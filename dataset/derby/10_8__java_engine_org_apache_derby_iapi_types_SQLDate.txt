1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.SQLDate
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
8:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.db.DatabaseContext;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369:  
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
1:eac0369: import java.sql.Date;
1:eac0369: import java.sql.Timestamp;
1:e21adc5: import java.sql.PreparedStatement;
1:eac0369: 
1:eac0369: import java.util.Calendar;
1:eac0369: import java.util.GregorianCalendar;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.SQLException;
1:eac0369: 
1:eac0369: import java.text.DateFormat;
1:eac0369: import java.text.ParseException;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * This contains an instance of a SQL Date.
1:eac0369:  * <p>
1:dbed020:  * The date is stored as int (year &lt;&lt; 16 + month &lt;&lt; 8 + day)
1:eac0369:  * Null is represented by an encodedDate value of 0.
1:eac0369:  * Some of the static methods in this class are also used by SQLTime and SQLTimestamp
1:eac0369:  * so check those classes if you change the date encoding
1:eac0369:  *
1:eac0369:  * PERFORMANCE OPTIMIZATION:
1:eac0369:  * The java.sql.Date object is only instantiated when needed
1:eac0369:  * do to the overhead of Date.valueOf(), etc. methods.
1:eac0369:  */
1:eac0369: 
1:eac0369: public final class SQLDate extends DataType
1:eac0369: 						implements DateTimeDataValue
8:eac0369: {
1:eac0369: 
1:eac0369: 	private int	encodedDate;	//year << 16 + month << 8 + day
1:eac0369: 
1:eac0369:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLDate.class);
1:eac0369: 
1:eac0369:     public int estimateMemoryUsage()
1:eac0369:     {
1:eac24d2:         return BASE_MEMORY_USAGE;
1:eac0369:     } // end of estimateMemoryUsage
1:eac0369: 
1:eac0369:     int getEncodedDate()
1:eac0369:     {
1:eac0369:         return encodedDate;
6:eac0369:     }
1:eac0369:     
1:eac0369: 	/*
1:eac0369: 	** DataValueDescriptor interface
1:eac0369: 	** (mostly implemented in DataType)
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public String getString()
1:eac0369: 	{
1:eac0369: 		//format is [yyy]y-mm-dd e.g. 1-01-01, 9999-99-99
1:eac0369: 		if (!isNull())
1:eac0369: 		{
1:eac24d2: 			return encodedDateToString(encodedDate);
1:eac0369: 		}
3:eac0369: 		else
1:eac0369: 		{
2:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:a57602b: 
1:eac0369: 	/**
1:eac0369: 		getTimestamp returns a timestamp with the date value 
1:eac0369: 		time is set to 00:00:00.0
1:eac0369: 	*/
1:eac0369: 	public Timestamp getTimestamp( Calendar cal) 
1:eac0369: 	{
2:eac0369: 		if (isNull())
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369:         
1:a57602b:         return new Timestamp(getTimeInMillis(cal));
1:eac0369:     }
1:eac0369: 
1:a57602b:     /**
1:a57602b:      * Convert the date into a milli-seconds since the epoch
1:a57602b:      * with the time set to 00:00 based upon the passed in Calendar.
1:a57602b:      */
1:a57602b:     private long getTimeInMillis(Calendar cal)
1:eac0369:     {
1:eac0369:         if( cal == null)
1:eac0369:             cal = new GregorianCalendar();
1:eac0369:         cal.clear();
1:a57602b:         
1:a57602b:         SQLDate.setDateInCalendar(cal, encodedDate);
1:a57602b:         
1:a57602b:         return cal.getTimeInMillis();
1:eac0369:     }
1:eac0369:     
1:a57602b:     /**
1:a57602b:      * Set the date portion of a date-time value into
1:a57602b:      * the passed in Calendar object from its encodedDate
1:a57602b:      * value. Only the YEAR, MONTH and DAY_OF_MONTH
1:a57602b:      * fields are modified. The remaining
1:a57602b:      * state of the Calendar is not modified.
1:a57602b:      */
1:a57602b:     static void setDateInCalendar(Calendar cal, int encodedDate)
1:eac0369:     {
1:a57602b:         // Note Calendar uses 0 for January, Derby uses 1.
1:a57602b:         cal.set(getYear(encodedDate),
1:a57602b:                 getMonth(encodedDate)-1, getDay(encodedDate));     
1:a57602b:     }
1:a57602b:     
1:eac0369: 	/**
1:eac0369: 		getObject returns the date value
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	public Object getObject()
1:eac0369: 	{
1:eac0369: 		return getDate( (Calendar) null);
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	public int getLength()
1:eac0369: 	{
1:eac0369: 		return 4;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* this is for DataType's error generator */
1:eac0369: 	public String getTypeName()
1:eac0369: 	{
1:eac0369: 		return "DATE";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.SQL_DATE_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 		@exception IOException error writing data
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException {
1:eac0369: 
8:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
1:eac0369: 
1:eac0369: 		out.writeInt(encodedDate);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see java.io.Externalizable#readExternal
1:eac0369: 	 *
1:eac0369: 	 * @exception IOException	Thrown on error reading the object
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in) throws IOException
1:eac0369: 	{
2:eac0369: 		encodedDate = in.readInt();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:854dd10: 	/** @see DataValueDescriptor#cloneValue */
1:854dd10: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
1:eac0369: 	{
1:eac0369: 		// Call constructor with all of our info
1:eac0369: 		return new SQLDate(encodedDate);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#getNewNull
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getNewNull()
1:eac0369: 	{
1:eac0369: 		return new SQLDate();
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void restoreToNull()
1:eac0369: 	{
1:eac0369: 		// clear encodedDate
1:eac0369: 		encodedDate = 0;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#setValueFromResultSet 
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1:eac0369: 									  boolean isNullable)
1:eac0369: 		throws SQLException, StandardException
1:eac0369: 	{
1:eac0369:         setValue(resultSet.getDate(colNumber), (Calendar) null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Orderable interface
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @see org.apache.derby.iapi.types.Orderable
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public int compare(DataValueDescriptor other)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Use compare method from dominant type, negating result
1:eac0369: 		 * to reflect flipping of sides.
1:eac0369: 		 */
1:eac0369: 		if (typePrecedence() < other.typePrecedence())
1:eac0369: 		{
1:eac0369: 			return - (other.compare(this));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		boolean thisNull, otherNull;
1:eac0369: 
1:eac0369: 		thisNull = this.isNull();
1:eac0369: 		otherNull = other.isNull();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * thisNull otherNull	return
1:eac0369: 		 *	T		T		 	0	(this == other)
1:eac0369: 		 *	F		T		 	-1 	(this < other)
1:eac0369: 		 *	T		F		 	1	(this > other)
1:eac0369: 		 */
1:eac0369: 		if (thisNull || otherNull)
1:eac0369: 		{
1:eac0369: 			if (!thisNull)		// otherNull must be true
1:eac0369: 				return -1;
1:eac0369: 			if (!otherNull)		// thisNull must be true
1:eac0369: 				return 1;
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 			Neither are null compare them 
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		int comparison;
1:eac0369: 		/* get the comparison date values */
1:eac0369: 		int otherVal = 0;
1:eac0369: 
1:eac0369: 		/* if the argument is another SQLDate
1:eac0369: 		 * get the encodedDate
1:eac0369: 		 */
1:eac0369: 		if (other instanceof SQLDate)
1:eac0369: 		{
1:eac0369: 			otherVal = ((SQLDate)other).encodedDate; 
1:eac0369: 		}
1:eac0369: 		else 
1:eac0369: 		{
1:eac0369: 			/* O.K. have to do it the hard way and calculate the numeric value
1:eac0369: 			 * from the value
1:eac0369: 			 */
1:eac0369: 			otherVal = SQLDate.computeEncodedDate(other.getDate(new GregorianCalendar()));
1:eac0369: 		}
1:eac0369: 		if (encodedDate > otherVal)
1:eac0369: 			comparison = 1;
1:eac0369: 		else if (encodedDate < otherVal)
1:eac0369: 			comparison = -1;
1:eac0369: 		else 
1:eac0369: 			comparison = 0;
1:eac0369: 
1:eac0369: 		return comparison;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean compare(int op,
1:eac0369: 						   DataValueDescriptor other,
1:eac0369: 						   boolean orderedNulls,
1:eac0369: 						   boolean unknownRV)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!orderedNulls)		// nulls are unordered
1:eac0369: 		{
1:eac0369: 			if (this.isNull() || other.isNull())
1:eac0369: 				return unknownRV;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Do the comparison */
1:eac0369: 		return super.compare(op, other, orderedNulls, unknownRV);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Class interface
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Constructors
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/** no-arg constructor required by Formattable */
1:eac0369: 	public SQLDate() {
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public SQLDate(Date value) throws StandardException
1:eac0369: 	{
1:eac0369: 		parseDate(value);
1:eac0369: 	}
1:eac0369:     
1:eac0369:     private void parseDate( java.util.Date value) throws StandardException
1:eac0369: 	{
1:eac0369: 		encodedDate = computeEncodedDate(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private SQLDate(int encodedDate) {
1:eac0369: 		this.encodedDate = encodedDate;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Construct a date from a string. The allowed date formats are:
1:eac0369:      *<ol>
1:eac0369:      *<li>ISO: yyyy-mm-dd
1:eac0369:      *<li>IBM USA standard: mm/dd/yyyy
1:eac0369:      *<li>IBM European standard: dd.mm.yyyy
1:eac0369:      *</ol>
1:eac0369:      * Trailing blanks may be included; leading zeros may be omitted from the month and day portions.
1:eac0369:      *
1:eac0369:      * @param dateStr
1:eac0369:      * @param isJdbcEscape if true then only the JDBC date escape syntax is allowed
1:eac0369:      * @param localeFinder
1:eac0369:      *
1:f668d94:      * @exception StandardException if the syntax is invalid or the value is
1:f668d94:      * out of range
1:eac0369:      */
1:eac0369:     public SQLDate( String dateStr, boolean isJdbcEscape, LocaleFinder localeFinder)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         parseDate( dateStr, isJdbcEscape, localeFinder, (Calendar) null);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Construct a date from a string. The allowed date formats are:
1:eac0369:      *<ol>
1:eac0369:      *<li>ISO: yyyy-mm-dd
1:eac0369:      *<li>IBM USA standard: mm/dd/yyyy
1:eac0369:      *<li>IBM European standard: dd.mm.yyyy
1:eac0369:      *</ol>
1:eac0369:      * Trailing blanks may be included; leading zeros may be omitted from the month and day portions.
1:eac0369:      *
1:eac0369:      * @param dateStr
1:eac0369:      * @param isJdbcEscape if true then only the JDBC date escape syntax is allowed
1:eac0369:      * @param localeFinder
1:eac0369:      *
1:f668d94:      * @exception StandardException if the syntax is invalid or the value is
1:f668d94:      * out of range
1:eac0369:      */
1:eac0369:     public SQLDate( String dateStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         parseDate( dateStr, isJdbcEscape, localeFinder, cal);
1:eac0369:     }
1:eac0369: 
1:eac0369:     static final char ISO_SEPARATOR = '-';
1:eac0369:     private static final char[] ISO_SEPARATOR_ONLY = {ISO_SEPARATOR};
1:eac0369:     private static final char IBM_USA_SEPARATOR = '/';
1:eac0369:     private static final char[] IBM_USA_SEPARATOR_ONLY = {IBM_USA_SEPARATOR};
1:eac0369:     private static final char IBM_EUR_SEPARATOR = '.';
1:eac0369:     private static final char[] IBM_EUR_SEPARATOR_ONLY = {IBM_EUR_SEPARATOR};
1:eac0369:     private static final char[] END_OF_STRING = {(char) 0};
1:eac0369:     
1:eac0369:     private void parseDate( String dateStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         boolean validSyntax = true;
1:eac0369:         DateTimeParser parser = new DateTimeParser( dateStr);
1:eac0369:         int year = 0;
1:eac0369:         int month = 0;
1:eac0369:         int day = 0;
1:eac0369:         StandardException thrownSE = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             switch( parser.nextSeparator())
1:eac0369:             {
1:eac0369:             case ISO_SEPARATOR:
1:eac0369:                 encodedDate = SQLTimestamp.parseDateOrTimestamp( parser, false)[0];
1:eac0369:                 return;
1:eac0369: 
1:eac0369:             case IBM_USA_SEPARATOR:
1:eac0369:                 if( isJdbcEscape)
1:eac0369:                 {
1:eac0369:                     validSyntax = false;
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369:                 month = parser.parseInt( 2, true, IBM_USA_SEPARATOR_ONLY, false);
1:eac0369:                 day = parser.parseInt( 2, true, IBM_USA_SEPARATOR_ONLY, false);
1:eac0369:                 year = parser.parseInt( 4, false, END_OF_STRING, false);
1:eac0369:                 break;
1:eac0369: 
1:eac0369:             case IBM_EUR_SEPARATOR:
1:eac0369:                 if( isJdbcEscape)
1:eac0369:                 {
1:eac0369:                     validSyntax = false;
1:eac0369:                     break;
1:eac0369:                 }
1:eac0369:                 day = parser.parseInt( 2, true, IBM_EUR_SEPARATOR_ONLY, false);
1:eac0369:                 month = parser.parseInt( 2, true, IBM_EUR_SEPARATOR_ONLY, false);
1:eac0369:                 year = parser.parseInt( 4, false, END_OF_STRING, false);
1:eac0369:                 break;
1:eac0369: 
1:eac0369:             default:
1:eac0369:                 validSyntax = false;
1:eac0369:             }
1:eac0369:         }
1:eac0369:         catch( StandardException se)
1:eac0369:         {
1:eac0369:             validSyntax = false;
1:eac0369:             thrownSE = se;
1:eac0369:         }
1:eac0369:         if( validSyntax)
1:eac0369:         {
1:eac0369:             encodedDate = computeEncodedDate( year, month, day);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // See if it is a localized date or timestamp.
1:eac0369:             dateStr = StringUtil.trimTrailing( dateStr);
1:eac0369:             DateFormat dateFormat = null;
1:eac0369:             if( localeFinder == null)
1:eac0369:                 dateFormat = DateFormat.getDateInstance();
1:eac0369:             else if( cal == null)
1:eac0369:                 dateFormat = localeFinder.getDateFormat();
1:eac0369:             else
1:eac0369:                 dateFormat = (DateFormat) localeFinder.getDateFormat().clone();
1:eac0369:             if( cal != null)
1:eac0369:                 dateFormat.setCalendar( cal);
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 encodedDate = computeEncodedDate( dateFormat.parse( dateStr), cal);
1:eac0369:             }
1:eac0369:             catch( ParseException pe)
1:eac0369:             {
1:eac0369:                 // Maybe it is a localized timestamp
1:eac0369:                 try
1:eac0369:                 {
1:eac0369:                     encodedDate = SQLTimestamp.parseLocalTimestamp( dateStr, localeFinder, cal)[0];
1:eac0369:                 }
1:eac0369:                 catch( ParseException pe2)
1:eac0369:                 {
1:eac0369:                     if( thrownSE != null)
1:eac0369:                         throw thrownSE;
1:eac0369:                     throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:     } // end of parseDate
1:eac0369: 
1:806114c: 	/**
1:806114c: 	 * Set the value from a correctly typed Date object.
1:806114c: 	 * @throws StandardException 
1:806114c: 	 */
1:806114c: 	void setObject(Object theValue) throws StandardException
1:eac0369: 	{
1:806114c: 		setValue((Date) theValue);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1:eac0369: 
1:eac0369: 		// Same format means same type SQLDate
1:eac0369: 		if (theValue instanceof SQLDate) {
1:eac0369: 			restoreToNull();
1:eac0369: 			encodedDate = ((SQLDate) theValue).encodedDate;
1:eac0369: 		}
1:eac0369:         else
1:eac0369:         {
1:eac0369:             Calendar cal = new GregorianCalendar();
1:eac0369: 			setValue(theValue.getDate( cal), cal);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see DateTimeDataValue#setValue
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	public void setValue(Date value, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		restoreToNull();
1:eac0369: 		encodedDate = computeEncodedDate((java.util.Date) value, cal);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@see DateTimeDataValue#setValue
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	public void setValue(Timestamp value, Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		restoreToNull();
1:eac0369: 		encodedDate = computeEncodedDate((java.util.Date) value, cal);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void setValue(String theValue)
1:eac0369: 	    throws StandardException
1:eac0369: 	{
1:eac0369: 		restoreToNull();
1:eac0369: 
1:eac0369: 		if (theValue != null)
1:eac0369: 		{
1:a0dbbd7:             DatabaseContext databaseContext = (DatabaseContext) DataValueFactoryImpl.getContext(DatabaseContext.CONTEXT_ID);
1:eac0369:             parseDate( theValue,
1:eac0369:                        false,
1:eac0369:                        (databaseContext == null) ? null : databaseContext.getDatabase(),
1:eac0369:                        (Calendar) null);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** SQL Operators
1:eac0369: 	*/
1:eac0369: 
1:985f758:     NumberDataValue nullValueInt() {
1:985f758:         return new SQLInteger();
1:eac0369:     }
1:eac0369: 
1:eac0369:     
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getYear
1:eac0369: 	 * 
2:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getYear(NumberDataValue result)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {    
1:eac0369:             return SQLDate.setSource(getYear(encodedDate), result);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getMonth
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getMonth(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {
1:eac0369:             return SQLDate.setSource(getMonth(encodedDate), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getDate
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getDate(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:985f758:         if (isNull()) {
1:985f758:             return nullValueInt();
1:985f758:         } else {
1:eac0369:             return SQLDate.setSource(getDay(encodedDate), result);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getHours
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getHours(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:eac0369: 						"getHours", "Date");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getMinutes
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getMinutes(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:eac0369: 						"getMinutes", "Date");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DateTimeDataValue#getSeconds
1:eac0369: 	 * 
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public NumberDataValue getSeconds(NumberDataValue result)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1:eac0369: 						"getSeconds", "Date");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** String display of value
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 		{
1:eac0369: 			return "NULL";
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return getDate( (Calendar) null).toString();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Hash code
1:eac0369: 	 */
1:eac0369: 	public int hashCode()
1:eac0369: 	{
1:eac0369: 		return encodedDate;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see DataValueDescriptor#typePrecedence */
1:eac0369: 	public int	typePrecedence()
1:eac0369: 	{
1:eac0369: 		return TypeId.DATE_PRECEDENCE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check if the value is null.  
1:eac0369: 	 * encodedDate is 0 if the value is null
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not value is logically null.
1:eac0369: 	 */
1:eac0369: 	public final boolean isNull()
1:eac0369: 	{
1:eac0369: 		return (encodedDate == 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the value field.  We instantiate the field
1:eac0369: 	 * on demand.
1:eac0369: 	 *
1:eac0369: 	 * @return	The value field.
1:eac0369: 	 */
1:eac0369: 	public Date getDate( Calendar cal)
1:eac0369: 	{
1:a57602b:         if (isNull())
1:a57602b:             return null;
1:a57602b:         
1:a57602b:         return new Date(getTimeInMillis(cal));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the year from the encodedDate.
1:eac0369: 	 *
1:eac0369: 	 * @param encodedDate	the encoded date
1:eac0369: 	 * @return	 			year value.
1:eac0369: 	 */
1:eac0369: 	static int getYear(int encodedDate)
1:eac0369: 	{
1:eac0369: 		return (encodedDate >>> 16);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:a57602b: 	 * Get the month from the encodedDate,
1:a57602b:      * January is one.
1:eac0369: 	 *
1:eac0369: 	 * @param encodedDate	the encoded date
1:eac0369: 	 * @return	 			month value.
1:eac0369: 	 */
1:eac0369: 	static int getMonth(int encodedDate)
1:eac0369: 	{
1:eac0369: 		return ((encodedDate >>> 8) & 0x00ff);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the day from the encodedDate.
1:eac0369: 	 *
1:eac0369: 	 * @param encodedDate	the encoded date
1:eac0369: 	 * @return	 			day value.
1:eac0369: 	 */
1:eac0369: 	static int getDay(int encodedDate)
1:eac0369: 	{
1:eac0369: 		return (encodedDate & 0x00ff);
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 	 *	computeEncodedDate extracts the year, month and date from
1:eac0369: 	 *	a Calendar value and encodes them as
1:dbed020: 	 *		year &lt;&lt; 16 + month &lt;&lt; 8 + date
1:eac0369: 	 *	Use this function will help to remember to add 1 to month
1:eac0369: 	 *  which is 0 based in the Calendar class
1:6b50965: 	 *	@param cal	the Calendar 
1:eac0369: 	 *	@return 		the encodedDate
1:eac0369:      *
1:eac0369:      *  @exception StandardException if the value is out of the DB2 date range
1:eac0369: 	 */
1:eac0369: 	static int computeEncodedDate(Calendar cal) throws StandardException
1:eac0369: 	{
1:eac0369: 		return computeEncodedDate(cal.get(Calendar.YEAR),
1:eac0369:                                   cal.get(Calendar.MONTH) + 1,
1:eac0369:                                   cal.get(Calendar.DATE));
1:eac0369: 	}
1:eac0369: 
1:eac0369:     static int computeEncodedDate( int y, int m, int d) throws StandardException
1:eac0369:     {
1:eac0369:         int maxDay = 31;
1:eac0369:         switch( m)
1:eac0369:         {
1:eac0369:         case 4:
1:eac0369:         case 6:
1:eac0369:         case 9:
1:eac0369:         case 11:
1:eac0369:             maxDay = 30;
1:eac0369:             break;
1:eac0369:                 
1:eac0369:         case 2:
1:eac0369:             // leap years are every 4 years except for century years not divisble by 400.
1:eac0369:             maxDay = ((y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0)) ? 29 : 28;
1:eac0369:             break;
1:eac0369:         }
1:eac0369:         if( y < 1 || y > 9999
1:eac0369:             || m < 1 || m > 12
1:eac0369:             || d < 1 || d > maxDay)
1:eac0369:             throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1:eac0369:         return (y << 16) + (m << 8) + d;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Convert a date to the JDBC representation and append it to a string buffer.
1:eac0369:      *
1:eac0369:      * @param year
1:eac0369:      * @param month 1 based (January == 1)
1:eac0369:      * @param day
1:eac0369:      * @param sb The string representation is appended to this StringBuffer
1:eac0369:      */
1:eac0369:     static void dateToString( int year, int month, int day, StringBuffer sb)
1:eac0369:     {
1:eac0369:         String yearStr = Integer.toString( year);
1:eac0369:         for( int i = yearStr.length(); i < 4; i++)
1:eac0369:             sb.append( '0');
1:eac0369: 		sb.append(yearStr);
1:eac0369: 		sb.append(ISO_SEPARATOR);
1:eac0369: 
1:eac0369: 		String monthStr = Integer.toString( month);
1:eac0369: 		String dayStr = Integer.toString( day);
1:eac0369: 		if (monthStr.length() == 1)
1:eac0369: 			sb.append('0');
1:eac0369: 		sb.append(monthStr);
1:eac0369: 		sb.append(ISO_SEPARATOR);
1:eac0369: 		if (dayStr.length() == 1)
1:eac0369: 			sb.append('0');
1:eac0369: 		sb.append(dayStr);
1:eac0369:     } // end of dateToString
1:eac0369:     
1:eac0369: 	/**
1:eac0369: 	 * Get the String version from the encodedDate.
1:eac0369: 	 *
1:eac0369: 	 * @return	 string value.
1:eac0369: 	 */
1:eac0369: 	static String encodedDateToString(int encodedDate)
1:eac0369: 	{
1:eac0369: 		StringBuffer vstr = new StringBuffer();
1:eac0369:         dateToString( getYear(encodedDate), getMonth(encodedDate), getDay(encodedDate), vstr);
1:eac0369: 		return vstr.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		This helper routine tests the nullability of various parameters
1:eac0369: 		and sets up the result appropriately.
1:eac0369: 
1:eac0369: 		If source is null, a new NumberDataValue is built. 
1:eac0369: 
1:eac0369: 		@exception StandardException	Thrown on error
1:eac0369: 	 */
1:eac0369: 	static NumberDataValue setSource(int value,
1:eac0369: 										NumberDataValue source)
1:eac0369: 									throws StandardException {
1:eac0369: 		/*
1:eac0369: 		** NOTE: Most extract operations return int, so the generation of
1:eac0369: 		** a SQLInteger is here.  Those extract operations that return
1:eac0369: 		** something other than int must allocate the source NumberDataValue
1:eac0369: 		** themselves, so that we do not allocate a SQLInteger here.
1:eac0369: 		*/
1:eac0369: 		if (source == null)
1:eac0369: 			source = new SQLInteger();
1:eac0369: 
1:eac0369: 		source.setValue(value);
1:eac0369: 
1:eac0369: 		return source;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369:      * Compute the encoded date given a date
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	private static int computeEncodedDate(java.util.Date value) throws StandardException
1:eac0369: 	{
1:eac0369:         return computeEncodedDate( value, null);
1:eac0369:     }
1:eac0369: 
1:eac0369:     static int computeEncodedDate(java.util.Date value, Calendar currentCal) throws StandardException
1:eac0369:     {
1:eac0369: 		if (value == null)
1:eac0369: 			return 0;			//encoded dates have a 0 value for null
1:eac0369:         if( currentCal == null)
1:eac0369:             currentCal = new GregorianCalendar();
1:eac0369: 		currentCal.setTime(value);
1:eac0369: 		return SQLDate.computeEncodedDate(currentCal);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:         /**
1:2dd0b6f:          * Implement the date SQL function: construct a SQL date from a string, number, or timestamp.
1:eac0369:          *
1:2dd0b6f:          * @param operand Must be a date or a string convertible to a date.
1:2dd0b6f:          * @param dvf the DataValueFactory
1:eac0369:          *
1:2dd0b6f:          * @exception StandardException standard error policy
1:eac0369:          */
1:2dd0b6f:     public static DateTimeDataValue computeDateFunction( DataValueDescriptor operand,
1:2dd0b6f:                                                          DataValueFactory dvf) throws StandardException
1:eac0369:     {
1:2dd0b6f:         try
1:eac0369:         {
1:2dd0b6f:             if( operand.isNull())
1:2dd0b6f:                 return new SQLDate();
1:2dd0b6f:             if( operand instanceof SQLDate)
1:854dd10:                 return (SQLDate) operand.cloneValue(false);
1:eac0369: 
1:2dd0b6f:             if( operand instanceof SQLTimestamp)
1:eac0369:             {
1:2dd0b6f:                 DateTimeDataValue retVal = new SQLDate();
1:2dd0b6f:                 retVal.setValue( operand);
1:2dd0b6f:                 return retVal;
1:eac0369:             }
1:2dd0b6f:             if( operand instanceof NumberDataValue)
1:eac0369:             {
1:2dd0b6f:                 int daysSinceEpoch = operand.getInt();
1:2dd0b6f:                 if( daysSinceEpoch <= 0 || daysSinceEpoch > 3652059)
1:2dd0b6f:                     throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:2dd0b6f:                                                           operand.getString(), "date");
1:2dd0b6f:                 Calendar cal = new GregorianCalendar( 1970, 0, 1, 12, 0, 0);
1:2dd0b6f:                 cal.add( Calendar.DATE, daysSinceEpoch - 1);
1:2dd0b6f:                 return new SQLDate( computeEncodedDate( cal.get( Calendar.YEAR),
1:2dd0b6f:                                                         cal.get( Calendar.MONTH) + 1,
1:2dd0b6f:                                                         cal.get( Calendar.DATE)));
1:eac0369:             }
1:2dd0b6f:             String str = operand.getString();
1:2dd0b6f:             if( str.length() == 7)
1:eac0369:             {
1:2dd0b6f:                 // yyyyddd where ddd is the day of the year
1:2dd0b6f:                 int year = SQLTimestamp.parseDateTimeInteger( str, 0, 4);
1:2dd0b6f:                 int dayOfYear = SQLTimestamp.parseDateTimeInteger( str, 4, 3);
1:2dd0b6f:                 if( dayOfYear < 1 || dayOfYear > 366)
1:2dd0b6f:                     throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:2dd0b6f:                                                           operand.getString(), "date");
1:2dd0b6f:                 Calendar cal = new GregorianCalendar( year, 0, 1, 2, 0, 0);
1:2dd0b6f:                 cal.add( Calendar.DAY_OF_YEAR, dayOfYear - 1);
1:2dd0b6f:                 int y = cal.get( Calendar.YEAR);
1:2dd0b6f:                 if( y != year)
1:2dd0b6f:                     throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:2dd0b6f:                                                           operand.getString(), "date");
1:2dd0b6f:                 return new SQLDate( computeEncodedDate( year,
1:2dd0b6f:                                                         cal.get( Calendar.MONTH) + 1,
1:2dd0b6f:                                                         cal.get( Calendar.DATE)));
1:eac0369:             }
1:2dd0b6f:             // Else use the standard cast.
1:2dd0b6f:             return dvf.getDateValue( str, false);
1:eac0369:         }
1:2dd0b6f:         catch( StandardException se)
1:eac0369:         {
1:2dd0b6f:             if( SQLState.LANG_DATE_SYNTAX_EXCEPTION.startsWith( se.getSQLState()))
1:2dd0b6f:                 throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:2dd0b6f:                                                       operand.getString(), "date");
1:2dd0b6f:             throw se;
1:eac0369:         }
1:2dd0b6f:     } // end of computeDateFunction
1:e21adc5: 
1:e21adc5:     /** Adding this method to ensure that super class' setInto method doesn't get called
1:e21adc5:       * that leads to the violation of JDBC spec( untyped nulls ) when batching is turned on.
1:e21adc5:       */     
1:e21adc5:     public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
1:e21adc5: 
1:e21adc5:                   ps.setDate(position, getDate((Calendar) null));
1:e21adc5:      }
1:e21adc5: 
1:eac0369: 
1:eac0369:     /**
1:d365a22:      * Add a number of intervals to a datetime value. Implements the JDBC escape TIMESTAMPADD function.
1:eac0369:      *
1:d365a22:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:d365a22:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:d365a22:      * @param intervalCount The number of intervals to add
1:d365a22:      * @param currentDate Used to convert time to timestamp
1:d365a22:      * @param resultHolder If non-null a DateTimeDataValue that can be used to hold the result. If null then
1:d365a22:      *                     generate a new holder
2:d365a22:      *
1:d365a22:      * @return startTime + intervalCount intervals, as a timestamp
1:d365a22:      *
1:d365a22:      * @exception StandardException
1:eac0369:      */
1:d365a22:     public DateTimeDataValue timestampAdd( int intervalType,
1:d365a22:                                            NumberDataValue intervalCount,
1:d365a22:                                            java.sql.Date currentDate,
1:d365a22:                                            DateTimeDataValue resultHolder)
1:985f758:         throws StandardException
1:eac0369:     {
1:d365a22:         return toTimestamp().timestampAdd( intervalType, intervalCount, currentDate, resultHolder);
1:eac0369:     }
1:eac0369: 
1:d365a22:     private SQLTimestamp toTimestamp() throws StandardException
1:eac0369:     {
1:d365a22:         return new SQLTimestamp( getEncodedDate(), 0, 0);
1:eac0369:     }
1:eac0369:     
2:d365a22:     /**
1:d365a22:      * Finds the difference between two datetime values as a number of intervals. Implements the JDBC
1:d365a22:      * TIMESTAMPDIFF escape function.
1:d365a22:      *
1:d365a22:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:d365a22:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:d365a22:      * @param time1
1:d365a22:      * @param currentDate Used to convert time to timestamp
1:d365a22:      * @param resultHolder If non-null a NumberDataValue that can be used to hold the result. If null then
1:d365a22:      *                     generate a new holder
1:d365a22:      *
1:d365a22:      * @return the number of intervals by which this datetime is greater than time1
1:d365a22:      *
1:d365a22:      * @exception StandardException
2:d365a22:      */
1:d365a22:     public NumberDataValue timestampDiff( int intervalType,
1:d365a22:                                           DateTimeDataValue time1,
1:d365a22:                                           java.sql.Date currentDate,
1:d365a22:                                           NumberDataValue resultHolder)
2:d365a22:         throws StandardException
1:eac0369:     {
1:d365a22:         return toTimestamp().timestampDiff( intervalType, time1, currentDate, resultHolder);
1:eac0369:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:  * The date is stored as int (year &lt;&lt; 16 + month &lt;&lt; 8 + day)
/////////////////////////////////////////////////////////////////////////
1: 	 *		year &lt;&lt; 16 + month &lt;&lt; 8 + date
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1:             DatabaseContext databaseContext = (DatabaseContext) DataValueFactoryImpl.getContext(DatabaseContext.CONTEXT_ID);
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException if the syntax is invalid or the value is
1:      * out of range
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException if the syntax is invalid or the value is
1:      * out of range
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:eac24d2
/////////////////////////////////////////////////////////////////////////
1:         return BASE_MEMORY_USAGE;
/////////////////////////////////////////////////////////////////////////
1: 			return encodedDateToString(encodedDate);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:79fec78
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:aff8c99
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1: 	/** @see DataValueDescriptor#cloneValue */
1: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
/////////////////////////////////////////////////////////////////////////
1:                 return (SQLDate) operand.cloneValue(false);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a57602b
/////////////////////////////////////////////////////////////////////////
1:         
1:         return new Timestamp(getTimeInMillis(cal));
1:     /**
1:      * Convert the date into a milli-seconds since the epoch
1:      * with the time set to 00:00 based upon the passed in Calendar.
1:      */
1:     private long getTimeInMillis(Calendar cal)
1:         
1:         SQLDate.setDateInCalendar(cal, encodedDate);
1:         
1:         return cal.getTimeInMillis();
1:     /**
1:      * Set the date portion of a date-time value into
1:      * the passed in Calendar object from its encodedDate
1:      * value. Only the YEAR, MONTH and DAY_OF_MONTH
1:      * fields are modified. The remaining
1:      * state of the Calendar is not modified.
1:      */
1:     static void setDateInCalendar(Calendar cal, int encodedDate)
1:         // Note Calendar uses 0 for January, Derby uses 1.
1:         cal.set(getYear(encodedDate),
1:                 getMonth(encodedDate)-1, getDay(encodedDate));     
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         if (isNull())
1:             return null;
1:         
1:         return new Date(getTimeInMillis(cal));
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the month from the encodedDate,
1:      * January is one.
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Set the value from a correctly typed Date object.
1: 	 * @throws StandardException 
1: 	 */
1: 	void setObject(Object theValue) throws StandardException
1: 		setValue((Date) theValue);
commit:e21adc5
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Adding this method to ensure that super class' setInto method doesn't get called
1:       * that leads to the violation of JDBC spec( untyped nulls ) when batching is turned on.
1:       */     
1:     public void setInto(PreparedStatement ps, int position) throws SQLException, StandardException {
1: 
1:                   ps.setDate(position, getDate((Calendar) null));
1:      }
1: 
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.SQLDate
1: 
0:    Copyright 2001, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
0: import org.apache.derby.iapi.types.SQLInteger;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.db.DatabaseContext;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.DateTimeDataValue;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: 
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:  
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.types.DataType;
1: 
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: import java.sql.Date;
0: import java.sql.Time;
1: import java.sql.Timestamp;
0: import java.sql.Types;
1: 
1: import java.util.Calendar;
1: import java.util.GregorianCalendar;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: 
1: import java.text.DateFormat;
1: import java.text.ParseException;
1: 
1: /**
1:  * This contains an instance of a SQL Date.
1:  * <p>
0:  * The date is stored as int (year << 16 + month << 8 + day)
1:  * Null is represented by an encodedDate value of 0.
1:  * Some of the static methods in this class are also used by SQLTime and SQLTimestamp
1:  * so check those classes if you change the date encoding
1:  *
1:  * PERFORMANCE OPTIMIZATION:
1:  * The java.sql.Date object is only instantiated when needed
1:  * do to the overhead of Date.valueOf(), etc. methods.
1:  */
1: 
1: public final class SQLDate extends DataType
1: 						implements DateTimeDataValue
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
1: 
1: 	private int	encodedDate;	//year << 16 + month << 8 + day
1: 
0: 	// The cached value.toString()
0: 	private String	valueString;
1: 
1:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLDate.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
0:         return BASE_MEMORY_USAGE + ClassSize.estimateMemoryUsage( valueString);
1:     } // end of estimateMemoryUsage
1: 
1:     int getEncodedDate()
1:     {
1:         return encodedDate;
1:     }
1:     
1: 	/*
1: 	** DataValueDescriptor interface
1: 	** (mostly implemented in DataType)
1: 	*/
1: 
1: 	public String getString()
1: 	{
1: 		//format is [yyy]y-mm-dd e.g. 1-01-01, 9999-99-99
1: 		if (!isNull())
1: 		{
0: 			if (valueString == null)
1: 			{
0: 				valueString = encodedDateToString(encodedDate);
1: 			}
0: 			return valueString;
1: 		}
1: 		else
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
0: 				if (valueString != null)
1: 				{
0: 					SanityManager.THROWASSERT(
0: 						"valueString expected to be null, not " +
0: 						valueString);
1: 				}
1: 			}
1: 			return null;
1: 		}
1: 	}
1: 
1: 	/**
1: 		getTimestamp returns a timestamp with the date value 
1: 		time is set to 00:00:00.0
1: 	*/
1: 	public Timestamp getTimestamp( Calendar cal) 
1: 	{
1: 		if (isNull())
1: 		{
1: 			return null;
1: 		}
1: 		else 
0: 			// date is converted to a timestamp filling the time in with 00:00:00
0:             return newTimestamp(cal);
1:     }
1: 
0:     private long getTimeInMillis( Calendar cal)
1:     {
1:         if( cal == null)
1:             cal = new GregorianCalendar();
1:         cal.clear();
0:         cal.set( getYear( encodedDate), getMonth( encodedDate)-1, getDay( encodedDate));
0:         return cal.getTime().getTime();
1:     }
1:     
0:     private Timestamp newTimestamp(java.util.Calendar cal)
1:     {
0:         return new Timestamp(getTimeInMillis( cal));
1: 	}
1: 
1: 	/**
1: 		getObject returns the date value
1: 
1: 	 */
1: 	public Object getObject()
1: 	{
1: 		return getDate( (Calendar) null);
1: 	}
1: 		
1: 	public int getLength()
1: 	{
1: 		return 4;
1: 	}
1: 
1: 	/* this is for DataType's error generator */
1: 	public String getTypeName()
1: 	{
1: 		return "DATE";
1: 	}
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.SQL_DATE_ID;
1: 	}
1: 
1: 	/** 
1: 		@exception IOException error writing data
1: 
1: 	*/
1: 	public void writeExternal(ObjectOutput out) throws IOException {
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
1: 
1: 		out.writeInt(encodedDate);
1: 	}
1: 
1: 	/**
1: 	 * @see java.io.Externalizable#readExternal
1: 	 *
1: 	 * @exception IOException	Thrown on error reading the object
1: 	 */
1: 	public void readExternal(ObjectInput in) throws IOException
1: 	{
1: 		encodedDate = in.readInt();
1: 
0: 		// reset cached string values
0: 		valueString = null;
1: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException
1: 	{
1: 		encodedDate = in.readInt();
1: 
0: 		// reset cached string values
0: 		valueString = null;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
1: 	{
1: 		// Call constructor with all of our info
1: 		return new SQLDate(encodedDate);
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#getNewNull
1: 	 */
1: 	public DataValueDescriptor getNewNull()
1: 	{
1: 		return new SQLDate();
1: 	}
1: 	/**
1: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
1: 	 *
1: 	 */
1: 
1: 	public void restoreToNull()
1: 	{
1: 		// clear encodedDate
1: 		encodedDate = 0;
1: 
0: 		// clear cached valueString
0: 		valueString = null;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#setValueFromResultSet 
1: 	 *
1: 	 * @exception SQLException		Thrown on error
1: 	 */
1: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1: 									  boolean isNullable)
1: 		throws SQLException, StandardException
1: 	{
1:         setValue(resultSet.getDate(colNumber), (Calendar) null);
1: 	}
1: 
1: 	/**
1: 	 * Orderable interface
1: 	 *
1: 	 *
1: 	 * @see org.apache.derby.iapi.types.Orderable
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public int compare(DataValueDescriptor other)
1: 		throws StandardException
1: 	{
1: 		/* Use compare method from dominant type, negating result
1: 		 * to reflect flipping of sides.
1: 		 */
1: 		if (typePrecedence() < other.typePrecedence())
1: 		{
1: 			return - (other.compare(this));
1: 		}
1: 
1: 
1: 		boolean thisNull, otherNull;
1: 
1: 		thisNull = this.isNull();
1: 		otherNull = other.isNull();
1: 
1: 		/*
1: 		 * thisNull otherNull	return
1: 		 *	T		T		 	0	(this == other)
1: 		 *	F		T		 	-1 	(this < other)
1: 		 *	T		F		 	1	(this > other)
1: 		 */
1: 		if (thisNull || otherNull)
1: 		{
1: 			if (!thisNull)		// otherNull must be true
1: 				return -1;
1: 			if (!otherNull)		// thisNull must be true
1: 				return 1;
1: 			return 0;
1: 		}
1: 
1: 		/*
1: 			Neither are null compare them 
1: 		 */
1: 
1: 		int comparison;
1: 		/* get the comparison date values */
1: 		int otherVal = 0;
1: 
1: 		/* if the argument is another SQLDate
1: 		 * get the encodedDate
1: 		 */
1: 		if (other instanceof SQLDate)
1: 		{
1: 			otherVal = ((SQLDate)other).encodedDate; 
1: 		}
1: 		else 
1: 		{
1: 			/* O.K. have to do it the hard way and calculate the numeric value
1: 			 * from the value
1: 			 */
1: 			otherVal = SQLDate.computeEncodedDate(other.getDate(new GregorianCalendar()));
1: 		}
1: 		if (encodedDate > otherVal)
1: 			comparison = 1;
1: 		else if (encodedDate < otherVal)
1: 			comparison = -1;
1: 		else 
1: 			comparison = 0;
1: 
1: 		return comparison;
1: 	}
1: 
1: 	/**
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean unknownRV)
1: 		throws StandardException
1: 	{
1: 		if (!orderedNulls)		// nulls are unordered
1: 		{
1: 			if (this.isNull() || other.isNull())
1: 				return unknownRV;
1: 		}
1: 
1: 		/* Do the comparison */
1: 		return super.compare(op, other, orderedNulls, unknownRV);
1: 	}
1: 
1: 	/*
1: 	** Class interface
1: 	*/
1: 
1: 	/*
1: 	** Constructors
1: 	*/
1: 
1: 	/** no-arg constructor required by Formattable */
1: 	public SQLDate() {
1: 	}
1: 
1: 	public SQLDate(Date value) throws StandardException
1: 	{
1: 		parseDate(value);
1: 	}
1: 
1:     private void parseDate( java.util.Date value) throws StandardException
1: 	{
1: 		encodedDate = computeEncodedDate(value);
1: 	}
1: 
1: 	private SQLDate(int encodedDate) {
1: 		this.encodedDate = encodedDate;
1: 	}
1: 
1:     /**
1:      * Construct a date from a string. The allowed date formats are:
1:      *<ol>
1:      *<li>ISO: yyyy-mm-dd
1:      *<li>IBM USA standard: mm/dd/yyyy
1:      *<li>IBM European standard: dd.mm.yyyy
1:      *</ol>
1:      * Trailing blanks may be included; leading zeros may be omitted from the month and day portions.
1:      *
1:      * @param dateStr
1:      * @param isJdbcEscape if true then only the JDBC date escape syntax is allowed
1:      * @param localeFinder
1:      *
0:      * @return the internal DataValueDescriptor for the value
1:      *
0:      * @exception Standard exception if the syntax is invalid or the value is out of range.
1:      */
1:     public SQLDate( String dateStr, boolean isJdbcEscape, LocaleFinder localeFinder)
1:         throws StandardException
1:     {
1:         parseDate( dateStr, isJdbcEscape, localeFinder, (Calendar) null);
1:     }
1: 
1:     /**
1:      * Construct a date from a string. The allowed date formats are:
1:      *<ol>
1:      *<li>ISO: yyyy-mm-dd
1:      *<li>IBM USA standard: mm/dd/yyyy
1:      *<li>IBM European standard: dd.mm.yyyy
1:      *</ol>
1:      * Trailing blanks may be included; leading zeros may be omitted from the month and day portions.
1:      *
1:      * @param dateStr
1:      * @param isJdbcEscape if true then only the JDBC date escape syntax is allowed
1:      * @param localeFinder
1:      *
0:      * @return the internal DataValueDescriptor for the value
1:      *
0:      * @exception Standard exception if the syntax is invalid or the value is out of range.
1:      */
1:     public SQLDate( String dateStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
1:         throws StandardException
1:     {
1:         parseDate( dateStr, isJdbcEscape, localeFinder, cal);
1:     }
1: 
1:     static final char ISO_SEPARATOR = '-';
1:     private static final char[] ISO_SEPARATOR_ONLY = {ISO_SEPARATOR};
1:     private static final char IBM_USA_SEPARATOR = '/';
1:     private static final char[] IBM_USA_SEPARATOR_ONLY = {IBM_USA_SEPARATOR};
1:     private static final char IBM_EUR_SEPARATOR = '.';
1:     private static final char[] IBM_EUR_SEPARATOR_ONLY = {IBM_EUR_SEPARATOR};
1:     private static final char[] END_OF_STRING = {(char) 0};
1:     
1:     private void parseDate( String dateStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
1:         throws StandardException
1:     {
1:         boolean validSyntax = true;
1:         DateTimeParser parser = new DateTimeParser( dateStr);
1:         int year = 0;
1:         int month = 0;
1:         int day = 0;
1:         StandardException thrownSE = null;
1: 
1:         try
1:         {
1:             switch( parser.nextSeparator())
1:             {
1:             case ISO_SEPARATOR:
1:                 encodedDate = SQLTimestamp.parseDateOrTimestamp( parser, false)[0];
0:                 valueString = parser.getTrimmedString();
1:                 return;
1: 
1:             case IBM_USA_SEPARATOR:
1:                 if( isJdbcEscape)
1:                 {
1:                     validSyntax = false;
1:                     break;
1:                 }
1:                 month = parser.parseInt( 2, true, IBM_USA_SEPARATOR_ONLY, false);
1:                 day = parser.parseInt( 2, true, IBM_USA_SEPARATOR_ONLY, false);
1:                 year = parser.parseInt( 4, false, END_OF_STRING, false);
1:                 break;
1: 
1:             case IBM_EUR_SEPARATOR:
1:                 if( isJdbcEscape)
1:                 {
1:                     validSyntax = false;
1:                     break;
1:                 }
1:                 day = parser.parseInt( 2, true, IBM_EUR_SEPARATOR_ONLY, false);
1:                 month = parser.parseInt( 2, true, IBM_EUR_SEPARATOR_ONLY, false);
1:                 year = parser.parseInt( 4, false, END_OF_STRING, false);
1:                 break;
1: 
1:             default:
1:                 validSyntax = false;
1:             }
1:         }
1:         catch( StandardException se)
1:         {
1:             validSyntax = false;
1:             thrownSE = se;
1:         }
1:         if( validSyntax)
1:         {
0:             valueString = parser.checkEnd();
1:             encodedDate = computeEncodedDate( year, month, day);
1:         }
1:         else
1:         {
1:             // See if it is a localized date or timestamp.
1:             dateStr = StringUtil.trimTrailing( dateStr);
1:             DateFormat dateFormat = null;
1:             if( localeFinder == null)
1:                 dateFormat = DateFormat.getDateInstance();
1:             else if( cal == null)
1:                 dateFormat = localeFinder.getDateFormat();
1:             else
1:                 dateFormat = (DateFormat) localeFinder.getDateFormat().clone();
1:             if( cal != null)
1:                 dateFormat.setCalendar( cal);
1:             try
1:             {
1:                 encodedDate = computeEncodedDate( dateFormat.parse( dateStr), cal);
1:             }
1:             catch( ParseException pe)
1:             {
1:                 // Maybe it is a localized timestamp
1:                 try
1:                 {
1:                     encodedDate = SQLTimestamp.parseLocalTimestamp( dateStr, localeFinder, cal)[0];
1:                 }
1:                 catch( ParseException pe2)
1:                 {
1:                     if( thrownSE != null)
1:                         throw thrownSE;
1:                     throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
1:                 }
1:             }
0:             valueString = dateStr;
1:         }
1:     } // end of parseDate
1: 
0: 	public void setValue(Object theValue) throws StandardException
1: 	{
0: 		if (theValue == null)
1: 		{
0: 			setToNull();
1: 		}
0: 		else if (theValue instanceof Date)
1: 		{
0: 			setValue((Date)theValue, (Calendar) null);
1: 		}
0: 		else if (theValue instanceof Timestamp)
1: 		{
0: 			setValue((Timestamp)theValue, (Calendar) null);
1: 		}
1: 		else
1: 		{
0: 			genericSetObject(theValue);
1: 		}
1: 
1: 	}
1: 
1: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1: 
1: 		// Same format means same type SQLDate
1: 		if (theValue instanceof SQLDate) {
1: 			restoreToNull();
1: 			encodedDate = ((SQLDate) theValue).encodedDate;
1: 		}
1:         else
1:         {
1:             Calendar cal = new GregorianCalendar();
1: 			setValue(theValue.getDate( cal), cal);
1:         }
1: 	}
1: 
1: 	/**
1: 		@see DateTimeDataValue#setValue
1: 
1: 	 */
1: 	public void setValue(Date value, Calendar cal) throws StandardException
1: 	{
1: 		restoreToNull();
1: 		encodedDate = computeEncodedDate((java.util.Date) value, cal);
1: 	}
1: 
1: 	/**
1: 		@see DateTimeDataValue#setValue
1: 
1: 	 */
1: 	public void setValue(Timestamp value, Calendar cal) throws StandardException
1: 	{
1: 		restoreToNull();
1: 		encodedDate = computeEncodedDate((java.util.Date) value, cal);
1: 	}
1: 
1: 
1: 	public void setValue(String theValue)
1: 	    throws StandardException
1: 	{
1: 		restoreToNull();
1: 
1: 		if (theValue != null)
1: 		{
0:             DatabaseContext databaseContext = (DatabaseContext) ContextService.getContext(DatabaseContext.CONTEXT_ID);
1:             parseDate( theValue,
1:                        false,
1:                        (databaseContext == null) ? null : databaseContext.getDatabase(),
1:                        (Calendar) null);
1:         }
1: 	}
1: 
1: 	/*
1: 	** SQL Operators
1: 	*/
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getYear
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getYear(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getYear called on a null");
1: 		}
1: 		return SQLDate.setSource(getYear(encodedDate), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getMonth
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getMonth(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMonth called on a null");
1: 		}
1: 		return SQLDate.setSource(getMonth(encodedDate), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getDate
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getDate(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getDate called on a null");
1: 		}
1: 		return SQLDate.setSource(getDay(encodedDate), result);
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getHours
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getHours(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getHours called on null.");
1: 		}
1: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1: 						"getHours", "Date");
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getMinutes
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getMinutes(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMinutes called on null.");
1: 		}
1: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1: 						"getMinutes", "Date");
1: 	}
1: 
1: 	/**
1: 	 * @see DateTimeDataValue#getSeconds
1: 	 * 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public NumberDataValue getSeconds(NumberDataValue result)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(!isNull(), "getSeconds called on null.");
1: 		}
1: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
1: 						"getSeconds", "Date");
1: 	}
1: 
1: 	/*
1: 	** String display of value
1: 	*/
1: 
1: 	public String toString()
1: 	{
1: 		if (isNull())
1: 		{
1: 			return "NULL";
1: 		}
1: 		else
1: 		{
1: 			return getDate( (Calendar) null).toString();
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * Hash code
1: 	 */
1: 	public int hashCode()
1: 	{
1: 		return encodedDate;
1: 	}
1: 
1: 	/** @see DataValueDescriptor#typePrecedence */
1: 	public int	typePrecedence()
1: 	{
1: 		return TypeId.DATE_PRECEDENCE;
1: 	}
1: 
1: 	/**
1: 	 * Check if the value is null.  
1: 	 * encodedDate is 0 if the value is null
1: 	 *
1: 	 * @return Whether or not value is logically null.
1: 	 */
1: 	public final boolean isNull()
1: 	{
1: 		return (encodedDate == 0);
1: 	}
1: 
1: 	/**
1: 	 * Get the value field.  We instantiate the field
1: 	 * on demand.
1: 	 *
1: 	 * @return	The value field.
1: 	 */
1: 	public Date getDate( Calendar cal)
1: 	{
0: 		if (encodedDate != 0)
0:             return new Date( getTimeInMillis( cal));
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Get the year from the encodedDate.
1: 	 *
1: 	 * @param encodedDate	the encoded date
1: 	 * @return	 			year value.
1: 	 */
1: 	static int getYear(int encodedDate)
1: 	{
1: 		return (encodedDate >>> 16);
1: 	}
1: 
1: 	/**
0: 	 * Get the month from the encodedDate.
1: 	 *
1: 	 * @param encodedDate	the encoded date
1: 	 * @return	 			month value.
1: 	 */
1: 	static int getMonth(int encodedDate)
1: 	{
1: 		return ((encodedDate >>> 8) & 0x00ff);
1: 	}
1: 
1: 	/**
1: 	 * Get the day from the encodedDate.
1: 	 *
1: 	 * @param encodedDate	the encoded date
1: 	 * @return	 			day value.
1: 	 */
1: 	static int getDay(int encodedDate)
1: 	{
1: 		return (encodedDate & 0x00ff);
1: 	}
1: 	/**
1: 	 *	computeEncodedDate extracts the year, month and date from
1: 	 *	a Calendar value and encodes them as
0: 	 *		year << 16 + month << 8 + date
1: 	 *	Use this function will help to remember to add 1 to month
1: 	 *  which is 0 based in the Calendar class
0: 	 *	@param value	the Calendar 
1: 	 *	@return 		the encodedDate
1:      *
1:      *  @exception StandardException if the value is out of the DB2 date range
1: 	 */
1: 	static int computeEncodedDate(Calendar cal) throws StandardException
1: 	{
1: 		return computeEncodedDate(cal.get(Calendar.YEAR),
1:                                   cal.get(Calendar.MONTH) + 1,
1:                                   cal.get(Calendar.DATE));
1: 	}
1: 
1:     static int computeEncodedDate( int y, int m, int d) throws StandardException
1:     {
1:         int maxDay = 31;
1:         switch( m)
1:         {
1:         case 4:
1:         case 6:
1:         case 9:
1:         case 11:
1:             maxDay = 30;
1:             break;
1:                 
1:         case 2:
1:             // leap years are every 4 years except for century years not divisble by 400.
1:             maxDay = ((y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0)) ? 29 : 28;
1:             break;
1:         }
1:         if( y < 1 || y > 9999
1:             || m < 1 || m > 12
1:             || d < 1 || d > maxDay)
1:             throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
1:         return (y << 16) + (m << 8) + d;
1:     }
1: 
1:     /**
1:      * Convert a date to the JDBC representation and append it to a string buffer.
1:      *
1:      * @param year
1:      * @param month 1 based (January == 1)
1:      * @param day
1:      * @param sb The string representation is appended to this StringBuffer
1:      */
1:     static void dateToString( int year, int month, int day, StringBuffer sb)
1:     {
1:         String yearStr = Integer.toString( year);
1:         for( int i = yearStr.length(); i < 4; i++)
1:             sb.append( '0');
1: 		sb.append(yearStr);
1: 		sb.append(ISO_SEPARATOR);
1: 
1: 		String monthStr = Integer.toString( month);
1: 		String dayStr = Integer.toString( day);
1: 		if (monthStr.length() == 1)
1: 			sb.append('0');
1: 		sb.append(monthStr);
1: 		sb.append(ISO_SEPARATOR);
1: 		if (dayStr.length() == 1)
1: 			sb.append('0');
1: 		sb.append(dayStr);
1:     } // end of dateToString
1:     
1: 	/**
1: 	 * Get the String version from the encodedDate.
1: 	 *
1: 	 * @return	 string value.
1: 	 */
1: 	static String encodedDateToString(int encodedDate)
1: 	{
1: 		StringBuffer vstr = new StringBuffer();
1:         dateToString( getYear(encodedDate), getMonth(encodedDate), getDay(encodedDate), vstr);
1: 		return vstr.toString();
1: 	}
1: 
0: 	// International Support
1: 
1: 	/**
0: 	 * International version of getString(). Overrides getNationalString
0: 	 * in DataType for date, time, and timestamp.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected String getNationalString(LocaleFinder localeFinder) throws StandardException
1: 	{
1: 		if (isNull())
1: 		{
0: 			return getString();
1: 		}
1: 
0: 		return localeFinder.getDateFormat().format(getDate(new GregorianCalendar()));
1: 	}
1: 
1: 	/**
1: 		This helper routine tests the nullability of various parameters
1: 		and sets up the result appropriately.
1: 
1: 		If source is null, a new NumberDataValue is built. 
1: 
1: 		@exception StandardException	Thrown on error
1: 	 */
1: 	static NumberDataValue setSource(int value,
1: 										NumberDataValue source)
1: 									throws StandardException {
1: 		/*
1: 		** NOTE: Most extract operations return int, so the generation of
1: 		** a SQLInteger is here.  Those extract operations that return
1: 		** something other than int must allocate the source NumberDataValue
1: 		** themselves, so that we do not allocate a SQLInteger here.
1: 		*/
1: 		if (source == null)
1: 			source = new SQLInteger();
1: 
1: 		source.setValue(value);
1: 
1: 		return source;
1: 	}
1: 	/**
1:      * Compute the encoded date given a date
1: 	 *
1: 	 */
1: 	private static int computeEncodedDate(java.util.Date value) throws StandardException
1: 	{
1:         return computeEncodedDate( value, null);
1:     }
1: 
1:     static int computeEncodedDate(java.util.Date value, Calendar currentCal) throws StandardException
1:     {
1: 		if (value == null)
1: 			return 0;			//encoded dates have a 0 value for null
1:         if( currentCal == null)
1:             currentCal = new GregorianCalendar();
1: 		currentCal.setTime(value);
1: 		return SQLDate.computeEncodedDate(currentCal);
1: 	}
1: }
1: 
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:985f758
/////////////////////////////////////////////////////////////////////////
1:     NumberDataValue nullValueInt() {
1:         return new SQLInteger();
0:     }
0: 
0:     
1:         throws StandardException
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {    
0:             return SQLDate.setSource(getYear(encodedDate), result);
0:         }
0:     }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {
0:             return SQLDate.setSource(getMonth(encodedDate), result);
0:         }
/////////////////////////////////////////////////////////////////////////
1:         if (isNull()) {
1:             return nullValueInt();
1:         } else {
0:             return SQLDate.setSource(getDay(encodedDate), result);
0:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 *	@param cal	the Calendar 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d365a22
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Add a number of intervals to a datetime value. Implements the JDBC escape TIMESTAMPADD function.
1:      *
1:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:      * @param intervalCount The number of intervals to add
1:      * @param currentDate Used to convert time to timestamp
1:      * @param resultHolder If non-null a DateTimeDataValue that can be used to hold the result. If null then
1:      *                     generate a new holder
1:      *
1:      * @return startTime + intervalCount intervals, as a timestamp
1:      *
1:      * @exception StandardException
1:      */
1:     public DateTimeDataValue timestampAdd( int intervalType,
1:                                            NumberDataValue intervalCount,
1:                                            java.sql.Date currentDate,
1:                                            DateTimeDataValue resultHolder)
1:         throws StandardException
0:     {
1:         return toTimestamp().timestampAdd( intervalType, intervalCount, currentDate, resultHolder);
0:     }
0: 
1:     private SQLTimestamp toTimestamp() throws StandardException
0:     {
1:         return new SQLTimestamp( getEncodedDate(), 0, 0);
0:     }
0:     
1:     /**
1:      * Finds the difference between two datetime values as a number of intervals. Implements the JDBC
1:      * TIMESTAMPDIFF escape function.
1:      *
1:      * @param intervalType One of FRAC_SECOND_INTERVAL, SECOND_INTERVAL, MINUTE_INTERVAL, HOUR_INTERVAL,
1:      *                     DAY_INTERVAL, WEEK_INTERVAL, MONTH_INTERVAL, QUARTER_INTERVAL, or YEAR_INTERVAL
1:      * @param time1
1:      * @param currentDate Used to convert time to timestamp
1:      * @param resultHolder If non-null a NumberDataValue that can be used to hold the result. If null then
1:      *                     generate a new holder
1:      *
1:      * @return the number of intervals by which this datetime is greater than time1
1:      *
1:      * @exception StandardException
1:      */
1:     public NumberDataValue timestampDiff( int intervalType,
1:                                           DateTimeDataValue time1,
1:                                           java.sql.Date currentDate,
1:                                           NumberDataValue resultHolder)
1:         throws StandardException
0:     {
1:         return toTimestamp().timestampDiff( intervalType, time1, currentDate, resultHolder);
0:     }
commit:2dd0b6f
/////////////////////////////////////////////////////////////////////////
0:     
/////////////////////////////////////////////////////////////////////////
0: 
0:         /**
1:          * Implement the date SQL function: construct a SQL date from a string, number, or timestamp.
0:          *
1:          * @param operand Must be a date or a string convertible to a date.
1:          * @param dvf the DataValueFactory
0:          *
1:          * @exception StandardException standard error policy
0:          */
1:     public static DateTimeDataValue computeDateFunction( DataValueDescriptor operand,
1:                                                          DataValueFactory dvf) throws StandardException
0:     {
1:         try
0:         {
1:             if( operand.isNull())
1:                 return new SQLDate();
1:             if( operand instanceof SQLDate)
0:                 return (SQLDate) operand.getClone();
0: 
1:             if( operand instanceof SQLTimestamp)
0:             {
1:                 DateTimeDataValue retVal = new SQLDate();
1:                 retVal.setValue( operand);
1:                 return retVal;
0:             }
1:             if( operand instanceof NumberDataValue)
0:             {
1:                 int daysSinceEpoch = operand.getInt();
1:                 if( daysSinceEpoch <= 0 || daysSinceEpoch > 3652059)
1:                     throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:                                                           operand.getString(), "date");
1:                 Calendar cal = new GregorianCalendar( 1970, 0, 1, 12, 0, 0);
1:                 cal.add( Calendar.DATE, daysSinceEpoch - 1);
1:                 return new SQLDate( computeEncodedDate( cal.get( Calendar.YEAR),
1:                                                         cal.get( Calendar.MONTH) + 1,
1:                                                         cal.get( Calendar.DATE)));
0:             }
1:             String str = operand.getString();
1:             if( str.length() == 7)
0:             {
1:                 // yyyyddd where ddd is the day of the year
1:                 int year = SQLTimestamp.parseDateTimeInteger( str, 0, 4);
1:                 int dayOfYear = SQLTimestamp.parseDateTimeInteger( str, 4, 3);
1:                 if( dayOfYear < 1 || dayOfYear > 366)
1:                     throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:                                                           operand.getString(), "date");
1:                 Calendar cal = new GregorianCalendar( year, 0, 1, 2, 0, 0);
1:                 cal.add( Calendar.DAY_OF_YEAR, dayOfYear - 1);
1:                 int y = cal.get( Calendar.YEAR);
1:                 if( y != year)
1:                     throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:                                                           operand.getString(), "date");
1:                 return new SQLDate( computeEncodedDate( year,
1:                                                         cal.get( Calendar.MONTH) + 1,
1:                                                         cal.get( Calendar.DATE)));
0:             }
1:             // Else use the standard cast.
1:             return dvf.getDateValue( str, false);
0:         }
1:         catch( StandardException se)
0:         {
1:             if( SQLState.LANG_DATE_SYNTAX_EXCEPTION.startsWith( se.getSQLState()))
1:                 throw StandardException.newException( SQLState.LANG_INVALID_FUNCTION_ARGUMENT,
1:                                                       operand.getString(), "date");
1:             throw se;
0:         }
1:     } // end of computeDateFunction
0: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 2001, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.types.SQLInteger;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.db.DatabaseContext;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.DateTimeDataValue;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0:  
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.DataType;
0: 
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: 
0: import java.util.Calendar;
0: import java.util.GregorianCalendar;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: 
0: import java.text.DateFormat;
0: import java.text.ParseException;
0: 
0: /**
0:  * This contains an instance of a SQL Date.
0:  * <p>
0:  * The date is stored as int (year << 16 + month << 8 + day)
0:  * Null is represented by an encodedDate value of 0.
0:  * Some of the static methods in this class are also used by SQLTime and SQLTimestamp
0:  * so check those classes if you change the date encoding
0:  *
0:  * PERFORMANCE OPTIMIZATION:
0:  * The java.sql.Date object is only instantiated when needed
0:  * do to the overhead of Date.valueOf(), etc. methods.
0:  */
0: 
0: public final class SQLDate extends DataType
0: 						implements DateTimeDataValue
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2001_2004;
0: 
0: 	private int	encodedDate;	//year << 16 + month << 8 + day
0: 
0: 	// The cached value.toString()
0: 	private String	valueString;
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLDate.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         return BASE_MEMORY_USAGE + ClassSize.estimateMemoryUsage( valueString);
0:     } // end of estimateMemoryUsage
0: 
0:     int getEncodedDate()
0:     {
0:         return encodedDate;
0:     }
0:     
0: 	/*
0: 	** DataValueDescriptor interface
0: 	** (mostly implemented in DataType)
0: 	*/
0: 
0: 	public String getString()
0: 	{
0: 		//format is [yyy]y-mm-dd e.g. 1-01-01, 9999-99-99
0: 		if (!isNull())
0: 		{
0: 			if (valueString == null)
0: 			{
0: 				valueString = encodedDateToString(encodedDate);
0: 			}
0: 			return valueString;
0: 		}
0: 		else
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				if (valueString != null)
0: 				{
0: 					SanityManager.THROWASSERT(
0: 						"valueString expected to be null, not " +
0: 						valueString);
0: 				}
0: 			}
0: 			return null;
0: 		}
0: 	}
0: 
0: 	/**
0: 		getTimestamp returns a timestamp with the date value 
0: 		time is set to 00:00:00.0
0: 	*/
0: 	public Timestamp getTimestamp( Calendar cal) 
0: 	{
0: 		if (isNull())
0: 		{
0: 			return null;
0: 		}
0: 		else 
0: 			// date is converted to a timestamp filling the time in with 00:00:00
0:             return newTimestamp(cal);
0:     }
0: 
0:     private long getTimeInMillis( Calendar cal)
0:     {
0:         if( cal == null)
0:             cal = new GregorianCalendar();
0:         cal.clear();
0:         cal.set( getYear( encodedDate), getMonth( encodedDate)-1, getDay( encodedDate));
0:         return cal.getTime().getTime();
0:     }
0:     
0:     private Timestamp newTimestamp(java.util.Calendar cal)
0:     {
0:         return new Timestamp(getTimeInMillis( cal));
0: 	}
0: 
0: 	/**
0: 		getObject returns the date value
0: 
0: 	 */
0: 	public Object getObject()
0: 	{
0: 		return getDate( (Calendar) null);
0: 	}
0: 		
0: 	public int getLength()
0: 	{
0: 		return 4;
0: 	}
0: 
0: 	/* this is for DataType's error generator */
0: 	public String getTypeName()
0: 	{
0: 		return "DATE";
0: 	}
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.SQL_DATE_ID;
0: 	}
0: 
0: 	/** 
0: 		@exception IOException error writing data
0: 
0: 	*/
0: 	public void writeExternal(ObjectOutput out) throws IOException {
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(!isNull(), "writeExternal() is not supposed to be called for null values.");
0: 
0: 		out.writeInt(encodedDate);
0: 	}
0: 
0: 	/**
0: 	 * @see java.io.Externalizable#readExternal
0: 	 *
0: 	 * @exception IOException	Thrown on error reading the object
0: 	 */
0: 	public void readExternal(ObjectInput in) throws IOException
0: 	{
0: 		encodedDate = in.readInt();
0: 
0: 		// reset cached string values
0: 		valueString = null;
0: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException
0: 	{
0: 		encodedDate = in.readInt();
0: 
0: 		// reset cached string values
0: 		valueString = null;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
0: 	{
0: 		// Call constructor with all of our info
0: 		return new SQLDate(encodedDate);
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#getNewNull
0: 	 */
0: 	public DataValueDescriptor getNewNull()
0: 	{
0: 		return new SQLDate();
0: 	}
0: 	/**
0: 	 * @see org.apache.derby.iapi.services.io.Storable#restoreToNull
0: 	 *
0: 	 */
0: 
0: 	public void restoreToNull()
0: 	{
0: 		// clear encodedDate
0: 		encodedDate = 0;
0: 
0: 		// clear cached valueString
0: 		valueString = null;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#setValueFromResultSet 
0: 	 *
0: 	 * @exception SQLException		Thrown on error
0: 	 */
0: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
0: 									  boolean isNullable)
0: 		throws SQLException, StandardException
0: 	{
0:         setValue(resultSet.getDate(colNumber), (Calendar) null);
0: 	}
0: 
0: 	/**
0: 	 * Orderable interface
0: 	 *
0: 	 *
0: 	 * @see org.apache.derby.iapi.types.Orderable
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public int compare(DataValueDescriptor other)
0: 		throws StandardException
0: 	{
0: 		/* Use compare method from dominant type, negating result
0: 		 * to reflect flipping of sides.
0: 		 */
0: 		if (typePrecedence() < other.typePrecedence())
0: 		{
0: 			return - (other.compare(this));
0: 		}
0: 
0: 
0: 		boolean thisNull, otherNull;
0: 
0: 		thisNull = this.isNull();
0: 		otherNull = other.isNull();
0: 
0: 		/*
0: 		 * thisNull otherNull	return
0: 		 *	T		T		 	0	(this == other)
0: 		 *	F		T		 	-1 	(this < other)
0: 		 *	T		F		 	1	(this > other)
0: 		 */
0: 		if (thisNull || otherNull)
0: 		{
0: 			if (!thisNull)		// otherNull must be true
0: 				return -1;
0: 			if (!otherNull)		// thisNull must be true
0: 				return 1;
0: 			return 0;
0: 		}
0: 
0: 		/*
0: 			Neither are null compare them 
0: 		 */
0: 
0: 		int comparison;
0: 		/* get the comparison date values */
0: 		int otherVal = 0;
0: 
0: 		/* if the argument is another SQLDate
0: 		 * get the encodedDate
0: 		 */
0: 		if (other instanceof SQLDate)
0: 		{
0: 			otherVal = ((SQLDate)other).encodedDate; 
0: 		}
0: 		else 
0: 		{
0: 			/* O.K. have to do it the hard way and calculate the numeric value
0: 			 * from the value
0: 			 */
0: 			otherVal = SQLDate.computeEncodedDate(other.getDate(new GregorianCalendar()));
0: 		}
0: 		if (encodedDate > otherVal)
0: 			comparison = 1;
0: 		else if (encodedDate < otherVal)
0: 			comparison = -1;
0: 		else 
0: 			comparison = 0;
0: 
0: 		return comparison;
0: 	}
0: 
0: 	/**
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public boolean compare(int op,
0: 						   DataValueDescriptor other,
0: 						   boolean orderedNulls,
0: 						   boolean unknownRV)
0: 		throws StandardException
0: 	{
0: 		if (!orderedNulls)		// nulls are unordered
0: 		{
0: 			if (this.isNull() || other.isNull())
0: 				return unknownRV;
0: 		}
0: 
0: 		/* Do the comparison */
0: 		return super.compare(op, other, orderedNulls, unknownRV);
0: 	}
0: 
0: 	/*
0: 	** Class interface
0: 	*/
0: 
0: 	/*
0: 	** Constructors
0: 	*/
0: 
0: 	/** no-arg constructor required by Formattable */
0: 	public SQLDate() {
0: 	}
0: 
0: 	public SQLDate(Date value) throws StandardException
0: 	{
0: 		parseDate(value);
0: 	}
0: 
0:     private void parseDate( java.util.Date value) throws StandardException
0: 	{
0: 		encodedDate = computeEncodedDate(value);
0: 	}
0: 
0: 	private SQLDate(int encodedDate) {
0: 		this.encodedDate = encodedDate;
0: 	}
0: 
0:     /**
0:      * Construct a date from a string. The allowed date formats are:
0:      *<ol>
0:      *<li>ISO: yyyy-mm-dd
0:      *<li>IBM USA standard: mm/dd/yyyy
0:      *<li>IBM European standard: dd.mm.yyyy
0:      *</ol>
0:      * Trailing blanks may be included; leading zeros may be omitted from the month and day portions.
0:      *
0:      * @param dateStr
0:      * @param isJdbcEscape if true then only the JDBC date escape syntax is allowed
0:      * @param localeFinder
0:      *
0:      * @return the internal DataValueDescriptor for the value
0:      *
0:      * @exception Standard exception if the syntax is invalid or the value is out of range.
0:      */
0:     public SQLDate( String dateStr, boolean isJdbcEscape, LocaleFinder localeFinder)
0:         throws StandardException
0:     {
0:         parseDate( dateStr, isJdbcEscape, localeFinder, (Calendar) null);
0:     }
0: 
0:     /**
0:      * Construct a date from a string. The allowed date formats are:
0:      *<ol>
0:      *<li>ISO: yyyy-mm-dd
0:      *<li>IBM USA standard: mm/dd/yyyy
0:      *<li>IBM European standard: dd.mm.yyyy
0:      *</ol>
0:      * Trailing blanks may be included; leading zeros may be omitted from the month and day portions.
0:      *
0:      * @param dateStr
0:      * @param isJdbcEscape if true then only the JDBC date escape syntax is allowed
0:      * @param localeFinder
0:      *
0:      * @return the internal DataValueDescriptor for the value
0:      *
0:      * @exception Standard exception if the syntax is invalid or the value is out of range.
0:      */
0:     public SQLDate( String dateStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
0:         throws StandardException
0:     {
0:         parseDate( dateStr, isJdbcEscape, localeFinder, cal);
0:     }
0: 
0:     static final char ISO_SEPARATOR = '-';
0:     private static final char[] ISO_SEPARATOR_ONLY = {ISO_SEPARATOR};
0:     private static final char IBM_USA_SEPARATOR = '/';
0:     private static final char[] IBM_USA_SEPARATOR_ONLY = {IBM_USA_SEPARATOR};
0:     private static final char IBM_EUR_SEPARATOR = '.';
0:     private static final char[] IBM_EUR_SEPARATOR_ONLY = {IBM_EUR_SEPARATOR};
0:     private static final char[] END_OF_STRING = {(char) 0};
0:     
0:     private void parseDate( String dateStr, boolean isJdbcEscape, LocaleFinder localeFinder, Calendar cal)
0:         throws StandardException
0:     {
0:         boolean validSyntax = true;
0:         DateTimeParser parser = new DateTimeParser( dateStr);
0:         int year = 0;
0:         int month = 0;
0:         int day = 0;
0:         StandardException thrownSE = null;
0: 
0:         try
0:         {
0:             switch( parser.nextSeparator())
0:             {
0:             case ISO_SEPARATOR:
0:                 encodedDate = SQLTimestamp.parseDateOrTimestamp( parser, false)[0];
0:                 valueString = parser.getTrimmedString();
0:                 return;
0: 
0:             case IBM_USA_SEPARATOR:
0:                 if( isJdbcEscape)
0:                 {
0:                     validSyntax = false;
0:                     break;
0:                 }
0:                 month = parser.parseInt( 2, true, IBM_USA_SEPARATOR_ONLY, false);
0:                 day = parser.parseInt( 2, true, IBM_USA_SEPARATOR_ONLY, false);
0:                 year = parser.parseInt( 4, false, END_OF_STRING, false);
0:                 break;
0: 
0:             case IBM_EUR_SEPARATOR:
0:                 if( isJdbcEscape)
0:                 {
0:                     validSyntax = false;
0:                     break;
0:                 }
0:                 day = parser.parseInt( 2, true, IBM_EUR_SEPARATOR_ONLY, false);
0:                 month = parser.parseInt( 2, true, IBM_EUR_SEPARATOR_ONLY, false);
0:                 year = parser.parseInt( 4, false, END_OF_STRING, false);
0:                 break;
0: 
0:             default:
0:                 validSyntax = false;
0:             }
0:         }
0:         catch( StandardException se)
0:         {
0:             validSyntax = false;
0:             thrownSE = se;
0:         }
0:         if( validSyntax)
0:         {
0:             valueString = parser.checkEnd();
0:             encodedDate = computeEncodedDate( year, month, day);
0:         }
0:         else
0:         {
0:             // See if it is a localized date or timestamp.
0:             dateStr = StringUtil.trimTrailing( dateStr);
0:             DateFormat dateFormat = null;
0:             if( localeFinder == null)
0:                 dateFormat = DateFormat.getDateInstance();
0:             else if( cal == null)
0:                 dateFormat = localeFinder.getDateFormat();
0:             else
0:                 dateFormat = (DateFormat) localeFinder.getDateFormat().clone();
0:             if( cal != null)
0:                 dateFormat.setCalendar( cal);
0:             try
0:             {
0:                 encodedDate = computeEncodedDate( dateFormat.parse( dateStr), cal);
0:             }
0:             catch( ParseException pe)
0:             {
0:                 // Maybe it is a localized timestamp
0:                 try
0:                 {
0:                     encodedDate = SQLTimestamp.parseLocalTimestamp( dateStr, localeFinder, cal)[0];
0:                 }
0:                 catch( ParseException pe2)
0:                 {
0:                     if( thrownSE != null)
0:                         throw thrownSE;
0:                     throw StandardException.newException( SQLState.LANG_DATE_SYNTAX_EXCEPTION);
0:                 }
0:             }
0:             valueString = dateStr;
0:         }
0:     } // end of parseDate
0: 
0: 	public void setValue(Object theValue) throws StandardException
0: 	{
0: 		if (theValue == null)
0: 		{
0: 			setToNull();
0: 		}
0: 		else if (theValue instanceof Date)
0: 		{
0: 			setValue((Date)theValue, (Calendar) null);
0: 		}
0: 		else if (theValue instanceof Timestamp)
0: 		{
0: 			setValue((Timestamp)theValue, (Calendar) null);
0: 		}
0: 		else
0: 		{
0: 			genericSetObject(theValue);
0: 		}
0: 
0: 	}
0: 
0: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
0: 
0: 		// Same format means same type SQLDate
0: 		if (theValue instanceof SQLDate) {
0: 			restoreToNull();
0: 			encodedDate = ((SQLDate) theValue).encodedDate;
0: 		}
0:         else
0:         {
0:             Calendar cal = new GregorianCalendar();
0: 			setValue(theValue.getDate( cal), cal);
0:         }
0: 	}
0: 
0: 	/**
0: 		@see DateTimeDataValue#setValue
0: 
0: 	 */
0: 	public void setValue(Date value, Calendar cal) throws StandardException
0: 	{
0: 		restoreToNull();
0: 		encodedDate = computeEncodedDate((java.util.Date) value, cal);
0: 	}
0: 
0: 	/**
0: 		@see DateTimeDataValue#setValue
0: 
0: 	 */
0: 	public void setValue(Timestamp value, Calendar cal) throws StandardException
0: 	{
0: 		restoreToNull();
0: 		encodedDate = computeEncodedDate((java.util.Date) value, cal);
0: 	}
0: 
0: 
0: 	public void setValue(String theValue)
0: 	    throws StandardException
0: 	{
0: 		restoreToNull();
0: 
0: 		if (theValue != null)
0: 		{
0:             DatabaseContext databaseContext = (DatabaseContext) ContextService.getContext(DatabaseContext.CONTEXT_ID);
0:             parseDate( theValue,
0:                        false,
0:                        (databaseContext == null) ? null : databaseContext.getDatabase(),
0:                        (Calendar) null);
0:         }
0: 	}
0: 
0: 	/*
0: 	** SQL Operators
0: 	*/
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getYear
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getYear(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getYear called on a null");
0: 		}
0: 		return SQLDate.setSource(getYear(encodedDate), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getMonth
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getMonth(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMonth called on a null");
0: 		}
0: 		return SQLDate.setSource(getMonth(encodedDate), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getDate
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getDate(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getDate called on a null");
0: 		}
0: 		return SQLDate.setSource(getDay(encodedDate), result);
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getHours
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getHours(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getHours called on null.");
0: 		}
0: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
0: 						"getHours", "Date");
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getMinutes
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getMinutes(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getMinutes called on null.");
0: 		}
0: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
0: 						"getMinutes", "Date");
0: 	}
0: 
0: 	/**
0: 	 * @see DateTimeDataValue#getSeconds
0: 	 * 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public NumberDataValue getSeconds(NumberDataValue result)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(!isNull(), "getSeconds called on null.");
0: 		}
0: 		throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
0: 						"getSeconds", "Date");
0: 	}
0: 
0: 	/*
0: 	** String display of value
0: 	*/
0: 
0: 	public String toString()
0: 	{
0: 		if (isNull())
0: 		{
0: 			return "NULL";
0: 		}
0: 		else
0: 		{
0: 			return getDate( (Calendar) null).toString();
0: 		}
0: 	}
0: 
0: 	/*
0: 	 * Hash code
0: 	 */
0: 	public int hashCode()
0: 	{
0: 		return encodedDate;
0: 	}
0: 
0: 	/** @see DataValueDescriptor#typePrecedence */
0: 	public int	typePrecedence()
0: 	{
0: 		return TypeId.DATE_PRECEDENCE;
0: 	}
0: 
0: 	/**
0: 	 * Check if the value is null.  
0: 	 * encodedDate is 0 if the value is null
0: 	 *
0: 	 * @return Whether or not value is logically null.
0: 	 */
0: 	public final boolean isNull()
0: 	{
0: 		return (encodedDate == 0);
0: 	}
0: 
0: 	/**
0: 	 * Get the value field.  We instantiate the field
0: 	 * on demand.
0: 	 *
0: 	 * @return	The value field.
0: 	 */
0: 	public Date getDate( Calendar cal)
0: 	{
0: 		if (encodedDate != 0)
0:             return new Date( getTimeInMillis( cal));
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Get the year from the encodedDate.
0: 	 *
0: 	 * @param encodedDate	the encoded date
0: 	 * @return	 			year value.
0: 	 */
0: 	static int getYear(int encodedDate)
0: 	{
0: 		return (encodedDate >>> 16);
0: 	}
0: 
0: 	/**
0: 	 * Get the month from the encodedDate.
0: 	 *
0: 	 * @param encodedDate	the encoded date
0: 	 * @return	 			month value.
0: 	 */
0: 	static int getMonth(int encodedDate)
0: 	{
0: 		return ((encodedDate >>> 8) & 0x00ff);
0: 	}
0: 
0: 	/**
0: 	 * Get the day from the encodedDate.
0: 	 *
0: 	 * @param encodedDate	the encoded date
0: 	 * @return	 			day value.
0: 	 */
0: 	static int getDay(int encodedDate)
0: 	{
0: 		return (encodedDate & 0x00ff);
0: 	}
0: 	/**
0: 	 *	computeEncodedDate extracts the year, month and date from
0: 	 *	a Calendar value and encodes them as
0: 	 *		year << 16 + month << 8 + date
0: 	 *	Use this function will help to remember to add 1 to month
0: 	 *  which is 0 based in the Calendar class
0: 	 *	@param value	the Calendar 
0: 	 *	@return 		the encodedDate
0:      *
0:      *  @exception StandardException if the value is out of the DB2 date range
0: 	 */
0: 	static int computeEncodedDate(Calendar cal) throws StandardException
0: 	{
0: 		return computeEncodedDate(cal.get(Calendar.YEAR),
0:                                   cal.get(Calendar.MONTH) + 1,
0:                                   cal.get(Calendar.DATE));
0: 	}
0: 
0:     static int computeEncodedDate( int y, int m, int d) throws StandardException
0:     {
0:         int maxDay = 31;
0:         switch( m)
0:         {
0:         case 4:
0:         case 6:
0:         case 9:
0:         case 11:
0:             maxDay = 30;
0:             break;
0:                 
0:         case 2:
0:             // leap years are every 4 years except for century years not divisble by 400.
0:             maxDay = ((y % 4) == 0 && ((y % 100) != 0 || (y % 400) == 0)) ? 29 : 28;
0:             break;
0:         }
0:         if( y < 1 || y > 9999
0:             || m < 1 || m > 12
0:             || d < 1 || d > maxDay)
0:             throw StandardException.newException( SQLState.LANG_DATE_RANGE_EXCEPTION);
0:         return (y << 16) + (m << 8) + d;
0:     }
0: 
0:     /**
0:      * Convert a date to the JDBC representation and append it to a string buffer.
0:      *
0:      * @param year
0:      * @param month 1 based (January == 1)
0:      * @param day
0:      * @param sb The string representation is appended to this StringBuffer
0:      */
0:     static void dateToString( int year, int month, int day, StringBuffer sb)
0:     {
0:         String yearStr = Integer.toString( year);
0:         for( int i = yearStr.length(); i < 4; i++)
0:             sb.append( '0');
0: 		sb.append(yearStr);
0: 		sb.append(ISO_SEPARATOR);
0: 
0: 		String monthStr = Integer.toString( month);
0: 		String dayStr = Integer.toString( day);
0: 		if (monthStr.length() == 1)
0: 			sb.append('0');
0: 		sb.append(monthStr);
0: 		sb.append(ISO_SEPARATOR);
0: 		if (dayStr.length() == 1)
0: 			sb.append('0');
0: 		sb.append(dayStr);
0:     } // end of dateToString
0:     
0: 	/**
0: 	 * Get the String version from the encodedDate.
0: 	 *
0: 	 * @return	 string value.
0: 	 */
0: 	static String encodedDateToString(int encodedDate)
0: 	{
0: 		StringBuffer vstr = new StringBuffer();
0:         dateToString( getYear(encodedDate), getMonth(encodedDate), getDay(encodedDate), vstr);
0: 		return vstr.toString();
0: 	}
0: 
0: 	// International Support
0: 
0: 	/**
0: 	 * International version of getString(). Overrides getNationalString
0: 	 * in DataType for date, time, and timestamp.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected String getNationalString(LocaleFinder localeFinder) throws StandardException
0: 	{
0: 		if (isNull())
0: 		{
0: 			return getString();
0: 		}
0: 
0: 		return localeFinder.getDateFormat().format(getDate(new GregorianCalendar()));
0: 	}
0: 
0: 	/**
0: 		This helper routine tests the nullability of various parameters
0: 		and sets up the result appropriately.
0: 
0: 		If source is null, a new NumberDataValue is built. 
0: 
0: 		@exception StandardException	Thrown on error
0: 	 */
0: 	static NumberDataValue setSource(int value,
0: 										NumberDataValue source)
0: 									throws StandardException {
0: 		/*
0: 		** NOTE: Most extract operations return int, so the generation of
0: 		** a SQLInteger is here.  Those extract operations that return
0: 		** something other than int must allocate the source NumberDataValue
0: 		** themselves, so that we do not allocate a SQLInteger here.
0: 		*/
0: 		if (source == null)
0: 			source = new SQLInteger();
0: 
0: 		source.setValue(value);
0: 
0: 		return source;
0: 	}
0: 	/**
0:      * Compute the encoded date given a date
0: 	 *
0: 	 */
0: 	private static int computeEncodedDate(java.util.Date value) throws StandardException
0: 	{
0:         return computeEncodedDate( value, null);
0:     }
0: 
0:     static int computeEncodedDate(java.util.Date value, Calendar currentCal) throws StandardException
0:     {
0: 		if (value == null)
0: 			return 0;			//encoded dates have a 0 value for null
0:         if( currentCal == null)
0:             currentCal = new GregorianCalendar();
0: 		currentCal.setTime(value);
0: 		return SQLDate.computeEncodedDate(currentCal);
0: 	}
0: }
0: 
============================================================================