1:fe77ca5: /*
2:fe77ca5: 
1:985fc85:    Derby - Class org.apache.derby.impl.tools.ij.StatementFinder
1:985fc85: 
1:11bc2d0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:11bc2d0:    contributor license agreements.  See the NOTICE file distributed with
1:11bc2d0:    this work for additional information regarding copyright ownership.
1:11bc2d0:    The ASF licenses this file to You under the Apache License, Version 2.0
1:11bc2d0:    (the "License"); you may not use this file except in compliance with
1:11bc2d0:    the License.  You may obtain a copy of the License at
1:985fc85: 
1:985fc85:       http://www.apache.org/licenses/LICENSE-2.0
1:985fc85: 
1:985fc85:    Unless required by applicable law or agreed to in writing, software
1:985fc85:    distributed under the License is distributed on an "AS IS" BASIS,
1:985fc85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985fc85:    See the License for the specific language governing permissions and
1:985fc85:    limitations under the License.
1:985fc85: 
2:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: package org.apache.derby.impl.tools.ij;
1:fe77ca5: 
1:c0c3716: import org.apache.derby.iapi.tools.i18n.LocalizedOutput;
1:c0c3716: import org.apache.derby.iapi.tools.i18n.LocalizedInput;
1:c0c3716: 
1:fe77ca5: import java.io.IOException;
1:fe77ca5: import java.io.Reader;
1:fe77ca5: 
2:fe77ca5: /**
1:fe77ca5: 	StatementGrabber looks through an input stream for
1:fe77ca5: 	the next JSQL statement.  A statement is considered to
1:fe77ca5: 	be any tokens up to the next semicolon or EOF.
1:fe77ca5: 	<p>
1:fe77ca5: 	Semicolons inside comments, strings, and delimited identifiers
1:fe77ca5: 	are not considered to be statement terminators but to be
1:fe77ca5: 	part of those tokens.
1:fe77ca5: 	<p>
1:ad72a2b:     Comments currently recognized include the SQL comment,
1:ad72a2b:     which begins with "--" and ends at the next EOL, and nested
1:ad72a2b:     bracketed comments.
1:fe77ca5: 	<p>
1:fe77ca5: 	Strings and delimited identifiers are permitted to contain
1:fe77ca5: 	newlines; the actual IJ or JSQL parsers will report errors when
1:fe77ca5: 	those cases occur.
1:fe77ca5: 	<p>
1:fe77ca5: 	There are no escaped characters, i.e. "\n" is considered to
1:fe77ca5: 	be two characters, '\' and 'n'.
1:fe77ca5: 
1:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: public class StatementFinder {
1:fe77ca5: 
1:fe77ca5: 	private Reader source; 
1:fe77ca5: 	private StringBuffer statement = new StringBuffer();
1:fe77ca5: 	private int state;
1:fe77ca5: 	private boolean atEOF = false;
1:fe77ca5: 	private boolean peekEOF = false;
1:fe77ca5: 	private char peekChar;
1:fe77ca5: 	private boolean peeked = false;
1:c0c3716: 	private LocalizedOutput promptwriter;
1:c0c3716: 	private boolean doPrompt;
1:c0c3716: 	private boolean continuedStatement;
1:fe77ca5: 
1:fe77ca5: 	// state variables
1:fe77ca5: 	private static final int IN_STATEMENT = 0;
1:fe77ca5: 	private static final int IN_STRING = 1;
1:fe77ca5: 	private static final int IN_SQLCOMMENT = 2;
1:fe77ca5: 	private static final int END_OF_STATEMENT = 3;
1:fe77ca5: 	private static final int END_OF_INPUT = 4;
1:fe77ca5: 
1:fe77ca5: 	// special state-changing characters
1:fe77ca5: 	private static final char MINUS = '-';
1:fe77ca5: 	private static final char SINGLEQUOTE = '\'';
1:fe77ca5: 	private static final char DOUBLEQUOTE = '\"';
1:fe77ca5: 	private static final char SEMICOLON = ';';
1:fe77ca5: 	private static final char NEWLINE = '\n';
1:fe77ca5: 	private static final char RETURN = '\r';
1:fe77ca5: 	private static final char SPACE = ' ';
1:fe77ca5: 	private static final char TAB = '\t';
1:fe77ca5: 	private static final char FORMFEED = '\f';
1:ad72a2b: 	private static final char SLASH = '/';
1:ad72a2b: 	private static final char ASTERISK = '*';
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		The constructor does not assume the stream is data input
1:fe77ca5: 		or buffered, so it will wrap it appropriately.
1:fe77ca5: 
1:c0c3716: 		If the StatementFinder's input stream is connected to
1:c0c3716: 		System.in, a LocalizedOutput stream may be given to print
1:c0c3716: 		line continuation prompts when StatementFinder reads a newline.
1:c0c3716: 
1:fe77ca5: 		@param s the input stream for reading statements from.
1:c0c3716: 		@param promptDest LocalizedOutput stream to write line
1:dbed020: 						continuation prompts ("&gt; ") to. If null,
1:c0c3716: 						no such prompts will be written.
1:fe77ca5: 	 */
1:c0c3716: 	public StatementFinder(LocalizedInput s, LocalizedOutput promptDest) {
1:fe77ca5: 		source = s;
1:c0c3716: 		if(promptDest != null && s.isStandardInput()) {
1:c0c3716: 			promptwriter = promptDest;
1:c0c3716: 			doPrompt = true;
1:c0c3716: 		} else {
1:c0c3716: 			doPrompt = false;
1:c0c3716: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Reinit is used to redirect the finder to another stream.
1:fe77ca5: 		The previous stream should not have been in a PEEK state.
1:fe77ca5: 
1:c0c3716: 		If an output stream was given when constructing this 
1:c0c3716: 		StatementFinder and the input is standard input, 
1:c0c3716: 		continuation prompting will be enabled.
1:c0c3716: 
1:fe77ca5: 		@param s the input stream for reading statements from.
1:fe77ca5: 	 */
1:c0c3716: 	public void ReInit(LocalizedInput s) {
1:fe77ca5: 	    try {
1:fe77ca5: 			source.close();
1:fe77ca5: 		} catch (IOException ioe) {
1:fe77ca5: 			// just be quiet if it is already gone
1:fe77ca5: 		}
1:fe77ca5: 		source = s;
1:fe77ca5: 		state = IN_STATEMENT;
1:fe77ca5: 		atEOF = false;
1:fe77ca5: 		peekEOF = false;
1:fe77ca5: 		peeked = false;
1:c0c3716: 		if(s.isStandardInput() && promptwriter != null) {
1:c0c3716: 			doPrompt = true;
1:c0c3716: 		} else {
1:c0c3716: 			doPrompt = false;
1:c0c3716: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	public void close() throws IOException {
1:fe77ca5: 		source.close();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		get the next statement in the input stream. Returns it,
1:fe77ca5: 		dropping its closing semicolon if it has one. If there is
1:fe77ca5: 		no next statement, return a null.
1:fe77ca5: 
1:fe77ca5: 		@return the next statement in the input stream.
1:fe77ca5: 	 */
1:fe77ca5: 	public String nextStatement() {
1:fe77ca5: 		boolean haveSemi = false;
1:fe77ca5: 		char nextChar;
1:fe77ca5: 
1:fe77ca5: 		// initialize fields for getting the next statement
1:fe77ca5: 		statement.setLength(0);
1:fe77ca5: 		if (state == END_OF_INPUT) return null;
1:fe77ca5: 
1:fe77ca5: 		state = IN_STATEMENT;
1:fe77ca5: 
1:fe77ca5: 		// skip leading whitespace
1:fe77ca5: 		nextChar = peekChar();
1:fe77ca5: 		if (peekEOF()) {
1:fe77ca5: 			state = END_OF_INPUT;
1:fe77ca5: 			return null;
1:fe77ca5: 		}
1:fe77ca5: 		if (whiteSpace(nextChar)) {
1:fe77ca5: 			while (whiteSpace(peekChar()) && ! peekEOF());
1:fe77ca5: 			if (peekEOF()) {
1:fe77ca5: 				state = END_OF_INPUT;
1:fe77ca5: 				return null;
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		while (state != END_OF_STATEMENT && state != END_OF_INPUT) {
1:fe77ca5: 
1:fe77ca5: 			// get the next character from the input
1:fe77ca5: 			nextChar = readChar();
1:fe77ca5: 			if (atEOF()) {
1:fe77ca5: 				state = END_OF_INPUT;
1:fe77ca5: 				break;
1:fe77ca5: 			}
1:c0c3716: 			
1:c0c3716: 			if (!(nextChar == MINUS))
1:c0c3716: 				continuedStatement=true;
1:fe77ca5: 
1:fe77ca5: 			switch(nextChar) {
1:fe77ca5: 				case MINUS:
1:fe77ca5: 					readSingleLineComment(nextChar);
1:fe77ca5: 					break;
1:ad72a2b: 				case SLASH:
1:ad72a2b: 				    readBracketedComment();
1:ad72a2b: 				    break;
1:fe77ca5: 				case SINGLEQUOTE:
1:fe77ca5: 				case DOUBLEQUOTE:
1:fe77ca5: 					readString(nextChar);
1:fe77ca5: 					break;
1:fe77ca5: 				case SEMICOLON:
1:fe77ca5: 					haveSemi = true;
1:fe77ca5: 					state = END_OF_STATEMENT;
1:c0c3716: 					continuedStatement=false;
1:fe77ca5: 					break;
1:c0c3716: 				case NEWLINE:
1:c0c3716: 				case RETURN:
1:c0c3716: 					if(doPrompt) {
1:c0c3716: 						utilMain.doPrompt(false, promptwriter, "");
1:c0c3716: 						/* If the next character is a newline as well,
1:c0c3716: 						   we swallow it to avoid double prompting on
1:c0c3716: 						   Windows. */
1:c0c3716: 						if(nextChar == RETURN && peekChar() == NEWLINE) {
1:c0c3716: 							readChar();
1:c0c3716: 						}
1:c0c3716: 					}
1:fe77ca5: 				default:
1:fe77ca5: 					// keep going, just a normal character
1:fe77ca5: 					break;
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (haveSemi)
1:fe77ca5: 			statement.setLength(statement.length()-1);
1:fe77ca5: 		return statement.toString();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Determine if the given character is considered whitespace
1:fe77ca5: 
1:fe77ca5: 		@param c the character to consider
1:fe77ca5: 		@return true if the character is whitespace
1:fe77ca5: 	 */
1:fe77ca5: 	private boolean whiteSpace(char c) {
1:fe77ca5: 		return (c == SPACE ||
1:fe77ca5: 		    	c == TAB ||
1:fe77ca5: 		    	c == RETURN ||
1:fe77ca5: 		    	c == NEWLINE ||
1:fe77ca5: 		    	c == FORMFEED);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:ad72a2b: 	 	* Advance the source stream to the end of a comment
1:ad72a2b: 		* if it is on one, assuming the first character of
1:ad72a2b: 		* a potential bracketed comment has been found.
1:ad72a2b: 		* If it is not a comment, do not advance the stream.
1:ad72a2b: 	 */
1:ad72a2b: 	private void readBracketedComment() {
1:ad72a2b: 		char nextChar = peekChar();
1:ad72a2b: 
1:ad72a2b: 		// if next char is EOF, we are done.
1:ad72a2b: 		if (peekEOF()) return;
1:ad72a2b: 
1:ad72a2b: 		// if nextChar is not an asterisk, then not a comment.
1:ad72a2b: 		if (nextChar != ASTERISK)
1:ad72a2b: 		{
1:ad72a2b: 			continuedStatement = true;
1:ad72a2b: 			return;
1:ad72a2b: 		}
1:ad72a2b: 
1:ad72a2b: 		// we are really in a comment
1:ad72a2b: 		readChar(); // grab the asterisk for real.
1:ad72a2b: 
1:ad72a2b: 		int nestingLevel = 1;
1:ad72a2b: 
1:ad72a2b: 		while (true) {
1:ad72a2b: 			nextChar = readChar();
1:ad72a2b: 
1:ad72a2b: 			if (atEOF()) {
1:ad72a2b: 				// let the caller process the EOF, don't read it
1:ad72a2b: 				state = IN_STATEMENT;
1:ad72a2b: 				return;
1:ad72a2b: 			}
1:ad72a2b: 
1:ad72a2b: 			char peek = peekChar();
1:ad72a2b: 
1:ad72a2b: 			if (nextChar == SLASH && peek == ASTERISK) {
1:ad72a2b: 				readChar();
1:ad72a2b: 				nestingLevel++;
1:ad72a2b: 			} else if (nextChar == ASTERISK && peek == SLASH) {
1:ad72a2b: 				readChar();
1:ad72a2b: 				nestingLevel--;
1:ad72a2b: 				if (nestingLevel == 0) {
1:ad72a2b: 					state = IN_STATEMENT;
1:ad72a2b: 					return;
1:ad72a2b: 				}
1:ad72a2b: 			} else if (nextChar == NEWLINE || nextChar == RETURN) {
1:ad72a2b: 				if (doPrompt) {
1:ad72a2b: 					utilMain.doPrompt(false, promptwriter, "");
1:ad72a2b: 					// If the next character is a NEWLINE, we process
1:ad72a2b: 					// it as well to account for Windows CRLFs.
1:ad72a2b: 					if (nextChar == RETURN && peek == NEWLINE) {
1:ad72a2b: 						readChar();
1:ad72a2b: 					}
1:ad72a2b: 				}
1:ad72a2b: 			}
1:ad72a2b: 		}
1:ad72a2b: 	}
1:ad72a2b: 
1:ad72a2b: 	/**
1:fe77ca5: 		Advance the source stream to the end of a comment if it
1:fe77ca5: 		is on one, assuming the first character of
1:fe77ca5: 		a potential single line comment has been found.
1:fe77ca5: 		If it is not a comment, do not advance the stream.
1:fe77ca5: 		<p>
1:fe77ca5: 		The form of a single line comment is, in regexp, XX.*$,
1:fe77ca5: 		where XX is two instances of commentChar.
1:fe77ca5: 
1:fe77ca5: 		@param commentChar the character whose duplication signifies
1:fe77ca5: 			the start of the comment.
1:fe77ca5: 	 */
1:fe77ca5: 	private void readSingleLineComment(char commentChar) {
1:fe77ca5: 		char nextChar;
1:fe77ca5: 
1:fe77ca5: 		nextChar = peekChar();
1:fe77ca5: 		// if next char is EOF, we are done.
1:fe77ca5: 		if (peekEOF()) return;
1:fe77ca5: 
1:fe77ca5: 		// if nextChar is not a minus, it was just a normal minus,
1:fe77ca5: 		// nothing special to do
1:c0c3716: 		if (nextChar != commentChar)
1:c0c3716: 		{
1:c0c3716: 			continuedStatement=true;
1:c0c3716: 			return;
1:c0c3716: 		}
1:fe77ca5: 
1:fe77ca5: 		// we are really in a comment
1:fe77ca5: 		readChar(); // grab the minus for real.
1:fe77ca5: 
1:fe77ca5: 		state = IN_SQLCOMMENT;
1:fe77ca5: 		do {
1:fe77ca5: 			nextChar = peekChar();
1:fe77ca5: 			if (peekEOF()) {
1:fe77ca5: 				// let the caller process the EOF, don't read it
1:fe77ca5: 				state = IN_STATEMENT;
2:fe77ca5: 				return;
1:fe77ca5: 			}
1:fe77ca5: 			switch (nextChar) {
1:fe77ca5: 				case NEWLINE:
1:fe77ca5: 				case RETURN:
1:fe77ca5: 					readChar(); // okay to process the character
1:fe77ca5: 					state = IN_STATEMENT;
1:c0c3716: 					if (doPrompt){
1:c0c3716: 						// If we had previously already started a statement,
1:c0c3716: 						// add the prompt.
1:c0c3716: 						// Otherwise, consider this a single line comment,
1:c0c3716: 						// and the next line should not get a prompt
1:c0c3716: 						if (continuedStatement)
1:c0c3716: 							utilMain.doPrompt(false, promptwriter, "");
1:c0c3716:                         else
1:c0c3716:                             utilMain.doPrompt(true, promptwriter, "");
1:c0c3716: 					    
1:c0c3716: 						/* If the next character is a NEWLINE, we process
1:c0c3716: 						 *  it as well to account for Windows CRLFs. */
1:c0c3716: 						if(nextChar == RETURN && peekChar() == NEWLINE) {
1:c0c3716: 							readChar();
1:c0c3716: 						}
1:c0c3716: 					}
1:c0c3716: 				return;
1:fe77ca5: 				default:
1:fe77ca5: 					readChar(); // process the character, still in comment
1:fe77ca5: 					break;
1:fe77ca5: 			}
1:fe77ca5: 		} while (state == IN_SQLCOMMENT); // could be while true...
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Advance the stream to the end of the string.
1:fe77ca5: 		Assumes the opening delimiter of the string has been read.
1:fe77ca5: 		This handles the SQL ability to put the delimiter within
1:fe77ca5: 		the string by doubling it, by reading those as two strings
1:fe77ca5: 		sitting next to one another.  I.e, 'Mary''s lamb' is read
1:fe77ca5: 		by this class as two strings, 'Mary' and 's lamb'.
1:fe77ca5: 		<p>
1:fe77ca5: 		The delimiter of the string is expected to be repeated at
1:fe77ca5: 		its other end. If the other flavor of delimiter occurs within
1:fe77ca5: 		the string, it is just a normal character within it.
1:fe77ca5: 		<p>
1:fe77ca5: 		All characters except the delimiter are permitted within the
1:fe77ca5: 		string. If EOF is hit before the closing delimiter is found,
1:fe77ca5: 		the end of the string is assumed. Parsers using this parser
1:fe77ca5: 		will detect the error in that case and return appropriate messages.
1:fe77ca5: 
1:fe77ca5: 		@param stringDelimiter the starting and ending character
1:fe77ca5: 			for the string being read.
1:fe77ca5: 	 */
1:fe77ca5: 	private void readString(char stringDelimiter) {
1:fe77ca5: 		state = IN_STRING;
1:fe77ca5: 		do {
1:fe77ca5: 			char nextChar = readChar();
1:fe77ca5: 
1:fe77ca5: 			if (atEOF()) {
1:fe77ca5: 				state = END_OF_INPUT;
1:fe77ca5: 				return;
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			if (nextChar == stringDelimiter) {
1:fe77ca5: 				// we've reached the end of the string
1:fe77ca5: 				state = IN_STATEMENT;
1:fe77ca5: 				return;
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			// still in string
1:fe77ca5: 		} while (state == IN_STRING); // could be while true...
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private boolean atEOF() {
1:fe77ca5: 		return atEOF;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	private boolean peekEOF() {
1:fe77ca5: 		return peekEOF;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		return the next character in the source stream and
1:fe77ca5: 		append it to the statement buffer.
1:fe77ca5: 
1:fe77ca5: 		@return the next character in the source stream.
1:fe77ca5: 	 */
1:fe77ca5: 	private char readChar() {
1:fe77ca5: 		if (!peeked) peekChar();
1:fe77ca5: 
1:fe77ca5: 		peeked = false;
1:fe77ca5: 		atEOF = peekEOF;
1:fe77ca5: 
1:fe77ca5: 		if (!atEOF) statement.append(peekChar);
1:fe77ca5: 
1:fe77ca5: 		return peekChar;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		return the next character in the source stream, without
1:fe77ca5: 		advancing.
1:fe77ca5: 
1:fe77ca5: 		@return the next character in the source stream.
1:fe77ca5: 	 */
1:fe77ca5: 	private char peekChar() {
1:fe77ca5: 		peeked = true;
1:fe77ca5: 		char c = '\00';
1:fe77ca5: 
1:fe77ca5: 		try {
1:fe77ca5: 		    int cInt;
1:fe77ca5: 
1:fe77ca5: 			// REMIND: this is assuming a flat ascii source file.
1:fe77ca5: 			// will need to beef it up at some future point to
1:fe77ca5: 			// understand whether the stream is ascii or something else.
1:fe77ca5: 			cInt = source.read();
1:fe77ca5: 			peekEOF = (cInt == -1);
1:fe77ca5: 			if (!peekEOF) c = (char)cInt;
1:fe77ca5: 		} catch (IOException ie) {
1:fe77ca5: 			throw ijException.iOException(ie);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		peekChar = c;
1:fe77ca5: 		return c;
1:fe77ca5: 	}
1:fe77ca5: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 						continuation prompts ("&gt; ") to. If null,
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:ad72a2b
/////////////////////////////////////////////////////////////////////////
1:     Comments currently recognized include the SQL comment,
1:     which begins with "--" and ends at the next EOL, and nested
1:     bracketed comments.
/////////////////////////////////////////////////////////////////////////
1: 	private static final char SLASH = '/';
1: 	private static final char ASTERISK = '*';
/////////////////////////////////////////////////////////////////////////
1: 				case SLASH:
1: 				    readBracketedComment();
1: 				    break;
/////////////////////////////////////////////////////////////////////////
1: 	 	* Advance the source stream to the end of a comment
1: 		* if it is on one, assuming the first character of
1: 		* a potential bracketed comment has been found.
1: 		* If it is not a comment, do not advance the stream.
1: 	 */
1: 	private void readBracketedComment() {
1: 		char nextChar = peekChar();
1: 
1: 		// if next char is EOF, we are done.
1: 		if (peekEOF()) return;
1: 
1: 		// if nextChar is not an asterisk, then not a comment.
1: 		if (nextChar != ASTERISK)
1: 		{
1: 			continuedStatement = true;
1: 			return;
1: 		}
1: 
1: 		// we are really in a comment
1: 		readChar(); // grab the asterisk for real.
1: 
1: 		int nestingLevel = 1;
1: 
1: 		while (true) {
1: 			nextChar = readChar();
1: 
1: 			if (atEOF()) {
1: 				// let the caller process the EOF, don't read it
1: 				state = IN_STATEMENT;
1: 				return;
1: 			}
1: 
1: 			char peek = peekChar();
1: 
1: 			if (nextChar == SLASH && peek == ASTERISK) {
1: 				readChar();
1: 				nestingLevel++;
1: 			} else if (nextChar == ASTERISK && peek == SLASH) {
1: 				readChar();
1: 				nestingLevel--;
1: 				if (nestingLevel == 0) {
1: 					state = IN_STATEMENT;
1: 					return;
1: 				}
1: 			} else if (nextChar == NEWLINE || nextChar == RETURN) {
1: 				if (doPrompt) {
1: 					utilMain.doPrompt(false, promptwriter, "");
1: 					// If the next character is a NEWLINE, we process
1: 					// it as well to account for Windows CRLFs.
1: 					if (nextChar == RETURN && peek == NEWLINE) {
1: 						readChar();
1: 					}
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:c0c3716
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.tools.i18n.LocalizedOutput;
1: import org.apache.derby.iapi.tools.i18n.LocalizedInput;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	private LocalizedOutput promptwriter;
1: 	private boolean doPrompt;
1: 	private boolean continuedStatement;
/////////////////////////////////////////////////////////////////////////
1: 		If the StatementFinder's input stream is connected to
1: 		System.in, a LocalizedOutput stream may be given to print
1: 		line continuation prompts when StatementFinder reads a newline.
1: 
1: 		@param promptDest LocalizedOutput stream to write line
0: 						continuation prompts ("> ") to. If null,
1: 						no such prompts will be written.
1: 	public StatementFinder(LocalizedInput s, LocalizedOutput promptDest) {
1: 		if(promptDest != null && s.isStandardInput()) {
1: 			promptwriter = promptDest;
1: 			doPrompt = true;
1: 		} else {
1: 			doPrompt = false;
1: 		}
1: 		If an output stream was given when constructing this 
1: 		StatementFinder and the input is standard input, 
1: 		continuation prompting will be enabled.
1: 
1: 	public void ReInit(LocalizedInput s) {
/////////////////////////////////////////////////////////////////////////
1: 		if(s.isStandardInput() && promptwriter != null) {
1: 			doPrompt = true;
1: 		} else {
1: 			doPrompt = false;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			if (!(nextChar == MINUS))
1: 				continuedStatement=true;
/////////////////////////////////////////////////////////////////////////
1: 					continuedStatement=false;
1: 				case NEWLINE:
1: 				case RETURN:
1: 					if(doPrompt) {
1: 						utilMain.doPrompt(false, promptwriter, "");
1: 						/* If the next character is a newline as well,
1: 						   we swallow it to avoid double prompting on
1: 						   Windows. */
1: 						if(nextChar == RETURN && peekChar() == NEWLINE) {
1: 							readChar();
1: 						}
1: 					}
/////////////////////////////////////////////////////////////////////////
1: 		if (nextChar != commentChar)
1: 		{
1: 			continuedStatement=true;
1: 			return;
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 					if (doPrompt){
1: 						// If we had previously already started a statement,
1: 						// add the prompt.
1: 						// Otherwise, consider this a single line comment,
1: 						// and the next line should not get a prompt
1: 						if (continuedStatement)
1: 							utilMain.doPrompt(false, promptwriter, "");
1:                         else
1:                             utilMain.doPrompt(true, promptwriter, "");
1: 					    
1: 						/* If the next character is a NEWLINE, we process
1: 						 *  it as well to account for Windows CRLFs. */
1: 						if(nextChar == RETURN && peekChar() == NEWLINE) {
1: 							readChar();
1: 						}
1: 					}
1: 				return;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:11bc2d0
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:985fc85
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.tools.ij.StatementFinder
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:a8ff4fd
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.tools.ij;
1: 
1: import java.io.IOException;
1: import java.io.Reader;
1: 
1: /**
1: 	StatementGrabber looks through an input stream for
1: 	the next JSQL statement.  A statement is considered to
1: 	be any tokens up to the next semicolon or EOF.
1: 	<p>
1: 	Semicolons inside comments, strings, and delimited identifiers
1: 	are not considered to be statement terminators but to be
1: 	part of those tokens.
1: 	<p>
0: 	The only comment form currently recognized is the SQL comment,
0: 	which begins with "--" and ends at the next EOL.
1: 	<p>
1: 	Strings and delimited identifiers are permitted to contain
1: 	newlines; the actual IJ or JSQL parsers will report errors when
1: 	those cases occur.
1: 	<p>
1: 	There are no escaped characters, i.e. "\n" is considered to
1: 	be two characters, '\' and 'n'.
1: 
0: 	@author ames
1:  */
1: 
1: public class StatementFinder {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private Reader source; 
1: 	private StringBuffer statement = new StringBuffer();
1: 	private int state;
1: 	private boolean atEOF = false;
1: 	private boolean peekEOF = false;
1: 	private char peekChar;
1: 	private boolean peeked = false;
1: 
1: 	// state variables
1: 	private static final int IN_STATEMENT = 0;
1: 	private static final int IN_STRING = 1;
1: 	private static final int IN_SQLCOMMENT = 2;
1: 	private static final int END_OF_STATEMENT = 3;
1: 	private static final int END_OF_INPUT = 4;
1: 
1: 	// special state-changing characters
1: 	private static final char MINUS = '-';
1: 	private static final char SINGLEQUOTE = '\'';
1: 	private static final char DOUBLEQUOTE = '\"';
1: 	private static final char SEMICOLON = ';';
1: 	private static final char NEWLINE = '\n';
1: 	private static final char RETURN = '\r';
1: 	private static final char SPACE = ' ';
1: 	private static final char TAB = '\t';
1: 	private static final char FORMFEED = '\f';
1: 
1: 	/**
1: 		The constructor does not assume the stream is data input
1: 		or buffered, so it will wrap it appropriately.
1: 
1: 		@param s the input stream for reading statements from.
1: 	 */
0: 	public StatementFinder(Reader s) { 
1: 		source = s;
1: 	}
1: 
1: 	/**
1: 		Reinit is used to redirect the finder to another stream.
1: 		The previous stream should not have been in a PEEK state.
1: 
1: 		@param s the input stream for reading statements from.
1: 	 */
0: 	public void ReInit(Reader s) { 
1: 	    try {
1: 			source.close();
1: 		} catch (IOException ioe) {
1: 			// just be quiet if it is already gone
1: 		}
1: 		source = s;
1: 		state = IN_STATEMENT;
1: 		atEOF = false;
1: 		peekEOF = false;
1: 		peeked = false;
1: 	}
1: 
1: 	public void close() throws IOException {
1: 		source.close();
1: 	}
1: 
1: 	/**
1: 		get the next statement in the input stream. Returns it,
1: 		dropping its closing semicolon if it has one. If there is
1: 		no next statement, return a null.
1: 
1: 		@return the next statement in the input stream.
1: 	 */
1: 	public String nextStatement() {
1: 		boolean haveSemi = false;
1: 		char nextChar;
1: 
1: 		// initialize fields for getting the next statement
1: 		statement.setLength(0);
1: 		if (state == END_OF_INPUT) return null;
1: 
1: 		state = IN_STATEMENT;
1: 
1: 		// skip leading whitespace
1: 		nextChar = peekChar();
1: 		if (peekEOF()) {
1: 			state = END_OF_INPUT;
1: 			return null;
1: 		}
1: 		if (whiteSpace(nextChar)) {
1: 			while (whiteSpace(peekChar()) && ! peekEOF());
1: 			if (peekEOF()) {
1: 				state = END_OF_INPUT;
1: 				return null;
1: 			}
1: 		}
1: 
1: 		while (state != END_OF_STATEMENT && state != END_OF_INPUT) {
1: 
1: 			// get the next character from the input
1: 			nextChar = readChar();
1: 			if (atEOF()) {
1: 				state = END_OF_INPUT;
1: 				break;
1: 			}
1: 
1: 			switch(nextChar) {
1: 				case MINUS:
1: 					readSingleLineComment(nextChar);
1: 					break;
1: 				case SINGLEQUOTE:
1: 				case DOUBLEQUOTE:
1: 					readString(nextChar);
1: 					break;
1: 				case SEMICOLON:
1: 					haveSemi = true;
1: 					state = END_OF_STATEMENT;
1: 					break;
1: 				default:
1: 					// keep going, just a normal character
1: 					break;
1: 			}
1: 		}
1: 
1: 		if (haveSemi)
1: 			statement.setLength(statement.length()-1);
1: 		return statement.toString();
1: 	}
1: 
1: 	/**
1: 		Determine if the given character is considered whitespace
1: 
1: 		@param c the character to consider
1: 		@return true if the character is whitespace
1: 	 */
1: 	private boolean whiteSpace(char c) {
1: 		return (c == SPACE ||
1: 		    	c == TAB ||
1: 		    	c == RETURN ||
1: 		    	c == NEWLINE ||
1: 		    	c == FORMFEED);
1: 	}
1: 
1: 	/**
1: 		Advance the source stream to the end of a comment if it
1: 		is on one, assuming the first character of
1: 		a potential single line comment has been found.
1: 		If it is not a comment, do not advance the stream.
1: 		<p>
1: 		The form of a single line comment is, in regexp, XX.*$,
1: 		where XX is two instances of commentChar.
1: 
1: 		@param commentChar the character whose duplication signifies
1: 			the start of the comment.
1: 	 */
1: 	private void readSingleLineComment(char commentChar) {
1: 		char nextChar;
1: 
1: 		nextChar = peekChar();
1: 		// if next char is EOF, we are done.
1: 		if (peekEOF()) return;
1: 
1: 		// if nextChar is not a minus, it was just a normal minus,
1: 		// nothing special to do
0: 		if (nextChar != commentChar) return;
1: 
1: 		// we are really in a comment
1: 		readChar(); // grab the minus for real.
1: 
1: 		state = IN_SQLCOMMENT;
1: 		do {
1: 			nextChar = peekChar();
1: 			if (peekEOF()) {
1: 				// let the caller process the EOF, don't read it
1: 				state = IN_STATEMENT;
1: 				return;
1: 			}
1: 			switch (nextChar) {
1: 				case NEWLINE:
1: 				case RETURN:
1: 					readChar(); // okay to process the character
1: 					state = IN_STATEMENT;
1: 					return;
1: 				default:
1: 					readChar(); // process the character, still in comment
1: 					break;
1: 			}
1: 		} while (state == IN_SQLCOMMENT); // could be while true...
1: 	}
1: 
1: 	/**
1: 		Advance the stream to the end of the string.
1: 		Assumes the opening delimiter of the string has been read.
1: 		This handles the SQL ability to put the delimiter within
1: 		the string by doubling it, by reading those as two strings
1: 		sitting next to one another.  I.e, 'Mary''s lamb' is read
1: 		by this class as two strings, 'Mary' and 's lamb'.
1: 		<p>
1: 		The delimiter of the string is expected to be repeated at
1: 		its other end. If the other flavor of delimiter occurs within
1: 		the string, it is just a normal character within it.
1: 		<p>
1: 		All characters except the delimiter are permitted within the
1: 		string. If EOF is hit before the closing delimiter is found,
1: 		the end of the string is assumed. Parsers using this parser
1: 		will detect the error in that case and return appropriate messages.
1: 
1: 		@param stringDelimiter the starting and ending character
1: 			for the string being read.
1: 	 */
1: 	private void readString(char stringDelimiter) {
1: 		state = IN_STRING;
1: 		do {
1: 			char nextChar = readChar();
1: 
1: 			if (atEOF()) {
1: 				state = END_OF_INPUT;
1: 				return;
1: 			}
1: 
1: 			if (nextChar == stringDelimiter) {
1: 				// we've reached the end of the string
1: 				state = IN_STATEMENT;
1: 				return;
1: 			}
1: 
1: 			// still in string
1: 		} while (state == IN_STRING); // could be while true...
1: 	}
1: 
1: 	private boolean atEOF() {
1: 		return atEOF;
1: 	}
1: 
1: 	private boolean peekEOF() {
1: 		return peekEOF;
1: 	}
1: 
1: 	/**
1: 		return the next character in the source stream and
1: 		append it to the statement buffer.
1: 
1: 		@return the next character in the source stream.
1: 	 */
1: 	private char readChar() {
1: 		if (!peeked) peekChar();
1: 
1: 		peeked = false;
1: 		atEOF = peekEOF;
1: 
1: 		if (!atEOF) statement.append(peekChar);
1: 
1: 		return peekChar;
1: 	}
1: 
1: 	/**
1: 		return the next character in the source stream, without
1: 		advancing.
1: 
1: 		@return the next character in the source stream.
1: 	 */
1: 	private char peekChar() {
1: 		peeked = true;
1: 		char c = '\00';
1: 
1: 		try {
1: 		    int cInt;
1: 
1: 			// REMIND: this is assuming a flat ascii source file.
1: 			// will need to beef it up at some future point to
1: 			// understand whether the stream is ascii or something else.
1: 			cInt = source.read();
1: 			peekEOF = (cInt == -1);
1: 			if (!peekEOF) c = (char)cInt;
1: 		} catch (IOException ie) {
1: 			throw ijException.iOException(ie);
1: 		}
1: 
1: 		peekChar = c;
1: 		return c;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.tools.ij;
0: 
0: import java.io.IOException;
0: import java.io.Reader;
0: 
0: /**
0: 	StatementGrabber looks through an input stream for
0: 	the next JSQL statement.  A statement is considered to
0: 	be any tokens up to the next semicolon or EOF.
0: 	<p>
0: 	Semicolons inside comments, strings, and delimited identifiers
0: 	are not considered to be statement terminators but to be
0: 	part of those tokens.
0: 	<p>
0: 	The only comment form currently recognized is the SQL comment,
0: 	which begins with "--" and ends at the next EOL.
0: 	<p>
0: 	Strings and delimited identifiers are permitted to contain
0: 	newlines; the actual IJ or JSQL parsers will report errors when
0: 	those cases occur.
0: 	<p>
0: 	There are no escaped characters, i.e. "\n" is considered to
0: 	be two characters, '\' and 'n'.
0: 
0: 	@author ames
0:  */
0: 
0: public class StatementFinder {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private Reader source; 
0: 	private StringBuffer statement = new StringBuffer();
0: 	private int state;
0: 	private boolean atEOF = false;
0: 	private boolean peekEOF = false;
0: 	private char peekChar;
0: 	private boolean peeked = false;
0: 
0: 	// state variables
0: 	private static final int IN_STATEMENT = 0;
0: 	private static final int IN_STRING = 1;
0: 	private static final int IN_SQLCOMMENT = 2;
0: 	private static final int END_OF_STATEMENT = 3;
0: 	private static final int END_OF_INPUT = 4;
0: 
0: 	// special state-changing characters
0: 	private static final char MINUS = '-';
0: 	private static final char SINGLEQUOTE = '\'';
0: 	private static final char DOUBLEQUOTE = '\"';
0: 	private static final char SEMICOLON = ';';
0: 	private static final char NEWLINE = '\n';
0: 	private static final char RETURN = '\r';
0: 	private static final char SPACE = ' ';
0: 	private static final char TAB = '\t';
0: 	private static final char FORMFEED = '\f';
0: 
0: 	/**
0: 		The constructor does not assume the stream is data input
0: 		or buffered, so it will wrap it appropriately.
0: 
0: 		@param s the input stream for reading statements from.
0: 	 */
0: 	public StatementFinder(Reader s) { 
0: 		source = s;
0: 	}
0: 
0: 	/**
0: 		Reinit is used to redirect the finder to another stream.
0: 		The previous stream should not have been in a PEEK state.
0: 
0: 		@param s the input stream for reading statements from.
0: 	 */
0: 	public void ReInit(Reader s) { 
0: 	    try {
0: 			source.close();
0: 		} catch (IOException ioe) {
0: 			// just be quiet if it is already gone
0: 		}
0: 		source = s;
0: 		state = IN_STATEMENT;
0: 		atEOF = false;
0: 		peekEOF = false;
0: 		peeked = false;
0: 	}
0: 
0: 	public void close() throws IOException {
0: 		source.close();
0: 	}
0: 
0: 	/**
0: 		get the next statement in the input stream. Returns it,
0: 		dropping its closing semicolon if it has one. If there is
0: 		no next statement, return a null.
0: 
0: 		@return the next statement in the input stream.
0: 	 */
0: 	public String nextStatement() {
0: 		boolean haveSemi = false;
0: 		char nextChar;
0: 
0: 		// initialize fields for getting the next statement
0: 		statement.setLength(0);
0: 		if (state == END_OF_INPUT) return null;
0: 
0: 		state = IN_STATEMENT;
0: 
0: 		// skip leading whitespace
0: 		nextChar = peekChar();
0: 		if (peekEOF()) {
0: 			state = END_OF_INPUT;
0: 			return null;
0: 		}
0: 		if (whiteSpace(nextChar)) {
0: 			while (whiteSpace(peekChar()) && ! peekEOF());
0: 			if (peekEOF()) {
0: 				state = END_OF_INPUT;
0: 				return null;
0: 			}
0: 		}
0: 
0: 		while (state != END_OF_STATEMENT && state != END_OF_INPUT) {
0: 
0: 			// get the next character from the input
0: 			nextChar = readChar();
0: 			if (atEOF()) {
0: 				state = END_OF_INPUT;
0: 				break;
0: 			}
0: 
0: 			switch(nextChar) {
0: 				case MINUS:
0: 					readSingleLineComment(nextChar);
0: 					break;
0: 				case SINGLEQUOTE:
0: 				case DOUBLEQUOTE:
0: 					readString(nextChar);
0: 					break;
0: 				case SEMICOLON:
0: 					haveSemi = true;
0: 					state = END_OF_STATEMENT;
0: 					break;
0: 				default:
0: 					// keep going, just a normal character
0: 					break;
0: 			}
0: 		}
0: 
0: 		if (haveSemi)
0: 			statement.setLength(statement.length()-1);
0: 		return statement.toString();
0: 	}
0: 
0: 	/**
0: 		Determine if the given character is considered whitespace
0: 
0: 		@param c the character to consider
0: 		@return true if the character is whitespace
0: 	 */
0: 	private boolean whiteSpace(char c) {
0: 		return (c == SPACE ||
0: 		    	c == TAB ||
0: 		    	c == RETURN ||
0: 		    	c == NEWLINE ||
0: 		    	c == FORMFEED);
0: 	}
0: 
0: 	/**
0: 		Advance the source stream to the end of a comment if it
0: 		is on one, assuming the first character of
0: 		a potential single line comment has been found.
0: 		If it is not a comment, do not advance the stream.
0: 		<p>
0: 		The form of a single line comment is, in regexp, XX.*$,
0: 		where XX is two instances of commentChar.
0: 
0: 		@param commentChar the character whose duplication signifies
0: 			the start of the comment.
0: 	 */
0: 	private void readSingleLineComment(char commentChar) {
0: 		char nextChar;
0: 
0: 		nextChar = peekChar();
0: 		// if next char is EOF, we are done.
0: 		if (peekEOF()) return;
0: 
0: 		// if nextChar is not a minus, it was just a normal minus,
0: 		// nothing special to do
0: 		if (nextChar != commentChar) return;
0: 
0: 		// we are really in a comment
0: 		readChar(); // grab the minus for real.
0: 
0: 		state = IN_SQLCOMMENT;
0: 		do {
0: 			nextChar = peekChar();
0: 			if (peekEOF()) {
0: 				// let the caller process the EOF, don't read it
0: 				state = IN_STATEMENT;
0: 				return;
0: 			}
0: 			switch (nextChar) {
0: 				case NEWLINE:
0: 				case RETURN:
0: 					readChar(); // okay to process the character
0: 					state = IN_STATEMENT;
0: 					return;
0: 				default:
0: 					readChar(); // process the character, still in comment
0: 					break;
0: 			}
0: 		} while (state == IN_SQLCOMMENT); // could be while true...
0: 	}
0: 
0: 	/**
0: 		Advance the stream to the end of the string.
0: 		Assumes the opening delimiter of the string has been read.
0: 		This handles the SQL ability to put the delimiter within
0: 		the string by doubling it, by reading those as two strings
0: 		sitting next to one another.  I.e, 'Mary''s lamb' is read
0: 		by this class as two strings, 'Mary' and 's lamb'.
0: 		<p>
0: 		The delimiter of the string is expected to be repeated at
0: 		its other end. If the other flavor of delimiter occurs within
0: 		the string, it is just a normal character within it.
0: 		<p>
0: 		All characters except the delimiter are permitted within the
0: 		string. If EOF is hit before the closing delimiter is found,
0: 		the end of the string is assumed. Parsers using this parser
0: 		will detect the error in that case and return appropriate messages.
0: 
0: 		@param stringDelimiter the starting and ending character
0: 			for the string being read.
0: 	 */
0: 	private void readString(char stringDelimiter) {
0: 		state = IN_STRING;
0: 		do {
0: 			char nextChar = readChar();
0: 
0: 			if (atEOF()) {
0: 				state = END_OF_INPUT;
0: 				return;
0: 			}
0: 
0: 			if (nextChar == stringDelimiter) {
0: 				// we've reached the end of the string
0: 				state = IN_STATEMENT;
0: 				return;
0: 			}
0: 
0: 			// still in string
0: 		} while (state == IN_STRING); // could be while true...
0: 	}
0: 
0: 	private boolean atEOF() {
0: 		return atEOF;
0: 	}
0: 
0: 	private boolean peekEOF() {
0: 		return peekEOF;
0: 	}
0: 
0: 	/**
0: 		return the next character in the source stream and
0: 		append it to the statement buffer.
0: 
0: 		@return the next character in the source stream.
0: 	 */
0: 	private char readChar() {
0: 		if (!peeked) peekChar();
0: 
0: 		peeked = false;
0: 		atEOF = peekEOF;
0: 
0: 		if (!atEOF) statement.append(peekChar);
0: 
0: 		return peekChar;
0: 	}
0: 
0: 	/**
0: 		return the next character in the source stream, without
0: 		advancing.
0: 
0: 		@return the next character in the source stream.
0: 	 */
0: 	private char peekChar() {
0: 		peeked = true;
0: 		char c = '\00';
0: 
0: 		try {
0: 		    int cInt;
0: 
0: 			// REMIND: this is assuming a flat ascii source file.
0: 			// will need to beef it up at some future point to
0: 			// understand whether the stream is ascii or something else.
0: 			cInt = source.read();
0: 			peekEOF = (cInt == -1);
0: 			if (!peekEOF) c = (char)cInt;
0: 		} catch (IOException ie) {
0: 			throw ijException.iOException(ie);
0: 		}
0: 
0: 		peekChar = c;
0: 		return c;
0: 	}
0: }
============================================================================