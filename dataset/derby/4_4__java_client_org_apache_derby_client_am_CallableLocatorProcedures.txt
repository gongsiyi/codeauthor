1:6de69bd: /*
2:6de69bd:  
1:6de69bd:    Derby - Class org.apache.derby.client.am.CallableLocatorProcedures
1:6de69bd:  
1:6de69bd:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6de69bd:    contributor license agreements.  See the NOTICE file distributed with
1:6de69bd:    this work for additional information regarding copyright ownership.
1:6de69bd:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6de69bd:    (the "License"); you may not use this file except in compliance with
1:6de69bd:    the License.  You may obtain a copy of the License at
1:6de69bd:  
1:6de69bd:       http://www.apache.org/licenses/LICENSE-2.0
1:6de69bd:  
1:6de69bd:    Unless required by applicable law or agreed to in writing, software
1:6de69bd:    distributed under the License is distributed on an "AS IS" BASIS,
1:6de69bd:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6de69bd:    See the License for the specific language governing permissions and
1:6de69bd:    limitations under the License.
1:6de69bd:  
1:6de69bd:  */
1:6de69bd: 
1:6de69bd: package org.apache.derby.client.am;
1:6de69bd: 
1:69e3d06: import java.sql.ResultSet;
1:69e3d06: import java.sql.Types;
1:b16fdc6: import org.apache.derby.shared.common.error.ExceptionUtil;
1:b16fdc6: import org.apache.derby.shared.common.reference.SQLState;
1:b16fdc6: 
1:6de69bd: /**
1:6de69bd:  * Contains the necessary methods to call the stored procedure that
1:6de69bd:  * operate on LOBs identified by locators.  An instance of this class
1:6de69bd:  * will be initialized with a <code>Connection</code> parameter and
1:6de69bd:  * all calls will be made on that connection.
1:6de69bd:  * <p>
1:6de69bd:  * The class makes sure that each procedure call is only prepared once
1:6de69bd:  * per instance.  Hence, it will keep references to
1:6de69bd:  * <code>CallableStatement</code> objects for procedures that have
1:6de69bd:  * been called through this instance.  This makes it possible to
1:6de69bd:  * prepare each procedure call only once per <code>Connection</code>.
1:6de69bd:  * <p> 
1:6de69bd:  * Since LOBs can not be parameters to stored procedures, the
1:6de69bd:  * framework should make sure that calls involving a byte[] or String
1:6de69bd:  * that does not fit in a VARCHAR (FOR BIT DATA), are split into
1:6de69bd:  * several calls each operating on a fragment of the LOB.
1:6de69bd:  *
1:475fc20:  * @see ClientConnection#locatorProcedureCall for an example of how to use
1:6de69bd:  * this class.
1:6de69bd:  */
1:6de69bd: class CallableLocatorProcedures 
1:6de69bd: {
1:b16fdc6:     //caches the information from a Stored Procedure
1:b16fdc6:     //call as to whether locator support is available in
1:b16fdc6:     //the server or not.
1:0326967:     private boolean isLocatorSupportAvailable = true;
1:b16fdc6:     
1:6de69bd:     // One member variable for each stored procedure that can be called.
1:6de69bd:     // Used to be able to only prepare each procedure call once per connection.
1:69e3d06:     private ClientCallableStatement blobCreateLocatorCall;
1:69e3d06:     private ClientCallableStatement blobReleaseLocatorCall;
1:69e3d06:     private ClientCallableStatement blobGetPositionFromLocatorCall;
1:69e3d06:     private ClientCallableStatement blobGetPositionFromBytesCall;
1:69e3d06:     private ClientCallableStatement blobGetLengthCall;
1:69e3d06:     private ClientCallableStatement blobGetBytesCall;
1:69e3d06:     private ClientCallableStatement blobSetBytesCall;
1:69e3d06:     private ClientCallableStatement blobTruncateCall;
1:69e3d06:     private ClientCallableStatement clobCreateLocatorCall;
1:69e3d06:     private ClientCallableStatement clobReleaseLocatorCall;
1:69e3d06:     private ClientCallableStatement clobGetPositionFromStringCall;
1:69e3d06:     private ClientCallableStatement clobGetPositionFromLocatorCall;
1:69e3d06:     private ClientCallableStatement clobGetLengthCall;
1:69e3d06:     private ClientCallableStatement clobGetSubStringCall;
1:69e3d06:     private ClientCallableStatement clobSetStringCall;
1:69e3d06:     private ClientCallableStatement clobTruncateCall;
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * The connection to be used when calling the stored procedures.
1:6de69bd:      */
1:69e3d06:     private final ClientConnection connection;
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Max size of byte[] and String parameters to procedures
1:6de69bd:      */
1:6de69bd:     private static final int VARCHAR_MAXWIDTH = 32672;
1:6de69bd: 
1:b16fdc6:     //Constant representing an invalid locator value
1:b16fdc6:     private static final int INVALID_LOCATOR = -1;
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Create an instance to be used for calling locator-based stored
1:6de69bd:      * procedures.
1:6de69bd:      *
1:6de69bd:      * @param conn the connection to be used to prepare calls.
1:6de69bd:      */
1:69e3d06:     CallableLocatorProcedures(ClientConnection conn)
1:6de69bd:     {
1:6de69bd:         this.connection = conn;
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Allocates an empty BLOB on server and returns its locator.  Any
1:6de69bd:      * subsequent operations on this BLOB value will be stored in temporary
1:6de69bd:      * space on the server.
1:6de69bd:      *
1:6de69bd:      * @return locator that identifies the created BLOB.
1:6de69bd:      */
1:6de69bd:     int blobCreateLocator() throws SqlException
1:6de69bd:     {
1:b16fdc6:         //The information on whether the locator support
1:b16fdc6:         //is available is cached in the boolean
1:b16fdc6:         //isLocatorSupportAvailable. If this is false
1:b16fdc6:         //we can return -1
1:b16fdc6:         if (!isLocatorSupportAvailable) {
1:b16fdc6:             return INVALID_LOCATOR;
1:b16fdc6:         }
1:b16fdc6:         
1:b16fdc6:         try {
1:51ef6db:             if (blobCreateLocatorCall == null ||
1:51ef6db:                     !blobCreateLocatorCall.openOnClient_) {
1:6de69bd:                 blobCreateLocatorCall = connection.prepareCallX
1:6de69bd:                         ("? = CALL SYSIBM.BLOBCREATELOCATOR()",
1:69e3d06:                         ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                         ResultSet.CONCUR_READ_ONLY,
1:6de69bd:                         connection.holdability());
1:6de69bd:                 blobCreateLocatorCall
1:69e3d06:                         .registerOutParameterX(1, Types.INTEGER);
1:6de69bd:                 // Make sure this statement does not commit user transaction
1:6de69bd:                 blobCreateLocatorCall.isAutoCommittableStatement_ = false;
1:6de69bd:             }
1:b16fdc6:             blobCreateLocatorCall.executeX();
1:b16fdc6:         }
1:b16fdc6:         catch(SqlException sqle) {
1:b16fdc6:             //An exception has occurred while calling the stored procedure
1:b16fdc6:             //used to create the locator value. 
1:b16fdc6:             
1:b16fdc6:             //We verify to see if this SqlException has a SQLState of
1:b16fdc6:             //42Y03(SQLState.LANG_NO_SUCH_METHOD_ALIAS)
1:b16fdc6:             //(corresponding to the stored procedure not being found)
1:b16fdc6:             
1:b16fdc6:             //This means that locator support is not available. 
1:b16fdc6:             
1:b16fdc6:             //This information is cached so that each time to determine
1:b16fdc6:             //if locator support is available we do not have to make a
1:b16fdc6:             //round trip to the server.
1:b16fdc6:             if (sqle.getSQLState().compareTo
1:b16fdc6:                     (ExceptionUtil.getSQLStateFromIdentifier
1:b16fdc6:                     (SQLState.LANG_NO_SUCH_METHOD_ALIAS)) == 0) {
1:b16fdc6:                 isLocatorSupportAvailable = false;
1:b16fdc6:                 return INVALID_LOCATOR;
1:b16fdc6:             }
1:b16fdc6:             else {
1:b16fdc6:                 //The SqlException has not occurred because of the
1:b16fdc6:                 //stored procedure not being found. Hence we simply throw
1:b16fdc6:                 //it back.
1:b16fdc6:                 throw sqle;
1:b16fdc6:             }
1:b16fdc6:         }
1:b16fdc6:         
1:6de69bd:         return blobCreateLocatorCall.getIntX(1);
1:6de69bd:     }
1:b16fdc6: 
1:6de69bd:     /**
1:6de69bd:      * This method frees the BLOB and releases the resources that it
1:6de69bd:      * holds. (E.g., temporary space used to store this BLOB on the server.)
1:6de69bd:      * @param locator locator that designates the BLOB to be released.
1:6de69bd:      */
1:6de69bd:     void blobReleaseLocator(int locator) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (blobReleaseLocatorCall == null ||
1:51ef6db:                 !blobReleaseLocatorCall.openOnClient_) {
1:6de69bd:             blobReleaseLocatorCall = connection.prepareCallX
1:6de69bd:                 ("CALL SYSIBM.BLOBRELEASELOCATOR(?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             blobReleaseLocatorCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         blobReleaseLocatorCall.setIntX(1, locator);
1:b16fdc6:         try {
1:6de69bd:             blobReleaseLocatorCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:6de69bd:         }
1:ec46920:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Retrieves the byte position in the BLOB value designated by this
1:6de69bd:      * <code>locator</code> at which pattern given by
1:6de69bd:      * <code>searchLocator</code> begins. The search begins at position
1:6de69bd:      * <code>fromPosition</code>.
1:6de69bd:      * @param locator locator that identifies the BLOB to be searched.
1:6de69bd:      * @param searchLocator locator designating the BLOB value for which to
1:6de69bd:      *        search
1:6de69bd:      * @param fromPosition the position in the BLOB value
1:6de69bd:      *        at which to begin searching; the first position is 1
1:6de69bd:      * @return the position at which the pattern begins, else -1
1:6de69bd:      */
1:6de69bd:     long blobGetPositionFromLocator(int locator, 
1:6de69bd:                                     int searchLocator, 
1:6de69bd:                                     long fromPosition) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (blobGetPositionFromLocatorCall == null ||
1:51ef6db:                 !blobGetPositionFromLocatorCall.openOnClient_) {
1:6de69bd:             blobGetPositionFromLocatorCall = connection.prepareCallX
1:6de69bd:                 ("? = CALL SYSIBM.BLOBGETPOSITIONFROMLOCATOR(?, ?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             blobGetPositionFromLocatorCall
1:69e3d06:                 .registerOutParameterX(1, Types.BIGINT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             blobGetPositionFromLocatorCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         blobGetPositionFromLocatorCall.setIntX(2, locator);
1:6de69bd:         blobGetPositionFromLocatorCall.setIntX(3, searchLocator);
1:6de69bd:         blobGetPositionFromLocatorCall.setLongX(4, fromPosition);
1:5b7bb25:         try {
1:6de69bd:             blobGetPositionFromLocatorCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:5b7bb25:         }
1:6de69bd:         return blobGetPositionFromLocatorCall.getLongX(1);
1:6de69bd:     }
1:6de69bd: 
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Retrieves the byte position at which the specified byte array
1:6de69bd:      * <code>searchLiteral</code> begins within the <code>BLOB</code> value
1:6de69bd:      * identified by <code>locator</code>.  The search for
1:6de69bd:      * <code>searchLiteral</code> begins at position <code>fromPosition</code>.
1:6de69bd:      * <p>
1:6de69bd:      * If <code>searchLiteral</code> is longer than the maximum length of a
1:6de69bd:      * VARCHAR FOR BIT DATA, it will be split into smaller fragments, and
1:6de69bd:      * repeated procedure calls will be made to perform the entire search
1:6de69bd:      *
1:6de69bd:      * @param locator locator that identifies the BLOB to be searched.
1:6de69bd:      * @param searchLiteral the byte array for which to search
1:6de69bd:      * @param fromPosition the position at which to begin searching; the
1:6de69bd:      *        first position is 1
1:6de69bd:      * @return the position at which the pattern appears, else -1
1:6de69bd:      */
1:6de69bd:     long blobGetPositionFromBytes(int locator, 
1:6de69bd:                                   byte[] searchLiteral, 
1:6de69bd:                                   long fromPosition) throws SqlException
1:6de69bd:     {
1:6de69bd:         long blobLength = -1;  // Will be fetched from server if needed
1:6de69bd:         int patternLength = searchLiteral.length;
1:6de69bd: 
1:6de69bd:         // If searchLiteral needs to be partitioned, 
1:6de69bd:         // we may have to try several start positions
1:6de69bd:         do { 
1:6de69bd:             long foundAt = blobGetPositionFromBytes(locator, 
1:6de69bd:                                                     fromPosition,
1:6de69bd:                                                     searchLiteral, 
1:6de69bd:                                                     0,
1:6de69bd:                                                     VARCHAR_MAXWIDTH);
1:6de69bd: 
1:6de69bd:             // If searchLiteral is longer than VARCHAR_MAXWIDTH, 
1:6de69bd:             // we need to check the rest
1:6de69bd:             boolean tryAgain = false;
1:6de69bd:             if ((patternLength > VARCHAR_MAXWIDTH) && (foundAt > 0)) {
1:6de69bd:                 // First part of searchLiteral matched, check rest
1:6de69bd:                 int comparedSoFar = VARCHAR_MAXWIDTH;
1:6de69bd:                 while (comparedSoFar < patternLength) {
1:6de69bd:                     int numBytesThisRound 
1:6de69bd:                         = Math.min(patternLength - comparedSoFar, 
1:6de69bd:                                    VARCHAR_MAXWIDTH);
1:6de69bd:                     long pos = blobGetPositionFromBytes(locator,
1:6de69bd:                                                         foundAt + comparedSoFar,
1:6de69bd:                                                         searchLiteral,
1:6de69bd:                                                         comparedSoFar,
1:6de69bd:                                                         numBytesThisRound);
1:6de69bd: 
1:6de69bd:                     if (pos != (foundAt + comparedSoFar)) { 
1:6de69bd:                         // This part did not match
1:6de69bd:                         // Try to find a later match for the same prefix
1:6de69bd:                         tryAgain = true;
1:6de69bd:                         fromPosition = foundAt + 1;
1:6de69bd:                         break;
1:6de69bd:                     }
1:6de69bd: 
1:6de69bd:                     comparedSoFar += numBytesThisRound;
1:6de69bd:                 }
1:6de69bd:             }
1:6de69bd:             
1:6de69bd:             if (!tryAgain) return foundAt;
1:6de69bd: 
1:6de69bd:             // Need Blob length in order to determine when to stop
1:6de69bd:             if (blobLength < 0) {  
1:6de69bd:                 blobLength = blobGetLength(locator);
1:6de69bd:             }
1:6de69bd:         } while (fromPosition + patternLength <= blobLength);
1:6de69bd: 
1:6de69bd:         return -1;  // No match
1:6de69bd:     }
1:6de69bd:         
1:6de69bd:     
1:6de69bd:     /**
1:6de69bd:      * Retrieves the byte position at which the specified part of the byte
1:6de69bd:      * array <code>searchLiteral</code> begins within the <code>BLOB</code>
1:6de69bd:      * value identified by <code>locator</code>.  The search for
1:6de69bd:      * <code>searchLiteral</code> begins at position <code>fromPosition</code>.
1:6de69bd:      * <p>
1:6de69bd:      * This is a helper function used by blobGetPositionFromBytes(int, byte[],
1:6de69bd:      * long) for each call to the BLOBGETPOSITIONFROMBYTES procedure.
1:6de69bd:      *
1:6de69bd:      * @param locator locator that identifies the BLOB to be searched.
1:6de69bd:      * @param searchLiteral the byte array for which to search
1:6de69bd:      * @param fromPosition the position at which to begin searching; the
1:6de69bd:      *        first position is 1
1:6de69bd:      * @param offset the offset into the array <code>searchLiteral</code> at
1:6de69bd:      *        which the pattern to search for starts
1:6de69bd:      * @param length the number of bytes from the array of bytes
1:6de69bd:      *        <code>searchLiteral</code> to use for the pattern to search
1:6de69bd:      *        for. It is assumed that this length is smaller than the maximum
1:6de69bd:      *        size of a VARCHAR FOR BIT DATA column.  Otherwise, an exception
1:6de69bd:      *        will be thrown.
1:6de69bd:      * @return the position at which the pattern appears, else -1
1:6de69bd:      */
1:6de69bd:     private long blobGetPositionFromBytes(int locator,
1:6de69bd:                                           long fromPosition, 
1:6de69bd:                                           byte[] searchLiteral,
1:6de69bd:                                           int offset,
1:6de69bd:                                           int length) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (blobGetPositionFromBytesCall == null ||
1:51ef6db:                 !blobGetPositionFromBytesCall.openOnClient_) {
1:6de69bd:             blobGetPositionFromBytesCall = connection.prepareCallX
1:6de69bd:                 ("? = CALL SYSIBM.BLOBGETPOSITIONFROMBYTES(?, ?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             blobGetPositionFromBytesCall
1:69e3d06:                 .registerOutParameterX(1, Types.BIGINT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             blobGetPositionFromBytesCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd:         
1:6de69bd:         byte[] bytesToBeCompared = searchLiteral;
1:6de69bd:         int numBytes = Math.min(searchLiteral.length - offset, length);
1:6de69bd:         if (numBytes != bytesToBeCompared.length) {
1:6de69bd:             // Need an array that contains just what is to be sent
1:6de69bd:             bytesToBeCompared = new byte[numBytes];
1:6de69bd:             System.arraycopy(searchLiteral, offset,
1:6de69bd:                              bytesToBeCompared, 0, numBytes);
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         blobGetPositionFromBytesCall.setIntX(2, locator);
1:6de69bd:         blobGetPositionFromBytesCall.setBytesX(3, bytesToBeCompared);
1:6de69bd:         blobGetPositionFromBytesCall.setLongX(4, fromPosition);
1:5b7bb25:         try {
1:6de69bd:             blobGetPositionFromBytesCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:5b7bb25:         }
1:6de69bd:         return blobGetPositionFromBytesCall.getLongX(1);
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     
1:6de69bd:     /**
1:6de69bd:      * Returns the number of bytes in the <code>BLOB</code> value
1:6de69bd:      * designated by this <code>sourceLocator</code>.
1:6de69bd:      * 
1:6de69bd:      * @param sourceLocator locator that identifies the BLOB
1:6de69bd:      * @return length of the <code>BLOB</code> in bytes 
1:6de69bd:      */
1:6de69bd:     long blobGetLength(int sourceLocator) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (blobGetLengthCall == null || !blobGetLengthCall.openOnClient_) {
1:6de69bd:             blobGetLengthCall = connection.prepareCallX
1:6de69bd:                 ("? = CALL SYSIBM.BLOBGETLENGTH(?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:69e3d06:             blobGetLengthCall.registerOutParameterX(1, Types.BIGINT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             blobGetLengthCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         blobGetLengthCall.setIntX(2, sourceLocator);
1:5b7bb25:         try {
1:6de69bd:             blobGetLengthCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:5b7bb25:         }
1:6de69bd:         return blobGetLengthCall.getLongX(1);
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Retrieves all or part of the <code>BLOB</code> value that is identified
1:6de69bd:      * by <code>sourceLocator</code>, as an array of bytes.  This
1:6de69bd:      * <code>byte</code> array contains up to <code>forLength</code>
1:6de69bd:      * consecutive bytes starting at position <code>fromPosition</code>.
1:6de69bd:      * <p>
1:6de69bd:      * If <code>forLength</code> is larger than the maximum length of a VARCHAR
1:6de69bd:      * FOR BIT DATA, the reading of the BLOB will be split into repeated
1:6de69bd:      * procedure calls.
1:6de69bd:      *
1:6de69bd:      * @param sourceLocator locator that identifies the Blob to operate on
1:6de69bd:      * @param fromPosition the ordinal position of the first byte in the
1:6de69bd:      *        <code>BLOB</code> value to be extracted; the first byte is at
1:6de69bd:      *        position 1
1:6de69bd:      * @param forLength the number of consecutive bytes to be copied; the value
1:6de69bd:      *        for length must be 0 or greater.  Specifying a length that goes
1:6de69bd:      *        beyond the end of the BLOB (i.e., <code>fromPosition + forLength
1:dbed020:      *        &gt; blob.length()</code>), will result in an error.
1:6de69bd:      * @return a byte array containing up to <code>forLength</code> consecutive
1:6de69bd:      *         bytes from the <code>BLOB</code> value designated by
1:6de69bd:      *         <code>sourceLocator</code>, starting with the byte at position
1:6de69bd:      *         <code>fromPosition</code>
1:6de69bd:      */
1:6de69bd:     byte[] blobGetBytes(int sourceLocator, long fromPosition, int forLength) 
1:6de69bd:         throws SqlException
1:6de69bd:     {
1:6de69bd:         if (forLength == 0) return new byte[0];
1:6de69bd:         
1:51ef6db:         if (blobGetBytesCall == null || !blobGetBytesCall.openOnClient_) {
1:6de69bd:             blobGetBytesCall = connection.prepareCallX
1:6de69bd:                 ("? = CALL SYSIBM.BLOBGETBYTES(?, ?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:69e3d06:             blobGetBytesCall.registerOutParameterX(1, Types.VARBINARY);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             blobGetBytesCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         byte retVal[] = null;
1:6de69bd:         int gotSoFar = 0;
1:6de69bd:         while (gotSoFar < forLength) {
1:6de69bd:             blobGetBytesCall.setIntX(2, sourceLocator);
1:6de69bd:             blobGetBytesCall.setLongX(3, fromPosition + gotSoFar);
1:6de69bd:             blobGetBytesCall.setIntX(4, forLength - gotSoFar);
1:5b7bb25:             try {
1:6de69bd:                 blobGetBytesCall.executeX();
1:5b7bb25:             } catch (SqlException sqle) {
1:5b7bb25:                 sqle = handleInvalidLocator(sqle);
1:5b7bb25:                 throw sqle;
1:5b7bb25:             }
1:6de69bd:             byte[] result = blobGetBytesCall.getBytesX(1);
1:6de69bd:             
1:6de69bd:             if (gotSoFar == 0) {  // First round of reading
1:6de69bd:                 if (result.length == forLength) {  // Got everything
1:6de69bd:                     return result;
1:6de69bd:                 } else {
1:6de69bd:                     // Blob is probably greater than MAX VARCHAR length, need to
1:6de69bd:                     // read in parts, create array for putting pieces together
1:6de69bd:                     retVal = new byte[forLength];
1:6de69bd:                 }
1:6de69bd:             }
1:6de69bd:            
1:6de69bd:             // If not able to read more, stop
1:6de69bd:             if (result.length == 0) break;
1:6de69bd:             
1:6de69bd:             System.arraycopy(result, 0,
1:6de69bd:                              retVal, gotSoFar, result.length);
1:6de69bd:             gotSoFar += result.length;
1:6de69bd:         }
1:6de69bd:         return retVal;
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Writes all or part of the given <code>byte</code> array to the
1:6de69bd:      * <code>BLOB</code> value designated by <code>sourceLocator</code>.
1:6de69bd:      * Writing starts at position <code>fromPosition</code> in the
1:6de69bd:      * <code>BLOB</code> value; <code>forLength</code> bytes from the given
1:6de69bd:      * byte array are written. If the end of the <code>Blob</code> value is
1:6de69bd:      * reached while writing the array of bytes, then the length of the
1:6de69bd:      * <code>Blob</code> value will be increased to accomodate the extra bytes.
1:6de69bd:      * <p>
1:6de69bd:      * If <code>forLength</code> is larger than the maximum length of a VARCHAR
1:6de69bd:      * FOR BIT DATA, the writing to the BLOB value will be split into repeated
1:6de69bd:      * procedure calls.
1:6de69bd:      *
1:6de69bd:      * @param sourceLocator locator that identifies the Blob to operated on
1:6de69bd:      * @param fromPosition the position in the <code>BLOB</code> value at which
1:6de69bd:      *        to start writing; the first position is 1
1:6de69bd:      * @param forLength the number of bytes to be written to the
1:6de69bd:      *        <code>BLOB</code> value from the array of bytes
1:6de69bd:      *        <code>bytes</code>.  Specifying a length that goes beyond the end
1:dbed020:      *        of the BLOB (i.e., <code>fromPosition + forLength &gt;
1:6de69bd:      *        blob.length()</code>, will result in an error.
1:6de69bd:      * @param bytes the array of bytes to be written
1:6de69bd:      */
1:6de69bd:     void blobSetBytes(int sourceLocator, 
1:6de69bd:                       long fromPosition, 
1:6de69bd:                       int forLength, 
1:6de69bd:                       byte[] bytes) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (blobSetBytesCall == null || !blobSetBytesCall.openOnClient_) {
1:6de69bd:             blobSetBytesCall = connection.prepareCallX
1:6de69bd:                 ("CALL SYSIBM.BLOBSETBYTES(?, ?, ?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             blobSetBytesCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         int sentSoFar = 0;
1:6de69bd:         byte[] bytesToBeSent = bytes;
1:6de69bd:         while (sentSoFar < forLength) {
1:6de69bd:             // Only send what can fit in a VARCHAR FOR BIT DATA parameter
1:6de69bd:             int numBytesThisRound 
1:6de69bd:                 = Math.min(forLength - sentSoFar, VARCHAR_MAXWIDTH);
1:6de69bd:             if (numBytesThisRound != bytesToBeSent.length) {
1:6de69bd:                 // Need an array that contains just what is to be sent
1:6de69bd:                 bytesToBeSent = new byte[numBytesThisRound];                
1:6de69bd:             }
1:6de69bd:             if (bytesToBeSent != bytes) {
1:6de69bd:                 // Need to copy from original array
1:6de69bd:                 System.arraycopy(bytes, sentSoFar,
1:6de69bd:                                  bytesToBeSent, 0, numBytesThisRound);
1:6de69bd:             }
1:6de69bd:             
1:6de69bd:             blobSetBytesCall.setIntX(1, sourceLocator);
1:6de69bd:             blobSetBytesCall.setLongX(2, fromPosition + sentSoFar);
1:6de69bd:             blobSetBytesCall.setIntX(3, numBytesThisRound);
1:6de69bd:             blobSetBytesCall.setBytesX(4, bytesToBeSent);
1:5b7bb25:             try {
1:6de69bd:                 blobSetBytesCall.executeX();
1:5b7bb25:             } catch (SqlException sqle) {
1:5b7bb25:                 sqle = handleInvalidLocator(sqle);
1:5b7bb25:                 throw sqle;
1:5b7bb25:             }
1:6de69bd:             
1:6de69bd:             sentSoFar += numBytesThisRound;
1:6de69bd:         }
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Truncates the <code>BLOB</code> value identified by
1:74eba43:      * <code>sourceLocator</code> to be <code>length</code> bytes.  
1:74eba43:      * <p>
1:6de69bd:      * <b>Note:</b> If the value specified for <code>length</code> is greater
1:6de69bd:      * than the length+1 of the <code>BLOB</code> value then an
1:5b7bb25:      * <code>SqlException</code> will be thrown.
1:6de69bd:      * 
1:6de69bd:      * @param sourceLocator locator identifying the Blob to be truncated
1:6de69bd:      * @param length the length, in bytes, to which the <code>BLOB</code> value
1:6de69bd:      *        should be truncated
1:6de69bd:      */
1:6de69bd:     void blobTruncate(int sourceLocator, long length) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (blobTruncateCall == null || !blobTruncateCall.openOnClient_) {
1:6de69bd:             blobTruncateCall = connection.prepareCallX
1:6de69bd:                 ("CALL SYSIBM.BLOBTRUNCATE(?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             blobTruncateCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         blobTruncateCall.setIntX(1, sourceLocator);
1:6de69bd:         blobTruncateCall.setLongX(2, length);
1:5b7bb25:         try {
1:6de69bd:             blobTruncateCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:6de69bd:         }
1:5b7bb25:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Allocates an empty CLOB on server and returns its locator. Any
1:6de69bd:      * subsequent operations on this CLOB value will be stored in temporary
1:6de69bd:      * space on the server.
1:6de69bd:      * 
1:6de69bd:      * @return locator that identifies the created CLOB.
1:6de69bd:      */
1:6de69bd:     int clobCreateLocator() throws SqlException
1:6de69bd:     {
1:b16fdc6:         //The information on whether the locator support
1:b16fdc6:         //is available is cached in the boolean
1:b16fdc6:         //isLocatorSupportAvailable. If this is false
1:b16fdc6:         //we can return -1
1:b16fdc6:         if (!isLocatorSupportAvailable) {
1:b16fdc6:             return INVALID_LOCATOR;
1:b16fdc6:         }
1:b16fdc6:         
1:5b7bb25:         try {
1:51ef6db:             if (clobCreateLocatorCall == null ||
1:51ef6db:                     !clobCreateLocatorCall.openOnClient_) {
1:6de69bd:                 clobCreateLocatorCall = connection.prepareCallX
1:6de69bd:                         ("? = CALL SYSIBM.CLOBCREATELOCATOR()",
1:69e3d06:                         ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                         ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                         ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:                 clobCreateLocatorCall
1:69e3d06:                         .registerOutParameterX(1, Types.INTEGER);
1:6de69bd:                 // Make sure this statement does not commit user transaction
1:6de69bd:                 clobCreateLocatorCall.isAutoCommittableStatement_ = false;
1:b16fdc6:             }
1:b16fdc6:             clobCreateLocatorCall.executeX();
1:b16fdc6:         }
1:b16fdc6:         catch(SqlException sqle) {
1:b16fdc6:             //An exception has occurred while calling the stored procedure
1:b16fdc6:             //used to create the locator value. 
1:b16fdc6:             
1:b16fdc6:             //We verify to see if this SqlException has a SQLState of
1:b16fdc6:             //42Y03(SQLState.LANG_NO_SUCH_METHOD_ALIAS)
1:b16fdc6:             //(corresponding to the stored procedure not being found)
1:b16fdc6:             
1:b16fdc6:             //This means that locator support is not available. 
1:b16fdc6:             
1:b16fdc6:             //This information is cached so that each time to determine
1:b16fdc6:             //if locator support is available we do not have to make a
1:b16fdc6:             //round trip to the server.
1:b16fdc6:             if (sqle.getSQLState().compareTo
1:b16fdc6:                     (ExceptionUtil.getSQLStateFromIdentifier
1:b16fdc6:                     (SQLState.LANG_NO_SUCH_METHOD_ALIAS)) == 0) {
1:b16fdc6:                 isLocatorSupportAvailable = false;
1:b16fdc6:                 return INVALID_LOCATOR;
1:b16fdc6:             }
1:b16fdc6:             else {
1:b16fdc6:                 //The SqlException has not occurred because of the
1:b16fdc6:                 //stored procedure not being found. Hence we simply throw
1:b16fdc6:                 //it back.
1:b16fdc6:                 throw sqle;
1:b16fdc6:             }
1:6de69bd:         }
1:b16fdc6:         
1:6de69bd:         return clobCreateLocatorCall.getIntX(1);
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * This method frees the CLOB and releases the resources that it
1:6de69bd:      * holds. (E.g., temporary space used to store this CLOB on the server.)
1:6de69bd:      * @param locator locator that designates the CLOB to be released.
1:6de69bd:      */
1:6de69bd:     void clobReleaseLocator(int locator) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (clobReleaseLocatorCall == null ||
1:51ef6db:                 !clobReleaseLocatorCall.openOnClient_) {
1:6de69bd:             clobReleaseLocatorCall = connection.prepareCallX
1:6de69bd:                 ("CALL SYSIBM.CLOBRELEASELOCATOR(?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             clobReleaseLocatorCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         clobReleaseLocatorCall.setIntX(1, locator);
1:5b7bb25:         try {
1:6de69bd:             clobReleaseLocatorCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:6de69bd:         }
1:ec46920:     }
1:6de69bd: 
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Retrieves the character position at which the specified substring 
1:6de69bd:      * <code>searchLiteral</code> begins within the <code>CLOB</code> value
1:6de69bd:      * identified by <code>locator</code>.  The search for
1:6de69bd:      * <code>searchLiteral</code> begins at position <code>fromPosition</code>.
1:6de69bd:      * <p>
1:6de69bd:      * If <code>searchLiteral</code> is longer than the maximum length of a
1:6de69bd:      * VARCHAR, it will be split into smaller fragments, and
1:6de69bd:      * repeated procedure calls will be made to perform the entire search
1:6de69bd:      *
1:6de69bd:      * @param locator locator that identifies the CLOB to be searched.
1:6de69bd:      * @param searchLiteral the substring for which to search
1:6de69bd:      * @param fromPosition the position at which to begin searching; the
1:6de69bd:      *        first position is 1
1:6de69bd:      * @return the position at which the pattern appears, else -1
1:6de69bd:      */
1:6de69bd:     long clobGetPositionFromString(int locator, 
1:6de69bd:                                    String searchLiteral, 
1:6de69bd:                                    long fromPosition) throws SqlException
1:6de69bd:     {
1:6de69bd:         long clobLength = -1;  // Will be fetched from server if needed
1:6de69bd:         int patternLength = searchLiteral.length();
1:6de69bd:         do {
1:6de69bd:             long foundAt = clobGetPositionFromString(locator, 
1:6de69bd:                                                      fromPosition,
1:6de69bd:                                                      searchLiteral, 
1:6de69bd:                                                      0,
1:6de69bd:                                                      VARCHAR_MAXWIDTH);
1:6de69bd: 
1:6de69bd:             // If searchLiteral is longer than VARCHAR_MAXWIDTH, 
1:6de69bd:             // we need to check the rest
1:6de69bd:             boolean tryAgain = false;
1:6de69bd:             if ((patternLength > VARCHAR_MAXWIDTH) && (foundAt > 0)) {
1:6de69bd:                 // First part of searchLiteral matched, check rest
1:6de69bd:                 int comparedSoFar = VARCHAR_MAXWIDTH;
1:6de69bd:                 while (comparedSoFar < patternLength) {
1:6de69bd:                     int numCharsThisRound 
1:6de69bd:                         = Math.min(patternLength - comparedSoFar, 
1:6de69bd:                                    VARCHAR_MAXWIDTH);
1:6de69bd:                     long pos = clobGetPositionFromString(locator,
1:6de69bd:                                                          foundAt+comparedSoFar,
1:6de69bd:                                                          searchLiteral,
1:6de69bd:                                                          comparedSoFar,
1:6de69bd:                                                          numCharsThisRound);
1:6de69bd: 
1:6de69bd:                     if (pos != (foundAt + comparedSoFar)) { 
1:6de69bd:                         // This part did not match
1:6de69bd:                         // Try to find a later match for the same prefix
1:6de69bd:                         tryAgain = true;
1:6de69bd:                         fromPosition = foundAt + 1;
1:6de69bd:                         break;
1:6de69bd:                     }
1:6de69bd: 
1:6de69bd:                     comparedSoFar += numCharsThisRound;
1:6de69bd:                 }
1:6de69bd:             }
1:6de69bd:             
1:6de69bd:             if (!tryAgain) return foundAt;
1:6de69bd: 
1:6de69bd:             // Need Clob length in order to determine when to stop
1:6de69bd:             if (clobLength < 0) {  
1:6de69bd:                 clobLength = clobGetLength(locator);
1:6de69bd:             }
1:6de69bd:         } while (fromPosition + patternLength <= clobLength);
1:6de69bd: 
1:6de69bd:         return -1;  // No match
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * 
1:6de69bd:      * Retrieves the character position at which the specified part of the
1:6de69bd:      * substring <code>searchLiteral</code> begins within the <code>CLOB</code>
1:6de69bd:      * value identified by <code>locator</code>.  The search for
1:6de69bd:      * <code>searchLiteral</code> begins at position <code>fromPosition</code>.
1:74eba43:      * <p> 
1:74eba43:      * This is a helper function used by clobGetPositionFromString(int,
1:6de69bd:      * String, long) for each call to the CLOBGETPOSITIONFROMSTRING procedure.
1:6de69bd:      *
1:6de69bd:      * @param locator locator that identifies the CLOB to be searched.
1:6de69bd:      * @param searchLiteral the substring for which to search
1:6de69bd:      * @param fromPosition the position at which to begin searching; the
1:6de69bd:      *        first position is 1
1:6de69bd:      * @param offset the offset into the string <code>searchLiteral</code> at
1:6de69bd:      *        which the pattern to search for starts
1:6de69bd:      * @param length the number of characters from the string
1:6de69bd:      *        <code>searchLiteral</code> to use for the pattern to search
1:6de69bd:      *        for. It is assumed that this length is smaller than the maximum
1:6de69bd:      *        size of a VARCHAR column.  Otherwise, an exception will be
1:6de69bd:      *        thrown.
1:6de69bd:      * @return the position at which the pattern appears, else -1
1:6de69bd:      */
1:6de69bd:     private long clobGetPositionFromString(int locator, 
1:6de69bd:                                            long fromPosition,
1:6de69bd:                                            String searchLiteral, 
1:6de69bd:                                            int offset,
1:6de69bd:                                            int length) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (clobGetPositionFromStringCall == null ||
1:51ef6db:                 !clobGetPositionFromStringCall.openOnClient_) {
1:6de69bd:             clobGetPositionFromStringCall = connection.prepareCallX
1:6de69bd:                 ("? = CALL SYSIBM.CLOBGETPOSITIONFROMSTRING(?, ?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             clobGetPositionFromStringCall
1:69e3d06:                 .registerOutParameterX(1, Types.BIGINT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             clobGetPositionFromStringCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         String stringToBeCompared = searchLiteral;
1:6de69bd:         int numChars = Math.min(searchLiteral.length() - offset, length);
1:6de69bd:         if (numChars != stringToBeCompared.length()) {
1:6de69bd:             // Need a String that contains just what is to be sent
1:6de69bd:             stringToBeCompared 
1:6de69bd:                 = searchLiteral.substring(offset, offset + numChars);
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         clobGetPositionFromStringCall.setIntX(2, locator);
1:a6f48dd:         clobGetPositionFromStringCall.setStringX(3, stringToBeCompared);
1:6de69bd:         clobGetPositionFromStringCall.setLongX(4, fromPosition);
1:5b7bb25:         try {
1:6de69bd:             clobGetPositionFromStringCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:5b7bb25:         }
1:6de69bd:         return clobGetPositionFromStringCall.getLongX(1);
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Retrieves the character position in the CLOB value designated by this
1:6de69bd:      * <code>locator</code> at which substring given by
1:6de69bd:      * <code>searchLocator</code> begins. The search begins at position
1:6de69bd:      * <code>fromPosition</code>.
1:6de69bd:      * @param locator locator that identifies the CLOB to be searched.
1:6de69bd:      * @param searchLocator locator designating the CLOB value for which to
1:6de69bd:      *        search
1:6de69bd:      * @param fromPosition the position in the CLOB value
1:6de69bd:      *        at which to begin searching; the first position is 1
1:6de69bd:      * @return the position at which the pattern begins, else -1
1:6de69bd:      */
1:6de69bd:     long clobGetPositionFromLocator(int locator, 
1:6de69bd:                                     int searchLocator, 
1:6de69bd:                                     long fromPosition) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (clobGetPositionFromLocatorCall == null ||
1:51ef6db:                 !clobGetPositionFromLocatorCall.openOnClient_) {
1:6de69bd:             clobGetPositionFromLocatorCall = connection.prepareCallX
1:6de69bd:                 ("? = CALL SYSIBM.CLOBGETPOSITIONFROMLOCATOR(?, ?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             clobGetPositionFromLocatorCall
1:69e3d06:                 .registerOutParameterX(1, Types.BIGINT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             clobGetPositionFromLocatorCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         clobGetPositionFromLocatorCall.setIntX(2, locator);
1:6de69bd:         clobGetPositionFromLocatorCall.setIntX(3, searchLocator);
1:6de69bd:         clobGetPositionFromLocatorCall.setLongX(4, fromPosition);
1:5b7bb25:         try {
1:6de69bd:             clobGetPositionFromLocatorCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:5b7bb25:         }
1:6de69bd:         return clobGetPositionFromLocatorCall.getLongX(1);
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Returns the number of character in the <code>CLOB</code> value
1:6de69bd:      * designated by this <code>sourceLocator</code>.
1:6de69bd:      * 
1:6de69bd:      * @param sourceLocator locator that identifies the CLOB
1:6de69bd:      * @return length of the <code>CLOB</code> in characters 
1:6de69bd:      */
1:6de69bd:     long clobGetLength(int sourceLocator) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (clobGetLengthCall == null || !clobGetLengthCall.openOnClient_) {
1:6de69bd:             clobGetLengthCall = connection.prepareCallX
1:6de69bd:                 ("? = CALL SYSIBM.CLOBGETLENGTH(?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:69e3d06:             clobGetLengthCall.registerOutParameterX(1, Types.BIGINT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             clobGetLengthCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         clobGetLengthCall.setIntX(2, sourceLocator);
1:5b7bb25:         try {
1:6de69bd:             clobGetLengthCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:5b7bb25:         }
1:6de69bd:         return clobGetLengthCall.getLongX(1);
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Retrieves all or part of the <code>CLOB</code> value that is identified
1:6de69bd:      * by <code>sourceLocator</code>, as a <code>String</code>.  This
1:6de69bd:      * <code>String</code> contains up to <code>forLength</code> consecutive
1:6de69bd:      * characters starting at position <code>fromPosition</code>.  
1:6de69bd:      * <p> 
1:6de69bd:      * If <code>forLength</code> is larger than the maximum length of a
1:6de69bd:      * VARCHAR, the reading of the CLOB will be split into repeated procedure
1:6de69bd:      * calls.
1:6de69bd:      *
1:6de69bd:      * @param sourceLocator locator that identifies the CLOB to operate on
1:6de69bd:      * @param fromPosition the ordinal position of the first character in the
1:6de69bd:      *        <code>CLOB</code> value to be extracted; the first character is
1:6de69bd:      *        at position 1
1:6de69bd:      * @param forLength the number of consecutive characters to be copied; the
1:6de69bd:      *        value for length must be 0 or greater.  Specifying a length that
1:6de69bd:      *        goes beyond the end of the CLOB (i.e., <code>fromPosition +
1:dbed020:      *        forLength &gt; clob.length()</code>, will result in an error.
1:6de69bd:      * @return a string containing up to <code>forLength</code> consecutive
1:6de69bd:      *         characters from the <code>CLOB</code> value designated by
1:6de69bd:      *         <code>sourceLocator</code>, starting with the character at
1:6de69bd:      *         position <code>fromPosition</code>
1:6de69bd:      */
1:6de69bd:     String clobGetSubString(int sourceLocator, long fromPosition, int forLength)
1:6de69bd:         throws SqlException
1:6de69bd:     {
1:74eba43:         if (forLength == 0) return "";
1:6de69bd: 
1:51ef6db:         if (clobGetSubStringCall == null ||
1:51ef6db:                 !clobGetSubStringCall.openOnClient_) {
1:6de69bd:             clobGetSubStringCall = connection.prepareCallX
1:6de69bd:                 ("? = CALL SYSIBM.CLOBGETSUBSTRING(?, ?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             clobGetSubStringCall
1:69e3d06:                 .registerOutParameterX(1, Types.VARCHAR);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             clobGetSubStringCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         StringBuffer retVal = null;
1:6de69bd:         int gotSoFar = 0;
1:6de69bd:         while (gotSoFar < forLength) {
1:6de69bd:             clobGetSubStringCall.setIntX(2, sourceLocator);
1:6de69bd:             clobGetSubStringCall.setLongX(3, fromPosition + gotSoFar);
1:6de69bd:             clobGetSubStringCall.setIntX(4, forLength - gotSoFar);
1:5b7bb25:             try {
1:6de69bd:                 clobGetSubStringCall.executeX();
1:5b7bb25:             } catch (SqlException sqle) {
1:5b7bb25:                 sqle = handleInvalidLocator(sqle);
1:5b7bb25:                 throw sqle;
1:5b7bb25:             }
1:6de69bd:             String result =  clobGetSubStringCall.getStringX(1);
1:6de69bd: 
1:6de69bd:             if (gotSoFar == 0) {  // First round of reading
1:6de69bd:                 if (result.length() == forLength) {  // Got everything
1:6de69bd:                     return result;
1:6de69bd:                 } else {
1:6de69bd:                     // Clob is probably greater than MAX VARCHAR length, 
1:6de69bd:                     // need to read it in parts, 
1:6de69bd:                     // create StringBuffer for putting pieces together
1:6de69bd:                     retVal = new StringBuffer(forLength);
1:6de69bd:                 }
1:6de69bd:             }
1:6de69bd:            
1:6de69bd:             // If not able to read more, stop
1:6de69bd:             if (result.length() == 0) break;
1:6de69bd:             
1:6de69bd:             retVal.append(result);
1:6de69bd:             gotSoFar += result.length();
1:6de69bd:         }
1:6de69bd:         return retVal.toString();
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Writes all or part of the given <code>String</code> to the
1:6de69bd:      * <code>CLOB</code> value designated by <code>sourceLocator</code>.
1:6de69bd:      * Writing starts at position <code>fromPosition</code> in the
1:6de69bd:      * <code>CLOB</code> value; <code>forLength</code> characters from the
1:69e3d06:      * given string are written. If the end of the <code>CLOB</code> value is
1:6de69bd:      * reached while writing the string, then the length of the
1:69e3d06:      * <code>CLOB</code> value will be increased to accomodate the extra
1:6de69bd:      * characters.
1:6de69bd:      * <p> 
1:6de69bd:      * If <code>forLength</code> is larger than the maximum length of a
1:6de69bd:      * VARCHAR, the writing to the CLOB value will be split into repeated
1:6de69bd:      * procedure calls.
1:6de69bd:      *
1:69e3d06:      * @param sourceLocator locator that identifies the CLOB to operated on
1:6de69bd:      * @param fromPosition the position in the <code>CLOB</code> value at which
1:6de69bd:      *        to start writing; the first position is 1
1:6de69bd:      * @param forLength the number of characters to be written to the
1:6de69bd:      *        <code>CLOB</code> value from the string <code>string</code>.
1:6de69bd:      *        Specifying a length that goes beyond the end of the CLOB (i.e.,
1:dbed020:      *        <code>fromPosition + forLength &gt; clob.length()</code>, will
1:6de69bd:      *        result in an error.
1:6de69bd:      * @param string the string to be written
1:6de69bd:      */
1:6de69bd:     void clobSetString(int sourceLocator, 
1:6de69bd:                        long fromPosition, 
1:6de69bd:                        int forLength, 
1:6de69bd:                        String string) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (clobSetStringCall == null || !clobSetStringCall.openOnClient_) {
1:6de69bd:             clobSetStringCall = connection.prepareCallX
1:6de69bd:                 ("CALL SYSIBM.CLOBSETSTRING(?, ?, ?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             clobSetStringCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         int sentSoFar = 0;
1:6de69bd:         String stringToBeSent = string;
1:6de69bd:         while (sentSoFar < forLength) {
1:6de69bd:             // Only send what can fit in a VARCHAR parameter
1:6de69bd:             int numCharsThisRound 
1:6de69bd:                 = Math.min(forLength - sentSoFar, VARCHAR_MAXWIDTH);
1:6de69bd:             if (numCharsThisRound < string.length()) {
1:6de69bd:                 // Need a String that contains just what is to be sent
1:6de69bd:                 stringToBeSent 
1:6de69bd:                     = string.substring(sentSoFar, sentSoFar+numCharsThisRound);
1:6de69bd:             }
1:6de69bd:             
1:6de69bd:             clobSetStringCall.setIntX(1, sourceLocator);
1:6de69bd:             clobSetStringCall.setLongX(2, fromPosition + sentSoFar);
1:6de69bd:             clobSetStringCall.setIntX(3, numCharsThisRound);
1:6de69bd:             clobSetStringCall.setStringX(4, stringToBeSent);
1:5b7bb25:             try {
1:6de69bd:                 clobSetStringCall.executeX();
1:5b7bb25:             } catch (SqlException sqle) {
1:5b7bb25:                 sqle = handleInvalidLocator(sqle);
1:5b7bb25:                 throw sqle;
1:5b7bb25:             }
1:6de69bd: 
1:6de69bd:             sentSoFar += numCharsThisRound;
1:6de69bd:         }
1:6de69bd:     }
1:6de69bd: 
1:6de69bd:     /**
1:6de69bd:      * Truncates the <code>CLOB</code> value identified by
1:6de69bd:      * <code>sourceLocator</code> to be <code>length</code> characters.  
1:6de69bd:      * <p>
1:6de69bd:      * <b>Note:</b> If the value specified for <code>length</code> is greater
1:6de69bd:      * than the length+1 of the <code>CLOB</code> value then an
1:5b7bb25:      * <code>SqlException</code> will be thrown.
1:6de69bd:      * 
1:69e3d06:      * @param sourceLocator locator identifying the CLOB to be truncated
1:6de69bd:      * @param length the length, in characters, to which the <code>CLOB</code>
1:6de69bd:      *        value should be truncated
1:6de69bd:      */
1:6de69bd:     void clobTruncate(int sourceLocator, long length) throws SqlException
1:6de69bd:     {
1:51ef6db:         if (clobTruncateCall == null || !clobTruncateCall.openOnClient_) {
1:6de69bd:             clobTruncateCall = connection.prepareCallX
1:6de69bd:                 ("CALL SYSIBM.CLOBTRUNCATE(?, ?)",
1:69e3d06:                  ResultSet.TYPE_FORWARD_ONLY,
1:69e3d06:                  ResultSet.CONCUR_READ_ONLY,
1:69e3d06:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:6de69bd:             // Make sure this statement does not commit user transaction
1:6de69bd:             clobTruncateCall.isAutoCommittableStatement_ = false;
1:6de69bd:         }
1:6de69bd: 
1:6de69bd:         clobTruncateCall.setIntX(1, sourceLocator);
1:6de69bd:         clobTruncateCall.setLongX(2, length);
1:5b7bb25:         try {
1:6de69bd:             clobTruncateCall.executeX();
1:5b7bb25:         } catch (SqlException sqle) {
1:5b7bb25:             sqle = handleInvalidLocator(sqle);
1:5b7bb25:             throw sqle;
1:6de69bd:         }
1:6de69bd:     }
1:6de69bd: 
1:5b7bb25:     /**
1:5b7bb25:      * If the given exception indicates that locator was not valid, we
1:5b7bb25:      * assume the locator has been garbage-collected due to
1:5b7bb25:      * transaction commit, and wrap the exception in an exception with
1:855f0de:      * SQL state <code>LOB_OBJECT_INVALID</code>.
1:5b7bb25:      * @param sqle Exception to be checked
1:5b7bb25:      * @return If <code>sqle</code> indicates that locator was
1:5b7bb25:      *         invalid, an <code>SqlException</code> with SQL state
1:855f0de:      *         <code>LOB_OBJECT_INVALID</code>. Otherwise, the
1:5b7bb25:      *         incoming exception is returned.
1:5b7bb25:      */
1:5b7bb25:     private SqlException handleInvalidLocator(SqlException sqle)
1:5b7bb25:     {
1:855f0de:         SqlException ex = sqle;
1:855f0de:         while (ex != null) {
1:855f0de:             if (ex.getSQLState().compareTo
1:5b7bb25:                 (ExceptionUtil.getSQLStateFromIdentifier
1:855f0de:                  (SQLState.LOB_LOCATOR_INVALID)) == 0) {
1:855f0de:                 return new SqlException(connection.agent_.logWriter_,
1:855f0de:                                new ClientMessageId(SQLState.LOB_OBJECT_INVALID),
1:855f0de:                                null,
1:855f0de:                                sqle);
1:855f0de:             }
1:855f0de:             ex = ex.getNextException();
1:5b7bb25:         }
1:6de69bd: 
1:855f0de:         // LOB_LOCATOR_INVALID not found, return original exception
1:855f0de:         return sqle;
1:5b7bb25:     }
3:5b7bb25: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      *        &gt; blob.length()</code>), will result in an error.
/////////////////////////////////////////////////////////////////////////
1:      *        of the BLOB (i.e., <code>fromPosition + forLength &gt;
/////////////////////////////////////////////////////////////////////////
1:      *        forLength &gt; clob.length()</code>, will result in an error.
/////////////////////////////////////////////////////////////////////////
1:      *        <code>fromPosition + forLength &gt; clob.length()</code>, will
commit:b16fdc6
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.error.ExceptionUtil;
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
1:     //caches the information from a Stored Procedure
1:     //call as to whether locator support is available in
1:     //the server or not.
0:     boolean isLocatorSupportAvailable = true;
1:     
/////////////////////////////////////////////////////////////////////////
1:     //Constant representing an invalid locator value
1:     private static final int INVALID_LOCATOR = -1;
/////////////////////////////////////////////////////////////////////////
1:         //The information on whether the locator support
1:         //is available is cached in the boolean
1:         //isLocatorSupportAvailable. If this is false
1:         //we can return -1
1:         if (!isLocatorSupportAvailable) {
1:             return INVALID_LOCATOR;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         
1:         try {
1:             blobCreateLocatorCall.executeX();
1:         }
1:         catch(SqlException sqle) {
1:             //An exception has occurred while calling the stored procedure
1:             //used to create the locator value. 
1:             
1:             //We verify to see if this SqlException has a SQLState of
1:             //42Y03(SQLState.LANG_NO_SUCH_METHOD_ALIAS)
1:             //(corresponding to the stored procedure not being found)
1:             
1:             //This means that locator support is not available. 
1:             
1:             //This information is cached so that each time to determine
1:             //if locator support is available we do not have to make a
1:             //round trip to the server.
1:             if (sqle.getSQLState().compareTo
1:                     (ExceptionUtil.getSQLStateFromIdentifier
1:                     (SQLState.LANG_NO_SUCH_METHOD_ALIAS)) == 0) {
1:                 isLocatorSupportAvailable = false;
1:                 return INVALID_LOCATOR;
1:             }
1:             else {
1:                 //The SqlException has not occurred because of the
1:                 //stored procedure not being found. Hence we simply throw
1:                 //it back.
1:                 throw sqle;
1:             }
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         //The information on whether the locator support
1:         //is available is cached in the boolean
1:         //isLocatorSupportAvailable. If this is false
1:         //we can return -1
1:         if (!isLocatorSupportAvailable) {
1:             return INVALID_LOCATOR;
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             clobCreateLocatorCall.executeX();
1:         }
1:         catch(SqlException sqle) {
1:             //An exception has occurred while calling the stored procedure
1:             //used to create the locator value. 
1:             
1:             //We verify to see if this SqlException has a SQLState of
1:             //42Y03(SQLState.LANG_NO_SUCH_METHOD_ALIAS)
1:             //(corresponding to the stored procedure not being found)
1:             
1:             //This means that locator support is not available. 
1:             
1:             //This information is cached so that each time to determine
1:             //if locator support is available we do not have to make a
1:             //round trip to the server.
1:             if (sqle.getSQLState().compareTo
1:                     (ExceptionUtil.getSQLStateFromIdentifier
1:                     (SQLState.LANG_NO_SUCH_METHOD_ALIAS)) == 0) {
1:                 isLocatorSupportAvailable = false;
1:                 return INVALID_LOCATOR;
1:             }
1:             else {
1:                 //The SqlException has not occurred because of the
1:                 //stored procedure not being found. Hence we simply throw
1:                 //it back.
1:                 throw sqle;
1:             }
1:         }
1:         
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     private boolean isLocatorSupportAvailable = true;
commit:475fc20
/////////////////////////////////////////////////////////////////////////
1:  * @see ClientConnection#locatorProcedureCall for an example of how to use
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1:     private ClientCallableStatement blobCreateLocatorCall;
1:     private ClientCallableStatement blobReleaseLocatorCall;
1:     private ClientCallableStatement blobGetPositionFromLocatorCall;
1:     private ClientCallableStatement blobGetPositionFromBytesCall;
1:     private ClientCallableStatement blobGetLengthCall;
1:     private ClientCallableStatement blobGetBytesCall;
1:     private ClientCallableStatement blobSetBytesCall;
1:     private ClientCallableStatement blobTruncateCall;
1:     private ClientCallableStatement clobCreateLocatorCall;
1:     private ClientCallableStatement clobReleaseLocatorCall;
1:     private ClientCallableStatement clobGetPositionFromStringCall;
1:     private ClientCallableStatement clobGetPositionFromLocatorCall;
1:     private ClientCallableStatement clobGetLengthCall;
1:     private ClientCallableStatement clobGetSubStringCall;
1:     private ClientCallableStatement clobSetStringCall;
1:     private ClientCallableStatement clobTruncateCall;
1:     private final ClientConnection connection;
/////////////////////////////////////////////////////////////////////////
1:     CallableLocatorProcedures(ClientConnection conn)
/////////////////////////////////////////////////////////////////////////
1:                         ResultSet.TYPE_FORWARD_ONLY,
1:                         ResultSet.CONCUR_READ_ONLY,
1:                         .registerOutParameterX(1, Types.INTEGER);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:                 .registerOutParameterX(1, Types.BIGINT);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:                 .registerOutParameterX(1, Types.BIGINT);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             blobGetLengthCall.registerOutParameterX(1, Types.BIGINT);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             blobGetBytesCall.registerOutParameterX(1, Types.VARBINARY);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
/////////////////////////////////////////////////////////////////////////
1:                         ResultSet.TYPE_FORWARD_ONLY,
1:                         ResultSet.CONCUR_READ_ONLY,
1:                         ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:                         .registerOutParameterX(1, Types.INTEGER);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:                 .registerOutParameterX(1, Types.BIGINT);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:                 .registerOutParameterX(1, Types.BIGINT);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             clobGetLengthCall.registerOutParameterX(1, Types.BIGINT);
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:                 .registerOutParameterX(1, Types.VARCHAR);
/////////////////////////////////////////////////////////////////////////
1:      * given string are written. If the end of the <code>CLOB</code> value is
1:      * <code>CLOB</code> value will be increased to accomodate the extra
1:      * @param sourceLocator locator that identifies the CLOB to operated on
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
/////////////////////////////////////////////////////////////////////////
1:      * @param sourceLocator locator identifying the CLOB to be truncated
/////////////////////////////////////////////////////////////////////////
1:                  ResultSet.TYPE_FORWARD_ONLY,
1:                  ResultSet.CONCUR_READ_ONLY,
1:                  ResultSet.CLOSE_CURSORS_AT_COMMIT);
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:51ef6db
/////////////////////////////////////////////////////////////////////////
1:             if (blobCreateLocatorCall == null ||
1:                     !blobCreateLocatorCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (blobReleaseLocatorCall == null ||
1:                 !blobReleaseLocatorCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (blobGetPositionFromLocatorCall == null ||
1:                 !blobGetPositionFromLocatorCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (blobGetPositionFromBytesCall == null ||
1:                 !blobGetPositionFromBytesCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (blobGetLengthCall == null || !blobGetLengthCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (blobGetBytesCall == null || !blobGetBytesCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (blobSetBytesCall == null || !blobSetBytesCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (blobTruncateCall == null || !blobTruncateCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:             if (clobCreateLocatorCall == null ||
1:                     !clobCreateLocatorCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (clobReleaseLocatorCall == null ||
1:                 !clobReleaseLocatorCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (clobGetPositionFromStringCall == null ||
1:                 !clobGetPositionFromStringCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (clobGetPositionFromLocatorCall == null ||
1:                 !clobGetPositionFromLocatorCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (clobGetLengthCall == null || !clobGetLengthCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (clobGetSubStringCall == null ||
1:                 !clobGetSubStringCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (clobSetStringCall == null || !clobSetStringCall.openOnClient_) {
/////////////////////////////////////////////////////////////////////////
1:         if (clobTruncateCall == null || !clobTruncateCall.openOnClient_) {
commit:74eba43
/////////////////////////////////////////////////////////////////////////
0:  * @see Connection#locatorProcedureCall for an example of how to use
/////////////////////////////////////////////////////////////////////////
1:      * <code>sourceLocator</code> to be <code>length</code> bytes.  
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:      * <p> 
1:      * This is a helper function used by clobGetPositionFromString(int,
/////////////////////////////////////////////////////////////////////////
1:         if (forLength == 0) return "";
commit:6de69bd
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:    Derby - Class org.apache.derby.client.am.CallableLocatorProcedures
1:  
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derby.client.am;
1: 
1: /**
1:  * Contains the necessary methods to call the stored procedure that
1:  * operate on LOBs identified by locators.  An instance of this class
1:  * will be initialized with a <code>Connection</code> parameter and
1:  * all calls will be made on that connection.
1:  * <p>
1:  * The class makes sure that each procedure call is only prepared once
1:  * per instance.  Hence, it will keep references to
1:  * <code>CallableStatement</code> objects for procedures that have
1:  * been called through this instance.  This makes it possible to
1:  * prepare each procedure call only once per <code>Connection</code>.
1:  * <p> 
1:  * Since LOBs can not be parameters to stored procedures, the
1:  * framework should make sure that calls involving a byte[] or String
1:  * that does not fit in a VARCHAR (FOR BIT DATA), are split into
1:  * several calls each operating on a fragment of the LOB.
1:  *
0:  * @see Connection.locatorProcedureCall() for an example of how to use
1:  * this class.
1:  */
1: class CallableLocatorProcedures 
1: {
1:     // One member variable for each stored procedure that can be called.
1:     // Used to be able to only prepare each procedure call once per connection.
0:     private CallableStatement blobCreateLocatorCall;
0:     private CallableStatement blobReleaseLocatorCall;
0:     private CallableStatement blobGetPositionFromLocatorCall;
0:     private CallableStatement blobGetPositionFromBytesCall;
0:     private CallableStatement blobGetLengthCall;
0:     private CallableStatement blobGetBytesCall;
0:     private CallableStatement blobSetBytesCall;
0:     private CallableStatement blobTruncateCall;
0:     private CallableStatement clobCreateLocatorCall;
0:     private CallableStatement clobReleaseLocatorCall;
0:     private CallableStatement clobGetPositionFromStringCall;
0:     private CallableStatement clobGetPositionFromLocatorCall;
0:     private CallableStatement clobGetLengthCall;
0:     private CallableStatement clobGetSubStringCall;
0:     private CallableStatement clobSetStringCall;
0:     private CallableStatement clobTruncateCall;
1: 
1:     /**
1:      * The connection to be used when calling the stored procedures.
1:      */
0:     private final Connection connection; 
1: 
1:     /**
1:      * Max size of byte[] and String parameters to procedures
1:      */
1:     private static final int VARCHAR_MAXWIDTH = 32672;
1: 
1: 
1:     /**
1:      * Create an instance to be used for calling locator-based stored
1:      * procedures.
1:      *
1:      * @param conn the connection to be used to prepare calls.
1:      */
0:     CallableLocatorProcedures(Connection conn) 
1:     {
1:         this.connection = conn;
1:     }
1: 
1:     /**
1:      * Allocates an empty BLOB on server and returns its locator.  Any
1:      * subsequent operations on this BLOB value will be stored in temporary
1:      * space on the server.
1:      *
0:      * @throws org.apache.derby.client.am.SqlException
1:      * @return locator that identifies the created BLOB.
1:      */
1:     int blobCreateLocator() throws SqlException
1:     {
0:         if (blobCreateLocatorCall == null) {
1:             blobCreateLocatorCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.BLOBCREATELOCATOR()",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
1:                  connection.holdability());
1:             blobCreateLocatorCall
0:                 .registerOutParameterX(1, java.sql.Types.INTEGER);
1:             // Make sure this statement does not commit user transaction
1:             blobCreateLocatorCall.isAutoCommittableStatement_ = false;
1:         }
1: 
0:         blobCreateLocatorCall.executeX();
1:         return blobCreateLocatorCall.getIntX(1);
1:     }
1: 
1:     /**
1:      * This method frees the BLOB and releases the resources that it
1:      * holds. (E.g., temporary space used to store this BLOB on the server.)
1:      * @param locator locator that designates the BLOB to be released.
0:      * @throws org.apache.derby.client.am.SqlException 
1:      */
1:     void blobReleaseLocator(int locator) throws SqlException
1:     {
0:         if (blobReleaseLocatorCall == null) {
1:             blobReleaseLocatorCall = connection.prepareCallX
1:                 ("CALL SYSIBM.BLOBRELEASELOCATOR(?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             // Make sure this statement does not commit user transaction
1:             blobReleaseLocatorCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         blobReleaseLocatorCall.setIntX(1, locator);
1:         blobReleaseLocatorCall.executeX();
1:     }
1: 
1:     /**
1:      * Retrieves the byte position in the BLOB value designated by this
1:      * <code>locator</code> at which pattern given by
1:      * <code>searchLocator</code> begins. The search begins at position
1:      * <code>fromPosition</code>.
1:      * @param locator locator that identifies the BLOB to be searched.
1:      * @param searchLocator locator designating the BLOB value for which to
1:      *        search
1:      * @param fromPosition the position in the BLOB value
1:      *        at which to begin searching; the first position is 1
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return the position at which the pattern begins, else -1
1:      */
1:     long blobGetPositionFromLocator(int locator, 
1:                                     int searchLocator, 
1:                                     long fromPosition) throws SqlException
1:     {
0:         if (blobGetPositionFromLocatorCall == null) {
1:             blobGetPositionFromLocatorCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.BLOBGETPOSITIONFROMLOCATOR(?, ?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             blobGetPositionFromLocatorCall
0:                 .registerOutParameterX(1, java.sql.Types.BIGINT);
1:             // Make sure this statement does not commit user transaction
1:             blobGetPositionFromLocatorCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         blobGetPositionFromLocatorCall.setIntX(2, locator);
1:         blobGetPositionFromLocatorCall.setIntX(3, searchLocator);
1:         blobGetPositionFromLocatorCall.setLongX(4, fromPosition);
1:         blobGetPositionFromLocatorCall.executeX();
1:         return blobGetPositionFromLocatorCall.getLongX(1);
1:     }
1: 
1: 
1:     /**
1:      * Retrieves the byte position at which the specified byte array
1:      * <code>searchLiteral</code> begins within the <code>BLOB</code> value
1:      * identified by <code>locator</code>.  The search for
1:      * <code>searchLiteral</code> begins at position <code>fromPosition</code>.
1:      * <p>
1:      * If <code>searchLiteral</code> is longer than the maximum length of a
1:      * VARCHAR FOR BIT DATA, it will be split into smaller fragments, and
1:      * repeated procedure calls will be made to perform the entire search
1:      *
1:      * @param locator locator that identifies the BLOB to be searched.
1:      * @param searchLiteral the byte array for which to search
1:      * @param fromPosition the position at which to begin searching; the
1:      *        first position is 1
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return the position at which the pattern appears, else -1
1:      */
1:     long blobGetPositionFromBytes(int locator, 
1:                                   byte[] searchLiteral, 
1:                                   long fromPosition) throws SqlException
1:     {
1:         long blobLength = -1;  // Will be fetched from server if needed
1:         int patternLength = searchLiteral.length;
1: 
1:         // If searchLiteral needs to be partitioned, 
1:         // we may have to try several start positions
1:         do { 
1:             long foundAt = blobGetPositionFromBytes(locator, 
1:                                                     fromPosition,
1:                                                     searchLiteral, 
1:                                                     0,
1:                                                     VARCHAR_MAXWIDTH);
1: 
1:             // If searchLiteral is longer than VARCHAR_MAXWIDTH, 
1:             // we need to check the rest
1:             boolean tryAgain = false;
1:             if ((patternLength > VARCHAR_MAXWIDTH) && (foundAt > 0)) {
1:                 // First part of searchLiteral matched, check rest
1:                 int comparedSoFar = VARCHAR_MAXWIDTH;
1:                 while (comparedSoFar < patternLength) {
1:                     int numBytesThisRound 
1:                         = Math.min(patternLength - comparedSoFar, 
1:                                    VARCHAR_MAXWIDTH);
1:                     long pos = blobGetPositionFromBytes(locator,
1:                                                         foundAt + comparedSoFar,
1:                                                         searchLiteral,
1:                                                         comparedSoFar,
1:                                                         numBytesThisRound);
1: 
1:                     if (pos != (foundAt + comparedSoFar)) { 
1:                         // This part did not match
1:                         // Try to find a later match for the same prefix
1:                         tryAgain = true;
1:                         fromPosition = foundAt + 1;
1:                         break;
1:                     }
1: 
1:                     comparedSoFar += numBytesThisRound;
1:                 }
1:             }
1:             
1:             if (!tryAgain) return foundAt;
1: 
1:             // Need Blob length in order to determine when to stop
1:             if (blobLength < 0) {  
1:                 blobLength = blobGetLength(locator);
1:             }
1:         } while (fromPosition + patternLength <= blobLength);
1: 
1:         return -1;  // No match
1:     }
1:         
1:     
1:     /**
1:      * Retrieves the byte position at which the specified part of the byte
1:      * array <code>searchLiteral</code> begins within the <code>BLOB</code>
1:      * value identified by <code>locator</code>.  The search for
1:      * <code>searchLiteral</code> begins at position <code>fromPosition</code>.
1:      * <p>
1:      * This is a helper function used by blobGetPositionFromBytes(int, byte[],
1:      * long) for each call to the BLOBGETPOSITIONFROMBYTES procedure.
1:      *
1:      * @param locator locator that identifies the BLOB to be searched.
1:      * @param searchLiteral the byte array for which to search
1:      * @param fromPosition the position at which to begin searching; the
1:      *        first position is 1
1:      * @param offset the offset into the array <code>searchLiteral</code> at
1:      *        which the pattern to search for starts
1:      * @param length the number of bytes from the array of bytes
1:      *        <code>searchLiteral</code> to use for the pattern to search
1:      *        for. It is assumed that this length is smaller than the maximum
1:      *        size of a VARCHAR FOR BIT DATA column.  Otherwise, an exception
1:      *        will be thrown.
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return the position at which the pattern appears, else -1
1:      */
1:     private long blobGetPositionFromBytes(int locator,
1:                                           long fromPosition, 
1:                                           byte[] searchLiteral,
1:                                           int offset,
1:                                           int length) throws SqlException
1:     {
0:         if (blobGetPositionFromBytesCall == null) {
1:             blobGetPositionFromBytesCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.BLOBGETPOSITIONFROMBYTES(?, ?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             blobGetPositionFromBytesCall
0:                 .registerOutParameterX(1, java.sql.Types.BIGINT);
1:             // Make sure this statement does not commit user transaction
1:             blobGetPositionFromBytesCall.isAutoCommittableStatement_ = false;
1:         }
1:         
1:         byte[] bytesToBeCompared = searchLiteral;
1:         int numBytes = Math.min(searchLiteral.length - offset, length);
1:         if (numBytes != bytesToBeCompared.length) {
1:             // Need an array that contains just what is to be sent
1:             bytesToBeCompared = new byte[numBytes];
1:             System.arraycopy(searchLiteral, offset,
1:                              bytesToBeCompared, 0, numBytes);
1:         }
1: 
1:         blobGetPositionFromBytesCall.setIntX(2, locator);
1:         blobGetPositionFromBytesCall.setBytesX(3, bytesToBeCompared);
1:         blobGetPositionFromBytesCall.setLongX(4, fromPosition);
1:         blobGetPositionFromBytesCall.executeX();
1:         return blobGetPositionFromBytesCall.getLongX(1);
1:     }
1: 
1:     
1:     /**
1:      * Returns the number of bytes in the <code>BLOB</code> value
1:      * designated by this <code>sourceLocator</code>.
1:      * 
1:      * @param sourceLocator locator that identifies the BLOB
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return length of the <code>BLOB</code> in bytes 
1:      */
1:     long blobGetLength(int sourceLocator) throws SqlException
1:     {
0:         if (blobGetLengthCall == null) {
1:             blobGetLengthCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.BLOBGETLENGTH(?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:             blobGetLengthCall.registerOutParameterX(1, java.sql.Types.BIGINT);
1:             // Make sure this statement does not commit user transaction
1:             blobGetLengthCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         blobGetLengthCall.setIntX(2, sourceLocator);
1:         blobGetLengthCall.executeX();
1:         return blobGetLengthCall.getLongX(1);
1:     }
1: 
1:     /**
1:      * Retrieves all or part of the <code>BLOB</code> value that is identified
1:      * by <code>sourceLocator</code>, as an array of bytes.  This
1:      * <code>byte</code> array contains up to <code>forLength</code>
1:      * consecutive bytes starting at position <code>fromPosition</code>.
1:      * <p>
1:      * If <code>forLength</code> is larger than the maximum length of a VARCHAR
1:      * FOR BIT DATA, the reading of the BLOB will be split into repeated
1:      * procedure calls.
1:      *
1:      * @param sourceLocator locator that identifies the Blob to operate on
1:      * @param fromPosition the ordinal position of the first byte in the
1:      *        <code>BLOB</code> value to be extracted; the first byte is at
1:      *        position 1
1:      * @param forLength the number of consecutive bytes to be copied; the value
1:      *        for length must be 0 or greater.  Specifying a length that goes
1:      *        beyond the end of the BLOB (i.e., <code>fromPosition + forLength
0:      *        > blob.length()</code>), will result in an error.
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return a byte array containing up to <code>forLength</code> consecutive
1:      *         bytes from the <code>BLOB</code> value designated by
1:      *         <code>sourceLocator</code>, starting with the byte at position
1:      *         <code>fromPosition</code>
1:      */
1:     byte[] blobGetBytes(int sourceLocator, long fromPosition, int forLength) 
1:         throws SqlException
1:     {
1:         if (forLength == 0) return new byte[0];
1:         
0:         if (blobGetBytesCall == null) {
1:             blobGetBytesCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.BLOBGETBYTES(?, ?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:             blobGetBytesCall.registerOutParameterX(1, java.sql.Types.VARBINARY);
1:             // Make sure this statement does not commit user transaction
1:             blobGetBytesCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         byte retVal[] = null;
1:         int gotSoFar = 0;
1:         while (gotSoFar < forLength) {
1:             blobGetBytesCall.setIntX(2, sourceLocator);
1:             blobGetBytesCall.setLongX(3, fromPosition + gotSoFar);
1:             blobGetBytesCall.setIntX(4, forLength - gotSoFar);
1:             blobGetBytesCall.executeX();
1:             byte[] result = blobGetBytesCall.getBytesX(1);
1:             
1:             if (gotSoFar == 0) {  // First round of reading
1:                 if (result.length == forLength) {  // Got everything
1:                     return result;
1:                 } else {
1:                     // Blob is probably greater than MAX VARCHAR length, need to
1:                     // read in parts, create array for putting pieces together
1:                     retVal = new byte[forLength];
1:                 }
1:             }
1:            
1:             // If not able to read more, stop
1:             if (result.length == 0) break;
1:             
1:             System.arraycopy(result, 0,
1:                              retVal, gotSoFar, result.length);
1:             gotSoFar += result.length;
1:         }
1:         return retVal;
1:     }
1: 
1:     /**
1:      * Writes all or part of the given <code>byte</code> array to the
1:      * <code>BLOB</code> value designated by <code>sourceLocator</code>.
1:      * Writing starts at position <code>fromPosition</code> in the
1:      * <code>BLOB</code> value; <code>forLength</code> bytes from the given
1:      * byte array are written. If the end of the <code>Blob</code> value is
1:      * reached while writing the array of bytes, then the length of the
1:      * <code>Blob</code> value will be increased to accomodate the extra bytes.
1:      * <p>
1:      * If <code>forLength</code> is larger than the maximum length of a VARCHAR
1:      * FOR BIT DATA, the writing to the BLOB value will be split into repeated
1:      * procedure calls.
1:      *
1:      * @param sourceLocator locator that identifies the Blob to operated on
1:      * @param fromPosition the position in the <code>BLOB</code> value at which
1:      *        to start writing; the first position is 1
1:      * @param forLength the number of bytes to be written to the
1:      *        <code>BLOB</code> value from the array of bytes
1:      *        <code>bytes</code>.  Specifying a length that goes beyond the end
0:      *        of the BLOB (i.e., <code>fromPosition + forLength >
1:      *        blob.length()</code>, will result in an error.
1:      * @param bytes the array of bytes to be written
0:      * @throws org.apache.derby.client.am.SqlException 
1:      */
1:     void blobSetBytes(int sourceLocator, 
1:                       long fromPosition, 
1:                       int forLength, 
1:                       byte[] bytes) throws SqlException
1:     {
0:         if (blobSetBytesCall == null) {
1:             blobSetBytesCall = connection.prepareCallX
1:                 ("CALL SYSIBM.BLOBSETBYTES(?, ?, ?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             // Make sure this statement does not commit user transaction
1:             blobSetBytesCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         int sentSoFar = 0;
1:         byte[] bytesToBeSent = bytes;
1:         while (sentSoFar < forLength) {
1:             // Only send what can fit in a VARCHAR FOR BIT DATA parameter
1:             int numBytesThisRound 
1:                 = Math.min(forLength - sentSoFar, VARCHAR_MAXWIDTH);
1:             if (numBytesThisRound != bytesToBeSent.length) {
1:                 // Need an array that contains just what is to be sent
1:                 bytesToBeSent = new byte[numBytesThisRound];                
1:             }
1:             if (bytesToBeSent != bytes) {
1:                 // Need to copy from original array
1:                 System.arraycopy(bytes, sentSoFar,
1:                                  bytesToBeSent, 0, numBytesThisRound);
1:             }
1:             
1:             blobSetBytesCall.setIntX(1, sourceLocator);
1:             blobSetBytesCall.setLongX(2, fromPosition + sentSoFar);
1:             blobSetBytesCall.setIntX(3, numBytesThisRound);
1:             blobSetBytesCall.setBytesX(4, bytesToBeSent);
1:             blobSetBytesCall.executeX();
1:             
1:             sentSoFar += numBytesThisRound;
1:         }
1:     }
1: 
1:     /**
1:      * Truncates the <code>BLOB</code> value identified by
0:      * <code>sourceLocator</code> to be <code>length</code> bytes.  <p>
1:      * <b>Note:</b> If the value specified for <code>length</code> is greater
1:      * than the length+1 of the <code>BLOB</code> value then an
0:      * <code>SQLException</code> will be thrown.
1:      * 
1:      * @param sourceLocator locator identifying the Blob to be truncated
1:      * @param length the length, in bytes, to which the <code>BLOB</code> value
1:      *        should be truncated
0:      * @throws org.apache.derby.client.am.SqlException 
1:      */
1:     void blobTruncate(int sourceLocator, long length) throws SqlException
1:     {
0:         if (blobTruncateCall == null) {
1:             blobTruncateCall = connection.prepareCallX
1:                 ("CALL SYSIBM.BLOBTRUNCATE(?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             // Make sure this statement does not commit user transaction
1:             blobTruncateCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         blobTruncateCall.setIntX(1, sourceLocator);
1:         blobTruncateCall.setLongX(2, length);
1:         blobTruncateCall.executeX();
1:     }
1: 
1:     /**
1:      * Allocates an empty CLOB on server and returns its locator. Any
1:      * subsequent operations on this CLOB value will be stored in temporary
1:      * space on the server.
1:      * 
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return locator that identifies the created CLOB.
1:      */
1:     int clobCreateLocator() throws SqlException
1:     {
0:         if (clobCreateLocatorCall == null) {
1:             clobCreateLocatorCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.CLOBCREATELOCATOR()",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             clobCreateLocatorCall
0:                 .registerOutParameterX(1, java.sql.Types.INTEGER);
1:             // Make sure this statement does not commit user transaction
1:             clobCreateLocatorCall.isAutoCommittableStatement_ = false;
1:         }
1: 
0:         clobCreateLocatorCall.executeX();
1:         return clobCreateLocatorCall.getIntX(1);
1:     }
1: 
1:     /**
1:      * This method frees the CLOB and releases the resources that it
1:      * holds. (E.g., temporary space used to store this CLOB on the server.)
1:      * @param locator locator that designates the CLOB to be released.
0:      * @throws org.apache.derby.client.am.SqlException 
1:      */
1:     void clobReleaseLocator(int locator) throws SqlException
1:     {
0:         if (clobReleaseLocatorCall == null) {
1:             clobReleaseLocatorCall = connection.prepareCallX
1:                 ("CALL SYSIBM.CLOBRELEASELOCATOR(?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             // Make sure this statement does not commit user transaction
1:             clobReleaseLocatorCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         clobReleaseLocatorCall.setIntX(1, locator);
1:         clobReleaseLocatorCall.executeX();
1:     }
1: 
1: 
1:     /**
1:      * Retrieves the character position at which the specified substring 
1:      * <code>searchLiteral</code> begins within the <code>CLOB</code> value
1:      * identified by <code>locator</code>.  The search for
1:      * <code>searchLiteral</code> begins at position <code>fromPosition</code>.
1:      * <p>
1:      * If <code>searchLiteral</code> is longer than the maximum length of a
1:      * VARCHAR, it will be split into smaller fragments, and
1:      * repeated procedure calls will be made to perform the entire search
1:      *
1:      * @param locator locator that identifies the CLOB to be searched.
1:      * @param searchLiteral the substring for which to search
1:      * @param fromPosition the position at which to begin searching; the
1:      *        first position is 1
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return the position at which the pattern appears, else -1
1:      */
1:     long clobGetPositionFromString(int locator, 
1:                                    String searchLiteral, 
1:                                    long fromPosition) throws SqlException
1:     {
1:         long clobLength = -1;  // Will be fetched from server if needed
1:         int patternLength = searchLiteral.length();
1:         do {
1:             long foundAt = clobGetPositionFromString(locator, 
1:                                                      fromPosition,
1:                                                      searchLiteral, 
1:                                                      0,
1:                                                      VARCHAR_MAXWIDTH);
1: 
1:             // If searchLiteral is longer than VARCHAR_MAXWIDTH, 
1:             // we need to check the rest
1:             boolean tryAgain = false;
1:             if ((patternLength > VARCHAR_MAXWIDTH) && (foundAt > 0)) {
1:                 // First part of searchLiteral matched, check rest
1:                 int comparedSoFar = VARCHAR_MAXWIDTH;
1:                 while (comparedSoFar < patternLength) {
1:                     int numCharsThisRound 
1:                         = Math.min(patternLength - comparedSoFar, 
1:                                    VARCHAR_MAXWIDTH);
1:                     long pos = clobGetPositionFromString(locator,
1:                                                          foundAt+comparedSoFar,
1:                                                          searchLiteral,
1:                                                          comparedSoFar,
1:                                                          numCharsThisRound);
1: 
1:                     if (pos != (foundAt + comparedSoFar)) { 
1:                         // This part did not match
1:                         // Try to find a later match for the same prefix
1:                         tryAgain = true;
1:                         fromPosition = foundAt + 1;
1:                         break;
1:                     }
1: 
1:                     comparedSoFar += numCharsThisRound;
1:                 }
1:             }
1:             
1:             if (!tryAgain) return foundAt;
1: 
1:             // Need Clob length in order to determine when to stop
1:             if (clobLength < 0) {  
1:                 clobLength = clobGetLength(locator);
1:             }
1:         } while (fromPosition + patternLength <= clobLength);
1: 
1:         return -1;  // No match
1:     }
1: 
1:     /**
1:      * 
1:      * Retrieves the character position at which the specified part of the
1:      * substring <code>searchLiteral</code> begins within the <code>CLOB</code>
1:      * value identified by <code>locator</code>.  The search for
1:      * <code>searchLiteral</code> begins at position <code>fromPosition</code>.
0:      * <p> This is a helper function used by clobGetPositionFromString(int,
1:      * String, long) for each call to the CLOBGETPOSITIONFROMSTRING procedure.
1:      *
1:      * @param locator locator that identifies the CLOB to be searched.
1:      * @param searchLiteral the substring for which to search
1:      * @param fromPosition the position at which to begin searching; the
1:      *        first position is 1
1:      * @param offset the offset into the string <code>searchLiteral</code> at
1:      *        which the pattern to search for starts
1:      * @param length the number of characters from the string
1:      *        <code>searchLiteral</code> to use for the pattern to search
1:      *        for. It is assumed that this length is smaller than the maximum
1:      *        size of a VARCHAR column.  Otherwise, an exception will be
1:      *        thrown.
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return the position at which the pattern appears, else -1
1:      */
1:     private long clobGetPositionFromString(int locator, 
1:                                            long fromPosition,
1:                                            String searchLiteral, 
1:                                            int offset,
1:                                            int length) throws SqlException
1:     {
0:         if (clobGetPositionFromStringCall == null) {
1:             clobGetPositionFromStringCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.CLOBGETPOSITIONFROMSTRING(?, ?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             clobGetPositionFromStringCall
0:                 .registerOutParameterX(1, java.sql.Types.BIGINT);
1:             // Make sure this statement does not commit user transaction
1:             clobGetPositionFromStringCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         String stringToBeCompared = searchLiteral;
1:         int numChars = Math.min(searchLiteral.length() - offset, length);
1:         if (numChars != stringToBeCompared.length()) {
1:             // Need a String that contains just what is to be sent
1:             stringToBeCompared 
1:                 = searchLiteral.substring(offset, offset + numChars);
1:         }
1: 
1:         clobGetPositionFromStringCall.setIntX(2, locator);
0:         clobGetPositionFromStringCall.setStringX(3, searchLiteral);
1:         clobGetPositionFromStringCall.setLongX(4, fromPosition);
1:         clobGetPositionFromStringCall.executeX();
1:         return clobGetPositionFromStringCall.getLongX(1);
1:     }
1: 
1:     /**
1:      * Retrieves the character position in the CLOB value designated by this
1:      * <code>locator</code> at which substring given by
1:      * <code>searchLocator</code> begins. The search begins at position
1:      * <code>fromPosition</code>.
1:      * @param locator locator that identifies the CLOB to be searched.
1:      * @param searchLocator locator designating the CLOB value for which to
1:      *        search
1:      * @param fromPosition the position in the CLOB value
1:      *        at which to begin searching; the first position is 1
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return the position at which the pattern begins, else -1
1:      */
1:     long clobGetPositionFromLocator(int locator, 
1:                                     int searchLocator, 
1:                                     long fromPosition) throws SqlException
1:     {
0:         if (clobGetPositionFromLocatorCall == null) {
1:             clobGetPositionFromLocatorCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.CLOBGETPOSITIONFROMLOCATOR(?, ?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             clobGetPositionFromLocatorCall
0:                 .registerOutParameterX(1, java.sql.Types.BIGINT);
1:             // Make sure this statement does not commit user transaction
1:             clobGetPositionFromLocatorCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         clobGetPositionFromLocatorCall.setIntX(2, locator);
1:         clobGetPositionFromLocatorCall.setIntX(3, searchLocator);
1:         clobGetPositionFromLocatorCall.setLongX(4, fromPosition);
1:         clobGetPositionFromLocatorCall.executeX();
1:         return clobGetPositionFromLocatorCall.getLongX(1);
1:     }
1: 
1:     /**
1:      * Returns the number of character in the <code>CLOB</code> value
1:      * designated by this <code>sourceLocator</code>.
1:      * 
1:      * @param sourceLocator locator that identifies the CLOB
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return length of the <code>CLOB</code> in characters 
1:      */
1:     long clobGetLength(int sourceLocator) throws SqlException
1:     {
0:         if (clobGetLengthCall == null) {
1:             clobGetLengthCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.CLOBGETLENGTH(?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:             clobGetLengthCall.registerOutParameterX(1, java.sql.Types.BIGINT);
1:             // Make sure this statement does not commit user transaction
1:             clobGetLengthCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         clobGetLengthCall.setIntX(2, sourceLocator);
1:         clobGetLengthCall.executeX();
1:         return clobGetLengthCall.getLongX(1);
1:     }
1: 
1:     /**
1:      * Retrieves all or part of the <code>CLOB</code> value that is identified
1:      * by <code>sourceLocator</code>, as a <code>String</code>.  This
1:      * <code>String</code> contains up to <code>forLength</code> consecutive
1:      * characters starting at position <code>fromPosition</code>.  
1:      * <p> 
1:      * If <code>forLength</code> is larger than the maximum length of a
1:      * VARCHAR, the reading of the CLOB will be split into repeated procedure
1:      * calls.
1:      *
1:      * @param sourceLocator locator that identifies the CLOB to operate on
1:      * @param fromPosition the ordinal position of the first character in the
1:      *        <code>CLOB</code> value to be extracted; the first character is
1:      *        at position 1
1:      * @param forLength the number of consecutive characters to be copied; the
1:      *        value for length must be 0 or greater.  Specifying a length that
1:      *        goes beyond the end of the CLOB (i.e., <code>fromPosition +
0:      *        forLength > clob.length()</code>, will result in an error.
0:      * @throws org.apache.derby.client.am.SqlException 
1:      * @return a string containing up to <code>forLength</code> consecutive
1:      *         characters from the <code>CLOB</code> value designated by
1:      *         <code>sourceLocator</code>, starting with the character at
1:      *         position <code>fromPosition</code>
1:      */
1:     String clobGetSubString(int sourceLocator, long fromPosition, int forLength)
1:         throws SqlException
1:     {
0:         if (forLength == 0) return new String("");
1: 
0:         if (clobGetSubStringCall == null) {
1:             clobGetSubStringCall = connection.prepareCallX
1:                 ("? = CALL SYSIBM.CLOBGETSUBSTRING(?, ?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             clobGetSubStringCall
0:                 .registerOutParameterX(1, java.sql.Types.VARCHAR);
1:             // Make sure this statement does not commit user transaction
1:             clobGetSubStringCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         StringBuffer retVal = null;
1:         int gotSoFar = 0;
1:         while (gotSoFar < forLength) {
1:             clobGetSubStringCall.setIntX(2, sourceLocator);
1:             clobGetSubStringCall.setLongX(3, fromPosition + gotSoFar);
1:             clobGetSubStringCall.setIntX(4, forLength - gotSoFar);
1:             clobGetSubStringCall.executeX();
1:             String result =  clobGetSubStringCall.getStringX(1);
1: 
1:             if (gotSoFar == 0) {  // First round of reading
1:                 if (result.length() == forLength) {  // Got everything
1:                     return result;
1:                 } else {
1:                     // Clob is probably greater than MAX VARCHAR length, 
1:                     // need to read it in parts, 
1:                     // create StringBuffer for putting pieces together
1:                     retVal = new StringBuffer(forLength);
1:                 }
1:             }
1:            
1:             // If not able to read more, stop
1:             if (result.length() == 0) break;
1:             
1:             retVal.append(result);
1:             gotSoFar += result.length();
1:         }
1:         return retVal.toString();
1:     }
1: 
1:     /**
1:      * Writes all or part of the given <code>String</code> to the
1:      * <code>CLOB</code> value designated by <code>sourceLocator</code>.
1:      * Writing starts at position <code>fromPosition</code> in the
1:      * <code>CLOB</code> value; <code>forLength</code> characters from the
0:      * given string are written. If the end of the <code>Clob</code> value is
1:      * reached while writing the string, then the length of the
0:      * <code>Clob</code> value will be increased to accomodate the extra
1:      * characters.
1:      * <p> 
1:      * If <code>forLength</code> is larger than the maximum length of a
1:      * VARCHAR, the writing to the CLOB value will be split into repeated
1:      * procedure calls.
1:      *
0:      * @param sourceLocator locator that identifies the Clob to operated on
1:      * @param fromPosition the position in the <code>CLOB</code> value at which
1:      *        to start writing; the first position is 1
1:      * @param forLength the number of characters to be written to the
1:      *        <code>CLOB</code> value from the string <code>string</code>.
1:      *        Specifying a length that goes beyond the end of the CLOB (i.e.,
0:      *        <code>fromPosition + forLength > clob.length()</code>, will
1:      *        result in an error.
1:      * @param string the string to be written
0:      * @throws org.apache.derby.client.am.SqlException 
1:      */
1:     void clobSetString(int sourceLocator, 
1:                        long fromPosition, 
1:                        int forLength, 
1:                        String string) throws SqlException
1:     {
0:         if (clobSetStringCall == null) {
1:             clobSetStringCall = connection.prepareCallX
1:                 ("CALL SYSIBM.CLOBSETSTRING(?, ?, ?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             // Make sure this statement does not commit user transaction
1:             clobSetStringCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         int sentSoFar = 0;
1:         String stringToBeSent = string;
1:         while (sentSoFar < forLength) {
1:             // Only send what can fit in a VARCHAR parameter
1:             int numCharsThisRound 
1:                 = Math.min(forLength - sentSoFar, VARCHAR_MAXWIDTH);
1:             if (numCharsThisRound < string.length()) {
1:                 // Need a String that contains just what is to be sent
1:                 stringToBeSent 
1:                     = string.substring(sentSoFar, sentSoFar+numCharsThisRound);
1:             }
1:             
1:             clobSetStringCall.setIntX(1, sourceLocator);
1:             clobSetStringCall.setLongX(2, fromPosition + sentSoFar);
1:             clobSetStringCall.setIntX(3, numCharsThisRound);
1:             clobSetStringCall.setStringX(4, stringToBeSent);
1:             clobSetStringCall.executeX();
1: 
1:             sentSoFar += numCharsThisRound;
1:         }
1:     }
1: 
1:     /**
1:      * Truncates the <code>CLOB</code> value identified by
1:      * <code>sourceLocator</code> to be <code>length</code> characters.  
1:      * <p>
1:      * <b>Note:</b> If the value specified for <code>length</code> is greater
1:      * than the length+1 of the <code>CLOB</code> value then an
0:      * <code>SQLException</code> will be thrown.
1:      * 
0:      * @param sourceLocator locator identifying the Clob to be truncated
1:      * @param length the length, in characters, to which the <code>CLOB</code>
1:      *        value should be truncated
0:      * @throws org.apache.derby.client.am.SqlException 
1:      */
1:     void clobTruncate(int sourceLocator, long length) throws SqlException
1:     {
0:         if (clobTruncateCall == null) {
1:             clobTruncateCall = connection.prepareCallX
1:                 ("CALL SYSIBM.CLOBTRUNCATE(?, ?)",
0:                  java.sql.ResultSet.TYPE_FORWARD_ONLY, 
0:                  java.sql.ResultSet.CONCUR_READ_ONLY, 
0:                  java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:             // Make sure this statement does not commit user transaction
1:             clobTruncateCall.isAutoCommittableStatement_ = false;
1:         }
1: 
1:         clobTruncateCall.setIntX(1, sourceLocator);
1:         clobTruncateCall.setLongX(2, length);
1:         clobTruncateCall.executeX();
1:     }
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:ec46920
/////////////////////////////////////////////////////////////////////////
0:             if (blobCreateLocatorCall == null) {
0:                 blobCreateLocatorCall = connection.prepareCallX
0:                         ("? = CALL SYSIBM.BLOBCREATELOCATOR()",
0:                         java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                         java.sql.ResultSet.CONCUR_READ_ONLY,
0:                         connection.holdability());
0:                 blobCreateLocatorCall
0:                         .registerOutParameterX(1, java.sql.Types.INTEGER);
0:                 // Make sure this statement does not commit user transaction
0:                 blobCreateLocatorCall.isAutoCommittableStatement_ = false;
1:             }
/////////////////////////////////////////////////////////////////////////
0:             if (clobCreateLocatorCall == null) {
0:                 clobCreateLocatorCall = connection.prepareCallX
0:                         ("? = CALL SYSIBM.CLOBCREATELOCATOR()",
0:                         java.sql.ResultSet.TYPE_FORWARD_ONLY,
0:                         java.sql.ResultSet.CONCUR_READ_ONLY,
0:                         java.sql.ResultSet.CLOSE_CURSORS_AT_COMMIT);
0:                 clobCreateLocatorCall
0:                         .registerOutParameterX(1, java.sql.Types.INTEGER);
0:                 // Make sure this statement does not commit user transaction
0:                 clobCreateLocatorCall.isAutoCommittableStatement_ = false;
1:             }
commit:855f0de
/////////////////////////////////////////////////////////////////////////
1:      * SQL state <code>LOB_OBJECT_INVALID</code>.
1:      *         <code>LOB_OBJECT_INVALID</code>. Otherwise, the
1:         SqlException ex = sqle;
1:         while (ex != null) {
1:             if (ex.getSQLState().compareTo
1:                  (SQLState.LOB_LOCATOR_INVALID)) == 0) {
1:                 return new SqlException(connection.agent_.logWriter_,
1:                                new ClientMessageId(SQLState.LOB_OBJECT_INVALID),
1:                                null,
1:                                sqle);
1:             }
1:             ex = ex.getNextException();
0: 
1:         // LOB_LOCATOR_INVALID not found, return original exception
1:         return sqle;
commit:a6f48dd
/////////////////////////////////////////////////////////////////////////
1:         clobGetPositionFromStringCall.setStringX(3, stringToBeCompared);
commit:5b7bb25
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             blobReleaseLocatorCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             blobGetPositionFromLocatorCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             blobGetPositionFromBytesCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             blobGetLengthCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 blobGetBytesCall.executeX();
1:             } catch (SqlException sqle) {
1:                 sqle = handleInvalidLocator(sqle);
1:                 throw sqle;
1:             }
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 blobSetBytesCall.executeX();
1:             } catch (SqlException sqle) {
1:                 sqle = handleInvalidLocator(sqle);
1:                 throw sqle;
1:             }
/////////////////////////////////////////////////////////////////////////
1:      * <code>SqlException</code> will be thrown.
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             blobTruncateCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             clobReleaseLocatorCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             clobGetPositionFromStringCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             clobGetPositionFromLocatorCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             clobGetLengthCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 clobGetSubStringCall.executeX();
1:             } catch (SqlException sqle) {
1:                 sqle = handleInvalidLocator(sqle);
1:                 throw sqle;
1:             }
/////////////////////////////////////////////////////////////////////////
1:             try {
0:                 clobSetStringCall.executeX();
1:             } catch (SqlException sqle) {
1:                 sqle = handleInvalidLocator(sqle);
1:                 throw sqle;
1:             }
/////////////////////////////////////////////////////////////////////////
1:      * <code>SqlException</code> will be thrown.
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             clobTruncateCall.executeX();
1:         } catch (SqlException sqle) {
1:             sqle = handleInvalidLocator(sqle);
1:             throw sqle;
1:         }
1:     }
0: 
1:     /**
1:      * If the given exception indicates that locator was not valid, we
1:      * assume the locator has been garbage-collected due to
1:      * transaction commit, and wrap the exception in an exception with
0:      * SQL state <code>BLOB_ACCESSED_AFTER_COMMIT</code>.
1:      * @param sqle Exception to be checked
1:      * @return If <code>sqle</code> indicates that locator was
1:      *         invalid, an <code>SqlException</code> with SQL state
0:      *         <code>BLOB_ACCESSED_AFTER_COMMIT</code>. Otherwise, the
1:      *         incoming exception is returned.
1:      */
1:     private SqlException handleInvalidLocator(SqlException sqle)
1:     {
0:         if ((sqle.getMessage().indexOf(ExceptionUtil
0:                 .getSQLStateFromIdentifier(SQLState.LOB_LOCATOR_INVALID)) >= 0)
0:             // With Java 6, the reason for the failure of the
0:             // procedure call is not reported, just
0:             // LANG_UNEXPECTED_USER_EXCEPTION (see DERBY-1629).
0:             // Until this is fixed, treat all such errors as INVALID_LOCATOR
0:             || (sqle.getSQLState().compareTo
1:                 (ExceptionUtil.getSQLStateFromIdentifier
0:                  (SQLState.LANG_UNEXPECTED_USER_EXCEPTION)) == 0)) {
0:             return new SqlException(connection.agent_.logWriter_,
0:                     new ClientMessageId(SQLState.BLOB_ACCESSED_AFTER_COMMIT),
0:                     null,
0:                     sqle);
0:         } else {
0:             return sqle;
1:         }
============================================================================