1:77323ec: /*
7:77323ec:  
1:1bac3f3:    Derby - Class org.apache.derby.impl.store.replication.net.ReplicationMessageTransmit
1:77323ec:  
1:77323ec:    Licensed to the Apache Software Foundation (ASF) under one or more
1:77323ec:    contributor license agreements.  See the NOTICE file distributed with
1:77323ec:    this work for additional information regarding copyright ownership.
1:77323ec:    The ASF licenses this file to you under the Apache License, Version 2.0
1:77323ec:    (the "License"); you may not use this file except in compliance with
1:77323ec:    the License.  You may obtain a copy of the License at
1:77323ec:  
1:77323ec:       http://www.apache.org/licenses/LICENSE-2.0
1:77323ec:  
1:77323ec:    Unless required by applicable law or agreed to in writing, software
1:77323ec:    distributed under the License is distributed on an "AS IS" BASIS,
1:77323ec:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:77323ec:    See the License for the specific language governing permissions and
1:77323ec:    limitations under the License.
1:77323ec:  
1:77323ec:  */
1:1bac3f3: package org.apache.derby.impl.store.replication.net;
1:77323ec: 
1:77323ec: import java.io.IOException;
1:864d9d1: import java.net.InetSocketAddress;
1:77323ec: import java.net.Socket;
1:c283bcd: import java.net.SocketTimeoutException;
1:77323ec: import java.security.AccessController;
1:77323ec: import java.security.PrivilegedActionException;
1:77323ec: import java.security.PrivilegedExceptionAction;
1:77323ec: import javax.net.SocketFactory;
1:77323ec: import org.apache.derby.iapi.error.StandardException;
1:77323ec: import org.apache.derby.iapi.reference.SQLState;
1:ec9d167: import org.apache.derby.iapi.util.InterruptStatus;
1:c085d07: import org.apache.derby.shared.common.reference.MessageId;
1:77323ec: 
1:77323ec: /**
1:77323ec:  * Used to send replication messages to the slave. Called by the
1:77323ec:  * Master controller to transmit replication messages wrapped in
1:77323ec:  * a <code>ReplicationMessage</code> object to a receiver. The
1:77323ec:  * receiver is implemented by the <code>ReplicationMessageReceive</code>
1:77323ec:  * class.
1:77323ec:  */
1:77323ec: public class ReplicationMessageTransmit {
1:c283bcd:     
1:c283bcd:     /** Number of millis to wait for a response message before timing out
1:c283bcd:      */
1:4a14003:     private final int DEFAULT_MESSAGE_RESPONSE_TIMEOUT = 30000;
1:c283bcd: 
1:c283bcd:     /** Used to synchronize when waiting for a response message from the slave
1:c283bcd:      */
1:c283bcd:     private final Object receiveSemaphore = new Object();
1:c283bcd: 
1:c283bcd:     /** The message received from the slave as a response to sending a
1:c283bcd:      * message. */
1:c283bcd:     private ReplicationMessage receivedMsg = null;
1:c283bcd: 
1:c283bcd:     /** Whether or not to keep the message receiver thread alive. Set to true
1:c283bcd:      * to terminate the thread */
1:c283bcd:     private volatile boolean stopMessageReceiver = false;
1:c283bcd: 
1:77323ec:     /**
1:77323ec:      * Contains the address (hostname and port number) of the slave
1:77323ec:      * to replicate to.
1:77323ec:      */
1:77323ec:     private final SlaveAddress slaveAddress;
1:77323ec:     
1:77323ec:     /**
1:77323ec:      * Used to write/read message objects to/from a connection.
1:77323ec:      */
1:77323ec:     private SocketConnection socketConn;
1:c283bcd: 
1:c283bcd:     /**
1:c283bcd:      * The name of the replicated database
1:c283bcd:      */
1:c283bcd:     private String dbname;
1:77323ec:     
1:77323ec:     /**
1:77323ec:      * Constructor initializes the slave address used in replication.
4:77323ec:      *
1:f2ec1d8:      * @param slaveAddress contains the address (host name and port number)
1:f2ec1d8:      *                     of the slave to connect to.
1:77323ec:      */
1:f2ec1d8:     public ReplicationMessageTransmit(SlaveAddress slaveAddress) {
1:f2ec1d8:         this.slaveAddress = slaveAddress;
2:77323ec:     }
1:77323ec:     
1:77323ec:     /**
1:77323ec:      * Used to create a <code>Socket</code> connection to the slave and
1:77323ec:      * establish compatibility with the database version of the slave by
1:77323ec:      * comparing the UID's of the <code>ReplicationMessage</code> classes
1:77323ec:      * of the master and the slave.
1:77323ec:      *
1:864d9d1:      * @param timeout the amount of time for which the connection should
1:864d9d1:      *                block before being established.
1:864d9d1:      *
1:29fd25c:      * @param synchOnInstant the master log instant, used to check
1:29fd25c:      * that the master and slave log files are in synch. If no chunks
1:29fd25c:      * of log records have been shipped to the slave yet, this is the
1:29fd25c:      * end position in the current log file. If a chunk of log has
1:29fd25c:      * been shipped, this is the instant of the log record shipped
1:29fd25c:      * last. Note that there is a difference!
1:8e4af95:      * 
1:77323ec:      * @throws IOException if an exception occurs while trying to create the
1:8e4af95:      *         <code>SocketConnection</code> class or open a connection.
1:77323ec:      *
1:77323ec:      * @throws StandardException If an error message is received from the
1:77323ec:      *         server indicating incompatible software versions of master
1:77323ec:      *         and slave.
1:77323ec:      *
2:77323ec:      * @throws ClassNotFoundException Class of a serialized object cannot
1:77323ec:      *         be found.
1:77323ec:      */
1:29fd25c:     public void initConnection(int timeout, long synchOnInstant) throws
1:77323ec:         IOException,
1:77323ec:         StandardException,
1:77323ec:         ClassNotFoundException {
1:77323ec:         
1:77323ec:         Socket s = null;
1:864d9d1:         
1:864d9d1:         final int timeout_ = timeout;
1:8e4af95:         try {
1:8e4af95:             //create a connection to the slave.
1:7e7a589:             s = AccessController.doPrivileged(new PrivilegedExceptionAction<Socket>() {
1:7e7a589:                 public Socket run() throws IOException {
1:8e4af95:                     SocketFactory sf = SocketFactory.getDefault();
1:8e4af95:                     InetSocketAddress sockAddr = new InetSocketAddress(
1:8e4af95:                             slaveAddress.getHostAddress(), 
1:8e4af95:                             slaveAddress.getPortNumber());
1:8e4af95:                     Socket s_temp = sf.createSocket();
1:8e4af95:                     s_temp.connect(sockAddr, timeout_);
1:8e4af95:                     return s_temp;
1:8e4af95:                 }
1:8e4af95:             });
1:8e4af95:         } catch(PrivilegedActionException pea) {
1:8e4af95:             throw (IOException) pea.getException();
1:8e4af95:         }
1:5d5aab5:         
1:c283bcd:         // keep socket alive even if no log is shipped for a long time
1:c283bcd:         s.setKeepAlive(true);
1:77323ec:         
1:77323ec:         socketConn = new SocketConnection(s);
1:c283bcd: 
1:c283bcd:         // Start the thread that will listen for incoming messages.
1:c283bcd:         startMessageReceiverThread(dbname);
1:77323ec:         
1:c283bcd:         // Verify that the master and slave have the same software version
1:c283bcd:         // and exactly equal log files.
1:c283bcd:         brokerConnection(synchOnInstant);
1:77323ec:     }
1:77323ec:     
1:77323ec:     /**
1:29fd25c:      * Tear down the network connection established with the
1:29fd25c:      * other replication peer
1:29fd25c:      *
1:29fd25c:      * @throws IOException if an exception occurs while trying to tear
1:29fd25c:      *                     down the network connection
1:29fd25c:      */
1:29fd25c:     public void tearDown() throws IOException {
1:c283bcd:         stopMessageReceiver = true;
1:c085d07:         if(socketConn != null) {
1:c085d07:             socketConn.tearDown();
1:c283bcd:             socketConn = null;
1:c085d07:         }
1:29fd25c:     }
1:29fd25c: 
1:29fd25c:     /**
1:77323ec:      * Used to send a replication message to the slave.
1:77323ec:      *
1:77323ec:      * @param message a <code>ReplicationMessage</code> object that contains
1:77323ec:      *                the message to be transmitted.
1:77323ec:      *
1:c085d07:      * @throws IOException 1) if an exception occurs while transmitting
1:c085d07:      *                        the message.
1:c085d07:      *                     2) if the connection handle is invalid.
1:77323ec:      */
1:77323ec:     public void sendMessage(ReplicationMessage message) throws IOException {
1:c085d07:         checkSocketConnection();
1:77323ec:         socketConn.writeMessage(message);
1:77323ec:     }
1:77323ec:     
1:77323ec:     /**
1:c283bcd:      * Send a replication message to the slave and return the
1:c283bcd:      * message received as a response. Will only wait
1:c283bcd:      * DEFAULT_MESSAGE_RESPONSE_TIMEOUT millis for the response
1:c283bcd:      * message. If not received when the wait times out, no message is
1:c283bcd:      * returned. The method is synchronized to guarantee that only one
1:c283bcd:      * thread will be waiting for a response message at any time.
1:77323ec:      *
1:c283bcd:      * @param message a ReplicationMessage object that contains the message to
1:c283bcd:      * be transmitted.
1:77323ec:      *
1:c283bcd:      * @return the response message
1:c283bcd:      * @throws IOException 1) if an exception occurs while sending or receiving
1:c283bcd:      *                        a message.
1:c085d07:      *                     2) if the connection handle is invalid.
1:c283bcd:      * @throws StandardException if the response message has not been received
1:c283bcd:      * after DEFAULT_MESSAGE_RESPONSE_TIMEOUT millis
1:77323ec:      */
1:c283bcd:     public synchronized ReplicationMessage
1:c283bcd:         sendMessageWaitForReply(ReplicationMessage message)
1:c283bcd:         throws IOException, StandardException {
1:c283bcd:         receivedMsg = null;
1:c085d07:         checkSocketConnection();
1:c283bcd:         socketConn.writeMessage(message);
1:ec9d167:         long startMillis = System.currentTimeMillis();
1:ec9d167:         long waited = 0L;
1:ec9d167: 
1:ec9d167:         while (receivedMsg == null &&
1:ec9d167:                waited < DEFAULT_MESSAGE_RESPONSE_TIMEOUT) {
1:ec9d167: 
1:ec9d167:             synchronized (receiveSemaphore) {
1:ec9d167:                 try {
1:ec9d167:                     receiveSemaphore.wait(
1:ec9d167:                         DEFAULT_MESSAGE_RESPONSE_TIMEOUT - waited);
1:ec9d167:                 } catch (InterruptedException ie) {
1:ec9d167:                     InterruptStatus.setInterrupted();
1:ec9d167:                     waited = System.currentTimeMillis() - startMillis;
1:ec9d167:                     continue;
1:ec9d167:                 }
1:ec9d167:                 break;
1:c283bcd:             }
1:c283bcd:         }
1:ec9d167: 
1:c283bcd:         if (receivedMsg == null) {
1:c283bcd:             throw StandardException.
1:c283bcd:                 newException(SQLState.REPLICATION_CONNECTION_LOST, dbname);
1:c283bcd: 
1:c283bcd:         }
1:c283bcd:         return receivedMsg;
1:77323ec:     }
1:77323ec:     
1:77323ec:     /**
1:29fd25c:      * Used to send initiator messages to the slave and receive
1:29fd25c:      * information about the compatibility of the slave with the
1:29fd25c:      * master. One message is used to check that the slave and master
1:29fd25c:      * have the same software versions. A second message is used to
1:29fd25c:      * check that the master and slave log files are in synch.
1:29fd25c:      *
1:29fd25c:      * @param synchOnInstant the master log instant, used to check
1:29fd25c:      * that the master and slave log files are in synch. If no chunks
1:29fd25c:      * of log records have been shipped to the slave yet, this is the
1:29fd25c:      * end position in the current log file. If a chunk of log has
1:29fd25c:      * been shipped, this is the instant of the log record shipped
1:29fd25c:      * last. Note that there is a difference!
1:77323ec:      *
1:77323ec:      * @throws IOException if an exception occurs during the sending or
1:77323ec:      *                     reading of the message.
1:77323ec:      *
1:77323ec:      * @throws StandardException If an error message is received from the
1:77323ec:      *                           server indicating a mis-match in
1:29fd25c:      *                           serialVersionUID or log files out of synch.
1:77323ec:      *
1:77323ec:      * @throws ClassNotFoundException Class of a serialized object cannot
2:77323ec:      *                                be found.
1:77323ec:      */
1:c283bcd:     private void brokerConnection(long synchOnInstant)
1:77323ec:         throws IOException, StandardException, ClassNotFoundException {
1:29fd25c:         // Check that master and slave have the same serialVersionUID
1:29fd25c:         ReplicationMessage initiatorMsg = 
1:29fd25c:             new ReplicationMessage(ReplicationMessage.TYPE_INITIATE_VERSION, 
1:ce40a31:                                    ReplicationMessage.serialVersionUID);
1:c283bcd:         verifyMessageType(sendMessageWaitForReply(initiatorMsg),
1:c283bcd:                           ReplicationMessage.TYPE_ACK);
1:29fd25c: 
1:29fd25c:         // Check that master and slave log files are in synch
1:29fd25c:         initiatorMsg =
1:ce40a31:             new ReplicationMessage(ReplicationMessage.TYPE_INITIATE_INSTANT, synchOnInstant);
1:c283bcd:         verifyMessageType(sendMessageWaitForReply(initiatorMsg),
1:c283bcd:                           ReplicationMessage.TYPE_ACK);
1:29fd25c:     }
1:29fd25c: 
1:29fd25c:     /**
1:29fd25c:      * Used to parse a message received from the slave. If the message
1:29fd25c:      * is an ack of the last shipped message, this method terminates
1:29fd25c:      * quietly. Otherwise, it throws the exception received in the
1:29fd25c:      * message from the slave describing why the last message could
1:29fd25c:      * not be acked.
1:29fd25c:      *
1:29fd25c:      * @throws StandardException If an error message is received from
1:29fd25c:      *                           the server
1:29fd25c:      *
1:29fd25c:      * @throws ClassNotFoundException Class of a serialized object cannot
1:29fd25c:      *                                be found.
1:29fd25c:      */
1:c283bcd:     private boolean verifyMessageType(ReplicationMessage message,
1:c283bcd:                                       int expectedType)
1:29fd25c:         throws StandardException {
1:77323ec:         //If the message is a TYPE_ACK the slave is capable
1:77323ec:         //of handling the messages and is at a compatible database version.
1:c283bcd:         if (message.getType() == expectedType) {
1:c283bcd:             return true;
1:c283bcd:         } else if (message.getType() == ReplicationMessage.TYPE_ERROR) {
1:29fd25c:             // See ReplicationMessage#TYPE_ERROR
1:c283bcd:             String exception[] = (String[])message.getMessage();
1:29fd25c:             throw StandardException.
1:29fd25c:                 newException(exception[exception.length - 1], exception);
1:77323ec:         } else {
1:77323ec:             //The message format was not recognized. Hence throw
1:77323ec:             //an unexpected exception.
2:77323ec:             throw StandardException.newException
1:77323ec:                 (SQLState.REPLICATION_UNEXPECTED_EXCEPTION);
1:77323ec:         }
1:77323ec:     }
1:c085d07:     
1:c085d07:     /**
1:c085d07:      * Verifies if the <code>SocketConnection</code> is valid.
1:c085d07:      *
1:c085d07:      * @throws IOException If the socket connection object is not
1:c085d07:      *                     valid (is null).
1:c085d07:      */
1:c085d07:     private void checkSocketConnection() throws IOException {
1:c085d07:         if (socketConn == null) {
1:c085d07:             throw new IOException
1:c085d07:                     (MessageId.REPLICATION_INVALID_CONNECTION_HANDLE);
1:c085d07:         }
1:c085d07:     }
1:c283bcd: 
1:c283bcd:     private void startMessageReceiverThread(String dbname) {
1:c4d6dc2:         MasterReceiverThread msgReceiver = new MasterReceiverThread(dbname);
1:c283bcd:         msgReceiver.setDaemon(true);
1:c283bcd:         msgReceiver.start();
1:c283bcd:     }
1:c283bcd: 
1:c283bcd:     /////////////////
1:c283bcd:     // Inner Class //
1:c283bcd:     /////////////////
1:c283bcd: 
1:c283bcd:     /**
1:c283bcd:      * Thread that listens for messages from the slave. A separate thread
1:c283bcd:      * listening for messages from the slave is needed because the slave
1:c283bcd:      * may send messages to the master at any time, and these messages require
1:c283bcd:      * immediate action.
1:c283bcd:      */
1:c283bcd:     private class MasterReceiverThread extends Thread {
1:c283bcd: 
1:c283bcd:         private final ReplicationMessage pongMsg =
1:c283bcd:             new ReplicationMessage(ReplicationMessage.TYPE_PONG, null);
1:c283bcd: 
1:c283bcd:         MasterReceiverThread(String dbname) {
1:c283bcd:             super("derby.master.receiver-" + dbname);
1:c283bcd:         }
1:c283bcd: 
1:c283bcd:         public void run() {
1:c283bcd:             ReplicationMessage message;
1:c283bcd:             while (!stopMessageReceiver) {
1:c283bcd:                 try {
1:c283bcd:                     message = readMessage();
1:c283bcd: 
1:c283bcd:                     switch (message.getType()) {
1:c283bcd:                     case ReplicationMessage.TYPE_PING:
1:c283bcd:                         sendMessage(pongMsg);
1:c283bcd:                         break;
1:c283bcd:                     case ReplicationMessage.TYPE_ACK:
1:c283bcd:                     case ReplicationMessage.TYPE_ERROR:
1:c283bcd:                         synchronized (receiveSemaphore) {
1:c283bcd:                             receivedMsg = message;
1:c283bcd:                             receiveSemaphore.notify();
1:c283bcd:                         }
1:c283bcd:                         break;
1:c283bcd:                     default:
1:c283bcd:                         // Handling of other messages (i.e., stop and failover)
1:c283bcd:                         // not implemented yet
1:c283bcd:                         break;
1:c283bcd:                     }
1:c283bcd:                 } catch (SocketTimeoutException ste) {
1:c283bcd:                     // ignore socket timeout on reads
1:c283bcd:                 } catch (ClassNotFoundException cnfe) {
1:94f8091:                     // TODO: print problem to log
1:c283bcd:                 } catch (IOException ex) {
2:c283bcd:                     // TODO: print problem to log
1:c283bcd:                     // If we get an exception for this socket, the log shipper
1:c283bcd:                     // will clean up. Stop this thread.
1:c283bcd:                     stopMessageReceiver = true;
1:c283bcd:                 }
1:c283bcd:             }
1:c283bcd:         }
1:c283bcd: 
1:c283bcd:         /**
1:c283bcd:          * Used to read a replication message sent by the slave. Hangs until a
1:c283bcd:          * message is received from the slave
1:c283bcd:          *
1:c283bcd:          * @return the reply message.
1:c283bcd:          *
1:c283bcd:          * @throws ClassNotFoundException Class of a serialized object cannot
1:c283bcd:          *                                be found.
1:c283bcd:          *
1:c283bcd:          * @throws IOException 1) if an exception occurs while reading from the
1:c283bcd:          *                        stream.
1:c283bcd:          *                     2) if the connection handle is invalid.
1:c283bcd:          */
1:c283bcd:         private ReplicationMessage readMessage() throws
1:c283bcd:             ClassNotFoundException, IOException {
1:c283bcd:             checkSocketConnection();
1:c283bcd:             return (ReplicationMessage)socketConn.readMessage();
1:c283bcd:         }
1:c283bcd:     }
1:77323ec: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                                    ReplicationMessage.serialVersionUID);
1:             new ReplicationMessage(ReplicationMessage.TYPE_INITIATE_INSTANT, synchOnInstant);
commit:7e7a589
/////////////////////////////////////////////////////////////////////////
1:             s = AccessController.doPrivileged(new PrivilegedExceptionAction<Socket>() {
1:                 public Socket run() throws IOException {
author:Lily Wei
-------------------------------------------------------------------------------
commit:94f8091
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     // TODO: print problem to log
commit:9b06465
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.impl.store.replication.ReplicationLogger;
/////////////////////////////////////////////////////////////////////////
0:                     ReplicationLogger repLogger = new ReplicationLogger(dbname);
0:                     repLogger.logError(MessageId.REPLICATION_ERROR_BEGIN, cnfe);
0:                     ReplicationLogger repLogger = new ReplicationLogger(dbname);
0:                     repLogger.logError(MessageId.REPLICATION_ERROR_BEGIN, ex);                    
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:ec9d167
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.InterruptStatus;
/////////////////////////////////////////////////////////////////////////
1:         long startMillis = System.currentTimeMillis();
1:         long waited = 0L;
1: 
1:         while (receivedMsg == null &&
1:                waited < DEFAULT_MESSAGE_RESPONSE_TIMEOUT) {
1: 
1:             synchronized (receiveSemaphore) {
1:                 try {
1:                     receiveSemaphore.wait(
1:                         DEFAULT_MESSAGE_RESPONSE_TIMEOUT - waited);
1:                 } catch (InterruptedException ie) {
1:                     InterruptStatus.setInterrupted();
1:                     waited = System.currentTimeMillis() - startMillis;
1:                     continue;
1:                 }
1:                 break;
1: 
commit:4a14003
/////////////////////////////////////////////////////////////////////////
1:     private final int DEFAULT_MESSAGE_RESPONSE_TIMEOUT = 30000;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:8e4af95
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      *         <code>SocketConnection</code> class or open a connection.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         try {
1:             //create a connection to the slave.
0:             s = (Socket)
0:             AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
1:                     SocketFactory sf = SocketFactory.getDefault();
1:                     InetSocketAddress sockAddr = new InetSocketAddress(
1:                             slaveAddress.getHostAddress(), 
1:                             slaveAddress.getPortNumber());
1:                     Socket s_temp = sf.createSocket();
1:                     s_temp.connect(sockAddr, timeout_);
1:                     return s_temp;
1:                 }
1:             });
1:         } catch(PrivilegedActionException pea) {
1:             throw (IOException) pea.getException();
1:         }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c4d6dc2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         MasterReceiverThread msgReceiver = new MasterReceiverThread(dbname);
/////////////////////////////////////////////////////////////////////////
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:f2ec1d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param slaveAddress contains the address (host name and port number)
1:      *                     of the slave to connect to.
1:     public ReplicationMessageTransmit(SlaveAddress slaveAddress) {
1:         this.slaveAddress = slaveAddress;
commit:c283bcd
/////////////////////////////////////////////////////////////////////////
1: import java.net.SocketTimeoutException;
/////////////////////////////////////////////////////////////////////////
1:     /** Number of millis to wait for a response message before timing out
1:      */
0:     private final int DEFAULT_MESSAGE_RESPONSE_TIMEOUT = 5000;
1: 
0:     /** The thread that listens for messages from the slave */
0:     private Thread msgReceiver = null;
1: 
1:     /** Used to synchronize when waiting for a response message from the slave
1:      */
1:     private final Object receiveSemaphore = new Object();
1: 
1:     /** The message received from the slave as a response to sending a
1:      * message. */
1:     private ReplicationMessage receivedMsg = null;
1: 
1:     /** Whether or not to keep the message receiver thread alive. Set to true
1:      * to terminate the thread */
1:     private volatile boolean stopMessageReceiver = false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * The name of the replicated database
1:      */
1:     private String dbname;
/////////////////////////////////////////////////////////////////////////
0:      * @param dbname The name of the replicated database
0:     public ReplicationMessageTransmit(String hostName, int portNumber,
0:                                       String dbname)
0:         throws UnknownHostException {
0:         this.dbname = dbname;
/////////////////////////////////////////////////////////////////////////
1:         // keep socket alive even if no log is shipped for a long time
1:         s.setKeepAlive(true);
1: 
1:         // Start the thread that will listen for incoming messages.
1:         startMessageReceiverThread(dbname);
1:         // Verify that the master and slave have the same software version
1:         // and exactly equal log files.
1:         brokerConnection(synchOnInstant);
/////////////////////////////////////////////////////////////////////////
1:         stopMessageReceiver = true;
0:         msgReceiver = null;
1:             socketConn = null;
/////////////////////////////////////////////////////////////////////////
1:      * Send a replication message to the slave and return the
1:      * message received as a response. Will only wait
1:      * DEFAULT_MESSAGE_RESPONSE_TIMEOUT millis for the response
1:      * message. If not received when the wait times out, no message is
1:      * returned. The method is synchronized to guarantee that only one
1:      * thread will be waiting for a response message at any time.
1:      * @param message a ReplicationMessage object that contains the message to
1:      * be transmitted.
1:      * @return the response message
1:      * @throws IOException 1) if an exception occurs while sending or receiving
1:      *                        a message.
1:      * @throws StandardException if the response message has not been received
1:      * after DEFAULT_MESSAGE_RESPONSE_TIMEOUT millis
1:     public synchronized ReplicationMessage
1:         sendMessageWaitForReply(ReplicationMessage message)
1:         throws IOException, StandardException {
1:         receivedMsg = null;
1:         socketConn.writeMessage(message);
1:         synchronized (receiveSemaphore) {
1:             try {
0:                 receiveSemaphore.wait(DEFAULT_MESSAGE_RESPONSE_TIMEOUT);
0:             } catch (InterruptedException ie) {
1:             }
1:         }
1:         if (receivedMsg == null) {
1:             throw StandardException.
1:                 newException(SQLState.REPLICATION_CONNECTION_LOST, dbname);
1: 
1:         }
1:         return receivedMsg;
/////////////////////////////////////////////////////////////////////////
1:     private void brokerConnection(long synchOnInstant)
1:         verifyMessageType(sendMessageWaitForReply(initiatorMsg),
1:                           ReplicationMessage.TYPE_ACK);
1:         verifyMessageType(sendMessageWaitForReply(initiatorMsg),
1:                           ReplicationMessage.TYPE_ACK);
/////////////////////////////////////////////////////////////////////////
1:     private boolean verifyMessageType(ReplicationMessage message,
1:                                       int expectedType)
1:         if (message.getType() == expectedType) {
1:             return true;
1:         } else if (message.getType() == ReplicationMessage.TYPE_ERROR) {
1:             String exception[] = (String[])message.getMessage();
/////////////////////////////////////////////////////////////////////////
1: 
1:     private void startMessageReceiverThread(String dbname) {
0:         msgReceiver = new MasterReceiverThread(dbname);
1:         msgReceiver.setDaemon(true);
1:         msgReceiver.start();
1:     }
1: 
1:     /////////////////
1:     // Inner Class //
1:     /////////////////
1: 
1:     /**
1:      * Thread that listens for messages from the slave. A separate thread
1:      * listening for messages from the slave is needed because the slave
1:      * may send messages to the master at any time, and these messages require
1:      * immediate action.
1:      */
1:     private class MasterReceiverThread extends Thread {
1: 
1:         private final ReplicationMessage pongMsg =
1:             new ReplicationMessage(ReplicationMessage.TYPE_PONG, null);
1: 
1:         MasterReceiverThread(String dbname) {
1:             super("derby.master.receiver-" + dbname);
1:         }
1: 
1:         public void run() {
1:             ReplicationMessage message;
1:             while (!stopMessageReceiver) {
0:                 try {
1:                     message = readMessage();
1: 
1:                     switch (message.getType()) {
1:                     case ReplicationMessage.TYPE_PING:
1:                         sendMessage(pongMsg);
1:                         break;
1:                     case ReplicationMessage.TYPE_ACK:
1:                     case ReplicationMessage.TYPE_ERROR:
0:                         synchronized (receiveSemaphore) {
1:                             receivedMsg = message;
1:                             receiveSemaphore.notify();
1:                         }
1:                         break;
1:                     default:
1:                         // Handling of other messages (i.e., stop and failover)
1:                         // not implemented yet
1:                         break;
1:                     }
1:                 } catch (SocketTimeoutException ste) {
1:                     // ignore socket timeout on reads
1:                 } catch (ClassNotFoundException cnfe) {
1:                     // TODO: print problem to log
1:                 } catch (IOException ex) {
1:                     // TODO: print problem to log
1:                     // If we get an exception for this socket, the log shipper
1:                     // will clean up. Stop this thread.
1:                     stopMessageReceiver = true;
0:                     msgReceiver = null;
1:                 }
1:             }
1:         }
1: 
1:         /**
1:          * Used to read a replication message sent by the slave. Hangs until a
1:          * message is received from the slave
1:          *
1:          * @return the reply message.
1:          *
1:          * @throws ClassNotFoundException Class of a serialized object cannot
1:          *                                be found.
1:          *
1:          * @throws IOException 1) if an exception occurs while reading from the
1:          *                        stream.
1:          *                     2) if the connection handle is invalid.
1:          */
1:         private ReplicationMessage readMessage() throws
1:             ClassNotFoundException, IOException {
1:             checkSocketConnection();
1:             return (ReplicationMessage)socketConn.readMessage();
1:         }
1:     }
commit:1bac3f3
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.replication.net.ReplicationMessageTransmit
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derby.impl.store.replication.net;
commit:c085d07
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.MessageId;
/////////////////////////////////////////////////////////////////////////
1:         if(socketConn != null) {
1:             socketConn.tearDown();
1:         }
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException 1) if an exception occurs while transmitting
1:      *                        the message.
1:      *                     2) if the connection handle is invalid.
1:         checkSocketConnection();
/////////////////////////////////////////////////////////////////////////
0:      * @throws IOException 1) if an exception occurs while reading from the
0:      *                        stream.
1:      *                     2) if the connection handle is invalid.
1:         checkSocketConnection();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Verifies if the <code>SocketConnection</code> is valid.
1:      *
1:      * @throws IOException If the socket connection object is not
1:      *                     valid (is null).
1:      */
1:     private void checkSocketConnection() throws IOException {
1:         if (socketConn == null) {
1:             throw new IOException
1:                     (MessageId.REPLICATION_INVALID_CONNECTION_HANDLE);
1:         }
1:     }
commit:5d5aab5
/////////////////////////////////////////////////////////////////////////
0:         //The reads on the InputStreams obtained from the socket on the
0:         //transmitter should not hang indefinitely. Use the timeout
0:         //used for the connection establishment here to ensure that the
0:         //reads timeout after the timeout period mentioned for the
0:         //connection.
0:         s.setSoTimeout(timeout_);
1:         
commit:29fd25c
/////////////////////////////////////////////////////////////////////////
1:      * @param synchOnInstant the master log instant, used to check
1:      * that the master and slave log files are in synch. If no chunks
1:      * of log records have been shipped to the slave yet, this is the
1:      * end position in the current log file. If a chunk of log has
1:      * been shipped, this is the instant of the log record shipped
1:      * last. Note that there is a difference!
/////////////////////////////////////////////////////////////////////////
1:     public void initConnection(int timeout, long synchOnInstant) throws
/////////////////////////////////////////////////////////////////////////
0:         sendInitiatorAndReceiveAck(synchOnInstant);
1:      * Tear down the network connection established with the
1:      * other replication peer
1:      *
1:      * @throws IOException if an exception occurs while trying to tear
1:      *                     down the network connection
1:      */
1:     public void tearDown() throws IOException {
0:         socketConn.tearDown();
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Used to send initiator messages to the slave and receive
1:      * information about the compatibility of the slave with the
1:      * master. One message is used to check that the slave and master
1:      * have the same software versions. A second message is used to
1:      * check that the master and slave log files are in synch.
1:      *
1:      * @param synchOnInstant the master log instant, used to check
1:      * that the master and slave log files are in synch. If no chunks
1:      * of log records have been shipped to the slave yet, this is the
1:      * end position in the current log file. If a chunk of log has
1:      * been shipped, this is the instant of the log record shipped
1:      * last. Note that there is a difference!
1:      *                           serialVersionUID or log files out of synch.
0:     private void sendInitiatorAndReceiveAck(long synchOnInstant)
1:         // Check that master and slave have the same serialVersionUID
1:         ReplicationMessage initiatorMsg = 
1:             new ReplicationMessage(ReplicationMessage.TYPE_INITIATE_VERSION, 
0:                                    new Long(ReplicationMessage.
0:                                             serialVersionUID));
0:         verifyMessageAck(readMessage());
1: 
1:         // Check that master and slave log files are in synch
1:         initiatorMsg =
0:             new ReplicationMessage(ReplicationMessage.TYPE_INITIATE_INSTANT,
0:                                    new Long(synchOnInstant));
0:         sendMessage(initiatorMsg);
0:         verifyMessageAck(readMessage());
1:     }
1: 
1:     /**
1:      * Used to parse a message received from the slave. If the message
1:      * is an ack of the last shipped message, this method terminates
1:      * quietly. Otherwise, it throws the exception received in the
1:      * message from the slave describing why the last message could
1:      * not be acked.
1:      *
1:      * @throws StandardException If an error message is received from
1:      *                           the server
1:      *
1:      * @throws ClassNotFoundException Class of a serialized object cannot
1:      *                                be found.
1:      */
0:     private void verifyMessageAck(ReplicationMessage ack) 
1:         throws StandardException {
1:             // See ReplicationMessage#TYPE_ERROR
0:             String exception[] = (String[])ack.getMessage();
1:             throw StandardException.
1:                 newException(exception[exception.length - 1], exception);
commit:864d9d1
/////////////////////////////////////////////////////////////////////////
1: import java.net.InetSocketAddress;
/////////////////////////////////////////////////////////////////////////
1:      * @param timeout the amount of time for which the connection should
1:      *                block before being established.
1:      *
/////////////////////////////////////////////////////////////////////////
0:     public void initConnection(int timeout) throws
/////////////////////////////////////////////////////////////////////////
1:         final int timeout_ = timeout;
1:         
0:                 InetSocketAddress sockAddr = new InetSocketAddress(
0:                         slaveAddress.getHostAddress(), 
0:                         slaveAddress.getPortNumber());
0:                 Socket s_temp = sf.createSocket();
0:                 s_temp.connect(sockAddr, timeout_);
0:                 return s_temp;
commit:77323ec
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
0:    Derby - Class org.apache.derby.impl.services.replication.net.ReplicationMessageTransmit
1:  
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
0: package org.apache.derby.impl.services.replication.net;
1: 
1: import java.io.IOException;
1: import java.net.Socket;
0: import java.net.UnknownHostException;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: import javax.net.SocketFactory;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: /**
1:  * Used to send replication messages to the slave. Called by the
1:  * Master controller to transmit replication messages wrapped in
1:  * a <code>ReplicationMessage</code> object to a receiver. The
1:  * receiver is implemented by the <code>ReplicationMessageReceive</code>
1:  * class.
1:  */
1: public class ReplicationMessageTransmit {
1:     
1:     /**
1:      * Contains the address (hostname and port number) of the slave
1:      * to replicate to.
1:      */
1:     private final SlaveAddress slaveAddress;
1:     
1:     /**
1:      * Used to write/read message objects to/from a connection.
1:      */
1:     private SocketConnection socketConn;
1:     
1:     /**
1:      * Constructor initializes the slave address used in replication.
1:      *
0:      * @param hostName a <code>String</code> that contains the host name of
0:      *                 the slave to replicate to.
0:      * @param portNumber an integer that contains the port number of the
0:      *                   slave to replicate to.
1:      *
0:      * @throws UnknownHostException If an exception occurs while trying to
0:      *                              resolve the host name.
1:      */
0:     public ReplicationMessageTransmit(String hostName, int portNumber) 
0:     throws UnknownHostException {
0:         slaveAddress = new SlaveAddress(hostName, portNumber);
1:     }
1:     
1:     /**
1:      * Used to create a <code>Socket</code> connection to the slave and
1:      * establish compatibility with the database version of the slave by
1:      * comparing the UID's of the <code>ReplicationMessage</code> classes
1:      * of the master and the slave.
1:      *
0:      * @throws PrivilegedActionException if an exception occurs while trying
0:      *                                   to open a connection.
1:      *
1:      * @throws IOException if an exception occurs while trying to create the
0:      *         <code>SocketConnection</code> class.
1:      *
1:      * @throws StandardException If an error message is received from the
1:      *         server indicating incompatible software versions of master
1:      *         and slave.
1:      *
1:      * @throws ClassNotFoundException Class of a serialized object cannot
1:      *         be found.
1:      */
0:     public void initConnection() throws
0:         PrivilegedActionException,
1:         IOException,
1:         StandardException,
1:         ClassNotFoundException {
1:         
1:         Socket s = null;
1:         
0:         //create a connection to the slave.
0:         s = (Socket)
0:         AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:             public Object run() throws IOException {
0:                 SocketFactory sf = SocketFactory.getDefault();
0:                 return sf.createSocket(slaveAddress.getHostAddress(),
0:                     slaveAddress.getPortNumber());
1:             }
0:         });
1:         
1:         socketConn = new SocketConnection(s);
1:         
0:         //send the initiate message and receive acknowledgment
0:         sendInitiatorAndReceiveAck();
1:     }
1:     
1:     /**
1:      * Used to send a replication message to the slave.
1:      *
1:      * @param message a <code>ReplicationMessage</code> object that contains
1:      *                the message to be transmitted.
1:      *
0:      * @throws IOException if an exception occurs while transmitting
0:      *                     the message.
1:      */
1:     public void sendMessage(ReplicationMessage message) throws IOException {
1:         socketConn.writeMessage(message);
1:     }
1:     
1:     /**
0:      * Used to read a replication message sent by the slave. This method
0:      * would wait on the connection from the slave until a message is received
0:      * or a connection failure occurs.
1:      *
0:      * @return the reply message.
1:      *
1:      * @throws ClassNotFoundException Class of a serialized object cannot
1:      *                                be found.
1:      *
0:      * @throws IOException if an exception occurs while reading from the
0:      *                     stream.
1:      */
0:     public ReplicationMessage readMessage() throws
0:         ClassNotFoundException, IOException {
0:         return (ReplicationMessage)socketConn.readMessage();
1:     }
1:     
1:     /**
0:      * Used to send a initiator message to the slave and receive information
0:      * about the compatibility of the slave with the master. The slave 
0:      * determines if the software versions are compatible by comparing the
0:      * UID's of the <code>ReplicationMessage</code> of the master and the
0:      * slave.
1:      *
1:      * @throws IOException if an exception occurs during the sending or
1:      *                     reading of the message.
1:      *
1:      * @throws StandardException If an error message is received from the
1:      *                           server indicating a mis-match in
0:      *                           serialVersionUID.
1:      *
1:      * @throws ClassNotFoundException Class of a serialized object cannot
1:      *                                be found.
1:      */
0:     private void sendInitiatorAndReceiveAck() 
1:         throws IOException, StandardException, ClassNotFoundException {
0:         //Build the initiator message with the serialVersionUID of the
0:         //ReplicationMessage.
0:         ReplicationMessage initiatorMsg = new ReplicationMessage
0:             (ReplicationMessage.TYPE_INITIATE, new Long(
0:             ReplicationMessage.serialVersionUID));
1:         
0:         //send the initiator message to the slave.
0:         sendMessage(initiatorMsg);
1:         
0:         //read the acknowledgment from the slave.
0:         ReplicationMessage ack = readMessage();
1:         
1:         
1:         //If the message is a TYPE_ACK the slave is capable
1:         //of handling the messages and is at a compatible database version.
0:         if (ack.getType() == ReplicationMessage.TYPE_ACK) {
0:             return;
0:         } else if (ack.getType() == ReplicationMessage.TYPE_ERROR) {
0:             //The UID's do not match.
1:             throw StandardException.newException
0:                 ((String)ack.getMessage());
1:         } else {
1:             //The message format was not recognized. Hence throw
1:             //an unexpected exception.
1:             throw StandardException.newException
1:                 (SQLState.REPLICATION_UNEXPECTED_EXCEPTION);
1:         }
1:     }
1: }
============================================================================