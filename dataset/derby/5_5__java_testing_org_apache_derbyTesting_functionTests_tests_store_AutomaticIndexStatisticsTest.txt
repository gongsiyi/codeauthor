1:0548478: /*
4:0548478: 
1:0548478:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.AutomaticIndexStatisticsTest
1:0548478: 
1:0548478:    Licensed to the Apache Software Foundation (ASF) under one or more
1:0548478:    contributor license agreements.  See the NOTICE file distributed with
1:0548478:    this work for additional information regarding copyright ownership.
1:0548478:    The ASF licenses this file to you under the Apache License, Version 2.0
1:0548478:    (the "License"); you may not use this file except in compliance with
1:0548478:    the License.  You may obtain a copy of the License at
1:0548478: 
1:0548478:       http://www.apache.org/licenses/LICENSE-2.0
1:0548478: 
1:0548478:    Unless required by applicable law or agreed to in writing, software
1:0548478:    distributed under the License is distributed on an "AS IS" BASIS,
1:0548478:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0548478:    See the License for the specific language governing permissions and
1:0548478:    limitations under the License.
1:0548478: 
1:0548478:  */
1:0548478: package org.apache.derbyTesting.functionTests.tests.store;
1:0548478: 
1:0548478: import java.io.File;
1:0548478: import java.io.IOException;
1:0548478: import java.security.AccessController;
1:0548478: import java.security.PrivilegedAction;
1:0548478: import java.sql.Connection;
1:0548478: import java.sql.PreparedStatement;
1:0548478: import java.sql.ResultSet;
1:0548478: import java.sql.SQLException;
1:0548478: import java.sql.Statement;
1:0548478: import java.sql.Timestamp;
1:0548478: import java.util.Date;
1:0548478: import javax.sql.DataSource;
1:0548478: import junit.framework.Test;
1:0548478: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:0548478: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:9b33bd1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:0548478: import org.apache.derbyTesting.junit.IndexStatsUtil;
1:0548478: import org.apache.derbyTesting.junit.IndexStatsUtil.IdxStats;
1:0548478: import org.apache.derbyTesting.junit.JDBC;
1:0548478: import org.apache.derbyTesting.junit.JDBCDataSource;
1:0548478: import org.apache.derbyTesting.junit.TestConfiguration;
1:6051d0c: import org.apache.derbyTesting.junit.TimeZoneTestSetup;
1:0548478: import org.apache.derbyTesting.junit.Utilities;
1:0548478: 
1:0548478: /**
1:0548478:  * Tests various aspects of the automatic index statistics update feature,
1:0548478:  * which is designed to run as a background task.
1:0548478:  * <p>
1:0548478:  * Some of the tests ensure that the daemon is able to recover after
1:0548478:  * encountering various kinds of "expected errors", for instance if the table
1:0548478:  * is dropped while being scanned by the daemon.
1:0548478:  */
1:0548478: public class AutomaticIndexStatisticsTest
1:0548478:     extends BaseJDBCTestCase {
1:0548478: 
1:14621ff:     // used also by Derby5582AutomaticIndexStatisticsTest so just protected
1:1690ef6:     protected static final String MASTERDB = "masterDb";
1:0548478:     private static final String BIG_TABLE = "BIG_TABLE";
1:0548478:     private static final long DEFAULT_TIMEOUT = 20*1000;
1:0548478: 
1:0548478:     private static final String[] TYPES = new String[] {"TABLE", "VIEW"};
1:0548478: 
1:0548478:     private static boolean dbCreated;
1:0548478:     // Change this if running test cases in parallel...
1:0548478:     private static IndexStatsUtil stats;
1:0548478: 
1:0548478:     public AutomaticIndexStatisticsTest(String name) {
1:0548478: 
1:0548478:         super(name);
1:0548478:     }
1:0548478: 
1:0548478:     public static Test suite() {
1:1ae02c9:         Test test = new BaseTestSuite(AutomaticIndexStatisticsTest.class);
1:9b33bd1:         test = new CleanDatabaseTestSetup(test);
1:9b33bd1:         test = TestConfiguration.additionalDatabaseDecorator(test, MASTERDB);
1:9b33bd1: 
1:6051d0c:         // DERBY-5964: The test needs to check the timestamp stored in
1:6051d0c:         // SYSSTATISTICS, which is in the local timezone. Since those
1:6051d0c:         // timestamps may be ambiguous around the transition to or from DST,
1:6051d0c:         // run this test in a timezone that doesn't observe DST. The
1:6051d0c:         // TimeZoneTestSetup can probably be removed once DERBY-5974 is fixed.
1:9b33bd1:         return new TimeZoneTestSetup(test, "GMT");
1:0548478:     }
1:0548478: 
1:0548478:     /** Initialize the default statistics helper object. */
1:0548478:     public void setUp()
1:0548478:             throws SQLException {
1:0548478:         if (stats != null) {
1:0548478:             stats.release();
1:0548478:         }
1:0548478:         stats = new IndexStatsUtil(openDefaultConnection(), DEFAULT_TIMEOUT);
1:0548478:     }
1:0548478: 
1:0548478:     /** Release the default statistics helper object. */
1:0548478:     public void tearDown()
1:0548478:             throws Exception {
1:0548478:         if (stats != null) {
1:0548478:             stats.release();
1:0548478:         }
1:0548478:         stats = null;
1:0548478:         super.tearDown();
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Make sure stats are created when the table grows, and that the database
1:0548478:      * can be deleted after automated stats create/update -
1:0548478:      * that is verify that there are no open file handles left behind in the
1:0548478:      * daemon.
1:0548478:      */
1:0548478:     public void testStatsCreatedOnGrowthThenDeleteDb()
1:0548478:             throws SQLException {
1:c2c2fb8:         String db = "singleUse/newCleanDb";
1:c2c2fb8:         DataSource ds = JDBCDataSource.getDataSource();
1:c2c2fb8:         JDBCDataSource.setBeanProperty(ds, "databaseName", db);
1:c2c2fb8:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:c2c2fb8:         Connection con = ds.getConnection();
1:0548478:         String TAB = "TEST_GROWTH_EMPTY";
1:c2c2fb8:         createAndInsertSimple(con, TAB, 300);
1:0548478:         // This should trigger creation of statistics.
1:c2c2fb8:         PreparedStatement ps = con.prepareStatement(
1:c2c2fb8:                 "select * from " + TAB + " where id = ?");
1:c2c2fb8:         ps.close();
1:0548478: 
1:bce78c9:         // Get statistics for the non-unique index.
1:c2c2fb8:         IdxStats[] myStats = new IndexStatsUtil(
1:c2c2fb8:                 ds.getConnection(), DEFAULT_TIMEOUT).getStatsTable(TAB, 1);
1:0548478:         assertEquals(1, myStats.length);
1:0548478:         assertTrue(myStats[0].rows == 300);
1:0548478: 
1:0548478:         // Shutdown database and try to delete it.
1:c2c2fb8:         JDBCDataSource.shutdownDatabase(ds);
1:c2c2fb8:         assertDirectoryDeleted(constructDbPath(db));
1:0548478:     }
1:0548478: 
1:0548478:     /** Make sure stats are updated when the table grows. */
1:0548478:     public void testStatsUpdatedOnGrowth()
1:0548478:             throws SQLException {
1:0548478:         String TAB = "TEST_GROWTH";
1:0548478:         createAndInsertSimple(TAB, 10000);
1:0548478:         // This should trigger creation of statistics.
2:0548478:         prepareStatement("select * from " + TAB + " where id = ?");
1:0548478: 
2:0548478:         // Get statistics
1:0548478:         IdxStats[] statsPre = stats.getStatsTable(TAB, 1);
1:0548478:         assertEquals(1, statsPre.length);
1:0548478: 
1:0548478:         // Insert more rows.
1:0548478:         setAutoCommit(false);
1:0548478:         insertSimple(TAB, 50000, 10000);
1:0548478:         // Force a checkpoint to update the row estimates.
1:0548478:         forceRowCountEstimateUpdate(TAB);
1:0548478:         prepareStatement("select * from " + TAB + " where 1=1");
1:0548478:         IdxStats[] statsPost = getFilteredTableStats(TAB, 1, statsPre);
1:0548478:         assertEquals(1, statsPost.length);
1:0548478:         assertFalse(statsPre[0].equals(statsPost[0]));
1:0548478:         assertFalse(statsPre[0].after(statsPost[0]));
1:0548478:         // Insert a few more rows, should not trigger a new update
1:0548478:         insertSimple(TAB, 1000, 60000);
1:0548478:         forceRowCountEstimateUpdate(TAB);
1:0548478:         prepareStatement("select * from " + TAB + " where 2=2");
1:0548478:         // Manual wait to see if the existing stats are replaced - they should
1:0548478:         // not be
1:0548478:         Utilities.sleep(1500);
1:0548478:         IdxStats[] statsPost1 = stats.getStatsTable(TAB, 1);
1:0548478:         assertTrue(statsPost[0].equals(statsPost1[0]));
1:0548478:         assertFalse(statsPost1[0].after(statsPost[0]));
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Shuts down database while the daemon is scanning a table, and then
1:0548478:      * makes sure the database directory can be deleted.
1:0548478:      */
1:0548478:     public void testShutdownWhileScanningThenDelete()
1:0548478:             throws IOException, SQLException {
1:0548478:         // Need a big enough table to get the timing right.
1:0548478:         String db = "singleUse/copyShutdown";
1:0548478:         copyDb(db);
1:0548478:         DataSource ds = JDBCDataSource.getDataSource();
1:0548478:         JDBCDataSource.setBeanProperty(ds, "databaseName", db);
1:0548478:         Connection con = ds.getConnection();
1:0548478:         String TAB = BIG_TABLE;
1:0548478: 
1:0548478:         // Trigger statistics creation.
1:0548478:         PreparedStatement ps = con.prepareStatement(
1:0548478:                 "select * from " + TAB + " where id = ?");
1:0548478:         ps.close();
1:0548478: 
1:0548478:         // Wait to make sure the scan starts.
1:0548478:         Utilities.sleep(150);
1:0548478:         // Now shut down the database.
1:0548478:         JDBCDataSource.shutdownDatabase(ds);
1:0548478:         assertDirectoryDeleted(constructDbPath(db));
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Drops table while the daemon is scanning it, then triggers update of
1:0548478:      * statistics of a different table, and finally shuts down and deletes the
1:0548478:      * database.
1:0548478:      */
1:0548478:     public void testDropWhileScanningThenDelete()
1:0548478:             throws IOException, SQLException {
1:0548478:         // Need a big enough table to get the timing right.
1:0548478:         String TAB1 = BIG_TABLE;
1:0548478:         String TAB2 = "SECONDARY_TABLE";
1:0548478:         String db = "singleUse/copyDrop";
1:0548478:         copyDb(db);
1:0548478:         DataSource ds = JDBCDataSource.getDataSource();
1:0548478:         JDBCDataSource.setBeanProperty(ds, "databaseName", db);
1:0548478:         Connection con = ds.getConnection();
1:0548478:         // Create secondary table.
1:0548478:         createAndInsertSimple(con, TAB2, 20000);
1:0548478: 
1:0548478:         // Trigger statistics creation.
1:0548478:         PreparedStatement ps = con.prepareStatement(
1:0548478:                 "select * from " + TAB1 + " where id = ?");
1:0548478:         ps.close();
1:0548478:         // Wait to make sure the scan starts.
1:0548478:         Utilities.sleep(150);
1:0548478:         println("dropping table...");
1:0548478:         Statement stmt = con.createStatement();
1:0548478:         stmt.executeUpdate("drop table " + TAB1);
1:0548478:         stmt.close();
1:0548478: 
1:0548478:         // Trigger stats update on secondary table.
1:0548478:         IndexStatsUtil myStats =
1:0548478:                 new IndexStatsUtil(ds.getConnection(), DEFAULT_TIMEOUT);
1:0548478:         myStats.assertNoStatsTable(TAB2);
1:bce78c9:         con.prepareStatement("select * from " + TAB2 + " where id = ?");
1:0548478:         myStats.assertTableStats(TAB2, 1);
1:0548478:         myStats.release();
1:9b33bd1: 
1:0548478:         // Shutdown, then delete database directory.
1:9b33bd1:         JDBCDataSource.shutdownDatabase(ds);
1:9b33bd1:         assertDirectoryDeleted(constructDbPath(db));
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Tests that compressing the table while scanned makes the daemon fail
1:9b33bd1:      * gracefully, and that the daemon can do other work afterwards.
1:0548478:      */
1:0548478:     public void testCompressWhileScanning()
1:0548478:             throws IOException, SQLException {
1:0548478:         String TAB1 = BIG_TABLE;
1:0548478:         String TAB2 = "SECONDARY_TABLE";
1:0548478:         String db = "singleUse/copyCompress";
1:0548478:         copyDb(db);
1:0548478:         DataSource ds = JDBCDataSource.getDataSource();
1:0548478:         JDBCDataSource.setBeanProperty(ds, "databaseName", db);
1:0548478:         Connection con = ds.getConnection();
1:0548478:         // Create secondary table.
1:0548478:         createAndInsertSimple(con, TAB2, 20000);
1:0548478: 
1:0548478:         // Trigger statistics creation.
1:0548478:         PreparedStatement ps = con.prepareStatement(
1:0548478:                 "select * from " + TAB1 + " where id = ?");
1:0548478:         ps.close();
1:0548478:         // Wait to make sure the scan starts.
1:0548478:         Utilities.sleep(150);
1:0548478:         println("compressing table...");
1:0548478:         Statement stmt = con.createStatement();
1:0548478:         stmt.executeUpdate("call SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP', '" +
1:0548478:                 TAB1 + "', 0)");
1:0548478:         stmt.close();
1:0548478:         // There should still be a statistics object written during the
1:0548478:         // compress operation.
1:0548478:         IndexStatsUtil myStats =
1:0548478:                 new IndexStatsUtil(ds.getConnection(), DEFAULT_TIMEOUT);
1:0548478:         myStats.assertTableStats(TAB1, 1);
1:0548478: 
1:0548478:         // Trigger stats update on secondary table, make sure the daemon can
1:0548478:         // still process work.
1:0548478:         myStats.assertNoStatsTable(TAB2);
1:bce78c9:         con.prepareStatement("select * from " + TAB2 + " where id = ?");
1:0548478:         myStats.assertTableStats(TAB2, 1);
1:0548478:         myStats.release();
1:0548478: 
1:9b33bd1:         // Shutdown database and try to delete it.
1:0548478:         JDBCDataSource.shutdownDatabase(ds);
1:0548478:         assertDirectoryDeleted(constructDbPath(db));
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Tests that the statistics computed are correct.
1:0548478:      *
1:0548478:      * @throws SQLException if something goes wrong
1:0548478:      */
1:0548478:     public void testStatisticsCorrectness()
1:0548478:             throws SQLException {
1:0548478:         // Create table.
1:0548478:         String TAB = "STAT_CORR";
1:0548478:         dropTable(TAB);
1:0548478:         Statement stmt = createStatement();
1:0548478:         stmt.executeUpdate("create table " + TAB +
1:0548478:                 " (id1 int, id2 int, id3 int, val int, " +
1:0548478:                 "primary key (id1, id2, id3))");
1:0548478:         stats.assertNoStatsTable(TAB);
1:0548478:         // Insert rows.
1:0548478:         PreparedStatement ps = prepareStatement("insert into " + TAB +
1:0548478:                 " values (?,?,?,?)");
1:0548478:         // # rows = 100 * 50 * 10 = 50'000
1:0548478:         setAutoCommit(false);
1:0548478:         final int rows = 100*50*10;
1:0548478:         for (int i=1; i <= 100; i++) {
1:0548478:             ps.setInt(1, i);
1:0548478:             for (int j=1; j <= 50; j++) {
1:0548478:                 ps.setInt(2, j);
1:0548478:                 for (int k=1; k <= 10; k++) {
1:0548478:                     ps.setInt(3, k);
1:0548478:                     ps.setInt(4, i*j*k % 750);
1:0548478:                     ps.executeUpdate();
1:0548478:                 }
1:0548478:             }
1:0548478:         }
1:0548478:         commit();
1:0548478:         setAutoCommit(true);
1:0548478: 
1:0548478:         // Select to trigger statistics generation.
1:0548478:         forceRowCountEstimateUpdate(TAB);
1:0548478:         JDBC.assertDrainResults(
1:0548478:                 prepareStatement("select * from " + TAB + " where id1 = 10")
1:0548478:                 .executeQuery());
1:0548478: 
1:0548478:         // We expect three stats objects for the single index; one per
1:0548478:         // leading columns combination (c1, c1-c2, and c1-c2-c3).
1:0548478:         IdxStats statsObj[] = stats.getStatsTable(TAB, 3);
1:0548478:         assertEquals(3, statsObj.length);
1:0548478: 
1:0548478:         Timestamp now = new Timestamp(new Date().getTime());
1:0548478:         for (int i=0; i < statsObj.length; i++) {
1:0548478:             IdxStats s = statsObj[i];
1:0548478:             assertEquals(rows, s.rows);
1:afbc4ba:             
1:afbc4ba:             // DERBY-6144 
1:afbc4ba:             // Stats cannot have been created after the current time (future).
1:afbc4ba:             assertFalse(
1:afbc4ba:                 "expected stat created in past:now = " + now + 
1:afbc4ba:                 ";s.created = " + s.created,
1:afbc4ba:                 s.created.compareTo(now) > 0);
1:afbc4ba: 
1:0548478:             switch (s.lcols) {
1:0548478:                 case 1:
1:0548478:                     assertEquals(100, s.card);
1:0548478:                     break;
1:0548478:                 case 2:
1:0548478:                     assertEquals(5000, s.card);
1:0548478:                     break;
1:0548478:                 case 3:
1:0548478:                     assertEquals(50000, s.card);
1:0548478:                     break;
1:0548478:             default:
1:0548478:                 fail("unexpected number of leading columns: " + s.lcols);
1:0548478:             }
1:0548478:         }
1:0548478: 
1:0548478:         // Now create a second index in the opposite order, check stats.
1:0548478:         stmt.executeUpdate("create index IDXREV on " + TAB + "(id3, id2, id1)");
1:0548478:         statsObj = stats.getStatsIndex("IDXREV", 3);
1:0548478:         assertEquals(3, statsObj.length);
1:0548478:         Timestamp earlier = now;
1:0548478:         now = new Timestamp(new Date().getTime());
1:0548478:         for (int i=0; i < statsObj.length; i++) {
1:0548478:             IdxStats s = statsObj[i];
1:0548478:             assertEquals(rows, s.rows);
1:0548478:             assertTrue("current stats created " + s.created +
1:0548478:                     ", previous stats created " + earlier,
1:0548478:                     s.created.after(earlier));
1:5f1932e:             // Stats cannot have been created after the current time (future).
1:afbc4ba:             assertFalse(
1:afbc4ba:                 "expected stat created in past:now = " + now + 
1:afbc4ba:                 ";s.created = " + s.created,
1:afbc4ba:                 s.created.compareTo(now) > 0);
1:afbc4ba: 
1:0548478:             switch (s.lcols) {
1:0548478:                 case 1:
1:0548478:                     assertEquals(10, s.card);
1:0548478:                     break;
1:0548478:                 case 2:
1:0548478:                     assertEquals(500, s.card);
1:0548478:                     break;
1:0548478:                 case 3:
1:0548478:                     assertEquals(50000, s.card);
1:0548478:                     break;
1:0548478:             default:
1:0548478:                 fail("unexpected number of leading columns: " + s.lcols);
1:0548478:             }
1:0548478:         }
1:0548478: 
1:bce78c9:         // Finally, create a non-unique index on the val column.
1:0548478:         stmt.executeUpdate("create index IDXVAL on " + TAB + "(val)");
1:0548478:         ResultSet rs = stmt.executeQuery(
1:0548478:                 "select val from " + TAB + " order by val");
1:0548478:         // Calculate number of unique values.
1:0548478:         int uniqueVals = 0;
1:0548478:         int prev = -1;
1:0548478:         while (rs.next()) {
1:0548478:             int curr = rs.getInt(1);
1:0548478:             if (curr != prev) {
1:0548478:                 uniqueVals++;
1:0548478:                 prev = curr;
1:0548478:             }
1:0548478:         }
1:0548478:         rs.close();
1:0548478:         // Get stats and check the associated values.
1:0548478:         IdxStats[] valStat = stats.getStatsIndex("IDXVAL", 1);
1:0548478:         assertEquals(1, valStat.length);
1:0548478:         assertEquals(uniqueVals, valStat[0].card);
1:0548478:         assertEquals(rows, valStat[0].rows);
1:0548478:     }
1:0548478: 
1:0548478:     public void testSelectFromSimpleView()
1:0548478:             throws SQLException {
1:0548478:         // First create a table with a few columns.
1:0548478:         String table = "VIEW_BASE_TABLE";
1:0548478:         String view = "MY_VIEW";
1:0548478: 
1:0548478:         dropIfExists(getConnection(), view);
1:0548478:         dropIfExists(getConnection(), table);
1:0548478:         Statement s = createStatement();
1:0548478:         s.execute("create table " + table + " (" +
1:0548478:                 "id int primary key, col1 int, col2 int)");
1:0548478:         s.execute("create index COL2_IDX on " + table + "(col2)");
1:0548478:         PreparedStatement ps = prepareStatement("insert into " + table +
1:0548478:                 " values (?,?,?)");
1:0548478:         setAutoCommit(false);
1:0548478:         for (int i=0; i < 30000; i++) {
1:0548478:             ps.setInt(1, i);
1:0548478:             ps.setInt(2, i % 15);
1:0548478:             ps.setInt(3, i % 25);
1:0548478:             ps.executeUpdate();
1:0548478:             // Commit periodically
1:0548478:             if (i % 5000 == 0) {
1:0548478:                 commit();
1:0548478:             }
1:0548478:         }
1:0548478:         commit();
1:0548478:         setAutoCommit(true);
1:0548478:         ps.close();
1:0548478: 
1:0548478:         // Create the view.
1:0548478:         s.execute("create view " + view + "(vcol_1, vcol2) " +
1:0548478:                 "AS select id, col2 from " + table);
1:0548478: 
1:0548478:         // Select from the view, using index.
1:0548478:         stats.assertNoStatsTable(table);
1:bce78c9:         prepareStatement("select * from " + view + " where vcol2 = 7");
1:0548478:         stats.assertNoStatsTable(table);
1:0548478:         // Trigger update of the base table.
1:bce78c9:         prepareStatement("select * from " + table + " where col2 = 7");
1:bce78c9:         stats.assertTableStats(table, 1);
1:bce78c9:     }
1:bce78c9: 
1:bce78c9:     /**
1:bce78c9:      * Verifies that queries on a table with single-column unique indexes only
1:bce78c9:      * don't trigger a statistics update with the istat daemon.
1:bce78c9:      */
1:bce78c9:     public void testNoUpdateTriggeredBySingleColumnUniqueIndex()
1:bce78c9:             throws SQLException {
1:bce78c9:         // Create table.
1:bce78c9:         String TAB = "STAT_SCUI";
1:bce78c9:         dropTable(TAB);
1:bce78c9:         Statement stmt = createStatement();
1:bce78c9:         stmt.executeUpdate("create table " + TAB +
1:bce78c9:                 " (id int primary key, val int unique not null)");
1:bce78c9:         stats.assertNoStatsTable(TAB);
1:bce78c9:         PreparedStatement ps = prepareStatement(
1:bce78c9:                 "insert into " + TAB + " values (?,?)");
1:bce78c9:         setAutoCommit(false);
1:bce78c9:         for (int i=0; i < 2000; i++) {
1:bce78c9:             ps.setInt(1, i);
1:bce78c9:             ps.setInt(2, i);
1:bce78c9:             ps.executeUpdate();
1:bce78c9:         }
1:bce78c9:         commit();
1:bce78c9:         // The queries below would trigger a stats update in earlier releases.
1:bce78c9:         PreparedStatement psSel1 = prepareStatement(
1:bce78c9:                 "select id from " + TAB + " where id = ?");
1:bce78c9:         psSel1.setInt(1, 98);
1:bce78c9:         JDBC.assertSingleValueResultSet(psSel1.executeQuery(), "98");
1:bce78c9:         PreparedStatement psSel2 = prepareStatement(
1:bce78c9:                 "select val from " + TAB + " where val = ?");
1:bce78c9:         psSel2.setInt(1, 1573);
1:bce78c9:         JDBC.assertSingleValueResultSet(psSel2.executeQuery(), "1573");
1:bce78c9:         Utilities.sleep(100); 
1:bce78c9:         stats.assertNoStatsTable(TAB);
1:bce78c9: 
1:bce78c9:         // Try again after inserting more data.
1:bce78c9:         for (int i=2000; i < 4000; i++) {
1:bce78c9:             ps.setInt(1, i);
1:bce78c9:             ps.setInt(2, i);
1:bce78c9:             ps.executeUpdate();
1:bce78c9:         }
1:bce78c9:         commit();
1:bce78c9:         forceRowCountEstimateUpdate(TAB);
1:bce78c9:         psSel1 = prepareStatement(
1:bce78c9:                 "select id from " + TAB + " where id = ?");
1:bce78c9:         psSel1.setInt(1, 117);
1:bce78c9:         JDBC.assertSingleValueResultSet(psSel1.executeQuery(), "117");
1:bce78c9:         psSel2 = prepareStatement(
1:bce78c9:                 "select val from " + TAB + " where val = ?");
1:bce78c9:         psSel2.setInt(1, 1);
1:bce78c9:         JDBC.assertSingleValueResultSet(psSel2.executeQuery(), "1");
1:bce78c9:         Utilities.sleep(100); 
1:bce78c9:         stats.assertNoStatsTable(TAB);
1:bce78c9: 
1:bce78c9:         // Cleanup
1:bce78c9:         dropTable(TAB);
1:0548478:     }
1:0548478: 
1:0548478:     // Utility methods
1:0548478: 
1:0548478:     /**
1:0548478:      * Creates a copy of the master db.
1:0548478:      *
1:0548478:      * @param newDbName name of the copy
1:0548478:      * @throws IOException if something goes wrong
1:0548478:      * @throws SQLException if something goes wrong
1:0548478:      */
1:0548478:     private void copyDb(String newDbName)
1:0548478:             throws IOException, SQLException {
1:0548478:         if (!dbCreated) {
1:0548478:             createMasterDb();
1:0548478:         }
1:0548478: 
1:0548478:         File master = constructDbPath(
1:0548478:                 TestConfiguration.getCurrent().getPhysicalDatabaseName(
1:0548478:                     MASTERDB));
1:0548478:         final File dest = constructDbPath(newDbName);
1:0548478: 
1:0548478:         // Make sure the directory containing the database directory exists.
1:0548478:         // We expect the security manager to stop us from creating directories
1:0548478:         // where we aren't supposed to.
1:0548478:         if (!PrivilegedFileOpsForTests.exists(dest.getParentFile())) {
1:3f5c48a:             AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:0548478: 
1:3f5c48a:                 public Void run() {
1:0548478:                     assertTrue(dest.getParentFile().mkdirs());
1:0548478:                     return null;
1:0548478:                 }
1:0548478:             });
1:0548478:         }
1:0548478: 
1:0548478:         PrivilegedFileOpsForTests.copy(master, dest);
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Creates the default/master db with a larger number of rows.
1:0548478:      *
1:0548478:      * @throws SQLException if creating the database fails
1:0548478:      */
1:0548478:     private void createMasterDb()
1:0548478:             throws SQLException {
1:0548478:         long start = System.currentTimeMillis();
1:0548478:         String table = BIG_TABLE;
1:0548478:         int rows = 1*1000*1000;
1:0548478:         DataSource ds1 = JDBCDataSource.getDataSourceLogical(MASTERDB);
1:0548478:         JDBCDataSource.setBeanProperty(ds1, "createDatabase", "create");
1:0548478:         Connection con = ds1.getConnection();
1:0548478:         // Check if the table exists, if so, drop it.
1:0548478:         dropIfExists(con, table);
1:0548478:         // Create the table.
1:0548478:         Statement stmt = con.createStatement();
1:0548478:         stmt.executeUpdate("create table " + table + "(id int primary key)");
1:0548478:         stmt.close();
1:0548478: 
1:0548478:         // Insert data
1:0548478:         con.setAutoCommit(false);
1:0548478:         PreparedStatement ps = con.prepareStatement("insert into " + table +
1:0548478:                 " values ?");
1:0548478:         for (int i=0; i < rows; i++) {
1:0548478:             ps.setInt(1, i);
1:0548478:             ps.addBatch();
1:0548478:             if (i % 5000 == 0) {
1:0548478:                 ps.executeBatch();
1:0548478:                 con.commit();
1:0548478:             }
1:0548478:         }
1:0548478:         ps.executeBatch();
1:0548478:         con.commit();
1:0548478:         con.close();
1:0548478:         println("created master db with " + rows + " rows in " +
1:0548478:                 ((System.currentTimeMillis() - start) / 1000) + " seconds");
1:0548478: 
1:0548478:         // Shut down the master db, we will copy it later.
1:0548478:         JDBCDataSource.shutdownDatabase(
1:0548478:                 JDBCDataSource.getDataSourceLogical(MASTERDB));
1:0548478: 
1:0548478:         dbCreated = true;
1:0548478: 
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Forces Derby to update the row count estimate by doing a full table
1:0548478:      * scan and then invoking a checkpoint.
1:0548478:      *
1:0548478:      * @param table target table
1:0548478:      * @throws SQLException if something goes wrong
1:0548478:      */
1:0548478:     private void forceRowCountEstimateUpdate(String table)
1:0548478:             throws SQLException {
1:0548478:         Statement stmt = createStatement();
1:0548478:         JDBC.assertDrainResults(
1:0548478:                 stmt.executeQuery("select count(*) from " + table));
1:0548478:         stmt.execute("call SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE()");
1:0548478:         stmt.close();
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Constructs the path to the database base directory.
1:0548478:      *
1:0548478:      * @param relDbDirName the database name (relative)
1:0548478:      * @return The path to the database.
1:0548478:      */
1:0548478:     private File constructDbPath(String relDbDirName) {
1:0548478:         // Example:
1:0548478:         //     "singleUse/readOnly" -> "<derby.system.home>/singleUse/readOnly"
1:0548478:         File f = new File(getSystemProperty("derby.system.home"));
1:0548478:         return new File(f, relDbDirName);
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Default method to create and populate a simple test table.
1:0548478:      * <p>
1:bce78c9:      * The table consists of a two integer columns, where the first is the
1:bce78c9:      * primary key of the table and the second is a value with a non-unique
1:bce78c9:      * index on it.
1:0548478:      *
1:0548478:      * @param table target table
1:0548478:      * @param rows number of rows to insert
1:0548478:      * @throws SQLException if creating/populating the table fails
1:0548478:      */
1:0548478:     private void createAndInsertSimple(String table, int rows)
1:0548478:             throws SQLException {
1:0548478:         createAndInsertSimple(null, table, rows);
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Default method to create and populate a simple test table.
1:0548478:      * <p>
1:bce78c9:      * The table consists of a two integer columns, where the first is the
1:bce78c9:      * primary key of the table and the second is a value with a non-unique
1:bce78c9:      * index on it.
1:0548478:      *
1:0548478:      * @param con the connection to use (may be {@code null}, in which case
1:0548478:      *      the default connection will be used)
1:0548478:      * @param table target table
1:0548478:      * @param rows number of rows to insert
1:0548478:      * @throws SQLException if creating/populating the table fails
1:0548478:      */
1:0548478:     private void createAndInsertSimple(Connection con, String table, int rows)
1:0548478:             throws SQLException {
1:0548478:         Statement s;
1:0548478:         IndexStatsUtil myStats;
1:0548478:         if (con == null) {
1:0548478:             con = getConnection();
1:0548478:             s = createStatement();
1:0548478:             myStats = stats;
1:0548478:         } else {
1:0548478:             s = con.createStatement();
1:0548478:             myStats = new IndexStatsUtil(con);
1:0548478:         }
1:0548478:         // See if the table exists, and if so, drop it.
1:0548478:         dropIfExists(con, table);
1:0548478:         // Create table.
1:bce78c9:         s.executeUpdate(
1:bce78c9:                 "create table " + table + "(id int primary key, val int)");
1:bce78c9:         s.executeUpdate("create index NON_UNIQUE_INDEX_" + table + " on " +
1:bce78c9:                 table + "(val)");
1:0548478: 
1:0548478:         myStats.assertNoStatsTable(table);
1:0548478: 
1:0548478:         // Insert data
1:0548478:         long start = System.currentTimeMillis();
1:0548478:         println("created " + table + ", inserting " + rows + " rows");
1:0548478:         insertSimple(con, table, rows, 0);
1:0548478:         println("completed in " + (System.currentTimeMillis() - start) + " ms");
1:bce78c9:         myStats.assertNoStatsTable(table);
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Inserts the specified number of rows into the table, using an increasing
1:0548478:      * integer as the value.
1:0548478:      *
1:0548478:      * @param table target table
1:0548478:      * @param rows number of rows
1:0548478:      * @param start starting value for the first inserted row
1:0548478:      * @throws SQLException if something goes wrong
1:0548478:      */
1:0548478:     private void insertSimple(String table, int rows, int start)
1:0548478:             throws SQLException {
1:0548478:         // Use the default connection.
1:0548478:         insertSimple(getConnection(), table, rows, start);
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Inserts the specified number of rows into the table, using an increasing
1:0548478:      * integer as the value.
1:0548478:      *
1:0548478:      * @param con the connection to use
1:0548478:      * @param table target table
1:0548478:      * @param rows number of rows
1:0548478:      * @param start starting value for the first inserted row
1:0548478:      * @throws SQLException if something goes wrong
1:0548478:      * @throws NullPointerException if {@code con} is {@code null}
1:0548478:      */
1:0548478:     private void insertSimple(Connection con, String table, int rows, int start)
1:0548478:             throws SQLException {
1:0548478:         PreparedStatement ps = con.prepareStatement(
1:bce78c9:                                     "insert into " + table + " values (?,?)");
1:0548478:         boolean autoCommit = con.getAutoCommit();
1:0548478:         con.setAutoCommit(false);
1:0548478:         for (int i=start; i < start+rows; i++) {
1:0548478:             ps.setInt(1, i);
1:bce78c9:             ps.setInt(2, i % 20);
1:0548478:             ps.addBatch();
1:0548478:             if (i % 5000 == 0) {
1:0548478:                 ps.executeBatch();
1:0548478:                 con.commit();
1:0548478:             }
1:0548478:         }
1:0548478:         ps.executeBatch();
1:0548478:         con.commit();
1:0548478:         con.setAutoCommit(autoCommit);
1:0548478:     }
1:0548478: 
1:0548478:     /**
1:0548478:      * Obtains the statistics for all indexes associated with the given table in
1:0548478:      * the default database.
1:0548478:      *
1:0548478:      * @param table base table
1:0548478:      * @param expectedCount number of statistics objects to obtain
1:0548478:      * @param oldStats statistics objects to ignore
1:0548478:      * @return An array with the statistics objects obtained.
1:0548478:      * @throws SQLException if something goes wrong
1:0548478:      * @throws AssertionError if the number of statistics objects expected
1:0548478:      *      can't be obtained within the time limit
1:0548478:      *      ({@linkplain #DEFAULT_TIMEOUT})
1:0548478:      */
1:0548478:     private IdxStats[] getFilteredTableStats(String table, int expectedCount,
1:0548478:                                              IdxStats[] oldStats)
1:0548478:             throws SQLException {
1:0548478:         long start = System.currentTimeMillis();
1:0548478:         while (System.currentTimeMillis() - start < DEFAULT_TIMEOUT) {
1:0548478:             IdxStats[] ret = stats.getStatsTable(table, expectedCount);
1:0548478:             boolean doReturn = true;
1:0548478:             // Check if we have new stats (if filtering is asked for).
1:0548478:             if (oldStats != null) {
1:0548478:                 for (int i=0; i < ret.length; i++) {
1:0548478:                     for (int j=0; j < oldStats.length; j++) {
1:0548478:                         if (ret[i].equals(oldStats[j])) {
1:0548478:                             doReturn = false;
1:0548478:                             break;
1:0548478:                         }
1:0548478:                     }
1:0548478:                 }
1:0548478:             }
1:0548478:             if (doReturn) {
1:0548478:                 return ret;
1:0548478:             }
1:0548478:             Utilities.sleep(250);
1:0548478:         }
1:0548478:         fail("getting stats for table " + table + " timed out (#expected=" +
1:0548478:                 expectedCount + ", #oldStats=" +
1:0548478:                 (oldStats == null ? 0 : oldStats.length) + ")");
1:0548478:         // Silence the compiler.
1:0548478:         return null;
1:0548478:     }
1:0548478: 
1:0548478:     // Static utility methods
1:0548478: 
1:0548478:     /**
1:0548478:      * Drops the specified entity if it exists.
1:0548478:      *
1:0548478:      * @param con connection to the database
1:0548478:      * @param entity the entity to drop (i.e. table or view)
1:0548478:      */
1:0548478:     private static void dropIfExists(Connection con, String entity)
1:0548478:             throws SQLException {
1:0548478:         ResultSet tables = con.getMetaData().getTables(
1:0548478:                 null, null, entity, TYPES);
1:0548478:         while (tables.next()) {
1:0548478:             String type = tables.getString(4);
1:0548478:             if (type.equals("TABLE")) {
1:0548478:                 dropTable(con, entity);
1:0548478:             } else if (type.equals("VIEW")) {
1:0548478:                 con.createStatement().executeUpdate("drop view " + entity);
1:0548478:             } else {
1:0548478:                 fail("entity " + entity + " of unsupported type: " + type);
1:0548478:             }
1:0548478:         }
1:0548478:         tables.close();
1:0548478:     }
1:0548478: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         Test test = new BaseTestSuite(AutomaticIndexStatisticsTest.class);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:             AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:                 public Void run() {
commit:9b33bd1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
0:         Test test = new TestSuite(AutomaticIndexStatisticsTest.class);
1:         test = new CleanDatabaseTestSetup(test);
1:         test = TestConfiguration.additionalDatabaseDecorator(test, MASTERDB);
1: 
1:         return new TimeZoneTestSetup(test, "GMT");
/////////////////////////////////////////////////////////////////////////
1:      * gracefully, and that the daemon can do other work afterwards.
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Shutdown database and try to delete it.
1:         JDBCDataSource.shutdownDatabase(ds);
1:         assertDirectoryDeleted(constructDbPath(db));
commit:6051d0c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TimeZoneTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-5964: The test needs to check the timestamp stored in
1:         // SYSSTATISTICS, which is in the local timezone. Since those
1:         // timestamps may be ambiguous around the transition to or from DST,
1:         // run this test in a timezone that doesn't observe DST. The
1:         // TimeZoneTestSetup can probably be removed once DERBY-5974 is fixed.
0:         return new TimeZoneTestSetup(
0:                 TestConfiguration.additionalDatabaseDecorator(suite, MASTERDB),
0:                 "GMT");
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:afbc4ba
/////////////////////////////////////////////////////////////////////////
1:             
1:             // DERBY-6144 
1:             // Stats cannot have been created after the current time (future).
1:             assertFalse(
1:                 "expected stat created in past:now = " + now + 
1:                 ";s.created = " + s.created,
1:                 s.created.compareTo(now) > 0);
1: 
/////////////////////////////////////////////////////////////////////////
1:             assertFalse(
1:                 "expected stat created in past:now = " + now + 
1:                 ";s.created = " + s.created,
1:                 s.created.compareTo(now) > 0);
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:bce78c9
/////////////////////////////////////////////////////////////////////////
1:         // Get statistics for the non-unique index.
/////////////////////////////////////////////////////////////////////////
1:         con.prepareStatement("select * from " + TAB2 + " where id = ?");
/////////////////////////////////////////////////////////////////////////
1:         con.prepareStatement("select * from " + TAB2 + " where id = ?");
/////////////////////////////////////////////////////////////////////////
1:         // Finally, create a non-unique index on the val column.
/////////////////////////////////////////////////////////////////////////
1:         prepareStatement("select * from " + view + " where vcol2 = 7");
1:         prepareStatement("select * from " + table + " where col2 = 7");
1:         stats.assertTableStats(table, 1);
1:     }
1: 
1:     /**
1:      * Verifies that queries on a table with single-column unique indexes only
1:      * don't trigger a statistics update with the istat daemon.
1:      */
1:     public void testNoUpdateTriggeredBySingleColumnUniqueIndex()
1:             throws SQLException {
1:         // Create table.
1:         String TAB = "STAT_SCUI";
1:         dropTable(TAB);
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("create table " + TAB +
1:                 " (id int primary key, val int unique not null)");
1:         stats.assertNoStatsTable(TAB);
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into " + TAB + " values (?,?)");
1:         setAutoCommit(false);
1:         for (int i=0; i < 2000; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, i);
1:             ps.executeUpdate();
1:         }
1:         commit();
1:         // The queries below would trigger a stats update in earlier releases.
1:         PreparedStatement psSel1 = prepareStatement(
1:                 "select id from " + TAB + " where id = ?");
1:         psSel1.setInt(1, 98);
1:         JDBC.assertSingleValueResultSet(psSel1.executeQuery(), "98");
1:         PreparedStatement psSel2 = prepareStatement(
1:                 "select val from " + TAB + " where val = ?");
1:         psSel2.setInt(1, 1573);
1:         JDBC.assertSingleValueResultSet(psSel2.executeQuery(), "1573");
1:         Utilities.sleep(100); 
1:         stats.assertNoStatsTable(TAB);
1: 
1:         // Try again after inserting more data.
1:         for (int i=2000; i < 4000; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, i);
1:             ps.executeUpdate();
1:         }
1:         commit();
1:         forceRowCountEstimateUpdate(TAB);
1:         psSel1 = prepareStatement(
1:                 "select id from " + TAB + " where id = ?");
1:         psSel1.setInt(1, 117);
1:         JDBC.assertSingleValueResultSet(psSel1.executeQuery(), "117");
1:         psSel2 = prepareStatement(
1:                 "select val from " + TAB + " where val = ?");
1:         psSel2.setInt(1, 1);
1:         JDBC.assertSingleValueResultSet(psSel2.executeQuery(), "1");
1:         Utilities.sleep(100); 
1:         stats.assertNoStatsTable(TAB);
1: 
1:         // Cleanup
1:         dropTable(TAB);
/////////////////////////////////////////////////////////////////////////
1:      * The table consists of a two integer columns, where the first is the
1:      * primary key of the table and the second is a value with a non-unique
1:      * index on it.
/////////////////////////////////////////////////////////////////////////
1:      * The table consists of a two integer columns, where the first is the
1:      * primary key of the table and the second is a value with a non-unique
1:      * index on it.
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate(
1:                 "create table " + table + "(id int primary key, val int)");
1:         s.executeUpdate("create index NON_UNIQUE_INDEX_" + table + " on " +
1:                 table + "(val)");
/////////////////////////////////////////////////////////////////////////
1:         myStats.assertNoStatsTable(table);
/////////////////////////////////////////////////////////////////////////
1:                                     "insert into " + table + " values (?,?)");
1:             ps.setInt(2, i % 20);
commit:c2c2fb8
/////////////////////////////////////////////////////////////////////////
1:         String db = "singleUse/newCleanDb";
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, "databaseName", db);
1:         JDBCDataSource.setBeanProperty(ds, "createDatabase", "create");
1:         Connection con = ds.getConnection();
1:         createAndInsertSimple(con, TAB, 300);
1:         PreparedStatement ps = con.prepareStatement(
1:                 "select * from " + TAB + " where id = ?");
1:         ps.close();
1:         IdxStats[] myStats = new IndexStatsUtil(
1:                 ds.getConnection(), DEFAULT_TIMEOUT).getStatsTable(TAB, 1);
1:         JDBCDataSource.shutdownDatabase(ds);
1:         assertDirectoryDeleted(constructDbPath(db));
commit:5f1932e
/////////////////////////////////////////////////////////////////////////
1:             // Stats cannot have been created after the current time (future).
0:             assertFalse(s.created.compareTo(now) > 0);
commit:0548478
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.store.AutomaticIndexStatisticsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Timestamp;
1: import java.util.Date;
1: 
1: import javax.sql.DataSource;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.IndexStatsUtil;
1: import org.apache.derbyTesting.junit.IndexStatsUtil.IdxStats;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.Utilities;
1: 
1: /**
1:  * Tests various aspects of the automatic index statistics update feature,
1:  * which is designed to run as a background task.
1:  * <p>
1:  * Some of the tests ensure that the daemon is able to recover after
1:  * encountering various kinds of "expected errors", for instance if the table
1:  * is dropped while being scanned by the daemon.
1:  */
1: public class AutomaticIndexStatisticsTest
1:     extends BaseJDBCTestCase {
1: 
0:     private static final String MASTERDB = "masterDb";
1:     private static final String BIG_TABLE = "BIG_TABLE";
1:     private static final long DEFAULT_TIMEOUT = 20*1000;
1: 
1:     private static final String[] TYPES = new String[] {"TABLE", "VIEW"};
1: 
1:     private static boolean dbCreated;
1:     // Change this if running test cases in parallel...
1:     private static IndexStatsUtil stats;
1: 
1:     public AutomaticIndexStatisticsTest(String name) {
1: 
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite(AutomaticIndexStatisticsTest.class);
0:         return TestConfiguration.additionalDatabaseDecorator(suite, MASTERDB);
1:     }
1: 
1:     /** Initialize the default statistics helper object. */
1:     public void setUp()
1:             throws SQLException {
1:         if (stats != null) {
1:             stats.release();
1:         }
1:         stats = new IndexStatsUtil(openDefaultConnection(), DEFAULT_TIMEOUT);
1:     }
1: 
1:     /** Release the default statistics helper object. */
1:     public void tearDown()
1:             throws Exception {
1:         if (stats != null) {
1:             stats.release();
1:         }
1:         stats = null;
1:         super.tearDown();
1:     }
1: 
1:     /**
1:      * Make sure stats are created when the table grows, and that the database
1:      * can be deleted after automated stats create/update -
1:      * that is verify that there are no open file handles left behind in the
1:      * daemon.
1:      */
1:     public void testStatsCreatedOnGrowthThenDeleteDb()
1:             throws SQLException {
1:         String TAB = "TEST_GROWTH_EMPTY";
0:         createAndInsertSimple(TAB, 300);
1:         // This should trigger creation of statistics.
1:         prepareStatement("select * from " + TAB + " where id = ?");
1: 
1:         // Get statistics
0:         IdxStats[] myStats = stats.getStatsTable(TAB, 1);
1:         assertEquals(1, myStats.length);
1:         assertTrue(myStats[0].rows == 300);
0:         assertTrue(myStats[0].card == 300);
1: 
1:         // Shutdown database and try to delete it.
0:         TestConfiguration.getCurrent().shutdownDatabase();
0:         assertDirectoryDeleted(constructDbPath(
0:                 getTestConfiguration().getDefaultDatabaseName()));
1:     }
1: 
1:     /** Make sure stats are updated when the table grows. */
1:     public void testStatsUpdatedOnGrowth()
1:             throws SQLException {
1:         String TAB = "TEST_GROWTH";
1:         createAndInsertSimple(TAB, 10000);
1:         // This should trigger creation of statistics.
1:         prepareStatement("select * from " + TAB + " where id = ?");
1: 
1:         // Get statistics
1:         IdxStats[] statsPre = stats.getStatsTable(TAB, 1);
1:         assertEquals(1, statsPre.length);
1: 
1:         // Insert more rows.
1:         setAutoCommit(false);
1:         insertSimple(TAB, 50000, 10000);
1:         // Force a checkpoint to update the row estimates.
1:         forceRowCountEstimateUpdate(TAB);
1:         prepareStatement("select * from " + TAB + " where 1=1");
1:         IdxStats[] statsPost = getFilteredTableStats(TAB, 1, statsPre);
1:         assertEquals(1, statsPost.length);
1:         assertFalse(statsPre[0].equals(statsPost[0]));
1:         assertFalse(statsPre[0].after(statsPost[0]));
1:         // Insert a few more rows, should not trigger a new update
1:         insertSimple(TAB, 1000, 60000);
1:         forceRowCountEstimateUpdate(TAB);
1:         prepareStatement("select * from " + TAB + " where 2=2");
1:         // Manual wait to see if the existing stats are replaced - they should
1:         // not be
1:         Utilities.sleep(1500);
1:         IdxStats[] statsPost1 = stats.getStatsTable(TAB, 1);
1:         assertTrue(statsPost[0].equals(statsPost1[0]));
1:         assertFalse(statsPost1[0].after(statsPost[0]));
1:     }
1: 
1:     /**
1:      * Shuts down database while the daemon is scanning a table, and then
1:      * makes sure the database directory can be deleted.
1:      */
1:     public void testShutdownWhileScanningThenDelete()
1:             throws IOException, SQLException {
1:         // Need a big enough table to get the timing right.
1:         String db = "singleUse/copyShutdown";
1:         copyDb(db);
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, "databaseName", db);
1:         Connection con = ds.getConnection();
1:         String TAB = BIG_TABLE;
1: 
1:         // Trigger statistics creation.
1:         PreparedStatement ps = con.prepareStatement(
1:                 "select * from " + TAB + " where id = ?");
1:         ps.close();
1: 
1:         // Wait to make sure the scan starts.
1:         Utilities.sleep(150);
1:         // Now shut down the database.
1:         JDBCDataSource.shutdownDatabase(ds);
1:         assertDirectoryDeleted(constructDbPath(db));
1:     }
1: 
1:     /**
1:      * Drops table while the daemon is scanning it, then triggers update of
1:      * statistics of a different table, and finally shuts down and deletes the
1:      * database.
1:      */
1:     public void testDropWhileScanningThenDelete()
1:             throws IOException, SQLException {
1:         // Need a big enough table to get the timing right.
1:         String TAB1 = BIG_TABLE;
1:         String TAB2 = "SECONDARY_TABLE";
1:         String db = "singleUse/copyDrop";
1:         copyDb(db);
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, "databaseName", db);
1:         Connection con = ds.getConnection();
1:         // Create secondary table.
1:         createAndInsertSimple(con, TAB2, 20000);
1: 
1:         // Trigger statistics creation.
1:         PreparedStatement ps = con.prepareStatement(
1:                 "select * from " + TAB1 + " where id = ?");
1:         ps.close();
1:         // Wait to make sure the scan starts.
1:         Utilities.sleep(150);
1:         println("dropping table...");
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("drop table " + TAB1);
1:         stmt.close();
1: 
1:         // Trigger stats update on secondary table.
1:         IndexStatsUtil myStats =
1:                 new IndexStatsUtil(ds.getConnection(), DEFAULT_TIMEOUT);
1:         myStats.assertNoStatsTable(TAB2);
0:         ps = con.prepareStatement("select * from " + TAB2 + " where id = ?");
1:         myStats.assertTableStats(TAB2, 1);
1:         myStats.release();
1: 
1:         // Shutdown, then delete database directory.
1:         JDBCDataSource.shutdownDatabase(ds);
1:         assertDirectoryDeleted(constructDbPath(db));
1:     }
1: 
1:     /**
1:      * Tests that compressing the table while scanned makes the daemon fail
0:      * gracefully, and that the daemon can do other work afterwords.
1:      */
1:     public void testCompressWhileScanning()
1:             throws IOException, SQLException {
1:         String TAB1 = BIG_TABLE;
1:         String TAB2 = "SECONDARY_TABLE";
1:         String db = "singleUse/copyCompress";
1:         copyDb(db);
1:         DataSource ds = JDBCDataSource.getDataSource();
1:         JDBCDataSource.setBeanProperty(ds, "databaseName", db);
1:         Connection con = ds.getConnection();
1:         // Create secondary table.
1:         createAndInsertSimple(con, TAB2, 20000);
1: 
1:         // Trigger statistics creation.
1:         PreparedStatement ps = con.prepareStatement(
1:                 "select * from " + TAB1 + " where id = ?");
1:         ps.close();
1:         // Wait to make sure the scan starts.
1:         Utilities.sleep(150);
1:         println("compressing table...");
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("call SYSCS_UTIL.SYSCS_COMPRESS_TABLE('APP', '" +
1:                 TAB1 + "', 0)");
1:         stmt.close();
1:         // There should still be a statistics object written during the
1:         // compress operation.
1:         IndexStatsUtil myStats =
1:                 new IndexStatsUtil(ds.getConnection(), DEFAULT_TIMEOUT);
1:         myStats.assertTableStats(TAB1, 1);
1: 
1:         // Trigger stats update on secondary table, make sure the daemon can
1:         // still process work.
1:         myStats.assertNoStatsTable(TAB2);
0:         ps = con.prepareStatement("select * from " + TAB2 + " where id = ?");
1:         myStats.assertTableStats(TAB2, 1);
1:         myStats.release();
1:     }
1: 
1:     /**
1:      * Tests that the statistics computed are correct.
1:      *
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testStatisticsCorrectness()
1:             throws SQLException {
1:         // Create table.
1:         String TAB = "STAT_CORR";
1:         dropTable(TAB);
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("create table " + TAB +
1:                 " (id1 int, id2 int, id3 int, val int, " +
1:                 "primary key (id1, id2, id3))");
1:         stats.assertNoStatsTable(TAB);
1:         // Insert rows.
1:         PreparedStatement ps = prepareStatement("insert into " + TAB +
1:                 " values (?,?,?,?)");
1:         // # rows = 100 * 50 * 10 = 50'000
1:         setAutoCommit(false);
1:         final int rows = 100*50*10;
1:         for (int i=1; i <= 100; i++) {
1:             ps.setInt(1, i);
1:             for (int j=1; j <= 50; j++) {
1:                 ps.setInt(2, j);
1:                 for (int k=1; k <= 10; k++) {
1:                     ps.setInt(3, k);
1:                     ps.setInt(4, i*j*k % 750);
1:                     ps.executeUpdate();
1:                 }
1:             }
1:         }
1:         commit();
1:         setAutoCommit(true);
1: 
1:         // Select to trigger statistics generation.
1:         forceRowCountEstimateUpdate(TAB);
1:         JDBC.assertDrainResults(
1:                 prepareStatement("select * from " + TAB + " where id1 = 10")
1:                 .executeQuery());
1: 
1:         // We expect three stats objects for the single index; one per
1:         // leading columns combination (c1, c1-c2, and c1-c2-c3).
1:         IdxStats statsObj[] = stats.getStatsTable(TAB, 3);
1:         assertEquals(3, statsObj.length);
1: 
1:         Timestamp now = new Timestamp(new Date().getTime());
1:         for (int i=0; i < statsObj.length; i++) {
1:             IdxStats s = statsObj[i];
1:             assertEquals(rows, s.rows);
0:             assertTrue(s.created.before(now));
1:             switch (s.lcols) {
1:                 case 1:
1:                     assertEquals(100, s.card);
1:                     break;
1:                 case 2:
1:                     assertEquals(5000, s.card);
1:                     break;
1:                 case 3:
1:                     assertEquals(50000, s.card);
1:                     break;
1:             default:
1:                 fail("unexpected number of leading columns: " + s.lcols);
1:             }
1:         }
1: 
1:         // Now create a second index in the opposite order, check stats.
1:         stmt.executeUpdate("create index IDXREV on " + TAB + "(id3, id2, id1)");
1:         statsObj = stats.getStatsIndex("IDXREV", 3);
1:         assertEquals(3, statsObj.length);
1:         Timestamp earlier = now;
1:         now = new Timestamp(new Date().getTime());
1:         for (int i=0; i < statsObj.length; i++) {
1:             IdxStats s = statsObj[i];
1:             assertEquals(rows, s.rows);
1:             assertTrue("current stats created " + s.created +
1:                     ", previous stats created " + earlier,
1:                     s.created.after(earlier));
0:             assertTrue(s.created.before(now));
1:             switch (s.lcols) {
1:                 case 1:
1:                     assertEquals(10, s.card);
1:                     break;
1:                 case 2:
1:                     assertEquals(500, s.card);
1:                     break;
1:                 case 3:
1:                     assertEquals(50000, s.card);
1:                     break;
1:             default:
1:                 fail("unexpected number of leading columns: " + s.lcols);
1:             }
1:         }
1: 
0:         // Finally, create a unique index on the val column.
1:         stmt.executeUpdate("create index IDXVAL on " + TAB + "(val)");
1:         ResultSet rs = stmt.executeQuery(
1:                 "select val from " + TAB + " order by val");
1:         // Calculate number of unique values.
1:         int uniqueVals = 0;
1:         int prev = -1;
1:         while (rs.next()) {
1:             int curr = rs.getInt(1);
1:             if (curr != prev) {
1:                 uniqueVals++;
1:                 prev = curr;
1:             }
1:         }
1:         rs.close();
1:         // Get stats and check the associated values.
1:         IdxStats[] valStat = stats.getStatsIndex("IDXVAL", 1);
1:         assertEquals(1, valStat.length);
1:         assertEquals(uniqueVals, valStat[0].card);
1:         assertEquals(rows, valStat[0].rows);
1:     }
1: 
1:     public void testSelectFromSimpleView()
1:             throws SQLException {
1:         // First create a table with a few columns.
1:         String table = "VIEW_BASE_TABLE";
1:         String view = "MY_VIEW";
1: 
1:         dropIfExists(getConnection(), view);
1:         dropIfExists(getConnection(), table);
1:         Statement s = createStatement();
1:         s.execute("create table " + table + " (" +
1:                 "id int primary key, col1 int, col2 int)");
1:         s.execute("create index COL2_IDX on " + table + "(col2)");
1:         PreparedStatement ps = prepareStatement("insert into " + table +
1:                 " values (?,?,?)");
1:         setAutoCommit(false);
1:         for (int i=0; i < 30000; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, i % 15);
1:             ps.setInt(3, i % 25);
1:             ps.executeUpdate();
1:             // Commit periodically
1:             if (i % 5000 == 0) {
1:                 commit();
1:             }
1:         }
1:         commit();
1:         setAutoCommit(true);
1:         ps.close();
1: 
1:         // Create the view.
1:         s.execute("create view " + view + "(vcol_1, vcol2) " +
1:                 "AS select id, col2 from " + table);
1: 
1:         // Select from the view, using index.
1:         stats.assertNoStatsTable(table);
0:         ps = prepareStatement("select * from " + view + " where vcol2 = 7");
1:         stats.assertNoStatsTable(table);
1:         // Trigger update of the base table.
0:         ps = prepareStatement("select * from " + table + " where col2 = 7");
0:         stats.assertTableStats(table, 2);
1:     }
1: 
1:     // Utility methods
1: 
1:     /**
1:      * Creates a copy of the master db.
1:      *
1:      * @param newDbName name of the copy
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void copyDb(String newDbName)
1:             throws IOException, SQLException {
1:         if (!dbCreated) {
1:             createMasterDb();
1:         }
1: 
1:         File master = constructDbPath(
1:                 TestConfiguration.getCurrent().getPhysicalDatabaseName(
1:                     MASTERDB));
1:         final File dest = constructDbPath(newDbName);
1: 
1:         // Make sure the directory containing the database directory exists.
1:         // We expect the security manager to stop us from creating directories
1:         // where we aren't supposed to.
1:         if (!PrivilegedFileOpsForTests.exists(dest.getParentFile())) {
0:             AccessController.doPrivileged(new PrivilegedAction() {
1: 
0:                 public Object run() {
1:                     assertTrue(dest.getParentFile().mkdirs());
1:                     return null;
1:                 }
1:             });
1:         }
1: 
1:         PrivilegedFileOpsForTests.copy(master, dest);
1:     }
1: 
1:     /**
1:      * Creates the default/master db with a larger number of rows.
1:      *
1:      * @throws SQLException if creating the database fails
1:      */
1:     private void createMasterDb()
1:             throws SQLException {
1:         long start = System.currentTimeMillis();
1:         String table = BIG_TABLE;
1:         int rows = 1*1000*1000;
1:         DataSource ds1 = JDBCDataSource.getDataSourceLogical(MASTERDB);
1:         JDBCDataSource.setBeanProperty(ds1, "createDatabase", "create");
1:         Connection con = ds1.getConnection();
1:         // Check if the table exists, if so, drop it.
1:         dropIfExists(con, table);
1:         // Create the table.
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("create table " + table + "(id int primary key)");
1:         stmt.close();
1: 
1:         // Insert data
1:         con.setAutoCommit(false);
1:         PreparedStatement ps = con.prepareStatement("insert into " + table +
1:                 " values ?");
1:         for (int i=0; i < rows; i++) {
1:             ps.setInt(1, i);
1:             ps.addBatch();
1:             if (i % 5000 == 0) {
1:                 ps.executeBatch();
1:                 con.commit();
1:             }
1:         }
1:         ps.executeBatch();
1:         con.commit();
1:         con.close();
1:         println("created master db with " + rows + " rows in " +
1:                 ((System.currentTimeMillis() - start) / 1000) + " seconds");
1: 
1:         // Shut down the master db, we will copy it later.
1:         JDBCDataSource.shutdownDatabase(
1:                 JDBCDataSource.getDataSourceLogical(MASTERDB));
1: 
1:         dbCreated = true;
1: 
1:     }
1: 
1:     /**
1:      * Forces Derby to update the row count estimate by doing a full table
1:      * scan and then invoking a checkpoint.
1:      *
1:      * @param table target table
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void forceRowCountEstimateUpdate(String table)
1:             throws SQLException {
1:         Statement stmt = createStatement();
1:         JDBC.assertDrainResults(
1:                 stmt.executeQuery("select count(*) from " + table));
1:         stmt.execute("call SYSCS_UTIL.SYSCS_CHECKPOINT_DATABASE()");
1:         stmt.close();
1:     }
1: 
1:     /**
1:      * Constructs the path to the database base directory.
1:      *
1:      * @param relDbDirName the database name (relative)
1:      * @return The path to the database.
1:      */
1:     private File constructDbPath(String relDbDirName) {
1:         // Example:
1:         //     "singleUse/readOnly" -> "<derby.system.home>/singleUse/readOnly"
1:         File f = new File(getSystemProperty("derby.system.home"));
1:         return new File(f, relDbDirName);
1:     }
1: 
1:     /**
1:      * Default method to create and populate a simple test table.
1:      * <p>
0:      * The table consists of a single integer column, which is also the primary
0:      * key of the table.
1:      *
1:      * @param table target table
1:      * @param rows number of rows to insert
1:      * @throws SQLException if creating/populating the table fails
1:      */
1:     private void createAndInsertSimple(String table, int rows)
1:             throws SQLException {
1:         createAndInsertSimple(null, table, rows);
1:     }
1: 
1:     /**
1:      * Default method to create and populate a simple test table.
1:      * <p>
0:      * The table consists of a single integer column, which is also the primary
0:      * key of the table.
1:      *
1:      * @param con the connection to use (may be {@code null}, in which case
1:      *      the default connection will be used)
1:      * @param table target table
1:      * @param rows number of rows to insert
1:      * @throws SQLException if creating/populating the table fails
1:      */
1:     private void createAndInsertSimple(Connection con, String table, int rows)
1:             throws SQLException {
1:         Statement s;
1:         IndexStatsUtil myStats;
1:         if (con == null) {
1:             con = getConnection();
1:             s = createStatement();
1:             myStats = stats;
1:         } else {
1:             s = con.createStatement();
1:             myStats = new IndexStatsUtil(con);
1:         }
1:         // See if the table exists, and if so, drop it.
1:         dropIfExists(con, table);
1:         // Create table.
0:         s.executeUpdate("create table " + table + "(id int primary key)");
1: 
1:         myStats.assertNoStatsTable(table);
1: 
1:         // Insert data
1:         long start = System.currentTimeMillis();
1:         println("created " + table + ", inserting " + rows + " rows");
1:         insertSimple(con, table, rows, 0);
1:         println("completed in " + (System.currentTimeMillis() - start) + " ms");
1:     }
1: 
1:     /**
1:      * Inserts the specified number of rows into the table, using an increasing
1:      * integer as the value.
1:      *
1:      * @param table target table
1:      * @param rows number of rows
1:      * @param start starting value for the first inserted row
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void insertSimple(String table, int rows, int start)
1:             throws SQLException {
1:         // Use the default connection.
1:         insertSimple(getConnection(), table, rows, start);
1:     }
1: 
1:     /**
1:      * Inserts the specified number of rows into the table, using an increasing
1:      * integer as the value.
1:      *
1:      * @param con the connection to use
1:      * @param table target table
1:      * @param rows number of rows
1:      * @param start starting value for the first inserted row
1:      * @throws SQLException if something goes wrong
1:      * @throws NullPointerException if {@code con} is {@code null}
1:      */
1:     private void insertSimple(Connection con, String table, int rows, int start)
1:             throws SQLException {
1:         PreparedStatement ps = con.prepareStatement(
0:                                     "insert into " + table + " values ?");
1:         boolean autoCommit = con.getAutoCommit();
1:         con.setAutoCommit(false);
1:         for (int i=start; i < start+rows; i++) {
1:             ps.setInt(1, i);
1:             ps.addBatch();
1:             if (i % 5000 == 0) {
1:                 ps.executeBatch();
1:                 con.commit();
1:             }
1:         }
1:         ps.executeBatch();
1:         con.commit();
1:         con.setAutoCommit(autoCommit);
1:     }
1: 
1:     /**
1:      * Obtains the statistics for all indexes associated with the given table in
1:      * the default database.
1:      *
1:      * @param table base table
1:      * @param expectedCount number of statistics objects to obtain
1:      * @param oldStats statistics objects to ignore
1:      * @return An array with the statistics objects obtained.
1:      * @throws SQLException if something goes wrong
1:      * @throws AssertionError if the number of statistics objects expected
1:      *      can't be obtained within the time limit
1:      *      ({@linkplain #DEFAULT_TIMEOUT})
1:      */
1:     private IdxStats[] getFilteredTableStats(String table, int expectedCount,
1:                                              IdxStats[] oldStats)
1:             throws SQLException {
1:         long start = System.currentTimeMillis();
1:         while (System.currentTimeMillis() - start < DEFAULT_TIMEOUT) {
1:             IdxStats[] ret = stats.getStatsTable(table, expectedCount);
1:             boolean doReturn = true;
1:             // Check if we have new stats (if filtering is asked for).
1:             if (oldStats != null) {
1:                 for (int i=0; i < ret.length; i++) {
1:                     for (int j=0; j < oldStats.length; j++) {
1:                         if (ret[i].equals(oldStats[j])) {
1:                             doReturn = false;
1:                             break;
1:                         }
1:                     }
1:                 }
1:             }
1:             if (doReturn) {
1:                 return ret;
1:             }
1:             Utilities.sleep(250);
1:         }
1:         fail("getting stats for table " + table + " timed out (#expected=" +
1:                 expectedCount + ", #oldStats=" +
1:                 (oldStats == null ? 0 : oldStats.length) + ")");
1:         // Silence the compiler.
1:         return null;
1:     }
1: 
1:     // Static utility methods
1: 
1:     /**
1:      * Drops the specified entity if it exists.
1:      *
1:      * @param con connection to the database
1:      * @param entity the entity to drop (i.e. table or view)
1:      */
1:     private static void dropIfExists(Connection con, String entity)
1:             throws SQLException {
1:         ResultSet tables = con.getMetaData().getTables(
1:                 null, null, entity, TYPES);
1:         while (tables.next()) {
1:             String type = tables.getString(4);
1:             if (type.equals("TABLE")) {
1:                 dropTable(con, entity);
1:             } else if (type.equals("VIEW")) {
1:                 con.createStatement().executeUpdate("drop view " + entity);
1:             } else {
1:                 fail("entity " + entity + " of unsupported type: " + type);
1:             }
1:         }
1:         tables.close();
1:     }
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:14621ff
/////////////////////////////////////////////////////////////////////////
1:     // used also by Derby5582AutomaticIndexStatisticsTest so just protected
commit:1690ef6
/////////////////////////////////////////////////////////////////////////
0: 	// used also by Derby5582AutomaticIndexStatisticsTest so just protected
1:     protected static final String MASTERDB = "masterDb";
============================================================================