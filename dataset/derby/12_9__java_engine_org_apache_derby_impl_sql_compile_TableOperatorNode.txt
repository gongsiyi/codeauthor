1:fe77ca5: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.TableOperatorNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
17:fe77ca5: 
3:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: package	org.apache.derby.impl.sql.compile;
1:fe77ca5: 
1:3bb140c: import java.util.Properties;
1:fe77ca5: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:fe77ca5: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizable;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizer;
1:fe77ca5: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1:fe77ca5: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:fe77ca5: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:fe77ca5: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:fe77ca5: import org.apache.derby.iapi.util.JBitSet;
1:fe77ca5: 
4:fe77ca5: /**
1:fe77ca5:  * A TableOperatorNode represents a relational operator like UNION, INTERSECT,
1:fe77ca5:  * JOIN, etc. that takes two tables as parameters and returns a table.  The
1:fe77ca5:  * parameters it takes are represented as ResultSetNodes.
13:fe77ca5:  *
1:fe77ca5:  * Currently, all known table operators are binary operators, so there are no
1:fe77ca5:  * subclasses of this node type called "BinaryTableOperatorNode" and
1:fe77ca5:  * "UnaryTableOperatorNode".
1:fe77ca5:  *
1:fe77ca5:  */
1:fe77ca5: 
1:03eae1d: abstract class TableOperatorNode extends FromTable
1:fe77ca5: {
1:fe77ca5: 	ResultSetNode	leftResultSet;
1:fe77ca5: 	ResultSetNode	rightResultSet;
1:fe77ca5: 	Optimizer		leftOptimizer;
1:fe77ca5: 	Optimizer		rightOptimizer;
1:fe77ca5: 	private boolean 	leftModifyAccessPathsDone;
1:fe77ca5: 	private boolean 	rightModifyAccessPathsDone;
1:fe77ca5: 
1:3bb140c:     /**
1:3bb140c:      * Constructor for a TableOperatorNode.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param leftResultSet		The ResultSetNode on the left side of this node
1:fe77ca5: 	 * @param rightResultSet	The ResultSetNode on the right side of this node
1:fe77ca5: 	 * @param tableProperties	Properties list associated with the table
1:3bb140c:      * @param cm                The context manager
1:fe77ca5: 	 *
2:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     TableOperatorNode(ResultSetNode  leftResultSet,
1:3bb140c:                       ResultSetNode  rightResultSet,
1:3bb140c:                       Properties     tableProperties,
1:3bb140c:                       ContextManager cm)
2:fe77ca5: 				throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		/* correlationName is always null */
1:3bb140c:         super(null, tableProperties, cm);
1:3bb140c:         this.leftResultSet = leftResultSet;
1:3bb140c:         this.rightResultSet = rightResultSet;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:f8b521a: 	 * DERBY-4365
1:f8b521a: 	 * Bind untyped nulls to the types in the given ResultColumnList.
1:f8b521a: 	 * This is used for binding the nulls in row constructors and
1:f8b521a: 	 * table constructors.  
1:f8b521a: 	 *
1:f8b521a: 	 * @param rcl	The ResultColumnList with the types to bind nulls to
1:f8b521a: 	 *
1:f8b521a: 	 * @exception StandardException		Thrown on error
1:f8b521a: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindUntypedNullsToResultColumns(ResultColumnList rcl)
1:f8b521a: 	throws StandardException
1:f8b521a: 	{
1:f8b521a: 		leftResultSet.bindUntypedNullsToResultColumns(rcl);
1:f8b521a: 		rightResultSet.bindUntypedNullsToResultColumns(rcl);
1:f8b521a: 	}
1:f8b521a: 
1:f8b521a: 	/**
1:fe77ca5: 	 * @see Optimizable#modifyAccessPath
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:fe77ca5: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		boolean callModifyAccessPaths = false;
1:fe77ca5: 
1:fe77ca5: 		if (leftResultSet instanceof FromTable)
1:fe77ca5: 		{
1:fe77ca5: 			if (leftOptimizer != null)
1:0f0f8ad: 			{
1:0f0f8ad: 				/* We know leftOptimizer's list of Optimizables consists of
1:0f0f8ad: 				 * exactly one Optimizable, and we know that the Optimizable
1:0f0f8ad: 				 * is actually leftResultSet (see optimizeSource() of this
1:0f0f8ad: 				 * class). That said, the following call to modifyAccessPaths()
1:0f0f8ad: 				 * will effectively replace leftResultSet as it exists in
1:0f0f8ad: 				 * leftOptimizer's list with a "modified" node that *may* be
1:0f0f8ad: 				 * different from the original leftResultSet--for example, it
1:0f0f8ad: 				 * could be a new DISTINCT node whose child is the original
1:0f0f8ad: 				 * leftResultSet.  So after we've modified the node's access
1:0f0f8ad: 				 * path(s) we have to explicitly set this.leftResulSet to
1:0f0f8ad: 				 * point to the modified node. Otherwise leftResultSet would
1:0f0f8ad: 				 * continue to point to the node as it existed *before* it was
1:0f0f8ad: 				 * modified, and that could lead to incorrect behavior for
1:0f0f8ad: 				 * certain queries.  DERBY-1852.
1:0f0f8ad: 				 */
1:fe77ca5: 				leftOptimizer.modifyAccessPaths();
1:0f0f8ad: 				leftResultSet = (ResultSetNode)
1:7f6b163: 					leftOptimizer.getOptimizable(0);
1:0f0f8ad: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				leftResultSet = 
1:fe77ca5: 					(ResultSetNode)
1:fe77ca5: 						((FromTable) leftResultSet).modifyAccessPath(outerTables);
1:fe77ca5: 			}
1:fe77ca5: 			leftModifyAccessPathsDone = true;
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			callModifyAccessPaths = true;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (rightResultSet instanceof FromTable)
1:fe77ca5: 		{
1:fe77ca5: 			if (rightOptimizer != null)
1:0f0f8ad: 			{
1:0f0f8ad: 				/* For the same reasons outlined above we need to make sure
1:0f0f8ad: 				 * we set rightResultSet to point to the *modified* right result
1:0f0f8ad: 				 * set node, which sits at position "0" in rightOptimizer's
1:0f0f8ad: 				 * list.
1:0f0f8ad: 				 */
1:fe77ca5: 				rightOptimizer.modifyAccessPaths();
1:0f0f8ad: 				rightResultSet = (ResultSetNode)
1:7f6b163: 					rightOptimizer.getOptimizable(0);
1:0f0f8ad: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				rightResultSet = 
1:fe77ca5: 					(ResultSetNode)
1:fe77ca5: 						((FromTable) rightResultSet).modifyAccessPath(outerTables);
1:fe77ca5: 			}
1:fe77ca5: 			rightModifyAccessPathsDone = true;
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			callModifyAccessPaths = true;
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		if (callModifyAccessPaths)
1:fe77ca5: 		{
1:fe77ca5: 			return (Optimizable) modifyAccessPaths();
1:fe77ca5: 		}
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** @see Optimizable#verifyProperties 
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:fe77ca5: 	public void verifyProperties(DataDictionary dDictionary)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		if (leftResultSet instanceof Optimizable)
1:fe77ca5: 		{
1:fe77ca5: 			((Optimizable) leftResultSet).verifyProperties(dDictionary);
1:fe77ca5: 		}
1:fe77ca5: 		if (rightResultSet instanceof Optimizable)
1:fe77ca5: 		{
1:fe77ca5: 			((Optimizable) rightResultSet).verifyProperties(dDictionary);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		super.verifyProperties(dDictionary);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:acdff3c: 	 * @see Optimizable#updateBestPlanMap
1:fe77ca5: 	 *
1:acdff3c: 	 * Makes a call to add/load/remove the plan mapping for this node,
1:62d4560: 	 * and then makes the necessary call to recurse on this node's
1:acdff3c: 	 * left and right child, in order to ensure that we've handled
1:acdff3c: 	 * the full plan all the way down this node's subtree. 
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:acdff3c: 	public void updateBestPlanMap(short action,
1:e07631a: 		Object planKey) throws StandardException
1:fe77ca5: 	{
1:acdff3c: 		super.updateBestPlanMap(action, planKey);
1:fe77ca5: 
1:e07631a: 		// Now walk the children.  Note that if either child is not
1:e07631a: 		// an Optimizable and the call to child.getOptimizerImpl()
1:e07631a: 		// returns null, then that means we haven't tried to optimize
1:e07631a: 		// the child yet.  So in that case there's nothing to
1:e07631a: 		// add/load.
1:fe77ca5: 
1:62d4560: 		if (leftResultSet instanceof Optimizable)
1:5872305: 		{
1:62d4560: 			((Optimizable)leftResultSet).
1:acdff3c: 				updateBestPlanMap(action, planKey);
1:fe77ca5: 		}
1:e07631a: 		else if (leftResultSet.getOptimizerImpl() != null)
1:5872305: 		{
1:62d4560: 			leftResultSet.getOptimizerImpl().
1:acdff3c: 				updateBestPlanMaps(action, planKey);
1:5872305: 		}
1:fe77ca5: 
1:62d4560: 		if (rightResultSet instanceof Optimizable)
4:62d4560: 		{
1:62d4560: 			((Optimizable)rightResultSet).
1:acdff3c: 				updateBestPlanMap(action, planKey);
1:5872305: 		}
1:e07631a: 		else if (rightResultSet.getOptimizerImpl() != null)
1:62d4560: 		{
1:62d4560: 			rightResultSet.getOptimizerImpl().
1:acdff3c: 				updateBestPlanMaps(action, planKey);
4:62d4560: 		}
1:62d4560: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:fe77ca5: 	 * for how this should be done for tree printing.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	This object as a String
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:fe77ca5: 	public String toString()
1:fe77ca5: 	{
1:fe77ca5: 		if (SanityManager.DEBUG)
1:fe77ca5: 		{
1:03eae1d: 			return "nestedInParens: " + false + "\n" +
1:fe77ca5: 				super.toString();
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			return "";
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:fe77ca5: 	 * how tree printing is supposed to work.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param depth		The depth of this node in the tree
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:fe77ca5: 	{
1:fe77ca5: 		if (SanityManager.DEBUG)
1:fe77ca5: 		{
1:fe77ca5: 			super.printSubNodes(depth);
1:fe77ca5: 
1:fe77ca5: 			if (leftResultSet != null)
1:fe77ca5: 			{
1:fe77ca5: 				printLabel(depth, "leftResultSet: ");
1:c9a1206: 				leftResultSet.treePrint(depth + 1);
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			if (rightResultSet != null)
1:fe77ca5: 			{
1:fe77ca5: 				printLabel(depth, "rightResultSet: ");
1:c9a1206: 				rightResultSet.treePrint(depth + 1);
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the leftResultSet from this node.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return ResultSetNode	The leftResultSet from this node.
1:fe77ca5: 	 */
1:3bb140c:     ResultSetNode getLeftResultSet()
1:fe77ca5: 	{
1:fe77ca5: 		return leftResultSet;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the rightResultSet from this node.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return ResultSetNode	The rightResultSet from this node.
1:fe77ca5: 	 */
1:3bb140c:     ResultSetNode getRightResultSet()
1:fe77ca5: 	{
1:fe77ca5: 		return rightResultSet;
1:fe77ca5: 	}
1:fe77ca5: 
1:3bb140c:     ResultSetNode getLeftmostResultSet()
1:fe77ca5: 	{
1:fe77ca5: 		if (leftResultSet instanceof TableOperatorNode)
1:fe77ca5: 		{
1:fe77ca5: 			return ((TableOperatorNode) leftResultSet).getLeftmostResultSet();
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			return leftResultSet;
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:3bb140c:     void setLeftmostResultSet(ResultSetNode newLeftResultSet)
1:fe77ca5: 	{
1:fe77ca5: 		if (leftResultSet instanceof TableOperatorNode)
1:fe77ca5: 		{
1:fe77ca5: 			((TableOperatorNode) leftResultSet).setLeftmostResultSet(newLeftResultSet);
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			this.leftResultSet = newLeftResultSet;
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set the (query block) level (0-based) for this FromTable.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param level		The query block level for this FromTable.
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     void setLevel(int level)
1:fe77ca5: 	{
1:fe77ca5: 		super.setLevel(level);
1:fe77ca5: 		if (leftResultSet instanceof FromTable)
1:fe77ca5: 		{
1:fe77ca5: 			((FromTable) leftResultSet).setLevel(level);
1:fe77ca5: 		}
1:fe77ca5: 		if (rightResultSet instanceof FromTable)
1:fe77ca5: 		{
1:fe77ca5: 			((FromTable) rightResultSet).setLevel(level);
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Return the exposed name for this table, which is the name that
1:fe77ca5: 	 * can be used to refer to this table in the rest of the query.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	The exposed name for this table.
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     String getExposedName()
1:fe77ca5: 	{
1:fe77ca5: 		return null;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Mark whether or not this node is nested in parens.  (Useful to parser
2:fe77ca5: 	 * since some trees get created left deep and others right deep.)
1:03eae1d: 	 * The resulting state of this cal was never used so its
1:03eae1d: 	 * field was removed to save runtimespace for this node.
1:03eae1d: 	 * Further cleanup can be done including parser changes
1:03eae1d: 	 * if this call is really nor required.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param nestedInParens	Whether or not this node is nested in parens.
1:fe77ca5: 	 */
1:3bb140c:     void setNestedInParens(boolean nestedInParens)
1:fe77ca5: 	{
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind the non VTI tables in this TableOperatorNode. This means getting
1:fe77ca5: 	 * their TableDescriptors from the DataDictionary.
1:fe77ca5: 	 * We will build an unbound RCL for this node.  This RCL must be
1:fe77ca5: 	 * "bound by hand" after the underlying left and right RCLs
1:fe77ca5: 	 * are bound.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param dataDictionary	The DataDictionary to use for binding
1:fe77ca5: 	 * @param fromListParam		FromList to use/append to.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	ResultSetNode		Returns this.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode bindNonVTITables(DataDictionary dataDictionary,
2:fe77ca5: 						  FromList fromListParam) 
1:fe77ca5: 							throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		leftResultSet = leftResultSet.bindNonVTITables(dataDictionary, fromListParam);
1:fe77ca5: 		rightResultSet = rightResultSet.bindNonVTITables(dataDictionary, fromListParam);
1:fe77ca5: 		/* Assign the tableNumber */
1:fe77ca5: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
1:fe77ca5: 			tableNumber = getCompilerContext().getNextTableNumber();
1:fe77ca5: 
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind the VTI tables in this TableOperatorNode. This means getting
1:fe77ca5: 	 * their TableDescriptors from the DataDictionary.
1:fe77ca5: 	 * We will build an unbound RCL for this node.  This RCL must be
1:fe77ca5: 	 * "bound by hand" after the underlying left and right RCLs
1:fe77ca5: 	 * are bound.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param fromListParam		FromList to use/append to.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	ResultSetNode		Returns this.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode bindVTITables(FromList fromListParam)
1:fe77ca5: 							throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		leftResultSet = leftResultSet.bindVTITables(fromListParam);
1:fe77ca5: 		rightResultSet = rightResultSet.bindVTITables(fromListParam);
1:fe77ca5: 
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind the expressions under this TableOperatorNode.  This means
1:fe77ca5: 	 * binding the sub-expressions, as well as figuring out what the
1:fe77ca5: 	 * return type is for each expression.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindExpressions(FromList fromListParam)
1:fe77ca5: 				throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		/*
2:fe77ca5: 		** Parameters not allowed in select list of either side of union,
2:fe77ca5: 		** except when the union is for a table constructor.
1:fe77ca5: 		*/
1:fe77ca5: 		if ( ! (this instanceof UnionNode) ||
1:fe77ca5: 			 ! ((UnionNode) this).tableConstructor())
1:fe77ca5: 		{
1:fe77ca5: 			leftResultSet.rejectParameters();
1:fe77ca5: 			rightResultSet.rejectParameters();
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		leftResultSet.bindExpressions(fromListParam);
1:fe77ca5: 		rightResultSet.bindExpressions(fromListParam);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Check for (and reject) ? parameters directly under the ResultColumns.
1:fe77ca5: 	 * This is done for SELECT statements.  For TableOperatorNodes, we
1:fe77ca5: 	 * simply pass the check through to the left and right children.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown if a ? parameter found
1:fe77ca5: 	 *									directly under a ResultColumn
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     void rejectParameters() throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		leftResultSet.rejectParameters();
1:fe77ca5: 		rightResultSet.rejectParameters();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind the expressions in this ResultSetNode if it has tables.  This means binding the
1:fe77ca5: 	 * sub-expressions, as well as figuring out what the return type is for
1:fe77ca5: 	 * each expression.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param fromListParam		FromList to use/append to.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindExpressionsWithTables(FromList fromListParam)
1:fe77ca5: 					throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		/*
1:6200b38: 		** Parameters not allowed in select list of either side of a set operator,
1:6200b38: 		** except when the set operator is for a table constructor.
1:fe77ca5: 		*/
1:fe77ca5: 		if ( ! (this instanceof UnionNode) ||
1:fe77ca5: 			 ! ((UnionNode) this).tableConstructor())
1:fe77ca5: 		{
1:fe77ca5: 			leftResultSet.rejectParameters();
1:fe77ca5: 			rightResultSet.rejectParameters();
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		leftResultSet.bindExpressionsWithTables(fromListParam);
1:fe77ca5: 		rightResultSet.bindExpressionsWithTables(fromListParam);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind the result columns of this ResultSetNode when there is no
1:fe77ca5: 	 * base table to bind them to.  This is useful for SELECT statements,
1:fe77ca5: 	 * where the result columns get their types from the expressions that
1:fe77ca5: 	 * live under them.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param fromListParam		FromList to use/append to.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindResultColumns(FromList fromListParam)
1:fe77ca5: 					throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		leftResultSet.bindResultColumns(fromListParam);
1:fe77ca5: 		rightResultSet.bindResultColumns(fromListParam);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Bind the result columns for this ResultSetNode to a base table.
1:fe77ca5: 	 * This is useful for INSERT and UPDATE statements, where the
1:fe77ca5: 	 * result columns get their types from the table being updated or
1:fe77ca5: 	 * inserted into.
1:fe77ca5: 	 * If a result column list is specified, then the verification that the 
1:fe77ca5: 	 * result column list does not contain any duplicates will be done when
1:fe77ca5: 	 * binding them by name.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param targetTableDescriptor	The TableDescriptor for the table being
1:fe77ca5: 	 *				updated or inserted into
1:fe77ca5: 	 * @param targetColumnList	For INSERT statements, the user
1:fe77ca5: 	 *					does not have to supply column
1:fe77ca5: 	 *					names (for example, "insert into t
1:fe77ca5: 	 *					values (1,2,3)".  When this
1:fe77ca5: 	 *					parameter is null, it means that
1:fe77ca5: 	 *					the user did not supply column
1:fe77ca5: 	 *					names, and so the binding should
1:fe77ca5: 	 *					be done based on order.  When it
1:fe77ca5: 	 *					is not null, it means do the binding
1:fe77ca5: 	 *					by name, not position.
1:fe77ca5: 	 * @param statement			Calling DMLStatementNode (Insert or Update)
1:fe77ca5: 	 * @param fromListParam		FromList to use/append to.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:8fe3166:     void bindResultColumns(TableDescriptor targetTableDescriptor,
1:8fe3166:             FromVTI targetVTI, ResultColumnList targetColumnList,
1:8fe3166:             DMLStatementNode statement, FromList fromListParam)
1:fe77ca5: 				throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		leftResultSet.bindResultColumns(targetTableDescriptor,
1:fe77ca5: 										targetVTI,
1:fe77ca5: 										targetColumnList,
1:fe77ca5: 										statement, fromListParam);
1:fe77ca5: 		rightResultSet.bindResultColumns(targetTableDescriptor,
1:fe77ca5: 										targetVTI,
1:fe77ca5: 										targetColumnList,
1:fe77ca5: 										statement, fromListParam);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** 
1:fe77ca5: 	 * Determine whether or not the specified name is an exposed name in
1:fe77ca5: 	 * the current query block.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param name	The specified name to search for as an exposed name.
1:fe77ca5: 	 * @param schemaName	Schema name, if non-null.
1:fe77ca5: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1:fe77ca5: 	 *						names or match on table id.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return The FromTable, if any, with the exposed name.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:8fe3166:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		FromTable result = leftResultSet.getFromTableByName(name, schemaName, exactMatch);
1:fe77ca5: 
1:fe77ca5: 		/* We search both sides for a TableOperatorNode (join nodes)
1:fe77ca5: 		 * but only the left side for a UnionNode.
1:fe77ca5: 		 */
1:fe77ca5: 		if (result == null)
1:fe77ca5: 		{
1:fe77ca5: 			result = rightResultSet.getFromTableByName(name, schemaName, exactMatch);
1:fe77ca5: 		}
1:fe77ca5: 		return result;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** 
1:fe77ca5: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1:fe77ca5: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1:fe77ca5: 	 * that ResultColumn must percolate up to the new PRN.  However,
1:fe77ca5: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1:fe77ca5: 	 * which points to the FromTable and the ResultColumn that is the source for
1:fe77ca5: 	 * the ColumnReference.  
1:fe77ca5: 	 * (The new PRN will have the original of the ResultColumnList and
1:fe77ca5: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1:fe77ca5: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1:fe77ca5: 	 * will remain at the FromTable, with the PRN getting a new 
1:fe77ca5: 	 * VirtualColumnNode for each ResultColumn.expression.)
1:fe77ca5: 	 * We then project out the non-referenced columns.  If there are no referenced
1:fe77ca5: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1:fe77ca5: 	 * whose expression is 1.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param numTables			Number of tables in the DML Statement
1:fe77ca5: 	 * @param gbl				The group by list, if any
1:fe77ca5: 	 * @param fromList			The from list, if any
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode preprocess(int numTables,
1:fe77ca5: 									GroupByList gbl,
1:fe77ca5: 									FromList fromList)
1:fe77ca5: 								throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		leftResultSet = leftResultSet.preprocess(numTables, gbl, fromList);
1:fe77ca5: 		/* If leftResultSet is a FromSubquery, then we must explicitly extract
1:fe77ca5: 		 * out the subquery (flatten it).  (SelectNodes have their own
1:fe77ca5: 		 * method of flattening them.
1:fe77ca5: 		 */
1:fe77ca5: 		if (leftResultSet instanceof FromSubquery)
1:fe77ca5: 		{
1:fe77ca5: 			leftResultSet = ((FromSubquery) leftResultSet).extractSubquery(numTables);
1:fe77ca5: 		}
1:fe77ca5: 		rightResultSet = rightResultSet.preprocess(numTables, gbl, fromList);
1:fe77ca5: 		/* If rightResultSet is a FromSubquery, then we must explicitly extract
1:fe77ca5: 		 * out the subquery (flatten it).  (SelectNodes have their own
1:fe77ca5: 		 * method of flattening them.
1:fe77ca5: 		 */
1:fe77ca5: 		if (rightResultSet instanceof FromSubquery)
1:fe77ca5: 		{
1:fe77ca5: 			rightResultSet = ((FromSubquery) rightResultSet).extractSubquery(numTables);
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		/* Build the referenced table map (left || right) */
1:11f7ee3: 		setReferencedTableMap( (JBitSet) leftResultSet.getReferencedTableMap().clone() );
1:11f7ee3:         getReferencedTableMap().or(rightResultSet.getReferencedTableMap());
1:11f7ee3: 		getReferencedTableMap().set(tableNumber);
1:fe77ca5: 
1:fe77ca5: 		/* Only generate a PRN if this node is not a flattenable join node. */
1:fe77ca5: 		if (isFlattenableJoinNode())
1:fe77ca5: 		{
1:fe77ca5: 			return this;
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			/* Project out any unreferenced RCs before we generate the PRN.
1:fe77ca5: 			 * NOTE: We have to do this at the end of preprocess since it has to 
1:fe77ca5: 			 * be from the bottom up.  We can't do it until the join expression is 
1:fe77ca5: 			 * bound, since the join expression may contain column references that
1:fe77ca5: 			 * are not referenced anywhere else above us.
1:fe77ca5: 			 */
1:fe77ca5:             projectResultColumns();
1:fe77ca5: 			return genProjectRestrict(numTables);
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5:     /**
1:fe77ca5:      * Find the unreferenced result columns and project them out. This is used in pre-processing joins
1:fe77ca5:      * that are not flattened into the where clause.
1:fe77ca5:      */
1:3bb140c:     @Override
1:fe77ca5:     void projectResultColumns() throws StandardException
1:fe77ca5:     {
1:11f7ee3:         getResultColumns().doProjection();
1:fe77ca5:     }
1:fe77ca5:     
1:fe77ca5:     /**
1:fe77ca5:      * Set the referenced columns in the column list if it may not be correct.
1:fe77ca5:      */
1:fe77ca5:     void setReferencedColumns()
1:fe77ca5:     {}
1:fe77ca5:     
1:fe77ca5: 	/**
1:fe77ca5: 	 * Optimize a TableOperatorNode. 
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param dataDictionary	The DataDictionary to use for optimization
1:fe77ca5: 	 * @param predicateList		The PredicateList to apply.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	ResultSetNode	The top of the optimized query tree
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode optimize(DataDictionary dataDictionary,
1:fe77ca5: 								  PredicateList predicateList,
1:fe77ca5: 								  double outerRows)
1:fe77ca5: 				throws StandardException
1:fe77ca5: 	{
1:11f7ee3:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
1:fe77ca5: 
1:fe77ca5: 		/* RESOLVE: This is just a stub for now */
1:fe77ca5: 		leftResultSet = leftResultSet.optimize(
3:fe77ca5: 											dataDictionary,
1:3bb140c: 											predicateList,
1:fe77ca5: 											outerRows);
1:fe77ca5: 		rightResultSet = rightResultSet.optimize(
1:3bb140c: 											dataDictionary,
3:fe77ca5: 											predicateList,
1:fe77ca5: 											outerRows);
1:fe77ca5: 
1:fe77ca5: 		/* The cost is the sum of the two child costs */
1:11f7ee3: 		getCostEstimate().setCost(leftResultSet.getCostEstimate().getEstimatedCost(),
1:fe77ca5: 							 leftResultSet.getCostEstimate().rowCount(),
1:fe77ca5: 							 leftResultSet.getCostEstimate().singleScanRowCount() +
1:fe77ca5: 							 rightResultSet.getCostEstimate().singleScanRowCount());
1:fe77ca5: 
1:11f7ee3: 		getCostEstimate().add(rightResultSet.getCostEstimate(), getCostEstimate());
1:fe77ca5: 
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * @see ResultSetNode#modifyAccessPaths
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode modifyAccessPaths() throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		/* Beetle 4454 - union all with another union all would modify access
1:fe77ca5: 		 * paths twice causing NullPointerException, make sure we don't
1:fe77ca5: 		 * do this again, if we have already done it in modifyAccessPaths(outertables)
1:fe77ca5: 		 */
1:fe77ca5: 		if (!leftModifyAccessPathsDone)
1:0f0f8ad: 		{
1:fe77ca5: 			if (leftOptimizer != null)
1:fe77ca5: 			{
1:0f0f8ad: 				/* We know leftOptimizer's list of Optimizables consists of
1:0f0f8ad: 				 * exactly one Optimizable, and we know that the Optimizable
1:0f0f8ad: 				 * is actually leftResultSet (see optimizeSource() of this
1:0f0f8ad: 				 * class). That said, the following call to modifyAccessPaths()
1:0f0f8ad: 				 * will effectively replace leftResultSet as it exists in
1:0f0f8ad: 				 * leftOptimizer's list with a "modified" node that *may* be
1:0f0f8ad: 				 * different from the original leftResultSet--for example, it
1:0f0f8ad: 				 * could be a new DISTINCT node whose child is the original
1:0f0f8ad: 				 * leftResultSet.  So after we've modified the node's access
1:0f0f8ad: 				 * path(s) we have to explicitly set this.leftResulSet to
1:0f0f8ad: 				 * point to the modified node. Otherwise leftResultSet would
1:0f0f8ad: 				 * continue to point to the node as it existed *before* it was
1:0f0f8ad: 				 * modified, and that could lead to incorrect behavior for
1:0f0f8ad: 				 * certain queries.  DERBY-1852.
1:0f0f8ad: 				 */
1:fe77ca5: 				leftOptimizer.modifyAccessPaths();
1:0f0f8ad: 				leftResultSet = (ResultSetNode)
1:7f6b163: 					leftOptimizer.getOptimizable(0);
1:0f0f8ad: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:5872305: 				// If this is a SetOperatorNode then we may have pushed
1:5872305: 				// predicates down to the children.  If that's the case
1:5872305: 				// then we need to pass those predicates down as part
1:5872305: 				// of the modifyAccessPaths call so that they can be
1:5872305: 				// pushed one last time, in prep for generation.
1:5872305: 				if (this instanceof SetOperatorNode)
1:5872305: 				{
1:5872305: 					SetOperatorNode setOp = (SetOperatorNode)this;
1:5872305: 					leftResultSet = leftResultSet.modifyAccessPaths(
1:5872305: 						setOp.getLeftOptPredicateList());
1:5872305: 				}
1:5872305: 				else
1:fe77ca5: 					leftResultSet = leftResultSet.modifyAccessPaths();
1:fe77ca5: 			}
1:5872305: 		}
1:fe77ca5: 		if (!rightModifyAccessPathsDone)
1:0f0f8ad: 		{
1:fe77ca5: 			if (rightOptimizer != null)
1:fe77ca5: 			{
1:0f0f8ad: 				/* For the same reasons outlined above we need to make sure
1:0f0f8ad: 				 * we set rightResultSet to point to the *modified* right result
1:0f0f8ad: 				 * set node, which sits at position "0" in rightOptimizer's
1:0f0f8ad: 				 * list.
1:0f0f8ad: 				 */
1:fe77ca5: 				rightOptimizer.modifyAccessPaths();
1:0f0f8ad: 				rightResultSet = (ResultSetNode)
1:7f6b163: 					rightOptimizer.getOptimizable(0);
1:0f0f8ad: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:5872305: 				if (this instanceof SetOperatorNode) {
1:5872305: 					SetOperatorNode setOp = (SetOperatorNode)this;
1:5872305: 					rightResultSet = rightResultSet.modifyAccessPaths(
1:5872305: 						setOp.getRightOptPredicateList());
1:fe77ca5: 				}
1:5872305: 				else
1:fe77ca5: 					rightResultSet = rightResultSet.modifyAccessPaths();
1:fe77ca5: 			}
1:fe77ca5: 		}
1:fe77ca5: 		return this;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Search to see if a query references the specifed table name.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param name		Table name (String) to search for.
1:fe77ca5: 	 * @param baseTable	Whether or not name is for a base table
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	true if found, else false
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean referencesTarget(String name, boolean baseTable)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		return leftResultSet.referencesTarget(name, baseTable) ||
1:fe77ca5: 			   rightResultSet.referencesTarget(name, baseTable);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return	true if references SESSION schema tables, else false
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:fe77ca5: 	public boolean referencesSessionSchema()
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		return leftResultSet.referencesSessionSchema() ||
1:fe77ca5: 			   rightResultSet.referencesSessionSchema();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** 
1:fe77ca5: 	 * Optimize a source result set to this table operator.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 	protected ResultSetNode optimizeSource(
1:fe77ca5: 							Optimizer optimizer,
1:fe77ca5: 							ResultSetNode sourceResultSet,
1:fe77ca5: 							PredicateList predList,
1:fe77ca5: 							CostEstimate outerCost)
1:fe77ca5: 			throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		ResultSetNode	retval;
1:fe77ca5: 
1:fe77ca5: 		if (sourceResultSet instanceof FromTable)
1:fe77ca5: 		{
1:3bb140c:             FromList optList = new FromList(
1:3bb140c:                     getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                     (FromTable)sourceResultSet,
1:3bb140c:                     getContextManager());
1:fe77ca5: 
1:fe77ca5: 			/* If there is no predicate list, create an empty one */
1:fe77ca5: 			if (predList == null)
1:3bb140c:                 predList = new PredicateList(getContextManager());
1:fe77ca5: 
1:3c3e7db:             // recursively create a new optimizer
1:fe77ca5: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
1:fe77ca5: 			OptimizerFactory optimizerFactory = lcc.getOptimizerFactory();
1:fe77ca5: 			optimizer = optimizerFactory.getOptimizer(optList,
1:fe77ca5: 													predList,
1:fe77ca5: 													getDataDictionary(),
1:a56ecfa: 													(RequiredRowOrdering) null,
1:fe77ca5: 													getCompilerContext().getNumTables(),
1:a56ecfa: 													null,
1:fe77ca5: 													  lcc);
1:ab10884: 			optimizer.prepForNextRound();
1:fe77ca5: 
1:fe77ca5: 			if (sourceResultSet == leftResultSet)
1:fe77ca5: 			{
1:fe77ca5: 				leftOptimizer = optimizer;
1:fe77ca5: 			}
1:fe77ca5: 			else if (sourceResultSet == rightResultSet)
1:fe77ca5: 			{
1:fe77ca5: 				rightOptimizer = optimizer;
1:fe77ca5: 			}
1:fe77ca5: 			else
1:fe77ca5: 			{
1:fe77ca5: 				if (SanityManager.DEBUG)
1:fe77ca5: 					SanityManager.THROWASSERT("Result set being optimized is neither left nor right");
1:fe77ca5: 			}
1:fe77ca5: 			
1:fe77ca5: 			/*
1:fe77ca5: 			** Set the estimated number of outer rows from the outer part of
1:fe77ca5: 			** the plan.
1:fe77ca5: 			*/
1:fe77ca5: 			optimizer.setOuterRows(outerCost.rowCount());
1:fe77ca5: 
1:fe77ca5: 			/* Optimize the underlying result set */
1:fe77ca5: 			while (optimizer.getNextPermutation())
1:fe77ca5: 			{
1:fe77ca5: 				while (optimizer.getNextDecoratedPermutation())
1:fe77ca5: 				{
1:fe77ca5: 					optimizer.costPermutation();
1:fe77ca5: 				}
1:fe77ca5: 			}
1:fe77ca5: 
1:fe77ca5: 			retval = sourceResultSet;
1:3c3e7db: 
1:3c3e7db:             // dispose of the recursively created optimizer
1:3c3e7db:             if ( optimizerTracingIsOn() ) { getOptimizerTracer().traceEndQueryBlock(); }
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			retval = sourceResultSet.optimize(
1:3c3e7db: 										getDataDictionary(),
1:fe77ca5: 										predList,
1:fe77ca5: 										outerCost.rowCount());
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		return retval;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Decrement (query block) level (0-based) for 
1:fe77ca5: 	 * all of the tables in this ResultSet tree.
1:fe77ca5: 	 * This is useful when flattening a subquery.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param decrement	The amount to decrement by.
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:fe77ca5: 	void decrementLevel(int decrement)
1:fe77ca5: 	{
1:fe77ca5: 		leftResultSet.decrementLevel(decrement);
1:fe77ca5: 		rightResultSet.decrementLevel(decrement);
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:20bd3c0: 	 * @see ResultSetNode#adjustForSortElimination
1:20bd3c0: 	 */
1:3bb140c:     @Override
1:cf530d5: 	void adjustForSortElimination()
1:fe77ca5: 	{
1:cf530d5: 		leftResultSet.adjustForSortElimination();
1:cf530d5: 		rightResultSet.adjustForSortElimination();
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/**
1:cf530d5: 	 * @see ResultSetNode#adjustForSortElimination
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:20bd3c0: 	void adjustForSortElimination(RequiredRowOrdering rowOrdering)
1:20bd3c0: 		throws StandardException
1:20bd3c0: 	{
1:20bd3c0: 		leftResultSet.adjustForSortElimination(rowOrdering);
1:20bd3c0: 		rightResultSet.adjustForSortElimination(rowOrdering);
1:20bd3c0: 	}
1:20bd3c0: 
1:20bd3c0: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:fe77ca5: 	 * 
1:fe77ca5: 	 * @param v the visitor
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException on error
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:fe77ca5: 		throws StandardException
1:fe77ca5: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:fe77ca5: 
1:aebfb28: 		if (leftResultSet != null)
1:fe77ca5: 		{
1:fe77ca5: 			leftResultSet = (ResultSetNode)leftResultSet.accept(v);
1:fe77ca5: 		}
1:aebfb28: 		if (rightResultSet != null)
1:fe77ca5: 		{
1:fe77ca5: 			rightResultSet = (ResultSetNode)rightResultSet.accept(v);
1:fe77ca5: 		}
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 	/** 
1:fe77ca5: 	 * apparently something special needs to be done for me....
1:fe77ca5: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean needsSpecialRCLBinding()
1:fe77ca5: 	{
1:fe77ca5: 		return true;
1:fe77ca5: 	}
1:fe77ca5: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1: 		setReferencedTableMap( (JBitSet) leftResultSet.getReferencedTableMap().clone() );
1:         getReferencedTableMap().or(rightResultSet.getReferencedTableMap());
1: 		getReferencedTableMap().set(tableNumber);
/////////////////////////////////////////////////////////////////////////
1:         getResultColumns().doProjection();
/////////////////////////////////////////////////////////////////////////
1:         setCostEstimate( getOptimizerFactory().getCostEstimate() );
/////////////////////////////////////////////////////////////////////////
1: 		getCostEstimate().setCost(leftResultSet.getCostEstimate().getEstimatedCost(),
1: 		getCostEstimate().add(rightResultSet.getCostEstimate(), getCostEstimate());
commit:3c3e7db
/////////////////////////////////////////////////////////////////////////
1:             // recursively create a new optimizer
/////////////////////////////////////////////////////////////////////////
1: 
1:             // dispose of the recursively created optimizer
1:             if ( optimizerTracingIsOn() ) { getOptimizerTracer().traceEndQueryBlock(); }
1: 										getDataDictionary(),
commit:6a270cb
/////////////////////////////////////////////////////////////////////////
0:         costEstimate = getOptimizerFactory().getCostEstimate();
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
1:                 (RequiredRowOrdering) null,
0:                 null );
/////////////////////////////////////////////////////////////////////////
1: 													null,
commit:7f6b163
/////////////////////////////////////////////////////////////////////////
1: 					leftOptimizer.getOptimizable(0);
/////////////////////////////////////////////////////////////////////////
1: 					rightOptimizer.getOptimizable(0);
/////////////////////////////////////////////////////////////////////////
1: 					leftOptimizer.getOptimizable(0);
/////////////////////////////////////////////////////////////////////////
1: 					rightOptimizer.getOptimizable(0);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Constructor for a TableOperatorNode.
1:      * @param cm                The context manager
1:     TableOperatorNode(ResultSetNode  leftResultSet,
1:                       ResultSetNode  rightResultSet,
1:                       Properties     tableProperties,
1:                       ContextManager cm)
1:         super(null, tableProperties, cm);
1:         this.leftResultSet = leftResultSet;
1:         this.rightResultSet = rightResultSet;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindUntypedNullsToResultColumns(ResultColumnList rcl)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     ResultSetNode getLeftResultSet()
/////////////////////////////////////////////////////////////////////////
1:     ResultSetNode getRightResultSet()
1:     ResultSetNode getLeftmostResultSet()
/////////////////////////////////////////////////////////////////////////
1:     void setLeftmostResultSet(ResultSetNode newLeftResultSet)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void setLevel(int level)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String getExposedName()
/////////////////////////////////////////////////////////////////////////
1:     void setNestedInParens(boolean nestedInParens)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode bindNonVTITables(DataDictionary dataDictionary,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode bindVTITables(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindExpressions(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void rejectParameters() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindExpressionsWithTables(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindResultColumns(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
0:         referencedTableMap.or(rightResultSet.getReferencedTableMap());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode optimize(DataDictionary dataDictionary,
0:         Optimizer opt = getOptimizer(
0:                 new FromList(getOptimizerFactory().doJoinOrderOptimization(),
0:                              this,
0:                              getContextManager()),
1:                 predicateList,
1:                 dataDictionary,
0:                 (RequiredRowOrdering) null);
0:         costEstimate = opt.newCostEstimate();
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode modifyAccessPaths() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean referencesTarget(String name, boolean baseTable)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             FromList optList = new FromList(
1:                     getOptimizerFactory().doJoinOrderOptimization(),
1:                     (FromTable)sourceResultSet,
1:                     getContextManager());
1:                 predList = new PredicateList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean needsSpecialRCLBinding()
commit:c341dc4
/////////////////////////////////////////////////////////////////////////
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				leftResultSet.treePrint(depth + 1);
1: 				rightResultSet.treePrint(depth + 1);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void bindResultColumns(TableDescriptor targetTableDescriptor,
1:             FromVTI targetVTI, ResultColumnList targetColumnList,
1:             DMLStatementNode statement, FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
commit:402f3c2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (leftResultSet != null)
1: 		if (rightResultSet != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:f8b521a
/////////////////////////////////////////////////////////////////////////
1: 	 * DERBY-4365
1: 	 * Bind untyped nulls to the types in the given ResultColumnList.
1: 	 * This is used for binding the nulls in row constructors and
1: 	 * table constructors.  
1: 	 *
1: 	 * @param rcl	The ResultColumnList with the types to bind nulls to
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList rcl)
1: 	throws StandardException
1: 	{
1: 		leftResultSet.bindUntypedNullsToResultColumns(rcl);
1: 		rightResultSet.bindUntypedNullsToResultColumns(rcl);
1: 	}
1: 
1: 	/**
author:Army
-------------------------------------------------------------------------------
commit:20bd3c0
/////////////////////////////////////////////////////////////////////////
1: 	 * @see ResultSetNode#adjustForSortElimination
1: 	 */
1: 	void adjustForSortElimination(RequiredRowOrdering rowOrdering)
1: 		throws StandardException
1: 	{
1: 		leftResultSet.adjustForSortElimination(rowOrdering);
1: 		rightResultSet.adjustForSortElimination(rowOrdering);
1: 	}
1: 
1: 	/**
commit:cf530d5
/////////////////////////////////////////////////////////////////////////
1: 	 * @see ResultSetNode#adjustForSortElimination
1: 	void adjustForSortElimination()
1: 		leftResultSet.adjustForSortElimination();
1: 		rightResultSet.adjustForSortElimination();
commit:0f0f8ad
/////////////////////////////////////////////////////////////////////////
1: 			{
1: 				/* We know leftOptimizer's list of Optimizables consists of
1: 				 * exactly one Optimizable, and we know that the Optimizable
1: 				 * is actually leftResultSet (see optimizeSource() of this
1: 				 * class). That said, the following call to modifyAccessPaths()
1: 				 * will effectively replace leftResultSet as it exists in
1: 				 * leftOptimizer's list with a "modified" node that *may* be
1: 				 * different from the original leftResultSet--for example, it
1: 				 * could be a new DISTINCT node whose child is the original
1: 				 * leftResultSet.  So after we've modified the node's access
1: 				 * path(s) we have to explicitly set this.leftResulSet to
1: 				 * point to the modified node. Otherwise leftResultSet would
1: 				 * continue to point to the node as it existed *before* it was
1: 				 * modified, and that could lead to incorrect behavior for
1: 				 * certain queries.  DERBY-1852.
1: 				 */
1: 				leftResultSet = (ResultSetNode)
0: 					((OptimizerImpl)leftOptimizer)
0: 						.optimizableList.getOptimizable(0);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 			{
1: 				/* For the same reasons outlined above we need to make sure
1: 				 * we set rightResultSet to point to the *modified* right result
1: 				 * set node, which sits at position "0" in rightOptimizer's
1: 				 * list.
1: 				 */
1: 				rightResultSet = (ResultSetNode)
0: 					((OptimizerImpl)rightOptimizer)
0: 						.optimizableList.getOptimizable(0);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 			{
1: 				/* We know leftOptimizer's list of Optimizables consists of
1: 				 * exactly one Optimizable, and we know that the Optimizable
1: 				 * is actually leftResultSet (see optimizeSource() of this
1: 				 * class). That said, the following call to modifyAccessPaths()
1: 				 * will effectively replace leftResultSet as it exists in
1: 				 * leftOptimizer's list with a "modified" node that *may* be
1: 				 * different from the original leftResultSet--for example, it
1: 				 * could be a new DISTINCT node whose child is the original
1: 				 * leftResultSet.  So after we've modified the node's access
1: 				 * path(s) we have to explicitly set this.leftResulSet to
1: 				 * point to the modified node. Otherwise leftResultSet would
1: 				 * continue to point to the node as it existed *before* it was
1: 				 * modified, and that could lead to incorrect behavior for
1: 				 * certain queries.  DERBY-1852.
1: 				 */
1: 				leftResultSet = (ResultSetNode)
0: 					((OptimizerImpl)leftOptimizer)
0: 						.optimizableList.getOptimizable(0);
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 			{
1: 				/* For the same reasons outlined above we need to make sure
1: 				 * we set rightResultSet to point to the *modified* right result
1: 				 * set node, which sits at position "0" in rightOptimizer's
1: 				 * list.
1: 				 */
1: 				rightResultSet = (ResultSetNode)
0: 					((OptimizerImpl)rightOptimizer)
0: 						.optimizableList.getOptimizable(0);
1: 			}
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:acdff3c
/////////////////////////////////////////////////////////////////////////
1: 	 * @see Optimizable#updateBestPlanMap
1: 	 * Makes a call to add/load/remove the plan mapping for this node,
1: 	 * left and right child, in order to ensure that we've handled
1: 	 * the full plan all the way down this node's subtree. 
1: 	public void updateBestPlanMap(short action,
1: 		super.updateBestPlanMap(action, planKey);
/////////////////////////////////////////////////////////////////////////
1: 				updateBestPlanMap(action, planKey);
1: 				updateBestPlanMaps(action, planKey);
1: 				updateBestPlanMap(action, planKey);
1: 				updateBestPlanMaps(action, planKey);
commit:03eae1d
/////////////////////////////////////////////////////////////////////////
1: abstract class TableOperatorNode extends FromTable
/////////////////////////////////////////////////////////////////////////
1: 			return "nestedInParens: " + false + "\n" +
/////////////////////////////////////////////////////////////////////////
1: 	 * The resulting state of this cal was never used so its
1: 	 * field was removed to save runtimespace for this node.
1: 	 * Further cleanup can be done including parser changes
1: 	 * if this call is really nor required.
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.TableOperatorNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * A TableOperatorNode represents a relational operator like UNION, INTERSECT,
1:  * JOIN, etc. that takes two tables as parameters and returns a table.  The
1:  * parameters it takes are represented as ResultSetNodes.
1:  *
1:  * Currently, all known table operators are binary operators, so there are no
1:  * subclasses of this node type called "BinaryTableOperatorNode" and
1:  * "UnaryTableOperatorNode".
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public abstract class TableOperatorNode extends FromTable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	boolean			nestedInParens;
1: 	ResultSetNode	leftResultSet;
1: 	ResultSetNode	rightResultSet;
1: 	Optimizer		leftOptimizer;
1: 	Optimizer		rightOptimizer;
1: 	private boolean 	leftModifyAccessPathsDone;
1: 	private boolean 	rightModifyAccessPathsDone;
1: 
1: 	/**
0: 	 * Initializer for a TableOperatorNode.
1: 	 *
1: 	 * @param leftResultSet		The ResultSetNode on the left side of this node
1: 	 * @param rightResultSet	The ResultSetNode on the right side of this node
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void init(Object leftResultSet,
0: 							 Object rightResultSet,
0: 							 Object tableProperties)
1: 				throws StandardException
1: 	{
1: 		/* correlationName is always null */
0: 		init(null, tableProperties);
0: 		this.leftResultSet = (ResultSetNode) leftResultSet;
0: 		this.rightResultSet = (ResultSetNode) rightResultSet;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#modifyAccessPath
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
1: 	{
1: 		boolean callModifyAccessPaths = false;
1: 
1: 		if (leftResultSet instanceof FromTable)
1: 		{
1: 			if (leftOptimizer != null)
1: 				leftOptimizer.modifyAccessPaths();
1: 			else
1: 			{
1: 				leftResultSet = 
1: 					(ResultSetNode)
1: 						((FromTable) leftResultSet).modifyAccessPath(outerTables);
1: 			}
1: 			leftModifyAccessPathsDone = true;
1: 		}
1: 		else
1: 		{
1: 			callModifyAccessPaths = true;
1: 		}
1: 
1: 		if (rightResultSet instanceof FromTable)
1: 		{
1: 			if (rightOptimizer != null)
1: 				rightOptimizer.modifyAccessPaths();
1: 			else
1: 			{
1: 				rightResultSet = 
1: 					(ResultSetNode)
1: 						((FromTable) rightResultSet).modifyAccessPath(outerTables);
1: 			}
1: 			rightModifyAccessPathsDone = true;
1: 		}
1: 		else
1: 		{
1: 			callModifyAccessPaths = true;
1: 		}
1: 
1: 		if (callModifyAccessPaths)
1: 		{
1: 			return (Optimizable) modifyAccessPaths();
1: 		}
1: 		return this;
1: 	}
1: 
1: 	/** @see Optimizable#verifyProperties 
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void verifyProperties(DataDictionary dDictionary)
1: 		throws StandardException
1: 	{
1: 		if (leftResultSet instanceof Optimizable)
1: 		{
1: 			((Optimizable) leftResultSet).verifyProperties(dDictionary);
1: 		}
1: 		if (rightResultSet instanceof Optimizable)
1: 		{
1: 			((Optimizable) rightResultSet).verifyProperties(dDictionary);
1: 		}
1: 
1: 		super.verifyProperties(dDictionary);
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return "nestedInParens: " + nestedInParens + "\n" +
0: 				leftResultSet.toString() + "\n" +
0: 				rightResultSet.toString() + "\n" + 
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (leftResultSet != null)
1: 			{
1: 				printLabel(depth, "leftResultSet: ");
0: 				leftResultSet.printSubNodes(depth + 1);
1: 			}
1: 
1: 			if (rightResultSet != null)
1: 			{
1: 				printLabel(depth, "rightResultSet: ");
0: 				rightResultSet.printSubNodes(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the leftResultSet from this node.
1: 	 *
1: 	 * @return ResultSetNode	The leftResultSet from this node.
1: 	 */
0: 	public ResultSetNode getLeftResultSet()
1: 	{
1: 		return leftResultSet;
1: 	}
1: 
1: 	/**
1: 	 * Get the rightResultSet from this node.
1: 	 *
1: 	 * @return ResultSetNode	The rightResultSet from this node.
1: 	 */
0: 	public ResultSetNode getRightResultSet()
1: 	{
1: 		return rightResultSet;
1: 	}
1: 
0: 	public ResultSetNode getLeftmostResultSet()
1: 	{
1: 		if (leftResultSet instanceof TableOperatorNode)
1: 		{
1: 			return ((TableOperatorNode) leftResultSet).getLeftmostResultSet();
1: 		}
1: 		else
1: 		{
1: 			return leftResultSet;
1: 		}
1: 	}
1: 
0: 	public void setLeftmostResultSet(ResultSetNode newLeftResultSet)
1: 	{
1: 		if (leftResultSet instanceof TableOperatorNode)
1: 		{
1: 			((TableOperatorNode) leftResultSet).setLeftmostResultSet(newLeftResultSet);
1: 		}
1: 		else
1: 		{
1: 			this.leftResultSet = newLeftResultSet;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Set the (query block) level (0-based) for this FromTable.
1: 	 *
1: 	 * @param level		The query block level for this FromTable.
1: 	 *
0: 	 * @return Nothing
1: 	 */
0: 	public void setLevel(int level)
1: 	{
1: 		super.setLevel(level);
1: 		if (leftResultSet instanceof FromTable)
1: 		{
1: 			((FromTable) leftResultSet).setLevel(level);
1: 		}
1: 		if (rightResultSet instanceof FromTable)
1: 		{
1: 			((FromTable) rightResultSet).setLevel(level);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return the exposed name for this table, which is the name that
1: 	 * can be used to refer to this table in the rest of the query.
1: 	 *
1: 	 * @return	The exposed name for this table.
1: 	 */
1: 
0: 	public String getExposedName()
1: 	{
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Mark whether or not this node is nested in parens.  (Useful to parser
1: 	 * since some trees get created left deep and others right deep.)
1: 	 *
1: 	 * @param nestedInParens	Whether or not this node is nested in parens.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setNestedInParens(boolean nestedInParens)
1: 	{
0: 		this.nestedInParens = nestedInParens;
1: 	}
1: 
1: 	/**
0: 	 * Return whether or not the table operator for this node was
0: 	 * nested in parens in the query.  (Useful to parser
1: 	 * since some trees get created left deep and others right deep.)
1: 	 *
0: 	 * @return boolean		Whether or not this node was nested in parens.
1: 	 */
0: 	public boolean getNestedInParens()
1: 	{
0: 		return nestedInParens;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Bind the non VTI tables in this TableOperatorNode. This means getting
1: 	 * their TableDescriptors from the DataDictionary.
1: 	 * We will build an unbound RCL for this node.  This RCL must be
1: 	 * "bound by hand" after the underlying left and right RCLs
1: 	 * are bound.
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for binding
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
1: 	 * @return	ResultSetNode		Returns this.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode bindNonVTITables(DataDictionary dataDictionary, 
1: 						  FromList fromListParam) 
1: 							throws StandardException
1: 	{
1: 		leftResultSet = leftResultSet.bindNonVTITables(dataDictionary, fromListParam);
1: 		rightResultSet = rightResultSet.bindNonVTITables(dataDictionary, fromListParam);
1: 		/* Assign the tableNumber */
1: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
1: 			tableNumber = getCompilerContext().getNextTableNumber();
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Bind the VTI tables in this TableOperatorNode. This means getting
1: 	 * their TableDescriptors from the DataDictionary.
1: 	 * We will build an unbound RCL for this node.  This RCL must be
1: 	 * "bound by hand" after the underlying left and right RCLs
1: 	 * are bound.
1: 	 *
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
1: 	 * @return	ResultSetNode		Returns this.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode bindVTITables(FromList fromListParam) 
1: 							throws StandardException
1: 	{
1: 		leftResultSet = leftResultSet.bindVTITables(fromListParam);
1: 		rightResultSet = rightResultSet.bindVTITables(fromListParam);
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions under this TableOperatorNode.  This means
1: 	 * binding the sub-expressions, as well as figuring out what the
1: 	 * return type is for each expression.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindExpressions(FromList fromListParam)
1: 				throws StandardException
1: 	{
1: 		/*
1: 		** Parameters not allowed in select list of either side of union,
1: 		** except when the union is for a table constructor.
1: 		*/
1: 		if ( ! (this instanceof UnionNode) ||
1: 			 ! ((UnionNode) this).tableConstructor())
1: 		{
1: 			leftResultSet.rejectParameters();
1: 			rightResultSet.rejectParameters();
1: 		}
1: 
1: 		leftResultSet.bindExpressions(fromListParam);
1: 		rightResultSet.bindExpressions(fromListParam);
1: 	}
1: 
1: 	/**
1: 	 * Check for (and reject) ? parameters directly under the ResultColumns.
1: 	 * This is done for SELECT statements.  For TableOperatorNodes, we
1: 	 * simply pass the check through to the left and right children.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown if a ? parameter found
1: 	 *									directly under a ResultColumn
1: 	 */
1: 
0: 	public void rejectParameters() throws StandardException
1: 	{
1: 		leftResultSet.rejectParameters();
1: 		rightResultSet.rejectParameters();
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions in this ResultSetNode if it has tables.  This means binding the
1: 	 * sub-expressions, as well as figuring out what the return type is for
1: 	 * each expression.
1: 	 *
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindExpressionsWithTables(FromList fromListParam)
1: 					throws StandardException
1: 	{
1: 		/*
1: 		** Parameters not allowed in select list of either side of union,
1: 		** except when the union is for a table constructor.
1: 		*/
1: 		if ( ! (this instanceof UnionNode) ||
1: 			 ! ((UnionNode) this).tableConstructor())
1: 		{
1: 			leftResultSet.rejectParameters();
1: 			rightResultSet.rejectParameters();
1: 		}
1: 
1: 		leftResultSet.bindExpressionsWithTables(fromListParam);
1: 		rightResultSet.bindExpressionsWithTables(fromListParam);
1: 	}
1: 
1: 	/**
1: 	 * Bind the result columns of this ResultSetNode when there is no
1: 	 * base table to bind them to.  This is useful for SELECT statements,
1: 	 * where the result columns get their types from the expressions that
1: 	 * live under them.
1: 	 *
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindResultColumns(FromList fromListParam)
1: 					throws StandardException
1: 	{
1: 		leftResultSet.bindResultColumns(fromListParam);
1: 		rightResultSet.bindResultColumns(fromListParam);
1: 	}
1: 
1: 	/**
1: 	 * Bind the result columns for this ResultSetNode to a base table.
1: 	 * This is useful for INSERT and UPDATE statements, where the
1: 	 * result columns get their types from the table being updated or
1: 	 * inserted into.
1: 	 * If a result column list is specified, then the verification that the 
1: 	 * result column list does not contain any duplicates will be done when
1: 	 * binding them by name.
1: 	 *
1: 	 * @param targetTableDescriptor	The TableDescriptor for the table being
1: 	 *				updated or inserted into
1: 	 * @param targetColumnList	For INSERT statements, the user
1: 	 *					does not have to supply column
1: 	 *					names (for example, "insert into t
1: 	 *					values (1,2,3)".  When this
1: 	 *					parameter is null, it means that
1: 	 *					the user did not supply column
1: 	 *					names, and so the binding should
1: 	 *					be done based on order.  When it
1: 	 *					is not null, it means do the binding
1: 	 *					by name, not position.
1: 	 * @param statement			Calling DMLStatementNode (Insert or Update)
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindResultColumns(TableDescriptor targetTableDescriptor,
0: 					FromVTI targetVTI,
0: 					ResultColumnList targetColumnList,
0: 					DMLStatementNode statement,
1: 					FromList fromListParam)
1: 				throws StandardException
1: 	{
1: 		leftResultSet.bindResultColumns(targetTableDescriptor,
1: 										targetVTI,
1: 										targetColumnList,
1: 										statement, fromListParam);
1: 		rightResultSet.bindResultColumns(targetTableDescriptor,
1: 										targetVTI,
1: 										targetColumnList,
1: 										statement, fromListParam);
1: 	}
1: 
1: 	/** 
1: 	 * Determine whether or not the specified name is an exposed name in
1: 	 * the current query block.
1: 	 *
1: 	 * @param name	The specified name to search for as an exposed name.
1: 	 * @param schemaName	Schema name, if non-null.
1: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1: 	 *						names or match on table id.
1: 	 *
1: 	 * @return The FromTable, if any, with the exposed name.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1: 		throws StandardException
1: 	{
1: 		FromTable result = leftResultSet.getFromTableByName(name, schemaName, exactMatch);
1: 
1: 		/* We search both sides for a TableOperatorNode (join nodes)
1: 		 * but only the left side for a UnionNode.
1: 		 */
1: 		if (result == null)
1: 		{
1: 			result = rightResultSet.getFromTableByName(name, schemaName, exactMatch);
1: 		}
1: 		return result;
1: 	}
1: 
1: 	/** 
1: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1: 	 * that ResultColumn must percolate up to the new PRN.  However,
1: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1: 	 * which points to the FromTable and the ResultColumn that is the source for
1: 	 * the ColumnReference.  
1: 	 * (The new PRN will have the original of the ResultColumnList and
1: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1: 	 * will remain at the FromTable, with the PRN getting a new 
1: 	 * VirtualColumnNode for each ResultColumn.expression.)
1: 	 * We then project out the non-referenced columns.  If there are no referenced
1: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1: 	 * whose expression is 1.
1: 	 *
1: 	 * @param numTables			Number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 * @param fromList			The from list, if any
1: 	 *
1: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode preprocess(int numTables,
1: 									GroupByList gbl,
1: 									FromList fromList)
1: 								throws StandardException
1: 	{
1: 		leftResultSet = leftResultSet.preprocess(numTables, gbl, fromList);
1: 		/* If leftResultSet is a FromSubquery, then we must explicitly extract
1: 		 * out the subquery (flatten it).  (SelectNodes have their own
1: 		 * method of flattening them.
1: 		 */
1: 		if (leftResultSet instanceof FromSubquery)
1: 		{
1: 			leftResultSet = ((FromSubquery) leftResultSet).extractSubquery(numTables);
1: 		}
1: 		rightResultSet = rightResultSet.preprocess(numTables, gbl, fromList);
1: 		/* If rightResultSet is a FromSubquery, then we must explicitly extract
1: 		 * out the subquery (flatten it).  (SelectNodes have their own
1: 		 * method of flattening them.
1: 		 */
1: 		if (rightResultSet instanceof FromSubquery)
1: 		{
1: 			rightResultSet = ((FromSubquery) rightResultSet).extractSubquery(numTables);
1: 		}
1: 
1: 		/* Build the referenced table map (left || right) */
0: 		referencedTableMap = (JBitSet) leftResultSet.getReferencedTableMap().clone();
0: 		referencedTableMap.or((JBitSet) rightResultSet.getReferencedTableMap());
0: 		referencedTableMap.set(tableNumber);
1: 
1: 		/* Only generate a PRN if this node is not a flattenable join node. */
1: 		if (isFlattenableJoinNode())
1: 		{
1: 			return this;
1: 		}
1: 		else
1: 		{
1: 			/* Project out any unreferenced RCs before we generate the PRN.
1: 			 * NOTE: We have to do this at the end of preprocess since it has to 
1: 			 * be from the bottom up.  We can't do it until the join expression is 
1: 			 * bound, since the join expression may contain column references that
1: 			 * are not referenced anywhere else above us.
1: 			 */
1:             projectResultColumns();
1: 			return genProjectRestrict(numTables);
1: 		}
1: 	}
1: 
1:     /**
1:      * Find the unreferenced result columns and project them out. This is used in pre-processing joins
1:      * that are not flattened into the where clause.
1:      */
1:     void projectResultColumns() throws StandardException
1:     {
0:         resultColumns.doProjection();
1:     }
1:     
1:     /**
1:      * Set the referenced columns in the column list if it may not be correct.
1:      */
1:     void setReferencedColumns()
1:     {}
1:     
1: 	/**
1: 	 * Optimize a TableOperatorNode. 
1: 	 *
1: 	 * @param dataDictionary	The DataDictionary to use for optimization
1: 	 * @param predicateList		The PredicateList to apply.
1: 	 *
1: 	 * @return	ResultSetNode	The top of the optimized query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
1: 								  PredicateList predicateList,
1: 								  double outerRows)
1: 				throws StandardException
1: 	{
0: 		/* Get an optimizer, so we can get a cost structure */
0: 		Optimizer optimizer =
0: 							getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									this,
0: 									getContextManager()),
1: 									predicateList,
1: 									dataDictionary,
0: 									(RequiredRowOrdering) null);
1: 
0: 		costEstimate = optimizer.newCostEstimate();
1: 
1: 		/* RESOLVE: This is just a stub for now */
1: 		leftResultSet = leftResultSet.optimize(
1: 											dataDictionary,
1: 											predicateList,
1: 											outerRows);
1: 		rightResultSet = rightResultSet.optimize(
1: 											dataDictionary,
1: 											predicateList,
1: 											outerRows);
1: 
1: 		/* The cost is the sum of the two child costs */
0: 		costEstimate.setCost(leftResultSet.getCostEstimate().getEstimatedCost(),
1: 							 leftResultSet.getCostEstimate().rowCount(),
1: 							 leftResultSet.getCostEstimate().singleScanRowCount() +
1: 							 rightResultSet.getCostEstimate().singleScanRowCount());
1: 
0: 		costEstimate.add(rightResultSet.costEstimate, costEstimate);
1: 
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSetNode#modifyAccessPaths
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
1: 	{
1: 		/* Beetle 4454 - union all with another union all would modify access
1: 		 * paths twice causing NullPointerException, make sure we don't
1: 		 * do this again, if we have already done it in modifyAccessPaths(outertables)
1: 		 */
1: 		if (!leftModifyAccessPathsDone)
1: 		{
1: 			if (leftOptimizer != null)
1: 				leftOptimizer.modifyAccessPaths();
1: 			else
1: 				leftResultSet = leftResultSet.modifyAccessPaths();
1: 		}
1: 		if (!rightModifyAccessPathsDone)
1: 		{
1: 			if (rightOptimizer != null)
1: 				rightOptimizer.modifyAccessPaths();
1: 			else
1: 				rightResultSet = rightResultSet.modifyAccessPaths();
1: 		}
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Search to see if a query references the specifed table name.
1: 	 *
1: 	 * @param name		Table name (String) to search for.
1: 	 * @param baseTable	Whether or not name is for a base table
1: 	 *
1: 	 * @return	true if found, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean referencesTarget(String name, boolean baseTable)
1: 		throws StandardException
1: 	{
1: 		return leftResultSet.referencesTarget(name, baseTable) ||
1: 			   rightResultSet.referencesTarget(name, baseTable);
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		return leftResultSet.referencesSessionSchema() ||
1: 			   rightResultSet.referencesSessionSchema();
1: 	}
1: 
1: 	/** 
1: 	 * Optimize a source result set to this table operator.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	protected ResultSetNode optimizeSource(
1: 							Optimizer optimizer,
1: 							ResultSetNode sourceResultSet,
1: 							PredicateList predList,
1: 							CostEstimate outerCost)
1: 			throws StandardException
1: 	{
1: 		ResultSetNode	retval;
1: 
1: 		if (sourceResultSet instanceof FromTable)
1: 		{
0: 			FromList optList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									sourceResultSet,
0: 									getContextManager());
1: 
1: 			/* If there is no predicate list, create an empty one */
1: 			if (predList == null)
0: 				predList = (PredicateList) getNodeFactory().getNode(
0: 												C_NodeTypes.PREDICATE_LIST,
0: 												getContextManager());
1: 
1: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
1: 			OptimizerFactory optimizerFactory = lcc.getOptimizerFactory();
1: 			optimizer = optimizerFactory.getOptimizer(optList,
1: 													predList,
1: 													getDataDictionary(),
0: 													(RequiredRowOrdering) null,
1: 													getCompilerContext().getNumTables(),
1: 													  lcc);
1: 
1: 			if (sourceResultSet == leftResultSet)
1: 			{
1: 				leftOptimizer = optimizer;
1: 			}
1: 			else if (sourceResultSet == rightResultSet)
1: 			{
1: 				rightOptimizer = optimizer;
1: 			}
1: 			else
1: 			{
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.THROWASSERT("Result set being optimized is neither left nor right");
1: 			}
1: 			
1: 			/*
1: 			** Set the estimated number of outer rows from the outer part of
1: 			** the plan.
1: 			*/
1: 			optimizer.setOuterRows(outerCost.rowCount());
1: 
1: 			/* Optimize the underlying result set */
1: 			while (optimizer.getNextPermutation())
1: 			{
1: 				while (optimizer.getNextDecoratedPermutation())
1: 				{
1: 					optimizer.costPermutation();
1: 				}
1: 			}
1: 
1: 			retval = sourceResultSet;
1: 		}
1: 		else
1: 		{
1: 			retval = sourceResultSet.optimize(
0: 										optimizer.getDataDictionary(),
1: 										predList,
1: 										outerCost.rowCount());
1: 		}
1: 
1: 		return retval;
1: 	}
1: 
1: 	/**
1: 	 * Decrement (query block) level (0-based) for 
1: 	 * all of the tables in this ResultSet tree.
1: 	 * This is useful when flattening a subquery.
1: 	 *
1: 	 * @param decrement	The amount to decrement by.
1: 	 *
0: 	 * @return Nothing;
1: 	 */
1: 	void decrementLevel(int decrement)
1: 	{
1: 		leftResultSet.decrementLevel(decrement);
1: 		rightResultSet.decrementLevel(decrement);
1: 	}
1: 
1: 	/**
0: 	 * Replace any DEFAULTs with the associated tree for the default.
1: 	 *
0: 	 * @param ttd	The TableDescriptor for the target table.
0: 	 * @param tcl	The RCL for the target table.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	void replaceDefaults(TableDescriptor ttd, ResultColumnList tcl) 
1: 		throws StandardException
1: 	{
0: 		leftResultSet.replaceDefaults(ttd, tcl);
0: 		rightResultSet.replaceDefaults(ttd, tcl);
1: 	}
1: 
1: 	/**
0: 	 * Notify the underlying result set tree that the result is
0: 	 * ordering dependent.  (For example, no bulk fetch on an index
0: 	 * if under an IndexRowToBaseRow.)
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	void markOrderingDependent()
1: 	{
0: 		leftResultSet.markOrderingDependent();
0: 		rightResultSet.markOrderingDependent();
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		if (v.skipChildren(this))
1: 		{
0: 			return v.visit(this);
1: 		}
1: 
0: 		Visitable returnNode = super.accept(v);
1: 
0: 		if (leftResultSet != null && !v.stopTraversal())
1: 		{
1: 			leftResultSet = (ResultSetNode)leftResultSet.accept(v);
1: 		}
0: 		if (rightResultSet != null && !v.stopTraversal())
1: 		{
1: 			rightResultSet = (ResultSetNode)rightResultSet.accept(v);
1: 		}
0: 		return returnNode;
1: 	}
1: 
1: 	/** 
1: 	 * apparently something special needs to be done for me....
1: 	 */
0: 	public boolean needsSpecialRCLBinding()
1: 	{
1: 		return true;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:e07631a
/////////////////////////////////////////////////////////////////////////
1: 		Object planKey) throws StandardException
0: 		super.addOrLoadBestPlanMapping(doAdd, planKey);
0: 
1: 		// Now walk the children.  Note that if either child is not
1: 		// an Optimizable and the call to child.getOptimizerImpl()
1: 		// returns null, then that means we haven't tried to optimize
1: 		// the child yet.  So in that case there's nothing to
1: 		// add/load.
0: 
0: 				addOrLoadBestPlanMapping(doAdd, planKey);
1: 		else if (leftResultSet.getOptimizerImpl() != null)
0: 				addOrLoadBestPlanMappings(doAdd, planKey);
0: 				addOrLoadBestPlanMapping(doAdd, planKey);
1: 		else if (rightResultSet.getOptimizerImpl() != null)
0: 				addOrLoadBestPlanMappings(doAdd, planKey);
commit:5872305
/////////////////////////////////////////////////////////////////////////
1: 			{
1: 				// If this is a SetOperatorNode then we may have pushed
1: 				// predicates down to the children.  If that's the case
1: 				// then we need to pass those predicates down as part
1: 				// of the modifyAccessPaths call so that they can be
1: 				// pushed one last time, in prep for generation.
1: 				if (this instanceof SetOperatorNode)
1: 				{
1: 					SetOperatorNode setOp = (SetOperatorNode)this;
1: 					leftResultSet = leftResultSet.modifyAccessPaths(
1: 						setOp.getLeftOptPredicateList());
1: 				}
1: 				else
0: 					leftResultSet = leftResultSet.modifyAccessPaths();
1: 			}
1: 			{
1: 				if (this instanceof SetOperatorNode) {
1: 					SetOperatorNode setOp = (SetOperatorNode)this;
1: 					rightResultSet = rightResultSet.modifyAccessPaths(
1: 						setOp.getRightOptPredicateList());
1: 				}
1: 				else
0: 					rightResultSet = rightResultSet.modifyAccessPaths();
1: 			}
commit:ab10884
/////////////////////////////////////////////////////////////////////////
1: 			optimizer.prepForNextRound();
commit:62d4560
/////////////////////////////////////////////////////////////////////////
0: 	 * @see Optimizable#addOrLoadBestPlanMapping
0: 	 *
0: 	 * Makes a call to add/load the plan mapping for this node,
1: 	 * and then makes the necessary call to recurse on this node's
0: 	 * left and right child, in order to ensure that we have a
0: 	 * full plan mapped.
0: 	 */
0: 	public void addOrLoadBestPlanMapping(boolean doAdd,
0: 		Optimizer optimizer) throws StandardException
1: 	{
0: 		super.addOrLoadBestPlanMapping(doAdd, optimizer);
1: 		if (leftResultSet instanceof Optimizable)
1: 		{
1: 			((Optimizable)leftResultSet).
0: 				addOrLoadBestPlanMapping(doAdd, optimizer);
1: 		}
0: 		else
1: 		{
1: 			leftResultSet.getOptimizerImpl().
0: 				addOrLoadBestPlanMappings(doAdd, optimizer);
1: 		}
0: 
1: 		if (rightResultSet instanceof Optimizable)
1: 		{
1: 			((Optimizable)rightResultSet).
0: 				addOrLoadBestPlanMapping(doAdd, optimizer);
1: 		}
0: 		else
1: 		{
1: 			rightResultSet.getOptimizerImpl().
0: 				addOrLoadBestPlanMappings(doAdd, optimizer);
1: 		}
1: 	}
0: 
0: 	/**
/////////////////////////////////////////////////////////////////////////
0: 			((OptimizerImpl)optimizer).prepForNextRound();
commit:6200b38
/////////////////////////////////////////////////////////////////////////
1: 		** Parameters not allowed in select list of either side of a set operator,
1: 		** except when the set operator is for a table constructor.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * A TableOperatorNode represents a relational operator like UNION, INTERSECT,
0:  * JOIN, etc. that takes two tables as parameters and returns a table.  The
0:  * parameters it takes are represented as ResultSetNodes.
0:  *
0:  * Currently, all known table operators are binary operators, so there are no
0:  * subclasses of this node type called "BinaryTableOperatorNode" and
0:  * "UnaryTableOperatorNode".
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public abstract class TableOperatorNode extends FromTable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	boolean			nestedInParens;
0: 	ResultSetNode	leftResultSet;
0: 	ResultSetNode	rightResultSet;
0: 	Optimizer		leftOptimizer;
0: 	Optimizer		rightOptimizer;
0: 	private boolean 	leftModifyAccessPathsDone;
0: 	private boolean 	rightModifyAccessPathsDone;
0: 
0: 	/**
0: 	 * Initializer for a TableOperatorNode.
0: 	 *
0: 	 * @param leftResultSet		The ResultSetNode on the left side of this node
0: 	 * @param rightResultSet	The ResultSetNode on the right side of this node
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void init(Object leftResultSet,
0: 							 Object rightResultSet,
0: 							 Object tableProperties)
0: 				throws StandardException
0: 	{
0: 		/* correlationName is always null */
0: 		init(null, tableProperties);
0: 		this.leftResultSet = (ResultSetNode) leftResultSet;
0: 		this.rightResultSet = (ResultSetNode) rightResultSet;
0: 	}
0: 
0: 	/**
0: 	 * @see Optimizable#modifyAccessPath
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException
0: 	{
0: 		boolean callModifyAccessPaths = false;
0: 
0: 		if (leftResultSet instanceof FromTable)
0: 		{
0: 			if (leftOptimizer != null)
0: 				leftOptimizer.modifyAccessPaths();
0: 			else
0: 			{
0: 				leftResultSet = 
0: 					(ResultSetNode)
0: 						((FromTable) leftResultSet).modifyAccessPath(outerTables);
0: 			}
0: 			leftModifyAccessPathsDone = true;
0: 		}
0: 		else
0: 		{
0: 			callModifyAccessPaths = true;
0: 		}
0: 
0: 		if (rightResultSet instanceof FromTable)
0: 		{
0: 			if (rightOptimizer != null)
0: 				rightOptimizer.modifyAccessPaths();
0: 			else
0: 			{
0: 				rightResultSet = 
0: 					(ResultSetNode)
0: 						((FromTable) rightResultSet).modifyAccessPath(outerTables);
0: 			}
0: 			rightModifyAccessPathsDone = true;
0: 		}
0: 		else
0: 		{
0: 			callModifyAccessPaths = true;
0: 		}
0: 
0: 		if (callModifyAccessPaths)
0: 		{
0: 			return (Optimizable) modifyAccessPaths();
0: 		}
0: 		return this;
0: 	}
0: 
0: 	/** @see Optimizable#verifyProperties 
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void verifyProperties(DataDictionary dDictionary)
0: 		throws StandardException
0: 	{
0: 		if (leftResultSet instanceof Optimizable)
0: 		{
0: 			((Optimizable) leftResultSet).verifyProperties(dDictionary);
0: 		}
0: 		if (rightResultSet instanceof Optimizable)
0: 		{
0: 			((Optimizable) rightResultSet).verifyProperties(dDictionary);
0: 		}
0: 
0: 		super.verifyProperties(dDictionary);
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "nestedInParens: " + nestedInParens + "\n" +
0: 				leftResultSet.toString() + "\n" +
0: 				rightResultSet.toString() + "\n" + 
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (leftResultSet != null)
0: 			{
0: 				printLabel(depth, "leftResultSet: ");
0: 				leftResultSet.printSubNodes(depth + 1);
0: 			}
0: 
0: 			if (rightResultSet != null)
0: 			{
0: 				printLabel(depth, "rightResultSet: ");
0: 				rightResultSet.printSubNodes(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the leftResultSet from this node.
0: 	 *
0: 	 * @return ResultSetNode	The leftResultSet from this node.
0: 	 */
0: 	public ResultSetNode getLeftResultSet()
0: 	{
0: 		return leftResultSet;
0: 	}
0: 
0: 	/**
0: 	 * Get the rightResultSet from this node.
0: 	 *
0: 	 * @return ResultSetNode	The rightResultSet from this node.
0: 	 */
0: 	public ResultSetNode getRightResultSet()
0: 	{
0: 		return rightResultSet;
0: 	}
0: 
0: 	public ResultSetNode getLeftmostResultSet()
0: 	{
0: 		if (leftResultSet instanceof TableOperatorNode)
0: 		{
0: 			return ((TableOperatorNode) leftResultSet).getLeftmostResultSet();
0: 		}
0: 		else
0: 		{
0: 			return leftResultSet;
0: 		}
0: 	}
0: 
0: 	public void setLeftmostResultSet(ResultSetNode newLeftResultSet)
0: 	{
0: 		if (leftResultSet instanceof TableOperatorNode)
0: 		{
0: 			((TableOperatorNode) leftResultSet).setLeftmostResultSet(newLeftResultSet);
0: 		}
0: 		else
0: 		{
0: 			this.leftResultSet = newLeftResultSet;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Set the (query block) level (0-based) for this FromTable.
0: 	 *
0: 	 * @param level		The query block level for this FromTable.
0: 	 *
0: 	 * @return Nothing
0: 	 */
0: 	public void setLevel(int level)
0: 	{
0: 		super.setLevel(level);
0: 		if (leftResultSet instanceof FromTable)
0: 		{
0: 			((FromTable) leftResultSet).setLevel(level);
0: 		}
0: 		if (rightResultSet instanceof FromTable)
0: 		{
0: 			((FromTable) rightResultSet).setLevel(level);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return the exposed name for this table, which is the name that
0: 	 * can be used to refer to this table in the rest of the query.
0: 	 *
0: 	 * @return	The exposed name for this table.
0: 	 */
0: 
0: 	public String getExposedName()
0: 	{
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * Mark whether or not this node is nested in parens.  (Useful to parser
0: 	 * since some trees get created left deep and others right deep.)
0: 	 *
0: 	 * @param nestedInParens	Whether or not this node is nested in parens.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setNestedInParens(boolean nestedInParens)
0: 	{
0: 		this.nestedInParens = nestedInParens;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not the table operator for this node was
0: 	 * nested in parens in the query.  (Useful to parser
0: 	 * since some trees get created left deep and others right deep.)
0: 	 *
0: 	 * @return boolean		Whether or not this node was nested in parens.
0: 	 */
0: 	public boolean getNestedInParens()
0: 	{
0: 		return nestedInParens;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Bind the non VTI tables in this TableOperatorNode. This means getting
0: 	 * their TableDescriptors from the DataDictionary.
0: 	 * We will build an unbound RCL for this node.  This RCL must be
0: 	 * "bound by hand" after the underlying left and right RCLs
0: 	 * are bound.
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for binding
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	ResultSetNode		Returns this.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode bindNonVTITables(DataDictionary dataDictionary, 
0: 						  FromList fromListParam) 
0: 							throws StandardException
0: 	{
0: 		leftResultSet = leftResultSet.bindNonVTITables(dataDictionary, fromListParam);
0: 		rightResultSet = rightResultSet.bindNonVTITables(dataDictionary, fromListParam);
0: 		/* Assign the tableNumber */
0: 		if (tableNumber == -1)  // allow re-bind, in which case use old number
0: 			tableNumber = getCompilerContext().getNextTableNumber();
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Bind the VTI tables in this TableOperatorNode. This means getting
0: 	 * their TableDescriptors from the DataDictionary.
0: 	 * We will build an unbound RCL for this node.  This RCL must be
0: 	 * "bound by hand" after the underlying left and right RCLs
0: 	 * are bound.
0: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	ResultSetNode		Returns this.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode bindVTITables(FromList fromListParam) 
0: 							throws StandardException
0: 	{
0: 		leftResultSet = leftResultSet.bindVTITables(fromListParam);
0: 		rightResultSet = rightResultSet.bindVTITables(fromListParam);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions under this TableOperatorNode.  This means
0: 	 * binding the sub-expressions, as well as figuring out what the
0: 	 * return type is for each expression.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindExpressions(FromList fromListParam)
0: 				throws StandardException
0: 	{
0: 		/*
0: 		** Parameters not allowed in select list of either side of union,
0: 		** except when the union is for a table constructor.
0: 		*/
0: 		if ( ! (this instanceof UnionNode) ||
0: 			 ! ((UnionNode) this).tableConstructor())
0: 		{
0: 			leftResultSet.rejectParameters();
0: 			rightResultSet.rejectParameters();
0: 		}
0: 
0: 		leftResultSet.bindExpressions(fromListParam);
0: 		rightResultSet.bindExpressions(fromListParam);
0: 	}
0: 
0: 	/**
0: 	 * Check for (and reject) ? parameters directly under the ResultColumns.
0: 	 * This is done for SELECT statements.  For TableOperatorNodes, we
0: 	 * simply pass the check through to the left and right children.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown if a ? parameter found
0: 	 *									directly under a ResultColumn
0: 	 */
0: 
0: 	public void rejectParameters() throws StandardException
0: 	{
0: 		leftResultSet.rejectParameters();
0: 		rightResultSet.rejectParameters();
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions in this ResultSetNode if it has tables.  This means binding the
0: 	 * sub-expressions, as well as figuring out what the return type is for
0: 	 * each expression.
0: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindExpressionsWithTables(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		/*
0: 		** Parameters not allowed in select list of either side of union,
0: 		** except when the union is for a table constructor.
0: 		*/
0: 		if ( ! (this instanceof UnionNode) ||
0: 			 ! ((UnionNode) this).tableConstructor())
0: 		{
0: 			leftResultSet.rejectParameters();
0: 			rightResultSet.rejectParameters();
0: 		}
0: 
0: 		leftResultSet.bindExpressionsWithTables(fromListParam);
0: 		rightResultSet.bindExpressionsWithTables(fromListParam);
0: 	}
0: 
0: 	/**
0: 	 * Bind the result columns of this ResultSetNode when there is no
0: 	 * base table to bind them to.  This is useful for SELECT statements,
0: 	 * where the result columns get their types from the expressions that
0: 	 * live under them.
0: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindResultColumns(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		leftResultSet.bindResultColumns(fromListParam);
0: 		rightResultSet.bindResultColumns(fromListParam);
0: 	}
0: 
0: 	/**
0: 	 * Bind the result columns for this ResultSetNode to a base table.
0: 	 * This is useful for INSERT and UPDATE statements, where the
0: 	 * result columns get their types from the table being updated or
0: 	 * inserted into.
0: 	 * If a result column list is specified, then the verification that the 
0: 	 * result column list does not contain any duplicates will be done when
0: 	 * binding them by name.
0: 	 *
0: 	 * @param targetTableDescriptor	The TableDescriptor for the table being
0: 	 *				updated or inserted into
0: 	 * @param targetColumnList	For INSERT statements, the user
0: 	 *					does not have to supply column
0: 	 *					names (for example, "insert into t
0: 	 *					values (1,2,3)".  When this
0: 	 *					parameter is null, it means that
0: 	 *					the user did not supply column
0: 	 *					names, and so the binding should
0: 	 *					be done based on order.  When it
0: 	 *					is not null, it means do the binding
0: 	 *					by name, not position.
0: 	 * @param statement			Calling DMLStatementNode (Insert or Update)
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindResultColumns(TableDescriptor targetTableDescriptor,
0: 					FromVTI targetVTI,
0: 					ResultColumnList targetColumnList,
0: 					DMLStatementNode statement,
0: 					FromList fromListParam)
0: 				throws StandardException
0: 	{
0: 		leftResultSet.bindResultColumns(targetTableDescriptor,
0: 										targetVTI,
0: 										targetColumnList,
0: 										statement, fromListParam);
0: 		rightResultSet.bindResultColumns(targetTableDescriptor,
0: 										targetVTI,
0: 										targetColumnList,
0: 										statement, fromListParam);
0: 	}
0: 
0: 	/** 
0: 	 * Determine whether or not the specified name is an exposed name in
0: 	 * the current query block.
0: 	 *
0: 	 * @param name	The specified name to search for as an exposed name.
0: 	 * @param schemaName	Schema name, if non-null.
0: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
0: 	 *						names or match on table id.
0: 	 *
0: 	 * @return The FromTable, if any, with the exposed name.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
0: 		throws StandardException
0: 	{
0: 		FromTable result = leftResultSet.getFromTableByName(name, schemaName, exactMatch);
0: 
0: 		/* We search both sides for a TableOperatorNode (join nodes)
0: 		 * but only the left side for a UnionNode.
0: 		 */
0: 		if (result == null)
0: 		{
0: 			result = rightResultSet.getFromTableByName(name, schemaName, exactMatch);
0: 		}
0: 		return result;
0: 	}
0: 
0: 	/** 
0: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
0: 	 * ColumnReferences must continue to point to the same ResultColumn, so
0: 	 * that ResultColumn must percolate up to the new PRN.  However,
0: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
0: 	 * which points to the FromTable and the ResultColumn that is the source for
0: 	 * the ColumnReference.  
0: 	 * (The new PRN will have the original of the ResultColumnList and
0: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
0: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
0: 	 * will remain at the FromTable, with the PRN getting a new 
0: 	 * VirtualColumnNode for each ResultColumn.expression.)
0: 	 * We then project out the non-referenced columns.  If there are no referenced
0: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
0: 	 * whose expression is 1.
0: 	 *
0: 	 * @param numTables			Number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList)
0: 								throws StandardException
0: 	{
0: 		leftResultSet = leftResultSet.preprocess(numTables, gbl, fromList);
0: 		/* If leftResultSet is a FromSubquery, then we must explicitly extract
0: 		 * out the subquery (flatten it).  (SelectNodes have their own
0: 		 * method of flattening them.
0: 		 */
0: 		if (leftResultSet instanceof FromSubquery)
0: 		{
0: 			leftResultSet = ((FromSubquery) leftResultSet).extractSubquery(numTables);
0: 		}
0: 		rightResultSet = rightResultSet.preprocess(numTables, gbl, fromList);
0: 		/* If rightResultSet is a FromSubquery, then we must explicitly extract
0: 		 * out the subquery (flatten it).  (SelectNodes have their own
0: 		 * method of flattening them.
0: 		 */
0: 		if (rightResultSet instanceof FromSubquery)
0: 		{
0: 			rightResultSet = ((FromSubquery) rightResultSet).extractSubquery(numTables);
0: 		}
0: 
0: 		/* Build the referenced table map (left || right) */
0: 		referencedTableMap = (JBitSet) leftResultSet.getReferencedTableMap().clone();
0: 		referencedTableMap.or((JBitSet) rightResultSet.getReferencedTableMap());
0: 		referencedTableMap.set(tableNumber);
0: 
0: 		/* Only generate a PRN if this node is not a flattenable join node. */
0: 		if (isFlattenableJoinNode())
0: 		{
0: 			return this;
0: 		}
0: 		else
0: 		{
0: 			/* Project out any unreferenced RCs before we generate the PRN.
0: 			 * NOTE: We have to do this at the end of preprocess since it has to 
0: 			 * be from the bottom up.  We can't do it until the join expression is 
0: 			 * bound, since the join expression may contain column references that
0: 			 * are not referenced anywhere else above us.
0: 			 */
0:             projectResultColumns();
0: 			return genProjectRestrict(numTables);
0: 		}
0: 	}
0: 
0:     /**
0:      * Find the unreferenced result columns and project them out. This is used in pre-processing joins
0:      * that are not flattened into the where clause.
0:      */
0:     void projectResultColumns() throws StandardException
0:     {
0:         resultColumns.doProjection();
0:     }
0:     
0:     /**
0:      * Set the referenced columns in the column list if it may not be correct.
0:      */
0:     void setReferencedColumns()
0:     {}
0:     
0: 	/**
0: 	 * Optimize a TableOperatorNode. 
0: 	 *
0: 	 * @param dataDictionary	The DataDictionary to use for optimization
0: 	 * @param predicateList		The PredicateList to apply.
0: 	 *
0: 	 * @return	ResultSetNode	The top of the optimized query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode optimize(DataDictionary dataDictionary,
0: 								  PredicateList predicateList,
0: 								  double outerRows)
0: 				throws StandardException
0: 	{
0: 		/* Get an optimizer, so we can get a cost structure */
0: 		Optimizer optimizer =
0: 							getOptimizer(
0: 								(FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									this,
0: 									getContextManager()),
0: 									predicateList,
0: 									dataDictionary,
0: 									(RequiredRowOrdering) null);
0: 
0: 		costEstimate = optimizer.newCostEstimate();
0: 
0: 		/* RESOLVE: This is just a stub for now */
0: 		leftResultSet = leftResultSet.optimize(
0: 											dataDictionary,
0: 											predicateList,
0: 											outerRows);
0: 		rightResultSet = rightResultSet.optimize(
0: 											dataDictionary,
0: 											predicateList,
0: 											outerRows);
0: 
0: 		/* The cost is the sum of the two child costs */
0: 		costEstimate.setCost(leftResultSet.getCostEstimate().getEstimatedCost(),
0: 							 leftResultSet.getCostEstimate().rowCount(),
0: 							 leftResultSet.getCostEstimate().singleScanRowCount() +
0: 							 rightResultSet.getCostEstimate().singleScanRowCount());
0: 
0: 		costEstimate.add(rightResultSet.costEstimate, costEstimate);
0: 
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSetNode#modifyAccessPaths
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode modifyAccessPaths() throws StandardException
0: 	{
0: 		/* Beetle 4454 - union all with another union all would modify access
0: 		 * paths twice causing NullPointerException, make sure we don't
0: 		 * do this again, if we have already done it in modifyAccessPaths(outertables)
0: 		 */
0: 		if (!leftModifyAccessPathsDone)
0: 		{
0: 			if (leftOptimizer != null)
0: 				leftOptimizer.modifyAccessPaths();
0: 			else
0: 				leftResultSet = leftResultSet.modifyAccessPaths();
0: 		}
0: 		if (!rightModifyAccessPathsDone)
0: 		{
0: 			if (rightOptimizer != null)
0: 				rightOptimizer.modifyAccessPaths();
0: 			else
0: 				rightResultSet = rightResultSet.modifyAccessPaths();
0: 		}
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Search to see if a query references the specifed table name.
0: 	 *
0: 	 * @param name		Table name (String) to search for.
0: 	 * @param baseTable	Whether or not name is for a base table
0: 	 *
0: 	 * @return	true if found, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesTarget(String name, boolean baseTable)
0: 		throws StandardException
0: 	{
0: 		return leftResultSet.referencesTarget(name, baseTable) ||
0: 			   rightResultSet.referencesTarget(name, baseTable);
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		return leftResultSet.referencesSessionSchema() ||
0: 			   rightResultSet.referencesSessionSchema();
0: 	}
0: 
0: 	/** 
0: 	 * Optimize a source result set to this table operator.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected ResultSetNode optimizeSource(
0: 							Optimizer optimizer,
0: 							ResultSetNode sourceResultSet,
0: 							PredicateList predList,
0: 							CostEstimate outerCost)
0: 			throws StandardException
0: 	{
0: 		ResultSetNode	retval;
0: 
0: 		if (sourceResultSet instanceof FromTable)
0: 		{
0: 			FromList optList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									sourceResultSet,
0: 									getContextManager());
0: 
0: 			/* If there is no predicate list, create an empty one */
0: 			if (predList == null)
0: 				predList = (PredicateList) getNodeFactory().getNode(
0: 												C_NodeTypes.PREDICATE_LIST,
0: 												getContextManager());
0: 
0: 			LanguageConnectionContext lcc = getLanguageConnectionContext();
0: 			OptimizerFactory optimizerFactory = lcc.getOptimizerFactory();
0: 			optimizer = optimizerFactory.getOptimizer(optList,
0: 													predList,
0: 													getDataDictionary(),
0: 													(RequiredRowOrdering) null,
0: 													getCompilerContext().getNumTables(),
0: 													  lcc);
0: 
0: 			if (sourceResultSet == leftResultSet)
0: 			{
0: 				leftOptimizer = optimizer;
0: 			}
0: 			else if (sourceResultSet == rightResultSet)
0: 			{
0: 				rightOptimizer = optimizer;
0: 			}
0: 			else
0: 			{
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.THROWASSERT("Result set being optimized is neither left nor right");
0: 			}
0: 			
0: 			/*
0: 			** Set the estimated number of outer rows from the outer part of
0: 			** the plan.
0: 			*/
0: 			optimizer.setOuterRows(outerCost.rowCount());
0: 
0: 			/* Optimize the underlying result set */
0: 			while (optimizer.getNextPermutation())
0: 			{
0: 				while (optimizer.getNextDecoratedPermutation())
0: 				{
0: 					optimizer.costPermutation();
0: 				}
0: 			}
0: 
0: 			retval = sourceResultSet;
0: 		}
0: 		else
0: 		{
0: 			retval = sourceResultSet.optimize(
0: 										optimizer.getDataDictionary(),
0: 										predList,
0: 										outerCost.rowCount());
0: 		}
0: 
0: 		return retval;
0: 	}
0: 
0: 	/**
0: 	 * Decrement (query block) level (0-based) for 
0: 	 * all of the tables in this ResultSet tree.
0: 	 * This is useful when flattening a subquery.
0: 	 *
0: 	 * @param decrement	The amount to decrement by.
0: 	 *
0: 	 * @return Nothing;
0: 	 */
0: 	void decrementLevel(int decrement)
0: 	{
0: 		leftResultSet.decrementLevel(decrement);
0: 		rightResultSet.decrementLevel(decrement);
0: 	}
0: 
0: 	/**
0: 	 * Replace any DEFAULTs with the associated tree for the default.
0: 	 *
0: 	 * @param ttd	The TableDescriptor for the target table.
0: 	 * @param tcl	The RCL for the target table.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void replaceDefaults(TableDescriptor ttd, ResultColumnList tcl) 
0: 		throws StandardException
0: 	{
0: 		leftResultSet.replaceDefaults(ttd, tcl);
0: 		rightResultSet.replaceDefaults(ttd, tcl);
0: 	}
0: 
0: 	/**
0: 	 * Notify the underlying result set tree that the result is
0: 	 * ordering dependent.  (For example, no bulk fetch on an index
0: 	 * if under an IndexRowToBaseRow.)
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void markOrderingDependent()
0: 	{
0: 		leftResultSet.markOrderingDependent();
0: 		rightResultSet.markOrderingDependent();
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		if (v.skipChildren(this))
0: 		{
0: 			return v.visit(this);
0: 		}
0: 
0: 		Visitable returnNode = super.accept(v);
0: 
0: 		if (leftResultSet != null && !v.stopTraversal())
0: 		{
0: 			leftResultSet = (ResultSetNode)leftResultSet.accept(v);
0: 		}
0: 		if (rightResultSet != null && !v.stopTraversal())
0: 		{
0: 			rightResultSet = (ResultSetNode)rightResultSet.accept(v);
0: 		}
0: 		return returnNode;
0: 	}
0: 
0: 	/** 
0: 	 * apparently something special needs to be done for me....
0: 	 */
0: 	public boolean needsSpecialRCLBinding()
0: 	{
0: 		return true;
0: 	}
0: }
============================================================================