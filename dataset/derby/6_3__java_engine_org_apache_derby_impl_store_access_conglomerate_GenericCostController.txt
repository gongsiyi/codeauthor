1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.conglomerate.GenericCostController
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
6:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.conglomerate;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
4:eac0369: /**
1:eac0369: 
1:eac0369: A Generic class which implements the basic functionality needed for a cost 
1:eac0369: controller.  
1:eac0369: 
3:eac0369: **/
1:eac0369: 
1:b22462c: public abstract class GenericCostController 
1:eac0369:     extends GenericController implements StoreCostController
3:eac0369: {
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Fields of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constructors for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Private/Protected methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implementing StoreCostController class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implementing StoreCostController class, default impl
1:eac0369:      *      just throws exception:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the cost of exact key lookup.
10:eac0369:      * <p>
1:eac0369:      * Return the estimated cost of calling ScanController.fetch()
1:eac0369:      * on the current conglomerate, with start and stop positions set such
1:eac0369:      * that an exact match is expected.
1:eac0369:      * <p>
1:eac0369:      * This call returns the cost of a fetchNext() performed on a scan which
1:eac0369:      * has been positioned with a start position which specifies exact match
1:eac0369:      * on all keys in the row.
1:eac0369:      * <p>
1:eac0369:      * Example:
1:eac0369:      * <p>
1:eac0369:      * In the case of a btree this call can be used to determine the cost of
1:eac0369:      * doing an exact probe into btree, giving all key columns.  This cost
1:eac0369:      * can be used if the client knows it will be doing an exact key probe
1:eac0369:      * but does not have the key's at optimize time to use to make a call to
1:eac0369:      * getScanCost()
1:eac0369:      * <p>
27:eac0369:      *
2:eac0369: 	 * @param validColumns    A description of which columns to return from
2:eac0369:      *                        row on the page into "templateRow."  templateRow,
2:eac0369:      *                        and validColumns work together to
2:eac0369:      *                        describe the row to be returned by the fetch - 
3:eac0369:      *                        see RowUtil for description of how these three 
2:eac0369:      *                        parameters work together to describe a fetched 
2:eac0369:      *                        "row".
1:eac0369:      *
3:eac0369:      * @param access_type     Describe the type of access the query will be
2:eac0369:      *                        performing to the ScanController.  
1:eac0369:      *
2:eac0369:      *                        STORECOST_CLUSTERED - The location of one scan
2:eac0369:      *                            is likely clustered "close" to the previous 
2:eac0369:      *                            scan.  For instance if the query plan were
2:eac0369:      *                            to used repeated "reopenScan()'s" to probe
2:eac0369:      *                            for the next key in an index, then this flag
2:eac0369:      *                            should be be specified.  If this flag is not 
2:eac0369:      *                            set then each scan will be costed independant
2:eac0369:      *                            of any other predicted scan access.
1:eac0369:      *
2:eac0369: 	 * @return The cost of the fetch.
1:eac0369:      *
3:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:fa09146: 	 * @see org.apache.derby.iapi.store.access.RowUtil
1:eac0369:      **/
1:eac0369:     public double getFetchFromFullKeyCost(
1:eac0369:     FormatableBitSet validColumns,
1:eac0369:     int     access_type)
3:eac0369: 		throws StandardException
1:eac0369:     {
3:eac0369:         // Not implemented in default conglomerate, needs to be overridden.
3:eac0369:         throw StandardException.newException(
3:eac0369:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE);
3:eac0369:     }
1:b22462c: 
1:eac0369: 
1:eac0369: }
============================================================================
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @see org.apache.derby.iapi.store.access.RowUtil
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:b22462c
/////////////////////////////////////////////////////////////////////////
1: public abstract class GenericCostController 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.conglomerate.GenericCostController
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.conglomerate
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.conglomerate;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.StoreCostResult;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.impl.sql.execute.RowUtil;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: 
1: /**
1: 
1: A Generic class which implements the basic functionality needed for a cost 
1: controller.  
1: 
1: **/
1: 
0: public class GenericCostController 
1:     extends GenericController implements StoreCostController
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1: 
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Public Methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Public Methods implementing StoreCostController class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Public Methods implementing StoreCostController class, default impl
1:      *      just throws exception:
1:      **************************************************************************
1:      */
1: 
1:     /**
0:      * Return the cost of calling ConglomerateController.fetch().
1:      * <p>
0:      * Return the estimated cost of calling ConglomerateController.fetch()
0:      * on the current conglomerate.  This gives the cost of finding a record
0:      * in the conglomerate given the exact RowLocation of the record in
0:      * question. 
1:      * <p>
0:      * The validColumns describes what kind of row is being fetched, 
0:      * ie. it may be cheaper to fetch a partial row than a complete row.
1:      * <p>
1:      *
1:      *
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "templateRow."  templateRow,
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1:      *
1:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ConglomerateController.  
1:      *
0:      *                        STORECOST_CLUSTERED - The location of one fetch
0:      *                            is likely clustered "close" to the next 
0:      *                            fetch.  For instance if the query plan were
0:      *                            to sort the RowLocations of a heap and then
0:      *                            use those RowLocations sequentially to 
0:      *                            probe into the heap, then this flag should
0:      *                            be specified.  If this flag is not set then
0:      *                            access to the table is assumed to be
0:      *                            random - ie. the type of access one gets 
0:      *                            if you scan an index and probe each row
0:      *                            in turn into the base table is "random".
1:      *
1:      *
1: 	 * @return The cost of the fetch.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
0: 	 * @see RowUtil
1:      **/
0:     public double getFetchFromRowLocationCost(
0:     FormatableBitSet      validColumns,
0:     int         access_type)
1: 		throws StandardException
1:     {
1:         // Not implemented in default conglomerate, needs to be overridden.
1:         throw StandardException.newException(
1:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1:     /**
1:      * Return the cost of exact key lookup.
1:      * <p>
1:      * Return the estimated cost of calling ScanController.fetch()
1:      * on the current conglomerate, with start and stop positions set such
1:      * that an exact match is expected.
1:      * <p>
1:      * This call returns the cost of a fetchNext() performed on a scan which
1:      * has been positioned with a start position which specifies exact match
1:      * on all keys in the row.
1:      * <p>
1:      * Example:
1:      * <p>
1:      * In the case of a btree this call can be used to determine the cost of
1:      * doing an exact probe into btree, giving all key columns.  This cost
1:      * can be used if the client knows it will be doing an exact key probe
1:      * but does not have the key's at optimize time to use to make a call to
1:      * getScanCost()
1:      * <p>
1:      *
1: 	 * @param validColumns    A description of which columns to return from
1:      *                        row on the page into "templateRow."  templateRow,
1:      *                        and validColumns work together to
1:      *                        describe the row to be returned by the fetch - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a fetched 
1:      *                        "row".
1:      *
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ScanController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one scan
1:      *                            is likely clustered "close" to the previous 
1:      *                            scan.  For instance if the query plan were
1:      *                            to used repeated "reopenScan()'s" to probe
1:      *                            for the next key in an index, then this flag
1:      *                            should be be specified.  If this flag is not 
1:      *                            set then each scan will be costed independant
1:      *                            of any other predicted scan access.
1:      *
1: 	 * @return The cost of the fetch.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
0: 	 * @see RowUtil
1:      **/
1:     public double getFetchFromFullKeyCost(
1:     FormatableBitSet validColumns,
1:     int     access_type)
1: 		throws StandardException
1:     {
1:         // Not implemented in default conglomerate, needs to be overridden.
1:         throw StandardException.newException(
1:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE);
1:     }
1: 
1:     /**
0:      * Calculate the cost of a scan.
1:      * <p>
0:      * Cause this object to calculate the cost of performing the described
0:      * scan.  The interface is setup such that first a call is made to
0:      * calcualteScanCost(), and then subsequent calls to accessor routines
0:      * are made to get various pieces of information about the cost of
0:      * the scan.
1:      * <p>
0:      * For the purposes of costing this routine is going to assume that 
0:      * a page will remain in cache between the time one next()/fetchNext()
0:      * call and a subsequent next()/fetchNext() call is made within a scan.
1:      * <p>
0:      * The result of costing the scan is placed in the "cost_result".  
0:      * The cost of the scan is stored by calling 
0:      * cost_result.setEstimatedCost(cost).
0:      * The estimated row count is stored by calling 
0:      * cost_result.setEstimatedRowCount(row_count).
1:      * <p>
0:      * The estimated cost of the scan assumes the caller will 
0:      * execute a fetchNext() loop for every row that qualifies between
0:      * start and stop position.  Note that this cost is different than
0:      * execution a next(),fetch() loop; or if the scan is going to be
0:      * terminated by client prior to reaching the stop condition.
1:      * <p>
0:      * The estimated number of rows returned from the scan 
0:      * assumes the caller will execute a fetchNext() loop for every 
0:      * row that qualifies between start and stop position.
1:      * <p>
1:      *
1:      *
0:      * @param scan_type       The type of scan that will be executed.  There
0:      *                        are currently 2 types:
0:      *                        STORECOST_SCAN_NORMAL - scans will be executed
0:      *                        using the standard next/fetch, where each fetch
0:      *                        can retrieve 1 or many rows (if fetchNextGroup()
0:      *                        interface is used).
1:      *
0:      *                        STORECOST_SCAN_SET - The entire result set will
0:      *                        be retrieved using the the fetchSet() interface.
1:      *
0:      * @param row_count       Estimated total row count of the table.  The 
0:      *                        current system tracks row counts in heaps better
0:      *                        than btree's (btree's have "rows" which are not
0:      *                        user rows - branch rows, control rows), so 
0:      *                        if available the client should
0:      *                        pass in the base table's row count into this
0:      *                        routine to be used as the index's row count.
0:      *                        If the caller has no idea, pass in -1.
1:      *
0:      * @param group_size      The number of rows to be returned by a single
0:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
1:      *
0: 	 * @param forUpdate       Should be true if the caller intends to update 
0:      *                        through the scan.
1:      * 
0: 	 * @param scanColumnList  A description of which columns to return from 
0:      *                        every fetch in the scan.  template, 
0:      *                        and scanColumnList work together
0:      *                        to describe the row to be returned by the scan - 
1:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a "row".
1:      * 
0:      * @param template        A prototypical row which the scan may use to
0: 	 *                        maintain its position in the conglomerate.  Not 
0:      *                        all access method scan types will require this, 
0:      *                        if they don't it's ok to pass in null.
0:      *                        In order to scan a conglomerate one must 
0:      *                        allocate 2 separate "row" templates.  The "row" 
0:      *                        template passed into openScan is for the private
0:      *                        use of the scan itself, and no access to it
0:      *                        should be made by the caller while the scan is 
0:      *                        still open.  Because of this the scanner must 
0:      *                        allocate another "row" template to hold the 
0:      *                        values returned from fetch().  Note that this 
0:      *                        template must be for the full row, whether a 
0:      *                        partial row scan is being executed or not.
1:      *
0: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        startSearchOperator, defines the starting 
0:      *                        position of the scan.  If null, the starting
0:      *                        position of the scan is the first row of the 
0:      *                        conglomerate.  The startKeyValue must only
0:      *                        reference columns included in the scanColumnList.
1:      *
0: 	 * @param startSearchOperation 
0:      *                        an operator which defines how the startKeyValue
0:      *                        is to be searched for.  If startSearchOperation 
0:      *                        is ScanController.GE, the scan starts on the 
0:      *                        first row which is greater than or equal to the 
0: 	 *                        startKeyValue.  If startSearchOperation is 
0:      *                        ScanController.GT, the scan starts on the first
0:      *                        row whose key is greater than startKeyValue.  The
0:      *                        startSearchOperation parameter is ignored if the
0:      *                        startKeyValue parameter is null.
1:      *
0: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        stopSearchOperator, defines the ending position
0:      *                        of the scan.  If null, the ending position of the
0:      *                        scan is the last row of the conglomerate.  The
0:      *                        stopKeyValue must only reference columns included
0:      *                        in the scanColumnList.
1:      *
0: 	 * @param stopSearchOperation
0:      *                        an operator which defines how the stopKeyValue
0:      *                        is used to determine the scan stopping position. 
0:      *                        If stopSearchOperation is ScanController.GE, the
0:      *                        scan stops just before the first row which is
0:      *                        greater than or equal to the stopKeyValue.  If 
0:      *                        stopSearchOperation is ScanController.GT, the 
0:      *                        scan stops just before the first row whose key 
0:      *                        is greater than startKeyValue.  The
0:      *                        stopSearchOperation parameter is ignored if the
0:      *                        stopKeyValue parameter is null.
1:      *
1:      *                        
1:      * @param access_type     Describe the type of access the query will be
1:      *                        performing to the ScanController.  
1:      *
1:      *                        STORECOST_CLUSTERED - The location of one scan
1:      *                            is likely clustered "close" to the previous 
1:      *                            scan.  For instance if the query plan were
1:      *                            to used repeated "reopenScan()'s" to probe
1:      *                            for the next key in an index, then this flag
1:      *                            should be be specified.  If this flag is not 
1:      *                            set then each scan will be costed independant
1:      *                            of any other predicted scan access.
1:      *
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
0: 	 * @see RowUtil
1:      **/
0: 	public void getScanCost(
0:         int                     scan_type,
0:         long                    row_count,
0:         int                     group_size,
0: 		boolean                 forUpdate,
0: 		FormatableBitSet                 scanColumnList,
0: 		DataValueDescriptor[]   template,
0: 		DataValueDescriptor[]   startKeyValue,
0: 		int                     startSearchOperator,
0: 		DataValueDescriptor[]   stopKeyValue,
0: 		int                     stopSearchOperator,
0:         boolean                 reopen_scan,
0:         int                     access_type,
0:         StoreCostResult         cost_result)
1: 			throws StandardException
1:     {
1:         // Not implemented in default conglomerate, needs to be overridden.
1:         throw StandardException.newException(
1:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE);
1:     }
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:8758a25
/////////////////////////////////////////////////////////////////////////
0: 	 * @param startSearchOperator 
/////////////////////////////////////////////////////////////////////////
0: 	 * @param stopSearchOperator
/////////////////////////////////////////////////////////////////////////
0: 		FormatableBitSet        scanColumnList,
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.conglomerate
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.conglomerate;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.StoreCostResult;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.impl.sql.execute.RowUtil;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: 
0: /**
0: 
0: A Generic class which implements the basic functionality needed for a cost 
0: controller.  
0: 
0: **/
0: 
0: public class GenericCostController 
0:     extends GenericController implements StoreCostController
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0: 
0:     /**************************************************************************
0:      * Fields of the class
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Private/Protected methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Public Methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Public Methods implementing StoreCostController class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Public Methods implementing StoreCostController class, default impl
0:      *      just throws exception:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Return the cost of calling ConglomerateController.fetch().
0:      * <p>
0:      * Return the estimated cost of calling ConglomerateController.fetch()
0:      * on the current conglomerate.  This gives the cost of finding a record
0:      * in the conglomerate given the exact RowLocation of the record in
0:      * question. 
0:      * <p>
0:      * The validColumns describes what kind of row is being fetched, 
0:      * ie. it may be cheaper to fetch a partial row than a complete row.
0:      * <p>
0:      *
0:      *
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "templateRow."  templateRow,
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0:      *
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ConglomerateController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one fetch
0:      *                            is likely clustered "close" to the next 
0:      *                            fetch.  For instance if the query plan were
0:      *                            to sort the RowLocations of a heap and then
0:      *                            use those RowLocations sequentially to 
0:      *                            probe into the heap, then this flag should
0:      *                            be specified.  If this flag is not set then
0:      *                            access to the table is assumed to be
0:      *                            random - ie. the type of access one gets 
0:      *                            if you scan an index and probe each row
0:      *                            in turn into the base table is "random".
0:      *
0:      *
0: 	 * @return The cost of the fetch.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     public double getFetchFromRowLocationCost(
0:     FormatableBitSet      validColumns,
0:     int         access_type)
0: 		throws StandardException
0:     {
0:         // Not implemented in default conglomerate, needs to be overridden.
0:         throw StandardException.newException(
0:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0:     /**
0:      * Return the cost of exact key lookup.
0:      * <p>
0:      * Return the estimated cost of calling ScanController.fetch()
0:      * on the current conglomerate, with start and stop positions set such
0:      * that an exact match is expected.
0:      * <p>
0:      * This call returns the cost of a fetchNext() performed on a scan which
0:      * has been positioned with a start position which specifies exact match
0:      * on all keys in the row.
0:      * <p>
0:      * Example:
0:      * <p>
0:      * In the case of a btree this call can be used to determine the cost of
0:      * doing an exact probe into btree, giving all key columns.  This cost
0:      * can be used if the client knows it will be doing an exact key probe
0:      * but does not have the key's at optimize time to use to make a call to
0:      * getScanCost()
0:      * <p>
0:      *
0: 	 * @param validColumns    A description of which columns to return from
0:      *                        row on the page into "templateRow."  templateRow,
0:      *                        and validColumns work together to
0:      *                        describe the row to be returned by the fetch - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a fetched 
0:      *                        "row".
0:      *
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ScanController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one scan
0:      *                            is likely clustered "close" to the previous 
0:      *                            scan.  For instance if the query plan were
0:      *                            to used repeated "reopenScan()'s" to probe
0:      *                            for the next key in an index, then this flag
0:      *                            should be be specified.  If this flag is not 
0:      *                            set then each scan will be costed independant
0:      *                            of any other predicted scan access.
0:      *
0: 	 * @return The cost of the fetch.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0:     public double getFetchFromFullKeyCost(
0:     FormatableBitSet validColumns,
0:     int     access_type)
0: 		throws StandardException
0:     {
0:         // Not implemented in default conglomerate, needs to be overridden.
0:         throw StandardException.newException(
0:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE);
0:     }
0: 
0:     /**
0:      * Calculate the cost of a scan.
0:      * <p>
0:      * Cause this object to calculate the cost of performing the described
0:      * scan.  The interface is setup such that first a call is made to
0:      * calcualteScanCost(), and then subsequent calls to accessor routines
0:      * are made to get various pieces of information about the cost of
0:      * the scan.
0:      * <p>
0:      * For the purposes of costing this routine is going to assume that 
0:      * a page will remain in cache between the time one next()/fetchNext()
0:      * call and a subsequent next()/fetchNext() call is made within a scan.
0:      * <p>
0:      * The result of costing the scan is placed in the "cost_result".  
0:      * The cost of the scan is stored by calling 
0:      * cost_result.setEstimatedCost(cost).
0:      * The estimated row count is stored by calling 
0:      * cost_result.setEstimatedRowCount(row_count).
0:      * <p>
0:      * The estimated cost of the scan assumes the caller will 
0:      * execute a fetchNext() loop for every row that qualifies between
0:      * start and stop position.  Note that this cost is different than
0:      * execution a next(),fetch() loop; or if the scan is going to be
0:      * terminated by client prior to reaching the stop condition.
0:      * <p>
0:      * The estimated number of rows returned from the scan 
0:      * assumes the caller will execute a fetchNext() loop for every 
0:      * row that qualifies between start and stop position.
0:      * <p>
0:      *
0:      *
0:      * @param scan_type       The type of scan that will be executed.  There
0:      *                        are currently 2 types:
0:      *                        STORECOST_SCAN_NORMAL - scans will be executed
0:      *                        using the standard next/fetch, where each fetch
0:      *                        can retrieve 1 or many rows (if fetchNextGroup()
0:      *                        interface is used).
0:      *
0:      *                        STORECOST_SCAN_SET - The entire result set will
0:      *                        be retrieved using the the fetchSet() interface.
0:      *
0:      * @param row_count       Estimated total row count of the table.  The 
0:      *                        current system tracks row counts in heaps better
0:      *                        than btree's (btree's have "rows" which are not
0:      *                        user rows - branch rows, control rows), so 
0:      *                        if available the client should
0:      *                        pass in the base table's row count into this
0:      *                        routine to be used as the index's row count.
0:      *                        If the caller has no idea, pass in -1.
0:      *
0:      * @param group_size      The number of rows to be returned by a single
0:      *                        fetch call for STORECOST_SCAN_NORMAL scans.
0:      *
0: 	 * @param forUpdate       Should be true if the caller intends to update 
0:      *                        through the scan.
0:      * 
0: 	 * @param scanColumnList  A description of which columns to return from 
0:      *                        every fetch in the scan.  template, 
0:      *                        and scanColumnList work together
0:      *                        to describe the row to be returned by the scan - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a "row".
0:      * 
0:      * @param template        A prototypical row which the scan may use to
0: 	 *                        maintain its position in the conglomerate.  Not 
0:      *                        all access method scan types will require this, 
0:      *                        if they don't it's ok to pass in null.
0:      *                        In order to scan a conglomerate one must 
0:      *                        allocate 2 separate "row" templates.  The "row" 
0:      *                        template passed into openScan is for the private
0:      *                        use of the scan itself, and no access to it
0:      *                        should be made by the caller while the scan is 
0:      *                        still open.  Because of this the scanner must 
0:      *                        allocate another "row" template to hold the 
0:      *                        values returned from fetch().  Note that this 
0:      *                        template must be for the full row, whether a 
0:      *                        partial row scan is being executed or not.
0:      *
0: 	 * @param startKeyValue   An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        startSearchOperator, defines the starting 
0:      *                        position of the scan.  If null, the starting
0:      *                        position of the scan is the first row of the 
0:      *                        conglomerate.  The startKeyValue must only
0:      *                        reference columns included in the scanColumnList.
0:      *
0: 	 * @param startSearchOperation 
0:      *                        an operator which defines how the startKeyValue
0:      *                        is to be searched for.  If startSearchOperation 
0:      *                        is ScanController.GE, the scan starts on the 
0:      *                        first row which is greater than or equal to the 
0: 	 *                        startKeyValue.  If startSearchOperation is 
0:      *                        ScanController.GT, the scan starts on the first
0:      *                        row whose key is greater than startKeyValue.  The
0:      *                        startSearchOperation parameter is ignored if the
0:      *                        startKeyValue parameter is null.
0:      *
0: 	 * @param stopKeyValue    An indexable row which holds a (partial) key 
0:      *                        value which, in combination with the 
0:      *                        stopSearchOperator, defines the ending position
0:      *                        of the scan.  If null, the ending position of the
0:      *                        scan is the last row of the conglomerate.  The
0:      *                        stopKeyValue must only reference columns included
0:      *                        in the scanColumnList.
0:      *
0: 	 * @param stopSearchOperation
0:      *                        an operator which defines how the stopKeyValue
0:      *                        is used to determine the scan stopping position. 
0:      *                        If stopSearchOperation is ScanController.GE, the
0:      *                        scan stops just before the first row which is
0:      *                        greater than or equal to the stopKeyValue.  If 
0:      *                        stopSearchOperation is ScanController.GT, the 
0:      *                        scan stops just before the first row whose key 
0:      *                        is greater than startKeyValue.  The
0:      *                        stopSearchOperation parameter is ignored if the
0:      *                        stopKeyValue parameter is null.
0:      *
0:      *                        
0:      * @param access_type     Describe the type of access the query will be
0:      *                        performing to the ScanController.  
0:      *
0:      *                        STORECOST_CLUSTERED - The location of one scan
0:      *                            is likely clustered "close" to the previous 
0:      *                            scan.  For instance if the query plan were
0:      *                            to used repeated "reopenScan()'s" to probe
0:      *                            for the next key in an index, then this flag
0:      *                            should be be specified.  If this flag is not 
0:      *                            set then each scan will be costed independant
0:      *                            of any other predicted scan access.
0:      *
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0: 	 * @see RowUtil
0:      **/
0: 	public void getScanCost(
0:         int                     scan_type,
0:         long                    row_count,
0:         int                     group_size,
0: 		boolean                 forUpdate,
0: 		FormatableBitSet                 scanColumnList,
0: 		DataValueDescriptor[]   template,
0: 		DataValueDescriptor[]   startKeyValue,
0: 		int                     startSearchOperator,
0: 		DataValueDescriptor[]   stopKeyValue,
0: 		int                     stopSearchOperator,
0:         boolean                 reopen_scan,
0:         int                     access_type,
0:         StoreCostResult         cost_result)
0: 			throws StandardException
0:     {
0:         // Not implemented in default conglomerate, needs to be overridden.
0:         throw StandardException.newException(
0:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE);
0:     }
0: }
============================================================================