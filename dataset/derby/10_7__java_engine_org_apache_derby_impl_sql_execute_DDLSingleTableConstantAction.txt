1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.DDLSingleTableConstantAction
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:a52a206: import java.util.ArrayList;
1:c92685e: import java.util.List;
1:c92685e: import java.util.Properties;
1:c92685e: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:c92685e: import org.apache.derby.iapi.error.StandardException;
1:c92685e: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:c92685e: 
1:c92685e: import org.apache.derby.iapi.sql.Activation;
1:c92685e: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:c92685e: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:c92685e: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1:c92685e: import org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor;
1:c92685e: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:c92685e: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:c92685e: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:c92685e: import org.apache.derby.iapi.store.access.ConglomerateController;
1:c92685e: import org.apache.derby.iapi.store.access.TransactionController;
1:c92685e: 
3:eac0369: /**
1:eac0369:  * Abstract class that has actions that are across
1:eac0369:  * all DDL actions that are tied to a table.  An example
1:eac0369:  * of DDL that affects a table is CREATE INDEX or
1:eac0369:  * DROP VIEW.  An example of DDL that does not affect
1:eac0369:  * a table is CREATE STATEMENT or DROP SCHEMA.
2:eac0369:  *
1:eac0369:  */
1:eac0369: abstract class DDLSingleTableConstantAction extends DDLConstantAction 
2:eac0369: {
1:eac0369: 	protected UUID					tableId;
1:c92685e: 
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * constructor
1:eac0369: 	 *
1:eac0369: 	 * @param tableId the target table
1:eac0369: 	 */
1:9cd47dc: 	DDLSingleTableConstantAction(UUID tableId)
1:eac0369: 	{
1:eac0369: 		super();
1:eac0369: 		this.tableId = tableId;
2:eac0369: 	}
1:c92685e: 
1:c92685e: 	/**
1:c92685e: 	 * Drop the constraint corresponding to the received descriptor.
1:c92685e: 	 * If in doing so we also drop a backing conglomerate that is
1:c92685e: 	 * shared by other constraints/indexes, then we have to create
1:c92685e: 	 * a new conglomerate to fill the gap.
1:c92685e: 	 *
1:c92685e: 	 * This method exists here as a "utility" method for the various
1:c92685e: 	 * constant actions that may drop constraints in one way or
1:c92685e: 	 * another (there are several that do).
1:c92685e: 	 *
1:c92685e: 	 * @param consDesc ConstraintDescriptor for the constraint to drop
2:c92685e: 	 * @param activation Activation used when creating a new backing
2:c92685e: 	 *  index (if a new backing index is needed)
2:c92685e: 	 * @param lcc LanguageConnectionContext used for dropping
1:c92685e: 	 * @param clearDeps Whether or not to clear dependencies when
1:c92685e: 	 *   dropping the constraint
1:c92685e: 	 */
1:c92685e: 	void dropConstraint(ConstraintDescriptor consDesc,
1:c92685e: 		Activation activation, LanguageConnectionContext lcc,
1:c92685e: 		boolean clearDeps) throws StandardException
1:c92685e: 	{
1:c92685e: 		dropConstraint(consDesc, (TableDescriptor)null,
1:71c8e86: 			(List<ConstantAction>)null, activation, lcc, clearDeps);
1:c92685e: 	}
1:c92685e: 
1:c92685e: 	/**
1:c92685e: 	 * See "dropConstraint(...") above.
1:c92685e: 	 *
1:c92685e: 	 * @param skipCreate Optional TableDescriptor.  If non-null
1:c92685e: 	 *  then we will skip the "create new conglomerate" processing
1:c92685e: 	 *  *IF* the constraint that we drop came from the table
1:c92685e: 	 *  described by skipCreate.
1:c92685e: 	 */
1:c92685e: 	void dropConstraint(ConstraintDescriptor consDesc,
1:c92685e: 		TableDescriptor skipCreate, Activation activation,
1:c92685e: 		LanguageConnectionContext lcc, boolean clearDeps)
1:c92685e: 		throws StandardException
1:c92685e: 	{
1:c92685e: 		dropConstraint(consDesc, skipCreate,
1:71c8e86: 			(List<ConstantAction>)null, activation, lcc, clearDeps);
1:c92685e: 	}
1:c92685e: 
1:c92685e: 	/**
1:c92685e: 	 * See "dropConstraint(...") above.
1:c92685e: 	 *
1:c92685e: 	 * @param newConglomActions Optional List.  If non-null then
1:c92685e: 	 *  for each ConglomerateDescriptor for which we skip the
1:c92685e: 	 *  "create new conglomerate" processing we will add a
1:c92685e: 	 *  ConstantAction to this list.  The constant action can
1:c92685e: 	 *  then be executed later (esp. by the caller) to create the
1:c92685e: 	 *  new conglomerate, if needed.  If this argument is null and
1:c92685e: 	 *  we skip creation of a new conglomerate, the new conglomerate
1:c92685e: 	 *  is effectively ignored (which may be fine in some cases--
1:c92685e: 	 *  ex. when dropping a table).
1:c92685e: 	 */
1:c92685e: 	void dropConstraint(ConstraintDescriptor consDesc,
1:71c8e86: 		TableDescriptor skipCreate, List<ConstantAction> newConglomActions,
1:c92685e: 		Activation activation, LanguageConnectionContext lcc,
1:c92685e: 		boolean clearDeps) throws StandardException
1:c92685e: 	{
1:c92685e: 		/* Get the properties on the old backing conglomerate before
1:c92685e: 		 * dropping the constraint, since we can't get them later if
1:c92685e: 		 * dropping the constraint causes us to drop the backing
1:c92685e: 		 * conglomerate.
1:c92685e: 		 */
1:c92685e: 		Properties ixProps = null;
1:c92685e: 		if (consDesc instanceof KeyConstraintDescriptor)
1:c92685e: 		{
1:c92685e: 			ixProps = new Properties();
1:c92685e: 			loadIndexProperties(lcc,
1:c92685e: 				((KeyConstraintDescriptor)consDesc)
1:c92685e: 					.getIndexConglomerateDescriptor(lcc.getDataDictionary()),
1:c92685e: 				ixProps);
1:c92685e: 		}
1:c92685e: 
1:c92685e: 		ConglomerateDescriptor newBackingConglomCD = consDesc.drop(lcc, clearDeps);
1:c92685e: 
1:c92685e: 		/* If we don't need a new conglomerate then there's nothing
1:c92685e: 		 * else to do.
1:c92685e: 		 */
1:c92685e: 		if (newBackingConglomCD == null)
1:c92685e: 			return;
1:a52a206: 
1:c92685e: 		/* Only create the new conglomerate if it is NOT for the table
1:c92685e: 		 * described by skipCreate.
1:c92685e: 		 */
1:c92685e: 		if ((skipCreate != null) &&
1:c92685e: 			skipCreate.getUUID().equals(
1:c92685e: 				consDesc.getTableDescriptor().getUUID()))
1:c92685e: 		{
1:c92685e: 			/* We're skipping the "create new conglom" phase; if we have
1:c92685e: 			 * a list in which to store the ConstantAction, then store it;
1:c92685e: 			 * otherwise, the new conglomerate is effectively ignored.
1:c92685e: 			 */
1:c92685e: 			if (newConglomActions != null)
1:c92685e: 			{
1:c92685e: 				newConglomActions.add(
1:c92685e: 					getConglomReplacementAction(newBackingConglomCD,
1:c92685e: 						consDesc.getTableDescriptor(), ixProps));
1:c92685e: 			}
1:c92685e: 		}
1:c92685e: 		else
1:c92685e: 		{
1:c92685e: 			executeConglomReplacement(
1:c92685e: 				getConglomReplacementAction(newBackingConglomCD,
1:c92685e: 					consDesc.getTableDescriptor(), ixProps),
1:c92685e: 				activation);
1:c92685e: 		}
1:c92685e: 
1:c92685e: 		return;
1:c92685e: 	}
1:c92685e: 
1:a52a206: 	/**
1:c92685e: 	 * Similar to dropConstraint(...) above, except this method
1:c92685e: 	 * drops a conglomerate directly instead of going through
1:c92685e: 	 * a ConstraintDescriptor.
1:c92685e: 	 *
1:c92685e: 	 * @param congDesc ConglomerateDescriptor for the conglom to drop
1:a52a206: 	 * @param td TableDescriptor for the table on which congDesc exists
1:a52a206: 	 * @param activation Activation used when creating a new backing
1:a52a206: 	 *  index (if a new backing index is needed)
1:a52a206: 	 * @param lcc LanguageConnectionContext used for dropping
1:c92685e: 	 */
1:c92685e: 	void dropConglomerate(
1:c92685e: 		ConglomerateDescriptor congDesc, TableDescriptor td,
1:c92685e: 		Activation activation, LanguageConnectionContext lcc)
1:c92685e: 		throws StandardException
1:c92685e: 	{
1:c92685e: 		dropConglomerate(congDesc, td,
1:71c8e86: 			false, (List<ConstantAction>)null, activation, lcc);
1:c92685e: 	}
1:c92685e: 
1:c92685e: 	/**
1:c92685e: 	 * See "dropConglomerate(...)" above.
1:c92685e: 	 *	
1:c92685e: 	 * @param skipCreate If true then we will skip the "create
1:c92685e: 	 *  new conglomerate" processing for the dropped conglom.
1:c92685e: 	 * @param newConglomActions Optional List.  If non-null then
1:c92685e: 	 *  for each ConglomerateDescriptor for which we skip the
1:c92685e: 	 *  "create new conglomerate" processing we will add a
1:c92685e: 	 *  ConstantAction to this list.  The constant action can
1:c92685e: 	 *  then be executed later (esp. by the caller) to create the
1:c92685e: 	 *  new conglomerate, if needed.  If this argument is null and
1:c92685e: 	 *  we skip creation of a new conglomerate, the new conglomerate
1:c92685e: 	 *  is effectively ignored (which may be fine in some cases--
1:c92685e: 	 *  ex. when dropping a table).
1:c92685e: 	 */
1:c92685e: 	void dropConglomerate(
1:c92685e: 		ConglomerateDescriptor congDesc, TableDescriptor td,
1:71c8e86: 		boolean skipCreate, List<ConstantAction> newConglomActions,
1:c92685e: 		Activation activation, LanguageConnectionContext lcc)
1:c92685e: 		throws StandardException
1:c92685e: 	{
1:c92685e: 		// Get the properties on the old index before dropping.
1:c92685e: 		Properties ixProps = new Properties();
1:c92685e: 		loadIndexProperties(lcc, congDesc, ixProps);
1:c92685e: 
1:c92685e: 		// Drop the conglomerate.
1:c92685e: 		ConglomerateDescriptor newBackingConglomCD = congDesc.drop(lcc, td);
1:c92685e: 
1:c92685e: 		/* If we don't need a new conglomerate then there's nothing
1:c92685e: 		 * else to do.
1:c92685e: 		 */
1:c92685e: 		if (newBackingConglomCD == null)
1:c92685e: 			return;
1:c92685e: 
1:c92685e: 		if (skipCreate)
1:c92685e: 		{
1:c92685e: 			/* We're skipping the "create new conglom" phase; if we have
1:c92685e: 			 * a list in which to store the ConstantAction, then store it;
1:c92685e: 			 * otherwise, the new conglomerate is effectively ignored.
1:c92685e: 			 */
1:c92685e: 			if (newConglomActions != null)
1:c92685e: 			{
1:c92685e: 				newConglomActions.add(
1:c92685e: 					getConglomReplacementAction(
1:c92685e: 						newBackingConglomCD, td, ixProps));
1:c92685e: 			}
1:c92685e: 		}
1:c92685e: 		else
1:c92685e: 		{
1:c92685e: 			executeConglomReplacement(
1:c92685e: 				getConglomReplacementAction(newBackingConglomCD, td, ixProps),
1:c92685e: 				activation);
1:c92685e: 		}
1:c92685e: 
1:c92685e: 		return;
1:c92685e: 	}
1:c92685e:     
1:c92685e:     /**
1:a52a206:      * Recreate backing index of unique constraint.
1:2e3ed68:      *
1:a52a206:      * It first drops the existing index and creates it again with 
1:a52a206:      * uniqueness set to false and uniqueWhenNotNull set to true. It reuses
1:a52a206:      * the uuid so there is no need to update ConstraintDescriptor.
1:2e3ed68:      *
1:2e3ed68:      * @param cd            ConglomerateDescritor to recreate
1:2e3ed68:      * @param td            TableDescriptor for table on which congDesc exists
1:2e3ed68:      * @param activation    Activation used when creating a new backing index 
1:2e3ed68:      *                      (if a new backing index is needed)
1:2e3ed68:      * @param lcc           LanguageConnectionContext used for dropping
1:2e3ed68:      *
1:a52a206:      * @throws StandardException
1:a52a206:      */
1:2e3ed68:     void recreateUniqueConstraintBackingIndexAsUniqueWhenNotNull(
1:2e3ed68:     ConglomerateDescriptor      cd,
1:2e3ed68:     TableDescriptor             td,
1:2e3ed68:     Activation                  activation, 
1:2e3ed68:     LanguageConnectionContext   lcc) 
1:2e3ed68:         throws StandardException 
1:2e3ed68:     {
1:a52a206:         //get index property
1:2e3ed68:         Properties prop = new Properties ();
1:a52a206:         loadIndexProperties(lcc, cd, prop);
1:71c8e86:         ArrayList<ConstantAction> list = new ArrayList<ConstantAction>();
1:2e3ed68: 
1:2e3ed68:         // drop the existing index.
1:a52a206:         dropConglomerate(cd, td, false, list, activation, lcc);
1:2e3ed68: 
1:2e3ed68: 
1:a52a206:         String [] cols = cd.getColumnNames();
1:2e3ed68:         if (cols == null) 
1:2e3ed68:         {
1:2e3ed68:             //column list wasn't stored in conglomerateDescriptor
1:a52a206:             //fetch is from table descriptor
1:a52a206:             int [] pos = cd.getIndexDescriptor().baseColumnPositions();
1:2e3ed68:             cols       = new String [pos.length];
1:2e3ed68: 
1:2e3ed68:             for (int i = 0; i < cols.length; i++) 
1:2e3ed68:             {
1:2e3ed68:                 cols[i] = td.getColumnDescriptor(pos[i]).getColumnName();
1:a52a206:             }
1:a52a206:         }
1:a52a206:         
1:a52a206:         //create new index action
1:a52a206:         CreateIndexConstantAction action =
1:2e3ed68:                 new CreateIndexConstantAction(
1:2e3ed68:                         false,          // not part of create table 
1:2e3ed68:                         false,          // not unique
1:2e3ed68:                         true,           // create as unique when not null index
1:0c5bc3a:                         cd.getIndexDescriptor().hasDeferrableChecking(),
1:0c5bc3a:                         false,          // deferred or not: shouldn't matter
1:0c5bc3a:                                         // since we know we already have a
1:0c5bc3a:                                         // unique index
1:2db96c5:                         DataDictionary.UNIQUE_CONSTRAINT,
1:2e3ed68:                         cd.getIndexDescriptor().indexType(), 
1:2e3ed68:                         td.getSchemaName(), 
1:2e3ed68:                         cd.getConglomerateName(), td.getName(), td.getUUID(),
1:2e3ed68:                         cols, cd.getIndexDescriptor().isAscending(),
1:2e3ed68:                         true, cd.getUUID(), prop);
1:2e3ed68: 
1:a52a206:         //create index
1:a52a206:         action.executeConstantAction(activation);
1:a52a206:     }
1:eac0369: 
1:c92685e: 	/**
1:c92685e: 	 * Get any table properties that exist for the received
1:c92685e: 	 * index descriptor.
1:c92685e: 	 */
1:c92685e: 	private void loadIndexProperties(LanguageConnectionContext lcc,
1:c92685e: 		ConglomerateDescriptor congDesc, Properties ixProps)
1:c92685e: 		throws StandardException
1:c92685e: 	{
1:c92685e: 	   	ConglomerateController cc = 
1:c92685e: 		   	lcc.getTransactionExecute().openConglomerate(
1:c92685e: 			   	congDesc.getConglomerateNumber(),
1:c92685e: 			   	false,
1:c92685e: 			   	TransactionController.OPENMODE_FORUPDATE,
1:c92685e: 			   	TransactionController.MODE_TABLE,
1:c92685e: 			   	TransactionController.ISOLATION_SERIALIZABLE);
1:c92685e: 
1:c92685e: 		cc.getInternalTablePropertySet(ixProps);
1:c92685e: 		cc.close();
1:c92685e: 		return;
1:c92685e: 	}
1:c92685e: 
1:c92685e: 	/**
1:c92685e: 	 * Create a ConstantAction which, when executed, will create a
1:c92685e: 	 * new conglomerate whose attributes match those of the received
1:c92685e: 	 * ConglomerateDescriptor.
1:c92685e: 	 *
1:c92685e: 	 * @param srcCD Descriptor describing what the replacement
1:c92685e: 	 *   physical conglomerate should look like
1:c92685e: 	 * @param td Table descriptor for the table to which srcCD belongs
1:c92685e: 	 * @param properties Properties from the old (dropped) conglom
1:c92685e: 	 *  that should be "forwarded" to the new (replacement) conglom.
1:c92685e: 	 */
1:c92685e: 	ConstantAction getConglomReplacementAction(ConglomerateDescriptor srcCD,
1:c92685e: 		TableDescriptor td, Properties properties) throws StandardException
1:c92685e: 	{
1:c92685e: 		/* Re-use CreateIndexActionConstantAction to do the work
1:c92685e: 		 * of creating a new conglomerate.  The big difference
1:c92685e: 		 * between creating an _index_ and creating an index
1:c92685e: 		 * _conglomerate_ is that we don't need to create a new
1:c92685e: 		 * ConglomerateDescriptor in the latter case.  Use of the
1:c92685e: 		 * following constructor dictates that we want to create
1:c92685e: 		 * a _conglomerate_ only--i.e. that no new conglomerate
1:c92685e: 		 * descriptor is necessary.
1:c92685e: 		 */
1:c92685e: 		return new CreateIndexConstantAction(srcCD, td, properties);
1:c92685e: 	}
1:c92685e: 
1:c92685e: 	/**
1:c92685e: 	 * Execute the received ConstantAction, which will create a
1:c92685e: 	 * new physical conglomerate (or find an existing physical
1:c92685e: 	 * conglomerate that is "sharable") to replace some dropped
1:c92685e: 	 * physical conglomerate.  Then find any conglomerate descriptors
1:c92685e: 	 * which still reference the dropped physical conglomerate and
1:c92685e: 	 * update them all to have a conglomerate number that points
1:c92685e: 	 * to the conglomerate created by the ConstantAction.
1:c92685e: 	 *
1:c92685e: 	 * This method is called as part of DROP processing to handle
1:c92685e: 	 * cases where a physical conglomerate that was shared by
1:c92685e: 	 * multiple descriptors is dropped--in which case a new physical
1:c92685e: 	 * conglomerate must be created to support the remaining
1:c92685e: 	 * descriptors.
1:c92685e: 	 *
1:c92685e: 	 * @param replaceConglom Constant action which, when executed,
1:c92685e: 	 *  will either create a new conglomerate or find an existing
1:c92685e: 	 *  one that satisfies the ConstantAction's requirements.
1:c92685e: 	 * @param activation Activation used when creating the conglom
1:c92685e: 	 */
1:c92685e: 	void executeConglomReplacement(ConstantAction replaceConglom,
1:c92685e: 		Activation activation) throws StandardException
1:c92685e: 	{
1:c92685e: 		CreateIndexConstantAction replaceConglomAction =
1:c92685e: 			(CreateIndexConstantAction)replaceConglom;
1:c92685e: 
1:c92685e: 		LanguageConnectionContext lcc =
1:c92685e: 			activation.getLanguageConnectionContext();
1:c92685e: 
1:c92685e: 		DataDictionary dd = lcc.getDataDictionary();
1:c92685e: 
1:c92685e: 		// Create the new (replacment) backing conglomerate...
1:c92685e: 		replaceConglomAction.executeConstantAction(activation);
1:c92685e: 
1:c92685e: 		/* Find all conglomerate descriptors that referenced the
1:c92685e: 		 * old backing conglomerate and update them to have the
1:c92685e: 		 * conglomerate number for the new backing conglomerate.
1:c92685e: 		 */
1:c92685e: 		ConglomerateDescriptor [] congDescs =
1:c92685e: 			dd.getConglomerateDescriptors(
1:c92685e: 				replaceConglomAction.getReplacedConglomNumber());
1:c92685e: 
1:c92685e: 		if (SanityManager.DEBUG)
1:c92685e: 		{
1:c92685e: 			/* There should be at least one descriptor requiring
1:c92685e: 			 * an updated conglomerate number--namely, the one
1:c92685e: 			 * corresponding to "srcCD" for which the constant
1:c92685e: 			 * action was created (see getConglomReplacementAction()
1:c92685e: 			 * above). There may be others, as well.
1:c92685e: 			 */
1:c92685e: 			if (congDescs.length < 1)
1:c92685e: 			{
1:c92685e: 				SanityManager.THROWASSERT(
1:c92685e: 					"Should have found at least one conglomerate " +
1:c92685e: 					"descriptor that needs an updated conglomerate " +
1:c92685e: 					"number (due to a dropped index), but only " +
1:c92685e: 					"found " + congDescs.length);
1:c92685e: 			}
1:c92685e: 		}
1:c92685e: 
1:c92685e: 		dd.updateConglomerateDescriptor(congDescs,
1:c92685e: 			replaceConglomAction.getCreatedConglomNumber(),
1:c92685e: 			lcc.getTransactionExecute());
1:c92685e: 
1:c92685e: 		return;
1:c92685e: 	}
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2db96c5
/////////////////////////////////////////////////////////////////////////
1:                         DataDictionary.UNIQUE_CONSTRAINT,
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:                         cd.getIndexDescriptor().hasDeferrableChecking(),
1:                         false,          // deferred or not: shouldn't matter
1:                                         // since we know we already have a
1:                                         // unique index
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 			(List<ConstantAction>)null, activation, lcc, clearDeps);
/////////////////////////////////////////////////////////////////////////
1: 			(List<ConstantAction>)null, activation, lcc, clearDeps);
/////////////////////////////////////////////////////////////////////////
1: 		TableDescriptor skipCreate, List<ConstantAction> newConglomActions,
/////////////////////////////////////////////////////////////////////////
1: 			false, (List<ConstantAction>)null, activation, lcc);
/////////////////////////////////////////////////////////////////////////
1: 		boolean skipCreate, List<ConstantAction> newConglomActions,
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<ConstantAction> list = new ArrayList<ConstantAction>();
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:2e3ed68
/////////////////////////////////////////////////////////////////////////
1:      *
1:      *
1:      * @param cd            ConglomerateDescritor to recreate
1:      * @param td            TableDescriptor for table on which congDesc exists
1:      * @param activation    Activation used when creating a new backing index 
1:      *                      (if a new backing index is needed)
1:      * @param lcc           LanguageConnectionContext used for dropping
1:      *
1:     void recreateUniqueConstraintBackingIndexAsUniqueWhenNotNull(
1:     ConglomerateDescriptor      cd,
1:     TableDescriptor             td,
1:     Activation                  activation, 
1:     LanguageConnectionContext   lcc) 
1:         throws StandardException 
1:     {
1:         Properties prop = new Properties ();
1: 
1:         // drop the existing index.
1: 
1: 
1:         if (cols == null) 
1:         {
1:             //column list wasn't stored in conglomerateDescriptor
1:             cols       = new String [pos.length];
1: 
1:             for (int i = 0; i < cols.length; i++) 
1:             {
1:                 cols[i] = td.getColumnDescriptor(pos[i]).getColumnName();
1:                 new CreateIndexConstantAction(
1:                         false,          // not part of create table 
1:                         false,          // not unique
1:                         true,           // create as unique when not null index
1:                         cd.getIndexDescriptor().indexType(), 
1:                         td.getSchemaName(), 
1:                         cd.getConglomerateName(), td.getName(), td.getUUID(),
1:                         cols, cd.getIndexDescriptor().isAscending(),
1:                         true, cd.getUUID(), prop);
1: 
commit:a52a206
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Recreate backing index of unique constraint.
1:      * It first drops the existing index and creates it again with 
1:      * uniqueness set to false and uniqueWhenNotNull set to true. It reuses
1:      * the uuid so there is no need to update ConstraintDescriptor.
0:      * @param cd ConglomerateDescritor to recreate
1:      * @param td TableDescriptor for the table on which congDesc exists
1:      * @param activation Activation used when creating a new backing
1:      *  index (if a new backing index is needed)
1:      * @param lcc LanguageConnectionContext used for dropping
1:      * @throws StandardException
1:      */
0:     void recreateUniqueConstraintBackingIndex (
0:             ConglomerateDescriptor  cd,
0:             TableDescriptor td,
0:             Activation activation, 
0:             LanguageConnectionContext lcc) throws StandardException {
0:         Properties prop = new Properties ();
1:         //get index property
1:         loadIndexProperties(lcc, cd, prop);
0:         ArrayList list = new ArrayList();
1:         dropConglomerate(cd, td, false, list, activation, lcc);
1:         String [] cols = cd.getColumnNames();
0:         if (cols == null) {
0:             //column list wasn't stored in conglomerateDescritor
1:             //fetch is from table descriptor
1:             int [] pos = cd.getIndexDescriptor().baseColumnPositions();
0:             cols = new String [pos.length];
0:             for (int i = 0; i < cols.length; i++) {
0:                 cols [i] = td.getColumnDescriptor(pos [i]).getColumnName();
1:             }
1:         }
1:         
1:         //create new index action
1:         CreateIndexConstantAction action =
0:                 new CreateIndexConstantAction (false, false, true, 
0:                 cd.getIndexDescriptor().indexType(), td.getSchemaName(), 
0:                 cd.getConglomerateName(), td.getName(), td.getUUID(),
0:                 cols, cd.getIndexDescriptor().isAscending(),
0:                 true, cd.getUUID(), prop);
1:         //create index
1:         action.executeConstantAction(activation);
1:     }
author:Army
-------------------------------------------------------------------------------
commit:c92685e
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.KeyConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Drop the constraint corresponding to the received descriptor.
1: 	 * If in doing so we also drop a backing conglomerate that is
1: 	 * shared by other constraints/indexes, then we have to create
1: 	 * a new conglomerate to fill the gap.
1: 	 *
1: 	 * This method exists here as a "utility" method for the various
1: 	 * constant actions that may drop constraints in one way or
1: 	 * another (there are several that do).
1: 	 *
1: 	 * @param consDesc ConstraintDescriptor for the constraint to drop
1: 	 * @param activation Activation used when creating a new backing
1: 	 *  index (if a new backing index is needed)
1: 	 * @param lcc LanguageConnectionContext used for dropping
1: 	 * @param clearDeps Whether or not to clear dependencies when
1: 	 *   dropping the constraint
1: 	 */
1: 	void dropConstraint(ConstraintDescriptor consDesc,
1: 		Activation activation, LanguageConnectionContext lcc,
1: 		boolean clearDeps) throws StandardException
1: 	{
1: 		dropConstraint(consDesc, (TableDescriptor)null,
0: 			(List)null, activation, lcc, clearDeps);
1: 	}
1: 
1: 	/**
1: 	 * See "dropConstraint(...") above.
1: 	 *
1: 	 * @param skipCreate Optional TableDescriptor.  If non-null
1: 	 *  then we will skip the "create new conglomerate" processing
1: 	 *  *IF* the constraint that we drop came from the table
1: 	 *  described by skipCreate.
1: 	 */
1: 	void dropConstraint(ConstraintDescriptor consDesc,
1: 		TableDescriptor skipCreate, Activation activation,
1: 		LanguageConnectionContext lcc, boolean clearDeps)
1: 		throws StandardException
1: 	{
1: 		dropConstraint(consDesc, skipCreate,
0: 			(List)null, activation, lcc, clearDeps);
1: 	}
1: 
1: 	/**
1: 	 * See "dropConstraint(...") above.
1: 	 *
1: 	 * @param newConglomActions Optional List.  If non-null then
1: 	 *  for each ConglomerateDescriptor for which we skip the
1: 	 *  "create new conglomerate" processing we will add a
1: 	 *  ConstantAction to this list.  The constant action can
1: 	 *  then be executed later (esp. by the caller) to create the
1: 	 *  new conglomerate, if needed.  If this argument is null and
1: 	 *  we skip creation of a new conglomerate, the new conglomerate
1: 	 *  is effectively ignored (which may be fine in some cases--
1: 	 *  ex. when dropping a table).
1: 	 */
1: 	void dropConstraint(ConstraintDescriptor consDesc,
0: 		TableDescriptor skipCreate, List newConglomActions,
1: 		Activation activation, LanguageConnectionContext lcc,
1: 		boolean clearDeps) throws StandardException
1: 	{
1: 		/* Get the properties on the old backing conglomerate before
1: 		 * dropping the constraint, since we can't get them later if
1: 		 * dropping the constraint causes us to drop the backing
1: 		 * conglomerate.
1: 		 */
1: 		Properties ixProps = null;
1: 		if (consDesc instanceof KeyConstraintDescriptor)
1: 		{
1: 			ixProps = new Properties();
1: 			loadIndexProperties(lcc,
1: 				((KeyConstraintDescriptor)consDesc)
1: 					.getIndexConglomerateDescriptor(lcc.getDataDictionary()),
1: 				ixProps);
1: 		}
1: 
1: 		ConglomerateDescriptor newBackingConglomCD = consDesc.drop(lcc, clearDeps);
1: 
1: 		/* If we don't need a new conglomerate then there's nothing
1: 		 * else to do.
1: 		 */
1: 		if (newBackingConglomCD == null)
1: 			return;
1: 
1: 		/* Only create the new conglomerate if it is NOT for the table
1: 		 * described by skipCreate.
1: 		 */
1: 		if ((skipCreate != null) &&
1: 			skipCreate.getUUID().equals(
1: 				consDesc.getTableDescriptor().getUUID()))
1: 		{
1: 			/* We're skipping the "create new conglom" phase; if we have
1: 			 * a list in which to store the ConstantAction, then store it;
1: 			 * otherwise, the new conglomerate is effectively ignored.
1: 			 */
1: 			if (newConglomActions != null)
1: 			{
1: 				newConglomActions.add(
1: 					getConglomReplacementAction(newBackingConglomCD,
1: 						consDesc.getTableDescriptor(), ixProps));
1: 			}
1: 		}
1: 		else
1: 		{
1: 			executeConglomReplacement(
1: 				getConglomReplacementAction(newBackingConglomCD,
1: 					consDesc.getTableDescriptor(), ixProps),
1: 				activation);
1: 		}
1: 
1: 		return;
1: 	}
1: 
1: 	/**
1: 	 * Similar to dropConstraint(...) above, except this method
1: 	 * drops a conglomerate directly instead of going through
1: 	 * a ConstraintDescriptor.
1: 	 *
1: 	 * @param congDesc ConglomerateDescriptor for the conglom to drop
0: 	 * @param td TableDescriptor for the table on which congDesc exists
1: 	 * @param activation Activation used when creating a new backing
1: 	 *  index (if a new backing index is needed)
1: 	 * @param lcc LanguageConnectionContext used for dropping
1: 	 */
1: 	void dropConglomerate(
1: 		ConglomerateDescriptor congDesc, TableDescriptor td,
1: 		Activation activation, LanguageConnectionContext lcc)
1: 		throws StandardException
1: 	{
1: 		dropConglomerate(congDesc, td,
0: 			false, (List)null, activation, lcc);
1: 	}
1: 
1: 	/**
1: 	 * See "dropConglomerate(...)" above.
1: 	 *	
1: 	 * @param skipCreate If true then we will skip the "create
1: 	 *  new conglomerate" processing for the dropped conglom.
1: 	 * @param newConglomActions Optional List.  If non-null then
1: 	 *  for each ConglomerateDescriptor for which we skip the
1: 	 *  "create new conglomerate" processing we will add a
1: 	 *  ConstantAction to this list.  The constant action can
1: 	 *  then be executed later (esp. by the caller) to create the
1: 	 *  new conglomerate, if needed.  If this argument is null and
1: 	 *  we skip creation of a new conglomerate, the new conglomerate
1: 	 *  is effectively ignored (which may be fine in some cases--
1: 	 *  ex. when dropping a table).
1: 	 */
1: 	void dropConglomerate(
1: 		ConglomerateDescriptor congDesc, TableDescriptor td,
0: 		boolean skipCreate, List newConglomActions,
1: 		Activation activation, LanguageConnectionContext lcc)
1: 		throws StandardException
1: 	{
1: 		// Get the properties on the old index before dropping.
1: 		Properties ixProps = new Properties();
1: 		loadIndexProperties(lcc, congDesc, ixProps);
1: 
1: 		// Drop the conglomerate.
1: 		ConglomerateDescriptor newBackingConglomCD = congDesc.drop(lcc, td);
1: 
1: 		/* If we don't need a new conglomerate then there's nothing
1: 		 * else to do.
1: 		 */
1: 		if (newBackingConglomCD == null)
1: 			return;
1: 
1: 		if (skipCreate)
1: 		{
1: 			/* We're skipping the "create new conglom" phase; if we have
1: 			 * a list in which to store the ConstantAction, then store it;
1: 			 * otherwise, the new conglomerate is effectively ignored.
1: 			 */
1: 			if (newConglomActions != null)
1: 			{
1: 				newConglomActions.add(
1: 					getConglomReplacementAction(
1: 						newBackingConglomCD, td, ixProps));
1: 			}
1: 		}
1: 		else
1: 		{
1: 			executeConglomReplacement(
1: 				getConglomReplacementAction(newBackingConglomCD, td, ixProps),
1: 				activation);
1: 		}
1: 
1: 		return;
1: 	}
1: 
1: 	/**
1: 	 * Get any table properties that exist for the received
1: 	 * index descriptor.
1: 	 */
1: 	private void loadIndexProperties(LanguageConnectionContext lcc,
1: 		ConglomerateDescriptor congDesc, Properties ixProps)
1: 		throws StandardException
1: 	{
1: 	   	ConglomerateController cc = 
1: 		   	lcc.getTransactionExecute().openConglomerate(
1: 			   	congDesc.getConglomerateNumber(),
1: 			   	false,
1: 			   	TransactionController.OPENMODE_FORUPDATE,
1: 			   	TransactionController.MODE_TABLE,
1: 			   	TransactionController.ISOLATION_SERIALIZABLE);
1: 
1: 		cc.getInternalTablePropertySet(ixProps);
1: 		cc.close();
1: 		return;
1: 	}
1: 
1: 	/**
1: 	 * Create a ConstantAction which, when executed, will create a
1: 	 * new conglomerate whose attributes match those of the received
1: 	 * ConglomerateDescriptor.
1: 	 *
1: 	 * @param srcCD Descriptor describing what the replacement
1: 	 *   physical conglomerate should look like
1: 	 * @param td Table descriptor for the table to which srcCD belongs
1: 	 * @param properties Properties from the old (dropped) conglom
1: 	 *  that should be "forwarded" to the new (replacement) conglom.
1: 	 */
1: 	ConstantAction getConglomReplacementAction(ConglomerateDescriptor srcCD,
1: 		TableDescriptor td, Properties properties) throws StandardException
1: 	{
1: 		/* Re-use CreateIndexActionConstantAction to do the work
1: 		 * of creating a new conglomerate.  The big difference
1: 		 * between creating an _index_ and creating an index
1: 		 * _conglomerate_ is that we don't need to create a new
1: 		 * ConglomerateDescriptor in the latter case.  Use of the
1: 		 * following constructor dictates that we want to create
1: 		 * a _conglomerate_ only--i.e. that no new conglomerate
1: 		 * descriptor is necessary.
1: 		 */
1: 		return new CreateIndexConstantAction(srcCD, td, properties);
1: 	}
1: 
1: 	/**
1: 	 * Execute the received ConstantAction, which will create a
1: 	 * new physical conglomerate (or find an existing physical
1: 	 * conglomerate that is "sharable") to replace some dropped
1: 	 * physical conglomerate.  Then find any conglomerate descriptors
1: 	 * which still reference the dropped physical conglomerate and
1: 	 * update them all to have a conglomerate number that points
1: 	 * to the conglomerate created by the ConstantAction.
1: 	 *
1: 	 * This method is called as part of DROP processing to handle
1: 	 * cases where a physical conglomerate that was shared by
1: 	 * multiple descriptors is dropped--in which case a new physical
1: 	 * conglomerate must be created to support the remaining
1: 	 * descriptors.
1: 	 *
1: 	 * @param replaceConglom Constant action which, when executed,
1: 	 *  will either create a new conglomerate or find an existing
1: 	 *  one that satisfies the ConstantAction's requirements.
1: 	 * @param activation Activation used when creating the conglom
1: 	 */
1: 	void executeConglomReplacement(ConstantAction replaceConglom,
1: 		Activation activation) throws StandardException
1: 	{
1: 		CreateIndexConstantAction replaceConglomAction =
1: 			(CreateIndexConstantAction)replaceConglom;
1: 
1: 		LanguageConnectionContext lcc =
1: 			activation.getLanguageConnectionContext();
1: 
1: 		DataDictionary dd = lcc.getDataDictionary();
1: 
1: 		// Create the new (replacment) backing conglomerate...
1: 		replaceConglomAction.executeConstantAction(activation);
1: 
1: 		/* Find all conglomerate descriptors that referenced the
1: 		 * old backing conglomerate and update them to have the
1: 		 * conglomerate number for the new backing conglomerate.
1: 		 */
1: 		ConglomerateDescriptor [] congDescs =
1: 			dd.getConglomerateDescriptors(
1: 				replaceConglomAction.getReplacedConglomNumber());
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			/* There should be at least one descriptor requiring
1: 			 * an updated conglomerate number--namely, the one
1: 			 * corresponding to "srcCD" for which the constant
1: 			 * action was created (see getConglomReplacementAction()
1: 			 * above). There may be others, as well.
1: 			 */
1: 			if (congDescs.length < 1)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"Should have found at least one conglomerate " +
1: 					"descriptor that needs an updated conglomerate " +
1: 					"number (due to a dropped index), but only " +
1: 					"found " + congDescs.length);
1: 			}
1: 		}
1: 
1: 		dd.updateConglomerateDescriptor(congDescs,
1: 			replaceConglomAction.getCreatedConglomNumber(),
1: 			lcc.getTransactionExecute());
1: 
1: 		return;
1: 	}
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9cd47dc
/////////////////////////////////////////////////////////////////////////
1: 	DDLSingleTableConstantAction(UUID tableId)
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.DDLSingleTableConstantAction
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
1: /**
1:  * Abstract class that has actions that are across
1:  * all DDL actions that are tied to a table.  An example
1:  * of DDL that affects a table is CREATE INDEX or
1:  * DROP VIEW.  An example of DDL that does not affect
1:  * a table is CREATE STATEMENT or DROP SCHEMA.
1:  *
0:  * @author jamie
1:  */
1: abstract class DDLSingleTableConstantAction extends DDLConstantAction 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	protected UUID					tableId;
1: 
1: 	
1: 	/**
1: 	 * constructor
1: 	 *
1: 	 * @param tableId the target table
1: 	 */
0: 	protected DDLSingleTableConstantAction(UUID tableId)
1: 	{
1: 		super();
1: 		this.tableId = tableId;
1: 	}
1: 
1: 	/**
0: 	 * Does this constant action modify the passed in table
0: 	 * uuid?  By modify we mean add or drop things tied to
0: 	 * this table (e.g. index, trigger, constraint).  Things
0: 	 * like views or spses that reference this table don't
0: 	 * count.
1: 	 *
0: 	 * @param tableId the table id
1: 	 */
0: 	public boolean modifiesTableId(UUID tableId)
1: 	{
0: 		return (this.tableId == null) ?
0: 			false :
0: 			this.tableId.equals(tableId);
1: 	}
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: /**
0:  * Abstract class that has actions that are across
0:  * all DDL actions that are tied to a table.  An example
0:  * of DDL that affects a table is CREATE INDEX or
0:  * DROP VIEW.  An example of DDL that does not affect
0:  * a table is CREATE STATEMENT or DROP SCHEMA.
0:  *
0:  * @author jamie
0:  */
0: abstract class DDLSingleTableConstantAction extends DDLConstantAction 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	protected UUID					tableId;
0: 
0: 	
0: 	/**
0: 	 * constructor
0: 	 *
0: 	 * @param tableId the target table
0: 	 */
0: 	protected DDLSingleTableConstantAction(UUID tableId)
0: 	{
0: 		super();
0: 		this.tableId = tableId;
0: 	}
0: 
0: 	/**
0: 	 * Does this constant action modify the passed in table
0: 	 * uuid?  By modify we mean add or drop things tied to
0: 	 * this table (e.g. index, trigger, constraint).  Things
0: 	 * like views or spses that reference this table don't
0: 	 * count.
0: 	 *
0: 	 * @param tableId the table id
0: 	 */
0: 	public boolean modifiesTableId(UUID tableId)
0: 	{
0: 		return (this.tableId == null) ?
0: 			false :
0: 			this.tableId.equals(tableId);
0: 	}
0: }
============================================================================