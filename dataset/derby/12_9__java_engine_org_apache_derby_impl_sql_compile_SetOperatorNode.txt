1:47f9d0a: /*
35:47f9d0a: 
1:47f9d0a:    Derby - Class org.apache.derby.impl.sql.compile.SetOperatorNode
1:47f9d0a: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:47f9d0a: 
1:47f9d0a:       http://www.apache.org/licenses/LICENSE-2.0
1:47f9d0a: 
1:47f9d0a:    Unless required by applicable law or agreed to in writing, software
1:47f9d0a:    distributed under the License is distributed on an "AS IS" BASIS,
1:47f9d0a:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:47f9d0a:    See the License for the specific language governing permissions and
1:47f9d0a:    limitations under the License.
1:47f9d0a: 
8:47f9d0a:  */
1:5872305: 
1:47f9d0a: package	org.apache.derby.impl.sql.compile;
1:47f9d0a: 
1:3bb140c: import java.util.HashMap;
1:3bb140c: import java.util.Properties;
1:47f9d0a: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:5872305: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:5872305: import org.apache.derby.iapi.sql.compile.Optimizable;
1:5872305: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1:5872305: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
1:47f9d0a: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:47f9d0a: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:47f9d0a: import org.apache.derby.iapi.util.JBitSet;
1:5872305: 
1:5872305: /**
1:47f9d0a:  * A SetOperatorNode represents a UNION, INTERSECT, or EXCEPT in a DML statement. Binding and optimization
1:47f9d0a:  * preprocessing is the same for all of these operations, so they share bind methods in this abstract class.
11:47f9d0a:  *
1:47f9d0a:  * The class contains a boolean telling whether the operation should eliminate
1:47f9d0a:  * duplicate rows.
1:47f9d0a:  *
1:47f9d0a:  */
1:47f9d0a: 
1:03eae1d: abstract class SetOperatorNode extends TableOperatorNode
12:47f9d0a: {
1:5872305: 	/**
1:47f9d0a: 	** Tells whether to eliminate duplicate rows.  all == TRUE means do
1:47f9d0a: 	** not eliminate duplicates, all == FALSE means eliminate duplicates.
1:47f9d0a: 	*/
1:47f9d0a: 	boolean			all;
1:4d044a3: 
1:b4cda60:     QueryExpressionClauses qec = new QueryExpressionClauses();
1:47f9d0a: 
1:5872305: 	// List of scoped predicates for pushing during optimization.
1:03eae1d: 	private PredicateList leftOptPredicates;
1:03eae1d: 	private PredicateList rightOptPredicates;
1:5872305: 
1:5872305: 	// List of original (unscoped) predicates that we tried to push
1:5872305: 	// during the most recent phase of optimization.
1:03eae1d: 	private PredicateList pushedPredicates;
1:5872305: 
1:5872305: 	// Mapping of original predicates to scoped predicates, used to
1:5872305: 	// avoid re-scoping predicates unnecessarily.
1:71c8e86: 	private HashMap<Predicate,Predicate> leftScopedPreds;
1:71c8e86: 	private HashMap<Predicate,Predicate> rightScopedPreds;
1:47f9d0a: 
1:4d044a3: 	/**
1:3bb140c:      * Constructor for a SetOperatorNode.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param leftResult		The ResultSetNode on the left side of this union
1:47f9d0a: 	 * @param rightResult		The ResultSetNode on the right side of this union
1:47f9d0a: 	 * @param all				Whether or not this is an ALL.
1:47f9d0a: 	 * @param tableProperties	Properties list associated with the table
1:3bb140c:      * @param cm                The context manager
1:47f9d0a: 	 *
2:47f9d0a: 	 * @exception StandardException		Thrown on error
1:4d044a3: 	 */
1:3bb140c:     SetOperatorNode(ResultSetNode leftResult,
1:3bb140c:                     ResultSetNode rightResult,
1:3bb140c:                     boolean all,
1:3bb140c:                     Properties tableProperties,
1:3bb140c:                     ContextManager cm) throws StandardException {
1:3bb140c:         super(leftResult, rightResult, tableProperties, cm);
1:3bb140c:         this.all = all;
1:5872305: 
1:47f9d0a: 		/* resultColumns cannot be null, so we make a copy of the left RCL
1:47f9d0a: 		 * for now.  At bind() time, we need to recopy the list because there
1:47f9d0a: 		 * may have been a "*" in the list.  (We will set the names and
1:47f9d0a: 		 * column types at that time, as expected.)
1:5872305: 		 */
1:11f7ee3: 		setResultColumns( leftResultSet.getResultColumns().copyListAndObjects() );
1:4d044a3: 	}
1:c9a1206: 
1:108305b: 	/**
1:5872305: 	 * @see Optimizable#modifyAccessPath
1:5872305: 	 *
1:5872305: 	 * @exception StandardException		Thrown on error
1:5872305: 	 */
1:5872305: 	public Optimizable modifyAccessPath(JBitSet outerTables,
1:5872305: 		PredicateList predList) throws StandardException
1:5872305: 	{
1:5872305: 		// When we optimized this node we attempted to push predicates down to
1:5872305: 		// the children, which means the best access path for the children
1:5872305: 		// might depend on those predicates.  So now that we're preparing
1:5872305: 		// to generate the best paths, we have to push those same predicates
1:5872305: 		// down again (this is the last time) so that the children can use
1:e07631a: 		// them as appropriate. NOTE: If our final choice for join strategy
1:e07631a: 		// is a hash join, then we do not push the predicates because we'll
1:e07631a: 		// need them to be at this level in order to find out which of them
1:e07631a: 		// is the equijoin predicate that is required by hash join.
1:e07631a: 		if ((predList != null) &&
1:e07631a: 			!getTrulyTheBestAccessPath().getJoinStrategy().isHashJoin())
1:5872305: 		{
1:5872305: 			for (int i = predList.size() - 1; i >= 0; i--)
1:5872305: 				if (pushOptPredicate(predList.getOptPredicate(i)))
1:5872305: 					predList.removeOptPredicate(i);
1:108305b: 		}
1:5872305: 
1:5872305: 		/*
1:5872305: 		 * It's possible that we tried to push a predicate down to this node's
1:5872305: 		 * children but failed to do so.  This can happen if this node's
1:5872305: 		 * children both match the criteria for pushing a predicate (namely,
1:5872305: 		 * they reference base tables) but the children's children do not.
1:5872305: 		 * Ex.
1:5872305: 		 *  select * from
1:5872305: 		 *    (select i,j from t2 UNION
1:5872305: 		 *      values (1,1),(2,2),(3,3),(4,4) UNION
1:5872305: 		 *      select i,j from t1
1:5872305: 		 *    ) x0 (i,j),
1:5872305: 		 *    t5 where x0.i = t5.i;
1:5872305: 		 *
1:5872305: 		 * This will yield a tree resembling the following:
1:5872305: 		 *
1:5872305: 		 *                     UNION
1:5872305: 		 *                    /     \
1:5872305: 		 *               UNION     SELECT (T1)
1:5872305: 		 *              /     \
1:5872305: 		 *        SELECT (T2)  VALUES
1:5872305: 		 *
1:5872305: 		 * In this case the top UNION ("this") will push the predicate down,
1:5872305: 		 * but the second UNION will _not_ push the predicate because
1:5872305: 		 * it can't be pushed to the VALUES clause.  This means that
1:5872305: 		 * after we're done modifying the paths for "this" node (the top
1:5872305: 		 * UNION), the predicate will still be sitting in our leftOptPredicates
1:5872305: 		 * list.  If that's the case, then we have to make sure the predicate,
1:5872305: 		 * which was _not_ enforced in the left child, is enforced at this
1:5872305: 		 * level.  We do that by generating a ProjectRestrictNode above this
1:5872305: 		 * node.  Yes, this means the predicate will actually be applied
1:5872305: 		 * twice to the right child (in this case), but that's okay as it
1:5872305: 		 * won't affect the results.
1:5872305: 		 */
1:5872305: 
1:5872305: 		// Get the cost estimate for this node so that we can put it in
1:5872305: 		// the new ProjectRestrictNode, if one is needed.
1:5872305: 		CostEstimate ce = getFinalCostEstimate();
1:5872305: 
1:5872305: 		// Modify this node's access paths.
1:5872305: 		ResultSetNode topNode = (ResultSetNode)modifyAccessPath(outerTables);
1:5872305: 
1:cafb31f: 		/* Now see if there are any left over predicates; if so, then we
1:0f0f8ad: 		 * have to generate a ProjectRestrictNode.  Note: we want to check
1:0f0f8ad: 		 * all SetOpNodes that exist in the subtree rooted at this SetOpNode.
1:0f0f8ad: 		 * Since we just modified access paths on this node, it's possible
1:0f0f8ad: 		 * that the SetOperatorNode chain (if there was one) is now "broken"
1:0f0f8ad: 		 * as a result of the insertion of new nodes.  For example, prior
1:0f0f8ad: 		 * to modification of access paths we may have a chain such as:
1:0f0f8ad: 		 *
1:0f0f8ad: 		 *                          UnionNode (0)
1:0f0f8ad: 		 *                          /       \
1:0f0f8ad: 		 *                 UnionNode (1)    SelectNode (2)
1:0f0f8ad: 		 *                 /        \ 
1:0f0f8ad: 		 *      SelectNode (3)     SelectNode (4)
1:0f0f8ad: 		 *
1:0f0f8ad: 		 * Now if UnionNode(1) did not specify "ALL" then as part of the
1:0f0f8ad: 		 * above call to modifyAccessPaths() we will have inserted a
1:0f0f8ad: 		 * DistinctNode above it, thus giving:
1:0f0f8ad: 		 *
1:0f0f8ad: 		 *                          UnionNode (0)
1:0f0f8ad: 		 *                          /       \
1:0f0f8ad: 		 *                 DistinctNode (5)  SelectNode (2)
1:0f0f8ad: 		 *                      |
1:0f0f8ad: 		 *                 UnionNode (1)
1:0f0f8ad: 		 *                 /        \ 
1:0f0f8ad: 		 *      SelectNode (3)     SelectNode (4)
1:0f0f8ad: 		 *
1:0f0f8ad: 		 * So our chain of UnionNode's has now been "broken" by an intervening
1:0f0f8ad: 		 * DistinctNode.  For this reason we can't just walk the chain of
1:0f0f8ad: 		 * SetOperatorNodes looking for unpushed predicates (because the
1:0f0f8ad: 		 * chain might be broken and then we could miss some nodes). Instead,
1:0f0f8ad: 		 * we have to get a collection of all relevant nodes that exist beneath
1:0f0f8ad: 		 * this SetOpNode and call hasUnPushedPredicates() on each one.  For
1:0f0f8ad: 		 * now we only consider UnionNodes to be "relevant" because those are
1:0f0f8ad: 		 * the only ones that might actually have unpushed predicates.
1:0f0f8ad: 		 * 
1:0f0f8ad: 		 * If we find any UnionNodes that *do* have unpushed predicates then
1:0f0f8ad: 		 * we have to use a PRN to enforce the predicate at the level of
1:0f0f8ad: 		 * this, the top-most, SetOperatorNode.
1:cafb31f: 		 */
1:0f0f8ad: 
1:0f0f8ad: 		// Find all UnionNodes in the subtree.
1:a6d25cd:         CollectNodesVisitor<UnionNode> cnv =
1:a6d25cd:                 new CollectNodesVisitor<UnionNode>(UnionNode.class);
1:0f0f8ad: 		this.accept(cnv);
1:0f0f8ad: 
1:0f0f8ad: 		// Now see if any of them have unpushed predicates.
1:0f0f8ad: 		boolean genPRN = false;
1:a6d25cd:         for (UnionNode node : cnv.getList())
1:0f0f8ad: 		{
1:a6d25cd:             if (node.hasUnPushedPredicates())
1:0f0f8ad: 			{
1:0f0f8ad: 				genPRN = true;
1:0f0f8ad: 				break;
1:0f0f8ad: 			}
1:0f0f8ad: 		}
1:0f0f8ad: 
1:0f0f8ad: 		if (genPRN)
1:5872305: 		{
1:5872305: 			// When we generate the project restrict node, we pass in the
1:5872305: 			// "pushedPredicates" list because that has the predicates in
1:5872305: 			// _unscoped_ form, which means they are intended for _this_
1:5872305: 			// node instead of this node's children.  That's exactly what
1:5872305: 			// we want.
1:3bb140c:             ResultSetNode prnRSN = new ProjectRestrictNode(
1:5872305: 				topNode,					// Child ResultSet
1:5872305: 				topNode.getResultColumns(),	// Projection
1:5872305: 				null,						// Restriction
1:5872305: 				pushedPredicates,			// Restriction as PredicateList
1:5872305: 				null,						// Subquerys in Projection
1:5872305: 				null,						// Subquerys in Restriction
1:5872305: 				null,						// Table properties
3:0787955: 				getContextManager());
1:11f7ee3: 			prnRSN.setCostEstimate( ce.cloneMe() );
1:5872305: 			prnRSN.setReferencedTableMap(topNode.getReferencedTableMap());
1:5872305: 			topNode = prnRSN;
1:5872305: 		}
1:5872305: 
1:5872305: 		return (Optimizable)topNode;
1:5872305: 	}
1:5872305: 
1:c341dc4: 	/**
1:5872305: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#pushOptPredicate
1:5872305: 	 *
1:5872305: 	 * Take a predicate and push it down to both the left AND right result
1:5872305: 	 * sets.  Return "true" if we successfully pushed it to both sides,
1:5872305: 	 * and "false" otherwise.  The assumption is that if we return "true",
1:5872305: 	 * the caller will take the predicate and remove it from its own list
1:5872305: 	 * of predicates to evaluate; if we return false, then the predicate
1:5872305: 	 * will be evaluated at the level of the caller.  So returning "false"
1:5872305: 	 * means that the left and right result sets for this node will be fully
1:5872305: 	 * returned, and then the predicate will be evaluated against the
1:5872305: 	 * <set-operator> of those result sets (as of DERBY-805, the only set
1:5872305: 	 * operator calling this method is UnionNode).  If we can push the
1:5872305: 	 * predicate down to both children, though, we can evaluate it closer
1:5872305: 	 * to store, which means that each child result set returns only the
1:5872305: 	 * correctly qualified rows, and thus the calling set operator will
1:5872305: 	 * have a smaller result set on which to operate, which can boost
1:5872305: 	 * performance.
1:5872305: 	 *
1:5872305: 	 * That said, if we can't push the predicate to _both_ sides, we don't
1:5872305: 	 * push it at all.  The reason is that if we push to one side but not
1:5872305: 	 * to the other, we would have to ask the question of whether we should
1:5872305: 	 * return "true" (meaning that the predicate would be removed from the
1:5872305: 	 * caller's list and thus would _not_ be evaluated at the <set-operator>
1:5872305: 	 * level) or "false" (meaning that the caller would keep the predicate
1:5872305: 	 * and evaluate it at the <set-operator> level).  Depending on the query
1:5872305: 	 * in question, both answers could end up returning incorrect results.
1:5872305: 	 *
1:5872305: 	 * For example, if we push it to the right but not to the left, then
1:5872305: 	 * leave it in the caller's list, the optimizer for the caller might
1:5872305: 	 * decide to use the predicate to do a hash join with some outer result
1:5872305: 	 * set (if the predicate is an equijoin predicate).  That would result
1:5872305: 	 * in materialization of the calling node and of its children--but since
1:5872305: 	 * we pushed a predicate that depends on the outer table down into the
1:5872305: 	 * right child, materialization of the right child will only return the
1:5872305: 	 * rows that join with the _first_ row of the outer result set, which 
1:5872305: 	 * is wrong.
1:5872305: 	 *
1:5872305: 	 * If, on the other hand, we push the predicate to one side and then tell
1:5872305: 	 * the caller to remove it from its list, the side to which we did _not_
1:5872305: 	 * push the predicate could return rows that aren't qualified.  Then,
1:5872305: 	 * since the caller removed the predicate from its list, it (the caller)
1:5872305: 	 * will not evaluate the predicate on its own result set--and thus we
1:5872305: 	 * can end up returning rows that we weren't supposed to return.
1:5872305: 	 * 
1:5872305: 	 * So all of that said, only push (and return "true") if we think we
1:5872305: 	 * can push the predicate to both sides.
1:5872305: 	 *
1:5872305: 	 * @exception StandardException		Thrown on error
1:5872305: 	 */
1:3bb140c:     @Override
1:5872305: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1:5872305: 		throws StandardException
1:5872305: 	{
1:5872305: 		// This method was added to SetOperatorNode as part of DERBY-805,
1:5872305: 		// which was only targeted for UnionNodes.  So for now, we don't
1:5872305: 		// do anything if "this" isn't a Union.  This check can be removed
1:5872305: 		// when support for other SetOperators is added.
1:5872305: 		if (!(this instanceof UnionNode))
1:5872305: 			return false;
1:5872305: 
1:5872305: 		// We only handle certain types of predicates here; if the received
1:5872305: 		// predicate doesn't qualify, then don't push it.
1:5872305: 		Predicate pred = (Predicate)optimizablePredicate;
1:5872305: 		if (!pred.pushableToSubqueries())
1:5872305: 			return false;
1:5872305: 
1:5872305: 		// Check to see if the child nodes reference any base tables; if either
1:5872305: 		// child does not reference at least one base table, then we don't try
1:5872305: 		// to push the predicate.
1:5872305: 		JBitSet tableNums = new JBitSet(getReferencedTableMap().size());
1:5872305: 		BaseTableNumbersVisitor btnVis =
1:5872305: 			new BaseTableNumbersVisitor(tableNums);
1:5872305: 
1:5872305: 		// Check the left child.
1:5872305: 		leftResultSet.accept(btnVis);
1:3bb140c: 
1:3bb140c:         boolean canPush = (tableNums.getFirstSetBit() != -1);
1:5872305: 
1:5872305: 		/* If we can't push it to _both_ children, then we don't push at all.
1:5872305: 		 * RESOLVE: We can add the ability to push a predicate to one side
1:5872305: 		 * only by putting a ProjectRestrictNode between the union node and
1:5872305: 		 * the child as a place to park the predicate. To make things simple,
1:5872305: 		 * we might want to always put ProjectRestrictNodes under both sides
1:5872305: 		 * of the union during preprocessing (i.e. after binding but before
1:5872305: 		 * optimization). In some cases the extra nodes won't be needed, but
1:5872305: 		 * PRNs (and the corresponding ProjectRestrictResultSets) are cheap.
1:5872305: 		 * Also, we could eliminate unnecessary ProjectRestrictNodes at the
1:5872305: 		 * end of optimization (possibly in modifyAccessPaths()).  Until all
1:5872305: 		 * of that is implemented, though, we only push if we can push to
1:5872305: 		 * both sides...
1:5872305: 		 */
1:5872305: 		if (!canPush)
1:5872305: 			return false;
1:5872305: 
1:5872305: 		// Check the right child.
1:5872305: 		tableNums.clearAll();
1:5872305: 		rightResultSet.accept(btnVis);
2:5872305: 		canPush = (tableNums.getFirstSetBit() != -1);
1:5872305: 		if (!canPush)
1:5872305: 			return false;
1:5872305: 
1:5872305: 		// Get a list of all of the underlying base tables that this node
1:5872305: 		// references.  We pass this down when scoping so that we can tell
1:5872305: 		// if the operands are actually supposed to be scoped to _this_
1:5872305: 		// node's children.  Note that in order for the predicate to
1:5872305: 		// have been pushed this far, at least one of its operands must
1:5872305: 		// apply to this node--we don't know which one it is, though,
1:5872305: 		// so we use this tableNums info to figure that out.
1:5872305: 		tableNums.clearAll();
1:5872305: 		this.accept(btnVis);
1:5872305: 
1:5872305: 		/* What we want to do here is push the predicate to the left/right
1:5872305: 		 * child.  That means that we need to find the equivalent column(s)
1:5872305: 		 * in each child.
1:5872305: 		 * Ex:
1:5872305: 		 * 
1:5872305: 		 *  select * from
1:5872305: 		 *    (select i,j from t1 union select i,j from t2) X1,
1:5872305: 		 *    (select a,b from t3 union select a,b from t4) X2
1:5872305: 		 *  where X1.j = X2.b;
1:5872305: 		 *
1:5872305: 		 * In this example, X1.j maps to "t1" for the left side of the
1:5872305: 		 * union (X1) and "t2" for the right side of the union.  So we have
1:5872305: 		 * to get versions of the predicate that are appropriate to each
1:5872305: 		 * side.  That's what the call to getPredScopedForResultSet()
1:5872305: 		 * in the following code does.
1:5872305: 		 */
1:5872305: 
1:df88f63: 		// For details on how this whichRC variable is used, see the
1:df88f63: 		// comments in BinaryRelationalOperatorNode.getScopedOperand().
1:df88f63: 		int [] whichRC = new int[] { -1 };
1:df88f63: 
1:5872305: 		// See if we already have a scoped version of the predicate cached,
1:5872305: 		// and if so just use that.
1:5872305: 		Predicate scopedPred = null;
1:5872305: 		if (leftScopedPreds == null)
1:71c8e86: 			leftScopedPreds = new HashMap<Predicate,Predicate>();
1:5872305: 		else
1:71c8e86: 			scopedPred = leftScopedPreds.get(pred);
1:5872305: 		if (scopedPred == null)
1:5872305: 		{
1:5872305: 			scopedPred = pred.getPredScopedForResultSet(
1:df88f63: 				tableNums, leftResultSet, whichRC);
1:5872305: 			leftScopedPreds.put(pred, scopedPred);
1:5872305: 		}
1:5872305: 
1:5872305: 		// Add the scoped predicate to our list for the left child.
1:5872305: 		getLeftOptPredicateList().addOptPredicate(scopedPred);
1:5872305: 
1:5872305: 		scopedPred = null;
1:5872305: 		if (rightScopedPreds == null)
1:71c8e86: 			rightScopedPreds = new HashMap<Predicate,Predicate>();
1:5872305: 		else
1:71c8e86: 			scopedPred = rightScopedPreds.get(pred);
1:5872305: 		if (scopedPred == null)
1:5872305: 		{
1:5872305: 			scopedPred = pred.getPredScopedForResultSet(
1:df88f63: 				tableNums, rightResultSet, whichRC);
1:5872305: 			rightScopedPreds.put(pred, scopedPred);
1:5872305: 		}
1:5872305: 
1:5872305: 		// Add the scoped predicate to our list for the right child.
1:5872305: 		getRightOptPredicateList().addOptPredicate(scopedPred);
1:5872305: 
1:5872305: 		// Add the predicate (in its original form) to our list of predicates
1:5872305: 		// that we've pushed during this phase of optimization.  We need to
1:5872305: 		// keep this list of pushed predicates around so that we can do
1:5872305: 		// a "pull" of them later, if needed.  We also need this list for
1:5872305: 		// cases where predicates are not pushed all the way down; see
1:5872305: 		// modifyAccessPaths() in this class for more.
1:5872305: 		if (pushedPredicates == null)
1:3bb140c:             pushedPredicates = new PredicateList(getContextManager());
1:5872305: 
1:5872305: 		pushedPredicates.addOptPredicate(pred);
2:cafb31f: 		return true;
1:5872305: 	}
1:5872305: 
1:5872305: 	/**
1:5872305: 	 * @see Optimizable#pullOptPredicates
1:5872305: 	 *
1:5872305: 	 * @exception StandardException		Thrown on error
1:5872305: 	 */
1:3bb140c:     @Override
1:5872305: 	public void pullOptPredicates(
1:5872305: 		OptimizablePredicateList optimizablePredicates)
1:5872305: 		throws StandardException
1:5872305: 	{
1:5872305: 		if (pushedPredicates == null)
1:5872305: 		// we didn't push anything, so nothing to pull.
1:5872305: 			return;
1:5872305: 
1:5872305: 		// It's possible that we tried to push a predicate down to this
1:5872305: 		// SetOperatorNode's children but weren't actually able to do so
1:5872305: 		// (see modifyAccessPaths() in this class for details on when that
1:5872305: 		// can happen).  In that case the predicates will still be sitting
1:5872305: 		// in the left/right predicate list; we can ignore them here by
1:5872305: 		// just discarding them.  When it comes time to modifyAccessPaths,
1:5872305: 		// though, we'll handle them correctly--i.e. we'll generate a
1:5872305: 		// ProjectRestrictNode over this node to ensure the predicates are
1:5872305: 		// enforced.
1:5872305: 
1:5872305: 		if (leftOptPredicates != null)
1:5872305: 			leftOptPredicates.removeAllElements();
1:5872305: 
1:5872305: 		if (rightOptPredicates != null)
1:5872305: 			rightOptPredicates.removeAllElements();
1:5872305: 
1:5872305: 		/* Note that predicates which have been explicitly scoped should
1:5872305: 		 * not be pulled.  The reason is that a scoped predicate can only
1:5872305: 		 * be pushed to a specific, target result set.  When it comes time
1:5872305: 		 * to pull the predicate up, there's no need to pull the scoped
1:5872305: 		 * predicate because it, by definition, was only intended for this
1:5872305: 		 * specific result set and therefore cannot be pushed anywhere else.
1:5872305: 		 * So at "pull" time, we can just discard the scoped predicates.  We
1:5872305: 		 * do, however, need to pull the original, unscoped predicate from
1:5872305: 		 * which the scoped predicate was created because we can potentially
1:5872305: 		 * push that predicate elsewhere
1:5872305: 		 */
1:df88f63: 		RemapCRsVisitor rcrv = new RemapCRsVisitor(false);
1:5872305: 		for (int i = 0; i < pushedPredicates.size(); i++)
1:5872305: 		{
1:3bb140c:             Predicate pred = (Predicate)pushedPredicates.getOptPredicate(i);
1:5872305: 			if (pred.isScopedForPush())
1:df88f63: 			{
1:df88f63: 				/* We don't need to pull the predicate if it's scoped, but
1:df88f63: 				 * since scoped predicates are cached between rounds of
1:df88f63: 				 * optimization, it's possible that we'll reuse the scoped
1:df88f63: 				 * predicate again in a later round.  So to make sure we
1:df88f63: 				 * get a "fresh start" in later rounds, we un-remap the
1:df88f63: 				 * predicate here.
1:df88f63: 				 */
1:df88f63:  				pred.getAndNode().accept(rcrv);
1:5872305: 				continue;
1:df88f63: 			}
1:5872305: 			optimizablePredicates.addOptPredicate(pred);
1:5872305: 		}
1:5872305: 
1:5872305: 		// We're done with the pushedPredicates list, so clear it out
1:5872305: 		// in preparation for another phase of optimization.
1:5872305: 		pushedPredicates.removeAllElements();
1:5872305: 	}
1:5872305: 
1:5872305: 	/**
1:cafb31f: 	 * It's possible that we tried to push predicates to this node's
1:cafb31f: 	 * children but failed to do so. This can happen if this node's
1:cafb31f: 	 * children both satisfy the criteria for pushing a predicate
1:cafb31f: 	 * (namely, they reference base tables) but the children's
1:cafb31f: 	 * children do not (see modifyAccessPaths() above for an example
1:0f0f8ad: 	 * of how that can happen).  So this method determines whether
1:0f0f8ad: 	 * or not this particular SetOperatorNode has predicates which
1:0f0f8ad: 	 * were *not* successfully pushed to both of its children (note:
1:0f0f8ad: 	 * this currently only applies to UnionNodes).
1:cafb31f: 	 *
1:0f0f8ad: 	 * @return True if this SetOperatorNode has unpushed predicates;
1:0f0f8ad: 	 *  false otherwise.
1:cafb31f: 	 */
1:cafb31f: 	protected boolean hasUnPushedPredicates()
1:cafb31f: 	{
1:cafb31f: 		// Check this node.
1:0f0f8ad: 		return
1:0f0f8ad: 			((leftOptPredicates != null) && (leftOptPredicates.size() > 0)) ||
1:0f0f8ad: 			((rightOptPredicates != null) && (rightOptPredicates.size() > 0));
1:cafb31f: 	}
1:cafb31f: 
1:cafb31f: 	/**
1:47f9d0a: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:47f9d0a: 	 * for how this should be done for tree printing.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @return	This object as a String
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:47f9d0a: 	public String toString()
1:cafb31f: 	{
1:47f9d0a: 		if (SanityManager.DEBUG)
1:cafb31f: 		{
1:47f9d0a: 			return 	"all: " + all + "\n" +
1:47f9d0a: 				super.toString();
1:cafb31f: 		}
2:47f9d0a: 		else
1:5872305: 		{
1:47f9d0a: 			return "";
1:cafb31f: 		}
1:5872305: 	}
1:cafb31f: 
5:47f9d0a: 	/**
1:c9a1206: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:c9a1206: 	 * how tree printing is supposed to work.
1:c9a1206: 	 *
1:c9a1206: 	 * @param depth		The depth of this node in the tree
1:c9a1206: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:c9a1206: 	{
1:c9a1206: 		if (SanityManager.DEBUG)
1:c9a1206: 		{
1:c9a1206: 			super.printSubNodes(depth);
1:4d044a3: 
1:b4cda60:             printQueryExpressionSuffixClauses(depth, qec);
1:4d044a3: 		}
1:4d044a3: 	}
1:c9a1206: 	/**
1:47f9d0a: 	 * Bind the result columns of this ResultSetNode when there is no
1:47f9d0a: 	 * base table to bind them to.  This is useful for SELECT statements,
1:47f9d0a: 	 * where the result columns get their types from the expressions that
1:47f9d0a: 	 * live under them.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param fromListParam		FromList to use/append to.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindResultColumns(FromList fromListParam)
4:47f9d0a: 					throws StandardException
1:5872305: 	{
1:47f9d0a: 		super.bindResultColumns(fromListParam);
1:c9a1206: 
1:47f9d0a: 		/* Now we build our RCL */
1:47f9d0a: 		buildRCL();
1:4d044a3: 	}
1:c9a1206: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Bind the result columns for this ResultSetNode to a base table.
1:47f9d0a: 	 * This is useful for INSERT and UPDATE statements, where the
1:47f9d0a: 	 * result columns get their types from the table being updated or
1:47f9d0a: 	 * inserted into.
1:47f9d0a: 	 * If a result column list is specified, then the verification that the 
1:47f9d0a: 	 * result column list does not contain any duplicates will be done when
1:47f9d0a: 	 * binding them by name.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param targetTableDescriptor	The TableDescriptor for the table being
1:47f9d0a: 	 *				updated or inserted into
1:47f9d0a: 	 * @param targetColumnList	For INSERT statements, the user
1:47f9d0a: 	 *					does not have to supply column
1:47f9d0a: 	 *					names (for example, "insert into t
1:47f9d0a: 	 *					values (1,2,3)".  When this
1:47f9d0a: 	 *					parameter is null, it means that
1:47f9d0a: 	 *					the user did not supply column
1:47f9d0a: 	 *					names, and so the binding should
1:47f9d0a: 	 *					be done based on order.  When it
1:47f9d0a: 	 *					is not null, it means do the binding
1:47f9d0a: 	 *					by name, not position.
1:47f9d0a: 	 * @param statement			Calling DMLStatementNode (Insert or Update)
1:47f9d0a: 	 * @param fromListParam		FromList to use/append to.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:8fe3166:     void bindResultColumns(TableDescriptor targetTableDescriptor,
1:8fe3166:             FromVTI targetVTI, ResultColumnList targetColumnList,
1:8fe3166:             DMLStatementNode statement, FromList fromListParam)
1:47f9d0a: 				throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		super.bindResultColumns(targetTableDescriptor,
1:47f9d0a: 								targetVTI,
1:47f9d0a: 								targetColumnList, statement,
1:47f9d0a: 								fromListParam);
1:cafb31f: 
1:47f9d0a: 		/* Now we build our RCL */
1:47f9d0a: 		buildRCL();
1:c9a1206: 	}
1:5872305: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Build the RCL for this node.  We propagate the RCL up from the
1:47f9d0a: 	 * left child to form this node's RCL.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:5872305: 
1:47f9d0a: 	private void buildRCL() throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		/* Verify that both sides of the union have the same # of columns in their
1:47f9d0a: 		 * RCL.
1:47f9d0a: 		 */
1:d5ef906: 		if (leftResultSet.getResultColumns().visibleSize() !=
1:d5ef906: 			rightResultSet.getResultColumns().visibleSize())
1:47f9d0a: 		{
1:47f9d0a: 			throw StandardException.newException(SQLState.LANG_UNION_UNMATCHED_COLUMNS,
1:47f9d0a:                                                  getOperatorName());
1:c9a1206: 		}
1:5872305: 
1:47f9d0a: 		/* We need to recreate resultColumns for this node, since there
1:47f9d0a: 		 * may have been 1 or more *'s in the left's SELECT list.
1:47f9d0a: 		 */
1:11f7ee3: 		setResultColumns( leftResultSet.getResultColumns().copyListAndObjects() );
1:5872305: 
1:0255faa:         // The generated grouping columns of the left result set should not be
1:0255faa:         // part of the result from the set operation (DERBY-3764).
1:11f7ee3:         getResultColumns().removeGeneratedGroupingColumns();
1:4d044a3: 
1:11f7ee3:         getResultColumns().removeOrderByColumns();
1:0255faa: 
1:47f9d0a: 		/* Create new expressions with the dominant types after verifying
1:47f9d0a: 		 * union compatibility between left and right sides.
1:47f9d0a: 		 */
1:11f7ee3: 		getResultColumns().setUnionResultExpression(rightResultSet.getResultColumns(), tableNumber, level, getOperatorName());
1:c9a1206: 	}
1:47f9d0a: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Bind the result columns of a table constructor to the types in the
1:47f9d0a: 	 * given ResultColumnList.  Use when inserting from a table constructor,
1:47f9d0a: 	 * and there are nulls in the values clauses.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param rcl	The ResultColumnList with the types to bind to
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error.
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindUntypedNullsToResultColumns(ResultColumnList rcl)
1:47f9d0a: 				throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		/*
1:47f9d0a: 		** If the RCL from the parent is null, then
1:47f9d0a: 		** the types are coming from the union itself.
1:47f9d0a: 		** So we have to cross check the two child
1:47f9d0a: 		** rcls.
1:47f9d0a: 		*/
1:47f9d0a: 		if (rcl == null)
1:47f9d0a: 		{
1:47f9d0a: 			ResultColumnList lrcl = rightResultSet.getResultColumns();
1:47f9d0a: 			ResultColumnList rrcl = leftResultSet.getResultColumns();
1:47f9d0a: 
1:47f9d0a: 			leftResultSet.bindUntypedNullsToResultColumns(rrcl);
1:47f9d0a: 			rightResultSet.bindUntypedNullsToResultColumns(lrcl);
1:5872305: 		}
1:47f9d0a: 		else	
1:47f9d0a: 		{
1:47f9d0a: 			leftResultSet.bindUntypedNullsToResultColumns(rcl);
1:47f9d0a: 			rightResultSet.bindUntypedNullsToResultColumns(rcl);
1:5872305: 		}			
18:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a:     /**
1:c341dc4:      * {@inheritDoc}
1:c341dc4:      */
1:3bb140c:     @Override
1:c341dc4:     void replaceOrForbidDefaults(TableDescriptor ttd,
1:c341dc4:                                  ResultColumnList tcl,
1:c341dc4:                                  boolean allowDefaults)
1:c341dc4:         throws StandardException
1:c341dc4:     {
1:c341dc4:         leftResultSet.replaceOrForbidDefaults(ttd, tcl, allowDefaults);
1:c341dc4:         rightResultSet.replaceOrForbidDefaults(ttd, tcl, allowDefaults);
1:c341dc4:     }
1:c341dc4: 
1:c341dc4: 
1:c341dc4:     /**
1:47f9d0a: 	 * Get the parameter types from the given RowResultSetNode into the
1:47f9d0a: 	 * given array of types.  If an array position is already filled in,
1:47f9d0a: 	 * don't clobber it.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param types	The array of types to fill in
1:47f9d0a: 	 * @param rrsn	The RowResultSetNode from which to take the param types
1:47f9d0a: 	 *
1:47f9d0a: 	 * @return	The number of new types found in the RowResultSetNode
1:47f9d0a: 	 */
1:47f9d0a: 	int getParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
1:d5bc20f: 	 throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		int	numTypes = 0;
1:47f9d0a: 
1:47f9d0a: 		/* Look for columns where we have not found a non-? yet. */
1:47f9d0a: 		for (int i = 0; i < types.length; i++)
1:47f9d0a: 		{
1:47f9d0a: 			if (types[i] == null)
1:47f9d0a: 			{
1:e1f49ca:                 ResultColumn rc = rrsn.getResultColumns().elementAt(i);
1:d5bc20f: 				if ( ! (rc.getExpression().requiresTypeFromContext()))
1:47f9d0a: 				{
1:ba1b7ec: 					types[i] = rc.getExpression().getTypeServices();
1:47f9d0a: 					numTypes++;
1:47f9d0a: 				}
1:47f9d0a: 			}
1:47f9d0a: 		}
1:47f9d0a: 
1:47f9d0a: 		return numTypes;
1:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Set the type of each ? parameter in the given RowResultSetNode
1:47f9d0a: 	 * according to its ordinal position in the given array of types.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param types	An array of types containing the proper type for each
1:47f9d0a: 	 *				? parameter, by ordinal position.
1:47f9d0a: 	 * @param rrsn	A RowResultSetNode that could contain ? parameters whose
1:47f9d0a: 	 *				types need to be set.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:47f9d0a: 	void setParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
1:47f9d0a: 					throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		/*
1:47f9d0a: 		** Look for ? parameters in the result column list
1:47f9d0a: 		** of each RowResultSetNode
1:47f9d0a: 		*/
1:47f9d0a: 		ResultColumnList rrcl = rrsn.getResultColumns();
1:47f9d0a: 		int rrclSize = rrcl.size();
1:e1f49ca: 
1:47f9d0a: 		for (int index = 0; index < rrclSize; index++)
1:47f9d0a: 		{
1:e1f49ca:             ResultColumn rc = rrcl.elementAt(index);
1:47f9d0a: 
1:d5bc20f: 			if (rc.getExpression().requiresTypeFromContext())
1:47f9d0a: 			{
1:47f9d0a: 				/*
1:47f9d0a: 				** We found a ? - set its type to the type from the
1:47f9d0a: 				** type array.
1:47f9d0a: 				*/
1:d5bc20f: 				rc.getExpression().setType(types[index]);
1:47f9d0a: 			}
1:47f9d0a: 		}
1:47f9d0a: 	}
1:47f9d0a: 
1:3bb140c:     @Override
1:4d044a3:     public void bindExpressions(FromList fromList) throws StandardException {
1:4d044a3:         // Actions for UnionNode qua top node of a multi-valued table value
1:4d044a3:         // constructor
1:b4cda60:         for (int i = 0; i < qec.size(); i++) {
1:b4cda60:             final OrderByList obl = qec.getOrderByList(i);
1:b4cda60: 
1:b4cda60:             if (obl != null) {
1:b4cda60:                 obl.bindOrderByColumns(this);
1:b4cda60:                 obl.pullUpOrderByColumns(this);
1:b4cda60:             }
1:b4cda60: 
1:b4cda60:             bindOffsetFetch(qec.getOffset(i), qec.getFetchFirst(i));
1:4d044a3:         }
1:4d044a3: 
1:4d044a3:         super.bindExpressions(fromList);
1:4d044a3:     }
1:4d044a3: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Bind the expressions in the target list.  This means binding the
1:47f9d0a: 	 * sub-expressions, as well as figuring out what the return type is
1:47f9d0a: 	 * for each expression.  This is useful for EXISTS subqueries, where we
1:47f9d0a: 	 * need to validate the target list before blowing it away and replacing
1:47f9d0a: 	 * it with a SELECT true.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     void bindTargetExpressions(FromList fromListParam)
1:47f9d0a: 					throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		leftResultSet.bindTargetExpressions(fromListParam);
1:47f9d0a: 		rightResultSet.bindTargetExpressions(fromListParam);
1:47f9d0a: 	}
1:47f9d0a: 
1:b4cda60:     @Override
1:b4cda60:     public void pushQueryExpressionSuffix() {
1:b4cda60:         qec.push();
1:b4cda60:     }
1:b4cda60: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Push the order by list down from the cursor node
1:47f9d0a: 	 * into its child result set so that the optimizer
1:47f9d0a: 	 * has all of the information that it needs to 
1:47f9d0a: 	 * consider sort avoidance.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param orderByList	The order by list
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:47f9d0a: 	void pushOrderByList(OrderByList orderByList)
1:47f9d0a: 	{
1:b4cda60:         qec.setOrderByList(orderByList);
1:4d044a3: 	}
1:4d044a3: 
1:47f9d0a:     /**
1:108305b:      * Push down the offset and fetch first parameters, if any, to this node.
1:108305b:      *
1:108305b:      * @param offset    the OFFSET, if any
1:108305b:      * @param fetchFirst the OFFSET FIRST, if any
1:57c1b5c:      * @param hasJDBClimitClause true if the clauses were added by (and have the semantics of) a JDBC limit clause
1:108305b:      */
1:3bb140c:     @Override
1:57c1b5c:     void pushOffsetFetchFirst( ValueNode offset, ValueNode fetchFirst, boolean hasJDBClimitClause )
1:108305b:     {
1:b4cda60:         qec.setOffset(offset);
1:b4cda60:         qec.setFetchFirst(fetchFirst);
1:b4cda60:         qec.setHasJDBCLimitClause(hasJDBClimitClause);
1:4d044a3:     }
1:108305b: 
1:108305b: 
1:108305b:     /**
1:47f9d0a: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1:47f9d0a: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1:47f9d0a: 	 * that ResultColumn must percolate up to the new PRN.  However,
1:47f9d0a: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1:47f9d0a: 	 * which points to the FromTable and the ResultColumn that is the source for
1:47f9d0a: 	 * the ColumnReference.  
1:47f9d0a: 	 * (The new PRN will have the original of the ResultColumnList and
1:47f9d0a: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1:47f9d0a: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1:47f9d0a: 	 * will remain at the FromTable, with the PRN getting a new 
1:47f9d0a: 	 * VirtualColumnNode for each ResultColumn.expression.)
1:47f9d0a: 	 * We then project out the non-referenced columns.  If there are no referenced
1:47f9d0a: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1:47f9d0a: 	 * whose expression is 1.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param numTables			Number of tables in the DML Statement
1:47f9d0a: 	 * @param gbl				The group by list, if any
1:47f9d0a: 	 * @param fromList			The from list, if any
1:47f9d0a: 	 *
1:47f9d0a: 	 * @return The preprocessed ResultSetNode that can be optimized
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode preprocess(int numTables,
1:47f9d0a: 									GroupByList gbl,
1:47f9d0a: 									FromList fromList)
1:47f9d0a: 								throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		ResultSetNode newTop = this;
1:47f9d0a: 
1:47f9d0a: 		/* RESOLVE - what does numTables and referencedTableMap mean here? */
1:47f9d0a: 		leftResultSet = leftResultSet.preprocess(numTables, gbl, fromList);
1:47f9d0a: 		rightResultSet = rightResultSet.preprocess(numTables, gbl, fromList);
1:47f9d0a: 
1:47f9d0a: 		/* Build the referenced table map (left || right) */
1:11f7ee3: 		setReferencedTableMap( (JBitSet) leftResultSet.getReferencedTableMap().clone() );
1:11f7ee3:         getReferencedTableMap().or(rightResultSet.getReferencedTableMap());
1:47f9d0a: 
1:47f9d0a: 		/* If this is a UNION without an all and we have
1:47f9d0a: 		 * an order by then we can consider eliminating the sort for the
1:47f9d0a: 		 * order by.  All of the columns in the order by list must
1:47f9d0a: 		 * be ascending in order to do this.  There are 2 cases:
1:47f9d0a: 		 *	o	The order by list is an in order prefix of the columns
1:47f9d0a: 		 *		in the select list.  In this case the output of the
1:47f9d0a: 		 *		sort from the distinct will be in the right order
1:47f9d0a: 		 *		so we simply eliminate the order by list.
1:47f9d0a: 		 *	o	The order by list is a subset of the columns in the
1:47f9d0a: 		 *		the select list.  In this case we need to reorder the
1:47f9d0a: 		 *		columns in the select list so that the ordering columns
1:47f9d0a: 		 *		are an in order prefix of the select list and put a PRN
1:47f9d0a: 		 *		above the select so that the shape of the result set
1:47f9d0a: 		 *		is as expected.
1:47f9d0a: 		 */
1:b4cda60:         for (int i = 0; i < qec.size(); i++) {
1:b4cda60:             OrderByList obl = qec.getOrderByList(i);
1:b4cda60: 
1:b4cda60:             if ((! all) && obl != null &&
1:b4cda60:                 obl.allAscending())
1:4d044a3:             {
1:4d044a3:                 /* Order by list currently restricted to columns in select
1:4d044a3:                  * list, so we will always eliminate the order by here.
1:4d044a3:                  */
1:11f7ee3:                 if (obl.isInOrderPrefix(getResultColumns()))
1:4d044a3:                 {
1:b4cda60:                     obl = null;
1:b4cda60:                     qec.setOrderByList(i, null);
1:4d044a3:                 }
1:4d044a3:                 /* RESOLVE - We currently only eliminate the order by if it is
1:4d044a3:                  * a prefix of the select list.  We do not currently do the
1:4d044a3:                  * elimination if the order by is not a prefix because the code
1:4d044a3:                  * doesn't work.  The problem has something to do with the
1:4d044a3:                  * fact that we generate additional nodes between the union
1:4d044a3:                  * and the PRN (for reordering that we would generate here)
1:4d044a3:                  * when modifying the access paths.  VCNs under the PRN can be
1:4d044a3:                  * seen as correlated since their source resultset is the Union
1:4d044a3:                  * which is no longer the result set directly under them.  This
1:4d044a3:                  * causes the wrong code to get generated. (jerry - 11/3/98)
1:4d044a3:                  * (bug 59)
1:4d044a3:                  */
1:4d044a3:             }
1:4d044a3: 
1:4d044a3:             // UnionNode qua top of table value constructor with ordering
1:4d044a3:             // If we have more than 1 ORDERBY columns, we may be able to
1:4d044a3:             // remove duplicate columns, e.g., "ORDER BY 1, 1, 2".
1:b4cda60:             if (obl != null && obl.size() > 1) {
1:b4cda60:                 obl.removeDupColumns();
1:4d044a3:             }
1:4d044a3:         }
1:47f9d0a: 
1:47f9d0a: 		return newTop;
1:47f9d0a: 	}
1:47f9d0a: 	
1:47f9d0a: 	/**
1:47f9d0a: 	 * Ensure that the top of the RSN tree has a PredicateList.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param numTables			The number of tables in the query.
1:47f9d0a: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode ensurePredicateList(int numTables)
1:47f9d0a: 		throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		return genProjectRestrict(numTables);
1:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Verify that a SELECT * is valid for this type of subquery.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param outerFromList	The FromList from the outer query block(s)
1:47f9d0a: 	 * @param subqueryType	The subquery type
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     void verifySelectStarSubquery(FromList outerFromList, int subqueryType)
1:47f9d0a: 					throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		/* Check both sides - SELECT * is not valid on either side */
1:47f9d0a: 		leftResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
1:47f9d0a: 		rightResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
1:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a: 	/** 
1:47f9d0a: 	 * Determine whether or not the specified name is an exposed name in
1:47f9d0a: 	 * the current query block.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param name	The specified name to search for as an exposed name.
1:47f9d0a: 	 * @param schemaName	Schema name, if non-null.
1:47f9d0a: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1:47f9d0a: 	 *						names or match on table id.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @return The FromTable, if any, with the exposed name.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:8fe3166:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1:47f9d0a: 		throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		/* We search both sides for a TableOperatorNode (join nodes)
1:47f9d0a: 		 * but only the left side for a UnionNode.
1:47f9d0a: 		 */
1:47f9d0a: 		return leftResultSet.getFromTableByName(name, schemaName, exactMatch);
1:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Set the result column for the subquery to a boolean true,
1:47f9d0a: 	 * Useful for transformations such as
1:47f9d0a: 	 * changing:
1:47f9d0a: 	 *		where exists (select ... from ...) 
1:47f9d0a: 	 * to:
1:47f9d0a: 	 *		where (select true from ...)
1:47f9d0a: 	 *
1:47f9d0a: 	 * NOTE: No transformation is performed if the ResultColumn.expression is
1:47f9d0a: 	 * already the correct boolean constant.
1:47f9d0a: 	 * 
1:0787955: 	 * This method is used during binding of EXISTS predicates to map
1:0787955: 	 * a subquery's result column list into a single TRUE node.  For
1:0787955: 	 * SELECT and VALUES subqueries this transformation is pretty
1:0787955: 	 * straightforward.  But for set operators (ex. INTERSECT) we have
1:0787955: 	 * to do some extra work.  To see why, assume we have the following
1:0787955: 	 * query:
1:0787955: 	 *
1:0787955: 	 *  select * from ( values 'BAD' ) as T
1:0787955: 	 *    where exists ((values 1) intersect (values 2))
1:0787955: 	 *
1:0787955: 	 * If we treated the INTERSECT in this query the same way that we
1:0787955: 	 * treat SELECT/VALUES subqueries then the above query would get
1:0787955: 	 * transformed into:
1:0787955: 	 *
1:0787955: 	 *  select * from ( values 'BAD' ) as T
1:0787955: 	 *    where ((values TRUE) intersect (values TRUE))
1:0787955: 	 *
1:0787955: 	 * Since both children of the INTERSECT would then have the same value,
1:0787955: 	 * the result of set operation would be a single value (TRUE), which
1:0787955: 	 * means the WHERE clause would evaluate to TRUE and thus the query
1:0787955: 	 * would return one row with value 'BAD'.  That would be wrong.
1:0787955: 	 *
1:0787955: 	 * To avoid this problem, we internally wrap this SetOperatorNode
1:0787955: 	 * inside a "SELECT *" subquery and then we change the new SelectNode's
1:0787955: 	 * result column list (as opposed to *this* nodes' result column list)
1:0787955: 	 * to a singe boolean true node:
1:0787955: 	 *
1:0787955: 	 *  select * from ( values 'BAD' ) as T where
1:0787955: 	 *      SELECT TRUE FROM ((values 1) intersect (values 2))
1:0787955: 	 *
1:0787955: 	 * In this case the left and right children of the INTERSECT retain
1:0787955: 	 * their values, which ensures that the result of the intersect
1:0787955: 	 * operation will be correct.  Since (1 intersect 2) is an empty
1:0787955: 	 * result set, the internally generated SELECT node will return
1:0787955: 	 * zero rows, which in turn means the WHERE predicate will return
1:0787955: 	 * NULL (an empty result set from a SubqueryNode is treated as NULL
1:0787955: 	 * at execution time; see impl/sql/execute/AnyResultSet). Since
1:0787955: 	 * NULL is not the same as TRUE the query will correctly return
1:0787955: 	 * zero rows.  DERBY-2370.
1:0787955: 	 *
1:47f9d0a: 	 * @param onlyConvertAlls	Boolean, whether or not to just convert *'s
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode setResultToBooleanTrueNode(boolean onlyConvertAlls)
1:0787955: 		throws StandardException
1:47f9d0a: 	{
1:0787955: 		// First create a FromList to hold this node (and only this node).
1:0787955: 
1:3bb140c:         FromList fromList = new FromList(
1:3bb140c:                 getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                 getContextManager());
1:0787955: 
1:0787955: 		fromList.addFromTable(this);
1:0787955: 
1:0787955: 		/* It's possible that this SetOperatorNode (or more specifically,
1:0787955: 		 * one of its children) references tables from an outer query, ex:
1:0787955: 		 *
1:0787955: 		 *  select j from onerow where exists
1:0787955: 		 *    (select 1 from diffrow where 1 = 0 INTERSECT
1:0787955: 		 *      select * from diffrow where onerow.j < k)
1:0787955: 		 *
1:0787955: 		 * In this case the right child of the INTERSECT node references
1:0787955: 		 * the outer table "onerow".  In order to ensure that the new
1:0787955: 		 * subquery binds correctly we mark the new FromList as "transparent",
1:0787955: 		 * which means that the FromTables it contains (namely, this node
1:0787955: 		 * and its children) will still be able to see (and reference) the
1:0787955: 		 * outer table.
1:0787955: 		 */
1:0787955: 		fromList.markAsTransparent();
1:0787955: 
1:0787955: 		// Now create a ResultColumnList that simply holds the "*".
1:0787955: 
1:3bb140c:         ResultColumnList rcl = new ResultColumnList(getContextManager());
1:0787955: 
1:3bb140c:        ResultColumn allResultColumn =
1:3bb140c:                 new AllResultColumn(null, getContextManager());
1:0787955: 
1:0787955: 		rcl.addResultColumn(allResultColumn);
1:0787955: 
1:0787955: 		/* Create a new SELECT node of the form:
1:0787955: 		 *  SELECT * FROM <thisSetOperatorNode>
1:0787955: 		 */
1:3bb140c:         ResultSetNode result = new SelectNode(
1:0787955: 				rcl,      // ResultColumns
1:0787955: 				fromList, // FROM list
1:0787955: 				null,     // WHERE clause
1:0787955: 				null,     // GROUP BY list
1:0787955: 				null,     // having clause
1:7a9ce7e: 				null, /* window list */
1:a56ecfa: 				null, /* optimizer override plan */
1:0787955: 				getContextManager());
1:0787955: 
1:0787955: 		/* And finally, transform the "*" in the new SELECT node
1:0787955: 		 * into a TRUE constant node.  This ultimately gives us:
1:0787955: 		 *
1:0787955: 		 *  SELECT TRUE FROM <thisSetOperatorNode>
1:0787955: 		 *
1:0787955: 		 * which has a single result column that is a boolean TRUE
1:0787955: 		 * constant.  So we're done.
1:0787955: 		 */
1:0787955: 		return result.setResultToBooleanTrueNode(onlyConvertAlls);
1:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
1:47f9d0a: 	 * Currently, a FSqry is flattenable if all of the following are true:
1:47f9d0a: 	 *		o  Subquery is a SelectNode. (ie, not a RowResultSetNode or a UnionNode)
1:47f9d0a: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1:47f9d0a: 	 *		o  It does not contain a group by or having clause
1:47f9d0a: 	 *		o  It does not contain aggregates.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @param fromList	The outer from list
1:47f9d0a: 	 *
1:47f9d0a: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean flattenableInFromSubquery(FromList fromList)
1:47f9d0a: 	{
1:47f9d0a: 		/* Unions in FromSubquerys are not flattenable.	 */
1:47f9d0a: 		return false;
1:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a: 	/**
1:47f9d0a: 	 * Return whether or not to materialize this ResultSet tree.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @return Whether or not to materialize this ResultSet tree.
1:47f9d0a: 	 *			would return valid results.
1:47f9d0a: 	 *
1:47f9d0a: 	 * @exception StandardException		Thrown on error
1:47f9d0a: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean performMaterialization(JBitSet outerTables)
1:47f9d0a: 		throws StandardException
1:47f9d0a: 	{
1:47f9d0a: 		// RESOLVE - just say no to materialization right now - should be a cost based decision
1:47f9d0a: 		return false;
1:47f9d0a: 
1:47f9d0a: 		/* Actual materialization, if appropriate, will be placed by our parent PRN.
1:47f9d0a: 		 * This is because PRN might have a join condition to apply.  (Materialization
1:47f9d0a: 		 * can only occur before that.
1:47f9d0a: 		 */
1:47f9d0a: 		//return true;
1:47f9d0a: 	}
1:47f9d0a: 
1:47f9d0a:     /**
1:47f9d0a:      * @return the operator name: "UNION", "INTERSECT", or "EXCEPT"
1:47f9d0a:      */
1:47f9d0a:     abstract String getOperatorName();
1:5872305: 
1:47f9d0a: 	/**
1:5872305: 	 * Retrieve the list of optimizable predicates that are
1:5872305: 	 * targeted for the left child.  Create a new (empty)
1:5872305: 	 * list if the list is null.
1:5872305: 	 */
1:03eae1d: 	PredicateList getLeftOptPredicateList()
1:5872305: 		throws StandardException
1:5872305: 	{
1:5872305: 		if (leftOptPredicates == null) {
1:3bb140c:             leftOptPredicates = new PredicateList(getContextManager());
1:5872305: 		}
1:5872305: 
1:5872305: 		return leftOptPredicates;
1:5872305: 	}
1:5872305: 
1:5872305: 	/**
1:5872305: 	 * Retrieve the list of optimizable predicates that are
1:5872305: 	 * targeted for the right child.  Create a new (empty)
1:5872305: 	 * list if the list is null.
1:5872305: 	 */
1:03eae1d: 	PredicateList getRightOptPredicateList()
1:5872305: 		throws StandardException
1:5872305: 	{
1:5872305: 		if (rightOptPredicates == null) {
1:3bb140c:             rightOptPredicates = new PredicateList(getContextManager());
1:5872305: 		}
1:5872305: 
1:5872305: 		return rightOptPredicates;
1:5872305: 	}
1:47f9d0a: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1: 		setResultColumns( leftResultSet.getResultColumns().copyListAndObjects() );
/////////////////////////////////////////////////////////////////////////
1: 			prnRSN.setCostEstimate( ce.cloneMe() );
/////////////////////////////////////////////////////////////////////////
1: 		setResultColumns( leftResultSet.getResultColumns().copyListAndObjects() );
1:         getResultColumns().removeGeneratedGroupingColumns();
1:         getResultColumns().removeOrderByColumns();
1: 		getResultColumns().setUnionResultExpression(rightResultSet.getResultColumns(), tableNumber, level, getOperatorName());
/////////////////////////////////////////////////////////////////////////
1: 		setReferencedTableMap( (JBitSet) leftResultSet.getReferencedTableMap().clone() );
1:         getReferencedTableMap().or(rightResultSet.getReferencedTableMap());
/////////////////////////////////////////////////////////////////////////
1:                 if (obl.isInOrderPrefix(getResultColumns()))
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
1: 				null, /* optimizer override plan */
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 	private HashMap<Predicate,Predicate> leftScopedPreds;
1: 	private HashMap<Predicate,Predicate> rightScopedPreds;
/////////////////////////////////////////////////////////////////////////
1: 			leftScopedPreds = new HashMap<Predicate,Predicate>();
1: 			scopedPred = leftScopedPreds.get(pred);
/////////////////////////////////////////////////////////////////////////
1: 			rightScopedPreds = new HashMap<Predicate,Predicate>();
1: 			scopedPred = rightScopedPreds.get(pred);
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
0:     boolean   hasJDBClimitClause; // were OFFSET/FETCH FIRST specified by a JDBC LIMIT clause?
/////////////////////////////////////////////////////////////////////////
1:      * @param hasJDBClimitClause true if the clauses were added by (and have the semantics of) a JDBC limit clause
1:     void pushOffsetFetchFirst( ValueNode offset, ValueNode fetchFirst, boolean hasJDBClimitClause )
0:         this.hasJDBClimitClause = hasJDBClimitClause;
commit:df88f63
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		// For details on how this whichRC variable is used, see the
1: 		// comments in BinaryRelationalOperatorNode.getScopedOperand().
1: 		int [] whichRC = new int[] { -1 };
1: 
/////////////////////////////////////////////////////////////////////////
1: 				tableNums, leftResultSet, whichRC);
/////////////////////////////////////////////////////////////////////////
1: 				tableNums, rightResultSet, whichRC);
/////////////////////////////////////////////////////////////////////////
1: 		RemapCRsVisitor rcrv = new RemapCRsVisitor(false);
1: 			{
1: 				/* We don't need to pull the predicate if it's scoped, but
1: 				 * since scoped predicates are cached between rounds of
1: 				 * optimization, it's possible that we'll reuse the scoped
1: 				 * predicate again in a later round.  So to make sure we
1: 				 * get a "fresh start" in later rounds, we un-remap the
1: 				 * predicate here.
1: 				 */
1:  				pred.getAndNode().accept(rcrv);
1: 			}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1:     QueryExpressionClauses qec = new QueryExpressionClauses();
/////////////////////////////////////////////////////////////////////////
1:             printQueryExpressionSuffixClauses(depth, qec);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < qec.size(); i++) {
1:             final OrderByList obl = qec.getOrderByList(i);
1: 
1:             if (obl != null) {
1:                 obl.bindOrderByColumns(this);
1:                 obl.pullUpOrderByColumns(this);
1:             }
1: 
1:             bindOffsetFetch(qec.getOffset(i), qec.getFetchFirst(i));
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public void pushQueryExpressionSuffix() {
1:         qec.push();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         qec.setOrderByList(orderByList);
/////////////////////////////////////////////////////////////////////////
1:         qec.setOffset(offset);
1:         qec.setFetchFirst(fetchFirst);
1:         qec.setHasJDBCLimitClause(hasJDBClimitClause);
/////////////////////////////////////////////////////////////////////////
1:         for (int i = 0; i < qec.size(); i++) {
1:             OrderByList obl = qec.getOrderByList(i);
1: 
1:             if ((! all) && obl != null &&
1:                 obl.allAscending())
0:                 if (obl.isInOrderPrefix(resultColumns))
1:                     obl = null;
1:                     qec.setOrderByList(i, null);
/////////////////////////////////////////////////////////////////////////
1:             if (obl != null && obl.size() > 1) {
1:                 obl.removeDupColumns();
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:                 ResultColumn rc = rrsn.getResultColumns().elementAt(i);
/////////////////////////////////////////////////////////////////////////
1: 
1:             ResultColumn rc = rrcl.elementAt(index);
/////////////////////////////////////////////////////////////////////////
0:                 OrderByColumn obc = orderByList.elementAt(0);
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Properties;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a SetOperatorNode.
1:      * @param cm                The context manager
1:     SetOperatorNode(ResultSetNode leftResult,
1:                     ResultSetNode rightResult,
1:                     boolean all,
1:                     Properties tableProperties,
1:                     ContextManager cm) throws StandardException {
1:         super(leftResult, rightResult, tableProperties, cm);
1:         this.all = all;
/////////////////////////////////////////////////////////////////////////
1:             ResultSetNode prnRSN = new ProjectRestrictNode(
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1: 
1:         boolean canPush = (tableNums.getFirstSetBit() != -1);
/////////////////////////////////////////////////////////////////////////
1:             pushedPredicates = new PredicateList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:             Predicate pred = (Predicate)pushedPredicates.getOptPredicate(i);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindResultColumns(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindUntypedNullsToResultColumns(ResultColumnList rcl)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void bindTargetExpressions(FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
0:         referencedTableMap.or(rightResultSet.getReferencedTableMap());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode ensurePredicateList(int numTables)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void verifySelectStarSubquery(FromList outerFromList, int subqueryType)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode setResultToBooleanTrueNode(boolean onlyConvertAlls)
1:         FromList fromList = new FromList(
1:                 getOptimizerFactory().doJoinOrderOptimization(),
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList rcl = new ResultColumnList(getContextManager());
1:        ResultColumn allResultColumn =
1:                 new AllResultColumn(null, getContextManager());
1:         ResultSetNode result = new SelectNode(
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean flattenableInFromSubquery(FromList fromList)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean performMaterialization(JBitSet outerTables)
/////////////////////////////////////////////////////////////////////////
1:             leftOptPredicates = new PredicateList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             rightOptPredicates = new PredicateList(getContextManager());
commit:4d044a3
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * List of columns in ORDER BY list. Usually size 1, if size 2, we
0:      * are a VALUES top node UNION node and element 2 has been passed
0:      * from InterceptOrExceptNode to prepare for merge implementation
0:      * of intersect or except.
1:      */
0:     OrderByList[] orderByLists = new OrderByList[1];
1: 
/////////////////////////////////////////////////////////////////////////
0:             if (orderByLists[0] != null) {
0:                 for (int i = 0; i < orderByLists.length; i++) {
0:                     printLabel(depth, "orderByLists[" + i + "]:");
0:                     orderByLists[i].treePrint(depth + 1);
1:                 }
0:             if (offset != null) {
0:                 printLabel(depth, "offset:");
0:                 offset.treePrint(depth + 1);
1:             }
1: 
0:             if (fetchFirst != null) {
0:                 printLabel(depth, "fetch first/next:");
0:                 fetchFirst.treePrint(depth + 1);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         resultColumns.removeOrderByColumns();
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void bindExpressions(FromList fromList) throws StandardException {
1:         // Actions for UnionNode qua top node of a multi-valued table value
1:         // constructor
0:         if (orderByLists[0] != null) {
0:             orderByLists[0].bindOrderByColumns(this);
0:             orderByLists[0].pullUpOrderByColumns(this);
1:         }
1: 
0:         bindOffsetFetch(offset, fetchFirst);
1:         super.bindExpressions(fromList);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:         if (this.orderByLists[0] != null) {
0:             // Presumably a push down order by from IntersectOrExceptNode
0:             // on a VALUES clause that already has an ORDER BY.
0:             if (SanityManager.DEBUG) {
0:                 SanityManager.ASSERT(
0:                     orderByList.size() == resultColumns.visibleSize());
0:                 OrderByColumn obc = (OrderByColumn)orderByList.elementAt(0);
0:                 SanityManager.ASSERT(
0:                     obc.getExpression() instanceof NumericConstantNode);
0:                 try {
0:                     SanityManager.ASSERT(
0:                             ((NumericConstantNode)obc.getExpression())
0:                             .value.getInt() == 1);
0:                 } catch (Exception e) {
0:                     SanityManager.THROWASSERT(e);
1:                 }
1:             }
1: 
0:             // FIXME: Check to see if this extra ordering can be eliminated
0:             OrderByList[] newOrderByLists = new OrderByList[2];
0:             newOrderByLists[0] = orderByLists[0];
0:             newOrderByLists[1] = orderByList;
0:             this.orderByLists = newOrderByLists;
0:         } else {
0:             this.orderByLists[0] = orderByList;
1:         }
/////////////////////////////////////////////////////////////////////////
0:         for (int i = 0; i < orderByLists.length; i++) {
0:             if ((! all) && orderByLists[i] != null &&
0:                 orderByLists[i].allAscending())
1:             {
1:                 /* Order by list currently restricted to columns in select
1:                  * list, so we will always eliminate the order by here.
1:                  */
0:                 if (orderByLists[i].isInOrderPrefix(resultColumns))
1:                 {
0:                     orderByLists[i] = null;
1:                 }
1:                 /* RESOLVE - We currently only eliminate the order by if it is
1:                  * a prefix of the select list.  We do not currently do the
1:                  * elimination if the order by is not a prefix because the code
1:                  * doesn't work.  The problem has something to do with the
1:                  * fact that we generate additional nodes between the union
1:                  * and the PRN (for reordering that we would generate here)
1:                  * when modifying the access paths.  VCNs under the PRN can be
1:                  * seen as correlated since their source resultset is the Union
1:                  * which is no longer the result set directly under them.  This
1:                  * causes the wrong code to get generated. (jerry - 11/3/98)
1:                  * (bug 59)
1:                  */
1:             }
1: 
1:             // UnionNode qua top of table value constructor with ordering
1:             // If we have more than 1 ORDERBY columns, we may be able to
1:             // remove duplicate columns, e.g., "ORDER BY 1, 1, 2".
0:             if (orderByLists[i] != null && orderByLists[i].size() > 1) {
0:                 orderByLists[i].removeDupColumns();
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
commit:108305b
/////////////////////////////////////////////////////////////////////////
0:     ValueNode   offset; // OFFSET n ROWS
0:     ValueNode   fetchFirst; // FETCH FIRST n ROWS ONLY
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Push down the offset and fetch first parameters, if any, to this node.
1:      *
1:      * @param offset    the OFFSET, if any
1:      * @param fetchFirst the OFFSET FIRST, if any
1:      */
0:     void pushOffsetFetchFirst(ValueNode offset, ValueNode fetchFirst)
1:     {
0:         this.offset = offset;
0:         this.fetchFirst = fetchFirst;
1:     }
1: 
1: 
1:     /**
commit:c341dc4
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * {@inheritDoc}
1:      */
1:     void replaceOrForbidDefaults(TableDescriptor ttd,
1:                                  ResultColumnList tcl,
1:                                  boolean allowDefaults)
1:         throws StandardException
1:     {
1:         leftResultSet.replaceOrForbidDefaults(ttd, tcl, allowDefaults);
1:         rightResultSet.replaceOrForbidDefaults(ttd, tcl, allowDefaults);
1:     }
1: 
1: 
1:     /**
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: 				null, /* window list */
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
0: 			if (orderByList != null) {
0: 				printLabel(depth, "orderByList:");
0: 				orderByList.treePrint(depth + 1);
1: 			}
1: 
1: 		}
1: 	}
1: 	/**
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:0958c84
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a6d25cd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         CollectNodesVisitor<UnionNode> cnv =
1:                 new CollectNodesVisitor<UnionNode>(UnionNode.class);
1:         for (UnionNode node : cnv.getList())
1:             if (node.hasUnPushedPredicates())
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void bindResultColumns(TableDescriptor targetTableDescriptor,
1:             FromVTI targetVTI, ResultColumnList targetColumnList,
1:             DMLStatementNode statement, FromList fromListParam)
/////////////////////////////////////////////////////////////////////////
1:     FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
commit:c0a807c
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 		List unions = cnv.getList();
commit:0255faa
/////////////////////////////////////////////////////////////////////////
1:         // The generated grouping columns of the left result set should not be
1:         // part of the result from the set operation (DERBY-3764).
0:         resultColumns.removeGeneratedGroupingColumns();
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ba1b7ec
/////////////////////////////////////////////////////////////////////////
1: 					types[i] = rc.getExpression().getTypeServices();
commit:03eae1d
/////////////////////////////////////////////////////////////////////////
1: abstract class SetOperatorNode extends TableOperatorNode
/////////////////////////////////////////////////////////////////////////
1: 	private PredicateList leftOptPredicates;
1: 	private PredicateList rightOptPredicates;
1: 	private PredicateList pushedPredicates;
0: 	private HashMap leftScopedPreds;
0: 	private HashMap rightScopedPreds;
/////////////////////////////////////////////////////////////////////////
1: 	PredicateList getLeftOptPredicateList()
/////////////////////////////////////////////////////////////////////////
1: 	PredicateList getRightOptPredicateList()
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:002cd88
/////////////////////////////////////////////////////////////////////////
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0: 				//collation of ? operand should be same as the compilation schema
0: 				rc.getExpression().setCollationUsingCompilationSchema(
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 				//collation of ? operand should be same as the current schema
0: 				rc.getExpression().getTypeServices().setCollationDerivation(
0: 						StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 				rc.getExpression().getTypeServices().setCollationType(
0: 						getLanguageConnectionContext().getDefaultSchema()
0: 								.getCollationType());
author:Army
-------------------------------------------------------------------------------
commit:0787955
/////////////////////////////////////////////////////////////////////////
1: 	 * This method is used during binding of EXISTS predicates to map
1: 	 * a subquery's result column list into a single TRUE node.  For
1: 	 * SELECT and VALUES subqueries this transformation is pretty
1: 	 * straightforward.  But for set operators (ex. INTERSECT) we have
1: 	 * to do some extra work.  To see why, assume we have the following
1: 	 * query:
1: 	 *
1: 	 *  select * from ( values 'BAD' ) as T
1: 	 *    where exists ((values 1) intersect (values 2))
1: 	 *
1: 	 * If we treated the INTERSECT in this query the same way that we
1: 	 * treat SELECT/VALUES subqueries then the above query would get
1: 	 * transformed into:
1: 	 *
1: 	 *  select * from ( values 'BAD' ) as T
1: 	 *    where ((values TRUE) intersect (values TRUE))
1: 	 *
1: 	 * Since both children of the INTERSECT would then have the same value,
1: 	 * the result of set operation would be a single value (TRUE), which
1: 	 * means the WHERE clause would evaluate to TRUE and thus the query
1: 	 * would return one row with value 'BAD'.  That would be wrong.
1: 	 *
1: 	 * To avoid this problem, we internally wrap this SetOperatorNode
1: 	 * inside a "SELECT *" subquery and then we change the new SelectNode's
1: 	 * result column list (as opposed to *this* nodes' result column list)
1: 	 * to a singe boolean true node:
1: 	 *
1: 	 *  select * from ( values 'BAD' ) as T where
1: 	 *      SELECT TRUE FROM ((values 1) intersect (values 2))
1: 	 *
1: 	 * In this case the left and right children of the INTERSECT retain
1: 	 * their values, which ensures that the result of the intersect
1: 	 * operation will be correct.  Since (1 intersect 2) is an empty
1: 	 * result set, the internally generated SELECT node will return
1: 	 * zero rows, which in turn means the WHERE predicate will return
1: 	 * NULL (an empty result set from a SubqueryNode is treated as NULL
1: 	 * at execution time; see impl/sql/execute/AnyResultSet). Since
1: 	 * NULL is not the same as TRUE the query will correctly return
1: 	 * zero rows.  DERBY-2370.
1: 	 *
0: 	public ResultSetNode setResultToBooleanTrueNode(boolean onlyConvertAlls)
1: 		throws StandardException
1: 		// First create a FromList to hold this node (and only this node).
1: 
0: 		FromList fromList =
0: 			(FromList) getNodeFactory().getNode(
0: 				C_NodeTypes.FROM_LIST,
1: 				getContextManager());
1: 
1: 		fromList.addFromTable(this);
1: 
1: 		/* It's possible that this SetOperatorNode (or more specifically,
1: 		 * one of its children) references tables from an outer query, ex:
1: 		 *
1: 		 *  select j from onerow where exists
1: 		 *    (select 1 from diffrow where 1 = 0 INTERSECT
1: 		 *      select * from diffrow where onerow.j < k)
1: 		 *
1: 		 * In this case the right child of the INTERSECT node references
1: 		 * the outer table "onerow".  In order to ensure that the new
1: 		 * subquery binds correctly we mark the new FromList as "transparent",
1: 		 * which means that the FromTables it contains (namely, this node
1: 		 * and its children) will still be able to see (and reference) the
1: 		 * outer table.
1: 		 */
1: 		fromList.markAsTransparent();
1: 
1: 		// Now create a ResultColumnList that simply holds the "*".
1: 
0: 		ResultColumnList rcl =
0: 			(ResultColumnList) getNodeFactory().getNode(
0: 				C_NodeTypes.RESULT_COLUMN_LIST,
1: 				getContextManager());
1: 
0: 		ResultColumn allResultColumn =
0: 			(ResultColumn) getNodeFactory().getNode(
0: 				C_NodeTypes.ALL_RESULT_COLUMN,
0: 				null,
1: 				getContextManager());
1: 
1: 		rcl.addResultColumn(allResultColumn);
1: 
1: 		/* Create a new SELECT node of the form:
1: 		 *  SELECT * FROM <thisSetOperatorNode>
1: 		 */
0: 		ResultSetNode result =
0: 			(ResultSetNode) getNodeFactory().getNode(
0: 				C_NodeTypes.SELECT_NODE,
1: 				rcl,      // ResultColumns
0: 				null,     // AGGREGATE list
1: 				fromList, // FROM list
1: 				null,     // WHERE clause
1: 				null,     // GROUP BY list
1: 				null,     // having clause
1: 				getContextManager());
1: 
1: 		/* And finally, transform the "*" in the new SELECT node
1: 		 * into a TRUE constant node.  This ultimately gives us:
1: 		 *
1: 		 *  SELECT TRUE FROM <thisSetOperatorNode>
1: 		 *
1: 		 * which has a single result column that is a boolean TRUE
1: 		 * constant.  So we're done.
1: 		 */
1: 		return result.setResultToBooleanTrueNode(onlyConvertAlls);
commit:0f0f8ad
/////////////////////////////////////////////////////////////////////////
1: 		 * have to generate a ProjectRestrictNode.  Note: we want to check
1: 		 * all SetOpNodes that exist in the subtree rooted at this SetOpNode.
1: 		 * Since we just modified access paths on this node, it's possible
1: 		 * that the SetOperatorNode chain (if there was one) is now "broken"
1: 		 * as a result of the insertion of new nodes.  For example, prior
1: 		 * to modification of access paths we may have a chain such as:
1: 		 *
1: 		 *                          UnionNode (0)
1: 		 *                          /       \
1: 		 *                 UnionNode (1)    SelectNode (2)
1: 		 *                 /        \ 
1: 		 *      SelectNode (3)     SelectNode (4)
1: 		 *
1: 		 * Now if UnionNode(1) did not specify "ALL" then as part of the
1: 		 * above call to modifyAccessPaths() we will have inserted a
1: 		 * DistinctNode above it, thus giving:
1: 		 *
1: 		 *                          UnionNode (0)
1: 		 *                          /       \
1: 		 *                 DistinctNode (5)  SelectNode (2)
1: 		 *                      |
1: 		 *                 UnionNode (1)
1: 		 *                 /        \ 
1: 		 *      SelectNode (3)     SelectNode (4)
1: 		 *
1: 		 * So our chain of UnionNode's has now been "broken" by an intervening
1: 		 * DistinctNode.  For this reason we can't just walk the chain of
1: 		 * SetOperatorNodes looking for unpushed predicates (because the
1: 		 * chain might be broken and then we could miss some nodes). Instead,
1: 		 * we have to get a collection of all relevant nodes that exist beneath
1: 		 * this SetOpNode and call hasUnPushedPredicates() on each one.  For
1: 		 * now we only consider UnionNodes to be "relevant" because those are
1: 		 * the only ones that might actually have unpushed predicates.
1: 		 * 
1: 		 * If we find any UnionNodes that *do* have unpushed predicates then
1: 		 * we have to use a PRN to enforce the predicate at the level of
1: 		 * this, the top-most, SetOperatorNode.
1: 
1: 		// Find all UnionNodes in the subtree.
0: 		CollectNodesVisitor cnv = new CollectNodesVisitor(UnionNode.class);
1: 		this.accept(cnv);
0: 		java.util.Vector unions = cnv.getList();
1: 
1: 		// Now see if any of them have unpushed predicates.
1: 		boolean genPRN = false;
0: 		for (int i = unions.size() - 1; i >= 0; i--)
1: 		{
0: 			if (((UnionNode)unions.get(i)).hasUnPushedPredicates())
1: 			{
1: 				genPRN = true;
1: 				break;
1: 			}
1: 		}
1: 
1: 		if (genPRN)
/////////////////////////////////////////////////////////////////////////
1: 	 * of how that can happen).  So this method determines whether
1: 	 * or not this particular SetOperatorNode has predicates which
1: 	 * were *not* successfully pushed to both of its children (note:
1: 	 * this currently only applies to UnionNodes).
1: 	 * @return True if this SetOperatorNode has unpushed predicates;
1: 	 *  false otherwise.
1: 		return
1: 			((leftOptPredicates != null) && (leftOptPredicates.size() > 0)) ||
1: 			((rightOptPredicates != null) && (rightOptPredicates.size() > 0));
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
1: 		if (leftResultSet.getResultColumns().visibleSize() !=
1: 			rightResultSet.getResultColumns().visibleSize())
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:cafb31f
/////////////////////////////////////////////////////////////////////////
1: 		/* Now see if there are any left over predicates; if so, then we
0: 		 * have to generate a ProjectRestrictNode.  Note: we walk the
0: 		 * entire chain of UnionNodes (if there is a chain) and see if
0: 		 * any UnionNode at any level has un-pushed predicates; if so, then
0: 		 * we use a PRN to enforce the predicate at this, the top-most
0: 		 * UnionNode.
1: 		 */
0: 		if (hasUnPushedPredicates())
/////////////////////////////////////////////////////////////////////////
1: 	 * It's possible that we tried to push predicates to this node's
1: 	 * children but failed to do so. This can happen if this node's
1: 	 * children both satisfy the criteria for pushing a predicate
1: 	 * (namely, they reference base tables) but the children's
1: 	 * children do not (see modifyAccessPaths() above for an example
0: 	 * of how that can happen).  So this method will walk the chain
0: 	 * of nodes beneath this one and determine if any SetOperatorNode
0: 	 * at any level has predicates that were not successfully pushed
0: 	 * to both of its children (note: this currently only applies
0: 	 * to UnionNodes).
1: 	 *
0: 	 * @return True if any UnionNode (or actually, any SetOperatorNode)
0: 	 *  in the chain of SetOperatorNodes (starting with this one) has
0: 	 *  unpushed predicates; false otherwise.
1: 	 */
1: 	protected boolean hasUnPushedPredicates()
1: 	{
1: 		// Check this node.
0: 		if (((leftOptPredicates != null) && (leftOptPredicates.size() > 0)) ||
0: 			((rightOptPredicates != null) && (rightOptPredicates.size() > 0)))
1: 		{
1: 			return true;
1: 		}
1: 
0: 		// Now check the children.
0: 		if ((leftResultSet instanceof SetOperatorNode) &&
0: 			((SetOperatorNode)leftResultSet).hasUnPushedPredicates())
1: 		{
1: 			return true;
1: 		}
1: 
0: 		return ((rightResultSet instanceof SetOperatorNode) &&
0: 			((SetOperatorNode)rightResultSet).hasUnPushedPredicates());
1: 	}
1: 
1: 	/**
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * @param colMap			int array representation of correspondence between
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:e07631a
/////////////////////////////////////////////////////////////////////////
1: 		// them as appropriate. NOTE: If our final choice for join strategy
1: 		// is a hash join, then we do not push the predicates because we'll
1: 		// need them to be at this level in order to find out which of them
1: 		// is the equijoin predicate that is required by hash join.
1: 		if ((predList != null) &&
1: 			!getTrulyTheBestAccessPath().getJoinStrategy().isHashJoin())
commit:5872305
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.AccessPath;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
/////////////////////////////////////////////////////////////////////////
0: import java.util.HashMap;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	// List of scoped predicates for pushing during optimization.
0: 	PredicateList leftOptPredicates;
0: 	PredicateList rightOptPredicates;
1: 
1: 	// List of original (unscoped) predicates that we tried to push
1: 	// during the most recent phase of optimization.
0: 	PredicateList pushedPredicates;
1: 
1: 	// Mapping of original predicates to scoped predicates, used to
1: 	// avoid re-scoping predicates unnecessarily.
0: 	HashMap leftScopedPreds;
0: 	HashMap rightScopedPreds;
/////////////////////////////////////////////////////////////////////////
1: 	 * @see Optimizable#modifyAccessPath
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Optimizable modifyAccessPath(JBitSet outerTables,
1: 		PredicateList predList) throws StandardException
1: 	{
1: 		// When we optimized this node we attempted to push predicates down to
1: 		// the children, which means the best access path for the children
1: 		// might depend on those predicates.  So now that we're preparing
1: 		// to generate the best paths, we have to push those same predicates
1: 		// down again (this is the last time) so that the children can use
0: 		// them as appropriate.
0: 		if (predList != null) 
1: 		{
1: 			for (int i = predList.size() - 1; i >= 0; i--)
1: 				if (pushOptPredicate(predList.getOptPredicate(i)))
1: 					predList.removeOptPredicate(i);
1: 		}
1: 
1: 		/*
1: 		 * It's possible that we tried to push a predicate down to this node's
1: 		 * children but failed to do so.  This can happen if this node's
1: 		 * children both match the criteria for pushing a predicate (namely,
1: 		 * they reference base tables) but the children's children do not.
1: 		 * Ex.
1: 		 *  select * from
1: 		 *    (select i,j from t2 UNION
1: 		 *      values (1,1),(2,2),(3,3),(4,4) UNION
1: 		 *      select i,j from t1
1: 		 *    ) x0 (i,j),
1: 		 *    t5 where x0.i = t5.i;
1: 		 *
1: 		 * This will yield a tree resembling the following:
1: 		 *
1: 		 *                     UNION
1: 		 *                    /     \
1: 		 *               UNION     SELECT (T1)
1: 		 *              /     \
1: 		 *        SELECT (T2)  VALUES
1: 		 *
1: 		 * In this case the top UNION ("this") will push the predicate down,
1: 		 * but the second UNION will _not_ push the predicate because
1: 		 * it can't be pushed to the VALUES clause.  This means that
1: 		 * after we're done modifying the paths for "this" node (the top
1: 		 * UNION), the predicate will still be sitting in our leftOptPredicates
1: 		 * list.  If that's the case, then we have to make sure the predicate,
1: 		 * which was _not_ enforced in the left child, is enforced at this
1: 		 * level.  We do that by generating a ProjectRestrictNode above this
1: 		 * node.  Yes, this means the predicate will actually be applied
1: 		 * twice to the right child (in this case), but that's okay as it
1: 		 * won't affect the results.
1: 		 */
1: 
1: 		// Get the cost estimate for this node so that we can put it in
1: 		// the new ProjectRestrictNode, if one is needed.
1: 		CostEstimate ce = getFinalCostEstimate();
1: 
1: 		// Modify this node's access paths.
1: 		ResultSetNode topNode = (ResultSetNode)modifyAccessPath(outerTables);
1: 
0: 		// Now see if there are any left over predicates; if so, then we
0: 		// have to generate a ProjectRestrictNode.
0: 		if (((leftOptPredicates != null) && (leftOptPredicates.size() > 0)) ||
0: 			((rightOptPredicates != null) && (rightOptPredicates.size() > 0)))
1: 		{
1: 			// When we generate the project restrict node, we pass in the
1: 			// "pushedPredicates" list because that has the predicates in
1: 			// _unscoped_ form, which means they are intended for _this_
1: 			// node instead of this node's children.  That's exactly what
1: 			// we want.
0: 			ResultSetNode prnRSN = (ResultSetNode) getNodeFactory().getNode(
0: 				C_NodeTypes.PROJECT_RESTRICT_NODE,
1: 				topNode,					// Child ResultSet
1: 				topNode.getResultColumns(),	// Projection
1: 				null,						// Restriction
1: 				pushedPredicates,			// Restriction as PredicateList
1: 				null,						// Subquerys in Projection
1: 				null,						// Subquerys in Restriction
1: 				null,						// Table properties
0: 				getContextManager());
0: 			prnRSN.costEstimate = ce.cloneMe();
1: 			prnRSN.setReferencedTableMap(topNode.getReferencedTableMap());
1: 			topNode = prnRSN;
1: 		}
1: 
1: 		return (Optimizable)topNode;
1: 	}
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.sql.compile.Optimizable#pushOptPredicate
1: 	 *
1: 	 * Take a predicate and push it down to both the left AND right result
1: 	 * sets.  Return "true" if we successfully pushed it to both sides,
1: 	 * and "false" otherwise.  The assumption is that if we return "true",
1: 	 * the caller will take the predicate and remove it from its own list
1: 	 * of predicates to evaluate; if we return false, then the predicate
1: 	 * will be evaluated at the level of the caller.  So returning "false"
1: 	 * means that the left and right result sets for this node will be fully
1: 	 * returned, and then the predicate will be evaluated against the
1: 	 * <set-operator> of those result sets (as of DERBY-805, the only set
1: 	 * operator calling this method is UnionNode).  If we can push the
1: 	 * predicate down to both children, though, we can evaluate it closer
1: 	 * to store, which means that each child result set returns only the
1: 	 * correctly qualified rows, and thus the calling set operator will
1: 	 * have a smaller result set on which to operate, which can boost
1: 	 * performance.
1: 	 *
1: 	 * That said, if we can't push the predicate to _both_ sides, we don't
1: 	 * push it at all.  The reason is that if we push to one side but not
1: 	 * to the other, we would have to ask the question of whether we should
1: 	 * return "true" (meaning that the predicate would be removed from the
1: 	 * caller's list and thus would _not_ be evaluated at the <set-operator>
1: 	 * level) or "false" (meaning that the caller would keep the predicate
1: 	 * and evaluate it at the <set-operator> level).  Depending on the query
1: 	 * in question, both answers could end up returning incorrect results.
1: 	 *
1: 	 * For example, if we push it to the right but not to the left, then
1: 	 * leave it in the caller's list, the optimizer for the caller might
1: 	 * decide to use the predicate to do a hash join with some outer result
1: 	 * set (if the predicate is an equijoin predicate).  That would result
1: 	 * in materialization of the calling node and of its children--but since
1: 	 * we pushed a predicate that depends on the outer table down into the
1: 	 * right child, materialization of the right child will only return the
1: 	 * rows that join with the _first_ row of the outer result set, which 
1: 	 * is wrong.
1: 	 *
1: 	 * If, on the other hand, we push the predicate to one side and then tell
1: 	 * the caller to remove it from its list, the side to which we did _not_
1: 	 * push the predicate could return rows that aren't qualified.  Then,
1: 	 * since the caller removed the predicate from its list, it (the caller)
1: 	 * will not evaluate the predicate on its own result set--and thus we
1: 	 * can end up returning rows that we weren't supposed to return.
1: 	 * 
1: 	 * So all of that said, only push (and return "true") if we think we
1: 	 * can push the predicate to both sides.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1: 		throws StandardException
1: 	{
1: 		// This method was added to SetOperatorNode as part of DERBY-805,
1: 		// which was only targeted for UnionNodes.  So for now, we don't
1: 		// do anything if "this" isn't a Union.  This check can be removed
1: 		// when support for other SetOperators is added.
1: 		if (!(this instanceof UnionNode))
1: 			return false;
1: 
1: 		// We only handle certain types of predicates here; if the received
1: 		// predicate doesn't qualify, then don't push it.
1: 		Predicate pred = (Predicate)optimizablePredicate;
1: 		if (!pred.pushableToSubqueries())
1: 			return false;
1: 
1: 		// Check to see if the child nodes reference any base tables; if either
1: 		// child does not reference at least one base table, then we don't try
1: 		// to push the predicate.
0: 		boolean canPush = false;
1: 
1: 		JBitSet tableNums = new JBitSet(getReferencedTableMap().size());
1: 		BaseTableNumbersVisitor btnVis =
1: 			new BaseTableNumbersVisitor(tableNums);
1: 
1: 		// Check the left child.
1: 		leftResultSet.accept(btnVis);
1: 		canPush = (tableNums.getFirstSetBit() != -1);
1: 
1: 		/* If we can't push it to _both_ children, then we don't push at all.
1: 		 * RESOLVE: We can add the ability to push a predicate to one side
1: 		 * only by putting a ProjectRestrictNode between the union node and
1: 		 * the child as a place to park the predicate. To make things simple,
1: 		 * we might want to always put ProjectRestrictNodes under both sides
1: 		 * of the union during preprocessing (i.e. after binding but before
1: 		 * optimization). In some cases the extra nodes won't be needed, but
1: 		 * PRNs (and the corresponding ProjectRestrictResultSets) are cheap.
1: 		 * Also, we could eliminate unnecessary ProjectRestrictNodes at the
1: 		 * end of optimization (possibly in modifyAccessPaths()).  Until all
1: 		 * of that is implemented, though, we only push if we can push to
1: 		 * both sides...
1: 		 */
1: 		if (!canPush)
1: 			return false;
1: 
1: 		// Check the right child.
1: 		tableNums.clearAll();
1: 		rightResultSet.accept(btnVis);
1: 		canPush = (tableNums.getFirstSetBit() != -1);
1: 		if (!canPush)
1: 			return false;
1: 
0: 		BinaryRelationalOperatorNode opNode =
0: 			(BinaryRelationalOperatorNode)pred.getAndNode().getLeftOperand();
1: 
0: 		// Note: we assume we only get here for predicates with col refs on
0: 		// both sides; if that ever changes, the following cast will need
0: 		// to be updated accordingly.
0: 		boolean opWasRemapped = 
0: 			((ColumnReference)opNode.getLeftOperand()).hasBeenRemapped();
1: 
0: 		/* If there is a ProjectRestrictNode directly above this node,
0: 		 * then the predicate in question may have been remapped to this
0: 		 * SetOperatorNode before we got here (see pushOptPredicate() in
0: 		 * ProjectRestrictNode).  If we leave it mapped when we try to
0: 		 * get scoped predicates for the left and right result sets, the
0: 		 * underlying column references of the scoped predicates will
0: 		 * effectively be doubly-mapped (i.e. mapped more than once), which
0: 		 * can cause problems at code generation time.  So we 1) un-remap
0: 		 * the predicate here, 2) get the scoped predicates, and then
0: 		 * 3) remap the predicate again at the end of this method.
1: 		 */
0: 		RemapCRsVisitor rcrv = null;
0: 		if (opWasRemapped)
1: 		{
0: 			rcrv = new RemapCRsVisitor(false);
0: 			pred.getAndNode().accept(rcrv);
1: 		}
1: 
1: 		// Get a list of all of the underlying base tables that this node
1: 		// references.  We pass this down when scoping so that we can tell
1: 		// if the operands are actually supposed to be scoped to _this_
1: 		// node's children.  Note that in order for the predicate to
1: 		// have been pushed this far, at least one of its operands must
1: 		// apply to this node--we don't know which one it is, though,
1: 		// so we use this tableNums info to figure that out.
1: 		tableNums.clearAll();
1: 		this.accept(btnVis);
1: 
1: 		/* What we want to do here is push the predicate to the left/right
1: 		 * child.  That means that we need to find the equivalent column(s)
1: 		 * in each child.
1: 		 * Ex:
1: 		 * 
1: 		 *  select * from
1: 		 *    (select i,j from t1 union select i,j from t2) X1,
1: 		 *    (select a,b from t3 union select a,b from t4) X2
1: 		 *  where X1.j = X2.b;
1: 		 *
1: 		 * In this example, X1.j maps to "t1" for the left side of the
1: 		 * union (X1) and "t2" for the right side of the union.  So we have
1: 		 * to get versions of the predicate that are appropriate to each
1: 		 * side.  That's what the call to getPredScopedForResultSet()
1: 		 * in the following code does.
1: 		 */
1: 
1: 		// See if we already have a scoped version of the predicate cached,
1: 		// and if so just use that.
1: 		Predicate scopedPred = null;
1: 		if (leftScopedPreds == null)
0: 			leftScopedPreds = new HashMap();
1: 		else
0: 			scopedPred = (Predicate)leftScopedPreds.get(pred);
1: 		if (scopedPred == null)
1: 		{
1: 			scopedPred = pred.getPredScopedForResultSet(
0: 				tableNums, leftResultSet);
1: 			leftScopedPreds.put(pred, scopedPred);
1: 		}
1: 
1: 		// Add the scoped predicate to our list for the left child.
1: 		getLeftOptPredicateList().addOptPredicate(scopedPred);
1: 
1: 		scopedPred = null;
1: 		if (rightScopedPreds == null)
0: 			rightScopedPreds = new HashMap();
1: 		else
0: 			scopedPred = (Predicate)rightScopedPreds.get(pred);
1: 		if (scopedPred == null)
1: 		{
1: 			scopedPred = pred.getPredScopedForResultSet(
0: 				tableNums, rightResultSet);
1: 			rightScopedPreds.put(pred, scopedPred);
1: 		}
1: 
1: 		// Add the scoped predicate to our list for the right child.
1: 		getRightOptPredicateList().addOptPredicate(scopedPred);
1: 
0: 		// Restore the original predicate to the way it was before we got
0: 		// here--i.e. remap it again if needed.
0: 		if (opWasRemapped)
1: 		{
0: 			rcrv = new RemapCRsVisitor(true);
0: 			pred.getAndNode().accept(rcrv);
1: 		}
1: 
1: 		// Add the predicate (in its original form) to our list of predicates
1: 		// that we've pushed during this phase of optimization.  We need to
1: 		// keep this list of pushed predicates around so that we can do
1: 		// a "pull" of them later, if needed.  We also need this list for
1: 		// cases where predicates are not pushed all the way down; see
1: 		// modifyAccessPaths() in this class for more.
1: 		if (pushedPredicates == null)
0: 			pushedPredicates = new PredicateList();
1: 
1: 		pushedPredicates.addOptPredicate(pred);
0: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * @see Optimizable#pullOptPredicates
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void pullOptPredicates(
1: 		OptimizablePredicateList optimizablePredicates)
1: 		throws StandardException
1: 	{
1: 		if (pushedPredicates == null)
1: 		// we didn't push anything, so nothing to pull.
1: 			return;
1: 
1: 		// It's possible that we tried to push a predicate down to this
1: 		// SetOperatorNode's children but weren't actually able to do so
1: 		// (see modifyAccessPaths() in this class for details on when that
1: 		// can happen).  In that case the predicates will still be sitting
1: 		// in the left/right predicate list; we can ignore them here by
1: 		// just discarding them.  When it comes time to modifyAccessPaths,
1: 		// though, we'll handle them correctly--i.e. we'll generate a
1: 		// ProjectRestrictNode over this node to ensure the predicates are
1: 		// enforced.
1: 
1: 		if (leftOptPredicates != null)
1: 			leftOptPredicates.removeAllElements();
1: 
1: 		if (rightOptPredicates != null)
1: 			rightOptPredicates.removeAllElements();
1: 
1: 		/* Note that predicates which have been explicitly scoped should
1: 		 * not be pulled.  The reason is that a scoped predicate can only
1: 		 * be pushed to a specific, target result set.  When it comes time
1: 		 * to pull the predicate up, there's no need to pull the scoped
1: 		 * predicate because it, by definition, was only intended for this
1: 		 * specific result set and therefore cannot be pushed anywhere else.
1: 		 * So at "pull" time, we can just discard the scoped predicates.  We
1: 		 * do, however, need to pull the original, unscoped predicate from
1: 		 * which the scoped predicate was created because we can potentially
1: 		 * push that predicate elsewhere
1: 		 */
0: 		Predicate pred = null;
1: 		for (int i = 0; i < pushedPredicates.size(); i++)
1: 		{
0: 			pred = (Predicate)pushedPredicates.getOptPredicate(i);
1: 			if (pred.isScopedForPush())
1: 				continue;
1: 			optimizablePredicates.addOptPredicate(pred);
1: 		}
1: 
1: 		// We're done with the pushedPredicates list, so clear it out
1: 		// in preparation for another phase of optimization.
1: 		pushedPredicates.removeAllElements();
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Retrieve the list of optimizable predicates that are
1: 	 * targeted for the left child.  Create a new (empty)
1: 	 * list if the list is null.
1: 	 */
0: 	protected PredicateList getLeftOptPredicateList()
1: 		throws StandardException
1: 	{
1: 		if (leftOptPredicates == null) {
0: 			leftOptPredicates =
0: 				(PredicateList) getNodeFactory().getNode(
0: 					C_NodeTypes.PREDICATE_LIST,
0: 					getContextManager());
1: 		}
1: 
1: 		return leftOptPredicates;
1: 	}
1: 
1: 	/**
1: 	 * Retrieve the list of optimizable predicates that are
1: 	 * targeted for the right child.  Create a new (empty)
1: 	 * list if the list is null.
1: 	 */
0: 	protected PredicateList getRightOptPredicateList()
1: 		throws StandardException
1: 	{
1: 		if (rightOptPredicates == null) {
0: 			rightOptPredicates =
0: 				(PredicateList) getNodeFactory().getNode(
0: 					C_NodeTypes.PREDICATE_LIST,
0: 					getContextManager());
1: 		}
1: 
1: 		return rightOptPredicates;
1: 	}
1: 
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 	 throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 				if ( ! (rc.getExpression().requiresTypeFromContext()))
/////////////////////////////////////////////////////////////////////////
1: 			if (rc.getExpression().requiresTypeFromContext())
1: 				rc.getExpression().setType(types[index]);
commit:47f9d0a
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.compile.SetOperatorNode
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
1: /**
1:  * A SetOperatorNode represents a UNION, INTERSECT, or EXCEPT in a DML statement. Binding and optimization
1:  * preprocessing is the same for all of these operations, so they share bind methods in this abstract class.
1:  *
1:  * The class contains a boolean telling whether the operation should eliminate
1:  * duplicate rows.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public abstract class SetOperatorNode extends TableOperatorNode
1: {
1: 	/**
1: 	** Tells whether to eliminate duplicate rows.  all == TRUE means do
1: 	** not eliminate duplicates, all == FALSE means eliminate duplicates.
1: 	*/
1: 	boolean			all;
1: 
0: 	OrderByList orderByList;
1: 
1: 
1: 	/**
0: 	 * Initializer for a SetOperatorNode.
1: 	 *
1: 	 * @param leftResult		The ResultSetNode on the left side of this union
1: 	 * @param rightResult		The ResultSetNode on the right side of this union
1: 	 * @param all				Whether or not this is an ALL.
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(
0: 					Object leftResult,
0: 					Object rightResult,
0: 					Object all,
0: 					Object tableProperties)
1: 			throws StandardException
1: 	{
0: 		super.init(leftResult, rightResult, tableProperties);
1: 
0: 		this.all = ((Boolean) all).booleanValue();
1: 
1: 		/* resultColumns cannot be null, so we make a copy of the left RCL
1: 		 * for now.  At bind() time, we need to recopy the list because there
1: 		 * may have been a "*" in the list.  (We will set the names and
1: 		 * column types at that time, as expected.)
1: 		 */
0: 		resultColumns = leftResultSet.getResultColumns().copyListAndObjects();
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return 	"all: " + all + "\n" +
0: 				"orderByList: " + 
0: 				(orderByList != null ? orderByList.toString() : "null") + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind the result columns of this ResultSetNode when there is no
1: 	 * base table to bind them to.  This is useful for SELECT statements,
1: 	 * where the result columns get their types from the expressions that
1: 	 * live under them.
1: 	 *
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void bindResultColumns(FromList fromListParam)
1: 					throws StandardException
1: 	{
1: 		super.bindResultColumns(fromListParam);
1: 
1: 		/* Now we build our RCL */
1: 		buildRCL();
1: 	}
1: 
1: 	/**
1: 	 * Bind the result columns for this ResultSetNode to a base table.
1: 	 * This is useful for INSERT and UPDATE statements, where the
1: 	 * result columns get their types from the table being updated or
1: 	 * inserted into.
1: 	 * If a result column list is specified, then the verification that the 
1: 	 * result column list does not contain any duplicates will be done when
1: 	 * binding them by name.
1: 	 *
1: 	 * @param targetTableDescriptor	The TableDescriptor for the table being
1: 	 *				updated or inserted into
1: 	 * @param targetColumnList	For INSERT statements, the user
1: 	 *					does not have to supply column
1: 	 *					names (for example, "insert into t
1: 	 *					values (1,2,3)".  When this
1: 	 *					parameter is null, it means that
1: 	 *					the user did not supply column
1: 	 *					names, and so the binding should
1: 	 *					be done based on order.  When it
1: 	 *					is not null, it means do the binding
1: 	 *					by name, not position.
1: 	 * @param statement			Calling DMLStatementNode (Insert or Update)
1: 	 * @param fromListParam		FromList to use/append to.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindResultColumns(TableDescriptor targetTableDescriptor,
0: 					FromVTI targetVTI,
0: 					ResultColumnList targetColumnList,
0: 					DMLStatementNode statement,
0: 					FromList fromListParam)
1: 				throws StandardException
1: 	{
1: 		super.bindResultColumns(targetTableDescriptor,
1: 								targetVTI,
1: 								targetColumnList, statement,
1: 								fromListParam);
1: 
1: 		/* Now we build our RCL */
1: 		buildRCL();
1: 	}
1: 
1: 	/**
1: 	 * Build the RCL for this node.  We propagate the RCL up from the
1: 	 * left child to form this node's RCL.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	private void buildRCL() throws StandardException
1: 	{
1: 		/* Verify that both sides of the union have the same # of columns in their
1: 		 * RCL.
1: 		 */
0: 		if (leftResultSet.getResultColumns().size() !=
0: 			rightResultSet.getResultColumns().size())
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_UNION_UNMATCHED_COLUMNS,
1:                                                  getOperatorName());
1: 		}
1: 
1: 		/* We need to recreate resultColumns for this node, since there
1: 		 * may have been 1 or more *'s in the left's SELECT list.
1: 		 */
0: 		resultColumns = leftResultSet.getResultColumns().copyListAndObjects();
1: 
1: 		/* Create new expressions with the dominant types after verifying
1: 		 * union compatibility between left and right sides.
1: 		 */
0: 		resultColumns.setUnionResultExpression(rightResultSet.getResultColumns(), tableNumber, level, getOperatorName());
1: 	}
1: 
1: 	/**
1: 	 * Bind the result columns of a table constructor to the types in the
1: 	 * given ResultColumnList.  Use when inserting from a table constructor,
1: 	 * and there are nulls in the values clauses.
1: 	 *
1: 	 * @param rcl	The ResultColumnList with the types to bind to
1: 	 *
1: 	 * @exception StandardException		Thrown on error.
1: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList rcl)
1: 				throws StandardException
1: 	{
1: 		/*
1: 		** If the RCL from the parent is null, then
1: 		** the types are coming from the union itself.
1: 		** So we have to cross check the two child
1: 		** rcls.
1: 		*/
1: 		if (rcl == null)
1: 		{
1: 			ResultColumnList lrcl = rightResultSet.getResultColumns();
1: 			ResultColumnList rrcl = leftResultSet.getResultColumns();
1: 
1: 			leftResultSet.bindUntypedNullsToResultColumns(rrcl);
1: 			rightResultSet.bindUntypedNullsToResultColumns(lrcl);
1: 		}
1: 		else	
1: 		{
1: 			leftResultSet.bindUntypedNullsToResultColumns(rcl);
1: 			rightResultSet.bindUntypedNullsToResultColumns(rcl);
1: 		}			
1: 	}
1: 
1: 	/**
1: 	 * Get the parameter types from the given RowResultSetNode into the
1: 	 * given array of types.  If an array position is already filled in,
1: 	 * don't clobber it.
1: 	 *
1: 	 * @param types	The array of types to fill in
1: 	 * @param rrsn	The RowResultSetNode from which to take the param types
1: 	 *
1: 	 * @return	The number of new types found in the RowResultSetNode
1: 	 */
1: 	int getParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
1: 	{
1: 		int	numTypes = 0;
1: 
1: 		/* Look for columns where we have not found a non-? yet. */
1: 		for (int i = 0; i < types.length; i++)
1: 		{
1: 			if (types[i] == null)
1: 			{
0: 				ResultColumn rc =
0: 					(ResultColumn) rrsn.getResultColumns().elementAt(i);
0: 				if ( ! (rc.getExpression().isParameterNode()))
1: 				{
0: 					types[i] = rc.getExpressionType();
1: 					numTypes++;
1: 				}
1: 			}
1: 		}
1: 
1: 		return numTypes;
1: 	}
1: 
1: 	/**
1: 	 * Set the type of each ? parameter in the given RowResultSetNode
1: 	 * according to its ordinal position in the given array of types.
1: 	 *
1: 	 * @param types	An array of types containing the proper type for each
1: 	 *				? parameter, by ordinal position.
1: 	 * @param rrsn	A RowResultSetNode that could contain ? parameters whose
1: 	 *				types need to be set.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void setParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
1: 					throws StandardException
1: 	{
1: 		/*
1: 		** Look for ? parameters in the result column list
1: 		** of each RowResultSetNode
1: 		*/
1: 		ResultColumnList rrcl = rrsn.getResultColumns();
1: 		int rrclSize = rrcl.size();
1: 		for (int index = 0; index < rrclSize; index++)
1: 		{
0: 			ResultColumn	rc = (ResultColumn) rrcl.elementAt(index);
1: 
0: 			if (rc.getExpression().isParameterNode())
1: 			{
1: 				/*
1: 				** We found a ? - set its type to the type from the
1: 				** type array.
1: 				*/
0: 				((ParameterNode) rc.getExpression()).setDescriptor(
0: 											types[index]);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind the expressions in the target list.  This means binding the
1: 	 * sub-expressions, as well as figuring out what the return type is
1: 	 * for each expression.  This is useful for EXISTS subqueries, where we
1: 	 * need to validate the target list before blowing it away and replacing
1: 	 * it with a SELECT true.
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void bindTargetExpressions(FromList fromListParam)
1: 					throws StandardException
1: 	{
1: 		leftResultSet.bindTargetExpressions(fromListParam);
1: 		rightResultSet.bindTargetExpressions(fromListParam);
1: 	}
1: 
1: 	/**
1: 	 * Push the order by list down from the cursor node
1: 	 * into its child result set so that the optimizer
1: 	 * has all of the information that it needs to 
1: 	 * consider sort avoidance.
1: 	 *
1: 	 * @param orderByList	The order by list
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void pushOrderByList(OrderByList orderByList)
1: 	{
0: 		this.orderByList = orderByList;
1: 	}
1: 
1: 	/** 
1: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1: 	 * that ResultColumn must percolate up to the new PRN.  However,
1: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1: 	 * which points to the FromTable and the ResultColumn that is the source for
1: 	 * the ColumnReference.  
1: 	 * (The new PRN will have the original of the ResultColumnList and
1: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1: 	 * will remain at the FromTable, with the PRN getting a new 
1: 	 * VirtualColumnNode for each ResultColumn.expression.)
1: 	 * We then project out the non-referenced columns.  If there are no referenced
1: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1: 	 * whose expression is 1.
1: 	 *
1: 	 * @param numTables			Number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 * @param fromList			The from list, if any
1: 	 *
1: 	 * @return The preprocessed ResultSetNode that can be optimized
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public ResultSetNode preprocess(int numTables,
1: 									GroupByList gbl,
1: 									FromList fromList)
1: 								throws StandardException
1: 	{
1: 		ResultSetNode newTop = this;
1: 
1: 		/* RESOLVE - what does numTables and referencedTableMap mean here? */
1: 		leftResultSet = leftResultSet.preprocess(numTables, gbl, fromList);
1: 		rightResultSet = rightResultSet.preprocess(numTables, gbl, fromList);
1: 
1: 		/* Build the referenced table map (left || right) */
0: 		referencedTableMap = (JBitSet) leftResultSet.getReferencedTableMap().clone();
0: 		referencedTableMap.or((JBitSet) rightResultSet.getReferencedTableMap());
1: 
1: 		/* If this is a UNION without an all and we have
1: 		 * an order by then we can consider eliminating the sort for the
1: 		 * order by.  All of the columns in the order by list must
1: 		 * be ascending in order to do this.  There are 2 cases:
1: 		 *	o	The order by list is an in order prefix of the columns
1: 		 *		in the select list.  In this case the output of the
1: 		 *		sort from the distinct will be in the right order
1: 		 *		so we simply eliminate the order by list.
1: 		 *	o	The order by list is a subset of the columns in the
1: 		 *		the select list.  In this case we need to reorder the
1: 		 *		columns in the select list so that the ordering columns
1: 		 *		are an in order prefix of the select list and put a PRN
1: 		 *		above the select so that the shape of the result set
1: 		 *		is as expected.
1: 		 */
0: 		if ((! all) && orderByList != null && orderByList.allAscending())
1: 		{
0: 			/* Order by list currently restricted to columns in select
0: 			 * list, so we will always eliminate the order by here.
1: 			 */
0: 			if (orderByList.isInOrderPrefix(resultColumns))
1: 			{
0: 				orderByList = null;
1: 			}
0: 			/* RESOLVE - We currently only eliminate the order by if it is
0: 			 * a prefix of the select list.  We do not currently do the 
0: 			 * elimination if the order by is not a prefix because the code
0: 			 * doesn't work.  The problem has something to do with the
0: 			 * fact that we generate additional nodes between the union
0: 			 * and the PRN (for reordering that we would generate here)
0: 			 * when modifying the access paths.  VCNs under the PRN can be
0: 			 * seen as correlated since their source resultset is the Union
0: 			 * which is no longer the result set directly under them.  This
0: 			 * causes the wrong code to get generated. (jerry - 11/3/98)
0: 			 * (bug 59)
1: 			 */
1: 		}
1: 
1: 		return newTop;
1: 	}
1: 	
1: 	/**
1: 	 * Ensure that the top of the RSN tree has a PredicateList.
1: 	 *
1: 	 * @param numTables			The number of tables in the query.
1: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
1: 		throws StandardException
1: 	{
1: 		return genProjectRestrict(numTables);
1: 	}
1: 
1: 	/**
1: 	 * Verify that a SELECT * is valid for this type of subquery.
1: 	 *
1: 	 * @param outerFromList	The FromList from the outer query block(s)
1: 	 * @param subqueryType	The subquery type
1: 	 *
0: 	 * @return	None
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void verifySelectStarSubquery(FromList outerFromList, int subqueryType) 
1: 					throws StandardException
1: 	{
1: 		/* Check both sides - SELECT * is not valid on either side */
1: 		leftResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
1: 		rightResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
1: 	}
1: 
1: 	/** 
1: 	 * Determine whether or not the specified name is an exposed name in
1: 	 * the current query block.
1: 	 *
1: 	 * @param name	The specified name to search for as an exposed name.
1: 	 * @param schemaName	Schema name, if non-null.
1: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
1: 	 *						names or match on table id.
1: 	 *
1: 	 * @return The FromTable, if any, with the exposed name.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
1: 		throws StandardException
1: 	{
1: 		/* We search both sides for a TableOperatorNode (join nodes)
1: 		 * but only the left side for a UnionNode.
1: 		 */
1: 		return leftResultSet.getFromTableByName(name, schemaName, exactMatch);
1: 	}
1: 
1: 	/**
1: 	 * Set the result column for the subquery to a boolean true,
1: 	 * Useful for transformations such as
1: 	 * changing:
1: 	 *		where exists (select ... from ...) 
1: 	 * to:
1: 	 *		where (select true from ...)
1: 	 *
1: 	 * NOTE: No transformation is performed if the ResultColumn.expression is
1: 	 * already the correct boolean constant.
1: 	 * 
1: 	 * @param onlyConvertAlls	Boolean, whether or not to just convert *'s
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void setResultToBooleanTrueNode(boolean onlyConvertAlls)
1: 				throws StandardException
1: 	{
0: 		super.setResultToBooleanTrueNode(onlyConvertAlls);
0: 		leftResultSet.setResultToBooleanTrueNode(onlyConvertAlls);
0: 		rightResultSet.setResultToBooleanTrueNode(onlyConvertAlls);
1: 	}
1: 
1: 	/**
0: 	 * This ResultSet is the source for an Insert.  The target RCL
0: 	 * is in a different order and/or a superset of this RCL.  In most cases
0: 	 * we will reorder and/or add defaults to the current RCL so that is
0: 	 * matches the target RCL.  Those RSNs whose generate() method does
0: 	 * not handle projects will insert a PRN, with a new RCL which matches
0: 	 * the target RCL, above the current RSN.
0: 	 * NOTE - The new or enhanced RCL will be fully bound.
1: 	 *
0: 	 * @param numTargetColumns	# of columns in target RCL
0: 	 * @param colMap[]			int array representation of correspondence between
0: 	 *							RCLs - colmap[i] = -1 -> missing in current RCL
0: 	 *								   colmap[i] = j -> targetRCL(i) <-> thisRCL(j+1)
0: 	 * @param dataDictionary	DataDictionary to use
0: 	 * @param targetTD			TableDescriptor for target if the target is not a VTI, null if a VTI
0:      * @param targetVTI         Target description if it is a VTI, null if not a VTI
1: 	 *
0: 	 * @return ResultSetNode	The new top of the tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode enhanceRCLForInsert(int numTargetColumns, int[] colMap, 
0: 											 DataDictionary dataDictionary,
0: 											 TableDescriptor targetTD,
0:                                              FromVTI targetVTI)
1: 			throws StandardException
1: 	{
0: 		// our newResultCols are put into the bound form straight away.
0: 		ResultColumnList newResultCols =
0: 								(ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
0: 		int numResultSetColumns = resultColumns.size();
1: 
0: 		/* Create a massaged version of the source RCL.
0: 		 * (Much simpler to build new list and then assign to source,
0: 		 * rather than massage the source list in place.)
1: 		 */
0: 		for (int index = 0; index < numTargetColumns; index++)
1: 		{
0: 			ResultColumn	newResultColumn;
0: 			ResultColumn	oldResultColumn;
0: 			ColumnReference newColumnReference;
1: 
0: 			if (colMap[index] != -1)
1: 			{
0: 				// getResultColumn uses 1-based positioning, so offset the colMap entry appropriately
0: 				oldResultColumn = resultColumns.getResultColumn(colMap[index]+1);
1: 
0: 				newColumnReference = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												oldResultColumn.getName(),
0: 												null,
0: 												getContextManager());
0: 				/* The ColumnReference points to the source of the value */
0: 				newColumnReference.setSource(oldResultColumn);
0: 				// colMap entry is 0-based, columnId is 1-based.
0: 				newColumnReference.setType(oldResultColumn.getExpressionType());
1: 
0: 				// Source of an insert, so nesting levels must be 0
0: 				newColumnReference.setNestingLevel(0);
0: 				newColumnReference.setSourceLevel(0);
1: 
0: 				// because the insert already copied the target table's
0: 				// column descriptors into the result, we grab it from there.
0: 				// alternatively, we could do what the else clause does,
0: 				// and look it up in the DD again.
0: 				newResultColumn = (ResultColumn) getNodeFactory().getNode(
0: 						C_NodeTypes.RESULT_COLUMN,
0: 						oldResultColumn.getType(),
0: 						newColumnReference,
0: 						getContextManager());
1: 			}
1: 			else
1: 			{
0: 				newResultColumn = genNewRCForInsert(targetTD, targetVTI, index + 1, dataDictionary);
1: 			}
1: 
0: 			newResultCols.addResultColumn(newResultColumn);
1: 		}
1: 
0: 		/* The generated ProjectRestrictNode now has the ResultColumnList
0: 		 * in the order that the InsertNode expects.
0: 		 * NOTE: This code here is an exception to several "rules":
0: 		 *		o  This is the only ProjectRestrictNode that is currently
0: 		 *		   generated outside of preprocess().
0: 		 *	    o  The UnionNode is the only node which is not at the
0: 		 *		   top of the query tree which has ColumnReferences under
0: 		 *		   its ResultColumnList prior to expression push down.
1: 		 */
0: 		return (ResultSetNode) getNodeFactory().getNode(
0: 									C_NodeTypes.PROJECT_RESTRICT_NODE,
0: 									this,
0: 									newResultCols,
0: 									null,
0: 									null,
0: 									null,
0: 									null,
0: 									tableProperties,
0: 									getContextManager());
1: 	}
1: 
1: 	/**
1: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
1: 	 * Currently, a FSqry is flattenable if all of the following are true:
1: 	 *		o  Subquery is a SelectNode. (ie, not a RowResultSetNode or a UnionNode)
1: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
1: 	 *		o  It does not contain a group by or having clause
1: 	 *		o  It does not contain aggregates.
1: 	 *
1: 	 * @param fromList	The outer from list
1: 	 *
1: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
1: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
1: 	{
1: 		/* Unions in FromSubquerys are not flattenable.	 */
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Return whether or not to materialize this ResultSet tree.
1: 	 *
1: 	 * @return Whether or not to materialize this ResultSet tree.
1: 	 *			would return valid results.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean performMaterialization(JBitSet outerTables)
1: 		throws StandardException
1: 	{
1: 		// RESOLVE - just say no to materialization right now - should be a cost based decision
1: 		return false;
1: 
1: 		/* Actual materialization, if appropriate, will be placed by our parent PRN.
1: 		 * This is because PRN might have a join condition to apply.  (Materialization
1: 		 * can only occur before that.
1: 		 */
1: 		//return true;
1: 	}
1: 
1:     /**
1:      * @return the operator name: "UNION", "INTERSECT", or "EXCEPT"
1:      */
1:     abstract String getOperatorName();
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Derby - Class org.apache.derby.impl.sql.compile.SetOperatorNode
0: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: /**
0:  * A SetOperatorNode represents a UNION, INTERSECT, or EXCEPT in a DML statement. Binding and optimization
0:  * preprocessing is the same for all of these operations, so they share bind methods in this abstract class.
0:  *
0:  * The class contains a boolean telling whether the operation should eliminate
0:  * duplicate rows.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public abstract class SetOperatorNode extends TableOperatorNode
0: {
0: 	/**
0: 	** Tells whether to eliminate duplicate rows.  all == TRUE means do
0: 	** not eliminate duplicates, all == FALSE means eliminate duplicates.
0: 	*/
0: 	boolean			all;
0: 
0: 	OrderByList orderByList;
0: 
0: 
0: 	/**
0: 	 * Initializer for a SetOperatorNode.
0: 	 *
0: 	 * @param leftResult		The ResultSetNode on the left side of this union
0: 	 * @param rightResult		The ResultSetNode on the right side of this union
0: 	 * @param all				Whether or not this is an ALL.
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(
0: 					Object leftResult,
0: 					Object rightResult,
0: 					Object all,
0: 					Object tableProperties)
0: 			throws StandardException
0: 	{
0: 		super.init(leftResult, rightResult, tableProperties);
0: 
0: 		this.all = ((Boolean) all).booleanValue();
0: 
0: 		/* resultColumns cannot be null, so we make a copy of the left RCL
0: 		 * for now.  At bind() time, we need to recopy the list because there
0: 		 * may have been a "*" in the list.  (We will set the names and
0: 		 * column types at that time, as expected.)
0: 		 */
0: 		resultColumns = leftResultSet.getResultColumns().copyListAndObjects();
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return 	"all: " + all + "\n" +
0: 				"orderByList: " + 
0: 				(orderByList != null ? orderByList.toString() : "null") + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind the result columns of this ResultSetNode when there is no
0: 	 * base table to bind them to.  This is useful for SELECT statements,
0: 	 * where the result columns get their types from the expressions that
0: 	 * live under them.
0: 	 *
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void bindResultColumns(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		super.bindResultColumns(fromListParam);
0: 
0: 		/* Now we build our RCL */
0: 		buildRCL();
0: 	}
0: 
0: 	/**
0: 	 * Bind the result columns for this ResultSetNode to a base table.
0: 	 * This is useful for INSERT and UPDATE statements, where the
0: 	 * result columns get their types from the table being updated or
0: 	 * inserted into.
0: 	 * If a result column list is specified, then the verification that the 
0: 	 * result column list does not contain any duplicates will be done when
0: 	 * binding them by name.
0: 	 *
0: 	 * @param targetTableDescriptor	The TableDescriptor for the table being
0: 	 *				updated or inserted into
0: 	 * @param targetColumnList	For INSERT statements, the user
0: 	 *					does not have to supply column
0: 	 *					names (for example, "insert into t
0: 	 *					values (1,2,3)".  When this
0: 	 *					parameter is null, it means that
0: 	 *					the user did not supply column
0: 	 *					names, and so the binding should
0: 	 *					be done based on order.  When it
0: 	 *					is not null, it means do the binding
0: 	 *					by name, not position.
0: 	 * @param statement			Calling DMLStatementNode (Insert or Update)
0: 	 * @param fromListParam		FromList to use/append to.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindResultColumns(TableDescriptor targetTableDescriptor,
0: 					FromVTI targetVTI,
0: 					ResultColumnList targetColumnList,
0: 					DMLStatementNode statement,
0: 					FromList fromListParam)
0: 				throws StandardException
0: 	{
0: 		super.bindResultColumns(targetTableDescriptor,
0: 								targetVTI,
0: 								targetColumnList, statement,
0: 								fromListParam);
0: 
0: 		/* Now we build our RCL */
0: 		buildRCL();
0: 	}
0: 
0: 	/**
0: 	 * Build the RCL for this node.  We propagate the RCL up from the
0: 	 * left child to form this node's RCL.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	private void buildRCL() throws StandardException
0: 	{
0: 		/* Verify that both sides of the union have the same # of columns in their
0: 		 * RCL.
0: 		 */
0: 		if (leftResultSet.getResultColumns().size() !=
0: 			rightResultSet.getResultColumns().size())
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_UNION_UNMATCHED_COLUMNS,
0:                                                  getOperatorName());
0: 		}
0: 
0: 		/* We need to recreate resultColumns for this node, since there
0: 		 * may have been 1 or more *'s in the left's SELECT list.
0: 		 */
0: 		resultColumns = leftResultSet.getResultColumns().copyListAndObjects();
0: 
0: 		/* Create new expressions with the dominant types after verifying
0: 		 * union compatibility between left and right sides.
0: 		 */
0: 		resultColumns.setUnionResultExpression(rightResultSet.getResultColumns(), tableNumber, level, getOperatorName());
0: 	}
0: 
0: 	/**
0: 	 * Bind the result columns of a table constructor to the types in the
0: 	 * given ResultColumnList.  Use when inserting from a table constructor,
0: 	 * and there are nulls in the values clauses.
0: 	 *
0: 	 * @param rcl	The ResultColumnList with the types to bind to
0: 	 *
0: 	 * @exception StandardException		Thrown on error.
0: 	 */
0: 	public void bindUntypedNullsToResultColumns(ResultColumnList rcl)
0: 				throws StandardException
0: 	{
0: 		/*
0: 		** If the RCL from the parent is null, then
0: 		** the types are coming from the union itself.
0: 		** So we have to cross check the two child
0: 		** rcls.
0: 		*/
0: 		if (rcl == null)
0: 		{
0: 			ResultColumnList lrcl = rightResultSet.getResultColumns();
0: 			ResultColumnList rrcl = leftResultSet.getResultColumns();
0: 
0: 			leftResultSet.bindUntypedNullsToResultColumns(rrcl);
0: 			rightResultSet.bindUntypedNullsToResultColumns(lrcl);
0: 		}
0: 		else	
0: 		{
0: 			leftResultSet.bindUntypedNullsToResultColumns(rcl);
0: 			rightResultSet.bindUntypedNullsToResultColumns(rcl);
0: 		}			
0: 	}
0: 
0: 	/**
0: 	 * Get the parameter types from the given RowResultSetNode into the
0: 	 * given array of types.  If an array position is already filled in,
0: 	 * don't clobber it.
0: 	 *
0: 	 * @param types	The array of types to fill in
0: 	 * @param rrsn	The RowResultSetNode from which to take the param types
0: 	 *
0: 	 * @return	The number of new types found in the RowResultSetNode
0: 	 */
0: 	int getParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
0: 	{
0: 		int	numTypes = 0;
0: 
0: 		/* Look for columns where we have not found a non-? yet. */
0: 		for (int i = 0; i < types.length; i++)
0: 		{
0: 			if (types[i] == null)
0: 			{
0: 				ResultColumn rc =
0: 					(ResultColumn) rrsn.getResultColumns().elementAt(i);
0: 				if ( ! (rc.getExpression().isParameterNode()))
0: 				{
0: 					types[i] = rc.getExpressionType();
0: 					numTypes++;
0: 				}
0: 			}
0: 		}
0: 
0: 		return numTypes;
0: 	}
0: 
0: 	/**
0: 	 * Set the type of each ? parameter in the given RowResultSetNode
0: 	 * according to its ordinal position in the given array of types.
0: 	 *
0: 	 * @param types	An array of types containing the proper type for each
0: 	 *				? parameter, by ordinal position.
0: 	 * @param rrsn	A RowResultSetNode that could contain ? parameters whose
0: 	 *				types need to be set.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void setParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
0: 					throws StandardException
0: 	{
0: 		/*
0: 		** Look for ? parameters in the result column list
0: 		** of each RowResultSetNode
0: 		*/
0: 		ResultColumnList rrcl = rrsn.getResultColumns();
0: 		int rrclSize = rrcl.size();
0: 		for (int index = 0; index < rrclSize; index++)
0: 		{
0: 			ResultColumn	rc = (ResultColumn) rrcl.elementAt(index);
0: 
0: 			if (rc.getExpression().isParameterNode())
0: 			{
0: 				/*
0: 				** We found a ? - set its type to the type from the
0: 				** type array.
0: 				*/
0: 				((ParameterNode) rc.getExpression()).setDescriptor(
0: 											types[index]);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind the expressions in the target list.  This means binding the
0: 	 * sub-expressions, as well as figuring out what the return type is
0: 	 * for each expression.  This is useful for EXISTS subqueries, where we
0: 	 * need to validate the target list before blowing it away and replacing
0: 	 * it with a SELECT true.
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void bindTargetExpressions(FromList fromListParam)
0: 					throws StandardException
0: 	{
0: 		leftResultSet.bindTargetExpressions(fromListParam);
0: 		rightResultSet.bindTargetExpressions(fromListParam);
0: 	}
0: 
0: 	/**
0: 	 * Push the order by list down from the cursor node
0: 	 * into its child result set so that the optimizer
0: 	 * has all of the information that it needs to 
0: 	 * consider sort avoidance.
0: 	 *
0: 	 * @param orderByList	The order by list
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void pushOrderByList(OrderByList orderByList)
0: 	{
0: 		this.orderByList = orderByList;
0: 	}
0: 
0: 	/** 
0: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
0: 	 * ColumnReferences must continue to point to the same ResultColumn, so
0: 	 * that ResultColumn must percolate up to the new PRN.  However,
0: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
0: 	 * which points to the FromTable and the ResultColumn that is the source for
0: 	 * the ColumnReference.  
0: 	 * (The new PRN will have the original of the ResultColumnList and
0: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
0: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
0: 	 * will remain at the FromTable, with the PRN getting a new 
0: 	 * VirtualColumnNode for each ResultColumn.expression.)
0: 	 * We then project out the non-referenced columns.  If there are no referenced
0: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
0: 	 * whose expression is 1.
0: 	 *
0: 	 * @param numTables			Number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return The preprocessed ResultSetNode that can be optimized
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList)
0: 								throws StandardException
0: 	{
0: 		ResultSetNode newTop = this;
0: 
0: 		/* RESOLVE - what does numTables and referencedTableMap mean here? */
0: 		leftResultSet = leftResultSet.preprocess(numTables, gbl, fromList);
0: 		rightResultSet = rightResultSet.preprocess(numTables, gbl, fromList);
0: 
0: 		/* Build the referenced table map (left || right) */
0: 		referencedTableMap = (JBitSet) leftResultSet.getReferencedTableMap().clone();
0: 		referencedTableMap.or((JBitSet) rightResultSet.getReferencedTableMap());
0: 
0: 		/* If this is a UNION without an all and we have
0: 		 * an order by then we can consider eliminating the sort for the
0: 		 * order by.  All of the columns in the order by list must
0: 		 * be ascending in order to do this.  There are 2 cases:
0: 		 *	o	The order by list is an in order prefix of the columns
0: 		 *		in the select list.  In this case the output of the
0: 		 *		sort from the distinct will be in the right order
0: 		 *		so we simply eliminate the order by list.
0: 		 *	o	The order by list is a subset of the columns in the
0: 		 *		the select list.  In this case we need to reorder the
0: 		 *		columns in the select list so that the ordering columns
0: 		 *		are an in order prefix of the select list and put a PRN
0: 		 *		above the select so that the shape of the result set
0: 		 *		is as expected.
0: 		 */
0: 		if ((! all) && orderByList != null && orderByList.allAscending())
0: 		{
0: 			/* Order by list currently restricted to columns in select
0: 			 * list, so we will always eliminate the order by here.
0: 			 */
0: 			if (orderByList.isInOrderPrefix(resultColumns))
0: 			{
0: 				orderByList = null;
0: 			}
0: 			/* RESOLVE - We currently only eliminate the order by if it is
0: 			 * a prefix of the select list.  We do not currently do the 
0: 			 * elimination if the order by is not a prefix because the code
0: 			 * doesn't work.  The problem has something to do with the
0: 			 * fact that we generate additional nodes between the union
0: 			 * and the PRN (for reordering that we would generate here)
0: 			 * when modifying the access paths.  VCNs under the PRN can be
0: 			 * seen as correlated since their source resultset is the Union
0: 			 * which is no longer the result set directly under them.  This
0: 			 * causes the wrong code to get generated. (jerry - 11/3/98)
0: 			 * (bug 59)
0: 			 */
0: 		}
0: 
0: 		return newTop;
0: 	}
0: 	
0: 	/**
0: 	 * Ensure that the top of the RSN tree has a PredicateList.
0: 	 *
0: 	 * @param numTables			The number of tables in the query.
0: 	 * @return ResultSetNode	A RSN tree with a node which has a PredicateList on top.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode ensurePredicateList(int numTables) 
0: 		throws StandardException
0: 	{
0: 		return genProjectRestrict(numTables);
0: 	}
0: 
0: 	/**
0: 	 * Verify that a SELECT * is valid for this type of subquery.
0: 	 *
0: 	 * @param outerFromList	The FromList from the outer query block(s)
0: 	 * @param subqueryType	The subquery type
0: 	 *
0: 	 * @return	None
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void verifySelectStarSubquery(FromList outerFromList, int subqueryType) 
0: 					throws StandardException
0: 	{
0: 		/* Check both sides - SELECT * is not valid on either side */
0: 		leftResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
0: 		rightResultSet.verifySelectStarSubquery(outerFromList, subqueryType);
0: 	}
0: 
0: 	/** 
0: 	 * Determine whether or not the specified name is an exposed name in
0: 	 * the current query block.
0: 	 *
0: 	 * @param name	The specified name to search for as an exposed name.
0: 	 * @param schemaName	Schema name, if non-null.
0: 	 * @param exactMatch	Whether or not we need an exact match on specified schema and table
0: 	 *						names or match on table id.
0: 	 *
0: 	 * @return The FromTable, if any, with the exposed name.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	protected FromTable getFromTableByName(String name, String schemaName, boolean exactMatch)
0: 		throws StandardException
0: 	{
0: 		/* We search both sides for a TableOperatorNode (join nodes)
0: 		 * but only the left side for a UnionNode.
0: 		 */
0: 		return leftResultSet.getFromTableByName(name, schemaName, exactMatch);
0: 	}
0: 
0: 	/**
0: 	 * Set the result column for the subquery to a boolean true,
0: 	 * Useful for transformations such as
0: 	 * changing:
0: 	 *		where exists (select ... from ...) 
0: 	 * to:
0: 	 *		where (select true from ...)
0: 	 *
0: 	 * NOTE: No transformation is performed if the ResultColumn.expression is
0: 	 * already the correct boolean constant.
0: 	 * 
0: 	 * @param onlyConvertAlls	Boolean, whether or not to just convert *'s
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setResultToBooleanTrueNode(boolean onlyConvertAlls)
0: 				throws StandardException
0: 	{
0: 		super.setResultToBooleanTrueNode(onlyConvertAlls);
0: 		leftResultSet.setResultToBooleanTrueNode(onlyConvertAlls);
0: 		rightResultSet.setResultToBooleanTrueNode(onlyConvertAlls);
0: 	}
0: 
0: 	/**
0: 	 * This ResultSet is the source for an Insert.  The target RCL
0: 	 * is in a different order and/or a superset of this RCL.  In most cases
0: 	 * we will reorder and/or add defaults to the current RCL so that is
0: 	 * matches the target RCL.  Those RSNs whose generate() method does
0: 	 * not handle projects will insert a PRN, with a new RCL which matches
0: 	 * the target RCL, above the current RSN.
0: 	 * NOTE - The new or enhanced RCL will be fully bound.
0: 	 *
0: 	 * @param numTargetColumns	# of columns in target RCL
0: 	 * @param colMap[]			int array representation of correspondence between
0: 	 *							RCLs - colmap[i] = -1 -> missing in current RCL
0: 	 *								   colmap[i] = j -> targetRCL(i) <-> thisRCL(j+1)
0: 	 * @param dataDictionary	DataDictionary to use
0: 	 * @param targetTD			TableDescriptor for target if the target is not a VTI, null if a VTI
0:      * @param targetVTI         Target description if it is a VTI, null if not a VTI
0: 	 *
0: 	 * @return ResultSetNode	The new top of the tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode enhanceRCLForInsert(int numTargetColumns, int[] colMap, 
0: 											 DataDictionary dataDictionary,
0: 											 TableDescriptor targetTD,
0:                                              FromVTI targetVTI)
0: 			throws StandardException
0: 	{
0: 		// our newResultCols are put into the bound form straight away.
0: 		ResultColumnList newResultCols =
0: 								(ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
0: 		int numResultSetColumns = resultColumns.size();
0: 
0: 		/* Create a massaged version of the source RCL.
0: 		 * (Much simpler to build new list and then assign to source,
0: 		 * rather than massage the source list in place.)
0: 		 */
0: 		for (int index = 0; index < numTargetColumns; index++)
0: 		{
0: 			ResultColumn	newResultColumn;
0: 			ResultColumn	oldResultColumn;
0: 			ColumnReference newColumnReference;
0: 
0: 			if (colMap[index] != -1)
0: 			{
0: 				// getResultColumn uses 1-based positioning, so offset the colMap entry appropriately
0: 				oldResultColumn = resultColumns.getResultColumn(colMap[index]+1);
0: 
0: 				newColumnReference = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												oldResultColumn.getName(),
0: 												null,
0: 												getContextManager());
0: 				/* The ColumnReference points to the source of the value */
0: 				newColumnReference.setSource(oldResultColumn);
0: 				// colMap entry is 0-based, columnId is 1-based.
0: 				newColumnReference.setType(oldResultColumn.getExpressionType());
0: 
0: 				// Source of an insert, so nesting levels must be 0
0: 				newColumnReference.setNestingLevel(0);
0: 				newColumnReference.setSourceLevel(0);
0: 
0: 				// because the insert already copied the target table's
0: 				// column descriptors into the result, we grab it from there.
0: 				// alternatively, we could do what the else clause does,
0: 				// and look it up in the DD again.
0: 				newResultColumn = (ResultColumn) getNodeFactory().getNode(
0: 						C_NodeTypes.RESULT_COLUMN,
0: 						oldResultColumn.getType(),
0: 						newColumnReference,
0: 						getContextManager());
0: 			}
0: 			else
0: 			{
0: 				newResultColumn = genNewRCForInsert(targetTD, targetVTI, index + 1, dataDictionary);
0: 			}
0: 
0: 			newResultCols.addResultColumn(newResultColumn);
0: 		}
0: 
0: 		/* The generated ProjectRestrictNode now has the ResultColumnList
0: 		 * in the order that the InsertNode expects.
0: 		 * NOTE: This code here is an exception to several "rules":
0: 		 *		o  This is the only ProjectRestrictNode that is currently
0: 		 *		   generated outside of preprocess().
0: 		 *	    o  The UnionNode is the only node which is not at the
0: 		 *		   top of the query tree which has ColumnReferences under
0: 		 *		   its ResultColumnList prior to expression push down.
0: 		 */
0: 		return (ResultSetNode) getNodeFactory().getNode(
0: 									C_NodeTypes.PROJECT_RESTRICT_NODE,
0: 									this,
0: 									newResultCols,
0: 									null,
0: 									null,
0: 									null,
0: 									null,
0: 									tableProperties,
0: 									getContextManager());
0: 	}
0: 
0: 	/**
0: 	 * Evaluate whether or not the subquery in a FromSubquery is flattenable.  
0: 	 * Currently, a FSqry is flattenable if all of the following are true:
0: 	 *		o  Subquery is a SelectNode. (ie, not a RowResultSetNode or a UnionNode)
0: 	 *		o  It contains no top level subqueries.  (RESOLVE - we can relax this)
0: 	 *		o  It does not contain a group by or having clause
0: 	 *		o  It does not contain aggregates.
0: 	 *
0: 	 * @param fromList	The outer from list
0: 	 *
0: 	 * @return boolean	Whether or not the FromSubquery is flattenable.
0: 	 */
0: 	public boolean flattenableInFromSubquery(FromList fromList)
0: 	{
0: 		/* Unions in FromSubquerys are not flattenable.	 */
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Return whether or not to materialize this ResultSet tree.
0: 	 *
0: 	 * @return Whether or not to materialize this ResultSet tree.
0: 	 *			would return valid results.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean performMaterialization(JBitSet outerTables)
0: 		throws StandardException
0: 	{
0: 		// RESOLVE - just say no to materialization right now - should be a cost based decision
0: 		return false;
0: 
0: 		/* Actual materialization, if appropriate, will be placed by our parent PRN.
0: 		 * This is because PRN might have a join condition to apply.  (Materialization
0: 		 * can only occur before that.
0: 		 */
0: 		//return true;
0: 	}
0: 
0:     /**
0:      * @return the operator name: "UNION", "INTERSECT", or "EXCEPT"
0:      */
0:     abstract String getOperatorName();
0: }
============================================================================