1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.DataValueFactory
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
17:eac0369: 
11:eac0369:  */
1:b5e1331: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:638f1b4: import java.sql.Blob;
1:638f1b4: import java.sql.Clob;
1:eac0369: import java.sql.Date;
1:eac0369: import java.sql.Time;
1:eac0369: import java.sql.Timestamp;
1:eac0369: 
1:b5e1331: import java.text.RuleBasedCollator;
1:b5e1331: 
1:b5e1331: /**
1:9373fed:  * This interface is how we get data values of different types.
1:92268ac:  * 
1:9373fed:  * For any method that takes a 'previous' argument it is required
1:9373fed:  * that the caller pass in an object of the same class that would
1:9373fed:  * be returned by the call if null was passed for previous.
1:92268ac:  */
1:eac0369: public interface DataValueFactory
1:eac0369: {
11:eac0369:         /**
1:eac0369:          * Get a SQL int with the given value.  A null argument means get
1:c8c1551:          * a SQL null value.  Uses the previous value (if non-null)
4:eac0369:          * to hold the return value.
1:9373fed:          *
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(Integer value, NumberDataValue previous)
7:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL int with a char value.  A null argument means get
1:c8c1551:          * a SQL null value.  Uses the previous value (if non-null)
1:eac0369:          * to hold the return value.
5:eac0369:          *
1:eac0369:          */
1:eac0369:         public NumberDataValue getDataValue(char value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL smallint with the given value.  A null argument means get
1:4309044:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:eac0369:          * to hold the return value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(Short value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL TINYINT with the given value.  A null argument means get
1:4309044:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:eac0369:          * to hold the return value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(Byte value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL bigint with the given value.  A null argument means get
1:4309044:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:eac0369:          * to hold the return value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(Long value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL real with the given value.  A null argument means get
1:4309044:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:eac0369:          * to hold the return value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(Float value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL double precision with the given value.  A null argument means
1:4309044:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:eac0369:          * to hold the return value.
1:eac0369:          *
4:eac0369:          * @exception StandardException         Thrown on error
1:cf58aec:          */
1:eac0369:         NumberDataValue         getDataValue(Double value, NumberDataValue previous)
1:cf58aec:                                                         throws StandardException;
1:cf58aec: 
1:cf58aec:         /**
2:eac0369:          * Get a SQL boolean with the given value.  A null argument means get
1:4309044:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:eac0369:          * to hold the return value.
1:cf58aec:          *
1:eac0369:          */
1:eac0369:         BooleanDataValue        getDataValue(Boolean value, BooleanDataValue previous)
1:eac0369:                                                         throws StandardException;
1:cf58aec:         
1:eac0369:         // ------ LONGVARBIT
1:cf58aec: 
1:eac0369:         /**
1:eac0369:          * Get a SQL Long Bit Varying with the given value.  A null argument means
1:c8c1551:          * get a SQL null value.  Uses the previous value (if
1:eac0369:          * non-null) to hold the return value.
1:eac0369:          *
1:cf58aec:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         BitDataValue            getLongVarbitDataValue(byte[] value,
1:eac0369:                                                                                                 BitDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         // ------ BLOB
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL Blob with the given value.  A null argument means
1:c8c1551:          * get a SQL null value.  Uses the previous value (if
1:eac0369:          * non-null) to hold the return value.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         BitDataValue            getBlobDataValue(byte[] value,
1:eac0369:                                                                                                 BitDataValue previous)
1:eac0369:                                                         throws StandardException;
1:638f1b4: 
1:638f1b4:         /**
1:638f1b4:          * Get a SQL Blob with the given value.  A null argument means
1:638f1b4:          * get a SQL null value.  Uses the previous value (if
1:638f1b4:          * non-null) to hold the return value.
1:638f1b4:          *
1:638f1b4:          * @exception StandardException         Thrown on error
1:638f1b4:          */
1:638f1b4:         BitDataValue            getBlobDataValue(Blob value,
1:638f1b4:                                                                                                 BitDataValue previous)
1:638f1b4:                                                         throws StandardException;
1:eac0369:         /**
1:eac0369:          * Get a SQL varchar with the given value.  A null argument means get
1:4309044:          * a SQL null value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         StringDataValue         getVarcharDataValue(String value);
1:9373fed:         
1:9373fed:         /**
1:9373fed:          * Get a SQLVarhar object to represent a SQL VARCHAR  (UCS_BASIC)
1:9373fed:          * with the given value. A null argument means get a SQL NULL value.
1:9373fed:          * If previous is not null (Java reference) then it will be set
1:9373fed:          * to the value passed in and returned, otherwise a new SQLVarchar
1:9373fed:          * will be created and set to the value.
1:9373fed:          *
1:9373fed:          */
1:9373fed:         StringDataValue getVarcharDataValue(String value, StringDataValue previous)
1:9373fed:             throws StandardException;
1:9373fed:         
1:9373fed:         /**
1:9373fed:          * Get a StringDataValue to represent a SQL VARCHAR with the
1:9373fed:          * passed in collationType. A null argument means get a SQL NULL value.
1:9373fed:          * If previous is not null (Java reference) then it will be set
1:9373fed:          * to the value passed in and returned, otherwise a new StringDataValue
1:9373fed:          * will be created and set to the value.
1:9373fed:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:9373fed:          * then the call is the equivalent of the overload without collationType.
1:9373fed:          */
1:9373fed:         StringDataValue getVarcharDataValue(String value, StringDataValue previous,
1:9373fed:                 int collationType) throws StandardException;
1:eac0369:         /**
1:eac0369:          * Get a SQL long varchar with the given value.  A null argument means
1:4309044:          * get a SQL null value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         StringDataValue         getLongvarcharDataValue(String value);
1:9373fed:         
1:eac0369:         /**
1:9373fed:          * Get a SQLLongvarchar object to represent a SQL LONG VARCHAR  (UCS_BASIC)
1:9373fed:          * with the given value. A null argument means get a SQL NULL value.
1:9373fed:          * If previous is not null (Java reference) then it will be set
1:9373fed:          * to the value passed in and returned, otherwise a new SQLLongvarchar
1:9373fed:          * will be created and set to the value.
1:eac0369:          *
1:eac0369:          */
1:9373fed:         StringDataValue getLongvarcharDataValue(String value, StringDataValue previous) throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:9373fed:          * Get a StringDataValue to represent a SQL LONG VARCHAR with the
1:9373fed:          * passed in collationType. A null argument means get a SQL NULL value.
1:9373fed:          * If previous is not null (Java reference) then it will be set
1:9373fed:          * to the value passed in and returned, otherwise a new StringDataValue
1:9373fed:          * will be created and set to the value.
1:9373fed:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:9373fed:          * then the call is the equivalent of the overload without collationType.
1:9373fed: 
1:9373fed:          */
1:9373fed:         StringDataValue getLongvarcharDataValue(String value, StringDataValue previous,
1:9373fed:                 int collationType) throws StandardException;
1:9373fed:         
1:9373fed:  
1:9373fed:         /**
1:9373fed:          * Get a SQLClob object to represent a SQL CLOB  (UCS_BASIC)
1:9373fed:          * with the given value. A null argument means get a SQL NULL value.
1:9373fed:          * If previous is not null (Java reference) then it will be set
1:9373fed:          * to the value passed in and returned, otherwise a new SQLLongvarchar
1:9373fed:          * will be created and set to the value.
1:9373fed:          *
1:9373fed:          */
1:9373fed:         StringDataValue getClobDataValue(String value, StringDataValue previous) throws StandardException;
1:9373fed: 
1:9373fed:         /**
1:638f1b4:          * Get a SQLClob object to represent a SQL CLOB  (UCS_BASIC)
1:638f1b4:          * with the given value. A null argument means get a SQL NULL value.
1:638f1b4:          * If previous is not null (Java reference) then it will be set
1:638f1b4:          * to the value passed in and returned, otherwise a new SQLLongvarchar
1:638f1b4:          * will be created and set to the value.
1:638f1b4:          *
1:638f1b4:          */
1:638f1b4:         StringDataValue getClobDataValue(Clob value, StringDataValue previous) throws StandardException;
1:638f1b4: 
1:638f1b4:         /**
1:9373fed:          * Get a StringDataValue to represent a SQL LONG VARCHAR with the
1:9373fed:          * passed in collationType. A null argument means get a SQL NULL value.
1:9373fed:          * If previous is not null (Java reference) then it will be set
1:9373fed:          * to the value passed in and returned, otherwise a new StringDataValue
1:9373fed:          * will be created and set to the value.
1:9373fed:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:9373fed:          * then the call is the equivalent of the overload without collationType.
1:9373fed:          */
1:9373fed:         StringDataValue getClobDataValue(String value, StringDataValue previous,
1:9373fed:                 int collationType) throws StandardException;
1:9373fed: 
1:9373fed:         /**
1:85e788b:          * Get a StringDataValue to represent a SQL CLOB with the
1:85e788b:          * passed in collationType. A null argument means get a SQL NULL value.
1:85e788b:          * If previous is not null (Java reference) then it will be set
1:85e788b:          * to the value passed in and returned, otherwise a new StringDataValue
1:85e788b:          * will be created and set to the value.
1:85e788b:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:85e788b:          * then the call is the equivalent of the overload without collationType.
1:85e788b:          */
1:85e788b:         StringDataValue getClobDataValue(Clob value, StringDataValue previous,
1:85e788b:                 int collationType) throws StandardException;
1:85e788b: 
1:85e788b:         /**
1:eac0369:          * Get a User-defined data value with the given value and type name.
1:4309044:          * A null argument means get a SQL null value.  The second arg uses
1:eac0369:          * the previous value (if non-null) hold the return value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         UserDataValue           getDataValue(Object value,
1:eac0369:                                                                                 UserDataValue previous);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a RefDataValue with the given value.  A null argument means get
1:c8c1551:          * a SQL null value.  Uses the previous value (if non-null)
1:eac0369:          * to hold the return value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         RefDataValue            getDataValue(RowLocation value, RefDataValue previous);
1:eac0369: 
1:eac0369:         /**
1:4309044:          * Get a SQL int with the given value.  The second arg re-uses the
2:eac0369:          * previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(int value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:4309044:          * Get a SQL bigint with the given value.  The second arg re-uses the
1:eac0369:          * previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(long value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:c8c1551:          * Get a SQL real with the given value.  Uses the previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(float value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:c8c1551:          * Get a SQL double precision with the given value.  Uses the previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(double value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:c8c1551:          * Get a SQL SMALLINT with the given value.  Uses the
1:eac0369:          * previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          */
1:c8c1551:          NumberDataValue         getDataValue(short value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:c8c1551:          * Get a SQL TINYINT with the given value. Uses the
1:eac0369:          * previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue         getDataValue(byte value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:5465561:          * Get a SQL DECIMAL with the given value. Uses the
1:eac0369:          * previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:d7f7457:         NumberDataValue         getDecimalDataValue(Number value, NumberDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:         /**
1:4309044:          * Get a SQL boolean with the given value.  The second arg re-uses the
1:eac0369:          * previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         BooleanDataValue        getDataValue(boolean value, BooleanDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
2:eac0369:          * Get a SQL bit with the given value.  The second form re-uses the
1:eac0369:          * previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         BitDataValue            getBitDataValue(byte[] value) throws StandardException;
1:eac0369:         BitDataValue            getBitDataValue(byte[] value, BitDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:c8c1551:          * Get a SQL bit with the given value.  Uses the
1:eac0369:          * previous value, if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         BitDataValue            getVarbitDataValue(byte[] value, BitDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:c8c1551:          * Get a new SQLChar object to represent a SQL CHAR (UCS_BASIC)
1:c8c1551:          * with the given value. A null argument means get a SQL NULL value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         StringDataValue         getCharDataValue(String value);
1:b2a0e89:         
1:b2a0e89:         /**
1:c8c1551:          * Get a SQLChar object to represent a SQL CHAR  (UCS_BASIC
1:c8c1551:          * with the given value. A null argument means get a SQL NULL value.
1:b2a0e89:          * If previous is not null (Java reference) then it will be set
1:b2a0e89:          * to the value passed in and returned, otherwise a new SQLChar
1:b2a0e89:          * will be created and set to the value.
1:b2a0e89:          *
1:b2a0e89:          */
1:9373fed:         StringDataValue  getCharDataValue(String value, StringDataValue previous)
1:eac0369:                                                         throws StandardException;
1:9373fed:         
1:9373fed:         /**
1:9373fed:          * Get a StringDataValue to represent a SQL CHAR with the
1:9373fed:          * passed in collationType. A null argument means get a SQL NULL value.
1:9373fed:          * If previous is not null (Java reference) then it will be set
1:9373fed:          * to the value passed in and returned, otherwise a new StringDataValue
1:9373fed:          * will be created and set to the value.
1:9373fed:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:9373fed:          * then the call is the equivalent of the overload without collationType.
1:9373fed:          */
1:9373fed:         StringDataValue getCharDataValue(String value, StringDataValue previous,
1:9373fed:                 int collationType) throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL date with the given value.  A null argument means get
1:4309044:          * a SQL null value.  The second arg re-uses the previous value,
2:eac0369:          * if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         DateTimeDataValue       getDataValue(Date value, DateTimeDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL time with the given value.  A null argument means get
1:4309044:          * a SQL null value.  The second arg re-uses the previous value,
1:eac0369:          * if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         DateTimeDataValue       getDataValue(Time value, DateTimeDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL timestamp with the given value.  A null argument means get
1:4309044:          * a SQL null value.  The second arg re-uses the previous value,
1:eac0369:          * if non-null, as the data holder to return.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         DateTimeDataValue       getDataValue(Timestamp value,
1:eac0369:                                                                                 DateTimeDataValue previous)
1:eac0369:                                                         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:2dd0b6f:          * Implement the timestamp SQL function: construct a SQL timestamp from a string, or timestamp.
1:eac0369:          *
1:2dd0b6f:          * @param operand Must be a timestamp or a string convertible to a timestamp.
1:eac0369:          */
1:2dd0b6f:         DateTimeDataValue getTimestamp( DataValueDescriptor operand) throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Construct a SQL timestamp from a date and time.
1:eac0369:          *
1:eac0369:          * @param date Must be convertible to a date.
1:eac0369:          * @param time Must be convertible to a time.
1:eac0369:          */
1:eac0369:         DateTimeDataValue getTimestamp( DataValueDescriptor date, DataValueDescriptor time) throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:2dd0b6f:          * Implements the SQL date function
1:eac0369:          *
1:2dd0b6f:          * @param operand A date, timestamp, string or integer.
1:eac0369:          *
1:2dd0b6f:          * @return the corresponding date value
1:eac0369:          *
1:2dd0b6f:          * @exception StandardException if the syntax is invalid or the date is out of range.
1:eac0369:          */
1:2dd0b6f:         public DateTimeDataValue getDate( DataValueDescriptor operand) throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * @param dateStr A date in one of the DB2 standard date formats or the local format.
1:eac0369:          * @param isJdbcEscape If true then the timestamp must be in the JDBC timestamp escape format, otherwise it must
1:eac0369:          *                     be in the DB2 timestamp format.
1:eac0369:          * @return A DateTimeDataValue
1:eac0369:          *
1:eac0369:          * @exception StandardException if the syntax is invalid or the date is out of range.
1:eac0369:          */
1:eac0369:         public DateTimeDataValue getDateValue( String dateStr, boolean isJdbcEscape) throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * @param timeStr A date in one of the DB2 standard time formats or the local format.
1:eac0369:          * @param isJdbcEscape If true then the timestamp must be in the JDBC time escape format, otherwise it must
1:eac0369:          *                     be in the DB2 time format.
1:eac0369:          * @return A DateTimeDataValue
1:eac0369:          *
1:eac0369:          * @exception StandardException if the syntax is invalid or the time is out of range.
1:eac0369:          */
1:eac0369:         public DateTimeDataValue getTimeValue( String timeStr, boolean isJdbcEscape) throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:6b50965:          * @param timestampStr A time in string format.
1:eac0369:          * @param isJdbcEscape If true then the time must be in the JDBC time escape format, otherwise it must
1:eac0369:          *                     be in the DB2 time format.
1:eac0369:          * @return An internal timestamp
1:eac0369:          *
1:eac0369:          * @exception StandardException if the syntax is invalid or the timestamp is out of range.
1:eac0369:          */
1:eac0369:         public DateTimeDataValue getTimestampValue( String timestampStr, boolean isJdbcEscape) throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:c8c1551:          * Get a null XML value. Uses the previous value,
1:eac0369:          * if non-null, as the data holder to return.
1:eac0369:          */
1:099e28f:         XMLDataValue getXMLDataValue(XMLDataValue previous)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL int with a SQL null value. If the supplied value
5:eac0369:          * is null then get a new value, otherwise set it to null and return 
4:eac0369:          * that value.
1:2ca9dc6:          *
1:2ca9dc6:          */
1:eac0369:         NumberDataValue getNullInteger(NumberDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL smallint with  a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          */
1:eac0369:         NumberDataValue getNullShort(NumberDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL tinyint with  a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue getNullByte(NumberDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL bigint with  a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue getNullLong(NumberDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL float with  a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue getNullFloat(NumberDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL double with  a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         NumberDataValue getNullDouble(NumberDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL Decimal/Numeric with  a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:cf58aec:         NumberDataValue getNullDecimal(NumberDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL boolean with  a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          */
1:eac0369:         BooleanDataValue getNullBoolean(BooleanDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL Bit with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         BitDataValue            getNullBit(BitDataValue dataValue) throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL Bit Varying with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         BitDataValue            getNullVarbit(BitDataValue dataValue) throws StandardException;
1:eac0369: 
1:eac0369:         // --- LONGVARBIT
1:eac0369:         /**
1:eac0369:          * Get a SQL Long Bit Varying with a SQL null value. If the supplied
1:eac0369:          * value is null then get a new value, otherwise set it to null
1:eac0369:          * and return that value.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         BitDataValue            getNullLongVarbit(
1:eac0369:                                                                                                         BitDataValue dataValue)
1:eac0369:                                                                 throws StandardException;
1:eac0369:         // --- BLOB
1:eac0369:         /**
1:eac0369:          * Get a SQL Blob with a SQL null value. If the supplied
1:eac0369:          * value is null then get a new value, otherwise set it to null
1:eac0369:          * and return that value.
1:eac0369:          *
1:eac0369:          * @exception StandardException         Thrown on error
1:eac0369:          */
1:eac0369:         BitDataValue            getNullBlob(BitDataValue dataValue)
1:eac0369:                 throws StandardException;
1:eac0369:         
1:eac0369:     // ------ CHAR
1:eac0369:         /**
1:a1aaa63:          * Get a SQL CHAR (UCS_BASIC) with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          */
1:eac0369:         StringDataValue         getNullChar(StringDataValue dataValue);
1:a1aaa63:         
1:a1aaa63:         /**
1:a1aaa63:          * Get a SQL CHAR set to NULL with collation set to collationType.
1:a1aaa63:          * If the supplied value is null then get a new value,
1:a1aaa63:          * otherwise set it to null and return that value.
1:a1aaa63:          */
1:a1aaa63:         StringDataValue         getNullChar(StringDataValue dataValue,
1:6b95f61:                 int collationType)
1:6b95f61:         throws StandardException;
1:a1aaa63: 
1:a1aaa63:         /**
1:a1aaa63:          * Get a SQL VARCHAR (UCS_BASIC) with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         StringDataValue         getNullVarchar(StringDataValue dataValue);
1:92268ac:         
1:92268ac:         /**
1:a1aaa63:          * Get a SQL VARCHAR set to NULL with collation set to collationType.
1:a1aaa63:          * If the supplied value is null then get a new value,
1:a1aaa63:          * otherwise set it to null and return that value.
1:a1aaa63:          */
1:a1aaa63:         StringDataValue         getNullVarchar(StringDataValue dataValue,
1:6b95f61:                 int collationType)
1:6b95f61:         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:a1aaa63:          * Get a SQL LONG VARCHAR (UCS_BASIC) with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         StringDataValue         getNullLongvarchar(StringDataValue dataValue);
1:a1aaa63:         
1:a1aaa63:         /**
1:a1aaa63:          * Get a SQL LONG VARCHAR set to NULL with collation set to collationType.
1:a1aaa63:          * If the supplied value is null then get a new value,
1:a1aaa63:          * otherwise set it to null and return that value.
1:a1aaa63:          */
1:a1aaa63:         StringDataValue         getNullLongvarchar(StringDataValue dataValue,
1:6b95f61:                 int collationType)
1:6b95f61:         throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:a1aaa63:          * Get a SQL CLOB (UCS_BASIC) with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         StringDataValue         getNullClob(StringDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:a1aaa63:          * Get a SQL CLOB set to NULL with collation set to collationType.
1:a1aaa63:          * If the supplied value is null then get a new value,
1:a1aaa63:          * otherwise set it to null and return that value.
1:a1aaa63:          */
1:a1aaa63:         StringDataValue         getNullClob(StringDataValue dataValue,
1:6b95f61:                 int collationType)
1:6b95f61:         throws StandardException;
1:a1aaa63: 
1:a1aaa63:         /**
1:eac0369:          * Get a User-defined data value with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         UserDataValue           getNullObject(UserDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a RefDataValue with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         RefDataValue            getNullRef(RefDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL date with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         DateTimeDataValue       getNullDate(DateTimeDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL time with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          *
1:eac0369:          */
1:eac0369:         DateTimeDataValue       getNullTime(DateTimeDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * Get a SQL timestamp with a SQL null value. If the supplied value
1:eac0369:          * is null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          */
1:eac0369:         DateTimeDataValue       getNullTimestamp(DateTimeDataValue dataValue);
1:eac0369: 
1:eac0369:         /**
1:099e28f:          * Get an XML with a SQL null value. If the supplied value is
1:099e28f:          * null then get a new value, otherwise set it to null and return 
1:eac0369:          * that value.
1:eac0369:          */
1:099e28f:         XMLDataValue            getNullXML(XMLDataValue dataValue);
1:2ca9dc6:         
1:2ca9dc6:         /**
1:b5e1331:          * Return the RuleBasedCollator depending on the collation type. 
1:b5e1331:          * If the collation type is UCS_BASIC, then this method will return 
1:b5e1331:          * null. If the collation type is TERRITORY_BASED then the return
1:b5e1331:          * value will be the Collator derived from the database's locale.
1:6b95f61:          * If this is the first time Collator is being requested for a
1:6b95f61:          * database with collation type of TERRITORY_BASED, then we will check 
1:6b95f61:          * to make sure that JVM supports the Collator for the database's 
1:6b95f61:          * locale. If not, we will throw an exception 
1:b5e1331:          * 
1:b5e1331:          * This method will be used when Store code is trying to create a DVD
1:b5e1331:          * template row using the format ids and the collation types. First a
1:b5e1331:          * DVD will be constructed just using format id. Then if the DVD is of
1:b5e1331:          * type StringDataValue, then it will call this method to get the
1:b5e1331:          * Collator object. If the Collator object returned from this method is
1:b5e1331:          * null then we will continue to use the default DVDs for the character
1:b5e1331:          * types, ie the DVDs which just use the JVM's default collation. (This
1:b5e1331:          * is why, we want this method to return null if we are dealing with
1:b5e1331:          * UCS_BASIC.) If the Collator object returned is not null, then we
1:b5e1331:          * will construct collation sensitive DVD for the character types. So,
1:b5e1331:          * the return value of this method determines if we are going to create
1:b5e1331:          * a character DVD with default collation or with custom collation. 
1:b5e1331:          * 
1:b5e1331:          * @param collationType This will be UCS_BASIC or TERRITORY_BASED
1:b5e1331:          *  
1:b5e1331:          * @return Collator null if the collation type is UCS_BASIC.
1:b5e1331:          *  Collator based on territory if the collation type is TERRITORY_BASED
1:b5e1331:          */
1:6b95f61:         RuleBasedCollator getCharacterCollator(int collationType) 
1:6b95f61:         throws StandardException;
1:767d656:         
1:767d656:         /**
1:767d656:          * Return an object based on the format id and collation type. For
1:767d656:          * format ids which do not correspond to character types, a format id
1:767d656:          * is sufficient to get the right DVD. But for character types, Derby
1:767d656:          * uses same format id for collation sensitive character types and for
1:767d656:          * character types that use the default JVM collation. To get the
1:767d656:          * correct DVD for character types, we need to know the collation type.
1:767d656:          * Using collation type, we will determine if we need to construct
1:767d656:          * collation sensitive DVD and associate the correct RuleBasedCollator
1:767d656:          * with such DVDs.
1:767d656:          *  
1:767d656:          * @param formatId Format id for the DVD
1:767d656:          * @param collationType this is meaningful only for character types.
1:767d656:          * 
1:57cb998:          * @return DataValueDescriptor which will be constructed using the 
1:57cb998:          * passed parameters 
1:767d656:          */
1:57cb998:         DataValueDescriptor getNull(int formatId, int collationType) 
1:767d656:         throws StandardException;
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5465561
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:          * Get a SQL DECIMAL with the given value. Uses the
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:85e788b
/////////////////////////////////////////////////////////////////////////
1:          * Get a StringDataValue to represent a SQL CLOB with the
1:          * passed in collationType. A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new StringDataValue
1:          * will be created and set to the value.
1:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:          * then the call is the equivalent of the overload without collationType.
1:          */
1:         StringDataValue getClobDataValue(Clob value, StringDataValue previous,
1:                 int collationType) throws StandardException;
1: 
1:         /**
commit:9495437
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:          * Get a PASSWORD with a SQL null value.
1:          *
1:          */
0:         StringDataValue         getNullPassword(StringDataValue dataValue);
1:         
1:         /**
commit:638f1b4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Blob;
1: import java.sql.Clob;
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
1:          * Get a SQL Blob with the given value.  A null argument means
1:          * get a SQL null value.  Uses the previous value (if
1:          * non-null) to hold the return value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
1:         BitDataValue            getBlobDataValue(Blob value,
1:                                                                                                 BitDataValue previous)
1:                                                         throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:          * Get a SQLClob object to represent a SQL CLOB  (UCS_BASIC)
1:          * with the given value. A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new SQLLongvarchar
1:          * will be created and set to the value.
1:          *
1:          */
1:         StringDataValue getClobDataValue(Clob value, StringDataValue previous) throws StandardException;
1: 
1:         /**
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:4309044
/////////////////////////////////////////////////////////////////////////
1:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:          * a SQL null value.  The second arg  uses the previous value (if non-null)
1:          * a SQL null value.  The second arg  uses the previous value (if non-null)
/////////////////////////////////////////////////////////////////////////
1:          * a SQL null value.
/////////////////////////////////////////////////////////////////////////
1:          * get a SQL null value.
/////////////////////////////////////////////////////////////////////////
1:          * A null argument means get a SQL null value.  The second arg uses
/////////////////////////////////////////////////////////////////////////
1:          * Get a SQL int with the given value.  The second arg re-uses the
1:          * Get a SQL bigint with the given value.  The second arg re-uses the
/////////////////////////////////////////////////////////////////////////
1:          * Get a SQL boolean with the given value.  The second arg re-uses the
/////////////////////////////////////////////////////////////////////////
1:          * a SQL null value.  The second arg re-uses the previous value,
1:          * a SQL null value.  The second arg re-uses the previous value,
1:          * a SQL null value.  The second arg re-uses the previous value,
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:6b95f61
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 int collationType)
1:         throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:                 int collationType)
1:         throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:                 int collationType)
1:         throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:                 int collationType)
1:         throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:          * If this is the first time Collator is being requested for a
1:          * database with collation type of TERRITORY_BASED, then we will check 
1:          * to make sure that JVM supports the Collator for the database's 
1:          * locale. If not, we will throw an exception 
/////////////////////////////////////////////////////////////////////////
1:         RuleBasedCollator getCharacterCollator(int collationType) 
1:         throws StandardException;
commit:111785f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:57cb998
/////////////////////////////////////////////////////////////////////////
1:          * @return DataValueDescriptor which will be constructed using the 
1:          * passed parameters 
1:         DataValueDescriptor getNull(int formatId, int collationType) 
commit:767d656
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Return an object based on the format id and collation type. For
1:          * format ids which do not correspond to character types, a format id
1:          * is sufficient to get the right DVD. But for character types, Derby
1:          * uses same format id for collation sensitive character types and for
1:          * character types that use the default JVM collation. To get the
1:          * correct DVD for character types, we need to know the collation type.
1:          * Using collation type, we will determine if we need to construct
1:          * collation sensitive DVD and associate the correct RuleBasedCollator
1:          * with such DVDs.
1:          *  
1:          * @param formatId Format id for the DVD
1:          * @param collationType this is meaningful only for character types.
1:          * 
0:          * @return Object which will be constructed using the passed
0:          * parameters 
1:          */
0:         Object getInstanceUsingFormatIdAndCollationType(int formatId, int collationType)
1:         throws StandardException;
commit:b5e1331
/////////////////////////////////////////////////////////////////////////
1: import java.text.RuleBasedCollator;
1: 
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Return the RuleBasedCollator depending on the collation type. 
1:          * If the collation type is UCS_BASIC, then this method will return 
1:          * null. If the collation type is TERRITORY_BASED then the return
1:          * value will be the Collator derived from the database's locale.
1:          * 
1:          * This method will be used when Store code is trying to create a DVD
1:          * template row using the format ids and the collation types. First a
1:          * DVD will be constructed just using format id. Then if the DVD is of
1:          * type StringDataValue, then it will call this method to get the
1:          * Collator object. If the Collator object returned from this method is
1:          * null then we will continue to use the default DVDs for the character
1:          * types, ie the DVDs which just use the JVM's default collation. (This
1:          * is why, we want this method to return null if we are dealing with
1:          * UCS_BASIC.) If the Collator object returned is not null, then we
1:          * will construct collation sensitive DVD for the character types. So,
1:          * the return value of this method determines if we are going to create
1:          * a character DVD with default collation or with custom collation. 
1:          * 
1:          * @param collationType This will be UCS_BASIC or TERRITORY_BASED
1:          *  
1:          * @return Collator null if the collation type is UCS_BASIC.
1:          *  Collator based on territory if the collation type is TERRITORY_BASED
1:          */
0:         RuleBasedCollator getCharacterCollator(int collationType);
commit:2ca9dc6
/////////////////////////////////////////////////////////////////////////
0: import java.util.Locale;
/////////////////////////////////////////////////////////////////////////
1: 
1:         /**
0:          * Set the locale on DVF. This method gets called by the boot method of
0:          * BasicDatabase after BasicDatabase has finished booting DVF. This 
0:          * Locale will be either the Locale obtained from the territory 
0:          * attribute supplied by the user on the JDBC url at database create 
0:          * time or if user didn't provide the territory attribute at database
0:          * create time, then it will be set to the default JVM locale. The 
0:          * Locale object will be used to construct the Collator object if user 
0:          * has requested territory based collation.
1:          *
0:          * @param localeOfTheDatabase Use this object to construct the 
0:          *   Collator object
1:          */
0:         void setLocale(Locale localeOfTheDatabase);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:a1aaa63
/////////////////////////////////////////////////////////////////////////
1:          * Get a SQL CHAR (UCS_BASIC) with a SQL null value. If the supplied value
1:         
1:         /**
1:          * Get a SQL CHAR set to NULL with collation set to collationType.
1:          * If the supplied value is null then get a new value,
1:          * otherwise set it to null and return that value.
1:          */
1:         StringDataValue         getNullChar(StringDataValue dataValue,
0:                 int collationType);
1:          * Get a SQL VARCHAR (UCS_BASIC) with a SQL null value. If the supplied value
1:         
1:         /**
1:          * Get a SQL VARCHAR set to NULL with collation set to collationType.
1:          * If the supplied value is null then get a new value,
1:          * otherwise set it to null and return that value.
1:          */
1:         StringDataValue         getNullVarchar(StringDataValue dataValue,
0:                 int collationType);
1:          * Get a SQL LONG VARCHAR (UCS_BASIC) with a SQL null value. If the supplied value
1:         
1:         /**
1:          * Get a SQL LONG VARCHAR set to NULL with collation set to collationType.
1:          * If the supplied value is null then get a new value,
1:          * otherwise set it to null and return that value.
1:          */
1:         StringDataValue         getNullLongvarchar(StringDataValue dataValue,
0:                 int collationType);
1:          * Get a SQL CLOB (UCS_BASIC) with a SQL null value. If the supplied value
/////////////////////////////////////////////////////////////////////////
1:          * Get a SQL CLOB set to NULL with collation set to collationType.
1:          * If the supplied value is null then get a new value,
1:          * otherwise set it to null and return that value.
1:          */
1:         StringDataValue         getNullClob(StringDataValue dataValue,
0:                 int collationType);
1: 
1:         /**
commit:9373fed
/////////////////////////////////////////////////////////////////////////
1:  * This interface is how we get data values of different types.
1:  * 
1:  * For any method that takes a 'previous' argument it is required
1:  * that the caller pass in an object of the same class that would
1:  * be returned by the call if null was passed for previous.
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Get a SQLVarhar object to represent a SQL VARCHAR  (UCS_BASIC)
1:          * with the given value. A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new SQLVarchar
1:          * will be created and set to the value.
1:          *
1:          */
1:         StringDataValue getVarcharDataValue(String value, StringDataValue previous)
1:             throws StandardException;
1:         
1:         /**
1:          * Get a StringDataValue to represent a SQL VARCHAR with the
1:          * passed in collationType. A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new StringDataValue
1:          * will be created and set to the value.
1:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:          * then the call is the equivalent of the overload without collationType.
1:          */
1:         StringDataValue getVarcharDataValue(String value, StringDataValue previous,
1:                 int collationType) throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:         
1:          * Get a SQLLongvarchar object to represent a SQL LONG VARCHAR  (UCS_BASIC)
1:          * with the given value. A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new SQLLongvarchar
1:          * will be created and set to the value.
1:         StringDataValue getLongvarcharDataValue(String value, StringDataValue previous) throws StandardException;
1:          * Get a StringDataValue to represent a SQL LONG VARCHAR with the
1:          * passed in collationType. A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new StringDataValue
1:          * will be created and set to the value.
1:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:          * then the call is the equivalent of the overload without collationType.
1: 
1:          */
1:         StringDataValue getLongvarcharDataValue(String value, StringDataValue previous,
1:                 int collationType) throws StandardException;
1:         
1:  
1:         /**
1:          * Get a SQLClob object to represent a SQL CLOB  (UCS_BASIC)
1:          * with the given value. A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new SQLLongvarchar
1:          * will be created and set to the value.
1:          *
1:          */
1:         StringDataValue getClobDataValue(String value, StringDataValue previous) throws StandardException;
1: 
1:         /**
1:          * Get a StringDataValue to represent a SQL LONG VARCHAR with the
1:          * passed in collationType. A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new StringDataValue
1:          * will be created and set to the value.
1:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:          * then the call is the equivalent of the overload without collationType.
1:          */
1:         StringDataValue getClobDataValue(String value, StringDataValue previous,
1:                 int collationType) throws StandardException;
1:         
1:         /**
/////////////////////////////////////////////////////////////////////////
1:         StringDataValue  getCharDataValue(String value, StringDataValue previous)
1:         
1:         /**
1:          * Get a StringDataValue to represent a SQL CHAR with the
1:          * passed in collationType. A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new StringDataValue
1:          * will be created and set to the value.
1:          * If collationType is equal to StringDataValue.COLLATION_TYPE_UCS_BASIC
1:          * then the call is the equivalent of the overload without collationType.
1:          */
1:         StringDataValue getCharDataValue(String value, StringDataValue previous,
1:                 int collationType) throws StandardException;
commit:c8c1551
/////////////////////////////////////////////////////////////////////////
1:          * a SQL null value.  Uses the previous value (if non-null)
1:          * a SQL null value.  Uses the previous value (if non-null)
/////////////////////////////////////////////////////////////////////////
1:          * get a SQL null value.  Uses the previous value (if
/////////////////////////////////////////////////////////////////////////
1:          * get a SQL null value.  Uses the previous value (if
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:          * a SQL null value.  Uses the previous value (if non-null)
/////////////////////////////////////////////////////////////////////////
1:          * Get a SQL real with the given value.  Uses the previous value, if non-null, as the data holder to return.
1:          * Get a SQL double precision with the given value.  Uses the previous value, if non-null, as the data holder to return.
1:          * Get a SQL SMALLINT with the given value.  Uses the
1:          NumberDataValue         getDataValue(short value, NumberDataValue previous)
1:          * Get a SQL TINYINT with the given value. Uses the
/////////////////////////////////////////////////////////////////////////
1:          * Get a SQL bit with the given value.  Uses the
1:          * Get a new SQLChar object to represent a SQL CHAR (UCS_BASIC)
1:          * with the given value. A null argument means get a SQL NULL value.
1:          * Get a SQLChar object to represent a SQL CHAR  (UCS_BASIC
1:          * with the given value. A null argument means get a SQL NULL value.
/////////////////////////////////////////////////////////////////////////
1:          * Get a null XML value. Uses the previous value,
commit:b2a0e89
/////////////////////////////////////////////////////////////////////////
0:          * Get a new SQLChar object to represent a SQL CHAR with the given value.
0:          * A null argument means get a SQL NULL value.
1:         
1:         /**
0:          * Get a SQLChar object to represent a SQL CHAR with the given value.
0:          * A null argument means get a SQL NULL value.
1:          * If previous is not null (Java reference) then it will be set
1:          * to the value passed in and returned, otherwise a new SQLChar
1:          * will be created and set to the value.
1:          *
1:          */
commit:2a58829
/////////////////////////////////////////////////////////////////////////
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
0:         NumberDataValue         getDecimalDataValue(Number value) throws StandardException;
1:         NumberDataValue         getDecimalDataValue(Number value, NumberDataValue previous)
commit:cf58aec
/////////////////////////////////////////////////////////////////////////
0:         NumberDataValue         getDecimalDataValue(BigDecimal value) throws StandardException;
0:         NumberDataValue         getDecimalDataValue(BigDecimal value, NumberDataValue previous)
1: 
1:         /**
0:          * Get a SQL DECIMAL with the given value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         NumberDataValue         getDecimalDataValue(Long value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:         NumberDataValue getNullDecimal(NumberDataValue dataValue);
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.DataValueFactory
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import java.math.BigDecimal;
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: 
0: import java.util.Locale;
1: 
1: /**
0:  * This interface is how we get constant data values of different types.
1:  */
1: 
1: public interface DataValueFactory
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1:         /**
1:          * Get a SQL int with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          */
0:         NumberDataValue         getDataValue(Integer value);
1:         NumberDataValue         getDataValue(Integer value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL int with a char value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          */
0:         public NumberDataValue getDataValue(char value);
1:         public NumberDataValue getDataValue(char value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL smallint with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          */
0:         NumberDataValue         getDataValue(Short value);
1:         NumberDataValue         getDataValue(Short value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL TINYINT with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          */
0:         NumberDataValue         getDataValue(Byte value);
1:         NumberDataValue         getDataValue(Byte value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL bigint with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          */
0:         NumberDataValue         getDataValue(Long value);
1:         NumberDataValue         getDataValue(Long value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL real with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          */
0:         NumberDataValue         getDataValue(Float value) throws StandardException;
1:         NumberDataValue         getDataValue(Float value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL double precision with the given value.  A null argument means
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         NumberDataValue         getDataValue(Double value) throws StandardException;
1:         NumberDataValue         getDataValue(Double value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL boolean with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          */
0:         BooleanDataValue        getDataValue(Boolean value);
1:         BooleanDataValue        getDataValue(Boolean value, BooleanDataValue previous)
1:                                                         throws StandardException;
1:         
1:         // ------ LONGVARBIT
1: 
1:         /**
1:          * Get a SQL Long Bit Varying with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value (if
1:          * non-null) to hold the return value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         BitDataValue            getLongVarbitDataValue(byte[] value) throws StandardException;
1:         BitDataValue            getLongVarbitDataValue(byte[] value,
1:                                                                                                 BitDataValue previous)
1:                                                         throws StandardException;
1: 
1:         // ------ BLOB
1: 
1:         /**
1:          * Get a SQL Blob with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value (if
1:          * non-null) to hold the return value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         BitDataValue            getBlobDataValue(byte[] value) throws StandardException;
1:         BitDataValue            getBlobDataValue(byte[] value,
1:                                                                                                 BitDataValue previous)
1:                                                         throws StandardException;
0:         // ------ BOOLEAN
1:         /**
1:          * Get a SQL boolean with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         BooleanDataValue        getDataValue(BooleanDataValue value) throws StandardException;
1: 
1:         /**
1:          * Get a SQL varchar with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          */
1:         StringDataValue         getVarcharDataValue(String value);
0:         StringDataValue         getVarcharDataValue(String value,
0:                                                                                         StringDataValue previous)
1:                                                                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL long varchar with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value
0:          * (if non-null) to hold the return value.
1:          *
1:          */
1:         StringDataValue         getLongvarcharDataValue(String value);
0:         StringDataValue         getLongvarcharDataValue(String value, StringDataValue previous) throws StandardException;
1: 
1:         /**
0:          * Get a SQL Clob with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value
0:          * (if non-null) to hold the return value.
1:          *
1:          */
0:         StringDataValue         getClobDataValue(String value);
0:         StringDataValue         getClobDataValue(String value, StringDataValue previous) throws StandardException;
1: 
1:         /**
0:          * Get a SQL national varchar with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          */
0:         StringDataValue         getNationalVarcharDataValue(String value);
0:         StringDataValue         getNationalVarcharDataValue(String value,
0:                                                                                         StringDataValue previous)
1:                                                                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL national long varchar with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value
0:          * (if non-null) to hold the return value.
1:          */
0:         StringDataValue         getNationalLongvarcharDataValue(String value);
0:         StringDataValue         getNationalLongvarcharDataValue(String value,
0:                                                                                                 StringDataValue previous)
1:                                                                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL national blob with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value
0:          * (if non-null) to hold the return value.
1:          */
0:         StringDataValue         getNClobDataValue(String value);
0:         StringDataValue         getNClobDataValue(String value, StringDataValue previous) 
1:             throws StandardException;
1: 
1:         /**
1:          * Get a User-defined data value with the given value and type name.
0:          * A null argument means get a SQL null value.  The second form uses
1:          * the previous value (if non-null) hold the return value.
1:          *
1:          */
0:         UserDataValue           getDataValue(Object value);
1:         UserDataValue           getDataValue(Object value,
1:                                                                                 UserDataValue previous);
1: 
1:         /**
1:          * Get a RefDataValue with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
1:          * to hold the return value.
1:          *
1:          */
0:         RefDataValue            getDataValue(RowLocation value);
1:         RefDataValue            getDataValue(RowLocation value, RefDataValue previous);
1: 
1:         /**
0:          * Get a SQL int with the given value.  The second form re-uses the
1:          * previous value, if non-null, as the data holder to return.
1:          *
1:          */
0:         NumberDataValue         getDataValue(int value);
1:         NumberDataValue         getDataValue(int value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL bigint with the given value.  The second form re-uses the
1:          * previous value, if non-null, as the data holder to return.
1:          *
1:          */
0:         NumberDataValue         getDataValue(long value);
1:         NumberDataValue         getDataValue(long value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL real with the given value.  The second form
0:          * re-uses the previous value, if non-null, as the data holder to return.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         NumberDataValue         getDataValue(float value) throws StandardException;
1:         NumberDataValue         getDataValue(float value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL double precision with the given value.  The second form
0:          * re-uses the previous value, if non-null, as the data holder to return.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         NumberDataValue         getDataValue(double value) throws StandardException;
1:         NumberDataValue         getDataValue(double value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL SMALLINT with the given value.  The second form re-uses the
1:          * previous value, if non-null, as the data holder to return.
1:          *
1:          */
0:         NumberDataValue         getDataValue(short value);
0:         NumberDataValue         getDataValue(short value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL TINYINT with the given value.  The second form re-uses the
1:          * previous value, if non-null, as the data holder to return.
1:          *
1:          */
0:         NumberDataValue         getDataValue(byte value);
1:         NumberDataValue         getDataValue(byte value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL DECIMAL with the given value.  The second form re-uses the
1:          * previous value, if non-null, as the data holder to return.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         NumberDataValue         getDataValue(BigDecimal value) throws StandardException;
0:         NumberDataValue         getDataValue(BigDecimal value, NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL DECIMAL with the given value.  The second form re-uses the
1:          * previous value, if non-null, as the data holder to return.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         NumberDataValue         getDecimalDataValue(String value) throws StandardException;
0:         NumberDataValue         getDecimalDataValue(String value,
0:                                                                                         NumberDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL boolean with the given value.  The second form re-uses the
1:          * previous value, if non-null, as the data holder to return.
1:          *
1:          */
0:         BooleanDataValue        getDataValue(boolean value);
1:         BooleanDataValue        getDataValue(boolean value, BooleanDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL bit with the given value.  The second form re-uses the
1:          * previous value, if non-null, as the data holder to return.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
1:         BitDataValue            getBitDataValue(byte[] value) throws StandardException;
1:         BitDataValue            getBitDataValue(byte[] value, BitDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL bit with the given value.  The second form re-uses the
1:          * previous value, if non-null, as the data holder to return.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
0:         BitDataValue            getVarbitDataValue(byte[] value) throws StandardException;
1:         BitDataValue            getVarbitDataValue(byte[] value, BitDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL char with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
1:          * if non-null, as the data holder to return.
1:          *
1:          */
1:         StringDataValue         getCharDataValue(String value);
0:         StringDataValue         getCharDataValue(String value, StringDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
0:          * Get a SQL national char with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
1:          * if non-null, as the data holder to return.
1:          */
0:         StringDataValue         getNationalCharDataValue(String value);
0:         StringDataValue         getNationalCharDataValue(String value, StringDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL date with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
1:          * if non-null, as the data holder to return.
1:          *
1:          */
0:         DateTimeDataValue       getDataValue(Date value) throws StandardException;
1:         DateTimeDataValue       getDataValue(Date value, DateTimeDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL time with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
1:          * if non-null, as the data holder to return.
1:          *
1:          */
0:         DateTimeDataValue       getDataValue(Time value) throws StandardException;
1:         DateTimeDataValue       getDataValue(Time value, DateTimeDataValue previous)
1:                                                         throws StandardException;
1: 
1:         /**
1:          * Get a SQL timestamp with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
1:          * if non-null, as the data holder to return.
1:          *
1:          */
0:         DateTimeDataValue       getDataValue(Timestamp value) throws StandardException;
1:         DateTimeDataValue       getDataValue(Timestamp value,
1:                                                                                 DateTimeDataValue previous)
1:                                                         throws StandardException;
1:         /**
1:          * Construct a SQL timestamp from a date and time.
1:          *
1:          * @param date Must be convertible to a date.
1:          * @param time Must be convertible to a time.
1:          */
1:         DateTimeDataValue getTimestamp( DataValueDescriptor date, DataValueDescriptor time) throws StandardException;
1: 
1:         /**
1:          * @param dateStr A date in one of the DB2 standard date formats or the local format.
1:          * @param isJdbcEscape If true then the timestamp must be in the JDBC timestamp escape format, otherwise it must
1:          *                     be in the DB2 timestamp format.
1:          * @return A DateTimeDataValue
1:          *
1:          * @exception StandardException if the syntax is invalid or the date is out of range.
1:          */
1:         public DateTimeDataValue getDateValue( String dateStr, boolean isJdbcEscape) throws StandardException;
1: 
1:         /**
1:          * @param timeStr A date in one of the DB2 standard time formats or the local format.
1:          * @param isJdbcEscape If true then the timestamp must be in the JDBC time escape format, otherwise it must
1:          *                     be in the DB2 time format.
1:          * @return A DateTimeDataValue
1:          *
1:          * @exception StandardException if the syntax is invalid or the time is out of range.
1:          */
1:         public DateTimeDataValue getTimeValue( String timeStr, boolean isJdbcEscape) throws StandardException;
1: 
1:         /**
0:          * @param timeStr A time in string format.
1:          * @param isJdbcEscape If true then the time must be in the JDBC time escape format, otherwise it must
1:          *                     be in the DB2 time format.
1:          * @return An internal timestamp
1:          *
1:          * @exception StandardException if the syntax is invalid or the timestamp is out of range.
1:          */
1:         public DateTimeDataValue getTimestampValue( String timestampStr, boolean isJdbcEscape) throws StandardException;
1: 
1:         /**
1:          * Get a SQL int with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         NumberDataValue getNullInteger(NumberDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL smallint with  a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          */
1:         NumberDataValue getNullShort(NumberDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL tinyint with  a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         NumberDataValue getNullByte(NumberDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL bigint with  a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         NumberDataValue getNullLong(NumberDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL float with  a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         NumberDataValue getNullFloat(NumberDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL double with  a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         NumberDataValue getNullDouble(NumberDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL Decimal/Numeric with  a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
0:         NumberDataValue getNullBigDecimal(NumberDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL boolean with  a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          */
1:         BooleanDataValue getNullBoolean(BooleanDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL Bit with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
1:         BitDataValue            getNullBit(BitDataValue dataValue) throws StandardException;
1: 
1:         /**
1:          * Get a SQL Bit Varying with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
1:         BitDataValue            getNullVarbit(BitDataValue dataValue) throws StandardException;
1: 
1:         // --- LONGVARBIT
1:         /**
1:          * Get a SQL Long Bit Varying with a SQL null value. If the supplied
1:          * value is null then get a new value, otherwise set it to null
1:          * and return that value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
1:         BitDataValue            getNullLongVarbit(
1:                                                                                                         BitDataValue dataValue)
1:                                                                 throws StandardException;
1:         // --- BLOB
1:         /**
1:          * Get a SQL Blob with a SQL null value. If the supplied
1:          * value is null then get a new value, otherwise set it to null
1:          * and return that value.
1:          *
1:          * @exception StandardException         Thrown on error
1:          */
1:         BitDataValue            getNullBlob(BitDataValue dataValue)
1:                 throws StandardException;
1:         
1:     // ------ CHAR
1:         /**
0:          * Get a SQL char with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          */
1:         StringDataValue         getNullChar(StringDataValue dataValue);
1: 
1:         /**
0:          * Get a SQL varchar with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         StringDataValue         getNullVarchar(StringDataValue dataValue);
1: 
1:         /**
0:          * Get a SQL long varchar with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         StringDataValue         getNullLongvarchar(StringDataValue dataValue);
1: 
1:         /**
0:          * Get a SQL long varchar with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         StringDataValue         getNullClob(StringDataValue dataValue);
1: 
1:         /**
0:          * Get a SQL national char with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          */
0:         StringDataValue         getNullNationalChar(StringDataValue dataValue);
1: 
1:         /**
0:          * Get a SQL national varchar with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
0:         StringDataValue         getNullNationalVarchar(StringDataValue dataValue);
1: 
1:         /**
0:          * Get a SQL national long varchar with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
0:         StringDataValue         getNullNationalLongvarchar(StringDataValue dataValue);
1: 
1:         /**
0:          * Get a SQL NCLOB with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
0:         StringDataValue         getNullNClob(StringDataValue dataValue);
1: 
1:         /**
1:          * Get a User-defined data value with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         UserDataValue           getNullObject(UserDataValue dataValue);
1: 
1:         /**
1:          * Get a RefDataValue with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         RefDataValue            getNullRef(RefDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL date with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         DateTimeDataValue       getNullDate(DateTimeDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL time with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          *
1:          */
1:         DateTimeDataValue       getNullTime(DateTimeDataValue dataValue);
1: 
1:         /**
1:          * Get a SQL timestamp with a SQL null value. If the supplied value
1:          * is null then get a new value, otherwise set it to null and return 
1:          * that value.
1:          */
1:         DateTimeDataValue       getNullTimestamp(DateTimeDataValue dataValue);
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1:          * @param timestampStr A time in string format.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:099e28f
/////////////////////////////////////////////////////////////////////////
0:          * Get a null XML value. The second form re-uses the previous value,
0:          * if non-null, as the data holder to return.
0:          */
0:         XMLDataValue getXMLDataValue();
1:         XMLDataValue getXMLDataValue(XMLDataValue previous)
0: 			throws StandardException;
0: 
0:         /**
/////////////////////////////////////////////////////////////////////////
0: 
0:         /**
1:          * Get an XML with a SQL null value. If the supplied value is
1:          * null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          */
1:         XMLDataValue            getNullXML(XMLDataValue dataValue);
commit:2dd0b6f
/////////////////////////////////////////////////////////////////////////
0: 
0:         /**
1:          * Implement the timestamp SQL function: construct a SQL timestamp from a string, or timestamp.
0:          *
1:          * @param operand Must be a timestamp or a string convertible to a timestamp.
0:          */
1:         DateTimeDataValue getTimestamp( DataValueDescriptor operand) throws StandardException;
0: 
/////////////////////////////////////////////////////////////////////////
1:          * Implements the SQL date function
0:          *
1:          * @param operand A date, timestamp, string or integer.
0:          *
1:          * @return the corresponding date value
0:          *
1:          * @exception StandardException if the syntax is invalid or the date is out of range.
0:          */
1:         public DateTimeDataValue getDate( DataValueDescriptor operand) throws StandardException;
0: 
0:         /**
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import java.math.BigDecimal;
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: 
0: import java.util.Locale;
0: 
0: /**
0:  * This interface is how we get constant data values of different types.
0:  */
0: 
0: public interface DataValueFactory
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0:         /**
0:          * Get a SQL int with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          */
0:         NumberDataValue         getDataValue(Integer value);
0:         NumberDataValue         getDataValue(Integer value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL int with a char value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          */
0:         public NumberDataValue getDataValue(char value);
0:         public NumberDataValue getDataValue(char value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL smallint with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          */
0:         NumberDataValue         getDataValue(Short value);
0:         NumberDataValue         getDataValue(Short value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL TINYINT with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          */
0:         NumberDataValue         getDataValue(Byte value);
0:         NumberDataValue         getDataValue(Byte value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL bigint with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          */
0:         NumberDataValue         getDataValue(Long value);
0:         NumberDataValue         getDataValue(Long value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL real with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          */
0:         NumberDataValue         getDataValue(Float value) throws StandardException;
0:         NumberDataValue         getDataValue(Float value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL double precision with the given value.  A null argument means
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         NumberDataValue         getDataValue(Double value) throws StandardException;
0:         NumberDataValue         getDataValue(Double value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL boolean with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          */
0:         BooleanDataValue        getDataValue(Boolean value);
0:         BooleanDataValue        getDataValue(Boolean value, BooleanDataValue previous)
0:                                                         throws StandardException;
0:         
0:         // ------ LONGVARBIT
0: 
0:         /**
0:          * Get a SQL Long Bit Varying with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value (if
0:          * non-null) to hold the return value.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         BitDataValue            getLongVarbitDataValue(byte[] value) throws StandardException;
0:         BitDataValue            getLongVarbitDataValue(byte[] value,
0:                                                                                                 BitDataValue previous)
0:                                                         throws StandardException;
0: 
0:         // ------ BLOB
0: 
0:         /**
0:          * Get a SQL Blob with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value (if
0:          * non-null) to hold the return value.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         BitDataValue            getBlobDataValue(byte[] value) throws StandardException;
0:         BitDataValue            getBlobDataValue(byte[] value,
0:                                                                                                 BitDataValue previous)
0:                                                         throws StandardException;
0:         // ------ BOOLEAN
0:         /**
0:          * Get a SQL boolean with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         BooleanDataValue        getDataValue(BooleanDataValue value) throws StandardException;
0: 
0:         /**
0:          * Get a SQL varchar with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          */
0:         StringDataValue         getVarcharDataValue(String value);
0:         StringDataValue         getVarcharDataValue(String value,
0:                                                                                         StringDataValue previous)
0:                                                                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL long varchar with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value
0:          * (if non-null) to hold the return value.
0:          *
0:          */
0:         StringDataValue         getLongvarcharDataValue(String value);
0:         StringDataValue         getLongvarcharDataValue(String value, StringDataValue previous) throws StandardException;
0: 
0:         /**
0:          * Get a SQL Clob with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value
0:          * (if non-null) to hold the return value.
0:          *
0:          */
0:         StringDataValue         getClobDataValue(String value);
0:         StringDataValue         getClobDataValue(String value, StringDataValue previous) throws StandardException;
0: 
0:         /**
0:          * Get a SQL national varchar with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          */
0:         StringDataValue         getNationalVarcharDataValue(String value);
0:         StringDataValue         getNationalVarcharDataValue(String value,
0:                                                                                         StringDataValue previous)
0:                                                                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL national long varchar with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value
0:          * (if non-null) to hold the return value.
0:          */
0:         StringDataValue         getNationalLongvarcharDataValue(String value);
0:         StringDataValue         getNationalLongvarcharDataValue(String value,
0:                                                                                                 StringDataValue previous)
0:                                                                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL national blob with the given value.  A null argument means
0:          * get a SQL null value.  The second form uses the previous value
0:          * (if non-null) to hold the return value.
0:          */
0:         StringDataValue         getNClobDataValue(String value);
0:         StringDataValue         getNClobDataValue(String value, StringDataValue previous) 
0:             throws StandardException;
0: 
0:         /**
0:          * Get a User-defined data value with the given value and type name.
0:          * A null argument means get a SQL null value.  The second form uses
0:          * the previous value (if non-null) hold the return value.
0:          *
0:          */
0:         UserDataValue           getDataValue(Object value);
0:         UserDataValue           getDataValue(Object value,
0:                                                                                 UserDataValue previous);
0: 
0:         /**
0:          * Get a RefDataValue with the given value.  A null argument means get
0:          * a SQL null value.  The second form uses the previous value (if non-null)
0:          * to hold the return value.
0:          *
0:          */
0:         RefDataValue            getDataValue(RowLocation value);
0:         RefDataValue            getDataValue(RowLocation value, RefDataValue previous);
0: 
0:         /**
0:          * Get a SQL int with the given value.  The second form re-uses the
0:          * previous value, if non-null, as the data holder to return.
0:          *
0:          */
0:         NumberDataValue         getDataValue(int value);
0:         NumberDataValue         getDataValue(int value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL bigint with the given value.  The second form re-uses the
0:          * previous value, if non-null, as the data holder to return.
0:          *
0:          */
0:         NumberDataValue         getDataValue(long value);
0:         NumberDataValue         getDataValue(long value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL real with the given value.  The second form
0:          * re-uses the previous value, if non-null, as the data holder to return.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         NumberDataValue         getDataValue(float value) throws StandardException;
0:         NumberDataValue         getDataValue(float value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL double precision with the given value.  The second form
0:          * re-uses the previous value, if non-null, as the data holder to return.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         NumberDataValue         getDataValue(double value) throws StandardException;
0:         NumberDataValue         getDataValue(double value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL SMALLINT with the given value.  The second form re-uses the
0:          * previous value, if non-null, as the data holder to return.
0:          *
0:          */
0:         NumberDataValue         getDataValue(short value);
0:         NumberDataValue         getDataValue(short value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL TINYINT with the given value.  The second form re-uses the
0:          * previous value, if non-null, as the data holder to return.
0:          *
0:          */
0:         NumberDataValue         getDataValue(byte value);
0:         NumberDataValue         getDataValue(byte value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL DECIMAL with the given value.  The second form re-uses the
0:          * previous value, if non-null, as the data holder to return.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         NumberDataValue         getDataValue(BigDecimal value) throws StandardException;
0:         NumberDataValue         getDataValue(BigDecimal value, NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL DECIMAL with the given value.  The second form re-uses the
0:          * previous value, if non-null, as the data holder to return.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         NumberDataValue         getDecimalDataValue(String value) throws StandardException;
0:         NumberDataValue         getDecimalDataValue(String value,
0:                                                                                         NumberDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL boolean with the given value.  The second form re-uses the
0:          * previous value, if non-null, as the data holder to return.
0:          *
0:          */
0:         BooleanDataValue        getDataValue(boolean value);
0:         BooleanDataValue        getDataValue(boolean value, BooleanDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL bit with the given value.  The second form re-uses the
0:          * previous value, if non-null, as the data holder to return.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         BitDataValue            getBitDataValue(byte[] value) throws StandardException;
0:         BitDataValue            getBitDataValue(byte[] value, BitDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL bit with the given value.  The second form re-uses the
0:          * previous value, if non-null, as the data holder to return.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         BitDataValue            getVarbitDataValue(byte[] value) throws StandardException;
0:         BitDataValue            getVarbitDataValue(byte[] value, BitDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL char with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
0:          * if non-null, as the data holder to return.
0:          *
0:          */
0:         StringDataValue         getCharDataValue(String value);
0:         StringDataValue         getCharDataValue(String value, StringDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL national char with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
0:          * if non-null, as the data holder to return.
0:          */
0:         StringDataValue         getNationalCharDataValue(String value);
0:         StringDataValue         getNationalCharDataValue(String value, StringDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL date with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
0:          * if non-null, as the data holder to return.
0:          *
0:          */
0:         DateTimeDataValue       getDataValue(Date value) throws StandardException;
0:         DateTimeDataValue       getDataValue(Date value, DateTimeDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL time with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
0:          * if non-null, as the data holder to return.
0:          *
0:          */
0:         DateTimeDataValue       getDataValue(Time value) throws StandardException;
0:         DateTimeDataValue       getDataValue(Time value, DateTimeDataValue previous)
0:                                                         throws StandardException;
0: 
0:         /**
0:          * Get a SQL timestamp with the given value.  A null argument means get
0:          * a SQL null value.  The second form re-uses the previous value,
0:          * if non-null, as the data holder to return.
0:          *
0:          */
0:         DateTimeDataValue       getDataValue(Timestamp value) throws StandardException;
0:         DateTimeDataValue       getDataValue(Timestamp value,
0:                                                                                 DateTimeDataValue previous)
0:                                                         throws StandardException;
0:         /**
0:          * Construct a SQL timestamp from a date and time.
0:          *
0:          * @param date Must be convertible to a date.
0:          * @param time Must be convertible to a time.
0:          */
0:         DateTimeDataValue getTimestamp( DataValueDescriptor date, DataValueDescriptor time) throws StandardException;
0: 
0:         /**
0:          * @param dateStr A date in one of the DB2 standard date formats or the local format.
0:          * @param isJdbcEscape If true then the timestamp must be in the JDBC timestamp escape format, otherwise it must
0:          *                     be in the DB2 timestamp format.
0:          * @return A DateTimeDataValue
0:          *
0:          * @exception StandardException if the syntax is invalid or the date is out of range.
0:          */
0:         public DateTimeDataValue getDateValue( String dateStr, boolean isJdbcEscape) throws StandardException;
0: 
0:         /**
0:          * @param timeStr A date in one of the DB2 standard time formats or the local format.
0:          * @param isJdbcEscape If true then the timestamp must be in the JDBC time escape format, otherwise it must
0:          *                     be in the DB2 time format.
0:          * @return A DateTimeDataValue
0:          *
0:          * @exception StandardException if the syntax is invalid or the time is out of range.
0:          */
0:         public DateTimeDataValue getTimeValue( String timeStr, boolean isJdbcEscape) throws StandardException;
0: 
0:         /**
0:          * @param timeStr A time in string format.
0:          * @param isJdbcEscape If true then the time must be in the JDBC time escape format, otherwise it must
0:          *                     be in the DB2 time format.
0:          * @return An internal timestamp
0:          *
0:          * @exception StandardException if the syntax is invalid or the timestamp is out of range.
0:          */
0:         public DateTimeDataValue getTimestampValue( String timestampStr, boolean isJdbcEscape) throws StandardException;
0: 
0:         /**
0:          * Get a SQL int with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         NumberDataValue getNullInteger(NumberDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL smallint with  a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          */
0:         NumberDataValue getNullShort(NumberDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL tinyint with  a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         NumberDataValue getNullByte(NumberDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL bigint with  a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         NumberDataValue getNullLong(NumberDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL float with  a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         NumberDataValue getNullFloat(NumberDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL double with  a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         NumberDataValue getNullDouble(NumberDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL Decimal/Numeric with  a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         NumberDataValue getNullBigDecimal(NumberDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL boolean with  a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          */
0:         BooleanDataValue getNullBoolean(BooleanDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL Bit with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         BitDataValue            getNullBit(BitDataValue dataValue) throws StandardException;
0: 
0:         /**
0:          * Get a SQL Bit Varying with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         BitDataValue            getNullVarbit(BitDataValue dataValue) throws StandardException;
0: 
0:         // --- LONGVARBIT
0:         /**
0:          * Get a SQL Long Bit Varying with a SQL null value. If the supplied
0:          * value is null then get a new value, otherwise set it to null
0:          * and return that value.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         BitDataValue            getNullLongVarbit(
0:                                                                                                         BitDataValue dataValue)
0:                                                                 throws StandardException;
0:         // --- BLOB
0:         /**
0:          * Get a SQL Blob with a SQL null value. If the supplied
0:          * value is null then get a new value, otherwise set it to null
0:          * and return that value.
0:          *
0:          * @exception StandardException         Thrown on error
0:          */
0:         BitDataValue            getNullBlob(BitDataValue dataValue)
0:                 throws StandardException;
0:         
0:     // ------ CHAR
0:         /**
0:          * Get a SQL char with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          */
0:         StringDataValue         getNullChar(StringDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL varchar with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         StringDataValue         getNullVarchar(StringDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL long varchar with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         StringDataValue         getNullLongvarchar(StringDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL long varchar with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         StringDataValue         getNullClob(StringDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL national char with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          */
0:         StringDataValue         getNullNationalChar(StringDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL national varchar with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         StringDataValue         getNullNationalVarchar(StringDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL national long varchar with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         StringDataValue         getNullNationalLongvarchar(StringDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL NCLOB with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         StringDataValue         getNullNClob(StringDataValue dataValue);
0: 
0:         /**
0:          * Get a User-defined data value with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         UserDataValue           getNullObject(UserDataValue dataValue);
0: 
0:         /**
0:          * Get a RefDataValue with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         RefDataValue            getNullRef(RefDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL date with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         DateTimeDataValue       getNullDate(DateTimeDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL time with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          *
0:          */
0:         DateTimeDataValue       getNullTime(DateTimeDataValue dataValue);
0: 
0:         /**
0:          * Get a SQL timestamp with a SQL null value. If the supplied value
0:          * is null then get a new value, otherwise set it to null and return 
0:          * that value.
0:          */
0:         DateTimeDataValue       getNullTimestamp(DateTimeDataValue dataValue);
0: }
============================================================================