1:ceee49e: /*
10:ceee49e: 
1:ceee49e:    Derby - Class 
1:ceee49e:    org.apache.derbyTesting.functionTests.tests.derbynet.RuntimeInfoTest
1:ceee49e: 
1:ceee49e:    Licensed to the Apache Software Foundation (ASF) under one or more
1:ceee49e:    contributor license agreements.  See the NOTICE file distributed with
1:ceee49e:    this work for additional information regarding copyright ownership.
1:ceee49e:    The ASF licenses this file to You under the Apache License, Version 2.0
1:ceee49e:    (the "License"); you may not use this file except in compliance with
1:ceee49e:    the License.  You may obtain a copy of the License at
1:ceee49e: 
1:ceee49e:       http://www.apache.org/licenses/LICENSE-2.0
1:ceee49e: 
1:ceee49e:    Unless required by applicable law or agreed to in writing, software
1:ceee49e:    distributed under the License is distributed on an "AS IS" BASIS,
1:ceee49e:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ceee49e:    See the License for the specific language governing permissions and
1:ceee49e:    limitations under the License.
1:ceee49e: 
2:ceee49e:  */
1:ceee49e: package org.apache.derbyTesting.functionTests.tests.derbynet;
1:ceee49e: 
1:ceee49e: import java.sql.Connection;
1:ceee49e: import java.sql.PreparedStatement;
1:ceee49e: import java.sql.ResultSet;
1:ceee49e: import java.sql.SQLException;
1:ceee49e: import java.util.HashMap;
1:ceee49e: import java.util.Locale;
1:ceee49e: import junit.framework.Test;
1:ceee49e: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:ceee49e: import org.apache.derbyTesting.junit.LocaleTestSetup;
1:ceee49e: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1:ceee49e: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:ceee49e: import org.apache.derbyTesting.junit.TestConfiguration;
1:ceee49e: 
2:ceee49e: /**
1:ceee49e:  This tests the runtimeinfo command
1:ceee49e:  */
1:ceee49e: 
1:ceee49e: public class RuntimeInfoTest extends BaseJDBCTestCase {
1:ceee49e: 
1:ceee49e: 	private static String[] RuntimeinfoCmd = new String[] {
1:dcfc481:             "-Demma.verbosity.level=silent",
1:ceee49e: 			"org.apache.derby.drda.NetworkServerControl", "runtimeinfo",
1:ceee49e: 			"-p", String.valueOf(TestConfiguration.getCurrent().getPort()) };
1:ceee49e: 	private static String[] RuntimeinfoLocaleCmd = new String[] {
1:dcfc481:             "-Demma.verbosity.level=silent",
1:ceee49e: 			"-Duser.language=err", "-Duser.country=DE",
1:ceee49e: 			"org.apache.derby.drda.NetworkServerControl", "runtimeinfo",
1:ceee49e: 			"-p", String.valueOf(TestConfiguration.getCurrent().getPort()) };
1:ceee49e: 	
1:b32256d:     private static final String POLICY_FILE_NAME =
1:b32256d:         "org/apache/derbyTesting/functionTests/tests/derbynet/RuntimeInfoTest.policy";
1:ceee49e: 
1:b32256d:     private static final Locale englishLocale = new Locale("en", "US");
1:b32256d:     private static final Locale germanLocale = new Locale("de", "DE");
1:b32256d:     private static final String stdout_err_tags = "<[^<>]*STD.*>";
1:ceee49e: 	
1:ceee49e: 	/**
1:ceee49e: 	 * Constructor
1:ceee49e: 	 * 
1:ceee49e: 	 * @param name
1:ceee49e: 	 */
1:ceee49e: 	public RuntimeInfoTest(String name) {
1:ceee49e: 		super(name);
4:ceee49e: 	}
1:ceee49e: 
1:ceee49e: 	/**
1:ceee49e: 	 * Creates a suite with two testcases, with and without some extra 
1:ceee49e: 	 * system properties.
1:ceee49e: 	 * 
1:eaac485: 	 * @return The test suite with both English and German locales.
1:ceee49e: 	 */
1:ceee49e: 	public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("RuntimeInfoTest");
1:4a2a038: 
1:4a2a038:         // Run testRunTests in both English and German locale
1:4a2a038:         suite.addTest(decorateTest(englishLocale, "testRunTests"));
1:4a2a038:         suite.addTest(decorateTest(germanLocale, "testRunTests"));
1:4a2a038: 
1:4a2a038:         // Other test cases, only tested in a single locale.
1:4a2a038:         suite.addTest(
1:4a2a038:                 decorateTest(englishLocale, "testRuntimeInfoWithLongValues"));
1:4a2a038: 
1:ceee49e: 		return suite;
1:ceee49e: 	}	
1:ceee49e: 	
1:ceee49e: 	/**
1:ceee49e: 	 * This is the wrapper that calls the x_tests in order.
1:ceee49e: 	 * These fixtures rely on the order of the commands being issued.
1:ceee49e: 	 */
1:ceee49e: 	public void testRunTests() throws Exception {
1:ceee49e: 		x_testRuntimeInfoWithActiveConn();
1:ceee49e: 		x_testRuntimeInfoLocale();
1:ceee49e: 		x_testRuntimeInfoAfterConnClose();
1:ceee49e: 	}
1:ceee49e: 	
1:ceee49e: 	/**
1:ceee49e: 	 * Test runtimeinfo
1:ceee49e: 	 * 
1:ceee49e: 	 * @throws Exception
1:ceee49e: 	 */
1:ceee49e: 	public void x_testRuntimeInfoWithActiveConn() throws Exception {
1:ceee49e: 		Process p = execJavaCmd(RuntimeinfoCmd);
1:ceee49e: 		String output = sed(readProcessOutput(p));
1:ceee49e: 		
1:ceee49e: 		printIfVerbose("testRuntimeInfo", output);
1:ceee49e: 		
1:ceee49e: 		String expectedOutput = ((HashMap)outputs.get(Locale.getDefault())).get("RuntimeInfoWithActiveConn").toString();
1:ceee49e: 		assertEquals("Output doesn't match", expectedOutput, output);
1:ceee49e: 	}
1:ceee49e: 	
1:ceee49e: 	/**
1:ceee49e: 	 * Test runtimeinfo w/ foreign (non-English) locale
1:ceee49e: 	 */
1:ceee49e: 	public void x_testRuntimeInfoLocale() throws Exception {      
1:ceee49e: 		Connection conn1 = getConnection();
1:ceee49e: 		// Now get a couple of connections with some prepared statements
1:ceee49e: 		Connection conn2 = openDefaultConnection();
1:ceee49e: 		PreparedStatement ps = prepareAndExecuteQuery(conn1,
1:ceee49e: 				"SELECT count(*) from sys.systables");
1:ceee49e: 		PreparedStatement ps2 = prepareAndExecuteQuery(conn1, "VALUES(1)");
1:ceee49e: 
1:ceee49e: 		Connection conn3 = openDefaultConnection();
1:ceee49e: 		PreparedStatement ps3 = prepareAndExecuteQuery(conn2,
1:ceee49e: 				"SELECT count(*) from sys.systables");
1:ceee49e: 		PreparedStatement ps4 = prepareAndExecuteQuery(conn2, "VALUES(2)");
1:ceee49e: 
1:ceee49e: 		Process p = execJavaCmd(RuntimeinfoLocaleCmd);
1:ceee49e: 		String output = sed(readProcessOutput(p));
1:ceee49e: 		
1:ceee49e: 		printIfVerbose("testRuntimeInfoLocale", output);
1:ceee49e: 		
1:ceee49e: 		int matched = 0;
1:ceee49e: 		String matchString = "\tSYSLH0001\tSELECT count(*) from sys.systables\n	SYSLH0002\tVALUES(1)\n";
1:ceee49e: 		String invertedMatchString = "\tSYSLH0002\tVALUES(1)\n\tSYSLH0001\tSELECT count(*) from sys.systables\n";
1:ceee49e: 		
1:ceee49e: 		/* The IF clause accomodates for the different order that the result may have */ 
1:ceee49e: 		matched = output.indexOf(matchString);
1:ceee49e: 		if (matched == -1) { /* The order was incorrect, try the other one */
1:ceee49e: 			matched = output.indexOf(invertedMatchString);
1:ceee49e: 			assertTrue(matched != -1);
1:ceee49e: 		}
1:ceee49e: 		
1:ceee49e: 		matched = 0;
1:ceee49e: 		matchString = "\tSYSLH0001\tSELECT count(*) from sys.systables\n	SYSLH0002\tVALUES(2)\n";
1:ceee49e: 		invertedMatchString = "\tSYSLH0002\tVALUES(2)\n\tSYSLH0001\tSELECT count(*) from sys.systables\n";
1:ceee49e: 		
1:ceee49e: 		/* Same as above, but with VALUES(2) */ 
1:ceee49e: 		matched = output.indexOf(matchString);
1:ceee49e: 		if (matched == -1) { /* The order was incorrect, try the other one */
1:ceee49e: 			matched = output.indexOf(invertedMatchString);
1:ceee49e: 			assertTrue(matched != -1);
1:ceee49e: 		}
1:ceee49e: 		
1:ceee49e: 		/* Match the empty session */
1:ceee49e: 		matched = 0;
1:ceee49e: 		matchString = ((HashMap)outputs.get(Locale.getDefault())).get("RuntimeInfoLocaleString").toString();
1:ceee49e: 		
1:ceee49e: 		assertTrue(output.indexOf(matchString) != -1);
1:ceee49e: 
1:ceee49e: 		ps.close();
1:ceee49e: 		ps2.close();
1:ceee49e: 		ps3.close();
1:ceee49e: 		ps4.close();
1:ceee49e: 		conn1.close();
1:ceee49e: 		conn2.close();
1:ceee49e: 		conn3.close();
1:ceee49e: 
1:ceee49e: 	}
1:ceee49e: 
1:ceee49e: 	/**
1:ceee49e: 	 * once more after closing the connections 
1:ceee49e: 	 * - by calling NetworkServerControl.getRuntimeInfo 
1:ceee49e: 	 * @throws Exception
1:ceee49e: 	 */
1:ceee49e: 	public void x_testRuntimeInfoAfterConnClose() throws Exception {
1:ceee49e: 
1:086dc6d:         String expectedOutput =
1:086dc6d:             outputs.get(Locale.getDefault()).get("RuntimeInfoAfterConnClose");
1:086dc6d: 
1:086dc6d:         // DERBY-1455 and DERBY-6701: The closed connections may not be
1:086dc6d:         // cleaned up by the network server immediately. Retry the
1:086dc6d:         // getRuntimeInfo() call for up to one minute until we get the
1:086dc6d:         // expected response.
1:086dc6d:         String s = null;
1:086dc6d:         int retriesLeft = 60;
1:086dc6d:         while (true) {
1:086dc6d:             s = sed(NetworkServerTestSetup
1:ceee49e: 					.getNetworkServerControl(TestConfiguration.getCurrent().getPort())
1:086dc6d:                     .getRuntimeInfo());
1:086dc6d: 
1:086dc6d:             // Keep retrying until we either get the expected response, or
1:086dc6d:             // we reach the maximum number of retries.
1:086dc6d:             if (expectedOutput.equals(s) || (--retriesLeft <= 0)) {
1:086dc6d:                 break;
1:086dc6d:             }
1:086dc6d: 
1:086dc6d:             sleep(1000L);
1:086dc6d:         }
1:086dc6d: 
1:ceee49e: 		NetworkServerTestSetup.getNetworkServerControl().shutdown();
1:ceee49e: 		
1:ceee49e: 		printIfVerbose("testRuntimeInfoMethod", s);
1:ceee49e: 		
1:ceee49e: 		assertEquals("Output doesn't match", expectedOutput, s);
1:ceee49e: 	}
1:ceee49e: 
1:4a2a038:     /**
1:4a2a038:      * Regression test case for DERBY-6456, which caused an infinite loop if
1:4a2a038:      * the runtimeinfo output was more than 32KB.
1:4a2a038:      */
1:4a2a038:     public void testRuntimeInfoWithLongValues() throws Exception {
1:4a2a038:         // First open many connections on the server, so that the reply from
1:4a2a038:         // getRuntimeInfo() will be long.
1:4a2a038:         for (int i = 0; i < 200; i++) {
1:4a2a038:             prepareAndExecuteQuery(openDefaultConnection(),
1:4a2a038:                 "VALUES 'Hello, World! How are you today?',\n"
1:4a2a038:               + "'Not that bad today, actually. Thanks for asking.'\n"
1:4a2a038:               + "-- Let's add some more text to increase the output length.\n"
1:4a2a038:               + "-- And even more here... The statement text, including this\n"
1:4a2a038:               + "-- comment, will be included in the runtimeinfo output.\n");
1:4a2a038:         }
1:4a2a038: 
1:4a2a038:         // This call used to hang.
1:4a2a038:         String runtimeinfo =
1:4a2a038:             NetworkServerTestSetup.getNetworkServerControl().getRuntimeInfo();
1:4a2a038: 
1:4a2a038:         // For debugging:
1:4a2a038:         println(runtimeinfo);
1:4a2a038: 
1:4a2a038:         // Output gets truncated to 65535 bytes (DERBY-5220).
1:4a2a038:         assertEquals(65535, runtimeinfo.length());
1:4a2a038:     }
1:4a2a038: 
1:ceee49e: 	public static PreparedStatement prepareAndExecuteQuery(Connection conn,
1:ceee49e: 			String sql) throws SQLException {
1:ceee49e: 		PreparedStatement ps = conn.prepareStatement(sql);
1:ceee49e: 		ResultSet rs = ps.executeQuery();
1:ceee49e: 		rs.next();
1:ceee49e: 		return ps;
1:ceee49e: 	}
1:ceee49e: 	
1:ceee49e: 	/**
1:ceee49e:      * Replace memory values in the output string
1:c495206:      * Removes output tags for STDOUT and STDERR from readProcessOutput
1:ceee49e:      * Also trims the string to make it easier to compare.
1:ceee49e:      * 
1:ceee49e:      * @param s the string to remove lines from
1:ceee49e:      * @return the string with the lines removed
1:ceee49e:      */
1:ceee49e:     private String sed(String s) {
1:086dc6d:         HashMap<String, String> strings = outputs.get(Locale.getDefault());
1:086dc6d:         s = s.replaceAll(strings.get("sedMemorySearch"),
1:086dc6d:                          strings.get("sedMemoryReplace"));
1:086dc6d:         s = s.replaceAll(strings.get("sedSessionNumberSearch"),
1:086dc6d:                          strings.get("sedSessionNumberReplace"));
1:c495206: 		s = s.replaceAll(stdout_err_tags, "");
1:ceee49e: 		s = s.trim();
1:ceee49e: 		return s;
1:ceee49e:     }
1:ceee49e:     
1:ceee49e:     /**
1:ceee49e:      * Prints strings to System.out to make it easier to update the tests
1:ceee49e:      * when the output changes. BaseTestCase.println() only prints when on VERBOSE
1:ceee49e:      * 
1:ceee49e:      * @param name just a label to identify the string
1:ceee49e:      * @param s the string to be printed
1:ceee49e:      */
1:ceee49e:     private void printIfVerbose(String name,String s) {
1:ceee49e: 		println("\n\n>>>" + name + ">>>");
1:ceee49e: 		println(s);
1:ceee49e: 		println("<<<" + name + "<<<\n\n");
1:ceee49e:     }
1:ceee49e: 
1:ceee49e: 	/**
1:ceee49e: 	 * Decorate a test with SecurityManagerSetup, clientServersuite, and
1:ceee49e: 	 * SupportFilesSetup.
1:ceee49e: 	 * 
1:ceee49e: 	 * @return the decorated test
1:ceee49e: 	 */
1:4a2a038:     private static Test decorateTest(Locale serverLocale, String testName) {
1:4a2a038:         Test test = new RuntimeInfoTest(testName);
1:4a2a038: 
1:ceee49e:         test = TestConfiguration.clientServerDecorator(test);
1:ceee49e:         
1:ceee49e:         /* A single use database must be used to ensure the consistent output.
1:ceee49e:          * The output would change whether the test was being ran for the first
1:ceee49e:          * or subsequent times. */
1:ceee49e:         test = TestConfiguration.singleUseDatabaseDecorator(test);
1:ceee49e:         test = new LocaleTestSetup(test, serverLocale);
1:ceee49e:         // Install a security manager using the initial policy file.
1:b32256d:         return new SecurityManagerSetup(test, POLICY_FILE_NAME);
1:ceee49e:     }
1:ceee49e: 	
1:9d44c9e: 	private static final HashMap<Locale, HashMap<String, String>> outputs;
1:ceee49e: 	static {
1:9d44c9e: 		HashMap<String, String> englishOutputs = new HashMap<String, String>();
1:ceee49e: 		englishOutputs.put("RuntimeInfoWithActiveConn",
1:ceee49e: 				"--- Derby Network Server Runtime Information ---\n" + 
1:ceee49e: 				"---------- Session Information ---------------\n" + 
1:086dc6d:                 "Session # :##\n" +
1:ceee49e: 				"\n" + 
1:ceee49e: 				"\n" + 
1:ceee49e: 				"-------------------------------------------------------------\n" + 
1:ceee49e: 				"# Connection Threads : 1\n" + 
1:ceee49e: 				"# Active Sessions : 1\n" + 
1:ceee49e: 				"# Waiting  Sessions : 0\n" + 
1:ceee49e: 				"\n" + 
1:ceee49e: 				"Total Memory : #####	Free Memory : #####");
1:ceee49e: 		englishOutputs.put("RuntimeInfoAfterConnClose", 
1:ceee49e: 				"--- Derby Network Server Runtime Information ---\n" + 
1:ceee49e: 				"---------- Session Information ---------------\n" + 
1:086dc6d:                 "Session # :##\n" +
1:ceee49e: 				"\n" + 
1:ceee49e: 				"\n" + 
1:ceee49e: 				"-------------------------------------------------------------\n" + 
1:ceee49e: 				"# Connection Threads : 4\n" + 
1:ceee49e: 				"# Active Sessions : 1\n" + 
1:ceee49e: 				"# Waiting  Sessions : 0\n" + 
1:ceee49e: 				"\n" + 
1:ceee49e: 				"Total Memory : #####	Free Memory : #####");
1:ceee49e: 		englishOutputs.put("sedMemorySearch", "(?m)Memory : [0-9]*");
1:ceee49e: 		englishOutputs.put("sedMemoryReplace", "Memory : #####");
1:086dc6d:         englishOutputs.put("sedSessionNumberSearch", "(?m)^(Session # :)\\d+");
1:086dc6d:         englishOutputs.put("sedSessionNumberReplace", "$1##");
1:ceee49e: 		englishOutputs.put("RuntimeInfoLocaleString", "\tStmt ID\t\tSQLText\n\t-------------\t-----------\n\n\n\nSession");
1:ceee49e: 		
1:9d44c9e: 		HashMap<String, String> germanOutputs = new HashMap<String, String>();
1:ceee49e: 		germanOutputs.put("RuntimeInfoWithActiveConn",
1:ceee49e: 				"--- Laufzeitinformationen zu Derby Network Server ---\n" + 
1:be4b130: 				"---------- Sessioninformationen ---------------\n" + 
1:086dc6d:                 "Sessionnummer:##\n" +
1:ceee49e: 				"\n" + 
1:ceee49e: 				"\n" + 
1:ceee49e: 				"-------------------------------------------------------------\n" + 
1:be4b130: 				"Anzahl Verbindungsthreads: 1\n" + 
1:be4b130: 				"Anzahl aktive Sessions: 1\n" + 
1:be4b130: 				"Anzahl wartende Sessions: 0\n" + 
1:ceee49e: 				"\n" + 
1:be4b130: 				"Speicher gesamt: #####	Freier Speicher: #####");
1:ceee49e: 		germanOutputs.put("RuntimeInfoAfterConnClose", 
1:ceee49e: 				"--- Laufzeitinformationen zu Derby Network Server ---\n" + 
1:be4b130: 				"---------- Sessioninformationen ---------------\n" + 
1:086dc6d:                 "Sessionnummer:##\n" +
1:ceee49e: 				"\n" + 
1:ceee49e: 				"\n" + 
1:ceee49e: 				"-------------------------------------------------------------\n" + 
1:be4b130: 				"Anzahl Verbindungsthreads: 4\n" + 
1:be4b130: 				"Anzahl aktive Sessions: 1\n" + 
1:be4b130: 				"Anzahl wartende Sessions: 0\n" + 
1:ceee49e: 				"\n" + 
1:be4b130: 				"Speicher gesamt: #####	Freier Speicher: #####");
1:be4b130: 		germanOutputs.put("sedMemorySearch", "Speicher gesamt: [0-9]*	Freier Speicher: [0-9]*");
1:be4b130: 		germanOutputs.put("sedMemoryReplace", "Speicher gesamt: #####	Freier Speicher: #####");
1:086dc6d:         germanOutputs.put("sedSessionNumberSearch", "(?m)^(Sessionnummer:)\\d+");
1:086dc6d:         germanOutputs.put("sedSessionNumberReplace", "$1##");
1:be4b130: 		germanOutputs.put("RuntimeInfoLocaleString", "\tAnwsg-ID\t\tSQL-Text\n\t-------------\t-----------\n\n\n\nSessionnummer");
1:ceee49e: 		
1:9d44c9e: 		outputs = new HashMap<Locale, HashMap<String, String>>();
1:ceee49e: 		outputs.put(englishLocale, englishOutputs);
1:ceee49e: 		outputs.put(germanLocale, germanOutputs);
1:ceee49e: 	}
1:ceee49e: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:086dc6d
/////////////////////////////////////////////////////////////////////////
1:         String expectedOutput =
1:             outputs.get(Locale.getDefault()).get("RuntimeInfoAfterConnClose");
1: 
1:         // DERBY-1455 and DERBY-6701: The closed connections may not be
1:         // cleaned up by the network server immediately. Retry the
1:         // getRuntimeInfo() call for up to one minute until we get the
1:         // expected response.
1:         String s = null;
1:         int retriesLeft = 60;
1:         while (true) {
1:             s = sed(NetworkServerTestSetup
1:                     .getRuntimeInfo());
1: 
1:             // Keep retrying until we either get the expected response, or
1:             // we reach the maximum number of retries.
1:             if (expectedOutput.equals(s) || (--retriesLeft <= 0)) {
1:                 break;
1:             }
1: 
1:             sleep(1000L);
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         HashMap<String, String> strings = outputs.get(Locale.getDefault());
1:         s = s.replaceAll(strings.get("sedMemorySearch"),
1:                          strings.get("sedMemoryReplace"));
1:         s = s.replaceAll(strings.get("sedSessionNumberSearch"),
1:                          strings.get("sedSessionNumberReplace"));
/////////////////////////////////////////////////////////////////////////
1:                 "Session # :##\n" +
/////////////////////////////////////////////////////////////////////////
1:                 "Session # :##\n" +
/////////////////////////////////////////////////////////////////////////
1:         englishOutputs.put("sedSessionNumberSearch", "(?m)^(Session # :)\\d+");
1:         englishOutputs.put("sedSessionNumberReplace", "$1##");
1:                 "Sessionnummer:##\n" +
/////////////////////////////////////////////////////////////////////////
1:                 "Sessionnummer:##\n" +
/////////////////////////////////////////////////////////////////////////
1:         germanOutputs.put("sedSessionNumberSearch", "(?m)^(Sessionnummer:)\\d+");
1:         germanOutputs.put("sedSessionNumberReplace", "$1##");
commit:4a2a038
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Run testRunTests in both English and German locale
1:         suite.addTest(decorateTest(englishLocale, "testRunTests"));
1:         suite.addTest(decorateTest(germanLocale, "testRunTests"));
1: 
1:         // Other test cases, only tested in a single locale.
1:         suite.addTest(
1:                 decorateTest(englishLocale, "testRuntimeInfoWithLongValues"));
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Regression test case for DERBY-6456, which caused an infinite loop if
1:      * the runtimeinfo output was more than 32KB.
1:      */
1:     public void testRuntimeInfoWithLongValues() throws Exception {
1:         // First open many connections on the server, so that the reply from
1:         // getRuntimeInfo() will be long.
1:         for (int i = 0; i < 200; i++) {
1:             prepareAndExecuteQuery(openDefaultConnection(),
1:                 "VALUES 'Hello, World! How are you today?',\n"
1:               + "'Not that bad today, actually. Thanks for asking.'\n"
1:               + "-- Let's add some more text to increase the output length.\n"
1:               + "-- And even more here... The statement text, including this\n"
1:               + "-- comment, will be included in the runtimeinfo output.\n");
1:         }
1: 
1:         // This call used to hang.
1:         String runtimeinfo =
1:             NetworkServerTestSetup.getNetworkServerControl().getRuntimeInfo();
1: 
1:         // For debugging:
1:         println(runtimeinfo);
1: 
1:         // Output gets truncated to 65535 bytes (DERBY-5220).
1:         assertEquals(65535, runtimeinfo.length());
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private static Test decorateTest(Locale serverLocale, String testName) {
1:         Test test = new RuntimeInfoTest(testName);
1: 
commit:9d44c9e
/////////////////////////////////////////////////////////////////////////
1: 	private static final HashMap<Locale, HashMap<String, String>> outputs;
1: 		HashMap<String, String> englishOutputs = new HashMap<String, String>();
/////////////////////////////////////////////////////////////////////////
1: 		HashMap<String, String> germanOutputs = new HashMap<String, String>();
/////////////////////////////////////////////////////////////////////////
1: 		outputs = new HashMap<Locale, HashMap<String, String>>();
commit:b32256d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private static final String POLICY_FILE_NAME =
1:         "org/apache/derbyTesting/functionTests/tests/derbynet/RuntimeInfoTest.policy";
1:     private static final Locale englishLocale = new Locale("en", "US");
1:     private static final Locale germanLocale = new Locale("de", "DE");
1:     private static final String stdout_err_tags = "<[^<>]*STD.*>";
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return new SecurityManagerSetup(test, POLICY_FILE_NAME);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("RuntimeInfoTest");
commit:dcfc481
/////////////////////////////////////////////////////////////////////////
1:             "-Demma.verbosity.level=silent",
1:             "-Demma.verbosity.level=silent",
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:be4b130
/////////////////////////////////////////////////////////////////////////
1: 				"---------- Sessioninformationen ---------------\n" + 
0: 				"Sessionnummer:2\n" + 
1: 				"Anzahl Verbindungsthreads: 1\n" + 
1: 				"Anzahl aktive Sessions: 1\n" + 
1: 				"Anzahl wartende Sessions: 0\n" + 
1: 				"Speicher gesamt: #####	Freier Speicher: #####");
1: 				"---------- Sessioninformationen ---------------\n" + 
0: 				"Sessionnummer:8\n" + 
1: 				"Anzahl Verbindungsthreads: 4\n" + 
1: 				"Anzahl aktive Sessions: 1\n" + 
1: 				"Anzahl wartende Sessions: 0\n" + 
1: 				"Speicher gesamt: #####	Freier Speicher: #####");
1: 		germanOutputs.put("sedMemorySearch", "Speicher gesamt: [0-9]*	Freier Speicher: [0-9]*");
1: 		germanOutputs.put("sedMemoryReplace", "Speicher gesamt: #####	Freier Speicher: #####");
1: 		germanOutputs.put("RuntimeInfoLocaleString", "\tAnwsg-ID\t\tSQL-Text\n\t-------------\t-----------\n\n\n\nSessionnummer");
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:c495206
/////////////////////////////////////////////////////////////////////////
0: 	private static String stdout_err_tags = "<[^<>]*STD.*>";
/////////////////////////////////////////////////////////////////////////
1:      * Removes output tags for STDOUT and STDERR from readProcessOutput
/////////////////////////////////////////////////////////////////////////
1: 		s = s.replaceAll(stdout_err_tags, "");
commit:eaac485
/////////////////////////////////////////////////////////////////////////
1: 	 * @return The test suite with both English and German locales.
commit:ceee49e
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class 
1:    org.apache.derbyTesting.functionTests.tests.derbynet.RuntimeInfoTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.derbynet;
1: 
0: import java.io.File;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.util.HashMap;
1: import java.util.Locale;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.LocaleTestSetup;
1: import org.apache.derbyTesting.junit.NetworkServerTestSetup;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  This tests the runtimeinfo command
1:  */
1: 
1: public class RuntimeInfoTest extends BaseJDBCTestCase {
1: 
1: 	private static String[] RuntimeinfoCmd = new String[] {
1: 			"org.apache.derby.drda.NetworkServerControl", "runtimeinfo",
1: 			"-p", String.valueOf(TestConfiguration.getCurrent().getPort()) };
1: 	private static String[] RuntimeinfoLocaleCmd = new String[] {
1: 			"-Duser.language=err", "-Duser.country=DE",
1: 			"org.apache.derby.drda.NetworkServerControl", "runtimeinfo",
1: 			"-p", String.valueOf(TestConfiguration.getCurrent().getPort()) };
1: 	
0: 	private static String POLICY_FILE_NAME=
0:     	"functionTests/tests/derbynet/RuntimeInfoTest.policy";
0:     private static String TARGET_POLICY_FILE_NAME="runtimeinfo.policy";
1: 
0:     private static Locale englishLocale = new Locale("en","US");
0: 	private static Locale germanLocale = new Locale("de","DE");
1: 	
1: 	/**
1: 	 * Constructor
1: 	 * 
1: 	 * @param name
1: 	 */
1: 	public RuntimeInfoTest(String name) {
1: 		super(name);
1: 	}
1: 
1: 	/**
1: 	 * Creates a suite with two testcases, with and without some extra 
1: 	 * system properties.
1: 	 * 
0: 	 * @return
1: 	 */
1: 	public static Test suite() {
0: 		TestSuite suite = new TestSuite("RuntimeInfoTest");
1:         
0:         suite.addTest(decorateTest(englishLocale));
0:         suite.addTest(decorateTest(germanLocale));
1: 		return suite;
1: 	}	
1: 	
1: 	/**
1: 	 * This is the wrapper that calls the x_tests in order.
1: 	 * These fixtures rely on the order of the commands being issued.
1: 	 */
1: 	public void testRunTests() throws Exception {
1: 		x_testRuntimeInfoWithActiveConn();
1: 		x_testRuntimeInfoLocale();
1: 		x_testRuntimeInfoAfterConnClose();
1: 	}
1: 	
1: 	/**
1: 	 * Test runtimeinfo
1: 	 * 
1: 	 * @throws Exception
1: 	 */
1: 	public void x_testRuntimeInfoWithActiveConn() throws Exception {
1: 		Process p = execJavaCmd(RuntimeinfoCmd);
1: 		String output = sed(readProcessOutput(p));
1: 		
1: 		printIfVerbose("testRuntimeInfo", output);
1: 		
1: 		String expectedOutput = ((HashMap)outputs.get(Locale.getDefault())).get("RuntimeInfoWithActiveConn").toString();
1: 		assertEquals("Output doesn't match", expectedOutput, output);
1: 	}
1: 	
1: 	/**
1: 	 * Test runtimeinfo w/ foreign (non-English) locale
1: 	 */
1: 	public void x_testRuntimeInfoLocale() throws Exception {      
1: 		Connection conn1 = getConnection();
1: 		// Now get a couple of connections with some prepared statements
1: 		Connection conn2 = openDefaultConnection();
1: 		PreparedStatement ps = prepareAndExecuteQuery(conn1,
1: 				"SELECT count(*) from sys.systables");
1: 		PreparedStatement ps2 = prepareAndExecuteQuery(conn1, "VALUES(1)");
1: 
1: 		Connection conn3 = openDefaultConnection();
1: 		PreparedStatement ps3 = prepareAndExecuteQuery(conn2,
1: 				"SELECT count(*) from sys.systables");
1: 		PreparedStatement ps4 = prepareAndExecuteQuery(conn2, "VALUES(2)");
1: 
1: 		Process p = execJavaCmd(RuntimeinfoLocaleCmd);
1: 		String output = sed(readProcessOutput(p));
1: 		
1: 		printIfVerbose("testRuntimeInfoLocale", output);
1: 		
1: 		int matched = 0;
1: 		String matchString = "\tSYSLH0001\tSELECT count(*) from sys.systables\n	SYSLH0002\tVALUES(1)\n";
1: 		String invertedMatchString = "\tSYSLH0002\tVALUES(1)\n\tSYSLH0001\tSELECT count(*) from sys.systables\n";
1: 		
1: 		/* The IF clause accomodates for the different order that the result may have */ 
1: 		matched = output.indexOf(matchString);
1: 		if (matched == -1) { /* The order was incorrect, try the other one */
1: 			matched = output.indexOf(invertedMatchString);
1: 			assertTrue(matched != -1);
1: 		}
1: 		
1: 		matched = 0;
1: 		matchString = "\tSYSLH0001\tSELECT count(*) from sys.systables\n	SYSLH0002\tVALUES(2)\n";
1: 		invertedMatchString = "\tSYSLH0002\tVALUES(2)\n\tSYSLH0001\tSELECT count(*) from sys.systables\n";
1: 		
1: 		/* Same as above, but with VALUES(2) */ 
1: 		matched = output.indexOf(matchString);
1: 		if (matched == -1) { /* The order was incorrect, try the other one */
1: 			matched = output.indexOf(invertedMatchString);
1: 			assertTrue(matched != -1);
1: 		}
1: 		
1: 		/* Match the empty session */
1: 		matched = 0;
1: 		matchString = ((HashMap)outputs.get(Locale.getDefault())).get("RuntimeInfoLocaleString").toString();
1: 		
1: 		assertTrue(output.indexOf(matchString) != -1);
1: 
1: 		ps.close();
1: 		ps2.close();
1: 		ps3.close();
1: 		ps4.close();
1: 		conn1.close();
1: 		conn2.close();
1: 		conn3.close();
1: 
1: 	}
1: 
1: 	/**
1: 	 * once more after closing the connections 
1: 	 * - by calling NetworkServerControl.getRuntimeInfo 
1: 	 * @throws Exception
1: 	 */
1: 	public void x_testRuntimeInfoAfterConnClose() throws Exception {
0: 		// give the network server a second to clean up (DERBY-1455)
0: 		Thread.sleep(1000);
1: 
0: 		String s = NetworkServerTestSetup
1: 					.getNetworkServerControl(TestConfiguration.getCurrent().getPort())
0: 					.getRuntimeInfo();
0: 		s = sed(s);
1: 		NetworkServerTestSetup.getNetworkServerControl().shutdown();
1: 		
1: 		printIfVerbose("testRuntimeInfoMethod", s);
1: 		
0: 		String expectedOutput = ((HashMap)outputs.get(Locale.getDefault())).get("RuntimeInfoAfterConnClose").toString();
1: 		assertEquals("Output doesn't match", expectedOutput, s);
1: 	}
1: 
1: 	public static PreparedStatement prepareAndExecuteQuery(Connection conn,
1: 			String sql) throws SQLException {
1: 		PreparedStatement ps = conn.prepareStatement(sql);
1: 		ResultSet rs = ps.executeQuery();
1: 		rs.next();
1: 		return ps;
1: 	}
1: 	
1: 	/**
1:      * Replace memory values in the output string
1:      * Also trims the string to make it easier to compare.
1:      * 
1:      * @param s the string to remove lines from
1:      * @return the string with the lines removed
1:      */
1:     private String sed(String s) {
0:     	String searchString = ((HashMap)outputs.get(Locale.getDefault())).get("sedMemorySearch").toString();
0:     	String replaceString = ((HashMap)outputs.get(Locale.getDefault())).get("sedMemoryReplace").toString();
0: 		s = s.replaceAll(searchString, replaceString);
1: 		s = s.trim();
1: 		return s;
1:     }
1:     
1:     /**
1:      * Prints strings to System.out to make it easier to update the tests
1:      * when the output changes. BaseTestCase.println() only prints when on VERBOSE
1:      * 
1:      * @param name just a label to identify the string
1:      * @param s the string to be printed
1:      */
1:     private void printIfVerbose(String name,String s) {
1: 		println("\n\n>>>" + name + ">>>");
1: 		println(s);
1: 		println("<<<" + name + "<<<\n\n");
1:     }
1:     
1:     /**
0:      * Construct the name of the server policy file.
1:      */
0:     private String makePolicyName()
0:     {
0:         try {
0:             String  userDir = getSystemProperty( "user.dir" );
0:             String  fileName = userDir + File.separator + SupportFilesSetup.EXTINOUT + File.separator + TARGET_POLICY_FILE_NAME;
0:             File      file = new File( fileName );
0:             String  urlString = file.toURI().toURL().toExternalForm();
1: 
0:             return urlString;
1:         }
0:         catch (Exception e)
0:         {
0:             fail(e.getMessage());
0:             return null;
1:         }
1:     }
1: 	
1: 	/**
1: 	 * Decorate a test with SecurityManagerSetup, clientServersuite, and
1: 	 * SupportFilesSetup.
1: 	 * 
1: 	 * @return the decorated test
1: 	 */
0: 	private static Test decorateTest(Locale serverLocale) {
0:         String policyName = new RuntimeInfoTest("test").makePolicyName();
1: 
0:         Test test = new TestSuite(RuntimeInfoTest.class);
1:         
1:         test = TestConfiguration.clientServerDecorator(test);
1:         
1:         /* A single use database must be used to ensure the consistent output.
1:          * The output would change whether the test was being ran for the first
1:          * or subsequent times. */
1:         test = TestConfiguration.singleUseDatabaseDecorator(test);
1:         test = new LocaleTestSetup(test, serverLocale);
1:         // Install a security manager using the initial policy file.
0:         test = new SecurityManagerSetup(test, policyName);
1: 
0:         // Copy over the policy file we want to use.
0:         test = new SupportFilesSetup
0:             (
0:              test,
0:              null,
0:              new String[] { POLICY_FILE_NAME },
0:              null,
0:              new String[] { TARGET_POLICY_FILE_NAME}
0:              );
1:         
0:         return test;
1:     }
1: 	
0: 	private static final HashMap outputs;
1: 	static {
0: 		HashMap englishOutputs = new HashMap();
1: 		englishOutputs.put("RuntimeInfoWithActiveConn",
1: 				"--- Derby Network Server Runtime Information ---\n" + 
1: 				"---------- Session Information ---------------\n" + 
0: 				"Session # :2\n" + 
1: 				"\n" + 
1: 				"\n" + 
1: 				"-------------------------------------------------------------\n" + 
1: 				"# Connection Threads : 1\n" + 
1: 				"# Active Sessions : 1\n" + 
1: 				"# Waiting  Sessions : 0\n" + 
1: 				"\n" + 
1: 				"Total Memory : #####	Free Memory : #####");
1: 		englishOutputs.put("RuntimeInfoAfterConnClose", 
1: 				"--- Derby Network Server Runtime Information ---\n" + 
1: 				"---------- Session Information ---------------\n" + 
0: 				"Session # :8\n" + 
1: 				"\n" + 
1: 				"\n" + 
1: 				"-------------------------------------------------------------\n" + 
1: 				"# Connection Threads : 4\n" + 
1: 				"# Active Sessions : 1\n" + 
1: 				"# Waiting  Sessions : 0\n" + 
1: 				"\n" + 
1: 				"Total Memory : #####	Free Memory : #####");
1: 		englishOutputs.put("sedMemorySearch", "(?m)Memory : [0-9]*");
1: 		englishOutputs.put("sedMemoryReplace", "Memory : #####");
1: 		englishOutputs.put("RuntimeInfoLocaleString", "\tStmt ID\t\tSQLText\n\t-------------\t-----------\n\n\n\nSession");
1: 		
0: 		HashMap germanOutputs = new HashMap();
1: 		germanOutputs.put("RuntimeInfoWithActiveConn",
1: 				"--- Laufzeitinformationen zu Derby Network Server ---\n" + 
0: 				"---------- Sitzungsinformationen ---------------\n" + 
0: 				"Sitzungsnummer:2\n" + 
1: 				"\n" + 
1: 				"\n" + 
1: 				"-------------------------------------------------------------\n" + 
0: 				"Anzahl der Verbindungs-Threads: 1\n" + 
0: 				"Anzahl der aktiven Sitzungen: 1\n" + 
0: 				"Anzahl der wartenden Sitzungen: 0\n" + 
1: 				"\n" + 
0: 				"Gesamtspeicher: #####	Freier Speicher: #####");
1: 		germanOutputs.put("RuntimeInfoAfterConnClose", 
1: 				"--- Laufzeitinformationen zu Derby Network Server ---\n" + 
0: 				"---------- Sitzungsinformationen ---------------\n" + 
0: 				"Sitzungsnummer:8\n" + 
1: 				"\n" + 
1: 				"\n" + 
1: 				"-------------------------------------------------------------\n" + 
0: 				"Anzahl der Verbindungs-Threads: 4\n" + 
0: 				"Anzahl der aktiven Sitzungen: 1\n" + 
0: 				"Anzahl der wartenden Sitzungen: 0\n" + 
1: 				"\n" + 
0: 				"Gesamtspeicher: #####	Freier Speicher: #####");
0: 		germanOutputs.put("sedMemorySearch", "Gesamtspeicher: [0-9]*	Freier Speicher: [0-9]*");
0: 		germanOutputs.put("sedMemoryReplace", "Gesamtspeicher: #####	Freier Speicher: #####");
0: 		germanOutputs.put("RuntimeInfoLocaleString", "\tAnwsg-ID\t\tSQL-Text\n\t--------------\t------------\n\n\n\nSitzungsnummer");
1: 		
0: 		outputs = new HashMap();
1: 		outputs.put(englishLocale, englishOutputs);
1: 		outputs.put(germanLocale, germanOutputs);
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:d806534
/////////////////////////////////////////////////////////////////////////
0: 		germanOutputs.put("RuntimeInfoLocaleString", "\tAnwsg-ID\t\tSQL-Text\n\t-------------\t-----------\n\n\n\nSitzungsnummer");
============================================================================