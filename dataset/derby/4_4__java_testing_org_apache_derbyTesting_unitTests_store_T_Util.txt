1:2bc809f: /*
12:2bc809f: 
1:2bc809f:    Derby - Class org.apache.derbyTesting.unitTests.store.T_Util
1:2bc809f: 
1:c38b841:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c38b841:    contributor license agreements.  See the NOTICE file distributed with
1:c38b841:    this work for additional information regarding copyright ownership.
1:c38b841:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c38b841:    (the "License"); you may not use this file except in compliance with
1:c38b841:    the License.  You may obtain a copy of the License at
1:2bc809f: 
1:2bc809f:       http://www.apache.org/licenses/LICENSE-2.0
1:2bc809f: 
1:2bc809f:    Unless required by applicable law or agreed to in writing, software
1:2bc809f:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bc809f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bc809f:    See the License for the specific language governing permissions and
1:2bc809f:    limitations under the License.
1:2bc809f: 
2:2bc809f:  */
1:2bc809f: 
1:2bc809f: package org.apache.derbyTesting.unitTests.store;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.raw.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.reference.Property;
1:2bc809f: 
1:2bc809f: // impl imports are the preferred way to create unit tests.
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_MultiThreadedIterations;
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.context.ContextService;
1:2bc809f: import org.apache.derby.iapi.services.context.ContextManager;
1:2bc809f: import org.apache.derby.iapi.services.locks.*;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.error.StandardException;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:2bc809f: import org.apache.derby.iapi.store.access.Qualifier;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.types.DataValueDescriptor;
1:2bc809f: 
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.reference.Attribute;
1:2bc809f: import org.apache.derby.iapi.services.property.PropertyUtil;
1:2bc809f: import org.apache.derby.iapi.error.ExceptionSeverity;
1:2bc809f: import java.io.*;
1:2bc809f: import java.util.Properties;
1:2bc809f: import org.apache.derby.iapi.types.SQLChar;
1:2bc809f: 
1:2bc809f: 
1:2bc809f: /*
1:2bc809f:   Utility class to help test raw store functionality.  
1:2bc809f: 
1:2bc809f:   If you write a raw store unit test, be that a protocol test or an
1:2bc809f:   implementation test, and find youself needing to do certain operations over
1:2bc809f:   and over again, chances are that functionality is either in here or should be
1:2bc809f:   added.  This class is here entirely for the convenience of people writing
1:2bc809f:   unit tests for the RawStore.
1:2bc809f: */
1:2bc809f: public class T_Util
3:2bc809f: { 
1:2bc809f: 
1:2bc809f: 	RawStoreFactory	rsFactory;
1:2bc809f: 	LockFactory  lFactory;
1:2bc809f: 	ContextService csFactory;
1:2bc809f: 
1:2bc809f: 	private int		openContainerMode;	// mode flags used in openContainer
1:2bc809f: 
1:2bc809f: 	public T_Util(RawStoreFactory rsf, LockFactory lf, 
1:2bc809f: 				  ContextService csf)
1:2bc809f: 	{
1:2bc809f: 		rsFactory = rsf;
1:2bc809f: 		lFactory = lf;
1:2bc809f: 		csFactory = csf;
1:2bc809f: 
1:2bc809f: 		openContainerMode = 0; // logged by default
8:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public void setOpenMode(int newMode) {
1:2bc809f: 		openContainerMode = newMode;
1:e257b0e: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * function that checks for a condition, throws T_Fail exception if the condition
1:2bc809f: 	 * is not met.
1:2bc809f: 	 */
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * check that transaction does not hold any lock
1:2bc809f: 	 */
1:2bc809f: 	public void t_checkNullLockCount(Transaction t) throws T_Fail {
1:3c1f634: 		if (lFactory.areLocksHeld(t.getCompatibilitySpace()))
1:2bc809f: 			throw T_Fail.testFailMsg("Previous action did not clean up all locks.");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * check that page number on the page matches the input page number
1:2bc809f: 	 */
1:2bc809f: 	public static void t_checkPageNumber(Page page, long pageNumber) throws T_Fail {
1:2bc809f: 		if (page.getPageNumber() != pageNumber)
1:2bc809f: 			throw T_Fail.testFailMsg("page number expected to be " + pageNumber + ", is " +
1:2bc809f: 				page.getPageNumber());
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * check that the number of record on the page matches input.  
1:2bc809f: 	 * @param page the page in question
1:2bc809f: 	 * @param count the total number of record - this include deleted as well as non-deleted
1:2bc809f: 	 * @param nonDeleted the number of non-deleted record
1:2bc809f: 	 */
1:2bc809f: 	public static void t_checkRecordCount(Page page, int count, int nonDeleted) throws T_Fail, StandardException {
1:2bc809f: 		if (page.recordCount() != count)
1:2bc809f: 			throw T_Fail.testFailMsg("recordCount() expected to be " + count + ", is " + page.recordCount());
1:2bc809f: 
1:2bc809f: 		if (page.nonDeletedRecordCount() != nonDeleted)
1:2bc809f: 			throw T_Fail.testFailMsg("nonDeletedRecordCount() expected to be " + nonDeleted + ", is " + page.nonDeletedRecordCount());
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * check the number of fields in the slot
1:2bc809f: 	 */
1:2bc809f: 	public static void t_checkFieldCount(Page page, int slot, int count) throws T_Fail, StandardException {
1:2bc809f: 		if (page.fetchNumFieldsAtSlot(slot) != count)
1:2bc809f: 			throw T_Fail.testFailMsg("number of fields at slot " + slot + " expected to be " + count
1:2bc809f: 									 + ", is " + page.fetchNumFieldsAtSlot(slot));
1:2bc809f: 	}
1:2bc809f: 
2:2bc809f: 	/**
1:2bc809f: 		Fetch a record that is expected to exist using a record handle.
1:2bc809f: 		The record has a T_RawStoreRow of 1 column and this column as value as
1:2bc809f: 		specified by data, which could be null.
1:2bc809f: 
1:2bc809f: 		Calls recordExists() before fetch to ensure that the record
1:2bc809f: 		is there.
1:2bc809f: 
1:2bc809f: 		@param page the page in question
1:2bc809f: 		@param rh the record handle
1:2bc809f: 		@param data the string value that is expected in the row
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Implementation failed expectation
2:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:2bc809f: 		@see Page#recordExists
1:2bc809f: 	*/
1:2bc809f: 	public static void t_checkFetch(Page page, RecordHandle rh, String data, int stringLen)
2:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		t_checkFetch(page, rh, T_Util.getStringFromData(data, stringLen));
1:2bc809f: 	}
1:2bc809f: 	
1:2bc809f: 	public static void t_checkFetch(Page page, RecordHandle rh, String data)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 
2:2bc809f: 		if (!page.recordExists(rh, false))
1:2bc809f: 			throw T_Fail.testFailMsg("Record does not exist");
1:2bc809f: 
1:2bc809f: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1:2bc809f: 
1:2bc809f: 		int slot = page.getSlotNumber(rh);
1:2bc809f: 
1:2bc809f: 		RecordHandle rhf = 
1:2bc809f:             page.fetchFromSlot(
1:2bc809f:                 rh, slot, readRow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 		if (rhf == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Failed to read record");
1:2bc809f: 
1:2bc809f: 		if ((data == null) || readRow.getStorableColumn(0).isNull()) {
1:2bc809f: 
1:2bc809f: 			if ((data == null) && readRow.getStorableColumn(0).isNull())
1:2bc809f: 				return;
1:2bc809f: 
1:2bc809f: 			throw T_Fail.testFailMsg("Record's value incorrect");
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		if (!readRow.toString().equals(data))
1:2bc809f: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Fetch a record from a container that is expected to exist using a record handle.
1:2bc809f: 		Calls recordExists() before fetch to ensure that the record
1:2bc809f: 		is there.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Implementation failed expectation
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:2bc809f: 		@see Page#recordExists
1:2bc809f: 	*/
1:2bc809f: 	public void t_checkFetch(ContainerHandle c, RecordHandle rh, String data)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 
2:2bc809f: 		Page page = t_getPage(c, rh.getPageNumber());
1:2bc809f: 
2:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			t_checkFetch(page, rh, data);
1:2bc809f: 		}
2:2bc809f: 		finally
1:2bc809f: 		{
2:2bc809f: 			page.unlatch();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Check to make sure record is NOT there
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Implementation failed expectation
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	 */
1:2bc809f: 	public void t_checkFetchFail(ContainerHandle c, RecordHandle rh)
1:2bc809f: 		throws T_Fail, StandardException 
1:2bc809f: 	{
1:2bc809f: 		Page page = t_getPage(c, rh.getPageNumber());
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			if (page.recordExists(rh, true))
1:2bc809f: 				throw T_Fail.testFailMsg("Record Exists");
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			page.unlatch();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Fetch a deleted record from a container using a record handle.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Implementation failed expectation
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:2bc809f: 		@see Page#recordExists
1:00d19b5: 		@see Page#fetchFromSlot
1:2bc809f: 	*/
1:2bc809f: 	public void t_checkFetchDeleted(ContainerHandle c, RecordHandle rh, 
1:2bc809f: 									String data)
1:2bc809f: 		throws T_Fail, StandardException 
1:2bc809f: 	{
1:2bc809f: 		Page p = t_getPage(c, rh.getPageNumber());
1:2bc809f: 		if (p == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Page not found " + rh);
1:2bc809f: 
1:2bc809f: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1:2bc809f: 
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			int slot = p.getSlotNumber(rh);
1:2bc809f: 			if (p.fetchFromSlot(
1:2bc809f:                     rh, slot, readRow.getRow(), 
1:2bc809f:                     (FetchDescriptor) null,
1:2bc809f:                     false) != null)
1:2bc809f:             {
1:2bc809f: 				throw T_Fail.testFailMsg(
1:2bc809f:                     "Record at slot " + slot + " not deleted");
1:2bc809f:             }
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			p.unlatch();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 		Fetch a record that is expected to exist using a record handle.
1:2bc809f: 		The record contains the values in the passed in row, which is a
1:2bc809f: 		T_RawStoreRow.  A T_RawStoreRow of the same number of columns will be made and fetched
1:2bc809f: 		from the page and compared with the passed in row.
1:2bc809f: 
1:2bc809f: 	*/
1:2bc809f: 	public static void t_checkFetch(Page page, RecordHandle rh, T_RawStoreRow row)
1:2bc809f: 		throws T_Fail, StandardException 
1:2bc809f: 	{
1:2bc809f: 		if (!page.recordExists(rh, false))
1:2bc809f: 			throw T_Fail.testFailMsg("Record does not exist");
1:2bc809f: 
1:2bc809f: 		// try to fetch the same number of columns as the passed in row
1:2bc809f: 		int ncol = row.nColumns();
1:2bc809f: 		T_RawStoreRow readRow = new T_RawStoreRow(ncol);
1:2bc809f: 		for (int i = 0; i < ncol; i++)
1:2bc809f: 			readRow.setColumn(i, (String) null);
1:2bc809f: 
1:00d19b5: 		RecordHandle rhf = page.fetchFromSlot(rh, page.getSlotNumber(rh),
1:00d19b5: 											  readRow.getRow(), null, false);
1:2bc809f: 		if (rhf == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Failed to read record");
1:2bc809f: 		if (!readRow.toString().equals(row.toString()))
1:2bc809f: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" +
1:2bc809f: 									 row.toString() + ": - got :" + readRow.toString());
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	    Using sparse row representation:
1:2bc809f: 		Fetch a column of a record that is expected to exist, using a record 
1:2bc809f: 		handle and a FormatableBitSet object.
1:2bc809f: 		Check that column colNum has value data.
1:2bc809f: 	*/
1:2bc809f: 	public static void t_checkFetchCol(Page page, RecordHandle rh, int colNum,
1:2bc809f: 									   int numCols, String data)
1:2bc809f: 		throws T_Fail, StandardException 
1:2bc809f: 	{
1:2bc809f: 		if (!page.recordExists(rh, false))
1:2bc809f: 			throw T_Fail.testFailMsg("Record does not exist");
1:2bc809f: 
1:2bc809f: 		T_RawStoreRow readRow = new T_RawStoreRow(numCols);
1:2bc809f: 		for (int i = 0; i < numCols; i++)
1:2bc809f: 			readRow.setColumn(i, (String) null);
1:2bc809f: 		FormatableBitSet colList = new FormatableBitSet(numCols);
1:2bc809f: 		colList.set(colNum);
1:00d19b5: 		FetchDescriptor desc = new FetchDescriptor(numCols, colList, null);
1:2bc809f: 
1:00d19b5: 		RecordHandle rhf = page.fetchFromSlot(rh, page.getSlotNumber(rh),
1:00d19b5: 											  readRow.getRow(), desc, false);
1:2bc809f: 		if (rhf == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Failed to read record");
1:2bc809f: 		String col = readRow.getStorableColumn(colNum).toString();
1:2bc809f: 		if (!col.equals(data))
1:2bc809f: 			throw T_Fail.testFailMsg("Record's value for column " + colNum +
1:2bc809f: 									 " incorrect, expected :" + data +
1:2bc809f: 									 ": - got :" + readRow.toString());
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * the following is a sequence of fetches, fetching the first row, fetching
1:2bc809f: 	 * the next and previous rows, and fetching the last row in the page.
1:2bc809f: 	 *
1:2bc809f: 	 * The row is assumed to be a T_RawStoreRow with 1 column, which value is the
1:2bc809f: 	 * string specified in data.
1:2bc809f: 	 */
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * fetch and check the first row in the page.  
1:2bc809f: 	 * Return the first row's recordHandle. 
1:2bc809f: 	 */
1:2bc809f: 	public static RecordHandle t_checkFetchFirst(Page page, String data)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1:2bc809f: 
1:2bc809f:         int slot = 0;
1:2bc809f:         while (page.isDeletedAtSlot(slot))
1:2bc809f:         {
1:2bc809f:             slot++;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 		RecordHandle rhf = 
1:2bc809f:             page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, slot, 
1:2bc809f:                 readRow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 		if (rhf == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Failed to read record");
1:2bc809f: 		if (!readRow.toString().equals(data))
1:2bc809f: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1:2bc809f: 
1:2bc809f: 		return rhf;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * Fetch and check the next (next to rh) row in the page.
1:2bc809f: 	 * Return the next row's recordHandle
1:2bc809f: 	 */
1:2bc809f: 	public static RecordHandle t_checkFetchNext(Page page, RecordHandle rh, String data)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		if (!page.recordExists(rh, false))
1:2bc809f: 			throw T_Fail.testFailMsg("Record does not exist");
1:2bc809f: 
1:2bc809f: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1:2bc809f: 
1:2bc809f:         int slot = page.getSlotNumber(rh) + 1;
1:2bc809f:         while (page.isDeletedAtSlot(slot))
1:2bc809f:         {
1:2bc809f:             slot++;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 		RecordHandle rhf = 
1:2bc809f:             page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 
1:2bc809f:                 slot,
1:2bc809f:                 readRow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 		if (rhf == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Failed to read record");
1:2bc809f: 		if (!readRow.toString().equals(data))
1:2bc809f: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1:2bc809f: 
1:2bc809f: 		return rhf;
1:2bc809f: 	}
1:2bc809f: 	
1:2bc809f: 	/*
1:2bc809f: 	 * Fetch and check the previous (previous to rh) row in the page.
1:2bc809f: 	 * Return the previous row's recordHandle
1:2bc809f: 	 */
1:2bc809f: 	public static RecordHandle t_checkFetchPrevious(Page page, RecordHandle rh, String data)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		if (!page.recordExists(rh, false))
1:2bc809f: 			throw T_Fail.testFailMsg("Record does not exist");
1:2bc809f: 
1:2bc809f: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1:2bc809f: 
1:2bc809f:         int slot = page.getSlotNumber(rh) - 1;
1:2bc809f: 
1:2bc809f:         while (page.isDeletedAtSlot(slot) && slot >= 0)
1:2bc809f:         {
1:2bc809f:             slot--;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         if (slot == -1)
1:2bc809f:             return(null);
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		RecordHandle rhf = 
1:2bc809f:             page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 
1:2bc809f:                 slot,
1:2bc809f:                 readRow.getRow(), 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 		if (rhf == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Failed to read record");
1:2bc809f: 		if (!readRow.toString().equals(data))
1:2bc809f: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1:2bc809f: 
1:2bc809f: 		return rhf;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * Fetch and check the last row in the page.
1:2bc809f: 	 * Return the last row's recordHandle
1:2bc809f: 	 */
1:2bc809f: 	public static RecordHandle t_checkFetchLast(Page page, String data)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1:2bc809f: 
1:2bc809f:         int slot = page.recordCount() - 1;
1:2bc809f:         while (page.isDeletedAtSlot(slot) && slot >= 0)
1:2bc809f:         {
1:2bc809f:             slot--;
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         if (slot == -1)
1:2bc809f:             return(null);
1:2bc809f: 
1:2bc809f: 		RecordHandle rhf = 
1:2bc809f:             page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 
1:2bc809f:                 slot,
1:2bc809f:                 readRow.getRow(),
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f: 		if (rhf == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Failed to read record");
1:2bc809f: 		if (!readRow.toString().equals(data))
1:2bc809f: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1:2bc809f: 
1:2bc809f: 		return rhf;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * Fetch and check the slot on the page.  
1:2bc809f: 	 *
1:2bc809f: 	 * The slot number is NOT a stable reference once the page is unlatched,
1:2bc809f: 	 * this check is only valid if you know the page has not been unlatched
1:2bc809f: 	 * since you put the row in, or you know nobody has touched the page since
1:2bc809f: 	 * you determined the slot number
1:2bc809f: 	 *
1:2bc809f: 	 * The slot refers to a row in the page which has a T_RawStoreRow of 1 column, the
1:2bc809f: 	 * column has the value of data input.
1:2bc809f: 	 *
1:2bc809f: 	 * @param page the page in question
1:2bc809f: 	 * @param slot the slot number (see above)
1:2bc809f: 	 * @param data the column value
1:2bc809f: 	 * @param deleted if the row is deleted, set to true
1:2bc809f: 	 * @param forUpdate If you want to lock the row for update, set forUpdate to true.
1:2bc809f: 	 *
1:2bc809f: 	 */
1:2bc809f: 	public static void t_checkFetchBySlot(Page page, int slot, 
1:2bc809f: 									String data, boolean deleted, 
1:2bc809f: 									boolean forUpdate)
1:2bc809f: 		throws T_Fail, StandardException 
1:2bc809f: 	{
1:2bc809f: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1:2bc809f: 		RecordHandle rh = 
1:2bc809f:             page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, slot, 
1:2bc809f:                 readRow.getRow(),
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 true);
1:2bc809f: 
1:2bc809f: 		if (rh == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Failed to read record");
1:2bc809f: 		if (!readRow.toString().equals(data))
1:2bc809f: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1:2bc809f: 
1:2bc809f: 		if (page.isDeletedAtSlot(slot) != deleted)
1:2bc809f: 			throw T_Fail.testFailMsg("Record at slot " + slot + " deleted=" +
1:2bc809f: 									 page.isDeletedAtSlot(slot) + ", expect " + deleted);
1:2bc809f: 
1:2bc809f: 		// RESOLVE: check locking
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * check a column value from a slot on the page
1:2bc809f: 	 *
1:2bc809f: 	 * The slot number is NOT a stable reference once the page is unlatched,
1:2bc809f: 	 * this check is only valid if you know the page has not been unlatched
1:2bc809f: 	 * since you put the row in, or you know nobody has touched the page since
1:2bc809f: 	 * you determined the slot number
1:2bc809f: 	 *
1:2bc809f: 	 * The storable in the specified column put into the input column and it
1:2bc809f: 	 * is check for the same value as the input data 
1:2bc809f: 	 *
1:2bc809f: 	 * @param page the page in question
1:2bc809f: 	 * @param slot the slot number (see above)
1:2bc809f: 	 * @param fieldId the field Id on the row
1:2bc809f: 	 * @param column the storable to put the column in
1:2bc809f: 	 * @param forUpdate true if you want to lock the row for update
1:2bc809f: 	 * @param data the expected value in the column
1:2bc809f: 	 */
1:2bc809f: 	public static void t_checkFetchColFromSlot(Page page,
1:2bc809f: 										 int slot,
1:2bc809f: 										 int fieldId,
1:2bc809f: 										 DataValueDescriptor column,
1:2bc809f: 										 boolean forUpdate,
1:2bc809f: 										 String data,
1:2bc809f: 										 int stringLen)
1:2bc809f: 		 throws StandardException, T_Fail
1:2bc809f: 	{
1:2bc809f: 		t_checkFetchColFromSlot(page, slot, fieldId, column, forUpdate, T_Util.getStringFromData(data, stringLen));
1:2bc809f: 	}
1:2bc809f: 	
1:2bc809f: 	public static void t_checkFetchColFromSlot(
1:2bc809f:     Page                page,
1:2bc809f:     int                 slot,
1:2bc809f:     int                 fieldId,
1:2bc809f:     DataValueDescriptor column,
1:2bc809f:     boolean             forUpdate,
1:2bc809f:     String              data)
1:2bc809f: 		 throws StandardException, T_Fail
1:2bc809f: 	{
1:2bc809f:         DataValueDescriptor[] fetch_row = new DataValueDescriptor[fieldId + 1];
1:2bc809f:         fetch_row[fieldId] = column;
1:2bc809f:         FormatableBitSet validCols = new FormatableBitSet(fieldId + 1);
1:2bc809f:         validCols.set(fieldId);
1:2bc809f: 
1:2bc809f: 		RecordHandle rh =
1:2bc809f: 			page.fetchFromSlot(
1:2bc809f:                 null, slot, fetch_row,
1:2bc809f:                 new FetchDescriptor(
1:2bc809f:                     fetch_row.length, validCols, (Qualifier[][]) null), 
1:2bc809f:                 true);
1:2bc809f: 
1:2bc809f: 		if (rh == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Failed to fetch record: slot "
1:2bc809f: 							 + slot + " field " + fieldId);
1:2bc809f: 
1:2bc809f: 		// RESOLVE - how to check rh lock mode?
1:2bc809f: 
1:2bc809f: 		if (data == null)
1:2bc809f: 		{
1:2bc809f: 			if (!column.isNull())
1:2bc809f: 				throw T_Fail.testFailMsg("Failed to fetch null column: slot "
1:2bc809f: 								 + slot + " field " + fieldId + " column is " + column);
1:2bc809f: 		}
1:2bc809f: 		else
1:2bc809f: 		{
1:2bc809f: 			if (column.isNull())
1:2bc809f: 				throw T_Fail.testFailMsg("expect non null column, got null: slot "
1:2bc809f: 								 + slot + " field " + fieldId);
1:2bc809f: 			if (!column.toString().equals(data))
1:2bc809f: 				throw T_Fail.testFailMsg("expect " + data + " got " + column.toString()
1:2bc809f: 								 + ": slot " + slot + " field " + fieldId);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Take an empty page and check it does actually seem to be empty.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public static void t_checkEmptyPage(Page page) throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		// check the counts
1:2bc809f: 		t_checkRecordCount(page, 0, 0);
1:2bc809f: 
1:2bc809f:         try
1:2bc809f:         {
1:2bc809f:             page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, 0, null, 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 false);
1:2bc809f: 
1:2bc809f:             throw T_Fail.testFailMsg(
1:2bc809f:                 "fetchFromSlot() must throw exception on fetch from slot 0 on an empty page");
1:2bc809f:         }
1:2bc809f:         catch (StandardException se)
1:2bc809f:         {
1:2bc809f:             // expected exception.
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 		// check we can't get a record handle. NB here we are guessing that 0
1:2bc809f: 		// and RecordHandle.FIRST_RECORD_ID might be valid record identifiers,
1:2bc809f: 		// nothing in the API states that they will be.  Eother way we
1:2bc809f: 		// shouldn't get a valid RecordHandle back.
1:2bc809f: 		if (page.getRecordHandle(0) != null)
1:2bc809f: 			throw T_Fail.testFailMsg("obtained a RecordHandle for an empty page");
1:2bc809f: 
1:2bc809f: 		if (page.getRecordHandle(RecordHandle.FIRST_RECORD_ID) != null)
1:2bc809f: 			throw T_Fail.testFailMsg("obtained a RecordHandle for an empty page");
1:2bc809f: 		
1:2bc809f: 		// should be no aux object
1:2bc809f: 		if (page.getAuxObject() != null)
1:2bc809f: 			throw T_Fail.testFailMsg("empty page has an aux object");
1:2bc809f: 
1:2bc809f: 		t_readOnlySlotOutOfRange(page, Page.FIRST_SLOT_NUMBER);
1:2bc809f: 
1:2bc809f: 		if (!page.spaceForInsert())
1:2bc809f: 			throw T_Fail.testFailMsg("spaceForInsert() returned false on an empty page");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 		Check to see the correct behaviour for read only operations
1:2bc809f: 		that take a slot when the slot is out of range.
1:2bc809f: 	*/
1:2bc809f: 	public static void t_readOnlySlotOutOfRange(Page page, int slot) throws T_Fail, StandardException {
1:2bc809f: 
3:2bc809f: 		try {
1:2bc809f: 			page.fetchFromSlot(
1:2bc809f:                 (RecordHandle) null, slot, 
1:2bc809f:                 new DataValueDescriptor[0], 
1:2bc809f:                 (FetchDescriptor) null,
1:2bc809f:                 true);
1:2bc809f: 
1:2bc809f: 			throw T_Fail.testFailMsg("fetchFromSlot succeeded on out of range slot " + slot);
1:2bc809f: 		} catch (StandardException se0) {
1:2bc809f: 			// Statement exception expected, throw if not a statement exception.
1:2bc809f:             if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:2bc809f:                 throw se0;
1:e257b0e: 		}
1:2bc809f: 		try {
1:2bc809f: 			page.isDeletedAtSlot(slot);
1:2bc809f: 			throw T_Fail.testFailMsg("isDeletedAtSlot succeeded on out of range slot " + slot);
1:2bc809f: 		} catch (StandardException se2) {
1:2bc809f: 			// Statement exception expected, throw if not a statement exception.
1:2bc809f:             if (se2.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:2bc809f:                 throw se2;
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 		Check to see the correct behaviour for update operations
1:2bc809f: 		that take a slot when the slot is out of range.
1:2bc809f: 	*/
1:2bc809f: 	public static void t_updateSlotOutOfRange(Page page, int slot) throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 			page.deleteAtSlot(slot, false, (LogicalUndo)null);
1:2bc809f: 			throw T_Fail.testFailMsg("deleteAtSlot succeeded on out of range slot " + slot);
1:2bc809f: 		} catch (StandardException se0) {
1:2bc809f: 			// Statement exception expected, throw if not a statement exception.
1:2bc809f:             if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:2bc809f:                 throw se0;
1:2bc809f: 		}
1:2bc809f: 		try {
1:2bc809f: 			page.deleteAtSlot(slot, true, (LogicalUndo)null);
1:2bc809f: 			throw T_Fail.testFailMsg("deleteAtSlot succeeded on out of range slot " + slot);
1:2bc809f: 		} catch (StandardException se0) {
1:2bc809f: 			// Statement exception expected, throw if not a statement exception.
1:2bc809f:             if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:2bc809f:                 throw se0;
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		T_RawStoreRow row = new T_RawStoreRow((String) null);
1:2bc809f: 
1:2bc809f: 		// insert at the last slot will succeed, so don't do it.
1:2bc809f: 		if (page.recordCount() != slot) {
1:2bc809f: 			try {			
1:2bc809f: 					page.insertAtSlot(slot, row.getRow(), (FormatableBitSet) null, (LogicalUndo)null,
1:2bc809f: 						Page.INSERT_DEFAULT, 100);
1:2bc809f: 					throw T_Fail.testFailMsg("insertAtSlot succeeded, on out of range slot " + slot);
1:2bc809f:             } catch (StandardException se0) {
1:2bc809f:                 // Statement exception expected, throw if not a statement exception.
1:2bc809f:                 if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:2bc809f:                     throw se0;
1:2bc809f:             }
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		try {			
1:2bc809f: 			page.updateAtSlot(slot, row.getRow(), (FormatableBitSet) null);
1:2bc809f: 			throw T_Fail.testFailMsg("updateAtSlot succeeded on out of range slot " + slot);
1:2bc809f:         } catch (StandardException se0) {
1:2bc809f:             // Statement exception expected, throw if not a statement exception.
1:2bc809f:             if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:2bc809f:                 throw se0;
1:2bc809f:         }
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * Save point checks
1:2bc809f: 	 */
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Negative test - check that an invalid savepoint is detected.
1:2bc809f: 	    
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public static void t_checkInvalidSavePoint(Transaction t, String name)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		// check a non-existent save point is trapped
1:2bc809f: 		try {
1:2bc809f: 			t.rollbackToSavePoint(name, null);
1:2bc809f: 
1:2bc809f: 			throw T_Fail.testFailMsg("non existent save point did not cause exception on rollbackToSavePoint");
1:2bc809f: 		} catch (StandardException se) {
1:2bc809f: 			// we expected this ...
1:2bc809f: 		}
1:2bc809f: 		try {
1:2bc809f: 			t.releaseSavePoint(name, null);
1:2bc809f: 			throw T_Fail.testFailMsg("non existent save point did not cause exception on releaseSavePoint");
1:2bc809f: 
1:2bc809f: 		} catch (StandardException se) {
1:2bc809f: 			// we expected this ...
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/* 
1:2bc809f: 	 * same as above, check an invalid savepoint in the given transaction
1:2bc809f: 	 * context
1:2bc809f: 	 */
1:2bc809f: 	public void t_checkInvalidSavePoint(T_TWC ctx, String name)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 		csFactory.setCurrentContextManager(ctx.cm);
1:2bc809f: 		try {
1:2bc809f: 		t_checkInvalidSavePoint(ctx.tran, name);
1:2bc809f: 		} finally {
1:2bc809f: 			csFactory.resetCurrentContextManager(ctx.cm);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * function that actually do something, start, commit, abort a trasaction,
1:2bc809f: 	 * get a page, insert a row, etc.
1:2bc809f: 	 */
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 		Start a user transaction, ensures that the startTransaction method
1:2bc809f: 		does not return null (which it shouldn't).
1:2bc809f: 	*/
1:2bc809f: 	public Transaction t_startTransaction() 
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 			
1:2bc809f: 			Transaction t1 = 
1:2bc809f:                 rsFactory.startTransaction(
1:2bc809f:                     csFactory.getCurrentContextManager(),
1:2bc809f: 					AccessFactoryGlobals.USER_TRANS_NAME);
1:2bc809f: 
1:2bc809f: 			if (t1 == null)
1:2bc809f: 				throw T_Fail.testFailMsg("Start a transaction");
1:2bc809f: 			t_checkNullLockCount(t1);
1:2bc809f: 			return t1;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 		Start a user transaction, ensures that the startTransaction method
1:2bc809f: 		does not return null (which it shouldn't).
1:2bc809f: 	*/
1:2bc809f: 	public Transaction t_startGlobalTransaction(
1:2bc809f:     int     format_id,
1:2bc809f:     byte[]  global_id,
1:2bc809f:     byte[]  branch_id) 
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 			Transaction t1 = 
1:2bc809f:                 rsFactory.startGlobalTransaction(
1:2bc809f:                     csFactory.getCurrentContextManager(),
1:2bc809f:                     format_id, global_id, branch_id);
1:2bc809f: 
1:2bc809f: 			if (t1 == null)
1:2bc809f: 				throw T_Fail.testFailMsg("Start a transaction");
1:2bc809f: 			t_checkNullLockCount(t1);
1:2bc809f: 			return t1;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * start a user transaction with its own context (T_TWC)
1:2bc809f: 	 */
1:2bc809f: 	public T_TWC t_startTransactionWithContext()
1:2bc809f: 		throws StandardException, T_Fail
1:2bc809f: 	{
1:2bc809f: 		T_TWC ctx = new T_TWC(csFactory, lFactory, rsFactory);
1:2bc809f: 		ctx.startUserTransaction();
1:2bc809f: 		return ctx;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * start an internal transaction
1:2bc809f: 	 */
1:2bc809f: 	public Transaction t_startInternalTransaction() 
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 			Transaction t1 = rsFactory.startInternalTransaction(csFactory.getCurrentContextManager());
1:2bc809f: 
1:2bc809f: 			if (t1 == null)
1:2bc809f: 				throw T_Fail.testFailMsg("Failed to start an internal transaction");
1:2bc809f: 			t_checkNullLockCount(t1);
1:2bc809f: 			return t1;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * commit a transaction
1:2bc809f: 	 */
1:2bc809f: 	public void t_commit(Transaction t) 
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 		t.commit();
1:2bc809f: 		t_checkNullLockCount(t);
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * commit a transaction with context
1:2bc809f: 	 */
1:2bc809f: 	public void t_commit(T_TWC ctx) 
1:2bc809f: 		throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		csFactory.setCurrentContextManager(ctx.cm);
1:b91cfb2: 		try {
1:2bc809f: 		t_commit(ctx.tran);
1:2bc809f: 		} finally {
1:2bc809f: 			csFactory.resetCurrentContextManager(ctx.cm);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * close a transaction with context
1:2bc809f: 	 */
1:2bc809f: 	public void t_close(T_TWC ctx)
1:2bc809f: 		throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		ctx.tran.close();
1:2bc809f: 		ctx.tran = null;
1:2bc809f: 		ctx.cm = null;		// no need to close a context ???
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * abort a transaction
1:2bc809f: 	 */
1:2bc809f: 	public void t_abort(Transaction t) 
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 		t.abort();
1:2bc809f: 		t_checkNullLockCount(t);
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * abort a transaction with context
1:2bc809f: 	 */
1:2bc809f: 	public void t_abort(T_TWC ctx) 
1:2bc809f: 		throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		csFactory.setCurrentContextManager(ctx.cm);
1:2bc809f: 		try {
1:2bc809f: 		t_abort(ctx.tran);
1:2bc809f: 		} finally {
1:2bc809f: 			csFactory.resetCurrentContextManager(ctx.cm);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Add a new container in the transaction
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public long t_addContainer(Transaction t, long segmentId)
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 		
1:2bc809f: 		long cid = 
1:2bc809f:             t.addContainer(
1:2bc809f:                 segmentId, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:2bc809f:                 ContainerHandle.MODE_DEFAULT, (Properties) null, 0);
1:2bc809f: 
1:2bc809f: 		if (cid < 0)
1:2bc809f: 			throw T_Fail.testFailMsg("add container");
1:2bc809f: 
1:2bc809f: 		return cid;		
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public long t_addContainer(T_TWC ctx, long segmentId)
1:2bc809f: 		throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		csFactory.setCurrentContextManager(ctx.cm);
1:2bc809f: 		try {
1:2bc809f: 		return t_addContainer(ctx.tran, segmentId);
1:2bc809f: 		} finally {
1:2bc809f: 			csFactory.resetCurrentContextManager(ctx.cm);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 
1:2bc809f: 		Add a new container in the transaction with a specified page size
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public long t_addContainer(Transaction t, long segmentId, int pageSize)
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 		Properties tableProperties = new Properties();
1:2bc809f: 		tableProperties.put(Property.PAGE_SIZE_PARAMETER, Integer.toString(pageSize));
1:2bc809f: 		
1:2bc809f: 		long cid = 
1:2bc809f:             t.addContainer(
1:2bc809f:                 segmentId, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:2bc809f:                 ContainerHandle.MODE_DEFAULT, tableProperties, 0);
1:2bc809f: 
1:2bc809f: 		if (cid < 0)
1:2bc809f: 			throw T_Fail.testFailMsg("add container");
1:2bc809f: 
1:2bc809f: 		return cid;		
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public long t_addContainer(T_TWC ctx, long segmentId, int pageSize)
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 		csFactory.setCurrentContextManager(ctx.cm);
1:2bc809f: 		try {
1:2bc809f: 		return t_addContainer(ctx.tran, segmentId, pageSize);
1:2bc809f: 		} finally {
1:2bc809f: 			csFactory.resetCurrentContextManager(ctx.cm);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public long t_addContainer(Transaction t, long segmentId, Properties tableProperties)
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 		long cid = 
1:2bc809f:             t.addContainer(
1:2bc809f:                 segmentId, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:2bc809f:                 ContainerHandle.MODE_DEFAULT, tableProperties, 0);
1:2bc809f: 
1:2bc809f: 		if (cid < 0)
1:2bc809f: 			throw T_Fail.testFailMsg("add container");
1:2bc809f: 
1:2bc809f: 		return cid;		
1:2bc809f: 	}
1:2bc809f: 				
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 
1:2bc809f: 		Add a new container in the transaction with specified 
1:2bc809f:         pageSize, spareSpace, minimumRecordSize, and reusableRecordId
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public long t_addContainer(Transaction t, long segmentId, int pageSize, int spareSpace, 
1:2bc809f: 			int minimumRecordSize, boolean reusableRecordId)
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 		Properties tableProperties = new Properties();
1:2bc809f: 		tableProperties.put(Property.PAGE_SIZE_PARAMETER, Integer.toString(pageSize));
1:2bc809f: 		tableProperties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, Integer.toString(spareSpace));
1:2bc809f: 		tableProperties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, Integer.toString(minimumRecordSize));
1:2bc809f: 
1:2bc809f:         if (reusableRecordId) {
1:2bc809f:             tableProperties.put(RawStoreFactory.PAGE_REUSABLE_RECORD_ID, "true");
1:2bc809f:         }
1:2bc809f: 		
1:2bc809f: 		long cid = 
1:2bc809f:             t.addContainer(
1:2bc809f:                 segmentId, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:2bc809f:                 ContainerHandle.MODE_DEFAULT, tableProperties, 0);
1:2bc809f: 
1:2bc809f: 		if (cid < 0)
1:2bc809f: 			throw T_Fail.testFailMsg("add container");
1:2bc809f: 
1:2bc809f: 		return cid;		
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public long t_addContainer(T_TWC ctx, long segmentId, int pageSize, int spareSpace, int minimumRecordSize)
1:2bc809f: 		throws StandardException, T_Fail {
1:2bc809f: 		csFactory.setCurrentContextManager(ctx.cm);
1:2bc809f: 		try {
1:2bc809f: 		return t_addContainer(ctx.tran, segmentId, pageSize, spareSpace, minimumRecordSize, false);
1:2bc809f: 		} finally {
1:2bc809f: 			csFactory.resetCurrentContextManager(ctx.cm);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Open a container.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	
1:2bc809f: 	public ContainerHandle t_openContainer(Transaction t, long segmentId, long containerId, boolean forUpdate)
1:2bc809f: 		throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		ContainerKey id = new ContainerKey(segmentId, containerId);
1:2bc809f: 		ContainerHandle c = t.openContainer(id,
1:2bc809f: 			forUpdate ? (ContainerHandle.MODE_FORUPDATE | openContainerMode) : ContainerHandle.MODE_READONLY);
1:2bc809f: 		if (c == null)
1:2bc809f: 			throw T_Fail.testFailMsg("ContainerHandle failed to open: (" +
1:2bc809f: 									 segmentId + "," + containerId + ")");
1:2bc809f: 
1:2bc809f: 		return c;
1:2bc809f: 	}
1:2bc809f: 	public ContainerHandle t_openContainer(T_TWC ctx, long segmentId, long containerId, boolean forUpdate)
1:2bc809f: 		throws StandardException, T_Fail 
1:2bc809f: 	{
1:2bc809f: 		csFactory.setCurrentContextManager(ctx.cm);
1:2bc809f: 		try {
1:2bc809f: 			return t_openContainer(ctx.tran, segmentId, containerId, forUpdate);
1:2bc809f: 		} finally {
1:2bc809f: 			csFactory.resetCurrentContextManager(ctx.cm);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Drop a container 
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public void t_dropContainer(Transaction t, long segmentId, long containerId) 
1:2bc809f: 		 throws StandardException, T_Fail
1:2bc809f: 	{
1:2bc809f: 		t.dropContainer(new ContainerKey(segmentId, containerId));
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Get the last page in a container.
1:2bc809f: 		Always returns a valid page or null if there is no page in the container.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public Page t_getLastPage(ContainerHandle c) throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		Page page = c.getFirstPage();
1:2bc809f: 		if (page != null)
1:2bc809f: 		{
1:2bc809f: 			Page nextPage;
1:2bc809f: 			while((nextPage = c.getNextPage(page.getPageNumber())) != null)
1:2bc809f: 			{
1:2bc809f: 				page.unlatch();
1:2bc809f: 				page = nextPage;
1:2bc809f: 			}
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		return page;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Get a specific page in a container.
1:2bc809f: 		Always returns a valid page.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public Page t_getPage(ContainerHandle c, long pageNumber) throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		Page page = c.getPage(pageNumber);
1:2bc809f: 		if (page == null)
1:2bc809f: 			throw T_Fail.testFailMsg("fail to get page " + pageNumber + " from container " + c);
1:2bc809f: 
1:2bc809f: 		if (page.getPageNumber() != pageNumber)
1:2bc809f: 			throw T_Fail.testFailMsg("page expected to have page number " +
1:2bc809f: 				pageNumber + ", has " + page.getPageNumber() + " Container " + c);
1:2bc809f: 
1:2bc809f: 		return page;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Add a page to a container.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Unexpected behaviour from the API
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public Page t_addPage(ContainerHandle c) throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		Page page = c.addPage();
1:2bc809f: 
1:2bc809f: 		if (page == null)
1:2bc809f: 			throw T_Fail.testFailMsg("addPage() returned null");
1:2bc809f: 
1:2bc809f: 		return page;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Remove a page from a container.
1:2bc809f: 
2:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 	*/
1:2bc809f: 	public void t_removePage(ContainerHandle c, Page p) throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		long pnum = p.getPageNumber();
1:2bc809f: 		c.removePage(p);
1:2bc809f: 
1:2bc809f: 		// we should not be able to get this page 
1:2bc809f: 		Page badp = c.getPage(pnum);
1:2bc809f: 		if (badp != null)
1:2bc809f: 			throw T_Fail.testFailMsg("got a deallcated page back");
1:2bc809f: 	} 
1:2bc809f: 
1:b91cfb2: 	/**
1:e257b0e: 	 * Check that it's not possible to get a page which is already latched by
1:e257b0e: 	 * the same transaction.
1:b91cfb2: 	 *
1:b91cfb2: 	 * @param c a container handle
1:b91cfb2: 	 * @param pageNumber the page number to check
1:b91cfb2: 	 * @exception StandardException if an unexpected error occurs
1:b91cfb2: 	 * @exception T_Fail if the test fails
1:b91cfb2: 	 */
1:b91cfb2: 	public void t_checkGetLatchedPage(ContainerHandle c, long pageNumber)
1:b91cfb2: 			throws StandardException, T_Fail {
1:b91cfb2: 
1:b91cfb2: 		try {
1:b91cfb2: 			Page p = c.getPage(pageNumber);
1:b91cfb2: 			throw T_Fail.testFailMsg("got latched page");
1:b91cfb2: 		} catch (StandardException se) {
1:dede9bf:             if (!"XSDAO".equals(se.getSQLState())) {
1:b91cfb2: 				throw se;
1:ab4e752: 			}
1:b91cfb2: 		}
1:b91cfb2: 	}
1:b91cfb2: 
1:2bc809f: 	/**
1:2bc809f: 		Call page.insert() and ensure that the return record handle is not null.
1:2bc809f: 		This assumes the caller has called spaceForInsert.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:2bc809f: 		@see Page#insert
1:2bc809f: 	*/
1:2bc809f: 	public static RecordHandle t_insert(Page page, T_RawStoreRow row)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 		
1:2bc809f: 		RecordHandle rh = page.insert(row.getRow(), (FormatableBitSet) null, Page.INSERT_DEFAULT, 100);
1:2bc809f: 
1:2bc809f: 		return rh;
1:b91cfb2: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Call page.insert() and ensure that the return record handle is not null.
1:2bc809f: 		This assumes the caller has called spaceForInsert.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:2bc809f: 		@see Page#insert
1:2bc809f: 	*/
1:2bc809f: 	public static RecordHandle t_insertAtSlot(Page page, int slot, T_RawStoreRow row)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 		
1:2bc809f: 		RecordHandle rh = page.insertAtSlot(slot, row.getRow(), (FormatableBitSet) null,
1:2bc809f: 			(LogicalUndo) null, Page.INSERT_DEFAULT, 100);
1:2bc809f: 
1:2bc809f: 		return rh;
1:b91cfb2: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Call page.insert() and ensure that the return record handle is not null.
1:2bc809f: 		This assumes the caller has called spaceForInsert.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:2bc809f: 		@see Page#insert
1:2bc809f: 	*/
1:2bc809f: 	public static RecordHandle t_insertAtSlot(Page page, int slot, T_RawStoreRow row, byte insertFlag)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 		
1:2bc809f: 		RecordHandle rh = page.insertAtSlot(slot, row.getRow(), (FormatableBitSet) null,
1:2bc809f: 			(LogicalUndo) null, insertFlag, 100);
1:2bc809f: 
1:2bc809f: 		return rh;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Call page.insert() and ensure that the return record handle is not null.
1:2bc809f: 		This assumes the caller has called spaceForInsert.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:2bc809f: 		@see Page#insert
1:2bc809f: 	*/
1:2bc809f: 	public static RecordHandle t_insertAtSlot(Page page, int slot, T_RawStoreRow row, byte insertFlag,
1:2bc809f: 			int overflowThreshold) throws T_Fail, StandardException {
1:2bc809f: 		
1:2bc809f: 		RecordHandle rh = page.insertAtSlot(slot, row.getRow(), (FormatableBitSet) null,
1:2bc809f: 			(LogicalUndo) null, insertFlag, overflowThreshold);
1:2bc809f: 
1:2bc809f: 		return rh;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Insert a record on the last page, if the row doesn't fit on the
1:2bc809f: 		last page create a new page and insert there.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:2bc809f: 		@see Page#insert
1:2bc809f: 	*/
1:2bc809f: 	public RecordHandle t_insert(ContainerHandle c, T_RawStoreRow row)
1:2bc809f: 		throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		Page page = c.getPageForInsert(0);
1:2bc809f: 		boolean addedPage = false;
1:2bc809f: 
1:2bc809f: 		if (page == null)
1:2bc809f: 		{
1:2bc809f: 			page = t_addPage(c);
1:2bc809f: 			addedPage = true;
1:2bc809f: 		}
1:2bc809f: 		else if (!page.spaceForInsert(row.getRow(), (FormatableBitSet) null, 100)) {
1:2bc809f: 			page.unlatch();
1:2bc809f: 			page = t_addPage(c);
1:2bc809f: 			addedPage = true;
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		RecordHandle rh = t_insert(page, row);
1:2bc809f: 		page.unlatch();
1:2bc809f: 
1:2bc809f: 		if (rh == null) {
1:2bc809f: 			if (addedPage)
1:2bc809f: 				throw T_Fail.testFailMsg("insert returned null on an empty page");
1:2bc809f: 
1:2bc809f: 			page = t_addPage(c);
1:2bc809f: 			rh = t_insert(page, row);
1:2bc809f: 			page.unlatch();
1:2bc809f: 		}
1:2bc809f: 		return rh;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Update a record.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:00d19b5: 		@see Page#updateAtSlot
1:2bc809f: 	*/
1:2bc809f: 	public void t_update(ContainerHandle c, RecordHandle rh, T_RawStoreRow row)
1:2bc809f: 		 throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		Page page = t_getPage(c, rh.getPageNumber());
1:2bc809f: 		try
1:2bc809f: 		{
1:00d19b5: 			int slot = page.getSlotNumber(rh);
1:00d19b5: 			if (page.updateAtSlot(slot, row.getRow(), null) == null)
1:2bc809f: 				throw T_Fail.testFailMsg("update failed");
1:2bc809f: 
1:2bc809f: 			t_checkFetch(page, rh, row);
1:2bc809f: 		}
1:2bc809f: 		finally
1:2bc809f: 		{
1:2bc809f: 			page.unlatch();
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	    Using sparse representation:
1:2bc809f: 		Update a column of a record and check resulting value.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:00d19b5: 		@see Page#updateAtSlot
1:2bc809f: 	*/
1:2bc809f: 	public void t_checkUpdateCol(Page page, RecordHandle rh, int colNum, int
1:2bc809f: 								 numCols, String data)
1:2bc809f: 		 throws T_Fail, StandardException
1:2bc809f: 	{
1:2bc809f: 		if (!page.recordExists(rh, false))
1:2bc809f: 			throw T_Fail.testFailMsg("Record does not exist");
1:2bc809f: 
1:2bc809f: 		T_RawStoreRow writeRow = new T_RawStoreRow(numCols);
1:2bc809f: 		for (int i = 0; i < numCols; i++)	
1:2bc809f: 			writeRow.setColumn(i, (String) null);
1:2bc809f: 		writeRow.setColumn(colNum, data);
1:2bc809f: 		FormatableBitSet colList = new FormatableBitSet(numCols);
1:2bc809f: 		colList.set(colNum);
1:2bc809f: 
1:00d19b5: 		int slot = page.getSlotNumber(rh);
1:00d19b5: 		if (page.updateAtSlot(slot, writeRow.getRow(), colList) == null)
1:2bc809f: 			throw T_Fail.testFailMsg("update failed");
1:2bc809f: 		
1:2bc809f: 		t_checkFetchCol(page, rh, colNum, numCols, data);
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Check to make sure a row (possibly with overflow) is of the correct length
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 		@exception StandardException Unexpected exception from the implementation
1:2bc809f: 
1:2bc809f: 	 */
1:2bc809f: 	public void t_checkStringLengthFetch(Page page, int slot, int expectedLength) throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		T_RawStoreRow rr = new T_RawStoreRow((String) null);
1:2bc809f: 
1:2bc809f: 		page.fetchFromSlot(
1:2bc809f:             (RecordHandle) null, slot, rr.getRow(), 
1:2bc809f:             (FetchDescriptor) null,
1:2bc809f:             true);
1:2bc809f: 
1:2bc809f: 		String s = ((SQLChar) (rr.getStorableColumn(0))).getString();
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		if ((s == null) && (expectedLength < 0))
1:2bc809f: 			return;
1:2bc809f: 
1:2bc809f: 		if ((s != null) && (expectedLength < 0))
1:2bc809f: 			throw T_Fail.testFailMsg("Expected null string, fetched one of length " + s.length());
1:2bc809f: 
1:2bc809f: 		if (s == null)
1:2bc809f: 			throw T_Fail.testFailMsg("Expected string length " + expectedLength + " got null string");
1:2bc809f: 
1:2bc809f: 		if (s.length() != expectedLength)
1:2bc809f: 			throw T_Fail.testFailMsg("fetch string length incorrect expected " + expectedLength + " got " + s.length());
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Lazy people's random file generator:
1:2bc809f: 		Generate a random file with specified name and file size
1:2bc809f: 
1:2bc809f: 		@exception T_Fail Record handle returned is null.
1:2bc809f: 	*/
1:2bc809f: 	public void t_genRandomFile(String fileName, String mode, int size) throws T_Fail {
1:2bc809f: 
1:2bc809f: 		RandomAccessFile iFile = null;
1:b91cfb2: 		try {
1:2bc809f: 			iFile = new RandomAccessFile(fileName, mode);
1:2bc809f: 			for (int i = 0; i < size; i++){
1:2bc809f: 				byte b = (byte) (i & 0xff);
1:2bc809f: 				b = (byte) (((b >= ' ') && (b <= '~')) ? b : ' ');
1:2bc809f: 				iFile.write(b);
1:2bc809f: 			}
1:2bc809f: 			iFile.close();
1:2bc809f: 		} catch (FileNotFoundException fnfe) {
1:2bc809f: 			throw T_Fail.testFailMsg("cannot create new file");
1:2bc809f: 		} catch (IOException ioe) {
1:2bc809f: 			throw T_Fail.testFailMsg("io error, test failed");
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Return a string of stringLen characters that starts with data
1:2bc809f: 		and is padded with nulls.
1:2bc809f: 	*/
1:2bc809f: 	public static String getStringFromData(String data, int stringLen) {
1:2bc809f: 		char[] ca = new char[stringLen];
1:2bc809f: 
1:2bc809f: 		char[] sd = data.toCharArray();
1:2bc809f: 
1:2bc809f: 		System.arraycopy(sd, 0, ca, 0, sd.length);
1:2bc809f: 		
1:2bc809f: 		return new String(ca);
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Make this thread wait a bit, probably for post commit to finish
1:2bc809f: 	 */
1:2bc809f: 	public static void t_wait(int milliSecond)
1:2bc809f: 	{
1:2bc809f: 		Thread.currentThread().yield();
1:2bc809f: 		try
1:2bc809f: 		{
1:2bc809f: 			Thread.currentThread().sleep(milliSecond);
1:2bc809f: 		}
1:2bc809f: 		catch (InterruptedException ie)
1:2bc809f: 		{
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Add in encryption parameters to the startParam if "testDataEncryption"
1:2bc809f: 		is set to a non-null string.
1:2bc809f: 	 */
1:2bc809f: 	public static Properties setEncryptionParam(Properties startParams)
1:2bc809f: 	{
1:2bc809f: 		// see if we are testing encryption
1:2bc809f: 		String encryptionPassword = 
1:2bc809f: 					PropertyUtil.getSystemProperty("testDataEncryption");
1:2bc809f: 		//look for alternate encryption provider
1:2bc809f: 		String encryptionProvider = 
1:2bc809f: 					PropertyUtil.getSystemProperty("testEncryptionProvider");
1:2bc809f: 		if (encryptionPassword != null)
1:2bc809f: 		{
1:2bc809f: 			if (startParams == null)
1:2bc809f: 				startParams = new Properties();
1:2bc809f: 
1:2bc809f: 			startParams.put(Attribute.DATA_ENCRYPTION, "true");
1:2bc809f: 			startParams.put(Attribute.BOOT_PASSWORD, encryptionPassword);
1:2bc809f: 			if (encryptionProvider != null) {
1:2bc809f: 			    startParams.put(Attribute.CRYPTO_PROVIDER, encryptionProvider);
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			//			System.out.println("Setting encryption password to " + encryptionPassword);
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		return startParams;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:dede9bf
/////////////////////////////////////////////////////////////////////////
1:             if (!"XSDAO".equals(se.getSQLState())) {
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e257b0e
/////////////////////////////////////////////////////////////////////////
1: 	 * Check that it's not possible to get a page which is already latched by
1: 	 * the same transaction.
/////////////////////////////////////////////////////////////////////////
0: 		if (!SanityManager.DEBUG) {
0: 			// don't run the interrupter thread in sane builds, since getPage()
0: 			// will throw an assert error instead of hanging (DERBY-2635)
0: 			interrupter.start();
1: 		}
0: 			// expect thread interrupted exception in insane builds
0: 			if (SanityManager.DEBUG || !se.getMessageId().equals("08000")) {
/////////////////////////////////////////////////////////////////////////
0: 			if (interrupter.isAlive()) {
0: 				interrupter.join();
1: 			}
commit:5b7c053
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		} catch (RuntimeException e) {
0: 			// try to double latch a page. The AssertFailure class is not
0: 			// available in insane jars, so we cannot reference the class
0: 			// directly.
0: 				  e.getClass().getName().endsWith(".sanity.AssertFailure") &&
0: 				  e.getMessage().endsWith("Attempted to latch page twice"))) {
0: 				throw e;
commit:ab4e752
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.AssertFailure;
/////////////////////////////////////////////////////////////////////////
0: 		} catch (AssertFailure af) {
0: 			// When running in sane mode, an AssertFailure will be thrown if we
0: 			// try to double latch a page.
0: 			if (!(SanityManager.DEBUG &&
0: 				  af.getMessage().endsWith("Attempted to latch page twice"))) {
0: 				throw af;
1: 			}
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: 		if (lFactory.areLocksHeld(t.getCompatibilitySpace()))
commit:b91cfb2
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Check that it's not possible to get a page which is latched.
1: 	 *
1: 	 * @param c a container handle
1: 	 * @param pageNumber the page number to check
1: 	 * @exception StandardException if an unexpected error occurs
1: 	 * @exception T_Fail if the test fails
1: 	 */
1: 	public void t_checkGetLatchedPage(ContainerHandle c, long pageNumber)
1: 			throws StandardException, T_Fail {
0: 		// we expect to hang in getPage() so make sure we are interrupted
0: 		final Thread me = Thread.currentThread();
0: 		Runnable r = new Runnable() {
0: 				public void run() {
1: 					try {
0: 						Thread.sleep(2000);
0: 					} catch (InterruptedException e) { }
0: 					me.interrupt();
1: 				}
0: 			};
0: 		Thread interrupter = new Thread(r);
0: 		interrupter.start();
1: 
1: 		try {
1: 			Page p = c.getPage(pageNumber);
1: 			throw T_Fail.testFailMsg("got latched page");
1: 		} catch (StandardException se) {
0: 			// expect thread interrupted exception
0: 			if (!se.getMessageId().equals("08000")) {
1: 				throw se;
1: 			}
1: 		}
1: 
1: 		try {
0: 			interrupter.join();
0: 		} catch (InterruptedException ie) { }
1: 	}
commit:00d19b5
/////////////////////////////////////////////////////////////////////////
1: 		@see Page#fetchFromSlot
/////////////////////////////////////////////////////////////////////////
1: 		RecordHandle rhf = page.fetchFromSlot(rh, page.getSlotNumber(rh),
1: 											  readRow.getRow(), null, false);
/////////////////////////////////////////////////////////////////////////
1: 		FetchDescriptor desc = new FetchDescriptor(numCols, colList, null);
1: 		RecordHandle rhf = page.fetchFromSlot(rh, page.getSlotNumber(rh),
1: 											  readRow.getRow(), desc, false);
/////////////////////////////////////////////////////////////////////////
1: 		@see Page#updateAtSlot
/////////////////////////////////////////////////////////////////////////
1: 			int slot = page.getSlotNumber(rh);
1: 			if (page.updateAtSlot(slot, row.getRow(), null) == null)
/////////////////////////////////////////////////////////////////////////
1: 		@see Page#updateAtSlot
/////////////////////////////////////////////////////////////////////////
1: 		int slot = page.getSlotNumber(rh);
1: 		if (page.updateAtSlot(slot, writeRow.getRow(), colList) == null)
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c38b841
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2bc809f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.store.T_Util
1: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.store;
1: 
1: import org.apache.derby.iapi.store.raw.*;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: 
1: // impl imports are the preferred way to create unit tests.
1: import org.apache.derbyTesting.unitTests.harness.T_MultiThreadedIterations;
1: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.locks.*;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: 
1: import org.apache.derby.iapi.reference.Attribute;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.error.ExceptionSeverity;
1: import java.io.*;
1: import java.util.Properties;
1: import org.apache.derby.iapi.types.SQLChar;
1: 
1: 
1: /*
1:   Utility class to help test raw store functionality.  
1: 
1:   If you write a raw store unit test, be that a protocol test or an
1:   implementation test, and find youself needing to do certain operations over
1:   and over again, chances are that functionality is either in here or should be
1:   added.  This class is here entirely for the convenience of people writing
1:   unit tests for the RawStore.
1: */
1: public class T_Util
1: { 
1: 
1: 	RawStoreFactory	rsFactory;
1: 	LockFactory  lFactory;
1: 	ContextService csFactory;
1: 
1: 	private int		openContainerMode;	// mode flags used in openContainer
1: 
1: 	public T_Util(RawStoreFactory rsf, LockFactory lf, 
1: 				  ContextService csf)
1: 	{
1: 		rsFactory = rsf;
1: 		lFactory = lf;
1: 		csFactory = csf;
1: 
1: 		openContainerMode = 0; // logged by default
1: 	}
1: 
1: 	public void setOpenMode(int newMode) {
1: 		openContainerMode = newMode;
1: 	}
1: 
1: 	/*
1: 	 * function that checks for a condition, throws T_Fail exception if the condition
1: 	 * is not met.
1: 	 */
1: 
1: 	/*
1: 	 * check that transaction does not hold any lock
1: 	 */
1: 	public void t_checkNullLockCount(Transaction t) throws T_Fail {
0: 		if (lFactory.areLocksHeld(t))
1: 			throw T_Fail.testFailMsg("Previous action did not clean up all locks.");
1: 	}
1: 
1: 	/*
1: 	 * check that page number on the page matches the input page number
1: 	 */
1: 	public static void t_checkPageNumber(Page page, long pageNumber) throws T_Fail {
1: 		if (page.getPageNumber() != pageNumber)
1: 			throw T_Fail.testFailMsg("page number expected to be " + pageNumber + ", is " +
1: 				page.getPageNumber());
1: 	}
1: 
1: 	/*
1: 	 * check that the number of record on the page matches input.  
1: 	 * @param page the page in question
1: 	 * @param count the total number of record - this include deleted as well as non-deleted
1: 	 * @param nonDeleted the number of non-deleted record
1: 	 */
1: 	public static void t_checkRecordCount(Page page, int count, int nonDeleted) throws T_Fail, StandardException {
1: 		if (page.recordCount() != count)
1: 			throw T_Fail.testFailMsg("recordCount() expected to be " + count + ", is " + page.recordCount());
1: 
1: 		if (page.nonDeletedRecordCount() != nonDeleted)
1: 			throw T_Fail.testFailMsg("nonDeletedRecordCount() expected to be " + nonDeleted + ", is " + page.nonDeletedRecordCount());
1: 	}
1: 
1: 	/*
1: 	 * check the number of fields in the slot
1: 	 */
1: 	public static void t_checkFieldCount(Page page, int slot, int count) throws T_Fail, StandardException {
1: 		if (page.fetchNumFieldsAtSlot(slot) != count)
1: 			throw T_Fail.testFailMsg("number of fields at slot " + slot + " expected to be " + count
1: 									 + ", is " + page.fetchNumFieldsAtSlot(slot));
1: 	}
1: 
1: 	/**
1: 		Fetch a record that is expected to exist using a record handle.
1: 		The record has a T_RawStoreRow of 1 column and this column as value as
1: 		specified by data, which could be null.
1: 
1: 		Calls recordExists() before fetch to ensure that the record
1: 		is there.
1: 
1: 		@param page the page in question
1: 		@param rh the record handle
1: 		@param data the string value that is expected in the row
1: 
1: 		@exception T_Fail Implementation failed expectation
1: 		@exception StandardException Unexpected exception from the implementation
1: 
1: 		@see Page#recordExists
0: 		@see Page#fetch
1: 	*/
1: 	public static void t_checkFetch(Page page, RecordHandle rh, String data, int stringLen)
1: 		throws T_Fail, StandardException {
1: 
1: 		t_checkFetch(page, rh, T_Util.getStringFromData(data, stringLen));
1: 	}
1: 	
1: 	public static void t_checkFetch(Page page, RecordHandle rh, String data)
1: 		throws T_Fail, StandardException {
1: 
1: 		if (!page.recordExists(rh, false))
1: 			throw T_Fail.testFailMsg("Record does not exist");
1: 
1: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1: 
1: 		int slot = page.getSlotNumber(rh);
1: 
1: 		RecordHandle rhf = 
1:             page.fetchFromSlot(
1:                 rh, slot, readRow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 		if (rhf == null)
1: 			throw T_Fail.testFailMsg("Failed to read record");
1: 
1: 		if ((data == null) || readRow.getStorableColumn(0).isNull()) {
1: 
1: 			if ((data == null) && readRow.getStorableColumn(0).isNull())
1: 				return;
1: 
1: 			throw T_Fail.testFailMsg("Record's value incorrect");
1: 		}
1: 
1: 		if (!readRow.toString().equals(data))
1: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1: 	}
1: 
1: 	/**
1: 		Fetch a record from a container that is expected to exist using a record handle.
1: 		Calls recordExists() before fetch to ensure that the record
1: 		is there.
1: 
1: 		@exception T_Fail Implementation failed expectation
1: 		@exception StandardException Unexpected exception from the implementation
1: 
1: 		@see Page#recordExists
0: 		@see Page#fetch
1: 	*/
1: 	public void t_checkFetch(ContainerHandle c, RecordHandle rh, String data)
1: 		throws T_Fail, StandardException {
1: 
1: 		Page page = t_getPage(c, rh.getPageNumber());
1: 
1: 		try
1: 		{
1: 			t_checkFetch(page, rh, data);
1: 		}
1: 		finally
1: 		{
1: 			page.unlatch();
1: 		}
1: 	}
1: 
1: 	/**
1: 		Check to make sure record is NOT there
1: 
1: 		@exception T_Fail Implementation failed expectation
1: 		@exception StandardException Unexpected exception from the implementation
1: 	 */
1: 	public void t_checkFetchFail(ContainerHandle c, RecordHandle rh)
1: 		throws T_Fail, StandardException 
1: 	{
1: 		Page page = t_getPage(c, rh.getPageNumber());
1: 
1: 		try
1: 		{
1: 			if (page.recordExists(rh, true))
1: 				throw T_Fail.testFailMsg("Record Exists");
1: 		}
1: 		finally
1: 		{
1: 			page.unlatch();
1: 		}
1: 	}
1: 
1: 	/**
1: 		Fetch a deleted record from a container using a record handle.
1: 
1: 		@exception T_Fail Implementation failed expectation
1: 		@exception StandardException Unexpected exception from the implementation
1: 
1: 		@see Page#recordExists
0: 		@see Page#fetch
1: 	*/
1: 	public void t_checkFetchDeleted(ContainerHandle c, RecordHandle rh, 
1: 									String data)
1: 		throws T_Fail, StandardException 
1: 	{
1: 		Page p = t_getPage(c, rh.getPageNumber());
1: 		if (p == null)
1: 			throw T_Fail.testFailMsg("Page not found " + rh);
1: 
1: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1: 
1: 		try
1: 		{
1: 			int slot = p.getSlotNumber(rh);
1: 			if (p.fetchFromSlot(
1:                     rh, slot, readRow.getRow(), 
1:                     (FetchDescriptor) null,
1:                     false) != null)
1:             {
1: 				throw T_Fail.testFailMsg(
1:                     "Record at slot " + slot + " not deleted");
1:             }
1: 		}
1: 		finally
1: 		{
1: 			p.unlatch();
1: 		}
1: 	}
1: 
1: 
1: 	/*
1: 		Fetch a record that is expected to exist using a record handle.
1: 		The record contains the values in the passed in row, which is a
1: 		T_RawStoreRow.  A T_RawStoreRow of the same number of columns will be made and fetched
1: 		from the page and compared with the passed in row.
1: 
1: 	*/
1: 	public static void t_checkFetch(Page page, RecordHandle rh, T_RawStoreRow row)
1: 		throws T_Fail, StandardException 
1: 	{
1: 		if (!page.recordExists(rh, false))
1: 			throw T_Fail.testFailMsg("Record does not exist");
1: 
1: 		// try to fetch the same number of columns as the passed in row
1: 		int ncol = row.nColumns();
1: 		T_RawStoreRow readRow = new T_RawStoreRow(ncol);
1: 		for (int i = 0; i < ncol; i++)
1: 			readRow.setColumn(i, (String) null);
1: 
0: 		RecordHandle rhf = page.fetch(rh, readRow.getRow(), (FormatableBitSet) null, false);
1: 		if (rhf == null)
1: 			throw T_Fail.testFailMsg("Failed to read record");
1: 		if (!readRow.toString().equals(row.toString()))
1: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" +
1: 									 row.toString() + ": - got :" + readRow.toString());
1: 	}
1: 
1: 
1: 	/*
1: 	    Using sparse row representation:
1: 		Fetch a column of a record that is expected to exist, using a record 
1: 		handle and a FormatableBitSet object.
1: 		Check that column colNum has value data.
1: 	*/
1: 	public static void t_checkFetchCol(Page page, RecordHandle rh, int colNum,
1: 									   int numCols, String data)
1: 		throws T_Fail, StandardException 
1: 	{
1: 		if (!page.recordExists(rh, false))
1: 			throw T_Fail.testFailMsg("Record does not exist");
1: 
1: 		T_RawStoreRow readRow = new T_RawStoreRow(numCols);
1: 		for (int i = 0; i < numCols; i++)
1: 			readRow.setColumn(i, (String) null);
1: 		FormatableBitSet colList = new FormatableBitSet(numCols);
1: 		colList.set(colNum);
1: 
0: 		RecordHandle rhf = page.fetch(rh, readRow.getRow(), colList, false);
1: 		if (rhf == null)
1: 			throw T_Fail.testFailMsg("Failed to read record");
1: 		String col = readRow.getStorableColumn(colNum).toString();
1: 		if (!col.equals(data))
1: 			throw T_Fail.testFailMsg("Record's value for column " + colNum +
1: 									 " incorrect, expected :" + data +
1: 									 ": - got :" + readRow.toString());
1: 	}
1: 
1: 
1: 	/*
1: 	 * the following is a sequence of fetches, fetching the first row, fetching
1: 	 * the next and previous rows, and fetching the last row in the page.
1: 	 *
1: 	 * The row is assumed to be a T_RawStoreRow with 1 column, which value is the
1: 	 * string specified in data.
1: 	 */
1: 
1: 	/*
1: 	 * fetch and check the first row in the page.  
1: 	 * Return the first row's recordHandle. 
1: 	 */
1: 	public static RecordHandle t_checkFetchFirst(Page page, String data)
1: 		throws T_Fail, StandardException {
1: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1: 
1:         int slot = 0;
1:         while (page.isDeletedAtSlot(slot))
1:         {
1:             slot++;
1:         }
1: 
1: 		RecordHandle rhf = 
1:             page.fetchFromSlot(
1:                 (RecordHandle) null, slot, 
1:                 readRow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 		if (rhf == null)
1: 			throw T_Fail.testFailMsg("Failed to read record");
1: 		if (!readRow.toString().equals(data))
1: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1: 
1: 		return rhf;
1: 	}
1: 
1: 	/*
1: 	 * Fetch and check the next (next to rh) row in the page.
1: 	 * Return the next row's recordHandle
1: 	 */
1: 	public static RecordHandle t_checkFetchNext(Page page, RecordHandle rh, String data)
1: 		throws T_Fail, StandardException {
1: 
1: 		if (!page.recordExists(rh, false))
1: 			throw T_Fail.testFailMsg("Record does not exist");
1: 
1: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1: 
1:         int slot = page.getSlotNumber(rh) + 1;
1:         while (page.isDeletedAtSlot(slot))
1:         {
1:             slot++;
1:         }
1: 
1: 		RecordHandle rhf = 
1:             page.fetchFromSlot(
1:                 (RecordHandle) null, 
1:                 slot,
1:                 readRow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 		if (rhf == null)
1: 			throw T_Fail.testFailMsg("Failed to read record");
1: 		if (!readRow.toString().equals(data))
1: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1: 
1: 		return rhf;
1: 	}
1: 	
1: 	/*
1: 	 * Fetch and check the previous (previous to rh) row in the page.
1: 	 * Return the previous row's recordHandle
1: 	 */
1: 	public static RecordHandle t_checkFetchPrevious(Page page, RecordHandle rh, String data)
1: 		throws T_Fail, StandardException {
1: 
1: 		if (!page.recordExists(rh, false))
1: 			throw T_Fail.testFailMsg("Record does not exist");
1: 
1: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1: 
1:         int slot = page.getSlotNumber(rh) - 1;
1: 
1:         while (page.isDeletedAtSlot(slot) && slot >= 0)
1:         {
1:             slot--;
1:         }
1: 
1:         if (slot == -1)
1:             return(null);
1: 
1: 
1: 		RecordHandle rhf = 
1:             page.fetchFromSlot(
1:                 (RecordHandle) null, 
1:                 slot,
1:                 readRow.getRow(), 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 		if (rhf == null)
1: 			throw T_Fail.testFailMsg("Failed to read record");
1: 		if (!readRow.toString().equals(data))
1: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1: 
1: 		return rhf;
1: 	}
1: 
1: 	/*
1: 	 * Fetch and check the last row in the page.
1: 	 * Return the last row's recordHandle
1: 	 */
1: 	public static RecordHandle t_checkFetchLast(Page page, String data)
1: 		throws T_Fail, StandardException {
1: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1: 
1:         int slot = page.recordCount() - 1;
1:         while (page.isDeletedAtSlot(slot) && slot >= 0)
1:         {
1:             slot--;
1:         }
1: 
1:         if (slot == -1)
1:             return(null);
1: 
1: 		RecordHandle rhf = 
1:             page.fetchFromSlot(
1:                 (RecordHandle) null, 
1:                 slot,
1:                 readRow.getRow(),
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1: 		if (rhf == null)
1: 			throw T_Fail.testFailMsg("Failed to read record");
1: 		if (!readRow.toString().equals(data))
1: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1: 
1: 		return rhf;
1: 	}
1: 
1: 
1: 	/*
1: 	 * Fetch and check the slot on the page.  
1: 	 *
1: 	 * The slot number is NOT a stable reference once the page is unlatched,
1: 	 * this check is only valid if you know the page has not been unlatched
1: 	 * since you put the row in, or you know nobody has touched the page since
1: 	 * you determined the slot number
1: 	 *
1: 	 * The slot refers to a row in the page which has a T_RawStoreRow of 1 column, the
1: 	 * column has the value of data input.
1: 	 *
1: 	 * @param page the page in question
1: 	 * @param slot the slot number (see above)
1: 	 * @param data the column value
1: 	 * @param deleted if the row is deleted, set to true
1: 	 * @param forUpdate If you want to lock the row for update, set forUpdate to true.
1: 	 *
1: 	 */
1: 	public static void t_checkFetchBySlot(Page page, int slot, 
1: 									String data, boolean deleted, 
1: 									boolean forUpdate)
1: 		throws T_Fail, StandardException 
1: 	{
1: 		T_RawStoreRow readRow = new T_RawStoreRow((String) null);
1: 		RecordHandle rh = 
1:             page.fetchFromSlot(
1:                 (RecordHandle) null, slot, 
1:                 readRow.getRow(),
1:                 (FetchDescriptor) null,
1:                 true);
1: 
1: 		if (rh == null)
1: 			throw T_Fail.testFailMsg("Failed to read record");
1: 		if (!readRow.toString().equals(data))
1: 			throw T_Fail.testFailMsg("Record's value incorrect, expected :" + data + ": - got :" + readRow.toString());
1: 
1: 		if (page.isDeletedAtSlot(slot) != deleted)
1: 			throw T_Fail.testFailMsg("Record at slot " + slot + " deleted=" +
1: 									 page.isDeletedAtSlot(slot) + ", expect " + deleted);
1: 
1: 		// RESOLVE: check locking
1: 	}
1: 
1: 	/*
1: 	 * check a column value from a slot on the page
1: 	 *
1: 	 * The slot number is NOT a stable reference once the page is unlatched,
1: 	 * this check is only valid if you know the page has not been unlatched
1: 	 * since you put the row in, or you know nobody has touched the page since
1: 	 * you determined the slot number
1: 	 *
1: 	 * The storable in the specified column put into the input column and it
1: 	 * is check for the same value as the input data 
1: 	 *
1: 	 * @param page the page in question
1: 	 * @param slot the slot number (see above)
1: 	 * @param fieldId the field Id on the row
1: 	 * @param column the storable to put the column in
1: 	 * @param forUpdate true if you want to lock the row for update
1: 	 * @param data the expected value in the column
1: 	 */
1: 	public static void t_checkFetchColFromSlot(Page page,
1: 										 int slot,
1: 										 int fieldId,
1: 										 DataValueDescriptor column,
1: 										 boolean forUpdate,
1: 										 String data,
1: 										 int stringLen)
1: 		 throws StandardException, T_Fail
1: 	{
1: 		t_checkFetchColFromSlot(page, slot, fieldId, column, forUpdate, T_Util.getStringFromData(data, stringLen));
1: 	}
1: 	
1: 	public static void t_checkFetchColFromSlot(
1:     Page                page,
1:     int                 slot,
1:     int                 fieldId,
1:     DataValueDescriptor column,
1:     boolean             forUpdate,
1:     String              data)
1: 		 throws StandardException, T_Fail
1: 	{
1:         DataValueDescriptor[] fetch_row = new DataValueDescriptor[fieldId + 1];
1:         fetch_row[fieldId] = column;
1:         FormatableBitSet validCols = new FormatableBitSet(fieldId + 1);
1:         validCols.set(fieldId);
1: 
1: 		RecordHandle rh =
1: 			page.fetchFromSlot(
1:                 null, slot, fetch_row,
1:                 new FetchDescriptor(
1:                     fetch_row.length, validCols, (Qualifier[][]) null), 
1:                 true);
1: 
1: 		if (rh == null)
1: 			throw T_Fail.testFailMsg("Failed to fetch record: slot "
1: 							 + slot + " field " + fieldId);
1: 
1: 		// RESOLVE - how to check rh lock mode?
1: 
1: 		if (data == null)
1: 		{
1: 			if (!column.isNull())
1: 				throw T_Fail.testFailMsg("Failed to fetch null column: slot "
1: 								 + slot + " field " + fieldId + " column is " + column);
1: 		}
1: 		else
1: 		{
1: 			if (column.isNull())
1: 				throw T_Fail.testFailMsg("expect non null column, got null: slot "
1: 								 + slot + " field " + fieldId);
1: 			if (!column.toString().equals(data))
1: 				throw T_Fail.testFailMsg("expect " + data + " got " + column.toString()
1: 								 + ": slot " + slot + " field " + fieldId);
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 		Take an empty page and check it does actually seem to be empty.
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public static void t_checkEmptyPage(Page page) throws T_Fail, StandardException {
1: 
1: 		// check the counts
1: 		t_checkRecordCount(page, 0, 0);
1: 
1:         try
1:         {
1:             page.fetchFromSlot(
1:                 (RecordHandle) null, 0, null, 
1:                 (FetchDescriptor) null,
1:                 false);
1: 
1:             throw T_Fail.testFailMsg(
1:                 "fetchFromSlot() must throw exception on fetch from slot 0 on an empty page");
1:         }
1:         catch (StandardException se)
1:         {
1:             // expected exception.
1:         }
1: 
1: 		// check we can't get a record handle. NB here we are guessing that 0
1: 		// and RecordHandle.FIRST_RECORD_ID might be valid record identifiers,
1: 		// nothing in the API states that they will be.  Eother way we
1: 		// shouldn't get a valid RecordHandle back.
1: 		if (page.getRecordHandle(0) != null)
1: 			throw T_Fail.testFailMsg("obtained a RecordHandle for an empty page");
1: 
1: 		if (page.getRecordHandle(RecordHandle.FIRST_RECORD_ID) != null)
1: 			throw T_Fail.testFailMsg("obtained a RecordHandle for an empty page");
1: 		
1: 		// should be no aux object
1: 		if (page.getAuxObject() != null)
1: 			throw T_Fail.testFailMsg("empty page has an aux object");
1: 
1: 		t_readOnlySlotOutOfRange(page, Page.FIRST_SLOT_NUMBER);
1: 
1: 		if (!page.spaceForInsert())
1: 			throw T_Fail.testFailMsg("spaceForInsert() returned false on an empty page");
1: 	}
1: 
1: 	/*
1: 		Check to see the correct behaviour for read only operations
1: 		that take a slot when the slot is out of range.
1: 	*/
1: 	public static void t_readOnlySlotOutOfRange(Page page, int slot) throws T_Fail, StandardException {
1: 
1: 		try {
1: 			page.fetchFromSlot(
1:                 (RecordHandle) null, slot, 
1:                 new DataValueDescriptor[0], 
1:                 (FetchDescriptor) null,
1:                 true);
1: 
1: 			throw T_Fail.testFailMsg("fetchFromSlot succeeded on out of range slot " + slot);
1: 		} catch (StandardException se0) {
1: 			// Statement exception expected, throw if not a statement exception.
1:             if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:                 throw se0;
1: 		}
1: 		try {
1: 			page.isDeletedAtSlot(slot);
1: 			throw T_Fail.testFailMsg("isDeletedAtSlot succeeded on out of range slot " + slot);
1: 		} catch (StandardException se2) {
1: 			// Statement exception expected, throw if not a statement exception.
1:             if (se2.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:                 throw se2;
1: 		}
1: 	}
1: 
1: 	/*
1: 		Check to see the correct behaviour for update operations
1: 		that take a slot when the slot is out of range.
1: 	*/
1: 	public static void t_updateSlotOutOfRange(Page page, int slot) throws T_Fail, StandardException {
1: 
1: 		try {
1: 			page.deleteAtSlot(slot, false, (LogicalUndo)null);
1: 			throw T_Fail.testFailMsg("deleteAtSlot succeeded on out of range slot " + slot);
1: 		} catch (StandardException se0) {
1: 			// Statement exception expected, throw if not a statement exception.
1:             if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:                 throw se0;
1: 		}
1: 		try {
1: 			page.deleteAtSlot(slot, true, (LogicalUndo)null);
1: 			throw T_Fail.testFailMsg("deleteAtSlot succeeded on out of range slot " + slot);
1: 		} catch (StandardException se0) {
1: 			// Statement exception expected, throw if not a statement exception.
1:             if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:                 throw se0;
1: 		}
1: 
1: 		T_RawStoreRow row = new T_RawStoreRow((String) null);
1: 
1: 		// insert at the last slot will succeed, so don't do it.
1: 		if (page.recordCount() != slot) {
1: 			try {			
1: 					page.insertAtSlot(slot, row.getRow(), (FormatableBitSet) null, (LogicalUndo)null,
1: 						Page.INSERT_DEFAULT, 100);
1: 					throw T_Fail.testFailMsg("insertAtSlot succeeded, on out of range slot " + slot);
1:             } catch (StandardException se0) {
1:                 // Statement exception expected, throw if not a statement exception.
1:                 if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:                     throw se0;
1:             }
1: 		}
1: 
1: 		try {			
1: 			page.updateAtSlot(slot, row.getRow(), (FormatableBitSet) null);
1: 			throw T_Fail.testFailMsg("updateAtSlot succeeded on out of range slot " + slot);
1:         } catch (StandardException se0) {
1:             // Statement exception expected, throw if not a statement exception.
1:             if (se0.getSeverity() > ExceptionSeverity.STATEMENT_SEVERITY)
1:                 throw se0;
1:         }
1: 	}
1: 
1: 
1: 	/*
1: 	 * Save point checks
1: 	 */
1: 
1: 	/**
1: 		Negative test - check that an invalid savepoint is detected.
1: 	    
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public static void t_checkInvalidSavePoint(Transaction t, String name)
1: 		throws T_Fail, StandardException {
1: 
1: 		// check a non-existent save point is trapped
1: 		try {
1: 			t.rollbackToSavePoint(name, null);
1: 
1: 			throw T_Fail.testFailMsg("non existent save point did not cause exception on rollbackToSavePoint");
1: 		} catch (StandardException se) {
1: 			// we expected this ...
1: 		}
1: 		try {
1: 			t.releaseSavePoint(name, null);
1: 			throw T_Fail.testFailMsg("non existent save point did not cause exception on releaseSavePoint");
1: 
1: 		} catch (StandardException se) {
1: 			// we expected this ...
1: 		}
1: 	}
1: 
1: 	/* 
1: 	 * same as above, check an invalid savepoint in the given transaction
1: 	 * context
1: 	 */
1: 	public void t_checkInvalidSavePoint(T_TWC ctx, String name)
1: 		throws T_Fail, StandardException {
1: 		csFactory.setCurrentContextManager(ctx.cm);
1: 		try {
1: 		t_checkInvalidSavePoint(ctx.tran, name);
1: 		} finally {
1: 			csFactory.resetCurrentContextManager(ctx.cm);
1: 		}
1: 	}
1: 
1: 
1: 	/*
1: 	 * function that actually do something, start, commit, abort a trasaction,
1: 	 * get a page, insert a row, etc.
1: 	 */
1: 
1: 
1: 	/*
1: 		Start a user transaction, ensures that the startTransaction method
1: 		does not return null (which it shouldn't).
1: 	*/
1: 	public Transaction t_startTransaction() 
1: 		throws StandardException, T_Fail {
1: 			
1: 			Transaction t1 = 
1:                 rsFactory.startTransaction(
1:                     csFactory.getCurrentContextManager(),
1: 					AccessFactoryGlobals.USER_TRANS_NAME);
1: 
1: 			if (t1 == null)
1: 				throw T_Fail.testFailMsg("Start a transaction");
1: 			t_checkNullLockCount(t1);
1: 			return t1;
1: 	}
1: 
1: 	/*
1: 		Start a user transaction, ensures that the startTransaction method
1: 		does not return null (which it shouldn't).
1: 	*/
1: 	public Transaction t_startGlobalTransaction(
1:     int     format_id,
1:     byte[]  global_id,
1:     byte[]  branch_id) 
1: 		throws StandardException, T_Fail {
1: 
1: 			Transaction t1 = 
1:                 rsFactory.startGlobalTransaction(
1:                     csFactory.getCurrentContextManager(),
1:                     format_id, global_id, branch_id);
1: 
1: 			if (t1 == null)
1: 				throw T_Fail.testFailMsg("Start a transaction");
1: 			t_checkNullLockCount(t1);
1: 			return t1;
1: 	}
1: 
1: 	/*
1: 	 * start a user transaction with its own context (T_TWC)
1: 	 */
1: 	public T_TWC t_startTransactionWithContext()
1: 		throws StandardException, T_Fail
1: 	{
1: 		T_TWC ctx = new T_TWC(csFactory, lFactory, rsFactory);
1: 		ctx.startUserTransaction();
1: 		return ctx;
1: 	}
1: 
1: 	/*
1: 	 * start an internal transaction
1: 	 */
1: 	public Transaction t_startInternalTransaction() 
1: 		throws StandardException, T_Fail {
1: 
1: 			Transaction t1 = rsFactory.startInternalTransaction(csFactory.getCurrentContextManager());
1: 
1: 			if (t1 == null)
1: 				throw T_Fail.testFailMsg("Failed to start an internal transaction");
1: 			t_checkNullLockCount(t1);
1: 			return t1;
1: 	}
1: 
1: 	/*
1: 	 * commit a transaction
1: 	 */
1: 	public void t_commit(Transaction t) 
1: 		throws StandardException, T_Fail {
1: 		t.commit();
1: 		t_checkNullLockCount(t);
1: 	}
1: 
1: 	/*
1: 	 * commit a transaction with context
1: 	 */
1: 	public void t_commit(T_TWC ctx) 
1: 		throws StandardException, T_Fail 
1: 	{
1: 		csFactory.setCurrentContextManager(ctx.cm);
1: 		try {
1: 		t_commit(ctx.tran);
1: 		} finally {
1: 			csFactory.resetCurrentContextManager(ctx.cm);
1: 		}
1: 	}
1: 
1: 	/*
1: 	 * close a transaction with context
1: 	 */
1: 	public void t_close(T_TWC ctx)
1: 		throws StandardException, T_Fail 
1: 	{
1: 		ctx.tran.close();
1: 		ctx.tran = null;
1: 		ctx.cm = null;		// no need to close a context ???
1: 	}
1: 
1: 	/*
1: 	 * abort a transaction
1: 	 */
1: 	public void t_abort(Transaction t) 
1: 		throws StandardException, T_Fail {
1: 		t.abort();
1: 		t_checkNullLockCount(t);
1: 	}
1: 
1: 	/*
1: 	 * abort a transaction with context
1: 	 */
1: 	public void t_abort(T_TWC ctx) 
1: 		throws StandardException, T_Fail 
1: 	{
1: 		csFactory.setCurrentContextManager(ctx.cm);
1: 		try {
1: 		t_abort(ctx.tran);
1: 		} finally {
1: 			csFactory.resetCurrentContextManager(ctx.cm);
1: 		}
1: 	}
1: 
1: 	/**
1: 		Add a new container in the transaction
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public long t_addContainer(Transaction t, long segmentId)
1: 		throws StandardException, T_Fail {
1: 		
1: 		long cid = 
1:             t.addContainer(
1:                 segmentId, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:                 ContainerHandle.MODE_DEFAULT, (Properties) null, 0);
1: 
1: 		if (cid < 0)
1: 			throw T_Fail.testFailMsg("add container");
1: 
1: 		return cid;		
1: 	}
1: 
1: 	public long t_addContainer(T_TWC ctx, long segmentId)
1: 		throws StandardException, T_Fail 
1: 	{
1: 		csFactory.setCurrentContextManager(ctx.cm);
1: 		try {
1: 		return t_addContainer(ctx.tran, segmentId);
1: 		} finally {
1: 			csFactory.resetCurrentContextManager(ctx.cm);
1: 		}
1: 	}
1: 
1: 	/**
1: 
1: 		Add a new container in the transaction with a specified page size
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public long t_addContainer(Transaction t, long segmentId, int pageSize)
1: 		throws StandardException, T_Fail {
1: 
1: 		Properties tableProperties = new Properties();
1: 		tableProperties.put(Property.PAGE_SIZE_PARAMETER, Integer.toString(pageSize));
1: 		
1: 		long cid = 
1:             t.addContainer(
1:                 segmentId, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:                 ContainerHandle.MODE_DEFAULT, tableProperties, 0);
1: 
1: 		if (cid < 0)
1: 			throw T_Fail.testFailMsg("add container");
1: 
1: 		return cid;		
1: 	}
1: 
1: 	public long t_addContainer(T_TWC ctx, long segmentId, int pageSize)
1: 		throws StandardException, T_Fail {
1: 
1: 		csFactory.setCurrentContextManager(ctx.cm);
1: 		try {
1: 		return t_addContainer(ctx.tran, segmentId, pageSize);
1: 		} finally {
1: 			csFactory.resetCurrentContextManager(ctx.cm);
1: 		}
1: 	}
1: 
1: 	public long t_addContainer(Transaction t, long segmentId, Properties tableProperties)
1: 		throws StandardException, T_Fail {
1: 
1: 		long cid = 
1:             t.addContainer(
1:                 segmentId, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:                 ContainerHandle.MODE_DEFAULT, tableProperties, 0);
1: 
1: 		if (cid < 0)
1: 			throw T_Fail.testFailMsg("add container");
1: 
1: 		return cid;		
1: 	}
1: 				
1: 
1: 	/**
1: 
1: 		Add a new container in the transaction with specified 
1:         pageSize, spareSpace, minimumRecordSize, and reusableRecordId
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public long t_addContainer(Transaction t, long segmentId, int pageSize, int spareSpace, 
1: 			int minimumRecordSize, boolean reusableRecordId)
1: 		throws StandardException, T_Fail {
1: 
1: 		Properties tableProperties = new Properties();
1: 		tableProperties.put(Property.PAGE_SIZE_PARAMETER, Integer.toString(pageSize));
1: 		tableProperties.put(RawStoreFactory.PAGE_RESERVED_SPACE_PARAMETER, Integer.toString(spareSpace));
1: 		tableProperties.put(RawStoreFactory.MINIMUM_RECORD_SIZE_PARAMETER, Integer.toString(minimumRecordSize));
1: 
1:         if (reusableRecordId) {
1:             tableProperties.put(RawStoreFactory.PAGE_REUSABLE_RECORD_ID, "true");
1:         }
1: 		
1: 		long cid = 
1:             t.addContainer(
1:                 segmentId, ContainerHandle.DEFAULT_ASSIGN_ID, 
1:                 ContainerHandle.MODE_DEFAULT, tableProperties, 0);
1: 
1: 		if (cid < 0)
1: 			throw T_Fail.testFailMsg("add container");
1: 
1: 		return cid;		
1: 	}
1: 
1: 	public long t_addContainer(T_TWC ctx, long segmentId, int pageSize, int spareSpace, int minimumRecordSize)
1: 		throws StandardException, T_Fail {
1: 		csFactory.setCurrentContextManager(ctx.cm);
1: 		try {
1: 		return t_addContainer(ctx.tran, segmentId, pageSize, spareSpace, minimumRecordSize, false);
1: 		} finally {
1: 			csFactory.resetCurrentContextManager(ctx.cm);
1: 		}
1: 	}
1: 
1: 	/**
1: 		Open a container.
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	
1: 	public ContainerHandle t_openContainer(Transaction t, long segmentId, long containerId, boolean forUpdate)
1: 		throws StandardException, T_Fail 
1: 	{
1: 		ContainerKey id = new ContainerKey(segmentId, containerId);
1: 		ContainerHandle c = t.openContainer(id,
1: 			forUpdate ? (ContainerHandle.MODE_FORUPDATE | openContainerMode) : ContainerHandle.MODE_READONLY);
1: 		if (c == null)
1: 			throw T_Fail.testFailMsg("ContainerHandle failed to open: (" +
1: 									 segmentId + "," + containerId + ")");
1: 
1: 		return c;
1: 	}
1: 	public ContainerHandle t_openContainer(T_TWC ctx, long segmentId, long containerId, boolean forUpdate)
1: 		throws StandardException, T_Fail 
1: 	{
1: 		csFactory.setCurrentContextManager(ctx.cm);
1: 		try {
1: 			return t_openContainer(ctx.tran, segmentId, containerId, forUpdate);
1: 		} finally {
1: 			csFactory.resetCurrentContextManager(ctx.cm);
1: 		}
1: 	}
1: 
1: 	/**
1: 		Drop a container 
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public void t_dropContainer(Transaction t, long segmentId, long containerId) 
1: 		 throws StandardException, T_Fail
1: 	{
1: 		t.dropContainer(new ContainerKey(segmentId, containerId));
1: 	}
1: 
1: 	/**
1: 		Get the last page in a container.
1: 		Always returns a valid page or null if there is no page in the container.
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public Page t_getLastPage(ContainerHandle c) throws T_Fail, StandardException {
1: 
1: 		Page page = c.getFirstPage();
1: 		if (page != null)
1: 		{
1: 			Page nextPage;
1: 			while((nextPage = c.getNextPage(page.getPageNumber())) != null)
1: 			{
1: 				page.unlatch();
1: 				page = nextPage;
1: 			}
1: 		}
1: 
1: 		return page;
1: 	}
1: 
1: 
1: 	/**
1: 		Get a specific page in a container.
1: 		Always returns a valid page.
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public Page t_getPage(ContainerHandle c, long pageNumber) throws T_Fail, StandardException {
1: 
1: 		Page page = c.getPage(pageNumber);
1: 		if (page == null)
1: 			throw T_Fail.testFailMsg("fail to get page " + pageNumber + " from container " + c);
1: 
1: 		if (page.getPageNumber() != pageNumber)
1: 			throw T_Fail.testFailMsg("page expected to have page number " +
1: 				pageNumber + ", has " + page.getPageNumber() + " Container " + c);
1: 
1: 		return page;
1: 	}
1: 
1: 	/**
1: 		Add a page to a container.
1: 
1: 		@exception T_Fail Unexpected behaviour from the API
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public Page t_addPage(ContainerHandle c) throws T_Fail, StandardException {
1: 
1: 		Page page = c.addPage();
1: 
1: 		if (page == null)
1: 			throw T_Fail.testFailMsg("addPage() returned null");
1: 
1: 		return page;
1: 	}
1: 
1: 	/**
1: 		Remove a page from a container.
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 	*/
1: 	public void t_removePage(ContainerHandle c, Page p) throws T_Fail, StandardException
1: 	{
1: 		long pnum = p.getPageNumber();
1: 		c.removePage(p);
1: 
1: 		// we should not be able to get this page 
1: 		Page badp = c.getPage(pnum);
1: 		if (badp != null)
1: 			throw T_Fail.testFailMsg("got a deallcated page back");
1: 	} 
1: 
1: 
1: 	/**
1: 		Call page.insert() and ensure that the return record handle is not null.
1: 		This assumes the caller has called spaceForInsert.
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 
1: 		@see Page#insert
1: 	*/
1: 	public static RecordHandle t_insert(Page page, T_RawStoreRow row)
1: 		throws T_Fail, StandardException {
1: 		
1: 		RecordHandle rh = page.insert(row.getRow(), (FormatableBitSet) null, Page.INSERT_DEFAULT, 100);
1: 
1: 		return rh;
1: 	}
1: 
1: 	/**
1: 		Call page.insert() and ensure that the return record handle is not null.
1: 		This assumes the caller has called spaceForInsert.
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 
1: 		@see Page#insert
1: 	*/
1: 	public static RecordHandle t_insertAtSlot(Page page, int slot, T_RawStoreRow row)
1: 		throws T_Fail, StandardException {
1: 		
1: 		RecordHandle rh = page.insertAtSlot(slot, row.getRow(), (FormatableBitSet) null,
1: 			(LogicalUndo) null, Page.INSERT_DEFAULT, 100);
1: 
1: 		return rh;
1: 	}
1: 
1: 	/**
1: 		Call page.insert() and ensure that the return record handle is not null.
1: 		This assumes the caller has called spaceForInsert.
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 
1: 		@see Page#insert
1: 	*/
1: 	public static RecordHandle t_insertAtSlot(Page page, int slot, T_RawStoreRow row, byte insertFlag)
1: 		throws T_Fail, StandardException {
1: 		
1: 		RecordHandle rh = page.insertAtSlot(slot, row.getRow(), (FormatableBitSet) null,
1: 			(LogicalUndo) null, insertFlag, 100);
1: 
1: 		return rh;
1: 	}
1: 
1: 	/**
1: 		Call page.insert() and ensure that the return record handle is not null.
1: 		This assumes the caller has called spaceForInsert.
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 
1: 		@see Page#insert
1: 	*/
1: 	public static RecordHandle t_insertAtSlot(Page page, int slot, T_RawStoreRow row, byte insertFlag,
1: 			int overflowThreshold) throws T_Fail, StandardException {
1: 		
1: 		RecordHandle rh = page.insertAtSlot(slot, row.getRow(), (FormatableBitSet) null,
1: 			(LogicalUndo) null, insertFlag, overflowThreshold);
1: 
1: 		return rh;
1: 	}
1: 
1: 	/**
1: 		Insert a record on the last page, if the row doesn't fit on the
1: 		last page create a new page and insert there.
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 
1: 		@see Page#insert
1: 	*/
1: 	public RecordHandle t_insert(ContainerHandle c, T_RawStoreRow row)
1: 		throws T_Fail, StandardException {
1: 
1: 		Page page = c.getPageForInsert(0);
1: 		boolean addedPage = false;
1: 
1: 		if (page == null)
1: 		{
1: 			page = t_addPage(c);
1: 			addedPage = true;
1: 		}
1: 		else if (!page.spaceForInsert(row.getRow(), (FormatableBitSet) null, 100)) {
1: 			page.unlatch();
1: 			page = t_addPage(c);
1: 			addedPage = true;
1: 		}
1: 
1: 		RecordHandle rh = t_insert(page, row);
1: 		page.unlatch();
1: 
1: 		if (rh == null) {
1: 			if (addedPage)
1: 				throw T_Fail.testFailMsg("insert returned null on an empty page");
1: 
1: 			page = t_addPage(c);
1: 			rh = t_insert(page, row);
1: 			page.unlatch();
1: 		}
1: 		return rh;
1: 	}
1: 
1: 	/**
1: 		Update a record.
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 
0: 		@see Page#update
1: 	*/
1: 	public void t_update(ContainerHandle c, RecordHandle rh, T_RawStoreRow row)
1: 		 throws T_Fail, StandardException
1: 	{
1: 		Page page = t_getPage(c, rh.getPageNumber());
1: 		try
1: 		{
0: 			if (!page.update(rh, row.getRow(), (FormatableBitSet)null))
1: 				throw T_Fail.testFailMsg("update failed");
1: 
1: 			t_checkFetch(page, rh, row);
1: 		}
1: 		finally
1: 		{
1: 			page.unlatch();
1: 		}
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	    Using sparse representation:
1: 		Update a column of a record and check resulting value.
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 
0: 		@see Page#update
1: 	*/
1: 	public void t_checkUpdateCol(Page page, RecordHandle rh, int colNum, int
1: 								 numCols, String data)
1: 		 throws T_Fail, StandardException
1: 	{
1: 		if (!page.recordExists(rh, false))
1: 			throw T_Fail.testFailMsg("Record does not exist");
1: 
1: 		T_RawStoreRow writeRow = new T_RawStoreRow(numCols);
1: 		for (int i = 0; i < numCols; i++)	
1: 			writeRow.setColumn(i, (String) null);
1: 		writeRow.setColumn(colNum, data);
1: 		FormatableBitSet colList = new FormatableBitSet(numCols);
1: 		colList.set(colNum);
1: 
0: 		if (!page.update(rh, writeRow.getRow(), colList))
1: 			throw T_Fail.testFailMsg("update failed");
1: 		
1: 		t_checkFetchCol(page, rh, colNum, numCols, data);
1: 	}
1: 
1:         
1: 
1: 	/**
0: 		Delete a record.
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 
0: 		@see Page#delete
1: 	*/
0: 	public void t_delete(ContainerHandle c, RecordHandle rh)
1: 		throws T_Fail, StandardException {
1: 
1: 		Page page = t_getPage(c, rh.getPageNumber());
1: 
1: 		try
1: 		{
1: 			if (!page.recordExists(rh, false))
0: 				throw T_Fail.testFailMsg("record does not exist");
1: 
0: 			if (!page.delete(rh, (LogicalUndo)null))
0: 				throw T_Fail.testFailMsg("delete failed");
1: 
0: 			if (page.recordExists(rh, false))
0: 				throw T_Fail.testFailMsg("recordExists() returns true after a delete");
1: 		}
1: 		finally
1: 		{
1: 			page.unlatch();
1: 		}
1: 	}
1: 
1: 	/**
1: 		Check to make sure a row (possibly with overflow) is of the correct length
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 		@exception StandardException Unexpected exception from the implementation
1: 
1: 	 */
1: 	public void t_checkStringLengthFetch(Page page, int slot, int expectedLength) throws T_Fail, StandardException {
1: 
1: 		T_RawStoreRow rr = new T_RawStoreRow((String) null);
1: 
1: 		page.fetchFromSlot(
1:             (RecordHandle) null, slot, rr.getRow(), 
1:             (FetchDescriptor) null,
1:             true);
1: 
1: 		String s = ((SQLChar) (rr.getStorableColumn(0))).getString();
1: 
1: 
1: 		if ((s == null) && (expectedLength < 0))
1: 			return;
1: 
1: 		if ((s != null) && (expectedLength < 0))
1: 			throw T_Fail.testFailMsg("Expected null string, fetched one of length " + s.length());
1: 
1: 		if (s == null)
1: 			throw T_Fail.testFailMsg("Expected string length " + expectedLength + " got null string");
1: 
1: 		if (s.length() != expectedLength)
1: 			throw T_Fail.testFailMsg("fetch string length incorrect expected " + expectedLength + " got " + s.length());
1: 	}
1: 
1: 	/**
1: 		Lazy people's random file generator:
1: 		Generate a random file with specified name and file size
1: 
1: 		@exception T_Fail Record handle returned is null.
1: 	*/
1: 	public void t_genRandomFile(String fileName, String mode, int size) throws T_Fail {
1: 
1: 		RandomAccessFile iFile = null;
1: 		try {
1: 			iFile = new RandomAccessFile(fileName, mode);
1: 			for (int i = 0; i < size; i++){
1: 				byte b = (byte) (i & 0xff);
1: 				b = (byte) (((b >= ' ') && (b <= '~')) ? b : ' ');
1: 				iFile.write(b);
1: 			}
1: 			iFile.close();
1: 		} catch (FileNotFoundException fnfe) {
1: 			throw T_Fail.testFailMsg("cannot create new file");
1: 		} catch (IOException ioe) {
1: 			throw T_Fail.testFailMsg("io error, test failed");
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 		Return a string of stringLen characters that starts with data
1: 		and is padded with nulls.
1: 	*/
1: 	public static String getStringFromData(String data, int stringLen) {
1: 		char[] ca = new char[stringLen];
1: 
1: 		char[] sd = data.toCharArray();
1: 
1: 		System.arraycopy(sd, 0, ca, 0, sd.length);
1: 		
1: 		return new String(ca);
1: 	}
1: 
1: 	/**
1: 		Make this thread wait a bit, probably for post commit to finish
1: 	 */
1: 	public static void t_wait(int milliSecond)
1: 	{
1: 		Thread.currentThread().yield();
1: 		try
1: 		{
1: 			Thread.currentThread().sleep(milliSecond);
1: 		}
1: 		catch (InterruptedException ie)
1: 		{
1: 		}
1: 	}
1: 
1: 	/**
1: 		Add in encryption parameters to the startParam if "testDataEncryption"
1: 		is set to a non-null string.
1: 	 */
1: 	public static Properties setEncryptionParam(Properties startParams)
1: 	{
1: 		// see if we are testing encryption
1: 		String encryptionPassword = 
1: 					PropertyUtil.getSystemProperty("testDataEncryption");
1: 		//look for alternate encryption provider
1: 		String encryptionProvider = 
1: 					PropertyUtil.getSystemProperty("testEncryptionProvider");
1: 		if (encryptionPassword != null)
1: 		{
1: 			if (startParams == null)
1: 				startParams = new Properties();
1: 
1: 			startParams.put(Attribute.DATA_ENCRYPTION, "true");
1: 			startParams.put(Attribute.BOOT_PASSWORD, encryptionPassword);
1: 			if (encryptionProvider != null) {
1: 			    startParams.put(Attribute.CRYPTO_PROVIDER, encryptionProvider);
1: 			}
1: 
1: 			//			System.out.println("Setting encryption password to " + encryptionPassword);
1: 
1: 		}
1: 
1: 		return startParams;
1: 	}
1: 
1: }
============================================================================