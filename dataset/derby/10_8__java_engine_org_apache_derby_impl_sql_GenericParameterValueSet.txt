2:eac0369: /*
18:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.GenericParameterValueSet
1:345de35: 
1:67c1c96:    Licensed to the Apache Software Foundation (ASF) under one or more
1:67c1c96:    contributor license agreements.  See the NOTICE file distributed with
1:67c1c96:    this work for additional information regarding copyright ownership.
1:67c1c96:    The ASF licenses this file to you under the Apache License, Version 2.0
1:67c1c96:    (the "License"); you may not use this file except in compliance with
1:67c1c96:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
9:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql;
1:eac0369: 
1:992f56f: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:992f56f: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.sql.ParameterValueSet;
1:7736829: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:45075cc: import org.apache.derby.iapi.types.UserDataValue;
1:4c2fc4a: import org.apache.derby.impl.jdbc.Util;
1:eac0369: 
1:eac0369: import java.io.InputStream;
1:e33b8d8: import java.sql.ParameterMetaData;
1:eac0369: import java.sql.Types;
1:eac0369: 
6:eac0369: /**
1:eac0369:  * Implementation of ParameterValueSet
8:eac0369:  *
1:eac0369:  * @see ParameterValueSet
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:eac0369: final class GenericParameterValueSet implements ParameterValueSet 
10:eac0369: {
1:eac0369:   //all this has to be copied in the clone constructor
1:eac0369: 	private final GenericParameter[]				parms;
1:eac0369: 	final ClassInspector 			ci;
1:eac0369: 	private	final boolean			hasReturnOutputParam;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor for a GenericParameterValueSet
1:eac0369: 	 *
1:eac0369: 	 * @param numParms	The number of parameters in the new ParameterValueSet
1:eac0369: 	 * @param hasReturnOutputParam	if we have a ? = call syntax.  Note that
1:eac0369: 	 *			this is NOT the same thing as an output parameter -- return
1:eac0369: 	 *			output parameters are special cases of output parameters.
1:eac0369: 	 */
1:eac0369: 	GenericParameterValueSet(ClassInspector ci, int numParms, boolean hasReturnOutputParam)
1:eac0369: 	{
1:eac0369: 		this.ci = ci;
1:eac0369: 		this.hasReturnOutputParam = hasReturnOutputParam;
1:eac0369: 		parms = new GenericParameter[numParms];
1:eac0369: 		for (int i = 0; i < numParms; i++)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Last param is if this is a return output param.  True if 
1:eac0369: 			** we have an output param and we are on the 1st parameter.
1:eac0369: 			*/	
1:eac0369: 			parms[i] = new GenericParameter(this, (hasReturnOutputParam && i == 0));
1:992f56f: 		}
11:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Construct a pvs by cloning a pvs.
1:eac0369: 	*/
1:eac0369: 	private GenericParameterValueSet(int numParms, GenericParameterValueSet pvs)
1:eac0369: 	{
1:eac0369: 		this.hasReturnOutputParam = pvs.hasReturnOutputParam;
1:eac0369: 		this.ci = pvs.ci;
1:eac0369: 		parms = new GenericParameter[numParms];
1:eac0369: 		for (int i = 0; i < numParms; i++)
1:eac0369: 		{
1:eac0369: 			parms[i] = pvs.getGenericParameter(i).getClone(this);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** ParameterValueSet interface methods
1:eac0369: 	*/
1:7736829: 	
1:7736829: 	/**
1:7736829: 	 * Initialize the set by allocating a holder DataValueDescriptor object
1:7736829: 	 * for each parameter.
1:7736829: 	 */
1:dbfbecb: 	public void initialize(DataTypeDescriptor[] types) throws StandardException
1:7736829: 	{
1:7736829: 		for (int i = 0; i < parms.length; i++)
1:7736829: 		{
1:7736829: 			DataTypeDescriptor dtd = types[i];
1:7736829: 			
1:7736829: 			parms[i].initialize(dtd.getNull(),
1:7736829: 					dtd.getJDBCTypeId(), dtd.getTypeId().getCorrespondingJavaTypeName());
1:7736829: 		}
1:7736829: 	}
1:eac0369: 
1:eac0369: 	public void setParameterMode(int position, int mode) {
1:eac0369: 		parms[position].parameterMode = (short) mode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ParameterValueSet#clearParameters
1:eac0369: 	 */
1:eac0369: 	public void clearParameters()
1:eac0369: 	{
1:eac0369: 		for (int i = 0; i < parms.length; i++)
1:eac0369: 		{
1:eac0369: 			parms[i].clear();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the number of parameters in this set.
1:eac0369: 	 *
1:eac0369: 	 * @return	The number of parameters in this set.
1:eac0369: 	 */
1:eac0369:     public	int	getParameterCount()
1:eac0369: 	{
1:eac0369: 		return parms.length;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the parameter value at the given position.
1:eac0369: 	 *
1:eac0369: 	 * @return	The parameter at the given position.
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public	DataValueDescriptor	getParameter( int position ) throws StandardException
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			return parms[position].getValue();
1:eac0369: 		} catch (ArrayIndexOutOfBoundsException e) {
1:eac0369: 			checkPosition(position);
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	public	DataValueDescriptor	getParameterForSet(int position) throws StandardException {
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 
1:eac0369: 			GenericParameter gp = parms[position];
1:e33b8d8:             if (gp.parameterMode == (ParameterMetaData.parameterModeOut))
1:eac0369: 				throw StandardException.newException(SQLState.LANG_RETURN_OUTPUT_PARAM_CANNOT_BE_SET);
1:eac0369: 
1:eac0369: 			gp.isSet = true;
1:eac0369: 
1:eac0369: 			return gp.getValue();
1:eac0369: 		} catch (ArrayIndexOutOfBoundsException e) {
1:eac0369: 			checkPosition(position);
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	public	DataValueDescriptor	getParameterForGet(int position) throws StandardException {
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 
1:eac0369: 			GenericParameter gp = parms[position];
1:eac0369: 
1:eac0369: 			switch (gp.parameterMode) {
1:e33b8d8:             case (ParameterMetaData.parameterModeIn):
1:e33b8d8:             case (ParameterMetaData.parameterModeUnknown):
1:eac0369: 				throw StandardException.newException(SQLState.LANG_NOT_OUTPUT_PARAMETER, Integer.toString(position + 1));
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return gp.getValue();
1:eac0369: 		} catch (ArrayIndexOutOfBoundsException e) {
1:eac0369: 			checkPosition(position);
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setParameterAsObject(int position, Object value) throws StandardException {
1:eac0369: 
1:45075cc: 		UserDataValue dvd = (UserDataValue) getParameterForSet(position);
1:eac0369: 
1:eac0369: 		GenericParameter gp = parms[position];
1:806114c: 		if (value != null) {
1:eac0369: 
1:eac0369: 			{
1:eac0369: 
1:eac0369: 				boolean throwError;
1:eac0369: 				ClassNotFoundException t = null;
1:eac0369: 				try {
1:eac0369: 					throwError = !ci.instanceOf(gp.declaredClassName, value);
1:eac0369: 				} catch (ClassNotFoundException cnfe) {
1:eac0369: 					t = cnfe;
1:eac0369: 					throwError = true;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (throwError) {
1:eac0369: 					throw StandardException.newException(SQLState.LANG_DATA_TYPE_SET_MISMATCH, t,
1:eac0369: 						ClassInspector.readableClassName(value.getClass()), gp.declaredClassName);
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		dvd.setValue(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ParameterValueSet#allAreSet
1:eac0369: 	 */
1:eac0369: 	public boolean allAreSet()
1:eac0369: 	{
1:eac0369: 		for (int i = 0; i < parms.length; i++)
1:eac0369: 		{
1:eac0369: 			GenericParameter gp = parms[i];
1:eac0369: 			if (!gp.isSet)
1:eac0369: 			{
1:eac0369: 				switch (gp.parameterMode) {
1:e33b8d8:                 case (ParameterMetaData.parameterModeOut):
1:eac0369: 					break;
1:e33b8d8:                 case (ParameterMetaData.parameterModeInOut):
1:e33b8d8:                 case (ParameterMetaData.parameterModeUnknown):
1:e33b8d8:                 case (ParameterMetaData.parameterModeIn):
1:eac0369: 					return false;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ParameterValueSet#transferDataValues
1:eac0369: 	 */
1:eac0369: 	public void  transferDataValues(ParameterValueSet pvstarget) throws StandardException
1:eac0369: 	{
1:eac0369: 		// don't take application's values for return output parameters
1:eac0369: 		int firstParam = pvstarget.hasReturnOutputParameter() ? 1 : 0;
1:eac0369: 		for (int i = firstParam; i < parms.length;i++)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			GenericParameter oldp = parms[i];
1:eac0369: 
1:eac0369: 			if (oldp.registerOutType != Types.NULL) {
1:eac0369: 
1:eac0369: 				pvstarget.registerOutParameter(i, oldp.registerOutType, oldp.registerOutScale);
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (oldp.isSet)
1:eac0369: 			{
1:992f56f:                 DataValueDescriptor dvd = oldp.getValue();
1:992f56f:                 InputStream is = null;
1:992f56f:                 // See if the value type can hold a stream.
1:541361f:                 if (dvd.hasStream()) {
1:992f56f:                     // DERBY-4455: Don't materialize the stream when
1:992f56f:                     // transferring it. If the stream has been drained already,
1:992f56f:                     // and the user doesn't set a new value before executing
1:992f56f:                     // the prepared statement again, Derby will fail.
1:541361f:                     pvstarget.getParameterForSet(i).setValue(dvd.getStream(),
1:992f56f:                             DataValueDescriptor.UNKNOWN_LOGICAL_LENGTH);
1:992f56f:                 } else {
1:992f56f:                     pvstarget.getParameterForSet(i).setValue(dvd);
1:992f56f:                 }
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	GenericParameter getGenericParameter(int position)
1:eac0369: 	{
1:eac0369:     return(parms[position]);
1:eac0369:   }
1:eac0369: 
1:eac0369: 	/* Class implementation */
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		/* This method needed for derby.language.logStatementText=true.
1:eac0369: 		 * Do not put under SanityManager.DEBUG.
1:eac0369: 		 */
1:eac0369: 		StringBuffer strbuf = new StringBuffer();
1:eac0369: 
1:eac0369: 		for (int ctr = 0; ctr < parms.length; ctr++)
1:eac0369: 		{
1:eac0369: 			strbuf.append("begin parameter #" + (ctr + 1) + ": ");
1:eac0369: 			strbuf.append(parms[ctr].toString());
1:eac0369: 			strbuf.append(" :end parameter ");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return strbuf.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check the position number for a parameter and throw an exception if
1:eac0369: 	 * it is out of range.
1:eac0369: 	 *
1:eac0369: 	 * @param position	The position number to check
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	Thrown if position number is
1:eac0369: 	 *											out of range.
1:eac0369: 	 */
1:eac0369: 	private void checkPosition(int position) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (position < 0 || position >= parms.length)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			if (parms.length == 0)
1:eac0369: 				throw StandardException.newException(SQLState.NO_INPUT_PARAMETERS);
1:eac0369: 
1:eac0369: 			throw StandardException.newException(SQLState.LANG_INVALID_PARAM_POSITION, 
1:eac0369: 															String.valueOf(position+1),
1:eac0369: 															String.valueOf(parms.length));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public ParameterValueSet getClone()
1:eac0369: 	{
1:eac0369: 		return(new GenericParameterValueSet(parms.length, this));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CALLABLE STATEMENT
1:eac0369: 	//
1:eac0369: 	//////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the parameter as an output parameter.
1:eac0369: 	 *
1:eac0369: 	 * @param parameterIndex	The ordinal parameterIndex of a parameter to set
1:eac0369: 	 *			to the given value.
1:4c2fc4a: 	 * @param jdbcType	A type from java.sql.Types
1:eac0369: 	 * @param scale		the scale to use.  -1 means ignore scale
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:4c2fc4a: 	public void registerOutParameter(int parameterIndex, int jdbcType, int scale)
1:92268ac: 		throws StandardException
1:eac0369: 	{
1:4c2fc4a: 		checkPosition( parameterIndex );
1:4c2fc4a:         Util.checkSupportedRaiseStandard( jdbcType );
1:4c2fc4a: 		parms[ parameterIndex ].setOutParameter( jdbcType, scale );
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Validate the parameters.  This is done for situations where
1:eac0369: 	 * we cannot validate everything in the setXXX() calls.  In
1:eac0369: 	 * particular, before we do an execute() on a CallableStatement,
1:eac0369: 	 * we need to go through the parameters and make sure that
1:eac0369: 	 * all parameters are set up properly.  The motivator for this
1:eac0369: 	 * is that setXXX() can be called either before or after 
1:eac0369: 	 * registerOutputParamter(), we cannot be sure we have the types
1:eac0369: 	 * correct until we get to execute().
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException if the parameters aren't valid
1:eac0369: 	 */
1:eac0369: 	public void validate() throws StandardException
1:eac0369: 	{
1:eac0369: 		for (int i = 0; i < parms.length; i++)
1:eac0369: 		{
1:eac0369: 			parms[i].validate();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the parameter number (in jdbc lingo, i.e. 1 based)
1:eac0369: 	 * for the given parameter.  Linear search. 
1:eac0369: 	 *
1:eac0369: 	 * @return the parameter number, or 0 if not found
1:eac0369: 	 */
1:eac0369: 	public int getParameterNumber(GenericParameter theParam)
1:eac0369: 	{
1:eac0369: 		for (int i = 0; i < parms.length; i++)
1:eac0369: 		{
1:eac0369: 			if (parms[i] == theParam)
1:eac0369: 			{
1:eac0369: 				return i+1;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Check that there are not output parameters defined
1:eac0369: 		by the parameter set. If there are unknown parameter
1:94f158a: 		types they are forced to input types. i.e. Derby static method
1:eac0369: 		calls with parameters that are array.
1:eac0369: 
1:eac0369: 		@return true if a declared Java Procedure INOUT or OUT parameter is in the set, false otherwise.
1:eac0369: 	*/
1:eac0369: 	public boolean checkNoDeclaredOutputParameters() {
1:eac0369: 
1:eac0369: 		boolean hasDeclaredOutputParameter = false;
1:eac0369: 		for (int i=0; i<parms.length; i++) {
1:eac0369: 
1:eac0369: 			GenericParameter gp = parms[i];
1:eac0369: 
1:eac0369: 			switch (gp.parameterMode) {
1:e33b8d8:             case (ParameterMetaData.parameterModeIn):
1:eac0369: 				break;
1:e33b8d8:             case (ParameterMetaData.parameterModeInOut):
1:e33b8d8:             case (ParameterMetaData.parameterModeOut):
1:eac0369: 				hasDeclaredOutputParameter = true;
1:eac0369: 				break;
1:e33b8d8:             case (ParameterMetaData.parameterModeUnknown):
1:e33b8d8:                 gp.parameterMode = (ParameterMetaData.parameterModeIn);
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return hasDeclaredOutputParameter;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the mode of the parameter according to JDBC 3.0 ParameterMetaData
1:eac0369: 	 * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public short getParameterMode(int parameterIndex)
1:eac0369: 	{
1:eac0369: 		short mode = parms[parameterIndex - 1].parameterMode;
1:eac0369: 		//if (mode == (short) JDBC30Translation.PARAMETER_MODE_UNKNOWN)
1:eac0369: 		//	mode = (short) JDBC30Translation.PARAMETER_MODE_IN;
1:eac0369: 		return mode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is there a return output parameter in this pvs.  A return
1:eac0369: 	 * parameter is from a CALL statement of the following
1:eac0369: 	 * syntax: ? = CALL myMethod()
1:eac0369: 	 *
1:eac0369: 	 * @return true if it has a return parameter
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public boolean hasReturnOutputParameter()
1:eac0369: 	{
1:eac0369: 		return hasReturnOutputParam;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:698e318:      * Get the value of the return parameter in order to set it.
1:698e318:      *
1:eac0369:  	 *
2:eac0369:      * @exception StandardException if a database-access error occurs.
1:eac0369:      */
1:698e318:     public DataValueDescriptor getReturnValueForSet() throws StandardException
1:eac0369: 	{
1:eac0369: 		checkPosition(0);
1:698e318: 				
2:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:698e318: 			if (!hasReturnOutputParam)
1:698e318: 				SanityManager.THROWASSERT("getReturnValueForSet called on non-return parameter");
1:eac0369: 		}
1:698e318: 		
1:698e318: 		return parms[0].getValue();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the scale of the given parameter index in this pvs.
1:eac0369: 	 *
1:eac0369: 	 * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369: 	 *
1:eac0369: 	 * @return scale
1:eac0369: 	 */
1:eac0369: 	public int getScale(int parameterIndex)
1:eac0369: 	{
1:eac0369: 		return parms[parameterIndex-1].getScale();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the precision of the given parameter index in this pvs.
1:eac0369: 	 *
1:eac0369: 	 * @param parameterIndex the first parameter is 1, the second is 2, ...
1:eac0369: 	 *
1:eac0369: 	 * @return precision
1:eac0369: 	 */
1:eac0369: 	public int getPrecision(int parameterIndex)
1:eac0369: 	{
1:eac0369: 		return parms[parameterIndex-1].getPrecision();
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ParameterMetaData;
/////////////////////////////////////////////////////////////////////////
1:             if (gp.parameterMode == (ParameterMetaData.parameterModeOut))
/////////////////////////////////////////////////////////////////////////
1:             case (ParameterMetaData.parameterModeIn):
1:             case (ParameterMetaData.parameterModeUnknown):
/////////////////////////////////////////////////////////////////////////
1:                 case (ParameterMetaData.parameterModeOut):
1:                 case (ParameterMetaData.parameterModeInOut):
1:                 case (ParameterMetaData.parameterModeUnknown):
1:                 case (ParameterMetaData.parameterModeIn):
/////////////////////////////////////////////////////////////////////////
1:             case (ParameterMetaData.parameterModeIn):
1:             case (ParameterMetaData.parameterModeInOut):
1:             case (ParameterMetaData.parameterModeOut):
1:             case (ParameterMetaData.parameterModeUnknown):
1:                 gp.parameterMode = (ParameterMetaData.parameterModeIn);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4c2fc4a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.jdbc.Util;
/////////////////////////////////////////////////////////////////////////
1: 	 * @param jdbcType	A type from java.sql.Types
1: 	public void registerOutParameter(int parameterIndex, int jdbcType, int scale)
1: 		checkPosition( parameterIndex );
1:         Util.checkSupportedRaiseStandard( jdbcType );
1: 		parms[ parameterIndex ].setOutParameter( jdbcType, scale );
commit:9495437
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
/////////////////////////////////////////////////////////////////////////
0:         throws StandardException
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:541361f
/////////////////////////////////////////////////////////////////////////
1:                 if (dvd.hasStream()) {
1:                     pvstarget.getParameterForSet(i).setValue(dvd.getStream(),
commit:992f56f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.types.SQLBit;
0: import org.apache.derby.iapi.types.SQLBlob;
0: import org.apache.derby.iapi.types.SQLChar;
/////////////////////////////////////////////////////////////////////////
1:                 DataValueDescriptor dvd = oldp.getValue();
1:                 InputStream is = null;
1:                 // See if the value type can hold a stream.
0:                 // SQLBinary isn't public, check for both SQLBlob and SQLBit.
0:                 if (dvd instanceof SQLChar || dvd instanceof SQLBlob ||
0:                         dvd instanceof SQLBit) {
0:                     is = dvd.getStream();
1:                 }
0:                 if (is != null) {
1:                     // DERBY-4455: Don't materialize the stream when
1:                     // transferring it. If the stream has been drained already,
1:                     // and the user doesn't set a new value before executing
1:                     // the prepared statement again, Derby will fail.
0:                     pvstarget.getParameterForSet(i).setValue(is,
1:                             DataValueDescriptor.UNKNOWN_LOGICAL_LENGTH);
1:                 } else {
1:                     pvstarget.getParameterForSet(i).setValue(dvd);
1:                 }
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:dbfbecb
/////////////////////////////////////////////////////////////////////////
1: 	public void initialize(DataTypeDescriptor[] types) throws StandardException
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		types they are forced to input types. i.e. Derby static method
author:David Van Couvering
-------------------------------------------------------------------------------
commit:67c1c96
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 		if (value != null) {
commit:698e318
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Get the value of the return parameter in order to set it.
1:  	 *
1:     public DataValueDescriptor getReturnValueForSet() throws StandardException
1: 				
1: 			if (!hasReturnOutputParam)
1: 				SanityManager.THROWASSERT("getReturnValueForSet called on non-return parameter");
1: 		
1: 		return parms[0].getValue();
commit:45075cc
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.UserDataValue;
/////////////////////////////////////////////////////////////////////////
1: 		UserDataValue dvd = (UserDataValue) getParameterForSet(position);
/////////////////////////////////////////////////////////////////////////
commit:7736829
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Initialize the set by allocating a holder DataValueDescriptor object
1: 	 * for each parameter.
1: 	 */
0: 	public void initialize(DataTypeDescriptor[] types)
1: 	{
1: 		for (int i = 0; i < parms.length; i++)
1: 		{
1: 			DataTypeDescriptor dtd = types[i];
1: 			
1: 			parms[i].initialize(dtd.getNull(),
1: 					dtd.getJDBCTypeId(), dtd.getTypeId().getCorrespondingJavaTypeName());
1: 		}
1: 	}
/////////////////////////////////////////////////////////////////////////
0: 		parms[position].initialize(sdv, jdbcTypeId, className);
commit:1260b94
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.GenericParameterValueSet
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:bff3c2e
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql;
1: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
1: import org.apache.derby.iapi.sql.ParameterValueSet;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import java.io.InputStream;
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
1: import java.sql.Types;
0: import java.math.BigDecimal;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
1: /**
1:  * Implementation of ParameterValueSet
1:  *
1:  * @see ParameterValueSet
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
1: final class GenericParameterValueSet implements ParameterValueSet 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:   //all this has to be copied in the clone constructor
1: 	private final GenericParameter[]				parms;
1: 	final ClassInspector 			ci;
1: 	private	final boolean			hasReturnOutputParam;
1: 
0: 	//bug 4552 - "exec statement using" will return no parameters through parametermetadata
0: 	private boolean					isUsingPVS;
1: 
1: 	/**
1: 	 * Constructor for a GenericParameterValueSet
1: 	 *
1: 	 * @param numParms	The number of parameters in the new ParameterValueSet
1: 	 * @param hasReturnOutputParam	if we have a ? = call syntax.  Note that
1: 	 *			this is NOT the same thing as an output parameter -- return
1: 	 *			output parameters are special cases of output parameters.
1: 	 */
1: 	GenericParameterValueSet(ClassInspector ci, int numParms, boolean hasReturnOutputParam)
1: 	{
1: 		this.ci = ci;
1: 		this.hasReturnOutputParam = hasReturnOutputParam;
1: 		parms = new GenericParameter[numParms];
1: 		for (int i = 0; i < numParms; i++)
1: 		{
1: 			/*
1: 			** Last param is if this is a return output param.  True if 
1: 			** we have an output param and we are on the 1st parameter.
1: 			*/	
1: 			parms[i] = new GenericParameter(this, (hasReturnOutputParam && i == 0));
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Construct a pvs by cloning a pvs.
1: 	*/
1: 	private GenericParameterValueSet(int numParms, GenericParameterValueSet pvs)
1: 	{
1: 		this.hasReturnOutputParam = pvs.hasReturnOutputParam;
1: 		this.ci = pvs.ci;
1: 		parms = new GenericParameter[numParms];
1: 		for (int i = 0; i < numParms; i++)
1: 		{
1: 			parms[i] = pvs.getGenericParameter(i).getClone(this);
1: 		}
1: 	}
1: 
1: 	/*
1: 	** ParameterValueSet interface methods
1: 	*/
1: 
1: 	public void setParameterMode(int position, int mode) {
1: 		parms[position].parameterMode = (short) mode;
1: 	}
1: 
1: 	/**
1: 	 * @see ParameterValueSet#clearParameters
1: 	 */
1: 	public void clearParameters()
1: 	{
0: 		if (isUsingPVS)
0: 			return;
1: 
1: 		for (int i = 0; i < parms.length; i++)
1: 		{
1: 			parms[i].clear();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Returns the number of parameters in this set.
1: 	 *
1: 	 * @return	The number of parameters in this set.
1: 	 */
1:     public	int	getParameterCount()
1: 	{
1: 		return parms.length;
1: 	}
1: 
1: 	/**
1: 	 * Returns the parameter value at the given position.
1: 	 *
1: 	 * @return	The parameter at the given position.
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public	DataValueDescriptor	getParameter( int position ) throws StandardException
1: 	{
1: 		try {
1: 			return parms[position].getValue();
1: 		} catch (ArrayIndexOutOfBoundsException e) {
1: 			checkPosition(position);
1: 			return null;
1: 		}
1: 	}
1: 
1: 
1: 
1: 	public	DataValueDescriptor	getParameterForSet(int position) throws StandardException {
1: 
0: 		if (isUsingPVS)
0: 			throw StandardException.newException(SQLState.NO_SETXXX_FOR_EXEC_USING);
1: 
1: 		try {
1: 
1: 			GenericParameter gp = parms[position];
0: 			if (gp.parameterMode == JDBC30Translation.PARAMETER_MODE_OUT)
1: 				throw StandardException.newException(SQLState.LANG_RETURN_OUTPUT_PARAM_CANNOT_BE_SET);
1: 
1: 			gp.isSet = true;
1: 
1: 			return gp.getValue();
1: 		} catch (ArrayIndexOutOfBoundsException e) {
1: 			checkPosition(position);
1: 			return null;
1: 		}
1: 
1: 	}
1: 	
1: 	public	DataValueDescriptor	getParameterForGet(int position) throws StandardException {
1: 
0: 		if (isUsingPVS)
0: 			throw StandardException.newException(SQLState.NO_SETXXX_FOR_EXEC_USING);
1: 
1: 		try {
1: 
1: 			GenericParameter gp = parms[position];
1: 
1: 			switch (gp.parameterMode) {
0: 			case JDBC30Translation.PARAMETER_MODE_IN:
0: 			case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
1: 				throw StandardException.newException(SQLState.LANG_NOT_OUTPUT_PARAMETER, Integer.toString(position + 1));
1: 			}
1: 
1: 			return gp.getValue();
1: 		} catch (ArrayIndexOutOfBoundsException e) {
1: 			checkPosition(position);
1: 			return null;
1: 		}
1: 	}
1: 
1: 	public void setParameterAsObject(int position, Object value) throws StandardException {
1: 
0: 		DataValueDescriptor dvd = getParameterForSet(position);
1: 
1: 		GenericParameter gp = parms[position];
0: 		if (value != null && (gp.jdbcTypeId == Types.OTHER || gp.jdbcTypeId == org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT)) {
1: 
1: 			{
1: 
1: 				boolean throwError;
1: 				ClassNotFoundException t = null;
1: 				try {
1: 					throwError = !ci.instanceOf(gp.declaredClassName, value);
1: 				} catch (ClassNotFoundException cnfe) {
1: 					t = cnfe;
1: 					throwError = true;
1: 				}
1: 
1: 				if (throwError) {
1: 					throw StandardException.newException(SQLState.LANG_DATA_TYPE_SET_MISMATCH, t,
1: 						ClassInspector.readableClassName(value.getClass()), gp.declaredClassName);
1: 				}
1: 			}
1: 
1: 		}
1: 
1: 		dvd.setValue(value);
1: 	}
1: 
1: 	/**
1: 	 * @see ParameterValueSet#allAreSet
1: 	 */
1: 	public boolean allAreSet()
1: 	{
1: 		for (int i = 0; i < parms.length; i++)
1: 		{
1: 			GenericParameter gp = parms[i];
1: 			if (!gp.isSet)
1: 			{
1: 				switch (gp.parameterMode) {
0: 				case JDBC30Translation.PARAMETER_MODE_OUT:
1: 					break;
0: 				case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 				case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 				case JDBC30Translation.PARAMETER_MODE_IN:
1: 					return false;
1: 				}
1: 			}
1: 		}
1: 
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * @see ParameterValueSet#transferDataValues
1: 	 */
1: 	public void  transferDataValues(ParameterValueSet pvstarget) throws StandardException
1: 	{
1: 		// don't take application's values for return output parameters
1: 		int firstParam = pvstarget.hasReturnOutputParameter() ? 1 : 0;
1: 		for (int i = firstParam; i < parms.length;i++)
1: 		{
1: 
1: 			GenericParameter oldp = parms[i];
1: 
1: 			if (oldp.registerOutType != Types.NULL) {
1: 
1: 				pvstarget.registerOutParameter(i, oldp.registerOutType, oldp.registerOutScale);
1: 
1: 			}
1: 
1: 			if (oldp.isSet)
1: 			{
0: 				pvstarget.getParameterForSet(i).setValue(oldp.getValue());
1: 			}
1: 		}
0: 		((GenericParameterValueSet) pvstarget).isUsingPVS = isUsingPVS;
1: 	}
1: 
1: 	/*
0: 	 * workhorse for set and stuff storable data value
1: 	 */
1: 	/**
0: 	 * @see ParameterValueSet#setStorableDataValue
1: 	 */
0: 	public void setStorableDataValue(DataValueDescriptor sdv, int position, int jdbcTypeId, String className)
1: 	{
1: 		if (SanityManager.DEBUG) 
1: 		{
0: 			if (!(position >= 0 && position < parms.length))
1: 			{
0: 				SanityManager.THROWASSERT("position value of " 
0: 					+ position + " is out of range (0 to " + parms.length + ")");
1: 			}
0: 			if (parms[position].getValue() != null)
1: 			{
0: //COMMENTED OUT BY MAMTA -- should this be removed?
0: //			SanityManager.THROWASSERT(
0: //					"Attempt to reset a DataValueDescriptor in a ParameterValueSet, " +
0: //					"position = " + position);
1: 			}
1: 
0: 			/* We need the next assertion because this method gets called
0: 			 * from generated code, hence no run time checking on the
0: 			 * parameters.
1: 			 */
0: 			if (! (sdv instanceof DataValueDescriptor))
1: 			{
0: 				if (sdv == null)
1: 				{
0: 					SanityManager.THROWASSERT("sdv expected to be non-null");
1: 				}
0: 				SanityManager.THROWASSERT(
0: 					"sdv expected to be DataValueDescriptor, not " +
0: 					sdv.getClass().getName());
1: 			}
1: 		}
1: 
0: 		parms[position].setStorableDataValue(sdv, jdbcTypeId, className);
1: 
0: 		/* NOTE: We do not deal with associated parameters here.
0: 		 * This method is only called from the generated code
0: 		 * when initializing the parameters to null.  All
0: 		 * parameters, user and generated, will get initialized.
1: 		 */
1: 	}
1: 
1: 	GenericParameter getGenericParameter(int position)
1: 	{
1:     return(parms[position]);
1:   }
1: 
1: 	/* Class implementation */
1: 	public String toString()
1: 	{
1: 		/* This method needed for derby.language.logStatementText=true.
1: 		 * Do not put under SanityManager.DEBUG.
1: 		 */
1: 		StringBuffer strbuf = new StringBuffer();
1: 
1: 		for (int ctr = 0; ctr < parms.length; ctr++)
1: 		{
1: 			strbuf.append("begin parameter #" + (ctr + 1) + ": ");
1: 			strbuf.append(parms[ctr].toString());
1: 			strbuf.append(" :end parameter ");
1: 		}
1: 
1: 		return strbuf.toString();
1: 	}
1: 
1: 	/**
1: 	 * Check the position number for a parameter and throw an exception if
1: 	 * it is out of range.
1: 	 *
1: 	 * @param position	The position number to check
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException	Thrown if position number is
1: 	 *											out of range.
1: 	 */
1: 	private void checkPosition(int position) throws StandardException
1: 	{
1: 		if (position < 0 || position >= parms.length)
1: 		{
1: 
1: 			if (parms.length == 0)
1: 				throw StandardException.newException(SQLState.NO_INPUT_PARAMETERS);
1: 
1: 			throw StandardException.newException(SQLState.LANG_INVALID_PARAM_POSITION, 
1: 															String.valueOf(position+1),
1: 															String.valueOf(parms.length));
1: 		}
1: 	}
1: 
1: 
1: 	public ParameterValueSet getClone()
1: 	{
1: 		return(new GenericParameterValueSet(parms.length, this));
1: 	}
1: 
1: 	//////////////////////////////////////////////////////////////////
1: 	//
1: 	// CALLABLE STATEMENT
1: 	//
1: 	//////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Mark the parameter as an output parameter.
1: 	 *
1: 	 * @param parameterIndex	The ordinal parameterIndex of a parameter to set
1: 	 *			to the given value.
0: 	 * @param sqlType	A type from java.sql.Types
1: 	 * @param scale		the scale to use.  -1 means ignore scale
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public void registerOutParameter(int parameterIndex, int sqlType, int scale)
0: 		throws StandardException
1: 	{
0: 		checkPosition(parameterIndex);
0: 		parms[parameterIndex].setOutParameter(sqlType, scale);
1: 	}
1: 
1:     /**
0:      * Get the value of a parameter as a Java object.
1:      *
0:      * <p>This method returns a Java object whose type coresponds to the SQL
0:      * type that was registered for this parameter using registerOutParameter.
1:      *
0:      * <p>Note that this method may be used to read
0:      * datatabase-specific, abstract data types. This is done by
0:      * specifying a targetSqlType of java.sql.types.OTHER, which
0:      * allows the driver to return a database-specific Java type.
1:      *
0:      * @param parameterIndex The first parameter is 1, the second is 2, ...
0:      * @return A java.lang.Object holding the OUT parameter value.
1:      * @exception StandardException if a database-access error occurs.
0:      * @see Types 
1:      */
0:     public Object getObject(int parameterIndex) throws StandardException
1: 	{
0: 		DataValueDescriptor dvd = getParameterForGet(parameterIndex);
1: 
0: 		return dvd.getObject();
1: 	}
1: 
1: 	/**
1: 	 * Validate the parameters.  This is done for situations where
1: 	 * we cannot validate everything in the setXXX() calls.  In
1: 	 * particular, before we do an execute() on a CallableStatement,
1: 	 * we need to go through the parameters and make sure that
1: 	 * all parameters are set up properly.  The motivator for this
1: 	 * is that setXXX() can be called either before or after 
1: 	 * registerOutputParamter(), we cannot be sure we have the types
1: 	 * correct until we get to execute().
1: 	 *
1: 	 * @exception StandardException if the parameters aren't valid
1: 	 */
1: 	public void validate() throws StandardException
1: 	{
1: 		for (int i = 0; i < parms.length; i++)
1: 		{
1: 			parms[i].validate();
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * Return the parameter number (in jdbc lingo, i.e. 1 based)
1: 	 * for the given parameter.  Linear search. 
1: 	 *
1: 	 * @return the parameter number, or 0 if not found
1: 	 */
1: 	public int getParameterNumber(GenericParameter theParam)
1: 	{
1: 		for (int i = 0; i < parms.length; i++)
1: 		{
1: 			if (parms[i] == theParam)
1: 			{
1: 				return i+1;
1: 			}
1: 		}
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 		Check that there are not output parameters defined
1: 		by the parameter set. If there are unknown parameter
0: 		types they are forced to input types. i.e. Cloudscape static method
1: 		calls with parameters that are array.
1: 
1: 		@return true if a declared Java Procedure INOUT or OUT parameter is in the set, false otherwise.
1: 	*/
1: 	public boolean checkNoDeclaredOutputParameters() {
1: 
1: 		boolean hasDeclaredOutputParameter = false;
1: 		for (int i=0; i<parms.length; i++) {
1: 
1: 			GenericParameter gp = parms[i];
1: 
1: 			switch (gp.parameterMode) {
0: 			case JDBC30Translation.PARAMETER_MODE_IN:
1: 				break;
0: 			case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 			case JDBC30Translation.PARAMETER_MODE_OUT:
1: 				hasDeclaredOutputParameter = true;
1: 				break;
0: 			case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 				gp.parameterMode = JDBC30Translation.PARAMETER_MODE_IN;
1: 				break;
1: 			}
1: 		}
1: 		return hasDeclaredOutputParameter;
1: 	}
1: 
1: 	/**
1: 		Return the mode of the parameter according to JDBC 3.0 ParameterMetaData
1: 	 * @param parameterIndex the first parameter is 1, the second is 2, ...
1: 	 *
1: 	 */
1: 	public short getParameterMode(int parameterIndex)
1: 	{
1: 		short mode = parms[parameterIndex - 1].parameterMode;
1: 		//if (mode == (short) JDBC30Translation.PARAMETER_MODE_UNKNOWN)
1: 		//	mode = (short) JDBC30Translation.PARAMETER_MODE_IN;
1: 		return mode;
1: 	}
1: 
1: 	/**
1: 	 * Is there a return output parameter in this pvs.  A return
1: 	 * parameter is from a CALL statement of the following
1: 	 * syntax: ? = CALL myMethod()
1: 	 *
1: 	 * @return true if it has a return parameter
1: 	 *
1: 	 */
1: 	public boolean hasReturnOutputParameter()
1: 	{
1: 		return hasReturnOutputParam;
1: 	}
1: 
0: 	// bug 4552 - "exec statement using" will return no parameters through parametermetadata
1: 	/**
0: 	 * Is this pvs for using clause.
1: 	 *
0: 	 * @return true if this pvs for using clause.
1: 	 *
1: 	 */
0: 	public boolean isUsingParameterValueSet()
1: 	{
0: 		return isUsingPVS;
1: 	}
1: 
0: 	// bug 4552 - "exec statement using" will return no parameters through parametermetadata
1: 	/**
0: 	 * Set pvs for using clause.
1: 	 */
0: 	public void setUsingParameterValueSet()
1: 	{
0: 		isUsingPVS = true;
1: 	}
1: 
1:     /**
0:      * Set the value of the return parameter as a Java object.
1:      *
0:      * @param value the return value
1: 	 *
1:      * @exception StandardException if a database-access error occurs.
1:      */
0:     public void setReturnValue(Object value) throws StandardException
1: 	{
1: 		checkPosition(0);
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.ASSERT(parms.length > 0, "no return value");
0: 			SanityManager.ASSERT(hasReturnOutputParam, "shouldn't call setReturnValue() unless pvs has a return value");
1: 		}
0: 		parms[0].stuffObject(value);
1: 	}
1: 
1: 	/**
1: 	 * Return the scale of the given parameter index in this pvs.
1: 	 *
1: 	 * @param parameterIndex the first parameter is 1, the second is 2, ...
1: 	 *
1: 	 * @return scale
1: 	 */
1: 	public int getScale(int parameterIndex)
1: 	{
1: 		return parms[parameterIndex-1].getScale();
1: 	}
1: 
1: 	/**
1: 	 * Return the precision of the given parameter index in this pvs.
1: 	 *
1: 	 * @param parameterIndex the first parameter is 1, the second is 2, ...
1: 	 *
1: 	 * @return precision
1: 	 */
1: 	public int getPrecision(int parameterIndex)
1: 	{
1: 		return parms[parameterIndex-1].getPrecision();
1: 	}
1: 
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql;
0: 
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.io.InputStream;
0: import java.sql.Date;
0: import java.sql.Time;
0: import java.sql.Timestamp;
0: import java.sql.Types;
0: import java.math.BigDecimal;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: /**
0:  * Implementation of ParameterValueSet
0:  *
0:  * @see ParameterValueSet
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: final class GenericParameterValueSet implements ParameterValueSet 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:   //all this has to be copied in the clone constructor
0: 	private final GenericParameter[]				parms;
0: 	final ClassInspector 			ci;
0: 	private	final boolean			hasReturnOutputParam;
0: 
0: 	//bug 4552 - "exec statement using" will return no parameters through parametermetadata
0: 	private boolean					isUsingPVS;
0: 
0: 	/**
0: 	 * Constructor for a GenericParameterValueSet
0: 	 *
0: 	 * @param numParms	The number of parameters in the new ParameterValueSet
0: 	 * @param hasReturnOutputParam	if we have a ? = call syntax.  Note that
0: 	 *			this is NOT the same thing as an output parameter -- return
0: 	 *			output parameters are special cases of output parameters.
0: 	 */
0: 	GenericParameterValueSet(ClassInspector ci, int numParms, boolean hasReturnOutputParam)
0: 	{
0: 		this.ci = ci;
0: 		this.hasReturnOutputParam = hasReturnOutputParam;
0: 		parms = new GenericParameter[numParms];
0: 		for (int i = 0; i < numParms; i++)
0: 		{
0: 			/*
0: 			** Last param is if this is a return output param.  True if 
0: 			** we have an output param and we are on the 1st parameter.
0: 			*/	
0: 			parms[i] = new GenericParameter(this, (hasReturnOutputParam && i == 0));
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Construct a pvs by cloning a pvs.
0: 	*/
0: 	private GenericParameterValueSet(int numParms, GenericParameterValueSet pvs)
0: 	{
0: 		this.hasReturnOutputParam = pvs.hasReturnOutputParam;
0: 		this.ci = pvs.ci;
0: 		parms = new GenericParameter[numParms];
0: 		for (int i = 0; i < numParms; i++)
0: 		{
0: 			parms[i] = pvs.getGenericParameter(i).getClone(this);
0: 		}
0: 	}
0: 
0: 	/*
0: 	** ParameterValueSet interface methods
0: 	*/
0: 
0: 	public void setParameterMode(int position, int mode) {
0: 		parms[position].parameterMode = (short) mode;
0: 	}
0: 
0: 	/**
0: 	 * @see ParameterValueSet#clearParameters
0: 	 */
0: 	public void clearParameters()
0: 	{
0: 		if (isUsingPVS)
0: 			return;
0: 
0: 		for (int i = 0; i < parms.length; i++)
0: 		{
0: 			parms[i].clear();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Returns the number of parameters in this set.
0: 	 *
0: 	 * @return	The number of parameters in this set.
0: 	 */
0:     public	int	getParameterCount()
0: 	{
0: 		return parms.length;
0: 	}
0: 
0: 	/**
0: 	 * Returns the parameter value at the given position.
0: 	 *
0: 	 * @return	The parameter at the given position.
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public	DataValueDescriptor	getParameter( int position ) throws StandardException
0: 	{
0: 		try {
0: 			return parms[position].getValue();
0: 		} catch (ArrayIndexOutOfBoundsException e) {
0: 			checkPosition(position);
0: 			return null;
0: 		}
0: 	}
0: 
0: 
0: 
0: 	public	DataValueDescriptor	getParameterForSet(int position) throws StandardException {
0: 
0: 		if (isUsingPVS)
0: 			throw StandardException.newException(SQLState.NO_SETXXX_FOR_EXEC_USING);
0: 
0: 		try {
0: 
0: 			GenericParameter gp = parms[position];
0: 			if (gp.parameterMode == JDBC30Translation.PARAMETER_MODE_OUT)
0: 				throw StandardException.newException(SQLState.LANG_RETURN_OUTPUT_PARAM_CANNOT_BE_SET);
0: 
0: 			gp.isSet = true;
0: 
0: 			return gp.getValue();
0: 		} catch (ArrayIndexOutOfBoundsException e) {
0: 			checkPosition(position);
0: 			return null;
0: 		}
0: 
0: 	}
0: 	
0: 	public	DataValueDescriptor	getParameterForGet(int position) throws StandardException {
0: 
0: 		if (isUsingPVS)
0: 			throw StandardException.newException(SQLState.NO_SETXXX_FOR_EXEC_USING);
0: 
0: 		try {
0: 
0: 			GenericParameter gp = parms[position];
0: 
0: 			switch (gp.parameterMode) {
0: 			case JDBC30Translation.PARAMETER_MODE_IN:
0: 			case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 				throw StandardException.newException(SQLState.LANG_NOT_OUTPUT_PARAMETER, Integer.toString(position + 1));
0: 			}
0: 
0: 			return gp.getValue();
0: 		} catch (ArrayIndexOutOfBoundsException e) {
0: 			checkPosition(position);
0: 			return null;
0: 		}
0: 	}
0: 
0: 	public void setParameterAsObject(int position, Object value) throws StandardException {
0: 
0: 		DataValueDescriptor dvd = getParameterForSet(position);
0: 
0: 		GenericParameter gp = parms[position];
0: 		if (value != null && (gp.jdbcTypeId == Types.OTHER || gp.jdbcTypeId == org.apache.derby.iapi.reference.JDBC20Translation.SQL_TYPES_JAVA_OBJECT)) {
0: 
0: 			{
0: 
0: 				boolean throwError;
0: 				ClassNotFoundException t = null;
0: 				try {
0: 					throwError = !ci.instanceOf(gp.declaredClassName, value);
0: 				} catch (ClassNotFoundException cnfe) {
0: 					t = cnfe;
0: 					throwError = true;
0: 				}
0: 
0: 				if (throwError) {
0: 					throw StandardException.newException(SQLState.LANG_DATA_TYPE_SET_MISMATCH, t,
0: 						ClassInspector.readableClassName(value.getClass()), gp.declaredClassName);
0: 				}
0: 			}
0: 
0: 		}
0: 
0: 		dvd.setValue(value);
0: 	}
0: 
0: 	/**
0: 	 * @see ParameterValueSet#allAreSet
0: 	 */
0: 	public boolean allAreSet()
0: 	{
0: 		for (int i = 0; i < parms.length; i++)
0: 		{
0: 			GenericParameter gp = parms[i];
0: 			if (!gp.isSet)
0: 			{
0: 				switch (gp.parameterMode) {
0: 				case JDBC30Translation.PARAMETER_MODE_OUT:
0: 					break;
0: 				case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 				case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 				case JDBC30Translation.PARAMETER_MODE_IN:
0: 					return false;
0: 				}
0: 			}
0: 		}
0: 
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * @see ParameterValueSet#transferDataValues
0: 	 */
0: 	public void  transferDataValues(ParameterValueSet pvstarget) throws StandardException
0: 	{
0: 		// don't take application's values for return output parameters
0: 		int firstParam = pvstarget.hasReturnOutputParameter() ? 1 : 0;
0: 		for (int i = firstParam; i < parms.length;i++)
0: 		{
0: 
0: 			GenericParameter oldp = parms[i];
0: 
0: 			if (oldp.registerOutType != Types.NULL) {
0: 
0: 				pvstarget.registerOutParameter(i, oldp.registerOutType, oldp.registerOutScale);
0: 
0: 			}
0: 
0: 			if (oldp.isSet)
0: 			{
0: 				pvstarget.getParameterForSet(i).setValue(oldp.getValue());
0: 			}
0: 		}
0: 		((GenericParameterValueSet) pvstarget).isUsingPVS = isUsingPVS;
0: 	}
0: 
0: 	/*
0: 	 * workhorse for set and stuff storable data value
0: 	 */
0: 	/**
0: 	 * @see ParameterValueSet#setStorableDataValue
0: 	 */
0: 	public void setStorableDataValue(DataValueDescriptor sdv, int position, int jdbcTypeId, String className)
0: 	{
0: 		if (SanityManager.DEBUG) 
0: 		{
0: 			if (!(position >= 0 && position < parms.length))
0: 			{
0: 				SanityManager.THROWASSERT("position value of " 
0: 					+ position + " is out of range (0 to " + parms.length + ")");
0: 			}
0: 			if (parms[position].getValue() != null)
0: 			{
0: //COMMENTED OUT BY MAMTA -- should this be removed?
0: //			SanityManager.THROWASSERT(
0: //					"Attempt to reset a DataValueDescriptor in a ParameterValueSet, " +
0: //					"position = " + position);
0: 			}
0: 
0: 			/* We need the next assertion because this method gets called
0: 			 * from generated code, hence no run time checking on the
0: 			 * parameters.
0: 			 */
0: 			if (! (sdv instanceof DataValueDescriptor))
0: 			{
0: 				if (sdv == null)
0: 				{
0: 					SanityManager.THROWASSERT("sdv expected to be non-null");
0: 				}
0: 				SanityManager.THROWASSERT(
0: 					"sdv expected to be DataValueDescriptor, not " +
0: 					sdv.getClass().getName());
0: 			}
0: 		}
0: 
0: 		parms[position].setStorableDataValue(sdv, jdbcTypeId, className);
0: 
0: 		/* NOTE: We do not deal with associated parameters here.
0: 		 * This method is only called from the generated code
0: 		 * when initializing the parameters to null.  All
0: 		 * parameters, user and generated, will get initialized.
0: 		 */
0: 	}
0: 
0: 	GenericParameter getGenericParameter(int position)
0: 	{
0:     return(parms[position]);
0:   }
0: 
0: 	/* Class implementation */
0: 	public String toString()
0: 	{
0: 		/* This method needed for derby.language.logStatementText=true.
0: 		 * Do not put under SanityManager.DEBUG.
0: 		 */
0: 		StringBuffer strbuf = new StringBuffer();
0: 
0: 		for (int ctr = 0; ctr < parms.length; ctr++)
0: 		{
0: 			strbuf.append("begin parameter #" + (ctr + 1) + ": ");
0: 			strbuf.append(parms[ctr].toString());
0: 			strbuf.append(" :end parameter ");
0: 		}
0: 
0: 		return strbuf.toString();
0: 	}
0: 
0: 	/**
0: 	 * Check the position number for a parameter and throw an exception if
0: 	 * it is out of range.
0: 	 *
0: 	 * @param position	The position number to check
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException	Thrown if position number is
0: 	 *											out of range.
0: 	 */
0: 	private void checkPosition(int position) throws StandardException
0: 	{
0: 		if (position < 0 || position >= parms.length)
0: 		{
0: 
0: 			if (parms.length == 0)
0: 				throw StandardException.newException(SQLState.NO_INPUT_PARAMETERS);
0: 
0: 			throw StandardException.newException(SQLState.LANG_INVALID_PARAM_POSITION, 
0: 															String.valueOf(position+1),
0: 															String.valueOf(parms.length));
0: 		}
0: 	}
0: 
0: 
0: 	public ParameterValueSet getClone()
0: 	{
0: 		return(new GenericParameterValueSet(parms.length, this));
0: 	}
0: 
0: 	//////////////////////////////////////////////////////////////////
0: 	//
0: 	// CALLABLE STATEMENT
0: 	//
0: 	//////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Mark the parameter as an output parameter.
0: 	 *
0: 	 * @param parameterIndex	The ordinal parameterIndex of a parameter to set
0: 	 *			to the given value.
0: 	 * @param sqlType	A type from java.sql.Types
0: 	 * @param scale		the scale to use.  -1 means ignore scale
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void registerOutParameter(int parameterIndex, int sqlType, int scale)
0: 		throws StandardException
0: 	{
0: 		checkPosition(parameterIndex);
0: 		parms[parameterIndex].setOutParameter(sqlType, scale);
0: 	}
0: 
0:     /**
0:      * Get the value of a parameter as a Java object.
0:      *
0:      * <p>This method returns a Java object whose type coresponds to the SQL
0:      * type that was registered for this parameter using registerOutParameter.
0:      *
0:      * <p>Note that this method may be used to read
0:      * datatabase-specific, abstract data types. This is done by
0:      * specifying a targetSqlType of java.sql.types.OTHER, which
0:      * allows the driver to return a database-specific Java type.
0:      *
0:      * @param parameterIndex The first parameter is 1, the second is 2, ...
0:      * @return A java.lang.Object holding the OUT parameter value.
0:      * @exception StandardException if a database-access error occurs.
0:      * @see Types 
0:      */
0:     public Object getObject(int parameterIndex) throws StandardException
0: 	{
0: 		DataValueDescriptor dvd = getParameterForGet(parameterIndex);
0: 
0: 		return dvd.getObject();
0: 	}
0: 
0: 	/**
0: 	 * Validate the parameters.  This is done for situations where
0: 	 * we cannot validate everything in the setXXX() calls.  In
0: 	 * particular, before we do an execute() on a CallableStatement,
0: 	 * we need to go through the parameters and make sure that
0: 	 * all parameters are set up properly.  The motivator for this
0: 	 * is that setXXX() can be called either before or after 
0: 	 * registerOutputParamter(), we cannot be sure we have the types
0: 	 * correct until we get to execute().
0: 	 *
0: 	 * @exception StandardException if the parameters aren't valid
0: 	 */
0: 	public void validate() throws StandardException
0: 	{
0: 		for (int i = 0; i < parms.length; i++)
0: 		{
0: 			parms[i].validate();
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Return the parameter number (in jdbc lingo, i.e. 1 based)
0: 	 * for the given parameter.  Linear search. 
0: 	 *
0: 	 * @return the parameter number, or 0 if not found
0: 	 */
0: 	public int getParameterNumber(GenericParameter theParam)
0: 	{
0: 		for (int i = 0; i < parms.length; i++)
0: 		{
0: 			if (parms[i] == theParam)
0: 			{
0: 				return i+1;
0: 			}
0: 		}
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 		Check that there are not output parameters defined
0: 		by the parameter set. If there are unknown parameter
0: 		types they are forced to input types. i.e. Cloudscape static method
0: 		calls with parameters that are array.
0: 
0: 		@return true if a declared Java Procedure INOUT or OUT parameter is in the set, false otherwise.
0: 	*/
0: 	public boolean checkNoDeclaredOutputParameters() {
0: 
0: 		boolean hasDeclaredOutputParameter = false;
0: 		for (int i=0; i<parms.length; i++) {
0: 
0: 			GenericParameter gp = parms[i];
0: 
0: 			switch (gp.parameterMode) {
0: 			case JDBC30Translation.PARAMETER_MODE_IN:
0: 				break;
0: 			case JDBC30Translation.PARAMETER_MODE_IN_OUT:
0: 			case JDBC30Translation.PARAMETER_MODE_OUT:
0: 				hasDeclaredOutputParameter = true;
0: 				break;
0: 			case JDBC30Translation.PARAMETER_MODE_UNKNOWN:
0: 				gp.parameterMode = JDBC30Translation.PARAMETER_MODE_IN;
0: 				break;
0: 			}
0: 		}
0: 		return hasDeclaredOutputParameter;
0: 	}
0: 
0: 	/**
0: 		Return the mode of the parameter according to JDBC 3.0 ParameterMetaData
0: 	 * @param parameterIndex the first parameter is 1, the second is 2, ...
0: 	 *
0: 	 */
0: 	public short getParameterMode(int parameterIndex)
0: 	{
0: 		short mode = parms[parameterIndex - 1].parameterMode;
0: 		//if (mode == (short) JDBC30Translation.PARAMETER_MODE_UNKNOWN)
0: 		//	mode = (short) JDBC30Translation.PARAMETER_MODE_IN;
0: 		return mode;
0: 	}
0: 
0: 	/**
0: 	 * Is there a return output parameter in this pvs.  A return
0: 	 * parameter is from a CALL statement of the following
0: 	 * syntax: ? = CALL myMethod()
0: 	 *
0: 	 * @return true if it has a return parameter
0: 	 *
0: 	 */
0: 	public boolean hasReturnOutputParameter()
0: 	{
0: 		return hasReturnOutputParam;
0: 	}
0: 
0: 	// bug 4552 - "exec statement using" will return no parameters through parametermetadata
0: 	/**
0: 	 * Is this pvs for using clause.
0: 	 *
0: 	 * @return true if this pvs for using clause.
0: 	 *
0: 	 */
0: 	public boolean isUsingParameterValueSet()
0: 	{
0: 		return isUsingPVS;
0: 	}
0: 
0: 	// bug 4552 - "exec statement using" will return no parameters through parametermetadata
0: 	/**
0: 	 * Set pvs for using clause.
0: 	 */
0: 	public void setUsingParameterValueSet()
0: 	{
0: 		isUsingPVS = true;
0: 	}
0: 
0:     /**
0:      * Set the value of the return parameter as a Java object.
0:      *
0:      * @param value the return value
0: 	 *
0:      * @exception StandardException if a database-access error occurs.
0:      */
0:     public void setReturnValue(Object value) throws StandardException
0: 	{
0: 		checkPosition(0);
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(parms.length > 0, "no return value");
0: 			SanityManager.ASSERT(hasReturnOutputParam, "shouldn't call setReturnValue() unless pvs has a return value");
0: 		}
0: 		parms[0].stuffObject(value);
0: 	}
0: 
0: 	/**
0: 	 * Return the scale of the given parameter index in this pvs.
0: 	 *
0: 	 * @param parameterIndex the first parameter is 1, the second is 2, ...
0: 	 *
0: 	 * @return scale
0: 	 */
0: 	public int getScale(int parameterIndex)
0: 	{
0: 		return parms[parameterIndex-1].getScale();
0: 	}
0: 
0: 	/**
0: 	 * Return the precision of the given parameter index in this pvs.
0: 	 *
0: 	 * @param parameterIndex the first parameter is 1, the second is 2, ...
0: 	 *
0: 	 * @return precision
0: 	 */
0: 	public int getPrecision(int parameterIndex)
0: 	{
0: 		return parms[parameterIndex-1].getPrecision();
0: 	}
0: 
0: }
============================================================================