1:39f35f5: /*
2:39f35f5:  *
1:39f35f5:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.EncryptionKeyTest
1:39f35f5:  *
1:39f35f5:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:39f35f5:  * contributor license agreements.  See the NOTICE file distributed with
1:39f35f5:  * this work for additional information regarding copyright ownership.
1:39f35f5:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:39f35f5:  * (the "License"); you may not use this file except in compliance with
1:39f35f5:  * the License.  You may obtain a copy of the License at
1:39f35f5:  *
1:39f35f5:  *    http://www.apache.org/licenses/LICENSE-2.0
1:39f35f5:  *
1:39f35f5:  * Unless required by applicable law or agreed to in writing,
1:39f35f5:  * software distributed under the License is distributed on an
1:39f35f5:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:39f35f5:  * either express or implied. See the License for the specific
1:39f35f5:  * language governing permissions and limitations under the License.
2:39f35f5:  */
1:39f35f5: package org.apache.derbyTesting.functionTests.tests.store;
2:39f35f5: 
1:39f35f5: import java.io.File;
1:39f35f5: 
1:39f35f5: import java.sql.Connection;
1:39f35f5: import java.sql.CallableStatement;
1:39f35f5: import java.sql.PreparedStatement;
1:39f35f5: import java.sql.ResultSet;
1:39f35f5: import java.sql.Statement;
1:39f35f5: import java.sql.SQLException;
1:39f35f5: import java.sql.SQLWarning;
1:39f35f5: 
1:39f35f5: import javax.sql.DataSource;
1:39f35f5: 
1:3f5c48a: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:39f35f5: 
1:39f35f5: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:39f35f5: import org.apache.derbyTesting.junit.JDBCDataSource;
1:39f35f5: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:39f35f5: 
2:39f35f5: /**
1:39f35f5:  * Tests various connection sequences to encrypted databases.
1:39f35f5:  * Four kinds of external keys are used:
1:39f35f5:  *  <ol><li>the correct key
1:39f35f5:  *      <li>an incorrect key
1:39f35f5:  *      <li>a key with odd length (in hex representation)
1:39f35f5:  *      <li>a key containing invalid characters
1:39f35f5:  *  </ol>
2:39f35f5:  * <p>
1:39f35f5:  * The algorithms used for en-/decryption is determined by the subclasses,
1:39f35f5:  * where a single algorithm and a set of keys are associated with each
1:39f35f5:  * subclass.
1:39f35f5:  * <p>
1:39f35f5:  * Databases are created in the <tt>EXTINOUT</tt> directory. Backups are made
1:39f35f5:  * to <tt>EXTINOUT/backups</tt> and restored databases are put into
1:39f35f5:  * <tt>EXTINOUT/restored</tt> <b>if and only if</b> the databases need to be
1:39f35f5:  * both written and read. Otherwise backups are placed in <tt>EXTOUT</tt>.
1:39f35f5:  * Testsuites generated from this class must be wrapped in a
1:39f35f5:  * <code>SupportFileSetup</code> decorator.
1:39f35f5:  */
1:39f35f5:  //@NotThreadSafe
1:39f35f5: public abstract class EncryptionKeyTest
1:39f35f5:     extends BaseJDBCTestCase {
1:39f35f5: 
1:39f35f5:     /** Correct key constant. */
1:39f35f5:     protected static final int CORRECT_KEY = 0;
1:39f35f5:     /** Wrong key constant. */
1:39f35f5:     protected static final int WRONG_KEY = 1;
1:39f35f5:     /** Odd length key constant. */
1:39f35f5:     protected static final int ODD_LENGTH_KEY = 2;
1:39f35f5:     /** Invalid char key constant. */
1:39f35f5:     protected static final int INVALID_CHAR_KEY = 3;
1:39f35f5: 
1:39f35f5:     /** Table holding the test data. */
1:39f35f5:     private static final String TABLE = "encryptionkeytestdata";
1:39f35f5:     /** Test data inserted into database and used for verification. */
1:39f35f5:     private static final int[] DATA = {9,4,2,34,6543,3,123,434,5436,-123,0,123};
1:39f35f5: 
1:39f35f5:     /** The algorithm used by the fixture. */
1:39f35f5:     private final String algorithm;
1:39f35f5: 
1:39f35f5:     /** The correct key. */
1:39f35f5:     private final String keyCorrect;
1:39f35f5:     /** An incorrect key. */
1:39f35f5:     private final String keyWrong;
1:39f35f5:     /** A key with odd length. */
1:39f35f5:     private final String keyOddLength;
1:39f35f5:     /** A key with an invalid char in it. */
1:39f35f5:     private final String keyInvalidChar;
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Variable to hold the various connections.
1:39f35f5:      * No guarantee is made about the state of this connection, but it is
1:39f35f5:      * closed at tear-down.
1:39f35f5:      */
1:39f35f5:     private Connection con = null;
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Configures a new setup by specifying the encryption properties.
1:39f35f5:      *
1:39f35f5:      * @param name name of the fixture
1:39f35f5:      * @param algorithm encryption algorithm to use
1:39f35f5:      * @param correctKey the correct encryption key
1:39f35f5:      * @param wrongKey an incorrect encryption key
1:39f35f5:      * @param oddLengthKey a key of odd length
1:39f35f5:      * @param invalidCharKey a key with invalid characters
1:39f35f5:      */
1:39f35f5:     public EncryptionKeyTest(String name,
1:39f35f5:                              String algorithm,
1:39f35f5:                              String correctKey,
1:39f35f5:                              String wrongKey,
1:39f35f5:                              String oddLengthKey,
1:39f35f5:                              String invalidCharKey) {
1:39f35f5:         super(name);
1:39f35f5:         this.algorithm = algorithm;
1:39f35f5:         this.keyCorrect = correctKey;
1:39f35f5:         this.keyWrong = wrongKey;
1:39f35f5:         this.keyOddLength = oddLengthKey;
1:39f35f5:         this.keyInvalidChar = invalidCharKey;
6:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Clean up the connection maintained by this test.
1:39f35f5:      */
1:39f35f5:     protected void tearDown()
1:39f35f5:             throws java.lang.Exception {
1:39f35f5:         if (con != null && !con.isClosed()) {
1:39f35f5:             con.rollback();
1:39f35f5:             con.close();
1:39f35f5:         }
1:4ef144b:         con = null;
1:39f35f5:         super.tearDown();
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Test a sequence of connections and connection attempts.
1:39f35f5:      * Sequence: Create database, connect to database using correct key,
1:39f35f5:      * try to connect using incorrect key, connect using correct key.
1:39f35f5:      */
1:39f35f5:     public void testConnectionSequence1()
3:39f35f5:             throws SQLException {
1:39f35f5:         String dbName = "encryptedDB_ConnectionSequence1";
1:39f35f5:         // Create database.
1:39f35f5:         con = createAndPopulateDB(dbName);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         // Shutdown the database.
1:39f35f5:         con.close();
1:39f35f5:         shutdown(dbName);
1:39f35f5:         // Connect using correct key.
1:39f35f5:         con = getConnection(dbName, CORRECT_KEY);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         con.close();
1:39f35f5:         // Shutdown the database.
1:39f35f5:         shutdown(dbName);
1:39f35f5:         // Try to connect using wrong key.
2:39f35f5:         try {
1:39f35f5:             getConnection(dbName, WRONG_KEY);
1:39f35f5:             fail("Booting with an incorrect encryption key should fail.");
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("XJ040", sqle);
1:39f35f5:             assertSQLState("XBCXK", getLastSQLException(sqle));
1:39f35f5:         }
1:39f35f5:         // Connect using correct key.
1:39f35f5:         con = getConnection(dbName, CORRECT_KEY);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         con.close();
1:39f35f5:         // Shutdown the database.
1:39f35f5:         shutdown(dbName);
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Test a sequence of connections and connection attempts.
1:39f35f5:      * Sequence: Create database, connect to database using odd length key,
1:39f35f5:      * try to connect using incorrect key, connect using correct key.
1:39f35f5:      */
1:39f35f5:     public void testConnectionSequence2()
1:39f35f5:             throws SQLException {
1:39f35f5:         String dbName = "encryptedDB_ConnectionSequence2";
1:39f35f5:         // Create database.
1:39f35f5:         con = createAndPopulateDB(dbName);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         // Shutdown the database.
1:39f35f5:         con.close();
1:39f35f5:         shutdown(dbName);
1:39f35f5:         // Connect using odd length key.
1:39f35f5:         try {
1:39f35f5:             con = getConnection(dbName, ODD_LENGTH_KEY);
1:39f35f5:             fail("Connected with an odd length key.");
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("XJ040", sqle);
1:39f35f5:             SQLException lastSQLE = getLastSQLException(sqle);
1:39f35f5:             String sqlState = lastSQLE.getSQLState();
1:39f35f5:             // The state of this exception varies with the security provider
1:39f35f5:             // the test is run with.
1:39f35f5:             // Briefly stated, the deciding factor is whether the error is
1:39f35f5:             // caught by checks in the Derby code, or by the checks in the
1:39f35f5:             // security provider. For instance, the (current Sun JCE) DES
1:39f35f5:             // key implementation does not verify the key length, whereas the
1:39f35f5:             // AES key implementation does. For other providers, the situation
1:39f35f5:             // might be different.
1:39f35f5:             // XBCX0 : A general crypto exception, wraps the exception from the
1:39f35f5:             //         security provider.
1:39f35f5:             // XBCXM : A specific Derby exception for external keys of invalid
1:39f35f5:             //         lengths.
1:39f35f5:             if (!sqlState.equals("XBCX0") && !sqlState.equals("XBCXM")) {
1:39f35f5:                 throw lastSQLE;
1:39f35f5:             }
1:39f35f5:         }
1:39f35f5:         confirmNonBootedDB(dbName);
1:39f35f5:         // Try to connect using wrong key.
1:39f35f5:         try {
1:39f35f5:             getConnection(dbName, WRONG_KEY);
1:39f35f5:             fail("Booting with an incorrect encryption key should fail.");
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("XJ040", sqle);
1:39f35f5:             assertSQLState("XBCXK", getLastSQLException(sqle));
1:39f35f5:         }
1:39f35f5:         // Connect using correct key.
1:39f35f5:         con = getConnection(dbName, CORRECT_KEY);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         con.close();
1:39f35f5:         // Shutdown the database.
1:39f35f5:         shutdown(dbName);
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Backup an encrypted database.
1:39f35f5:      */
1:39f35f5:     public void testBackupEncryptedDatabase()
1:39f35f5:             throws SQLException {
1:39f35f5:         String dbName = "encryptionKeyDBToBackup";
1:39f35f5:         // Create the database.
1:39f35f5:         con = createAndPopulateDB(dbName);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         CallableStatement cs = con.prepareCall(
1:39f35f5:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
1:90c4f40:         cs.setString(1,
1:90c4f40:                 new File(SupportFilesSetup.EXTINOUT, "backups").getPath());
1:39f35f5:         // Perform backup.
1:39f35f5:         cs.execute();
1:39f35f5:         cs.close();
1:39f35f5:         con.close();
1:39f35f5:         shutdown(dbName);
1:39f35f5:         // Connect to original database after backup.
1:39f35f5:         con = getConnection(dbName, CORRECT_KEY);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         con.close();
1:39f35f5:         shutdown(dbName);
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Create a new database from a backup image.
1:39f35f5:      */
1:39f35f5:     public void testCreateDbFromBackup()
1:39f35f5:             throws SQLException {
1:39f35f5:         // No ordering imposed by JUnit, so we create our own db and backup.
1:39f35f5:         // Setup paths and names.
1:39f35f5:         final String dbName = "encryptionKeyDBToCreateFrom";
1:39f35f5:         final String backupDbLocation =
1:39f35f5:             SupportFilesSetup.getReadWrite(
1:39f35f5:                     new File("backups", "encryptionKeyDBToCreateFrom").getPath()
1:39f35f5:                 ).getPath();
1:39f35f5:         // Create the database.
1:39f35f5:         con = createAndPopulateDB(dbName);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         CallableStatement cs = con.prepareCall(
1:39f35f5:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
1:39f35f5:         cs.setString(1, 
1:39f35f5:                      new File(SupportFilesSetup.EXTINOUT, "backups").getPath());
1:39f35f5:         // Perform backup.
1:39f35f5:         cs.execute();
1:39f35f5:         cs.close();
1:39f35f5:         con.close();
1:39f35f5:         shutdown(dbName);
1:39f35f5:         // Create a new database from backup.
1:39f35f5:         String dbNameRestored = dbName + "Restored";
1:52f1d64:         con = getConnection(dbNameRestored, CORRECT_KEY,
1:39f35f5:                 "createFrom=" + backupDbLocation);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         con.close();
1:39f35f5:         shutdown(dbNameRestored, "restored");
1:39f35f5:         // Try to create a new database from backup with the wrong key.
1:39f35f5:         dbNameRestored = dbName + "RestoreAttemptedWrongKey";
1:39f35f5:         try {
1:52f1d64:             con = getConnection(dbNameRestored, WRONG_KEY,
1:39f35f5:                     "createFrom=" + backupDbLocation);
1:39f35f5:             fail("Created database from encrypted backup with wrong key.");
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("XJ040", sqle);
1:39f35f5:             assertSQLState("XBCXK", getLastSQLException(sqle));
1:39f35f5:         }
1:39f35f5:         assertTrue(con.isClosed());
1:39f35f5:         // Try to create a new database from backup with an invalid key.
1:39f35f5:         dbNameRestored = dbName + "RestoreAttemptedInvalidKey";
1:39f35f5:         try {
1:52f1d64:             con = getConnection(dbNameRestored, INVALID_CHAR_KEY,
1:39f35f5:                     "createFrom=" + backupDbLocation);
1:39f35f5:             fail("Created database from encrypted backup with an invalid key.");
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("XJ040", sqle);
1:39f35f5:             assertSQLState("XBCXN", getLastSQLException(sqle));
1:39f35f5:         }
1:39f35f5:         assertTrue(con.isClosed());
1:39f35f5:         // Try to create a new database from backup with an odd length key.
1:39f35f5:         dbNameRestored = dbName + "RestoreAttemptedOddLengthKey";
1:39f35f5:         try {
1:52f1d64:             con = getConnection(dbNameRestored, ODD_LENGTH_KEY,
1:39f35f5:                     "createFrom=" + backupDbLocation);
1:39f35f5:             fail("Created db from encrypted backup with an odd length key.");
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("XJ040", sqle);
1:39f35f5:             SQLException lastSQLE = getLastSQLException(sqle);
1:39f35f5:             String sqlState = lastSQLE.getSQLState();
1:39f35f5:             // The state of this exception varies with the security provider
1:39f35f5:             // the test is run with.
1:39f35f5:             // Briefly stated, the deciding factor is whether the error is
1:39f35f5:             // caught by checks in the Derby code, or by the checks in the
1:39f35f5:             // security provider. For instance, the (current Sun JCE) DES
1:39f35f5:             // key implementation does not verify the key length, whereas the
1:39f35f5:             // AES key implementation does. For other providers, the situation
1:39f35f5:             // might be different.
1:39f35f5:             // XBCX0 : A general crypto exception, wraps the exception from the
1:39f35f5:             //         security provider.
1:39f35f5:             // XBCXM : A specific Derby exception for external keys of invalid
1:39f35f5:             //         lengths.
1:39f35f5:             if (!sqlState.equals("XBCX0") && !sqlState.equals("XBCXM")) {
1:39f35f5:                 throw lastSQLE;
1:39f35f5:             }
1:39f35f5:         }
1:39f35f5:         assertTrue(con.isClosed());
1:39f35f5:         // Create a new database from backup again.
1:39f35f5:         dbNameRestored = dbName + "RestoredOnceMore";
1:52f1d64:         con = getConnection(dbNameRestored, CORRECT_KEY,
1:39f35f5:                 "createFrom=" + backupDbLocation);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         con.close();
1:39f35f5:         shutdown(dbNameRestored, "restored");
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Recover the database using <tt>restoreFrom</tt>.
1:39f35f5:      */
1:39f35f5:     public void testRestoreFrom()
1:39f35f5:             throws SQLException {
1:39f35f5:         // No ordering imposed by JUnit, so we create our own db and backup.
1:39f35f5:         String dbName = "encryptionKeyDBToRestoreFrom";
1:39f35f5:         String dbNameRestored = dbName + "Restored";
1:39f35f5:         createBackupRestore(dbName, dbNameRestored);
1:39f35f5:         shutdown(dbNameRestored, "restored");
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Try to recover database with an invalid key.
1:39f35f5:      * <p>
1:39f35f5:      * It should be noted that the existing database, which has been previously
1:39f35f5:      * recovered from the same backup image, is deleted/overwritten even though
1:39f35f5:      * Derby is unable to boot the backup image.
1:39f35f5:      */
1:39f35f5:     public void testInvalidRestoreFrom()
1:39f35f5:             throws SQLException {
1:39f35f5:         // No ordering imposed by JUnit, so we create our own db and backup.
1:39f35f5:         String dbName = "encryptionKeyDBToInvalidRestoreFrom";
1:39f35f5:         String dbNameRestored = dbName + "Restored";
1:39f35f5:         createBackupRestore(dbName, dbNameRestored);
1:39f35f5:         shutdown(dbNameRestored, "restored");
1:39f35f5:         // Check that the database is not booted.
1:39f35f5:         confirmNonBootedDB("restored/" + dbNameRestored);
1:39f35f5:         // Validate the existing database.
1:39f35f5:         con = getConnection("restored/" + dbNameRestored, CORRECT_KEY);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         con.close();
1:39f35f5:         shutdown(dbNameRestored, "restored");
1:39f35f5:         // Confirm that trying a restore with an invalid key will overwrite
1:39f35f5:         // the existing database we are trying to restore to/into. This is
1:39f35f5:         // expected behavior currently, but should maybe change?
1:39f35f5:         try {
1:52f1d64:             con = getConnection(dbNameRestored, INVALID_CHAR_KEY,
1:39f35f5:                     ";restoreFrom=" + obtainDbName(dbName, null));
1:39f35f5:             fail("Restored database with an invalid key.");
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("XBCXN", sqle);
1:39f35f5:         }
1:39f35f5:         // The database should no longer exist.
1:39f35f5:         try {
1:39f35f5:             // The "" is a hack to avoid using "create=true".
1:39f35f5:             con = getConnection("restored/" + dbNameRestored, CORRECT_KEY, "");
1:39f35f5:             fail("Expected connection to fail due to non-existent database.");
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("XJ004", sqle);
1:39f35f5:         }
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Try to create database with a key of odd length.
1:39f35f5:      */
1:39f35f5:     public void testCreateWithOddEncryptionKeyLength()
1:39f35f5:             throws SQLException {
1:39f35f5:         try {
1:39f35f5:             getConnection("encryptedDB_oddKeyLength", ODD_LENGTH_KEY);
1:39f35f5:             fail("Database creation with odd key length should fail.");
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("XJ041", sqle);
1:39f35f5:             SQLException lastSQLE = getLastSQLException(sqle);
1:39f35f5:             String sqlState = lastSQLE.getSQLState();
1:39f35f5:             // The state of this exception varies with the security provider
1:39f35f5:             // the test is run with. In general, it depends on whether it is
1:39f35f5:             // Derby code or the security provider code that detects the
1:39f35f5:             // problem with the encryption key.
1:39f35f5:             if (!sqlState.equals("XBCXM") && !sqlState.equals("XJ001")) {
1:39f35f5:                 throw lastSQLE;
1:39f35f5:             }
1:39f35f5:         }
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Try to create database with a key containing one or more invalid chars.
1:39f35f5:      */
1:39f35f5:     public void testCreateWithInvalidEncryptionKey() {
1:39f35f5:         try {
1:39f35f5:             getConnection("encryptedDB_invkeyChar", INVALID_CHAR_KEY);
1:39f35f5:             fail("Database creation with invalid key should fail.");
1:39f35f5:         } catch (SQLException sqle)  {
1:39f35f5:             assertSQLState("XJ041", sqle);
1:39f35f5:             assertSQLState("XBCXN", getLastSQLException(sqle));
1:39f35f5:         }
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /* ********************************************************************* *
1:39f35f5:      *                     H E L P E R  M E T H O D S                        *
1:39f35f5:      * ********************************************************************* */
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Obtain absolute path for the specified database name.
1:39f35f5:      * <p>
1:39f35f5:      * This absolute path is the name of the database (specified) prefixed with
1:39f35f5:      * the absolute path to the EXTINOUT directory. The latter is determined by
1:39f35f5:      * consulting <code>SupportFilesSetup</code>.
1:39f35f5:      *
2:39f35f5:      * @param dbName name of the database
1:39f35f5:      * @param subdirectory directory to prefix the database name with (can be
1:39f35f5:      *      <code>null</code>). Note that the database name will be prefixed
1:39f35f5:      *      with the path to the EXTINOUT directory even if this parameter is
1:39f35f5:      *      <code>null</code>.
1:39f35f5:      * @return A string with the absolute path to the database.
1:39f35f5:      * @see SupportFilesSetup
1:39f35f5:      */
1:3f5c48a:     String obtainDbName(String dbName, String subdirectory) {
1:39f35f5:         File tmp = new File(dbName);
1:39f35f5:         if (subdirectory != null) {
1:39f35f5:             tmp = new File(subdirectory, dbName);
1:39f35f5:         }
1:3f5c48a:         return PrivilegedFileOpsForTests.getAbsolutePath(
1:3f5c48a:                 new File(SupportFilesSetup.EXTINOUT, tmp.getPath()));
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Create encrypted database, validate it, backup, restore and validate
1:39f35f5:      * recovered database.
1:39f35f5:      * <p>
1:39f35f5:      * The source db is shutdown, the recovered db is left booted.
1:39f35f5:      *
1:39f35f5:      * @param sourceDb the original database to create
1:39f35f5:      * @param targetDb the database to recover to
1:39f35f5:      */
1:39f35f5:     private void createBackupRestore(String sourceDb, String targetDb)
1:39f35f5:             throws SQLException {
1:39f35f5:         // Create the database.
1:39f35f5:         con = createAndPopulateDB(sourceDb);
1:39f35f5:         validateDBContents(con);
1:39f35f5:         CallableStatement cs = con.prepareCall(
1:39f35f5:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
1:39f35f5:         cs.setString(1,
1:39f35f5:                      new File(SupportFilesSetup.EXTINOUT, "backups").getPath());
1:39f35f5:         // Perform backup.
1:39f35f5:         cs.execute();
1:39f35f5:         con.close();
1:39f35f5:         shutdown(sourceDb);
1:39f35f5:         confirmNonBootedDB(sourceDb);
1:39f35f5:         // Use the restoreFrom attribute.
1:52f1d64:         con = getConnection(targetDb, CORRECT_KEY,
1:39f35f5:                 ";restoreFrom=" + obtainDbName(sourceDb, "backups"));
1:39f35f5:         validateDBContents(con);
1:39f35f5:         con.close();
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Confirm that the specified encrypted database has not been booted.
1:39f35f5:      *
1:39f35f5:      * @param dbName name of an encrypted database
1:39f35f5:      * @throws junit.framework.AssertionFailedError if the database has been
1:39f35f5:      *      booted (connection may or may not be established)
1:39f35f5:      */
1:39f35f5:     private void confirmNonBootedDB(String dbName) {
1:39f35f5:         DataSource ds = JDBCDataSource.getDataSource(obtainDbName(dbName, null));
1:39f35f5:         try {
1:39f35f5:             ds.getConnection();
1:39f35f5:         } catch (SQLException sqle) {
1:39f35f5:             assertSQLState("Database booted? <state:" + sqle.getSQLState() +
1:39f35f5:                     ", msg:" + sqle.getMessage() + ">", "XJ040", sqle);
1:39f35f5:         }
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
2:39f35f5:      * Try to establish a connection to the named database with the
1:39f35f5:      * specified type of key.
1:39f35f5:      *
1:39f35f5:      * @param dbName name of the database
2:39f35f5:      * @param keyMode what kind of key to use (correct, wrong, invalid, odd)
2:39f35f5:      * @return A connection to the database.
2:39f35f5:      * @throws SQLException if connection fails
1:39f35f5:      */
1:39f35f5:     private Connection getConnection(String dbName, int keyMode)
1:39f35f5:             throws SQLException {
1:39f35f5:         return getConnection(dbName, keyMode, null);
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Create a new connection to the specified database, using the given
1:39f35f5:      * connection attributes.
1:39f35f5:      *
1:39f35f5:      * @param dbName name of the database
1:39f35f5:      * @param keyMode what kind of key to use (correct, wrong, invalid, odd)
2:39f35f5:      * @param recoveryAttribute attribute to recover a database from a backup,
2:39f35f5:      *      for instance <code>createFrom</code> or <code>restoreFrom</code>.
2:39f35f5:      *      Both the attribute and its value is expected.
1:39f35f5:      * @return A connection to the database.
1:39f35f5:      * @throws SQLException if connection fails
1:39f35f5:      */
1:39f35f5:     private Connection getConnection(String dbName,
1:39f35f5:                                      int keyMode,
1:39f35f5:                                      String recoveryAttribute)
1:39f35f5:             throws SQLException {
1:39f35f5:         DataSource ds = JDBCDataSource.getDataSource(
1:39f35f5:                 obtainDbName(dbName, 
1:39f35f5:                              recoveryAttribute == null ? null : "restored"));
1:39f35f5:         StringBuffer str = new StringBuffer(75);
1:39f35f5:         if (recoveryAttribute == null) {
1:39f35f5:             // Enable data encryption is this database is being created.
1:39f35f5:             JDBCDataSource.setBeanProperty(ds, "CreateDatabase", "create");
1:39f35f5:             str.append("dataEncryption=true;");
1:39f35f5:         } else {
1:39f35f5:             str.append(recoveryAttribute);
1:39f35f5:             str.append(";");
1:39f35f5:         }
1:39f35f5:         // Add the encryption algorithm.
1:39f35f5:         str.append("encryptionAlgorithm=");
1:39f35f5:         str.append(algorithm);
1:39f35f5:         str.append(";");
1:39f35f5:         // Add the key.
1:39f35f5:         str.append("encryptionKey=");
1:39f35f5:         switch (keyMode) {
1:39f35f5:             case CORRECT_KEY:
1:39f35f5:                 str.append(keyCorrect);
1:39f35f5:                 break;
1:39f35f5:             case WRONG_KEY:
1:39f35f5:                 str.append(keyWrong);
1:39f35f5:                 break;
1:39f35f5:             case ODD_LENGTH_KEY:
1:39f35f5:                 str.append(keyOddLength);
1:39f35f5:                 break;
1:39f35f5:             case INVALID_CHAR_KEY:
1:39f35f5:                 str.append(keyInvalidChar);
1:39f35f5:                 break;
1:39f35f5:             default:
1:39f35f5:                 throw new IllegalArgumentException(
1:39f35f5:                         "Invalid key mode specified: " + keyMode);
1:39f35f5:         }
1:39f35f5:         str.append(";");
1:39f35f5:         JDBCDataSource.setBeanProperty(
1:39f35f5:                 ds, "connectionAttributes", str.toString());
1:39f35f5:         return ds.getConnection();
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Shutdown the specified database.
1:39f35f5:      *
1:39f35f5:      * @param databaseName the name of the database
1:39f35f5:      */
1:39f35f5:     protected void shutdown(String databaseName)
1:39f35f5:             throws SQLException {
1:39f35f5:         shutdown(databaseName, null);
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Shutdown the database, specified by the database name and prefix.
1:39f35f5:      *
1:39f35f5:      * @param databaseName the name of the database
1:39f35f5:      * @param dir sub-directory prefix for the database
1:39f35f5:      */
1:39f35f5:     protected void shutdown(String databaseName, String dir)
1:39f35f5:             throws SQLException {
1:39f35f5:         DataSource ds = JDBCDataSource.getDataSource(
1:39f35f5:                 obtainDbName(databaseName, dir));
1:39f35f5:         JDBCDataSource.shutdownDatabase(ds);
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Create a new database and populate it.
1:39f35f5:      * <p>
1:39f35f5:      * The method fails with an exception if the database already exists.
1:39f35f5:      * This is because it is the creation process that is to be tested.
1:39f35f5:      *
1:39f35f5:      * @param dbName name of the database to create
1:39f35f5:      * @return A connection the to the newly created database.
1:39f35f5:      * @throws SQLException if the database already exist, or
1:39f35f5:      *      a general error happens during database interaction
1:39f35f5:      */
1:39f35f5:     protected Connection createAndPopulateDB(String dbName)
1:39f35f5:             throws SQLException {
1:5e00943:         Connection newCon = getConnection(dbName, CORRECT_KEY);
1:5e00943:         SQLWarning warning = newCon.getWarnings();
1:39f35f5:         // If the database already exists, fail the test.
1:39f35f5:         if (warning != null) {
1:39f35f5:             if ("01J01".equals(warning.getSQLState())) {
1:39f35f5:                 fail("Refusing to continue, database already exists <" +
1:39f35f5:                         warning.getMessage() + ">");
1:39f35f5:             }
1:39f35f5:         }
1:5e00943:         Statement stmt = newCon.createStatement();
1:39f35f5:         stmt.executeUpdate("CREATE TABLE " + TABLE + " (id int NOT NULL, " +
1:39f35f5:                 "val int NOT NULL, PRIMARY KEY(id))");
1:39f35f5:         stmt.close();
1:5e00943:         PreparedStatement ps = newCon.prepareStatement("INSERT INTO " + TABLE +
1:39f35f5:                 " (id, val) VALUES (?,?)");
1:39f35f5:         for (int i=0; i < DATA.length; i++) {
1:39f35f5:             ps.setInt(1, i);
1:39f35f5:             ps.setInt(2, DATA[i]);
1:39f35f5:             ps.executeUpdate();
1:39f35f5:         }
1:39f35f5:         ps.close();
1:5e00943:         return newCon;
1:39f35f5:     }
1:39f35f5: 
1:39f35f5:     /**
1:39f35f5:      * Validate the data in the database against the data model.
1:39f35f5:      *
1:39f35f5:      * @param con the database to validate the contents of
1:39f35f5:      * @throws junit.framework.AssertionFailedError if there is a mismatch
1:39f35f5:      *      between the data in the database and the model
1:39f35f5:      */
1:39f35f5:     protected void validateDBContents(Connection con)
1:39f35f5:             throws SQLException {
2:39f35f5:         Statement stmt = con.createStatement();
1:39f35f5:         ResultSet rs = stmt.executeQuery("SELECT id, val FROM " + TABLE +
1:39f35f5:                                             " ORDER BY id");
1:39f35f5:         int id, val;
1:39f35f5:         while (rs.next()) {
1:39f35f5:             id = rs.getInt(1);
1:39f35f5:             val = rs.getInt(2);
1:39f35f5:             if (id >= DATA.length) {
1:39f35f5:                 fail("Id in database out of bounds for data model; " +
1:39f35f5:                         id + " >= " + DATA.length);
1:39f35f5:             }
1:39f35f5:             if (val != DATA[id]) {
1:39f35f5:                 fail("Mismatch between db and model for id " + id + ";" +
1:39f35f5:                         val + " != " + DATA[id]);
1:39f35f5:             }
1:39f35f5:         }
1:39f35f5:         rs.close();
1:39f35f5:         stmt.close();
1:39f35f5:     }
1:39f35f5: } // End EncryptionKeyTest
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
1:     String obtainDbName(String dbName, String subdirectory) {
1:         return PrivilegedFileOpsForTests.getAbsolutePath(
1:                 new File(SupportFilesSetup.EXTINOUT, tmp.getPath()));
commit:4ef144b
/////////////////////////////////////////////////////////////////////////
1:         con = null;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:5e00943
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Connection newCon = getConnection(dbName, CORRECT_KEY);
1:         SQLWarning warning = newCon.getWarnings();
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = newCon.createStatement();
1:         PreparedStatement ps = newCon.prepareStatement("INSERT INTO " + TABLE +
/////////////////////////////////////////////////////////////////////////
1:         return newCon;
commit:52f1d64
/////////////////////////////////////////////////////////////////////////
1:         con = getConnection(dbNameRestored, CORRECT_KEY,
/////////////////////////////////////////////////////////////////////////
1:             con = getConnection(dbNameRestored, WRONG_KEY,
/////////////////////////////////////////////////////////////////////////
1:             con = getConnection(dbNameRestored, INVALID_CHAR_KEY,
/////////////////////////////////////////////////////////////////////////
1:             con = getConnection(dbNameRestored, ODD_LENGTH_KEY,
/////////////////////////////////////////////////////////////////////////
1:         con = getConnection(dbNameRestored, CORRECT_KEY,
/////////////////////////////////////////////////////////////////////////
1:             con = getConnection(dbNameRestored, INVALID_CHAR_KEY,
/////////////////////////////////////////////////////////////////////////
1:         con = getConnection(targetDb, CORRECT_KEY,
/////////////////////////////////////////////////////////////////////////
commit:90c4f40
/////////////////////////////////////////////////////////////////////////
1:         cs.setString(1,
1:                 new File(SupportFilesSetup.EXTINOUT, "backups").getPath());
commit:39f35f5
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.EncryptionKeyTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.io.File;
1: 
1: import java.sql.Connection;
1: import java.sql.CallableStatement;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.Statement;
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: 
1: import javax.sql.DataSource;
1: 
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
0: import java.security.PrivilegedActionException;
0: import java.security.PrivilegedExceptionAction;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: 
1: /**
1:  * Tests various connection sequences to encrypted databases.
1:  * Four kinds of external keys are used:
1:  *  <ol><li>the correct key
1:  *      <li>an incorrect key
1:  *      <li>a key with odd length (in hex representation)
1:  *      <li>a key containing invalid characters
1:  *  </ol>
1:  * <p>
1:  * The algorithms used for en-/decryption is determined by the subclasses,
1:  * where a single algorithm and a set of keys are associated with each
1:  * subclass.
1:  * <p>
1:  * Databases are created in the <tt>EXTINOUT</tt> directory. Backups are made
1:  * to <tt>EXTINOUT/backups</tt> and restored databases are put into
1:  * <tt>EXTINOUT/restored</tt> <b>if and only if</b> the databases need to be
1:  * both written and read. Otherwise backups are placed in <tt>EXTOUT</tt>.
1:  * Testsuites generated from this class must be wrapped in a
1:  * <code>SupportFileSetup</code> decorator.
1:  */
1:  //@NotThreadSafe
1: public abstract class EncryptionKeyTest
1:     extends BaseJDBCTestCase {
1: 
1:     /** Correct key constant. */
1:     protected static final int CORRECT_KEY = 0;
1:     /** Wrong key constant. */
1:     protected static final int WRONG_KEY = 1;
1:     /** Odd length key constant. */
1:     protected static final int ODD_LENGTH_KEY = 2;
1:     /** Invalid char key constant. */
1:     protected static final int INVALID_CHAR_KEY = 3;
1: 
1:     /** Table holding the test data. */
1:     private static final String TABLE = "encryptionkeytestdata";
1:     /** Test data inserted into database and used for verification. */
1:     private static final int[] DATA = {9,4,2,34,6543,3,123,434,5436,-123,0,123};
1: 
1:     /** The algorithm used by the fixture. */
1:     private final String algorithm;
1: 
1:     /** The correct key. */
1:     private final String keyCorrect;
1:     /** An incorrect key. */
1:     private final String keyWrong;
1:     /** A key with odd length. */
1:     private final String keyOddLength;
1:     /** A key with an invalid char in it. */
1:     private final String keyInvalidChar;
1: 
1:     /**
1:      * Variable to hold the various connections.
1:      * No guarantee is made about the state of this connection, but it is
1:      * closed at tear-down.
1:      */
1:     private Connection con = null;
1: 
1:     /**
1:      * Configures a new setup by specifying the encryption properties.
1:      *
1:      * @param name name of the fixture
1:      * @param algorithm encryption algorithm to use
1:      * @param correctKey the correct encryption key
1:      * @param wrongKey an incorrect encryption key
1:      * @param oddLengthKey a key of odd length
1:      * @param invalidCharKey a key with invalid characters
1:      */
1:     public EncryptionKeyTest(String name,
1:                              String algorithm,
1:                              String correctKey,
1:                              String wrongKey,
1:                              String oddLengthKey,
1:                              String invalidCharKey) {
1:         super(name);
1:         this.algorithm = algorithm;
1:         this.keyCorrect = correctKey;
1:         this.keyWrong = wrongKey;
1:         this.keyOddLength = oddLengthKey;
1:         this.keyInvalidChar = invalidCharKey;
1:     }
1: 
1:     /**
1:      * Clean up the connection maintained by this test.
1:      */
1:     protected void tearDown()
1:             throws java.lang.Exception {
1:         if (con != null && !con.isClosed()) {
1:             con.rollback();
1:             con.close();
0:             con = null;
1:         }
1:         super.tearDown();
1:     }
1: 
1:     /**
1:      * Test a sequence of connections and connection attempts.
1:      * Sequence: Create database, connect to database using correct key,
1:      * try to connect using incorrect key, connect using correct key.
1:      */
1:     public void testConnectionSequence1()
1:             throws SQLException {
1:         String dbName = "encryptedDB_ConnectionSequence1";
1:         // Create database.
1:         con = createAndPopulateDB(dbName);
1:         validateDBContents(con);
1:         // Shutdown the database.
1:         con.close();
1:         shutdown(dbName);
1:         // Connect using correct key.
1:         con = getConnection(dbName, CORRECT_KEY);
1:         validateDBContents(con);
1:         con.close();
1:         // Shutdown the database.
1:         shutdown(dbName);
1:         // Try to connect using wrong key.
1:         try {
1:             getConnection(dbName, WRONG_KEY);
1:             fail("Booting with an incorrect encryption key should fail.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ040", sqle);
1:             assertSQLState("XBCXK", getLastSQLException(sqle));
1:         }
1:         // Connect using correct key.
1:         con = getConnection(dbName, CORRECT_KEY);
1:         validateDBContents(con);
1:         con.close();
1:         // Shutdown the database.
1:         shutdown(dbName);
1:     }
1: 
1:     /**
1:      * Test a sequence of connections and connection attempts.
1:      * Sequence: Create database, connect to database using odd length key,
1:      * try to connect using incorrect key, connect using correct key.
1:      */
1:     public void testConnectionSequence2()
1:             throws SQLException {
1:         String dbName = "encryptedDB_ConnectionSequence2";
1:         // Create database.
1:         con = createAndPopulateDB(dbName);
1:         validateDBContents(con);
1:         // Shutdown the database.
1:         con.close();
1:         shutdown(dbName);
1:         // Connect using odd length key.
1:         try {
1:             con = getConnection(dbName, ODD_LENGTH_KEY);
1:             fail("Connected with an odd length key.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ040", sqle);
1:             SQLException lastSQLE = getLastSQLException(sqle);
1:             String sqlState = lastSQLE.getSQLState();
1:             // The state of this exception varies with the security provider
1:             // the test is run with.
1:             // Briefly stated, the deciding factor is whether the error is
1:             // caught by checks in the Derby code, or by the checks in the
1:             // security provider. For instance, the (current Sun JCE) DES
1:             // key implementation does not verify the key length, whereas the
1:             // AES key implementation does. For other providers, the situation
1:             // might be different.
1:             // XBCX0 : A general crypto exception, wraps the exception from the
1:             //         security provider.
1:             // XBCXM : A specific Derby exception for external keys of invalid
1:             //         lengths.
1:             if (!sqlState.equals("XBCX0") && !sqlState.equals("XBCXM")) {
1:                 throw lastSQLE;
1:             }
1:         }
1:         confirmNonBootedDB(dbName);
1:         // Try to connect using wrong key.
1:         try {
1:             getConnection(dbName, WRONG_KEY);
1:             fail("Booting with an incorrect encryption key should fail.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ040", sqle);
1:             assertSQLState("XBCXK", getLastSQLException(sqle));
1:         }
1:         // Connect using correct key.
1:         con = getConnection(dbName, CORRECT_KEY);
1:         validateDBContents(con);
1:         con.close();
1:         // Shutdown the database.
1:         shutdown(dbName);
1:     }
1: 
1:     /**
1:      * Backup an encrypted database.
1:      */
1:     public void testBackupEncryptedDatabase()
1:             throws SQLException {
1:         String dbName = "encryptionKeyDBToBackup";
1:         // Create the database.
1:         con = createAndPopulateDB(dbName);
1:         validateDBContents(con);
1:         CallableStatement cs = con.prepareCall(
1:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
0:         cs.setString(1, SupportFilesSetup.EXTOUT);
1:         // Perform backup.
1:         cs.execute();
1:         cs.close();
1:         con.close();
1:         shutdown(dbName);
1:         // Connect to original database after backup.
1:         con = getConnection(dbName, CORRECT_KEY);
1:         validateDBContents(con);
1:         con.close();
1:         shutdown(dbName);
1:     }
1: 
1:     /**
1:      * Create a new database from a backup image.
1:      */
1:     public void testCreateDbFromBackup()
1:             throws SQLException {
1:         // No ordering imposed by JUnit, so we create our own db and backup.
1:         // Setup paths and names.
1:         final String dbName = "encryptionKeyDBToCreateFrom";
1:         final String backupDbLocation =
1:             SupportFilesSetup.getReadWrite(
1:                     new File("backups", "encryptionKeyDBToCreateFrom").getPath()
1:                 ).getPath();
1:         // Create the database.
1:         con = createAndPopulateDB(dbName);
1:         validateDBContents(con);
1:         CallableStatement cs = con.prepareCall(
1:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
1:         cs.setString(1, 
1:                      new File(SupportFilesSetup.EXTINOUT, "backups").getPath());
1:         // Perform backup.
1:         cs.execute();
1:         cs.close();
1:         con.close();
1:         shutdown(dbName);
1:         // Create a new database from backup.
1:         String dbNameRestored = dbName + "Restored";
0:         con = getPrivilegedConnection(dbNameRestored, CORRECT_KEY,
1:                 "createFrom=" + backupDbLocation);
1:         validateDBContents(con);
1:         con.close();
1:         shutdown(dbNameRestored, "restored");
1:         // Try to create a new database from backup with the wrong key.
1:         dbNameRestored = dbName + "RestoreAttemptedWrongKey";
1:         try {
0:             con = getPrivilegedConnection(dbNameRestored, WRONG_KEY,
1:                     "createFrom=" + backupDbLocation);
1:             fail("Created database from encrypted backup with wrong key.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ040", sqle);
1:             assertSQLState("XBCXK", getLastSQLException(sqle));
1:         }
1:         assertTrue(con.isClosed());
1:         // Try to create a new database from backup with an invalid key.
1:         dbNameRestored = dbName + "RestoreAttemptedInvalidKey";
1:         try {
0:             con = getPrivilegedConnection(dbNameRestored, INVALID_CHAR_KEY,
1:                     "createFrom=" + backupDbLocation);
1:             fail("Created database from encrypted backup with an invalid key.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ040", sqle);
1:             assertSQLState("XBCXN", getLastSQLException(sqle));
1:         }
1:         assertTrue(con.isClosed());
1:         // Try to create a new database from backup with an odd length key.
1:         dbNameRestored = dbName + "RestoreAttemptedOddLengthKey";
1:         try {
0:             con = getPrivilegedConnection(dbNameRestored, ODD_LENGTH_KEY,
1:                     "createFrom=" + backupDbLocation);
1:             fail("Created db from encrypted backup with an odd length key.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ040", sqle);
1:             SQLException lastSQLE = getLastSQLException(sqle);
1:             String sqlState = lastSQLE.getSQLState();
1:             // The state of this exception varies with the security provider
1:             // the test is run with.
1:             // Briefly stated, the deciding factor is whether the error is
1:             // caught by checks in the Derby code, or by the checks in the
1:             // security provider. For instance, the (current Sun JCE) DES
1:             // key implementation does not verify the key length, whereas the
1:             // AES key implementation does. For other providers, the situation
1:             // might be different.
1:             // XBCX0 : A general crypto exception, wraps the exception from the
1:             //         security provider.
1:             // XBCXM : A specific Derby exception for external keys of invalid
1:             //         lengths.
1:             if (!sqlState.equals("XBCX0") && !sqlState.equals("XBCXM")) {
1:                 throw lastSQLE;
1:             }
1:         }
1:         assertTrue(con.isClosed());
1:         // Create a new database from backup again.
1:         dbNameRestored = dbName + "RestoredOnceMore";
0:         con = getPrivilegedConnection(dbNameRestored, CORRECT_KEY,
1:                 "createFrom=" + backupDbLocation);
1:         validateDBContents(con);
1:         con.close();
1:         shutdown(dbNameRestored, "restored");
1:     }
1: 
1:     /**
1:      * Recover the database using <tt>restoreFrom</tt>.
1:      */
1:     public void testRestoreFrom()
1:             throws SQLException {
1:         // No ordering imposed by JUnit, so we create our own db and backup.
1:         String dbName = "encryptionKeyDBToRestoreFrom";
1:         String dbNameRestored = dbName + "Restored";
1:         createBackupRestore(dbName, dbNameRestored);
1:         shutdown(dbNameRestored, "restored");
1:     }
1: 
1:     /**
1:      * Try to recover database with an invalid key.
1:      * <p>
1:      * It should be noted that the existing database, which has been previously
1:      * recovered from the same backup image, is deleted/overwritten even though
1:      * Derby is unable to boot the backup image.
1:      */
1:     public void testInvalidRestoreFrom()
1:             throws SQLException {
1:         // No ordering imposed by JUnit, so we create our own db and backup.
1:         String dbName = "encryptionKeyDBToInvalidRestoreFrom";
1:         String dbNameRestored = dbName + "Restored";
1:         createBackupRestore(dbName, dbNameRestored);
1:         shutdown(dbNameRestored, "restored");
1:         // Check that the database is not booted.
1:         confirmNonBootedDB("restored/" + dbNameRestored);
1:         // Validate the existing database.
1:         con = getConnection("restored/" + dbNameRestored, CORRECT_KEY);
1:         validateDBContents(con);
1:         con.close();
1:         shutdown(dbNameRestored, "restored");
1:         // Confirm that trying a restore with an invalid key will overwrite
1:         // the existing database we are trying to restore to/into. This is
1:         // expected behavior currently, but should maybe change?
1:         try {
0:             con = getPrivilegedConnection(dbNameRestored, INVALID_CHAR_KEY,
1:                     ";restoreFrom=" + obtainDbName(dbName, null));
1:             fail("Restored database with an invalid key.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XBCXN", sqle);
1:         }
1:         // The database should no longer exist.
1:         try {
1:             // The "" is a hack to avoid using "create=true".
1:             con = getConnection("restored/" + dbNameRestored, CORRECT_KEY, "");
1:             fail("Expected connection to fail due to non-existent database.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ004", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Try to create database with a key of odd length.
1:      */
1:     public void testCreateWithOddEncryptionKeyLength()
1:             throws SQLException {
1:         try {
1:             getConnection("encryptedDB_oddKeyLength", ODD_LENGTH_KEY);
1:             fail("Database creation with odd key length should fail.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ041", sqle);
1:             SQLException lastSQLE = getLastSQLException(sqle);
1:             String sqlState = lastSQLE.getSQLState();
1:             // The state of this exception varies with the security provider
1:             // the test is run with. In general, it depends on whether it is
1:             // Derby code or the security provider code that detects the
1:             // problem with the encryption key.
1:             if (!sqlState.equals("XBCXM") && !sqlState.equals("XJ001")) {
1:                 throw lastSQLE;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Try to create database with a key containing one or more invalid chars.
1:      */
1:     public void testCreateWithInvalidEncryptionKey() {
1:         try {
1:             getConnection("encryptedDB_invkeyChar", INVALID_CHAR_KEY);
1:             fail("Database creation with invalid key should fail.");
1:         } catch (SQLException sqle)  {
1:             assertSQLState("XJ041", sqle);
1:             assertSQLState("XBCXN", getLastSQLException(sqle));
1:         }
1:     }
1: 
1:     /* ********************************************************************* *
1:      *                     H E L P E R  M E T H O D S                        *
1:      * ********************************************************************* */
1: 
1:     /**
1:      * Obtain absolute path for the specified database name.
1:      * <p>
1:      * This absolute path is the name of the database (specified) prefixed with
1:      * the absolute path to the EXTINOUT directory. The latter is determined by
1:      * consulting <code>SupportFilesSetup</code>.
1:      *
1:      * @param dbName name of the database
1:      * @param subdirectory directory to prefix the database name with (can be
1:      *      <code>null</code>). Note that the database name will be prefixed
1:      *      with the path to the EXTINOUT directory even if this parameter is
1:      *      <code>null</code>.
1:      * @return A string with the absolute path to the database.
1:      * @see SupportFilesSetup
1:      */
0:     private String obtainDbName(String dbName, String subdirectory) {
1:         File tmp = new File(dbName);
1:         if (subdirectory != null) {
1:             tmp = new File(subdirectory, dbName);
1:         }
0:         final File db = tmp;
0:         return (String)AccessController.doPrivileged(
0:                     new PrivilegedAction() {
0:                         public Object run() {
0:                             return new File(SupportFilesSetup.EXTINOUT,
0:                                             db.getPath()).getAbsolutePath();
1:                         }
1:                     }
0:                 );
1:     }
1: 
1:     /**
1:      * Create encrypted database, validate it, backup, restore and validate
1:      * recovered database.
1:      * <p>
1:      * The source db is shutdown, the recovered db is left booted.
1:      *
1:      * @param sourceDb the original database to create
1:      * @param targetDb the database to recover to
1:      */
1:     private void createBackupRestore(String sourceDb, String targetDb)
1:             throws SQLException {
1:         // Create the database.
1:         con = createAndPopulateDB(sourceDb);
1:         validateDBContents(con);
1:         CallableStatement cs = con.prepareCall(
1:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
1:         cs.setString(1,
1:                      new File(SupportFilesSetup.EXTINOUT, "backups").getPath());
1:         // Perform backup.
1:         cs.execute();
1:         con.close();
1:         shutdown(sourceDb);
1:         confirmNonBootedDB(sourceDb);
1:         // Use the restoreFrom attribute.
0:         con = getPrivilegedConnection(targetDb, CORRECT_KEY,
1:                 ";restoreFrom=" + obtainDbName(sourceDb, "backups"));
1:         validateDBContents(con);
1:         con.close();
1:     }
1: 
1:     /**
1:      * Confirm that the specified encrypted database has not been booted.
1:      *
1:      * @param dbName name of an encrypted database
1:      * @throws junit.framework.AssertionFailedError if the database has been
1:      *      booted (connection may or may not be established)
1:      */
1:     private void confirmNonBootedDB(String dbName) {
1:         DataSource ds = JDBCDataSource.getDataSource(obtainDbName(dbName, null));
1:         try {
1:             ds.getConnection();
1:         } catch (SQLException sqle) {
1:             assertSQLState("Database booted? <state:" + sqle.getSQLState() +
1:                     ", msg:" + sqle.getMessage() + ">", "XJ040", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Try to establish a connection to the named database with the
1:      * specified type of key.
1:      *
1:      * @param dbName name of the database
1:      * @param keyMode what kind of key to use (correct, wrong, invalid, odd)
1:      * @return A connection to the database.
1:      * @throws SQLException if connection fails
1:      */
1:     private Connection getConnection(String dbName, int keyMode)
1:             throws SQLException {
1:         return getConnection(dbName, keyMode, null);
1:     }
1: 
1:     /**
1:      * Try to establish a connection to the named database with the
0:      * specified type of key and recovery mode.
1:      * <p>
0:      * The connection is made in a privileged block of code to allow Derby to
0:      * read the database backup used for recovery.
1:      *
1:      * @param dbName name of the database
1:      * @param keyMode what kind of key to use (correct, wrong, invalid, odd)
1:      * @param recoveryAttribute attribute to recover a database from a backup,
1:      *      for instance <code>createFrom</code> or <code>restoreFrom</code>.
1:      *      Both the attribute and its value is expected.
1:      * @return A connection to the database.
1:      * @throws SQLException if connection fails
1:      */
0:     private Connection getPrivilegedConnection(final String dbName,
0:                                                final int keyMode,
0:                                                final String recoveryAttribute)
1:             throws SQLException {
1:         try {
0:             return (Connection)AccessController.doPrivileged(
0:                 new PrivilegedExceptionAction() {
0:                     public Object run()
1:                             throws SQLException {
0:                         return getConnection(dbName, keyMode,
0:                             recoveryAttribute);
1:                     }
0:                 });
0:         } catch (PrivilegedActionException pae) {
0:             throw (SQLException)pae.getException();
1:         }
1:     }
1: 
1:     /**
1:      * Create a new connection to the specified database, using the given
1:      * connection attributes.
1:      *
1:      * @param dbName name of the database
1:      * @param keyMode what kind of key to use (correct, wrong, invalid, odd)
1:      * @param recoveryAttribute attribute to recover a database from a backup,
1:      *      for instance <code>createFrom</code> or <code>restoreFrom</code>.
1:      *      Both the attribute and its value is expected.
1:      * @return A connection to the database.
1:      * @throws SQLException if connection fails
1:      */
1:     private Connection getConnection(String dbName,
1:                                      int keyMode,
1:                                      String recoveryAttribute)
1:             throws SQLException {
1:         DataSource ds = JDBCDataSource.getDataSource(
1:                 obtainDbName(dbName, 
1:                              recoveryAttribute == null ? null : "restored"));
1:         StringBuffer str = new StringBuffer(75);
1:         if (recoveryAttribute == null) {
1:             // Enable data encryption is this database is being created.
1:             JDBCDataSource.setBeanProperty(ds, "CreateDatabase", "create");
1:             str.append("dataEncryption=true;");
1:         } else {
1:             str.append(recoveryAttribute);
1:             str.append(";");
1:         }
1:         // Add the encryption algorithm.
1:         str.append("encryptionAlgorithm=");
1:         str.append(algorithm);
1:         str.append(";");
1:         // Add the key.
1:         str.append("encryptionKey=");
1:         switch (keyMode) {
1:             case CORRECT_KEY:
1:                 str.append(keyCorrect);
1:                 break;
1:             case WRONG_KEY:
1:                 str.append(keyWrong);
1:                 break;
1:             case ODD_LENGTH_KEY:
1:                 str.append(keyOddLength);
1:                 break;
1:             case INVALID_CHAR_KEY:
1:                 str.append(keyInvalidChar);
1:                 break;
1:             default:
1:                 throw new IllegalArgumentException(
1:                         "Invalid key mode specified: " + keyMode);
1:         }
1:         str.append(";");
1:         JDBCDataSource.setBeanProperty(
1:                 ds, "connectionAttributes", str.toString());
1:         return ds.getConnection();
1:     }
1: 
1:     /**
1:      * Shutdown the specified database.
1:      *
1:      * @param databaseName the name of the database
1:      */
1:     protected void shutdown(String databaseName)
1:             throws SQLException {
1:         shutdown(databaseName, null);
1:     }
1: 
1:     /**
1:      * Shutdown the database, specified by the database name and prefix.
1:      *
1:      * @param databaseName the name of the database
1:      * @param dir sub-directory prefix for the database
1:      */
1:     protected void shutdown(String databaseName, String dir)
1:             throws SQLException {
1:         DataSource ds = JDBCDataSource.getDataSource(
1:                 obtainDbName(databaseName, dir));
1:         JDBCDataSource.shutdownDatabase(ds);
1:     }
1: 
1:     /**
1:      * Create a new database and populate it.
1:      * <p>
1:      * The method fails with an exception if the database already exists.
1:      * This is because it is the creation process that is to be tested.
1:      *
1:      * @param dbName name of the database to create
1:      * @return A connection the to the newly created database.
1:      * @throws SQLException if the database already exist, or
1:      *      a general error happens during database interaction
1:      */
1:     protected Connection createAndPopulateDB(String dbName)
1:             throws SQLException {
0:         Connection con = getConnection(dbName, CORRECT_KEY);
0:         SQLWarning warning = con.getWarnings();
1:         // If the database already exists, fail the test.
1:         if (warning != null) {
1:             if ("01J01".equals(warning.getSQLState())) {
1:                 fail("Refusing to continue, database already exists <" +
1:                         warning.getMessage() + ">");
1:             }
1:         }
1:         Statement stmt = con.createStatement();
1:         stmt.executeUpdate("CREATE TABLE " + TABLE + " (id int NOT NULL, " +
1:                 "val int NOT NULL, PRIMARY KEY(id))");
1:         stmt.close();
0:         PreparedStatement ps = con.prepareStatement("INSERT INTO " + TABLE +
1:                 " (id, val) VALUES (?,?)");
1:         for (int i=0; i < DATA.length; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, DATA[i]);
1:             ps.executeUpdate();
1:         }
1:         ps.close();
0:         return con;
1:     }
1: 
1:     /**
1:      * Validate the data in the database against the data model.
1:      *
1:      * @param con the database to validate the contents of
1:      * @throws junit.framework.AssertionFailedError if there is a mismatch
1:      *      between the data in the database and the model
1:      */
1:     protected void validateDBContents(Connection con)
1:             throws SQLException {
1:         Statement stmt = con.createStatement();
1:         ResultSet rs = stmt.executeQuery("SELECT id, val FROM " + TABLE +
1:                                             " ORDER BY id");
1:         int id, val;
1:         while (rs.next()) {
1:             id = rs.getInt(1);
1:             val = rs.getInt(2);
1:             if (id >= DATA.length) {
1:                 fail("Id in database out of bounds for data model; " +
1:                         id + " >= " + DATA.length);
1:             }
1:             if (val != DATA[id]) {
1:                 fail("Mismatch between db and model for id " + id + ";" +
1:                         val + " != " + DATA[id]);
1:             }
1:         }
1:         rs.close();
1:         stmt.close();
1:     }
1: } // End EncryptionKeyTest
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:51eb28b
/////////////////////////////////////////////////////////////////////////
0:         con = getPrivilegedConnection(dbNameRestored, CORRECT_KEY,
/////////////////////////////////////////////////////////////////////////
0:             con = getPrivilegedConnection(dbNameRestored, WRONG_KEY,
/////////////////////////////////////////////////////////////////////////
0:             con = getPrivilegedConnection(dbNameRestored, INVALID_CHAR_KEY,
/////////////////////////////////////////////////////////////////////////
0:             con = getPrivilegedConnection(dbNameRestored, ODD_LENGTH_KEY,
/////////////////////////////////////////////////////////////////////////
0:         con = getPrivilegedConnection(dbNameRestored, CORRECT_KEY,
/////////////////////////////////////////////////////////////////////////
0:             con = getPrivilegedConnection(dbNameRestored, INVALID_CHAR_KEY,
/////////////////////////////////////////////////////////////////////////
0:         con = getPrivilegedConnection(targetDb, CORRECT_KEY,
/////////////////////////////////////////////////////////////////////////
0:      * Try to establish a connection to the named database with the
0:      * specified type of key and recovery mode.
0:      * <p>
0:      * The connection is made in a privileged block of code to allow Derby to
0:      * read the database backup used for recovery.
0:      *
0:      * @param dbName name of the database
0:      * @param keyMode what kind of key to use (correct, wrong, invalid, odd)
0:      * @param recoveryAttribute attribute to recover a database from a backup,
0:      *      for instance <code>createFrom</code> or <code>restoreFrom</code>.
0:      *      Both the attribute and its value is expected.
0:      * @return A connection to the database.
0:      * @throws SQLException if connection fails
0:      */
0:     private Connection getPrivilegedConnection(final String dbName,
0:                                                final int keyMode,
0:                                                final String recoveryAttribute)
0:             throws SQLException {
0:         try {
0:             return (Connection)AccessController.doPrivileged(
0:                 new PrivilegedExceptionAction() {
0:                     public Object run()
0:                             throws SQLException {
0:                         return getConnection(dbName, keyMode,
0:                             recoveryAttribute);
0:                     }
0:                 });
0:         } catch (PrivilegedActionException pae) {
0:             throw (SQLException)pae.getException();
0:         }
0:     }
0: 
0:     /**
/////////////////////////////////////////////////////////////////////////
0:         return ds.getConnection();
commit:4cc7145
/////////////////////////////////////////////////////////////////////////
0:         
commit:c37b454
/////////////////////////////////////////////////////////////////////////
0:         con = getConnection(dbNameRestored, CORRECT_KEY,
/////////////////////////////////////////////////////////////////////////
0:             con = getConnection(dbNameRestored, WRONG_KEY,
/////////////////////////////////////////////////////////////////////////
0:             con = getConnection(dbNameRestored, INVALID_CHAR_KEY,
/////////////////////////////////////////////////////////////////////////
0:             con = getConnection(dbNameRestored, ODD_LENGTH_KEY,
/////////////////////////////////////////////////////////////////////////
0:         con = getConnection(dbNameRestored, CORRECT_KEY,
/////////////////////////////////////////////////////////////////////////
0:             con = getConnection(dbNameRestored, INVALID_CHAR_KEY,
/////////////////////////////////////////////////////////////////////////
0:         con = getConnection(targetDb, CORRECT_KEY,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             return ds.getConnection();
0:         } catch (SQLException se)
0:         {
0:             SQLException sen = se.getNextException();
0:             sen.printStackTrace();
0:             throw se;
0:             
0:         }
============================================================================