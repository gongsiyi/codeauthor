1:963d9f4: /*
1:963d9f4:  * Class org.apache.derbyTesting.functionTests.tests.lang.UpdateStatisticsTest
1:963d9f4:  *
1:963d9f4:  * Licensed to the Apache Software Foundation (ASF) under one
1:963d9f4:  * or more contributor license agreements.  See the NOTICE file
1:963d9f4:  * distributed with this work for additional information
1:963d9f4:  * regarding copyright ownership.  The ASF licenses this file
1:963d9f4:  * to you under the Apache License, Version 2.0 (the
1:963d9f4:  * "License"); you may not use this file except in compliance
1:963d9f4:  * with the License.  You may obtain a copy of the License at
1:963d9f4:  *
1:963d9f4:  *   http://www.apache.org/licenses/LICENSE-2.0
1:963d9f4:  *
1:963d9f4:  * Unless required by applicable law or agreed to in writing,
1:963d9f4:  * software distributed under the License is distributed on an
1:963d9f4:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:963d9f4:  * KIND, either express or implied.  See the License for the
1:963d9f4:  * specific language governing permissions and limitations
1:963d9f4:  * under the License.
1:963d9f4:  */
1:963d9f4: 
1:963d9f4: package org.apache.derbyTesting.functionTests.tests.lang;
1:963d9f4: 
1:ae1478d: import java.sql.CallableStatement;
1:beaa0a4: import java.sql.Connection;
1:c2b03c4: import java.sql.PreparedStatement;
1:963d9f4: import java.sql.ResultSet;
1:963d9f4: import java.sql.SQLException;
1:963d9f4: import java.sql.Statement;
1:7e33399: import java.sql.Types;
1:963d9f4: import junit.framework.Test;
1:963d9f4: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:c287c8c: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:a525856: import org.apache.derbyTesting.junit.IndexStatsUtil;
1:963d9f4: import org.apache.derbyTesting.junit.JDBC;
1:963d9f4: import org.apache.derbyTesting.junit.TestConfiguration;
1:c2b03c4: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1:c2b03c4: import org.apache.derbyTesting.junit.SQLUtilities;
1:963d9f4: 
1:963d9f4: /**
1:963d9f4:  * Tests for updating the statistics of one index or all the indexes on a
1:c2b03c4:  * table DERBY-269, DERBY-3788.
1:a6a0733:  * Tests for dropping the statistics of one index or all the indexes on a
1:a6a0733:  * table DERBY-4115.
1:963d9f4:  */
1:963d9f4: public class UpdateStatisticsTest extends BaseJDBCTestCase {
1:963d9f4: 
1:963d9f4:     public UpdateStatisticsTest(String name) {
1:963d9f4:         super(name);
1:963d9f4:     }
1:963d9f4: 
1:963d9f4:     public static Test suite() {
1:c287c8c:         //       Disable automatic index statistics generation. The generation will be
1:a525856:         //       triggered when preparing a statement and this will interfere
1:a525856:         //       with some of the asserts in testUpdateStatistics.
1:a525856:         //       With automatic generation enabled, testUpdateStatistics may
1:c287c8c:         //       fail intermittently due to timing, mostly when run
1:a525856:         //       with the client driver.
1:c287c8c:         Test test = TestConfiguration.defaultSuite(UpdateStatisticsTest.class);
1:c287c8c:         Test statsDisabled = DatabasePropertyTestSetup.singleProperty
1:c287c8c:             ( test, "derby.storage.indexStats.auto", "false", true );
1:c287c8c:         return statsDisabled;
1:963d9f4:     }
1:963d9f4: 
1:963d9f4:     /**
1:a6a0733:      * Test that parser can work with column and index named STATISTICS and
1:a6a0733:      *  does not get confused with non-reserved keyword STATISTICS used by
1:a6a0733:      *  UPDATE and DROP STATISTICS syntax generated internally for
1:a6a0733:      *  SYSCS_DROP_STATISTICS and SYSCS_UPDATE_STATISTICS
1:963d9f4:      */
1:a6a0733:     public void testIndexAndColumnNamedStatistics() throws SQLException {
1:b0e73bc:         String tbl = "T1";
1:a525856:         // Helper object to obtain information about index statistics.
1:a525856:         IndexStatsUtil stats = new IndexStatsUtil(openDefaultConnection());
1:963d9f4:         Statement s = createStatement();
1:a6a0733: 
1:b0e73bc:         // Get the initial count of statistics in the database.
1:b0e73bc:         int initialStatsCount = stats.getStats().length;
1:b0e73bc: 
1:a6a0733:         //Notice the name of one of the columns is STATISTICS
1:a6a0733:         s.executeUpdate("CREATE TABLE t1 (c11 int, statistics int not null)");
1:a6a0733:         //Notice that the name of the index is STATISTICS which is same as 
1:a6a0733:         // one of the column names
1:a6a0733:         s.executeUpdate("CREATE INDEX statistIcs ON t1(c11)");
1:a6a0733:         s.executeUpdate("INSERT INTO t1 VALUES(1,1)");
1:b0e73bc:         stats.assertNoStatsTable(tbl);
1:a6a0733:         //Drop the column named STATISTICS and make sure parser doesn't
1:a6a0733:         // throw an error
1:a6a0733:         s.executeUpdate("ALTER TABLE t1 DROP statistics");
1:a6a0733:         //Should still be able to call update/drop statistics on index 
1:a6a0733:         // STATISTICS
1:a6a0733:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','STATISTICS')");
1:b0e73bc:         stats.assertTableStats(tbl, 1);
1:a6a0733:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','STATISTICS')");
1:b0e73bc:         stats.assertNoStatsTable(tbl);
1:a6a0733:         //Add the column named STATISTICS back
1:a6a0733:         s.executeUpdate("ALTER TABLE t1 ADD COLUMN statistics int");
1:b0e73bc:         stats.assertNoStatsTable(tbl);
1:a6a0733:         //Update or drop statistics for index named STATISTICS. Note that there
1:a6a0733:         // is also a column named STATISTICS in the table
1:a6a0733:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','STATISTICS')");
1:b0e73bc:         stats.assertNoStatsTable(tbl);
1:a6a0733:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','STATISTICS')");
1:b0e73bc:         stats.assertTableStats(tbl, 1);
1:a6a0733:         s.executeUpdate("DROP TABLE t1");
1:a6a0733: 
1:b0e73bc:         // Check that we haven't created some other statistics as a side-effect.
1:b0e73bc:         assertEquals(initialStatsCount, stats.getStats().length);
1:a6a0733:     }
1:b0e73bc: 
1:f6e9c21:     //DERBY-5750(Sending an empty string as table name to compress table 
1:f6e9c21:     // procedure or empty string as index name to update statistics procedure 
1:f6e9c21:     // makes the parser throw an exception.)
1:f6e9c21:     //
1:f6e9c21:     //No table name will result in exception since Derby doesn't know table
1:f6e9c21:     // whose statistics it needs to be update/drop
1:f6e9c21:     public void testStatisticsProcsWithEmptyParamsDerby5750() throws SQLException {
1:f6e9c21:         Statement s = createStatement();
1:f6e9c21:         s.execute("create table DERBY5750_t1 (c11 int)");
1:f6e9c21:         s.executeUpdate("CREATE INDEX DERBY5750_I1 ON DERBY5750_t1(c11)");
1:f6e9c21:         //Following statements will give exceptions since there is no schema
1:f6e9c21:         // named empty string
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42Y07", s,
1:f6e9c21:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:f6e9c21:                 "'','DERBY5750_T1','DERBY5750_I1')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42Y07", s,
1:f6e9c21:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:f6e9c21:                 "'','DERBY5750_T1','DERBY5750_I1')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42Y07", s,
1:f6e9c21:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:f6e9c21:                 "'','','DERBY5750_I1')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42Y07", s,
1:f6e9c21:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:f6e9c21:                 "'','','DERBY5750_I1')");
1:f6e9c21: 
1:f6e9c21:         //null schema name will translate to current schema
1:f6e9c21:         s.execute("call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:f6e9c21:                 "null,'DERBY5750_T1','DERBY5750_I1')");
1:f6e9c21:         s.execute("call syscs_util.SYSCS_DROP_STATISTICS(" +
1:f6e9c21:                 "null,'DERBY5750_T1','DERBY5750_I1')");
1:f6e9c21:         
1:f6e9c21:         //Following statements will give exceptions since there is no table  
1:f6e9c21:         // named empty string
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X05", s,
1:f6e9c21:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:f6e9c21:                 "null,'','DERBY5750_I1')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X05", s,
1:f6e9c21:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:f6e9c21:                 "null,'','DERBY5750_I1')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X05", s,
1:f6e9c21:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:f6e9c21:                 "'APP','','DERBY5750_I1')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X05", s,
1:f6e9c21:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:f6e9c21:                 "'APP','','DERBY5750_I1')");
1:f6e9c21: 
1:f6e9c21:         //Following statements will give exceptions since table name can't 
1:f6e9c21:         // be null
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X05", s,
1:f6e9c21:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:f6e9c21:                 "null,null,'DERBY5750_I1')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X05", s,
1:f6e9c21:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:f6e9c21:                 "null,null,'DERBY5750_I1')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X05", s,
1:f6e9c21:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:f6e9c21:                 "'APP',null,'DERBY5750_I1')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X05", s,
1:f6e9c21:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:f6e9c21:                 "'APP',null,'DERBY5750_I1')");
1:f6e9c21: 
1:f6e9c21:         //Provide all the 3 params, schema, table and index name
1:f6e9c21:         s.execute("call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:f6e9c21:                 "'APP','DERBY5750_T1','DERBY5750_I1')");
1:f6e9c21:         s.execute("call syscs_util.SYSCS_DROP_STATISTICS("+
1:f6e9c21:                 "'APP','DERBY5750_T1','DERBY5750_I1')");
1:f6e9c21:         
1:f6e9c21:         
1:f6e9c21:         //Following statements will give exceptions since there is no index  
1:f6e9c21:         // named empty string
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X65", s,
1:f6e9c21:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:f6e9c21:                 "'APP','DERBY5750_T1','')");
1:f6e9c21:         assertStatementError(
1:f6e9c21:                 "42X65", s,
1:f6e9c21:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:f6e9c21:                 "'APP','DERBY5750_T1','')");
1:f6e9c21:         
1:f6e9c21:         s.execute("drop table DERBY5750_t1");    	
1:f6e9c21:     }
1:f6e9c21: 
1:a6a0733:     /**
1:a6a0733:      * Test for update statistics
1:a6a0733:      */
1:a6a0733:     public void testUpdateAndDropStatistics() throws SQLException {
1:387174c:         String tbl1 = "T1";
1:a6a0733:         // Helper object to obtain information about index statistics.
1:a6a0733:         IndexStatsUtil stats = new IndexStatsUtil(openDefaultConnection());
1:a6a0733:         Statement s = createStatement();
1:a6a0733: 
1:a6a0733:         //Calls to update and drop statistics below should fail because 
1:a6a0733:         // table APP.T1 does not exist
1:b0e73bc:         dropTable("T1");
1:a6a0733:         assertStatementError("42Y55", s, 
1:a6a0733:             "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1',null)");
1:963d9f4:         assertStatementError("42Y55", s, 
1:963d9f4:             "CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1',null)");
1:a6a0733: 
1:c2b03c4:         s.executeUpdate("CREATE TABLE t1 (c11 int, c12 varchar(128))");
1:963d9f4:         //following will pass now because we have created APP.T1
1:a6a0733:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1',null)");
1:963d9f4:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1',null)");
1:a6a0733:         
1:963d9f4:         //following should fail because index I1 does not exist on table APP.T1
1:963d9f4:         assertStatementError("42X65", s, 
1:a6a0733:                 "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','I1')");
1:a6a0733:         assertStatementError("42X65", s, 
1:a6a0733:                 "CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I1')");
1:a6a0733:         
1:c2b03c4:         s.executeUpdate("CREATE INDEX i1 on t1(c12)");
1:963d9f4:         //following will pass now because we have created index I1 on APP.T1
1:a6a0733:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','I1')");
1:963d9f4:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I1')");
1:963d9f4: 
1:963d9f4:         //The following set of subtest will ensure that when an index is
1:963d9f4:         //created on a table when there is no data in the table, then Derby
1:963d9f4:         //will not generate a row for it in sysstatistics table. If the index
1:963d9f4:         //is created after the table has data on it, there will be a row for
1:963d9f4:         //it in sysstatistics table. In order to generate statistics for the
1:963d9f4:         //first index, users can run the stored procedure 
1:963d9f4:         //SYSCS_UPDATE_STATISTICS
1:963d9f4:         //So far the table t1 is empty and we have already created index I1 on 
1:963d9f4:         //it. Since three was no data in the table when index I1 was created,
1:963d9f4:         //there will be no row in sysstatistics table
1:387174c:         stats.assertNoStatsTable(tbl1);
1:963d9f4:         //Now insert some data into t1 and then create a new index on the 
1:963d9f4:         //table. This will cause sysstatistics table to have one row for this
1:963d9f4:         //new index. Old index will still not have a row for it in
1:963d9f4:         //sysstatistics table
1:963d9f4:         s.executeUpdate("INSERT INTO T1 VALUES(1,'a'),(2,'b'),(3,'c'),(4,'d')");
1:c2b03c4:         s.executeUpdate("CREATE INDEX i2 ON t1(c11)");
1:387174c:         stats.assertTableStats(tbl1, 1);
1:a6a0733:         //Drop the statistics on index I2 and then add it back by calling 
1:a6a0733:         // update statistics
1:a6a0733:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','I2')");
1:a6a0733:         //Since we dropped the only statistics that existed for table T1, there
1:a6a0733:         // will no stats found at this point
1:387174c:         stats.assertNoStatsTable(tbl1);
1:a6a0733:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I2')");
1:a6a0733:         //The statistics for index I2 has been added back
1:387174c:         stats.assertTableStats(tbl1, 1);
1:963d9f4:         //Now update the statistics for the old index I1 using the new stored
1:963d9f4:         //procedure. Doing this should add a row for it in sysstatistics table
1:963d9f4:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I1')");
1:387174c:         stats.assertTableStats(tbl1, 2);
1:a6a0733:         //Drop the statistics on index I1 and then add it back by calling 
1:a6a0733:         // update statistics
1:a6a0733:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','I1')");
1:387174c:         stats.assertTableStats(tbl1, 1);
1:a6a0733:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I1')");
1:387174c:         stats.assertTableStats(tbl1, 2);
1:a6a0733:         //Drop all the statistics on table T1 and then recreate all the 
1:a6a0733:         // statisitcs back again
1:a6a0733:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1',null)");
1:387174c:         stats.assertNoStatsTable(tbl1);
1:a6a0733:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1',null)");
1:387174c:         stats.assertTableStats(tbl1, 2);
1:a6a0733:         //Dropping the index should get rid of it's statistics
1:a6a0733:         s.executeUpdate("DROP INDEX I1");
1:387174c:         stats.assertTableStats(tbl1, 1);
1:963d9f4: 
1:a6a0733:         //calls to system procedure for update and drop statistics are
1:a6a0733:         // internally converted into ALTER TABLE ... sql but that generated
1:a6a0733:         // sql format is not available to end user to issue directly. Write a 
1:a6a0733:         // test case for these internal sql syntaxes
1:963d9f4:         assertStatementError("42X01", s, 
1:963d9f4:             "ALTER TABLE APP.T1 ALL UPDATE STATISTICS");
1:963d9f4:         assertStatementError("42X01", s, 
1:963d9f4:             "ALTER TABLE APP.T1 UPDATE STATISTICS I1");
1:a6a0733:         assertStatementError("42X01", s, 
1:a6a0733:                 "ALTER TABLE APP.T1 ALL DROP STATISTICS");
1:a6a0733:         assertStatementError("42X01", s, 
1:a6a0733:                 "ALTER TABLE APP.T1 STATISTICS DROP I1");
1:c2b03c4:         //cleanup
1:c2b03c4:         s.executeUpdate("DROP TABLE t1");
1:963d9f4: 
1:a6a0733:         //Try update and drop statistics on global temporary table
1:963d9f4: 		s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit delete rows not logged");
1:963d9f4: 		s.executeUpdate("insert into session.t1 values(11, 1)");
1:a6a0733:         //following should fail because update/drop statistics can't be issued
1:a6a0733: 		// on global temporary tables
1:963d9f4:         assertStatementError("42995", s, 
1:a6a0733:                 "CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('SESSION','T1',null)");
1:a6a0733:         assertStatementError("42995", s, 
1:a6a0733:                 "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('SESSION','T1',null)");
1:c2b03c4:         
1:c2b03c4:         //Following test will show that updating the statistics will make a
1:c2b03c4:         //query pickup better index compare to prior to statistics availability.
1:c2b03c4:         //
1:c2b03c4:         //Check statistics update causes most efficient index usage
1:c2b03c4:         //Create a table with 2 non-unique indexes on 2 different columns.
1:c2b03c4:         //The indexes are created when the table is still empty and hence
1:c2b03c4:         //there are no statistics available for them in sys.sysstatistics.
1:c2b03c4:         //The table looks as follows
1:c2b03c4:         //        create table t2(c21 int, c22 char(14), c23 char(200))
1:c2b03c4:         //        create index t2i1 on t2(c21)
1:c2b03c4:         //        create index t2i2 on t2(c22)
1:c2b03c4:         //Load the data into the table and running following query will
1:c2b03c4:         //pickup index t2i1 on column c21
1:c2b03c4:         //        select * from t2 where c21=? and c22=?
1:c2b03c4:         //But once you make the statistics available for t2i2, the query
1:c2b03c4:         //will pickup index t2i2 on column c22 for the query above
1:c2b03c4:         //
1:c2b03c4:         //Start of test case for better index selection after statistics
1:c2b03c4:         //availability
1:c2b03c4:         s.executeUpdate("CREATE TABLE t2(c21 int, c22 char(14), c23 char(200))");
1:c2b03c4:         //No statistics will be created for the 2 indexes because the table is 
1:c2b03c4:         //empty
1:c2b03c4:         s.executeUpdate("CREATE INDEX t2i1 ON t2(c21)");
1:c2b03c4:         s.executeUpdate("CREATE INDEX t2i2 ON t2(c22)");
1:387174c:         stats.assertNoStatsTable("T2");
1:c2b03c4:         
1:c2b03c4:         PreparedStatement ps = prepareStatement("INSERT INTO T2 VALUES(?,?,?)");
1:c2b03c4:         for (int i=0; i<1000; i++) {
1:c2b03c4:         	ps.setInt(1, i%2);
1:c2b03c4:             ps.setString(2, "Tuple " +i);
1:c2b03c4:             ps.setString(3, "any value");
1:c2b03c4:             ps.addBatch();
1:c2b03c4:         }
1:c2b03c4:         ps.executeBatch();
1:c2b03c4: 
1:c2b03c4: 		s.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:c2b03c4: 		
1:c2b03c4: 		//Executing the query below and looking at it's plan will show that
1:c2b03c4: 		//we picked index T2I1 rather than T2I2 because there are no 
1:c2b03c4: 		//statistics available for T2I2 to show that it is a better index
1:c2b03c4: 		ps = prepareStatement("SELECT * FROM t2 WHERE c21=? AND c22=?");
1:c2b03c4:     	ps.setInt(1, 0);
1:c2b03c4:         ps.setString(2, "Tuple 4");
1:c2b03c4:         JDBC.assertDrainResults(ps.executeQuery());
1:c2b03c4: 		RuntimeStatisticsParser rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:c2b03c4: 		assertTrue(rtsp.usedSpecificIndexForIndexScan("T2","T2I1"));
1:c2b03c4: 
1:c2b03c4: 		//Running the update statistics below will create statistics for T2I2
1:c2b03c4: 		s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T2','T2I2')");
1:a525856:         stats.assertIndexStats("T2I2", 1);
1:c2b03c4: 
1:c2b03c4:         //Rerunning the query "SELECT * FROM t2 WHERE c21=? AND c22=?" and
1:c2b03c4:         //looking at it's plan will show that this time it picked up more
1:a6a0733:         //efficient index which is T2I2.
1:c2b03c4:         JDBC.assertDrainResults(ps.executeQuery());
1:c2b03c4: 		rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:c2b03c4: 		assertTrue(rtsp.usedSpecificIndexForIndexScan("T2","T2I2"));
1:a6a0733: 
1:a6a0733: 		//Drop statistics for T2I2 and we should see that we go back to using
1:a6a0733: 		// T2I1 rather than T2I2
1:a6a0733: 		s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T2','T2I2')");
1:a6a0733:         stats.assertIndexStats("T2I2", 0);
1:a6a0733: 
1:a6a0733:         //Rerunning the query "SELECT * FROM t2 WHERE c21=? AND c22=?" and
1:a6a0733:         // looking at it's plan will show that this time it picked up T2I1
1:a6a0733:         // rather than more efficient index T2I2  because no stats exists
1:a6a0733:         // for T2I2
1:a6a0733:         JDBC.assertDrainResults(ps.executeQuery());
1:a6a0733: 		rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1:a6a0733: 		assertTrue(rtsp.usedSpecificIndexForIndexScan("T2","T2I1"));
1:a6a0733: 
1:c2b03c4:         //cleanup
1:c2b03c4:         s.executeUpdate("DROP TABLE t2");
1:c2b03c4:         //End of test case for better index selection after statistics
1:c2b03c4:         //availability
1:a525856:         stats.release();
1:963d9f4:     }
1:a525856: 
1:beaa0a4:     /**
1:beaa0a4:      * Test that SYSCS_UPDATE_STATISTICS doesn't obtain exclusive locks on
1:beaa0a4:      * the table or rows in the table (DERBY-4274).
1:beaa0a4:      */
1:beaa0a4:     public void testNoExclusiveLockOnTable() throws SQLException {
1:beaa0a4:         Statement s = createStatement();
1:beaa0a4:         s.execute("create table t (x char(1))");
1:beaa0a4:         s.execute("create index ti on t(x)");
1:beaa0a4:         s.execute("insert into t values 'a','b','c','d'");
2:beaa0a4: 
1:beaa0a4:         setAutoCommit(false);
1:beaa0a4:         s.execute("lock table t in share mode");
1:beaa0a4: 
1:beaa0a4:         Connection c2 = openDefaultConnection();
1:beaa0a4:         Statement s2 = c2.createStatement();
1:beaa0a4:         // This call used to time out because SYSCS_UPDATE_STATISTICS tried
1:beaa0a4:         // to lock T exclusively.
1:beaa0a4:         s2.execute("call syscs_util.syscs_update_statistics('APP', 'T', null)");
1:beaa0a4:         s2.close();
1:beaa0a4:         c2.close();
1:beaa0a4: 
1:beaa0a4:         s.execute("drop table t");
1:beaa0a4:         commit();
1:963d9f4:     }
1:ae1478d: 
1:ae1478d:     /**
1:ae1478d:      * Regression test case for DERBY-5153. Compilation in parallel with
1:ae1478d:      * update of statistics sometimes failed on debug builds.
1:ae1478d:      */
1:a899bbc:     public void testParallelCompilationAndUpdate() throws Exception {
1:ae1478d:         setAutoCommit(false);
1:ae1478d: 
1:ae1478d:         // Create and populate a test table with a multi-column index.
1:ae1478d:         Statement s = createStatement();
1:ae1478d:         s.execute("create table derby5153(a int, b int, c int, d int)");
1:ae1478d:         s.execute("create index idx on derby5153(a,b,c,d)");
1:ae1478d: 
1:ae1478d:         PreparedStatement ins =
1:ae1478d:                 prepareStatement("insert into derby5153 values (1,2,3,4)");
1:ae1478d:         for (int i = 0; i < 100; i++) {
1:ae1478d:             ins.execute();
1:ae1478d:         }
1:ae1478d: 
1:ae1478d:         commit();
1:ae1478d: 
1:ae1478d:         // Start a thread that repeatedly updates the statistics for IDX.
1:ae1478d:         Connection updateConn = openDefaultConnection();
1:ae1478d:         IndexUpdateThread t =
1:ae1478d:                 new IndexUpdateThread(updateConn, "APP", "DERBY5153", "IDX");
1:ae1478d:         t.start();
1:ae1478d: 
2:ae1478d:         try {
1:ae1478d: 
1:ae1478d:             // Compile/execute the query a number of times while the index
1:ae1478d:             // statistics are being updated. This often failed with an assert
1:ae1478d:             // failure in debug builds before DERBY-5153.
1:ae1478d:             for (int i = 0; i < 100; i++) {
1:ae1478d:                 ResultSet rs = s.executeQuery(
1:ae1478d:                         "select * from derby5153 t1, derby5153 t2 " +
1:ae1478d:                         "where t1.a = t2.a");
1:ae1478d:                 rs.close();
1:ae1478d:             }
1:ae1478d: 
1:ae1478d:         } finally {
1:ae1478d: 
1:ae1478d:             // Let the update thread know we're done.
1:ae1478d:             t.done = true;
1:ae1478d: 
1:ae1478d:         }
1:ae1478d: 
1:ae1478d:         t.join();
1:ae1478d: 
1:ae1478d:         // Check if the update thread failed, and report if it did.
1:ae1478d:         if (t.exception != null) {
1:ae1478d:             throw t.exception;
1:ae1478d:         }
1:ae1478d: 
1:ae1478d:         updateConn.close();
1:00783b8: 
1:00783b8:         // Clean-up
1:00783b8:         dropTable("derby5153");
1:00783b8:         commit();
1:ae1478d:     }
1:29a19ff:     
1:29a19ff:     /**
1:29a19ff:      * Fixed DERBY-5681(When a foreign key constraint on a table is dropped,
1:29a19ff:      *  the associated statistics row for the conglomerate is not removed.)
1:29a19ff:      * @throws Exception
1:29a19ff:      */
1:29a19ff:     public void testDERBY5681() throws Exception {
1:29a19ff:         // Helper object to obtain information about index statistics.
1:29a19ff:         IndexStatsUtil stats = new IndexStatsUtil(openDefaultConnection());
1:29a19ff:         Statement s = createStatement();
1:29a19ff:     	
1:29a19ff:         //Test - primary key constraint
1:29a19ff:         s.executeUpdate("CREATE TABLE TEST_TAB_1 (c11 int not null,"+
1:29a19ff:                 "c12 int not null, c13 int)");
1:29a19ff:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         //Insert data into table with no constraint and there will be no stat
1:29a19ff:         // for that table at this point
1:29a19ff:         s.executeUpdate("INSERT INTO TEST_TAB_1 VALUES(1,1,1),(2,2,2)");
1:29a19ff:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_1', null)");
1:29a19ff:         stats.assertNoStatsTable("TEST_TAB_1");
1:bce78c9:         // Add primary key constraint to the table. With DERBY-3790 this won't
1:bce78c9:         // create a statistics entry, since the key consist of single column.
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:29a19ff:         		"PRIMARY KEY (c11)");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "DROP CONSTRAINT TEST_TAB_1_PK_1");
1:29a19ff:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_1', null)");
1:29a19ff:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         //Add the primary key constraint back since it will be used by the next
1:29a19ff:         // test to create foreign key constraint
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:29a19ff:         		"PRIMARY KEY (c11)");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff: 
1:29a19ff:         //Test - unique key constraint
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "ADD CONSTRAINT TEST_TAB_1_UNQ_1 "+
1:29a19ff:         		"UNIQUE (c12)");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "DROP CONSTRAINT TEST_TAB_1_UNQ_1");
1:29a19ff:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "DROP CONSTRAINT TEST_TAB_1_PK_1");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:29a19ff:         		"PRIMARY KEY (c11)");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:bce78c9: 
1:bce78c9:         //Test - non-unique index
1:bce78c9:         s.executeUpdate("CREATE INDEX TEST_TAB_1_NUNQ_1 ON TEST_TAB_1(c12)");
7:29a19ff:         stats.assertTableStats("TEST_TAB_1",1);
1:bce78c9:         s.executeUpdate("DROP INDEX TEST_TAB_1_NUNQ_1");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:bce78c9:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:bce78c9:                 "DROP CONSTRAINT TEST_TAB_1_PK_1");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:bce78c9:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:bce78c9:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:bce78c9:         		"PRIMARY KEY (c11)");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff: 
1:29a19ff:         //Test - unique key constraint on nullable column & non-nullable column
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "ADD CONSTRAINT TEST_TAB_1_UNQ_2 "+
1:29a19ff:         		"UNIQUE (c12, c13)");
1:29a19ff:         stats.assertTableStats("TEST_TAB_1",2);
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "DROP CONSTRAINT TEST_TAB_1_UNQ_2");
1:29a19ff:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "DROP CONSTRAINT TEST_TAB_1_PK_1");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:29a19ff:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:29a19ff:         		"PRIMARY KEY (c11)");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         
1:29a19ff:         //Test - foreign key but no primary key constraint
1:29a19ff:         s.executeUpdate("CREATE TABLE TEST_TAB_3 (c31 int not null)");
1:29a19ff:         s.executeUpdate("INSERT INTO TEST_TAB_3 VALUES(1),(2)");
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_3 "+
1:29a19ff:                 "ADD CONSTRAINT TEST_TAB_3_FK_1 "+
1:29a19ff:         		"FOREIGN KEY(c31) REFERENCES TEST_TAB_1(c11)");
1:29a19ff:         stats.assertTableStats("TEST_TAB_3",1);
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_3 "+
1:29a19ff:                 "DROP CONSTRAINT TEST_TAB_3_FK_1");
1:29a19ff:         stats.assertNoStatsTable("TEST_TAB_3");
1:29a19ff: 
1:29a19ff:         //Test - foreign key and primary key constraint
1:29a19ff:         s.executeUpdate("CREATE TABLE TEST_TAB_2 (c21 int not null)");
1:29a19ff:         s.executeUpdate("INSERT INTO TEST_TAB_2 VALUES(1),(2)");
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:29a19ff:                 "ADD CONSTRAINT TEST_TAB_2_PK_1 "+
1:29a19ff:         		"PRIMARY KEY (c21)");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_2");
1:bce78c9:         // DERBY-5702 Add a foreign key constraint and now we should find one
1:bce78c9:         // row of statistics for TEST_TAB_2 (for the foreign key constraint).
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:29a19ff:                 "ADD CONSTRAINT TEST_TAB_2_FK_1 "+
1:29a19ff:         		"FOREIGN KEY(c21) REFERENCES TEST_TAB_1(c11)");
1:a6a0733:         //DERBY-5702 Like primary key earlier, adding foreign key constraint
1:a6a0733:         // didn't automatically add a statistics row for it. Have to run update
1:29a19ff:         // statistics manually to get a row added for it's stat
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_2");
1:29a19ff:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_2', null)");
4:29a19ff:         stats.assertTableStats("TEST_TAB_2",1);
1:29a19ff:         //Number of statistics row for TEST_TAB_1 will remain unchanged since
1:29a19ff:         // it has only primary key defined on it
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_1");
1:29a19ff:         s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:29a19ff:                 "DROP CONSTRAINT TEST_TAB_2_FK_1");
1:bce78c9:         //Dropping the foreign key constraint should cause the statistics row
1:bce78c9:         // for TEST_TAB_2 to be dropped as well.
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_2");
1:29a19ff:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_2', null)");
1:bce78c9:         stats.assertNoStatsTable("TEST_TAB_2");
1:a6a0733:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
1:a6a0733:         //After DERBY-4115 is implemented, we will see no statistics 
1:a6a0733:         // for TEST_TAB_2 after calling SYSCS_DROP_STATISTICS on it.
1:a6a0733:         stats.assertNoStatsTable("TEST_TAB_2");
1:29a19ff:         s.execute("drop table TEST_TAB_2");
1:29a19ff:         s.execute("drop table TEST_TAB_1");
1:29a19ff:         stats.release();
1:29a19ff:     }
1:ae1478d: 
1:ae1478d:     /**
1:7e33399:      * Tests that the functionality that drops disposable statistics leaves
1:7e33399:      * useful statistics intact.
1:7e33399:      */
1:7e33399:     public void testDisposableStatsEagerness()
1:7e33399:             throws SQLException {
1:7e33399:         setAutoCommit(false);
1:7e33399:         String tbl = "DISPOSABLE_STATS_EAGERNESS";
1:7e33399:         String tbl_fk = tbl + "_FK";
1:7e33399:         String nuIdx = "NU_" + tbl;
1:7e33399:         Statement stmt = createStatement();
1:7e33399: 
1:7e33399:         // Create and populate the foreign key table.
1:7e33399:         stmt.executeUpdate("create table " + tbl_fk + "(" +
1:7e33399:                 "pk1 int generated always as identity)");
1:7e33399:         PreparedStatement ps = prepareStatement(
1:7e33399:                 "insert into " + tbl_fk + " values (DEFAULT)");
1:7e33399:         for (int i=1; i <= 1000; i++) {
1:7e33399:             ps.executeUpdate();
1:7e33399:         }
1:7e33399: 
1:7e33399:         // Create and populate the main table.
1:7e33399:         stmt.executeUpdate("create table " + tbl + "(" +
1:7e33399:                 "pk1 int generated always as identity," +
1:7e33399:                 "pk2 int not null," +
1:7e33399:                 "mynonunique int, " +
1:7e33399:                 "fk int not null)");
1:7e33399:         ps = prepareStatement("insert into " + tbl +
1:7e33399:                 " values (DEFAULT, ?, ?, ?)");
1:7e33399:         for (int i=1; i <= 1000; i++) {
1:7e33399:             ps.setInt(1, i);
1:7e33399:             ps.setInt(2, i % 35);
1:7e33399:             ps.setInt(3, i);
1:7e33399:             ps.executeUpdate();
1:7e33399:         }
1:7e33399:         
1:7e33399:         // Create the various indexes.
1:7e33399:         stmt.executeUpdate("alter table " + tbl_fk + " add constraint PK_" +
1:7e33399:                 tbl_fk + " primary key (pk1)");
1:7e33399:         
1:7e33399:         stmt.executeUpdate("alter table " + tbl + " add constraint PK_" + tbl +
1:7e33399:                 " primary key (pk1, pk2)");
1:7e33399:         stmt.executeUpdate("alter table " + tbl + " add constraint FK_" + tbl +
1:7e33399:                 " foreign key (fk) references " + tbl_fk + "(pk1)");
1:7e33399:         stmt.executeUpdate("create index " + nuIdx + " on " + tbl +
1:7e33399:                 "(mynonunique)");
1:7e33399:         commit();
1:7e33399:         setAutoCommit(true);
1:7e33399:         IndexStatsUtil stats = new IndexStatsUtil(getConnection());
1:bce78c9:         // Expected FK table: 0
1:7e33399:         // Expected main table: 2xPK, 1 non-unique, 1 FK = 4
1:bce78c9:         stats.assertNoStatsTable(tbl_fk);
1:7e33399:         stats.assertTableStats(tbl, 4);
1:7e33399:         IndexStatsUtil.IdxStats[] tbl_stats_0 = stats.getStatsTable(tbl);
1:7e33399: 
1:7e33399:         // Run the update statistics procedure.
1:afe4dfd:         // Sleep at least one tick to ensure the timestamps differ.
1:afe4dfd:         sleepAtLeastOneTick();
1:7e33399:         ps = prepareStatement(
1:7e33399:                 "call syscs_util.syscs_update_statistics('APP', ?, ?)");
1:7e33399:         ps.setNull(2, Types.VARCHAR);
1:7e33399:         ps.setString(1, tbl);
1:7e33399:         ps.execute();
1:7e33399:         ps.setString(1, tbl_fk);
1:7e33399:         ps.execute();
1:7e33399: 
1:7e33399:         // Check the counts.
1:bce78c9:         stats.assertNoStatsTable(tbl_fk);
1:7e33399:         stats.assertTableStats(tbl, 4);
1:7e33399:         // Check the timestamps (i.e. were they actually updated?).
1:7e33399:         IndexStatsUtil.IdxStats[] tbl_stats_1 = stats.getStatsTable(tbl);
1:7e33399:         assertEquals(tbl_stats_0.length, tbl_stats_1.length);
1:7e33399:         for (int i=0; i < tbl_stats_1.length; i++) {
1:7e33399:             assertTrue(tbl_stats_1[i].after(tbl_stats_0[i]));
1:7e33399:         }
1:7e33399: 
1:7e33399:         // Now make sure updating one index doesn't modify the others' stats.
1:afe4dfd:         sleepAtLeastOneTick();
1:7e33399:         ps.setString(1, tbl);
1:7e33399:         ps.setString(2, nuIdx);
1:7e33399:         ps.execute();
1:7e33399:         // Just use any of the previous stats as a reference point.
1:7e33399:         IndexStatsUtil.IdxStats nonUniqueIdx = stats.getStatsIndex(nuIdx)[0];
1:7e33399:         assertTrue(nonUniqueIdx.after(tbl_stats_1[0]));
1:7e33399:         // Check the counts again.
1:bce78c9:         stats.assertNoStatsTable(tbl_fk);
1:7e33399:         stats.assertTableStats(tbl, 4);
1:387174c: 
1:387174c:         // Cleanup
1:387174c:         dropTable(tbl);
1:387174c:         dropTable(tbl_fk);
1:7e33399:     }
1:7e33399: 
1:7e33399:     /**
1:ae1478d:      * A thread class that repeatedly calls SYSCS_UTIL.SYSCS_UPDATE_STATISTICS
1:ae1478d:      * until the flag {@code done} is set to true. Any exception thrown during
1:ae1478d:      * the lifetime of the thread can be found in the field {@code exception}.
1:ae1478d:      */
1:ae1478d:     private static class IndexUpdateThread extends Thread {
1:ae1478d:         private final CallableStatement updateStats;
1:ae1478d:         private volatile boolean done;
1:ae1478d:         private Exception exception;
1:ae1478d: 
1:ae1478d:         private IndexUpdateThread(
1:ae1478d:                 Connection c, String schema, String table, String index)
1:ae1478d:                 throws SQLException {
1:ae1478d:             updateStats = c.prepareCall(
1:ae1478d:                     "call syscs_util.syscs_update_statistics(?,?,?)");
1:ae1478d:             updateStats.setString(1, schema);
1:ae1478d:             updateStats.setString(2, table);
1:ae1478d:             updateStats.setString(3, index);
1:7e33399:         }
1:ae1478d: 
1:ae1478d:         public void run() {
1:7e33399:             try {
1:ae1478d:                 while (!done) {
1:ae1478d:                     updateStats.execute();
1:ae1478d:                 }
1:ae1478d:                 updateStats.close();
1:ae1478d:             } catch (Exception e) {
1:ae1478d:                 this.exception = e;
1:ae1478d:             }
1:ae1478d:         }
1:ae1478d:     }
1:ae1478d: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:f6e9c21
/////////////////////////////////////////////////////////////////////////
1:     //DERBY-5750(Sending an empty string as table name to compress table 
1:     // procedure or empty string as index name to update statistics procedure 
1:     // makes the parser throw an exception.)
1:     //
1:     //No table name will result in exception since Derby doesn't know table
1:     // whose statistics it needs to be update/drop
1:     public void testStatisticsProcsWithEmptyParamsDerby5750() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table DERBY5750_t1 (c11 int)");
1:         s.executeUpdate("CREATE INDEX DERBY5750_I1 ON DERBY5750_t1(c11)");
1:         //Following statements will give exceptions since there is no schema
1:         // named empty string
1:         assertStatementError(
1:                 "42Y07", s,
1:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:                 "'','DERBY5750_T1','DERBY5750_I1')");
1:         assertStatementError(
1:                 "42Y07", s,
1:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:                 "'','DERBY5750_T1','DERBY5750_I1')");
1:         assertStatementError(
1:                 "42Y07", s,
1:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:                 "'','','DERBY5750_I1')");
1:         assertStatementError(
1:                 "42Y07", s,
1:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:                 "'','','DERBY5750_I1')");
1: 
1:         //null schema name will translate to current schema
1:         s.execute("call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:                 "null,'DERBY5750_T1','DERBY5750_I1')");
1:         s.execute("call syscs_util.SYSCS_DROP_STATISTICS(" +
1:                 "null,'DERBY5750_T1','DERBY5750_I1')");
1:         
1:         //Following statements will give exceptions since there is no table  
1:         // named empty string
1:         assertStatementError(
1:                 "42X05", s,
1:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:                 "null,'','DERBY5750_I1')");
1:         assertStatementError(
1:                 "42X05", s,
1:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:                 "null,'','DERBY5750_I1')");
1:         assertStatementError(
1:                 "42X05", s,
1:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:                 "'APP','','DERBY5750_I1')");
1:         assertStatementError(
1:                 "42X05", s,
1:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:                 "'APP','','DERBY5750_I1')");
1: 
1:         //Following statements will give exceptions since table name can't 
1:         // be null
1:         assertStatementError(
1:                 "42X05", s,
1:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:                 "null,null,'DERBY5750_I1')");
1:         assertStatementError(
1:                 "42X05", s,
1:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:                 "null,null,'DERBY5750_I1')");
1:         assertStatementError(
1:                 "42X05", s,
1:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:                 "'APP',null,'DERBY5750_I1')");
1:         assertStatementError(
1:                 "42X05", s,
1:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:                 "'APP',null,'DERBY5750_I1')");
1: 
1:         //Provide all the 3 params, schema, table and index name
1:         s.execute("call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:                 "'APP','DERBY5750_T1','DERBY5750_I1')");
1:         s.execute("call syscs_util.SYSCS_DROP_STATISTICS("+
1:                 "'APP','DERBY5750_T1','DERBY5750_I1')");
1:         
1:         
1:         //Following statements will give exceptions since there is no index  
1:         // named empty string
1:         assertStatementError(
1:                 "42X65", s,
1:                 "call syscs_util.SYSCS_UPDATE_STATISTICS("+
1:                 "'APP','DERBY5750_T1','')");
1:         assertStatementError(
1:                 "42X65", s,
1:                 "call syscs_util.SYSCS_DROP_STATISTICS("+
1:                 "'APP','DERBY5750_T1','')");
1:         
1:         s.execute("drop table DERBY5750_t1");    	
1:     }
1: 
commit:a6a0733
/////////////////////////////////////////////////////////////////////////
1:  * Tests for dropping the statistics of one index or all the indexes on a
1:  * table DERBY-4115.
/////////////////////////////////////////////////////////////////////////
1:      * Test that parser can work with column and index named STATISTICS and
1:      *  does not get confused with non-reserved keyword STATISTICS used by
1:      *  UPDATE and DROP STATISTICS syntax generated internally for
1:      *  SYSCS_DROP_STATISTICS and SYSCS_UPDATE_STATISTICS
1:     public void testIndexAndColumnNamedStatistics() throws SQLException {
1: 
1:         //Notice the name of one of the columns is STATISTICS
1:         s.executeUpdate("CREATE TABLE t1 (c11 int, statistics int not null)");
1:         //Notice that the name of the index is STATISTICS which is same as 
1:         // one of the column names
1:         s.executeUpdate("CREATE INDEX statistIcs ON t1(c11)");
1:         s.executeUpdate("INSERT INTO t1 VALUES(1,1)");
0:         stats.assertNoStats();
1:         //Drop the column named STATISTICS and make sure parser doesn't
1:         // throw an error
1:         s.executeUpdate("ALTER TABLE t1 DROP statistics");
1:         //Should still be able to call update/drop statistics on index 
1:         // STATISTICS
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','STATISTICS')");
0:         stats.assertStats(1);
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','STATISTICS')");
0:         stats.assertNoStats();
1:         //Add the column named STATISTICS back
1:         s.executeUpdate("ALTER TABLE t1 ADD COLUMN statistics int");
0:         stats.assertNoStats();
1:         //Update or drop statistics for index named STATISTICS. Note that there
1:         // is also a column named STATISTICS in the table
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','STATISTICS')");
0:         stats.assertNoStats();
1:         s.executeUpdate("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','STATISTICS')");
0:         stats.assertStats(1);
1:         s.executeUpdate("DROP TABLE t1");
1:     }
1: 
1:     /**
1:      * Test for update statistics
1:      */
1:     public void testUpdateAndDropStatistics() throws SQLException {
1:         // Helper object to obtain information about index statistics.
1:         IndexStatsUtil stats = new IndexStatsUtil(openDefaultConnection());
1:         Statement s = createStatement();
1: 
1:         //Calls to update and drop statistics below should fail because 
1:         // table APP.T1 does not exist
1:         assertStatementError("42Y55", s, 
1:             "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1',null)");
1: 
1:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1',null)");
1:         
1:                 "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','I1')");
1:         assertStatementError("42X65", s, 
1:                 "CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I1')");
1:         
1:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','I1')");
/////////////////////////////////////////////////////////////////////////
1:         //Drop the statistics on index I2 and then add it back by calling 
1:         // update statistics
1:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','I2')");
1:         //Since we dropped the only statistics that existed for table T1, there
1:         // will no stats found at this point
0:         stats.assertNoStats();
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I2')");
1:         //The statistics for index I2 has been added back
0:         stats.assertStats(1);
1:         //Drop the statistics on index I1 and then add it back by calling 
1:         // update statistics
1:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1','I1')");
0:         stats.assertStats(1);
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I1')");
0:         stats.assertStats(2);
1:         //Drop all the statistics on table T1 and then recreate all the 
1:         // statisitcs back again
1:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T1',null)");
0:         stats.assertNoStats();
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1',null)");
0:         stats.assertStats(2);
1:         //Dropping the index should get rid of it's statistics
1:         s.executeUpdate("DROP INDEX I1");
0:         stats.assertStats(1);
1:         //calls to system procedure for update and drop statistics are
1:         // internally converted into ALTER TABLE ... sql but that generated
1:         // sql format is not available to end user to issue directly. Write a 
1:         // test case for these internal sql syntaxes
1:         assertStatementError("42X01", s, 
1:                 "ALTER TABLE APP.T1 ALL DROP STATISTICS");
1:         assertStatementError("42X01", s, 
1:                 "ALTER TABLE APP.T1 STATISTICS DROP I1");
1:         //Try update and drop statistics on global temporary table
1:         //following should fail because update/drop statistics can't be issued
1: 		// on global temporary tables
1:                 "CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('SESSION','T1',null)");
1:         assertStatementError("42995", s, 
1:                 "CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('SESSION','T1',null)");
/////////////////////////////////////////////////////////////////////////
1:         //efficient index which is T2I2.
1: 
1: 		//Drop statistics for T2I2 and we should see that we go back to using
1: 		// T2I1 rather than T2I2
1: 		s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','T2','T2I2')");
1:         stats.assertIndexStats("T2I2", 0);
1: 
1:         //Rerunning the query "SELECT * FROM t2 WHERE c21=? AND c22=?" and
1:         // looking at it's plan will show that this time it picked up T2I1
1:         // rather than more efficient index T2I2  because no stats exists
1:         // for T2I2
1:         JDBC.assertDrainResults(ps.executeQuery());
1: 		rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1: 		assertTrue(rtsp.usedSpecificIndexForIndexScan("T2","T2I1"));
1: 
/////////////////////////////////////////////////////////////////////////
0:         //DERBY-5702 Add a foreign key constraint and now we should find 2 rows
0:         // of statistics for TEST_TAB_2 - 1 for primary key and other for
1:         //DERBY-5702 Like primary key earlier, adding foreign key constraint
1:         // didn't automatically add a statistics row for it. Have to run update
/////////////////////////////////////////////////////////////////////////
1:         s.execute("CALL SYSCS_UTIL.SYSCS_DROP_STATISTICS('APP','TEST_TAB_2', null)");
1:         //After DERBY-4115 is implemented, we will see no statistics 
1:         // for TEST_TAB_2 after calling SYSCS_DROP_STATISTICS on it.
1:         stats.assertNoStatsTable("TEST_TAB_2");
commit:29a19ff
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Fixed DERBY-5681(When a foreign key constraint on a table is dropped,
1:      *  the associated statistics row for the conglomerate is not removed.)
1:      * @throws Exception
1:      */
1:     public void testDERBY5681() throws Exception {
1:         // Helper object to obtain information about index statistics.
1:         IndexStatsUtil stats = new IndexStatsUtil(openDefaultConnection());
1:         Statement s = createStatement();
1:     	
1:         //Test - primary key constraint
1:         s.executeUpdate("CREATE TABLE TEST_TAB_1 (c11 int not null,"+
1:                 "c12 int not null, c13 int)");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         //Insert data into table with no constraint and there will be no stat
1:         // for that table at this point
1:         s.executeUpdate("INSERT INTO TEST_TAB_1 VALUES(1,1,1),(2,2,2)");
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_1', null)");
1:         stats.assertNoStatsTable("TEST_TAB_1");
0:         //Add primary key constraint to the table and now we should find a 
0:         // statistics row for it
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:         		"PRIMARY KEY (c11)");
1:         stats.assertTableStats("TEST_TAB_1",1);
0:         //Dropping primary key constraint will drop the corresponding
0:         // statistics
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "DROP CONSTRAINT TEST_TAB_1_PK_1");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_1', null)");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         //Add the primary key constraint back since it will be used by the next
1:         // test to create foreign key constraint
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:         		"PRIMARY KEY (c11)");
0:         //The statistics for primary key constraint has been added
1:         stats.assertTableStats("TEST_TAB_1",1);
1: 
1:         //Test - unique key constraint
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "ADD CONSTRAINT TEST_TAB_1_UNQ_1 "+
1:         		"UNIQUE (c12)");
1:         stats.assertTableStats("TEST_TAB_1",2);
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "DROP CONSTRAINT TEST_TAB_1_UNQ_1");
1:         stats.assertTableStats("TEST_TAB_1",1);
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "DROP CONSTRAINT TEST_TAB_1_PK_1");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:         		"PRIMARY KEY (c11)");
1:         stats.assertTableStats("TEST_TAB_1",1);
1: 
1:         //Test - unique key constraint on nullable column & non-nullable column
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "ADD CONSTRAINT TEST_TAB_1_UNQ_2 "+
1:         		"UNIQUE (c12, c13)");
0:         stats.assertTableStats("TEST_TAB_1",3);
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "DROP CONSTRAINT TEST_TAB_1_UNQ_2");
1:         stats.assertTableStats("TEST_TAB_1",1);
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "DROP CONSTRAINT TEST_TAB_1_PK_1");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:         		"PRIMARY KEY (c11)");
1:         stats.assertTableStats("TEST_TAB_1",1);
1:         
1:         //Test - foreign key but no primary key constraint
1:         s.executeUpdate("CREATE TABLE TEST_TAB_3 (c31 int not null)");
1:         s.executeUpdate("INSERT INTO TEST_TAB_3 VALUES(1),(2)");
1:         s.executeUpdate("ALTER TABLE TEST_TAB_3 "+
1:                 "ADD CONSTRAINT TEST_TAB_3_FK_1 "+
1:         		"FOREIGN KEY(c31) REFERENCES TEST_TAB_1(c11)");
1:         stats.assertTableStats("TEST_TAB_3",1);
1:         s.executeUpdate("ALTER TABLE TEST_TAB_3 "+
1:                 "DROP CONSTRAINT TEST_TAB_3_FK_1");
1:         stats.assertNoStatsTable("TEST_TAB_3");
1: 
1:         //Test - foreign key and primary key constraint
1:         s.executeUpdate("CREATE TABLE TEST_TAB_2 (c21 int not null)");
1:         s.executeUpdate("INSERT INTO TEST_TAB_2 VALUES(1),(2)");
1:         s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:                 "ADD CONSTRAINT TEST_TAB_2_PK_1 "+
1:         		"PRIMARY KEY (c21)");
1:         stats.assertTableStats("TEST_TAB_2",1);
0:         //Add a foreign key constraint and now we should find 2 rows of 
0:         // statistics for TEST_TAB_2 - 1 for primary key and other for
0:         // foreign key constraint
1:         s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:                 "ADD CONSTRAINT TEST_TAB_2_FK_1 "+
1:         		"FOREIGN KEY(c21) REFERENCES TEST_TAB_1(c11)");
0:         //Like primary key earlier, adding foreign key constraint didn't
0:         // automatically add a statistics row for it. Have to run update
1:         // statistics manually to get a row added for it's stat
1:         stats.assertTableStats("TEST_TAB_2",1);
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_2', null)");
0:         stats.assertTableStats("TEST_TAB_2",2);
1:         //Number of statistics row for TEST_TAB_1 will remain unchanged since
1:         // it has only primary key defined on it
1:         stats.assertTableStats("TEST_TAB_1",1);
1:         s.executeUpdate("ALTER TABLE TEST_TAB_2 "+
1:                 "DROP CONSTRAINT TEST_TAB_2_FK_1");
0:         //Dropping the foreign key constraint should remove one of the 
0:         // statistics row for TEST_TAB_2. 
1:         stats.assertTableStats("TEST_TAB_2",1);
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','TEST_TAB_2', null)");
1:         stats.assertTableStats("TEST_TAB_2",1);
1:         s.execute("drop table TEST_TAB_2");
1:         s.execute("drop table TEST_TAB_1");
1:         stats.release();
1:     }
commit:c2b03c4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.RuntimeStatisticsParser;
1: import org.apache.derbyTesting.junit.SQLUtilities;
1:  * table DERBY-269, DERBY-3788.
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("CREATE TABLE t1 (c11 int, c12 varchar(128))");
1:         s.executeUpdate("CREATE INDEX i1 on t1(c12)");
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("CREATE INDEX i2 ON t1(c11)");
/////////////////////////////////////////////////////////////////////////
1:         //cleanup
1:         s.executeUpdate("DROP TABLE t1");
/////////////////////////////////////////////////////////////////////////
1:         
1:         //Following test will show that updating the statistics will make a
1:         //query pickup better index compare to prior to statistics availability.
1:         //
1:         //Check statistics update causes most efficient index usage
1:         //Create a table with 2 non-unique indexes on 2 different columns.
1:         //The indexes are created when the table is still empty and hence
1:         //there are no statistics available for them in sys.sysstatistics.
1:         //The table looks as follows
1:         //        create table t2(c21 int, c22 char(14), c23 char(200))
1:         //        create index t2i1 on t2(c21)
1:         //        create index t2i2 on t2(c22)
1:         //Load the data into the table and running following query will
1:         //pickup index t2i1 on column c21
1:         //        select * from t2 where c21=? and c22=?
1:         //But once you make the statistics available for t2i2, the query
1:         //will pickup index t2i2 on column c22 for the query above
1:         //
1:         //Start of test case for better index selection after statistics
1:         //availability
1:         s.executeUpdate("CREATE TABLE t2(c21 int, c22 char(14), c23 char(200))");
1:         //No statistics will be created for the 2 indexes because the table is 
1:         //empty
1:         s.executeUpdate("CREATE INDEX t2i1 ON t2(c21)");
1:         s.executeUpdate("CREATE INDEX t2i2 ON t2(c22)");
0:         rs = s.executeQuery("SELECT * FROM SYS.SYSSTATISTICS");
0:         JDBC.assertEmpty(rs);
1:         
1:         PreparedStatement ps = prepareStatement("INSERT INTO T2 VALUES(?,?,?)");
1:         for (int i=0; i<1000; i++) {
1:         	ps.setInt(1, i%2);
1:             ps.setString(2, "Tuple " +i);
1:             ps.setString(3, "any value");
1:             ps.addBatch();
1:         }
1:         ps.executeBatch();
1: 
1: 		s.execute("call SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1: 		
1: 		//Executing the query below and looking at it's plan will show that
1: 		//we picked index T2I1 rather than T2I2 because there are no 
1: 		//statistics available for T2I2 to show that it is a better index
1: 		ps = prepareStatement("SELECT * FROM t2 WHERE c21=? AND c22=?");
1:     	ps.setInt(1, 0);
1:         ps.setString(2, "Tuple 4");
1:         JDBC.assertDrainResults(ps.executeQuery());
1: 		RuntimeStatisticsParser rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1: 		assertTrue(rtsp.usedSpecificIndexForIndexScan("T2","T2I1"));
1: 
1: 		//Running the update statistics below will create statistics for T2I2
1: 		s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T2','T2I2')");
0:         rs = s.executeQuery("SELECT * FROM SYS.SYSSTATISTICS");
0:         JDBC.assertDrainResults(rs, 1);
1: 		
1:         //Rerunning the query "SELECT * FROM t2 WHERE c21=? AND c22=?" and
1:         //looking at it's plan will show that this time it picked up more
0:         //efficient index which is T2I2. 
1:         JDBC.assertDrainResults(ps.executeQuery());
1: 		rtsp = SQLUtilities.getRuntimeStatisticsParser(s);
1: 		assertTrue(rtsp.usedSpecificIndexForIndexScan("T2","T2I2"));
1:         //cleanup
1:         s.executeUpdate("DROP TABLE t2");
1:         //End of test case for better index selection after statistics
1:         //availability
commit:963d9f4
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Class org.apache.derbyTesting.functionTests.tests.lang.UpdateStatisticsTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.ResultSet;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Tests for updating the statistics of one index or all the indexes on a
0:  * table DERBY-269.
1:  */
1: public class UpdateStatisticsTest extends BaseJDBCTestCase {
1: 
1:     public UpdateStatisticsTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         return TestConfiguration.defaultSuite(UpdateStatisticsTest.class);
1:     }
1: 
1:     /**
0:      * Test for update statistics
1:      */
0:     public void testUpdateStatistics() throws SQLException {
1:         Statement s = createStatement();
0:         //following should fail because table APP.T1 does not exist
1:         assertStatementError("42Y55", s, 
1:             "CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1',null)");
0:         s.execute("CREATE TABLE t1 (c11 int, c12 varchar(128))");
1:         //following will pass now because we have created APP.T1
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1',null)");
1:         //following should fail because index I1 does not exist on table APP.T1
1:         assertStatementError("42X65", s, 
0:             "CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I1')");
0:         s.execute("CREATE INDEX i1 on t1(c12)");
1:         //following will pass now because we have created index I1 on APP.T1
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I1')");
1: 
1:         //The following set of subtest will ensure that when an index is
1:         //created on a table when there is no data in the table, then Derby
1:         //will not generate a row for it in sysstatistics table. If the index
1:         //is created after the table has data on it, there will be a row for
1:         //it in sysstatistics table. In order to generate statistics for the
1:         //first index, users can run the stored procedure 
1:         //SYSCS_UPDATE_STATISTICS
1:         //So far the table t1 is empty and we have already created index I1 on 
1:         //it. Since three was no data in the table when index I1 was created,
1:         //there will be no row in sysstatistics table
0:         ResultSet rs = s.executeQuery("SELECT * FROM SYS.SYSSTATISTICS");
0:         JDBC.assertEmpty(rs);
1:         //Now insert some data into t1 and then create a new index on the 
1:         //table. This will cause sysstatistics table to have one row for this
1:         //new index. Old index will still not have a row for it in
1:         //sysstatistics table
1:         s.executeUpdate("INSERT INTO T1 VALUES(1,'a'),(2,'b'),(3,'c'),(4,'d')");
0:         s.execute("CREATE INDEX i2 on t1(c11)");
0:         rs = s.executeQuery("SELECT * FROM SYS.SYSSTATISTICS");
0:         JDBC.assertDrainResults(rs, 1);
1:         //Now update the statistics for the old index I1 using the new stored
1:         //procedure. Doing this should add a row for it in sysstatistics table
1:         s.execute("CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('APP','T1','I1')");
0:         rs = s.executeQuery("SELECT * FROM SYS.SYSSTATISTICS");
0:         JDBC.assertDrainResults(rs, 2);
1: 
0:         //calls to system procedure for update statisitcs is internally
0:         //converted into ALTER TABLE ... sql but that generated sql format
0:         //is not available to end user to issue directly. Write a test case
0:         //for that sql syntax
1:         assertStatementError("42X01", s, 
1:             "ALTER TABLE APP.T1 ALL UPDATE STATISTICS");
1:         assertStatementError("42X01", s, 
1:             "ALTER TABLE APP.T1 UPDATE STATISTICS I1");
1: 
0:         //Try update statistics on global temporary table
1: 		s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit delete rows not logged");
1: 		s.executeUpdate("insert into session.t1 values(11, 1)");
0:         //following should fail because update statistics can't be issued on
0: 		//global temporary tables
1:         assertStatementError("42995", s, 
0:             "CALL SYSCS_UTIL.SYSCS_UPDATE_STATISTICS('SESSION','T1',null)");
1:     }
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:afe4dfd
/////////////////////////////////////////////////////////////////////////
1:         // Sleep at least one tick to ensure the timestamps differ.
1:         sleepAtLeastOneTick();
/////////////////////////////////////////////////////////////////////////
1:         sleepAtLeastOneTick();
commit:bce78c9
/////////////////////////////////////////////////////////////////////////
1:         // Add primary key constraint to the table. With DERBY-3790 this won't
1:         // create a statistics entry, since the key consist of single column.
1:         stats.assertNoStatsTable("TEST_TAB_1");
/////////////////////////////////////////////////////////////////////////
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1: 
1:         //Test - non-unique index
1:         s.executeUpdate("CREATE INDEX TEST_TAB_1_NUNQ_1 ON TEST_TAB_1(c12)");
1:         s.executeUpdate("DROP INDEX TEST_TAB_1_NUNQ_1");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "DROP CONSTRAINT TEST_TAB_1_PK_1");
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         s.executeUpdate("ALTER TABLE TEST_TAB_1 "+
1:                 "ADD CONSTRAINT TEST_TAB_1_PK_1 "+
1:         		"PRIMARY KEY (c11)");
1:         stats.assertNoStatsTable("TEST_TAB_1");
0:         stats.assertTableStats("TEST_TAB_1",2);
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         stats.assertNoStatsTable("TEST_TAB_1");
/////////////////////////////////////////////////////////////////////////
1:         stats.assertNoStatsTable("TEST_TAB_2");
1:         // DERBY-5702 Add a foreign key constraint and now we should find one
1:         // row of statistics for TEST_TAB_2 (for the foreign key constraint).
1:         stats.assertNoStatsTable("TEST_TAB_2");
0:         stats.assertTableStats("TEST_TAB_2",1);
1:         stats.assertNoStatsTable("TEST_TAB_1");
1:         //Dropping the foreign key constraint should cause the statistics row
1:         // for TEST_TAB_2 to be dropped as well.
1:         stats.assertNoStatsTable("TEST_TAB_2");
1:         stats.assertNoStatsTable("TEST_TAB_2");
/////////////////////////////////////////////////////////////////////////
1:         // Expected FK table: 0
1:         stats.assertNoStatsTable(tbl_fk);
/////////////////////////////////////////////////////////////////////////
1:         stats.assertNoStatsTable(tbl_fk);
/////////////////////////////////////////////////////////////////////////
1:         stats.assertNoStatsTable(tbl_fk);
commit:387174c
/////////////////////////////////////////////////////////////////////////
1:         String tbl1 = "T1";
/////////////////////////////////////////////////////////////////////////
1:         stats.assertNoStatsTable(tbl1);
1:         stats.assertTableStats(tbl1, 1);
1:         stats.assertNoStatsTable(tbl1);
1:         stats.assertTableStats(tbl1, 1);
1:         stats.assertTableStats(tbl1, 2);
1:         stats.assertTableStats(tbl1, 1);
1:         stats.assertTableStats(tbl1, 2);
1:         stats.assertNoStatsTable(tbl1);
1:         stats.assertTableStats(tbl1, 2);
1:         stats.assertTableStats(tbl1, 1);
/////////////////////////////////////////////////////////////////////////
1:         stats.assertNoStatsTable("T2");
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Cleanup
1:         dropTable(tbl);
1:         dropTable(tbl_fk);
commit:b0e73bc
/////////////////////////////////////////////////////////////////////////
1:         String tbl = "T1";
1:         // Get the initial count of statistics in the database.
1:         int initialStatsCount = stats.getStats().length;
1: 
1:         stats.assertNoStatsTable(tbl);
1:         stats.assertTableStats(tbl, 1);
1:         stats.assertNoStatsTable(tbl);
1:         stats.assertNoStatsTable(tbl);
1:         stats.assertNoStatsTable(tbl);
1:         stats.assertTableStats(tbl, 1);
1: 
1:         // Check that we haven't created some other statistics as a side-effect.
1:         assertEquals(initialStatsCount, stats.getStats().length);
/////////////////////////////////////////////////////////////////////////
1:         dropTable("T1");
commit:7e33399
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * Tests that the functionality that drops disposable statistics leaves
1:      * useful statistics intact.
1:      */
1:     public void testDisposableStatsEagerness()
1:             throws SQLException {
1:         setAutoCommit(false);
1:         String tbl = "DISPOSABLE_STATS_EAGERNESS";
1:         String tbl_fk = tbl + "_FK";
1:         String nuIdx = "NU_" + tbl;
1:         Statement stmt = createStatement();
1: 
1:         // Create and populate the foreign key table.
1:         stmt.executeUpdate("create table " + tbl_fk + "(" +
1:                 "pk1 int generated always as identity)");
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into " + tbl_fk + " values (DEFAULT)");
1:         for (int i=1; i <= 1000; i++) {
1:             ps.executeUpdate();
1:         }
1: 
1:         // Create and populate the main table.
1:         stmt.executeUpdate("create table " + tbl + "(" +
1:                 "pk1 int generated always as identity," +
1:                 "pk2 int not null," +
1:                 "mynonunique int, " +
1:                 "fk int not null)");
1:         ps = prepareStatement("insert into " + tbl +
1:                 " values (DEFAULT, ?, ?, ?)");
1:         for (int i=1; i <= 1000; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, i % 35);
1:             ps.setInt(3, i);
1:             ps.executeUpdate();
1:         }
1:         
1:         // Create the various indexes.
1:         stmt.executeUpdate("alter table " + tbl_fk + " add constraint PK_" +
1:                 tbl_fk + " primary key (pk1)");
1:         
1:         stmt.executeUpdate("alter table " + tbl + " add constraint PK_" + tbl +
1:                 " primary key (pk1, pk2)");
1:         stmt.executeUpdate("alter table " + tbl + " add constraint FK_" + tbl +
1:                 " foreign key (fk) references " + tbl_fk + "(pk1)");
1:         stmt.executeUpdate("create index " + nuIdx + " on " + tbl +
1:                 "(mynonunique)");
1:         commit();
1:         setAutoCommit(true);
1:         IndexStatsUtil stats = new IndexStatsUtil(getConnection());
0:         // Expected FK table: 1 (PK only)
1:         // Expected main table: 2xPK, 1 non-unique, 1 FK = 4
0:         stats.assertTableStats(tbl_fk, 1);
0:         IndexStatsUtil.IdxStats tbl_fk_pk_0 = stats.getStatsTable(tbl_fk)[0];
1:         stats.assertTableStats(tbl, 4);
1:         IndexStatsUtil.IdxStats[] tbl_stats_0 = stats.getStatsTable(tbl);
0:         // Avoid timestamp comparison problems on super-fast machines...
1:         try {
0:             Thread.sleep(10);
0:         } catch (InterruptedException ie) {
0:             Thread.currentThread().interrupt();
1:         }
1: 
1:         // Run the update statistics procedure.
1:         ps = prepareStatement(
1:                 "call syscs_util.syscs_update_statistics('APP', ?, ?)");
1:         ps.setNull(2, Types.VARCHAR);
1:         ps.setString(1, tbl);
1:         ps.execute();
1:         ps.setString(1, tbl_fk);
1:         ps.execute();
1: 
1:         // Check the counts.
0:         stats.assertTableStats(tbl_fk, 1);
1:         stats.assertTableStats(tbl, 4);
1:         // Check the timestamps (i.e. were they actually updated?).
0:         IndexStatsUtil.IdxStats tbl_fk_pk_1 = stats.getStatsTable(tbl_fk)[0];
0:         assertTrue(tbl_fk_pk_1.after(tbl_fk_pk_0));
1:         IndexStatsUtil.IdxStats[] tbl_stats_1 = stats.getStatsTable(tbl);
1:         assertEquals(tbl_stats_0.length, tbl_stats_1.length);
1:         for (int i=0; i < tbl_stats_1.length; i++) {
1:             assertTrue(tbl_stats_1[i].after(tbl_stats_0[i]));
1:         }
1: 
1:         // Now make sure updating one index doesn't modify the others' stats.
1:         ps.setString(1, tbl);
1:         ps.setString(2, nuIdx);
1:         ps.execute();
1:         // Just use any of the previous stats as a reference point.
1:         IndexStatsUtil.IdxStats nonUniqueIdx = stats.getStatsIndex(nuIdx)[0];
1:         assertTrue(nonUniqueIdx.after(tbl_stats_1[0]));
1:         // Check the counts again.
0:         stats.assertTableStats(tbl_fk, 1);
1:         stats.assertTableStats(tbl, 4);
1:     }
1: 
1:     /**
commit:aaa66cf
/////////////////////////////////////////////////////////////////////////
commit:a525856
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.IndexStatsUtil;
/////////////////////////////////////////////////////////////////////////
0:         // TODO: Disable automatic index statistics generation when the feature
0:         //       is added. As currently planned, the generation will be
1:         //       triggered when preparing a statement and this will interfere
1:         //       with some of the asserts in testUpdateStatistics.
1:         //       With automatic generation enabled, testUpdateStatistics may
0:         //       fail intermittently due to timing, mostly (only?) when run
1:         //       with the client driver.
/////////////////////////////////////////////////////////////////////////
1:         // Helper object to obtain information about index statistics.
1:         IndexStatsUtil stats = new IndexStatsUtil(openDefaultConnection());
/////////////////////////////////////////////////////////////////////////
0:         stats.assertNoStats();
0:         stats.assertStats(1);
0:         stats.assertStats(2);
0:         //calls to system procedure for update statistics is internally
/////////////////////////////////////////////////////////////////////////
0:         stats.assertNoStats();
/////////////////////////////////////////////////////////////////////////
1:         stats.assertIndexStats("T2I2", 1);
1: 
/////////////////////////////////////////////////////////////////////////
1:         stats.release();
0:      * <p>
0:      * TODO: Make sure this test is also run with automatic index statistics
0:      * generation enabled, as it revealed a bug in the data dictionary access
0:      * pattern (dd was left in write mode when it shouldn't have been).
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:00783b8
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Clean-up
1:         dropTable("derby5153");
1:         commit();
commit:a899bbc
/////////////////////////////////////////////////////////////////////////
1:     public void testParallelCompilationAndUpdate() throws Exception {
commit:ae1478d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
0: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Regression test case for DERBY-5153. Compilation in parallel with
1:      * update of statistics sometimes failed on debug builds.
0:      *
0:      * The test case should be disabled until the bug is fixed.
1:      */
0:     public void disabled_testParallelCompilationAndUpdate() throws Exception {
1:         setAutoCommit(false);
1: 
1:         // Create and populate a test table with a multi-column index.
1:         Statement s = createStatement();
1:         s.execute("create table derby5153(a int, b int, c int, d int)");
1:         s.execute("create index idx on derby5153(a,b,c,d)");
1: 
1:         PreparedStatement ins =
1:                 prepareStatement("insert into derby5153 values (1,2,3,4)");
1:         for (int i = 0; i < 100; i++) {
1:             ins.execute();
1:         }
1: 
1:         commit();
1: 
1:         // Start a thread that repeatedly updates the statistics for IDX.
1:         Connection updateConn = openDefaultConnection();
1:         IndexUpdateThread t =
1:                 new IndexUpdateThread(updateConn, "APP", "DERBY5153", "IDX");
1:         t.start();
1: 
1:         try {
1: 
1:             // Compile/execute the query a number of times while the index
1:             // statistics are being updated. This often failed with an assert
1:             // failure in debug builds before DERBY-5153.
1:             for (int i = 0; i < 100; i++) {
1:                 ResultSet rs = s.executeQuery(
1:                         "select * from derby5153 t1, derby5153 t2 " +
1:                         "where t1.a = t2.a");
1:                 rs.close();
1:             }
1: 
1:         } finally {
1: 
1:             // Let the update thread know we're done.
1:             t.done = true;
1: 
1:         }
1: 
1:         t.join();
1: 
1:         // Check if the update thread failed, and report if it did.
1:         if (t.exception != null) {
1:             throw t.exception;
1:         }
1: 
1:         updateConn.close();
1:     }
1: 
1:     /**
1:      * A thread class that repeatedly calls SYSCS_UTIL.SYSCS_UPDATE_STATISTICS
1:      * until the flag {@code done} is set to true. Any exception thrown during
1:      * the lifetime of the thread can be found in the field {@code exception}.
1:      */
1:     private static class IndexUpdateThread extends Thread {
1:         private final CallableStatement updateStats;
1:         private volatile boolean done;
1:         private Exception exception;
1: 
1:         private IndexUpdateThread(
1:                 Connection c, String schema, String table, String index)
1:                 throws SQLException {
1:             updateStats = c.prepareCall(
1:                     "call syscs_util.syscs_update_statistics(?,?,?)");
1:             updateStats.setString(1, schema);
1:             updateStats.setString(2, table);
1:             updateStats.setString(3, index);
1:         }
1: 
1:         public void run() {
1:             try {
1:                 while (!done) {
1:                     updateStats.execute();
1:                 }
1:                 updateStats.close();
1:             } catch (Exception e) {
1:                 this.exception = e;
1:             }
1:         }
1:     }
commit:beaa0a4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that SYSCS_UPDATE_STATISTICS doesn't obtain exclusive locks on
1:      * the table or rows in the table (DERBY-4274).
1:      */
1:     public void testNoExclusiveLockOnTable() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table t (x char(1))");
1:         s.execute("create index ti on t(x)");
1:         s.execute("insert into t values 'a','b','c','d'");
1: 
1:         setAutoCommit(false);
1:         s.execute("lock table t in share mode");
1: 
1:         Connection c2 = openDefaultConnection();
1:         Statement s2 = c2.createStatement();
1:         // This call used to time out because SYSCS_UPDATE_STATISTICS tried
1:         // to lock T exclusively.
1:         s2.execute("call syscs_util.syscs_update_statistics('APP', 'T', null)");
1:         s2.close();
1:         c2.close();
1: 
1:         s.execute("drop table t");
1:         commit();
0:     }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:c287c8c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         //       Disable automatic index statistics generation. The generation will be
1:         //       fail intermittently due to timing, mostly when run
1:         Test test = TestConfiguration.defaultSuite(UpdateStatisticsTest.class);
1:         Test statsDisabled = DatabasePropertyTestSetup.singleProperty
1:             ( test, "derby.storage.indexStats.auto", "false", true );
0: 
1:         return statsDisabled;
============================================================================