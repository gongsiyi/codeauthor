1:80eb35f: /*
2:80eb35f: 
1:80eb35f:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.SequenceTest
1:80eb35f: 
1:80eb35f:    Licensed to the Apache Software Foundation (ASF) under one or more
1:80eb35f:    contributor license agreements.  See the NOTICE file distributed with
1:80eb35f:    this work for additional information regarding copyright ownership.
1:80eb35f:    The ASF licenses this file to You under the Apache License, Version 2.0
1:80eb35f:    (the "License"); you may not use this file except in compliance with
1:80eb35f:    the License.  You may obtain a copy of the License at
1:80eb35f: 
1:80eb35f:       http://www.apache.org/licenses/LICENSE-2.0
1:80eb35f: 
1:80eb35f:    Unless required by applicable law or agreed to in writing, software
1:80eb35f:    distributed under the License is distributed on an "AS IS" BASIS,
1:80eb35f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:80eb35f:    See the License for the specific language governing permissions and
1:80eb35f:    limitations under the License.
1:80eb35f: 
1:80eb35f:  */
1:80eb35f: package org.apache.derbyTesting.functionTests.tests.lang;
1:80eb35f: 
1:80eb35f: import java.sql.Connection;
1:7953b49: import java.sql.DriverManager;
1:3b77ab8: import java.sql.PreparedStatement;
1:3b77ab8: import java.sql.ResultSet;
1:80eb35f: import java.sql.SQLException;
1:80eb35f: import java.sql.Statement;
1:80eb35f: import junit.framework.Test;
1:1ae02c9: import org.apache.derby.iapi.reference.SQLState;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:80eb35f: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:80eb35f: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:80eb35f: import org.apache.derbyTesting.junit.JDBC;
1:80eb35f: import org.apache.derbyTesting.junit.TestConfiguration;
1:80eb35f: 
1:80eb35f: /**
1:80eb35f:  * Test sequences.
1:80eb35f:  */
1:bb21983: public class SequenceTest extends GeneratedColumnsHelper {
1:80eb35f: 
1:80eb35f:     private static final String TEST_DBO = "TEST_DBO";
1:80eb35f:     private static final String ALPHA = "ALPHA";
1:80eb35f:     private static final String BETA = "BETA";
1:80eb35f:     private static final String[] LEGAL_USERS = {TEST_DBO, ALPHA, BETA};
1:80eb35f: 
1:7953b49:     private static  final   String  TOO_MANY_UNUSED_SEQUENCES = "X0Y93";
1:7953b49: 
1:80eb35f:     public SequenceTest(String name) {
1:80eb35f:         super(name);
1:80eb35f:         // TODO Auto-generated constructor stub
1:80eb35f:     }
1:80eb35f: 
1:80eb35f:     // SETUP
1:80eb35f: 
1:30dd4c5:     /**
1:80eb35f:      * Construct top level suite in this JUnit test
1:80eb35f:      */
1:80eb35f:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite(SequenceTest.class, "Sequence Test");
1:1ae02c9: 
1:80eb35f:         // Need atleast JSR169 to run these tests
1:80eb35f:         if (!JDBC.vmSupportsJSR169() && !JDBC.vmSupportsJDBC3()) {
1:80eb35f:             return suite;
1:80eb35f:         }
1:80eb35f: 
1:80eb35f:         Test cleanTest = new CleanDatabaseTestSetup(suite);
1:80eb35f:         Test authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
1:80eb35f:                 (cleanTest, LEGAL_USERS, "sequence");
1:80eb35f:         Test authorizedTest = TestConfiguration.sqlAuthorizationDecorator(authenticatedTest);
1:80eb35f: 
1:80eb35f:         return authorizedTest;
1:80eb35f:     }
1:80eb35f: 
1:139ca85:     public void test_01_CreateSequence() throws SQLException {
2:80eb35f:         Statement s = createStatement();
1:80eb35f:         s.executeUpdate("CREATE SEQUENCE mySeq");
1:80eb35f:     }
1:80eb35f: 
1:139ca85:     public void test_02_DropSequence() throws SQLException {
1:80eb35f:         Statement s = createStatement();
1:80eb35f:         s.executeUpdate("CREATE SEQUENCE mySeq1");
1:2f4a1a0:         s.executeUpdate("DROP SEQUENCE mySeq1 restrict");
1:80eb35f:     }
1:80eb35f: 
1:139ca85:     public void test_03_DuplicateCreationFailure() throws SQLException {
1:c4caf0a:         Statement s = null;
1:80eb35f:         try {
1:c4caf0a:             s = createStatement();
1:80eb35f:             s.executeUpdate("CREATE SEQUENCE mySeq1");
1:80eb35f:             s.executeUpdate("CREATE SEQUENCE mySeq1");
1:80eb35f:         } catch (SQLException sqle) {
1:80eb35f:             assertSQLState("X0Y68", sqle);
1:c4caf0a:         }finally{
1:2f4a1a0:             s.executeUpdate("DROP SEQUENCE mySeq1 restrict"); // Drop the one created.
1:80eb35f:         }
1:80eb35f:     }
1:80eb35f: 
1:139ca85:     public void test_04_ImplicitSchemaCreation() throws SQLException {
1:80eb35f:         Connection adminCon = openUserConnection(TEST_DBO);
1:80eb35f: 
1:80eb35f:         Connection alphaCon = openUserConnection(ALPHA);
1:80eb35f:         Statement stmt = alphaCon.createStatement();
1:80eb35f: 
1:80eb35f:         // should implicitly create schema ALPHA
1:80eb35f:         stmt.executeUpdate("CREATE SEQUENCE alpha_seq");
1:2f4a1a0:         stmt.executeUpdate("DROP SEQUENCE alpha_seq restrict");
1:80eb35f:         stmt.close();
1:80eb35f:         alphaCon.close();
1:80eb35f:         adminCon.close();
1:80eb35f:     }
1:bb21983: 
1:139ca85:     public void test_05CreateWithSchemaSpecified() throws SQLException {
1:bb21983: 
1:80eb35f:         // create DB
1:bb21983:         Connection alphaCon = openUserConnection(ALPHA);
1:80eb35f:         Statement stmt = alphaCon.createStatement();
1:80eb35f: 
1:80eb35f:         // should implicitly create schema ALPHA
1:80eb35f:         stmt.executeUpdate("CREATE SEQUENCE alpha.alpha_seq");
1:2f4a1a0:         stmt.executeUpdate("DROP SEQUENCE alpha.alpha_seq restrict");
1:80eb35f:         stmt.close();
1:80eb35f:         alphaCon.close();
1:80eb35f:     }
1:80eb35f: 
1:139ca85:     public void test_06_CreateWithSchemaSpecifiedCreateTrue() throws SQLException {
1:80eb35f:         Connection alphaCon = openUserConnection(ALPHA);
1:80eb35f:         Statement stmt = alphaCon.createStatement();
1:80eb35f: 
1:80eb35f:         // should implicitly create schema ALPHA
1:80eb35f:         stmt.executeUpdate("CREATE SEQUENCE alpha.alpha_seq");
1:2f4a1a0:         stmt.executeUpdate("DROP SEQUENCE alpha.alpha_seq restrict");
1:80eb35f:         stmt.close();
1:80eb35f:         alphaCon.close();
1:80eb35f:     }
1:80eb35f: 
1:139ca85:     public void test_07_CreateWithSchemaDropWithNoSchema() throws SQLException {
1:80eb35f:         Connection alphaCon = openUserConnection(ALPHA);
1:80eb35f:         Statement stmt = alphaCon.createStatement();
1:80eb35f: 
1:80eb35f:         // should implicitly create schema ALPHA
1:80eb35f:         stmt.executeUpdate("CREATE SEQUENCE alpha.alpha_seq");
1:2f4a1a0:         stmt.executeUpdate("DROP SEQUENCE alpha_seq restrict");
1:80eb35f:         stmt.close();
1:80eb35f:         alphaCon.close();
1:80eb35f:     }
1:80eb35f: 
1:3b77ab8:     /**
1:80eb35f:      * Test trying to drop a sequence in a schema that doesn't belong to one
1:80eb35f:      */
1:139ca85:     public void test_08_DropOtherSchemaSequence() throws SQLException {
1:80eb35f:         Connection adminCon = openUserConnection(TEST_DBO);
1:80eb35f: 
1:80eb35f:         Connection alphaCon = openUserConnection(ALPHA);
1:80eb35f:         Statement stmtAlpha = alphaCon.createStatement();
1:80eb35f:         stmtAlpha.executeUpdate("CREATE SEQUENCE alpha_seq");
1:80eb35f: 
1:80eb35f:         Connection betaCon = openUserConnection(BETA);
1:80eb35f:         Statement stmtBeta = betaCon.createStatement();
1:80eb35f: 
1:80eb35f:         // should implicitly create schema ALPHA
1:2f4a1a0:         assertStatementError("42507", stmtBeta, "DROP SEQUENCE alpha.alpha_seq restrict");
1:80eb35f: 
1:c4caf0a:         // Cleanup:
1:2f4a1a0:         stmtAlpha.executeUpdate("DROP SEQUENCE alpha_seq restrict");
1:80eb35f:         
1:80eb35f:         stmtAlpha.close();
1:80eb35f:         stmtBeta.close();
1:80eb35f:         alphaCon.close();
1:80eb35f:         betaCon.close();
1:80eb35f:         adminCon.close();
1:80eb35f:     }
1:80eb35f: 
1:4bea40e:     /**
1:80eb35f:      * Test trying to create a sequence in a schema that doesn't belong to one
1:80eb35f:      */
1:139ca85:     public void test_09_CreateOtherSchemaSequence() throws SQLException {
1:80eb35f:         // create DB
1:80eb35f:         Connection adminCon = openUserConnection(TEST_DBO);
1:80eb35f: 
1:80eb35f:         Connection alphaCon = openUserConnection(ALPHA);
1:80eb35f:         Statement stmtAlpha = alphaCon.createStatement();
1:c4caf0a:         stmtAlpha.executeUpdate("CREATE SEQUENCE alpha_seq");
1:80eb35f: 
1:80eb35f:         Connection betaCon = openUserConnection(BETA);
1:80eb35f:         Statement stmtBeta = betaCon.createStatement();
1:80eb35f: 
1:80eb35f:         // should implicitly create schema ALPHA
1:80eb35f:         assertStatementError("42507", stmtBeta, "CREATE SEQUENCE alpha.alpha_seq3");
1:80eb35f: 
1:c4caf0a:         // Cleanup:
1:2f4a1a0:         stmtAlpha.executeUpdate("DROP SEQUENCE alpha_seq restrict");
1:80eb35f:         
1:80eb35f:         stmtAlpha.close();
1:80eb35f:         stmtBeta.close();
1:80eb35f:         alphaCon.close();
1:80eb35f:         betaCon.close();
1:80eb35f:         adminCon.close();
1:80eb35f:     }
1:80eb35f: 
1:3b77ab8:     public void test_09a_createSequenceWithArguments() throws Exception {
1:80eb35f:         Connection alphaCon = openUserConnection(ALPHA);
1:80eb35f: 
1:bb21983:         goodStatement(alphaCon,
1:bb21983:                 "CREATE SEQUENCE small1 AS SMALLINT START WITH 0 INCREMENT BY 1");
1:bb21983: 
1:bb21983:         goodStatement(alphaCon,
1:bb21983:                 "CREATE SEQUENCE small2 AS SMALLINT START WITH " + Short.MIN_VALUE
1:bb21983:                         + " MAXVALUE " + Short.MAX_VALUE);
1:bb21983: 
1:bb21983:         goodStatement(alphaCon,
1:bb21983:                 "CREATE SEQUENCE small3 AS SMALLINT START WITH 1200"
1:bb21983:                         + " INCREMENT BY -5 MAXVALUE 32000 NO MINVALUE CYCLE");
1:bb21983: 
1:bb21983:         // maxvalue out of range
3:bb21983:         expectCompilationError(alphaCon,
1:bb21983:                 SQLState.LANG_SEQ_ARG_OUT_OF_DATATYPE_RANGE,
1:bb21983:                 "CREATE SEQUENCE small3 AS SMALLINT START WITH " + Short.MIN_VALUE
1:bb21983:                         + " MAXVALUE " + Integer.MAX_VALUE);
1:bb21983: 
1:bb21983:          // start with out of range
1:bb21983:         expectCompilationError(alphaCon,
1:bb21983:                 SQLState.LANG_SEQ_INVALID_START,
1:bb21983:                 "CREATE SEQUENCE small4 AS SMALLINT START WITH " + Integer.MIN_VALUE);
1:bb21983: 
1:bb21983:         // minvalue larger than maxvalue negative
1:bb21983:         expectCompilationError(alphaCon,
1:bb21983:                 SQLState.LANG_SEQ_MIN_EXCEEDS_MAX,
1:bb21983:                 "CREATE SEQUENCE small5 AS SMALLINT MAXVALUE -20000 MINVALUE -1");
1:bb21983: 
1:bb21983:         goodStatement(alphaCon,
1:bb21983:                 "CREATE SEQUENCE int1 AS INTEGER START WITH " + Integer.MIN_VALUE + " INCREMENT BY -10 CYCLE");
1:bb21983: 
1:bb21983:         goodStatement(alphaCon,
1:bb21983:                 "CREATE SEQUENCE int2 AS INTEGER INCREMENT BY 5"
1:bb21983:                         + " MAXVALUE " + Integer.MAX_VALUE);
1:bb21983: 
1:bb21983:         goodStatement(alphaCon,
1:bb21983:                 "CREATE SEQUENCE int3 AS INTEGER START WITH 1200 INCREMENT BY 5 "
1:bb21983:                         + "NO MAXVALUE MINVALUE -320000 CYCLE");
1:bb21983: 
1:bb21983:         // minvalue out of range
1:bb21983:         expectCompilationError(alphaCon,
1:bb21983:                 SQLState.LANG_SEQ_ARG_OUT_OF_DATATYPE_RANGE,
1:bb21983:                 "CREATE SEQUENCE int4 AS INTEGER START WITH " + Integer.MIN_VALUE
1:bb21983:                         + " MAXVALUE " + Short.MAX_VALUE
1:bb21983:                         + " MINVALUE " + Long.MIN_VALUE);
1:bb21983: 
1:bb21983:         // increment 0
1:bb21983:         expectCompilationError(alphaCon,
1:bb21983:                 SQLState.LANG_SEQ_INCREMENT_ZERO,
1:bb21983:                 "CREATE SEQUENCE int5 AS INTEGER INCREMENT BY 0");
1:bb21983: 
1:bb21983:         goodStatement(alphaCon,
1:bb21983:                 "CREATE SEQUENCE long1 AS BIGINT START WITH " + Long.MIN_VALUE + " INCREMENT BY -100 NO CYCLE");
1:bb21983: 
1:bb21983:         goodStatement(alphaCon,
1:bb21983:                 "CREATE SEQUENCE long2 AS BIGINT INCREMENT BY 25"
1:bb21983:                         + " MAXVALUE " + Integer.MAX_VALUE);
1:bb21983: 
1:bb21983:         goodStatement(alphaCon,
1:bb21983:                 "CREATE SEQUENCE long3 AS BIGINT START WITH 0 INCREMENT BY 5 "
1:bb21983:                         + "NO MAXVALUE MINVALUE " + Long.MIN_VALUE + " CYCLE");
1:bb21983: 
1:bb21983:         // invalid minvalue
1:bb21983:         expectCompilationError(alphaCon,
1:bb21983:                 SQLState.LANG_SEQ_ARG_OUT_OF_DATATYPE_RANGE,
1:bb21983:                 "CREATE SEQUENCE long4 AS BIGINT START WITH " + Integer.MAX_VALUE
1:bb21983:                         + " MINVALUE " + Long.MAX_VALUE);
1:bb21983: 
1:bb21983:         // minvalue larger than maxvalue
1:bb21983:         expectCompilationError(alphaCon,
1:bb21983:                 SQLState.LANG_SEQ_MIN_EXCEEDS_MAX,
1:bb21983:                 "CREATE SEQUENCE long5 AS BIGINT START WITH 0 MAXVALUE 100000 MINVALUE 100001");
1:bb21983: 
1:bb21983:         // should fail for non-int TYPES
1:bb21983:         expectCompilationError(alphaCon,
1:bb21983:                 SQLState.LANG_SYNTAX_ERROR,
1:bb21983:                 "CREATE SEQUENCE char1 AS CHAR INCREMENT BY 1");
1:bb21983: 
1:bb21983:     }
1:bb21983: 
1:80eb35f:     /**
1:4bea40e:      * initial test for next value
1:4bea40e:      * @throws SQLException on error
1:4bea40e:      */
1:139ca85:     public void test_10_NextValue() throws SQLException {
1:4bea40e:         Statement s = createStatement();
1:4bea40e:         s.executeUpdate("CREATE SEQUENCE mySeq1");
1:4bea40e:         s.execute("SELECT NEXT VALUE FOR mySeq1 from sys.systables");
1:6afbd85:         s.execute("DROP SEQUENCE mySeq1 restrict");
1:4bea40e:     }
1:bb21983: 
1:e671fc7:     /**
1:e671fc7:      * Verify that sequences can't be used in many contexts.
1:e671fc7:      */
1:e671fc7:     public void test_11_forbiddenContexts() throws Exception
1:e671fc7:     {
1:e671fc7:         Connection conn = openUserConnection(ALPHA);
1:e671fc7: 
1:e671fc7:         goodStatement( conn, "create sequence seq_11_a\n" );
1:e671fc7:         goodStatement( conn, "create sequence seq_11_b\n" );
1:e671fc7: 
1:e671fc7:         String illegalSequence = SQLState.LANG_NEXT_VALUE_FOR_ILLEGAL;
1:e671fc7:         
1:e671fc7:         // sequences not allowed in WHERE clause
1:e671fc7:         expectCompilationError( conn, illegalSequence, "select * from sys.systables where ( next value for seq_11_a ) > 100\n" );
1:e671fc7: 
1:e671fc7:         // sequences not allowed in HAVING clause
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, illegalSequence,
1:e671fc7:               "select max( conglomeratenumber ), tableid\n" +
1:e671fc7:               "from sys.sysconglomerates\n" +
1:e671fc7:               "group by tableid\n" +
1:e671fc7:               "having max( conglomeratenumber ) > ( next value for seq_11_a )\n"
1:e671fc7:               );
1:e671fc7:         
1:e671fc7:         // sequences not allowed in ON clause
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, illegalSequence, "select * from sys.sysconglomerates left join sys.sysschemas on conglomeratenumber = ( next value for seq_11_a )\n" );
1:e671fc7: 
1:e671fc7:         // sequences not allowed in CHECK constraints
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, illegalSequence, "create table t_11_1( a int check ( a > ( next value for seq_11_a ) ) )\n" );
1:e671fc7: 
1:e671fc7:         // sequences not allowed in generated columns
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, illegalSequence, "create table t_11_1( a int, b generated always as ( a + ( next value for seq_11_a ) ) )\n" );
1:e671fc7: 
1:e671fc7:         // sequences not allowed in aggregates
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, illegalSequence, "select max( next value for seq_11_a ) from sys.systables\n" );
1:e671fc7: 
1:e671fc7:         // sequences not allowed in CASE expressions
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, illegalSequence, "values case when ( next value for seq_11_a ) < 0 then 100 else 200 end\n" );
1:e671fc7: 
1:e671fc7:         // sequences not allowed in DISTINCT clauses
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, illegalSequence, "select distinct( next value for seq_11_a ) from sys.systables\n" );
1:e671fc7: 
1:e671fc7:         // sequences not allowed in ORDER BY clauses
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, illegalSequence, "select tableid, ( next value for seq_11_a ) a from sys.systables order by a\n" );
1:e671fc7: 
1:e671fc7:         // sequences not allowed in GROUP BY expressions
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, illegalSequence, "select max( tableid ), ( next value for seq_11_a ) from sys.systables group by ( next value for seq_11_a )\n" );
1:e671fc7: 
1:e671fc7:         // given sequence only allowed once per statement. see DERBY-4513.
1:e671fc7:         expectCompilationError
1:e671fc7:             ( conn, SQLState.LANG_SEQUENCE_REFERENCED_TWICE, "select next value for seq_11_a, next value for seq_11_a from sys.systables where 1=2\n" );
1:e671fc7: 
1:e671fc7:         // however, two different sequences can appear in a statement
1:e671fc7:         goodStatement( conn, "select next value for seq_11_a, next value for seq_11_b from sys.systables where 1=2\n" );
1:e671fc7:     }
1:e671fc7: 
1:ab49fa3:     /**
1:3b77ab8:      * Verify that optional clauses can appear in any order and redundant clauses
1:3b77ab8:      * are forbidden.
1:3b77ab8:      */
1:3b77ab8:     public void test_12_clauseOrder() throws Exception
1:3b77ab8:     {
1:3b77ab8:         Connection conn = openUserConnection(ALPHA);
1:3b77ab8: 
1:3b77ab8:         goodSequence
1:3b77ab8:             (
1:3b77ab8:              conn,
1:3b77ab8:              "seq_12_a", // name
1:3b77ab8:              "", // clauses
1:3b77ab8:              "INTEGER", // datatype
1:3b77ab8:              Integer.MIN_VALUE, // initial
1:3b77ab8:              Integer.MIN_VALUE, // min
1:3b77ab8:              Integer.MAX_VALUE, // max
1:3b77ab8:              1L, // step
1:3b77ab8:              false // cycle
1:3b77ab8:              );
1:3b77ab8: 
1:3b77ab8:         goodSequence
1:3b77ab8:             (
1:3b77ab8:              conn,
1:3b77ab8:              "seq_12_b", // name
1:3b77ab8:              "minvalue 5 increment by 3 cycle start with 100 maxvalue 1000000 as bigint", // clauses
1:3b77ab8:              "BIGINT", // datatype
1:3b77ab8:              100L, // initial
1:3b77ab8:              5L, // min
1:3b77ab8:              1000000L, // max
1:3b77ab8:              3L, // step
1:3b77ab8:              true // cycle
1:3b77ab8:              );
1:3b77ab8: 
1:3b77ab8:         goodSequence
1:3b77ab8:             (
1:3b77ab8:              conn,
1:3b77ab8:              "seq_12_c", // name
1:3b77ab8:              "increment by 3 as smallint no cycle no maxvalue", // clauses
1:3b77ab8:              "SMALLINT", // datatype
1:3b77ab8:              Short.MIN_VALUE, // initial
1:3b77ab8:              Short.MIN_VALUE, // min
1:3b77ab8:              Short.MAX_VALUE, // max
1:3b77ab8:              3L, // step
1:3b77ab8:              false // cycle
1:3b77ab8:              );
1:3b77ab8: 
1:3b77ab8:         goodSequence
1:3b77ab8:             (
1:3b77ab8:              conn,
1:3b77ab8:              "seq_12_d", // name
1:3b77ab8:              "maxvalue 1000000000 start with -50 increment by -3 cycle no minvalue", // clauses
1:3b77ab8:              "INTEGER", // datatype
1:3b77ab8:              -50L, // initial
1:3b77ab8:              Integer.MIN_VALUE, // min
1:3b77ab8:              1000000000, // max
1:3b77ab8:              -3L, // step
1:3b77ab8:              true // cycle
1:3b77ab8:              );
1:3b77ab8: 
1:3b77ab8:         expectCompilationError
1:3b77ab8:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 as smallint as bigint\n" );
1:3b77ab8:         expectCompilationError
1:3b77ab8:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 start with 3 start with 7\n" );
1:3b77ab8:         expectCompilationError
1:3b77ab8:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 minvalue 5 no minvalue\n" );
1:3b77ab8:         expectCompilationError
1:3b77ab8:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 maxvalue 5 no maxvalue\n" );
1:3b77ab8:         expectCompilationError
1:3b77ab8:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 increment by 7 increment by -7\n" );
1:3b77ab8:         expectCompilationError
1:3b77ab8:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 no cycle cycle\n" );
1:3b77ab8:     }
1:3b77ab8: 
1:3b77ab8:     private void goodSequence
1:3b77ab8:         (
1:3b77ab8:          Connection conn,
1:3b77ab8:          String sequenceName,
1:3b77ab8:          String clauses,
1:3b77ab8:          String datatype,
1:3b77ab8:          long initialValue,
1:3b77ab8:          long minValue,
1:3b77ab8:          long maxValue,
1:3b77ab8:          long stepValue,
1:3b77ab8:          boolean cycle
1:3b77ab8:          )
1:3b77ab8:         throws Exception
1:3b77ab8:     {
1:3b77ab8:         String statement = "create sequence " + sequenceName + " " + clauses;
1:3b77ab8:     
1:3b77ab8:         goodStatement( conn, statement );
1:3b77ab8: 
1:3b77ab8:         PreparedStatement ps = chattyPrepare
1:3b77ab8:             (
1:3b77ab8:              conn,
1:3b77ab8:              "select sequencedatatype, startvalue, minimumvalue, maximumvalue, increment, cycleoption\n" +
1:3b77ab8:              "from sys.syssequences\n" +
1:3b77ab8:              "where sequencename = ?"
1:3b77ab8:              );
1:3b77ab8:         ps.setString( 1, sequenceName.toUpperCase() );
1:3b77ab8: 
1:3b77ab8:         ResultSet rs = ps.executeQuery();
1:3b77ab8: 
1:3b77ab8:         rs.next();
1:3b77ab8:         int col = 1;
1:3b77ab8: 
1:3b77ab8:         assertEquals( datatype, rs.getString( col++ ) );
1:3b77ab8:         assertEquals( initialValue, rs.getLong( col++ ) );
1:3b77ab8:         assertEquals( minValue, rs.getLong( col++ ) );
1:3b77ab8:         assertEquals( maxValue, rs.getLong( col++ ) );
1:3b77ab8:         assertEquals( stepValue, rs.getLong( col++ ) );
1:3b77ab8:         assertEquals( cycle, rs.getString( col++ ).equals( "Y" ) );
1:3b77ab8: 
1:3b77ab8:         rs.close();
1:3b77ab8:         ps.close();
1:3b77ab8:     }
1:3b77ab8: 
1:2f4a1a0:     /**
1:2f4a1a0:      * Verify that restricted drops prevent objects from being orphaned.
1:2f4a1a0:      */
1:2f4a1a0:     public void test_13_restrictedDrop() throws Exception
1:2f4a1a0:     {
1:2f4a1a0:         Connection conn = openUserConnection(ALPHA);
1:2f4a1a0: 
1:2f4a1a0:         goodStatement( conn, "create table t_13_a( a int )" );
1:2f4a1a0:         goodStatement( conn, "create table t_13_b( a int )" );
1:2f4a1a0: 
1:2f4a1a0:         String createStatement;
1:2f4a1a0:         String dropStatement;
1:2f4a1a0:         String createDependentObject;
1:2f4a1a0:         String dropDependentObject;
1:2f4a1a0:         String badDropState;
1:2f4a1a0: 
1:2f4a1a0:         createStatement = "create sequence seq_13_a";
1:2f4a1a0:         dropStatement = "drop sequence seq_13_a restrict";
1:2f4a1a0:         createDependentObject = "create trigger trig_13 after insert on t_13_a for each row insert into t_13_b( a ) values ( next value for seq_13_a )\n";
1:2f4a1a0:         dropDependentObject = "drop trigger trig_13";
1:2f4a1a0:         badDropState = FORBIDDEN_DROP_TRIGGER;
1:2f4a1a0:         verifyRestrictedDrop
1:2f4a1a0:             (
1:2f4a1a0:              conn,
1:2f4a1a0:              createDependentObject,
1:2f4a1a0:              dropDependentObject,
1:2f4a1a0:              createStatement,
1:2f4a1a0:              dropStatement,
1:2f4a1a0:              badDropState
1:2f4a1a0:              );
1:2f4a1a0:         
1:2f4a1a0:         createStatement = "create sequence seq_13_b";
1:2f4a1a0:         dropStatement = "drop sequence seq_13_b restrict";
1:2f4a1a0:         createDependentObject = "create view v_13( a, b ) as select a, next value for seq_13_b from t_13_a\n";
1:2f4a1a0:         dropDependentObject = "drop view v_13";
1:2f4a1a0:         badDropState = VIEW_DEPENDENCY;
1:2f4a1a0:         verifyRestrictedDrop
1:2f4a1a0:             (
1:2f4a1a0:              conn,
1:2f4a1a0:              createDependentObject,
1:2f4a1a0:              dropDependentObject,
1:2f4a1a0:              createStatement,
1:2f4a1a0:              dropStatement,
1:2f4a1a0:              badDropState
1:2f4a1a0:              );
1:2f4a1a0: 
1:2f4a1a0:     }
1:2f4a1a0: 
1:80eb35f:     /**
1:30dd4c5:      * Verify that you can use sequences in insert statements driven
1:30dd4c5:      * by selects. See DERBY-4803.
1:30dd4c5:      */
1:30dd4c5:     public void test_14_insertSelect() throws Exception
1:30dd4c5:     {
1:30dd4c5:         Connection conn = openUserConnection(ALPHA);
1:bb21983: 
1:30dd4c5:         goodStatement( conn, "create sequence sequence_is" );
1:30dd4c5:         goodStatement( conn, "create table tis_1( a int )" );
1:30dd4c5:         goodStatement( conn, "create table tis_2( a int, b int )" );
1:30dd4c5:         goodStatement( conn, "insert into tis_1( a ) values ( 1 ), ( 2 )" );
1:30dd4c5:         goodStatement( conn, "insert into tis_2 select next value for sequence_is, a from tis_1" );
1:30dd4c5: 
1:30dd4c5:         assertResults
1:30dd4c5:             (
1:30dd4c5:              conn,
1:30dd4c5:              "select * from tis_2 order by b",
1:30dd4c5:              new String[][]
1:30dd4c5:              {
1:30dd4c5:                  { "-2147483648", "1" },
1:30dd4c5:                  { "-2147483647", "2" },
1:30dd4c5:              },
1:30dd4c5:              true
1:30dd4c5:              );
1:30dd4c5:     }
1:30dd4c5:     
1:80eb35f:     /**
1:ab49fa3:      * Verify that the new sequence-related keywords are non-reserved keywords.
1:ab49fa3:      */
1:ab49fa3:     public void test_15_5254() throws Exception
1:ab49fa3:     {
1:ab49fa3:         Connection conn = openUserConnection(ALPHA);
1:ab49fa3: 
1:ab49fa3:         goodStatement( conn, "create table t_5254( cycle int, minvalue int, maxvalue int )" );
1:ab49fa3:         goodStatement( conn, "drop table t_5254" );
1:ab49fa3:     }
1:fac3fe7:     
1:fac3fe7:     /**
1:fac3fe7:      * Verify that trigger recompilation doesn't choke trying to create
1:fac3fe7:      * two nested writable transactions.
1:fac3fe7:      */
1:fac3fe7:     public void test_16_6137() throws Exception
1:fac3fe7:     {
1:d9b64a6:         //DERBY-6176 (Couple failures in SequenceGeneratorTest suite on 
1:d9b64a6:         // trunk(1466748) with weme 6.2. Disabling the test for small
1:d9b64a6:         // devices.
1:d9b64a6:         if ( JDBC.vmSupportsJSR169() ) { return; }
1:4bea40e:         
1:fac3fe7:         Connection conn = openUserConnection( TEST_DBO );
1:fac3fe7: 
1:fac3fe7:         goodStatement( conn, "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '2' )" );
1:fac3fe7:         goodStatement( conn, "create table t_6137( rateID int generated always as identity primary key, amount decimal( 5,2 ) )" );
1:fac3fe7:         goodStatement( conn, "create table t_history_6137( changeID int primary key, amount decimal( 5,2 ) )" );
1:fac3fe7:         goodStatement( conn, "create sequence seq_6137 start with 1" );
1:fac3fe7:         goodStatement
1:fac3fe7:             (
1:fac3fe7:              conn,
1:fac3fe7:              "create trigger trg_t_6137_hist_del\n" +
1:fac3fe7:              "after delete on t_6137\n" +
1:fac3fe7:              "referencing old row as old\n" +
1:fac3fe7:              "for each row\n" +
1:fac3fe7:              " insert into t_history_6137 ( changeID, amount ) values (( next value for seq_6137 ), old.amount )\n"
1:fac3fe7:              );
1:fac3fe7:         goodStatement( conn, "insert into t_6137( amount ) values ( 30.04 ), ( 60.04 ), ( 90.04 )" );
1:fac3fe7: 
1:fac3fe7:         // invalidate the stored statements so that the trigger will have to be recompiled
1:fac3fe7:         goodStatement( conn, "call syscs_util.syscs_invalidate_stored_statements()" );
1:fac3fe7: 
1:fac3fe7:         // put the sequence in the cache
1:fac3fe7:         assertResults
1:fac3fe7:             (
1:fac3fe7:              conn,
1:fac3fe7:              "values next value for seq_6137",
1:fac3fe7:              new String[][]
1:fac3fe7:              {
1:fac3fe7:                  { "1" },
1:fac3fe7:              },
1:fac3fe7:              true
1:fac3fe7:              );
1:fac3fe7: 
1:fac3fe7:         // verify that the trigger recompiles and fires correctly
1:fac3fe7:         goodStatement( conn, "delete from t_6137 where rateID = 1" );
1:fac3fe7:         goodStatement( conn, "delete from t_6137 where rateID = 2" );
1:fac3fe7:         assertResults
1:fac3fe7:             (
1:fac3fe7:              conn,
1:fac3fe7:              "select * from t_history_6137 order by changeID",
1:fac3fe7:              new String[][]
1:fac3fe7:              {
1:fac3fe7:                  { "2", "30.04" },
1:fac3fe7:                  { "3", "60.04" },
1:fac3fe7:              },
1:fac3fe7:              true
1:fac3fe7:              );
1:fac3fe7: 
1:fac3fe7:         // verify current value of sequence
1:fac3fe7:         String  peekAtSequence = "values syscs_util.syscs_peek_at_sequence('" + TEST_DBO + "', 'SEQ_6137')";
1:fac3fe7:         assertResults
1:fac3fe7:             (
1:fac3fe7:              conn,
1:fac3fe7:              peekAtSequence,
1:fac3fe7:              new String[][]
1:fac3fe7:              {
1:fac3fe7:                  { "4" },
1:fac3fe7:              },
1:fac3fe7:              true
1:fac3fe7:              );
1:fac3fe7: 
1:fac3fe7:         // tidy up
1:fac3fe7:         goodStatement( conn, "drop trigger trg_t_6137_hist_del" );
1:fac3fe7:         goodStatement( conn, "drop table t_history_6137" );
1:fac3fe7:         goodStatement( conn, "drop table t_6137" );
1:fac3fe7:         goodStatement( conn, "drop sequence seq_6137 restrict" );
1:fac3fe7:         goodStatement( conn, "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', null )" );
1:fac3fe7: 
1:fac3fe7:         // verify that the uncleared cache does not leave a phantom sequence hanging around
1:fac3fe7:         expectExecutionError( conn, MISSING_OBJECT, peekAtSequence );
1:fac3fe7:         expectCompilationError( conn, OBJECT_DOES_NOT_EXIST, "values next value for seq_6137" );
1:fac3fe7:     }
1:7953b49:     
1:7953b49:     /**
1:9819cf8:      * Verify that a sequence can be used in the same transaction
1:9819cf8:      * which created it.
1:9819cf8:      */
1:9819cf8:     public void test_17_6554() throws Exception
1:9819cf8:     {
1:9819cf8:         Connection alphaConn = openUserConnection( ALPHA );
1:9819cf8:         Connection betaConn = openUserConnection( BETA );
1:9819cf8: 
1:9819cf8:         alphaConn.setAutoCommit( false );
1:9819cf8:         betaConn.setAutoCommit( false );
1:9819cf8: 
1:9819cf8:         String  createSequence = "create sequence seq6554";
1:9819cf8:         String  nextValueFor = "values next value for seq6554";
1:9819cf8:         String[][]  nextValueForResults =
1:9819cf8:             new String[][]
1:9819cf8:             {
1:9819cf8:                 { "-2147483648" },
1:9819cf8:             }; 
1:9819cf8: 
1:9819cf8:         goodStatement( alphaConn, createSequence );
1:9819cf8:         assertResults( alphaConn, nextValueFor, nextValueForResults, true );
1:9819cf8:         alphaConn.rollback();
1:9819cf8: 
1:9819cf8:         goodStatement( betaConn, createSequence );
1:9819cf8:         assertResults( betaConn, nextValueFor, nextValueForResults, true );
1:9819cf8:         betaConn.rollback();
1:9819cf8: 
1:9819cf8:         // now try creating and using the sequence inside the nested
1:9819cf8:         // transaction context of a database procedure
1:9819cf8: 
1:9819cf8:         goodStatement
1:9819cf8:             (
1:9819cf8:              alphaConn,
1:9819cf8:              "create procedure createSequence( sequenceName varchar( 128 ) )\n" +
1:9819cf8:              "language java parameter style java modifies sql data\n" +
1:9819cf8:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.SequenceTest.createSequence'\n"
1:9819cf8:              );
1:9819cf8:         goodStatement( alphaConn, "grant execute on procedure createSequence to public" );
1:9819cf8:         alphaConn.commit();
1:9819cf8: 
1:9819cf8:         String  runProcedure = "call alpha.createSequence( 'seq6554_2' )";
1:9819cf8:         String  postProcedureQuery= "values next value for seq6554_2";
1:9819cf8:         String[][]  postProcedureResults =
1:9819cf8:             new String[][]
1:9819cf8:             {
1:9819cf8:                 { "-2147483647" },
1:9819cf8:             };
1:9819cf8: 
1:9819cf8:         goodStatement( alphaConn, runProcedure );
1:9819cf8:         assertResults( alphaConn, postProcedureQuery, postProcedureResults, true );
1:9819cf8:         alphaConn.rollback();
1:9819cf8:         
1:9819cf8:         goodStatement( betaConn, runProcedure );
1:9819cf8:         assertResults( betaConn, postProcedureQuery, postProcedureResults, true );
1:9819cf8:         betaConn.rollback();
1:9819cf8: 
1:9819cf8:         alphaConn.setAutoCommit( true );
1:9819cf8:         betaConn.setAutoCommit( true );
1:9819cf8:     }
1:9819cf8:     
1:9819cf8:     /**
1:7953b49:      * Verify that sequence numbers pick up where they left off after eviction from
1:7953b49:      * the sequence cache.
1:7953b49:      */
1:7953b49:     public void test_17_6554_cacheEviction() throws Exception
1:7953b49:     {
1:7953b49:         Connection control = openUserConnection( TEST_DBO );
1:7953b49: 
1:7953b49:         // set the size of the sequence generator cache to 5 entries.
1:7953b49:         // bounce the database so that the value takes effect.
1:7953b49:         goodStatement( control, "call syscs_util.syscs_set_database_property( 'derby.language.sequenceGeneratorCacheSize', '5' )" );
1:7953b49:         getTestConfiguration().shutdownDatabase();
1:7953b49: 
1:7953b49:         Connection conn1 = openUserConnection( ALPHA );
1:7953b49:         Connection conn2 = openUserConnection( ALPHA );
1:7953b49: 
1:7953b49:         goodStatement( conn1, "create sequence s000" );
1:7953b49:         assertResults
1:7953b49:             (
1:7953b49:              conn1,
1:7953b49:              "values next value for s000",
1:7953b49:              new String[][]
1:7953b49:              {
1:7953b49:                  { "-2147483648" },
1:7953b49:              },
1:7953b49:              true
1:7953b49:              );
1:7953b49:         goodStatement( conn1, "create sequence s001" );
1:7953b49:         assertResults
1:7953b49:             (
1:7953b49:              conn1,
1:7953b49:              "values next value for s001",
1:7953b49:              new String[][]
1:7953b49:              {
1:7953b49:                  { "-2147483648" },
1:7953b49:              },
1:7953b49:              true
1:7953b49:              );
1:7953b49:         assertResults
1:7953b49:             (
1:7953b49:              conn1,
1:7953b49:              "values next value for s001",
1:7953b49:              new String[][]
1:7953b49:              {
1:7953b49:                  { "-2147483647" },
1:7953b49:              },
1:7953b49:              true
1:7953b49:              );
1:7953b49: 
1:7953b49:         // now create enough sequences to evict the first two sequences from the cache
1:7953b49:         goodStatement( conn2, "create sequence s002" );
1:7953b49:         goodStatement( conn2, "create sequence s003" );
1:7953b49:         goodStatement( conn2, "create sequence s004" );
1:7953b49:         goodStatement( conn2, "create sequence s005" );
1:7953b49:         goodStatement( conn2, "create sequence s006" );
1:7953b49:         goodStatement( conn2, "create sequence s007" );
1:7953b49:         goodStatement( conn2, "create sequence s008" );
1:7953b49:         goodStatement( conn2, "create sequence s009" );
1:7953b49:         goodStatement( conn2, "create sequence s010" );
1:7953b49: 
1:7953b49:         // now we pick up where we left off
1:7953b49:         assertResults
1:7953b49:             (
1:7953b49:              conn1,
1:7953b49:              "values next value for s000",
1:7953b49:              new String[][]
1:7953b49:              {
1:7953b49:                  { "-2147483647" },
1:7953b49:              },
1:7953b49:              true
1:7953b49:              );
1:7953b49:         assertResults
1:7953b49:             (
1:7953b49:              conn1,
1:7953b49:              "values next value for s001",
1:7953b49:              new String[][]
1:7953b49:              {
1:7953b49:                  { "-2147483646" },
1:7953b49:              },
1:7953b49:              true
1:7953b49:              );
1:7953b49: 
1:7953b49:         // restore the original size of the sequence generator cache
1:7953b49:         control = openUserConnection( TEST_DBO );
1:7953b49: 
1:7953b49:         goodStatement( control, "call syscs_util.syscs_set_database_property( 'derby.language.sequenceGeneratorCacheSize', '1000' )" );
1:7953b49:         getTestConfiguration().shutdownDatabase();
1:7953b49:     }
1:7953b49:     
1:7953b49:     //////////////////////////////////////////////////////////////////////
1:7953b49:     //
1:7953b49:     //  SQL ROUTINES
1:7953b49:     //
1:7953b49:     //////////////////////////////////////////////////////////////////////
1:7953b49: 
1:7953b49:     public  static  void    createSequence( String sequenceName )
1:7953b49:         throws Exception
1:7953b49:     {
1:7953b49:         Connection  conn = DriverManager.getConnection( "jdbc:default:connection" );
1:7953b49: 
1:7953b49:         conn.prepareStatement( "create sequence " + sequenceName ).execute();
1:7953b49: 
1:7953b49:         ResultSet   rs = conn.prepareStatement( "values next value for " + sequenceName ).executeQuery();
1:7953b49:         rs.next();
1:7953b49:         assertEquals( -2147483648L, rs.getLong( 1 ) );
1:7953b49:         rs.close();
1:7953b49:     }
1:7953b49: 
1:80eb35f: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite(SequenceTest.class, "Sequence Test");
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9819cf8
/////////////////////////////////////////////////////////////////////////
1:      * Verify that a sequence can be used in the same transaction
1:      * which created it.
1:      */
1:     public void test_17_6554() throws Exception
1:     {
1:         Connection alphaConn = openUserConnection( ALPHA );
1:         Connection betaConn = openUserConnection( BETA );
1: 
1:         alphaConn.setAutoCommit( false );
1:         betaConn.setAutoCommit( false );
1: 
1:         String  createSequence = "create sequence seq6554";
1:         String  nextValueFor = "values next value for seq6554";
1:         String[][]  nextValueForResults =
1:             new String[][]
1:             {
1:                 { "-2147483648" },
1:             }; 
1: 
1:         goodStatement( alphaConn, createSequence );
1:         assertResults( alphaConn, nextValueFor, nextValueForResults, true );
1:         alphaConn.rollback();
1: 
1:         goodStatement( betaConn, createSequence );
1:         assertResults( betaConn, nextValueFor, nextValueForResults, true );
1:         betaConn.rollback();
1: 
1:         // now try creating and using the sequence inside the nested
1:         // transaction context of a database procedure
1: 
1:         goodStatement
1:             (
1:              alphaConn,
1:              "create procedure createSequence( sequenceName varchar( 128 ) )\n" +
1:              "language java parameter style java modifies sql data\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.SequenceTest.createSequence'\n"
1:              );
1:         goodStatement( alphaConn, "grant execute on procedure createSequence to public" );
1:         alphaConn.commit();
1: 
1:         String  runProcedure = "call alpha.createSequence( 'seq6554_2' )";
1:         String  postProcedureQuery= "values next value for seq6554_2";
1:         String[][]  postProcedureResults =
1:             new String[][]
1:             {
1:                 { "-2147483647" },
1:             };
1: 
1:         goodStatement( alphaConn, runProcedure );
1:         assertResults( alphaConn, postProcedureQuery, postProcedureResults, true );
1:         alphaConn.rollback();
1:         
1:         goodStatement( betaConn, runProcedure );
1:         assertResults( betaConn, postProcedureQuery, postProcedureResults, true );
1:         betaConn.rollback();
1: 
1:         alphaConn.setAutoCommit( true );
1:         betaConn.setAutoCommit( true );
1:     }
1:     
1:     /**
commit:7953b49
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DriverManager;
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String  TOO_MANY_UNUSED_SEQUENCES = "X0Y93";
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Verify that sequence numbers pick up where they left off after eviction from
1:      * the sequence cache.
1:      */
1:     public void test_17_6554_cacheEviction() throws Exception
1:     {
1:         Connection control = openUserConnection( TEST_DBO );
1: 
1:         // set the size of the sequence generator cache to 5 entries.
1:         // bounce the database so that the value takes effect.
1:         goodStatement( control, "call syscs_util.syscs_set_database_property( 'derby.language.sequenceGeneratorCacheSize', '5' )" );
1:         getTestConfiguration().shutdownDatabase();
1: 
1:         Connection conn1 = openUserConnection( ALPHA );
1:         Connection conn2 = openUserConnection( ALPHA );
1: 
1:         goodStatement( conn1, "create sequence s000" );
1:         assertResults
1:             (
1:              conn1,
1:              "values next value for s000",
1:              new String[][]
1:              {
1:                  { "-2147483648" },
1:              },
1:              true
1:              );
1:         goodStatement( conn1, "create sequence s001" );
1:         assertResults
1:             (
1:              conn1,
1:              "values next value for s001",
1:              new String[][]
1:              {
1:                  { "-2147483648" },
1:              },
1:              true
1:              );
1:         assertResults
1:             (
1:              conn1,
1:              "values next value for s001",
1:              new String[][]
1:              {
1:                  { "-2147483647" },
1:              },
1:              true
1:              );
1: 
1:         // now create enough sequences to evict the first two sequences from the cache
1:         goodStatement( conn2, "create sequence s002" );
1:         goodStatement( conn2, "create sequence s003" );
1:         goodStatement( conn2, "create sequence s004" );
1:         goodStatement( conn2, "create sequence s005" );
1:         goodStatement( conn2, "create sequence s006" );
1:         goodStatement( conn2, "create sequence s007" );
1:         goodStatement( conn2, "create sequence s008" );
1:         goodStatement( conn2, "create sequence s009" );
1:         goodStatement( conn2, "create sequence s010" );
1: 
1:         // now we pick up where we left off
1:         assertResults
1:             (
1:              conn1,
1:              "values next value for s000",
1:              new String[][]
1:              {
1:                  { "-2147483647" },
1:              },
1:              true
1:              );
1:         assertResults
1:             (
1:              conn1,
1:              "values next value for s001",
1:              new String[][]
1:              {
1:                  { "-2147483646" },
1:              },
1:              true
1:              );
1: 
1:         // restore the original size of the sequence generator cache
1:         control = openUserConnection( TEST_DBO );
1: 
1:         goodStatement( control, "call syscs_util.syscs_set_database_property( 'derby.language.sequenceGeneratorCacheSize', '1000' )" );
1:         getTestConfiguration().shutdownDatabase();
1:     }
1:     
1:     //////////////////////////////////////////////////////////////////////
1:     //
1:     //  SQL ROUTINES
1:     //
1:     //////////////////////////////////////////////////////////////////////
1: 
1:     public  static  void    createSequence( String sequenceName )
1:         throws Exception
1:     {
1:         Connection  conn = DriverManager.getConnection( "jdbc:default:connection" );
1: 
1:         conn.prepareStatement( "create sequence " + sequenceName ).execute();
1: 
1:         ResultSet   rs = conn.prepareStatement( "values next value for " + sequenceName ).executeQuery();
1:         rs.next();
1:         assertEquals( -2147483648L, rs.getLong( 1 ) );
1:         rs.close();
1:     }
1: 
commit:fac3fe7
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Verify that trigger recompilation doesn't choke trying to create
1:      * two nested writable transactions.
1:      */
1:     public void test_16_6137() throws Exception
1:     {
1:         Connection conn = openUserConnection( TEST_DBO );
1: 
1:         goodStatement( conn, "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '2' )" );
1:         goodStatement( conn, "create table t_6137( rateID int generated always as identity primary key, amount decimal( 5,2 ) )" );
1:         goodStatement( conn, "create table t_history_6137( changeID int primary key, amount decimal( 5,2 ) )" );
1:         goodStatement( conn, "create sequence seq_6137 start with 1" );
1:         goodStatement
1:             (
1:              conn,
1:              "create trigger trg_t_6137_hist_del\n" +
1:              "after delete on t_6137\n" +
1:              "referencing old row as old\n" +
1:              "for each row\n" +
1:              " insert into t_history_6137 ( changeID, amount ) values (( next value for seq_6137 ), old.amount )\n"
1:              );
1:         goodStatement( conn, "insert into t_6137( amount ) values ( 30.04 ), ( 60.04 ), ( 90.04 )" );
1: 
1:         // invalidate the stored statements so that the trigger will have to be recompiled
1:         goodStatement( conn, "call syscs_util.syscs_invalidate_stored_statements()" );
1: 
1:         // put the sequence in the cache
1:         assertResults
1:             (
1:              conn,
1:              "values next value for seq_6137",
1:              new String[][]
1:              {
1:                  { "1" },
1:              },
1:              true
1:              );
1: 
1:         // verify that the trigger recompiles and fires correctly
1:         goodStatement( conn, "delete from t_6137 where rateID = 1" );
1:         goodStatement( conn, "delete from t_6137 where rateID = 2" );
1:         assertResults
1:             (
1:              conn,
1:              "select * from t_history_6137 order by changeID",
1:              new String[][]
1:              {
1:                  { "2", "30.04" },
1:                  { "3", "60.04" },
1:              },
1:              true
1:              );
1: 
1:         // verify current value of sequence
1:         String  peekAtSequence = "values syscs_util.syscs_peek_at_sequence('" + TEST_DBO + "', 'SEQ_6137')";
1:         assertResults
1:             (
1:              conn,
1:              peekAtSequence,
1:              new String[][]
1:              {
1:                  { "4" },
1:              },
1:              true
1:              );
1: 
1:         // tidy up
1:         goodStatement( conn, "drop trigger trg_t_6137_hist_del" );
1:         goodStatement( conn, "drop table t_history_6137" );
1:         goodStatement( conn, "drop table t_6137" );
1:         goodStatement( conn, "drop sequence seq_6137 restrict" );
1:         goodStatement( conn, "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', null )" );
1: 
1:         // verify that the uncleared cache does not leave a phantom sequence hanging around
1:         expectExecutionError( conn, MISSING_OBJECT, peekAtSequence );
1:         expectCompilationError( conn, OBJECT_DOES_NOT_EXIST, "values next value for seq_6137" );
1:     }
commit:ab49fa3
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that the new sequence-related keywords are non-reserved keywords.
1:      */
1:     public void test_15_5254() throws Exception
1:     {
1:         Connection conn = openUserConnection(ALPHA);
1: 
1:         goodStatement( conn, "create table t_5254( cycle int, minvalue int, maxvalue int )" );
1:         goodStatement( conn, "drop table t_5254" );
1:     }
commit:30dd4c5
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that you can use sequences in insert statements driven
1:      * by selects. See DERBY-4803.
1:      */
1:     public void test_14_insertSelect() throws Exception
1:     {
1:         Connection conn = openUserConnection(ALPHA);
1:         goodStatement( conn, "create sequence sequence_is" );
1:         goodStatement( conn, "create table tis_1( a int )" );
1:         goodStatement( conn, "create table tis_2( a int, b int )" );
1:         goodStatement( conn, "insert into tis_1( a ) values ( 1 ), ( 2 )" );
1:         goodStatement( conn, "insert into tis_2 select next value for sequence_is, a from tis_1" );
1: 
1:         assertResults
1:             (
1:              conn,
1:              "select * from tis_2 order by b",
1:              new String[][]
1:              {
1:                  { "-2147483648", "1" },
1:                  { "-2147483647", "2" },
1:              },
1:              true
1:              );
1:     }
1:     
commit:2f4a1a0
/////////////////////////////////////////////////////////////////////////
1:         s.executeUpdate("DROP SEQUENCE mySeq1 restrict");
/////////////////////////////////////////////////////////////////////////
1:             s.executeUpdate("DROP SEQUENCE mySeq1 restrict"); // Drop the one created.
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate("DROP SEQUENCE alpha_seq restrict");
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate("DROP SEQUENCE alpha.alpha_seq restrict");
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate("DROP SEQUENCE alpha.alpha_seq restrict");
/////////////////////////////////////////////////////////////////////////
1:         stmt.executeUpdate("DROP SEQUENCE alpha_seq restrict");
/////////////////////////////////////////////////////////////////////////
1:         assertStatementError("42507", stmtBeta, "DROP SEQUENCE alpha.alpha_seq restrict");
1:         stmtAlpha.executeUpdate("DROP SEQUENCE alpha_seq restrict");
/////////////////////////////////////////////////////////////////////////
1:         stmtAlpha.executeUpdate("DROP SEQUENCE alpha_seq restrict");
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that restricted drops prevent objects from being orphaned.
1:      */
1:     public void test_13_restrictedDrop() throws Exception
1:     {
1:         Connection conn = openUserConnection(ALPHA);
1: 
1:         goodStatement( conn, "create table t_13_a( a int )" );
1:         goodStatement( conn, "create table t_13_b( a int )" );
1: 
1:         String createStatement;
1:         String dropStatement;
1:         String createDependentObject;
1:         String dropDependentObject;
1:         String badDropState;
1: 
1:         createStatement = "create sequence seq_13_a";
1:         dropStatement = "drop sequence seq_13_a restrict";
1:         createDependentObject = "create trigger trig_13 after insert on t_13_a for each row insert into t_13_b( a ) values ( next value for seq_13_a )\n";
1:         dropDependentObject = "drop trigger trig_13";
1:         badDropState = FORBIDDEN_DROP_TRIGGER;
1:         verifyRestrictedDrop
1:             (
1:              conn,
1:              createDependentObject,
1:              dropDependentObject,
1:              createStatement,
1:              dropStatement,
1:              badDropState
1:              );
1:         
1:         createStatement = "create sequence seq_13_b";
1:         dropStatement = "drop sequence seq_13_b restrict";
1:         createDependentObject = "create view v_13( a, b ) as select a, next value for seq_13_b from t_13_a\n";
1:         dropDependentObject = "drop view v_13";
1:         badDropState = VIEW_DEPENDENCY;
1:         verifyRestrictedDrop
1:             (
1:              conn,
1:              createDependentObject,
1:              dropDependentObject,
1:              createStatement,
1:              dropStatement,
1:              badDropState
1:              );
1: 
1:     }
1: 
commit:3b77ab8
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
/////////////////////////////////////////////////////////////////////////
1:     public void test_09a_createSequenceWithArguments() throws Exception {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that optional clauses can appear in any order and redundant clauses
1:      * are forbidden.
1:      */
1:     public void test_12_clauseOrder() throws Exception
1:     {
1:         Connection conn = openUserConnection(ALPHA);
1: 
1:         goodSequence
1:             (
1:              conn,
1:              "seq_12_a", // name
1:              "", // clauses
1:              "INTEGER", // datatype
1:              Integer.MIN_VALUE, // initial
1:              Integer.MIN_VALUE, // min
1:              Integer.MAX_VALUE, // max
1:              1L, // step
1:              false // cycle
1:              );
1: 
1:         goodSequence
1:             (
1:              conn,
1:              "seq_12_b", // name
1:              "minvalue 5 increment by 3 cycle start with 100 maxvalue 1000000 as bigint", // clauses
1:              "BIGINT", // datatype
1:              100L, // initial
1:              5L, // min
1:              1000000L, // max
1:              3L, // step
1:              true // cycle
1:              );
1: 
1:         goodSequence
1:             (
1:              conn,
1:              "seq_12_c", // name
1:              "increment by 3 as smallint no cycle no maxvalue", // clauses
1:              "SMALLINT", // datatype
1:              Short.MIN_VALUE, // initial
1:              Short.MIN_VALUE, // min
1:              Short.MAX_VALUE, // max
1:              3L, // step
1:              false // cycle
1:              );
1: 
1:         goodSequence
1:             (
1:              conn,
1:              "seq_12_d", // name
1:              "maxvalue 1000000000 start with -50 increment by -3 cycle no minvalue", // clauses
1:              "INTEGER", // datatype
1:              -50L, // initial
1:              Integer.MIN_VALUE, // min
1:              1000000000, // max
1:              -3L, // step
1:              true // cycle
1:              );
1: 
1:         expectCompilationError
1:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 as smallint as bigint\n" );
1:         expectCompilationError
1:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 start with 3 start with 7\n" );
1:         expectCompilationError
1:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 minvalue 5 no minvalue\n" );
1:         expectCompilationError
1:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 maxvalue 5 no maxvalue\n" );
1:         expectCompilationError
1:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 increment by 7 increment by -7\n" );
1:         expectCompilationError
1:             ( conn, DUPLICATE_CLAUSE, "create sequence bad_12 no cycle cycle\n" );
1:     }
1: 
1:     private void goodSequence
1:         (
1:          Connection conn,
1:          String sequenceName,
1:          String clauses,
1:          String datatype,
1:          long initialValue,
1:          long minValue,
1:          long maxValue,
1:          long stepValue,
1:          boolean cycle
1:          )
1:         throws Exception
1:     {
1:         String statement = "create sequence " + sequenceName + " " + clauses;
1:     
1:         goodStatement( conn, statement );
1: 
1:         PreparedStatement ps = chattyPrepare
1:             (
1:              conn,
1:              "select sequencedatatype, startvalue, minimumvalue, maximumvalue, increment, cycleoption\n" +
1:              "from sys.syssequences\n" +
1:              "where sequencename = ?"
1:              );
1:         ps.setString( 1, sequenceName.toUpperCase() );
1: 
1:         ResultSet rs = ps.executeQuery();
1: 
1:         rs.next();
1:         int col = 1;
1: 
1:         assertEquals( datatype, rs.getString( col++ ) );
1:         assertEquals( initialValue, rs.getLong( col++ ) );
1:         assertEquals( minValue, rs.getLong( col++ ) );
1:         assertEquals( maxValue, rs.getLong( col++ ) );
1:         assertEquals( stepValue, rs.getLong( col++ ) );
1:         assertEquals( cycle, rs.getString( col++ ).equals( "Y" ) );
1: 
1:         rs.close();
1:         ps.close();
1:     }
1: 
commit:e671fc7
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that sequences can't be used in many contexts.
1:      */
1:     public void test_11_forbiddenContexts() throws Exception
1:     {
1:         Connection conn = openUserConnection(ALPHA);
1: 
1:         goodStatement( conn, "create sequence seq_11_a\n" );
1:         goodStatement( conn, "create sequence seq_11_b\n" );
1: 
1:         String illegalSequence = SQLState.LANG_NEXT_VALUE_FOR_ILLEGAL;
1:         
1:         // sequences not allowed in WHERE clause
1:         expectCompilationError( conn, illegalSequence, "select * from sys.systables where ( next value for seq_11_a ) > 100\n" );
1: 
1:         // sequences not allowed in HAVING clause
1:         expectCompilationError
1:             ( conn, illegalSequence,
1:               "select max( conglomeratenumber ), tableid\n" +
1:               "from sys.sysconglomerates\n" +
1:               "group by tableid\n" +
1:               "having max( conglomeratenumber ) > ( next value for seq_11_a )\n"
1:               );
1:         
1:         // sequences not allowed in ON clause
1:         expectCompilationError
1:             ( conn, illegalSequence, "select * from sys.sysconglomerates left join sys.sysschemas on conglomeratenumber = ( next value for seq_11_a )\n" );
1: 
1:         // sequences not allowed in CHECK constraints
1:         expectCompilationError
1:             ( conn, illegalSequence, "create table t_11_1( a int check ( a > ( next value for seq_11_a ) ) )\n" );
1: 
1:         // sequences not allowed in generated columns
1:         expectCompilationError
1:             ( conn, illegalSequence, "create table t_11_1( a int, b generated always as ( a + ( next value for seq_11_a ) ) )\n" );
1: 
1:         // sequences not allowed in aggregates
1:         expectCompilationError
1:             ( conn, illegalSequence, "select max( next value for seq_11_a ) from sys.systables\n" );
1: 
1:         // sequences not allowed in CASE expressions
1:         expectCompilationError
1:             ( conn, illegalSequence, "values case when ( next value for seq_11_a ) < 0 then 100 else 200 end\n" );
1: 
1:         // sequences not allowed in DISTINCT clauses
1:         expectCompilationError
1:             ( conn, illegalSequence, "select distinct( next value for seq_11_a ) from sys.systables\n" );
1: 
1:         // sequences not allowed in ORDER BY clauses
1:         expectCompilationError
1:             ( conn, illegalSequence, "select tableid, ( next value for seq_11_a ) a from sys.systables order by a\n" );
1: 
1:         // sequences not allowed in GROUP BY expressions
1:         expectCompilationError
1:             ( conn, illegalSequence, "select max( tableid ), ( next value for seq_11_a ) from sys.systables group by ( next value for seq_11_a )\n" );
1: 
1:         // given sequence only allowed once per statement. see DERBY-4513.
1:         expectCompilationError
1:             ( conn, SQLState.LANG_SEQUENCE_REFERENCED_TWICE, "select next value for seq_11_a, next value for seq_11_a from sys.systables where 1=2\n" );
1: 
1:         // however, two different sequences can appear in a statement
1:         goodStatement( conn, "select next value for seq_11_a, next value for seq_11_b from sys.systables where 1=2\n" );
1:     }
1: 
commit:139ca85
/////////////////////////////////////////////////////////////////////////
1:     public void test_01_CreateSequence() throws SQLException {
1:     public void test_02_DropSequence() throws SQLException {
1:     public void test_03_DuplicateCreationFailure() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void test_04_ImplicitSchemaCreation() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void test_05CreateWithSchemaSpecified() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void test_06_CreateWithSchemaSpecifiedCreateTrue() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void test_07_CreateWithSchemaDropWithNoSchema() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void test_08_DropOtherSchemaSequence() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void test_09_CreateOtherSchemaSequence() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void test_10_NextValue() throws SQLException {
commit:bb21983
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.SQLState;
1: public class SequenceTest extends GeneratedColumnsHelper {
/////////////////////////////////////////////////////////////////////////
0:     public void testCreateSequenceWithArguments() throws Exception {
1:         Connection alphaCon = openUserConnection(ALPHA);
1: 
1:         goodStatement(alphaCon,
1:                 "CREATE SEQUENCE small1 AS SMALLINT START WITH 0 INCREMENT BY 1");
1: 
1:         goodStatement(alphaCon,
1:                 "CREATE SEQUENCE small2 AS SMALLINT START WITH " + Short.MIN_VALUE
1:                         + " MAXVALUE " + Short.MAX_VALUE);
1: 
1:         goodStatement(alphaCon,
1:                 "CREATE SEQUENCE small3 AS SMALLINT START WITH 1200"
1:                         + " INCREMENT BY -5 MAXVALUE 32000 NO MINVALUE CYCLE");
1: 
1:         // maxvalue out of range
1:         expectCompilationError(alphaCon,
1:                 SQLState.LANG_SEQ_ARG_OUT_OF_DATATYPE_RANGE,
1:                 "CREATE SEQUENCE small3 AS SMALLINT START WITH " + Short.MIN_VALUE
1:                         + " MAXVALUE " + Integer.MAX_VALUE);
1: 
1:          // start with out of range
1:         expectCompilationError(alphaCon,
1:                 SQLState.LANG_SEQ_INVALID_START,
1:                 "CREATE SEQUENCE small4 AS SMALLINT START WITH " + Integer.MIN_VALUE);
1: 
1:         // minvalue larger than maxvalue negative
1:         expectCompilationError(alphaCon,
1:                 SQLState.LANG_SEQ_MIN_EXCEEDS_MAX,
1:                 "CREATE SEQUENCE small5 AS SMALLINT MAXVALUE -20000 MINVALUE -1");
1: 
1:         goodStatement(alphaCon,
1:                 "CREATE SEQUENCE int1 AS INTEGER START WITH " + Integer.MIN_VALUE + " INCREMENT BY -10 CYCLE");
1: 
1:         goodStatement(alphaCon,
1:                 "CREATE SEQUENCE int2 AS INTEGER INCREMENT BY 5"
1:                         + " MAXVALUE " + Integer.MAX_VALUE);
1: 
1:         goodStatement(alphaCon,
1:                 "CREATE SEQUENCE int3 AS INTEGER START WITH 1200 INCREMENT BY 5 "
1:                         + "NO MAXVALUE MINVALUE -320000 CYCLE");
1: 
1:         // minvalue out of range
1:         expectCompilationError(alphaCon,
1:                 SQLState.LANG_SEQ_ARG_OUT_OF_DATATYPE_RANGE,
1:                 "CREATE SEQUENCE int4 AS INTEGER START WITH " + Integer.MIN_VALUE
1:                         + " MAXVALUE " + Short.MAX_VALUE
1:                         + " MINVALUE " + Long.MIN_VALUE);
1: 
0:         // increment out of range
1:         expectCompilationError(alphaCon,
0:                 SQLState.LANG_SEQ_INCREMENT_OUT_OF_RANGE,
0:                 "CREATE SEQUENCE int5 AS INTEGER INCREMENT BY " + Long.MAX_VALUE);
1: 
1:         // increment 0
1:         expectCompilationError(alphaCon,
1:                 SQLState.LANG_SEQ_INCREMENT_ZERO,
1:                 "CREATE SEQUENCE int5 AS INTEGER INCREMENT BY 0");
1: 
0:        // increment too big
1:         expectCompilationError(alphaCon,
0:                 SQLState.LANG_SEQ_INCREMENT_OUT_OF_RANGE,
0:                 "CREATE SEQUENCE int6 AS INTEGER INCREMENT BY " + Long.MAX_VALUE);
1: 
1:         goodStatement(alphaCon,
1:                 "CREATE SEQUENCE long1 AS BIGINT START WITH " + Long.MIN_VALUE + " INCREMENT BY -100 NO CYCLE");
1: 
1:         goodStatement(alphaCon,
1:                 "CREATE SEQUENCE long2 AS BIGINT INCREMENT BY 25"
1:                         + " MAXVALUE " + Integer.MAX_VALUE);
1: 
1:         goodStatement(alphaCon,
1:                 "CREATE SEQUENCE long3 AS BIGINT START WITH 0 INCREMENT BY 5 "
1:                         + "NO MAXVALUE MINVALUE " + Long.MIN_VALUE + " CYCLE");
1: 
1:         // invalid minvalue
1:         expectCompilationError(alphaCon,
1:                 SQLState.LANG_SEQ_ARG_OUT_OF_DATATYPE_RANGE,
1:                 "CREATE SEQUENCE long4 AS BIGINT START WITH " + Integer.MAX_VALUE
1:                         + " MINVALUE " + Long.MAX_VALUE);
1: 
1:         // minvalue larger than maxvalue
1:         expectCompilationError(alphaCon,
1:                 SQLState.LANG_SEQ_MIN_EXCEEDS_MAX,
1:                 "CREATE SEQUENCE long5 AS BIGINT START WITH 0 MAXVALUE 100000 MINVALUE 100001");
1: 
1:         // should fail for non-int TYPES
1:         expectCompilationError(alphaCon,
1:                 SQLState.LANG_SYNTAX_ERROR,
1:                 "CREATE SEQUENCE char1 AS CHAR INCREMENT BY 1");
1: 
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
commit:4bea40e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * initial test for next value
1:      * @throws SQLException on error
1:      */
0:     public void testNextValue() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("CREATE SEQUENCE mySeq1");
1:         s.execute("SELECT NEXT VALUE FOR mySeq1 from sys.systables");
1:     }
1: 
commit:80eb35f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.SequenceTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Test sequences.
1:  */
0: public class SequenceTest extends BaseJDBCTestCase {
1: 
1:     private static final String TEST_DBO = "TEST_DBO";
1:     private static final String ALPHA = "ALPHA";
1:     private static final String BETA = "BETA";
1:     private static final String[] LEGAL_USERS = {TEST_DBO, ALPHA, BETA};
1: 
1:     public SequenceTest(String name) {
1:         super(name);
1:         // TODO Auto-generated constructor stub
1:     }
1: 
1:     // SETUP
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite(SequenceTest.class, "Sequence Test");
1:         // Need atleast JSR169 to run these tests
1:         if (!JDBC.vmSupportsJSR169() && !JDBC.vmSupportsJDBC3()) {
1:             return suite;
1:         }
1: 
1:         Test cleanTest = new CleanDatabaseTestSetup(suite);
1:         Test authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
1:                 (cleanTest, LEGAL_USERS, "sequence");
1:         Test authorizedTest = TestConfiguration.sqlAuthorizationDecorator(authenticatedTest);
1: 
1:         return authorizedTest;
1:     }
1: 
0:     public void testCreateSequence() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("CREATE SEQUENCE mySeq");
1:     }
1: 
0:     public void testDropSequence() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("CREATE SEQUENCE mySeq1");
0:         s.executeUpdate("DROP SEQUENCE mySeq1");
1:     }
1: 
0:     public void testDuplicateCreationFailure() {
1:         try {
1:             Statement s = createStatement();
1:             s.executeUpdate("CREATE SEQUENCE mySeq1");
1:             s.executeUpdate("CREATE SEQUENCE mySeq1");
1:         } catch (SQLException sqle) {
1:             assertSQLState("X0Y68", sqle);
1:         }
1:     }
1: 
0:     public void testImplicitSchemaCreation() throws SQLException {
1:         Connection adminCon = openUserConnection(TEST_DBO);
1: 
1:         Connection alphaCon = openUserConnection(ALPHA);
1:         Statement stmt = alphaCon.createStatement();
1: 
1:         // should implicitly create schema ALPHA
1:         stmt.executeUpdate("CREATE SEQUENCE alpha_seq");
0:         stmt.executeUpdate("DROP SEQUENCE alpha_seq");
1:         stmt.close();
1:         alphaCon.close();
1:         adminCon.close();
1:     }
1: 
0:     public void testCreateWithSchemaSpecified() throws SQLException {
1: 
1:         // create DB
1:         Connection alphaCon = openUserConnection(ALPHA);
1:         Statement stmt = alphaCon.createStatement();
1: 
1:         // should implicitly create schema ALPHA
1:         stmt.executeUpdate("CREATE SEQUENCE alpha.alpha_seq");
0:         stmt.executeUpdate("DROP SEQUENCE alpha.alpha_seq");
1:         stmt.close();
1:         alphaCon.close();
1:     }
1: 
0:     public void testCreateWithSchemaSpecifiedCreateTrue() throws SQLException {
1:         Connection alphaCon = openUserConnection(ALPHA);
1:         Statement stmt = alphaCon.createStatement();
1: 
1:         // should implicitly create schema ALPHA
1:         stmt.executeUpdate("CREATE SEQUENCE alpha.alpha_seq");
0:         stmt.executeUpdate("DROP SEQUENCE alpha.alpha_seq");
1:         stmt.close();
1:         alphaCon.close();
1:     }
1: 
0:     public void testCreateWithSchemaDropWithNoSchema() throws SQLException {
1:         Connection alphaCon = openUserConnection(ALPHA);
1:         Statement stmt = alphaCon.createStatement();
1: 
1:         // should implicitly create schema ALPHA
1:         stmt.executeUpdate("CREATE SEQUENCE alpha.alpha_seq");
0:         stmt.executeUpdate("DROP SEQUENCE alpha_seq");
1:         stmt.close();
1:         alphaCon.close();
1:     }
1: 
1:     /**
1:      * Test trying to drop a sequence in a schema that doesn't belong to one
1:      */
0:     public void testDropOtherSchemaSequence() throws SQLException {
1:         Connection adminCon = openUserConnection(TEST_DBO);
1: 
1:         Connection alphaCon = openUserConnection(ALPHA);
1:         Statement stmtAlpha = alphaCon.createStatement();
1:         stmtAlpha.executeUpdate("CREATE SEQUENCE alpha_seq");
1: 
1:         Connection betaCon = openUserConnection(BETA);
1:         Statement stmtBeta = betaCon.createStatement();
1: 
1:         // should implicitly create schema ALPHA
0:         assertStatementError("42507", stmtBeta, "DROP SEQUENCE alpha.alpha_seq");
1: 
1:         stmtAlpha.close();
1:         stmtBeta.close();
1:         alphaCon.close();
1:         betaCon.close();
1:         adminCon.close();
1:     }
1: 
1:     /**
1:      * Test trying to create a sequence in a schema that doesn't belong to one
1:      */
0:     public void testCreateOtherSchemaSequence() throws SQLException {
1:         // create DB
1:         Connection adminCon = openUserConnection(TEST_DBO);
1: 
1:         Connection alphaCon = openUserConnection(ALPHA);
1:         Statement stmtAlpha = alphaCon.createStatement();
1: 
1:         Connection betaCon = openUserConnection(BETA);
1:         Statement stmtBeta = betaCon.createStatement();
1: 
1:         // should implicitly create schema ALPHA
1:         assertStatementError("42507", stmtBeta, "CREATE SEQUENCE alpha.alpha_seq3");
1: 
1:         stmtAlpha.close();
1:         stmtBeta.close();
1:         alphaCon.close();
1:         betaCon.close();
1:         adminCon.close();
1:     }
1: 
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:d9b64a6
/////////////////////////////////////////////////////////////////////////
1:         //DERBY-6176 (Couple failures in SequenceGeneratorTest suite on 
1:         // trunk(1466748) with weme 6.2. Disabling the test for small
1:         // devices.
1:         if ( JDBC.vmSupportsJSR169() ) { return; }
0:         
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6afbd85
/////////////////////////////////////////////////////////////////////////
1:         s.execute("DROP SEQUENCE mySeq1 restrict");
author:Ole Solberg
-------------------------------------------------------------------------------
commit:c4caf0a
/////////////////////////////////////////////////////////////////////////
0:     public void testDuplicateCreationFailure() throws SQLException {
1:         Statement s = null;
1:             s = createStatement();
1:         }finally{
0:             s.executeUpdate("DROP SEQUENCE mySeq1"); // Drop the one created.
/////////////////////////////////////////////////////////////////////////
1:         // Cleanup:
0:         stmtAlpha.executeUpdate("DROP SEQUENCE alpha_seq");
0:         
/////////////////////////////////////////////////////////////////////////
1:         stmtAlpha.executeUpdate("CREATE SEQUENCE alpha_seq");
/////////////////////////////////////////////////////////////////////////
1:         // Cleanup:
0:         stmtAlpha.executeUpdate("DROP SEQUENCE alpha_seq");
0:         
============================================================================