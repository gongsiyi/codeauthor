1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.io.ArrayInputStream
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
17:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.services.io;
1:eac0369: 
1:eac0369: import java.io.InputStream;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.EOFException;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import java.io.UTFDataFormatException;
1:eac0369: 
2:eac0369: /**
1:eac0369: 	An InputStream that allows reading from an array of bytes. The array
1:eac0369: 	of bytes that is read from can be changed without having to create a new
1:eac0369: 	instance of this class.
1:eac0369: */
1:eac0369: public final class ArrayInputStream extends InputStream implements LimitObjectInput {
1:eac0369: 
1:eac0369: 	private byte[] pageData;
1:eac0369: 
1:eac0369: 	private int		start;
1:eac0369: 	private int		end;		// exclusive
1:eac0369: 	private int		position;
1:eac0369: 
1:8360656: 	/**
1:8360656: 	 * Create an ArrayInputStream with a zero length byte array.
1:8360656: 	 * The position is set to 0 and the limit is the entire byte array.
1:8360656: 	 *
1:8360656: 	 */
1:eac0369: 	public ArrayInputStream() {
1:bb5be6f: 		this(ArrayUtil.EMPTY_BYTE_ARRAY);
12:eac0369: 	}
1:eac0369: 
1:eac0369: 	private ErrorObjectInput oi;
1:eac0369: 
1:8360656: 	/**
1:8360656: 	 * Create an ArrayInputStream with the passed in data.
1:8360656: 	 * The position is set to 0 and the limit is the entire byte array.
1:8360656: 	 * @param data
1:8360656: 	 */
1:eac0369: 	public ArrayInputStream(byte[] data) {
1:eac0369: 		super();
1:eac0369: 		setData(data);
1:eac0369: 		oi = new org.apache.derby.iapi.services.io.FormatIdInputStream(this);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Public methods
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the array of bytes to be read.
1:8360656: 		Position is set to zero.
1:eac0369: 	*/
1:eac0369: 	public void setData(byte[] data) {
2:eac0369: 		pageData = data;
1:8360656: 		start = position = 0;
1:8360656: 		end = data.length;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a reference to the array of bytes this stream is going to read
1:eac0369: 		from so that caller may load it with stuff 
1:eac0369: 	*/
1:eac0369: 	public byte[] getData()
5:eac0369: 	{
1:eac0369: 		return pageData;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of InputStream
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public int read() throws IOException {
1:eac0369: 		if (position == end)
2:eac0369: 			return -1; // end of file
1:eac0369: 
1:eac0369: 		return pageData[position++] & 0xff ;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int read(byte b[], int off, int len) throws IOException {
1:33fa320:         final int available = available();
1:eac0369: 
1:33fa320:         if (len > available) {
1:33fa320:             // attempted to read more bytes than available
1:eac0369: 
1:33fa320:             if (available == 0) {
1:33fa320:                 // no bytes available, return -1 to report end of file
1:33fa320:                 return -1;
1:33fa320:             }
1:eac0369: 
1:33fa320:             // read all the available bytes
1:33fa320:             len = available;
1:33fa320:         }
1:eac0369: 
1:eac0369: 		System.arraycopy(pageData, position, b, off, len);
1:eac0369: 		position += len;
1:eac0369: 		return len;
1:eac0369: 	}
1:eac0369: 
1:50af304:     /**
1:50af304:      * Skip as many bytes as possible, but no more than {@code count}.
1:50af304:      *
1:50af304:      * @param count the number of bytes to skip
1:50af304:      * @return the number of bytes that were skipped
1:50af304:      */
1:eac0369: 	public long skip(long count)  throws IOException {
1:eac0369: 
1:50af304:         // return 0 on non-positive count, per javadoc for
1:50af304:         // InputStream.skip(long)
1:50af304:         if (count <= 0) {
1:50af304:             return 0;
1:50af304:         }
1:eac0369: 
1:50af304:         // don't skip more bytes than we have available
1:50af304:         long toSkip = Math.min(count, available());
1:50af304:         position += toSkip;
1:50af304:         return toSkip;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int getPosition() {
1:eac0369: 		return position;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public final void setPosition(int newPosition)
1:eac0369: 		throws IOException {
1:eac0369: 
1:eac0369:         if ((newPosition >= start) && (newPosition < end))
1:eac0369:             position = newPosition;
3:eac0369:         else
3:eac0369: 			throw new EOFException();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int available() throws IOException {
1:eac0369: 
1:eac0369: 		return end - position;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:50af304: 	/**
1:eac0369: 		A setLimit which also sets the position to be offset.
1:eac0369: 
1:eac0369: 		@exception IOException limit is out of range 
1:eac0369: 	*/
1:ca42415: 	public void setLimit(int offset, int length) throws IOException {
1:eac0369: 
1:eac0369: 		start = offset;
1:eac0369: 		end = offset + length;
1:ca42415: 		position = start;
1:eac0369: 
1:ca42415: 		if ((offset < 0) || (length < 0) || (end > pageData.length)) {
3:eac0369: 			start = end = position = 0;
1:eac0369: 			throw new EOFException();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of Limit
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public final void setLimit(int length) throws IOException {
1:eac0369: 
1:eac0369:         start = position;
1:eac0369:         end   = position + length;
1:eac0369: 
1:ca42415:         if (end > pageData.length) {
1:eac0369: 			start = end = position = 0;
1:eac0369: 			throw new EOFException();
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Clears the limit by setting the limit to be the entire byte array.
1:eac0369: 
1:eac0369: 		@see Limit#clearLimit
1:eac0369: 	*/
1:eac0369: 	public final int clearLimit() {
1:8360656:         start = 0;
1:8360656:         int remainingBytes = end - position;
1:8360656:         end = pageData.length;
1:8360656:         return remainingBytes;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of DataInput
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     public final void readFully(byte b[]) throws IOException {
1:eac0369: 		readFully(b, 0, b.length);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final void readFully(byte b[], int off, int len) throws IOException {
1:eac0369: 
1:33fa320: 		if (len > available()) {
1:eac0369: 			throw new EOFException();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		System.arraycopy(pageData, position, b, off, len);
1:eac0369: 		position += len;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:50af304:      * Skip as many bytes as possible, but no more than {@code n}.
1:50af304:      *
1:50af304:      * @param n the number of bytes to skip
1:50af304:      * @return the number of bytes that were skipped
1:50af304:      */
1:eac0369:     public final int skipBytes(int n) throws IOException {
1:50af304:         return (int) skip(n);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final boolean readBoolean() throws IOException {
1:eac0369: 		if (position == end)
2:eac0369: 			throw new EOFException(); // end of file
1:eac0369: 
1:eac0369: 		return pageData[position++] != 0;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final byte readByte() throws IOException {
1:eac0369: 		if (position == end)
1:eac0369: 			throw new EOFException(); // end of file
1:eac0369: 
1:eac0369: 		return pageData[position++];
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final int readUnsignedByte() throws IOException {
1:eac0369: 		if (position == end)
1:eac0369: 			throw new EOFException(); // end of file
1:eac0369: 
1:eac0369: 		return pageData[position++] & 0xff ;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final short readShort() throws IOException {
1:eac0369: 
1:eac0369: 		int pos = position;
1:eac0369: 		byte[] data = pageData;
1:eac0369: 
1:eac0369: 		if (pos >= (end - 1))
1:eac0369: 			throw new EOFException(); // end of file
1:eac0369: 
1:eac0369: 		int s = ((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff);
1:eac0369: 
1:eac0369: 		position = pos;
1:eac0369: 
1:eac0369: 		return (short) s;
1:eac0369:     }
1:eac0369: 
1:eac0369:    public final int readUnsignedShort() throws IOException {
1:eac0369:  		int    pos  = position;
1:eac0369: 		byte[] data = pageData;
1:eac0369: 
1:eac0369: 		if (pos >= (end - 1))
1:eac0369: 			throw new EOFException(); // end of file
1:eac0369: 
1:eac0369: 		int us = ((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff);
1:eac0369: 
1:eac0369: 		position = pos;
1:eac0369: 
1:eac0369: 		return us;
1:eac0369:    }
1:eac0369: 
1:eac0369:     public final char readChar() throws IOException {
1:eac0369:  		int    pos  = position;
1:eac0369: 		byte[] data = pageData;
1:eac0369: 
1:eac0369: 		if (pos >= (end -1))
1:eac0369: 			throw new EOFException(); // end of file
1:eac0369: 
1:eac0369: 		int c = ((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff);
1:eac0369: 
1:eac0369: 		position = pos;
1:eac0369: 
1:eac0369: 		return (char) c;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final int readInt() throws IOException {
1:eac0369: 
1:eac0369:  		int pos = position;
1:eac0369: 		byte[] data = pageData;
1:eac0369: 
1:eac0369: 		if (pos >= (end - 3))
1:eac0369: 			throw new EOFException(); // end of file
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 		int i = ((data[pos++] & 0xff) << 24) |
1:eac0369:                 ((data[pos++] & 0xff) << 16) |
1:eac0369:                 ((data[pos++] & 0xff) <<  8) |
1:eac0369:                 ((data[pos++] & 0xff)      );
1:eac0369: 
1:eac0369: 		position = pos;
1:eac0369: 
1:eac0369: 		return i;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final long readLong() throws IOException {
1:eac0369:  		int    pos  = position;
1:eac0369: 		byte[] data = pageData;
1:eac0369: 
1:eac0369: 		if (pos >= (end - 7))
1:eac0369: 			throw new EOFException(); // end of file
1:eac0369: 
1:eac0369: 		long l = 
1:eac0369:             (((long) (data[pos++] & 0xff)) << 56) |
1:eac0369:             (((long) (data[pos++] & 0xff)) << 48) |
1:eac0369:             (((long) (data[pos++] & 0xff)) << 40) |
1:eac0369:             (((long) (data[pos++] & 0xff)) << 32) |
1:eac0369:             (((long) (data[pos++] & 0xff)) << 24) |
1:eac0369:             (((long) (data[pos++] & 0xff)) << 16) |
1:eac0369:             (((long) (data[pos++] & 0xff)) <<  8) | 
1:eac0369:             (((long) (data[pos++] & 0xff))      );
1:eac0369: 
1:eac0369: 		position = pos;
1:eac0369: 
1:eac0369: 		return l;
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final float readFloat() throws IOException {
1:eac0369: 		return Float.intBitsToFloat(readInt());
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final double readDouble() throws IOException {
1:eac0369: 		return Double.longBitsToDouble(readLong());
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final String readLine() throws IOException {
1:eac0369: 		return oi.readLine();
1:eac0369:     }
1:eac0369:     public final String readUTF() throws IOException {
1:eac0369: 		return oi.readUTF();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:3fd26f3:      * read in a Derby UTF formated string into a char[].
1:eac0369:      * <p>
1:eac0369:      * This routine inline's the code to read a UTF format string from a
1:eac0369:      * byte[] array (pageData), into a char[] array.  The string will
1:eac0369:      * be read into the char[] array passed into this routine through
1:eac0369:      * rawData_array[0] if it is big enough.  If it is not big enough
1:eac0369:      * a new char[] will be alocated and returned to the caller by putting
1:eac0369:      * it into rawData_array[0].
1:eac0369:      * <p>
1:3fd26f3:      * To see detailed description of the Derby UTF format see
1:eac0369:      * the writeExternal() routine of SQLChar.
1:eac0369:      * <p>
1:eac0369:      * The routine returns the number of char's read into the returned
1:eac0369:      * char[], note that this length may smaller than the actual length
1:eac0369:      * of the char[] array.
1:6f4c92a:      * <p>
1:6f4c92a:      * The stream must be positioned on the first user byte when this method
1:6f4c92a:      * is invoked.
1:eac0369:      *
1:eac0369: 	 * @return The the number of valid char's in the returned char[].
1:eac0369:      *
1:eac0369:      * @param rawData_array This parameter uses a element array to implement
1:eac0369:      *                      an in/out function parameter.  The char[] array
1:eac0369:      *                      in rawData_array[0] is used to read the data into
1:eac0369:      *                      unless it is not big enough, then a new array
1:eac0369:      *                      is allocated and the old one discarded.  In 
1:eac0369:      *                      either case on return rawData_array[0] contains
1:eac0369:      *                      the filled in char[] - caller must allow that
1:eac0369:      *                      the array may or may not be different from the
1:eac0369:      *                      one passed in.
1:6f4c92a:      * @param utflen the byte length of the value, or {@code 0} if unknown
1:eac0369:      *
1:f668d94:      * @exception IOException if an I/O error happens
1:eac0369:      **/
1:6f4c92a:     public final int readDerbyUTF(char[][] rawData_array, int utflen)
1:eac0369:         throws IOException
1:eac0369: 	{
1:eac0369:         // copy globals locally, to give compiler chance to optimize.
1:eac0369:         byte[]  data    = pageData;
1:eac0369:         int     end_pos = end;
1:eac0369:  		int     pos     = position;
1:eac0369: 
1:eac0369:         /**
1:eac0369:          * 3 cases - can they all happen?
1:eac0369:          *
1:eac0369:          * o utflen == 0 and end is marked E0, 0, 0
1:eac0369:          * o utflen == 0 and there is no data (ie. 0 length string)
1:eac0369:          * o utflen != 0, utflen is exact length of following bytes
1:eac0369:          **/
1:eac0369: 
1:eac0369:         // requiredLength is the amount of bytes to read from the array,
1:eac0369:         // either the utflen in the header length, or the number of bytes
1:eac0369:         // available in the array.  Throw an exception if we know up front
1:eac0369:         // that utflen is bigger than number of bytes in the array.
1:eac0369: 		int requiredLength;
1:eac0369:         if (utflen != 0)
1:eac0369:         {
1:eac0369:             // this is the only place we need to check for end of file, 
1:eac0369:             // the subsequent loop will not read past bytes_available_in_array.
1:eac0369: 
1:eac0369:             if (utflen <= (end_pos - pos))
1:eac0369:             {
1:eac0369:                 requiredLength = utflen;
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 throw new EOFException();
1:eac0369:             }
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // the byte header returned 0, so read what is left in the array.
1:eac0369:             
1:eac0369:             requiredLength = (end_pos - pos);
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Use the passed in char[] array if it is long enough, otherwise
1:eac0369:         // allocate a new array, and will pass it back to caller at the end.
1:eac0369:         // Note that requiredLength is the worst case length for the array,
1:eac0369:         // as the number of char characters must be <= number of bytes (ie.
1:eac0369:         // all characters were stored compressed in 1 byte each - the ascii
1:eac0369:         // default) - if there are any 2 or 3 byte stored characters then
1:eac0369:         // the array will have extra space at the end.  "strlen" tracks the
1:eac0369:         // real number of char's in str[].
1:eac0369:         char[] str = rawData_array[0];
1:eac0369: 		if ((str == null) || (requiredLength > str.length)) 
1:eac0369:         {
1:eac0369: 			str = new char[requiredLength];
1:eac0369:             rawData_array[0] = str;
1:eac0369: 		} 
1:eac0369: 
1:eac0369:         end_pos = pos + requiredLength;
1:eac0369:         int strlen = 0;
1:eac0369: 
1:eac0369:         while (pos < end_pos)
1:eac0369:         {
1:eac0369: 			int char1 = (data[pos++] & 0xff);
1:eac0369: 
1:eac0369: 			// top fours bits of the first unsigned byte that maps to a 1,2 
1:eac0369:             // or 3 byte character
1:eac0369: 			//
1:eac0369: 			// 0000xxxx	- 0 - 1 byte char
1:eac0369: 			// 0001xxxx - 1 - 1 byte char
1:eac0369: 			// 0010xxxx - 2 - 1 byte char
1:eac0369: 			// 0011xxxx - 3 - 1 byte char
1:eac0369: 			// 0100xxxx - 4 - 1 byte char
1:eac0369: 			// 0101xxxx - 5 - 1 byte char
1:eac0369: 			// 0110xxxx - 6 - 1 byte char
1:eac0369: 			// 0111xxxx - 7 - 1 byte char
1:eac0369: 			// 1000xxxx - 8 - error
1:eac0369: 			// 1001xxxx - 9 - error
1:eac0369: 			// 1010xxxx - 10 - error
1:eac0369: 			// 1011xxxx - 11 - error
1:eac0369: 			// 1100xxxx - 12 - 2 byte char
1:eac0369: 			// 1101xxxx - 13 - 2 byte char
1:eac0369: 			// 1110xxxx - 14 - 3 byte char
1:eac0369: 			// 1111xxxx - 15 - error
1:eac0369: 
1:eac0369: 			int char2, char3;
1:eac0369: 			if ((char1 & 0x80) == 0x00)
1:eac0369: 			{
1:eac0369: 				// one byte character
1:eac0369: 				str[strlen++] = (char) char1;
1:eac0369: 			}
1:eac0369: 			else if ((char1 & 0x60) == 0x40) // we know the top bit is set here
1:eac0369: 			{ 
1:eac0369: 				// two byte character, make sure read of next byte is in bounds.
1:eac0369:                 if (pos >= end_pos)
1:eac0369: 					throw new UTFDataFormatException();		  
1:eac0369: 
1:eac0369:                 char2 = (data[pos++] & 0xff);
1:eac0369: 
1:eac0369: 				if ((char2 & 0xC0) != 0x80)
1:eac0369: 					throw new UTFDataFormatException();		  
1:eac0369: 
1:eac0369: 				str[strlen++] = (char)(((char1 & 0x1F) << 6) | (char2 & 0x3F));
1:eac0369: 			}
1:eac0369: 			else if ((char1 & 0x70) == 0x60) // we know the top bit is set here
1:eac0369: 			{
1:eac0369: 				// three byte character
1:eac0369: 
1:eac0369: 				// 3 byte character, make sure read of next 2 bytes in bounds.
1:eac0369:                 if (pos + 1 >= end_pos)
1:eac0369: 					throw new UTFDataFormatException();		  
1:eac0369: 
1:eac0369:                 char2 = (data[pos++] & 0xff);
1:eac0369:                 char3 = (data[pos++] & 0xff);
1:eac0369: 
1:eac0369: 				if ((char1 == 0xE0) && 
1:eac0369:                     (char2 ==    0) && 
1:eac0369:                     (char3 ==    0) && 
1:eac0369:                     (utflen == 0))
1:eac0369: 				{
1:eac0369: 					// we reached the end of a long string,
1:eac0369: 					// that was terminated with
1:eac0369: 					// (11100000, 00000000, 00000000)
1:eac0369:                     break;
1:eac0369: 				}
1:eac0369:                 else if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
1:eac0369:                 {
1:eac0369: 					throw new UTFDataFormatException();		  
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     str[strlen++] = (char)
1:eac0369:                         (((char1 & 0x0F) << 12) | 
1:eac0369:                          ((char2 & 0x3F) <<  6) | 
1:eac0369:                          ((char3 & 0x3F) <<  0));
1:eac0369:                 }
1:eac0369: 			}
1:eac0369: 			else 
1:eac0369:             {
1:eac0369: 				throw new UTFDataFormatException();
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369:         // update global on successful read exit.
1:eac0369:         position = pos;
1:eac0369: 
1:eac0369:         return(strlen);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Read a compressed int from the stream.
1:eac0369:      * <p>
1:eac0369:      * Read a compressed int from the stream, which is assumed to have
1:eac0369:      * been written by a call to CompressNumber.writeInt().
1:eac0369:      * <p>
1:eac0369:      * Code from CompressedNumber is inlined here so that these fields can
1:eac0369:      * be read from the array with a minimum of function calls.
1:eac0369:      * <p>
1:eac0369:      * The format of a compressed int is as follows:
1:eac0369:      *
1:eac0369:      * Formats are (with x representing value bits):
1:eac0369:      * <PRE>
1:dbed020:      * 1 Byte- 00xxxxxx                            val &lt;= 63 (0x3f)
1:dbed020:      * 2 Byte- 01xxxxxx xxxxxxxx                   val &gt; 63 &amp;&amp; &lt;= 16383 (0x3fff)
1:dbed020:      * 4 byte- 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx val &gt; 16383 &amp;&amp; &lt;= MAX_INT
1:eac0369:      * </PRE>
1:eac0369:      *
1:f668d94:      * @exception IOException if an I/O error happens
1:eac0369:      **/
1:eac0369:     public final int readCompressedInt()
1:eac0369:         throws IOException
1:eac0369:     {
1:eac0369:  		int    pos  = position;
1:eac0369: 		byte[] data = pageData;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             int value = data[pos++];
1:eac0369: 
1:eac0369:             if ((value & ~0x3f) == 0)
1:eac0369:             {
1:eac0369:                 // entire value is stored in this byte, we also know that the 
1:eac0369:                 // 0x80 bit was not set, so no need to mask off the sign 
1:eac0369:                 // extension from the byte to int conversion.
1:eac0369:             }
1:eac0369:             else if ((value & 0x80) == 0)
1:eac0369:             {
1:eac0369:                 // value stored in 2 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT((value & 0x40) == 0x40);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // top 8 bits of 2 byte value is stored in this byte, we also 
1:eac0369:                 // know that the 0x80 bit was not set, so no need to mask off 
1:eac0369:                 // the sign extension from the 1st byte to int conversion.  
1:eac0369:                 // Need to mask the byte in data[pos + 1] to account for 
1:eac0369:                 // possible sign extension.
1:eac0369: 
1:eac0369:                 value = 
1:eac0369:                     (((value & 0x3f) << 8) | (data[pos++] & 0xff));
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 // value stored in 4 bytes.  only use low 7 bits from 1st byte.
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.ASSERT((value & 0x80) == 0x80);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // top 8 bits of 4 byte value is stored in this byte, we also 
1:eac0369:                 // know that the 0x80 bit was set, so need to mask off the 
1:eac0369:                 // sign extension from the 1st byte to int conversion.  Need to
1:eac0369:                 // mask the bytes from the next 3 bytes data[pos + 1,2,3] to 
1:eac0369:                 // account for possible sign extension.
1:eac0369:                 //
1:eac0369: 
1:eac0369:                 value = 
1:eac0369:                     ((value       & 0x7f) << 24) |
1:eac0369:                     ((data[pos++] & 0xff) << 16) |
1:eac0369:                     ((data[pos++] & 0xff) <<  8) |
1:eac0369:                     ((data[pos++] & 0xff)      );
1:eac0369:             }
1:eac0369: 
1:eac0369:             position = pos;
1:eac0369: 
1:eac0369:             return(value);
1:eac0369:         }
1:eac0369:         catch (java.lang.ArrayIndexOutOfBoundsException ex)
1:eac0369:         {
1:eac0369: 			throw new EOFException(); // end of file
1:eac0369:         }
1:eac0369: 
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Read a compressed long from the stream.
1:eac0369:      * <p>
1:eac0369:      * Read a compressed long from the stream, which is assumed to have
1:eac0369:      * been written by a call to CompressNumber.writeLong().
1:eac0369:      * <p>
1:eac0369:      * Code from CompressedNumber is inlined here so that these fields can
1:eac0369:      * be read from the array with a minimum of function calls.
1:eac0369:      * <p>
1:eac0369:      * The format of a compressed int is as follows:
1:eac0369:      *
1:eac0369:      * Formats are (with x representing value bits):
1:eac0369:      * <PRE>
1:dbed020:      * value &gl;= 16383 (0x3fff): 
1:eac0369:      *     2 byte - 00xxxxxx xxxxxxxx 
1:eac0369:      *
1:dbed020:      * value &gt; 16383 &amp;&amp; &lt;= 0x3fffffff:
1:eac0369:      *     4 byte - 01xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
1:eac0369:      *
1:dbed020:      * value &lt; 0x3fffffff &amp;&lt; &lt;= MAX_LONG:
1:eac0369:      *     8 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
1:eac0369:      * </PRE>
1:eac0369:      *
1:eac0369:      **/
1:eac0369:     public final long readCompressedLong()
1:eac0369:         throws IOException
1:eac0369:     {
1:eac0369:         try
1:eac0369:         {
1:eac0369:             // copy globals locally, to give compiler chance to optimize.
1:eac0369:             int     pos         = position;
1:eac0369:             byte[]  data        = pageData;
1:eac0369: 
1:eac0369:             // int_value tells whether it is 1, 4, or 8 bytes long.
1:eac0369:             int     int_value   = data[pos++];
1:eac0369: 
1:eac0369:             // build up long value and return it through this variable.
1:eac0369:             long    long_value;
1:eac0369: 
1:eac0369:             if ((int_value & ~0x3f) == 0)
1:eac0369:             {
1:eac0369:                 // 2 byte representation
1:eac0369: 
1:eac0369:                 // 1st byte of value is stored in int_value, we also know that 
1:eac0369:                 // the 0x80 bit was not set, so no need to mask off the sign 
1:eac0369:                 // extension from the 1st byte to int conversion.
1:eac0369:                 long_value = ((int_value << 8) | (data[pos++] & 0xff));
1:eac0369:             }
1:eac0369:             else if ((int_value & 0x80) == 0)
1:eac0369:             {
1:eac0369:                 // value stored in 4 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:                 // Need to mask the bytes from the next 3 bytes 
1:eac0369:                 // data[pos + 1,2,3] to account for possible sign extension.
1:eac0369: 
1:eac0369:                 long_value = 
1:eac0369:                     ((int_value   & 0x3f) << 24) |
1:eac0369:                     ((data[pos++] & 0xff) << 16) |
1:eac0369:                     ((data[pos++] & 0xff) <<  8) |
1:eac0369:                     ((data[pos++] & 0xff)      );
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:2378df1:                 // top 7 bits of 8 byte value is stored in int_value, we also
1:eac0369:                 // know that the 0x80 bit was set, so need to mask off the 
1:eac0369:                 // sign extension from the 1st byte to int conversion.  Need to
1:eac0369:                 // mask the bytes from the next 7 bytes data[pos + 1,2,...] to 
1:eac0369:                 // account for possible sign extension.
1:eac0369:                 //
1:eac0369: 
1:2378df1:                 // value stored in 8 bytes.  only use low 7 bits from 1st byte.
1:eac0369:                 long_value = 
1:eac0369:                     (((long) (int_value   & 0x7f)) << 56) |
1:eac0369:                     (((long) (data[pos++] & 0xff)) << 48) |
1:eac0369:                     (((long) (data[pos++] & 0xff)) << 40) |
1:eac0369:                     (((long) (data[pos++] & 0xff)) << 32) |
1:eac0369:                     (((long) (data[pos++] & 0xff)) << 24) |
1:eac0369:                     (((long) (data[pos++] & 0xff)) << 16) |
1:eac0369:                     (((long) (data[pos++] & 0xff)) <<  8) |
1:eac0369:                     (((long) (data[pos++] & 0xff))      );
1:eac0369:             }
1:eac0369: 
1:eac0369:             position = pos;
1:eac0369: 
1:eac0369:             return(long_value);
1:eac0369:         }
1:eac0369:         catch (java.lang.ArrayIndexOutOfBoundsException ex)
1:eac0369:         {
1:eac0369:             // let java figure out if we went past end of data[] array.
1:eac0369:             
1:eac0369: 			throw new EOFException(); // end of file
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369: 	public Object readObject() throws ClassNotFoundException, IOException {
1:eac0369: 		return oi.readObject();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String getErrorInfo()  {
1:eac0369: 		return oi.getErrorInfo();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public Exception getNestedException() {
1:eac0369:         return oi.getNestedException();
1:eac0369:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * 1 Byte- 00xxxxxx                            val &lt;= 63 (0x3f)
1:      * 2 Byte- 01xxxxxx xxxxxxxx                   val &gt; 63 &amp;&amp; &lt;= 16383 (0x3fff)
1:      * 4 byte- 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx val &gt; 16383 &amp;&amp; &lt;= MAX_INT
/////////////////////////////////////////////////////////////////////////
1:      * value &gl;= 16383 (0x3fff): 
1:      * value &gt; 16383 &amp;&amp; &lt;= 0x3fffffff:
1:      * value &lt; 0x3fffffff &amp;&lt; &lt;= MAX_LONG:
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:bb5be6f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		this(ArrayUtil.EMPTY_BYTE_ARRAY);
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:      * @exception IOException if an I/O error happens
/////////////////////////////////////////////////////////////////////////
1:      * @exception IOException if an I/O error happens
commit:33fa320
/////////////////////////////////////////////////////////////////////////
1:         final int available = available();
1:         if (len > available) {
1:             // attempted to read more bytes than available
1:             if (available == 0) {
1:                 // no bytes available, return -1 to report end of file
1:                 return -1;
1:             }
1:             // read all the available bytes
1:             len = available;
1:         }
/////////////////////////////////////////////////////////////////////////
1: 		if (len > available()) {
commit:50af304
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Skip as many bytes as possible, but no more than {@code count}.
1:      *
1:      * @param count the number of bytes to skip
1:      * @return the number of bytes that were skipped
1:      */
1:         // return 0 on non-positive count, per javadoc for
1:         // InputStream.skip(long)
1:         if (count <= 0) {
1:             return 0;
1:         }
1:         // don't skip more bytes than we have available
1:         long toSkip = Math.min(count, available());
1:         position += toSkip;
1:         return toSkip;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Skip as many bytes as possible, but no more than {@code n}.
1:      *
1:      * @param n the number of bytes to skip
1:      * @return the number of bytes that were skipped
1:      */
1:         return (int) skip(n);
commit:d779ab1
/////////////////////////////////////////////////////////////////////////
0:             n = end - position;
commit:2378df1
/////////////////////////////////////////////////////////////////////////
1:                 // top 7 bits of 8 byte value is stored in int_value, we also
1:                 // value stored in 8 bytes.  only use low 7 bits from 1st byte.
commit:ca42415
/////////////////////////////////////////////////////////////////////////
1: 	public void setLimit(int offset, int length) throws IOException {
1: 		position = start;
1: 		if ((offset < 0) || (length < 0) || (end > pageData.length)) {
/////////////////////////////////////////////////////////////////////////
1:         if (end > pageData.length) {
commit:8360656
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.util.ReuseFactory;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Create an ArrayInputStream with a zero length byte array.
1: 	 * The position is set to 0 and the limit is the entire byte array.
1: 	 *
1: 	 */
0: 		this(ReuseFactory.getZeroLenByteArray());
1: 	/**
1: 	 * Create an ArrayInputStream with the passed in data.
1: 	 * The position is set to 0 and the limit is the entire byte array.
1: 	 * @param data
1: 	 */
1: 		Position is set to zero.
1: 		start = position = 0;
1: 		end = data.length;
/////////////////////////////////////////////////////////////////////////
1:         start = 0;
1:         int remainingBytes = end - position;
1:         end = pageData.length;
1:         return remainingBytes;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6f4c92a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * The stream must be positioned on the first user byte when this method
1:      * is invoked.
/////////////////////////////////////////////////////////////////////////
1:      * @param utflen the byte length of the value, or {@code 0} if unknown
1:     public final int readDerbyUTF(char[][] rawData_array, int utflen)
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1:      * read in a Derby UTF formated string into a char[].
/////////////////////////////////////////////////////////////////////////
1:      * To see detailed description of the Derby UTF format see
/////////////////////////////////////////////////////////////////////////
0:     public final int readDerbyUTF(char[][] rawData_array) 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.io.ArrayInputStream
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.io
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.io;
1: 
1: import java.io.InputStream;
1: import java.io.IOException;
0: import java.io.ObjectInput;
1: import java.io.EOFException;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.LimitObjectInput;
0: import org.apache.derby.iapi.services.io.ErrorObjectInput;
1: 
1: import java.io.UTFDataFormatException;
1: 
1: /**
1: 	An InputStream that allows reading from an array of bytes. The array
1: 	of bytes that is read from can be changed without having to create a new
1: 	instance of this class.
1: */
1: public final class ArrayInputStream extends InputStream implements LimitObjectInput {
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	private byte[] pageData;
1: 
1: 	private int		start;
1: 	private int		end;		// exclusive
1: 	private int		position;
1: 
1: 	public ArrayInputStream() {
0: 		this(null);
1: 	}
1: 
1: 	private ErrorObjectInput oi;
1: 
1: 	public ArrayInputStream(byte[] data) {
1: 		super();
1: 		setData(data);
1: 		oi = new org.apache.derby.iapi.services.io.FormatIdInputStream(this);
1: 	}
1: 
0: 	public ArrayInputStream(byte[] data, int offset, int length) throws IOException {
0: 		this(data);
0: 		setLimit(offset, length);
1: 	}
1: 
1: 	/*
1: 	** Public methods
1: 	*/
1: 
1: 	/**
1: 		Set the array of bytes to be read.
1: 	*/
1: 	public void setData(byte[] data) {
1: 		pageData = data;
0: 		clearLimit();
1: 	}
1: 
0: 	public void setData(byte[] data, int offset, int length) throws IOException {
1: 		pageData = data;
0: 		setLimit(offset, length);
1: 	}
1: 
1: 	/**
1: 		Return a reference to the array of bytes this stream is going to read
1: 		from so that caller may load it with stuff 
1: 	*/
1: 	public byte[] getData()
1: 	{
1: 		return pageData;
1: 	}
1: 
1: 	/*
1: 	** Methods of InputStream
1: 	*/
1: 
1: 	public int read() throws IOException {
1: 		if (position == end)
1: 			return -1; // end of file
1: 
1: 		return pageData[position++] & 0xff ;
1: 
1: 	}
1: 
1: 	public int read(byte b[], int off, int len) throws IOException {
1: 
0: 		if ((position + len) > end) {
1: 
0: 			len = end - position;
1: 
0: 			if (len == 0) {
1: 				return -1; // end of file
1: 			}
1: 		}
1: 
1: 		System.arraycopy(pageData, position, b, off, len);
1: 		position += len;
1: 		return len;
1: 	}
1: 
1: 	public long skip(long count)  throws IOException {
1: 
0: 		if ((position + count) > end) {
1: 
0: 			count = end - position;
1: 
0: 			if (count == 0)
0: 				return 0; // end of file
1: 		}
1: 
0: 		position += count;
1: 
0: 		return count;
1: 
1: 	}
1: 
1: 	public int getPosition() {
1: 		return position;
1: 	}
1: 
1: 	public final void setPosition(int newPosition)
1: 		throws IOException {
1: 
1:         if ((newPosition >= start) && (newPosition < end))
1:             position = newPosition;
1:         else
1: 			throw new EOFException();
1: 	}
1: 
1: 	public int available() throws IOException {
1: 
1: 		return end - position;
1: 	}
1: 
1: 
1: 	/**
1: 		A setLimit which also sets the position to be offset.
1: 
1: 		@exception IOException limit is out of range 
1: 	*/
0: 	public int setLimit(int offset, int length) throws IOException {
1: 
0: 		if ((offset < 0) || (length < 0)) {
1: 			start = end = position = 0;
1: 			throw new EOFException();
1: 		}
1: 
1: 		start = offset;
1: 		end = offset + length;
1: 
0: 		if (end > pageData.length) {
1: 			start = end = position = 0;
1: 			throw new EOFException();
1: 		}
1: 
0: 		position = start;
1: 
0: 		return length;
1: 	}
1: 
1: 	/*
1: 	** Methods of Limit
1: 	*/
1: 
1: 	public final void setLimit(int length) throws IOException {
1: 
1:         start = position;
1:         end   = position + length;
1: 
0:         if (end <= pageData.length)
1:         {
0:             return;
1:         }
1:         else
1:         {
1: 			start = end = position = 0;
1: 			throw new EOFException();
1:         }
1: 	}
1: 
1: 	/**
1: 		Clears the limit by setting the limit to be the entire byte array.
1: 
1: 		@see Limit#clearLimit
1: 	*/
1: 	public final int clearLimit() {
1: 
0: 		if (pageData != null) {
0: 			start = 0;
0: 			int remainingBytes = end - position;
0: 			end = pageData.length;
0: 			return remainingBytes;
0: 		} else {
1: 			start = end = position = 0;
0: 			return 0;
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Methods of DataInput
1: 	*/
1: 
1:     public final void readFully(byte b[]) throws IOException {
1: 		readFully(b, 0, b.length);
1:     }
1: 
1:     public final void readFully(byte b[], int off, int len) throws IOException {
1: 
0: 		if ((position + len) > end) {
1: 
1: 			throw new EOFException();
1: 		}
1: 
1: 		System.arraycopy(pageData, position, b, off, len);
1: 		position += len;
1: 	}
1: 
1:     public final int skipBytes(int n) throws IOException {
0: 		if ((position + n) > end) {
1: 
1: 			throw new EOFException();
1: 		}
0: 		position += n;
0: 		return n;
1:     }
1: 
1:     public final boolean readBoolean() throws IOException {
1: 		if (position == end)
1: 			throw new EOFException(); // end of file
1: 
1: 		return pageData[position++] != 0;
1:     }
1: 
1:     public final byte readByte() throws IOException {
1: 		if (position == end)
1: 			throw new EOFException(); // end of file
1: 
1: 		return pageData[position++];
1:     }
1: 
1:     public final int readUnsignedByte() throws IOException {
1: 		if (position == end)
1: 			throw new EOFException(); // end of file
1: 
1: 		return pageData[position++] & 0xff ;
1:     }
1: 
1:     public final short readShort() throws IOException {
1: 
1: 		int pos = position;
1: 		byte[] data = pageData;
1: 
1: 		if (pos >= (end - 1))
1: 			throw new EOFException(); // end of file
1: 
1: 		int s = ((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff);
1: 
1: 		position = pos;
1: 
1: 		return (short) s;
1:     }
1: 
1:    public final int readUnsignedShort() throws IOException {
1:  		int    pos  = position;
1: 		byte[] data = pageData;
1: 
1: 		if (pos >= (end - 1))
1: 			throw new EOFException(); // end of file
1: 
1: 		int us = ((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff);
1: 
1: 		position = pos;
1: 
1: 		return us;
1:    }
1: 
1:     public final char readChar() throws IOException {
1:  		int    pos  = position;
1: 		byte[] data = pageData;
1: 
1: 		if (pos >= (end -1))
1: 			throw new EOFException(); // end of file
1: 
1: 		int c = ((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff);
1: 
1: 		position = pos;
1: 
1: 		return (char) c;
1:     }
1: 
1:     public final int readInt() throws IOException {
1: 
1:  		int pos = position;
1: 		byte[] data = pageData;
1: 
1: 		if (pos >= (end - 3))
1: 			throw new EOFException(); // end of file
1: 
1: 
1: 
1: 		int i = ((data[pos++] & 0xff) << 24) |
1:                 ((data[pos++] & 0xff) << 16) |
1:                 ((data[pos++] & 0xff) <<  8) |
1:                 ((data[pos++] & 0xff)      );
1: 
1: 		position = pos;
1: 
1: 		return i;
1:     }
1: 
1:     public final long readLong() throws IOException {
1:  		int    pos  = position;
1: 		byte[] data = pageData;
1: 
1: 		if (pos >= (end - 7))
1: 			throw new EOFException(); // end of file
1: 
1: 		long l = 
1:             (((long) (data[pos++] & 0xff)) << 56) |
1:             (((long) (data[pos++] & 0xff)) << 48) |
1:             (((long) (data[pos++] & 0xff)) << 40) |
1:             (((long) (data[pos++] & 0xff)) << 32) |
1:             (((long) (data[pos++] & 0xff)) << 24) |
1:             (((long) (data[pos++] & 0xff)) << 16) |
1:             (((long) (data[pos++] & 0xff)) <<  8) | 
1:             (((long) (data[pos++] & 0xff))      );
1: 
1: 		position = pos;
1: 
1: 		return l;
1:     }
1: 
1:     public final float readFloat() throws IOException {
1: 		return Float.intBitsToFloat(readInt());
1:     }
1: 
1:     public final double readDouble() throws IOException {
1: 		return Double.longBitsToDouble(readLong());
1:     }
1: 
1:     public final String readLine() throws IOException {
1: 		return oi.readLine();
1:     }
1:     public final String readUTF() throws IOException {
1: 		return oi.readUTF();
1:     }
1: 
1:     /**
0:      * read in a cloudscape UTF formated string into a char[].
1:      * <p>
1:      * This routine inline's the code to read a UTF format string from a
1:      * byte[] array (pageData), into a char[] array.  The string will
1:      * be read into the char[] array passed into this routine through
1:      * rawData_array[0] if it is big enough.  If it is not big enough
1:      * a new char[] will be alocated and returned to the caller by putting
1:      * it into rawData_array[0].
1:      * <p>
0:      * To see detailed description of the cloudscape UTF format see
1:      * the writeExternal() routine of SQLChar.
1:      * <p>
1:      * The routine returns the number of char's read into the returned
1:      * char[], note that this length may smaller than the actual length
1:      * of the char[] array.
1:      *
1: 	 * @return The the number of valid char's in the returned char[].
1:      *
1:      * @param rawData_array This parameter uses a element array to implement
1:      *                      an in/out function parameter.  The char[] array
1:      *                      in rawData_array[0] is used to read the data into
1:      *                      unless it is not big enough, then a new array
1:      *                      is allocated and the old one discarded.  In 
1:      *                      either case on return rawData_array[0] contains
1:      *                      the filled in char[] - caller must allow that
1:      *                      the array may or may not be different from the
1:      *                      one passed in.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     public final int readCloudscapeUTF(char[][] rawData_array) 
1:         throws IOException
1: 	{
1:         // copy globals locally, to give compiler chance to optimize.
1:         byte[]  data    = pageData;
1:         int     end_pos = end;
1:  		int     pos     = position;
1: 
0:         // get header length - stored as an unsigned short.
1: 
0: 		int utflen;
0:         if (pos + 1 < end_pos) 
1:         {
0:             utflen = (((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff));
1:         }
1:         else
1:         {
1: 			throw new EOFException(); // end of file
1:         }
1: 
1:         /**
1:          * 3 cases - can they all happen?
1:          *
1:          * o utflen == 0 and end is marked E0, 0, 0
1:          * o utflen == 0 and there is no data (ie. 0 length string)
1:          * o utflen != 0, utflen is exact length of following bytes
1:          **/
1: 
1:         // requiredLength is the amount of bytes to read from the array,
1:         // either the utflen in the header length, or the number of bytes
1:         // available in the array.  Throw an exception if we know up front
1:         // that utflen is bigger than number of bytes in the array.
1: 		int requiredLength;
1:         if (utflen != 0)
1:         {
1:             // this is the only place we need to check for end of file, 
1:             // the subsequent loop will not read past bytes_available_in_array.
1: 
1:             if (utflen <= (end_pos - pos))
1:             {
1:                 requiredLength = utflen;
1:             }
1:             else
1:             {
1:                 throw new EOFException();
1:             }
1:         }
1:         else
1:         {
1:             // the byte header returned 0, so read what is left in the array.
1:             
1:             requiredLength = (end_pos - pos);
1:         }
1: 
1:         // Use the passed in char[] array if it is long enough, otherwise
1:         // allocate a new array, and will pass it back to caller at the end.
1:         // Note that requiredLength is the worst case length for the array,
1:         // as the number of char characters must be <= number of bytes (ie.
1:         // all characters were stored compressed in 1 byte each - the ascii
1:         // default) - if there are any 2 or 3 byte stored characters then
1:         // the array will have extra space at the end.  "strlen" tracks the
1:         // real number of char's in str[].
1:         char[] str = rawData_array[0];
1: 		if ((str == null) || (requiredLength > str.length)) 
1:         {
1: 			str = new char[requiredLength];
1:             rawData_array[0] = str;
1: 		} 
1: 
1:         end_pos = pos + requiredLength;
1:         int strlen = 0;
1: 
1:         while (pos < end_pos)
1:         {
1: 			int char1 = (data[pos++] & 0xff);
1: 
1: 			// top fours bits of the first unsigned byte that maps to a 1,2 
1:             // or 3 byte character
1: 			//
1: 			// 0000xxxx	- 0 - 1 byte char
1: 			// 0001xxxx - 1 - 1 byte char
1: 			// 0010xxxx - 2 - 1 byte char
1: 			// 0011xxxx - 3 - 1 byte char
1: 			// 0100xxxx - 4 - 1 byte char
1: 			// 0101xxxx - 5 - 1 byte char
1: 			// 0110xxxx - 6 - 1 byte char
1: 			// 0111xxxx - 7 - 1 byte char
1: 			// 1000xxxx - 8 - error
1: 			// 1001xxxx - 9 - error
1: 			// 1010xxxx - 10 - error
1: 			// 1011xxxx - 11 - error
1: 			// 1100xxxx - 12 - 2 byte char
1: 			// 1101xxxx - 13 - 2 byte char
1: 			// 1110xxxx - 14 - 3 byte char
1: 			// 1111xxxx - 15 - error
1: 
1: 			int char2, char3;
1: 			if ((char1 & 0x80) == 0x00)
1: 			{
1: 				// one byte character
1: 				str[strlen++] = (char) char1;
1: 			}
1: 			else if ((char1 & 0x60) == 0x40) // we know the top bit is set here
1: 			{ 
1: 				// two byte character, make sure read of next byte is in bounds.
1:                 if (pos >= end_pos)
1: 					throw new UTFDataFormatException();		  
1: 
1:                 char2 = (data[pos++] & 0xff);
1: 
1: 				if ((char2 & 0xC0) != 0x80)
1: 					throw new UTFDataFormatException();		  
1: 
1: 				str[strlen++] = (char)(((char1 & 0x1F) << 6) | (char2 & 0x3F));
1: 			}
1: 			else if ((char1 & 0x70) == 0x60) // we know the top bit is set here
1: 			{
1: 				// three byte character
1: 
1: 				// 3 byte character, make sure read of next 2 bytes in bounds.
1:                 if (pos + 1 >= end_pos)
1: 					throw new UTFDataFormatException();		  
1: 
1:                 char2 = (data[pos++] & 0xff);
1:                 char3 = (data[pos++] & 0xff);
1: 
1: 				if ((char1 == 0xE0) && 
1:                     (char2 ==    0) && 
1:                     (char3 ==    0) && 
1:                     (utflen == 0))
1: 				{
1: 					// we reached the end of a long string,
1: 					// that was terminated with
1: 					// (11100000, 00000000, 00000000)
1:                     break;
1: 				}
1:                 else if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
1:                 {
1: 					throw new UTFDataFormatException();		  
1:                 }
1:                 else
1:                 {
1:                     str[strlen++] = (char)
1:                         (((char1 & 0x0F) << 12) | 
1:                          ((char2 & 0x3F) <<  6) | 
1:                          ((char3 & 0x3F) <<  0));
1:                 }
1: 			}
1: 			else 
1:             {
1: 				throw new UTFDataFormatException();
1: 			}
1: 
1: 		}
1: 
1:         // update global on successful read exit.
1:         position = pos;
1: 
1:         return(strlen);
1: 	}
1: 
1:     /**
1:      * Read a compressed int from the stream.
1:      * <p>
1:      * Read a compressed int from the stream, which is assumed to have
1:      * been written by a call to CompressNumber.writeInt().
1:      * <p>
1:      * Code from CompressedNumber is inlined here so that these fields can
1:      * be read from the array with a minimum of function calls.
1:      * <p>
1:      * The format of a compressed int is as follows:
1:      *
1:      * Formats are (with x representing value bits):
1:      * <PRE>
0:      * 1 Byte- 00xxxxxx                            val <= 63 (0x3f)
0:      * 2 Byte- 01xxxxxx xxxxxxxx                   val > 63 && <= 16383 (0x3fff)
0:      * 4 byte- 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx val > 16383 && <= MAX_INT
1:      * </PRE>
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public final int readCompressedInt()
1:         throws IOException
1:     {
1:  		int    pos  = position;
1: 		byte[] data = pageData;
1: 
1:         try
1:         {
1:             int value = data[pos++];
1: 
1:             if ((value & ~0x3f) == 0)
1:             {
1:                 // entire value is stored in this byte, we also know that the 
1:                 // 0x80 bit was not set, so no need to mask off the sign 
1:                 // extension from the byte to int conversion.
1:             }
1:             else if ((value & 0x80) == 0)
1:             {
1:                 // value stored in 2 bytes.  only use low 6 bits from 1st byte.
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT((value & 0x40) == 0x40);
1:                 }
1: 
1:                 // top 8 bits of 2 byte value is stored in this byte, we also 
1:                 // know that the 0x80 bit was not set, so no need to mask off 
1:                 // the sign extension from the 1st byte to int conversion.  
1:                 // Need to mask the byte in data[pos + 1] to account for 
1:                 // possible sign extension.
1: 
1:                 value = 
1:                     (((value & 0x3f) << 8) | (data[pos++] & 0xff));
1:             }
1:             else
1:             {
1:                 // value stored in 4 bytes.  only use low 7 bits from 1st byte.
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.ASSERT((value & 0x80) == 0x80);
1:                 }
1: 
1:                 // top 8 bits of 4 byte value is stored in this byte, we also 
1:                 // know that the 0x80 bit was set, so need to mask off the 
1:                 // sign extension from the 1st byte to int conversion.  Need to
1:                 // mask the bytes from the next 3 bytes data[pos + 1,2,3] to 
1:                 // account for possible sign extension.
1:                 //
1: 
1:                 value = 
1:                     ((value       & 0x7f) << 24) |
1:                     ((data[pos++] & 0xff) << 16) |
1:                     ((data[pos++] & 0xff) <<  8) |
1:                     ((data[pos++] & 0xff)      );
1:             }
1: 
1:             position = pos;
1: 
1:             return(value);
1:         }
1:         catch (java.lang.ArrayIndexOutOfBoundsException ex)
1:         {
1: 			throw new EOFException(); // end of file
1:         }
1: 
1:     }
1: 
1:     /**
1:      * Read a compressed long from the stream.
1:      * <p>
1:      * Read a compressed long from the stream, which is assumed to have
1:      * been written by a call to CompressNumber.writeLong().
1:      * <p>
1:      * Code from CompressedNumber is inlined here so that these fields can
1:      * be read from the array with a minimum of function calls.
1:      * <p>
1:      * The format of a compressed int is as follows:
1:      *
1:      * Formats are (with x representing value bits):
1:      * <PRE>
0:      * value <= 16383 (0x3fff): 
1:      *     2 byte - 00xxxxxx xxxxxxxx 
1:      *
0:      * value > 16383 && <= 0x3fffffff:
1:      *     4 byte - 01xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
1:      *
0:      * value > 0x3fffffff && <= MAX_LONG:
1:      *     8 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
1:      * </PRE>
1:      *
1:      **/
1:     public final long readCompressedLong()
1:         throws IOException
1:     {
1:         try
1:         {
1:             // copy globals locally, to give compiler chance to optimize.
1:             int     pos         = position;
1:             byte[]  data        = pageData;
1: 
1:             // int_value tells whether it is 1, 4, or 8 bytes long.
1:             int     int_value   = data[pos++];
1: 
1:             // build up long value and return it through this variable.
1:             long    long_value;
1: 
1:             if ((int_value & ~0x3f) == 0)
1:             {
1:                 // 2 byte representation
1: 
1:                 // 1st byte of value is stored in int_value, we also know that 
1:                 // the 0x80 bit was not set, so no need to mask off the sign 
1:                 // extension from the 1st byte to int conversion.
1:                 long_value = ((int_value << 8) | (data[pos++] & 0xff));
1:             }
1:             else if ((int_value & 0x80) == 0)
1:             {
1:                 // value stored in 4 bytes.  only use low 6 bits from 1st byte.
1: 
1:                 // Need to mask the bytes from the next 3 bytes 
1:                 // data[pos + 1,2,3] to account for possible sign extension.
1: 
1:                 long_value = 
1:                     ((int_value   & 0x3f) << 24) |
1:                     ((data[pos++] & 0xff) << 16) |
1:                     ((data[pos++] & 0xff) <<  8) |
1:                     ((data[pos++] & 0xff)      );
1:             }
1:             else
1:             {
0:                 // top 7 bits of 4 byte value is stored in int_value, we also 
1:                 // know that the 0x80 bit was set, so need to mask off the 
1:                 // sign extension from the 1st byte to int conversion.  Need to
1:                 // mask the bytes from the next 7 bytes data[pos + 1,2,...] to 
1:                 // account for possible sign extension.
1:                 //
1: 
0:                 // value stored in 8 bytes.  only use low 6 bits from 1st byte.
1:                 long_value = 
1:                     (((long) (int_value   & 0x7f)) << 56) |
1:                     (((long) (data[pos++] & 0xff)) << 48) |
1:                     (((long) (data[pos++] & 0xff)) << 40) |
1:                     (((long) (data[pos++] & 0xff)) << 32) |
1:                     (((long) (data[pos++] & 0xff)) << 24) |
1:                     (((long) (data[pos++] & 0xff)) << 16) |
1:                     (((long) (data[pos++] & 0xff)) <<  8) |
1:                     (((long) (data[pos++] & 0xff))      );
1:             }
1: 
1:             position = pos;
1: 
1:             return(long_value);
1:         }
1:         catch (java.lang.ArrayIndexOutOfBoundsException ex)
1:         {
1:             // let java figure out if we went past end of data[] array.
1:             
1: 			throw new EOFException(); // end of file
1:         }
1:     }
1: 
1: 	public Object readObject() throws ClassNotFoundException, IOException {
1: 		return oi.readObject();
1: 	}
1: 
1: 	public String getErrorInfo()  {
1: 		return oi.getErrorInfo();
1: 	}
1: 
1:     public Exception getNestedException() {
1:         return oi.getNestedException();
1:     }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.io
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.io;
0: 
0: import java.io.InputStream;
0: import java.io.IOException;
0: import java.io.ObjectInput;
0: import java.io.EOFException;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.LimitObjectInput;
0: import org.apache.derby.iapi.services.io.ErrorObjectInput;
0: 
0: import java.io.UTFDataFormatException;
0: 
0: /**
0: 	An InputStream that allows reading from an array of bytes. The array
0: 	of bytes that is read from can be changed without having to create a new
0: 	instance of this class.
0: */
0: public final class ArrayInputStream extends InputStream implements LimitObjectInput {
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	private byte[] pageData;
0: 
0: 	private int		start;
0: 	private int		end;		// exclusive
0: 	private int		position;
0: 
0: 	public ArrayInputStream() {
0: 		this(null);
0: 	}
0: 
0: 	private ErrorObjectInput oi;
0: 
0: 	public ArrayInputStream(byte[] data) {
0: 		super();
0: 		setData(data);
0: 		oi = new org.apache.derby.iapi.services.io.FormatIdInputStream(this);
0: 	}
0: 
0: 	public ArrayInputStream(byte[] data, int offset, int length) throws IOException {
0: 		this(data);
0: 		setLimit(offset, length);
0: 	}
0: 
0: 	/*
0: 	** Public methods
0: 	*/
0: 
0: 	/**
0: 		Set the array of bytes to be read.
0: 	*/
0: 	public void setData(byte[] data) {
0: 		pageData = data;
0: 		clearLimit();
0: 	}
0: 
0: 	public void setData(byte[] data, int offset, int length) throws IOException {
0: 		pageData = data;
0: 		setLimit(offset, length);
0: 	}
0: 
0: 	/**
0: 		Return a reference to the array of bytes this stream is going to read
0: 		from so that caller may load it with stuff 
0: 	*/
0: 	public byte[] getData()
0: 	{
0: 		return pageData;
0: 	}
0: 
0: 	/*
0: 	** Methods of InputStream
0: 	*/
0: 
0: 	public int read() throws IOException {
0: 		if (position == end)
0: 			return -1; // end of file
0: 
0: 		return pageData[position++] & 0xff ;
0: 
0: 	}
0: 
0: 	public int read(byte b[], int off, int len) throws IOException {
0: 
0: 		if ((position + len) > end) {
0: 
0: 			len = end - position;
0: 
0: 			if (len == 0) {
0: 				return -1; // end of file
0: 			}
0: 		}
0: 
0: 		System.arraycopy(pageData, position, b, off, len);
0: 		position += len;
0: 		return len;
0: 	}
0: 
0: 	public long skip(long count)  throws IOException {
0: 
0: 		if ((position + count) > end) {
0: 
0: 			count = end - position;
0: 
0: 			if (count == 0)
0: 				return 0; // end of file
0: 		}
0: 
0: 		position += count;
0: 
0: 		return count;
0: 
0: 	}
0: 
0: 	public int getPosition() {
0: 		return position;
0: 	}
0: 
0: 	public final void setPosition(int newPosition)
0: 		throws IOException {
0: 
0:         if ((newPosition >= start) && (newPosition < end))
0:             position = newPosition;
0:         else
0: 			throw new EOFException();
0: 	}
0: 
0: 	public int available() throws IOException {
0: 
0: 		return end - position;
0: 	}
0: 
0: 
0: 	/**
0: 		A setLimit which also sets the position to be offset.
0: 
0: 		@exception IOException limit is out of range 
0: 	*/
0: 	public int setLimit(int offset, int length) throws IOException {
0: 
0: 		if ((offset < 0) || (length < 0)) {
0: 			start = end = position = 0;
0: 			throw new EOFException();
0: 		}
0: 
0: 		start = offset;
0: 		end = offset + length;
0: 
0: 		if (end > pageData.length) {
0: 			start = end = position = 0;
0: 			throw new EOFException();
0: 		}
0: 
0: 		position = start;
0: 
0: 		return length;
0: 	}
0: 
0: 	/*
0: 	** Methods of Limit
0: 	*/
0: 
0: 	public final void setLimit(int length) throws IOException {
0: 
0:         start = position;
0:         end   = position + length;
0: 
0:         if (end <= pageData.length)
0:         {
0:             return;
0:         }
0:         else
0:         {
0: 			start = end = position = 0;
0: 			throw new EOFException();
0:         }
0: 	}
0: 
0: 	/**
0: 		Clears the limit by setting the limit to be the entire byte array.
0: 
0: 		@see Limit#clearLimit
0: 	*/
0: 	public final int clearLimit() {
0: 
0: 		if (pageData != null) {
0: 			start = 0;
0: 			int remainingBytes = end - position;
0: 			end = pageData.length;
0: 			return remainingBytes;
0: 		} else {
0: 			start = end = position = 0;
0: 			return 0;
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Methods of DataInput
0: 	*/
0: 
0:     public final void readFully(byte b[]) throws IOException {
0: 		readFully(b, 0, b.length);
0:     }
0: 
0:     public final void readFully(byte b[], int off, int len) throws IOException {
0: 
0: 		if ((position + len) > end) {
0: 
0: 			throw new EOFException();
0: 		}
0: 
0: 		System.arraycopy(pageData, position, b, off, len);
0: 		position += len;
0: 	}
0: 
0:     public final int skipBytes(int n) throws IOException {
0: 		if ((position + n) > end) {
0: 
0: 			throw new EOFException();
0: 		}
0: 		position += n;
0: 		return n;
0:     }
0: 
0:     public final boolean readBoolean() throws IOException {
0: 		if (position == end)
0: 			throw new EOFException(); // end of file
0: 
0: 		return pageData[position++] != 0;
0:     }
0: 
0:     public final byte readByte() throws IOException {
0: 		if (position == end)
0: 			throw new EOFException(); // end of file
0: 
0: 		return pageData[position++];
0:     }
0: 
0:     public final int readUnsignedByte() throws IOException {
0: 		if (position == end)
0: 			throw new EOFException(); // end of file
0: 
0: 		return pageData[position++] & 0xff ;
0:     }
0: 
0:     public final short readShort() throws IOException {
0: 
0: 		int pos = position;
0: 		byte[] data = pageData;
0: 
0: 		if (pos >= (end - 1))
0: 			throw new EOFException(); // end of file
0: 
0: 		int s = ((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff);
0: 
0: 		position = pos;
0: 
0: 		return (short) s;
0:     }
0: 
0:    public final int readUnsignedShort() throws IOException {
0:  		int    pos  = position;
0: 		byte[] data = pageData;
0: 
0: 		if (pos >= (end - 1))
0: 			throw new EOFException(); // end of file
0: 
0: 		int us = ((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff);
0: 
0: 		position = pos;
0: 
0: 		return us;
0:    }
0: 
0:     public final char readChar() throws IOException {
0:  		int    pos  = position;
0: 		byte[] data = pageData;
0: 
0: 		if (pos >= (end -1))
0: 			throw new EOFException(); // end of file
0: 
0: 		int c = ((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff);
0: 
0: 		position = pos;
0: 
0: 		return (char) c;
0:     }
0: 
0:     public final int readInt() throws IOException {
0: 
0:  		int pos = position;
0: 		byte[] data = pageData;
0: 
0: 		if (pos >= (end - 3))
0: 			throw new EOFException(); // end of file
0: 
0: 
0: 
0: 		int i = ((data[pos++] & 0xff) << 24) |
0:                 ((data[pos++] & 0xff) << 16) |
0:                 ((data[pos++] & 0xff) <<  8) |
0:                 ((data[pos++] & 0xff)      );
0: 
0: 		position = pos;
0: 
0: 		return i;
0:     }
0: 
0:     public final long readLong() throws IOException {
0:  		int    pos  = position;
0: 		byte[] data = pageData;
0: 
0: 		if (pos >= (end - 7))
0: 			throw new EOFException(); // end of file
0: 
0: 		long l = 
0:             (((long) (data[pos++] & 0xff)) << 56) |
0:             (((long) (data[pos++] & 0xff)) << 48) |
0:             (((long) (data[pos++] & 0xff)) << 40) |
0:             (((long) (data[pos++] & 0xff)) << 32) |
0:             (((long) (data[pos++] & 0xff)) << 24) |
0:             (((long) (data[pos++] & 0xff)) << 16) |
0:             (((long) (data[pos++] & 0xff)) <<  8) | 
0:             (((long) (data[pos++] & 0xff))      );
0: 
0: 		position = pos;
0: 
0: 		return l;
0:     }
0: 
0:     public final float readFloat() throws IOException {
0: 		return Float.intBitsToFloat(readInt());
0:     }
0: 
0:     public final double readDouble() throws IOException {
0: 		return Double.longBitsToDouble(readLong());
0:     }
0: 
0:     public final String readLine() throws IOException {
0: 		return oi.readLine();
0:     }
0:     public final String readUTF() throws IOException {
0: 		return oi.readUTF();
0:     }
0: 
0:     /**
0:      * read in a cloudscape UTF formated string into a char[].
0:      * <p>
0:      * This routine inline's the code to read a UTF format string from a
0:      * byte[] array (pageData), into a char[] array.  The string will
0:      * be read into the char[] array passed into this routine through
0:      * rawData_array[0] if it is big enough.  If it is not big enough
0:      * a new char[] will be alocated and returned to the caller by putting
0:      * it into rawData_array[0].
0:      * <p>
0:      * To see detailed description of the cloudscape UTF format see
0:      * the writeExternal() routine of SQLChar.
0:      * <p>
0:      * The routine returns the number of char's read into the returned
0:      * char[], note that this length may smaller than the actual length
0:      * of the char[] array.
0:      *
0: 	 * @return The the number of valid char's in the returned char[].
0:      *
0:      * @param rawData_array This parameter uses a element array to implement
0:      *                      an in/out function parameter.  The char[] array
0:      *                      in rawData_array[0] is used to read the data into
0:      *                      unless it is not big enough, then a new array
0:      *                      is allocated and the old one discarded.  In 
0:      *                      either case on return rawData_array[0] contains
0:      *                      the filled in char[] - caller must allow that
0:      *                      the array may or may not be different from the
0:      *                      one passed in.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public final int readCloudscapeUTF(char[][] rawData_array) 
0:         throws IOException
0: 	{
0:         // copy globals locally, to give compiler chance to optimize.
0:         byte[]  data    = pageData;
0:         int     end_pos = end;
0:  		int     pos     = position;
0: 
0:         // get header length - stored as an unsigned short.
0: 
0: 		int utflen;
0:         if (pos + 1 < end_pos) 
0:         {
0:             utflen = (((data[pos++] & 0xff) << 8) | (data[pos++] & 0xff));
0:         }
0:         else
0:         {
0: 			throw new EOFException(); // end of file
0:         }
0: 
0:         /**
0:          * 3 cases - can they all happen?
0:          *
0:          * o utflen == 0 and end is marked E0, 0, 0
0:          * o utflen == 0 and there is no data (ie. 0 length string)
0:          * o utflen != 0, utflen is exact length of following bytes
0:          **/
0: 
0:         // requiredLength is the amount of bytes to read from the array,
0:         // either the utflen in the header length, or the number of bytes
0:         // available in the array.  Throw an exception if we know up front
0:         // that utflen is bigger than number of bytes in the array.
0: 		int requiredLength;
0:         if (utflen != 0)
0:         {
0:             // this is the only place we need to check for end of file, 
0:             // the subsequent loop will not read past bytes_available_in_array.
0: 
0:             if (utflen <= (end_pos - pos))
0:             {
0:                 requiredLength = utflen;
0:             }
0:             else
0:             {
0:                 throw new EOFException();
0:             }
0:         }
0:         else
0:         {
0:             // the byte header returned 0, so read what is left in the array.
0:             
0:             requiredLength = (end_pos - pos);
0:         }
0: 
0:         // Use the passed in char[] array if it is long enough, otherwise
0:         // allocate a new array, and will pass it back to caller at the end.
0:         // Note that requiredLength is the worst case length for the array,
0:         // as the number of char characters must be <= number of bytes (ie.
0:         // all characters were stored compressed in 1 byte each - the ascii
0:         // default) - if there are any 2 or 3 byte stored characters then
0:         // the array will have extra space at the end.  "strlen" tracks the
0:         // real number of char's in str[].
0:         char[] str = rawData_array[0];
0: 		if ((str == null) || (requiredLength > str.length)) 
0:         {
0: 			str = new char[requiredLength];
0:             rawData_array[0] = str;
0: 		} 
0: 
0:         end_pos = pos + requiredLength;
0:         int strlen = 0;
0: 
0:         while (pos < end_pos)
0:         {
0: 			int char1 = (data[pos++] & 0xff);
0: 
0: 			// top fours bits of the first unsigned byte that maps to a 1,2 
0:             // or 3 byte character
0: 			//
0: 			// 0000xxxx	- 0 - 1 byte char
0: 			// 0001xxxx - 1 - 1 byte char
0: 			// 0010xxxx - 2 - 1 byte char
0: 			// 0011xxxx - 3 - 1 byte char
0: 			// 0100xxxx - 4 - 1 byte char
0: 			// 0101xxxx - 5 - 1 byte char
0: 			// 0110xxxx - 6 - 1 byte char
0: 			// 0111xxxx - 7 - 1 byte char
0: 			// 1000xxxx - 8 - error
0: 			// 1001xxxx - 9 - error
0: 			// 1010xxxx - 10 - error
0: 			// 1011xxxx - 11 - error
0: 			// 1100xxxx - 12 - 2 byte char
0: 			// 1101xxxx - 13 - 2 byte char
0: 			// 1110xxxx - 14 - 3 byte char
0: 			// 1111xxxx - 15 - error
0: 
0: 			int char2, char3;
0: 			if ((char1 & 0x80) == 0x00)
0: 			{
0: 				// one byte character
0: 				str[strlen++] = (char) char1;
0: 			}
0: 			else if ((char1 & 0x60) == 0x40) // we know the top bit is set here
0: 			{ 
0: 				// two byte character, make sure read of next byte is in bounds.
0:                 if (pos >= end_pos)
0: 					throw new UTFDataFormatException();		  
0: 
0:                 char2 = (data[pos++] & 0xff);
0: 
0: 				if ((char2 & 0xC0) != 0x80)
0: 					throw new UTFDataFormatException();		  
0: 
0: 				str[strlen++] = (char)(((char1 & 0x1F) << 6) | (char2 & 0x3F));
0: 			}
0: 			else if ((char1 & 0x70) == 0x60) // we know the top bit is set here
0: 			{
0: 				// three byte character
0: 
0: 				// 3 byte character, make sure read of next 2 bytes in bounds.
0:                 if (pos + 1 >= end_pos)
0: 					throw new UTFDataFormatException();		  
0: 
0:                 char2 = (data[pos++] & 0xff);
0:                 char3 = (data[pos++] & 0xff);
0: 
0: 				if ((char1 == 0xE0) && 
0:                     (char2 ==    0) && 
0:                     (char3 ==    0) && 
0:                     (utflen == 0))
0: 				{
0: 					// we reached the end of a long string,
0: 					// that was terminated with
0: 					// (11100000, 00000000, 00000000)
0:                     break;
0: 				}
0:                 else if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))
0:                 {
0: 					throw new UTFDataFormatException();		  
0:                 }
0:                 else
0:                 {
0:                     str[strlen++] = (char)
0:                         (((char1 & 0x0F) << 12) | 
0:                          ((char2 & 0x3F) <<  6) | 
0:                          ((char3 & 0x3F) <<  0));
0:                 }
0: 			}
0: 			else 
0:             {
0: 				throw new UTFDataFormatException();
0: 			}
0: 
0: 		}
0: 
0:         // update global on successful read exit.
0:         position = pos;
0: 
0:         return(strlen);
0: 	}
0: 
0:     /**
0:      * Read a compressed int from the stream.
0:      * <p>
0:      * Read a compressed int from the stream, which is assumed to have
0:      * been written by a call to CompressNumber.writeInt().
0:      * <p>
0:      * Code from CompressedNumber is inlined here so that these fields can
0:      * be read from the array with a minimum of function calls.
0:      * <p>
0:      * The format of a compressed int is as follows:
0:      *
0:      * Formats are (with x representing value bits):
0:      * <PRE>
0:      * 1 Byte- 00xxxxxx                            val <= 63 (0x3f)
0:      * 2 Byte- 01xxxxxx xxxxxxxx                   val > 63 && <= 16383 (0x3fff)
0:      * 4 byte- 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx val > 16383 && <= MAX_INT
0:      * </PRE>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public final int readCompressedInt()
0:         throws IOException
0:     {
0:  		int    pos  = position;
0: 		byte[] data = pageData;
0: 
0:         try
0:         {
0:             int value = data[pos++];
0: 
0:             if ((value & ~0x3f) == 0)
0:             {
0:                 // entire value is stored in this byte, we also know that the 
0:                 // 0x80 bit was not set, so no need to mask off the sign 
0:                 // extension from the byte to int conversion.
0:             }
0:             else if ((value & 0x80) == 0)
0:             {
0:                 // value stored in 2 bytes.  only use low 6 bits from 1st byte.
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT((value & 0x40) == 0x40);
0:                 }
0: 
0:                 // top 8 bits of 2 byte value is stored in this byte, we also 
0:                 // know that the 0x80 bit was not set, so no need to mask off 
0:                 // the sign extension from the 1st byte to int conversion.  
0:                 // Need to mask the byte in data[pos + 1] to account for 
0:                 // possible sign extension.
0: 
0:                 value = 
0:                     (((value & 0x3f) << 8) | (data[pos++] & 0xff));
0:             }
0:             else
0:             {
0:                 // value stored in 4 bytes.  only use low 7 bits from 1st byte.
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.ASSERT((value & 0x80) == 0x80);
0:                 }
0: 
0:                 // top 8 bits of 4 byte value is stored in this byte, we also 
0:                 // know that the 0x80 bit was set, so need to mask off the 
0:                 // sign extension from the 1st byte to int conversion.  Need to
0:                 // mask the bytes from the next 3 bytes data[pos + 1,2,3] to 
0:                 // account for possible sign extension.
0:                 //
0: 
0:                 value = 
0:                     ((value       & 0x7f) << 24) |
0:                     ((data[pos++] & 0xff) << 16) |
0:                     ((data[pos++] & 0xff) <<  8) |
0:                     ((data[pos++] & 0xff)      );
0:             }
0: 
0:             position = pos;
0: 
0:             return(value);
0:         }
0:         catch (java.lang.ArrayIndexOutOfBoundsException ex)
0:         {
0: 			throw new EOFException(); // end of file
0:         }
0: 
0:     }
0: 
0:     /**
0:      * Read a compressed long from the stream.
0:      * <p>
0:      * Read a compressed long from the stream, which is assumed to have
0:      * been written by a call to CompressNumber.writeLong().
0:      * <p>
0:      * Code from CompressedNumber is inlined here so that these fields can
0:      * be read from the array with a minimum of function calls.
0:      * <p>
0:      * The format of a compressed int is as follows:
0:      *
0:      * Formats are (with x representing value bits):
0:      * <PRE>
0:      * value <= 16383 (0x3fff): 
0:      *     2 byte - 00xxxxxx xxxxxxxx 
0:      *
0:      * value > 16383 && <= 0x3fffffff:
0:      *     4 byte - 01xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
0:      *
0:      * value > 0x3fffffff && <= MAX_LONG:
0:      *     8 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
0:      * </PRE>
0:      *
0:      **/
0:     public final long readCompressedLong()
0:         throws IOException
0:     {
0:         try
0:         {
0:             // copy globals locally, to give compiler chance to optimize.
0:             int     pos         = position;
0:             byte[]  data        = pageData;
0: 
0:             // int_value tells whether it is 1, 4, or 8 bytes long.
0:             int     int_value   = data[pos++];
0: 
0:             // build up long value and return it through this variable.
0:             long    long_value;
0: 
0:             if ((int_value & ~0x3f) == 0)
0:             {
0:                 // 2 byte representation
0: 
0:                 // 1st byte of value is stored in int_value, we also know that 
0:                 // the 0x80 bit was not set, so no need to mask off the sign 
0:                 // extension from the 1st byte to int conversion.
0:                 long_value = ((int_value << 8) | (data[pos++] & 0xff));
0:             }
0:             else if ((int_value & 0x80) == 0)
0:             {
0:                 // value stored in 4 bytes.  only use low 6 bits from 1st byte.
0: 
0:                 // Need to mask the bytes from the next 3 bytes 
0:                 // data[pos + 1,2,3] to account for possible sign extension.
0: 
0:                 long_value = 
0:                     ((int_value   & 0x3f) << 24) |
0:                     ((data[pos++] & 0xff) << 16) |
0:                     ((data[pos++] & 0xff) <<  8) |
0:                     ((data[pos++] & 0xff)      );
0:             }
0:             else
0:             {
0:                 // top 7 bits of 4 byte value is stored in int_value, we also 
0:                 // know that the 0x80 bit was set, so need to mask off the 
0:                 // sign extension from the 1st byte to int conversion.  Need to
0:                 // mask the bytes from the next 7 bytes data[pos + 1,2,...] to 
0:                 // account for possible sign extension.
0:                 //
0: 
0:                 // value stored in 8 bytes.  only use low 6 bits from 1st byte.
0:                 long_value = 
0:                     (((long) (int_value   & 0x7f)) << 56) |
0:                     (((long) (data[pos++] & 0xff)) << 48) |
0:                     (((long) (data[pos++] & 0xff)) << 40) |
0:                     (((long) (data[pos++] & 0xff)) << 32) |
0:                     (((long) (data[pos++] & 0xff)) << 24) |
0:                     (((long) (data[pos++] & 0xff)) << 16) |
0:                     (((long) (data[pos++] & 0xff)) <<  8) |
0:                     (((long) (data[pos++] & 0xff))      );
0:             }
0: 
0:             position = pos;
0: 
0:             return(long_value);
0:         }
0:         catch (java.lang.ArrayIndexOutOfBoundsException ex)
0:         {
0:             // let java figure out if we went past end of data[] array.
0:             
0: 			throw new EOFException(); // end of file
0:         }
0:     }
0: 
0: 	public Object readObject() throws ClassNotFoundException, IOException {
0: 		return oi.readObject();
0: 	}
0: 
0: 	public String getErrorInfo()  {
0: 		return oi.getErrorInfo();
0: 	}
0: 
0:     public Exception getNestedException() {
0:         return oi.getNestedException();
0:     }
0: }
============================================================================