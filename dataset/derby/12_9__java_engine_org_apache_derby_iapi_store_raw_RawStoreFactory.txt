1:047a763: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.raw.RawStoreFactory
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
23:eac0369: 
1:c2afcc1:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.raw;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.daemon.DaemonService;
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:3c1f634: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
1:eac0369: import org.apache.derby.iapi.services.locks.LockFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.property.PersistentSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.TransactionInfo;
1:402725c: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.DatabaseInstant;
1:eac0369: import java.util.Properties;
1:eac0369: import java.io.Serializable;
1:eac0369: 
1:d203eea: /**
1:883a153:     RawStoreFactory implements a single unit of transactional
1:883a153:     storage. A RawStoreFactory contains Segments and Segments
1:883a153:     contain Containers.
1:883a153:     <P>
1:883a153:     Segments are identified
1:883a153:     by integer identifiers that are unique within a RawStoreFactory.
1:883a153:     <P>
1:883a153:     Containers are also identified by unique integer identifiers
1:883a153:     within a RawStoreFactory, but will overlap with segment identifiers.
1:883a153:     <P><B>LIMITS</B><BR>
1:883a153:     This is a list of (hopefully) all limits within the raw store. Where a size 
1:eac0369:     has more than one limit all are documented (rather than just the most 
1:eac0369:     restrictive) so that the correct limit can be found if the most restictive 
1:eac0369:     is every removed.
1:883a153:     <UL>
1:883a153:     <LI>Field - 
1:883a153:         <UL>
1:883a153:         <LI>Max length 2^31 - 1  (2147483647) - 
1:883a153:         </UL>
1:883a153:     <LI>Record - 
1:883a153:         <UL>
1:883a153:         <LI>Max number of fields 2^31 - 1  (2147483647) - from use of Object[] 
1:eac0369:         array to represent row, which can "only" have int sized number of array
1:eac0369:         members.
1:883a153:         </UL>
1:883a153:     <LI>Page -
1:883a153:     <LI>Container -
1:883a153:     <LI>Segment -
1:883a153:     <LI>Raw Store -
1:883a153:     </UL>
1:eac0369: 
1:883a153:     <P>
1:883a153:     Access and RawStore work together to provide the ACID properties of
1:883a153:     transactions. On a high level, RawStore deals with anything that directly
1:883a153:     impacts persistency. On a more detailed level, RawStore provides
1:883a153:     logging, rollback and recovery, data management on page, page allocation
1:883a153:     and deallocation, container allocation and deallocation.  
1:eac0369: 
1:eac0369: 
1:883a153:     <P>
1:883a153:     RawStore is organized as 3 branches, transaction, data, and
1:883a153:     logging.  These branches each have its own "factory", the transaction
1:883a153:     factory hands out transactions, the data factory hands out containers,
1:883a153:     and the log factory hands out logger (or log buffers) for transactions to
1:883a153:     write on.  For a more detailed description on these factories, please see
1:883a153:     their corresponding javadocs.
1:eac0369: 
1:eac0369: 
1:883a153:     MT - Thread Safe
1:eac0369: 
1:883a153:     @see ContainerHandle */
1:eac0369: 
1:eac0369: 
1:eac0369: public interface RawStoreFactory extends Corruptable {
1:eac0369: 
1:883a153:     /** Store engine version numbers indicating the database must be upgraded to 
1:883a153:      * or created at the current engine level 
1:883a153:      */
1:c2afcc1: 
1:883a153:     /** Derby Store Minor Version (1) **/
1:883a153:     public static final int DERBY_STORE_MINOR_VERSION_1    = 1;
1:32635d2: 
1:32635d2:     /** Derby Store Minor Version (2) **/
1:883a153:     public static final int DERBY_STORE_MINOR_VERSION_2    = 2;
1:32635d2: 
1:883a153:     /** Derby Store Minor Version (3) **/
1:883a153:     public static final int DERBY_STORE_MINOR_VERSION_3    = 3;
1:28e234d:         
1:883a153:     /** Derby Store Minor Version (4) **/
1:883a153:     public static final int DERBY_STORE_MINOR_VERSION_4    = 4;
1:f824190: 
1:d203eea:     /** Derby Store Minor Version (10) **/
1:d203eea:     public static final int DERBY_STORE_MINOR_VERSION_10   = 10;
1:d203eea: 
1:883a153:     /** Derby 10 Store Major version */
1:883a153:     public static final int DERBY_STORE_MAJOR_VERSION_10   = 10;
1:eac0369: 
1:883a153:     /**
1:883a153:         Default value for PAGE_SIZE_PARAMETER (4096).
1:883a153:     */
1:883a153:     public static final int PAGE_SIZE_DEFAULT = 4096;
1:eac0369: 
1:883a153:     /**
1:883a153:         Minimum page size we will accept (1024).
1:883a153:     */
1:883a153:     public static final int PAGE_SIZE_MINIMUM = 1024;
1:eac0369: 
1:eac0369: 
1:883a153:     public static final String PAGE_SIZE_STRING = "2048";
1:eac0369: 
1:eac0369: 
1:883a153:     /** Property name for the page cache size to be used in the storage area.
1:883a153:     Equal to 'derby.storage.pageCacheSize'
1:883a153:     */
1:883a153:     public static final String PAGE_CACHE_SIZE_PARAMETER = 
1:eac0369:         "derby.storage.pageCacheSize";
1:eac0369: 
1:883a153:     /**
1:883a153:         Default value for PAGE_CACHE_SIZE_PARAMETER (1000).
1:883a153:     */
1:883a153:     public static final int PAGE_CACHE_SIZE_DEFAULT = 1000;
1:eac0369: 
1:883a153:     /**
1:883a153:         Minimum page cache size we will accept (40).
1:883a153:     */
1:883a153:     public static final int PAGE_CACHE_SIZE_MINIMUM = 40;
1:eac0369: 
1:883a153:     /**
1:883a153:         Maximum page cache size we will accept (MAXINT).
1:883a153:     */
1:883a153:     public static final int PAGE_CACHE_SIZE_MAXIMUM = Integer.MAX_VALUE;
1:054acc3: 
1:eac0369: 
1:883a153:     /** Property name for the number of open files to maintain associated with
1:054acc3:         the page cache.  Internally this is referred to as the "ContainerCache".
1:054acc3: 
1:054acc3:         Each object in this cache maps to a java level "open" file on a file
1:054acc3:         in the database directory.  Although actual implementation depends on
1:054acc3:         JVM implementation, this usually maps to underlying open file resources
1:054acc3:         in the underlying operating system.  Setting this number too high
1:054acc3:         may result in I/O failures reported by Derby, which are the result 
1:054acc3:         of hitting some user and/or OS limit on the number of open files
1:054acc3:         allowed.  These I/O errors may happen during read, write and/or open 
1:054acc3:         operations.  
1:054acc3:         Sometimes these limits can be avoided simply by executing an OS 
1:054acc3:         specific command to raise the maximum open files allowed by whatever
1:054acc3:         mechanism is used to control resources allowed to be consumed by
1:054acc3:         the JVM.
1:054acc3: 
1:054acc3:         Derby may also open other files separate from this cache, so exausting
1:054acc3:         the open file resource may cause other operations than I/O to data
1:054acc3:         pages to fail.  A partial list of these operations includes: 
1:054acc3:         recovery logging, error logging, external sorting, and 
1:054acc3:         LOB disk overflow.
1:054acc3: 
1:054acc3:         The default maximum size of this cache is 100 open files.
1:054acc3:         The minimum size of this cache is 2 open files, attempting to set this
1:054acc3:         cache to a smaller size or a negative number will result in a size 2
1:054acc3:         cache.  Setting the cache size to a number bigger than an INT, or any
1:054acc3:         sort of illegal format number will result in a cache size of 100
1:054acc3:         open files.
1:054acc3: 
1:054acc3:         Equal to 'derby.storage.fileCacheSize'
1:883a153:     */
1:883a153:     public static final String CONTAINER_CACHE_SIZE_PARAMETER = 
1:054acc3:         "derby.storage.fileCacheSize";
1:054acc3: 
1:883a153:     /**
1:883a153:         Default value for CONTAINER_CACHE_SIZE_PARAMETER (100).
1:883a153:     */
1:883a153:     public static final int CONTAINER_CACHE_SIZE_DEFAULT = 100;
1:054acc3: 
1:883a153:     /**
1:883a153:         Minimum container cache size accepted (2).
1:883a153:     */
1:883a153:     public static final int CONTAINER_CACHE_SIZE_MINIMUM = 2;
1:054acc3: 
1:883a153:     /**
1:883a153:         Maximum container cache size we will accept (MAXINT).
1:883a153:     */
1:883a153:     public static final int CONTAINER_CACHE_SIZE_MAXIMUM = Integer.MAX_VALUE;
1:054acc3: 
1:883a153:     /**
1:883a153:         Maximum number of initial pages when a container is created
1:883a153:     */
1:883a153:     public static final short MAX_CONTAINER_INITIAL_PAGES = 1000;
1:054acc3: 
1:eac0369: 
1:883a153:     /** Property name for the default minimum record size to be used in the 
1:eac0369:         storage area. Minimum record size is the minimum number of bytes that a 
1:eac0369:         record will reserve on disk.
1:883a153:     */
1:883a153:     public static final String MINIMUM_RECORD_SIZE_PARAMETER = 
1:eac0369:         "derby.storage.minimumRecordSize";
1:883a153:     /**
1:883a153:         Default value for MINIMUM_RECORD_SIZE_PARAMETER for heap tables that 
1:eac0369:         allow overflow.  By setting minimumRecordSize to 12 bytes, we 
1:2f41733:         guarantee there is enough space to update the a head row even if there 
1:2f41733:         is not enough space on the page.  The 12 bytes of user data along with
1:2f41733:         the existing space in the record header will guarantee there is room
1:2f41733:         to write an overflow row header which will use the same initial portion
1:2f41733:         of the record header and at most 12 additional bytes for an overflow 
1:2f41733:         pointer (page + id).  Note that this is the "user"
1:2f41733:         portion of the record.  The record also will contain space for the
1:2f41733:         "non-user" portion which includes the offset table and the record
1:2f41733:         header.
1:883a153:     */
1:883a153:     public static final int MINIMUM_RECORD_SIZE_DEFAULT = 12;
1:2f41733: 
1:eac0369: 
1:883a153:     /**
1:883a153:         Minimum value for MINIMUM_RECORD_SIZE_PARAMETER (1).
1:883a153:     */
1:883a153:     public static final int MINIMUM_RECORD_SIZE_MINIMUM = 1;
1:eac0369: 
1:883a153:     /** Property name for percentage of space to leave free on page for updates.
1:883a153:     */
1:883a153:     public static final String PAGE_RESERVED_SPACE_PARAMETER = 
1:eac0369:         "derby.storage.pageReservedSpace";
1:eac0369: 
1:883a153:     public static final String PAGE_RESERVED_ZERO_SPACE_STRING = "0";
1:eac0369: 
1:883a153:     /** Property name for the number of pages we try to pre-allocate in one
1:883a153:     /** synchronous I/O
1:883a153:     */
1:883a153:     public static final String PRE_ALLOCATE_PAGE = 
1:eac0369:         "derby.storage.pagePerAllocate";
1:eac0369: 
1:eac0369: 
1:883a153:     /**
1:883a153:         Property name for container which reuses recordId when a page is
1:883a153:         reused.  Defaults to false, which means recordId is never reused.   
1:eac0369: 
1:883a153:         This property should NOT be set by the end user, only Access should set
1:883a153:         it for special conglomerates which does not count on permanant unique
1:883a153:         recordIds for all records.
1:883a153:     */
1:883a153:     public static final String PAGE_REUSABLE_RECORD_ID = 
1:eac0369:         "derby.storage.reusableRecordId";
1:eac0369: 
1:883a153:     /**
1:883a153:         Property name for buffer size to be used in the stream file container.
1:883a153:         Equal to 'derby.storage.streamFileBufferSize'
1:883a153:     */
1:883a153:     public static final String STREAM_FILE_BUFFER_SIZE_PARAMETER = 
1:eac0369:         "derby.storage.streamFileBufferSize";
1:eac0369: 
1:883a153:     /**
1:883a153:         Default value for STREAM_FILE_BUFFER_SIZE_PARAMETER (16384).
1:883a153:     */
1:883a153:     public static final int STREAM_FILE_BUFFER_SIZE_DEFAULT = 16384;
1:eac0369: 
1:883a153:     /**
1:883a153:         Minimum stream file buffer size we will accept (1024).
1:883a153:     */
1:883a153:     public static final int STREAM_FILE_BUFFER_SIZE_MINIMUM = 1024;
1:eac0369: 
1:883a153:     /**
1:883a153:         Maximum stream file buffer size we will accept (MAXINT).
1:883a153:     */
1:883a153:     public static final int STREAM_FILE_BUFFER_SIZE_MAXIMUM = 
1:eac0369:         Integer.MAX_VALUE;
1:eac0369: 
1:883a153:     /**
1:eac0369: 
1:883a153:         Property name for container which attempts to be created with an
1:883a153:         initial size of this many pages.  Defaults to 1 page.  
1:eac0369: 
1:883a153:         <BR>All containers are guarenteed to be created with at least 1 page,
1:883a153:         if this property is set, it will attempt to allocate
1:883a153:         CONTAINER_INITIAL_PAGES, but with no guarentee.
1:883a153:         CONTAIENR_INITIAL_PAGES legally ranges from 1 to
1:dbed020:         MAX_CONTAINER_INITIAL_PAGES.  Values &lt; 1 will
1:dbed020:         be set to 1 and values &gt; MAX_CONTAINER_INITIAL_PAGES will be set to
1:883a153:         MAX_CONTAINER_INITIAL_PAGES
1:eac0369: 
1:883a153:         This property should only be set in the PROPERTIES list in a CREATE
1:883a153:         TABLE or CREATE INDEX statement.  The global setting of this property
1:883a153:         has no effect. 
1:883a153:     */
1:883a153:     public static final String CONTAINER_INITIAL_PAGES = 
1:eac0369:         "derby.storage.initialPages";
1:eac0369: 
1:883a153:     /**
1:883a153:         encryption alignment requirement.
1:883a153:      */
1:883a153:     public static final int ENCRYPTION_ALIGNMENT = 8;
1:eac0369: 
1:883a153:     /**
1:883a153:         default encryption block size
1:883a153:         In old existing databases (ie 5.1.x), the default
1:883a153:         encryption block size used is 8. Do not change this value unless you 
1:883a153:         account for downgrade issues
1:883a153:      */
1:883a153:     public static final int DEFAULT_ENCRYPTION_BLOCKSIZE = 8;
1:eac0369: 
1:883a153:     /**
1:883a153:         encryption block size used during creation of encrypted database
1:883a153:         This property is not set by the user; it is set by the engine when
1:883a153:         RawStore boots up during creation of an encrypted database
1:883a153:     */
1:883a153:     public static final String ENCRYPTION_BLOCKSIZE = "derby.encryptionBlockSize";
1:eac0369: 
1:883a153:     /**
1:eac0369: 
1:883a153:         This variable is used to store the encryption scheme to allow
1:883a153:         for any future changes in encryption schemes of data 
1:883a153:         This property has been introduced in version 10
1:883a153:         Value starts at 1
1:883a153:      */
1:883a153:     public static final String DATA_ENCRYPT_ALGORITHM_VERSION="data_encrypt_algorithm_version";
1:eac0369: 
1:883a153:     /**
1:eac0369:                 Store the encryption scheme used for logging
1:883a153:         This will allow for any future changes in encryption schemes of logs
1:883a153:         This variable has been introduced in version 10 and value starts at 1.
1:883a153:      */
1:883a153:     public static final String LOG_ENCRYPT_ALGORITHM_VERSION="log_encrypt_algorithm_version";
1:eac0369: 
1:883a153:     /**
1:883a153:         If dataEncryption is true, store the encrypted key in
1:883a153:         services.properties file. It is really the encrypted
1:883a153:         key, but the property key is called the encryptedBootPassword.
1:eac0369: 
1:883a153:      */
1:883a153:     public static final String ENCRYPTED_KEY = 
1:eac0369:         "encryptedBootPassword";
1:eac0369: 
1:eac0369: 
1:054acc3:     /**
1:047a763:      * When the datbase is getting re-encrypted old encrypted key is 
1:047a763:      * stored in the service.properties until re-encyrption
1:047a763:      * successfully completes or rolled back. It is really the old 
1:047a763:      * encryptedkey, but the property key is called the 
1:047a763:      * OldEncryptedBootPassword.
1:883a153:      */
1:883a153:     public static final String OLD_ENCRYPTED_KEY = 
1:047a763:         "OldEncryptedBootPassword";
1:047a763: 
1:047a763: 
1:054acc3:     /**
1:d203eea:      * Tracks the status of any database-wide cryptographic operations.
1:d203eea:      * <p>
1:d203eea:      * The relevant operations are encryption, re-encryption and decryption.
1:d203eea:      * THe property is required to be able to bring the database back to state
1:d203eea:      * it was in before the cryptographic operation started in case the
1:d203eea:      * transformation of the database is aborted.
1:054acc3:      */
1:047a763:     public static final String DB_ENCRYPTION_STATUS =
1:047a763:         "derby.storage.databaseEncryptionStatus";
1:047a763: 
1:047a763:     /* (re)encryption is in progress, if a crash 
1:047a763:      *  occurs after this flag is set, 
1:047a763:      * (re)encryption needs to  be undone.
1:054acc3:      */
1:047a763:     public static final int DB_ENCRYPTION_IN_PROGRESS   = 1;
1:047a763: 
1:047a763:     /* this flag is used to track crash during undo
1:047a763:        of (re) encryption during recovery .
1:054acc3:     */
1:047a763:     public static final int DB_ENCRYPTION_IN_UNDO      =  2;
1:047a763: 
1:047a763:     /*
1:047a763:      * Cleanup any (re) encryption related resources. 
1:054acc3:      */
1:047a763:     public static final int  DB_ENCRYPTION_IN_CLEANUP  =  3;
1:047a763: 
1:047a763:     
1:883a153:     /**
1:047a763:        A File used to save the old copy of the verify key 
1:047a763:        (Attribute.CRYPTO_EXTERNAL_KEY_VERIFY_FILE) file during 
1:047a763:        re-encryption of the database. 
1:883a153:      */
1:883a153:     String CRYPTO_OLD_EXTERNAL_KEY_VERIFY_FILE = "verifyOldKey.dat";
1:047a763: 
1:047a763: 
1:047a763: 
1:883a153:     /**
1:883a153:      *  for debugging, keep all transaction logs intact.
1:883a153:      */
1:883a153:     public static final String KEEP_TRANSACTION_LOG = 
1:eac0369:         "derby.storage.keepTransactionLog";
1:eac0369: 
1:054acc3:     /**
1:eac0369:       * The following is a to enable patch for databases with recovery
1:eac0369:       * errors during redo of InitPage. If this property is set and
1:883a153:       * the page on the disk is corrupted and is getting exceptions like
1:883a153:       * invalid page format ids, we cook up the page during the recovery time.
1:883a153:       * We have seen this kind of problem with 1.5.1 databases from
1:883a153:       * customer Tridium ( Bug no: 3813).
1:883a153:       * This patch needs to be kept unless we find the problem is during
1:883a153:       * recovery process. If we discover this problem is actaully happening
1:883a153:       * at the recovery then this patch should be backed out.
1:883a153:       **/
1:883a153:     public static final String PATCH_INITPAGE_RECOVER_ERROR = 
1:eac0369:         "derby.storage.patchInitPageRecoverError";
1:eac0369: 
1:eac0369: 
1:883a153:     /** module name */
1:883a153:     public static final String MODULE = 
1:eac0369:         "org.apache.derby.iapi.store.raw.RawStoreFactory";
1:eac0369: 
1:883a153:     /**
1:883a153:         Is the store read-only.
1:883a153:     */
1:883a153:     public boolean isReadOnly();
1:eac0369: 
1:883a153:     /**
1:883a153:         Get the LockFactory to use with this store.
1:883a153:     */
1:883a153:     public LockFactory getLockFactory();
1:eac0369: 
1:888d12e:     /**
1:888d12e:         Register a handler class for insert undo events.
1:888d12e:         <P>
1:888d12e:         Register a class to be called when an undo of an insert 
1:888d12e:         is executed.  When an undo of an event is executed by
1:888d12e:         the raw store UndoHandler.insertUndoNotify() will be
1:888d12e:         called, allowing upper level callers to execute code
1:888d12e:         as necessary.  The initial need is for the access layer
1:888d12e:         to be able to queue post commit reclaim space in the
1:888d12e:         case of inserts which are aborted (including the normal
1:888d12e:         case of inserts failed for duplicate key violations)
1:888d12e:         (see DERBY-4057)
1:888d12e: 
1:888d12e:         @exception StandardException Standard Derby error policy
1:888d12e: 
1:888d12e:     */
1:888d12e:     public void setUndoInsertEventHandler(
1:888d12e:         UndoHandler undo_handle) throws StandardException;
1:888d12e: 
1:eac0369: 
1:883a153:     /**
1:883a153:         Create a user transaction, almost all work within the raw store is
1:eac0369:         performed in the context of a transaction.
1:883a153:         <P>
1:883a153:         Starting a transaction always performs the following steps.
1:883a153:         <OL>
1:883a153:         <LI>Create an raw store transaction context
1:883a153:         <LI>Create a new idle transaction and then link it to the context.
1:883a153:         </UL>
1:883a153:         Only one user transaction and one nested user transaction can be active
1:eac0369:         in a context at any one time.
1:883a153:         After a commit the transaction may be re-used.
1:883a153:         <P>
1:883a153:         <B>Raw Store Transaction Context Behaviour</B>
1:883a153:         <BR>
1:883a153:         The cleanupOnError() method of this context behaves as follows:
1:883a153:         <UL>
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:eac0369:         no action is taken.
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:eac0369:         the context's transaction is aborted, and the transaction returned to
1:eac0369:         the idle state.
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
1:eac0369:         then the context's transaction is aborted, the transaction closed, and
1:eac0369:         the context is popped off the stack.
1:883a153:         <LI>
1:883a153:         If error is not an instance of StandardException then the context's
1:883a153:         transaction is aborted, the transaction closed, and the
1:883a153:         context is popped off the stack.
1:883a153:         </UL>
1:eac0369: 
1:883a153:         @param contextMgr is the context manager to use.  An exception will be
1:883a153:         thrown if context is not the current context.
1:eac0369:         @param transName is the name of the transaction. Thsi name will be displayed
1:eac0369:         by the transactiontable VTI.
1:eac0369: 
1:883a153:         @exception StandardException Standard Derby error policy
1:eac0369: 
1:883a153:         @see Transaction
1:883a153:         @see org.apache.derby.iapi.services.context.Context
1:883a153:         @see StandardException
1:883a153:     */
1:eac0369: 
1:883a153:     public Transaction startTransaction(
1:eac0369:     ContextManager contextMgr,
1:eac0369:     String transName)
8:eac0369:         throws StandardException;
1:eac0369: 
1:883a153:     /**
1:883a153:         Create a global user transaction, almost all work within the raw store
1:eac0369:         is performed in the context of a transaction.
1:883a153:         <P>
1:eac0369:         The (format_id, global_id, branch_id) triplet is meant to come exactly
1:eac0369:         from a javax.transaction.xa.Xid.  We don't use Xid so that the system
1:eac0369:         can be delivered on a non-1.2 vm system and not require the javax 
1:eac0369:         classes in the path.  
18:eac0369:         <P>
1:883a153:         Starting a transaction always performs the following steps.
1:883a153:         <OL>
1:883a153:         <LI>Create an raw store transaction context
1:883a153:         <LI>Create a new idle transaction and then link it to the context.
1:883a153:         </UL>
1:883a153:         Only one user transaction can be active in a context at any one time.
1:883a153:         After a commit the transaction may be re-used.
1:883a153:         <P>
1:883a153:         <B>Raw Store Transaction Context Behaviour</B>
1:883a153:         <BR>
1:883a153:         The cleanupOnError() method of this context behaves as follows:
1:883a153:         <UL>
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then 
1:eac0369:         no action is taken.
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:eac0369:         the context's transaction is aborted, and the transaction returned to 
1:eac0369:         the idle state.
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY 
1:eac0369:         then the context's transaction is aborted, the transaction closed, and 
1:eac0369:         the context is popped off the stack.
1:883a153:         <LI>
1:883a153:         If error is not an instance of StandardException then the context's
1:883a153:         transaction is aborted, the transaction closed, and the
1:883a153:         context is popped off the stack.
1:883a153:         </UL>
1:eac0369: 
1:883a153:         @param contextMgr is the context manager to use.  An exception will be
1:883a153:                           thrown if context is not the current context.
1:eac0369:         @param format_id  the format id part of the Xid - ie. Xid.getFormatId().
1:eac0369:         @param global_id  the global transaction identifier part of XID - ie.
1:eac0369:                           Xid.getGlobalTransactionId().
1:12c6ed9:         @param local_id   The branch qualifier of the Xid - ie. 
1:eac0369:                           Xid.getBranchQaulifier()
1:eac0369: 
1:883a153:         @exception StandardException Standard Derby error policy
1:eac0369: 
1:883a153:         @see Transaction
1:883a153:         @see org.apache.derby.iapi.services.context.Context
1:883a153:         @see StandardException
1:883a153:     */
1:883a153:     public Transaction startGlobalTransaction(
1:eac0369:     ContextManager contextMgr,
1:eac0369:     int            format_id,
1:eac0369:     byte[]         global_id,
1:eac0369:     byte[]         local_id)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 
1:883a153:     /**
1:883a153:         Find a user transaction in the context manager, which must be the
1:883a153:         current context manager.  If a user transaction does not already exist,
1:883a153:         then create one @see #startTransaction
1:eac0369: 
1:883a153:         @param contextMgr the context manager to use.  An exception will be 
1:12c6ed9:                           thrown if context is not the current context.
1:12c6ed9:         @param transName  If a new transaction is started, it will be given 
1:12c6ed9:                           this name.
1:eac0369:         The name is displayed in the transactiontable VTI.
1:eac0369: 
1:883a153:         @exception StandardException Standard Derby error policy
1:eac0369: 
1:883a153:         @see #startTransaction
1:883a153:     */
1:883a153:     public Transaction findUserTransaction(
1:eac0369:         ContextManager contextMgr,
1:eac0369:         String transName) throws StandardException;
1:eac0369: 
1:eac0369: 
1:883a153:     /**
1:883a153:         Create an internal transaction.
1:883a153:         <P>
1:883a153:         Starting an internal transaction always performs the following steps.
1:883a153:         <OL>
1:883a153:         <LI>Create an raw store internal transaction context
1:883a153:         <LI>Create a new idle internal transaction and then link it to the 
1:eac0369:             context.
1:883a153:         </UL>
1:883a153:         <P>
1:883a153:         AN internal transaction is identical to a user transaction with the 
1:eac0369:         exception that
1:883a153:         <UL>
1:883a153:         <LI> Logical operations are not supported
1:883a153:         <LI> Savepoints are not supported
1:883a153:         <LI> Containers are not closed when commit() is called.
1:883a153:         <LI> Pages are not unlatched (since containers are not closed) when 
1:eac0369:              commit() is called.
1:883a153:         <LI> During recovery time internal transactions are rolled back before 
1:eac0369:              user transactions.
1:883a153:         </UL>
1:883a153:         Only one internal transaction can be active in a context at any one time.
1:883a153:         After a commit the transaction may be re-used.
1:883a153:         <P>
1:883a153:         <B>Raw Store Internal Transaction Context Behaviour</B>
1:883a153:         <BR>
1:883a153:         The cleanupOnError() method of this context behaves as follows:
1:883a153:         <UL>
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:883a153:         the internal transaction is aborted, the internal transaction is closed,        the context is popped off the stack, and an exception of severity 
1:eac0369:         Transaction exception is re-thrown.
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that has a severity 
1:eac0369:         greater than or equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:eac0369:         the context's internal transaction is aborted, the internal 
1:eac0369:         transaction is closed and the context is popped off the stack.
1:883a153:         <LI>
1:883a153:         If error is not an instance of StandardException then the context's
1:883a153:         internal transaction is aborted, the internal transaction is closed 
1:eac0369:         and the context is popped off the stack.
1:883a153:         </UL>
1:eac0369: 
1:883a153:         @exception StandardException Standard Derby error policy
1:eac0369: 
1:883a153:         @see Transaction
1:883a153:         @see org.apache.derby.iapi.services.context.Context
1:883a153:         @see StandardException
1:883a153:     */
1:883a153:     public Transaction startInternalTransaction(ContextManager contextMgr) throws StandardException;
1:eac0369: 
1:883a153:     /**
1:883a153:         Create a nested user transaction, almost all work within the raw store 
1:eac0369:         is performed in the context of a transaction.
1:883a153:         <P>
1:eac0369:         A nested user transaction is exactly the same as a user transaction,
1:eac0369:         except that one can specify a compatibility space to associate with
1:eac0369:         the transaction.
1:883a153:         Starting a transaction always performs the following steps.
1:883a153:         <OL>
1:883a153:         <LI>Create an raw store transaction context
1:883a153:         <LI>Create a new idle transaction and then link it to the context.
1:883a153:         </UL>
1:883a153:         Only one user transaction and one nested user transaction can be active
1:eac0369:         in a context at any one time.
1:883a153:         After a commit the transaction may be re-used.
1:883a153:         <P>
1:883a153:         <B>Raw Store Transaction Context Behaviour</B>
1:883a153:         <BR>
1:883a153:         The cleanupOnError() method of this context behaves as follows:
1:883a153:         <UL>
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:eac0369:         no action is taken.
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:eac0369:         the context's transaction is aborted, and the transaction returned to
1:eac0369:         the idle state.  If a user transaction exists on the context stack
1:eac0369:         then that transaction is aborted also.
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
1:eac0369:         then the context's transaction is aborted, the transaction closed, and
1:eac0369:         the context is popped off the stack.
1:883a153:         <LI>
1:883a153:         If error is not an instance of StandardException then the context's
1:883a153:         transaction is aborted, the transaction closed, and the
1:883a153:         context is popped off the stack.
1:883a153:         </UL>
1:eac0369: 
1:9819cf8:         @param parentTransaction parent transaction
1:883a153:         @param compatibilitySpace compatibility space to use for locks.
1:883a153:         @param contextMgr is the context manager to use.  An exception will be
1:883a153:         thrown if context is not the current context.
1:eac0369:         @param transName is the name of the transaction. This name will be 
1:eac0369:         displayed by the transactiontable VTI.
1:eac0369: 
1:883a153:         @exception StandardException Standard Derby error policy
1:eac0369: 
1:883a153:         @see Transaction
1:883a153:         @see org.apache.derby.iapi.services.context.Context
1:883a153:         @see StandardException
1:883a153:     */
1:eac0369: 
1:883a153:     public Transaction startNestedReadOnlyUserTransaction(
1:9819cf8:     Transaction parentTransaction,
1:3c1f634:     CompatibilitySpace compatibilitySpace,
1:eac0369:     ContextManager contextMgr,
2:eac0369:     String         transName)
1:eac0369:         throws StandardException;
1:eac0369: 
1:883a153:     /**
1:883a153:         Create a nested user transaction, almost all work within the raw store 
1:eac0369:         is performed in the context of a transaction.
1:883a153:         <P>
1:eac0369:         A nested user transaction is exactly the same as a user transaction,
1:eac0369:         except that one can specify a compatibility space to associate with
1:eac0369:         the transaction.
1:883a153:         Starting a transaction always performs the following steps.
1:883a153:         <OL>
1:883a153:         <LI>Create an raw store transaction context
1:883a153:         <LI>Create a new idle transaction and then link it to the context.
1:883a153:         </UL>
1:883a153:         Only one user transaction and one nested user transaction can be active
1:eac0369:         in a context at any one time.
1:883a153:         After a commit the transaction may be re-used.
1:883a153:         <P>
1:883a153:         <B>Raw Store Transaction Context Behaviour</B>
1:883a153:         <BR>
1:883a153:         The cleanupOnError() method of this context behaves as follows:
1:883a153:         <UL>
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:eac0369:         no action is taken.
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:eac0369:         the context's transaction is aborted, and the transaction returned to
1:eac0369:         the idle state.  If a user transaction exists on the context stack
1:eac0369:         then that transaction is aborted also.
1:883a153:         <LI>
1:883a153:         If error is an instance of StandardException that
1:883a153:         has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
1:eac0369:         then the context's transaction is aborted, the transaction closed, and
1:eac0369:         the context is popped off the stack.
1:883a153:         <LI>
1:883a153:         If error is not an instance of StandardException then the context's
1:883a153:         transaction is aborted, the transaction closed, and the
1:883a153:         context is popped off the stack.
1:883a153:         </UL>
1:eac0369: 
1:9819cf8:         @param parentTransaction parent transaction
1:883a153:         @param contextMgr is the context manager to use.  An exception will be
1:883a153:         thrown if context is not the current context.
1:eac0369:         @param transName is the name of the transaction. This name will be 
1:eac0369:         displayed by the transactiontable VTI.
1:ceaf7df:         @param flush_log_on_xact_end    By default should the transaction 
1:ceaf7df:         commit and abort be synced to the log.  Normal usage should pick true, 
1:ceaf7df:         unless there is specific performance need and usage works correctly if 
1:ceaf7df:         a commit can be lost on system crash.
1:eac0369: 
1:883a153:         @exception StandardException Standard Derby error policy
1:eac0369: 
1:883a153:         @see Transaction
1:883a153:         @see org.apache.derby.iapi.services.context.Context
1:883a153:         @see StandardException
1:883a153:     */
1:eac0369: 
1:883a153:     public Transaction startNestedUpdateUserTransaction(
1:9819cf8:     Transaction parentTransaction,
1:eac0369:     ContextManager contextMgr,
1:ceaf7df:     String         transName,
1:ceaf7df:     boolean        flush_log_on_xact_end)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 
1:883a153:     /**
1:883a153:       @see org.apache.derby.iapi.store.access.AccessFactory#getTransactionInfo
1:883a153:      */
1:883a153:     public TransactionInfo[] getTransactionInfo();
1:eac0369: 
1:4aeada8:     /**
1:4aeada8:      * Start the replication master role for this database
1:964abfa:      * @param dbmaster The master database that is being replicated.
1:4aeada8:      * @param host The hostname for the slave
1:4aeada8:      * @param port The port the slave is listening on
1:4aeada8:      * @param replicationMode The type of replication contract.
1:4aeada8:      * Currently only asynchronous replication is supported, but
1:4aeada8:      * 1-safe/2-safe/very-safe modes may be added later.
1:4aeada8:      * @exception StandardException Standard Derby exception policy,
1:4aeada8:      * thrown on error.
1:54be3b4:      */
1:964abfa:     public void startReplicationMaster(String dbmaster, String host, int port,
1:4aeada8:                                        String replicationMode)
1:4aeada8:         throws StandardException;
1:54be3b4:     
1:54be3b4:     /**
1:54be3b4:      * Stop the replication master role for this database.
1:fbb8866:      * 
1:54be3b4:      * @exception StandardException Standard Derby exception policy,
1:54be3b4:      * thrown on error.
1:651c99e:      */
1:54be3b4:     public void stopReplicationMaster() throws StandardException;
1:fd20d6b:         
1:fd20d6b:     /**
1:fd20d6b:      * Start failover for this database.
1:fbb8866:      *
1:fd20d6b:      * @param dbname the replication database that is being failed over.
1:fbb8866:      * 
1:fd20d6b:      * @exception StandardException Standard Derby exception policy,
1:fd20d6b:      *                           1) If the failover succeeds, an exception is
1:fd20d6b:      *                              thrown to indicate that the master database
1:fd20d6b:      *                              was shutdown after a successful failover
1:fd20d6b:      *                           2) If a failure occurs during network 
1:fd20d6b:      *                              communication with slave.
1:fd20d6b:      */
1:fd20d6b:     public void failover(String dbname) throws StandardException;
1:4aeada8: 
1:883a153:     /**
1:883a153:       * Freeze the database temporarily so a backup can be taken.
1:883a153:       * <P>Please see Derby on line documentation on backup and restore.
1:883a153:       *
1:883a153:       * @exception StandardException Thrown on error
1:883a153:       */
1:883a153:     public void freeze() throws StandardException;
1:eac0369: 
1:883a153:     /**
1:883a153:       * Unfreeze the database after a backup has been taken.
1:883a153:       * <P>Please see Derby on line documentation on backup and restore.
1:883a153:       *
1:883a153:       * @exception StandardException Thrown on error
1:883a153:       */
1:883a153:     public void unfreeze() throws StandardException;
1:eac0369: 
1:883a153:     /**
1:883a153:       * Backup the database to backupDir.  
1:883a153:       * <P>Please see Derby on line documentation on backup and restore.
1:883a153:       *
1:883a153:       * @param backupDir the name of the directory where the backup should be
1:fbb8866:       *                  stored.
1:fbb8866:       * @param wait      if <tt>true</tt>, waits for  all the backup blocking 
1:fbb8866:       *                  operations in progress to finish.
1:fbb8866:       * 
1:fbb8866:       * @exception StandardException Thrown on error
1:883a153:       */
1:fbb8866:     public void backup(
1:fbb8866:     String backupDir, 
1:fbb8866:     boolean wait) throws StandardException;
1:883a153: 
1:eac0369:         
1:883a153:     /**
1:883a153:      * Backup the database to a backup directory and enable the log archive
1:883a153:      * mode that will keep the archived log files required for roll-forward
1:883a153:      * from this version backup.
1:fbb8866:      *
1:883a153:      * @param backupDir                     the directory name where the 
2:fbb8866:      *                                      database backup should go.  This 
2:fbb8866:      *                                      directory will be created if not it
2:fbb8866:      *                                      does not exist.
1:fd20d6b:      *
1:883a153:      * @param deleteOnlineArchivedLogFiles  If true deletes online archived log
2:fbb8866:      *                                      files that exist before this backup,
2:fbb8866:      *                                      delete will occur only after backup
2:fbb8866:      *                                      is complete.
1:fd20d6b:      *
1:fbb8866:      * @param wait if <tt>true</tt>, waits for  all the backup blocking 
1:883a153:      *             operations in progress to finish.
1:fbb8866:      *
1:fbb8866:      * @exception StandardException Thrown on error
1:883a153:      */
2:fbb8866:     public void backupAndEnableLogArchiveMode(
1:fbb8866:     String  backupDir, 
1:fbb8866:     boolean deleteOnlineArchivedLogFiles,
1:fbb8866:     boolean wait) 
1:883a153:         throws StandardException;
1:883a153:         
1:883a153:     /**
1:883a153:      * disables the log archival process, i.e No old log files
1:883a153:      * will be kept around for a roll-forward recovery.
1:fbb8866:      *
1:883a153:      * @param deleteOnlineArchivedLogFiles  If true deletes all online archived
1:fbb8866:      *                                      log files that exist before this 
1:fbb8866:      *                                      call immediately; Only restore that
1:fbb8866:      *                                      can be performed after disabling 
1:fbb8866:      *                                      log archive mode is version 
1:fbb8866:      *                                      recovery.
1:fbb8866:      *
1:883a153:      * @exception StandardException Thrown on error
1:883a153:      */
1:883a153:     public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
1:883a153:         throws StandardException;
1:eac0369: 
1:eac0369: 
1:883a153:     /**
1:731568d:         Checkpoint the database.
1:731568d: 
1:731568d:         The raw store will wait for any current checkpoints to complete.  It
1:731568d:         will start a new checkpoint and not return until that checkpoint 
1:731568d:         completes.
1:eac0369: 
1:883a153:         @exception StandardException Standard Derby error policy
1:883a153:     */
1:883a153:     public void checkpoint() throws StandardException;
1:eac0369: 
1:eac0369: 
1:883a153:     /**
1:883a153:         Idle the raw store as much as possible. 
1:883a153:         @exception StandardException Standard Derby error policy
1:eac0369: 
1:883a153:     */
1:883a153:     public void idle() throws StandardException;
1:eac0369: 
1:883a153:     /**
1:883a153:         Get a flushed scan.
1:883a153:         @param start The instant for the beginning of the scan.
1:883a153:         @param groupsIWant log record groups the caller wants to scan.
1:883a153:         @exception StandardException StandardDerby error policy
1:883a153:         */
1:883a153:     ScanHandle openFlushedScan(DatabaseInstant start, int groupsIWant) 
1:883a153:          throws StandardException;
1:883a153: 
1:eac0369:     
1:883a153:     /**
1:883a153:         If this raw store has a daemon that services its need, return the
1:883a153:         daemon.  If not, return null
1:883a153:     */
1:883a153:     public DaemonService getDaemon();
1:eac0369: 
1:eac0369: 
1:883a153:     /*
1:883a153:      * return the transaction factory module 
1:883a153:      */
1:883a153:     public String getTransactionFactoryModule();
1:eac0369: 
1:883a153:     /*
1:883a153:      * return the data factory module 
1:883a153:      */
1:883a153:     public String getDataFactoryModule();
1:eac0369: 
1:883a153:     /*
1:883a153:      * return the Log factory module 
1:883a153:      */
1:883a153:     public String getLogFactoryModule();
1:eac0369: 
1:883a153:     /*
1:883a153:      * Return the module providing XAresource interface to the transaction 
1:eac0369:      * table. 
1:fbb8866:      *
1:883a153:      * @exception StandardException Standard Derby exception policy.
1:883a153:      */
1:883a153:     public /* XAResourceManager */ Object getXAResourceManager()
1:eac0369:         throws StandardException;
1:eac0369: 
1:883a153:     /*
1:883a153:      * the database creation phase is finished
1:883a153:      * @exception StandardException Standard Derby exception policy.
1:883a153:      */
1:883a153:     public void createFinished() throws StandardException;
1:eac0369: 
1:883a153:     /**
1:c6892a1:      * Get JBMS properties relevant to raw store
1:883a153:      *
1:883a153:      * @exception StandardException Standard Derby exception policy.
1:883a153:      */
1:883a153:     public void getRawStoreProperties(PersistentSet tc) 
1:883a153:          throws StandardException; 
1:eac0369: 
1:883a153:     /**
1:883a153:      *  Backup / restore support
1:883a153:      */
1:eac0369: 
1:883a153:     /**
1:883a153:      * Freeze the database from altering any persistent storage.
1:883a153:      *
1:883a153:      * @exception StandardException Standard Derby exception policy.
1:883a153:      */
1:883a153:     public void freezePersistentStore() throws StandardException;
1:eac0369: 
1:883a153:     /**
1:883a153:      * Unfreeze the database, persistent storage can now be altered.
1:883a153:      *
1:883a153:      * @exception StandardException Standard Derby exception policy.
1:883a153:      */
1:883a153:     public void unfreezePersistentStore() throws StandardException;
1:eac0369: 
1:883a153:     /**
1:883a153:         Encrypt cleartext into ciphertext.
1:eac0369: 
1:883a153:         @see org.apache.derby.iapi.services.crypto.CipherProvider#encrypt
1:883a153:         @exception StandardException Standard Derby Error Policy
1:883a153:      */
1:883a153:     public int encrypt(byte[] cleartext, int offset, int length, 
1:883a153:                        byte[] ciphertext, int outputOffset,
1:ae71c74:                        boolean newEngine) 
1:883a153:          throws StandardException ;
1:eac0369: 
1:883a153:     /**
1:883a153:         Decrypt cleartext from ciphertext.
1:eac0369: 
1:883a153:         @see org.apache.derby.iapi.services.crypto.CipherProvider#decrypt
1:883a153:         @exception StandardException Standard Derby Error Policy
1:883a153:      */
1:883a153:     public int decrypt(byte[] ciphertext, int offset, int length, 
1:883a153:                        byte[] cleartext, int outputOffset) 
1:883a153:          throws StandardException ;
1:eac0369: 
1:883a153:     /**
1:883a153:         Returns the encryption block size used during creation of the encrypted database
1:883a153:      */
1:883a153:     public int getEncryptionBlockSize();
1:eac0369: 
1:883a153:     /**
1:883a153:         Returns a secure random number for this raw store - if database is not
1:883a153:         encrypted, returns 0.
1:883a153:      */
1:883a153:     public int random();
1:eac0369: 
1:883a153:     /**
1:883a153:         Change the boot password.  Return the encrypted form of the secret key.
1:883a153:         The new value must be a String of the form: oldBootPassword, newBootPassword
1:eac0369: 
1:883a153:         @exception StandardException Standard Derby Error Policy
1:883a153:      */
1:883a153:     public Serializable changeBootPassword(Properties properties, Serializable changePassword)
1:883a153:          throws StandardException ;
1:eac0369: 
2:047a763:     /**
1:eac0369:      * Return an id which can be used to create a container.
1:eac0369:      * <p>
1:eac0369:      * Return an id number with is greater than any existing container
1:eac0369:      * in the current database.  Caller will use this to allocate future
1:eac0369:      * container numbers - most likely caching the value and then incrementing
1:eac0369:      * it as it is used.
1:eac0369:      * <p>
1:54be3b4:      *
1:883a153:      * @return The an id which can be used to create a container.
12:eac0369:      *
1:883a153:      * @exception  StandardException  Standard exception policy.
2:eac0369:      **/
1:eac0369:     long getMaxContainerId()
1:883a153:         throws StandardException;
1:402725c: 
1:402725c: 
1:402725c:     /**
1:883a153:         Get the Transaction Factory to use with this store.
1:883a153:     */
1:883a153:     public TransactionFactory getXactFactory();
1:b61f876: 
1:b61f876:     /**
1:b61f876:      *  Check to see if a database has been upgraded to the required
1:b61f876:      *  level in order to use a store feature.
1:b61f876:      *
1:b61f876:      * @param requiredMajorVersion  required database Engine major version
1:b61f876:      * @param requiredMinorVersion  required database Engine minor version
1:b61f876:      * @param feature               Non-null to throw an exception, null to 
1:b61f876:      *                              return the state of the version match.
1:b61f876:      *
1:b61f876:      * @return <code> true </code> if the database has been upgraded to 
1:b61f876:      *         the required level, <code> false </code> otherwise.
1:b61f876:      *
1:b61f876:      * @exception  StandardException 
1:b61f876:      *             if the database is not at the require version 
1:b61f876:      *             when <code>feature</code> feature is 
1:b61f876:      *             not <code> null </code>. 
1:b61f876:      */
1:883a153:     public boolean checkVersion(
1:b61f876:     int     requiredMajorVersion, 
1:b61f876:     int     requiredMinorVersion, 
1:b61f876:     String  feature) 
1:b61f876:         throws StandardException;
1:651c99e:     
1:651c99e:     /**
1:651c99e:      *  Use the available storage factory handle to create a readme
1:651c99e:      *   file in "seg0" directory warning users to not edit/delete
1:651c99e:      *   any files in the directory to avoid database corruption.
1:651c99e:      * 
1:651c99e:      * @throws StandardException
1:402725c:      */
1:651c99e:     public void createDataWarningFile() throws StandardException;
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:         MAX_CONTAINER_INITIAL_PAGES.  Values &lt; 1 will
1:         be set to 1 and values &gt; MAX_CONTAINER_INITIAL_PAGES will be set to
commit:9819cf8
/////////////////////////////////////////////////////////////////////////
1:         @param parentTransaction parent transaction
/////////////////////////////////////////////////////////////////////////
1:     Transaction parentTransaction,
/////////////////////////////////////////////////////////////////////////
1:         @param parentTransaction parent transaction
/////////////////////////////////////////////////////////////////////////
1:     Transaction parentTransaction,
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:         Register a handler class for insert undo events.
1:         <P>
1:         Register a class to be called when an undo of an insert 
1:         is executed.  When an undo of an event is executed by
1:         the raw store UndoHandler.insertUndoNotify() will be
1:         called, allowing upper level callers to execute code
1:         as necessary.  The initial need is for the access layer
1:         to be able to queue post commit reclaim space in the
1:         case of inserts which are aborted (including the normal
1:         case of inserts failed for duplicate key violations)
1:         (see DERBY-4057)
1: 
1:         @exception StandardException Standard Derby error policy
1: 
1:     */
1:     public void setUndoInsertEventHandler(
1:         UndoHandler undo_handle) throws StandardException;
1: 
commit:ceaf7df
/////////////////////////////////////////////////////////////////////////
1:         @param flush_log_on_xact_end    By default should the transaction 
1:         commit and abort be synced to the log.  Normal usage should pick true, 
1:         unless there is specific performance need and usage works correctly if 
1:         a commit can be lost on system crash.
/////////////////////////////////////////////////////////////////////////
1:     String         transName,
1:     boolean        flush_log_on_xact_end)
commit:883a153
/////////////////////////////////////////////////////////////////////////
1:     RawStoreFactory implements a single unit of transactional
1:     storage. A RawStoreFactory contains Segments and Segments
1:     contain Containers.
1:     <P>
1:     Segments are identified
1:     by integer identifiers that are unique within a RawStoreFactory.
1:     <P>
1:     Containers are also identified by unique integer identifiers
1:     within a RawStoreFactory, but will overlap with segment identifiers.
1:     <P><B>LIMITS</B><BR>
1:     This is a list of (hopefully) all limits within the raw store. Where a size 
1:     <UL>
1:     <LI>Field - 
1:         <UL>
1:         <LI>Max length 2^31 - 1  (2147483647) - 
1:         </UL>
1:     <LI>Record - 
1:         <UL>
1:         <LI>Max number of fields 2^31 - 1  (2147483647) - from use of Object[] 
1:         </UL>
1:     <LI>Page -
1:     <LI>Container -
1:     <LI>Segment -
1:     <LI>Raw Store -
1:     </UL>
1:     <P>
1:     Access and RawStore work together to provide the ACID properties of
1:     transactions. On a high level, RawStore deals with anything that directly
1:     impacts persistency. On a more detailed level, RawStore provides
1:     logging, rollback and recovery, data management on page, page allocation
1:     and deallocation, container allocation and deallocation.  
1:     <P>
1:     RawStore is organized as 3 branches, transaction, data, and
1:     logging.  These branches each have its own "factory", the transaction
1:     factory hands out transactions, the data factory hands out containers,
1:     and the log factory hands out logger (or log buffers) for transactions to
1:     write on.  For a more detailed description on these factories, please see
1:     their corresponding javadocs.
1:     MT - Thread Safe
1:     @see ContainerHandle */
1:     /** Store engine version numbers indicating the database must be upgraded to 
1:      * or created at the current engine level 
1:      */
1:     /** Derby Store Minor Version (1) **/
1:     public static final int DERBY_STORE_MINOR_VERSION_1    = 1;
1:     public static final int DERBY_STORE_MINOR_VERSION_2    = 2;
1:     /** Derby Store Minor Version (3) **/
1:     public static final int DERBY_STORE_MINOR_VERSION_3    = 3;
1:     /** Derby Store Minor Version (4) **/
1:     public static final int DERBY_STORE_MINOR_VERSION_4    = 4;
1:     /** Derby 10 Store Major version */
1:     public static final int DERBY_STORE_MAJOR_VERSION_10   = 10;
1:     /**
1:         Default value for PAGE_SIZE_PARAMETER (4096).
1:     */
1:     public static final int PAGE_SIZE_DEFAULT = 4096;
1:     /**
1:         Minimum page size we will accept (1024).
1:     */
1:     public static final int PAGE_SIZE_MINIMUM = 1024;
1:     public static final String PAGE_SIZE_STRING = "2048";
1:     /** Property name for the page cache size to be used in the storage area.
1:     Equal to 'derby.storage.pageCacheSize'
1:     */
1:     public static final String PAGE_CACHE_SIZE_PARAMETER = 
1:     /**
1:         Default value for PAGE_CACHE_SIZE_PARAMETER (1000).
1:     */
1:     public static final int PAGE_CACHE_SIZE_DEFAULT = 1000;
1:     /**
1:         Minimum page cache size we will accept (40).
1:     */
1:     public static final int PAGE_CACHE_SIZE_MINIMUM = 40;
1:     /**
1:         Maximum page cache size we will accept (MAXINT).
1:     */
1:     public static final int PAGE_CACHE_SIZE_MAXIMUM = Integer.MAX_VALUE;
1:     /** Property name for the number of open files to maintain associated with
/////////////////////////////////////////////////////////////////////////
1:     */
1:     public static final String CONTAINER_CACHE_SIZE_PARAMETER = 
1:     /**
1:         Default value for CONTAINER_CACHE_SIZE_PARAMETER (100).
1:     */
1:     public static final int CONTAINER_CACHE_SIZE_DEFAULT = 100;
1:     /**
1:         Minimum container cache size accepted (2).
1:     */
1:     public static final int CONTAINER_CACHE_SIZE_MINIMUM = 2;
1:     /**
1:         Maximum container cache size we will accept (MAXINT).
1:     */
1:     public static final int CONTAINER_CACHE_SIZE_MAXIMUM = Integer.MAX_VALUE;
1:     /**
1:         Maximum number of initial pages when a container is created
1:     */
1:     public static final short MAX_CONTAINER_INITIAL_PAGES = 1000;
1:     /** Property name for the default minimum record size to be used in the 
1:     */
1:     public static final String MINIMUM_RECORD_SIZE_PARAMETER = 
1:     /**
1:         Default value for MINIMUM_RECORD_SIZE_PARAMETER for heap tables that 
/////////////////////////////////////////////////////////////////////////
1:     */
1:     public static final int MINIMUM_RECORD_SIZE_DEFAULT = 12;
1:     /**
1:         Minimum value for MINIMUM_RECORD_SIZE_PARAMETER (1).
1:     */
1:     public static final int MINIMUM_RECORD_SIZE_MINIMUM = 1;
1:     /** Property name for percentage of space to leave free on page for updates.
1:     */
1:     public static final String PAGE_RESERVED_SPACE_PARAMETER = 
1:     public static final String PAGE_RESERVED_ZERO_SPACE_STRING = "0";
1:     /** Property name for the number of pages we try to pre-allocate in one
1:     /** synchronous I/O
1:     */
1:     public static final String PRE_ALLOCATE_PAGE = 
1:     /**
1:         Property name for container which reuses recordId when a page is
1:         reused.  Defaults to false, which means recordId is never reused.   
1:         This property should NOT be set by the end user, only Access should set
1:         it for special conglomerates which does not count on permanant unique
1:         recordIds for all records.
1:     */
1:     public static final String PAGE_REUSABLE_RECORD_ID = 
1:     /**
1:         Property name for buffer size to be used in the stream file container.
1:         Equal to 'derby.storage.streamFileBufferSize'
1:     */
1:     public static final String STREAM_FILE_BUFFER_SIZE_PARAMETER = 
1:     /**
1:         Default value for STREAM_FILE_BUFFER_SIZE_PARAMETER (16384).
1:     */
1:     public static final int STREAM_FILE_BUFFER_SIZE_DEFAULT = 16384;
1:     /**
1:         Minimum stream file buffer size we will accept (1024).
1:     */
1:     public static final int STREAM_FILE_BUFFER_SIZE_MINIMUM = 1024;
1:     /**
1:         Maximum stream file buffer size we will accept (MAXINT).
1:     */
1:     public static final int STREAM_FILE_BUFFER_SIZE_MAXIMUM = 
1:     /**
1:         Property name for container which attempts to be created with an
1:         initial size of this many pages.  Defaults to 1 page.  
1:         <BR>All containers are guarenteed to be created with at least 1 page,
1:         if this property is set, it will attempt to allocate
1:         CONTAINER_INITIAL_PAGES, but with no guarentee.
1:         CONTAIENR_INITIAL_PAGES legally ranges from 1 to
0:         MAX_CONTAINER_INITIAL_PAGES.  Values < 1 will
0:         be set to 1 and values > MAX_CONTAINER_INITIAL_PAGES will be set to
1:         MAX_CONTAINER_INITIAL_PAGES
1:         This property should only be set in the PROPERTIES list in a CREATE
1:         TABLE or CREATE INDEX statement.  The global setting of this property
1:         has no effect. 
1:     */
1:     public static final String CONTAINER_INITIAL_PAGES = 
1:     /**
1:         encryption alignment requirement.
1:      */
1:     public static final int ENCRYPTION_ALIGNMENT = 8;
1:     /**
1:         default encryption block size
1:         In old existing databases (ie 5.1.x), the default
1:         encryption block size used is 8. Do not change this value unless you 
1:         account for downgrade issues
1:      */
1:     public static final int DEFAULT_ENCRYPTION_BLOCKSIZE = 8;
1:     /**
1:         encryption block size used during creation of encrypted database
1:         This property is not set by the user; it is set by the engine when
1:         RawStore boots up during creation of an encrypted database
1:     */
1:     public static final String ENCRYPTION_BLOCKSIZE = "derby.encryptionBlockSize";
1:     /**
1:         This variable is used to store the encryption scheme to allow
1:         for any future changes in encryption schemes of data 
1:         This property has been introduced in version 10
1:         Value starts at 1
1:      */
1:     public static final String DATA_ENCRYPT_ALGORITHM_VERSION="data_encrypt_algorithm_version";
1:     /**
1:         This will allow for any future changes in encryption schemes of logs
1:         This variable has been introduced in version 10 and value starts at 1.
1:      */
1:     public static final String LOG_ENCRYPT_ALGORITHM_VERSION="log_encrypt_algorithm_version";
1:     /**
1:         If dataEncryption is true, store the encrypted key in
1:         services.properties file. It is really the encrypted
1:         key, but the property key is called the encryptedBootPassword.
1:      */
1:     public static final String ENCRYPTED_KEY = 
/////////////////////////////////////////////////////////////////////////
1:      */
1:     public static final String OLD_ENCRYPTED_KEY = 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      */
1:     String CRYPTO_OLD_EXTERNAL_KEY_VERIFY_FILE = "verifyOldKey.dat";
1:     /**
1:      *  for debugging, keep all transaction logs intact.
1:      */
1:     public static final String KEEP_TRANSACTION_LOG = 
1:       * the page on the disk is corrupted and is getting exceptions like
1:       * invalid page format ids, we cook up the page during the recovery time.
1:       * We have seen this kind of problem with 1.5.1 databases from
1:       * customer Tridium ( Bug no: 3813).
1:       * This patch needs to be kept unless we find the problem is during
1:       * recovery process. If we discover this problem is actaully happening
1:       * at the recovery then this patch should be backed out.
1:       **/
1:     public static final String PATCH_INITPAGE_RECOVER_ERROR = 
1:     /** module name */
1:     public static final String MODULE = 
1:     /**
1:         Is the store read-only.
1:     */
1:     public boolean isReadOnly();
1:     /**
1:         Get the LockFactory to use with this store.
1:     */
1:     public LockFactory getLockFactory();
1:     /**
1:         Create a user transaction, almost all work within the raw store is
1:         <P>
1:         Starting a transaction always performs the following steps.
1:         <OL>
1:         <LI>Create an raw store transaction context
1:         <LI>Create a new idle transaction and then link it to the context.
1:         </UL>
1:         Only one user transaction and one nested user transaction can be active
1:         After a commit the transaction may be re-used.
1:         <P>
1:         <B>Raw Store Transaction Context Behaviour</B>
1:         <BR>
1:         The cleanupOnError() method of this context behaves as follows:
1:         <UL>
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
1:         <LI>
1:         If error is not an instance of StandardException then the context's
1:         transaction is aborted, the transaction closed, and the
1:         context is popped off the stack.
1:         </UL>
1:         @param contextMgr is the context manager to use.  An exception will be
1:         thrown if context is not the current context.
1:         @exception StandardException Standard Derby error policy
1:         @see Transaction
1:         @see org.apache.derby.iapi.services.context.Context
1:         @see StandardException
1:     */
1:     public Transaction startTransaction(
1:     /**
1:         Create a global user transaction, almost all work within the raw store
1:         <P>
1:         Starting a transaction always performs the following steps.
1:         <OL>
1:         <LI>Create an raw store transaction context
1:         <LI>Create a new idle transaction and then link it to the context.
1:         </UL>
1:         Only one user transaction can be active in a context at any one time.
1:         After a commit the transaction may be re-used.
1:         <P>
1:         <B>Raw Store Transaction Context Behaviour</B>
1:         <BR>
1:         The cleanupOnError() method of this context behaves as follows:
1:         <UL>
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then 
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY 
1:         <LI>
1:         If error is not an instance of StandardException then the context's
1:         transaction is aborted, the transaction closed, and the
1:         context is popped off the stack.
1:         </UL>
1:         @param contextMgr is the context manager to use.  An exception will be
1:                           thrown if context is not the current context.
1:         @exception StandardException Standard Derby error policy
1:         @see Transaction
1:         @see org.apache.derby.iapi.services.context.Context
1:         @see StandardException
1:     */
1:     public Transaction startGlobalTransaction(
/////////////////////////////////////////////////////////////////////////
1:     /**
1:         Find a user transaction in the context manager, which must be the
1:         current context manager.  If a user transaction does not already exist,
1:         then create one @see #startTransaction
1:         @param contextMgr the context manager to use.  An exception will be 
1:         @exception StandardException Standard Derby error policy
1:         @see #startTransaction
1:     */
1:     public Transaction findUserTransaction(
1:     /**
1:         Create an internal transaction.
1:         <P>
1:         Starting an internal transaction always performs the following steps.
1:         <OL>
1:         <LI>Create an raw store internal transaction context
1:         <LI>Create a new idle internal transaction and then link it to the 
1:         </UL>
1:         <P>
1:         AN internal transaction is identical to a user transaction with the 
1:         <UL>
1:         <LI> Logical operations are not supported
1:         <LI> Savepoints are not supported
1:         <LI> Containers are not closed when commit() is called.
1:         <LI> Pages are not unlatched (since containers are not closed) when 
1:         <LI> During recovery time internal transactions are rolled back before 
1:         </UL>
1:         Only one internal transaction can be active in a context at any one time.
1:         After a commit the transaction may be re-used.
1:         <P>
1:         <B>Raw Store Internal Transaction Context Behaviour</B>
1:         <BR>
1:         The cleanupOnError() method of this context behaves as follows:
1:         <UL>
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:         the internal transaction is aborted, the internal transaction is closed,        the context is popped off the stack, and an exception of severity 
1:         <LI>
1:         If error is an instance of StandardException that has a severity 
1:         <LI>
1:         If error is not an instance of StandardException then the context's
1:         internal transaction is aborted, the internal transaction is closed 
1:         </UL>
1:         @exception StandardException Standard Derby error policy
1:         @see Transaction
1:         @see org.apache.derby.iapi.services.context.Context
1:         @see StandardException
1:     */
1:     public Transaction startInternalTransaction(ContextManager contextMgr) throws StandardException;
1:     /**
1:         Create a nested user transaction, almost all work within the raw store 
1:         <P>
1:         Starting a transaction always performs the following steps.
1:         <OL>
1:         <LI>Create an raw store transaction context
1:         <LI>Create a new idle transaction and then link it to the context.
1:         </UL>
1:         Only one user transaction and one nested user transaction can be active
1:         After a commit the transaction may be re-used.
1:         <P>
1:         <B>Raw Store Transaction Context Behaviour</B>
1:         <BR>
1:         The cleanupOnError() method of this context behaves as follows:
1:         <UL>
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
1:         <LI>
1:         If error is not an instance of StandardException then the context's
1:         transaction is aborted, the transaction closed, and the
1:         context is popped off the stack.
1:         </UL>
1:         @param compatibilitySpace compatibility space to use for locks.
1:         @param contextMgr is the context manager to use.  An exception will be
1:         thrown if context is not the current context.
1:         @exception StandardException Standard Derby error policy
1:         @see Transaction
1:         @see org.apache.derby.iapi.services.context.Context
1:         @see StandardException
1:     */
1:     public Transaction startNestedReadOnlyUserTransaction(
1:     /**
1:         Create a nested user transaction, almost all work within the raw store 
1:         <P>
1:         Starting a transaction always performs the following steps.
1:         <OL>
1:         <LI>Create an raw store transaction context
1:         <LI>Create a new idle transaction and then link it to the context.
1:         </UL>
1:         Only one user transaction and one nested user transaction can be active
1:         After a commit the transaction may be re-used.
1:         <P>
1:         <B>Raw Store Transaction Context Behaviour</B>
1:         <BR>
1:         The cleanupOnError() method of this context behaves as follows:
1:         <UL>
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:         <LI>
1:         If error is an instance of StandardException that
1:         has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
1:         <LI>
1:         If error is not an instance of StandardException then the context's
1:         transaction is aborted, the transaction closed, and the
1:         context is popped off the stack.
1:         </UL>
1:         @param contextMgr is the context manager to use.  An exception will be
1:         thrown if context is not the current context.
1:         @exception StandardException Standard Derby error policy
1:         @see Transaction
1:         @see org.apache.derby.iapi.services.context.Context
1:         @see StandardException
1:     */
1:     public Transaction startNestedUpdateUserTransaction(
1:     /**
1:       @see org.apache.derby.iapi.store.access.AccessFactory#getTransactionInfo
1:      */
1:     public TransactionInfo[] getTransactionInfo();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:       * Freeze the database temporarily so a backup can be taken.
1:       * <P>Please see Derby on line documentation on backup and restore.
1:       *
1:       * @exception StandardException Thrown on error
1:       */
1:     public void freeze() throws StandardException;
1:     /**
1:       * Unfreeze the database after a backup has been taken.
1:       * <P>Please see Derby on line documentation on backup and restore.
1:       *
1:       * @exception StandardException Thrown on error
1:       */
1:     public void unfreeze() throws StandardException;
1:     /**
1:       * Backup the database to backupDir.  
1:       * <P>Please see Derby on line documentation on backup and restore.
1:       *
1:       * @param backupDir the name of the directory where the backup should be
1:       */
1:         
1:     /**
1:      * Backup the database to a backup directory and enable the log archive
1:      * mode that will keep the archived log files required for roll-forward
1:      * from this version backup.
1:      * @param backupDir                     the directory name where the 
1:      * @param deleteOnlineArchivedLogFiles  If true deletes online archived log
1:      *             operations in progress to finish.
1:      */
1:         throws StandardException;
1:         
1:     /**
1:      * disables the log archival process, i.e No old log files
1:      * will be kept around for a roll-forward recovery.
1:      * @param deleteOnlineArchivedLogFiles  If true deletes all online archived
1:      * @exception StandardException Thrown on error
1:      */
1:     public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
1:         throws StandardException;
1:     /**
1:         @exception StandardException Standard Derby error policy
1:     */
1:     public void checkpoint() throws StandardException;
1:     /**
1:         Idle the raw store as much as possible. 
1:         @exception StandardException Standard Derby error policy
1:     */
1:     public void idle() throws StandardException;
1:     /**
1:         Get a flushed scan.
1:         @param start The instant for the beginning of the scan.
1:         @param groupsIWant log record groups the caller wants to scan.
1:         @exception StandardException StandardDerby error policy
1:         */
1:     ScanHandle openFlushedScan(DatabaseInstant start, int groupsIWant) 
1:          throws StandardException;
1:     
1:     /**
1:         If this raw store has a daemon that services its need, return the
1:         daemon.  If not, return null
1:     */
1:     public DaemonService getDaemon();
1:     /*
1:      * return the transaction factory module 
1:      */
1:     public String getTransactionFactoryModule();
1:     /*
1:      * return the data factory module 
1:      */
1:     public String getDataFactoryModule();
1:     /*
1:      * return the Log factory module 
1:      */
1:     public String getLogFactoryModule();
1:     /*
1:      * Return the module providing XAresource interface to the transaction 
1:      * @exception StandardException Standard Derby exception policy.
1:      */
1:     public /* XAResourceManager */ Object getXAResourceManager()
1:     /*
1:      * the database creation phase is finished
1:      * @exception StandardException Standard Derby exception policy.
1:      */
1:     public void createFinished() throws StandardException;
1:     /**
0:      * Get JBMS properties relavent to raw store
1:      *
1:      * @exception StandardException Standard Derby exception policy.
1:      */
1:     public void getRawStoreProperties(PersistentSet tc) 
1:          throws StandardException; 
1:     /**
1:      *  Backup / restore support
1:      */
1:     /**
1:      * Freeze the database from altering any persistent storage.
1:      *
1:      * @exception StandardException Standard Derby exception policy.
1:      */
1:     public void freezePersistentStore() throws StandardException;
1:     /**
1:      * Unfreeze the database, persistent storage can now be altered.
1:      *
1:      * @exception StandardException Standard Derby exception policy.
1:      */
1:     public void unfreezePersistentStore() throws StandardException;
1:     /**
1:         Encrypt cleartext into ciphertext.
1:         @see org.apache.derby.iapi.services.crypto.CipherProvider#encrypt
1:         @exception StandardException Standard Derby Error Policy
1:      */
1:     public int encrypt(byte[] cleartext, int offset, int length, 
1:                        byte[] ciphertext, int outputOffset,
1:          throws StandardException ;
1:     /**
1:         Decrypt cleartext from ciphertext.
1:         @see org.apache.derby.iapi.services.crypto.CipherProvider#decrypt
1:         @exception StandardException Standard Derby Error Policy
1:      */
1:     public int decrypt(byte[] ciphertext, int offset, int length, 
1:                        byte[] cleartext, int outputOffset) 
1:          throws StandardException ;
1:     /**
1:         Returns the encryption block size used during creation of the encrypted database
1:      */
1:     public int getEncryptionBlockSize();
1:     /**
1:         Returns a secure random number for this raw store - if database is not
1:         encrypted, returns 0.
1:      */
1:     public int random();
1:     /**
1:         Change the boot password.  Return the encrypted form of the secret key.
1:         The new value must be a String of the form: oldBootPassword, newBootPassword
1:         @exception StandardException Standard Derby Error Policy
1:      */
1:     public Serializable changeBootPassword(Properties properties, Serializable changePassword)
1:          throws StandardException ;
/////////////////////////////////////////////////////////////////////////
1:      * @return The an id which can be used to create a container.
1:      * @exception  StandardException  Standard exception policy.
1:         throws StandardException;
1:         Get the Transaction Factory to use with this store.
1:     */
1:     public TransactionFactory getXactFactory();
/////////////////////////////////////////////////////////////////////////
1:     public boolean checkVersion(
commit:2f41733
/////////////////////////////////////////////////////////////////////////
1:         guarantee there is enough space to update the a head row even if there 
1:         is not enough space on the page.  The 12 bytes of user data along with
1:         the existing space in the record header will guarantee there is room
1:         to write an overflow row header which will use the same initial portion
1:         of the record header and at most 12 additional bytes for an overflow 
1:         pointer (page + id).  Note that this is the "user"
1:         portion of the record.  The record also will contain space for the
1:         "non-user" portion which includes the offset table and the record
1:         header.
1: 
commit:731568d
/////////////////////////////////////////////////////////////////////////
1:         Checkpoint the database.
1: 
1:         The raw store will wait for any current checkpoints to complete.  It
1:         will start a new checkpoint and not return until that checkpoint 
1:         completes.
commit:054acc3
/////////////////////////////////////////////////////////////////////////
1: 
0: 	/** Property name for the number of open files to maintain associated with
1:         the page cache.  Internally this is referred to as the "ContainerCache".
1: 
1:         Each object in this cache maps to a java level "open" file on a file
1:         in the database directory.  Although actual implementation depends on
1:         JVM implementation, this usually maps to underlying open file resources
1:         in the underlying operating system.  Setting this number too high
1:         may result in I/O failures reported by Derby, which are the result 
1:         of hitting some user and/or OS limit on the number of open files
1:         allowed.  These I/O errors may happen during read, write and/or open 
1:         operations.  
1:         Sometimes these limits can be avoided simply by executing an OS 
1:         specific command to raise the maximum open files allowed by whatever
1:         mechanism is used to control resources allowed to be consumed by
1:         the JVM.
1: 
1:         Derby may also open other files separate from this cache, so exausting
1:         the open file resource may cause other operations than I/O to data
1:         pages to fail.  A partial list of these operations includes: 
1:         recovery logging, error logging, external sorting, and 
1:         LOB disk overflow.
1: 
1:         The default maximum size of this cache is 100 open files.
1:         The minimum size of this cache is 2 open files, attempting to set this
1:         cache to a smaller size or a negative number will result in a size 2
1:         cache.  Setting the cache size to a number bigger than an INT, or any
1:         sort of illegal format number will result in a cache size of 100
1:         open files.
1: 
1:         Equal to 'derby.storage.fileCacheSize'
1: 	*/
0: 	public static final String CONTAINER_CACHE_SIZE_PARAMETER = 
1:         "derby.storage.fileCacheSize";
1: 
1: 	/**
0: 		Default value for CONTAINER_CACHE_SIZE_PARAMETER (100).
1: 	*/
0: 	public static final int CONTAINER_CACHE_SIZE_DEFAULT = 100;
1: 
1: 	/**
0: 		Minimum container cache size accepted (2).
1: 	*/
0: 	public static final int CONTAINER_CACHE_SIZE_MINIMUM = 2;
1: 
1: 	/**
0: 		Maximum container cache size we will accept (MAXINT).
1: 	*/
0: 	public static final int CONTAINER_CACHE_SIZE_MAXIMUM = Integer.MAX_VALUE;
1: 
1: 
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1:         
0: 	/** Derby Store Minor Version (4) **/
0: 	public static final int DERBY_STORE_MINOR_VERSION_4    = 4;
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      *  Check to see if a database has been upgraded to the required
1:      *  level in order to use a store feature.
1:      *
1:      * @param requiredMajorVersion  required database Engine major version
1:      * @param requiredMinorVersion  required database Engine minor version
1:      * @param feature               Non-null to throw an exception, null to 
1:      *                              return the state of the version match.
1:      *
1:      * @return <code> true </code> if the database has been upgraded to 
1:      *         the required level, <code> false </code> otherwise.
1:      *
1:      * @exception  StandardException 
1:      *             if the database is not at the require version 
1:      *             when <code>feature</code> feature is 
1:      *             not <code> null </code>. 
1:      */
0: 	public boolean checkVersion(
1:     int     requiredMajorVersion, 
1:     int     requiredMinorVersion, 
1:     String  feature) 
1:         throws StandardException;
commit:ffd4e9b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:402725c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
0: 		Get the Transaction Factory to use with this store.
1: 	*/
0: 	public TransactionFactory getXactFactory();
commit:fbb8866
/////////////////////////////////////////////////////////////////////////
1:       *                  stored.
1:       * @param wait      if <tt>true</tt>, waits for  all the backup blocking 
1:       *                  operations in progress to finish.
1:       * 
1:       * @exception StandardException Thrown on error
1:     public void backup(
1:     String backupDir, 
1:     boolean wait) throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:      *
0: 	 * @param backupDir                     the directory name where the 
1:      *                                      database backup should go.  This 
1:      *                                      directory will be created if not it
1:      *                                      does not exist.
1:      *
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log
1:      *                                      files that exist before this backup,
1:      *                                      delete will occur only after backup
1:      *                                      is complete.
1:      *
1:      * @param wait if <tt>true</tt>, waits for  all the backup blocking 
0: 	 *             operations in progress to finish.
1:      *
1:      * @exception StandardException Thrown on error
1:     public void backupAndEnableLogArchiveMode(
1:     String  backupDir, 
1:     boolean deleteOnlineArchivedLogFiles,
1:     boolean wait) 
0: 	 * @param backupDir                     the directory name where the 
1:      *                                      database backup should go.  This 
1:      *                                      directory will be created if not it 
1:      *                                      does not exist.
1:      *
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log
1:      *                                      files that exist before this backup,
1:      *                                      delete will occur only after backup
1:      *                                      is complete.
1:      *
1: 	public void backupAndEnableLogArchiveMode(
0:     File    backupDir, 
0:     boolean deleteOnlineArchivedLogFiles) 
1:      *
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes all online archived
1:      *                                      log files that exist before this 
1:      *                                      call immediately; Only restore that
1:      *                                      can be performed after disabling 
1:      *                                      log archive mode is version 
1:      *                                      recovery.
1:      *
commit:12c6ed9
/////////////////////////////////////////////////////////////////////////
1:         @param local_id   The branch qualifier of the Xid - ie. 
/////////////////////////////////////////////////////////////////////////
0: 		@param contextMgr the context manager to use.  An exception will be 
1:                           thrown if context is not the current context.
1:         @param transName  If a new transaction is started, it will be given 
1:                           this name.
/////////////////////////////////////////////////////////////////////////
commit:c2afcc1
/////////////////////////////////////////////////////////////////////////
0: 	/** Store engine version numbers indicating the database must be upgraded to 
0: 	 * or created at the current engine level 
1: 	 */
1: 
0: 	/** Derby Store Minor Version (1) **/
0: 	public static final int DERBY_STORE_MINOR_VERSION_1    = 1;
0: 	/** Derby 10 Store Major version */
0: 	public static final int DERBY_STORE_MAJOR_VERSION_10   = 10;
commit:a5bdbd4
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:651c99e
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      *  Use the available storage factory handle to create a readme
1:      *   file in "seg0" directory warning users to not edit/delete
1:      *   any files in the directory to avoid database corruption.
1:      * 
1:      * @throws StandardException
1:      */
1:     public void createDataWarningFile() throws StandardException;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1:      * Get JBMS properties relevant to raw store
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
/////////////////////////////////////////////////////////////////////////
1:     CompatibilitySpace compatibilitySpace,
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:d203eea
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /** Derby Store Minor Version (10) **/
1:     public static final int DERBY_STORE_MINOR_VERSION_10   = 10;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tracks the status of any database-wide cryptographic operations.
1:      * <p>
1:      * The relevant operations are encryption, re-encryption and decryption.
1:      * THe property is required to be able to bring the database back to state
1:      * it was in before the cryptographic operation started in case the
1:      * transformation of the database is aborted.
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:fd20d6b
/////////////////////////////////////////////////////////////////////////
1:         
1:     /**
1:      * Start failover for this database.
1:      *
1:      * @param dbname the replication database that is being failed over.
1:      * 
1:      * @exception StandardException Standard Derby exception policy,
1:      *                           1) If the failover succeeds, an exception is
1:      *                              thrown to indicate that the master database
1:      *                              was shutdown after a successful failover
1:      *                           2) If a failure occurs during network 
1:      *                              communication with slave.
1:      */
1:     public void failover(String dbname) throws StandardException;
commit:964abfa
/////////////////////////////////////////////////////////////////////////
1:      * @param dbmaster The master database that is being replicated.
/////////////////////////////////////////////////////////////////////////
1:     public void startReplicationMaster(String dbmaster, String host, int port,
commit:54be3b4
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Stop the replication master role for this database.
1:      * 
1:      * @exception StandardException Standard Derby exception policy,
1:      * thrown on error.
1:      */
1:     public void stopReplicationMaster() throws StandardException;
commit:4aeada8
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Start the replication master role for this database
1:      * @param host The hostname for the slave
1:      * @param port The port the slave is listening on
1:      * @param replicationMode The type of replication contract.
1:      * Currently only asynchronous replication is supported, but
1:      * 1-safe/2-safe/very-safe modes may be added later.
1:      * @exception StandardException Standard Derby exception policy,
1:      * thrown on error.
0:      */
0:     public void startReplicationMaster(String host, int port,
1:                                        String replicationMode)
1:         throws StandardException;
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 	  * <P>Please see Derby on line documentation on backup and restore.
/////////////////////////////////////////////////////////////////////////
0: 	  * <P>Please see Derby on line documentation on backup and restore.
/////////////////////////////////////////////////////////////////////////
0: 	  * <P>Please see Derby on line documentation on backup and restore.
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby error policy
0: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException StandardDerby error policy
/////////////////////////////////////////////////////////////////////////
0: 	 * @exception StandardException Standard Derby exception policy.
0: 	 * @exception StandardException Standard Derby exception policy.
0: 	 * @exception StandardException Standard Derby exception policy.
/////////////////////////////////////////////////////////////////////////
0: 	 * @exception StandardException Standard Derby exception policy.
0: 	 * @exception StandardException Standard Derby exception policy.
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby Error Policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby Error Policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby Error Policy
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:f824190
/////////////////////////////////////////////////////////////////////////
0: 	/** Derby Store Minor Version (3) **/
0: 	public static final int DERBY_STORE_MINOR_VERSION_3    = 3;
1: 
commit:047a763
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * When the datbase is getting re-encrypted old encrypted key is 
1:      * stored in the service.properties until re-encyrption
1:      * successfully completes or rolled back. It is really the old 
1:      * encryptedkey, but the property key is called the 
1:      * OldEncryptedBootPassword.
0: 	 */
0: 	public static final String OLD_ENCRYPTED_KEY = 
1:         "OldEncryptedBootPassword";
1: 
1: 
1:     /*
0:      * Following property is used to track the status of the (re)encryption,
0:      * required to bring the database back to state it was before the 
0:      * (re) encryption started, id (re) encryption of the database 
0:      * is aborted.
0:      */
1:     public static final String DB_ENCRYPTION_STATUS =
1:         "derby.storage.databaseEncryptionStatus";
1: 
1:     /* (re)encryption is in progress, if a crash 
1:      *  occurs after this flag is set, 
1:      * (re)encryption needs to  be undone.
0:      */
1:     public static final int DB_ENCRYPTION_IN_PROGRESS   = 1;
1: 
1:     /* this flag is used to track crash during undo
1:        of (re) encryption during recovery .
0:     */
1:     public static final int DB_ENCRYPTION_IN_UNDO      =  2;
1: 
1:     /*
1:      * Cleanup any (re) encryption related resources. 
0:      */
1:     public static final int  DB_ENCRYPTION_IN_CLEANUP  =  3;
1: 
1:     
1: 	/**
1:        A File used to save the old copy of the verify key 
1:        (Attribute.CRYPTO_EXTERNAL_KEY_VERIFY_FILE) file during 
1:        re-encryption of the database. 
0: 	 */
0: 	String CRYPTO_OLD_EXTERNAL_KEY_VERIFY_FILE = "verifyOldKey.dat";
1: 
1: 
1: 
commit:32635d2
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Derby Store Minor Version (2) **/
0: 	public static final int DERBY_STORE_MINOR_VERSION_2    = 2;
1: 
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ae71c74
/////////////////////////////////////////////////////////////////////////
0: 					   byte[] ciphertext, int outputOffset,
1:                        boolean newEngine) 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.raw.RawStoreFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: package org.apache.derby.iapi.store.raw;
1: 
1: import org.apache.derby.iapi.services.daemon.DaemonService;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.locks.LockFactory;
1: 
1: import org.apache.derby.iapi.services.property.PersistentSet;
1: 
1: import org.apache.derby.iapi.store.access.TransactionInfo;
1: 
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.store.access.DatabaseInstant;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
1: import java.util.Properties;
1: import java.io.Serializable;
0: import java.io.File;
1: 
0: /**
0: 	RawStoreFactory implements a single unit of transactional
0: 	storage. A RawStoreFactory contains Segments and Segments
0: 	contain Containers.
1: 	<P>
0: 	Segments are identified
0: 	by integer identifiers that are unique within a RawStoreFactory.
1: 	<P>
0: 	Containers are also identified by unique integer identifiers
0: 	within a RawStoreFactory, but will overlap with segment identifiers.
0: 	<P><B>LIMITS</B><BR>
0: 	This is a list of (hopefully) all limits within the raw store. Where a size 
1:     has more than one limit all are documented (rather than just the most 
1:     restrictive) so that the correct limit can be found if the most restictive 
1:     is every removed.
0: 	<UL>
0: 	<LI>Field - 
0: 		<UL>
0: 		<LI>Max length 2^31 - 1  (2147483647) - 
0: 		</UL>
0: 	<LI>Record - 
0: 		<UL>
0: 		<LI>Max number of fields 2^31 - 1  (2147483647) - from use of Object[] 
1:         array to represent row, which can "only" have int sized number of array
1:         members.
0: 		</UL>
0: 	<LI>Page -
0: 	<LI>Container -
0: 	<LI>Segment -
0: 	<LI>Raw Store -
0: 	</UL>
1: 
1: 	<P>
0: 	Access and RawStore work together to provide the ACID properties of
0: 	transactions. On a high level, RawStore deals with anything that directly
0: 	impacts persistency. On a more detailed level, RawStore provides
0: 	logging, rollback and recovery, data management on page, page allocation
0: 	and deallocation, container allocation and deallocation.  
1: 
1: 
1: 	<P>
0: 	RawStore is organized as 3 branches, transaction, data, and
0: 	logging.  These branches each have its own "factory", the transaction
0: 	factory hands out transactions, the data factory hands out containers,
0: 	and the log factory hands out logger (or log buffers) for transactions to
0: 	write on.  For a more detailed description on these factories, please see
0: 	their corresponding javadocs.
1: 
1: 
0: 	MT - Thread Safe
1: 
0: 	@see ContainerHandle */
1: 
1: 
1: public interface RawStoreFactory extends Corruptable {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 
0: 	/**
0: 		Default value for PAGE_SIZE_PARAMETER (4096).
0: 	*/
0: 	public static final int PAGE_SIZE_DEFAULT = 4096;
1: 
0: 	/**
0: 		Minimum page size we will accept (1024).
0: 	*/
0: 	public static final int PAGE_SIZE_MINIMUM = 1024;
1: 
1: 
0: 	public static final String PAGE_SIZE_STRING = "2048";
1: 
1: 
0: 	/** Property name for the page cache size to be used in the storage area.
0: 	Equal to 'derby.storage.pageCacheSize'
0: 	*/
0: 	public static final String PAGE_CACHE_SIZE_PARAMETER = 
1:         "derby.storage.pageCacheSize";
1: 
0: 	/**
0: 		Default value for PAGE_CACHE_SIZE_PARAMETER (1000).
0: 	*/
0: 	public static final int PAGE_CACHE_SIZE_DEFAULT = 1000;
1: 
0: 	/**
0: 		Minimum page cache size we will accept (40).
0: 	*/
0: 	public static final int PAGE_CACHE_SIZE_MINIMUM = 40;
1: 
0: 	/**
0: 		Maximum page cache size we will accept (MAXINT).
0: 	*/
0: 	public static final int PAGE_CACHE_SIZE_MAXIMUM = Integer.MAX_VALUE;
1: 
0: 	/**
0: 		Maximum number of initial pages when a container is created
0: 	*/
0: 	public static final short MAX_CONTAINER_INITIAL_PAGES = 1000;
1: 
0: 	/** Property name for the default minimum record size to be used in the 
1:         storage area. Minimum record size is the minimum number of bytes that a 
1:         record will reserve on disk.
0: 	*/
0: 	public static final String MINIMUM_RECORD_SIZE_PARAMETER = 
1:         "derby.storage.minimumRecordSize";
0: 	/**
0: 		Default value for MINIMUM_RECORD_SIZE_PARAMETER	for heap tables that 
1:         allow overflow.  By setting minimumRecordSize to 12 bytes, we 
0:         guarantee there is enough space to update the row even there is not
0:         enough space on the page.  The 12 bytes will guarantee there is room
0:         for an overflow pointer (page + id).
0: 	*/
0: 	public static final int MINIMUM_RECORD_SIZE_DEFAULT = 12;
1: 
0: 	/**
0: 		Minimum value for MINIMUM_RECORD_SIZE_PARAMETER (1).
0: 	*/
0: 	public static final int MINIMUM_RECORD_SIZE_MINIMUM = 1;
1: 
0: 	/** Property name for percentage of space to leave free on page for updates.
0: 	*/
0: 	public static final String PAGE_RESERVED_SPACE_PARAMETER = 
1:         "derby.storage.pageReservedSpace";
1: 
0: 	public static final String PAGE_RESERVED_ZERO_SPACE_STRING = "0";
1: 
0: 	/** Property name for the number of pages we try to pre-allocate in one
0: 	/** synchronous I/O
0: 	*/
0: 	public static final String PRE_ALLOCATE_PAGE = 
1:         "derby.storage.pagePerAllocate";
1: 
1: 
0: 	/**
0: 		Property name for container which reuses recordId when a page is
0: 		reused.  Defaults to false, which means recordId is never reused. 	
1: 
0: 		This property should NOT be set by the end user, only Access should set
0: 		it for special conglomerates which does not count on permanant unique
0: 		recordIds for all records.
0: 	*/
0: 	public static final String PAGE_REUSABLE_RECORD_ID = 
1:         "derby.storage.reusableRecordId";
1: 
0: 	/**
0: 		Property name for buffer size to be used in the stream file container.
0: 		Equal to 'derby.storage.streamFileBufferSize'
0: 	*/
0: 	public static final String STREAM_FILE_BUFFER_SIZE_PARAMETER = 
1:         "derby.storage.streamFileBufferSize";
1: 
0: 	/**
0: 		Default value for STREAM_FILE_BUFFER_SIZE_PARAMETER (16384).
0: 	*/
0: 	public static final int STREAM_FILE_BUFFER_SIZE_DEFAULT = 16384;
1: 
0: 	/**
0: 		Minimum stream file buffer size we will accept (1024).
0: 	*/
0: 	public static final int STREAM_FILE_BUFFER_SIZE_MINIMUM = 1024;
1: 
0: 	/**
0: 		Maximum stream file buffer size we will accept (MAXINT).
0: 	*/
0: 	public static final int STREAM_FILE_BUFFER_SIZE_MAXIMUM = 
1:         Integer.MAX_VALUE;
1: 
0: 	/**
1: 
0: 		Property name for container which attempts to be created with an
0: 		initial size of this many pages.  Defaults to 1 page.  
1: 
0: 		<BR>All containers are guarenteed to be created with at least 1 page,
0: 		if this property is set, it will attempt to allocate
0: 		CONTAINER_INITIAL_PAGES, but with no guarentee.
0: 		CONTAIENR_INITIAL_PAGES legally ranges from 1 to
0: 		MAX_CONTAINER_INITIAL_PAGES.  Values < 1 will
0: 		be set to 1 and values > MAX_CONTAINER_INITIAL_PAGES will be set to
0: 		MAX_CONTAINER_INITIAL_PAGES
1: 
0: 		This property should only be set in the PROPERTIES list in a CREATE
0: 		TABLE or CREATE INDEX statement.  The global setting of this property
0: 		has no effect. 
0: 	*/
0: 	public static final String CONTAINER_INITIAL_PAGES = 
1:         "derby.storage.initialPages";
1: 
0: 	/**
0: 		encryption alignment requirement.
0: 	 */
0: 	public static final int ENCRYPTION_ALIGNMENT = 8;
1: 
0: 	/**
0: 		default encryption block size
0: 		In old existing databases (ie 5.1.x), the default
0: 		encryption block size used is 8. Do not change this value unless you 
0: 		account for downgrade issues
0: 	 */
0: 	public static final int DEFAULT_ENCRYPTION_BLOCKSIZE = 8;
1: 
0: 	/**
0: 		encryption block size used during creation of encrypted database
0: 		This property is not set by the user; it is set by the engine when
0: 		RawStore boots up during creation of an encrypted database
0: 	*/
0: 	public static final String ENCRYPTION_BLOCKSIZE = "derby.encryptionBlockSize";
1: 
0: 	/**
1: 
0: 		This variable is used to store the encryption scheme to allow
0: 		for any future changes in encryption schemes of data 
0: 		This property has been introduced in version 10
0: 		Value starts at 1
0: 	 */
0: 	public static final String DATA_ENCRYPT_ALGORITHM_VERSION="data_encrypt_algorithm_version";
1: 
0: 	/**
1:                 Store the encryption scheme used for logging
0: 		This will allow for any future changes in encryption schemes of logs
0: 		This variable has been introduced in version 10 and value starts at 1.
0:  	 */
0: 	public static final String LOG_ENCRYPT_ALGORITHM_VERSION="log_encrypt_algorithm_version";
1: 
0: 	/**
0: 		If dataEncryption is true, store the encrypted key in
0: 		services.properties file. It is really the encrypted
0: 		key, but the property key is called the encryptedBootPassword.
1: 
0: 	 */
0: 	public static final String ENCRYPTED_KEY = 
1:         "encryptedBootPassword";
1: 
1: 
0: 	/**
0: 	 *  for debugging, keep all transaction logs intact.
0: 	 */
0: 	public static final String KEEP_TRANSACTION_LOG = 
1:         "derby.storage.keepTransactionLog";
1: 
0:     /**
1:       * The following is a to enable patch for databases with recovery
1:       * errors during redo of InitPage. If this property is set and
0: 	  * the page on the disk is corrupted and is getting exceptions like
0: 	  * invalid page format ids, we cook up the page during the recovery time.
0: 	  * We have seen this kind of problem with 1.5.1 databases from
0: 	  * customer Tridium ( Bug no: 3813).
0: 	  * This patch needs to be kept unless we find the problem is during
0: 	  * recovery process. If we discover this problem is actaully happening
0: 	  * at the recovery then this patch should be backed out.
1: 	  **/
0: 	public static final String PATCH_INITPAGE_RECOVER_ERROR = 
1:         "derby.storage.patchInitPageRecoverError";
1: 
1: 
0: 	/** module name */
0: 	public static final String MODULE = 
1:         "org.apache.derby.iapi.store.raw.RawStoreFactory";
1: 
0: 	/**
0: 		Is the store read-only.
0: 	*/
0: 	public boolean isReadOnly();
1: 
0: 	/**
0: 		Get the LockFactory to use with this store.
0: 	*/
0: 	public LockFactory getLockFactory();
1: 
1: 
0: 	/**
0: 		Create a user transaction, almost all work within the raw store is
1:         performed in the context of a transaction.
1: 		<P>
0: 		Starting a transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store transaction context
0: 		<LI>Create a new idle transaction and then link it to the context.
0: 		</UL>
0: 		Only one user transaction and one nested user transaction can be active
1:         in a context at any one time.
0: 		After a commit the transaction may be re-used.
1: 		<P>
0: 		<B>Raw Store Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:         no action is taken.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:         the context's transaction is aborted, and the transaction returned to
1:         the idle state.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
1:         then the context's transaction is aborted, the transaction closed, and
1:         the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		transaction is aborted, the transaction closed, and the
0: 		context is popped off the stack.
0: 		</UL>
1: 
0: 		@param contextMgr is the context manager to use.  An exception will be
0: 		thrown if context is not the current context.
1:         @param transName is the name of the transaction. Thsi name will be displayed
1:         by the transactiontable VTI.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
1: 
0: 	public Transaction startTransaction(
1:     ContextManager contextMgr,
1:     String transName)
1:         throws StandardException;
1: 
0: 	/**
0: 		Create a global user transaction, almost all work within the raw store
1:         is performed in the context of a transaction.
1: 		<P>
1:         The (format_id, global_id, branch_id) triplet is meant to come exactly
1:         from a javax.transaction.xa.Xid.  We don't use Xid so that the system
1:         can be delivered on a non-1.2 vm system and not require the javax 
1:         classes in the path.  
1:         <P>
0: 		Starting a transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store transaction context
0: 		<LI>Create a new idle transaction and then link it to the context.
0: 		</UL>
0: 		Only one user transaction can be active in a context at any one time.
0: 		After a commit the transaction may be re-used.
1: 		<P>
0: 		<B>Raw Store Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then 
1:         no action is taken.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:         the context's transaction is aborted, and the transaction returned to 
1:         the idle state.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY 
1:         then the context's transaction is aborted, the transaction closed, and 
1:         the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		transaction is aborted, the transaction closed, and the
0: 		context is popped off the stack.
0: 		</UL>
1: 
0: 		@param contextMgr is the context manager to use.  An exception will be
0: 		                  thrown if context is not the current context.
1:         @param format_id  the format id part of the Xid - ie. Xid.getFormatId().
1:         @param global_id  the global transaction identifier part of XID - ie.
1:                           Xid.getGlobalTransactionId().
0:         @param branch_id  The branch qualifier of the Xid - ie. 
1:                           Xid.getBranchQaulifier()
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
0: 	public Transaction startGlobalTransaction(
1:     ContextManager contextMgr,
1:     int            format_id,
1:     byte[]         global_id,
1:     byte[]         local_id)
1:         throws StandardException;
1: 
1: 
0: 	/**
0: 		Find a user transaction in the context manager, which must be the
0: 		current context manager.  If a user transaction does not already exist,
0: 		then create one @see #startTransaction
1: 
0: 		@param context is the context manager to use.  An exception will be
0: 		thrown if context is not the current context.
0:         @param transName  If a new transaction is started, it will be given this name.
1:         The name is displayed in the transactiontable VTI.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
0: 		@see #startTransaction
0: 	*/
0: 	public Transaction findUserTransaction(
1:         ContextManager contextMgr,
1:         String transName) throws StandardException;
1: 
1: 
0: 	/**
0: 		Create an internal transaction.
1: 		<P>
0: 		Starting an internal transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store internal transaction context
0: 		<LI>Create a new idle internal transaction and then link it to the 
1:             context.
0: 		</UL>
1: 		<P>
0: 		AN internal transaction is identical to a user transaction with the 
1:         exception that
0: 		<UL>
0: 		<LI> Logical operations are not supported
0: 		<LI> Savepoints are not supported
0: 		<LI> Containers are not closed when commit() is called.
0: 		<LI> Pages are not unlatched (since containers are not closed) when 
1:              commit() is called.
0: 		<LI> During recovery time internal transactions are rolled back before 
1:              user transactions.
0: 		</UL>
0: 		Only one internal transaction can be active in a context at any one time.
0: 		After a commit the transaction may be re-used.
1: 		<P>
0: 		<B>Raw Store Internal Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
0: 		the internal transaction is aborted, the internal transaction is closed,        the context is popped off the stack, and an exception of severity 
1:         Transaction exception is re-thrown.
0: 		<LI>
0: 		If error is an instance of StandardException that has a severity 
1:         greater than or equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:         the context's internal transaction is aborted, the internal 
1:         transaction is closed and the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		internal transaction is aborted, the internal transaction is closed 
1:         and the context is popped off the stack.
0: 		</UL>
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
0: 	public Transaction startInternalTransaction(ContextManager contextMgr) throws StandardException;
1: 
0: 	/**
0: 		Create a nested user transaction, almost all work within the raw store 
1:         is performed in the context of a transaction.
1: 		<P>
1:         A nested user transaction is exactly the same as a user transaction,
1:         except that one can specify a compatibility space to associate with
1:         the transaction.
0: 		Starting a transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store transaction context
0: 		<LI>Create a new idle transaction and then link it to the context.
0: 		</UL>
0: 		Only one user transaction and one nested user transaction can be active
1:         in a context at any one time.
0: 		After a commit the transaction may be re-used.
1: 		<P>
0: 		<B>Raw Store Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:         no action is taken.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:         the context's transaction is aborted, and the transaction returned to
1:         the idle state.  If a user transaction exists on the context stack
1:         then that transaction is aborted also.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
1:         then the context's transaction is aborted, the transaction closed, and
1:         the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		transaction is aborted, the transaction closed, and the
0: 		context is popped off the stack.
0: 		</UL>
1: 
0: 		@param compatibilitySpace compatibility space to use for locks.
0: 		@param contextMgr is the context manager to use.  An exception will be
0: 		thrown if context is not the current context.
1:         @param transName is the name of the transaction. This name will be 
1:         displayed by the transactiontable VTI.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
1: 
0: 	public Transaction startNestedReadOnlyUserTransaction(
0:     Object         compatibilitySpace,
1:     ContextManager contextMgr,
1:     String         transName)
1:         throws StandardException;
1: 
0: 	/**
0: 		Create a nested user transaction, almost all work within the raw store 
1:         is performed in the context of a transaction.
1: 		<P>
1:         A nested user transaction is exactly the same as a user transaction,
1:         except that one can specify a compatibility space to associate with
1:         the transaction.
0: 		Starting a transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store transaction context
0: 		<LI>Create a new idle transaction and then link it to the context.
0: 		</UL>
0: 		Only one user transaction and one nested user transaction can be active
1:         in a context at any one time.
0: 		After a commit the transaction may be re-used.
1: 		<P>
0: 		<B>Raw Store Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
1:         no action is taken.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
1:         the context's transaction is aborted, and the transaction returned to
1:         the idle state.  If a user transaction exists on the context stack
1:         then that transaction is aborted also.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
1:         then the context's transaction is aborted, the transaction closed, and
1:         the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		transaction is aborted, the transaction closed, and the
0: 		context is popped off the stack.
0: 		</UL>
1: 
0: 		@param compatibilitySpace compatibility space to use for locks.
0: 		@param contextMgr is the context manager to use.  An exception will be
0: 		thrown if context is not the current context.
1:         @param transName is the name of the transaction. This name will be 
1:         displayed by the transactiontable VTI.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
1: 
0: 	public Transaction startNestedUpdateUserTransaction(
1:     ContextManager contextMgr,
1:     String         transName)
1:         throws StandardException;
1: 
1: 
0: 	/**
0: 	  @see org.apache.derby.iapi.store.access.AccessFactory#getTransactionInfo
0: 	 */
0: 	public TransactionInfo[] getTransactionInfo();
1: 
0: 	/**
0: 	  * Freeze the database temporarily so a backup can be taken.
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
1: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void freeze() throws StandardException;
1: 
0: 	/**
0: 	  * Unfreeze the database after a backup has been taken.
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
1: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void unfreeze() throws StandardException;
1: 
0: 	/**
0: 	  * Backup the database to backupDir.  
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
1: 	  *
0: 	  * @param backupDir the name of the directory where the backup should be
0: 	  *		stored.
1: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void backup(String backupDir) throws StandardException;
1: 
0: 	/**
0: 	  * Backup the database to backupDir.  
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
1: 	  *
0: 	  * @param backupDir the directory where the backup should be stored.
1: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void backup(File backupDir) throws StandardException;
1: 
1: 
1: 		
0: 	/**
0: 	 * Backup the database to a backup directory and enable the log archive
0: 	 * mode that will keep the archived log files required for roll-forward
0: 	 * from this version backup.
0: 	 * @param backupDir the directory name where the database backup should
0: 	 *   go.  This directory will be created if not it does not exist.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log files
0: 	 * that exist before this backup, delete will occur only after backup is complete.
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void backupAndEnableLogArchiveMode(String backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles) 
1: 		throws StandardException;
1: 		
0: 	/**
0: 	 * Backup the database to a backup directory and enable the log archive
0: 	 * mode that will keep the archived log files required for roll-forward
0: 	 * from this version backup.
0: 	 * @param backupDir the directory name where the database backup should
0: 	 *   go.  This directory will be created if not it does not exist.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log files
0: 	 * that exist before this backup, delete will occur only after backup is complete.
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void backupAndEnableLogArchiveMode(File backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles) 
1: 		throws StandardException;
1: 	
0: 	/**
0: 	 * disables the log archival process, i.e No old log files
0: 	 * will be kept around for a roll-forward recovery.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes all online archived log files
0: 	 * that exist before this call immediately; Only restore that can be performed
0: 	 * after disabling log archive mode is version recovery.
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
1: 		throws StandardException;
1: 
1: 
0: 	/**
0: 		Try to checkpoint the database to minimize recovery time.
0: 		The raw store does not guarentee that a checkpoint will indeed have
0: 		happened by the time this routine returns.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public void checkpoint() throws StandardException;
1: 
1: 
0: 	/**
0: 		Idle the raw store as much as possible. 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
0: 	*/
0: 	public void idle() throws StandardException;
1: 
0: 	/*
0: 		Log truncation support - only applies to rawStore that supports logging
0: 		and log truncation control.
1: 
0: 		The RawStore will maintain a set of log instances called truncation low
0: 		water marks.  These TruncationLWMs are identified by UUID.  Once set,
0: 		the RawStore will not truncate any log record pass any TruncationLWM.
0: 		The client must reset these TruncationLWM or delete them from RawStore
0: 		or else the log will fill up.
1: 
0: 		These TruncationLWMs are durable across crashes
0: 	*/
1: 
0: 	/**
0: 		Set truncation low water mark.  If instant is null, set this named
0: 		truncation LWM to be the earliest legal log instant currently still
0: 		available - i.e., the first log instant that has not been truncated.
0: 		If a truncation low water mark of this name does not exist this creates
0: 		it.  If a truncation low water mark of this name already exists then
0: 		this call will move it to a new log instant.
1: 		<P>
0: 		When this returns the system will durably remember the new low water
0: 		mark.
1: 		
0: 		@param name The name of the new low water mark. 
0: 		@return The truncation low water mark log instant.
1: 
0: 		@exception StandardException StandardCloudscape error policy
0: 	*/
0: 	LogInstant setTruncationLWM(UUID name, DatabaseInstant instant) 
1: 		 throws StandardException; 
1: 
1: 
0: 	/**
0: 		Remove a truncation low water mark.  An exception will be thrown if it
0: 		is not already set. 
1: 		<P>
0: 		When this returns the low water mark is removed from the system
0: 		permanently. 
1: 
0: 		@param name The name of the truncation low water mark.
1: 
0: 		@exception StandardException StandardCloudscape error policy
0: 	*/
0: 	void removeTruncationLWM(UUID name) throws StandardException;
1: 
0: 	/**
0: 		Get a truncatin low water mark.  If it is not set, return null.
1: 
0: 		@param name The name of the truncation low water mark.
1: 
0: 		@exception StandardException StandardCloudscape error policy
0: 	*/
0: 	LogInstant getTruncationLWM(UUID name) throws StandardException;
1: 
1: 
0: 	/**
0: 	    Get a flushed scan.
0: 		@param start The instant for the beginning of the scan.
0: 		@param groupsIWant log record groups the caller wants to scan.
0: 		@exception StandardException StandardCloudscape error policy
0: 		*/
0: 	ScanHandle openFlushedScan(DatabaseInstant start, int groupsIWant) 
1: 		 throws StandardException;
1: 
1: 	
0: 	/**
0: 		If this raw store has a daemon that services its need, return the
0: 		daemon.  If not, return null
0: 	*/
0: 	public DaemonService getDaemon();
1: 
1: 
0: 	/*
0: 	 * return the transaction factory module 
0: 	 */
0: 	public String getTransactionFactoryModule();
1: 
0: 	/*
0: 	 * return the data factory module 
0: 	 */
0: 	public String getDataFactoryModule();
1: 
0: 	/*
0: 	 * return the Log factory module 
0: 	 */
0: 	public String getLogFactoryModule();
1: 
0: 	/*
0: 	 * Return the module providing XAresource interface to the transaction 
1:      * table. 
1:      *
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public /* XAResourceManager */ Object getXAResourceManager()
1:         throws StandardException;
1: 
0: 	/*
0: 	 * the database creation phase is finished
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void createFinished() throws StandardException;
1: 
0: 	/**
0: 	 * Get JBMS properties relavent to raw store
1: 	 *
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void getRawStoreProperties(PersistentSet tc) 
1: 		 throws StandardException; 
1: 
0: 	/**
0: 	 *  Backup / restore support
0: 	 */
1: 
0: 	/**
0: 	 * Freeze the database from altering any persistent storage.
1: 	 *
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void freezePersistentStore() throws StandardException;
1: 
0: 	/**
0: 	 * Unfreeze the database, persistent storage can now be altered.
1: 	 *
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void unfreezePersistentStore() throws StandardException;
1: 
0: 	/**
0: 		Encrypt cleartext into ciphertext.
1: 
0: 		@see org.apache.derby.iapi.services.crypto.CipherProvider#encrypt
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	public int encrypt(byte[] cleartext, int offset, int length, 
0: 					   byte[] ciphertext, int outputOffset) 
0: 		 throws StandardException ;
1: 
0: 	/**
0: 		Decrypt cleartext from ciphertext.
1: 
0: 		@see org.apache.derby.iapi.services.crypto.CipherProvider#decrypt
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	public int decrypt(byte[] ciphertext, int offset, int length, 
0: 					   byte[] cleartext, int outputOffset) 
0: 		 throws StandardException ;
1: 
0: 	/**
0: 	 	Returns the encryption block size used during creation of the encrypted database
0: 	 */
0: 	public int getEncryptionBlockSize();
1: 
0: 	/**
0: 		Returns a secure random number for this raw store - if database is not
0: 		encrypted, returns 0.
0: 	 */
0: 	public int random();
1: 
0: 	/**
0: 		Change the boot password.  Return the encrypted form of the secret key.
0: 		The new value must be a String of the form: oldBootPassword, newBootPassword
1: 
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	public Serializable changeBootPassword(Properties properties, Serializable changePassword)
0: 		 throws StandardException ;
1: 
0:     /**
1:      * Return an id which can be used to create a container.
1:      * <p>
1:      * Return an id number with is greater than any existing container
1:      * in the current database.  Caller will use this to allocate future
1:      * container numbers - most likely caching the value and then incrementing
1:      * it as it is used.
1:      * <p>
1:      *
0: 	 * @return The an id which can be used to create a container.
1:      *
0: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     long getMaxContainerId()
1: 		throws StandardException;
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.raw;
0: 
0: import org.apache.derby.iapi.services.daemon.DaemonService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.locks.LockFactory;
0: 
0: import org.apache.derby.iapi.services.property.PersistentSet;
0: 
0: import org.apache.derby.iapi.store.access.TransactionInfo;
0: 
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.store.access.DatabaseInstant;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: import java.util.Properties;
0: import java.io.Serializable;
0: import java.io.File;
0: 
0: /**
0: 	RawStoreFactory implements a single unit of transactional
0: 	storage. A RawStoreFactory contains Segments and Segments
0: 	contain Containers.
0: 	<P>
0: 	Segments are identified
0: 	by integer identifiers that are unique within a RawStoreFactory.
0: 	<P>
0: 	Containers are also identified by unique integer identifiers
0: 	within a RawStoreFactory, but will overlap with segment identifiers.
0: 	<P><B>LIMITS</B><BR>
0: 	This is a list of (hopefully) all limits within the raw store. Where a size 
0:     has more than one limit all are documented (rather than just the most 
0:     restrictive) so that the correct limit can be found if the most restictive 
0:     is every removed.
0: 	<UL>
0: 	<LI>Field - 
0: 		<UL>
0: 		<LI>Max length 2^31 - 1  (2147483647) - 
0: 		</UL>
0: 	<LI>Record - 
0: 		<UL>
0: 		<LI>Max number of fields 2^31 - 1  (2147483647) - from use of Object[] 
0:         array to represent row, which can "only" have int sized number of array
0:         members.
0: 		</UL>
0: 	<LI>Page -
0: 	<LI>Container -
0: 	<LI>Segment -
0: 	<LI>Raw Store -
0: 	</UL>
0: 
0: 	<P>
0: 	Access and RawStore work together to provide the ACID properties of
0: 	transactions. On a high level, RawStore deals with anything that directly
0: 	impacts persistency. On a more detailed level, RawStore provides
0: 	logging, rollback and recovery, data management on page, page allocation
0: 	and deallocation, container allocation and deallocation.  
0: 
0: 
0: 	<P>
0: 	RawStore is organized as 3 branches, transaction, data, and
0: 	logging.  These branches each have its own "factory", the transaction
0: 	factory hands out transactions, the data factory hands out containers,
0: 	and the log factory hands out logger (or log buffers) for transactions to
0: 	write on.  For a more detailed description on these factories, please see
0: 	their corresponding javadocs.
0: 
0: 
0: 	MT - Thread Safe
0: 
0: 	@see ContainerHandle */
0: 
0: 
0: public interface RawStoreFactory extends Corruptable {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 
0: 	/**
0: 		Default value for PAGE_SIZE_PARAMETER (4096).
0: 	*/
0: 	public static final int PAGE_SIZE_DEFAULT = 4096;
0: 
0: 	/**
0: 		Minimum page size we will accept (1024).
0: 	*/
0: 	public static final int PAGE_SIZE_MINIMUM = 1024;
0: 
0: 
0: 	public static final String PAGE_SIZE_STRING = "2048";
0: 
0: 
0: 	/** Property name for the page cache size to be used in the storage area.
0: 	Equal to 'derby.storage.pageCacheSize'
0: 	*/
0: 	public static final String PAGE_CACHE_SIZE_PARAMETER = 
0:         "derby.storage.pageCacheSize";
0: 
0: 	/**
0: 		Default value for PAGE_CACHE_SIZE_PARAMETER (1000).
0: 	*/
0: 	public static final int PAGE_CACHE_SIZE_DEFAULT = 1000;
0: 
0: 	/**
0: 		Minimum page cache size we will accept (40).
0: 	*/
0: 	public static final int PAGE_CACHE_SIZE_MINIMUM = 40;
0: 
0: 	/**
0: 		Maximum page cache size we will accept (MAXINT).
0: 	*/
0: 	public static final int PAGE_CACHE_SIZE_MAXIMUM = Integer.MAX_VALUE;
0: 
0: 	/**
0: 		Maximum number of initial pages when a container is created
0: 	*/
0: 	public static final short MAX_CONTAINER_INITIAL_PAGES = 1000;
0: 
0: 	/** Property name for the default minimum record size to be used in the 
0:         storage area. Minimum record size is the minimum number of bytes that a 
0:         record will reserve on disk.
0: 	*/
0: 	public static final String MINIMUM_RECORD_SIZE_PARAMETER = 
0:         "derby.storage.minimumRecordSize";
0: 	/**
0: 		Default value for MINIMUM_RECORD_SIZE_PARAMETER	for heap tables that 
0:         allow overflow.  By setting minimumRecordSize to 12 bytes, we 
0:         guarantee there is enough space to update the row even there is not
0:         enough space on the page.  The 12 bytes will guarantee there is room
0:         for an overflow pointer (page + id).
0: 	*/
0: 	public static final int MINIMUM_RECORD_SIZE_DEFAULT = 12;
0: 
0: 	/**
0: 		Minimum value for MINIMUM_RECORD_SIZE_PARAMETER (1).
0: 	*/
0: 	public static final int MINIMUM_RECORD_SIZE_MINIMUM = 1;
0: 
0: 	/** Property name for percentage of space to leave free on page for updates.
0: 	*/
0: 	public static final String PAGE_RESERVED_SPACE_PARAMETER = 
0:         "derby.storage.pageReservedSpace";
0: 
0: 	public static final String PAGE_RESERVED_ZERO_SPACE_STRING = "0";
0: 
0: 	/** Property name for the number of pages we try to pre-allocate in one
0: 	/** synchronous I/O
0: 	*/
0: 	public static final String PRE_ALLOCATE_PAGE = 
0:         "derby.storage.pagePerAllocate";
0: 
0: 
0: 	/**
0: 		Property name for container which reuses recordId when a page is
0: 		reused.  Defaults to false, which means recordId is never reused. 	
0: 
0: 		This property should NOT be set by the end user, only Access should set
0: 		it for special conglomerates which does not count on permanant unique
0: 		recordIds for all records.
0: 	*/
0: 	public static final String PAGE_REUSABLE_RECORD_ID = 
0:         "derby.storage.reusableRecordId";
0: 
0: 	/**
0: 		Property name for buffer size to be used in the stream file container.
0: 		Equal to 'derby.storage.streamFileBufferSize'
0: 	*/
0: 	public static final String STREAM_FILE_BUFFER_SIZE_PARAMETER = 
0:         "derby.storage.streamFileBufferSize";
0: 
0: 	/**
0: 		Default value for STREAM_FILE_BUFFER_SIZE_PARAMETER (16384).
0: 	*/
0: 	public static final int STREAM_FILE_BUFFER_SIZE_DEFAULT = 16384;
0: 
0: 	/**
0: 		Minimum stream file buffer size we will accept (1024).
0: 	*/
0: 	public static final int STREAM_FILE_BUFFER_SIZE_MINIMUM = 1024;
0: 
0: 	/**
0: 		Maximum stream file buffer size we will accept (MAXINT).
0: 	*/
0: 	public static final int STREAM_FILE_BUFFER_SIZE_MAXIMUM = 
0:         Integer.MAX_VALUE;
0: 
0: 	/**
0: 
0: 		Property name for container which attempts to be created with an
0: 		initial size of this many pages.  Defaults to 1 page.  
0: 
0: 		<BR>All containers are guarenteed to be created with at least 1 page,
0: 		if this property is set, it will attempt to allocate
0: 		CONTAINER_INITIAL_PAGES, but with no guarentee.
0: 		CONTAIENR_INITIAL_PAGES legally ranges from 1 to
0: 		MAX_CONTAINER_INITIAL_PAGES.  Values < 1 will
0: 		be set to 1 and values > MAX_CONTAINER_INITIAL_PAGES will be set to
0: 		MAX_CONTAINER_INITIAL_PAGES
0: 
0: 		This property should only be set in the PROPERTIES list in a CREATE
0: 		TABLE or CREATE INDEX statement.  The global setting of this property
0: 		has no effect. 
0: 	*/
0: 	public static final String CONTAINER_INITIAL_PAGES = 
0:         "derby.storage.initialPages";
0: 
0: 	/**
0: 		encryption alignment requirement.
0: 	 */
0: 	public static final int ENCRYPTION_ALIGNMENT = 8;
0: 
0: 	/**
0: 		default encryption block size
0: 		In old existing databases (ie 5.1.x), the default
0: 		encryption block size used is 8. Do not change this value unless you 
0: 		account for downgrade issues
0: 	 */
0: 	public static final int DEFAULT_ENCRYPTION_BLOCKSIZE = 8;
0: 
0: 	/**
0: 		encryption block size used during creation of encrypted database
0: 		This property is not set by the user; it is set by the engine when
0: 		RawStore boots up during creation of an encrypted database
0: 	*/
0: 	public static final String ENCRYPTION_BLOCKSIZE = "derby.encryptionBlockSize";
0: 
0: 	/**
0: 
0: 		This variable is used to store the encryption scheme to allow
0: 		for any future changes in encryption schemes of data 
0: 		This property has been introduced in version 10
0: 		Value starts at 1
0: 	 */
0: 	public static final String DATA_ENCRYPT_ALGORITHM_VERSION="data_encrypt_algorithm_version";
0: 
0: 	/**
0:                 Store the encryption scheme used for logging
0: 		This will allow for any future changes in encryption schemes of logs
0: 		This variable has been introduced in version 10 and value starts at 1.
0:  	 */
0: 	public static final String LOG_ENCRYPT_ALGORITHM_VERSION="log_encrypt_algorithm_version";
0: 
0: 	/**
0: 		If dataEncryption is true, store the encrypted key in
0: 		services.properties file. It is really the encrypted
0: 		key, but the property key is called the encryptedBootPassword.
0: 
0: 	 */
0: 	public static final String ENCRYPTED_KEY = 
0:         "encryptedBootPassword";
0: 
0: 
0: 	/**
0: 	 *  for debugging, keep all transaction logs intact.
0: 	 */
0: 	public static final String KEEP_TRANSACTION_LOG = 
0:         "derby.storage.keepTransactionLog";
0: 
0:     /**
0:       * The following is a to enable patch for databases with recovery
0:       * errors during redo of InitPage. If this property is set and
0: 	  * the page on the disk is corrupted and is getting exceptions like
0: 	  * invalid page format ids, we cook up the page during the recovery time.
0: 	  * We have seen this kind of problem with 1.5.1 databases from
0: 	  * customer Tridium ( Bug no: 3813).
0: 	  * This patch needs to be kept unless we find the problem is during
0: 	  * recovery process. If we discover this problem is actaully happening
0: 	  * at the recovery then this patch should be backed out.
0: 	  **/
0: 	public static final String PATCH_INITPAGE_RECOVER_ERROR = 
0:         "derby.storage.patchInitPageRecoverError";
0: 
0: 
0: 	/** module name */
0: 	public static final String MODULE = 
0:         "org.apache.derby.iapi.store.raw.RawStoreFactory";
0: 
0: 	/**
0: 		Is the store read-only.
0: 	*/
0: 	public boolean isReadOnly();
0: 
0: 	/**
0: 		Get the LockFactory to use with this store.
0: 	*/
0: 	public LockFactory getLockFactory();
0: 
0: 
0: 	/**
0: 		Create a user transaction, almost all work within the raw store is
0:         performed in the context of a transaction.
0: 		<P>
0: 		Starting a transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store transaction context
0: 		<LI>Create a new idle transaction and then link it to the context.
0: 		</UL>
0: 		Only one user transaction and one nested user transaction can be active
0:         in a context at any one time.
0: 		After a commit the transaction may be re-used.
0: 		<P>
0: 		<B>Raw Store Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
0:         no action is taken.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
0:         the context's transaction is aborted, and the transaction returned to
0:         the idle state.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
0:         then the context's transaction is aborted, the transaction closed, and
0:         the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		transaction is aborted, the transaction closed, and the
0: 		context is popped off the stack.
0: 		</UL>
0: 
0: 		@param contextMgr is the context manager to use.  An exception will be
0: 		thrown if context is not the current context.
0:         @param transName is the name of the transaction. Thsi name will be displayed
0:         by the transactiontable VTI.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
0: 
0: 	public Transaction startTransaction(
0:     ContextManager contextMgr,
0:     String transName)
0:         throws StandardException;
0: 
0: 	/**
0: 		Create a global user transaction, almost all work within the raw store
0:         is performed in the context of a transaction.
0: 		<P>
0:         The (format_id, global_id, branch_id) triplet is meant to come exactly
0:         from a javax.transaction.xa.Xid.  We don't use Xid so that the system
0:         can be delivered on a non-1.2 vm system and not require the javax 
0:         classes in the path.  
0:         <P>
0: 		Starting a transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store transaction context
0: 		<LI>Create a new idle transaction and then link it to the context.
0: 		</UL>
0: 		Only one user transaction can be active in a context at any one time.
0: 		After a commit the transaction may be re-used.
0: 		<P>
0: 		<B>Raw Store Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then 
0:         no action is taken.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
0:         the context's transaction is aborted, and the transaction returned to 
0:         the idle state.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY 
0:         then the context's transaction is aborted, the transaction closed, and 
0:         the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		transaction is aborted, the transaction closed, and the
0: 		context is popped off the stack.
0: 		</UL>
0: 
0: 		@param contextMgr is the context manager to use.  An exception will be
0: 		                  thrown if context is not the current context.
0:         @param format_id  the format id part of the Xid - ie. Xid.getFormatId().
0:         @param global_id  the global transaction identifier part of XID - ie.
0:                           Xid.getGlobalTransactionId().
0:         @param branch_id  The branch qualifier of the Xid - ie. 
0:                           Xid.getBranchQaulifier()
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
0: 	public Transaction startGlobalTransaction(
0:     ContextManager contextMgr,
0:     int            format_id,
0:     byte[]         global_id,
0:     byte[]         local_id)
0:         throws StandardException;
0: 
0: 
0: 	/**
0: 		Find a user transaction in the context manager, which must be the
0: 		current context manager.  If a user transaction does not already exist,
0: 		then create one @see #startTransaction
0: 
0: 		@param context is the context manager to use.  An exception will be
0: 		thrown if context is not the current context.
0:         @param transName  If a new transaction is started, it will be given this name.
0:         The name is displayed in the transactiontable VTI.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 		@see #startTransaction
0: 	*/
0: 	public Transaction findUserTransaction(
0:         ContextManager contextMgr,
0:         String transName) throws StandardException;
0: 
0: 
0: 	/**
0: 		Create an internal transaction.
0: 		<P>
0: 		Starting an internal transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store internal transaction context
0: 		<LI>Create a new idle internal transaction and then link it to the 
0:             context.
0: 		</UL>
0: 		<P>
0: 		AN internal transaction is identical to a user transaction with the 
0:         exception that
0: 		<UL>
0: 		<LI> Logical operations are not supported
0: 		<LI> Savepoints are not supported
0: 		<LI> Containers are not closed when commit() is called.
0: 		<LI> Pages are not unlatched (since containers are not closed) when 
0:              commit() is called.
0: 		<LI> During recovery time internal transactions are rolled back before 
0:              user transactions.
0: 		</UL>
0: 		Only one internal transaction can be active in a context at any one time.
0: 		After a commit the transaction may be re-used.
0: 		<P>
0: 		<B>Raw Store Internal Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
0: 		the internal transaction is aborted, the internal transaction is closed,        the context is popped off the stack, and an exception of severity 
0:         Transaction exception is re-thrown.
0: 		<LI>
0: 		If error is an instance of StandardException that has a severity 
0:         greater than or equal to ExceptionSeverity.TRANSACTION_SEVERITY then
0:         the context's internal transaction is aborted, the internal 
0:         transaction is closed and the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		internal transaction is aborted, the internal transaction is closed 
0:         and the context is popped off the stack.
0: 		</UL>
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
0: 	public Transaction startInternalTransaction(ContextManager contextMgr) throws StandardException;
0: 
0: 	/**
0: 		Create a nested user transaction, almost all work within the raw store 
0:         is performed in the context of a transaction.
0: 		<P>
0:         A nested user transaction is exactly the same as a user transaction,
0:         except that one can specify a compatibility space to associate with
0:         the transaction.
0: 		Starting a transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store transaction context
0: 		<LI>Create a new idle transaction and then link it to the context.
0: 		</UL>
0: 		Only one user transaction and one nested user transaction can be active
0:         in a context at any one time.
0: 		After a commit the transaction may be re-used.
0: 		<P>
0: 		<B>Raw Store Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
0:         no action is taken.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
0:         the context's transaction is aborted, and the transaction returned to
0:         the idle state.  If a user transaction exists on the context stack
0:         then that transaction is aborted also.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
0:         then the context's transaction is aborted, the transaction closed, and
0:         the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		transaction is aborted, the transaction closed, and the
0: 		context is popped off the stack.
0: 		</UL>
0: 
0: 		@param compatibilitySpace compatibility space to use for locks.
0: 		@param contextMgr is the context manager to use.  An exception will be
0: 		thrown if context is not the current context.
0:         @param transName is the name of the transaction. This name will be 
0:         displayed by the transactiontable VTI.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
0: 
0: 	public Transaction startNestedReadOnlyUserTransaction(
0:     Object         compatibilitySpace,
0:     ContextManager contextMgr,
0:     String         transName)
0:         throws StandardException;
0: 
0: 	/**
0: 		Create a nested user transaction, almost all work within the raw store 
0:         is performed in the context of a transaction.
0: 		<P>
0:         A nested user transaction is exactly the same as a user transaction,
0:         except that one can specify a compatibility space to associate with
0:         the transaction.
0: 		Starting a transaction always performs the following steps.
0: 		<OL>
0: 		<LI>Create an raw store transaction context
0: 		<LI>Create a new idle transaction and then link it to the context.
0: 		</UL>
0: 		Only one user transaction and one nested user transaction can be active
0:         in a context at any one time.
0: 		After a commit the transaction may be re-used.
0: 		<P>
0: 		<B>Raw Store Transaction Context Behaviour</B>
0: 		<BR>
0: 		The cleanupOnError() method of this context behaves as follows:
0: 		<UL>
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity less than ExceptionSeverity.TRANSACTION_SEVERITY then
0:         no action is taken.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity equal to ExceptionSeverity.TRANSACTION_SEVERITY then
0:         the context's transaction is aborted, and the transaction returned to
0:         the idle state.  If a user transaction exists on the context stack
0:         then that transaction is aborted also.
0: 		<LI>
0: 		If error is an instance of StandardException that
0: 		has a severity greater than  ExceptionSeverity.TRANSACTION_SEVERITY
0:         then the context's transaction is aborted, the transaction closed, and
0:         the context is popped off the stack.
0: 		<LI>
0: 		If error is not an instance of StandardException then the context's
0: 		transaction is aborted, the transaction closed, and the
0: 		context is popped off the stack.
0: 		</UL>
0: 
0: 		@param compatibilitySpace compatibility space to use for locks.
0: 		@param contextMgr is the context manager to use.  An exception will be
0: 		thrown if context is not the current context.
0:         @param transName is the name of the transaction. This name will be 
0:         displayed by the transactiontable VTI.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 		@see Transaction
0: 		@see org.apache.derby.iapi.services.context.Context
0: 		@see StandardException
0: 	*/
0: 
0: 	public Transaction startNestedUpdateUserTransaction(
0:     ContextManager contextMgr,
0:     String         transName)
0:         throws StandardException;
0: 
0: 
0: 	/**
0: 	  @see org.apache.derby.iapi.store.access.AccessFactory#getTransactionInfo
0: 	 */
0: 	public TransactionInfo[] getTransactionInfo();
0: 
0: 	/**
0: 	  * Freeze the database temporarily so a backup can be taken.
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
0: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void freeze() throws StandardException;
0: 
0: 	/**
0: 	  * Unfreeze the database after a backup has been taken.
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
0: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void unfreeze() throws StandardException;
0: 
0: 	/**
0: 	  * Backup the database to backupDir.  
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
0: 	  *
0: 	  * @param backupDir the name of the directory where the backup should be
0: 	  *		stored.
0: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void backup(String backupDir) throws StandardException;
0: 
0: 	/**
0: 	  * Backup the database to backupDir.  
0: 	  * <P>Please see cloudscape on line documentation on backup and restore.
0: 	  *
0: 	  * @param backupDir the directory where the backup should be stored.
0: 	  *
0: 	  * @exception StandardException Thrown on error
0: 	  */
0: 	public void backup(File backupDir) throws StandardException;
0: 
0: 
0: 		
0: 	/**
0: 	 * Backup the database to a backup directory and enable the log archive
0: 	 * mode that will keep the archived log files required for roll-forward
0: 	 * from this version backup.
0: 	 * @param backupDir the directory name where the database backup should
0: 	 *   go.  This directory will be created if not it does not exist.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log files
0: 	 * that exist before this backup, delete will occur only after backup is complete.
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void backupAndEnableLogArchiveMode(String backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles) 
0: 		throws StandardException;
0: 		
0: 	/**
0: 	 * Backup the database to a backup directory and enable the log archive
0: 	 * mode that will keep the archived log files required for roll-forward
0: 	 * from this version backup.
0: 	 * @param backupDir the directory name where the database backup should
0: 	 *   go.  This directory will be created if not it does not exist.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes online archived log files
0: 	 * that exist before this backup, delete will occur only after backup is complete.
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void backupAndEnableLogArchiveMode(File backupDir, 
0: 											  boolean
0: 											  deleteOnlineArchivedLogFiles) 
0: 		throws StandardException;
0: 	
0: 	/**
0: 	 * disables the log archival process, i.e No old log files
0: 	 * will be kept around for a roll-forward recovery.
0: 	 * @param deleteOnlineArchivedLogFiles  If true deletes all online archived log files
0: 	 * that exist before this call immediately; Only restore that can be performed
0: 	 * after disabling log archive mode is version recovery.
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void disableLogArchiveMode(boolean deleteOnlineArchivedLogFiles)
0: 		throws StandardException;
0: 
0: 
0: 	/**
0: 		Try to checkpoint the database to minimize recovery time.
0: 		The raw store does not guarentee that a checkpoint will indeed have
0: 		happened by the time this routine returns.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public void checkpoint() throws StandardException;
0: 
0: 
0: 	/**
0: 		Idle the raw store as much as possible. 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 	*/
0: 	public void idle() throws StandardException;
0: 
0: 	/*
0: 		Log truncation support - only applies to rawStore that supports logging
0: 		and log truncation control.
0: 
0: 		The RawStore will maintain a set of log instances called truncation low
0: 		water marks.  These TruncationLWMs are identified by UUID.  Once set,
0: 		the RawStore will not truncate any log record pass any TruncationLWM.
0: 		The client must reset these TruncationLWM or delete them from RawStore
0: 		or else the log will fill up.
0: 
0: 		These TruncationLWMs are durable across crashes
0: 	*/
0: 
0: 	/**
0: 		Set truncation low water mark.  If instant is null, set this named
0: 		truncation LWM to be the earliest legal log instant currently still
0: 		available - i.e., the first log instant that has not been truncated.
0: 		If a truncation low water mark of this name does not exist this creates
0: 		it.  If a truncation low water mark of this name already exists then
0: 		this call will move it to a new log instant.
0: 		<P>
0: 		When this returns the system will durably remember the new low water
0: 		mark.
0: 		
0: 		@param name The name of the new low water mark. 
0: 		@return The truncation low water mark log instant.
0: 
0: 		@exception StandardException StandardCloudscape error policy
0: 	*/
0: 	LogInstant setTruncationLWM(UUID name, DatabaseInstant instant) 
0: 		 throws StandardException; 
0: 
0: 
0: 	/**
0: 		Remove a truncation low water mark.  An exception will be thrown if it
0: 		is not already set. 
0: 		<P>
0: 		When this returns the low water mark is removed from the system
0: 		permanently. 
0: 
0: 		@param name The name of the truncation low water mark.
0: 
0: 		@exception StandardException StandardCloudscape error policy
0: 	*/
0: 	void removeTruncationLWM(UUID name) throws StandardException;
0: 
0: 	/**
0: 		Get a truncatin low water mark.  If it is not set, return null.
0: 
0: 		@param name The name of the truncation low water mark.
0: 
0: 		@exception StandardException StandardCloudscape error policy
0: 	*/
0: 	LogInstant getTruncationLWM(UUID name) throws StandardException;
0: 
0: 
0: 	/**
0: 	    Get a flushed scan.
0: 		@param start The instant for the beginning of the scan.
0: 		@param groupsIWant log record groups the caller wants to scan.
0: 		@exception StandardException StandardCloudscape error policy
0: 		*/
0: 	ScanHandle openFlushedScan(DatabaseInstant start, int groupsIWant) 
0: 		 throws StandardException;
0: 
0: 	
0: 	/**
0: 		If this raw store has a daemon that services its need, return the
0: 		daemon.  If not, return null
0: 	*/
0: 	public DaemonService getDaemon();
0: 
0: 
0: 	/*
0: 	 * return the transaction factory module 
0: 	 */
0: 	public String getTransactionFactoryModule();
0: 
0: 	/*
0: 	 * return the data factory module 
0: 	 */
0: 	public String getDataFactoryModule();
0: 
0: 	/*
0: 	 * return the Log factory module 
0: 	 */
0: 	public String getLogFactoryModule();
0: 
0: 	/*
0: 	 * Return the module providing XAresource interface to the transaction 
0:      * table. 
0:      *
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public /* XAResourceManager */ Object getXAResourceManager()
0:         throws StandardException;
0: 
0: 	/*
0: 	 * the database creation phase is finished
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void createFinished() throws StandardException;
0: 
0: 	/**
0: 	 * Get JBMS properties relavent to raw store
0: 	 *
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void getRawStoreProperties(PersistentSet tc) 
0: 		 throws StandardException; 
0: 
0: 	/**
0: 	 *  Backup / restore support
0: 	 */
0: 
0: 	/**
0: 	 * Freeze the database from altering any persistent storage.
0: 	 *
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void freezePersistentStore() throws StandardException;
0: 
0: 	/**
0: 	 * Unfreeze the database, persistent storage can now be altered.
0: 	 *
0: 	 * @exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void unfreezePersistentStore() throws StandardException;
0: 
0: 	/**
0: 		Encrypt cleartext into ciphertext.
0: 
0: 		@see org.apache.derby.iapi.services.crypto.CipherProvider#encrypt
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	public int encrypt(byte[] cleartext, int offset, int length, 
0: 					   byte[] ciphertext, int outputOffset) 
0: 		 throws StandardException ;
0: 
0: 	/**
0: 		Decrypt cleartext from ciphertext.
0: 
0: 		@see org.apache.derby.iapi.services.crypto.CipherProvider#decrypt
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	public int decrypt(byte[] ciphertext, int offset, int length, 
0: 					   byte[] cleartext, int outputOffset) 
0: 		 throws StandardException ;
0: 
0: 	/**
0: 	 	Returns the encryption block size used during creation of the encrypted database
0: 	 */
0: 	public int getEncryptionBlockSize();
0: 
0: 	/**
0: 		Returns a secure random number for this raw store - if database is not
0: 		encrypted, returns 0.
0: 	 */
0: 	public int random();
0: 
0: 	/**
0: 		Change the boot password.  Return the encrypted form of the secret key.
0: 		The new value must be a String of the form: oldBootPassword, newBootPassword
0: 
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	public Serializable changeBootPassword(Properties properties, Serializable changePassword)
0: 		 throws StandardException ;
0: 
0:     /**
0:      * Return an id which can be used to create a container.
0:      * <p>
0:      * Return an id number with is greater than any existing container
0:      * in the current database.  Caller will use this to allocate future
0:      * container numbers - most likely caching the value and then incrementing
0:      * it as it is used.
0:      * <p>
0:      *
0: 	 * @return The an id which can be used to create a container.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     long getMaxContainerId()
0: 		throws StandardException;
0: }
============================================================================