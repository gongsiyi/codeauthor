7:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.TransactionResourceImpl
1:345de35: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
12:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.jdbc;
1:eac0369: 
1:0e38470: import org.apache.derby.jdbc.InternalDriver;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.Context;
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.db.Database;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.error.ExceptionSeverity;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.Attribute;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:50ba36b: import org.apache.derby.iapi.util.IdUtil;
1:3a6f4cf: import org.apache.derby.iapi.util.InterruptStatus;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: import java.sql.SQLException;
1:eac0369: 
2:eac0369: /** 
1:eac0369:  *	An instance of a TransactionResourceImpl is a bundle of things that
1:eac0369:  *	connects a connection to the database - it is the transaction "context" in
1:eac0369:  *	a generic sense.  It is also the object of synchronization used by the
1:eac0369:  *	connection object to make sure only one thread is accessing the underlying
1:eac0369:  *	transaction and context.
1:eac0369:  *
1:eac0369:  *  <P>TransactionResourceImpl not only serves as a transaction "context", it
1:eac0369:  *	also takes care of: <OL>
1:eac0369:  *	<LI>context management: the pushing and popping of the context manager in
1:eac0369:  *		and out of the global context service</LI>
1:eac0369:  *	<LI>transaction demarcation: all calls to commit/abort/prepare/close a
1:eac0369:  *		transaction must route thru the transaction resource.
1:eac0369:  *	<LI>error handling</LI>
1:eac0369:  *	</OL>
1:eac0369:  *
1:eac0369:  *  <P>The only connection that have access to the TransactionResource is the
1:eac0369:  *  root connection, all other nested connections (called proxyConnection)
1:eac0369:  *  accesses the TransactionResource via the root connection.  The root
1:eac0369:  *  connection may be a plain EmbedConnection, or a DetachableConnection (in
1:eac0369:  *  case of a XATransaction).  A nested connection must be a ProxyConnection.
1:eac0369:  *  A proxyConnection is not detachable and can itself be a XA connection -
1:eac0369:  *  although an XATransaction may start nested local (proxy) connections.
1:eac0369:  *
1:eac0369:  *	<P> this is an example of how all the objects in this package relate to each
1:eac0369:  *		other.  In this example, the connection is nested 3 deep.  
1:eac0369:  *		DetachableConnection.  
1:eac0369:  *	<P><PRE>
1:eac0369:  *
1:eac0369:  *      lcc  cm   database  jdbcDriver
1:eac0369:  *       ^    ^    ^         ^ 
1:eac0369:  *       |    |    |         |
1:eac0369:  *      |======================|
1:eac0369:  *      | TransactionResource  |
1:eac0369:  *      |======================|
1:eac0369:  *             ^  |
1:eac0369:  *             |  |
1:eac0369:  *             |  |      |---------------rootConnection----------|
1:eac0369:  *             |  |      |                                       |
1:eac0369:  *             |  |      |- rootConnection-|                     |
1:eac0369:  *             |  |      |                 |                     |
1:eac0369:  *             |  V      V                 |                     |
1:eac0369:  *|========================|      |=================|      |=================|
1:eac0369:  *|    EmbedConnection     |      | EmbedConnection |      | EmbedConnection |
1:dbed020:  *|                        |&lt;-----|                 |&lt;-----|                 |
1:eac0369:  *| (DetachableConnection) |      | ProxyConnection |      | ProxyConnection |
1:eac0369:  *|========================|      |=================|      |=================|
1:eac0369:  *   ^                 | ^             ^                        ^
1:eac0369:  *   |                 | |             |                        |
1:eac0369:  *   ---rootConnection-- |             |                        |
1:eac0369:  *                       |             |                        |
1:eac0369:  *                       |             |                        |
1:eac0369:  * |======================|  |======================|  |======================|
1:eac0369:  * | ConnectionChild |  | ConnectionChild |  | ConnectionChild |
1:eac0369:  * |                      |  |                      |  |                      |
1:eac0369:  * |  (EmbedStatement)    |  |  (EmbedResultSet)    |  |  (...)               |
1:eac0369:  * |======================|  |======================|  |======================|
1:eac0369:  *
1:2b22c7f:  * </PRE>
1:eac0369:  * <P>A plain local connection <B>must</B> be attached (doubly linked with) to a
1:eac0369:  * TransactionResource at all times.  A detachable connection can be without a
1:eac0369:  * TransactionResource, and a TransactionResource for an XATransaction
1:eac0369:  * (called  XATransactionResource) can be without a connection.
1:eac0369:  *
1:eac0369:  *
1:eac0369:  */
1:eac0369: public final class TransactionResourceImpl
1:eac0369: {
1:eac0369: 	/*
1:eac0369: 	** instance variables set up in the constructor.
1:eac0369: 	*/
1:eac0369: 	// conn is only present if TR is attached to a connection
1:eac0369: 	protected ContextManager cm;
1:eac0369: 	protected ContextService csf;
1:eac0369: 	protected String username;
1:eac0369: 
1:eac0369: 	private String dbname;
1:0e38470: 	private InternalDriver driver;
1:eac0369: 	private String url;
1:eac0369: 	private String drdaID;
1:eac0369: 
1:eac0369: 	// set these up after constructor, called by EmbedConnection
1:eac0369: 	protected Database database;
1:eac0369: 	protected LanguageConnectionContext lcc;
1:eac0369: 
1:2b22c7f: 	/**
1:eac0369: 	 * create a brand new connection for a brand new transaction
1:eac0369: 	 */
1:eac0369: 	TransactionResourceImpl(
1:0e38470: 							InternalDriver driver, 
1:eac0369: 							String url,
1:eac0369: 							Properties info) throws SQLException 
1:eac0369: 	{
1:eac0369: 		this.driver = driver;
1:eac0369: 		csf = driver.getContextServiceFactory();
1:0e38470: 		dbname = InternalDriver.getDatabaseName(url, info);
1:eac0369: 		this.url = url;
1:eac0369: 
1:eac0369: 		// the driver manager will push a user name
1:eac0369: 		// into the properties if its getConnection(url, string, string)
1:eac0369: 		// interface is used.  Thus, we look there first.
1:eac0369: 		// Default to APP.
1:50ba36b: 		username = IdUtil.getUserNameFromURLProps(info);
1:eac0369: 
1:eac0369: 		drdaID = info.getProperty(Attribute.DRDAID_ATTR, null);
1:eac0369: 
1:eac0369: 		// make a new context manager for this TransactionResource
1:eac0369: 
1:eac0369: 		// note that the Database API requires that the 
1:eac0369: 		// getCurrentContextManager call return the context manager
1:eac0369: 		// associated with this session.  The JDBC driver assumes
1:eac0369: 		// responsibility (for now) for tracking and installing
1:eac0369: 		// this context manager for the thread, each time a database
1:eac0369: 		// call is made.
1:eac0369: 		cm = csf.newContextManager();
5:eac0369: 	}
1:2b22c7f: 
1:2b22c7f: 	/**
1:eac0369: 	 * Called only in EmbedConnection construtor.
1:eac0369: 	 * The Local Connection sets up the database in its constructor and sets it
1:eac0369: 	 * here.
1:eac0369: 	 */
1:eac0369: 	void setDatabase(Database db)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(database == null, 
1:eac0369: 				"setting database when it is not null"); 
1:3a6f4cf: 
1:eac0369: 		database = db;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Called only in EmbedConnection constructor.  Create a new transaction
1:eac0369: 	 * by creating a lcc.
1:eac0369: 	 *
1:eac0369: 	 * The arguments are not used by this object, it is used by
1:eac0369: 	 * XATransactionResoruceImpl.  Put them here so that there is only one
1:eac0369: 	 * routine to start a local connection.
1:eac0369: 	 */
1:eac0369: 	void startTransaction() throws StandardException, SQLException
1:eac0369: 	{
1:eac0369: 		// setting up local connection
1:eac0369: 		lcc = database.setupConnection(cm, username, drdaID, dbname);
1:eac0369: 	}
1:eac0369: 
1:2b22c7f: 	/**
1:eac0369: 	 * Return instance variables to EmbedConnection.  RESOLVE: given time, we
1:eac0369: 	 * should perhaps stop giving out reference to these things but instead use
1:eac0369: 	 * the transaction resource itself.
1:eac0369: 	 */
1:0e38470: 	InternalDriver getDriver() {
1:eac0369: 		return driver;
1:eac0369: 	}
1:eac0369: 	ContextService getCsf() {
1:eac0369: 		return  csf;
1:eac0369: 	}
1:eac0369: 
1:2b22c7f: 	/**
1:eac0369: 	 * need to be public because it is in the XATransactionResource interface
1:eac0369: 	 */
1:eac0369: 	ContextManager getContextManager() {
1:eac0369: 		return  cm;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	LanguageConnectionContext getLcc() {
1:eac0369: 		return  lcc;
1:eac0369: 	}
1:eac0369: 	String getDBName() {
1:eac0369: 		return  dbname;
1:eac0369: 	}
1:eac0369: 	String getUrl() {
1:eac0369: 		return  url;
1:eac0369: 	}
1:eac0369: 	Database getDatabase() {
1:eac0369: 		return  database;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	StandardException shutdownDatabaseException() {
1:eac0369: 		StandardException se = StandardException.newException(SQLState.SHUTDOWN_DATABASE, getDBName());
1:eac0369: 		se.setReport(StandardException.REPORT_NEVER);
1:eac0369: 		return se;
1:eac0369: 	}
1:eac0369: 
1:2b22c7f: 	/**
1:eac0369: 	 * local transaction demarcation - note that global or xa transaction
1:eac0369: 	 * cannot commit thru the connection, they can only commit thru the
1:eac0369: 	 * XAResource, which uses the xa_commit or xa_rollback interface as a 
1:eac0369: 	 * safeguard. 
1:eac0369: 	 */
1:93fa39e: 	void commit() throws StandardException
1:eac0369: 	{
1:eac0369: 		lcc.userCommit();
1:eac0369: 	}		
1:eac0369: 
1:93fa39e: 	void rollback() throws StandardException
1:eac0369: 	{
1:eac0369: 		// lcc may be null if this is called in close.
1:eac0369: 		if (lcc != null)
1:eac0369: 			lcc.userRollback();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * context management
1:eac0369: 	 */
1:eac0369: 
1:2b22c7f: 	/**
1:eac0369: 	 * An error happens in the constructor, pop the context.
1:eac0369: 	 */
1:eac0369: 	void clearContextInError()
1:eac0369: 	{
1:eac0369: 		csf.resetCurrentContextManager(cm);
1:eac0369: 		cm = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Resolve: probably superfluous
1:eac0369: 	 */
1:93fa39e: 	void clearLcc()
1:eac0369: 	{
1:eac0369: 		lcc = null;
1:eac0369: 	}
1:eac0369: 
1:93fa39e: 	final void setupContextStack()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(cm != null, "setting up null context manager stack");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 			csf.setCurrentContextManager(cm);
1:eac0369: 	}
1:eac0369: 
1:93fa39e: 	final void restoreContextStack() {
1:eac0369: 
1:eac0369: 		if ((csf == null) || (cm == null))
1:eac0369: 			return;
1:eac0369: 		csf.resetCurrentContextManager(cm);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * exception handling
1:eac0369: 	 */
1:eac0369: 
1:2b22c7f: 	/**
1:eac0369: 	 * clean up the error and wrap the real exception in some SQLException.
1:eac0369: 	 */
1:93fa39e: 	final SQLException handleException(Throwable thrownException,
1:eac0369: 									   boolean autoCommit,	
1:eac0369: 									   boolean rollbackOnAutoCommit)
1:eac0369: 			throws SQLException 
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.ASSERT(thrownException != null);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 				just pass SQL exceptions right back. We assume that JDBC driver
1:eac0369: 				code has cleaned up sufficiently. Not passing them through would mean
1:eac0369: 				that all cleanupOnError methods would require knowledge of Utils.
1:eac0369: 			 */
1:eac0369: 			if (thrownException instanceof SQLException) {
1:eac0369: 
1:3a6f4cf:                 InterruptStatus.restoreIntrFlagIfSeen();
1:eac0369: 				return (SQLException) thrownException;
1:3a6f4cf: 
1:eac0369: 			} 
1:eac0369: 
1:eac0369: 			boolean checkForShutdown = false;
1:eac0369: 			if (thrownException instanceof StandardException)
1:eac0369: 			{
1:eac0369: 				StandardException se = (StandardException) thrownException;
1:eac0369: 				int severity = se.getSeverity();
1:eac0369: 				if (severity <= ExceptionSeverity.STATEMENT_SEVERITY)
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** If autocommit is on, then do a rollback
1:eac0369: 					** to release locks if requested.  We did a stmt 
1:eac0369: 					** rollback in the cleanupOnError above, but we still
1:eac0369: 					** may hold locks from the stmt.
1:eac0369: 					*/
1:eac0369: 					if (autoCommit && rollbackOnAutoCommit)
1:eac0369: 					{
1:eac0369: 						se.setSeverity(ExceptionSeverity.TRANSACTION_SEVERITY);
1:eac0369: 					}
1:eac0369: 				} else if (SQLState.CONN_INTERRUPT.equals(se.getMessageId())) {
1:eac0369: 					// an interrupt closed the connection.
1:eac0369: 					checkForShutdown = true;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			// if cm is null, we don't have a connection context left,
1:eac0369: 			// it was already removed.  all that's left to cleanup is
1:eac0369: 			// JDBC objects.
1:eac0369: 			if (cm!=null) {
1:527b771: 			    //diagActive should be passed to cleanupOnError
1:527b771: 			    //only if a session is active, Login errors are a special case where
1:527b771: 			    // the database is active but the session is not.
1:527b771: 				boolean sessionActive = (database != null) && database.isActive() && 
1:527b771: 					!isLoginException(thrownException);
1:527b771: 				boolean isShutdown = cleanupOnError(thrownException, sessionActive);
1:eac0369: 				if (checkForShutdown && isShutdown) {
1:eac0369: 					// Change the error message to be a known shutdown.
1:eac0369: 					thrownException = shutdownDatabaseException();
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:3a6f4cf:             InterruptStatus.restoreIntrFlagIfSeen();
1:eac0369: 
1:de3b108: 			return wrapInSQLException(thrownException);
1:eac0369: 
1:eac0369: 		} catch (Throwable t) {
1:eac0369: 
1:4c5c16b:             if (cm != null) { // something to let us cleanup?
1:4c5c16b:                 cm.cleanupOnError(t, database != null ? isActive() : false);
1:eac0369: 			}
1:eac0369: 
1:3a6f4cf:             InterruptStatus.restoreIntrFlagIfSeen();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			   We'd rather throw the Throwable,
1:eac0369: 			   but then javac complains...
1:eac0369: 			   We assume if we are in this degenerate
1:eac0369: 			   case that it is actually a java exception
1:eac0369: 			 */
1:de3b108: 			throw wrapInSQLException(t);
1:eac0369: 			//throw t;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:527b771:      * Determine if the exception thrown is a login exception.
1:527b771:      * Needed for DERBY-5427 fix to prevent inappropriate thread dumps
1:527b771:      * and javacores. This exception is special because it is 
1:527b771:      * SESSION_SEVERITY and database.isActive() is true, but the 
1:527b771:      * session hasn't started yet,so it is not an actual crash and 
1:527b771:      * should not report extended diagnostics.
1:527b771:      * 
1:527b771:      * @param thrownException
1:527b771:      * @return true if this is a login failure exception
1:527b771:      */
1:527b771:     private boolean isLoginException(Throwable thrownException) {
1:0889c64:        if ((thrownException instanceof StandardException) &&
1:0889c64:            ((StandardException) thrownException).getSQLState().equals(SQLState.LOGIN_FAILED)) {
1:527b771:            return true;
1:527b771:        }
1:527b771:        return false;
1:527b771:     }
1:527b771:     
1:527b771:     /**
1:2b22c7f:      * Wrap a <code>Throwable</code> in an <code>SQLException</code>.
1:2b22c7f:      *
1:2b22c7f:      * @param thrownException a <code>Throwable</code>
1:2b22c7f:      * @return <code>thrownException</code>, if it is an
1:2b22c7f:      * <code>SQLException</code>; otherwise, an <code>SQLException</code> which
1:2b22c7f:      * wraps <code>thrownException</code>
1:2b22c7f:      */
1:de3b108: 	public static SQLException wrapInSQLException(Throwable thrownException) {
1:eac0369: 
1:eac0369: 		if (thrownException == null)
1:de3b108: 			return null;
1:eac0369: 
1:eac0369: 		if (thrownException instanceof SQLException) {
1:2b22c7f:             // Server side JDBC can end up with a SQLException in the nested
1:2b22c7f:             // stack. Return the exception with no wrapper.
1:2b22c7f:             return (SQLException) thrownException;
1:eac0369: 		}
1:2b22c7f: 
1:2b22c7f:         if (thrownException instanceof StandardException) {
1:eac0369: 
1:eac0369: 			StandardException se = (StandardException) thrownException;
1:eac0369: 
1:c8e3030:             if (SQLState.CONN_INTERRUPT.equals(se.getSQLState())) {
1:c8e3030:                 Thread.currentThread().interrupt();
1:c8e3030:             }
1:c8e3030: 
1:de3b108:             if (se.getCause() == null) {
1:2b22c7f:                 // se is a single, unchained exception. Just convert it to an
1:2b22c7f:                 // SQLException.
1:2b22c7f:                 return Util.generateCsSQLException(se);
1:de3b108:             }
1:eac0369: 
1:2b22c7f:             // se contains a non-empty exception chain. We want to put all of
1:2b22c7f:             // the exceptions (including Java exceptions) in the next-exception
1:2b22c7f:             // chain. Therefore, call wrapInSQLException() recursively to
1:2b22c7f:             // convert the cause chain into a chain of SQLExceptions.
1:2b22c7f:             return Util.seeNextException(se.getMessageId(),
1:63574ff:                         wrapInSQLException(se.getCause()), se.getCause(),
1:63574ff:                         se.getArguments());
1:2b22c7f:         }
1:eac0369: 
1:2b22c7f:         // thrownException is a Java exception
1:2b22c7f:         return Util.javaException(thrownException);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * TransactionResource methods
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	String getUserName() {
1:eac0369: 		return  username;
1:eac0369: 	}
1:eac0369: 
1:4c5c16b:     /**
1:4c5c16b:      * clean up error and print it to derby.log if diagActive is true
1:7b17fca:      * @param e the error we want to clean up
1:4c5c16b:      * @param diagActive
1:4c5c16b:      *        true if extended diagnostics should be considered, 
1:4c5c16b:      *        false not interested of extended diagnostic information
1:4c5c16b:      * @return true if the context manager is shutdown, false otherwise.
1:4c5c16b:      */
1:4c5c16b:     boolean cleanupOnError(Throwable e, boolean diagActive)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(cm != null, "cannot cleanup on error with null context manager");
1:eac0369: 
1:4c5c16b:         //DERBY-4856 thread dump
1:4c5c16b:         return cm.cleanupOnError(e, diagActive);
1:eac0369: 	}
1:eac0369: 
1:93fa39e: 	boolean isIdle()
1:eac0369: 	{
1:eac0369: 		// If no lcc, there is no transaction.
1:eac0369: 		return (lcc == null || lcc.getTransactionExecute().isIdle());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * class specific methods
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:eac0369: 	/* 
1:eac0369: 	 * is the underlaying database still active?
1:eac0369: 	 */
1:eac0369: 	boolean isActive()
1:eac0369: 	{
1:eac0369: 		// database is null at connection open time
1:eac0369: 		return (driver.isActive() && ((database == null) || database.isActive()));
1:eac0369: 	}
1:eac0369: 
1:eac0369: }
1:eac0369: 
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:  *|                        |&lt;-----|                 |&lt;-----|                 |
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:63574ff
/////////////////////////////////////////////////////////////////////////
1:                         wrapInSQLException(se.getCause()), se.getCause(),
1:                         se.getArguments());
commit:2b22c7f
/////////////////////////////////////////////////////////////////////////
1:  * </PRE>
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Wrap a <code>Throwable</code> in an <code>SQLException</code>.
1:      *
1:      * @param thrownException a <code>Throwable</code>
1:      * @return <code>thrownException</code>, if it is an
1:      * <code>SQLException</code>; otherwise, an <code>SQLException</code> which
1:      * wraps <code>thrownException</code>
1:      */
1:             // Server side JDBC can end up with a SQLException in the nested
1:             // stack. Return the exception with no wrapper.
1:             return (SQLException) thrownException;
1: 
1:         if (thrownException instanceof StandardException) {
1:                 // se is a single, unchained exception. Just convert it to an
1:                 // SQLException.
1:                 return Util.generateCsSQLException(se);
1:             // se contains a non-empty exception chain. We want to put all of
1:             // the exceptions (including Java exceptions) in the next-exception
1:             // chain. Therefore, call wrapInSQLException() recursively to
1:             // convert the cause chain into a chain of SQLExceptions.
1:             return Util.seeNextException(se.getMessageId(),
0:                         se.getArguments(), wrapInSQLException(se.getCause()));
1:         }
1:         // thrownException is a Java exception
1:         return Util.javaException(thrownException);
commit:de3b108
/////////////////////////////////////////////////////////////////////////
1: 			return wrapInSQLException(thrownException);
/////////////////////////////////////////////////////////////////////////
1: 			throw wrapInSQLException(t);
1: 	public static SQLException wrapInSQLException(Throwable thrownException) {
1: 			return null;
/////////////////////////////////////////////////////////////////////////
1:             if (se.getCause() == null) {
0:                 nextSQLException = Util.generateCsSQLException(se);
0:             } else {
0:                 nextSQLException = Util.seeNextException(se.getMessageId(),
0:                         se.getArguments(), wrapInSQLException(se.getCause()));
1:             }
commit:e70c716
/////////////////////////////////////////////////////////////////////////
0: 			wrapInSQLException(nextSQLException, se.getCause());
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0889c64
/////////////////////////////////////////////////////////////////////////
1:        if ((thrownException instanceof StandardException) &&
1:            ((StandardException) thrownException).getSQLState().equals(SQLState.LOGIN_FAILED)) {
commit:527b771
/////////////////////////////////////////////////////////////////////////
1: 			    //diagActive should be passed to cleanupOnError
1: 			    //only if a session is active, Login errors are a special case where
1: 			    // the database is active but the session is not.
1: 				boolean sessionActive = (database != null) && database.isActive() && 
1: 					!isLoginException(thrownException);
1: 				boolean isShutdown = cleanupOnError(thrownException, sessionActive);
/////////////////////////////////////////////////////////////////////////
1:      * Determine if the exception thrown is a login exception.
1:      * Needed for DERBY-5427 fix to prevent inappropriate thread dumps
1:      * and javacores. This exception is special because it is 
1:      * SESSION_SEVERITY and database.isActive() is true, but the 
1:      * session hasn't started yet,so it is not an actual crash and 
1:      * should not report extended diagnostics.
1:      * 
1:      * @param thrownException
1:      * @return true if this is a login failure exception
1:      */
1:     private boolean isLoginException(Throwable thrownException) {
0:        if (thrownException instanceof StandardException) {
0:            ((StandardException) thrownException).getSQLState().equals(SQLState.LOGIN_FAILED);
1:            return true;
1:        }
1:        return false;
1:     }
1:     
1:     /**
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:c8e3030
/////////////////////////////////////////////////////////////////////////
1:             if (SQLState.CONN_INTERRUPT.equals(se.getSQLState())) {
1:                 Thread.currentThread().interrupt();
1:             }
1: 
commit:3a6f4cf
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.InterruptStatus;
/////////////////////////////////////////////////////////////////////////
1:                 InterruptStatus.restoreIntrFlagIfSeen();
/////////////////////////////////////////////////////////////////////////
1:             InterruptStatus.restoreIntrFlagIfSeen();
/////////////////////////////////////////////////////////////////////////
1: 
1:             InterruptStatus.restoreIntrFlagIfSeen();
1: 
author:Lily Wei
-------------------------------------------------------------------------------
commit:7b17fca
/////////////////////////////////////////////////////////////////////////
1:      * @param e the error we want to clean up
commit:4c5c16b
/////////////////////////////////////////////////////////////////////////
0: 				boolean isShutdown = cleanupOnError(thrownException, database != null ? database.isActive() : false);
/////////////////////////////////////////////////////////////////////////
1:             if (cm != null) { // something to let us cleanup?
1:                 cm.cleanupOnError(t, database != null ? isActive() : false);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * clean up error and print it to derby.log if diagActive is true
0:      * @param error the error we want to clean up
1:      * @param diagActive
1:      *        true if extended diagnostics should be considered, 
1:      *        false not interested of extended diagnostic information
1:      * @return true if the context manager is shutdown, false otherwise.
1:      */
1:     boolean cleanupOnError(Throwable e, boolean diagActive)
1:         //DERBY-4856 thread dump
1:         return cm.cleanupOnError(e, diagActive);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:c5925e9
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:eb10a33
/////////////////////////////////////////////////////////////////////////
0:             sqlException.initCause(nextSQLException);
commit:93fa39e
/////////////////////////////////////////////////////////////////////////
1: 	void commit() throws StandardException
1: 	void rollback() throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 	void clearLcc()
1: 	final void setupContextStack()
/////////////////////////////////////////////////////////////////////////
1: 	final void restoreContextStack() {
/////////////////////////////////////////////////////////////////////////
1: 	final SQLException handleException(Throwable thrownException,
/////////////////////////////////////////////////////////////////////////
0: 	boolean cleanupOnError(Throwable e)
/////////////////////////////////////////////////////////////////////////
1: 	boolean isIdle()
commit:0e38470
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.jdbc.InternalDriver;
/////////////////////////////////////////////////////////////////////////
1: 	private InternalDriver driver;
/////////////////////////////////////////////////////////////////////////
1: 							InternalDriver driver, 
1: 		dbname = InternalDriver.getDatabaseName(url, info);
/////////////////////////////////////////////////////////////////////////
1: 	InternalDriver getDriver() {
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.TransactionResourceImpl
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc;
1: 
0: import org.apache.derby.jdbc.Driver169;
1: 
1: import org.apache.derby.iapi.services.context.Context;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.db.Database;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.error.ExceptionSeverity;
1: 
1: import org.apache.derby.iapi.reference.Attribute;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: import java.util.Properties;
1: import java.sql.SQLException;
1: 
1: /** 
1:  *	An instance of a TransactionResourceImpl is a bundle of things that
1:  *	connects a connection to the database - it is the transaction "context" in
1:  *	a generic sense.  It is also the object of synchronization used by the
1:  *	connection object to make sure only one thread is accessing the underlying
1:  *	transaction and context.
1:  *
1:  *  <P>TransactionResourceImpl not only serves as a transaction "context", it
1:  *	also takes care of: <OL>
1:  *	<LI>context management: the pushing and popping of the context manager in
1:  *		and out of the global context service</LI>
1:  *	<LI>transaction demarcation: all calls to commit/abort/prepare/close a
1:  *		transaction must route thru the transaction resource.
1:  *	<LI>error handling</LI>
1:  *	</OL>
1:  *
1:  *  <P>The only connection that have access to the TransactionResource is the
1:  *  root connection, all other nested connections (called proxyConnection)
1:  *  accesses the TransactionResource via the root connection.  The root
1:  *  connection may be a plain EmbedConnection, or a DetachableConnection (in
1:  *  case of a XATransaction).  A nested connection must be a ProxyConnection.
1:  *  A proxyConnection is not detachable and can itself be a XA connection -
1:  *  although an XATransaction may start nested local (proxy) connections.
1:  *
1:  *	<P> this is an example of how all the objects in this package relate to each
1:  *		other.  In this example, the connection is nested 3 deep.  
1:  *		DetachableConnection.  
1:  *	<P><PRE>
1:  *
1:  *      lcc  cm   database  jdbcDriver
1:  *       ^    ^    ^         ^ 
1:  *       |    |    |         |
1:  *      |======================|
1:  *      | TransactionResource  |
1:  *      |======================|
1:  *             ^  |
1:  *             |  |
1:  *             |  |      |---------------rootConnection----------|
1:  *             |  |      |                                       |
1:  *             |  |      |- rootConnection-|                     |
1:  *             |  |      |                 |                     |
1:  *             |  V      V                 |                     |
1:  *|========================|      |=================|      |=================|
1:  *|    EmbedConnection     |      | EmbedConnection |      | EmbedConnection |
0:  *|                        |<-----|                 |<-----|                 |
1:  *| (DetachableConnection) |      | ProxyConnection |      | ProxyConnection |
1:  *|========================|      |=================|      |=================|
1:  *   ^                 | ^             ^                        ^
1:  *   |                 | |             |                        |
1:  *   ---rootConnection-- |             |                        |
1:  *                       |             |                        |
1:  *                       |             |                        |
1:  * |======================|  |======================|  |======================|
1:  * | ConnectionChild |  | ConnectionChild |  | ConnectionChild |
1:  * |                      |  |                      |  |                      |
1:  * |  (EmbedStatement)    |  |  (EmbedResultSet)    |  |  (...)               |
1:  * |======================|  |======================|  |======================|
1:  *
1:  * <P>A plain local connection <B>must</B> be attached (doubly linked with) to a
1:  * TransactionResource at all times.  A detachable connection can be without a
1:  * TransactionResource, and a TransactionResource for an XATransaction
1:  * (called  XATransactionResource) can be without a connection.
1:  *
1:  *
1:  */
1: public final class TransactionResourceImpl
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/*
1: 	** instance variables set up in the constructor.
1: 	*/
1: 	// conn is only present if TR is attached to a connection
1: 	protected ContextManager cm;
1: 	protected ContextService csf;
1: 	protected String username;
1: 
1: 	private String dbname;
0: 	private Driver169 driver;
1: 	private String url;
1: 	private String drdaID;
1: 
1: 	// set these up after constructor, called by EmbedConnection
1: 	protected Database database;
1: 	protected LanguageConnectionContext lcc;
1: 
1: 	/*
1: 	 * create a brand new connection for a brand new transaction
1: 	 */
1: 	TransactionResourceImpl(
0: 							Driver169 driver, 
1: 							String url,
1: 							Properties info) throws SQLException 
1: 	{
1: 		this.driver = driver;
1: 		csf = driver.getContextServiceFactory();
0: 		dbname = Driver169.getDatabaseName(url, info);
1: 		this.url = url;
1: 
1: 		// the driver manager will push a user name
1: 		// into the properties if its getConnection(url, string, string)
1: 		// interface is used.  Thus, we look there first.
1: 		// Default to APP.
0: 		username = info.getProperty(Attribute.USERNAME_ATTR,
0: 									Property.DEFAULT_USER_NAME);
0: 		if (username.equals(""))
0: 			username = Property.DEFAULT_USER_NAME;
1: 
1: 		drdaID = info.getProperty(Attribute.DRDAID_ATTR, null);
1: 
1: 		// make a new context manager for this TransactionResource
1: 
1: 		// note that the Database API requires that the 
1: 		// getCurrentContextManager call return the context manager
1: 		// associated with this session.  The JDBC driver assumes
1: 		// responsibility (for now) for tracking and installing
1: 		// this context manager for the thread, each time a database
1: 		// call is made.
1: 		cm = csf.newContextManager();
1: 	}
1: 
1: 	/*
1: 	 * Called only in EmbedConnection construtor.
1: 	 * The Local Connection sets up the database in its constructor and sets it
1: 	 * here.
1: 	 */
1: 	void setDatabase(Database db)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(database == null, 
1: 				"setting database when it is not null"); 
1: 
1: 		database = db;
1: 	}
1: 
1: 	/*
1: 	 * Called only in EmbedConnection constructor.  Create a new transaction
1: 	 * by creating a lcc.
1: 	 *
1: 	 * The arguments are not used by this object, it is used by
1: 	 * XATransactionResoruceImpl.  Put them here so that there is only one
1: 	 * routine to start a local connection.
1: 	 */
1: 	void startTransaction() throws StandardException, SQLException
1: 	{
1: 		// setting up local connection
1: 		lcc = database.setupConnection(cm, username, drdaID, dbname);
1: 	}
1: 
1: 	/*
1: 	 * Return instance variables to EmbedConnection.  RESOLVE: given time, we
1: 	 * should perhaps stop giving out reference to these things but instead use
1: 	 * the transaction resource itself.
1: 	 */
0: 	Driver169 getDriver() {
1: 		return driver;
1: 	}
1: 	ContextService getCsf() {
1: 		return  csf;
1: 	}
1: 
1: 	/*
1: 	 * need to be public because it is in the XATransactionResource interface
1: 	 */
1: 	ContextManager getContextManager() {
1: 		return  cm;
1: 	}
1: 
1: 	LanguageConnectionContext getLcc() {
1: 		return  lcc;
1: 	}
1: 	String getDBName() {
1: 		return  dbname;
1: 	}
1: 	String getUrl() {
1: 		return  url;
1: 	}
1: 	Database getDatabase() {
1: 		return  database;
1: 	}
1: 
1: 	StandardException shutdownDatabaseException() {
1: 		StandardException se = StandardException.newException(SQLState.SHUTDOWN_DATABASE, getDBName());
1: 		se.setReport(StandardException.REPORT_NEVER);
1: 		return se;
1: 	}
1: 
1: 	/*
1: 	 * local transaction demarcation - note that global or xa transaction
1: 	 * cannot commit thru the connection, they can only commit thru the
1: 	 * XAResource, which uses the xa_commit or xa_rollback interface as a 
1: 	 * safeguard. 
1: 	 */
0: 	protected void commit() throws StandardException
1: 	{
1: 		lcc.userCommit();
1: 	}		
1: 
0: 	protected void rollback() throws StandardException
1: 	{
1: 		// lcc may be null if this is called in close.
1: 		if (lcc != null)
1: 			lcc.userRollback();
1: 	}
1: 
1: 	/*
1: 	 * context management
1: 	 */
1: 
1: 	/**
1: 	 * An error happens in the constructor, pop the context.
1: 	 */
1: 	void clearContextInError()
1: 	{
1: 		csf.resetCurrentContextManager(cm);
1: 		cm = null;
1: 	}
1: 
1: 	/**
1: 	 * Resolve: probably superfluous
1: 	 */
0: 	protected void clearLcc()
1: 	{
1: 		lcc = null;
1: 	}
1: 
0: 	protected final void setupContextStack()
1: 	{
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(cm != null, "setting up null context manager stack");
1: 		}
1: 
1: 			csf.setCurrentContextManager(cm);
1: 	}
1: 
0: 	protected final void restoreContextStack() {
1: 
1: 		if ((csf == null) || (cm == null))
1: 			return;
1: 		csf.resetCurrentContextManager(cm);
1: 	}
1: 
1: 	/*
1: 	 * exception handling
1: 	 */
1: 
1: 	/*
1: 	 * clean up the error and wrap the real exception in some SQLException.
1: 	 */
0: 	protected final SQLException handleException(Throwable thrownException,
1: 									   boolean autoCommit,	
1: 									   boolean rollbackOnAutoCommit)
1: 			throws SQLException 
1: 	{
1: 		try {
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.ASSERT(thrownException != null);
1: 
1: 			/*
1: 				just pass SQL exceptions right back. We assume that JDBC driver
1: 				code has cleaned up sufficiently. Not passing them through would mean
1: 				that all cleanupOnError methods would require knowledge of Utils.
1: 			 */
1: 			if (thrownException instanceof SQLException) {
1: 
1: 				return (SQLException) thrownException;
1: 
1: 			} 
1: 
1: 			boolean checkForShutdown = false;
1: 			if (thrownException instanceof StandardException)
1: 			{
1: 				StandardException se = (StandardException) thrownException;
1: 				int severity = se.getSeverity();
1: 				if (severity <= ExceptionSeverity.STATEMENT_SEVERITY)
1: 				{
1: 					/*
1: 					** If autocommit is on, then do a rollback
1: 					** to release locks if requested.  We did a stmt 
1: 					** rollback in the cleanupOnError above, but we still
1: 					** may hold locks from the stmt.
1: 					*/
1: 					if (autoCommit && rollbackOnAutoCommit)
1: 					{
1: 						se.setSeverity(ExceptionSeverity.TRANSACTION_SEVERITY);
1: 					}
1: 				} else if (SQLState.CONN_INTERRUPT.equals(se.getMessageId())) {
1: 					// an interrupt closed the connection.
1: 					checkForShutdown = true;
1: 				}
1: 			}
1: 			// if cm is null, we don't have a connection context left,
1: 			// it was already removed.  all that's left to cleanup is
1: 			// JDBC objects.
1: 			if (cm!=null) {
0: 				boolean isShutdown = cleanupOnError(thrownException);
1: 				if (checkForShutdown && isShutdown) {
1: 					// Change the error message to be a known shutdown.
1: 					thrownException = shutdownDatabaseException();
1: 				}
1: 			}
1: 
1: 
1: 
0: 			return wrapInSQLException((SQLException) null, thrownException);
1: 
1: 		} catch (Throwable t) {
1: 
0: 			if (cm!=null) { // something to let us cleanup?
0: 				cm.cleanupOnError(t);
1: 			}
1: 			/*
1: 			   We'd rather throw the Throwable,
1: 			   but then javac complains...
1: 			   We assume if we are in this degenerate
1: 			   case that it is actually a java exception
1: 			 */
0: 			throw wrapInSQLException((SQLException) null, t);
1: 			//throw t;
1: 		}
1: 
1: 	}
1: 		 
0: 	public static final SQLException wrapInSQLException(SQLException sqlException, Throwable thrownException) {
1: 
1: 		if (thrownException == null)
0: 			return sqlException;
1: 
0: 		SQLException nextSQLException;
1: 
1: 		if (thrownException instanceof SQLException) {
1: 
0: 			// server side JDBC can end up with a SQLException in the nested stack
0: 			nextSQLException = (SQLException) thrownException;
1: 		}
0: 		else if (thrownException instanceof StandardException) {
1: 
1: 			StandardException se = (StandardException) thrownException;
1: 
0: 			nextSQLException = Util.generateCsSQLException(se);
1: 
0: 			wrapInSQLException(nextSQLException, se.getNestedException());
1: 
0: 		} else {
1: 
0: 			nextSQLException = Util.javaException(thrownException);
1: 
0: 			// special case some java exceptions that have nested exceptions themselves
0: 			Throwable nestedByJVM = null;
0: 			if (thrownException instanceof ExceptionInInitializerError) {
0: 				nestedByJVM = ((ExceptionInInitializerError) thrownException).getException();
0: 			} else if (thrownException instanceof java.lang.reflect.InvocationTargetException) {
0: 				nestedByJVM = ((java.lang.reflect.InvocationTargetException) thrownException).getTargetException();
1: 			}
1: 
0: 			if (nestedByJVM != null) {
0: 				wrapInSQLException(nextSQLException, nestedByJVM);
1: 			}
1: 			
1: 		}
1: 
0: 		if (sqlException != null) {
0: 			sqlException.setNextException(nextSQLException);
1: 		}
1: 
0: 		return nextSQLException;
1: 	}
1: 
1: 	/*
1: 	 * TransactionResource methods
1: 	 */
1: 
1: 	String getUserName() {
1: 		return  username;
1: 	}
1: 
0: 	public boolean cleanupOnError(Throwable e)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(cm != null, "cannot cleanup on error with null context manager");
1: 
0: 		return cm.cleanupOnError(e);
1: 	}
1: 
0: 	public boolean isIdle()
1: 	{
1: 		// If no lcc, there is no transaction.
1: 		return (lcc == null || lcc.getTransactionExecute().isIdle());
1: 	}
1: 
1: 
1: 	/*
1: 	 * class specific methods
1: 	 */
1: 
1: 
1: 	/* 
1: 	 * is the underlaying database still active?
1: 	 */
1: 	boolean isActive()
1: 	{
1: 		// database is null at connection open time
1: 		return (driver.isActive() && ((database == null) || database.isActive()));
1: 	}
1: 
1: }
1: 
1: 
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:50ba36b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.IdUtil;
/////////////////////////////////////////////////////////////////////////
1: 		username = IdUtil.getUserNameFromURLProps(info);
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import org.apache.derby.jdbc.Driver169;
0: 
0: import org.apache.derby.iapi.services.context.Context;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.db.Database;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: 
0: import org.apache.derby.iapi.reference.Attribute;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.util.Properties;
0: import java.sql.SQLException;
0: 
0: /** 
0:  *	An instance of a TransactionResourceImpl is a bundle of things that
0:  *	connects a connection to the database - it is the transaction "context" in
0:  *	a generic sense.  It is also the object of synchronization used by the
0:  *	connection object to make sure only one thread is accessing the underlying
0:  *	transaction and context.
0:  *
0:  *  <P>TransactionResourceImpl not only serves as a transaction "context", it
0:  *	also takes care of: <OL>
0:  *	<LI>context management: the pushing and popping of the context manager in
0:  *		and out of the global context service</LI>
0:  *	<LI>transaction demarcation: all calls to commit/abort/prepare/close a
0:  *		transaction must route thru the transaction resource.
0:  *	<LI>error handling</LI>
0:  *	</OL>
0:  *
0:  *  <P>The only connection that have access to the TransactionResource is the
0:  *  root connection, all other nested connections (called proxyConnection)
0:  *  accesses the TransactionResource via the root connection.  The root
0:  *  connection may be a plain EmbedConnection, or a DetachableConnection (in
0:  *  case of a XATransaction).  A nested connection must be a ProxyConnection.
0:  *  A proxyConnection is not detachable and can itself be a XA connection -
0:  *  although an XATransaction may start nested local (proxy) connections.
0:  *
0:  *	<P> this is an example of how all the objects in this package relate to each
0:  *		other.  In this example, the connection is nested 3 deep.  
0:  *		DetachableConnection.  
0:  *	<P><PRE>
0:  *
0:  *      lcc  cm   database  jdbcDriver
0:  *       ^    ^    ^         ^ 
0:  *       |    |    |         |
0:  *      |======================|
0:  *      | TransactionResource  |
0:  *      |======================|
0:  *             ^  |
0:  *             |  |
0:  *             |  |      |---------------rootConnection----------|
0:  *             |  |      |                                       |
0:  *             |  |      |- rootConnection-|                     |
0:  *             |  |      |                 |                     |
0:  *             |  V      V                 |                     |
0:  *|========================|      |=================|      |=================|
0:  *|    EmbedConnection     |      | EmbedConnection |      | EmbedConnection |
0:  *|                        |<-----|                 |<-----|                 |
0:  *| (DetachableConnection) |      | ProxyConnection |      | ProxyConnection |
0:  *|========================|      |=================|      |=================|
0:  *   ^                 | ^             ^                        ^
0:  *   |                 | |             |                        |
0:  *   ---rootConnection-- |             |                        |
0:  *                       |             |                        |
0:  *                       |             |                        |
0:  * |======================|  |======================|  |======================|
0:  * | ConnectionChild |  | ConnectionChild |  | ConnectionChild |
0:  * |                      |  |                      |  |                      |
0:  * |  (EmbedStatement)    |  |  (EmbedResultSet)    |  |  (...)               |
0:  * |======================|  |======================|  |======================|
0:  *
0:  * <P>A plain local connection <B>must</B> be attached (doubly linked with) to a
0:  * TransactionResource at all times.  A detachable connection can be without a
0:  * TransactionResource, and a TransactionResource for an XATransaction
0:  * (called  XATransactionResource) can be without a connection.
0:  *
0:  *
0:  */
0: public final class TransactionResourceImpl
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/*
0: 	** instance variables set up in the constructor.
0: 	*/
0: 	// conn is only present if TR is attached to a connection
0: 	protected ContextManager cm;
0: 	protected ContextService csf;
0: 	protected String username;
0: 
0: 	private String dbname;
0: 	private Driver169 driver;
0: 	private String url;
0: 	private String drdaID;
0: 
0: 	// set these up after constructor, called by EmbedConnection
0: 	protected Database database;
0: 	protected LanguageConnectionContext lcc;
0: 
0: 	/*
0: 	 * create a brand new connection for a brand new transaction
0: 	 */
0: 	TransactionResourceImpl(
0: 							Driver169 driver, 
0: 							String url,
0: 							Properties info) throws SQLException 
0: 	{
0: 		this.driver = driver;
0: 		csf = driver.getContextServiceFactory();
0: 		dbname = Driver169.getDatabaseName(url, info);
0: 		this.url = url;
0: 
0: 		// the driver manager will push a user name
0: 		// into the properties if its getConnection(url, string, string)
0: 		// interface is used.  Thus, we look there first.
0: 		// Default to APP.
0: 		username = info.getProperty(Attribute.USERNAME_ATTR,
0: 									Property.DEFAULT_USER_NAME);
0: 		if (username.equals(""))
0: 			username = Property.DEFAULT_USER_NAME;
0: 
0: 		drdaID = info.getProperty(Attribute.DRDAID_ATTR, null);
0: 
0: 		// make a new context manager for this TransactionResource
0: 
0: 		// note that the Database API requires that the 
0: 		// getCurrentContextManager call return the context manager
0: 		// associated with this session.  The JDBC driver assumes
0: 		// responsibility (for now) for tracking and installing
0: 		// this context manager for the thread, each time a database
0: 		// call is made.
0: 		cm = csf.newContextManager();
0: 	}
0: 
0: 	/*
0: 	 * Called only in EmbedConnection construtor.
0: 	 * The Local Connection sets up the database in its constructor and sets it
0: 	 * here.
0: 	 */
0: 	void setDatabase(Database db)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(database == null, 
0: 				"setting database when it is not null"); 
0: 
0: 		database = db;
0: 	}
0: 
0: 	/*
0: 	 * Called only in EmbedConnection constructor.  Create a new transaction
0: 	 * by creating a lcc.
0: 	 *
0: 	 * The arguments are not used by this object, it is used by
0: 	 * XATransactionResoruceImpl.  Put them here so that there is only one
0: 	 * routine to start a local connection.
0: 	 */
0: 	void startTransaction() throws StandardException, SQLException
0: 	{
0: 		// setting up local connection
0: 		lcc = database.setupConnection(cm, username, drdaID, dbname);
0: 	}
0: 
0: 	/*
0: 	 * Return instance variables to EmbedConnection.  RESOLVE: given time, we
0: 	 * should perhaps stop giving out reference to these things but instead use
0: 	 * the transaction resource itself.
0: 	 */
0: 	Driver169 getDriver() {
0: 		return driver;
0: 	}
0: 	ContextService getCsf() {
0: 		return  csf;
0: 	}
0: 
0: 	/*
0: 	 * need to be public because it is in the XATransactionResource interface
0: 	 */
0: 	ContextManager getContextManager() {
0: 		return  cm;
0: 	}
0: 
0: 	LanguageConnectionContext getLcc() {
0: 		return  lcc;
0: 	}
0: 	String getDBName() {
0: 		return  dbname;
0: 	}
0: 	String getUrl() {
0: 		return  url;
0: 	}
0: 	Database getDatabase() {
0: 		return  database;
0: 	}
0: 
0: 	StandardException shutdownDatabaseException() {
0: 		StandardException se = StandardException.newException(SQLState.SHUTDOWN_DATABASE, getDBName());
0: 		se.setReport(StandardException.REPORT_NEVER);
0: 		return se;
0: 	}
0: 
0: 	/*
0: 	 * local transaction demarcation - note that global or xa transaction
0: 	 * cannot commit thru the connection, they can only commit thru the
0: 	 * XAResource, which uses the xa_commit or xa_rollback interface as a 
0: 	 * safeguard. 
0: 	 */
0: 	protected void commit() throws StandardException
0: 	{
0: 		lcc.userCommit();
0: 	}		
0: 
0: 	protected void rollback() throws StandardException
0: 	{
0: 		// lcc may be null if this is called in close.
0: 		if (lcc != null)
0: 			lcc.userRollback();
0: 	}
0: 
0: 	/*
0: 	 * context management
0: 	 */
0: 
0: 	/**
0: 	 * An error happens in the constructor, pop the context.
0: 	 */
0: 	void clearContextInError()
0: 	{
0: 		csf.resetCurrentContextManager(cm);
0: 		cm = null;
0: 	}
0: 
0: 	/**
0: 	 * Resolve: probably superfluous
0: 	 */
0: 	protected void clearLcc()
0: 	{
0: 		lcc = null;
0: 	}
0: 
0: 	protected final void setupContextStack()
0: 	{
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(cm != null, "setting up null context manager stack");
0: 		}
0: 
0: 			csf.setCurrentContextManager(cm);
0: 	}
0: 
0: 	protected final void restoreContextStack() {
0: 
0: 		if ((csf == null) || (cm == null))
0: 			return;
0: 		csf.resetCurrentContextManager(cm);
0: 	}
0: 
0: 	/*
0: 	 * exception handling
0: 	 */
0: 
0: 	/*
0: 	 * clean up the error and wrap the real exception in some SQLException.
0: 	 */
0: 	protected final SQLException handleException(Throwable thrownException,
0: 									   boolean autoCommit,	
0: 									   boolean rollbackOnAutoCommit)
0: 			throws SQLException 
0: 	{
0: 		try {
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.ASSERT(thrownException != null);
0: 
0: 			/*
0: 				just pass SQL exceptions right back. We assume that JDBC driver
0: 				code has cleaned up sufficiently. Not passing them through would mean
0: 				that all cleanupOnError methods would require knowledge of Utils.
0: 			 */
0: 			if (thrownException instanceof SQLException) {
0: 
0: 				return (SQLException) thrownException;
0: 
0: 			} 
0: 
0: 			boolean checkForShutdown = false;
0: 			if (thrownException instanceof StandardException)
0: 			{
0: 				StandardException se = (StandardException) thrownException;
0: 				int severity = se.getSeverity();
0: 				if (severity <= ExceptionSeverity.STATEMENT_SEVERITY)
0: 				{
0: 					/*
0: 					** If autocommit is on, then do a rollback
0: 					** to release locks if requested.  We did a stmt 
0: 					** rollback in the cleanupOnError above, but we still
0: 					** may hold locks from the stmt.
0: 					*/
0: 					if (autoCommit && rollbackOnAutoCommit)
0: 					{
0: 						se.setSeverity(ExceptionSeverity.TRANSACTION_SEVERITY);
0: 					}
0: 				} else if (SQLState.CONN_INTERRUPT.equals(se.getMessageId())) {
0: 					// an interrupt closed the connection.
0: 					checkForShutdown = true;
0: 				}
0: 			}
0: 			// if cm is null, we don't have a connection context left,
0: 			// it was already removed.  all that's left to cleanup is
0: 			// JDBC objects.
0: 			if (cm!=null) {
0: 				boolean isShutdown = cleanupOnError(thrownException);
0: 				if (checkForShutdown && isShutdown) {
0: 					// Change the error message to be a known shutdown.
0: 					thrownException = shutdownDatabaseException();
0: 				}
0: 			}
0: 
0: 
0: 
0: 			return wrapInSQLException((SQLException) null, thrownException);
0: 
0: 		} catch (Throwable t) {
0: 
0: 			if (cm!=null) { // something to let us cleanup?
0: 				cm.cleanupOnError(t);
0: 			}
0: 			/*
0: 			   We'd rather throw the Throwable,
0: 			   but then javac complains...
0: 			   We assume if we are in this degenerate
0: 			   case that it is actually a java exception
0: 			 */
0: 			throw wrapInSQLException((SQLException) null, t);
0: 			//throw t;
0: 		}
0: 
0: 	}
0: 		 
0: 	public static final SQLException wrapInSQLException(SQLException sqlException, Throwable thrownException) {
0: 
0: 		if (thrownException == null)
0: 			return sqlException;
0: 
0: 		SQLException nextSQLException;
0: 
0: 		if (thrownException instanceof SQLException) {
0: 
0: 			// server side JDBC can end up with a SQLException in the nested stack
0: 			nextSQLException = (SQLException) thrownException;
0: 		}
0: 		else if (thrownException instanceof StandardException) {
0: 
0: 			StandardException se = (StandardException) thrownException;
0: 
0: 			nextSQLException = Util.generateCsSQLException(se);
0: 
0: 			wrapInSQLException(nextSQLException, se.getNestedException());
0: 
0: 		} else {
0: 
0: 			nextSQLException = Util.javaException(thrownException);
0: 
0: 			// special case some java exceptions that have nested exceptions themselves
0: 			Throwable nestedByJVM = null;
0: 			if (thrownException instanceof ExceptionInInitializerError) {
0: 				nestedByJVM = ((ExceptionInInitializerError) thrownException).getException();
0: 			} else if (thrownException instanceof java.lang.reflect.InvocationTargetException) {
0: 				nestedByJVM = ((java.lang.reflect.InvocationTargetException) thrownException).getTargetException();
0: 			}
0: 
0: 			if (nestedByJVM != null) {
0: 				wrapInSQLException(nextSQLException, nestedByJVM);
0: 			}
0: 			
0: 		}
0: 
0: 		if (sqlException != null) {
0: 			sqlException.setNextException(nextSQLException);
0: 		}
0: 
0: 		return nextSQLException;
0: 	}
0: 
0: 	/*
0: 	 * TransactionResource methods
0: 	 */
0: 
0: 	String getUserName() {
0: 		return  username;
0: 	}
0: 
0: 	public boolean cleanupOnError(Throwable e)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(cm != null, "cannot cleanup on error with null context manager");
0: 
0: 		return cm.cleanupOnError(e);
0: 	}
0: 
0: 	public boolean isIdle()
0: 	{
0: 		// If no lcc, there is no transaction.
0: 		return (lcc == null || lcc.getTransactionExecute().isIdle());
0: 	}
0: 
0: 
0: 	/*
0: 	 * class specific methods
0: 	 */
0: 
0: 
0: 	/* 
0: 	 * is the underlaying database still active?
0: 	 */
0: 	boolean isActive()
0: 	{
0: 		// database is null at connection open time
0: 		return (driver.isActive() && ((database == null) || database.isActive()));
0: 	}
0: 
0: }
0: 
0: 
============================================================================