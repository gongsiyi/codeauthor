2:84e347a: /*
1:18c4da7: 
1:345de35:    Derby - Class org.apache.derby.impl.load.ExportWriteData
1:345de35: 
1:6d913c6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6d913c6:    contributor license agreements.  See the NOTICE file distributed with
1:6d913c6:    this work for additional information regarding copyright ownership.
1:6d913c6:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6d913c6:    (the "License"); you may not use this file except in compliance with
1:6d913c6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
4:eac0369: 
1:eac0369: package org.apache.derby.impl.load;
1:eac0369: 
1:eac0369: import java.io.FileOutputStream;
1:eac0369: import java.io.BufferedOutputStream;
1:eac0369: import java.io.OutputStreamWriter;
1:84e347a: import java.io.ByteArrayOutputStream;
1:84e347a: import java.io.InputStream;
1:84e347a: import java.io.Reader;
1:eac0369: import java.util.Date;
1:eac0369: import java.io.IOException;
1:e17a43d: import java.io.File;
1:eac0369: 
1:e23ae38: import org.apache.derby.iapi.services.io.FileUtil;
1:e23ae38: 
1:eac0369: //this class takes the passed row and writes it into the data file using the
1:eac0369: //properties from the control file
1:eac0369: //FIXED FORMAT: if length of nullstring is greater than column width, throw execption
1:eac0369: 
1:eac0369: final class ExportWriteData extends ExportWriteDataAbstract
1:400f6eb: 	implements java.security.PrivilegedExceptionAction<Object> {
1:eac0369: 
1:84e347a: 	private String outputFileName;
1:84e347a: 	private String lobsFileName;
1:84e347a: 	private boolean lobsInExtFile = false;
1:84e347a: 	private long lobFileOffset = 0;
1:eac0369: 
1:84e347a: 	// i18n support - instead of using DataOutputStream.writeBytes - use
1:84e347a: 	// OutputStreamWriter.write with the correct codeset.
1:84e347a: 	private OutputStreamWriter aStream;
1:84e347a: 	private OutputStreamWriter lobCharStream;
1:84e347a: 	private BufferedOutputStream lobOutBinaryStream;
1:84e347a: 	private ByteArrayOutputStream lobByteArrayStream;
1:84e347a: 
1:84e347a:     // temporary buffers userd to read/write the lob data.
1:84e347a:     private byte[] byteBuf; 
1:84e347a:     private char[] charBuf;
1:84e347a: 
1:84e347a: 	//writes data into the o/p file using control file properties
1:84e347a: 	ExportWriteData(String outputFileName, ControlInfo controlFileReader)
1:84e347a: 		throws Exception {
1:84e347a: 		this.outputFileName = outputFileName;
1:84e347a: 		this.controlFileReader = controlFileReader;
1:84e347a: 		init();
1:84e347a: 	}
1:052d757: 	
1:84e347a: 	//writes data into the o/p file using control file properties
1:84e347a: 	ExportWriteData(String outputFileName, 
1:84e347a: 					String lobsFileName,
1:84e347a: 					ControlInfo controlFileReader)
1:84e347a: 		throws Exception {
1:84e347a: 		this.outputFileName = outputFileName;
1:84e347a: 		this.lobsFileName = lobsFileName;
1:84e347a: 		this.controlFileReader = controlFileReader;
1:84e347a: 		lobsInExtFile = true;
1:84e347a:         byteBuf = new byte[8192];
1:84e347a:         charBuf = new char[8192];
1:84e347a: 		init();
5:eac0369: 	}
1:84e347a: 
1:84e347a: 	private void init() throws Exception 
1:84e347a: 	{
1:84e347a: 		loadPropertiesInfo();
1:84e347a: 		try {
1:84e347a: 			java.security.AccessController.doPrivileged(this);
1:84e347a: 		} catch (java.security.PrivilegedActionException pae) {
1:84e347a: 			throw pae.getException();
1:84e347a: 		}
1:84e347a: 
1:84e347a: 	}
1:84e347a: 
1:eac0369:   public final Object run() throws Exception {
1:84e347a: 	  openFiles();
1:eac0369: 	  return null;
1:eac0369:   }
1:84e347a: 
1:eac0369:   //prepares the o/p file for writing
1:84e347a:   private void openFiles() throws Exception {
1:eac0369: 
1:e23ae38:     outputFileName = FileUtil.stripProtocolFromFileName( outputFileName );
1:e23ae38:     if ( lobsInExtFile ) { lobsFileName = FileUtil.stripProtocolFromFileName( lobsFileName ); }
1:eac0369:     
1:052d757:     FileOutputStream anOutputStream = null;
1:052d757:     BufferedOutputStream buffered = null;
1:052d757:     FileOutputStream lobOutputStream = null;
1:052d757: 
1:052d757:     try {
1:dc43cf8:         File outputFile = new File(outputFileName);
1:052d757:         anOutputStream = new FileOutputStream(outputFileName);
1:dc43cf8:         FileUtil.limitAccessToOwner(outputFile);
1:dc43cf8: 
1:052d757:         buffered = new BufferedOutputStream(anOutputStream);
1:052d757:     
1:052d757:         aStream = dataCodeset == null ?
1:18c4da7:     		new OutputStreamWriter(buffered) :
1:18c4da7:     		new OutputStreamWriter(buffered, dataCodeset);    	        
1:84e347a: 
1:052d757:         // if lobs are exported to an external file, then 
1:052d757:         // setup the required streams to write lob data.
1:052d757:         if (lobsInExtFile) 
1:052d757:         {
1:052d757:             // setup streams to write large objects into the external file. 
1:e17a43d:             File lobsFile =  new File(lobsFileName);
1:e17a43d:             if (lobsFile.getParentFile() == null) {
1:e17a43d:                 // lob file name is unqualified. Make lobs file 
1:e17a43d:                 // parent directory is same as the the main export file. 
1:e17a43d:                 // lob file should get created at the same location 
1:e17a43d:                 // as the main export file.
1:e17a43d:                 lobsFile = new File((new File (outputFileName)).getParentFile(),
1:e17a43d:                                     lobsFileName);
1:e17a43d: 
1:e17a43d:             }
1:e17a43d: 
1:e17a43d:             lobOutputStream = new FileOutputStream(lobsFile);
1:dc43cf8:             FileUtil.limitAccessToOwner(lobsFile);
1:dc43cf8: 
1:052d757:             lobOutBinaryStream = new BufferedOutputStream(lobOutputStream);
1:84e347a: 
1:052d757:             // helper stream to convert char data to binary, after conversion
1:052d757:             // data is written to lobOutBinaryStream.
1:052d757:             lobByteArrayStream = new ByteArrayOutputStream();
1:052d757:             lobCharStream =  dataCodeset == null ?
1:052d757:                 new OutputStreamWriter(lobByteArrayStream) :
1:052d757:                 new OutputStreamWriter(lobByteArrayStream, dataCodeset);    	        
1:052d757:         }
1:052d757:     } catch (Exception e) {
1:052d757:         // might have failed to setup export file stream. for example 
1:052d757:         // user has specified invalid codeset or incorrect file path. 
1:052d757:         // close the opened file streams.
1:052d757: 
1:052d757:         if (aStream == null) {
1:052d757:             if (buffered != null) {
1:052d757:                 buffered.close();
1:052d757:             } else {
1:052d757:                 if(anOutputStream != null)
1:052d757:                     anOutputStream .close();
1:052d757:             }
1:052d757:         } else {
1:052d757:             // close the main export file stream.
1:052d757:             aStream.close();
1:052d757:             // close the external lob file stream.
1:052d757:             if (lobOutBinaryStream != null) {
1:052d757:                 lobOutBinaryStream.close() ;
1:052d757:             } else {
1:052d757:                 if (lobOutputStream != null) 
1:052d757:                     lobOutputStream.close();
1:052d757:             }
1:052d757:         }
1:052d757: 
1:052d757:         // throw back the original exception.
1:052d757:         throw e;
1:052d757:     }
1:84e347a:   }
1:eac0369: 
1:eac0369:   /**if control file says true for column definition, write it as first line of the
1:eac0369:   *  data file
1:eac0369:  	* @exception	Exception if there is an error
1:eac0369: 	*/
1:7a92d1f:   void writeColumnDefinitionOptionally(String[] columnNames,
1:eac0369:   											  String[] columnTypes)
2:eac0369:   														throws Exception {
1:eac0369: 	boolean ignoreColumnTypes=true;
1:eac0369: 
1:eac0369:     //do uppercase because the ui shows the values as True and False
1:eac0369:     if (columnDefinition.toUpperCase(java.util.Locale.ENGLISH).equals(ControlInfo.INTERNAL_TRUE.toUpperCase(java.util.Locale.ENGLISH))) {
1:4a4b0a8:        String tempStr="";
1:eac0369:        //put the start and stop delimiters around the column name and type
1:eac0369:        for (int i=0; i<columnNames.length; i++) {
1:eac0369: 		 // take care at adding fieldSeparator at the 
1:eac0369: 		 // end of the field if needed
1:eac0369: 		 if (i>0) {
1:eac0369: 			 tempStr=fieldSeparator;
1:eac0369: 		 } else {
1:eac0369: 			 tempStr="";
1:eac0369: 		 }
1:eac0369: 
1:eac0369:          tempStr=tempStr+
1:eac0369: 		 		 fieldStartDelimiter+columnNames[i]+fieldStopDelimiter;
1:eac0369: 		 if (ignoreColumnTypes==false) {
1:eac0369: 			 tempStr=tempStr+fieldSeparator+
1:eac0369: 		 		 fieldStartDelimiter+columnTypes[i]+fieldStopDelimiter;
1:eac0369: 		 }
1:eac0369: 
1:eac0369:          aStream.write(tempStr, 0, tempStr.length());
1:eac0369:        }
1:eac0369:        aStream.write(recordSeparator, 0, recordSeparator.length());
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369:   //puts the start and stop delimiters only if column value contains field/record separator
1:eac0369:   //in it
1:eac0369:   private void writeNextColumn(String oneColumn, boolean isNumeric) throws Exception {
1:eac0369:     if (oneColumn != null) {
1:eac0369:        //put the start and end delimiters always
1:eac0369:        //because of the bug 2045, I broke down following
1:eac0369:        //aStream.writeBytes(fieldStartDelimiter+oneColumn+fieldStopDelimiter);
1:eac0369:        //into 3 writeBytes. That bug had a table with long bit varying datatype and while
1:eac0369:        //writing data from that column using the stream, it would run out of memory.
1:eac0369: 	   // i18n - write using the write method of OutputStreamWriter
1:eac0369:        if (!isNumeric)
1:eac0369: 		   aStream.write(fieldStartDelimiter, 0, fieldStartDelimiter.length());
1:eac0369: 	   //convert the string to double character delimiters format if requred.
1:eac0369: 	   if(doubleDelimiter)
1:eac0369: 		   oneColumn = makeDoubleDelimiterString(oneColumn , fieldStartDelimiter);
1:eac0369: 	   aStream.write(oneColumn, 0, oneColumn.length());
1:eac0369:        if (!isNumeric)
1:eac0369:          aStream.write(fieldStopDelimiter, 0, fieldStopDelimiter.length());
1:eac0369:     }
1:eac0369:   }
1:eac0369: 
1:eac0369: 
1:eac0369: 	
1:2eacdb9:     /**
1:84e347a:      * Writes the binary data in the given input stream to an 
1:84e347a:      * external lob export file, and return it's location 
1:84e347a:      * information in the file as string. Location information 
1:84e347a:      * is written in the main export file. 
1:84e347a:      * @param istream   input streams that contains a binary column data.
1:84e347a:      * @return Location where the column data written in the external file. 
1:84e347a:      * @exception Exception  if any error occurs while writing the data.  
1:84e347a:      */
1:84e347a:     String writeBinaryColumnToExternalFile(InputStream istream) 
1:84e347a:         throws Exception
1:84e347a:     {
1:84e347a:         // read data from the input stream and write it to 
1:84e347a:         // the lob export file and also calculate the amount
1:84e347a:         // of data written in bytes. 
1:84e347a: 
1:84e347a:         long blobSize = 0;
1:84e347a:         int noBytes = 0 ;
1:ffdaf1e:         if (istream != null ) {
2:84e347a:             noBytes = istream.read(byteBuf) ;
1:ffdaf1e:             while(noBytes != -1) 
1:ffdaf1e:             {
1:ffdaf1e:                 lobOutBinaryStream.write(byteBuf, 0 , noBytes);
1:ffdaf1e:                 blobSize += noBytes;
1:ffdaf1e:                 noBytes = istream.read(byteBuf) ;
1:ffdaf1e:             }
1:ffdaf1e: 
1:ffdaf1e:             // close the input stream. 
1:ffdaf1e:             istream.close();
1:ffdaf1e: 
1:ffdaf1e:             // flush the output binary stream. 
1:ffdaf1e:             lobOutBinaryStream.flush();
1:ffdaf1e:         } else {
1:ffdaf1e:             // stream is null, column value must be  SQL NULL.
1:ffdaf1e:             // set the size to -1, on import columns will 
1:ffdaf1e:             // be interepreted as NULL, filename and offset are 
1:ffdaf1e:             // ignored.
1:ffdaf1e:             blobSize = -1;
1:84e347a:         }
1:84e347a: 				
1:84e347a:         // Encode a lob location information as string. This is 
1:84e347a:         // stored in the main export file. It will be used 
1:84e347a:         // to retrive this blob data on import. 
1:ffdaf1e:         // Format is : <code > <fileName>.<lobOffset>.<size of lob>/ </code>.
1:ffdaf1e:         // For a NULL blob, size will be written as -1
1:ffdaf1e: 
1:ffdaf1e:         String lobLocation = lobsFileName + "." + 
1:ffdaf1e:             lobFileOffset + "." +  blobSize + "/";
1:84e347a: 		
1:84e347a:         // update the offset, this will be  where next 
1:84e347a:         // large object data  will be written. 
1:ffdaf1e:         if (blobSize != -1)
1:ffdaf1e:             lobFileOffset += blobSize;
1:84e347a: 
1:84e347a:         return lobLocation;
1:84e347a:     }
1:84e347a: 
1:2eacdb9:     /**
1:84e347a:      * Writes the clob data in the given input Reader to an 
1:84e347a:      * external lob export file, and return it's location 
1:84e347a:      * information in the file as string. Location information 
1:84e347a:      * is written in the main export file. 
1:84e347a:      * @param ir   Reader that contains a clob column data.
1:84e347a:      * @return Location where the column data written in the external file. 
1:84e347a:      * @exception Exception  if any error occurs while writing the data.   
1:84e347a:      */
1:84e347a:     String writeCharColumnToExternalFile(Reader ir) 
1:84e347a:         throws Exception
1:84e347a:     {
1:84e347a: 
1:84e347a:         // read data from the input stream and write it to 
1:84e347a:         // the lob export file and also calculate the amount
1:84e347a:         // of data written in bytes. 
1:84e347a: 
1:84e347a:         long clobSize = 0;
1:84e347a:         int noChars = 0 ;
1:ffdaf1e:         if (ir != null ) {
1:ffdaf1e:             noChars = ir.read(charBuf) ;
1:ffdaf1e:             while(noChars != -1) 
1:ffdaf1e:             {
1:ffdaf1e:                 // characters data is converted to bytes using 
1:ffdaf1e:                 // the user specified code set. 
1:ffdaf1e:                 lobByteArrayStream.reset();
1:ffdaf1e:                 lobCharStream.write(charBuf, 0 , noChars);
1:ffdaf1e:                 lobCharStream.flush();
1:84e347a: 			
1:ffdaf1e:                 clobSize += lobByteArrayStream.size();
1:ffdaf1e:                 lobByteArrayStream.writeTo(lobOutBinaryStream);
1:ffdaf1e:                 noChars  = ir.read(charBuf) ;
1:ffdaf1e:             }
1:84e347a: 
1:ffdaf1e:             // close the input reader. 
1:ffdaf1e:             ir.close();
1:ffdaf1e:             // flush the output binary stream. 
1:ffdaf1e:             lobOutBinaryStream.flush();
1:ffdaf1e:         } else {
1:ffdaf1e:             // reader is null, the column value must be  SQL NULL.
1:ffdaf1e:             // set the size to -1, on import columns will 
1:ffdaf1e:             // be interepreted as NULL, filename and offset are 
1:ffdaf1e:             // ignored.
1:ffdaf1e:             clobSize = -1;
1:ffdaf1e:         }
1:84e347a: 
1:84e347a:         // Encode this lob location information as string. This will 
1:84e347a:         // be written to the main export file. It will be used 
1:84e347a:         // to retrive this blob data on import. 
1:ffdaf1e:         // Format is : <code > <fileName>.<lobOffset>.<size of lob>/ </code>.
1:ffdaf1e:         // For a NULL blob, size will be written as -1
1:ffdaf1e:         String lobLocation = lobsFileName + "." + 
1:ffdaf1e:             lobFileOffset + "." +  clobSize + "/";
1:84e347a: 
1:84e347a:         // update the offset, this will be  where next 
1:84e347a:         // large object data  will be written. 		
1:ffdaf1e:         if (clobSize != -1)
1:ffdaf1e:             lobFileOffset += clobSize;
1:84e347a:         return lobLocation;
1:84e347a:     }
1:84e347a: 	
1:84e347a: 
1:84e347a: 
1:84e347a:     /**write the passed row into the data file
1:eac0369:  	* @exception	Exception if there is an error
1:eac0369: 	*/
1:eac0369:   public void writeData(String[] oneRow, boolean[] isNumeric) throws Exception {
1:eac0369:     if (format.equals(ControlInfo.DEFAULT_FORMAT)) {
1:eac0369:        //if format is delimited, write column data and field separator and then the record separator
1:eac0369:        //if a column's value is null, write just the column separator
1:eac0369:        writeNextColumn(oneRow[0], isNumeric[0]);
1:eac0369:        for (int i = 1; i < oneRow.length; i++) {
1:eac0369:          aStream.write(fieldSeparator, 0, fieldSeparator.length());
1:eac0369:          writeNextColumn(oneRow[i], isNumeric[i]);
1:84e347a:        }
1:eac0369:        if (hasDelimiterAtEnd){ //write an additional delimeter if user wants one at the end of each row
1:eac0369:           aStream.write(fieldSeparator, 0, fieldSeparator.length());
1:84e347a:        }
1:eac0369:     }
1:eac0369:     aStream.write(recordSeparator, 0, recordSeparator.length());
1:eac0369:   }
1:84e347a: 
1:eac0369:   /**if nothing more to write, then close the file and write a message of completion
1:eac0369:   *  in message file
1:eac0369:  	*@exception	Exception if there is an error
1:eac0369: 	*/
1:eac0369:   public void noMoreRows() throws IOException {
1:eac0369:     aStream.flush();
1:eac0369:     aStream.close();
1:84e347a:     if (lobsInExtFile) {
1:84e347a:         // close the streams associated with lob data.
1:84e347a:         if (lobOutBinaryStream != null) {
2:84e347a:             lobOutBinaryStream.flush();
1:84e347a:             lobOutBinaryStream.close();
1:84e347a:         }
1:84e347a:         if (lobCharStream != null) 
1:84e347a:             lobCharStream.close();
1:84e347a:         if (lobByteArrayStream != null)
1:84e347a:             lobByteArrayStream.close();
1:84e347a:     }
1:84e347a:     
1:eac0369: //    System.err.print(new Date(System.currentTimeMillis()) + " ");
1:eac0369: //    System.err.println("Export finished");
1:eac0369: //    System.setErr(System.out);
1:eac0369:   }
1:eac0369: 
1:eac0369: 
1:2eacdb9: 	/**
1:eac0369: 	 * Convert the input string into double delimiter format for export.
1:eac0369: 	 * double character delimiter recognition in delimited format
1:eac0369: 	 * files applies to the export and import utilities. Character delimiters are
1:eac0369: 	 * permitted within the character-based fields of a file. This applies to
1:eac0369: 	 * fields of type CHAR, VARCHAR, LONGVARCHAR, or CLOB. Any pair of character
1:eac0369: 	 * delimiters found between the enclosing character delimiters is imported
1:eac0369: 	 * into the database. For example with doble quote(") as character delimiter
1:eac0369: 	 *
1:eac0369: 	 *	 "What a ""nice""day!"
1:eac0369: 	 *
1:eac0369: 	 *  will be imported as:
1:eac0369: 	 *
1:eac0369: 	 *	 What a "nice"day!
1:eac0369: 	 *
1:eac0369: 	 *	 In the case of export, the rule applies in reverse. For example,
1:eac0369: 	 *
1:eac0369: 	 *	 I am 6"tall.
1:eac0369: 	 *
1:eac0369: 	 *	 will be exported to a file as:
1:eac0369: 	 *
1:eac0369: 	 *	 "I am 6""tall."
1:eac0369: 
1:eac0369:  	 */
1:eac0369: 	private String makeDoubleDelimiterString(String inputString , String charDelimiter)
1:84e347a: 	{
1:eac0369: 		int start = inputString.indexOf(charDelimiter);
1:eac0369: 		StringBuffer result;
1:eac0369: 		//if delimeter is not found inside the string nothing to do
1:eac0369: 		if(start != -1)
1:84e347a: 		{
1:eac0369: 			result = new StringBuffer(inputString);
1:eac0369: 			int current;
1:eac0369: 			int delLength = charDelimiter.length();
1:eac0369: 			while(start!= -1)
1:84e347a: 			{
1:eac0369: 				//insert delimter character 
1:eac0369: 				result = result.insert(start, charDelimiter);
1:eac0369: 				current = start + delLength +1 ;
1:eac0369: 				start = result.toString().indexOf(charDelimiter, current);
1:eac0369: 			}
1:eac0369: 			return result.toString();
1:eac0369: 		}
1:eac0369: 		return inputString;
1:eac0369: 	}
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:400f6eb
/////////////////////////////////////////////////////////////////////////
1: 	implements java.security.PrivilegedExceptionAction<Object> {
commit:e23ae38
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.FileUtil;
1: 
/////////////////////////////////////////////////////////////////////////
1:     outputFileName = FileUtil.stripProtocolFromFileName( outputFileName );
1:     if ( lobsInExtFile ) { lobsFileName = FileUtil.stripProtocolFromFileName( lobsFileName ); }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4a4b0a8
/////////////////////////////////////////////////////////////////////////
1:        String tempStr="";
commit:2eacdb9
/////////////////////////////////////////////////////////////////////////
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 	/**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:dc43cf8
/////////////////////////////////////////////////////////////////////////
1:         File outputFile = new File(outputFileName);
1:         FileUtil.limitAccessToOwner(outputFile);
1: 
/////////////////////////////////////////////////////////////////////////
1:             FileUtil.limitAccessToOwner(lobsFile);
1: 
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:e17a43d
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1:             File lobsFile =  new File(lobsFileName);
1:             if (lobsFile.getParentFile() == null) {
1:                 // lob file name is unqualified. Make lobs file 
1:                 // parent directory is same as the the main export file. 
1:                 // lob file should get created at the same location 
1:                 // as the main export file.
1:                 lobsFile = new File((new File (outputFileName)).getParentFile(),
1:                                     lobsFileName);
1: 
1:             }
1: 
1:             lobOutputStream = new FileOutputStream(lobsFile);
commit:052d757
/////////////////////////////////////////////////////////////////////////
1: 
1:     FileOutputStream anOutputStream = null;
1:     BufferedOutputStream buffered = null;
1:     FileOutputStream lobOutputStream = null;
1: 
1:     try {
1:         anOutputStream = new FileOutputStream(outputFileName);
1:         buffered = new BufferedOutputStream(anOutputStream);
1:     
1:         aStream = dataCodeset == null ?
1:         // if lobs are exported to an external file, then 
1:         // setup the required streams to write lob data.
1:         if (lobsInExtFile) 
1:         {
1:             // setup streams to write large objects into the external file. 
0:             lobOutputStream = new FileOutputStream(lobsFileName);
1:             lobOutBinaryStream = new BufferedOutputStream(lobOutputStream);
1:             // helper stream to convert char data to binary, after conversion
1:             // data is written to lobOutBinaryStream.
1:             lobByteArrayStream = new ByteArrayOutputStream();
1:             lobCharStream =  dataCodeset == null ?
1:                 new OutputStreamWriter(lobByteArrayStream) :
1:                 new OutputStreamWriter(lobByteArrayStream, dataCodeset);    	        
1:         }
1:     } catch (Exception e) {
1:         // might have failed to setup export file stream. for example 
1:         // user has specified invalid codeset or incorrect file path. 
1:         // close the opened file streams.
1: 
1:         if (aStream == null) {
1:             if (buffered != null) {
1:                 buffered.close();
1:             } else {
1:                 if(anOutputStream != null)
1:                     anOutputStream .close();
1:             }
1:         } else {
1:             // close the main export file stream.
1:             aStream.close();
1:             // close the external lob file stream.
1:             if (lobOutBinaryStream != null) {
1:                 lobOutBinaryStream.close() ;
1:             } else {
1:                 if (lobOutputStream != null) 
1:                     lobOutputStream.close();
1:             }
1:         }
1: 
1:         // throw back the original exception.
1:         throw e;
1:     }
commit:ffdaf1e
/////////////////////////////////////////////////////////////////////////
1:         if (istream != null ) {
1:             while(noBytes != -1) 
1:             {
1:                 lobOutBinaryStream.write(byteBuf, 0 , noBytes);
1:                 blobSize += noBytes;
1:                 noBytes = istream.read(byteBuf) ;
1:             }
1: 
1:             // close the input stream. 
1:             istream.close();
1: 
1:             // flush the output binary stream. 
1:             lobOutBinaryStream.flush();
1:         } else {
1:             // stream is null, column value must be  SQL NULL.
1:             // set the size to -1, on import columns will 
1:             // be interepreted as NULL, filename and offset are 
1:             // ignored.
1:             blobSize = -1;
1:         // Format is : <code > <fileName>.<lobOffset>.<size of lob>/ </code>.
1:         // For a NULL blob, size will be written as -1
1: 
1:         String lobLocation = lobsFileName + "." + 
1:             lobFileOffset + "." +  blobSize + "/";
1:         if (blobSize != -1)
1:             lobFileOffset += blobSize;
/////////////////////////////////////////////////////////////////////////
1:         if (ir != null ) {
1:             noChars = ir.read(charBuf) ;
1:             while(noChars != -1) 
1:             {
1:                 // characters data is converted to bytes using 
1:                 // the user specified code set. 
1:                 lobByteArrayStream.reset();
1:                 lobCharStream.write(charBuf, 0 , noChars);
1:                 lobCharStream.flush();
1:                 clobSize += lobByteArrayStream.size();
1:                 lobByteArrayStream.writeTo(lobOutBinaryStream);
1:                 noChars  = ir.read(charBuf) ;
1:             }
1:             // close the input reader. 
1:             ir.close();
1:             // flush the output binary stream. 
1:             lobOutBinaryStream.flush();
1:         } else {
1:             // reader is null, the column value must be  SQL NULL.
1:             // set the size to -1, on import columns will 
1:             // be interepreted as NULL, filename and offset are 
1:             // ignored.
1:             clobSize = -1;
1:         }
1:         // Format is : <code > <fileName>.<lobOffset>.<size of lob>/ </code>.
1:         // For a NULL blob, size will be written as -1
1:         String lobLocation = lobsFileName + "." + 
1:             lobFileOffset + "." +  clobSize + "/";
1:         if (clobSize != -1)
1:             lobFileOffset += clobSize;
commit:84e347a
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayOutputStream;
1: import java.io.InputStream;
1: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
1: 	private String outputFileName;
1: 	private String lobsFileName;
1: 	private boolean lobsInExtFile = false;
1: 	private long lobFileOffset = 0;
1: 	// i18n support - instead of using DataOutputStream.writeBytes - use
1: 	// OutputStreamWriter.write with the correct codeset.
1: 	private OutputStreamWriter aStream;
1: 	private OutputStreamWriter lobCharStream;
1: 	private BufferedOutputStream lobOutBinaryStream;
1: 	private ByteArrayOutputStream lobByteArrayStream;
1:     // temporary buffers userd to read/write the lob data.
1:     private byte[] byteBuf; 
1:     private char[] charBuf;
1: 
1: 	//writes data into the o/p file using control file properties
1: 	ExportWriteData(String outputFileName, ControlInfo controlFileReader)
1: 		throws Exception {
1: 		this.outputFileName = outputFileName;
1: 		this.controlFileReader = controlFileReader;
1: 		init();
1: 	}
1: 	
1: 	//writes data into the o/p file using control file properties
1: 	ExportWriteData(String outputFileName, 
1: 					String lobsFileName,
1: 					ControlInfo controlFileReader)
1: 		throws Exception {
1: 		this.outputFileName = outputFileName;
1: 		this.lobsFileName = lobsFileName;
1: 		this.controlFileReader = controlFileReader;
1: 		lobsInExtFile = true;
1:         byteBuf = new byte[8192];
1:         charBuf = new char[8192];
1: 		init();
1: 	private void init() throws Exception 
1: 	{
1: 		loadPropertiesInfo();
1: 		try {
1: 			java.security.AccessController.doPrivileged(this);
1: 		} catch (java.security.PrivilegedActionException pae) {
1: 			throw pae.getException();
1: 		}
1: 
1: 	}
1: 	  openFiles();
1:   private void openFiles() throws Exception {
1: 	  if (lobsInExtFile) {
0: 		  url = new URL(lobsFileName);
0: 		  lobsFileName = url.getFile();
1: 	  }
/////////////////////////////////////////////////////////////////////////
1: 
0:     // if lobs are exported to an external file, then 
0:     // setup the required streams to write lob data.
0:     if (lobsInExtFile) 
1:     {
0:         // setup streams to write large objects into the external file. 
0:         FileOutputStream lobOutputStream = new FileOutputStream(lobsFileName);
0:         lobOutBinaryStream = new BufferedOutputStream(lobOutputStream);
1: 
0:         // helper stream to convert char data to binary, after conversion
0:         // data is written to lobOutBinaryStream.
0:         lobByteArrayStream = new ByteArrayOutputStream();
0:         lobCharStream =  dataCodeset == null ?
0:             new OutputStreamWriter(lobByteArrayStream) :
0:             new OutputStreamWriter(lobByteArrayStream, dataCodeset);    	        
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 
1: 	
1:     /*
1:      * Writes the binary data in the given input stream to an 
1:      * external lob export file, and return it's location 
1:      * information in the file as string. Location information 
1:      * is written in the main export file. 
1:      * @param istream   input streams that contains a binary column data.
1:      * @return Location where the column data written in the external file. 
1:      * @exception Exception  if any error occurs while writing the data.  
1:      */
1:     String writeBinaryColumnToExternalFile(InputStream istream) 
1:         throws Exception
1:     {
1:         // read data from the input stream and write it to 
1:         // the lob export file and also calculate the amount
1:         // of data written in bytes. 
1: 
1:         long blobSize = 0;
1:         int noBytes = 0 ;
1:         noBytes = istream.read(byteBuf) ;
0:         while(noBytes != -1) 
1:         {
0:             lobOutBinaryStream.write(byteBuf, 0 , noBytes);
0:             blobSize += noBytes;
1:             noBytes = istream.read(byteBuf) ;
1:         }
1: 
0:         // close the input stream. 
0:         istream.close();
1: 
0:         // flush the output binary stream. 
1:         lobOutBinaryStream.flush();
1: 				
1:         // Encode a lob location information as string. This is 
1:         // stored in the main export file. It will be used 
1:         // to retrive this blob data on import. 
0:         // Format is :  <fileName> : <lobOffset> : <size of lob>
0:         String lobLocation = lobsFileName + ":" + 
0:             lobFileOffset + ":" +  blobSize;
1: 		
1:         // update the offset, this will be  where next 
1:         // large object data  will be written. 
0:         lobFileOffset += blobSize;
1: 
1:         return lobLocation;
1:     }
1: 
1:     /*
1:      * Writes the clob data in the given input Reader to an 
1:      * external lob export file, and return it's location 
1:      * information in the file as string. Location information 
1:      * is written in the main export file. 
1:      * @param ir   Reader that contains a clob column data.
1:      * @return Location where the column data written in the external file. 
1:      * @exception Exception  if any error occurs while writing the data.   
1:      */
1:     String writeCharColumnToExternalFile(Reader ir) 
1:         throws Exception
1:     {
1: 
1:         // read data from the input stream and write it to 
1:         // the lob export file and also calculate the amount
1:         // of data written in bytes. 
1: 
1:         long clobSize = 0;
1:         int noChars = 0 ;
0:         noChars = ir.read(charBuf) ;
0:         while(noChars != -1) 
1: 		{
0:             // characters data is converted to bytes using 
0:             // the user specified code set. 
0:             lobByteArrayStream.reset();
0:             lobCharStream.write(charBuf, 0 , noChars);
0:             lobCharStream.flush();
1: 			
0:             clobSize += lobByteArrayStream.size();
0:             lobByteArrayStream.writeTo(lobOutBinaryStream);
0:             noChars  = ir.read(charBuf) ;
1:         }
1: 
0:         // close the input reader. 
0:         ir.close();
0:         // flush the output binary stream. 
1:         lobOutBinaryStream.flush();
1: 
1:         // Encode this lob location information as string. This will 
1:         // be written to the main export file. It will be used 
1:         // to retrive this blob data on import. 
0:         // Format is :  <fileName> : <lobOffset> : <size of lob>
0:         String lobLocation = lobsFileName + ":" + 
0:             lobFileOffset + ":" +  clobSize;
1: 
1:         // update the offset, this will be  where next 
1:         // large object data  will be written. 		
0:         lobFileOffset += clobSize;
1:         return lobLocation;
1:     }
1: 	
1: 
1: 
1:     /**write the passed row into the data file
/////////////////////////////////////////////////////////////////////////
0:     if (lobsInExtFile) {
1:         // close the streams associated with lob data.
1:         if (lobOutBinaryStream != null) {
0:             lobOutBinaryStream.flush();
1:             lobOutBinaryStream.close();
1:         }
1:         if (lobCharStream != null) 
1:             lobCharStream.close();
1:         if (lobByteArrayStream != null)
1:             lobByteArrayStream.close();
1:     }
1:     
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:6d913c6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:18c4da7
/////////////////////////////////////////////////////////////////////////
0:     BufferedOutputStream buffered = new BufferedOutputStream(anOutputStream);
1:     
0:     aStream = dataCodeset == null ?
1:     		new OutputStreamWriter(buffered) :
1:     		new OutputStreamWriter(buffered, dataCodeset);    	        
commit:7a92d1f
/////////////////////////////////////////////////////////////////////////
0:   ExportWriteData(String outputFileName, ControlInfo controlFileReader)
/////////////////////////////////////////////////////////////////////////
1:   void writeColumnDefinitionOptionally(String[] columnNames,
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.load.ExportWriteData
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.load;
1: 
1: import java.io.FileOutputStream;
1: import java.io.BufferedOutputStream;
1: import java.io.OutputStreamWriter;
0: import java.net.MalformedURLException;
0: import java.net.URL;
1: import java.util.Date;
1: import java.io.IOException;
1: 
1: //this class takes the passed row and writes it into the data file using the
1: //properties from the control file
1: //FIXED FORMAT: if length of nullstring is greater than column width, throw execption
1: 
1: final class ExportWriteData extends ExportWriteDataAbstract
0: 	implements java.security.PrivilegedExceptionAction {
0: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
0:   private String outputFileName;
0:   // i18n support - instead of using DataOutputStream.writeBytes - use
0:   // OutputStreamWriter.write with the correct codeset.
0:   private OutputStreamWriter aStream;
1: 
0:   //writes data into the o/p file using control file properties
0:   public ExportWriteData(String outputFileName, ControlInfo controlFileReader)
1:   throws Exception {
0:     this.outputFileName = outputFileName;
0:     this.controlFileReader = controlFileReader;
0:     loadPropertiesInfo();
1: 
0: 	try {
0: 		java.security.AccessController.doPrivileged(this);
0: 	} catch (java.security.PrivilegedActionException pae) {
0: 		throw pae.getException();
1: 	}
1: 
1:   }
1: 
1:   public final Object run() throws Exception {
0: 	  openFile();
1: 	  return null;
1:   }
1: 
1:   //prepares the o/p file for writing
0:   private void openFile() throws Exception {
0:     try {
0:       URL url = new URL(outputFileName);
0:       outputFileName = url.getFile();
0:     } catch (MalformedURLException ex) {}
0:     FileOutputStream anOutputStream = new FileOutputStream(outputFileName);
0:     aStream = new OutputStreamWriter(new BufferedOutputStream(anOutputStream), dataCodeset);
1:   }
1: 
1:   /**if control file says true for column definition, write it as first line of the
1:   *  data file
1:  	* @exception	Exception if there is an error
1: 	*/
0:   public void writeColumnDefinitionOptionally(String[] columnNames,
1:   											  String[] columnTypes)
1:   														throws Exception {
1: 	boolean ignoreColumnTypes=true;
1: 
1:     //do uppercase because the ui shows the values as True and False
1:     if (columnDefinition.toUpperCase(java.util.Locale.ENGLISH).equals(ControlInfo.INTERNAL_TRUE.toUpperCase(java.util.Locale.ENGLISH))) {
0:        String tempStr=new String();
1:        //put the start and stop delimiters around the column name and type
1:        for (int i=0; i<columnNames.length; i++) {
1: 		 // take care at adding fieldSeparator at the 
1: 		 // end of the field if needed
1: 		 if (i>0) {
1: 			 tempStr=fieldSeparator;
1: 		 } else {
1: 			 tempStr="";
1: 		 }
1: 
1:          tempStr=tempStr+
1: 		 		 fieldStartDelimiter+columnNames[i]+fieldStopDelimiter;
1: 		 if (ignoreColumnTypes==false) {
1: 			 tempStr=tempStr+fieldSeparator+
1: 		 		 fieldStartDelimiter+columnTypes[i]+fieldStopDelimiter;
1: 		 }
1: 
1:          aStream.write(tempStr, 0, tempStr.length());
1:        }
1:        aStream.write(recordSeparator, 0, recordSeparator.length());
1:     }
1:   }
1: 
1:   //puts the start and stop delimiters only if column value contains field/record separator
1:   //in it
1:   private void writeNextColumn(String oneColumn, boolean isNumeric) throws Exception {
1:     if (oneColumn != null) {
1:        //put the start and end delimiters always
1:        //because of the bug 2045, I broke down following
1:        //aStream.writeBytes(fieldStartDelimiter+oneColumn+fieldStopDelimiter);
1:        //into 3 writeBytes. That bug had a table with long bit varying datatype and while
1:        //writing data from that column using the stream, it would run out of memory.
1: 	   // i18n - write using the write method of OutputStreamWriter
1:        if (!isNumeric)
1: 		   aStream.write(fieldStartDelimiter, 0, fieldStartDelimiter.length());
1: 	   //convert the string to double character delimiters format if requred.
1: 	   if(doubleDelimiter)
1: 		   oneColumn = makeDoubleDelimiterString(oneColumn , fieldStartDelimiter);
1: 	   aStream.write(oneColumn, 0, oneColumn.length());
1:        if (!isNumeric)
1:          aStream.write(fieldStopDelimiter, 0, fieldStopDelimiter.length());
1:     }
1:   }
1: 
0:   /**write the passed row into the data file
1:  	* @exception	Exception if there is an error
1: 	*/
1:   public void writeData(String[] oneRow, boolean[] isNumeric) throws Exception {
1:     if (format.equals(ControlInfo.DEFAULT_FORMAT)) {
1:        //if format is delimited, write column data and field separator and then the record separator
1:        //if a column's value is null, write just the column separator
1:        writeNextColumn(oneRow[0], isNumeric[0]);
1:        for (int i = 1; i < oneRow.length; i++) {
1:          aStream.write(fieldSeparator, 0, fieldSeparator.length());
1:          writeNextColumn(oneRow[i], isNumeric[i]);
1:        }
1:        if (hasDelimiterAtEnd){ //write an additional delimeter if user wants one at the end of each row
1:           aStream.write(fieldSeparator, 0, fieldSeparator.length());
1:        }
1:     }
1:     aStream.write(recordSeparator, 0, recordSeparator.length());
1:   }
1: 
1:   /**if nothing more to write, then close the file and write a message of completion
1:   *  in message file
1:  	*@exception	Exception if there is an error
1: 	*/
1:   public void noMoreRows() throws IOException {
1:     aStream.flush();
1:     aStream.close();
1: //    System.err.print(new Date(System.currentTimeMillis()) + " ");
1: //    System.err.println("Export finished");
1: //    System.setErr(System.out);
1:   }
1: 
1: 
0: 	/*
1: 	 * Convert the input string into double delimiter format for export.
1: 	 * double character delimiter recognition in delimited format
1: 	 * files applies to the export and import utilities. Character delimiters are
1: 	 * permitted within the character-based fields of a file. This applies to
1: 	 * fields of type CHAR, VARCHAR, LONGVARCHAR, or CLOB. Any pair of character
1: 	 * delimiters found between the enclosing character delimiters is imported
1: 	 * into the database. For example with doble quote(") as character delimiter
1: 	 *
1: 	 *	 "What a ""nice""day!"
1: 	 *
1: 	 *  will be imported as:
1: 	 *
1: 	 *	 What a "nice"day!
1: 	 *
1: 	 *	 In the case of export, the rule applies in reverse. For example,
1: 	 *
1: 	 *	 I am 6"tall.
1: 	 *
1: 	 *	 will be exported to a file as:
1: 	 *
1: 	 *	 "I am 6""tall."
1: 
1:  	 */
1: 	private String makeDoubleDelimiterString(String inputString , String charDelimiter)
0: 	{
1: 		int start = inputString.indexOf(charDelimiter);
1: 		StringBuffer result;
1: 		//if delimeter is not found inside the string nothing to do
1: 		if(start != -1)
0: 		{
1: 			result = new StringBuffer(inputString);
1: 			int current;
1: 			int delLength = charDelimiter.length();
1: 			while(start!= -1)
0: 			{
1: 				//insert delimter character 
1: 				result = result.insert(start, charDelimiter);
1: 				current = start + delLength +1 ;
1: 				start = result.toString().indexOf(charDelimiter, current);
1: 			}
1: 			return result.toString();
1: 		}
1: 		return inputString;
1: 	}
1: }
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.load
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.load;
0: 
0: import java.io.FileOutputStream;
0: import java.io.BufferedOutputStream;
0: import java.io.OutputStreamWriter;
0: import java.net.MalformedURLException;
0: import java.net.URL;
0: import java.util.Date;
0: import java.io.IOException;
0: 
0: //this class takes the passed row and writes it into the data file using the
0: //properties from the control file
0: //FIXED FORMAT: if length of nullstring is greater than column width, throw execption
0: 
0: final class ExportWriteData extends ExportWriteDataAbstract
0: 	implements java.security.PrivilegedExceptionAction {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0:   private String outputFileName;
0:   // i18n support - instead of using DataOutputStream.writeBytes - use
0:   // OutputStreamWriter.write with the correct codeset.
0:   private OutputStreamWriter aStream;
0: 
0:   //writes data into the o/p file using control file properties
0:   public ExportWriteData(String outputFileName, ControlInfo controlFileReader)
0:   throws Exception {
0:     this.outputFileName = outputFileName;
0:     this.controlFileReader = controlFileReader;
0:     loadPropertiesInfo();
0: 
0: 	try {
0: 		java.security.AccessController.doPrivileged(this);
0: 	} catch (java.security.PrivilegedActionException pae) {
0: 		throw pae.getException();
0: 	}
0: 
0:   }
0: 
0:   public final Object run() throws Exception {
0: 	  openFile();
0: 	  return null;
0:   }
0: 
0:   //prepares the o/p file for writing
0:   private void openFile() throws Exception {
0:     try {
0:       URL url = new URL(outputFileName);
0:       outputFileName = url.getFile();
0:     } catch (MalformedURLException ex) {}
0:     FileOutputStream anOutputStream = new FileOutputStream(outputFileName);
0:     aStream = new OutputStreamWriter(new BufferedOutputStream(anOutputStream), dataCodeset);
0:   }
0: 
0:   /**if control file says true for column definition, write it as first line of the
0:   *  data file
0:  	* @exception	Exception if there is an error
0: 	*/
0:   public void writeColumnDefinitionOptionally(String[] columnNames,
0:   											  String[] columnTypes)
0:   														throws Exception {
0: 	boolean ignoreColumnTypes=true;
0: 
0:     //do uppercase because the ui shows the values as True and False
0:     if (columnDefinition.toUpperCase(java.util.Locale.ENGLISH).equals(ControlInfo.INTERNAL_TRUE.toUpperCase(java.util.Locale.ENGLISH))) {
0:        String tempStr=new String();
0:        //put the start and stop delimiters around the column name and type
0:        for (int i=0; i<columnNames.length; i++) {
0: 		 // take care at adding fieldSeparator at the 
0: 		 // end of the field if needed
0: 		 if (i>0) {
0: 			 tempStr=fieldSeparator;
0: 		 } else {
0: 			 tempStr="";
0: 		 }
0: 
0:          tempStr=tempStr+
0: 		 		 fieldStartDelimiter+columnNames[i]+fieldStopDelimiter;
0: 		 if (ignoreColumnTypes==false) {
0: 			 tempStr=tempStr+fieldSeparator+
0: 		 		 fieldStartDelimiter+columnTypes[i]+fieldStopDelimiter;
0: 		 }
0: 
0:          aStream.write(tempStr, 0, tempStr.length());
0:        }
0:        aStream.write(recordSeparator, 0, recordSeparator.length());
0:     }
0:   }
0: 
0:   //puts the start and stop delimiters only if column value contains field/record separator
0:   //in it
0:   private void writeNextColumn(String oneColumn, boolean isNumeric) throws Exception {
0:     if (oneColumn != null) {
0:        //put the start and end delimiters always
0:        //because of the bug 2045, I broke down following
0:        //aStream.writeBytes(fieldStartDelimiter+oneColumn+fieldStopDelimiter);
0:        //into 3 writeBytes. That bug had a table with long bit varying datatype and while
0:        //writing data from that column using the stream, it would run out of memory.
0: 	   // i18n - write using the write method of OutputStreamWriter
0:        if (!isNumeric)
0: 		   aStream.write(fieldStartDelimiter, 0, fieldStartDelimiter.length());
0: 	   //convert the string to double character delimiters format if requred.
0: 	   if(doubleDelimiter)
0: 		   oneColumn = makeDoubleDelimiterString(oneColumn , fieldStartDelimiter);
0: 	   aStream.write(oneColumn, 0, oneColumn.length());
0:        if (!isNumeric)
0:          aStream.write(fieldStopDelimiter, 0, fieldStopDelimiter.length());
0:     }
0:   }
0: 
0:   /**write the passed row into the data file
0:  	* @exception	Exception if there is an error
0: 	*/
0:   public void writeData(String[] oneRow, boolean[] isNumeric) throws Exception {
0:     if (format.equals(ControlInfo.DEFAULT_FORMAT)) {
0:        //if format is delimited, write column data and field separator and then the record separator
0:        //if a column's value is null, write just the column separator
0:        writeNextColumn(oneRow[0], isNumeric[0]);
0:        for (int i = 1; i < oneRow.length; i++) {
0:          aStream.write(fieldSeparator, 0, fieldSeparator.length());
0:          writeNextColumn(oneRow[i], isNumeric[i]);
0:        }
0:        if (hasDelimiterAtEnd){ //write an additional delimeter if user wants one at the end of each row
0:           aStream.write(fieldSeparator, 0, fieldSeparator.length());
0:        }
0:     }
0:     aStream.write(recordSeparator, 0, recordSeparator.length());
0:   }
0: 
0:   /**if nothing more to write, then close the file and write a message of completion
0:   *  in message file
0:  	*@exception	Exception if there is an error
0: 	*/
0:   public void noMoreRows() throws IOException {
0:     aStream.flush();
0:     aStream.close();
0: //    System.err.print(new Date(System.currentTimeMillis()) + " ");
0: //    System.err.println("Export finished");
0: //    System.setErr(System.out);
0:   }
0: 
0: 
0: 	/*
0: 	 * Convert the input string into double delimiter format for export.
0: 	 * double character delimiter recognition in delimited format
0: 	 * files applies to the export and import utilities. Character delimiters are
0: 	 * permitted within the character-based fields of a file. This applies to
0: 	 * fields of type CHAR, VARCHAR, LONGVARCHAR, or CLOB. Any pair of character
0: 	 * delimiters found between the enclosing character delimiters is imported
0: 	 * into the database. For example with doble quote(") as character delimiter
0: 	 *
0: 	 *	 "What a ""nice""day!"
0: 	 *
0: 	 *  will be imported as:
0: 	 *
0: 	 *	 What a "nice"day!
0: 	 *
0: 	 *	 In the case of export, the rule applies in reverse. For example,
0: 	 *
0: 	 *	 I am 6"tall.
0: 	 *
0: 	 *	 will be exported to a file as:
0: 	 *
0: 	 *	 "I am 6""tall."
0: 
0:  	 */
0: 	private String makeDoubleDelimiterString(String inputString , String charDelimiter)
0: 	{
0: 		int start = inputString.indexOf(charDelimiter);
0: 		StringBuffer result;
0: 		//if delimeter is not found inside the string nothing to do
0: 		if(start != -1)
0: 		{
0: 			result = new StringBuffer(inputString);
0: 			int current;
0: 			int delLength = charDelimiter.length();
0: 			while(start!= -1)
0: 			{
0: 				//insert delimter character 
0: 				result = result.insert(start, charDelimiter);
0: 				current = start + delLength +1 ;
0: 				start = result.toString().indexOf(charDelimiter, current);
0: 			}
0: 			return result.toString();
0: 		}
0: 		return inputString;
0: 	}
0: }
0: 
============================================================================