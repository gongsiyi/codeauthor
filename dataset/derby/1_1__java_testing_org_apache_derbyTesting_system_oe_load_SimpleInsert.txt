1:6e8ab1f: /*
3:6e8ab1f:  *
1:6e8ab1f:  * Derby - Class org.apache.derbyTesting.system.oe.load.SimpleInsert
1:6e8ab1f:  *
1:6e8ab1f:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:6e8ab1f:  * contributor license agreements.  See the NOTICE file distributed with
1:6e8ab1f:  * this work for additional information regarding copyright ownership.
1:6e8ab1f:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:6e8ab1f:  * (the "License"); you may not use this file except in compliance with
1:6e8ab1f:  * the License.  You may obtain a copy of the License at
1:6e8ab1f:  *
1:6e8ab1f:  *    http://www.apache.org/licenses/LICENSE-2.0
1:6e8ab1f:  *
1:6e8ab1f:  * Unless required by applicable law or agreed to in writing, 
1:6e8ab1f:  * software distributed under the License is distributed on an 
1:6e8ab1f:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:6e8ab1f:  * either express or implied. See the License for the specific 
1:6e8ab1f:  * language governing permissions and limitations under the License.
4:6e8ab1f:  */
1:6e8ab1f: package org.apache.derbyTesting.system.oe.load;
7:6e8ab1f: 
1:6e8ab1f: import java.sql.*;
1:6e8ab1f: 
1:6e8ab1f: import org.apache.derbyTesting.system.oe.client.Load;
1:6e8ab1f: import org.apache.derbyTesting.system.oe.util.OERandom;
1:6e8ab1f: 
4:6e8ab1f: /**
1:6e8ab1f:  * Implement the initial database population according to the TPC-C database
1:6e8ab1f:  * population requirements in Clause 4.3 using simple Insert sql statements
1:6e8ab1f:  */
1:6e8ab1f: public class SimpleInsert implements Load {
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * database connection
1:6e8ab1f:      */
1:6e8ab1f:     Connection conn = null;
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * warehouse scale factor, default to 1.
1:6e8ab1f:      */
1:6e8ab1f:     short scale = 1;
1:9f7e882:     
1:9f7e882:     /**
1:9f7e882:      * Seed value for random number generator.
1:9f7e882:      */
1:fbc46af:     long seed = System.currentTimeMillis();
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * Utility to generate random data per the TPC-C requirements
1:6e8ab1f:      */
1:6e8ab1f:     OERandom random;
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * Perform the necessary setup before database population.
1:6e8ab1f:      * 
1:6e8ab1f:      * @param conn -
1:6e8ab1f:      *            database connection
1:6e8ab1f:      * @param scale -
1:6e8ab1f:      *            scale of the database. The WAREHOUSE table is used as the base
1:6e8ab1f:      *            unit of scaling.
1:6e8ab1f:      * @throws Exception
1:6e8ab1f:      */
1:6e8ab1f:     public void setupLoad(Connection conn, short scale) throws SQLException {
1:7a0c00a: 
1:fbc46af:         setupConnection(conn, scale);
1:7a0c00a: 
1:6e8ab1f:         Statement s = conn.createStatement();
1:6e8ab1f:         try {
1:6e8ab1f:             s.execute("DROP TABLE C");
1:6e8ab1f:         } catch (SQLException sqle) {
1:6e8ab1f:             // ignore
5:6e8ab1f:         }
2:6e8ab1f:         conn.commit();
1:76c452e:         s.execute("CREATE TABLE C(CLOAD INT)");
1:6e8ab1f:         conn.commit();
1:6e8ab1f: 
1:76c452e:         random = new OERandom(-1, seed);
1:6e8ab1f: 
1:6e8ab1f:         // Section 2.1.6.1 of TPC-C spec
1:6e8ab1f:         int loadRandomFactor = random.randomInt(0, 255);
1:76c452e:         s.execute("INSERT INTO C VALUES(" + loadRandomFactor + ")");
1:fbc46af:         s.close();
1:fbc46af:         conn.commit();  
1:fbc46af:         
1:fbc46af:         setRandomGenerator();
1:fbc46af:     }
1:fbc46af:     
1:fbc46af:     /**
1:fbc46af:      * Set the connection up to the intended state.
1:fbc46af:      * Intended for use by sub-classes.
1:fbc46af:      */
1:fbc46af:     void setupConnection(Connection conn, short scale) throws SQLException
1:fbc46af:     {
1:fbc46af:         this.conn = conn;
1:fbc46af:         conn.setAutoCommit(false);
1:fbc46af:         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:6e8ab1f:         this.scale = scale;
1:6e8ab1f:     }
1:fbc46af:     
1:fbc46af:     /**
1:fbc46af:      * Setup the random number generator to be used for the load.
1:fbc46af:      * @throws SQLException
1:fbc46af:      */
1:fbc46af:     void setRandomGenerator() throws SQLException
1:fbc46af:     {
1:fbc46af:         Statement s = conn.createStatement();
1:fbc46af:         ResultSet rs = s.executeQuery("SELECT CLOAD FROM C");
1:fbc46af:         rs.next();
1:fbc46af:         int loadRandomFactor = rs.getInt(1);
1:fbc46af:         rs.close();
1:76c452e:         random = new OERandom(loadRandomFactor, seed);
1:fbc46af:         s.close();
1:fbc46af:         conn.commit();
1:fbc46af:     }
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * Follow the initial database population requirements in Section 4.3.3 and
1:6e8ab1f:      * populate all the required tables.
1:6e8ab1f:      * 
2:6e8ab1f:      * @throws SQLException
1:6e8ab1f:      */
1:fbc46af:     public void populateAllTables() throws Exception {
1:6e8ab1f:         // load item table
1:6e8ab1f:         itemTable(1, Load.ITEM_COUNT);
1:6e8ab1f: 
1:7a0c00a:         for (short w = 1; w <= scale; w++) {
1:fbc46af:             populateForOneWarehouse(w);
1:6e8ab1f:         }
1:fbc46af: 
1:6e8ab1f:     }
1:6e8ab1f:     
1:fbc46af:     /**
1:fbc46af:      * Populate all the tables needed for a specific warehouse.
1:fbc46af:      * for each row in warehouse table, load the stock,
1:fbc46af:      * district table. For each row in district table, load
1:fbc46af:      * the customer table. for each row in customer table, load
1:fbc46af:      * the customer table. for each row in customer table, load
1:fbc46af:      * @param w Warehouse to be populated.
1:fbc46af:      * @throws SQLException
1:fbc46af:      */
1:fbc46af:     void populateForOneWarehouse(short w) throws SQLException
1:fbc46af:     {
1:fbc46af:         warehouseTable(w);
1:fbc46af:         // for each warehouse: load the stock table
1:fbc46af:         stockTable(1, Load.STOCK_COUNT_W, w);
1:fbc46af:         for (short d = 1; d <= Load.DISTRICT_COUNT_W; d++) {
1:fbc46af:             districtTable(w, d);
1:fbc46af:             customerTable(w, d);
1:fbc46af:             orderTable(w, d);
1:fbc46af:         }
1:fbc46af:     }
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * Populate the ITEM table. See population requirements in section 4.3.3.1
1:6e8ab1f:      * <BR>
1:6e8ab1f:      * 
1:6e8ab1f:      * @param itemStart
1:6e8ab1f:      *            insert item information starting from this Item id (ITEM.I_ID)
1:6e8ab1f:      * @param itemEnd
1:6e8ab1f:      *            last Item id (ITEM.I_ID) for inserting information for
1:6e8ab1f:      * @throws SQLException
1:6e8ab1f:      */
1:6e8ab1f:     public void itemTable(int itemStart, int itemEnd) throws SQLException {
1:6e8ab1f:         PreparedStatement ps = conn
1:6e8ab1f:                 .prepareStatement("INSERT INTO ITEM(I_ID,I_IM_ID,I_NAME,I_PRICE,I_DATA)"
1:6e8ab1f:                         + " VALUES (?, ?, ?, ?, ?)");
1:6e8ab1f: 
1:6e8ab1f:         String price;
1:6e8ab1f: 
1:6e8ab1f:         for (int i = itemStart; i <= itemEnd; i++) {
1:6e8ab1f:             ps.setInt(1, i);
1:6e8ab1f:             ps.setInt(2, random.randomInt(1, 10000));
1:6e8ab1f:             ps.setString(3, random.randomAString14_24());
1:6e8ab1f:             price = random.randomDecimalString(100, 9999, 2);
1:6e8ab1f:             ps.setString(4, price);
1:6e8ab1f:             ps.setString(5, random.randomData());
1:6e8ab1f:             ps.executeUpdate();
1:6e8ab1f: 
1:6e8ab1f:             if ((i % (1000)) == 0) {
1:6e8ab1f:                 conn.commit();
1:6e8ab1f:             }
1:6e8ab1f:         }
1:6e8ab1f:         conn.commit();
1:6e8ab1f:         ps.close();
1:6e8ab1f:     }
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * Populate the WAREHOUSE table for a given warehouse. See population
1:6e8ab1f:      * requirements in section 4.3.3.1
1:6e8ab1f:      * 
1:6e8ab1f:      * @param w
1:6e8ab1f:      *            WAREHOUSE ID (W_ID) to insert data for.
1:6e8ab1f:      * @throws SQLException
1:6e8ab1f:      */
1:6e8ab1f:     public void warehouseTable(short w) throws SQLException {
1:6e8ab1f:         PreparedStatement ps = conn.prepareStatement("INSERT INTO WAREHOUSE "
1:6e8ab1f:                 + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, 300000.00)");
1:6e8ab1f: 
1:6e8ab1f:         ps.setShort(1, w);
1:6e8ab1f:         ps.setString(2, random.randomAString(6, 10));
1:6e8ab1f:         ps.setString(3, random.randomAString10_20());
1:6e8ab1f:         ps.setString(4, random.randomAString10_20());
1:6e8ab1f:         ps.setString(5, random.randomAString10_20());
1:6e8ab1f:         ps.setString(6, random.randomState());
1:6e8ab1f:         ps.setString(7, random.randomZIP());
1:6e8ab1f:         ps.setString(8, random.randomDecimalString(0, 2000, 4));
1:6e8ab1f: 
1:6e8ab1f:         ps.executeUpdate();
1:6e8ab1f:         conn.commit();
1:6e8ab1f:         ps.close();
1:6e8ab1f:     }
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * Populate the STOCK table for a given warehouse. See population
1:6e8ab1f:      * requirements in section 4.3.3.1 <BR>
1:6e8ab1f:      * 
1:6e8ab1f:      * @param itemStart
1:6e8ab1f:      *            insert stocks of items from this Item id (ITEM.I_ID)
1:6e8ab1f:      * @param itemEnd
1:6e8ab1f:      *            last Item id (ITEM.I_ID) to insert stocks of times for.
1:6e8ab1f:      * @param w
1:6e8ab1f:      *            WAREHOUSE id (W_ID) for which the stock is populated.
1:6e8ab1f:      * @throws SQLException
1:6e8ab1f:      */
1:6e8ab1f:     public void stockTable(int itemStart, int itemEnd, short w)
1:6e8ab1f:             throws SQLException {
1:6e8ab1f:         PreparedStatement ps = conn.prepareStatement("INSERT INTO STOCK "
1:6e8ab1f:                 + "(S_I_ID, S_W_ID, S_QUANTITY,S_DIST_01, S_DIST_02,"
1:6e8ab1f:                 + " S_DIST_03,S_DIST_04,S_DIST_05,"
1:6e8ab1f:                 + "S_DIST_06,S_DIST_07,S_DIST_08,S_DIST_09,S_DIST_10,"
1:6e8ab1f:                 + "S_ORDER_CNT, S_REMOTE_CNT, S_YTD, S_DATA ) VALUES "
1:6e8ab1f:                 + "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, 0, 0, ?)");
1:6e8ab1f: 
1:6e8ab1f:         ps.setShort(2, w);
1:6e8ab1f: 
1:6e8ab1f:         for (int i = itemStart; i <= itemEnd; i++) {
1:6e8ab1f:             ps.setInt(1, i);
1:6e8ab1f:             ps.setInt(3, random.randomInt(10, 100));
1:6e8ab1f:             ps.setString(4, random.randomAString24());
1:6e8ab1f:             ps.setString(5, random.randomAString24());
1:6e8ab1f:             ps.setString(6, random.randomAString24());
1:6e8ab1f:             ps.setString(7, random.randomAString24());
1:6e8ab1f:             ps.setString(8, random.randomAString24());
1:6e8ab1f:             ps.setString(9, random.randomAString24());
1:6e8ab1f:             ps.setString(10, random.randomAString24());
1:6e8ab1f:             ps.setString(11, random.randomAString24());
1:6e8ab1f:             ps.setString(12, random.randomAString24());
1:6e8ab1f:             ps.setString(13, random.randomAString24());
1:6e8ab1f: 
1:6e8ab1f:             ps.setString(14, random.randomData());
1:6e8ab1f:             ps.executeUpdate();
1:6e8ab1f: 
1:6e8ab1f:             if ((i % 1000) == 0) {
1:6e8ab1f:                 conn.commit();
1:6e8ab1f:             }
1:6e8ab1f:         }
1:6e8ab1f:         conn.commit();
1:6e8ab1f:         ps.close();
1:6e8ab1f:     }
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * Populate the DISTRICT table for a given warehouse. See population
1:6e8ab1f:      * requirements in section 4.3.3.1 <BR>
1:6e8ab1f:      * 
1:6e8ab1f:      * @param w -
1:6e8ab1f:      *            WAREHOUSE id (W_ID)
1:6e8ab1f:      * @param d -
1:6e8ab1f:      *            DISTRICT id (D_ID)
1:6e8ab1f:      * @throws SQLException
1:6e8ab1f:      */
1:6e8ab1f:     public void districtTable(short w, short d) throws SQLException {
1:6e8ab1f:         PreparedStatement ps = conn.prepareStatement("INSERT INTO DISTRICT"
1:6e8ab1f:                 + " (D_ID, D_W_ID, D_NAME, D_STREET_1, D_STREET_2,"
1:6e8ab1f:                 + " D_CITY, D_STATE, D_ZIP, D_TAX, D_YTD, D_NEXT_O_ID) "
1:6e8ab1f:                 + " VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, 30000.00, 3001)");
1:6e8ab1f: 
1:6e8ab1f:         ps.setShort(1, d);
1:6e8ab1f:         ps.setShort(2, w);
1:6e8ab1f:         ps.setString(3, random.randomAString(6, 10));
1:6e8ab1f:         ps.setString(4, random.randomAString10_20());
1:6e8ab1f:         ps.setString(5, random.randomAString10_20());
1:6e8ab1f:         ps.setString(6, random.randomAString10_20());
1:6e8ab1f:         ps.setString(7, random.randomState());
1:6e8ab1f:         ps.setString(8, random.randomZIP());
1:6e8ab1f:         ps.setString(9, random.randomDecimalString(0, 2000, 4));
1:6e8ab1f:         ps.executeUpdate();
1:6e8ab1f:         conn.commit();
1:6e8ab1f:         ps.close();
1:6e8ab1f: 
1:6e8ab1f:     }
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * Populate the CUSTOMER table for a given district for a specific
1:6e8ab1f:      * warehouse. See population requirements in section 4.3.3.1 <BR>
1:6e8ab1f:      * 
1:6e8ab1f:      * @param w -
1:6e8ab1f:      *            WAREHOUSE id (W_ID)
1:6e8ab1f:      * @param d -
1:6e8ab1f:      *            DISTRICT id (D_ID)
1:6e8ab1f:      * @throws SQLException
1:6e8ab1f:      */
1:6e8ab1f:     public void customerTable(short w, short d) throws SQLException {
1:6e8ab1f:         PreparedStatement psC = conn.prepareStatement("INSERT INTO CUSTOMER"
1:6e8ab1f:                 + " (C_ID, C_D_ID, C_W_ID, C_FIRST, C_MIDDLE, C_LAST,"
1:6e8ab1f:                 + " C_STREET_1, C_STREET_2,  C_CITY, C_STATE, C_ZIP, "
1:6e8ab1f:                 + "C_PHONE, C_SINCE, C_CREDIT, C_CREDIT_LIM,"
1:6e8ab1f:                 + " C_DISCOUNT, C_BALANCE, C_YTD_PAYMENT, "
1:6e8ab1f:                 + "C_PAYMENT_CNT, C_DELIVERY_CNT, C_DATA)  "
1:6e8ab1f:                 + "VALUES (?, ?, ?, ?, 'OE', ?, ?, ?, ?, ?, ?, ?, "
1:6e8ab1f:                 + " CURRENT TIMESTAMP ,?, 50000.00, ?, -10.0, 10.0,"
1:6e8ab1f:                 + " 1, 0, ?)");
1:6e8ab1f: 
1:6e8ab1f:         PreparedStatement psH = conn
1:6e8ab1f:                 .prepareStatement("INSERT INTO HISTORY (H_C_ID, H_C_D_ID, H_C_W_ID, H_D_ID, H_W_ID, H_DATE, H_AMOUNT, H_DATA) VALUES (?, ?, ?, ?, ?, CURRENT TIMESTAMP, 10.00, ?)");
1:6e8ab1f: 
1:6e8ab1f:         psC.setShort(2, d); // c_d_id
1:6e8ab1f:         psC.setShort(3, w); // c_w_id
1:6e8ab1f:         psH.setShort(2, d);
1:6e8ab1f:         psH.setShort(3, w);
1:6e8ab1f:         psH.setShort(4, d);
1:6e8ab1f:         psH.setShort(5, w);
1:6e8ab1f:         for (int c = 1; c <= Load.CUSTOMER_COUNT_W / Load.DISTRICT_COUNT_W; c++) {
1:6e8ab1f:             psC.setInt(1, c); // c_id
1:6e8ab1f:             psC.setString(4, random.randomAString8_16()); // c_first
1:6e8ab1f: 
1:6e8ab1f:             psC.setString(5, random.randomCLastPopulate(c)); // c_last
1:6e8ab1f:             psC.setString(6, random.randomAString10_20()); // c_street_1
1:6e8ab1f:             psC.setString(7, random.randomAString10_20()); // c_street_2
1:6e8ab1f:             psC.setString(8, random.randomAString10_20()); // c_city
1:6e8ab1f:             psC.setString(9, random.randomState()); // c_state
1:6e8ab1f:             psC.setString(10, random.randomZIP()); // c_zip
1:6e8ab1f:             psC.setString(11, random.randomNString(16, 16)); // c_phone
1:6e8ab1f: 
1:6e8ab1f:             psC.setString(12, Math.random() < 0.10 ? "BC" : "GC"); // c_credit
1:6e8ab1f: 
1:6e8ab1f:             psC.setString(13, random.randomDecimalString(0, 5000, 4)); // c_discount
1:6e8ab1f: 
1:6e8ab1f:             String str = random.randomAString300_500();
1:6e8ab1f:             if (str.length() > 255)
1:6e8ab1f:                 str = str.substring(255);
1:6e8ab1f:             psC.setString(14, str); // c_data
1:6e8ab1f: 
1:6e8ab1f:             psC.executeUpdate();
1:6e8ab1f: 
1:6e8ab1f:             psH.setInt(1, c);
1:6e8ab1f:             psH.setString(6, random.randomAString(12, 24));
1:6e8ab1f:             psH.executeUpdate();
1:6e8ab1f: 
1:6e8ab1f:             if ((c % 1000) == 0) {
1:6e8ab1f:                 conn.commit();
1:6e8ab1f:             }
1:6e8ab1f: 
1:6e8ab1f:         }
1:6e8ab1f:         conn.commit();
1:6e8ab1f: 
1:6e8ab1f:         psC.close();
1:6e8ab1f:         psH.close();
1:6e8ab1f:     }
1:6e8ab1f: 
1:6e8ab1f:     /**
1:6e8ab1f:      * Populate the ORDER table See population requirements in section 4.3.3.1
1:6e8ab1f:      * 
1:6e8ab1f:      * @param w -
1:6e8ab1f:      *            WAREHOUSE id (W_ID)
1:6e8ab1f:      * @param d -
1:6e8ab1f:      *            DISTRICT id (D_ID)
1:6e8ab1f:      * @throws SQLException
1:6e8ab1f:      */
1:6e8ab1f:     public void orderTable(short w, short d) throws SQLException {
1:6e8ab1f: 
1:6e8ab1f:         PreparedStatement psO = conn
1:6e8ab1f:                 .prepareStatement("INSERT INTO ORDERS (O_ID, O_D_ID, O_W_ID, O_C_ID, O_ENTRY_D, O_CARRIER_ID, O_OL_CNT, O_ALL_LOCAL) VALUES (?, ?, ?, ?, ?, ?, ?, 1)");
1:6e8ab1f: 
1:6e8ab1f:         PreparedStatement psOL = conn
1:6e8ab1f:                 .prepareStatement("INSERT INTO ORDERLINE (OL_O_ID, OL_D_ID, OL_W_ID, OL_NUMBER, OL_I_ID, OL_SUPPLY_W_ID, OL_DELIVERY_D, OL_QUANTITY, OL_AMOUNT, OL_DIST_INFO)  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1:6e8ab1f: 
1:6e8ab1f:         PreparedStatement psNO = conn
1:6e8ab1f:                 .prepareStatement("INSERT INTO NEWORDERS (NO_O_ID, NO_D_ID, NO_W_ID) VALUES (?, ?, ?)");
1:6e8ab1f: 
1:6e8ab1f:         psO.setShort(2, d);
1:6e8ab1f:         psO.setShort(3, w);
1:6e8ab1f:         
1:6e8ab1f:         // Section 4.3.3.1 of TPC-C specification revision 5.8.0
1:6e8ab1f:         // O_C_ID selected sequentially from a random permutation 
1:6e8ab1f:         // of [1 .. 3,000]
1:6e8ab1f:         int[] cid = random.randomIntPerm(Load.CUSTOMER_COUNT_W
1:6e8ab1f:                 / Load.DISTRICT_COUNT_W);
1:6e8ab1f:         
1:7a0c00a:         for (int o_id = 1; o_id <= cid.length; o_id++) {
1:6e8ab1f:             psO.setInt(1, o_id);
1:7a0c00a:             psO.setInt(4, cid[o_id-1]);
1:6e8ab1f: 
1:6e8ab1f:             Timestamp o_entry_d = new Timestamp(System.currentTimeMillis());
1:6e8ab1f: 
1:6e8ab1f:             psO.setTimestamp(5, o_entry_d);
1:6e8ab1f: 
1:7a0c00a:             if (o_id <= Load.NEWORDERS_BREAKPOINT)
1:6e8ab1f:                 psO.setShort(6, (short) random.randomInt(1, 10));
1:6e8ab1f:             else
1:6e8ab1f:                 psO.setNull(6, Types.SMALLINT);
1:6e8ab1f: 
1:6e8ab1f:             int o_ol_cnt = random.randomInt(5, 15);
1:6e8ab1f:             psO.setInt(7, o_ol_cnt);
1:6e8ab1f: 
1:6e8ab1f:             psO.executeUpdate();
1:6e8ab1f: 
1:6e8ab1f:             psOL.setShort(2, d);
1:6e8ab1f:             psOL.setShort(3, w);
1:6e8ab1f:             psNO.setShort(2, d);
1:6e8ab1f:             psNO.setShort(3, w);
1:7a0c00a:             for (int ol_number = 1; ol_number <= o_ol_cnt; ol_number++) {
1:6e8ab1f: 
1:6e8ab1f:                 psOL.setInt(1, o_id);
1:6e8ab1f:                 psOL.setInt(4, ol_number);
1:6e8ab1f: 
1:6e8ab1f:                 // OL_I_ID random within [1 .. 100,000]
1:6e8ab1f:                 psOL.setInt(5, random.randomInt(1, Load.ITEM_COUNT));
1:6e8ab1f:                 psOL.setShort(6, w);
1:7a0c00a:                 if (o_id <= Load.NEWORDERS_BREAKPOINT) {
1:6e8ab1f:                     psOL.setTimestamp(7, o_entry_d);
1:6e8ab1f:                     psOL.setString(9, "0.00");
1:6e8ab1f:                 } else {
1:6e8ab1f:                     psOL.setNull(7, Types.TIMESTAMP);
1:6e8ab1f:                     psOL.setString(9, random.randomDecimalString(1, 999999, 2));
1:6e8ab1f:                 }
1:6e8ab1f:                 psOL.setInt(8, 5);
1:6e8ab1f:                 psOL.setString(10, random.randomAString24());
1:6e8ab1f:                 psOL.executeUpdate();
1:6e8ab1f:             }
1:7a0c00a:             if (o_id > Load.NEWORDERS_BREAKPOINT) {
1:6e8ab1f:                 psNO.setInt(1, o_id);
1:6e8ab1f:                 psNO.executeUpdate();
1:6e8ab1f:             }
1:6e8ab1f:             if ((o_id % 1000) == 0) {
1:6e8ab1f:                 conn.commit();
1:6e8ab1f:             }
1:6e8ab1f: 
1:6e8ab1f:         }
1:6e8ab1f:         conn.commit();
1:6e8ab1f: 
1:6e8ab1f:         psOL.close();
1:6e8ab1f:         psO.close();
1:6e8ab1f:         psNO.close();
1:6e8ab1f:     }
1:6e8ab1f: 
1:9f7e882:     public void setSeed(long seed) {
1:9f7e882:         this.seed = seed;
1:9f7e882:     }
1:9f7e882: 
1:fbc46af:     /**
1:fbc46af:      * Ignore, this is a single threaded load.
1:fbc46af:      */
1:fbc46af:     public void setThreadCount(int threadCount) {
1:fbc46af:     }
1:fbc46af: 
1:6e8ab1f: }
============================================================================
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:76c452e
/////////////////////////////////////////////////////////////////////////
1:         s.execute("CREATE TABLE C(CLOAD INT)");
1:         random = new OERandom(-1, seed);
1:         s.execute("INSERT INTO C VALUES(" + loadRandomFactor + ")");
/////////////////////////////////////////////////////////////////////////
1:         random = new OERandom(loadRandomFactor, seed);
commit:fbc46af
/////////////////////////////////////////////////////////////////////////
1:     long seed = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
1:         setupConnection(conn, scale);
/////////////////////////////////////////////////////////////////////////
1:         s.close();
1:         conn.commit();  
1:         
1:         setRandomGenerator();
1:     }
1:     
1:     /**
1:      * Set the connection up to the intended state.
1:      * Intended for use by sub-classes.
1:      */
1:     void setupConnection(Connection conn, short scale) throws SQLException
1:     {
1:         this.conn = conn;
1:         conn.setAutoCommit(false);
1:         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1:     
1:     /**
1:      * Setup the random number generator to be used for the load.
1:      * @throws SQLException
1:      */
1:     void setRandomGenerator() throws SQLException
1:     {
1:         Statement s = conn.createStatement();
1:         ResultSet rs = s.executeQuery("SELECT CLOAD FROM C");
1:         rs.next();
1:         int loadRandomFactor = rs.getInt(1);
1:         rs.close();
0:         random = new OERandom(loadRandomFactor, -1, -1, seed);
1:         s.close();
1:         conn.commit();
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public void populateAllTables() throws Exception {
1:             populateForOneWarehouse(w);
1:     
1:     /**
1:      * Populate all the tables needed for a specific warehouse.
1:      * for each row in warehouse table, load the stock,
1:      * district table. For each row in district table, load
1:      * the customer table. for each row in customer table, load
1:      * the customer table. for each row in customer table, load
1:      * @param w Warehouse to be populated.
1:      * @throws SQLException
1:      */
1:     void populateForOneWarehouse(short w) throws SQLException
1:     {
1:         warehouseTable(w);
1:         // for each warehouse: load the stock table
1:         stockTable(1, Load.STOCK_COUNT_W, w);
1:         for (short d = 1; d <= Load.DISTRICT_COUNT_W; d++) {
1:             districtTable(w, d);
1:             customerTable(w, d);
1:             orderTable(w, d);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Ignore, this is a single threaded load.
1:      */
1:     public void setThreadCount(int threadCount) {
1:     }
1: 
commit:9f7e882
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Seed value for random number generator.
1:      */
0:     private long seed = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
0:         random = new OERandom(-1, -1, -1, seed);
0:         random = new OERandom(loadRandomFactor, -1, -1, seed);
/////////////////////////////////////////////////////////////////////////
1:     public void setSeed(long seed) {
1:         this.seed = seed;
1:     }
1: 
commit:7a0c00a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:         this.conn = conn;
0:         conn.setAutoCommit(false);
0:         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
1: 
/////////////////////////////////////////////////////////////////////////
1:         for (short w = 1; w <= scale; w++) {
0:             for (short d = 1; d <= Load.DISTRICT_COUNT_W; d++) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         for (int o_id = 1; o_id <= cid.length; o_id++) {
1:             psO.setInt(4, cid[o_id-1]);
1:             if (o_id <= Load.NEWORDERS_BREAKPOINT)
/////////////////////////////////////////////////////////////////////////
1:             for (int ol_number = 1; ol_number <= o_ol_cnt; ol_number++) {
/////////////////////////////////////////////////////////////////////////
1:                 if (o_id <= Load.NEWORDERS_BREAKPOINT) {
/////////////////////////////////////////////////////////////////////////
1:             if (o_id > Load.NEWORDERS_BREAKPOINT) {
commit:6e8ab1f
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.system.oe.load.SimpleInsert
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.system.oe.load;
1: 
1: import java.sql.*;
1: 
1: import org.apache.derbyTesting.system.oe.client.Load;
1: import org.apache.derbyTesting.system.oe.util.OERandom;
1: 
1: /**
1:  * Implement the initial database population according to the TPC-C database
1:  * population requirements in Clause 4.3 using simple Insert sql statements
1:  */
1: public class SimpleInsert implements Load {
1: 
1:     /**
1:      * database connection
1:      */
1:     Connection conn = null;
1: 
1:     /**
1:      * warehouse scale factor, default to 1.
1:      */
1:     short scale = 1;
1: 
1:     /**
1:      * Utility to generate random data per the TPC-C requirements
1:      */
1:     OERandom random;
1: 
1:     /**
0:      * Create an instance of this implementation. Connection will be set to non
0:      * auto commit mode and SERIALIZABLE isolation.
1:      */
0:     public SimpleInsert(Connection conn, short scale) throws SQLException {
0:         this.conn = conn;
0:         conn.setAutoCommit(false);
0:         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
0:         setupLoad(conn, scale);
1:     }
1: 
1:     /**
0:      * return the warehouse scale factor
1:      * 
0:      * @see org.apache.derbyTesting.system.oe.client.Load#getScale()
1:      */
0:     public short getScale() {
0:         return scale;
1:     }
1: 
1:     /**
1:      * Perform the necessary setup before database population.
1:      * 
1:      * @param conn -
1:      *            database connection
1:      * @param scale -
1:      *            scale of the database. The WAREHOUSE table is used as the base
1:      *            unit of scaling.
1:      * @throws Exception
1:      */
1:     public void setupLoad(Connection conn, short scale) throws SQLException {
1:         Statement s = conn.createStatement();
1:         try {
1:             s.execute("DROP TABLE C");
1:         } catch (SQLException sqle) {
1:             // ignore
1:         }
1:         conn.commit();
0:         s.execute("CREATE TABLE C(CLOAD INT, CLAST INT, CID INT, CITEM INT)");
1:         conn.commit();
1: 
0:         random = new OERandom(-1, -1, -1);
1: 
1:         // Section 2.1.6.1 of TPC-C spec
1:         int loadRandomFactor = random.randomInt(0, 255);
0:         s.execute("INSERT INTO C VALUES(" + loadRandomFactor + ", -1, -1, -1)");
0:         random = new OERandom(loadRandomFactor, -1, -1);
1:         conn.commit();
1: 
1:         this.scale = scale;
1:     }
1: 
1:     /**
1:      * Follow the initial database population requirements in Section 4.3.3 and
1:      * populate all the required tables.
1:      * 
1:      * @throws SQLException
1:      */
0:     public void populateAllTables() throws SQLException {
1:         // load item table
1:         itemTable(1, Load.ITEM_COUNT);
1: 
0:         // for each row in warehouse table, load the stock,
0:         // district table. For each row in district table, load
0:         // the customer table. for each row in customer table, load
0:         // the history, and order table.
1: 
0:         for (short w = 0; w < scale; w++) {
0:             warehouseTable(w);
0:             // for each warehouse: load the stock table
0:             stockTable(1, Load.STOCK_COUNT_W, w);
0:             for (short d = 0; d < Load.DISTRICT_COUNT_W; d++) {
0:                 districtTable(w, d);
0:                 customerTable(w, d);
0:                 orderTable(w, d);
1:             }
1:         }
1: 
1:     }
1: 
1:     /**
0:      * Return the number of rows in the table. A simple select count(*) from
0:      * tableName
1:      * 
0:      * @param tableName -
0:      *            name of the table
1:      * @throws SQLException
1:      */
0:     public int rowsInTable(String table) throws SQLException {
0:         Statement stmt = conn.createStatement();
0:         ResultSet rs = stmt.executeQuery("SELECT COUNT(*) FROM " + table);
0:         rs.next();
0:         int count = rs.getInt(1);
0:         rs.close();
0:         stmt.close();
1: 
0:         return count;
1:     }
1: 
1:     /**
1:      * Populate the ITEM table. See population requirements in section 4.3.3.1
1:      * <BR>
1:      * 
1:      * @param itemStart
1:      *            insert item information starting from this Item id (ITEM.I_ID)
1:      * @param itemEnd
1:      *            last Item id (ITEM.I_ID) for inserting information for
1:      * @throws SQLException
1:      */
1:     public void itemTable(int itemStart, int itemEnd) throws SQLException {
1:         PreparedStatement ps = conn
1:                 .prepareStatement("INSERT INTO ITEM(I_ID,I_IM_ID,I_NAME,I_PRICE,I_DATA)"
1:                         + " VALUES (?, ?, ?, ?, ?)");
1: 
1:         String price;
1: 
1:         for (int i = itemStart; i <= itemEnd; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, random.randomInt(1, 10000));
1:             ps.setString(3, random.randomAString14_24());
1:             price = random.randomDecimalString(100, 9999, 2);
1:             ps.setString(4, price);
1:             ps.setString(5, random.randomData());
1:             ps.executeUpdate();
1: 
1:             if ((i % (1000)) == 0) {
1:                 conn.commit();
1:             }
1:         }
1:         conn.commit();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Populate the WAREHOUSE table for a given warehouse. See population
1:      * requirements in section 4.3.3.1
1:      * 
1:      * @param w
1:      *            WAREHOUSE ID (W_ID) to insert data for.
1:      * @throws SQLException
1:      */
1:     public void warehouseTable(short w) throws SQLException {
1:         PreparedStatement ps = conn.prepareStatement("INSERT INTO WAREHOUSE "
1:                 + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, 300000.00)");
1: 
1:         ps.setShort(1, w);
1:         ps.setString(2, random.randomAString(6, 10));
1:         ps.setString(3, random.randomAString10_20());
1:         ps.setString(4, random.randomAString10_20());
1:         ps.setString(5, random.randomAString10_20());
1:         ps.setString(6, random.randomState());
1:         ps.setString(7, random.randomZIP());
1:         ps.setString(8, random.randomDecimalString(0, 2000, 4));
1: 
1:         ps.executeUpdate();
1:         conn.commit();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Populate the STOCK table for a given warehouse. See population
1:      * requirements in section 4.3.3.1 <BR>
1:      * 
1:      * @param itemStart
1:      *            insert stocks of items from this Item id (ITEM.I_ID)
1:      * @param itemEnd
1:      *            last Item id (ITEM.I_ID) to insert stocks of times for.
1:      * @param w
1:      *            WAREHOUSE id (W_ID) for which the stock is populated.
1:      * @throws SQLException
1:      */
1:     public void stockTable(int itemStart, int itemEnd, short w)
1:             throws SQLException {
1:         PreparedStatement ps = conn.prepareStatement("INSERT INTO STOCK "
1:                 + "(S_I_ID, S_W_ID, S_QUANTITY,S_DIST_01, S_DIST_02,"
1:                 + " S_DIST_03,S_DIST_04,S_DIST_05,"
1:                 + "S_DIST_06,S_DIST_07,S_DIST_08,S_DIST_09,S_DIST_10,"
1:                 + "S_ORDER_CNT, S_REMOTE_CNT, S_YTD, S_DATA ) VALUES "
1:                 + "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, 0, 0, ?)");
1: 
1:         ps.setShort(2, w);
1: 
1:         for (int i = itemStart; i <= itemEnd; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(3, random.randomInt(10, 100));
1:             ps.setString(4, random.randomAString24());
1:             ps.setString(5, random.randomAString24());
1:             ps.setString(6, random.randomAString24());
1:             ps.setString(7, random.randomAString24());
1:             ps.setString(8, random.randomAString24());
1:             ps.setString(9, random.randomAString24());
1:             ps.setString(10, random.randomAString24());
1:             ps.setString(11, random.randomAString24());
1:             ps.setString(12, random.randomAString24());
1:             ps.setString(13, random.randomAString24());
1: 
1:             ps.setString(14, random.randomData());
1:             ps.executeUpdate();
1: 
1:             if ((i % 1000) == 0) {
1:                 conn.commit();
1:             }
1:         }
1:         conn.commit();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Populate the DISTRICT table for a given warehouse. See population
1:      * requirements in section 4.3.3.1 <BR>
1:      * 
1:      * @param w -
1:      *            WAREHOUSE id (W_ID)
1:      * @param d -
1:      *            DISTRICT id (D_ID)
1:      * @throws SQLException
1:      */
1:     public void districtTable(short w, short d) throws SQLException {
1:         PreparedStatement ps = conn.prepareStatement("INSERT INTO DISTRICT"
1:                 + " (D_ID, D_W_ID, D_NAME, D_STREET_1, D_STREET_2,"
1:                 + " D_CITY, D_STATE, D_ZIP, D_TAX, D_YTD, D_NEXT_O_ID) "
1:                 + " VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, 30000.00, 3001)");
1: 
1:         ps.setShort(1, d);
1:         ps.setShort(2, w);
1:         ps.setString(3, random.randomAString(6, 10));
1:         ps.setString(4, random.randomAString10_20());
1:         ps.setString(5, random.randomAString10_20());
1:         ps.setString(6, random.randomAString10_20());
1:         ps.setString(7, random.randomState());
1:         ps.setString(8, random.randomZIP());
1:         ps.setString(9, random.randomDecimalString(0, 2000, 4));
1:         ps.executeUpdate();
1:         conn.commit();
1:         ps.close();
1: 
1:     }
1: 
1:     /**
1:      * Populate the CUSTOMER table for a given district for a specific
1:      * warehouse. See population requirements in section 4.3.3.1 <BR>
1:      * 
1:      * @param w -
1:      *            WAREHOUSE id (W_ID)
1:      * @param d -
1:      *            DISTRICT id (D_ID)
1:      * @throws SQLException
1:      */
1:     public void customerTable(short w, short d) throws SQLException {
1:         PreparedStatement psC = conn.prepareStatement("INSERT INTO CUSTOMER"
1:                 + " (C_ID, C_D_ID, C_W_ID, C_FIRST, C_MIDDLE, C_LAST,"
1:                 + " C_STREET_1, C_STREET_2,  C_CITY, C_STATE, C_ZIP, "
1:                 + "C_PHONE, C_SINCE, C_CREDIT, C_CREDIT_LIM,"
1:                 + " C_DISCOUNT, C_BALANCE, C_YTD_PAYMENT, "
1:                 + "C_PAYMENT_CNT, C_DELIVERY_CNT, C_DATA)  "
1:                 + "VALUES (?, ?, ?, ?, 'OE', ?, ?, ?, ?, ?, ?, ?, "
1:                 + " CURRENT TIMESTAMP ,?, 50000.00, ?, -10.0, 10.0,"
1:                 + " 1, 0, ?)");
1: 
1:         PreparedStatement psH = conn
1:                 .prepareStatement("INSERT INTO HISTORY (H_C_ID, H_C_D_ID, H_C_W_ID, H_D_ID, H_W_ID, H_DATE, H_AMOUNT, H_DATA) VALUES (?, ?, ?, ?, ?, CURRENT TIMESTAMP, 10.00, ?)");
1: 
1:         psC.setShort(2, d); // c_d_id
1:         psC.setShort(3, w); // c_w_id
1:         psH.setShort(2, d);
1:         psH.setShort(3, w);
1:         psH.setShort(4, d);
1:         psH.setShort(5, w);
1:         for (int c = 1; c <= Load.CUSTOMER_COUNT_W / Load.DISTRICT_COUNT_W; c++) {
1:             psC.setInt(1, c); // c_id
1:             psC.setString(4, random.randomAString8_16()); // c_first
1: 
1:             psC.setString(5, random.randomCLastPopulate(c)); // c_last
1:             psC.setString(6, random.randomAString10_20()); // c_street_1
1:             psC.setString(7, random.randomAString10_20()); // c_street_2
1:             psC.setString(8, random.randomAString10_20()); // c_city
1:             psC.setString(9, random.randomState()); // c_state
1:             psC.setString(10, random.randomZIP()); // c_zip
1:             psC.setString(11, random.randomNString(16, 16)); // c_phone
1: 
1:             psC.setString(12, Math.random() < 0.10 ? "BC" : "GC"); // c_credit
1: 
1:             psC.setString(13, random.randomDecimalString(0, 5000, 4)); // c_discount
1: 
1:             String str = random.randomAString300_500();
1:             if (str.length() > 255)
1:                 str = str.substring(255);
1:             psC.setString(14, str); // c_data
1: 
1:             psC.executeUpdate();
1: 
1:             psH.setInt(1, c);
1:             psH.setString(6, random.randomAString(12, 24));
1:             psH.executeUpdate();
1: 
1:             if ((c % 1000) == 0) {
1:                 conn.commit();
1:             }
1: 
1:         }
1:         conn.commit();
1: 
1:         psC.close();
1:         psH.close();
1:     }
1: 
1:     /**
1:      * Populate the ORDER table See population requirements in section 4.3.3.1
1:      * 
1:      * @param w -
1:      *            WAREHOUSE id (W_ID)
1:      * @param d -
1:      *            DISTRICT id (D_ID)
1:      * @throws SQLException
1:      */
1:     public void orderTable(short w, short d) throws SQLException {
1: 
1:         PreparedStatement psO = conn
1:                 .prepareStatement("INSERT INTO ORDERS (O_ID, O_D_ID, O_W_ID, O_C_ID, O_ENTRY_D, O_CARRIER_ID, O_OL_CNT, O_ALL_LOCAL) VALUES (?, ?, ?, ?, ?, ?, ?, 1)");
1: 
1:         PreparedStatement psOL = conn
1:                 .prepareStatement("INSERT INTO ORDERLINE (OL_O_ID, OL_D_ID, OL_W_ID, OL_NUMBER, OL_I_ID, OL_SUPPLY_W_ID, OL_DELIVERY_D, OL_QUANTITY, OL_AMOUNT, OL_DIST_INFO)  VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
1: 
1:         PreparedStatement psNO = conn
1:                 .prepareStatement("INSERT INTO NEWORDERS (NO_O_ID, NO_D_ID, NO_W_ID) VALUES (?, ?, ?)");
1: 
1:         psO.setShort(2, d);
1:         psO.setShort(3, w);
1:         
1:         // Section 4.3.3.1 of TPC-C specification revision 5.8.0
1:         // O_C_ID selected sequentially from a random permutation 
1:         // of [1 .. 3,000]
1:         int[] cid = random.randomIntPerm(Load.CUSTOMER_COUNT_W
1:                 / Load.DISTRICT_COUNT_W);
1:         
0:         for (int o_id = 0; o_id < cid.length; o_id++) {
1:             psO.setInt(1, o_id);
0:             psO.setInt(4, cid[o_id]);
1: 
1:             Timestamp o_entry_d = new Timestamp(System.currentTimeMillis());
1: 
1:             psO.setTimestamp(5, o_entry_d);
1: 
0:             if (o_id < Load.NEWORDERS_BREAKPOINT)
1:                 psO.setShort(6, (short) random.randomInt(1, 10));
1:             else
1:                 psO.setNull(6, Types.SMALLINT);
1: 
1:             int o_ol_cnt = random.randomInt(5, 15);
1:             psO.setInt(7, o_ol_cnt);
1: 
1:             psO.executeUpdate();
1: 
1:             psOL.setShort(2, d);
1:             psOL.setShort(3, w);
1:             psNO.setShort(2, d);
1:             psNO.setShort(3, w);
0:             for (int ol_number = 0; ol_number < o_ol_cnt; ol_number++) {
1: 
1:                 psOL.setInt(1, o_id);
1:                 psOL.setInt(4, ol_number);
1: 
1:                 // OL_I_ID random within [1 .. 100,000]
1:                 psOL.setInt(5, random.randomInt(1, Load.ITEM_COUNT));
1:                 psOL.setShort(6, w);
0:                 if (o_id < Load.NEWORDERS_BREAKPOINT) {
1:                     psOL.setTimestamp(7, o_entry_d);
1:                     psOL.setString(9, "0.00");
1:                 } else {
1:                     psOL.setNull(7, Types.TIMESTAMP);
1:                     psOL.setString(9, random.randomDecimalString(1, 999999, 2));
1:                 }
1:                 psOL.setInt(8, 5);
1:                 psOL.setString(10, random.randomAString24());
1:                 psOL.executeUpdate();
1:             }
0:             if (o_id >= Load.NEWORDERS_BREAKPOINT) {
1:                 psNO.setInt(1, o_id);
1:                 psNO.executeUpdate();
1:             }
1:             if ((o_id % 1000) == 0) {
1:                 conn.commit();
1:             }
1: 
1:         }
1:         conn.commit();
1: 
1:         psOL.close();
1:         psO.close();
1:         psNO.close();
1:     }
1: 
1: }
============================================================================