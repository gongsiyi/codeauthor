1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.sort.SortBuffer
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.sort;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369:   This class implements an in-memory ordered set
1:eac0369:   based on the balanced binary tree algorithm from
1:eac0369:   Knuth Vol. 3, Sec. 6.2.3, pp. 451-471.
1:eac0369:   Nodes are always maintained in order,
1:eac0369:   so that inserts and deletes can be intermixed.
1:eac0369:   <P>
1:eac0369:   This algorithm will insert/delete N elements
1:eac0369:   in O(N log(N)) time using O(N) space. 
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: class SortBuffer
1:eac0369: {
1:eac0369: 	/**
1:eac0369: 	Returned from insert when the row was inserted
1:eac0369: 	without incident.
1:eac0369: 	**/
1:eac0369: 	public static final int INSERT_OK = 0;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Returned from insert when the row which was
1:eac0369: 	inserted was a duplicate.  The set will have
1:eac0369: 	aggregated it in.
1:eac0369: 	**/
1:eac0369: 	public static final int INSERT_DUPLICATE = 1;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Returned from insert when the row was not able to be
1:eac0369: 	inserted because the set was full.
1:eac0369: 	**/
1:eac0369: 	public static final int INSERT_FULL = 2;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The sort this set is associated with.
1:eac0369: 	**/
1:eac0369: 	private MergeSort sort;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Where to allocate nodes from.
1:eac0369: 	**/
1:eac0369: 	private NodeAllocator allocator = null;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Special head node for the tree.  Head.rightLink is the
1:eac0369: 	root of the tree.
1:eac0369: 	**/
1:eac0369: 	private Node head = null;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The current height of the tree.
1:eac0369: 	**/
1:eac0369: 	private int height = 0;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Set, as a side effect of deleteLeftMost (only), to the
1:eac0369: 	key from the node that was deleted from the tree.  This
1:eac0369: 	field is only valid after a call to deleteLeftMost.
1:eac0369: 	**/
1:eac0369: 	private DataValueDescriptor[] deletedKey;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Set, as a side effect of deleteLeftMost and rotateRight,
1:eac0369: 	if the subtree they're working on decreased in height.
1:eac0369: 	This field is only valid after a call to deleteLeftMost
1:eac0369: 	or rotateRight.
1:eac0369: 	**/
1:eac0369: 	private boolean subtreeShrunk;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Set by the setNextAux() method.  This value is stuffed
1:eac0369: 	into the aux field of the next node that's allocated.
1:eac0369: 	**/
1:eac0369: 	private int nextAux;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Read by the getLastAux() method.  This value is read out
1:eac0369: 	of the last node that was deallocated from the tree.
1:eac0369: 	**/
1:eac0369: 	private int lastAux;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Arrange that the next node allocated in the tree have
1:eac0369: 	it's aux field set to the argument.
1:eac0369: 	**/
1:8417890: 	void setNextAux(int aux)
1:eac0369: 	{
1:eac0369: 		nextAux = aux;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Retrieve the aux value from the last node deallocated
1:eac0369: 	from the tree.
1:eac0369: 	**/
1:8417890: 	int getLastAux()
1:eac0369: 	{
1:eac0369: 		return lastAux;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Construct doesn't do anything, callers must call init
1:eac0369: 	and check its return code.
1:eac0369: 	**/
1:8417890: 	SortBuffer(MergeSort sort)
1:eac0369: 	{
1:eac0369: 		this.sort = sort;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Initialize.  Returns false if the allocator
1:eac0369: 	couldn't be initialized.
1:eac0369: 	**/
1:8417890: 	boolean init()
1:eac0369: 	{
1:eac0369: 		allocator = new NodeAllocator();
1:eac0369: 
1:eac0369: 		boolean initOK = false;
1:eac0369: 
1:eac0369: 		if (sort.sortBufferMin > 0)
1:eac0369: 			initOK = allocator.init(sort.sortBufferMin, sort.sortBufferMax);
1:eac0369: 		else
1:eac0369: 			initOK = allocator.init(sort.sortBufferMax);
1:eac0369: 
1:eac0369: 		if (initOK == false)
1:eac0369: 		{
1:eac0369: 			allocator = null;
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		reset();
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:8417890: 	void reset()
1:eac0369: 	{
1:eac0369: 		allocator.reset();
1:eac0369: 		head = allocator.newNode();
1:eac0369: 		height = 0;
1:eac0369: 	}
1:eac0369: 
1:8417890: 	void close()
1:eac0369: 	{
1:eac0369: 		if (allocator != null)
1:eac0369: 			allocator.close();
1:eac0369: 		allocator = null;
1:eac0369: 		height = 0;
1:eac0369: 		head = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Grow by a certain percent if we can
1:eac0369: 	*/
1:8417890: 	void grow(int percent)
1:eac0369: 	{
1:eac0369: 		if (percent > 0)
1:eac0369: 			allocator.grow(percent);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return the number of elements this sorter can sort.
1:eac0369: 	It's the capacity of the node allocator minus one
1:eac0369: 	because the sorter uses one node for the head.
1:eac0369: 	**/
1:8417890: 	int capacity()
1:eac0369: 	{
1:eac0369: 		if (allocator == null)
1:eac0369: 			return 0;
1:eac0369: 		return allocator.capacity() - 1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Insert a key k into the tree. Returns true if the
1:eac0369: 	key was inserted, false if the tree is full.  Silently
1:eac0369: 	ignores duplicate keys.
1:eac0369: 	<P>
1:eac0369: 	See Knuth Vol. 3, Sec. 6.2.3, pp. 455-457 for the algorithm.
1:eac0369: 	**/
1:8417890: 	int insert(DataValueDescriptor[] k)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		int c;
1:eac0369: 		Node p, q, r, s, t;
1:eac0369: 
1:eac0369: 		if (head.rightLink == null)
1:eac0369: 		{
1:eac0369: 			if ((sort.sortObserver != null) && 
1:eac0369: 				((k = sort.sortObserver.insertNonDuplicateKey(k)) == null))
1:eac0369: 			{
1:eac0369: 				return INSERT_DUPLICATE;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			q = allocator.newNode();
1:eac0369: 			q.key = k;
1:eac0369: 			q.aux = nextAux;
1:eac0369: 			head.rightLink = q;
1:eac0369: 			height = 1;
1:eac0369: 			return INSERT_OK;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// [A1. Initialize]
1:eac0369: 		t = head;
1:eac0369: 		p = s = head.rightLink;
1:eac0369: 
1:eac0369: 		// Search
1:eac0369: 		while (true)
1:eac0369: 		{
1:eac0369: 			// [A2. Compare]
1:eac0369: 			c = sort.compare(k, p.key);
1:eac0369: 			if (c == 0)
1:eac0369: 			{
1:eac0369: 				// The new key compares equal to the
1:eac0369: 				// current node's key.
1:eac0369: 
1:eac0369: 				// See if we can use the aggregators
1:eac0369: 				// to get rid of the new key.
1:eac0369: 				if ((sort.sortObserver != null) &&
1:eac0369: 					((k = sort.sortObserver.insertDuplicateKey(k, p.key)) == null))
1:eac0369: 				{
1:eac0369: 					return INSERT_DUPLICATE;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// Keep the duplicate key...
1:eac0369: 				// Allocate a new node for the key.
1:eac0369: 				q = allocator.newNode();
1:eac0369: 				if (q == null)
1:eac0369: 					return INSERT_FULL;
1:eac0369: 				q.aux = nextAux;
1:eac0369: 
1:eac0369: 				// Link the new node onto the current
1:eac0369: 				// node's duplicate chain.  The assumption
1:eac0369: 				// is made that a newly allocated node 
1:eac0369: 				// has null left and right links.
1:eac0369: 				q.key = k;
1:eac0369: 				q.dupChain = p.dupChain;
1:eac0369: 				p.dupChain = q;
1:eac0369: 
1:eac0369: 				// From the caller's perspective this was
1:eac0369: 				// not a duplicate insertion.
1:eac0369: 				return INSERT_OK;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (c < 0)
1:eac0369: 			{
1:eac0369: 				// [A3. Move left]
1:eac0369: 				q = p.leftLink;
1:eac0369: 				if (q == null)
1:eac0369: 				{
1:eac0369: 					q = allocator.newNode();
1:eac0369: 					if (q == null)
1:eac0369: 						return INSERT_FULL;
1:eac0369: 					q.aux = nextAux;
1:eac0369: 					p.leftLink = q;
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else // c > 0
1:eac0369: 			{
1:eac0369: 				// [A4. Move right]
1:eac0369: 				q = p.rightLink;
1:eac0369: 				if (q == null)
1:eac0369: 				{
1:eac0369: 					q = allocator.newNode();
1:eac0369: 					if (q == null)
1:eac0369: 						return INSERT_FULL;
1:eac0369: 					q.aux = nextAux;
1:eac0369: 					p.rightLink = q;
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (q.balance != 0)
1:eac0369: 			{
1:eac0369: 				t = p;
1:eac0369: 				s = q;
1:eac0369: 			}
1:eac0369: 			p = q;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * [A5. Insert]
1:eac0369: 		 * Node has been allocated and placed for k.
1:eac0369: 		 * Initialize it.
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		if ((sort.sortObserver != null) && 
1:eac0369: 			((k = sort.sortObserver.insertNonDuplicateKey(k)) == null))
1:eac0369: 		{
1:eac0369: 			return INSERT_DUPLICATE;
1:eac0369: 		}
1:eac0369: 		q.key = k;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * [A6. Adjust balance factors for nodes between
1:eac0369: 		 * s and q]
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		c = sort.compare(k, s.key);
1:eac0369: 		if (c < 0)
1:eac0369: 			r = p = s.leftLink;
1:eac0369: 		else
1:eac0369: 			r = p = s.rightLink;
1:eac0369: 
1:eac0369: 		while (p != q)
1:eac0369: 		{
1:eac0369: 			if (sort.compare(k, p.key) < 0)
1:eac0369: 			{
1:eac0369: 				p.balance = -1;
1:eac0369: 				p = p.leftLink;
1:eac0369: 			}
1:eac0369: 			else // sort.compare(k, p.key) > 0
1:eac0369: 			{
1:eac0369: 				p.balance = 1;
1:eac0369: 				p = p.rightLink;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// [A7. Balancing act]
1:eac0369: 
1:eac0369: 		int a = (c > 0 ? 1 : ((c == 0) ? 0 : -1));
1:eac0369: 
1:eac0369: 		if (s.balance == 0)
1:eac0369: 		{
1:eac0369: 			//debug("A7 (i). The tree has gotten higher");
1:eac0369: 			s.balance = a;
1:eac0369: 			height++;
1:eac0369: 			return INSERT_OK;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (s.balance == -a)
1:eac0369: 		{
1:eac0369: 			//debug("A7 (ii). The tree has gotten more balanced");
1:eac0369: 			s.balance = 0;
1:eac0369: 			return INSERT_OK;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//debug("A7 (iii). The tree has gotten more out of balance");
1:eac0369: 
1:eac0369: 		// s.balance == a
1:eac0369: 		if (r.balance == a)
1:eac0369: 		{
1:eac0369: 			//debug("A8. Single rotation");
1:eac0369: 			p = r;
1:eac0369: 			s.setLink(a, r.link(-a));
1:eac0369: 			r.setLink(-a, s);
1:eac0369: 			s.balance = 0;
1:eac0369: 			r.balance = 0;
1:eac0369: 		}
1:eac0369: 		else // r.balance == -a
1:eac0369: 		{
1:eac0369: 			//debug("A8. Double rotation");
1:eac0369: 			p = r.link(-a);
1:eac0369: 			r.setLink(-a, p.link(a));
1:eac0369: 			p.setLink(a, r);
1:eac0369: 			s.setLink(a, p.link(-a));
1:eac0369: 			p.setLink(-a, s);
1:eac0369: 
1:eac0369: 			if (p.balance == a)
1:eac0369: 			{
1:eac0369: 				s.balance = -a;
1:eac0369: 				r.balance = 0;
1:eac0369: 			}
1:eac0369: 			else if (p.balance == 0)
1:eac0369: 			{
1:eac0369: 				s.balance = 0;
1:eac0369: 				r.balance = 0;
1:eac0369: 			}
1:eac0369: 			else // p.balance == -a
1:eac0369: 			{
1:eac0369: 				s.balance = 0;
1:eac0369: 				r.balance = a;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			p.balance = 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// [A10. Finishing touch]
1:eac0369: 		if (s == t.rightLink)
1:eac0369: 			t.rightLink = p;
1:eac0369: 		else
1:eac0369: 			t.leftLink = p;
1:eac0369: 
1:eac0369: 		return INSERT_OK;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Return the lowest key and delete it from 
1:eac0369: 	the tree, preserving the balance of the tree.
1:eac0369: 	**/
1:8417890: 	DataValueDescriptor[] removeFirst()
1:eac0369: 	{
1:eac0369: 		if (head.rightLink == null)
1:eac0369: 			return null;
1:eac0369: 		head.rightLink = deleteLeftmost(head.rightLink);
1:eac0369: 		if (this.subtreeShrunk)
1:eac0369: 			height--;
1:eac0369: 		return this.deletedKey;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Delete the node with the lowest key from the subtree defined
1:eac0369: 	by 'thisNode', maintaining balance in the subtree.  Returns
1:eac0369: 	the node that should be the new root of the subtree.  This
1:eac0369: 	method sets this.subtreeShrunk if the subtree of thisNode
1:eac0369: 	decreased in height. Saves the key that was in the deleted
1:eac0369: 	node in 'deletedKey'.
1:eac0369: 	**/
1:eac0369: 	private Node deleteLeftmost(Node thisNode)
1:eac0369: 	{
1:eac0369: 		// If this node has no left child, we've found the
1:eac0369: 		// leftmost one, so delete it.
1:eac0369: 		if (thisNode.leftLink == null)
1:eac0369: 		{
1:eac0369: 
1:eac0369: 			// See if the current node has duplicates.  If so, we'll
1:eac0369: 			// just return one of them and not change the tree.
1:eac0369: 			if (thisNode.dupChain != null)
1:eac0369: 			{
1:eac0369: 				Node dupNode = thisNode.dupChain;
1:eac0369: 
1:eac0369: 				//System.out.println("deleteLeftmost(" + thisNode + "): found dup: " + dupNode);
1:eac0369: 
1:eac0369: 				// Return the key from the duplicate.  Note that even
1:eac0369: 				// though the keys compare equal they may not be equal,
1:eac0369: 				// depending on how the column ordering was specified.
1:eac0369: 				this.deletedKey = dupNode.key;
1:eac0369: 				lastAux = dupNode.aux;
1:eac0369: 
1:eac0369: 				// Unlink the dup node and free it.
1:eac0369: 				thisNode.dupChain = dupNode.dupChain;
1:eac0369: 				allocator.freeNode(dupNode);
1:eac0369: 				dupNode = null;
1:eac0369: 
1:eac0369: 				// Tree is not changing height since we're just removing
1:eac0369: 				// a node from the duplicate chain.
1:eac0369: 				this.subtreeShrunk = false;
1:eac0369: 
1:eac0369: 				// Preserve the current node as the root of this subtree..
1:eac0369: 				return thisNode;
1:eac0369: 			}
1:eac0369: 			else // thisNode.dupChain == null
1:eac0369: 			{
1:eac0369: 				//System.out.println("deleteLeftmost(" + thisNode + "): found key");
1:eac0369: 
1:eac0369: 				// Key to return is this node's key.
1:eac0369: 				this.deletedKey = thisNode.key;
1:eac0369: 				lastAux = thisNode.aux;
1:eac0369: 
1:eac0369: 				// We're removing this node, so it's subtree is shrinking
1:eac0369: 				// from height 1 to height 0.
1:eac0369: 				this.subtreeShrunk = true;
1:eac0369: 
1:eac0369: 				// Save this node's right link which might be cleared
1:eac0369: 				// out by the allocator.
1:eac0369: 				Node newRoot = thisNode.rightLink;
1:eac0369: 
1:eac0369: 				// Free the node we're deleting.
1:eac0369: 				allocator.freeNode(thisNode);
1:eac0369: 
1:eac0369: 				// Rearrange the tree to put this node's right subtree where
1:eac0369: 				// this node was.
1:eac0369: 				return newRoot;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Since this wasn't the leftmost node, delete the leftmost
1:eac0369: 		// node from this node's left subtree.  This operation may
1:eac0369: 		// rearrange the subtree, including the possiblility that the
1:eac0369: 		// root note changed, so set the root of the left subtree to
1:eac0369: 		// what the delete operation wants it to be.
1:eac0369: 		thisNode.leftLink = deleteLeftmost(thisNode.leftLink);
1:eac0369: 
1:eac0369: 		// If the left subtree didn't change size, then this subtree
1:eac0369: 		// could not have changed size either.
1:eac0369: 		if (this.subtreeShrunk == false)
1:eac0369: 			return thisNode;
1:eac0369: 
1:eac0369:  		// If the delete operation shrunk the subtree, we may have
1:eac0369: 		// some rebalancing to do.
1:eac0369: 
1:eac0369: 		if (thisNode.balance == 1)
1:eac0369: 		{
1:eac0369: 			// Tree got more unbalanced.  Need to do some
1:eac0369: 			// kind of rotation to fix it.  The rotateRight()
1:eac0369: 			// method will set subtreeShrunk appropriately
1:eac0369: 			// and return the node that should be the new
1:eac0369: 			// root of this subtree.
1:eac0369: 			return rotateRight(thisNode);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (thisNode.balance == -1)
1:eac0369: 		{
1:eac0369: 			// Tree became more balanced
1:eac0369: 			thisNode.balance = 0;
1:eac0369: 
1:eac0369: 			// Since the left subtree was higher, and it
1:eac0369: 			// shrunk, then this subtree shrunk, too.
1:eac0369: 			this.subtreeShrunk = true;
1:eac0369: 		}
1:eac0369: 		else // thisNode.balance == 0
1:eac0369: 		{
1:eac0369: 			// Tree became acceptably unbalanced
1:eac0369: 			thisNode.balance = 1;
1:eac0369: 
1:eac0369: 			// We had a balanced tree, and just the left
1:eac0369: 			// subtree shrunk, so this subtree as a whole
1:eac0369: 			// has not changed in height.
1:eac0369: 			this.subtreeShrunk = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// We have not rearranged this subtree.
1:eac0369: 		return thisNode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Perform either a single or double rotation, as appropriate, 
1:eac0369: 	to get the subtree 'thisNode' back in balance, assuming
1:eac0369: 	that the right subtree of 'thisNode' is higher than the
1:eac0369: 	left subtree.  Returns the node that should be the new
1:eac0369: 	root of the subtree.
1:eac0369: 	<P>
1:eac0369: 	These are the cases depicted in diagrams (1) and (2) of
1:eac0369: 	Knuth (p. 454), and the node names reflect these diagrams.
1:eac0369: 	However, in deletion, the single rotation may encounter
1:eac0369: 	a case where the "beta" and "gamma" subtrees are the same
1:eac0369: 	height (b.balance == 0), so the resulting does not always
1:eac0369: 	shrink.
1:eac0369: 	<P>
1:eac0369:     Note: This code will not do the "mirror image" cases.
1:eac0369: 	It only works when the right subtree is the higher one
1:eac0369: 	(this is the only case encountered when deleting leftmost
1:eac0369: 	nodes from the tree).
1:eac0369: 	**/
1:eac0369: 	private Node rotateRight(Node thisNode)
1:eac0369: 	{
1:eac0369: 		Node a = thisNode;
1:eac0369: 		Node b = thisNode.rightLink;
1:eac0369: 
1:eac0369: 		if (b.balance >= 0)
1:eac0369: 		{
1:eac0369: 			// single rotation
1:eac0369: 
1:eac0369: 			a.rightLink = b.leftLink;
1:eac0369: 			b.leftLink = a;
1:eac0369: 
1:eac0369: 			if (b.balance == 0)
1:eac0369: 			{
1:eac0369: 				a.balance = 1;
1:eac0369: 				b.balance = -1;
1:eac0369: 				this.subtreeShrunk = false;
1:eac0369: 			}
1:eac0369: 			else // b.balance == 1
1:eac0369: 			{
1:eac0369: 				a.balance = 0;
1:eac0369: 				b.balance = 0;
1:eac0369: 				this.subtreeShrunk = true;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return b;
1:eac0369: 		}
1:eac0369: 		else // b.balance == -1
1:eac0369: 		{
1:eac0369: 			// double rotation
1:eac0369: 
1:eac0369: 			Node x = b.leftLink;
1:eac0369: 
1:eac0369: 			a.rightLink = x.leftLink;
1:eac0369: 			x.leftLink = a;
1:eac0369: 			b.leftLink = x.rightLink;
1:eac0369: 			x.rightLink = b;
1:eac0369: 
1:eac0369: 			if (x.balance == 1)
1:eac0369: 			{
1:eac0369: 				a.balance = -1;
1:eac0369: 				b.balance = 0;
1:eac0369: 			}
1:eac0369: 			else if (x.balance == -1)
1:eac0369: 			{
1:eac0369: 				a.balance = 0;
1:eac0369: 				b.balance = 1;
1:eac0369: 			}
1:eac0369: 			else // x.balance == 0
1:eac0369: 			{
1:eac0369: 				a.balance = 0;
1:eac0369: 				b.balance = 0;
1:eac0369: 			}
1:eac0369: 			x.balance = 0;
1:eac0369: 
1:eac0369: 			this.subtreeShrunk = true;
1:eac0369: 
1:eac0369: 			return x;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void check()
1:eac0369: 	{
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             String error = null;
1:eac0369:             if (head.rightLink == null)
1:eac0369:             {
1:eac0369:                 if (height != 0)
1:eac0369:                     error = "empty tree with height " + height;
1:eac0369:             } 
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 if (depth(head.rightLink) != height)
1:eac0369:                     error = "tree height " + height + " != depth " + depth(head.rightLink);
1:eac0369:                 else
1:eac0369:                     error = checkNode(head.rightLink);
1:eac0369:             }
1:eac0369:             if (error != null)
1:eac0369:             {
1:eac0369:                 System.out.println("ERROR: " + error);
1:eac0369:                 print();
1:eac0369:                 System.exit(1);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private String checkNode(Node n)
1:eac0369: 	{
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (n == null)
1:eac0369:                 return null;
1:eac0369:             int ld = depth(n.leftLink);
1:eac0369:             int rd = depth(n.rightLink);
1:eac0369:             if (n.balance != (rd - ld))
1:eac0369:                 return "node " + n + ": left height " + ld + " right height " + rd;
1:eac0369:             
1:eac0369:             String e;
1:eac0369:             e = checkNode(n.rightLink);
1:eac0369:             if (e == null)
1:eac0369:                 e = checkNode(n.leftLink);
1:eac0369:             return e;
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return(null);
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private int depth(Node n)
1:eac0369: 	{
1:eac0369: 		int ld = 0;
1:eac0369: 		int rd = 0;
1:eac0369: 		if (n == null)
1:eac0369: 			return 0;
1:eac0369: 		if (n.leftLink != null)
1:eac0369: 			ld = depth(n.leftLink);
1:eac0369: 		if (n.rightLink != null)
1:eac0369: 			rd = depth(n.rightLink);
1:eac0369: 		if (rd > ld)
1:eac0369: 			return rd + 1;
1:eac0369: 		else
1:eac0369: 			return ld + 1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void print()
1:eac0369: 	{
1:eac0369: 		Node root = head.rightLink;
1:eac0369: 		System.out.println("tree height: " + height
1:eac0369: 			+ " root: " + ((root == null) ? -1 : root.id));
1:eac0369: 		if (root != null)
1:eac0369: 			printRecursive(root, 0);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void printRecursive(Node n, int depth)
1:eac0369: 	{
1:eac0369: 		if (n.rightLink != null)
1:eac0369: 			printRecursive(n.rightLink, depth + 1);
1:eac0369: 		for (int i = 0; i < depth; i++)
1:eac0369: 			System.out.print("       ");
1:eac0369: 		System.out.println(n);
1:eac0369: 		if (n.leftLink != null)
1:eac0369: 			printRecursive(n.leftLink, depth + 1);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void debug(String s)
1:eac0369: 	{
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             System.out.println(" === [" + s + "] ===");
1:eac0369:         }
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:8417890
/////////////////////////////////////////////////////////////////////////
1: 	void setNextAux(int aux)
/////////////////////////////////////////////////////////////////////////
1: 	int getLastAux()
/////////////////////////////////////////////////////////////////////////
1: 	SortBuffer(MergeSort sort)
/////////////////////////////////////////////////////////////////////////
1: 	boolean init()
/////////////////////////////////////////////////////////////////////////
1: 	void reset()
1: 	void close()
/////////////////////////////////////////////////////////////////////////
1: 	void grow(int percent)
/////////////////////////////////////////////////////////////////////////
1: 	int capacity()
/////////////////////////////////////////////////////////////////////////
1: 	int insert(DataValueDescriptor[] k)
/////////////////////////////////////////////////////////////////////////
1: 	DataValueDescriptor[] removeFirst()
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.sort.SortBuffer
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.sort
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.sort;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.SortObserver;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: /**
1: 
1:   This class implements an in-memory ordered set
1:   based on the balanced binary tree algorithm from
1:   Knuth Vol. 3, Sec. 6.2.3, pp. 451-471.
1:   Nodes are always maintained in order,
1:   so that inserts and deletes can be intermixed.
1:   <P>
1:   This algorithm will insert/delete N elements
1:   in O(N log(N)) time using O(N) space. 
1: 
1: **/
1: 
1: class SortBuffer
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 	Returned from insert when the row was inserted
1: 	without incident.
1: 	**/
1: 	public static final int INSERT_OK = 0;
1: 
1: 	/**
1: 	Returned from insert when the row which was
1: 	inserted was a duplicate.  The set will have
1: 	aggregated it in.
1: 	**/
1: 	public static final int INSERT_DUPLICATE = 1;
1: 
1: 	/**
1: 	Returned from insert when the row was not able to be
1: 	inserted because the set was full.
1: 	**/
1: 	public static final int INSERT_FULL = 2;
1: 
1: 	/**
1: 	The sort this set is associated with.
1: 	**/
1: 	private MergeSort sort;
1: 
1: 	/**
1: 	Where to allocate nodes from.
1: 	**/
1: 	private NodeAllocator allocator = null;
1: 
1: 	/**
1: 	Special head node for the tree.  Head.rightLink is the
1: 	root of the tree.
1: 	**/
1: 	private Node head = null;
1: 
1: 	/**
1: 	The current height of the tree.
1: 	**/
1: 	private int height = 0;
1: 
1: 	/**
1: 	Set, as a side effect of deleteLeftMost (only), to the
1: 	key from the node that was deleted from the tree.  This
1: 	field is only valid after a call to deleteLeftMost.
1: 	**/
1: 	private DataValueDescriptor[] deletedKey;
1: 
1: 	/**
1: 	Set, as a side effect of deleteLeftMost and rotateRight,
1: 	if the subtree they're working on decreased in height.
1: 	This field is only valid after a call to deleteLeftMost
1: 	or rotateRight.
1: 	**/
1: 	private boolean subtreeShrunk;
1: 
1: 	/**
1: 	Set by the setNextAux() method.  This value is stuffed
1: 	into the aux field of the next node that's allocated.
1: 	**/
1: 	private int nextAux;
1: 
1: 	/**
1: 	Read by the getLastAux() method.  This value is read out
1: 	of the last node that was deallocated from the tree.
1: 	**/
1: 	private int lastAux;
1: 
1: 	/**
1: 	Arrange that the next node allocated in the tree have
1: 	it's aux field set to the argument.
1: 	**/
0: 	public void setNextAux(int aux)
1: 	{
1: 		nextAux = aux;
1: 	}
1: 
1: 	/**
1: 	Retrieve the aux value from the last node deallocated
1: 	from the tree.
1: 	**/
0: 	public int getLastAux()
1: 	{
1: 		return lastAux;
1: 	}
1: 
1: 	/**
1: 	Construct doesn't do anything, callers must call init
1: 	and check its return code.
1: 	**/
0: 	public SortBuffer(MergeSort sort)
1: 	{
1: 		this.sort = sort;
1: 	}
1: 
1: 	/**
1: 	Initialize.  Returns false if the allocator
1: 	couldn't be initialized.
1: 	**/
0: 	public boolean init()
1: 	{
1: 		allocator = new NodeAllocator();
1: 
1: 		boolean initOK = false;
1: 
1: 		if (sort.sortBufferMin > 0)
1: 			initOK = allocator.init(sort.sortBufferMin, sort.sortBufferMax);
1: 		else
1: 			initOK = allocator.init(sort.sortBufferMax);
1: 
1: 		if (initOK == false)
1: 		{
1: 			allocator = null;
1: 			return false;
1: 		}
1: 		reset();
1: 		return true;
1: 	}
1: 
0: 	public void reset()
1: 	{
1: 		allocator.reset();
1: 		head = allocator.newNode();
1: 		height = 0;
1: 	}
1: 
0: 	public void close()
1: 	{
1: 		if (allocator != null)
1: 			allocator.close();
1: 		allocator = null;
1: 		height = 0;
1: 		head = null;
1: 	}
1: 
1: 	/**
1: 	Grow by a certain percent if we can
1: 	*/
0: 	public void grow(int percent)
1: 	{
1: 		if (percent > 0)
1: 			allocator.grow(percent);
1: 	}
1: 
1: 
1: 	/**
1: 	Return the number of elements this sorter can sort.
1: 	It's the capacity of the node allocator minus one
1: 	because the sorter uses one node for the head.
1: 	**/
0: 	public int capacity()
1: 	{
1: 		if (allocator == null)
1: 			return 0;
1: 		return allocator.capacity() - 1;
1: 	}
1: 
1: 	/**
1: 	Insert a key k into the tree. Returns true if the
1: 	key was inserted, false if the tree is full.  Silently
1: 	ignores duplicate keys.
1: 	<P>
1: 	See Knuth Vol. 3, Sec. 6.2.3, pp. 455-457 for the algorithm.
1: 	**/
0: 	public int insert(DataValueDescriptor[] k)
1: 		throws StandardException
1: 	{
1: 		int c;
1: 		Node p, q, r, s, t;
1: 
1: 		if (head.rightLink == null)
1: 		{
1: 			if ((sort.sortObserver != null) && 
1: 				((k = sort.sortObserver.insertNonDuplicateKey(k)) == null))
1: 			{
1: 				return INSERT_DUPLICATE;
1: 			}
1: 
1: 			q = allocator.newNode();
1: 			q.key = k;
1: 			q.aux = nextAux;
1: 			head.rightLink = q;
1: 			height = 1;
1: 			return INSERT_OK;
1: 		}
1: 
1: 		// [A1. Initialize]
1: 		t = head;
1: 		p = s = head.rightLink;
1: 
1: 		// Search
1: 		while (true)
1: 		{
1: 			// [A2. Compare]
1: 			c = sort.compare(k, p.key);
1: 			if (c == 0)
1: 			{
1: 				// The new key compares equal to the
1: 				// current node's key.
1: 
1: 				// See if we can use the aggregators
1: 				// to get rid of the new key.
1: 				if ((sort.sortObserver != null) &&
1: 					((k = sort.sortObserver.insertDuplicateKey(k, p.key)) == null))
1: 				{
1: 					return INSERT_DUPLICATE;
1: 				}
1: 
1: 				// Keep the duplicate key...
1: 				// Allocate a new node for the key.
1: 				q = allocator.newNode();
1: 				if (q == null)
1: 					return INSERT_FULL;
1: 				q.aux = nextAux;
1: 
1: 				// Link the new node onto the current
1: 				// node's duplicate chain.  The assumption
1: 				// is made that a newly allocated node 
1: 				// has null left and right links.
1: 				q.key = k;
1: 				q.dupChain = p.dupChain;
1: 				p.dupChain = q;
1: 
1: 				// From the caller's perspective this was
1: 				// not a duplicate insertion.
1: 				return INSERT_OK;
1: 			}
1: 
1: 			if (c < 0)
1: 			{
1: 				// [A3. Move left]
1: 				q = p.leftLink;
1: 				if (q == null)
1: 				{
1: 					q = allocator.newNode();
1: 					if (q == null)
1: 						return INSERT_FULL;
1: 					q.aux = nextAux;
1: 					p.leftLink = q;
1: 					break;
1: 				}
1: 			}
1: 			else // c > 0
1: 			{
1: 				// [A4. Move right]
1: 				q = p.rightLink;
1: 				if (q == null)
1: 				{
1: 					q = allocator.newNode();
1: 					if (q == null)
1: 						return INSERT_FULL;
1: 					q.aux = nextAux;
1: 					p.rightLink = q;
1: 					break;
1: 				}
1: 			}
1: 
1: 			if (q.balance != 0)
1: 			{
1: 				t = p;
1: 				s = q;
1: 			}
1: 			p = q;
1: 		}
1: 
1: 		/*
1: 		 * [A5. Insert]
1: 		 * Node has been allocated and placed for k.
1: 		 * Initialize it.
1: 		 */
1: 
1: 		if ((sort.sortObserver != null) && 
1: 			((k = sort.sortObserver.insertNonDuplicateKey(k)) == null))
1: 		{
1: 			return INSERT_DUPLICATE;
1: 		}
1: 		q.key = k;
1: 
1: 		/*
1: 		 * [A6. Adjust balance factors for nodes between
1: 		 * s and q]
1: 		 */
1: 
1: 		c = sort.compare(k, s.key);
1: 		if (c < 0)
1: 			r = p = s.leftLink;
1: 		else
1: 			r = p = s.rightLink;
1: 
1: 		while (p != q)
1: 		{
1: 			if (sort.compare(k, p.key) < 0)
1: 			{
1: 				p.balance = -1;
1: 				p = p.leftLink;
1: 			}
1: 			else // sort.compare(k, p.key) > 0
1: 			{
1: 				p.balance = 1;
1: 				p = p.rightLink;
1: 			}
1: 		}
1: 
1: 		// [A7. Balancing act]
1: 
1: 		int a = (c > 0 ? 1 : ((c == 0) ? 0 : -1));
1: 
1: 		if (s.balance == 0)
1: 		{
1: 			//debug("A7 (i). The tree has gotten higher");
1: 			s.balance = a;
1: 			height++;
1: 			return INSERT_OK;
1: 		}
1: 
1: 		if (s.balance == -a)
1: 		{
1: 			//debug("A7 (ii). The tree has gotten more balanced");
1: 			s.balance = 0;
1: 			return INSERT_OK;
1: 		}
1: 
1: 		//debug("A7 (iii). The tree has gotten more out of balance");
1: 
1: 		// s.balance == a
1: 		if (r.balance == a)
1: 		{
1: 			//debug("A8. Single rotation");
1: 			p = r;
1: 			s.setLink(a, r.link(-a));
1: 			r.setLink(-a, s);
1: 			s.balance = 0;
1: 			r.balance = 0;
1: 		}
1: 		else // r.balance == -a
1: 		{
1: 			//debug("A8. Double rotation");
1: 			p = r.link(-a);
1: 			r.setLink(-a, p.link(a));
1: 			p.setLink(a, r);
1: 			s.setLink(a, p.link(-a));
1: 			p.setLink(-a, s);
1: 
1: 			if (p.balance == a)
1: 			{
1: 				s.balance = -a;
1: 				r.balance = 0;
1: 			}
1: 			else if (p.balance == 0)
1: 			{
1: 				s.balance = 0;
1: 				r.balance = 0;
1: 			}
1: 			else // p.balance == -a
1: 			{
1: 				s.balance = 0;
1: 				r.balance = a;
1: 			}
1: 
1: 			p.balance = 0;
1: 		}
1: 
1: 		// [A10. Finishing touch]
1: 		if (s == t.rightLink)
1: 			t.rightLink = p;
1: 		else
1: 			t.leftLink = p;
1: 
1: 		return INSERT_OK;
1: 	}
1: 
1: 	/**
1: 	Return the lowest key and delete it from 
1: 	the tree, preserving the balance of the tree.
1: 	**/
0: 	public DataValueDescriptor[] removeFirst()
1: 	{
1: 		if (head.rightLink == null)
1: 			return null;
1: 		head.rightLink = deleteLeftmost(head.rightLink);
1: 		if (this.subtreeShrunk)
1: 			height--;
1: 		return this.deletedKey;
1: 	}
1: 
1: 	/**
1: 	Delete the node with the lowest key from the subtree defined
1: 	by 'thisNode', maintaining balance in the subtree.  Returns
1: 	the node that should be the new root of the subtree.  This
1: 	method sets this.subtreeShrunk if the subtree of thisNode
1: 	decreased in height. Saves the key that was in the deleted
1: 	node in 'deletedKey'.
1: 	**/
1: 	private Node deleteLeftmost(Node thisNode)
1: 	{
1: 		// If this node has no left child, we've found the
1: 		// leftmost one, so delete it.
1: 		if (thisNode.leftLink == null)
1: 		{
1: 
1: 			// See if the current node has duplicates.  If so, we'll
1: 			// just return one of them and not change the tree.
1: 			if (thisNode.dupChain != null)
1: 			{
1: 				Node dupNode = thisNode.dupChain;
1: 
1: 				//System.out.println("deleteLeftmost(" + thisNode + "): found dup: " + dupNode);
1: 
1: 				// Return the key from the duplicate.  Note that even
1: 				// though the keys compare equal they may not be equal,
1: 				// depending on how the column ordering was specified.
1: 				this.deletedKey = dupNode.key;
1: 				lastAux = dupNode.aux;
1: 
1: 				// Unlink the dup node and free it.
1: 				thisNode.dupChain = dupNode.dupChain;
1: 				allocator.freeNode(dupNode);
1: 				dupNode = null;
1: 
1: 				// Tree is not changing height since we're just removing
1: 				// a node from the duplicate chain.
1: 				this.subtreeShrunk = false;
1: 
1: 				// Preserve the current node as the root of this subtree..
1: 				return thisNode;
1: 			}
1: 			else // thisNode.dupChain == null
1: 			{
1: 				//System.out.println("deleteLeftmost(" + thisNode + "): found key");
1: 
1: 				// Key to return is this node's key.
1: 				this.deletedKey = thisNode.key;
1: 				lastAux = thisNode.aux;
1: 
1: 				// We're removing this node, so it's subtree is shrinking
1: 				// from height 1 to height 0.
1: 				this.subtreeShrunk = true;
1: 
1: 				// Save this node's right link which might be cleared
1: 				// out by the allocator.
1: 				Node newRoot = thisNode.rightLink;
1: 
1: 				// Free the node we're deleting.
1: 				allocator.freeNode(thisNode);
1: 
1: 				// Rearrange the tree to put this node's right subtree where
1: 				// this node was.
1: 				return newRoot;
1: 			}
1: 		}
1: 
1: 		// Since this wasn't the leftmost node, delete the leftmost
1: 		// node from this node's left subtree.  This operation may
1: 		// rearrange the subtree, including the possiblility that the
1: 		// root note changed, so set the root of the left subtree to
1: 		// what the delete operation wants it to be.
1: 		thisNode.leftLink = deleteLeftmost(thisNode.leftLink);
1: 
1: 		// If the left subtree didn't change size, then this subtree
1: 		// could not have changed size either.
1: 		if (this.subtreeShrunk == false)
1: 			return thisNode;
1: 
1:  		// If the delete operation shrunk the subtree, we may have
1: 		// some rebalancing to do.
1: 
1: 		if (thisNode.balance == 1)
1: 		{
1: 			// Tree got more unbalanced.  Need to do some
1: 			// kind of rotation to fix it.  The rotateRight()
1: 			// method will set subtreeShrunk appropriately
1: 			// and return the node that should be the new
1: 			// root of this subtree.
1: 			return rotateRight(thisNode);
1: 		}
1: 
1: 		if (thisNode.balance == -1)
1: 		{
1: 			// Tree became more balanced
1: 			thisNode.balance = 0;
1: 
1: 			// Since the left subtree was higher, and it
1: 			// shrunk, then this subtree shrunk, too.
1: 			this.subtreeShrunk = true;
1: 		}
1: 		else // thisNode.balance == 0
1: 		{
1: 			// Tree became acceptably unbalanced
1: 			thisNode.balance = 1;
1: 
1: 			// We had a balanced tree, and just the left
1: 			// subtree shrunk, so this subtree as a whole
1: 			// has not changed in height.
1: 			this.subtreeShrunk = false;
1: 		}
1: 
1: 		// We have not rearranged this subtree.
1: 		return thisNode;
1: 	}
1: 
1: 	/**
1: 	Perform either a single or double rotation, as appropriate, 
1: 	to get the subtree 'thisNode' back in balance, assuming
1: 	that the right subtree of 'thisNode' is higher than the
1: 	left subtree.  Returns the node that should be the new
1: 	root of the subtree.
1: 	<P>
1: 	These are the cases depicted in diagrams (1) and (2) of
1: 	Knuth (p. 454), and the node names reflect these diagrams.
1: 	However, in deletion, the single rotation may encounter
1: 	a case where the "beta" and "gamma" subtrees are the same
1: 	height (b.balance == 0), so the resulting does not always
1: 	shrink.
1: 	<P>
1:     Note: This code will not do the "mirror image" cases.
1: 	It only works when the right subtree is the higher one
1: 	(this is the only case encountered when deleting leftmost
1: 	nodes from the tree).
1: 	**/
1: 	private Node rotateRight(Node thisNode)
1: 	{
1: 		Node a = thisNode;
1: 		Node b = thisNode.rightLink;
1: 
1: 		if (b.balance >= 0)
1: 		{
1: 			// single rotation
1: 
1: 			a.rightLink = b.leftLink;
1: 			b.leftLink = a;
1: 
1: 			if (b.balance == 0)
1: 			{
1: 				a.balance = 1;
1: 				b.balance = -1;
1: 				this.subtreeShrunk = false;
1: 			}
1: 			else // b.balance == 1
1: 			{
1: 				a.balance = 0;
1: 				b.balance = 0;
1: 				this.subtreeShrunk = true;
1: 			}
1: 
1: 			return b;
1: 		}
1: 		else // b.balance == -1
1: 		{
1: 			// double rotation
1: 
1: 			Node x = b.leftLink;
1: 
1: 			a.rightLink = x.leftLink;
1: 			x.leftLink = a;
1: 			b.leftLink = x.rightLink;
1: 			x.rightLink = b;
1: 
1: 			if (x.balance == 1)
1: 			{
1: 				a.balance = -1;
1: 				b.balance = 0;
1: 			}
1: 			else if (x.balance == -1)
1: 			{
1: 				a.balance = 0;
1: 				b.balance = 1;
1: 			}
1: 			else // x.balance == 0
1: 			{
1: 				a.balance = 0;
1: 				b.balance = 0;
1: 			}
1: 			x.balance = 0;
1: 
1: 			this.subtreeShrunk = true;
1: 
1: 			return x;
1: 		}
1: 	}
1: 
1: 	public void check()
1: 	{
1:         if (SanityManager.DEBUG)
1:         {
1:             String error = null;
1:             if (head.rightLink == null)
1:             {
1:                 if (height != 0)
1:                     error = "empty tree with height " + height;
1:             } 
1:             else
1:             {
1:                 if (depth(head.rightLink) != height)
1:                     error = "tree height " + height + " != depth " + depth(head.rightLink);
1:                 else
1:                     error = checkNode(head.rightLink);
1:             }
1:             if (error != null)
1:             {
1:                 System.out.println("ERROR: " + error);
1:                 print();
1:                 System.exit(1);
1:             }
1:         }
1: 	}
1: 
1: 	private String checkNode(Node n)
1: 	{
1:         if (SanityManager.DEBUG)
1:         {
1:             if (n == null)
1:                 return null;
1:             int ld = depth(n.leftLink);
1:             int rd = depth(n.rightLink);
1:             if (n.balance != (rd - ld))
1:                 return "node " + n + ": left height " + ld + " right height " + rd;
1:             
1:             String e;
1:             e = checkNode(n.rightLink);
1:             if (e == null)
1:                 e = checkNode(n.leftLink);
1:             return e;
1:         }
1:         else
1:         {
1:             return(null);
1:         }
1: 	}
1: 
1: 	private int depth(Node n)
1: 	{
1: 		int ld = 0;
1: 		int rd = 0;
1: 		if (n == null)
1: 			return 0;
1: 		if (n.leftLink != null)
1: 			ld = depth(n.leftLink);
1: 		if (n.rightLink != null)
1: 			rd = depth(n.rightLink);
1: 		if (rd > ld)
1: 			return rd + 1;
1: 		else
1: 			return ld + 1;
1: 	}
1: 
1: 	public void print()
1: 	{
1: 		Node root = head.rightLink;
1: 		System.out.println("tree height: " + height
1: 			+ " root: " + ((root == null) ? -1 : root.id));
1: 		if (root != null)
1: 			printRecursive(root, 0);
1: 	}
1: 
1: 	private void printRecursive(Node n, int depth)
1: 	{
1: 		if (n.rightLink != null)
1: 			printRecursive(n.rightLink, depth + 1);
1: 		for (int i = 0; i < depth; i++)
1: 			System.out.print("       ");
1: 		System.out.println(n);
1: 		if (n.leftLink != null)
1: 			printRecursive(n.leftLink, depth + 1);
1: 	}
1: 
1: 	private void debug(String s)
1: 	{
1:         if (SanityManager.DEBUG)
1:         {
1:             System.out.println(" === [" + s + "] ===");
1:         }
1: 	}
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.sort
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.sort;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.SortObserver;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: /**
0: 
0:   This class implements an in-memory ordered set
0:   based on the balanced binary tree algorithm from
0:   Knuth Vol. 3, Sec. 6.2.3, pp. 451-471.
0:   Nodes are always maintained in order,
0:   so that inserts and deletes can be intermixed.
0:   <P>
0:   This algorithm will insert/delete N elements
0:   in O(N log(N)) time using O(N) space. 
0: 
0: **/
0: 
0: class SortBuffer
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	Returned from insert when the row was inserted
0: 	without incident.
0: 	**/
0: 	public static final int INSERT_OK = 0;
0: 
0: 	/**
0: 	Returned from insert when the row which was
0: 	inserted was a duplicate.  The set will have
0: 	aggregated it in.
0: 	**/
0: 	public static final int INSERT_DUPLICATE = 1;
0: 
0: 	/**
0: 	Returned from insert when the row was not able to be
0: 	inserted because the set was full.
0: 	**/
0: 	public static final int INSERT_FULL = 2;
0: 
0: 	/**
0: 	The sort this set is associated with.
0: 	**/
0: 	private MergeSort sort;
0: 
0: 	/**
0: 	Where to allocate nodes from.
0: 	**/
0: 	private NodeAllocator allocator = null;
0: 
0: 	/**
0: 	Special head node for the tree.  Head.rightLink is the
0: 	root of the tree.
0: 	**/
0: 	private Node head = null;
0: 
0: 	/**
0: 	The current height of the tree.
0: 	**/
0: 	private int height = 0;
0: 
0: 	/**
0: 	Set, as a side effect of deleteLeftMost (only), to the
0: 	key from the node that was deleted from the tree.  This
0: 	field is only valid after a call to deleteLeftMost.
0: 	**/
0: 	private DataValueDescriptor[] deletedKey;
0: 
0: 	/**
0: 	Set, as a side effect of deleteLeftMost and rotateRight,
0: 	if the subtree they're working on decreased in height.
0: 	This field is only valid after a call to deleteLeftMost
0: 	or rotateRight.
0: 	**/
0: 	private boolean subtreeShrunk;
0: 
0: 	/**
0: 	Set by the setNextAux() method.  This value is stuffed
0: 	into the aux field of the next node that's allocated.
0: 	**/
0: 	private int nextAux;
0: 
0: 	/**
0: 	Read by the getLastAux() method.  This value is read out
0: 	of the last node that was deallocated from the tree.
0: 	**/
0: 	private int lastAux;
0: 
0: 	/**
0: 	Arrange that the next node allocated in the tree have
0: 	it's aux field set to the argument.
0: 	**/
0: 	public void setNextAux(int aux)
0: 	{
0: 		nextAux = aux;
0: 	}
0: 
0: 	/**
0: 	Retrieve the aux value from the last node deallocated
0: 	from the tree.
0: 	**/
0: 	public int getLastAux()
0: 	{
0: 		return lastAux;
0: 	}
0: 
0: 	/**
0: 	Construct doesn't do anything, callers must call init
0: 	and check its return code.
0: 	**/
0: 	public SortBuffer(MergeSort sort)
0: 	{
0: 		this.sort = sort;
0: 	}
0: 
0: 	/**
0: 	Initialize.  Returns false if the allocator
0: 	couldn't be initialized.
0: 	**/
0: 	public boolean init()
0: 	{
0: 		allocator = new NodeAllocator();
0: 
0: 		boolean initOK = false;
0: 
0: 		if (sort.sortBufferMin > 0)
0: 			initOK = allocator.init(sort.sortBufferMin, sort.sortBufferMax);
0: 		else
0: 			initOK = allocator.init(sort.sortBufferMax);
0: 
0: 		if (initOK == false)
0: 		{
0: 			allocator = null;
0: 			return false;
0: 		}
0: 		reset();
0: 		return true;
0: 	}
0: 
0: 	public void reset()
0: 	{
0: 		allocator.reset();
0: 		head = allocator.newNode();
0: 		height = 0;
0: 	}
0: 
0: 	public void close()
0: 	{
0: 		if (allocator != null)
0: 			allocator.close();
0: 		allocator = null;
0: 		height = 0;
0: 		head = null;
0: 	}
0: 
0: 	/**
0: 	Grow by a certain percent if we can
0: 	*/
0: 	public void grow(int percent)
0: 	{
0: 		if (percent > 0)
0: 			allocator.grow(percent);
0: 	}
0: 
0: 
0: 	/**
0: 	Return the number of elements this sorter can sort.
0: 	It's the capacity of the node allocator minus one
0: 	because the sorter uses one node for the head.
0: 	**/
0: 	public int capacity()
0: 	{
0: 		if (allocator == null)
0: 			return 0;
0: 		return allocator.capacity() - 1;
0: 	}
0: 
0: 	/**
0: 	Insert a key k into the tree. Returns true if the
0: 	key was inserted, false if the tree is full.  Silently
0: 	ignores duplicate keys.
0: 	<P>
0: 	See Knuth Vol. 3, Sec. 6.2.3, pp. 455-457 for the algorithm.
0: 	**/
0: 	public int insert(DataValueDescriptor[] k)
0: 		throws StandardException
0: 	{
0: 		int c;
0: 		Node p, q, r, s, t;
0: 
0: 		if (head.rightLink == null)
0: 		{
0: 			if ((sort.sortObserver != null) && 
0: 				((k = sort.sortObserver.insertNonDuplicateKey(k)) == null))
0: 			{
0: 				return INSERT_DUPLICATE;
0: 			}
0: 
0: 			q = allocator.newNode();
0: 			q.key = k;
0: 			q.aux = nextAux;
0: 			head.rightLink = q;
0: 			height = 1;
0: 			return INSERT_OK;
0: 		}
0: 
0: 		// [A1. Initialize]
0: 		t = head;
0: 		p = s = head.rightLink;
0: 
0: 		// Search
0: 		while (true)
0: 		{
0: 			// [A2. Compare]
0: 			c = sort.compare(k, p.key);
0: 			if (c == 0)
0: 			{
0: 				// The new key compares equal to the
0: 				// current node's key.
0: 
0: 				// See if we can use the aggregators
0: 				// to get rid of the new key.
0: 				if ((sort.sortObserver != null) &&
0: 					((k = sort.sortObserver.insertDuplicateKey(k, p.key)) == null))
0: 				{
0: 					return INSERT_DUPLICATE;
0: 				}
0: 
0: 				// Keep the duplicate key...
0: 				// Allocate a new node for the key.
0: 				q = allocator.newNode();
0: 				if (q == null)
0: 					return INSERT_FULL;
0: 				q.aux = nextAux;
0: 
0: 				// Link the new node onto the current
0: 				// node's duplicate chain.  The assumption
0: 				// is made that a newly allocated node 
0: 				// has null left and right links.
0: 				q.key = k;
0: 				q.dupChain = p.dupChain;
0: 				p.dupChain = q;
0: 
0: 				// From the caller's perspective this was
0: 				// not a duplicate insertion.
0: 				return INSERT_OK;
0: 			}
0: 
0: 			if (c < 0)
0: 			{
0: 				// [A3. Move left]
0: 				q = p.leftLink;
0: 				if (q == null)
0: 				{
0: 					q = allocator.newNode();
0: 					if (q == null)
0: 						return INSERT_FULL;
0: 					q.aux = nextAux;
0: 					p.leftLink = q;
0: 					break;
0: 				}
0: 			}
0: 			else // c > 0
0: 			{
0: 				// [A4. Move right]
0: 				q = p.rightLink;
0: 				if (q == null)
0: 				{
0: 					q = allocator.newNode();
0: 					if (q == null)
0: 						return INSERT_FULL;
0: 					q.aux = nextAux;
0: 					p.rightLink = q;
0: 					break;
0: 				}
0: 			}
0: 
0: 			if (q.balance != 0)
0: 			{
0: 				t = p;
0: 				s = q;
0: 			}
0: 			p = q;
0: 		}
0: 
0: 		/*
0: 		 * [A5. Insert]
0: 		 * Node has been allocated and placed for k.
0: 		 * Initialize it.
0: 		 */
0: 
0: 		if ((sort.sortObserver != null) && 
0: 			((k = sort.sortObserver.insertNonDuplicateKey(k)) == null))
0: 		{
0: 			return INSERT_DUPLICATE;
0: 		}
0: 		q.key = k;
0: 
0: 		/*
0: 		 * [A6. Adjust balance factors for nodes between
0: 		 * s and q]
0: 		 */
0: 
0: 		c = sort.compare(k, s.key);
0: 		if (c < 0)
0: 			r = p = s.leftLink;
0: 		else
0: 			r = p = s.rightLink;
0: 
0: 		while (p != q)
0: 		{
0: 			if (sort.compare(k, p.key) < 0)
0: 			{
0: 				p.balance = -1;
0: 				p = p.leftLink;
0: 			}
0: 			else // sort.compare(k, p.key) > 0
0: 			{
0: 				p.balance = 1;
0: 				p = p.rightLink;
0: 			}
0: 		}
0: 
0: 		// [A7. Balancing act]
0: 
0: 		int a = (c > 0 ? 1 : ((c == 0) ? 0 : -1));
0: 
0: 		if (s.balance == 0)
0: 		{
0: 			//debug("A7 (i). The tree has gotten higher");
0: 			s.balance = a;
0: 			height++;
0: 			return INSERT_OK;
0: 		}
0: 
0: 		if (s.balance == -a)
0: 		{
0: 			//debug("A7 (ii). The tree has gotten more balanced");
0: 			s.balance = 0;
0: 			return INSERT_OK;
0: 		}
0: 
0: 		//debug("A7 (iii). The tree has gotten more out of balance");
0: 
0: 		// s.balance == a
0: 		if (r.balance == a)
0: 		{
0: 			//debug("A8. Single rotation");
0: 			p = r;
0: 			s.setLink(a, r.link(-a));
0: 			r.setLink(-a, s);
0: 			s.balance = 0;
0: 			r.balance = 0;
0: 		}
0: 		else // r.balance == -a
0: 		{
0: 			//debug("A8. Double rotation");
0: 			p = r.link(-a);
0: 			r.setLink(-a, p.link(a));
0: 			p.setLink(a, r);
0: 			s.setLink(a, p.link(-a));
0: 			p.setLink(-a, s);
0: 
0: 			if (p.balance == a)
0: 			{
0: 				s.balance = -a;
0: 				r.balance = 0;
0: 			}
0: 			else if (p.balance == 0)
0: 			{
0: 				s.balance = 0;
0: 				r.balance = 0;
0: 			}
0: 			else // p.balance == -a
0: 			{
0: 				s.balance = 0;
0: 				r.balance = a;
0: 			}
0: 
0: 			p.balance = 0;
0: 		}
0: 
0: 		// [A10. Finishing touch]
0: 		if (s == t.rightLink)
0: 			t.rightLink = p;
0: 		else
0: 			t.leftLink = p;
0: 
0: 		return INSERT_OK;
0: 	}
0: 
0: 	/**
0: 	Return the lowest key and delete it from 
0: 	the tree, preserving the balance of the tree.
0: 	**/
0: 	public DataValueDescriptor[] removeFirst()
0: 	{
0: 		if (head.rightLink == null)
0: 			return null;
0: 		head.rightLink = deleteLeftmost(head.rightLink);
0: 		if (this.subtreeShrunk)
0: 			height--;
0: 		return this.deletedKey;
0: 	}
0: 
0: 	/**
0: 	Delete the node with the lowest key from the subtree defined
0: 	by 'thisNode', maintaining balance in the subtree.  Returns
0: 	the node that should be the new root of the subtree.  This
0: 	method sets this.subtreeShrunk if the subtree of thisNode
0: 	decreased in height. Saves the key that was in the deleted
0: 	node in 'deletedKey'.
0: 	**/
0: 	private Node deleteLeftmost(Node thisNode)
0: 	{
0: 		// If this node has no left child, we've found the
0: 		// leftmost one, so delete it.
0: 		if (thisNode.leftLink == null)
0: 		{
0: 
0: 			// See if the current node has duplicates.  If so, we'll
0: 			// just return one of them and not change the tree.
0: 			if (thisNode.dupChain != null)
0: 			{
0: 				Node dupNode = thisNode.dupChain;
0: 
0: 				//System.out.println("deleteLeftmost(" + thisNode + "): found dup: " + dupNode);
0: 
0: 				// Return the key from the duplicate.  Note that even
0: 				// though the keys compare equal they may not be equal,
0: 				// depending on how the column ordering was specified.
0: 				this.deletedKey = dupNode.key;
0: 				lastAux = dupNode.aux;
0: 
0: 				// Unlink the dup node and free it.
0: 				thisNode.dupChain = dupNode.dupChain;
0: 				allocator.freeNode(dupNode);
0: 				dupNode = null;
0: 
0: 				// Tree is not changing height since we're just removing
0: 				// a node from the duplicate chain.
0: 				this.subtreeShrunk = false;
0: 
0: 				// Preserve the current node as the root of this subtree..
0: 				return thisNode;
0: 			}
0: 			else // thisNode.dupChain == null
0: 			{
0: 				//System.out.println("deleteLeftmost(" + thisNode + "): found key");
0: 
0: 				// Key to return is this node's key.
0: 				this.deletedKey = thisNode.key;
0: 				lastAux = thisNode.aux;
0: 
0: 				// We're removing this node, so it's subtree is shrinking
0: 				// from height 1 to height 0.
0: 				this.subtreeShrunk = true;
0: 
0: 				// Save this node's right link which might be cleared
0: 				// out by the allocator.
0: 				Node newRoot = thisNode.rightLink;
0: 
0: 				// Free the node we're deleting.
0: 				allocator.freeNode(thisNode);
0: 
0: 				// Rearrange the tree to put this node's right subtree where
0: 				// this node was.
0: 				return newRoot;
0: 			}
0: 		}
0: 
0: 		// Since this wasn't the leftmost node, delete the leftmost
0: 		// node from this node's left subtree.  This operation may
0: 		// rearrange the subtree, including the possiblility that the
0: 		// root note changed, so set the root of the left subtree to
0: 		// what the delete operation wants it to be.
0: 		thisNode.leftLink = deleteLeftmost(thisNode.leftLink);
0: 
0: 		// If the left subtree didn't change size, then this subtree
0: 		// could not have changed size either.
0: 		if (this.subtreeShrunk == false)
0: 			return thisNode;
0: 
0:  		// If the delete operation shrunk the subtree, we may have
0: 		// some rebalancing to do.
0: 
0: 		if (thisNode.balance == 1)
0: 		{
0: 			// Tree got more unbalanced.  Need to do some
0: 			// kind of rotation to fix it.  The rotateRight()
0: 			// method will set subtreeShrunk appropriately
0: 			// and return the node that should be the new
0: 			// root of this subtree.
0: 			return rotateRight(thisNode);
0: 		}
0: 
0: 		if (thisNode.balance == -1)
0: 		{
0: 			// Tree became more balanced
0: 			thisNode.balance = 0;
0: 
0: 			// Since the left subtree was higher, and it
0: 			// shrunk, then this subtree shrunk, too.
0: 			this.subtreeShrunk = true;
0: 		}
0: 		else // thisNode.balance == 0
0: 		{
0: 			// Tree became acceptably unbalanced
0: 			thisNode.balance = 1;
0: 
0: 			// We had a balanced tree, and just the left
0: 			// subtree shrunk, so this subtree as a whole
0: 			// has not changed in height.
0: 			this.subtreeShrunk = false;
0: 		}
0: 
0: 		// We have not rearranged this subtree.
0: 		return thisNode;
0: 	}
0: 
0: 	/**
0: 	Perform either a single or double rotation, as appropriate, 
0: 	to get the subtree 'thisNode' back in balance, assuming
0: 	that the right subtree of 'thisNode' is higher than the
0: 	left subtree.  Returns the node that should be the new
0: 	root of the subtree.
0: 	<P>
0: 	These are the cases depicted in diagrams (1) and (2) of
0: 	Knuth (p. 454), and the node names reflect these diagrams.
0: 	However, in deletion, the single rotation may encounter
0: 	a case where the "beta" and "gamma" subtrees are the same
0: 	height (b.balance == 0), so the resulting does not always
0: 	shrink.
0: 	<P>
0:     Note: This code will not do the "mirror image" cases.
0: 	It only works when the right subtree is the higher one
0: 	(this is the only case encountered when deleting leftmost
0: 	nodes from the tree).
0: 	**/
0: 	private Node rotateRight(Node thisNode)
0: 	{
0: 		Node a = thisNode;
0: 		Node b = thisNode.rightLink;
0: 
0: 		if (b.balance >= 0)
0: 		{
0: 			// single rotation
0: 
0: 			a.rightLink = b.leftLink;
0: 			b.leftLink = a;
0: 
0: 			if (b.balance == 0)
0: 			{
0: 				a.balance = 1;
0: 				b.balance = -1;
0: 				this.subtreeShrunk = false;
0: 			}
0: 			else // b.balance == 1
0: 			{
0: 				a.balance = 0;
0: 				b.balance = 0;
0: 				this.subtreeShrunk = true;
0: 			}
0: 
0: 			return b;
0: 		}
0: 		else // b.balance == -1
0: 		{
0: 			// double rotation
0: 
0: 			Node x = b.leftLink;
0: 
0: 			a.rightLink = x.leftLink;
0: 			x.leftLink = a;
0: 			b.leftLink = x.rightLink;
0: 			x.rightLink = b;
0: 
0: 			if (x.balance == 1)
0: 			{
0: 				a.balance = -1;
0: 				b.balance = 0;
0: 			}
0: 			else if (x.balance == -1)
0: 			{
0: 				a.balance = 0;
0: 				b.balance = 1;
0: 			}
0: 			else // x.balance == 0
0: 			{
0: 				a.balance = 0;
0: 				b.balance = 0;
0: 			}
0: 			x.balance = 0;
0: 
0: 			this.subtreeShrunk = true;
0: 
0: 			return x;
0: 		}
0: 	}
0: 
0: 	public void check()
0: 	{
0:         if (SanityManager.DEBUG)
0:         {
0:             String error = null;
0:             if (head.rightLink == null)
0:             {
0:                 if (height != 0)
0:                     error = "empty tree with height " + height;
0:             } 
0:             else
0:             {
0:                 if (depth(head.rightLink) != height)
0:                     error = "tree height " + height + " != depth " + depth(head.rightLink);
0:                 else
0:                     error = checkNode(head.rightLink);
0:             }
0:             if (error != null)
0:             {
0:                 System.out.println("ERROR: " + error);
0:                 print();
0:                 System.exit(1);
0:             }
0:         }
0: 	}
0: 
0: 	private String checkNode(Node n)
0: 	{
0:         if (SanityManager.DEBUG)
0:         {
0:             if (n == null)
0:                 return null;
0:             int ld = depth(n.leftLink);
0:             int rd = depth(n.rightLink);
0:             if (n.balance != (rd - ld))
0:                 return "node " + n + ": left height " + ld + " right height " + rd;
0:             
0:             String e;
0:             e = checkNode(n.rightLink);
0:             if (e == null)
0:                 e = checkNode(n.leftLink);
0:             return e;
0:         }
0:         else
0:         {
0:             return(null);
0:         }
0: 	}
0: 
0: 	private int depth(Node n)
0: 	{
0: 		int ld = 0;
0: 		int rd = 0;
0: 		if (n == null)
0: 			return 0;
0: 		if (n.leftLink != null)
0: 			ld = depth(n.leftLink);
0: 		if (n.rightLink != null)
0: 			rd = depth(n.rightLink);
0: 		if (rd > ld)
0: 			return rd + 1;
0: 		else
0: 			return ld + 1;
0: 	}
0: 
0: 	public void print()
0: 	{
0: 		Node root = head.rightLink;
0: 		System.out.println("tree height: " + height
0: 			+ " root: " + ((root == null) ? -1 : root.id));
0: 		if (root != null)
0: 			printRecursive(root, 0);
0: 	}
0: 
0: 	private void printRecursive(Node n, int depth)
0: 	{
0: 		if (n.rightLink != null)
0: 			printRecursive(n.rightLink, depth + 1);
0: 		for (int i = 0; i < depth; i++)
0: 			System.out.print("       ");
0: 		System.out.println(n);
0: 		if (n.leftLink != null)
0: 			printRecursive(n.leftLink, depth + 1);
0: 	}
0: 
0: 	private void debug(String s)
0: 	{
0:         if (SanityManager.DEBUG)
0:         {
0:             System.out.println(" === [" + s + "] ===");
0:         }
0: 	}
0: }
============================================================================