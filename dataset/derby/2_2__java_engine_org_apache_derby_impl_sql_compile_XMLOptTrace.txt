1:b6cc9d7: /*
26:b6cc9d7: 
1:b6cc9d7:    Derby - Class org.apache.derby.impl.sql.compile.XMLOptTrace
1:b6cc9d7: 
1:b6cc9d7:    Licensed to the Apache Software Foundation (ASF) under one or more
1:b6cc9d7:    contributor license agreements.  See the NOTICE file distributed with
1:b6cc9d7:    this work for additional information regarding copyright ownership.
1:b6cc9d7:    The ASF licenses this file to you under the Apache License, Version 2.0
1:b6cc9d7:    (the "License"); you may not use this file except in compliance with
1:b6cc9d7:    the License.  You may obtain a copy of the License at
1:b6cc9d7: 
1:b6cc9d7:       http://www.apache.org/licenses/LICENSE-2.0
1:b6cc9d7: 
1:b6cc9d7:    Unless required by applicable law or agreed to in writing, software
1:b6cc9d7:    distributed under the License is distributed on an "AS IS" BASIS,
1:b6cc9d7:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b6cc9d7:    See the License for the specific language governing permissions and
1:b6cc9d7:    limitations under the License.
1:b6cc9d7: 
2:b6cc9d7:  */
1:b6cc9d7: package org.apache.derby.impl.sql.compile;
1:b6cc9d7: 
1:b6cc9d7: import java.io.PrintWriter;
1:b6cc9d7: import java.util.Date;
1:3c3e7db: import java.util.Stack;
1:b6cc9d7: import javax.xml.parsers.DocumentBuilderFactory;
1:b6cc9d7: import javax.xml.parsers.ParserConfigurationException;
1:b6cc9d7: import javax.xml.transform.OutputKeys;
1:b6cc9d7: import javax.xml.transform.Transformer;
1:b6cc9d7: import javax.xml.transform.TransformerFactory;
1:b6cc9d7: import javax.xml.transform.dom.DOMSource;
1:b6cc9d7: import javax.xml.transform.stream.StreamResult;
1:b6cc9d7: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:b6cc9d7: import org.apache.derby.iapi.services.monitor.Monitor;
1:b6cc9d7: import org.apache.derby.iapi.sql.compile.AccessPath;
1:b6cc9d7: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:b6cc9d7: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1:b6cc9d7: import org.apache.derby.iapi.sql.compile.OptTrace;
1:b6cc9d7: import org.apache.derby.iapi.sql.compile.Optimizable;
1:b6cc9d7: import org.apache.derby.iapi.sql.compile.OptimizableList;
1:b6cc9d7: import org.apache.derby.iapi.sql.compile.Optimizer;
1:23e89eb: import org.apache.derby.iapi.sql.compile.OptimizerPlan;
1:b6cc9d7: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1:23e89eb: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:a8f9739: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1:a8f9739: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:b6cc9d7: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:23e89eb: import org.apache.derby.iapi.sql.dictionary.UniqueTupleDescriptor;
1:a8f9739: import org.apache.derby.iapi.util.IdUtil;
1:b6cc9d7: import org.apache.derby.iapi.util.JBitSet;
1:b6cc9d7: import org.w3c.dom.Document;
1:b6cc9d7: import org.w3c.dom.Element;
1:b6cc9d7: 
2:b6cc9d7: /**
1:b6cc9d7:  * Optimizer tracer which produces output in an xml format.
1:b6cc9d7:  */
1:bbd2a01: class   XMLOptTrace implements  OptTrace
9:b6cc9d7: {
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
3:b6cc9d7:     //
1:b6cc9d7:     //	CONSTANTS
1:b6cc9d7:     //
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
1:23e89eb: 
1:b6cc9d7:     // statement tags
1:b6cc9d7:     private static  final   String  STMT = "statement";
1:b6cc9d7:     private static  final   String  STMT_ID = "stmtID";
1:b6cc9d7:     private static  final   String  STMT_TEXT = "stmtText";
1:866d96b: 
1:b6cc9d7:     // query block tags
1:b6cc9d7:     private static  final   String  QBLOCK = "queryBlock";
1:b6cc9d7:     private static  final   String  QBLOCK_OPTIMIZER_ID = "qbOptimizerID";
1:b6cc9d7:     private static  final   String  QBLOCK_START_TIME = "qbStartTime";
1:b6cc9d7:     private static  final   String  QBLOCK_ID = "qbID";
1:b6cc9d7:     private static  final   String  QBLOCK_OPTIMIZABLE = "qbOptimizable";
1:b6cc9d7:     private static  final   String  QBLOCK_OPT_TABLE_NUMBER = "qboTableNumber";
1:b6cc9d7:     private static  final   String  QBLOCK_TIMEOUT = "qbTimeout";
1:b6cc9d7:     private static  final   String  QBLOCK_VACUOUS = "qbVacuous";
1:b6cc9d7:     private static  final   String  QBLOCK_SORT_COST = "qbSortCost";
1:b6cc9d7:     private static  final   String  QBLOCK_TOTAL_COST = "qbTotalCost";
1:b6cc9d7:     private static  final   String  QBLOCK_NO_BEST_PLAN = "qbNoBestPlan";
1:b6cc9d7:     private static  final   String  QBLOCK_SKIP = "qbSkip";
1:b6cc9d7: 
1:b6cc9d7:     // join order tags
1:b6cc9d7:     private static  final   String  JO = "joinOrder";
1:b6cc9d7:     private static  final   String  JO_COMPLETE = "joComplete";
1:b6cc9d7:     private static  final   String  JO_SLOT = "joSlot";
1:b6cc9d7: 
1:b6cc9d7:     // decoration tags
1:b6cc9d7:     private static  final   String  DECORATION = "decoration";
1:b6cc9d7:     private static  final   String  DECORATION_CONGLOM_NAME = "decConglomerateName";
1:b6cc9d7:     private static  final   String  DECORATION_KEY = "decKey";
1:b6cc9d7:     private static  final   String  DECORATION_TABLE_NAME = "decTableName";
1:b6cc9d7:     private static  final   String  DECORATION_JOIN_STRATEGY = "decJoinStrategy";
1:b6cc9d7:     private static  final   String  DECORATION_SKIP = "decSkip";
1:b6cc9d7:     private static  final   String  DECORATION_CONGLOM_COST = "decConglomerateCost";
1:b6cc9d7:     private static  final   String  DECORATION_FIRST_COLUMN_SELECTIVITY = "decExtraFirstColumnPreds";
1:b6cc9d7:     private static  final   String  DECORATION_EXTRA_START_STOP_SELECTIVITY = "decExtraFirstStartStopPreds";
1:b6cc9d7:     private static  final   String  DECORATION_START_STOP_SELECTIVITY = "decStartStopPred";
1:b6cc9d7:     private static  final   String  DECORATION_EXTRA_QUALIFIERS = "decExtraQualifiers";
1:b6cc9d7:     private static  final   String  DECORATION_EXTRA_NON_QUALIFIERS = "decExtraNonQualifiers";
1:b6cc9d7: 
1:b6cc9d7:     // skip tags
1:b6cc9d7:     private static  final   String  SKIP_REASON = "skipReason";
1:b6cc9d7: 
1:b6cc9d7:     // plan cost tags
1:b6cc9d7:     private static  final   String  PC = "planCost";
1:b6cc9d7:     private static  final   String  PC_TYPE = "pcType";
1:b6cc9d7:     private static  final   String  PC_COMPLETE = "pcComplete";
1:b6cc9d7:     private static  final   String  PC_AVOID_SORT= "pcAvoidSort";
1:b6cc9d7:     private static  final   String  PC_SUMMARY= "pcSummary";
1:b6cc9d7: 
1:b6cc9d7:     // CostEstimate tags
1:b6cc9d7:     private static  final   String  CE_ESTIMATED_COST = "ceEstimatedCost";
1:b6cc9d7:     private static  final   String  CE_ROW_COUNT = "ceEstimatedRowCount";
1:b6cc9d7:     private static  final   String  CE_SINGLE_SCAN_ROW_COUNT = "ceSingleScanRowCount";
1:b6cc9d7: 
1:b6cc9d7:     // selectivity tags
1:b6cc9d7:     private static  final   String  SEL_COUNT = "selCount";
1:b6cc9d7:     private static  final   String  SEL_SELECTIVITY = "selSelectivity";
1:b6cc9d7: 
1:a8f9739:     // distinguish table function names from conglomerate names
1:a8f9739:     private static  final   String  TABLE_FUNCTION_FLAG = "()";
1:a8f9739:     
1:b6cc9d7:     //
1:b6cc9d7:     // Statement and view for declaring a table function which reads the planCost element.
1:b6cc9d7:     // This table function is an instance of the XmlVTI and assumes that you have
1:b6cc9d7:     // already declared an ArrayList user-type and an asList factory function for it.
1:b6cc9d7:     //
1:b6cc9d7:     static  final   String  PLAN_COST_VTI =
1:b6cc9d7:         "create function planCost\n" +
1:b6cc9d7:         "(\n" +
1:b6cc9d7:         "    xmlResourceName varchar( 32672 ),\n" +
1:b6cc9d7:         "    rowTag varchar( 32672 ),\n" +
1:b6cc9d7:         "    parentTags ArrayList,\n" +
1:b6cc9d7:         "    childTags ArrayList\n" +
1:b6cc9d7:         ")\n" +
1:b6cc9d7:         "returns table\n" +
1:b6cc9d7:         "(\n" +
1:b6cc9d7:         "    text varchar( 32672 ),\n" +
1:b6cc9d7:         "    stmtID    int,\n" +
1:b6cc9d7:         "    qbID   int,\n" +
1:b6cc9d7:         "    complete  boolean,\n" +
1:b6cc9d7:         "    summary   varchar( 32672 ),\n" +
1:b6cc9d7:         "    type        varchar( 50 ),\n" +
1:b6cc9d7:         "    estimatedCost        double,\n" +
1:b6cc9d7:         "    estimatedRowCount    bigint\n" +
1:b6cc9d7:         ")\n" +
1:b6cc9d7:         "language java parameter style derby_jdbc_result_set no sql\n" +
1:b6cc9d7:         "external name 'org.apache.derby.vti.XmlVTI.xmlVTI'\n";
1:b6cc9d7: 
1:b6cc9d7:     static  final   String  PLAN_COST_VIEW =
1:b6cc9d7:         "create view planCost as\n" +
1:b6cc9d7:         "select *\n" +
1:b6cc9d7:         "from table\n" +
1:b6cc9d7:         "(\n" +
1:b6cc9d7:         "    planCost\n" +
1:b6cc9d7:         "    (\n" +
1:b6cc9d7:         "        'FILE_URL',\n" +
1:b6cc9d7:         "        'planCost',\n" +
1:b6cc9d7:         "        asList( '" + STMT_TEXT + "', '" + STMT_ID + "', '" + QBLOCK_ID + "' ),\n" +
1:23e89eb:         "        asList( '" + PC_COMPLETE + "', '" + PC_SUMMARY + "', '" + PC_TYPE + "', '" +
1:b6cc9d7:         CE_ESTIMATED_COST + "', '" + CE_ROW_COUNT + "' )\n" +
1:b6cc9d7:         "     )\n" +
1:b6cc9d7:         ") v\n";
1:b6cc9d7:         
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
1:b6cc9d7:     //
1:3c3e7db:     //	NESTED CLASSES
1:3c3e7db:     //
1:3c3e7db:     ////////////////////////////////////////////////////////////////////////
1:3c3e7db: 
1:3c3e7db:     public  static  final   class   QueryBlock
1:3c3e7db:     {
1:3c3e7db:         final   int                 queryBlockID;
1:3c3e7db:         final   OptimizableList optimizableList;
1:3c3e7db:         final   Element         queryBlockElement;
1:3c3e7db:         
1:3c3e7db:         Element         currentJoinsElement;
1:3c3e7db:         int[]              currentJoinOrder;
1:3c3e7db:         Element         currentBestPlan;
1:3c3e7db: 
1:3c3e7db:         // reset per join order
1:3c3e7db:         JoinStrategy    currentDecorationStrategy;
1:3c3e7db:         Element         currentDecoration;
1:3c3e7db: 
1:3c3e7db:         public  QueryBlock
1:3c3e7db:             (
1:3c3e7db:              int    queryBlockID,
1:3c3e7db:              OptimizableList    optimizableList,
1:3c3e7db:              Element    queryBlockElement
1:3c3e7db:              )
1:3c3e7db:         {
1:3c3e7db:             this.queryBlockID = queryBlockID;
1:3c3e7db:             this.optimizableList = optimizableList;
1:3c3e7db:             this.queryBlockElement = queryBlockElement;
1:3c3e7db:         }
1:3c3e7db:     }
1:3c3e7db: 
1:3c3e7db:     ////////////////////////////////////////////////////////////////////////
1:3c3e7db:     //
1:b6cc9d7:     //	STATE
1:b6cc9d7:     //
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
1:a8f9739: 
1:b6cc9d7:     private Document    _doc;
1:b6cc9d7:     private Element         _root;
1:b6cc9d7:     
1:b6cc9d7:     private Element         _currentStatement;
1:b6cc9d7:     private int                 _currentStatementID;
1:3c3e7db:     private QueryBlock      _currentQueryBlock;
1:3c3e7db:     private int                 _maxQueryID;
1:b6cc9d7: 
1:b6cc9d7: 
1:3c3e7db:     // pushed and popped on query block boundaries
1:3c3e7db:     private Stack<QueryBlock>  _queryBlockStack;
1:b6cc9d7: 
1:23e89eb:     // context
1:23e89eb:     private ContextManager  _cm;
1:23e89eb:     private LanguageConnectionContext   _lcc;
1:23e89eb: 
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
1:b6cc9d7:     //
1:b6cc9d7:     //	CONSTRUCTOR
1:b6cc9d7:     //
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
1:b6cc9d7: 
1:b6cc9d7:     /** 0-arg constructor required by OptTrace contract */
1:b6cc9d7:     public  XMLOptTrace()
1:b6cc9d7:         throws ParserConfigurationException
1:23e89eb:     {
1:b6cc9d7:         _doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
1:b6cc9d7:         _root = createElement( null, "optimizerTrace", null );
1:b6cc9d7:         _doc.appendChild( _root );
1:a8f9739:     }
1:b6cc9d7: 
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
1:b6cc9d7:     //
1:b6cc9d7:     //	BEHAVIOR
1:b6cc9d7:     //
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
1:b6cc9d7: 
1:b6cc9d7:     public  void    traceStartStatement( String statementText )
1:a8f9739:     {
1:b6cc9d7:         _currentStatementID++;
1:3c3e7db:         _maxQueryID = 0;
1:3c3e7db:         _currentQueryBlock = null;
1:3c3e7db:         _queryBlockStack = new Stack<QueryBlock>();
1:b6cc9d7:         
1:b6cc9d7:         _currentStatement = createElement( _root, STMT, null );
1:b6cc9d7:         _currentStatement .setAttribute( STMT_ID, Integer.toString( _currentStatementID ) );
1:b6cc9d7: 
1:b6cc9d7:         createElement( _currentStatement, STMT_TEXT, statementText );
10:b6cc9d7:     }
1:b6cc9d7:     
1:3c3e7db:     public  void    traceStartQueryBlock( long timeOptimizationStarted, int optimizerID, OptimizableList optimizableList )
1:b6cc9d7:     {
1:3c3e7db:         _maxQueryID++;
1:3c3e7db:         if ( _currentQueryBlock != null ) { _queryBlockStack.push( _currentQueryBlock ); }
1:b6cc9d7: 
1:3c3e7db:         Element queryElement = createElement( _currentStatement, QBLOCK, null );
1:3c3e7db:         queryElement.setAttribute( QBLOCK_OPTIMIZER_ID, Integer.toString( optimizerID ) );
1:3c3e7db:         queryElement.setAttribute( QBLOCK_START_TIME, formatTimestamp( timeOptimizationStarted ) );
1:3c3e7db:         queryElement.setAttribute( QBLOCK_ID, Integer.toString( _maxQueryID ) );
1:b6cc9d7: 
1:3c3e7db:         _currentQueryBlock = new QueryBlock( _maxQueryID, optimizableList, queryElement );
1:b6cc9d7: 
1:3c3e7db:         if ( optimizableList != null )
1:b6cc9d7:         {
1:3c3e7db:             for ( int i = 0; i < optimizableList.size(); i++ )
1:b6cc9d7:             {
1:3c3e7db:                 Optimizable opt = optimizableList.getOptimizable( i );
1:b6cc9d7: 
1:3c3e7db:                 if ( _cm == null )
1:b6cc9d7:                 {
1:23e89eb:                     _cm = ((QueryTreeNode) opt).getContextManager();
1:23e89eb:                     _lcc = (LanguageConnectionContext) _cm.getContext( LanguageConnectionContext.CONTEXT_ID );
1:23e89eb:                 }
1:23e89eb:                 
1:a8f9739:                 Element optElement = createElement
1:3c3e7db:                     ( queryElement, QBLOCK_OPTIMIZABLE, getOptimizableName( opt ).getFullSQLName() );
1:b6cc9d7:                 optElement.setAttribute( QBLOCK_OPT_TABLE_NUMBER, Integer.toString( opt.getTableNumber() ) );
1:b6cc9d7:             }
1:b6cc9d7:         }
1:b6cc9d7:     }
1:b6cc9d7:     
1:3c3e7db:     public  void    traceEndQueryBlock()
1:3c3e7db:     {
1:3c3e7db:         if ( _queryBlockStack.size() > 0 )
1:3c3e7db:         {
1:3c3e7db:             _currentQueryBlock = _queryBlockStack.pop();
1:3c3e7db:         }
1:3c3e7db:     }
1:3c3e7db: 
1:b6cc9d7:     public  void    traceTimeout( long currentTime, CostEstimate bestCost )
1:b6cc9d7:     {
1:3c3e7db:         Element timeout = createElement( _currentQueryBlock.queryBlockElement, QBLOCK_TIMEOUT, null );
1:b6cc9d7:         formatCost( timeout, bestCost );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceVacuous()
1:b6cc9d7:     {
1:3c3e7db:         createElement( _currentQueryBlock.queryBlockElement, QBLOCK_VACUOUS, null );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceCompleteJoinOrder()
1:b6cc9d7:     {
1:3c3e7db:         if ( _currentQueryBlock.currentJoinsElement != null )
1:3c3e7db:         { _currentQueryBlock.currentJoinsElement.setAttribute( JO_COMPLETE, "true" ); }
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceSortCost( CostEstimate sortCost, CostEstimate currentCost )
1:b6cc9d7:     {
1:3c3e7db:         Element sc = createElement( _currentQueryBlock.queryBlockElement, QBLOCK_SORT_COST, null );
1:b6cc9d7:         formatCost( sc, sortCost );
1:b6cc9d7:             
1:3c3e7db:         Element tcis = createElement( _currentQueryBlock.queryBlockElement, QBLOCK_TOTAL_COST, null );
1:b6cc9d7:         formatCost( tcis, currentCost );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceNoBestPlan()
1:b6cc9d7:     {
1:3c3e7db:         createElement( _currentQueryBlock.queryBlockElement, QBLOCK_NO_BEST_PLAN, null );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceModifyingAccessPaths( int optimizerID ) {}
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceShortCircuiting( boolean timeExceeded, Optimizable thisOpt, int joinPosition ) {}
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceSkippingJoinOrder( int nextOptimizable, int joinPosition, int[] proposedJoinOrder, JBitSet assignedTableMap )
1:b6cc9d7:     {
1:3c3e7db:         Optimizable opt = _currentQueryBlock.optimizableList.getOptimizable( nextOptimizable );
1:b6cc9d7: 
1:b6cc9d7:         Element skip = formatSkip
1:b6cc9d7:             (
1:3c3e7db:              _currentQueryBlock.queryBlockElement, QBLOCK_SKIP,
1:a8f9739:              "Useless join order. " + getOptimizableName( opt ).getFullSQLName() + " depends on tables after it in the join order"
1:b6cc9d7:              );
1:b6cc9d7:         formatJoinOrder( skip, proposedJoinOrder );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceIllegalUserJoinOrder() {}
1:b6cc9d7:     public  void    traceUserJoinOrderOptimized() {}
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceJoinOrderConsideration( int joinPosition, int[] proposedJoinOrder, JBitSet assignedTableMap )
1:b6cc9d7:     {
1:3c3e7db:         _currentQueryBlock.currentJoinsElement = createElement( _currentQueryBlock.queryBlockElement, JO, null );
1:3c3e7db:         _currentQueryBlock.currentJoinOrder = proposedJoinOrder;
1:b6cc9d7: 
1:3c3e7db:         _currentQueryBlock.currentDecorationStrategy = null;
1:3c3e7db:         _currentQueryBlock.currentDecoration = null;
1:b6cc9d7: 
1:3c3e7db:         formatJoinOrder( _currentQueryBlock.currentJoinsElement, proposedJoinOrder );
1:b6cc9d7:     }
1:b6cc9d7: 
1:b6cc9d7:     public  void    traceCostWithoutSortAvoidance( CostEstimate currentCost )
1:b6cc9d7:     {
1:b6cc9d7:         formatPlanCost
1:b6cc9d7:             (
1:3c3e7db:              _currentQueryBlock.currentJoinsElement, "withoutSortAvoidance",
1:3c3e7db:              _currentQueryBlock.currentJoinOrder, Optimizer.NORMAL_PLAN, currentCost
1:b6cc9d7:              );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceCostWithSortAvoidance( CostEstimate currentSortAvoidanceCost )
1:b6cc9d7:     {
1:b6cc9d7:         formatPlanCost
1:b6cc9d7:             (
1:3c3e7db:              _currentQueryBlock.currentJoinsElement, "withSortAvoidance",
1:3c3e7db:              _currentQueryBlock.currentJoinOrder, Optimizer.SORT_AVOIDANCE_PLAN, currentSortAvoidanceCost
1:b6cc9d7:              );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceCurrentPlanAvoidsSort( CostEstimate bestCost, CostEstimate currentSortAvoidanceCost ) {}
1:b6cc9d7:     public  void    traceCheapestPlanSoFar( int planType, CostEstimate currentCost ) {}
1:b6cc9d7:     public  void    traceSortNeededForOrdering( int planType, RequiredRowOrdering requiredRowOrdering ) {}
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceRememberingBestJoinOrder
1:b6cc9d7:         ( int joinPosition, int[] bestJoinOrder, int planType, CostEstimate planCost, JBitSet assignedTableMap )
1:b6cc9d7:     {
1:3c3e7db:         if ( _currentQueryBlock.currentBestPlan != null )
1:3c3e7db:         { _currentQueryBlock.queryBlockElement.removeChild( _currentQueryBlock.currentBestPlan ); }
1:3c3e7db:         _currentQueryBlock.currentBestPlan = formatPlanCost
1:3c3e7db:             ( _currentQueryBlock.queryBlockElement, "bestPlan", bestJoinOrder, planType, planCost );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceSkippingBecauseTooMuchMemory( int maxMemoryPerTable )
1:b6cc9d7:     {
1:3c3e7db:         formatSkip
1:3c3e7db:             ( _currentQueryBlock.currentDecoration, DECORATION_SKIP, "Exceeds limit on memory per table: " + maxMemoryPerTable );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceCostOfNScans( int tableNumber, double rowCount, CostEstimate cost ) {}
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceSkipUnmaterializableHashJoin()
1:b6cc9d7:     {
1:3c3e7db:         formatSkip
1:3c3e7db:             ( _currentQueryBlock.currentDecoration, DECORATION_SKIP, "Hash strategy not possible because table is not materializable" );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceSkipHashJoinNoHashKeys()
1:b6cc9d7:     {
1:3c3e7db:         formatSkip( _currentQueryBlock.currentDecoration, DECORATION_SKIP, "No hash keys" );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceHashKeyColumns( int[] hashKeyColumns ) {}
1:b6cc9d7:     public  void    traceOptimizingJoinNode() {}
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceConsideringJoinStrategy( JoinStrategy js, int tableNumber )
1:b6cc9d7:     {
1:3c3e7db:         _currentQueryBlock.currentDecorationStrategy = js;
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceRememberingBestAccessPath( AccessPath accessPath, int tableNumber, int planType ) {}
1:b6cc9d7:     public  void    traceNoMoreConglomerates( int tableNumber ) {}
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceConsideringConglomerate( ConglomerateDescriptor cd, int tableNumber )
1:b6cc9d7:     {
1:b6cc9d7:         Optimizable opt = getOptimizable( tableNumber );
1:b6cc9d7:         
1:3c3e7db:         _currentQueryBlock.currentDecoration = createElement( _currentQueryBlock.currentJoinsElement, DECORATION, null );
1:b6cc9d7: 
1:3c3e7db:         _currentQueryBlock.currentDecoration.setAttribute( DECORATION_CONGLOM_NAME, cd.getConglomerateName() );
1:3c3e7db:         _currentQueryBlock.currentDecoration.setAttribute( DECORATION_TABLE_NAME, getOptimizableName( opt ).toString() );
1:3c3e7db:         _currentQueryBlock.currentDecoration.setAttribute
1:3c3e7db:             ( DECORATION_JOIN_STRATEGY, _currentQueryBlock.currentDecorationStrategy.getName() );
1:b6cc9d7:         
2:b6cc9d7: 		String[]	columnNames = cd.getColumnNames();
1:b6cc9d7: 
1:b6cc9d7: 		if ( cd.isIndex() && (columnNames != null) )
1:b6cc9d7: 		{
2:b6cc9d7: 			int[]   keyColumns = cd.getIndexDescriptor().baseColumnPositions();
1:b6cc9d7: 
2:b6cc9d7:             for ( int i = 0; i < keyColumns.length; i++ )
1:b6cc9d7:             {
1:3c3e7db:                 createElement( _currentQueryBlock.currentDecoration, DECORATION_KEY, columnNames[ keyColumns[ i ] - 1 ] );
1:b6cc9d7:             }
1:b6cc9d7: 		}
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceScanningHeapWithUniqueKey() {}
1:b6cc9d7:     public  void    traceAddingUnorderedOptimizable( int predicateCount ) {}
1:b6cc9d7:     public  void    traceChangingAccessPathForTable( int tableNumber ) {}
1:b6cc9d7:     public  void    traceNoStartStopPosition() {}
1:b6cc9d7:     public  void    traceNonCoveringIndexCost( double cost, int tableNumber ) {}
1:b6cc9d7:     public  void    traceConstantStartStopPositions() {}
1:b6cc9d7:     public  void    traceEstimatingCostOfConglomerate( ConglomerateDescriptor cd, int tableNumber ) {}
1:b6cc9d7:     public  void    traceLookingForSpecifiedIndex( String indexName, int tableNumber ) {}
1:b6cc9d7:     public  void    traceSingleMatchedRowCost( double cost, int tableNumber ) {}
1:b6cc9d7:     public  void    traceCostIncludingExtra1stColumnSelectivity( CostEstimate cost, int tableNumber ) {}
1:b6cc9d7:     public  void    traceNextAccessPath( String baseTable, int predicateCount ) {}
1:b6cc9d7:     public  void    traceCostIncludingExtraStartStop( CostEstimate cost, int tableNumber ) {}
1:b6cc9d7:     public  void    traceCostIncludingExtraQualifierSelectivity( CostEstimate cost, int tableNumber ) {}
1:b6cc9d7:     public  void    traceCostIncludingExtraNonQualifierSelectivity( CostEstimate cost, int tableNumber ) {}
1:b6cc9d7:     public  void    traceCostOfNoncoveringIndex( CostEstimate cost, int tableNumber ) {}
1:b6cc9d7:     public  void    traceRememberingJoinStrategy( JoinStrategy joinStrategy, int tableNumber ) {}
1:b6cc9d7:     public  void    traceRememberingBestAccessPathSubstring( AccessPath ap, int tableNumber ) {}
1:b6cc9d7:     public  void    traceRememberingBestSortAvoidanceAccessPathSubstring( AccessPath ap, int tableNumber ) {}
1:b6cc9d7:     public  void    traceRememberingBestUnknownAccessPathSubstring( AccessPath ap, int tableNumber ) {}
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceCostOfConglomerateScan
1:b6cc9d7:         (
1:b6cc9d7:          int    tableNumber,
1:b6cc9d7:          ConglomerateDescriptor cd,
1:b6cc9d7:          CostEstimate   costEstimate,
1:b6cc9d7:          int    numExtraFirstColumnPreds,
1:b6cc9d7:          double    extraFirstColumnSelectivity,
1:b6cc9d7:          int    numExtraStartStopPreds,
1:b6cc9d7:          double    extraStartStopSelectivity,
1:b6cc9d7:          int    startStopPredCount,
1:b6cc9d7:          double    statStartStopSelectivity,
1:b6cc9d7:          int    numExtraQualifiers,
1:b6cc9d7:          double    extraQualifierSelectivity,
1:b6cc9d7:          int    numExtraNonQualifiers,
1:b6cc9d7:          double    extraNonQualifierSelectivity
1:b6cc9d7:          )
1:b6cc9d7:     {
1:3c3e7db:         Element cost = createElement( _currentQueryBlock.currentDecoration, DECORATION_CONGLOM_COST, null );
1:b6cc9d7:         cost.setAttribute( "name", cd.getConglomerateName() );
1:b6cc9d7: 
1:b6cc9d7:         formatCost( cost, costEstimate );
1:b6cc9d7:         formatSelectivity( cost, DECORATION_FIRST_COLUMN_SELECTIVITY, numExtraFirstColumnPreds, extraFirstColumnSelectivity );
1:b6cc9d7:         formatSelectivity( cost, DECORATION_EXTRA_START_STOP_SELECTIVITY, numExtraStartStopPreds, extraStartStopSelectivity );
1:b6cc9d7:         formatSelectivity( cost, DECORATION_START_STOP_SELECTIVITY, startStopPredCount, statStartStopSelectivity );
1:b6cc9d7:         formatSelectivity( cost, DECORATION_EXTRA_QUALIFIERS, numExtraQualifiers, extraQualifierSelectivity );
1:b6cc9d7:         formatSelectivity( cost, DECORATION_EXTRA_NON_QUALIFIERS, numExtraNonQualifiers, extraNonQualifierSelectivity );
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     public  void    traceCostIncludingCompositeSelectivityFromStats( CostEstimate cost, int tableNumber ) {}
1:b6cc9d7:     public  void    traceCompositeSelectivityFromStatistics( double statCompositeSelectivity ) {}
1:b6cc9d7:     public  void    traceCostIncludingStatsForIndex( CostEstimate cost, int tableNumber ) {}
1:b6cc9d7: 
1:b6cc9d7:     public  void    printToWriter( PrintWriter out )
1:b6cc9d7:     {
2:b6cc9d7:         try {
1:b6cc9d7:             TransformerFactory transformerFactory = TransformerFactory.newInstance();
1:b6cc9d7:             Transformer transformer = transformerFactory.newTransformer();
1:b6cc9d7:             DOMSource source = new DOMSource( _doc );
1:b6cc9d7:             StreamResult result = new StreamResult( out );
1:b6cc9d7: 
1:b6cc9d7:             // pretty-print
1:b6cc9d7:             transformer.setOutputProperty( OutputKeys.OMIT_XML_DECLARATION, "no" );
1:b6cc9d7:             transformer.setOutputProperty( OutputKeys.METHOD, "xml" );
1:b6cc9d7:             transformer.setOutputProperty( OutputKeys.INDENT, "yes" );
1:b6cc9d7:             transformer.setOutputProperty( OutputKeys.ENCODING, "UTF-8" );
1:b6cc9d7:             transformer.setOutputProperty( "{http://xml.apache.org/xslt}indent-amount", "4" );
1:b6cc9d7:             
1:b6cc9d7:             transformer.transform( source, result );
1:b6cc9d7:             
1:b6cc9d7:         }   catch (Throwable t) { printThrowable( t ); }
1:b6cc9d7:     }
1:b6cc9d7: 
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
1:b6cc9d7:     //
1:b6cc9d7:     //	MINIONS
1:b6cc9d7:     //
1:b6cc9d7:     ////////////////////////////////////////////////////////////////////////
1:b6cc9d7: 
1:b6cc9d7:     /** Get the Optimizable with the given tableNumber */
1:b6cc9d7:     private Optimizable getOptimizable( int tableNumber )
1:b6cc9d7:     {
1:3c3e7db:         for ( int i = 0; i < _currentQueryBlock.optimizableList.size(); i++ )
1:b6cc9d7:         {
1:3c3e7db:             Optimizable candidate = _currentQueryBlock.optimizableList.getOptimizable( i );
1:b6cc9d7:             
1:b6cc9d7:             if ( tableNumber == candidate.getTableNumber() )    { return candidate; }
1:b6cc9d7:         }
1:b6cc9d7: 
1:b6cc9d7:         return null;
1:b6cc9d7:     }
1:b6cc9d7: 
1:a8f9739:     /** Get the name of an optimizable */
1:a8f9739:     private TableName    getOptimizableName( Optimizable optimizable )
1:b6cc9d7:     {
1:a8f9739:         try {
1:a8f9739:             if ( isBaseTable( optimizable ) )
1:a8f9739:             {
1:b6cc9d7:                 ProjectRestrictNode prn = (ProjectRestrictNode) optimizable;
1:3bb140c:                 TableDescriptor td = 
1:3bb140c:                     ((FromBaseTable) prn.getChildResult()).getTableDescriptor();
1:23e89eb:                 return makeTableName( td.getSchemaName(), td.getName(), _cm );
1:a8f9739:             }
1:a56ecfa:             else if ( OptimizerImpl.isTableFunction( optimizable ) )
1:b6cc9d7:             {
2:3bb140c:                 ProjectRestrictNode prn = (ProjectRestrictNode) optimizable;
1:a8f9739:                 AliasDescriptor ad =
1:3bb140c:                     ((StaticMethodCallNode) ((FromVTI) prn.getChildResult()).
1:3bb140c:                         getMethodCall() ).ad;
1:23e89eb:                 return makeTableName( ad.getSchemaName(), ad.getName(), _cm );
1:a8f9739:             }
1:a8f9739:             else if ( isFromTable( optimizable ) )
1:a8f9739:             {
1:6a270cb:                 TableName   retval = ((FromTable) ((ProjectRestrictNode) optimizable).getChildResult()).getTableName();
1:6a270cb: 
1:6a270cb:                 if ( retval !=  null ) { return retval; }
1:b6cc9d7:             }
1:b6cc9d7:         }
1:a8f9739:         catch (StandardException e)
1:a8f9739:         {
1:a8f9739:             // Technically, an exception could occur here if the table name
1:a8f9739:             // was not previously bound and if an error occured while binding it.
1:a8f9739:             // But the optimizable should have been bound long before optimization,
1:a8f9739:             // so this should not be a problem.
1:b6cc9d7:         }
1:b6cc9d7: 
1:a8f9739:         String  nodeClass = optimizable.getClass().getName();
1:a8f9739:         String  unqualifiedName = nodeClass.substring( nodeClass.lastIndexOf( "." ) + 1 );
1:a8f9739: 
1:23e89eb:         return makeTableName( null, unqualifiedName, _cm );
1:a8f9739:     }
1:a8f9739: 
1:a8f9739:     /** Return true if the optimizable is a base table */
1:a8f9739:     private boolean isBaseTable( Optimizable optimizable )
1:a8f9739:     {
2:a8f9739:         if ( !( optimizable instanceof ProjectRestrictNode ) ) { return false; }
1:a8f9739: 
2:a8f9739:         ResultSetNode   rsn = ((ProjectRestrictNode) optimizable).getChildResult();
1:a8f9739: 
1:a8f9739:         return ( rsn instanceof FromBaseTable );
1:a8f9739:     }
1:a8f9739: 
1:a8f9739:     /** Return true if the optimizable is a FromTable */
1:a8f9739:     private boolean isFromTable( Optimizable optimizable )
1:a8f9739:     {
1:a8f9739:         if ( !( optimizable instanceof ProjectRestrictNode ) ) { return false; }
1:a8f9739: 
1:a8f9739:         ResultSetNode   rsn = ((ProjectRestrictNode) optimizable).getChildResult();
1:a8f9739: 
1:a8f9739:         return ( rsn instanceof FromTable );
1:a8f9739:     }
1:a8f9739: 
1:a8f9739:     /** Make a TableName */
1:3bb140c:     private TableName   makeTableName(
1:3bb140c:             String schemaName, String unqualifiedName, ContextManager cm )
1:a8f9739:     {
1:3bb140c:         TableName result = new TableName(schemaName, unqualifiedName, cm);
1:a8f9739: 
1:a8f9739:         return result;
1:a8f9739:     }
1:a8f9739: 
1:b6cc9d7:     /** Print an exception to the log file */
1:b6cc9d7:     private void    printThrowable( Throwable t )
1:b6cc9d7:     {
1:b6cc9d7:         t.printStackTrace( Monitor.getStream().getPrintWriter() );
1:b6cc9d7:     }
1:a8f9739: 
1:b6cc9d7:     /** Create an element and add it to a parent */
1:b6cc9d7:     private Element createElement( Element parent, String tag, String content )
1:b6cc9d7:     {
1:b6cc9d7:         Element child = null;
1:a8f9739:         
1:b6cc9d7:         try {
1:b6cc9d7:             child = _doc.createElement( tag );
1:b6cc9d7:             if ( parent != null) { parent.appendChild( child ); }
1:b6cc9d7:             if ( content != null ) { child.setTextContent( content ); }
1:b6cc9d7:         }
1:b6cc9d7:         catch (Throwable t) { printThrowable( t ); }
1:b6cc9d7: 
1:b6cc9d7:         return child;
1:b6cc9d7:     }
1:b6cc9d7: 
1:b6cc9d7:     /** Turn a timestamp into a human-readable string */
1:b6cc9d7:     private String  formatTimestamp( long timestamp ) { return (new Date( timestamp )).toString(); }
1:b6cc9d7: 
1:b6cc9d7:     /** Create an element explaining that we're skipping some processing */
1:b6cc9d7:     private Element formatSkip( Element parent, String skipTag, String reason )
1:b6cc9d7:     {
1:b6cc9d7:         Element skip = createElement( parent, skipTag, null );
1:b6cc9d7:         skip.setAttribute( SKIP_REASON, reason );
1:b6cc9d7: 
1:b6cc9d7:         return skip;
1:b6cc9d7:     }
1:b6cc9d7:     
1:b6cc9d7:     /** Turn a CostEstimate for a join order into a human-readable element */
1:b6cc9d7:     private Element formatPlanCost( Element parent, String type, int[] planOrder, int planType, CostEstimate raw )
1:b6cc9d7:     {
1:b6cc9d7:         Element cost = createElement( parent, PC, null );
1:b6cc9d7: 
1:b6cc9d7:         cost.setAttribute( PC_TYPE, type );
1:b6cc9d7:         if ( isComplete( planOrder ) ) { cost.setAttribute( PC_COMPLETE, "true" ); }
1:b6cc9d7:         if ( planType == Optimizer.SORT_AVOIDANCE_PLAN ) { cost.setAttribute( PC_AVOID_SORT, "true" ); }
1:b6cc9d7: 
1:23e89eb:         createElement( cost, PC_SUMMARY, formatPlanSummary( planOrder, planType ) );
1:b6cc9d7:         formatCost( cost, raw );
1:b6cc9d7: 
1:b6cc9d7:         return cost;
1:b6cc9d7:     }
1:b6cc9d7: 
1:b6cc9d7:     /** Return true if the join order has been completely filled in */
1:b6cc9d7:     private boolean isComplete( int[] joinOrder )
1:b6cc9d7:     {
1:b6cc9d7:         if ( joinOrder == null ) { return false; }
1:3c3e7db:         if ( joinOrder.length < _currentQueryBlock.optimizableList.size() ) { return false; }
1:b6cc9d7: 
1:b6cc9d7:         for ( int i = 0; i < joinOrder.length; i++ )
1:b6cc9d7:         {
1:b6cc9d7:             if ( joinOrder[ i ] < 0 ) { return false; }
1:b6cc9d7:         }
1:b6cc9d7: 
1:b6cc9d7:         return true;
1:b6cc9d7:     }
1:b6cc9d7: 
1:b6cc9d7:     /** Format a CostEstimate as subelements of a parent */
1:b6cc9d7:     private void    formatCost( Element costElement, CostEstimate raw )
1:b6cc9d7:     {
1:b6cc9d7:         createElement( costElement, CE_ESTIMATED_COST, Double.toString( raw.getEstimatedCost() ) );
1:b6cc9d7:         createElement( costElement, CE_ROW_COUNT, Long.toString( raw.getEstimatedRowCount() ) );
1:b6cc9d7:         createElement( costElement, CE_SINGLE_SCAN_ROW_COUNT, Double.toString( raw.singleScanRowCount() ) );
1:b6cc9d7:     }
1:b6cc9d7: 
1:b6cc9d7:     /** Format selectivity subelement */
1:b6cc9d7:     private void    formatSelectivity( Element parent, String tag, int count, double selectivity )
1:b6cc9d7:     {
1:b6cc9d7:         Element child = createElement( parent, tag, null );
1:b6cc9d7:         child.setAttribute( SEL_COUNT, Integer.toString( count ) );
1:b6cc9d7:         child.setAttribute( SEL_SELECTIVITY, Double.toString( selectivity ) );
1:b6cc9d7:     }
1:b6cc9d7: 
1:b6cc9d7:     /** Format a join order list */
1:b6cc9d7:     private void    formatJoinOrder( Element parent, int[] proposedJoinOrder )
1:b6cc9d7:     {
1:b6cc9d7:         if ( proposedJoinOrder != null )
1:b6cc9d7:         {
1:b6cc9d7:             for ( int idx = 0; idx < proposedJoinOrder.length; idx++ )
1:b6cc9d7:             {
1:b6cc9d7:                 int     optimizableNumber = proposedJoinOrder[ idx ];
1:b6cc9d7:                 if ( optimizableNumber >= 0 )
1:b6cc9d7:                 {
1:3c3e7db:                     Optimizable optimizable = _currentQueryBlock.optimizableList.getOptimizable( optimizableNumber );
1:a8f9739:                     createElement( parent, JO_SLOT, getOptimizableName( optimizable ).getFullSQLName() );
1:b6cc9d7:                 }
1:b6cc9d7:             }
1:b6cc9d7:         }
1:b6cc9d7:     }
1:b6cc9d7: 
1:b6cc9d7: 
1:b6cc9d7:     /**
2:b6cc9d7:      * <p>
1:b6cc9d7:      * Produce a string representation of the plan being considered now.
1:b6cc9d7:      * The string has the following grammar:
2:b6cc9d7:      * </p>
1:b6cc9d7:      *
1:b6cc9d7:      * <pre>
1:b6cc9d7:      * join :== factor OP factor
1:b6cc9d7:      *
1:b6cc9d7:      * OP :== "*" | "#"
1:b6cc9d7:      *
1:b6cc9d7:      * factor :== factor | conglomerateName
1:b6cc9d7:      * </pre>
1:b6cc9d7:      */
1:23e89eb:     private String  formatPlanSummary( int[] planOrder, int planType )
1:b6cc9d7:     {
1:23e89eb:         try {
1:23e89eb:             OptimizerPlan   plan = null;
1:b6cc9d7:         
1:23e89eb:             StringBuilder   buffer = new StringBuilder();
1:23e89eb:             boolean     avoidSort = (planType == Optimizer.SORT_AVOIDANCE_PLAN);
1:b6cc9d7: 
1:23e89eb:             // a negative optimizable number indicates the end of the plan
1:23e89eb:             int planLength = 0;
1:23e89eb:             for ( ; planLength < planOrder.length; planLength++ )
1:b6cc9d7:             {
1:23e89eb:                 if ( planOrder[ planLength ] < 0 ) { break; }
1:b6cc9d7:             }
1:b6cc9d7: 
1:23e89eb:             for ( int i = 0; i < planLength; i++ )
1:b6cc9d7:             {
1:23e89eb:                 int     listIndex = planOrder[ i ];
1:23e89eb: 
1:3c3e7db:                 if ( listIndex >= _currentQueryBlock.optimizableList.size() )
1:b6cc9d7:                 {
1:23e89eb:                     // should never happen!
1:23e89eb:                     buffer.append( "{ UNKNOWN LIST INDEX " + listIndex + " } " );
1:23e89eb:                     continue;
1:b6cc9d7:                 }
1:23e89eb: 
1:3c3e7db:                 Optimizable optimizable = _currentQueryBlock.optimizableList.getOptimizable( listIndex );
1:b6cc9d7:             
1:23e89eb:                 AccessPath  ap = avoidSort ?
1:23e89eb:                     optimizable.getBestSortAvoidancePath() : optimizable.getBestAccessPath();
1:23e89eb:                 JoinStrategy    js = ap.getJoinStrategy();
1:23e89eb:                 UniqueTupleDescriptor   utd = OptimizerImpl.isTableFunction( optimizable ) ?
1:23e89eb:                     ((StaticMethodCallNode) ((FromVTI) ((ProjectRestrictNode) optimizable).getChildResult()).getMethodCall()).ad :
1:23e89eb:                     ap.getConglomerateDescriptor();
1:23e89eb: 
1:3c3e7db:                 OptimizerPlan   current =   (utd == null) ?
1:3c3e7db:                     new OptimizerPlan.DeadEnd( getOptimizableName( optimizable ).toString() ) :
1:3c3e7db:                     OptimizerPlan.makeRowSource( utd, _lcc.getDataDictionary() );
1:23e89eb: 
1:23e89eb:                 if ( plan != null )
1:23e89eb:                 {
1:23e89eb:                     current = new OptimizerPlan.Join( js, plan, current );
1:23e89eb:                 }
1:23e89eb: 
1:23e89eb:                 plan = current;
1:23e89eb:             }
1:23e89eb: 
1:23e89eb:             return plan.toString();
1:23e89eb:         }
1:23e89eb:         catch (Exception e)
1:23e89eb:         {
1:23e89eb:             return e.getMessage();
1:23e89eb:         }
1:b6cc9d7:     }
1:23e89eb: 
1:b6cc9d7: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:3c3e7db
/////////////////////////////////////////////////////////////////////////
1: import java.util.Stack;
/////////////////////////////////////////////////////////////////////////
1:     //	NESTED CLASSES
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  final   class   QueryBlock
1:     {
1:         final   int                 queryBlockID;
1:         final   OptimizableList optimizableList;
1:         final   Element         queryBlockElement;
1:         
1:         Element         currentJoinsElement;
1:         int[]              currentJoinOrder;
1:         Element         currentBestPlan;
1: 
1:         // reset per join order
1:         JoinStrategy    currentDecorationStrategy;
1:         Element         currentDecoration;
1: 
1:         public  QueryBlock
1:             (
1:              int    queryBlockID,
1:              OptimizableList    optimizableList,
1:              Element    queryBlockElement
1:              )
1:         {
1:             this.queryBlockID = queryBlockID;
1:             this.optimizableList = optimizableList;
1:             this.queryBlockElement = queryBlockElement;
1:         }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
/////////////////////////////////////////////////////////////////////////
1:     private QueryBlock      _currentQueryBlock;
1:     private int                 _maxQueryID;
1:     // pushed and popped on query block boundaries
1:     private Stack<QueryBlock>  _queryBlockStack;
/////////////////////////////////////////////////////////////////////////
1:         _maxQueryID = 0;
1:         _currentQueryBlock = null;
1:         _queryBlockStack = new Stack<QueryBlock>();
1:     public  void    traceStartQueryBlock( long timeOptimizationStarted, int optimizerID, OptimizableList optimizableList )
1:         _maxQueryID++;
1:         if ( _currentQueryBlock != null ) { _queryBlockStack.push( _currentQueryBlock ); }
1:         Element queryElement = createElement( _currentStatement, QBLOCK, null );
1:         queryElement.setAttribute( QBLOCK_OPTIMIZER_ID, Integer.toString( optimizerID ) );
1:         queryElement.setAttribute( QBLOCK_START_TIME, formatTimestamp( timeOptimizationStarted ) );
1:         queryElement.setAttribute( QBLOCK_ID, Integer.toString( _maxQueryID ) );
1:         _currentQueryBlock = new QueryBlock( _maxQueryID, optimizableList, queryElement );
1:         if ( optimizableList != null )
1:             for ( int i = 0; i < optimizableList.size(); i++ )
1:                 Optimizable opt = optimizableList.getOptimizable( i );
1:                 if ( _cm == null )
1:                     ( queryElement, QBLOCK_OPTIMIZABLE, getOptimizableName( opt ).getFullSQLName() );
1:     public  void    traceEndQueryBlock()
1:     {
1:         if ( _queryBlockStack.size() > 0 )
1:         {
1:             _currentQueryBlock = _queryBlockStack.pop();
1:         }
1:     }
1: 
1:         Element timeout = createElement( _currentQueryBlock.queryBlockElement, QBLOCK_TIMEOUT, null );
1:         createElement( _currentQueryBlock.queryBlockElement, QBLOCK_VACUOUS, null );
1:         if ( _currentQueryBlock.currentJoinsElement != null )
1:         { _currentQueryBlock.currentJoinsElement.setAttribute( JO_COMPLETE, "true" ); }
1:         Element sc = createElement( _currentQueryBlock.queryBlockElement, QBLOCK_SORT_COST, null );
1:         Element tcis = createElement( _currentQueryBlock.queryBlockElement, QBLOCK_TOTAL_COST, null );
1:         createElement( _currentQueryBlock.queryBlockElement, QBLOCK_NO_BEST_PLAN, null );
/////////////////////////////////////////////////////////////////////////
1:         Optimizable opt = _currentQueryBlock.optimizableList.getOptimizable( nextOptimizable );
1:              _currentQueryBlock.queryBlockElement, QBLOCK_SKIP,
/////////////////////////////////////////////////////////////////////////
1:         _currentQueryBlock.currentJoinsElement = createElement( _currentQueryBlock.queryBlockElement, JO, null );
1:         _currentQueryBlock.currentJoinOrder = proposedJoinOrder;
1:         _currentQueryBlock.currentDecorationStrategy = null;
1:         _currentQueryBlock.currentDecoration = null;
1:         formatJoinOrder( _currentQueryBlock.currentJoinsElement, proposedJoinOrder );
1:              _currentQueryBlock.currentJoinsElement, "withoutSortAvoidance",
1:              _currentQueryBlock.currentJoinOrder, Optimizer.NORMAL_PLAN, currentCost
/////////////////////////////////////////////////////////////////////////
1:              _currentQueryBlock.currentJoinsElement, "withSortAvoidance",
1:              _currentQueryBlock.currentJoinOrder, Optimizer.SORT_AVOIDANCE_PLAN, currentSortAvoidanceCost
/////////////////////////////////////////////////////////////////////////
1:         if ( _currentQueryBlock.currentBestPlan != null )
1:         { _currentQueryBlock.queryBlockElement.removeChild( _currentQueryBlock.currentBestPlan ); }
1:         _currentQueryBlock.currentBestPlan = formatPlanCost
1:             ( _currentQueryBlock.queryBlockElement, "bestPlan", bestJoinOrder, planType, planCost );
1:         formatSkip
1:             ( _currentQueryBlock.currentDecoration, DECORATION_SKIP, "Exceeds limit on memory per table: " + maxMemoryPerTable );
1:         formatSkip
1:             ( _currentQueryBlock.currentDecoration, DECORATION_SKIP, "Hash strategy not possible because table is not materializable" );
1:         formatSkip( _currentQueryBlock.currentDecoration, DECORATION_SKIP, "No hash keys" );
/////////////////////////////////////////////////////////////////////////
1:         _currentQueryBlock.currentDecorationStrategy = js;
/////////////////////////////////////////////////////////////////////////
1:         _currentQueryBlock.currentDecoration = createElement( _currentQueryBlock.currentJoinsElement, DECORATION, null );
1:         _currentQueryBlock.currentDecoration.setAttribute( DECORATION_CONGLOM_NAME, cd.getConglomerateName() );
1:         _currentQueryBlock.currentDecoration.setAttribute( DECORATION_TABLE_NAME, getOptimizableName( opt ).toString() );
1:         _currentQueryBlock.currentDecoration.setAttribute
1:             ( DECORATION_JOIN_STRATEGY, _currentQueryBlock.currentDecorationStrategy.getName() );
/////////////////////////////////////////////////////////////////////////
1:                 createElement( _currentQueryBlock.currentDecoration, DECORATION_KEY, columnNames[ keyColumns[ i ] - 1 ] );
/////////////////////////////////////////////////////////////////////////
1:         Element cost = createElement( _currentQueryBlock.currentDecoration, DECORATION_CONGLOM_COST, null );
/////////////////////////////////////////////////////////////////////////
1:         for ( int i = 0; i < _currentQueryBlock.optimizableList.size(); i++ )
1:             Optimizable candidate = _currentQueryBlock.optimizableList.getOptimizable( i );
/////////////////////////////////////////////////////////////////////////
1:         if ( joinOrder.length < _currentQueryBlock.optimizableList.size() ) { return false; }
/////////////////////////////////////////////////////////////////////////
1:                     Optimizable optimizable = _currentQueryBlock.optimizableList.getOptimizable( optimizableNumber );
/////////////////////////////////////////////////////////////////////////
1:                 if ( listIndex >= _currentQueryBlock.optimizableList.size() )
1:                 Optimizable optimizable = _currentQueryBlock.optimizableList.getOptimizable( listIndex );
/////////////////////////////////////////////////////////////////////////
1:                 OptimizerPlan   current =   (utd == null) ?
1:                     new OptimizerPlan.DeadEnd( getOptimizableName( optimizable ).toString() ) :
1:                     OptimizerPlan.makeRowSource( utd, _lcc.getDataDictionary() );
commit:6a270cb
/////////////////////////////////////////////////////////////////////////
1:                 TableName   retval = ((FromTable) ((ProjectRestrictNode) optimizable).getChildResult()).getTableName();
1: 
1:                 if ( retval !=  null ) { return retval; }
commit:23e89eb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.OptimizerPlan;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.UniqueTupleDescriptor;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         "        asList( '" + PC_COMPLETE + "', '" + PC_SUMMARY + "', '" + PC_TYPE + "', '" +
/////////////////////////////////////////////////////////////////////////
1:     // context
1:     private ContextManager  _cm;
1:     private LanguageConnectionContext   _lcc;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:                 if ( i == 0 )
1:                 {
1:                     _cm = ((QueryTreeNode) opt).getContextManager();
1:                     _lcc = (LanguageConnectionContext) _cm.getContext( LanguageConnectionContext.CONTEXT_ID );
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 return makeTableName( td.getSchemaName(), td.getName(), _cm );
/////////////////////////////////////////////////////////////////////////
1:                 return makeTableName( ad.getSchemaName(), ad.getName(), _cm );
/////////////////////////////////////////////////////////////////////////
1:         return makeTableName( null, unqualifiedName, _cm );
/////////////////////////////////////////////////////////////////////////
1:         createElement( cost, PC_SUMMARY, formatPlanSummary( planOrder, planType ) );
/////////////////////////////////////////////////////////////////////////
1:     private String  formatPlanSummary( int[] planOrder, int planType )
1:         try {
1:             OptimizerPlan   plan = null;
1:             StringBuilder   buffer = new StringBuilder();
1:             boolean     avoidSort = (planType == Optimizer.SORT_AVOIDANCE_PLAN);
1:             // a negative optimizable number indicates the end of the plan
1:             int planLength = 0;
1:             for ( ; planLength < planOrder.length; planLength++ )
1:                 if ( planOrder[ planLength ] < 0 ) { break; }
1:             for ( int i = 0; i < planLength; i++ )
1:                 int     listIndex = planOrder[ i ];
1: 
0:                 if ( listIndex >= _currentOptimizableList.size() )
1:                     // should never happen!
1:                     buffer.append( "{ UNKNOWN LIST INDEX " + listIndex + " } " );
1:                     continue;
0:                 Optimizable optimizable = _currentOptimizableList.getOptimizable( listIndex );
1:             
1:                 AccessPath  ap = avoidSort ?
1:                     optimizable.getBestSortAvoidancePath() : optimizable.getBestAccessPath();
1:                 JoinStrategy    js = ap.getJoinStrategy();
1:                 UniqueTupleDescriptor   utd = OptimizerImpl.isTableFunction( optimizable ) ?
1:                     ((StaticMethodCallNode) ((FromVTI) ((ProjectRestrictNode) optimizable).getChildResult()).getMethodCall()).ad :
1:                     ap.getConglomerateDescriptor();
1: 
0:                 OptimizerPlan   current = OptimizerPlan.makeRowSource( utd, _lcc.getDataDictionary() );
1: 
1:                 if ( plan != null )
1:                 {
1:                     current = new OptimizerPlan.Join( js, plan, current );
1:                 }
1: 
1:                 plan = current;
1:             }
1: 
1:             return plan.toString();
1:         }
1:         catch (Exception e)
1:         {
1:             return e.getMessage();
1:         }
1: 
commit:a56ecfa
/////////////////////////////////////////////////////////////////////////
1:             else if ( OptimizerImpl.isTableFunction( optimizable ) )
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         boolean isTableFunction = OptimizerImpl.isTableFunction( optimizable );
commit:866d96b
/////////////////////////////////////////////////////////////////////////
0:         ContextManager  cm = ((QueryTreeNode) optimizable).getContextManager();
1:         
0:                 return makeTableName( td.getSchemaName(), td.getName(), cm );
/////////////////////////////////////////////////////////////////////////
0:                 return makeTableName( ad.getSchemaName(), ad.getName(), cm );
/////////////////////////////////////////////////////////////////////////
0:         return makeTableName( null, unqualifiedName, cm );
commit:a8f9739
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.util.IdUtil;
/////////////////////////////////////////////////////////////////////////
1:     // distinguish table function names from conglomerate names
1:     private static  final   String  TABLE_FUNCTION_FLAG = "()";
1:     
/////////////////////////////////////////////////////////////////////////
1:                 Element optElement = createElement
0:                     ( _currentQuery, QBLOCK_OPTIMIZABLE, getOptimizableName( opt ).getFullSQLName() );
/////////////////////////////////////////////////////////////////////////
1:              "Useless join order. " + getOptimizableName( opt ).getFullSQLName() + " depends on tables after it in the join order"
/////////////////////////////////////////////////////////////////////////
0:         _currentDecoration.setAttribute( DECORATION_TABLE_NAME, getOptimizableName( opt ).toString() );
/////////////////////////////////////////////////////////////////////////
1:     /** Get the name of an optimizable */
1:     private TableName    getOptimizableName( Optimizable optimizable )
1:         try {
1:             if ( isBaseTable( optimizable ) )
0:                 TableDescriptor td = ((FromBaseTable) ((ProjectRestrictNode) optimizable).getChildResult()).getTableDescriptor();
0:                 return makeTableName( td.getSchemaName(), td.getName() );
1:             }
0:             else if ( isTableFunction( optimizable ) )
1:             {
1:                 AliasDescriptor ad =
0:                     ((StaticMethodCallNode) ((FromVTI) ((ProjectRestrictNode) optimizable).getChildResult()).getMethodCall() ).ad;
0:                 return makeTableName( ad.getSchemaName(), ad.getName() );
1:             }
1:             else if ( isFromTable( optimizable ) )
1:             {
0:                 return ((FromTable) ((ProjectRestrictNode) optimizable).getChildResult()).getTableName();
1:         catch (StandardException e)
1:             // Technically, an exception could occur here if the table name
1:             // was not previously bound and if an error occured while binding it.
1:             // But the optimizable should have been bound long before optimization,
1:             // so this should not be a problem.
1:         String  nodeClass = optimizable.getClass().getName();
1:         String  unqualifiedName = nodeClass.substring( nodeClass.lastIndexOf( "." ) + 1 );
1: 
0:         return makeTableName( null, unqualifiedName );
1:     }
1: 
1:     /** Return true if the optimizable is a base table */
1:     private boolean isBaseTable( Optimizable optimizable )
1:     {
1:         if ( !( optimizable instanceof ProjectRestrictNode ) ) { return false; }
1: 
1:         ResultSetNode   rsn = ((ProjectRestrictNode) optimizable).getChildResult();
1: 
1:         return ( rsn instanceof FromBaseTable );
1:     }
1: 
1:     /** Return true if the optimizable is a FromTable */
1:     private boolean isFromTable( Optimizable optimizable )
1:     {
1:         if ( !( optimizable instanceof ProjectRestrictNode ) ) { return false; }
1: 
1:         ResultSetNode   rsn = ((ProjectRestrictNode) optimizable).getChildResult();
1: 
1:         return ( rsn instanceof FromTable );
1:     }
1: 
0:     /** Return true if the optimizable is a table function */
0:     private boolean isTableFunction( Optimizable optimizable )
1:     {
1:         if ( !( optimizable instanceof ProjectRestrictNode ) ) { return false; }
1: 
1:         ResultSetNode   rsn = ((ProjectRestrictNode) optimizable).getChildResult();
0:         if ( !( rsn instanceof FromVTI ) ) { return false; }
1: 
0:         return ( ((FromVTI) rsn).getMethodCall() instanceof StaticMethodCallNode );
1:     }
1: 
1:     /** Make a TableName */
0:     private TableName   makeTableName( String schemaName, String unqualifiedName )
1:     {
0:         TableName   result = new TableName();
0:         result.init( schemaName, unqualifiedName );
1: 
1:         return result;
/////////////////////////////////////////////////////////////////////////
1:                     createElement( parent, JO_SLOT, getOptimizableName( optimizable ).getFullSQLName() );
/////////////////////////////////////////////////////////////////////////
0:             String  conglomerateName = getSQLName( optimizable, cd, verbose );
/////////////////////////////////////////////////////////////////////////
0:     private String  getSQLName( Optimizable optimizable, ConglomerateDescriptor cd, boolean verbose )
0:         if ( !verbose && (cd != null) )
1:         {
0:             String  schemaName = getOptimizableName( optimizable ).getSchemaName();
0:             String  conglomerateName = cd.getConglomerateName();
0:             return IdUtil.mkQualifiedName( schemaName, conglomerateName );
1:         }
1: 
0:         boolean isTableFunction = isTableFunction( optimizable );
0:         buffer.append( getOptimizableName( optimizable ).getFullSQLName() );
0:         if ( isTableFunction ) { buffer.append( TABLE_FUNCTION_FLAG ); }
0:         if ( (cd != null) && cd.isIndex() )
commit:bbd2a01
/////////////////////////////////////////////////////////////////////////
1: class   XMLOptTrace implements  OptTrace
commit:b6cc9d7
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.sql.compile.XMLOptTrace
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derby.impl.sql.compile;
1: 
1: import java.io.PrintWriter;
1: import java.util.Date;
1: import javax.xml.parsers.DocumentBuilderFactory;
1: import javax.xml.parsers.ParserConfigurationException;
1: import javax.xml.transform.OutputKeys;
1: import javax.xml.transform.Transformer;
0: import javax.xml.transform.TransformerException;
1: import javax.xml.transform.TransformerFactory;
1: import javax.xml.transform.dom.DOMSource;
1: import javax.xml.transform.stream.StreamResult;
0: import org.w3c.dom.Attr;
1: import org.w3c.dom.Document;
1: import org.w3c.dom.Element;
0: import org.w3c.dom.Node;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.util.JBitSet;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.sql.compile.AccessPath;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.JoinStrategy;
1: import org.apache.derby.iapi.sql.compile.OptTrace;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.OptimizableList;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1: 
1: /**
1:  * Optimizer tracer which produces output in an xml format.
1:  */
0: public  class   XMLOptTrace implements  OptTrace
1: {
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTANTS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     // statement tags
1:     private static  final   String  STMT = "statement";
1:     private static  final   String  STMT_ID = "stmtID";
1:     private static  final   String  STMT_TEXT = "stmtText";
1: 
1:     // query block tags
1:     private static  final   String  QBLOCK = "queryBlock";
1:     private static  final   String  QBLOCK_OPTIMIZER_ID = "qbOptimizerID";
1:     private static  final   String  QBLOCK_START_TIME = "qbStartTime";
1:     private static  final   String  QBLOCK_ID = "qbID";
1:     private static  final   String  QBLOCK_OPTIMIZABLE = "qbOptimizable";
1:     private static  final   String  QBLOCK_OPT_TABLE_NUMBER = "qboTableNumber";
1:     private static  final   String  QBLOCK_TIMEOUT = "qbTimeout";
1:     private static  final   String  QBLOCK_VACUOUS = "qbVacuous";
1:     private static  final   String  QBLOCK_SORT_COST = "qbSortCost";
1:     private static  final   String  QBLOCK_TOTAL_COST = "qbTotalCost";
1:     private static  final   String  QBLOCK_NO_BEST_PLAN = "qbNoBestPlan";
1:     private static  final   String  QBLOCK_SKIP = "qbSkip";
1: 
1:     // join order tags
1:     private static  final   String  JO = "joinOrder";
1:     private static  final   String  JO_COMPLETE = "joComplete";
1:     private static  final   String  JO_SLOT = "joSlot";
1: 
1:     // decoration tags
1:     private static  final   String  DECORATION = "decoration";
1:     private static  final   String  DECORATION_CONGLOM_NAME = "decConglomerateName";
1:     private static  final   String  DECORATION_KEY = "decKey";
1:     private static  final   String  DECORATION_TABLE_NAME = "decTableName";
1:     private static  final   String  DECORATION_JOIN_STRATEGY = "decJoinStrategy";
1:     private static  final   String  DECORATION_SKIP = "decSkip";
1:     private static  final   String  DECORATION_CONGLOM_COST = "decConglomerateCost";
1:     private static  final   String  DECORATION_FIRST_COLUMN_SELECTIVITY = "decExtraFirstColumnPreds";
1:     private static  final   String  DECORATION_EXTRA_START_STOP_SELECTIVITY = "decExtraFirstStartStopPreds";
1:     private static  final   String  DECORATION_START_STOP_SELECTIVITY = "decStartStopPred";
1:     private static  final   String  DECORATION_EXTRA_QUALIFIERS = "decExtraQualifiers";
1:     private static  final   String  DECORATION_EXTRA_NON_QUALIFIERS = "decExtraNonQualifiers";
1: 
1:     // skip tags
1:     private static  final   String  SKIP_REASON = "skipReason";
1: 
1:     // plan cost tags
1:     private static  final   String  PC = "planCost";
1:     private static  final   String  PC_TYPE = "pcType";
1:     private static  final   String  PC_COMPLETE = "pcComplete";
1:     private static  final   String  PC_AVOID_SORT= "pcAvoidSort";
1:     private static  final   String  PC_SUMMARY= "pcSummary";
0:     private static  final   String  PC_VERBOSE= "pcVerbose";
1: 
1:     // CostEstimate tags
1:     private static  final   String  CE_ESTIMATED_COST = "ceEstimatedCost";
1:     private static  final   String  CE_ROW_COUNT = "ceEstimatedRowCount";
1:     private static  final   String  CE_SINGLE_SCAN_ROW_COUNT = "ceSingleScanRowCount";
1: 
1:     // selectivity tags
1:     private static  final   String  SEL_COUNT = "selCount";
1:     private static  final   String  SEL_SELECTIVITY = "selSelectivity";
1: 
1:     //
1:     // Statement and view for declaring a table function which reads the planCost element.
1:     // This table function is an instance of the XmlVTI and assumes that you have
1:     // already declared an ArrayList user-type and an asList factory function for it.
1:     //
1:     static  final   String  PLAN_COST_VTI =
1:         "create function planCost\n" +
1:         "(\n" +
1:         "    xmlResourceName varchar( 32672 ),\n" +
1:         "    rowTag varchar( 32672 ),\n" +
1:         "    parentTags ArrayList,\n" +
1:         "    childTags ArrayList\n" +
1:         ")\n" +
1:         "returns table\n" +
1:         "(\n" +
1:         "    text varchar( 32672 ),\n" +
1:         "    stmtID    int,\n" +
1:         "    qbID   int,\n" +
1:         "    complete  boolean,\n" +
1:         "    summary   varchar( 32672 ),\n" +
0:         "    verbose   varchar( 32672 ),\n" +
1:         "    type        varchar( 50 ),\n" +
1:         "    estimatedCost        double,\n" +
1:         "    estimatedRowCount    bigint\n" +
1:         ")\n" +
1:         "language java parameter style derby_jdbc_result_set no sql\n" +
1:         "external name 'org.apache.derby.vti.XmlVTI.xmlVTI'\n";
1: 
1:     static  final   String  PLAN_COST_VIEW =
1:         "create view planCost as\n" +
1:         "select *\n" +
1:         "from table\n" +
1:         "(\n" +
1:         "    planCost\n" +
1:         "    (\n" +
1:         "        'FILE_URL',\n" +
1:         "        'planCost',\n" +
1:         "        asList( '" + STMT_TEXT + "', '" + STMT_ID + "', '" + QBLOCK_ID + "' ),\n" +
0:         "        asList( '" + PC_COMPLETE + "', '" + PC_SUMMARY + "', '" + PC_VERBOSE + "', '" + PC_TYPE + "', '" +
1:         CE_ESTIMATED_COST + "', '" + CE_ROW_COUNT + "' )\n" +
1:         "     )\n" +
1:         ") v\n";
1:         
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	STATE
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     private Document    _doc;
1:     private Element         _root;
1:     
1:     private Element         _currentStatement;
1:     private int                 _currentStatementID;
1: 
0:     private Element         _currentQuery;
0:     private int                 _currentQueryID;
0:     private OptimizableList _currentOptimizableList;
0:     private Element         _currentJoinsElement;
0:     private int[]              _currentJoinOrder;
0:     private Element         _currentBestPlan;
1: 
0:     // reset per join order
0:     private JoinStrategy    _currentDecorationStrategy;
0:     private Element         _currentDecoration;
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTRUCTOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /** 0-arg constructor required by OptTrace contract */
1:     public  XMLOptTrace()
1:         throws ParserConfigurationException
1:     {
1:         _doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
1:         _root = createElement( null, "optimizerTrace", null );
1:         _doc.appendChild( _root );
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	BEHAVIOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     public  void    traceStartStatement( String statementText )
1:     {
1:         _currentStatementID++;
0:         _currentQueryID = 0;
1:         
1:         _currentStatement = createElement( _root, STMT, null );
1:         _currentStatement .setAttribute( STMT_ID, Integer.toString( _currentStatementID ) );
1: 
0:         _currentOptimizableList = null;
0:         _currentJoinsElement = null;
0:         _currentJoinOrder = null;
1: 
0:         _currentDecorationStrategy = null;
0:         _currentDecoration = null;
1: 
0:         _currentBestPlan = null;
1:         
1:         createElement( _currentStatement, STMT_TEXT, statementText );
1:     }
1:     
0:     public  void    traceStart( long timeOptimizationStarted, int optimizerID, OptimizableList optimizableList )
1:     {
0:         _currentQueryID++;
0:         _currentOptimizableList = optimizableList;
0:         _currentJoinOrder = null;
1: 
0:         _currentDecorationStrategy = null;
0:         _currentDecoration = null;
1: 
0:         _currentBestPlan = null;
1: 
0:         _currentQuery = createElement( _currentStatement, QBLOCK, null );
0:         _currentQuery.setAttribute( QBLOCK_OPTIMIZER_ID, Integer.toString( optimizerID ) );
0:         _currentQuery.setAttribute( QBLOCK_START_TIME, formatTimestamp( timeOptimizationStarted ) );
0:         _currentQuery.setAttribute( QBLOCK_ID, Integer.toString( _currentQueryID ) );
1: 
0:         if ( _currentOptimizableList != null )
1:         {
0:             for ( int i = 0; i < _currentOptimizableList.size(); i++ )
1:             {
0:                 Optimizable opt = _currentOptimizableList.getOptimizable( i );
0:                 Element optElement = createElement( _currentQuery, QBLOCK_OPTIMIZABLE, getOptimizableName( opt ) );
1:                 optElement.setAttribute( QBLOCK_OPT_TABLE_NUMBER, Integer.toString( opt.getTableNumber() ) );
1:             }
1:         }
1:     }
1:     
1:     public  void    traceTimeout( long currentTime, CostEstimate bestCost )
1:     {
0:         Element timeout = createElement( _currentQuery, QBLOCK_TIMEOUT, null );
1:         formatCost( timeout, bestCost );
1:     }
1:     
1:     public  void    traceVacuous()
1:     {
0:         createElement( _currentQuery, QBLOCK_VACUOUS, null );
1:     }
1:     
1:     public  void    traceCompleteJoinOrder()
1:     {
0:         if ( _currentJoinsElement != null )    { _currentJoinsElement.setAttribute( JO_COMPLETE, "true" ); }
1:     }
1:     
1:     public  void    traceSortCost( CostEstimate sortCost, CostEstimate currentCost )
1:     {
0:         Element sc = createElement( _currentQuery, QBLOCK_SORT_COST, null );
1:         formatCost( sc, sortCost );
1:             
0:         Element tcis = createElement( _currentQuery, QBLOCK_TOTAL_COST, null );
1:         formatCost( tcis, currentCost );
1:     }
1:     
1:     public  void    traceNoBestPlan()
1:     {
0:         createElement( _currentQuery, QBLOCK_NO_BEST_PLAN, null );
1:     }
1:     
1:     public  void    traceModifyingAccessPaths( int optimizerID ) {}
1:     
1:     public  void    traceShortCircuiting( boolean timeExceeded, Optimizable thisOpt, int joinPosition ) {}
1:     
1:     public  void    traceSkippingJoinOrder( int nextOptimizable, int joinPosition, int[] proposedJoinOrder, JBitSet assignedTableMap )
1:     {
0:         Optimizable opt = _currentOptimizableList.getOptimizable( nextOptimizable );
1: 
1:         Element skip = formatSkip
1:             (
0:              _currentQuery, QBLOCK_SKIP,
0:              "Useless join order. " + getOptimizableName( opt ) + " depends on tables after it in the join order"
1:              );
1:         formatJoinOrder( skip, proposedJoinOrder );
1:     }
1:     
1:     public  void    traceIllegalUserJoinOrder() {}
1:     public  void    traceUserJoinOrderOptimized() {}
1:     
1:     public  void    traceJoinOrderConsideration( int joinPosition, int[] proposedJoinOrder, JBitSet assignedTableMap )
1:     {
0:         _currentJoinsElement = createElement( _currentQuery, JO, null );
0:         _currentJoinOrder = proposedJoinOrder;
1: 
0:         _currentDecorationStrategy = null;
0:         _currentDecoration = null;
1: 
0:         formatJoinOrder( _currentJoinsElement, proposedJoinOrder );
1:     }
1: 
1:     public  void    traceCostWithoutSortAvoidance( CostEstimate currentCost )
1:     {
1:         formatPlanCost
1:             (
0:              _currentJoinsElement, "withoutSortAvoidance",
0:              _currentJoinOrder, Optimizer.NORMAL_PLAN, currentCost
1:              );
1:     }
1:     
1:     public  void    traceCostWithSortAvoidance( CostEstimate currentSortAvoidanceCost )
1:     {
1:         formatPlanCost
1:             (
0:              _currentJoinsElement, "withSortAvoidance",
0:              _currentJoinOrder, Optimizer.SORT_AVOIDANCE_PLAN, currentSortAvoidanceCost
1:              );
1:     }
1:     
1:     public  void    traceCurrentPlanAvoidsSort( CostEstimate bestCost, CostEstimate currentSortAvoidanceCost ) {}
1:     public  void    traceCheapestPlanSoFar( int planType, CostEstimate currentCost ) {}
1:     public  void    traceSortNeededForOrdering( int planType, RequiredRowOrdering requiredRowOrdering ) {}
1:     
1:     public  void    traceRememberingBestJoinOrder
1:         ( int joinPosition, int[] bestJoinOrder, int planType, CostEstimate planCost, JBitSet assignedTableMap )
1:     {
0:         if ( _currentBestPlan != null ) { _currentQuery.removeChild( _currentBestPlan ); }
0:         _currentBestPlan = formatPlanCost( _currentQuery, "bestPlan", bestJoinOrder, planType, planCost );
1:     }
1:     
1:     public  void    traceSkippingBecauseTooMuchMemory( int maxMemoryPerTable )
1:     {
0:         formatSkip( _currentDecoration, DECORATION_SKIP, "Exceeds limit on memory per table: " + maxMemoryPerTable );
1:     }
1:     
1:     public  void    traceCostOfNScans( int tableNumber, double rowCount, CostEstimate cost ) {}
1:     
1:     public  void    traceSkipUnmaterializableHashJoin()
1:     {
0:         formatSkip( _currentDecoration, DECORATION_SKIP, "Hash strategy not possible because table is not materializable" );
1:     }
1:     
1:     public  void    traceSkipHashJoinNoHashKeys()
1:     {
0:         formatSkip( _currentDecoration, DECORATION_SKIP, "No hash keys" );
1:     }
1:     
1:     public  void    traceHashKeyColumns( int[] hashKeyColumns ) {}
1:     public  void    traceOptimizingJoinNode() {}
1:     
1:     public  void    traceConsideringJoinStrategy( JoinStrategy js, int tableNumber )
1:     {
0:         _currentDecorationStrategy = js;
1:     }
1:     
1:     public  void    traceRememberingBestAccessPath( AccessPath accessPath, int tableNumber, int planType ) {}
1:     public  void    traceNoMoreConglomerates( int tableNumber ) {}
1:     
1:     public  void    traceConsideringConglomerate( ConglomerateDescriptor cd, int tableNumber )
1:     {
1:         Optimizable opt = getOptimizable( tableNumber );
1:         
0:         _currentDecoration = createElement( _currentJoinsElement, DECORATION, null );
1: 
0:         _currentDecoration.setAttribute( DECORATION_CONGLOM_NAME, cd.getConglomerateName() );
0:         _currentDecoration.setAttribute( DECORATION_TABLE_NAME, getOptimizableName( opt ) );
0:         _currentDecoration.setAttribute( DECORATION_JOIN_STRATEGY, _currentDecorationStrategy.getName() );
1:         
1: 		String[]	columnNames = cd.getColumnNames();
1: 
1: 		if ( cd.isIndex() && (columnNames != null) )
1: 		{
1: 			int[]   keyColumns = cd.getIndexDescriptor().baseColumnPositions();
1: 
1:             for ( int i = 0; i < keyColumns.length; i++ )
1:             {
0:                 createElement( _currentDecoration, DECORATION_KEY, columnNames[ keyColumns[ i ] - 1 ] );
1:             }
1: 		}
1:     }
1:     
1:     public  void    traceScanningHeapWithUniqueKey() {}
1:     public  void    traceAddingUnorderedOptimizable( int predicateCount ) {}
1:     public  void    traceChangingAccessPathForTable( int tableNumber ) {}
1:     public  void    traceNoStartStopPosition() {}
1:     public  void    traceNonCoveringIndexCost( double cost, int tableNumber ) {}
1:     public  void    traceConstantStartStopPositions() {}
1:     public  void    traceEstimatingCostOfConglomerate( ConglomerateDescriptor cd, int tableNumber ) {}
1:     public  void    traceLookingForSpecifiedIndex( String indexName, int tableNumber ) {}
1:     public  void    traceSingleMatchedRowCost( double cost, int tableNumber ) {}
1:     public  void    traceCostIncludingExtra1stColumnSelectivity( CostEstimate cost, int tableNumber ) {}
1:     public  void    traceNextAccessPath( String baseTable, int predicateCount ) {}
1:     public  void    traceCostIncludingExtraStartStop( CostEstimate cost, int tableNumber ) {}
1:     public  void    traceCostIncludingExtraQualifierSelectivity( CostEstimate cost, int tableNumber ) {}
1:     public  void    traceCostIncludingExtraNonQualifierSelectivity( CostEstimate cost, int tableNumber ) {}
1:     public  void    traceCostOfNoncoveringIndex( CostEstimate cost, int tableNumber ) {}
1:     public  void    traceRememberingJoinStrategy( JoinStrategy joinStrategy, int tableNumber ) {}
1:     public  void    traceRememberingBestAccessPathSubstring( AccessPath ap, int tableNumber ) {}
1:     public  void    traceRememberingBestSortAvoidanceAccessPathSubstring( AccessPath ap, int tableNumber ) {}
1:     public  void    traceRememberingBestUnknownAccessPathSubstring( AccessPath ap, int tableNumber ) {}
1:     
1:     public  void    traceCostOfConglomerateScan
1:         (
1:          int    tableNumber,
1:          ConglomerateDescriptor cd,
1:          CostEstimate   costEstimate,
1:          int    numExtraFirstColumnPreds,
1:          double    extraFirstColumnSelectivity,
1:          int    numExtraStartStopPreds,
1:          double    extraStartStopSelectivity,
1:          int    startStopPredCount,
1:          double    statStartStopSelectivity,
1:          int    numExtraQualifiers,
1:          double    extraQualifierSelectivity,
1:          int    numExtraNonQualifiers,
1:          double    extraNonQualifierSelectivity
1:          )
1:     {
0:         Element cost = createElement( _currentDecoration, DECORATION_CONGLOM_COST, null );
1:         cost.setAttribute( "name", cd.getConglomerateName() );
1: 
1:         formatCost( cost, costEstimate );
1:         formatSelectivity( cost, DECORATION_FIRST_COLUMN_SELECTIVITY, numExtraFirstColumnPreds, extraFirstColumnSelectivity );
1:         formatSelectivity( cost, DECORATION_EXTRA_START_STOP_SELECTIVITY, numExtraStartStopPreds, extraStartStopSelectivity );
1:         formatSelectivity( cost, DECORATION_START_STOP_SELECTIVITY, startStopPredCount, statStartStopSelectivity );
1:         formatSelectivity( cost, DECORATION_EXTRA_QUALIFIERS, numExtraQualifiers, extraQualifierSelectivity );
1:         formatSelectivity( cost, DECORATION_EXTRA_NON_QUALIFIERS, numExtraNonQualifiers, extraNonQualifierSelectivity );
1:     }
1:     
1:     public  void    traceCostIncludingCompositeSelectivityFromStats( CostEstimate cost, int tableNumber ) {}
1:     public  void    traceCompositeSelectivityFromStatistics( double statCompositeSelectivity ) {}
1:     public  void    traceCostIncludingStatsForIndex( CostEstimate cost, int tableNumber ) {}
1: 
1:     public  void    printToWriter( PrintWriter out )
1:     {
1:         try {
1:             TransformerFactory transformerFactory = TransformerFactory.newInstance();
1:             Transformer transformer = transformerFactory.newTransformer();
1:             DOMSource source = new DOMSource( _doc );
1:             StreamResult result = new StreamResult( out );
1: 
1:             // pretty-print
1:             transformer.setOutputProperty( OutputKeys.OMIT_XML_DECLARATION, "no" );
1:             transformer.setOutputProperty( OutputKeys.METHOD, "xml" );
1:             transformer.setOutputProperty( OutputKeys.INDENT, "yes" );
1:             transformer.setOutputProperty( OutputKeys.ENCODING, "UTF-8" );
1:             transformer.setOutputProperty( "{http://xml.apache.org/xslt}indent-amount", "4" );
1:             
1:             transformer.transform( source, result );
1:             
1:         }   catch (Throwable t) { printThrowable( t ); }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	MINIONS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /** Get the Optimizable with the given tableNumber */
1:     private Optimizable getOptimizable( int tableNumber )
1:     {
0:         for ( int i = 0; i < _currentOptimizableList.size(); i++ )
1:         {
0:             Optimizable candidate = _currentOptimizableList.getOptimizable( i );
1:             
1:             if ( tableNumber == candidate.getTableNumber() )    { return candidate; }
1:         }
1: 
1:         return null;
1:     }
1: 
0:     /** Get the name of a optimizables */
0:     private String    getOptimizableName( Optimizable optimizable )
1:     {
0:         String  name = null;
1:         
0:         if ( optimizable instanceof ProjectRestrictNode )
1:         {
1:             ProjectRestrictNode prn = (ProjectRestrictNode) optimizable;
0:             ResultSetNode   rsn = prn.getChildResult();
0:             if ( rsn instanceof FromBaseTable )
1:             {
1:                 try {
0:                     name = ((FromBaseTable) rsn).getTableName().getFullTableName();
1:                 }
0:                 catch (StandardException e)
1:                 {
0:                     // Technically, an exception could occur here if the table name
0:                     // was not previously bound and if an error occured while binding it.
0:                     // But the FromBaseTable should have been bound long before optimization,
0:                     // so this should not be a problem.
1:                 }
1:             }
1:         }
1: 
0:         // fallback
0:         if ( name == null )
1:         {
0:             String  nodeClass = optimizable.getClass().getName();
0:             name = nodeClass.substring( nodeClass.lastIndexOf( "." ) + 1 );
1:         }
1: 
0:         return name;
1:     }
1: 
1:     /** Print an exception to the log file */
1:     private void    printThrowable( Throwable t )
1:     {
1:         t.printStackTrace( Monitor.getStream().getPrintWriter() );
1:     }
1: 
1:     /** Create an element and add it to a parent */
1:     private Element createElement( Element parent, String tag, String content )
1:     {
1:         Element child = null;
1:         
1:         try {
1:             child = _doc.createElement( tag );
1:             if ( parent != null) { parent.appendChild( child ); }
1:             if ( content != null ) { child.setTextContent( content ); }
1:         }
1:         catch (Throwable t) { printThrowable( t ); }
1: 
1:         return child;
1:     }
1: 
1:     /** Turn a timestamp into a human-readable string */
1:     private String  formatTimestamp( long timestamp ) { return (new Date( timestamp )).toString(); }
1: 
1:     /** Create an element explaining that we're skipping some processing */
1:     private Element formatSkip( Element parent, String skipTag, String reason )
1:     {
1:         Element skip = createElement( parent, skipTag, null );
1:         skip.setAttribute( SKIP_REASON, reason );
1: 
1:         return skip;
1:     }
1:     
1:     /** Turn a CostEstimate for a join order into a human-readable element */
1:     private Element formatPlanCost( Element parent, String type, int[] planOrder, int planType, CostEstimate raw )
1:     {
1:         Element cost = createElement( parent, PC, null );
1: 
1:         cost.setAttribute( PC_TYPE, type );
1:         if ( isComplete( planOrder ) ) { cost.setAttribute( PC_COMPLETE, "true" ); }
1:         if ( planType == Optimizer.SORT_AVOIDANCE_PLAN ) { cost.setAttribute( PC_AVOID_SORT, "true" ); }
1: 
0:         createElement( cost, PC_SUMMARY, formatPlanSummary( planOrder, planType, false ) );
0:         createElement( cost, PC_VERBOSE, formatPlanSummary( planOrder, planType, true ) );
1:         formatCost( cost, raw );
1: 
1:         return cost;
1:     }
1: 
1:     /** Return true if the join order has been completely filled in */
1:     private boolean isComplete( int[] joinOrder )
1:     {
1:         if ( joinOrder == null ) { return false; }
0:         if ( joinOrder.length < _currentOptimizableList.size() ) { return false; }
1: 
1:         for ( int i = 0; i < joinOrder.length; i++ )
1:         {
1:             if ( joinOrder[ i ] < 0 ) { return false; }
1:         }
1: 
1:         return true;
1:     }
1: 
1:     /** Format a CostEstimate as subelements of a parent */
1:     private void    formatCost( Element costElement, CostEstimate raw )
1:     {
1:         createElement( costElement, CE_ESTIMATED_COST, Double.toString( raw.getEstimatedCost() ) );
1:         createElement( costElement, CE_ROW_COUNT, Long.toString( raw.getEstimatedRowCount() ) );
1:         createElement( costElement, CE_SINGLE_SCAN_ROW_COUNT, Double.toString( raw.singleScanRowCount() ) );
1:     }
1: 
1:     /** Format selectivity subelement */
1:     private void    formatSelectivity( Element parent, String tag, int count, double selectivity )
1:     {
1:         Element child = createElement( parent, tag, null );
1:         child.setAttribute( SEL_COUNT, Integer.toString( count ) );
1:         child.setAttribute( SEL_SELECTIVITY, Double.toString( selectivity ) );
1:     }
1: 
1:     /** Format a join order list */
1:     private void    formatJoinOrder( Element parent, int[] proposedJoinOrder )
1:     {
1:         if ( proposedJoinOrder != null )
1:         {
1:             for ( int idx = 0; idx < proposedJoinOrder.length; idx++ )
1:             {
1:                 int     optimizableNumber = proposedJoinOrder[ idx ];
1:                 if ( optimizableNumber >= 0 )
1:                 {
0:                     Optimizable optimizable = _currentOptimizableList.getOptimizable( optimizableNumber );
0:                     createElement( parent, JO_SLOT, getOptimizableName( optimizable ) );
1:                 }
1:             }
1:         }
1:     }
1: 
1: 
1:     /**
1:      * <p>
1:      * Produce a string representation of the plan being considered now.
1:      * The string has the following grammar:
1:      * </p>
1:      *
1:      * <pre>
1:      * join :== factor OP factor
1:      *
1:      * OP :== "*" | "#"
1:      *
1:      * factor :== factor | conglomerateName
1:      * </pre>
1:      */
0:     private String  formatPlanSummary( int[] planOrder, int planType, boolean verbose )
1:     {
0:         StringBuilder   buffer = new StringBuilder();
0:         boolean     avoidSort = (planType == Optimizer.SORT_AVOIDANCE_PLAN);
1: 
0:         // a negative optimizable number indicates the end of the plan
0:         int planLength = 0;
0:         for ( ; planLength < planOrder.length; planLength++ )
1:         {
0:             if ( planOrder[ planLength ] < 0 ) { break; }
1:         }
1: 
0:         // only add parentheses if there are more than 2 slots in the join order
0:         int     dontNeedParentheses = 2;
0:         int     lastParenthesizedIndex = planLength - dontNeedParentheses;
0:         for ( int i = 0; i < lastParenthesizedIndex; i++ ) { buffer.append( "(" ); }
1:         
0:         for ( int i = 0; i < planLength; i++ )
1:         {
0:             int     listIndex = planOrder[ i ];
1: 
0:             if ( listIndex >= _currentOptimizableList.size() )
1:             {
0:                 // should never happen!
0:                 buffer.append( "{ UNKNOWN LIST INDEX " + listIndex + " } " );
0:                 continue;
1:             }
1: 
0:             Optimizable optimizable = _currentOptimizableList.getOptimizable( listIndex );
1:             
0:             AccessPath  ap = avoidSort ?
0:                 optimizable.getBestSortAvoidancePath() : optimizable.getBestAccessPath();
0:             ConglomerateDescriptor  cd = ap.getConglomerateDescriptor();
0:             String  conglomerateName = getConglomerateName( optimizable, cd, verbose );
0:             JoinStrategy    js = ap.getJoinStrategy();
1: 
1:             //
0:             // The very first optimizable in the join order obiously doesn't join
0:             // to anything before it. For that reason, its join strategy is always
0:             // NESTED_LOOP. We can just assume that and not clutter up the
0:             // representation with vacuous information.
1:             //
0:             if ( i > 0 ) { buffer.append( " " + js.getOperatorSymbol() + " " ); }
1:             
0:             buffer.append( conglomerateName );
0:             if ( (i > 0) && (i <= lastParenthesizedIndex) ) { buffer.append( ")" ); }
1:         }
1: 
0:         return buffer.toString();
1:     }
1: 
1:     /**
1:      * <p>
0:      * Get a human-readable name for a conglomerate.
1:      * </p>
1:      */
0:     private String  getConglomerateName( Optimizable optimizable, ConglomerateDescriptor cd, boolean verbose )
1:     {
0:         if ( !verbose ) { return cd.getConglomerateName(); }
1: 
0:         StringBuilder   buffer = new StringBuilder();
0:         buffer.append( getOptimizableName( optimizable ) );
1:         
0:         if ( cd.isIndex() )
1:         {
0:             buffer.append( "{" );
1:             String[]	columnNames = cd.getColumnNames();
1:             
0:             if ( columnNames != null )
1:             {
1:                 int[]   keyColumns = cd.getIndexDescriptor().baseColumnPositions();
1:                 
1:                 for ( int i = 0; i < keyColumns.length; i++ )
1:                 {
0:                     if ( i > 0 ) { buffer.append( "," ); }
0:                     buffer.append( columnNames[ keyColumns[ i ] - 1 ] );
1:                 }
1:             }
0:             buffer.append( "}" );
1:         }
1: 
0:         return buffer.toString();
1:     }
1:     
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.ContextManager;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.w3c.dom.Document;
0: import org.w3c.dom.Element;
/////////////////////////////////////////////////////////////////////////
1:                 ProjectRestrictNode prn = (ProjectRestrictNode) optimizable;
1:                 TableDescriptor td = 
1:                     ((FromBaseTable) prn.getChildResult()).getTableDescriptor();
0:                 return makeTableName( td.getSchemaName(),
0:                                       td.getName(),
0:                                       prn.getContextManager() );
1:                 ProjectRestrictNode prn = (ProjectRestrictNode) optimizable;
1:                     ((StaticMethodCallNode) ((FromVTI) prn.getChildResult()).
1:                         getMethodCall() ).ad;
0:                 return makeTableName( ad.getSchemaName(), 
0:                                       ad.getName(),
0:                                       prn.getContextManager() );
/////////////////////////////////////////////////////////////////////////
0:         return makeTableName( null, unqualifiedName, null );
/////////////////////////////////////////////////////////////////////////
1:     private TableName   makeTableName(
1:             String schemaName, String unqualifiedName, ContextManager cm )
1:         TableName result = new TableName(schemaName, unqualifiedName, cm);
============================================================================