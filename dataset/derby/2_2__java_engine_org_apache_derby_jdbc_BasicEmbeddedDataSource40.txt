1:4e0e1f1: /*
1:7863d83: 
1:38667d9:    Derby - Class org.apache.derby.jdbc.BasicEmbeddedDataSource40
1:7863d83: 
1:4e0e1f1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:4e0e1f1:    contributor license agreements.  See the NOTICE file distributed with
1:4e0e1f1:    this work for additional information regarding copyright ownership.
1:4e0e1f1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:4e0e1f1:    (the "License"); you may not use this file except in compliance with
1:4e0e1f1:    the License.  You may obtain a copy of the License at
1:7863d83: 
1:4e0e1f1:       http://www.apache.org/licenses/LICENSE-2.0
1:7863d83: 
1:4e0e1f1:    Unless required by applicable law or agreed to in writing, software
1:4e0e1f1:    distributed under the License is distributed on an "AS IS" BASIS,
1:4e0e1f1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:4e0e1f1:    See the License for the specific language governing permissions and
1:4e0e1f1:    limitations under the License.
1:7863d83: 
1:4e0e1f1:  */
1:7863d83: 
1:4e0e1f1: package org.apache.derby.jdbc;
1:7863d83: 
1:7863d83: import java.io.PrintWriter;
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedAction;
1:7863d83: import java.sql.Connection;
1:a086620: import java.sql.Driver;
1:a086620: import java.sql.DriverManager;
1:7863d83: import java.sql.SQLException;
1:4e0e1f1: import java.sql.SQLFeatureNotSupportedException;
1:a086620: import java.util.Properties;
1:4e0e1f1: import java.util.logging.Logger;
1:a086620: import org.apache.derby.iapi.db.Database;
1:a086620: import org.apache.derby.iapi.error.ExceptionSeverity;
1:a086620: import org.apache.derby.iapi.jdbc.ResourceAdapter;
1:a086620: import org.apache.derby.iapi.reference.Attribute;
1:a086620: import org.apache.derby.iapi.reference.MessageId;
1:a086620: import org.apache.derby.iapi.reference.Property;
1:a086620: import org.apache.derby.iapi.reference.SQLState;
1:a086620: import org.apache.derby.iapi.services.i18n.MessageService;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:a086620: import org.apache.derby.iapi.services.monitor.Monitor;
1:4e0e1f1: import org.apache.derby.impl.jdbc.Util;
1:7863d83: 
1:a086620: /**
1:4e0e1f1:  *
1:7863d83:  * This data source is suitable for an application using embedded Derby,
1:2913612:  * running on Java 8 Compact Profile 2 or higher.
1:2913612:  * <p/>
1:a086620:  * BasicEmbeddedDataSource40 is similar to EmbeddedDataSource, but does
1:4e0e1f1:  * not support JNDI naming, i.e. it does not implement
1:4e0e1f1:  * {@code javax.naming.Referenceable}.
1:b004dff:  * <p/>
1:b004dff:  * The standard attributes provided are, cf. e.g. table
1:b004dff:  * 9.1 in the JDBC 4.2 specification.
1:b004dff:  * <ul>
1:b004dff:  *   <li>databaseName</li>
1:b004dff:  *   <li>dataSourceName</li>
1:b004dff:  *   <li>description</li>
1:b004dff:  *   <li>password</li>
1:b004dff:  *   <li>user</li>
1:b004dff:  * </ul>
1:b004dff:  * These standard attributes are not supported:
1:b004dff:  * <ul>
1:b004dff:  *   <li>networkProtocol</li>
1:b004dff:  *   <li>portNumber</li>
1:b004dff:  *   <li>roleName</li>
1:b004dff:  *   <li>serverName</li>
1:b004dff:  * </ul>
1:b004dff:  * The embedded Derby driver also supports these attributes:
1:b004dff:  * <ul>
1:b004dff:  *   <li>loginTimeout</li> @see javax.sql.CommonDataSource set/get
1:b004dff:  *   <li>logWriter</li> @see javax.sql.CommonDataSource set/get
1:b004dff:  *   <li>createDatabase</li>
1:b004dff:  *   <li>connectionAttributes</li>
1:b004dff:  *   <li>shutdownDatabase</li>
1:b004dff:  *   <li>attributesAsPassword</li>
1:b004dff:  * </ul>
1:b004dff:  * <br>
1:b004dff:  * See the specific Derby DataSource implementation for details on their
1:b004dff:  * meaning.
1:b004dff:  * <p/>
1:b004dff:  * See also the JDBC specifications for more details.
1:4e0e1f1:  *
1:a086620:  * @see EmbeddedDataSource
1:4e0e1f1:  */
1:a086620: public class BasicEmbeddedDataSource40 
1:a086620:     implements javax.sql.DataSource, java.io.Serializable, 
1:a086620:                EmbeddedDataSourceInterface
1:a086620: {
1:7863d83: 
1:7863d83:     private static final long serialVersionUID = -4945135214995641182L;
1:7863d83: 
1:a086620:     /**
1:b004dff:      * Set by {@link #setDescription(java.lang.String)}.
1:b004dff:      * @serial
1:b004dff:      */
1:b004dff:     protected String description;
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * Set by {@link #setDataSourceName(java.lang.String)}.
1:b004dff:      * @serial
1:b004dff:      */
1:b004dff:     protected String dataSourceName;
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * Set by {@link #setDatabaseName(java.lang.String)}.
1:b004dff:      * @serial
1:b004dff:      */
1:b004dff:     protected String databaseName;
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * Derby specific connection attributes. Set by
1:b004dff:      * {@link #setConnectionAttributes(java.lang.String)}.
1:a086620:      * @serial
1:a086620:      */
1:a086620:     protected String connectionAttributes;
1:7863d83: 
1:a086620:     /**
1:a086620:      * Set to "create" if the database should be created.
1:b004dff:      * See {@link #setCreateDatabase(java.lang.String)}.
1:a086620:      * @serial
1:a086620:      */
1:a086620:     protected String createDatabase;
1:a086620: 
1:a086620:     /**
1:b004dff:      * Set to "shutdown" if the database should be shutdown. See {@link
1:b004dff:      * #setShutdownDatabase(java.lang.String)}.
1:a086620:      * @serial
1:a086620:      */
1:a086620:     protected String shutdownDatabase;
1:a086620: 
1:a086620:     /**
1:a086620:      * Set password to be a set of connection attributes.
1:b004dff:      * @serial
1:a086620:      */
1:a086620:     protected boolean attributesAsPassword;
1:a086620: 
1:b004dff:     /**
1:b004dff:      * {@code shortDatabaseName} has attributes of {@code databaseName}
1:b004dff:      * stripped off. See {@link #databaseName}.
1:b004dff:      * @serial
1:b004dff:      */
1:a086620:     private String shortDatabaseName;
1:a086620: 
1:b004dff:     /**
1:b004dff:      * Set by {@link #setPassword(java.lang.String)}.
1:b004dff:      * @serial
1:b004dff:      */
1:a086620:     private String password;
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * Set by {@link #setUser(java.lang.String)}.
1:b004dff:      * @serial
1:b004dff:      */
1:a086620:     private String user;
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * Set by {@link #setLoginTimeout(int)}.
1:b004dff:      * @serial
1:b004dff:      */
1:a086620:     protected int loginTimeout;
1:a086620: 
1:b004dff:     /**
1:b004dff:      * Instance variable that will not be serialized.
1:b004dff:      */
1:a086620:     transient private PrintWriter printer;
1:b004dff: 
1:b004dff:     /**
1:b004dff:      * Instance variable that will not be serialized.
1:b004dff:      */
1:a086620:     transient protected String jdbcurl;
1:a086620: 
1:b004dff:     /**
1:b004dff:      * Unlike a DataSource, the internal driver is shared by all
1:b004dff:      * Derby databases in the same JVM.
1:b004dff:      */
1:a086620:     transient protected InternalDriver driver;
1:a086620: 
1:b004dff:     /**
1:b004dff:      * Constructs a basic embedded data source. See the class Javadoc.
1:b004dff:      */
1:a086620:     public BasicEmbeddedDataSource40() {
1:a086620:         update();
12:7863d83:     }
1:7863d83: 
1:a086620:    /*
1:a086620:      * Properties to be seen by Bean - access through reflection.
1:a086620:      */
1:a086620: 
1:b004dff:     /**
1:a086620:      * Set the database name.  Setting this property is mandatory.  If a
1:a086620:      * database named wombat at g:/db needs to be accessed, database name
1:a086620:      * should be set to "g:/db/wombat".  The database will be booted if it
1:a086620:      * is not already running in the system.
1:a086620:      *
1:a086620:      * @param databaseName the name of the database
1:a086620:      */
15:7863d83:     @Override
1:a086620:     public synchronized void setDatabaseName(String databaseName) {
1:a086620:         this.databaseName = databaseName;
1:a086620: 
1:a086620:         if( databaseName!= null && databaseName.contains(";")) {
1:a086620:             String[] dbShort = databaseName.split(";");
1:a086620:             this.shortDatabaseName = dbShort[0];
1:a086620:         } else {
1:a086620:             this.shortDatabaseName = databaseName;
1:a086620:         }
1:a086620: 
1:a086620:         update();
1:7863d83:     }
1:7863d83: 
1:a086620:     /**
1:a086620:      * @return the database name set by {@link #setDatabaseName}.
1:a086620:      */
1:7863d83:     @Override
1:7863d83:     public String getDatabaseName() {
1:a086620:         return databaseName;
1:7863d83:     }
1:7863d83: 
1:b004dff:     /**
1:b004dff:      * Return database name with ant attributes stripped off.
1:b004dff:     */
1:a086620:     private String getShortDatabaseName() {
1:a086620:         return shortDatabaseName;
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * Set the data source name.  The property is not mandatory.  It is used
1:a086620:      * for informational purposes only.
1:a086620:      *
1:a086620:      *  @param dsn the name of the data source
1:a086620:      */
1:7863d83:     @Override
1:a086620:     public void setDataSourceName(String dsn) {
1:a086620:         dataSourceName = dsn;
1:7863d83:     }
1:7863d83: 
1:a086620:     /**
1:a086620:      * @return data source name as set in {@link #setDataSourceName}.
1:a086620:      */
1:7863d83:     @Override
1:7863d83:     public String getDataSourceName() {
1:a086620:         return dataSourceName;
1:7863d83:     }
1:7863d83: 
1:a086620:     /**
1:a086620:      * Set the data source descripton. This property is not mandatory.
1:a086620:      * It is used for informational purposes only.
1:a086620:      *
1:a086620:      * @param desc the description of the data source
1:a086620:      */
1:7863d83:     @Override
1:a086620:     public void setDescription(String desc) {
1:a086620:         description = desc;
1:7863d83:     }
1:7863d83: 
1:a086620:     /**
1:a086620:      * @return the description as set in {@link #setDescription}.
1:a086620:      */
1:7863d83:     @Override
1:7863d83:     public String getDescription() {
1:a086620:         return description;
1:7863d83:     }
1:7863d83: 
1:a086620:     /**
1:a086620:      * Set the {@code user} property for the data source.
1:a086620:      * <p/>
1:a086620:      * This is user name for any data source {@code getConnection()} call
1:a086620:      * that takes no arguments.
1:a086620:      * @param user The user
1:a086620:     */
1:7863d83:     @Override
1:7863d83:     public void setUser(String user) {
1:a086620:         this.user = user;
1:7863d83:     }
1:7863d83: 
1:a086620:     /**
1:a086620:      * @return the user name as set by {@link #setUser}.
1:a086620:      */
1:7863d83:     @Override
1:7863d83:     public String getUser() {
1:a086620:         return user;
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * Set the {@code password} property for the data source.
1:a086620:      * <p/>
1:a086620:      * This is user's password for any data source {@code getConnection()} call
1:a086620:      * that takes no arguments.
1:a086620:      * @param password The password in plain text
1:a086620:      */
1:a086620:     @Override
1:a086620:     public void setPassword(String password) {
1:a086620:         this.password = password;
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * @return the password as set in {@link #setPassword}.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public String getPassword() {
1:a086620:         return password;
1:a086620:     }
1:a086620: 
1:a086620:     /*
1:a086620:      * DataSource methods
1:a086620:      */
1:a086620: 
1:a086620:     /**
1:a086620:      * Gets the maximum time in seconds that this data source can wait
1:a086620:      * while attempting to connect to a database.  A value of zero
1:a086620:      * means that the timeout is the default system timeout
1:a086620:      * if there is one; otherwise it means that there is no timeout.
1:a086620:      * When a data source object is created, the login timeout is
1:a086620:      * initially zero. See {@link #setLoginTimeout}.
1:a086620:      *
1:a086620:      * @return the data source login time limit
1:a086620:      * @exception SQLException if a database access error occurs.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public int getLoginTimeout() throws SQLException {
1:a086620:         return loginTimeout;
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * Sets the maximum time in seconds that this data source will wait
1:a086620:      * while attempting to connect to a database.  A value of zero
1:a086620:      * specifies that the timeout is the default system timeout
1:a086620:      * if there is one; otherwise it specifies that there is no timeout.
1:a086620:      * When a data source object is created, the login timeout is
1:a086620:      * initially zero.
1:a086620:      * <p/>
1:a086620:      * <b>Derby currently ignores this property.</b>
1:a086620:      *
1:a086620:      * @param seconds the data source login time limit
1:a086620:      * @exception SQLException if a database access error occurs.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public void setLoginTimeout(int seconds) throws SQLException {
1:a086620:         loginTimeout = seconds;
1:a086620:     }
1:a086620: 
1:a086620: 
1:a086620:     /**
1:a086620:      * Get the log writer for this data source.
1:a086620:      * <p/>
1:a086620:      * The log writer is a character output stream to which all logging
1:a086620:      * and tracing messages for this data source object instance will be
1:a086620:      * printed.  This includes messages printed by the methods of this
1:a086620:      * object, messages printed by methods of other objects manufactured
1:a086620:      * by this object, and so on.  Messages printed to a data source
1:a086620:      * specific log writer are not printed to the log writer associated
1:a086620:      * with the {@code java.sql.Drivermanager} class.
1:a086620:      * When a data source object is created the log writer is
1:a086620:      * initially null, in other words, logging is disabled.
1:a086620:      *
1:a086620:      * @return the log writer for this data source, null if disabled
1:a086620:      * @exception SQLException if a database-access error occurs.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public PrintWriter getLogWriter() throws SQLException {
1:a086620:         return printer;
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * Set the log writer for this data source.
1:a086620:      * <p/>
1:a086620:      * The log writer is a character output stream to which all logging
1:a086620:      * and tracing messages for this data source object instance will be
1:a086620:      * printed.  This includes messages printed by the methods of this
1:a086620:      * object, messages printed by methods of other objects manufactured
1:a086620:      * by this object, and so on.  Messages printed to a data source
1:a086620:      * specific log writer are not printed to the log writer associated
1:a086620:      * with the {@code java.sql.Drivermanager} class.
1:a086620:      * When a data source object is created the log writer is
1:a086620:      * initially null, in other words, logging is disabled.
1:a086620:      *
1:a086620:      * @param out the new log writer; to disable, set to null
1:a086620:      * @exception SQLException if a database-access error occurs.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public void setLogWriter(PrintWriter out) throws SQLException {
1:a086620:         printer = out;
1:a086620:     }
1:b004dff: 
1:a086620: 
1:b004dff:     /**
1:b004dff:      * Update {@link #jdbcurl} from attributes set.
1:b004dff:      */
1:a086620:     protected void update() {
1:a086620:         StringBuilder sb = new StringBuilder(64);
1:a086620: 
1:a086620:         sb.append(Attribute.PROTOCOL);
1:a086620: 
1:a086620:         // Set the database name from the databaseName property
1:a086620:         String dbName = getDatabaseName();
1:a086620: 
1:a086620:         if (dbName != null) {
1:a086620:             dbName = dbName.trim();
1:a086620:         }
1:a086620: 
1:a086620:         if (dbName == null || dbName.length() == 0) {
1:a086620:             // need to put something in so that we do not allow the
1:a086620:             // database name to be set from the request or from the
1:a086620:             // connection attributes.
1:a086620: 
1:a086620:             // this space will selected as the database name (and
1:a086620:             // trimmed to an empty string) See the getDatabaseName()
1:a086620:             // code in InternalDriver. Since this is a non-null value,
1:a086620:             // it will be selected over any databaseName connection
1:a086620:             // attribute.
1:a086620:             dbName = " ";
1:a086620:         }
1:a086620: 
1:a086620:         sb.append(dbName);
1:a086620:         String connAttrs = getConnectionAttributes();
1:a086620: 
1:a086620:         if (connAttrs != null) {
1:a086620:             connAttrs = connAttrs.trim();
1:a086620: 
1:a086620:             if (connAttrs.length() != 0) {
1:a086620:                 sb.append(';');
1:a086620:                 sb.append(connectionAttributes);
1:a086620:             }
1:a086620:         }
1:a086620: 
1:a086620:         jdbcurl = sb.toString();
1:a086620:     }
1:a086620: 
1:a086620:     /*
1:a086620:      * Properties to be seen by Bean - access thru reflection.
1:a086620:      */
1:a086620: 
1:a086620:     /**
1:a086620:      * Set this property to create a new database.  If this property
1:a086620:      * is not set, the database (identified by {@code databaseName})
1:a086620:      * is assumed to be already existing.
1:a086620:      *
1:a086620:      * @param create if set to the string {@code "create"}, this data
1:a086620:      * source will try to create a new database of databaseName, or
1:a086620:      * boot the database if one by that name already exists.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public void setCreateDatabase(String create) {
1:a086620:         if (create != null &&
1:a086620:             create.toLowerCase(java.util.Locale.ENGLISH).equals("create")) {
1:a086620:             createDatabase = create;
1:a086620:         } else {
1:a086620:             createDatabase = null;
1:a086620:         }
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * @return The string {@code "create"} if create is set, or {@code
1:a086620:      * null} if not
1:a086620:      */
1:a086620:     @Override
1:a086620:     public String getCreateDatabase() {
1:a086620:         return createDatabase;
1:a086620:     }
1:a086620: 
1:b004dff:     /**
1:b004dff:      * Return a handle to the internal driver, possibly instantiating it first
1:b004dff:      * if it hasn't been booted or if it has been shut down.
1:b004dff:      *
1:b004dff:      * @return The internal driver handle
1:b004dff:      * @throws SQLException
1:b004dff:      */
1:a086620:     @SuppressWarnings("ResultOfObjectAllocationIgnored")
1:a086620:     InternalDriver findDriver() throws SQLException {
1:a086620:         String url = jdbcurl;
1:a086620: 
1:a086620:         synchronized(this) {
1:a086620:             // The driver has either never been booted, or it has been
1:a086620:             // shutdown by a 'jdbc:derby:;shutdown=true'
1:a086620:             if (driver == null || !driver.acceptsURL(url)) {
1:a086620: 
1:a086620:                 new org.apache.derby.jdbc.EmbeddedDriver();
1:a086620: 
1:a086620:                 // If we know the driver, we loaded it.   Otherwise only
1:a086620:                 // work if DriverManager has already loaded it.
1:a086620:                 // DriverManager will throw an exception if driver is not found
1:a086620:                 Driver registerDriver = DriverManager.getDriver(url);
1:a086620: 
1:a086620:                 if (registerDriver instanceof AutoloadedDriver) {
1:a086620:                     driver =
1:a086620:                         (InternalDriver)AutoloadedDriver.getDriverModule();
1:a086620:                 } else {
1:a086620:                     driver = (InternalDriver) registerDriver;
1:a086620:                 }
1:a086620:             }
1:a086620:             // else driver != null and driver can accept url
1:a086620:         }
1:a086620: 
1:a086620:         return driver;
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * Set this property to pass in more Derby specific connection URL
1:a086620:      * attributes.
1:a086620:      * <br>
1:a086620:      * Any attributes that can be set using a property of this DataSource
1:a086620:      * implementation (e.g user, password) should not be set in connection
1:a086620:      * attributes. Conflicting settings in connection attributes and
1:a086620:      * properties of the DataSource will lead to unexpected behaviour.
1:a086620:      *
1:a086620:      * @param prop set to the list of Derby connection attributes
1:a086620:      * separated by semi-colons.  E.g., to specify an encryption
1:a086620:      * bootPassword of "x8hhk2adf", and set upgrade to true, do the
1:a086620:      * following:
1:a086620:      *
1:a086620:      * <pre>
1:a086620:      *     ds.setConnectionAttributes("bootPassword=x8hhk2adf;upgrade=true");
1:a086620:      * </pre>
1:a086620:      *
1:a086620:      * See the Derby documentation for complete list.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public void setConnectionAttributes(String prop) {
1:a086620:          connectionAttributes = prop;
1:a086620:          update();
1:a086620:     }
1:a086620: 
1:a086620: 
1:a086620:     /**
1:a086620:      * @return the Derby specific connection URL attributes, see
1:a086620:      * {@link #setConnectionAttributes}.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public String getConnectionAttributes() {
1:a086620:         return connectionAttributes;
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * Set this property if you wish to shutdown the database identified by
1:a086620:      * {@code databaseName}.
1:a086620:      *
1:a086620:      * @param shutdown if set to the string {@code "shutdown"}, this
1:a086620:      * data source will shutdown the database if it is running.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public void setShutdownDatabase(String shutdown) {
1:a086620:         if (shutdown != null && shutdown.equalsIgnoreCase("shutdown")) {
1:a086620:             shutdownDatabase = shutdown;
1:a086620:         } else {
1:a086620:             shutdownDatabase = null;
1:a086620:         }
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * @return the string {@code "shutdown"} if shutdown is set, or
1:a086620:      * null if not, cf.  {@link #setShutdownDatabase}.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public String getShutdownDatabase() {
1:a086620:         return shutdownDatabase;
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * Set {@code attributeAsPassword} property to enable passing connection
1:a086620:      * request attributes in the password argument of
1:a086620:      * {@link #getConnection(String,String)}.
1:a086620: 
1:a086620:      * If the property is set to {@code true} then the {@code password}
1:a086620:      * argument of the {@link #getConnection(String, String)}
1:a086620:      * method call is taken to be a list of connection attributes with the
1:a086620:      * same format as the {@code connectionAttributes} property.
1:a086620:      *
1:a086620:      * @param attributesAsPassword Use {@code true} to encode password
1:a086620:      * argument as a set of connection attributes in a connection request.
1:a086620:      */
1:a086620:     @Override
1:a086620:     public void setAttributesAsPassword(boolean attributesAsPassword) {
1:a086620:         this.attributesAsPassword = attributesAsPassword;
1:a086620:         update();
1:a086620:     }
1:a086620: 
1:a086620:     /**
1:a086620:      * Return the value of the {@code attributesAsPassword} property, cf.
1:a086620:      * {@link #setAttributesAsPassword}.
1:a086620:      * @return the value
1:a086620:      */
1:a086620:     @Override
1:a086620:     public boolean getAttributesAsPassword() {
1:a086620:         return attributesAsPassword;
1:a086620:     }
1:a086620: 
1:b004dff:      // Most of our customers would be using JNDI to get the data
1:b004dff:      // sources. Since we don't have a JNDI in the test setup to test this, we
1:b004dff:      // are adding this method to fake it. This is getting used in XAJNDITest
1:b004dff:      // so we can compare the two data sources.
1:a086620:     @Override
1:b004dff:     public boolean equals(Object other) {
1:a086620: 
1:b004dff:         if (other instanceof EmbeddedDataSource) {
1:b004dff:             EmbeddedDataSource ds = (EmbeddedDataSource)other;
1:a086620: 
1:a086620:             boolean match = true;
1:a086620: 
1:a086620:             if (databaseName != null) {
1:a086620:                 if  (!(databaseName.equals(ds.databaseName)))
1:a086620:                     match = false;
1:a086620:             } else if (ds.databaseName != null) {
1:a086620:                 match = false;
1:a086620:             }
1:a086620: 
1:a086620:             if (dataSourceName != null) {
1:a086620:                 if  (!(dataSourceName.equals(ds.dataSourceName))) {
1:a086620:                     match = false;
1:a086620:                 }
1:a086620:             } else if (ds.dataSourceName != null) {
1:a086620:                 match = false;
1:a086620:             }
1:a086620: 
1:a086620:             if (description != null) {
1:a086620:                 if  (!(description.equals(ds.description))) {
1:a086620:                     match = false;
1:a086620:                 }
1:a086620:             } else if (ds.description != null) {
1:a086620:                 match = false;
1:a086620:             }
1:a086620: 
1:a086620:             if (createDatabase != null) {
1:a086620:                 if  (!(createDatabase.equals(ds.createDatabase))) {
1:a086620:                     match = false;
1:a086620:                 }
1:a086620:             } else if (ds.createDatabase != null) {
1:a086620:                 match = false;
1:a086620:             }
1:a086620: 
1:a086620:             if (shutdownDatabase != null) {
1:a086620:                 if  (!(shutdownDatabase.equals(ds.shutdownDatabase))) {
1:a086620:                     match = false;
1:a086620:                 }
1:a086620:             } else if (ds.shutdownDatabase != null) {
1:a086620:                 match = false;
1:a086620:             }
1:a086620: 
1:a086620:             if (connectionAttributes != null) {
1:a086620:                 if  (!(connectionAttributes.equals(ds.connectionAttributes))) {
1:a086620:                     match = false;
1:a086620:                 }
1:a086620:             } else if (ds.connectionAttributes != null) {
1:a086620:                 match = false;
1:a086620:             }
1:a086620: 
1:a086620:             if (loginTimeout != ds.loginTimeout) {
1:a086620:                 match = false;
1:a086620:             }
1:a086620: 
1:a086620:             return match;
1:a086620: 
1:a086620:         }
1:a086620: 
1:a086620:         return false;
1:7863d83:     }
1:7863d83: 
1:b004dff:     // We don't really need this in the tests
1:b004dff:     // (see equals), but unsafe not to
1:b004dff:     // define hashCode if we define equals.
1:7863d83:     @Override
1:a086620:     public int hashCode() {
1:a086620:         int hash = 5;
1:a086620:         hash = 29 * hash +
1:a086620:             (this.description != null ?
1:a086620:              this.description.hashCode() : 0);
1:a086620:         hash = 29 * hash +
1:a086620:             (this.dataSourceName != null ?
1:a086620:              this.dataSourceName.hashCode() : 0);
1:a086620:         hash = 29 * hash +
1:a086620:             (this.databaseName != null ?
1:a086620:              this.databaseName.hashCode() : 0);
1:a086620:         hash = 29 * hash +
1:a086620:             (this.connectionAttributes != null ?
1:a086620:              this.connectionAttributes.hashCode() : 0);
1:a086620:         hash = 29 * hash +
1:a086620:             (this.createDatabase != null ?
1:a086620:              this.createDatabase.hashCode() : 0);
1:a086620:         hash = 29 * hash +
1:a086620:             (this.shutdownDatabase != null ?
1:a086620:              this.shutdownDatabase.hashCode() : 0);
1:a086620:         hash = 29 * hash +
1:a086620:             this.loginTimeout;
1:a086620:         return hash;
1:7863d83:     }
1:7863d83: 
1:7863d83: 
1:a086620:     /*
1:a086620:      * DataSource methods - keep these non-final so that others can
1:a086620:      * extend Derby's classes if they choose to.
1:a086620:      */
1:a086620: 
1:a086620: 
1:a086620:     /**
1:a086620:      * Attempt to establish a database connection.
1:a086620:      *
1:a086620:      * @return  a Connection to the database
1:a086620:      * @exception SQLException if a database-access error occurs.
1:a086620:      */
1:7863d83:     @Override
1:7863d83:     public Connection getConnection() throws SQLException {
1:a086620:         return this.getConnection(getUser(), getPassword(), false);
1:7863d83:     }
1:7863d83: 
1:a086620:     /**
1:a086620:      * Attempt to establish a database connection with the given username and
1:a086620:      * password.  If the {@code attributeAsPassword} property is set to true
1:a086620:      * then the password argument is taken to be a list of connection
1:a086620:      * attributes with the same format as the {@code connectionAttributes}
1:a086620:      * property.
1:a086620:      *
1:a086620:      * @param username the database user on whose behalf the Connection is
1:a086620:      *     being made
1:a086620:      * @param password the user's password
1:a086620:      * @return  a Connection to the database
1:a086620:      * @exception SQLException if a database-access error occurs.
1:a086620:      */
1:7863d83:     @Override
1:a086620:     public Connection getConnection(String username, String password)
2:7863d83:             throws SQLException {
1:a086620:         return this.getConnection(username, password, true);
1:7863d83:     }
1:7863d83: 
1:b004dff:     /**
1:b004dff:      * Get a user connection: minion method.
1:b004dff:      *
1:b004dff:      * @param username the user name
1:b004dff:      * @param password the password
1:b004dff:      * @param requestPassword {@code true} if the password came from the
1:b004dff:      *        getConnection() call with user and password arguments..
1:b004dff:      * @return user connection
1:b004dff:      * @throws SQLException
1:b004dff:      */
1:a086620:     final Connection getConnection(String username,
1:a086620:                                    String password,
1:a086620:                                    boolean requestPassword)
1:a086620:             throws SQLException {
1:a086620: 
1:a086620:         Properties info = new Properties();
1:a086620: 
1:a086620:         if (username != null) {
1:a086620:             info.put(Attribute.USERNAME_ATTR, username);
1:a086620:         }
1:a086620: 
1:a086620:         if (!requestPassword || !attributesAsPassword) {
1:a086620:             if (password != null) {
1:a086620:                 info.put(Attribute.PASSWORD_ATTR, password);
1:a086620:             }
1:a086620:         }
1:a086620: 
1:a086620:         if (createDatabase != null) {
1:a086620:             info.put(Attribute.CREATE_ATTR, "true");
1:a086620:         }
1:a086620: 
1:a086620:         if (shutdownDatabase != null) {
1:a086620:             info.put(Attribute.SHUTDOWN_ATTR, "true");
1:a086620:         }
1:a086620: 
1:a086620:         String url = jdbcurl;
1:a086620: 
1:a086620:         if (attributesAsPassword && requestPassword && password != null) {
1:a086620:             StringBuilder sb =
1:a086620:                 new StringBuilder(url.length() + password.length() + 1);
1:a086620: 
1:a086620:             sb.append(url);
1:a086620:             sb.append(';');
1:a086620:             sb.append(password); // these are now request attributes on the URL
1:a086620: 
1:a086620:             url = sb.toString();
1:a086620:         }
1:a086620: 
1:a086620:         Connection conn =  findDriver().connect( url, info, loginTimeout );
1:a086620: 
1:a086620:         // JDBC driver's getConnection method returns null if
1:a086620:         // the driver does not handle the request's URL.
1:a086620:         if (conn == null) {
1:a086620:            throw Util.generateCsSQLException(SQLState.PROPERTY_INVALID_VALUE,
1:a086620:                                              Attribute.DBNAME_ATTR,
1:a086620:                                              getDatabaseName());
1:a086620:         }
1:a086620: 
1:a086620:         return conn;
1:a086620:     }
1:a086620: 
1:a086620:     // JDBC 4.0 java.sql.Wrapper interface methods
1:a086620: 
1:a086620:     /**
1:a086620:      * Returns false unless {@code interFace} is implemented.
1:a086620:      *
1:a086620:      * @param interFace a class defining an interface
1:a086620:      * @return {@code true} if this implements the interface or directly or
1:a086620:      *     indirectly wraps an object that does
1:a086620:      * @throws SQLException if an error occurs while determining
1:a086620:      *     whether this is a wrapper for an object with the given interface
1:a086620:      */
1:7863d83:     @Override
1:a086620:     public boolean isWrapperFor(Class<?> interFace) throws SQLException {
1:a086620:         return interFace.isInstance(this);
1:7863d83:     }
1:7863d83: 
1:a086620:     /**
1:a086620:      * Returns {@code this} if this class implements the specified interface.
1:a086620:      *
1:a086620:      * @param iface a class defining an interface
1:a086620:      * @return an object that implements the interface
1:a086620:      * @throws SQLException if no object is found that implements the
1:a086620:      * interface
1:a086620:      */
1:7863d83:     @Override
1:7863d83:     public <T> T unwrap(Class<T> iface) throws SQLException {
1:a086620:         // Derby does not implement non-standard methods on JDBC objects,
1:a086620:         // hence return this if this class implements the interface, or
1:a086620:         // throw an SQLException.
1:a086620:         try {
1:a086620:             return iface.cast(this);
1:a086620:         } catch (ClassCastException cce) {
1:a086620:             throw Util.generateCsSQLException(SQLState.UNABLE_TO_UNWRAP,
1:a086620:                     iface);
1:a086620:         }
1:7863d83:     }
1:7863d83: 
1:4e0e1f1:     /**
1:b004dff:      * Return a resource adapter. Use {@code ra} if non-null and active, else
1:b004dff:      * get the one for the data base.
1:b004dff:      *
1:b004dff:      * @param ds The data source
1:b004dff:      * @param ra The cached value if any
1:b004dff:      * @param user The user name
1:b004dff:      * @param password The password in clear text
1:b004dff:      * @param requestPassword If {@code true}, use the supplied user and
1:b004dff:      *                        password to boot the database if required
1:b004dff:      * @return the resource adapter
1:b004dff:      * @throws SQLException An error occurred
1:b004dff:      */
1:a086620:     protected static ResourceAdapter setupResourceAdapter(
1:a086620:         EmbeddedXADataSourceInterface ds,
1:a086620:         ResourceAdapter ra,
1:a086620:         String user,
1:a086620:         String password,
1:a086620:         boolean requestPassword) throws SQLException {
1:a086620: 
1:a086620:         synchronized(ds) {
1:a086620:             if (ra == null || !ra.isActive()) {
1:a086620:                 // If it is inactive, it is useless.
1:a086620:                 ra = null;
1:a086620: 
1:a086620:                 // DERBY-4907 make sure the database name sent to find service
1:a086620:                 // does not include attributes.
1:a086620:                 String dbName =
1:a086620:                     ((BasicEmbeddedDataSource40)ds).getShortDatabaseName();
1:a086620: 
1:a086620:                 if (dbName != null) {
1:a086620:                     // see if database already booted, if it is, then
1:a086620:                     // don't make a connection.
1:a086620:                     Database database = null;
1:a086620: 
1:a086620:                     // if monitor is never setup by any ModuleControl,
1:a086620:                     // getMonitor returns null and no Derby database
1:a086620:                     // has been booted.
1:56c1dc2:                     if (getMonitor() != null) {
1:a086620:                         database = (Database)
1:56c1dc2:                             findService(Property.DATABASE_MODULE,
1:a086620:                                                 dbName);
1:a086620:                     }
1:a086620: 
1:a086620:                     if (database == null) {
1:a086620:                         // If database is not found, try connecting to it.
1:a086620:                         // This boots and/or creates the database.  If
1:a086620:                         // database cannot be found, this throws SQLException.
1:a086620:                         if (requestPassword) {
1:a086620:                             ds.getConnection(user, password).close();
1:a086620:                         } else {
1:a086620:                             ds.getConnection().close();
1:a086620:                         }
1:a086620: 
1:a086620:                         // now try to find it again
1:a086620:                         database = (Database)
1:56c1dc2:                             findService(Property.DATABASE_MODULE,
1:a086620:                                                 dbName);
1:a086620:                     }
1:a086620: 
1:a086620:                     if (database != null) {
1:a086620:                         ra = (ResourceAdapter) database.getResourceAdapter();
1:a086620:                     }
1:a086620:                 }
1:a086620: 
1:a086620:                 if (ra == null) {
1:a086620:                     throw new SQLException(
1:a086620:                         MessageService.getTextMessage(
1:a086620:                             MessageId.CORE_DATABASE_NOT_AVAILABLE),
1:a086620:                         "08006",
1:a086620:                         ExceptionSeverity.DATABASE_SEVERITY);
1:a086620:                 }
1:a086620: 
1:a086620:                 // If database is already up, we need to set up driver
1:a086620:                 // seperately.
1:a086620:                 InternalDriver driver =
1:a086620:                     ((BasicEmbeddedDataSource40)ds).findDriver();
1:a086620: 
1:a086620:                 if (driver == null) {
1:a086620:                     throw new SQLException(
1:a086620:                         MessageService.getTextMessage(
1:a086620:                             MessageId.CORE_DRIVER_NOT_AVAILABLE),
1:a086620:                         "08006",
1:a086620:                         ExceptionSeverity.DATABASE_SEVERITY);
1:a086620:                 }
1:a086620:             }
1:a086620:         }
1:a086620: 
1:a086620:         return ra;
1:a086620:     }
1:7863d83:     
1:a086620:     ////////////////////////////////////////////////////////////////////
3:a086620:     //
1:a086620:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:a086620:     //
1:a086620:     ////////////////////////////////////////////////////////////////////
1:a086620: 
1:a086620:     // Cannot add @Override here: the compiler balks since this is compiled
1:a086620:     // with compiler level 1.6 which doesn't specify this method in the
1:a086620:     // JDBC interface (4.0). Add as soon as we move to minimum 1.7.
1:a086620:     public  Logger getParentLogger() throws SQLFeatureNotSupportedException
1:a086620:     {
1:a086620:         throw (SQLFeatureNotSupportedException) Util.generateCsSQLException
1:a086620:             ( SQLState.NOT_IMPLEMENTED, "getParentLogger" );
1:7863d83:     }
1:a086620: 
1:56c1dc2:     ////////////////////////////////////////////////////////////////////
1:56c1dc2:     //
1:56c1dc2:     // SECURITY
1:56c1dc2:     //
1:56c1dc2:     ////////////////////////////////////////////////////////////////////
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     /**
1:56c1dc2:      * Privileged service lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private static  Object findService( final String factoryInterface, final String serviceName )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<Object>()
1:56c1dc2:              {
1:56c1dc2:                  public Object run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.findService( factoryInterface, serviceName );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2:     
1:7863d83: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1:                     if (getMonitor() != null) {
1:                             findService(Property.DATABASE_MODULE,
/////////////////////////////////////////////////////////////////////////
1:                             findService(Property.DATABASE_MODULE,
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // SECURITY
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     /**
1:      * Privileged service lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private static  Object findService( final String factoryInterface, final String serviceName )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<Object>()
1:              {
1:                  public Object run()
1:                  {
1:                      return Monitor.findService( factoryInterface, serviceName );
1:                  }
1:              }
1:              );
1:     }
1:     
commit:78bdf36
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b004dff
/////////////////////////////////////////////////////////////////////////
1:  * <p/>
1:  * The standard attributes provided are, cf. e.g. table
1:  * 9.1 in the JDBC 4.2 specification.
1:  * <ul>
1:  *   <li>databaseName</li>
1:  *   <li>dataSourceName</li>
1:  *   <li>description</li>
1:  *   <li>password</li>
1:  *   <li>user</li>
1:  * </ul>
1:  * These standard attributes are not supported:
1:  * <ul>
1:  *   <li>networkProtocol</li>
1:  *   <li>portNumber</li>
1:  *   <li>roleName</li>
1:  *   <li>serverName</li>
1:  * </ul>
1:  * The embedded Derby driver also supports these attributes:
1:  * <ul>
1:  *   <li>loginTimeout</li> @see javax.sql.CommonDataSource set/get
1:  *   <li>logWriter</li> @see javax.sql.CommonDataSource set/get
1:  *   <li>createDatabase</li>
1:  *   <li>connectionAttributes</li>
1:  *   <li>shutdownDatabase</li>
1:  *   <li>attributesAsPassword</li>
1:  * </ul>
1:  * <br>
1:  * See the specific Derby DataSource implementation for details on their
1:  * meaning.
1:  * <p/>
1:  * See also the JDBC specifications for more details.
/////////////////////////////////////////////////////////////////////////
1:      * Set by {@link #setDescription(java.lang.String)}.
1:      * @serial
1:      */
1:     protected String description;
1: 
1:     /**
1:      * Set by {@link #setDataSourceName(java.lang.String)}.
1:      * @serial
1:      */
1:     protected String dataSourceName;
1: 
1:     /**
1:      * Set by {@link #setDatabaseName(java.lang.String)}.
1:      * @serial
1:      */
1:     protected String databaseName;
1: 
1:     /**
1:      * Derby specific connection attributes. Set by
1:      * {@link #setConnectionAttributes(java.lang.String)}.
1:      * See {@link #setCreateDatabase(java.lang.String)}.
1:      * Set to "shutdown" if the database should be shutdown. See {@link
1:      * #setShutdownDatabase(java.lang.String)}.
1:      * @serial
1:     /**
1:      * {@code shortDatabaseName} has attributes of {@code databaseName}
1:      * stripped off. See {@link #databaseName}.
1:      * @serial
1:      */
1:     /**
1:      * Set by {@link #setPassword(java.lang.String)}.
1:      * @serial
1:      */
1: 
1:     /**
1:      * Set by {@link #setUser(java.lang.String)}.
1:      * @serial
1:      */
1: 
1:     /**
1:      * Set by {@link #setLoginTimeout(int)}.
1:      * @serial
1:      */
1:     /**
1:      * Instance variable that will not be serialized.
1:      */
1: 
1:     /**
1:      * Instance variable that will not be serialized.
1:      */
1:     /**
1:      * Unlike a DataSource, the internal driver is shared by all
1:      * Derby databases in the same JVM.
1:      */
1:     /**
1:      * Constructs a basic embedded data source. See the class Javadoc.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return database name with ant attributes stripped off.
1:     */
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Update {@link #jdbcurl} from attributes set.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return a handle to the internal driver, possibly instantiating it first
1:      * if it hasn't been booted or if it has been shut down.
1:      *
1:      * @return The internal driver handle
1:      * @throws SQLException
1:      */
/////////////////////////////////////////////////////////////////////////
1:      // Most of our customers would be using JNDI to get the data
1:      // sources. Since we don't have a JNDI in the test setup to test this, we
1:      // are adding this method to fake it. This is getting used in XAJNDITest
1:      // so we can compare the two data sources.
1:     public boolean equals(Object other) {
1:         if (other instanceof EmbeddedDataSource) {
1:             EmbeddedDataSource ds = (EmbeddedDataSource)other;
/////////////////////////////////////////////////////////////////////////
1:     // We don't really need this in the tests
1:     // (see equals), but unsafe not to
1:     // define hashCode if we define equals.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get a user connection: minion method.
1:      *
1:      * @param username the user name
1:      * @param password the password
1:      * @param requestPassword {@code true} if the password came from the
1:      *        getConnection() call with user and password arguments..
1:      * @return user connection
1:      * @throws SQLException
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return a resource adapter. Use {@code ra} if non-null and active, else
1:      * get the one for the data base.
1:      *
1:      * @param ds The data source
1:      * @param ra The cached value if any
1:      * @param user The user name
1:      * @param password The password in clear text
1:      * @param requestPassword If {@code true}, use the supplied user and
1:      *                        password to boot the database if required
1:      * @return the resource adapter
1:      * @throws SQLException An error occurred
1:      */
commit:a086620
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Driver;
1: import java.sql.DriverManager;
1: import java.util.Properties;
1: import org.apache.derby.iapi.db.Database;
1: import org.apache.derby.iapi.error.ExceptionSeverity;
1: import org.apache.derby.iapi.jdbc.ResourceAdapter;
1: import org.apache.derby.iapi.reference.Attribute;
1: import org.apache.derby.iapi.reference.MessageId;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.services.monitor.Monitor;
/////////////////////////////////////////////////////////////////////////
1:  * BasicEmbeddedDataSource40 is similar to EmbeddedDataSource, but does
1:  * @see EmbeddedDataSource
1: public class BasicEmbeddedDataSource40 
1:     implements javax.sql.DataSource, java.io.Serializable, 
1:                EmbeddedDataSourceInterface
1: {
0:     protected String description;
0:     protected String dataSourceName;
0:     protected String databaseName;
1:     /**
0:      * Derby specific connection attributes.
1:      * @serial
1:      */
1:     protected String connectionAttributes;
1:     /**
1:      * Set to "create" if the database should be created.
1:      * @serial
1:      */
1:     protected String createDatabase;
1: 
1:     /**
0:      * Set to "shutdown" if the database should be shutdown.
1:      * @serial
1:      */
1:     protected String shutdownDatabase;
1: 
1:     /**
1:      * Set password to be a set of connection attributes.
1:      */
1:     protected boolean attributesAsPassword;
1: 
0:     // shortDatabaseName has attributes of databaseName stripped off
1:     private String shortDatabaseName;
1: 
1:     private String password;
1:     private String user;
1:     protected int loginTimeout;
1: 
0:     // instance variables that will not be serialized
1:     transient private PrintWriter printer;
1:     transient protected String jdbcurl;
1: 
0:     // Unlike a DataSource, LocalDriver is shared by all
0:     // Derby databases in the same jvm.
1:     transient protected InternalDriver driver;
1: 
1:     public BasicEmbeddedDataSource40() {
1:         update();
1:    /*
1:      * Properties to be seen by Bean - access through reflection.
1:      */
1: 
1:     /**
1:      * Set the database name.  Setting this property is mandatory.  If a
1:      * database named wombat at g:/db needs to be accessed, database name
1:      * should be set to "g:/db/wombat".  The database will be booted if it
1:      * is not already running in the system.
1:      *
1:      * @param databaseName the name of the database
1:      */
1:     public synchronized void setDatabaseName(String databaseName) {
1:         this.databaseName = databaseName;
1: 
1:         if( databaseName!= null && databaseName.contains(";")) {
1:             String[] dbShort = databaseName.split(";");
1:             this.shortDatabaseName = dbShort[0];
1:         } else {
1:             this.shortDatabaseName = databaseName;
1:         }
1: 
1:         update();
1:     /**
1:      * @return the database name set by {@link #setDatabaseName}.
1:      */
1:         return databaseName;
1:     //
0:     // Return database name with ant attributes stripped off.
1:     //
1:     private String getShortDatabaseName() {
1:         return shortDatabaseName;
1:     }
1: 
1:     /**
1:      * Set the data source name.  The property is not mandatory.  It is used
1:      * for informational purposes only.
1:      *
1:      *  @param dsn the name of the data source
1:      */
1:     public void setDataSourceName(String dsn) {
1:         dataSourceName = dsn;
1:     /**
1:      * @return data source name as set in {@link #setDataSourceName}.
1:      */
1:         return dataSourceName;
1:     /**
1:      * Set the data source descripton. This property is not mandatory.
1:      * It is used for informational purposes only.
1:      *
1:      * @param desc the description of the data source
1:      */
1:     public void setDescription(String desc) {
1:         description = desc;
1:     /**
1:      * @return the description as set in {@link #setDescription}.
1:      */
1:         return description;
1:     /**
1:      * Set the {@code user} property for the data source.
1:      * <p/>
1:      * This is user name for any data source {@code getConnection()} call
1:      * that takes no arguments.
1:      * @param user The user
1:     */
1:         this.user = user;
1:     /**
1:      * @return the user name as set by {@link #setUser}.
1:      */
1:         return user;
1:     }
1: 
1:     /**
1:      * Set the {@code password} property for the data source.
1:      * <p/>
1:      * This is user's password for any data source {@code getConnection()} call
1:      * that takes no arguments.
1:      * @param password The password in plain text
1:      */
1:     @Override
1:     public void setPassword(String password) {
1:         this.password = password;
1:     }
1: 
1:     /**
1:      * @return the password as set in {@link #setPassword}.
1:      */
1:     @Override
1:     public String getPassword() {
1:         return password;
1:     }
1: 
1:     /*
1:      * DataSource methods
1:      */
1: 
1:     /**
1:      * Gets the maximum time in seconds that this data source can wait
1:      * while attempting to connect to a database.  A value of zero
1:      * means that the timeout is the default system timeout
1:      * if there is one; otherwise it means that there is no timeout.
1:      * When a data source object is created, the login timeout is
1:      * initially zero. See {@link #setLoginTimeout}.
1:      *
1:      * @return the data source login time limit
1:      * @exception SQLException if a database access error occurs.
1:      */
1:     @Override
1:     public int getLoginTimeout() throws SQLException {
1:         return loginTimeout;
1:     }
1: 
1:     /**
1:      * Sets the maximum time in seconds that this data source will wait
1:      * while attempting to connect to a database.  A value of zero
1:      * specifies that the timeout is the default system timeout
1:      * if there is one; otherwise it specifies that there is no timeout.
1:      * When a data source object is created, the login timeout is
1:      * initially zero.
1:      * <p/>
1:      * <b>Derby currently ignores this property.</b>
1:      *
1:      * @param seconds the data source login time limit
1:      * @exception SQLException if a database access error occurs.
1:      */
1:     @Override
1:     public void setLoginTimeout(int seconds) throws SQLException {
1:         loginTimeout = seconds;
1:     }
1: 
1: 
1:     /**
1:      * Get the log writer for this data source.
1:      * <p/>
1:      * The log writer is a character output stream to which all logging
1:      * and tracing messages for this data source object instance will be
1:      * printed.  This includes messages printed by the methods of this
1:      * object, messages printed by methods of other objects manufactured
1:      * by this object, and so on.  Messages printed to a data source
1:      * specific log writer are not printed to the log writer associated
1:      * with the {@code java.sql.Drivermanager} class.
1:      * When a data source object is created the log writer is
1:      * initially null, in other words, logging is disabled.
1:      *
1:      * @return the log writer for this data source, null if disabled
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     @Override
1:     public PrintWriter getLogWriter() throws SQLException {
1:         return printer;
1:     }
1: 
1:     /**
1:      * Set the log writer for this data source.
1:      * <p/>
1:      * The log writer is a character output stream to which all logging
1:      * and tracing messages for this data source object instance will be
1:      * printed.  This includes messages printed by the methods of this
1:      * object, messages printed by methods of other objects manufactured
1:      * by this object, and so on.  Messages printed to a data source
1:      * specific log writer are not printed to the log writer associated
1:      * with the {@code java.sql.Drivermanager} class.
1:      * When a data source object is created the log writer is
1:      * initially null, in other words, logging is disabled.
1:      *
1:      * @param out the new log writer; to disable, set to null
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     @Override
1:     public void setLogWriter(PrintWriter out) throws SQLException {
1:         printer = out;
1:     }
1: 
1:     protected void update() {
1:         StringBuilder sb = new StringBuilder(64);
1: 
1:         sb.append(Attribute.PROTOCOL);
1: 
1:         // Set the database name from the databaseName property
1:         String dbName = getDatabaseName();
1: 
1:         if (dbName != null) {
1:             dbName = dbName.trim();
1:         }
1: 
1:         if (dbName == null || dbName.length() == 0) {
1:             // need to put something in so that we do not allow the
1:             // database name to be set from the request or from the
1:             // connection attributes.
1: 
1:             // this space will selected as the database name (and
1:             // trimmed to an empty string) See the getDatabaseName()
1:             // code in InternalDriver. Since this is a non-null value,
1:             // it will be selected over any databaseName connection
1:             // attribute.
1:             dbName = " ";
1:         }
1: 
1:         sb.append(dbName);
1:         String connAttrs = getConnectionAttributes();
1: 
1:         if (connAttrs != null) {
1:             connAttrs = connAttrs.trim();
1: 
1:             if (connAttrs.length() != 0) {
1:                 sb.append(';');
1:                 sb.append(connectionAttributes);
1:             }
1:         }
1: 
1:         jdbcurl = sb.toString();
1:     }
1: 
1:     /*
1:      * Properties to be seen by Bean - access thru reflection.
1:      */
1: 
1:     /**
1:      * Set this property to create a new database.  If this property
1:      * is not set, the database (identified by {@code databaseName})
1:      * is assumed to be already existing.
1:      *
1:      * @param create if set to the string {@code "create"}, this data
1:      * source will try to create a new database of databaseName, or
1:      * boot the database if one by that name already exists.
1:      */
1:     @Override
1:     public void setCreateDatabase(String create) {
1:         if (create != null &&
1:             create.toLowerCase(java.util.Locale.ENGLISH).equals("create")) {
1:             createDatabase = create;
1:         } else {
1:             createDatabase = null;
1:         }
1:     }
1: 
1:     /**
1:      * @return The string {@code "create"} if create is set, or {@code
1:      * null} if not
1:      */
1:     @Override
1:     public String getCreateDatabase() {
1:         return createDatabase;
1:     }
1: 
1:     @SuppressWarnings("ResultOfObjectAllocationIgnored")
1:     InternalDriver findDriver() throws SQLException {
1:         String url = jdbcurl;
1: 
1:         synchronized(this) {
1:             // The driver has either never been booted, or it has been
1:             // shutdown by a 'jdbc:derby:;shutdown=true'
1:             if (driver == null || !driver.acceptsURL(url)) {
1: 
1:                 new org.apache.derby.jdbc.EmbeddedDriver();
1: 
1:                 // If we know the driver, we loaded it.   Otherwise only
1:                 // work if DriverManager has already loaded it.
1:                 // DriverManager will throw an exception if driver is not found
1:                 Driver registerDriver = DriverManager.getDriver(url);
1: 
1:                 if (registerDriver instanceof AutoloadedDriver) {
1:                     driver =
1:                         (InternalDriver)AutoloadedDriver.getDriverModule();
1:                 } else {
1:                     driver = (InternalDriver) registerDriver;
1:                 }
1:             }
1:             // else driver != null and driver can accept url
1:         }
1: 
1:         return driver;
1:     }
1: 
1:     /**
1:      * Set this property to pass in more Derby specific connection URL
1:      * attributes.
1:      * <br>
1:      * Any attributes that can be set using a property of this DataSource
1:      * implementation (e.g user, password) should not be set in connection
1:      * attributes. Conflicting settings in connection attributes and
1:      * properties of the DataSource will lead to unexpected behaviour.
1:      *
1:      * @param prop set to the list of Derby connection attributes
1:      * separated by semi-colons.  E.g., to specify an encryption
1:      * bootPassword of "x8hhk2adf", and set upgrade to true, do the
1:      * following:
1:      *
1:      * <pre>
1:      *     ds.setConnectionAttributes("bootPassword=x8hhk2adf;upgrade=true");
1:      * </pre>
1:      *
1:      * See the Derby documentation for complete list.
1:      */
1:     @Override
1:     public void setConnectionAttributes(String prop) {
1:          connectionAttributes = prop;
1:          update();
1:     }
1: 
1: 
1:     /**
1:      * @return the Derby specific connection URL attributes, see
1:      * {@link #setConnectionAttributes}.
1:      */
1:     @Override
1:     public String getConnectionAttributes() {
1:         return connectionAttributes;
1:     }
1: 
1:     /**
1:      * Set this property if you wish to shutdown the database identified by
1:      * {@code databaseName}.
1:      *
1:      * @param shutdown if set to the string {@code "shutdown"}, this
1:      * data source will shutdown the database if it is running.
1:      */
1:     @Override
1:     public void setShutdownDatabase(String shutdown) {
1:         if (shutdown != null && shutdown.equalsIgnoreCase("shutdown")) {
1:             shutdownDatabase = shutdown;
1:         } else {
1:             shutdownDatabase = null;
1:         }
1:     }
1: 
1:     /**
1:      * @return the string {@code "shutdown"} if shutdown is set, or
1:      * null if not, cf.  {@link #setShutdownDatabase}.
1:      */
1:     @Override
1:     public String getShutdownDatabase() {
1:         return shutdownDatabase;
1:     }
1: 
1:     /**
1:      * Set {@code attributeAsPassword} property to enable passing connection
1:      * request attributes in the password argument of
1:      * {@link #getConnection(String,String)}.
1: 
1:      * If the property is set to {@code true} then the {@code password}
1:      * argument of the {@link #getConnection(String, String)}
1:      * method call is taken to be a list of connection attributes with the
1:      * same format as the {@code connectionAttributes} property.
1:      *
1:      * @param attributesAsPassword Use {@code true} to encode password
1:      * argument as a set of connection attributes in a connection request.
1:      */
1:     @Override
1:     public void setAttributesAsPassword(boolean attributesAsPassword) {
1:         this.attributesAsPassword = attributesAsPassword;
1:         update();
1:     }
1: 
1:     /**
1:      * Return the value of the {@code attributesAsPassword} property, cf.
1:      * {@link #setAttributesAsPassword}.
1:      * @return the value
1:      */
1:     @Override
1:     public boolean getAttributesAsPassword() {
1:         return attributesAsPassword;
1:     }
1: 
0:     // Most of our customers would be using JNDI to get the data
0:     // sources. Since we don't have a jndi in the test setup to test this, we
0:     // are adding this method to fake it. This is getting used in XAJNDITest
0:     // so we can compare the two data sources.
1:     @Override
0:     public boolean equals(Object p0) {
1: 
0:         if (p0 instanceof EmbeddedDataSource) {
0:             EmbeddedDataSource ds = (EmbeddedDataSource)p0;
1: 
1:             boolean match = true;
1: 
1:             if (databaseName != null) {
1:                 if  (!(databaseName.equals(ds.databaseName)))
1:                     match = false;
1:             } else if (ds.databaseName != null) {
1:                 match = false;
1:             }
1: 
1:             if (dataSourceName != null) {
1:                 if  (!(dataSourceName.equals(ds.dataSourceName))) {
1:                     match = false;
1:                 }
1:             } else if (ds.dataSourceName != null) {
1:                 match = false;
1:             }
1: 
1:             if (description != null) {
1:                 if  (!(description.equals(ds.description))) {
1:                     match = false;
1:                 }
1:             } else if (ds.description != null) {
1:                 match = false;
1:             }
1: 
1:             if (createDatabase != null) {
1:                 if  (!(createDatabase.equals(ds.createDatabase))) {
1:                     match = false;
1:                 }
1:             } else if (ds.createDatabase != null) {
1:                 match = false;
1:             }
1: 
1:             if (shutdownDatabase != null) {
1:                 if  (!(shutdownDatabase.equals(ds.shutdownDatabase))) {
1:                     match = false;
1:                 }
1:             } else if (ds.shutdownDatabase != null) {
1:                 match = false;
1:             }
1: 
1:             if (connectionAttributes != null) {
1:                 if  (!(connectionAttributes.equals(ds.connectionAttributes))) {
1:                     match = false;
1:                 }
1:             } else if (ds.connectionAttributes != null) {
1:                 match = false;
1:             }
1: 
1:             if (loginTimeout != ds.loginTimeout) {
1:                 match = false;
1:             }
1: 
1:             return match;
1: 
1:         }
1: 
1:         return false;
1:     public int hashCode() {
1:         int hash = 5;
1:         hash = 29 * hash +
1:             (this.description != null ?
1:              this.description.hashCode() : 0);
1:         hash = 29 * hash +
1:             (this.dataSourceName != null ?
1:              this.dataSourceName.hashCode() : 0);
1:         hash = 29 * hash +
1:             (this.databaseName != null ?
1:              this.databaseName.hashCode() : 0);
1:         hash = 29 * hash +
1:             (this.connectionAttributes != null ?
1:              this.connectionAttributes.hashCode() : 0);
1:         hash = 29 * hash +
1:             (this.createDatabase != null ?
1:              this.createDatabase.hashCode() : 0);
1:         hash = 29 * hash +
1:             (this.shutdownDatabase != null ?
1:              this.shutdownDatabase.hashCode() : 0);
1:         hash = 29 * hash +
1:             this.loginTimeout;
1:         return hash;
1:     /*
1:      * DataSource methods - keep these non-final so that others can
1:      * extend Derby's classes if they choose to.
1:      */
1: 
1: 
1:     /**
1:      * Attempt to establish a database connection.
1:      *
1:      * @return  a Connection to the database
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:         return this.getConnection(getUser(), getPassword(), false);
1:     /**
1:      * Attempt to establish a database connection with the given username and
1:      * password.  If the {@code attributeAsPassword} property is set to true
1:      * then the password argument is taken to be a list of connection
1:      * attributes with the same format as the {@code connectionAttributes}
1:      * property.
1:      *
1:      * @param username the database user on whose behalf the Connection is
1:      *     being made
1:      * @param password the user's password
1:      * @return  a Connection to the database
1:      * @exception SQLException if a database-access error occurs.
1:      */
1:     public Connection getConnection(String username, String password)
1:         return this.getConnection(username, password, true);
0:     // requestPassword Use {@code true} if the password came from the
0:     // getConnection() call.
1:     final Connection getConnection(String username,
1:                                    String password,
1:                                    boolean requestPassword)
1:             throws SQLException {
1: 
1:         Properties info = new Properties();
1: 
1:         if (username != null) {
1:             info.put(Attribute.USERNAME_ATTR, username);
1:         }
1: 
1:         if (!requestPassword || !attributesAsPassword) {
1:             if (password != null) {
1:                 info.put(Attribute.PASSWORD_ATTR, password);
1:             }
1:         }
1: 
1:         if (createDatabase != null) {
1:             info.put(Attribute.CREATE_ATTR, "true");
1:         }
1: 
1:         if (shutdownDatabase != null) {
1:             info.put(Attribute.SHUTDOWN_ATTR, "true");
1:         }
1: 
1:         String url = jdbcurl;
1: 
1:         if (attributesAsPassword && requestPassword && password != null) {
1:             StringBuilder sb =
1:                 new StringBuilder(url.length() + password.length() + 1);
1: 
1:             sb.append(url);
1:             sb.append(';');
1:             sb.append(password); // these are now request attributes on the URL
1: 
1:             url = sb.toString();
1:         }
1: 
1:         Connection conn =  findDriver().connect( url, info, loginTimeout );
1: 
1:         // JDBC driver's getConnection method returns null if
1:         // the driver does not handle the request's URL.
1:         if (conn == null) {
1:            throw Util.generateCsSQLException(SQLState.PROPERTY_INVALID_VALUE,
1:                                              Attribute.DBNAME_ATTR,
1:                                              getDatabaseName());
1:         }
1: 
1:         return conn;
1:     }
1: 
1:     // JDBC 4.0 java.sql.Wrapper interface methods
1: 
1:     /**
1:      * Returns false unless {@code interFace} is implemented.
1:      *
1:      * @param interFace a class defining an interface
1:      * @return {@code true} if this implements the interface or directly or
1:      *     indirectly wraps an object that does
1:      * @throws SQLException if an error occurs while determining
1:      *     whether this is a wrapper for an object with the given interface
1:      */
1:     public boolean isWrapperFor(Class<?> interFace) throws SQLException {
1:         return interFace.isInstance(this);
1:     /**
1:      * Returns {@code this} if this class implements the specified interface.
1:      *
1:      * @param iface a class defining an interface
1:      * @return an object that implements the interface
1:      * @throws SQLException if no object is found that implements the
1:      * interface
1:      */
1:         // Derby does not implement non-standard methods on JDBC objects,
1:         // hence return this if this class implements the interface, or
1:         // throw an SQLException.
1:         try {
1:             return iface.cast(this);
1:         } catch (ClassCastException cce) {
1:             throw Util.generateCsSQLException(SQLState.UNABLE_TO_UNWRAP,
1:                     iface);
1:         }
1:     protected static ResourceAdapter setupResourceAdapter(
1:         EmbeddedXADataSourceInterface ds,
1:         ResourceAdapter ra,
1:         String user,
1:         String password,
1:         boolean requestPassword) throws SQLException {
1: 
1:         synchronized(ds) {
1:             if (ra == null || !ra.isActive()) {
1:                 // If it is inactive, it is useless.
1:                 ra = null;
1: 
1:                 // DERBY-4907 make sure the database name sent to find service
1:                 // does not include attributes.
1:                 String dbName =
1:                     ((BasicEmbeddedDataSource40)ds).getShortDatabaseName();
1: 
1:                 if (dbName != null) {
1:                     // see if database already booted, if it is, then
1:                     // don't make a connection.
1:                     Database database = null;
1: 
1:                     // if monitor is never setup by any ModuleControl,
1:                     // getMonitor returns null and no Derby database
1:                     // has been booted.
0:                     if (Monitor.getMonitor() != null) {
1:                         database = (Database)
0:                             Monitor.findService(Property.DATABASE_MODULE,
1:                                                 dbName);
1:                     }
1: 
1:                     if (database == null) {
1:                         // If database is not found, try connecting to it.
1:                         // This boots and/or creates the database.  If
1:                         // database cannot be found, this throws SQLException.
1:                         if (requestPassword) {
1:                             ds.getConnection(user, password).close();
1:                         } else {
1:                             ds.getConnection().close();
1:                         }
1: 
1:                         // now try to find it again
1:                         database = (Database)
0:                             Monitor.findService(Property.DATABASE_MODULE,
1:                                                 dbName);
1:                     }
1: 
1:                     if (database != null) {
1:                         ra = (ResourceAdapter) database.getResourceAdapter();
1:                     }
1:                 }
1: 
1:                 if (ra == null) {
1:                     throw new SQLException(
1:                         MessageService.getTextMessage(
1:                             MessageId.CORE_DATABASE_NOT_AVAILABLE),
1:                         "08006",
1:                         ExceptionSeverity.DATABASE_SEVERITY);
1:                 }
1: 
1:                 // If database is already up, we need to set up driver
1:                 // seperately.
1:                 InternalDriver driver =
1:                     ((BasicEmbeddedDataSource40)ds).findDriver();
1: 
1:                 if (driver == null) {
1:                     throw new SQLException(
1:                         MessageService.getTextMessage(
1:                             MessageId.CORE_DRIVER_NOT_AVAILABLE),
1:                         "08006",
1:                         ExceptionSeverity.DATABASE_SEVERITY);
1:                 }
1:             }
1:         }
1: 
1:         return ra;
1:     }
1:     
1:     ////////////////////////////////////////////////////////////////////
1:     //
1:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
1:     //
1:     ////////////////////////////////////////////////////////////////////
1: 
1:     // Cannot add @Override here: the compiler balks since this is compiled
1:     // with compiler level 1.6 which doesn't specify this method in the
1:     // JDBC interface (4.0). Add as soon as we move to minimum 1.7.
1:     public  Logger getParentLogger() throws SQLFeatureNotSupportedException
1:     {
1:         throw (SQLFeatureNotSupportedException) Util.generateCsSQLException
1:             ( SQLState.NOT_IMPLEMENTED, "getParentLogger" );
commit:7863d83
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
1: import java.sql.Connection;
1: import java.sql.SQLException;
1:  * This data source is suitable for an application using embedded Derby,
/////////////////////////////////////////////////////////////////////////
0: public class BasicEmbeddedDataSource40 extends EmbeddedBaseDataSource
1:     private static final long serialVersionUID = -4945135214995641182L;
1:     @Override
0:     public void setLoginTimeout(int seconds) throws SQLException {
0:         super.setLoginTimeout(seconds);
1:     }
1: 
1:     @Override
0:     public int getLoginTimeout() throws SQLException {
0:         return super.getLoginTimeout();
1:     }
1: 
1:     @Override
0:     public void setLogWriter(PrintWriter logWriter)
1:             throws SQLException {
0:         super.setLogWriter(logWriter);
1:     }
1: 
1:     @Override
0:     public PrintWriter getLogWriter() throws SQLException {
0:         return super.getLogWriter();
1:     }
1: 
1:     @Override
0:     public final void setPassword(String password) {
0:         super.setPassword(password);
1:     }
1: 
1:     @Override
0:     public final String getPassword() {
0:         return super.getPassword();
1:     }
1: 
1:     @Override
0:     public void setDatabaseName(String databaseName) {
0:         super.setDatabaseName(databaseName);
1:     }
1: 
1:     @Override
1:     public String getDatabaseName() {
0:         return super.getDatabaseName();
1:     }
1: 
1:     @Override
0:     public void setDataSourceName(String dataSourceName) {
0:         super.setDataSourceName(dataSourceName);
1:     }
1: 
1:     @Override
1:     public String getDataSourceName() {
0:         return super.getDataSourceName();
1:     }
1: 
1:     @Override
0:     public void setDescription(String description) {
0:         super.setDescription(description);
1:     }
1: 
1:     @Override
1:     public String getDescription() {
0:         return super.getDescription();
1:     }
1: 
1:     @Override
1:     public void setUser(String user) {
0:         super.setUser(user);
1:     }
1: 
1:     @Override
1:     public String getUser() {
0:         return super.getUser();
1:     }
1: 
1:     @Override
0:     public final void setCreateDatabase(String create) {
0:         super.setCreateDatabase(create);
1:     }
1: 
1:     @Override
0:     public final String getCreateDatabase() {
0:         return super.getCreateDatabase();
1:     }
1: 
1:     @Override
0:     public final void setShutdownDatabase(String shutdown) {
0:         super.setShutdownDatabase(shutdown);
1:     }
1: 
1:     @Override
0:     public final String getShutdownDatabase() {
0:         return super.getShutdownDatabase();
1:     }
1: 
1:     @Override
0:     public final void setConnectionAttributes(String prop) {
0:         super.setConnectionAttributes(prop);
1:     }
1: 
1:     @Override
0:     public final String getConnectionAttributes() {
0:         return super.getConnectionAttributes();
1:     }
1: 
1: 
1:     @Override
1:     public Connection getConnection() throws SQLException {
0:         return super.getConnection();
1:     }
1: 
1:     @Override
0:     public Connection getConnection(String user, String password)
1:             throws SQLException {
0:         return super.getConnection(user, password);
1:     }
1: 
1:     @Override
0:     public final Logger getParentLogger() throws SQLFeatureNotSupportedException {
0:         return super.getParentLogger();
1:     }
1: 
1:     @Override
0:     public boolean isWrapperFor(Class<?> iface) throws SQLException {
0:         return super.isWrapperFor(iface);
1:     }
1: 
1:     @Override
1:     public <T> T unwrap(Class<T> iface) throws SQLException {
0:         return super.unwrap(iface);
1:     }
1: 
1:     @Override
0:     public final void setAttributesAsPassword(boolean attributesAsPassword) {
0:         super.setAttributesAsPassword(attributesAsPassword);
1:     }
1: 
1:     @Override
0:     public final boolean getAttributesAsPassword() {
0:         return super.getAttributesAsPassword();
1:     }
commit:2913612
/////////////////////////////////////////////////////////////////////////
0:  * This datasource is suitable for an application using embedded Derby,
1:  * running on Java 8 Compact Profile 2 or higher.
1:  * <p/>
commit:38667d9
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.jdbc.BasicEmbeddedDataSource40
/////////////////////////////////////////////////////////////////////////
0:  * BasicEmbeddedDataSource40 is similar to EmbeddedDataSource40, but does
0:  public class BasicEmbeddedDataSource40 extends EmbeddedBaseDataSource
0:     public BasicEmbeddedDataSource40() {}
commit:4e0e1f1
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
0:    Derby - Class org.apache.derby.jdbc.NonJNDIEmbeddedDataSource40
0: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
1:  */
0: 
1: package org.apache.derby.jdbc;
0: 
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.util.logging.Logger;
1: import org.apache.derby.impl.jdbc.Util;
0: 
1: /**
1:  *
0:  * NonJNDIEmbeddedDataSource40 is similar to EmbeddedDataSource40, but does
1:  * not support JNDI naming, i.e. it does not implement
1:  * {@code javax.naming.Referenceable}.
1:  *
0:  * @see EmbeddedDataSource40
1:  */
0:  public class NonJNDIEmbeddedDataSource40 extends EmbeddedBaseDataSource
0:     implements javax.sql.DataSource {
0: 
0:    private static final long serialVersionUID = -4945135214995641182L;
0: 
0:     public NonJNDIEmbeddedDataSource40() {}
0: 
0:     ////////////////////////////////////////////////////////////////////
0:     //
0:     // INTRODUCED BY JDBC 4.1 IN JAVA 7
0:     //
0:     ////////////////////////////////////////////////////////////////////
0: 
0:     public  Logger getParentLogger() throws SQLFeatureNotSupportedException {
0:         throw (SQLFeatureNotSupportedException)Util.notImplemented(
0:                 "getParentLogger()");
0:     }
0: }
============================================================================