1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.raw.Transaction
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
9:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.raw;
1:eac0369: 
1:722a889: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.daemon.Serviceable;
1:3c1f634: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: import org.apache.derby.iapi.store.access.FileResource;
1:eac0369: import org.apache.derby.iapi.store.access.RowSource;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:722a889: import org.apache.derby.iapi.types.DataValueFactory;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.property.PersistentSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.ExceptionSeverity;
4:eac0369: /**
1:eac0369: */
1:eac0369: 
1:76addbc: public interface Transaction {
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the context manager this transaction is associated with.
1:eac0369: 	*/
1:eac0369: 	public ContextManager getContextManager();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the compatibility space of the transaction.
1:eac0369:      * <p>
1:eac0369:      * Returns an object that can be used with the lock manager to provide
1:eac0369:      * the compatibility space of a transaction.  2 transactions with the
1:eac0369:      * same compatibility space will not conflict in locks.  The usual case
1:eac0369:      * is that each transaction has it's own unique compatibility space.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The compatibility space of the transaction.
1:eac0369:      **/
1:3c1f634:     CompatibilitySpace getCompatibilitySpace();
1:eac0369: 
1:85e3e12:     /**
1:85e3e12:      * Tell this transaction whether it should time out immediately if a lock
1:5431e03:      * cannot be granted without waiting. This could be used in a nested
1:5431e03:      * transaction to prevent long waits if there is a lock conflict between
1:5431e03:      * the nested transaction and its parent. If it is used this way, the
1:5431e03:      * calling code should catch timeout exceptions from the nested transaction
1:5431e03:      * and retry the operation (without disabling waiting) in the parent
1:5431e03:      * transaction.
1:85e3e12:      *
1:85e3e12:      * @param noWait if {@code true} never wait for a lock in this transaction,
1:85e3e12:      * but time out immediately
1:5431e03:      * @see org.apache.derby.iapi.services.locks.LockOwner#noWait()
1:85e3e12:      */
1:85e3e12:     void setNoLockWait(boolean noWait);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Called after the transaction has been attached to an Access Manger
1:eac0369: 		TransactionController. Thus may not be called for all transactions.
1:eac0369: 		Purpose is to allow a transaction access to database (service) properties.
1:eac0369: 
1:eac0369: 		Will not be called for transactions early in the boot process, ie. before
1:eac0369: 		the property conglomerate is set up.
1:3fd26f3: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 	*/
1:eac0369: 	public void setup(PersistentSet set)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my transaction identifier. Transaction identifiers may be 
1:eac0369:         re-used for transactions that do not modify the raw store.
1:eac0369: 		May return null if this transaction has no globalId.
1:eac0369: 	*/
1:eac0369: 	public GlobalTransactionId getGlobalId();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the current default locking policy for all operations within this
1:eac0369: 		transaction. The transaction is initially started with a default
1:eac0369: 		locking policy equivalent to
1:eac0369: 		<PRE>
1:eac0369: 			 newLockingPolicy(
1:eac0369:               LockingPolicy.MODE_RECORD, LockingPolicy.ISOLATION_SERIALIZABLE, true);
1:eac0369: 		</PRE>
1:eac0369:         This default can be changed by subsequent calls to 
1:eac0369:         setDefaultLockingPolicy(LockingPolicy policy).
1:eac0369: 
1:eac0369: 
1:eac0369: 		@return The current default locking policy in this transaction.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public LockingPolicy getDefaultLockingPolicy();
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Obtain a locking policy for use in openContainer(). The mode
1:eac0369: 		and isolation must be constants from LockingPolicy. If higherOK is true
1:eac0369: 		then the object returned may implement a stricter form of locking than
1:eac0369: 		the one requested.
1:eac0369: 		<BR>
1:eac0369: 		A null LockingPolicy reference is identical to a LockingPolicy obtained 
1:eac0369:         by using MODE_NONE which is guaranteed to exist.
1:eac0369: 
1:eac0369: 		@param mode A constant of the form LockingPolicy.MODE_*
1:eac0369: 		@param isolation A constant of the form LockingPolicy.ISOLATION_*
1:12c6ed9: 		@param stricterOk True if a stricter level of locking is acceptable, 
1:eac0369:         false if an exact match is required.
1:eac0369: 
1:eac0369: 		@return A object that can be used in an openContainer call, 
1:eac0369:         null if a matching policy cannot be found.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public LockingPolicy newLockingPolicy(int mode, int isolation, boolean stricterOk);
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the default locking policy for all operations within this
1:eac0369: 		transaction. The transaction is intially started with a default
1:eac0369: 		locking policy equivalent to
1:eac0369: 		<PRE>
1:eac0369: 			 newLockingPolicy(
1:eac0369:               LockingPolicy.MODE_RECORD, LockingPolicy.ISOLATION_SERIALIZABLE, true);
1:eac0369: 		</PRE>
1:eac0369: 
2:eac0369: 		@param policy The lock policy to use, if null then then a no locking 
1:eac0369:         policy will be installed as the default.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public void setDefaultLockingPolicy(LockingPolicy policy);
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Commit this transaction. All savepoints within this transaction are 
1:eac0369:         released.
1:eac0369: 
1:eac0369: 		@return the commit instant of this transaction, or null if it
1:eac0369: 		didn't make any changes 
1:eac0369: 		
1:eac0369: 		@exception StandardException
1:eac0369:         A transaction level exception is thrown
1:eac0369:         if the transaction was aborted due to some error. Any exceptions that 
1:eac0369:         occur of lower severity than Transaction severity are caught, the 
1:eac0369:         transaction is then aborted and then an exception of Transaction
1:eac0369: 		severity is thrown nesting the original exception.
1:f668d94:         Any exception more severe than a
1:eac0369:         Transaction exception is not caught and the transaction is not aborted.
1:eac0369:         The transaction will be aborted by the standard context mechanism.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public LogInstant commit() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	    "Commit" this transaction without sync'ing the log.
1:eac0369: 		Everything else is identical to commit(), use this at your own risk.
1:eac0369: 		
1:eac0369: 		<BR>bits in the commitflag can turn on to fine tuned the "commit":
1:eac0369: 		KEEP_LOCKS - no locks will be released by the commit and no post commit
1:eac0369: 		processing will be initiated.  If, for some reasons, the locks cannot be
1:eac0369: 		kept even if this flag is set, then the commit will sync the log, i.e.,
1:eac0369: 		it will revert to the normal commit.
1:eac0369: 
1:eac0369: 		@exception StandardException
1:eac0369:         A transaction level exception is thrown
1:eac0369:         if the transaction was aborted due to some error. Any exceptions that 
1:eac0369:         occur of lower severity than Transaction severity are caught, the 
1:eac0369:         transaction is then aborted and then an exception of Transaction
1:eac0369: 		severity is thrown nesting the original exception.
1:f668d94:         Any exception more severe than a
1:eac0369:         Transaction exception is not caught and the transaction is not aborted.
1:eac0369:         The transaction will be aborted by the standard context mechanism.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public LogInstant commitNoSync(int commitflag) throws StandardException;
1:eac0369: 	public final int RELEASE_LOCKS = TransactionController.RELEASE_LOCKS;
1:eac0369: 	public final int KEEP_LOCKS = TransactionController.KEEP_LOCKS;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Abort all changes made by this transaction since the last commit, abort
1:eac0369: 		or the point the transaction was started, whichever is the most recent.
1:eac0369: 		All savepoints within this transaction are released.
1:eac0369: 
1:eac0369: 		@exception StandardException Only exceptions with severities greater 
1:eac0369:         than ExceptionSeverity.TRANSACTION_SEVERITY will be thrown.
1:eac0369: 		
1:eac0369: 	*/
1:eac0369: 	public void abort() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Close this transaction, the transaction must be idle. This close will
1:eac0369: 		pop the transaction context off the stack that was pushed when the 
1:eac0369:         transaction was started.
1:eac0369: 
1:eac0369: 		@see RawStoreFactory#startTransaction
1:eac0369: 
1:eac0369: 		@exception StandardException A transaction level exception is 
1:eac0369:         thrown if the transaction is not idle.
1:eac0369: 
1:eac0369: 		
1:eac0369: 	*/
1:eac0369: 	public void close() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369:         If this transaction is not idle, abort it.  After this call close().
1:eac0369: 
1:eac0369: 		@see RawStoreFactory#startTransaction
1:eac0369: 
1:eac0369: 		@exception StandardException A transaction level exception is 
1:eac0369:         thrown if the transaction is not idle.
1:eac0369: 
1:eac0369: 		
1:eac0369: 	*/
1:eac0369: 	public void destroy() throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set a save point in the current transaction. A save point defines a 
1:eac0369:         point in time in the transaction that changes can be rolled back to. 
1:eac0369:         Savepoints can be nested and they behave like a stack. Setting save 
1:eac0369:         points "one" and "two" and the rolling back "one" will rollback all 
1:eac0369:         the changes made since "one" (including those made since "two") and 
1:eac0369:         release savepoint "two".
1:eac0369:     @param name     The user provided name of the savepoint
1:eac0369: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1:eac0369:                     Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1:eac0369:                     A String value for kindOfSavepoint would mean it is SQL savepoint
1:eac0369:                     A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1:eac0369: 
1:eac0369: 		@return returns total number of savepoints in the stack.
1:eac0369: 		@exception StandardException
1:eac0369:         A statement level exception is thrown if a savepoint already 
1:eac0369:         exists in the current transaction with the same name.
1:eac0369: 		
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public int setSavePoint(String name, Object kindOfSavepoint) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Release the save point of the given name. Relasing a savepoint removes 
1:eac0369:         all knowledge from this transaction of the named savepoint and any 
1:eac0369:         savepoints set since the named savepoint was set.
1:eac0369:     @param name     The user provided name of the savepoint, set by the user
1:eac0369:                     in the setSavePoint() call.
1:eac0369: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1:eac0369:                     Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1:eac0369:                     A String value for kindOfSavepoint would mean it is SQL savepoint
1:eac0369:                     A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1:eac0369: 
1:eac0369: 		@return returns total number of savepoints in the stack.
1:eac0369: 		@exception StandardException
1:eac0369:         A statement level exception is thrown if a savepoint already
1:eac0369:         exists in the current transaction with the same name.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public int releaseSavePoint(String name, Object kindOfSavepoint) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Rollback all changes made since the named savepoint was set. The named
1:eac0369: 		savepoint is not released, it remains valid within this transaction, and
1:eac0369: 		thus can be named it future rollbackToSavePoint() calls. Any savepoints
1:eac0369: 		set since this named savepoint are released (and their changes rolled
1:eac0369:         back).
1:eac0369:     @param name     The user provided name of the savepoint, set by the user
1:eac0369:                     in the setSavePoint() call.
1:eac0369: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1:eac0369:                     Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1:eac0369:                     A String value for kindOfSavepoint would mean it is SQL savepoint
1:eac0369:                     A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1:eac0369: 
1:eac0369: 		@return returns total number of savepoints in the stack.
1:eac0369: 		@exception StandardException
1:eac0369:         A statement level exception is thrown if no savepoint exists with 
1:eac0369:         the given name.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public int rollbackToSavePoint(String name, Object kindOfSavepoint) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 
1:eac0369: 		Open a container, with the transaction's default locking policy.
1:eac0369: 
1:eac0369:         <p>
1:eac0369:         Note that if NOWAIT has been specified lock will be 
1:eac0369:         requested with no wait time, and if lock is not granted a 
1:eac0369:         SQLState.LOCK_TIMEOUT exception will be thrown.
1:eac0369: 		<P>
1:eac0369: 		The release() method of ContainerHandle will be called when this 
1:eac0369:         transaction is aborted or commited, it may be called explicitly to
1:eac0369: 		release the ContainerHandle before the end of the transaction.
1:eac0369: 
1:eac0369: 
1:eac0369: 		@return a valid ContainerHandle or null if the container does not exist.
1:eac0369: 
1:3fd26f3: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public ContainerHandle openContainer(ContainerKey containerId,  int mode)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 
1:eac0369: 		Open a container, with the defined locking policy, otherwise
1:eac0369: 		as openContainer(int containerId,  boolean forUpdate).
1:eac0369: 
1:eac0369: 		<P>
1:eac0369: 		Calls locking.lockContainer(this, returnValue, forUpdate) to lock the
1:eac0369:         container.  Note that if NOWAIT has been specified lock will be 
1:eac0369:         requested with no wait time, and if lock is not granted a 
1:eac0369:         SQLState.LOCK_TIMEOUT exception will be thrown.
1:eac0369: 
1:12c6ed9: 		@param locking The lock policy to use, if null then then a no locking 
1:12c6ed9:                        policy will be used.
1:eac0369: 
1:eac0369: 		@return a valid ContainerHandle or null if the container does not exist.
1:eac0369: 
1:3fd26f3: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 
1:12c6ed9: 	public ContainerHandle openContainer(
1:12c6ed9:     ContainerKey    containerId,
1:12c6ed9:     LockingPolicy   locking, 
1:12c6ed9:     int             mode) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add a new container to the segment. The new container initially has
1:eac0369: 		one page, page Container.FIRST_PAGE_NUMBER.
1:eac0369: 
1:eac0369: 		<BR>
1:eac0369: 		If pageSize is equal to ContainerHandle.DEFAULT_PAGESIZE or invalid 
1:eac0369:         then a default page size will be picked.
1:eac0369: 		<BR>
1:eac0369: 		SpareSpace indicates that percent (0% - 100%) of page space that will 
1:eac0369:         be attempted to be reserved for updates. E.g. with a value of 20 a page
1:eac0369:         that would normally hold 40 rows will be limited to 32 rows,
1:eac0369: 		actual calculation for the threshold where no more inserts are all 
1:eac0369:         accepted is up to the implementation.  Whatever the value of 
1:eac0369:         spaceSpace an empty page will always accept at least one insert.
1:eac0369: 		If spare space is equal to ContainerHandle.DEFAULT_PAGESIZE or invalid 
1:eac0369:         then a default value will be used.
1:eac0369: 
1:eac0369: 	    <P><B>Synchronisation</B>
1:eac0369: 		<P>
1:eac0369: 		The new container is exclusivly locked by this transaction until
1:eac0369: 		it commits.
1:eac0369: 
1:eac0369: 		@param segmentId    segment to create the container in.
1:eac0369: 		@param containerId  If not equal to 0 then this container id will be 
1:eac0369:                             used to create the container, else if set to 0 then
1:eac0369:                             the raw store will assign a number.
1:eac0369: 		@param mode mode description in @see ContainerHandle.  This mode is
1:eac0369: 		only effective for the duration of the addContainer call and not stored
1:eac0369: 		persistently for the lifetime of the container.
1:eac0369: 		@param tableProperties Implementation-specific properties of the
1:eac0369: 		conglomerate.
1:eac0369: 
1:eac0369: 		@return a container identifer that can be used in openContainer()
1:eac0369: 		This id is only valid within this RawStoreFactory.  Returns a negative 
1:eac0369:         number if a container could not be allocated.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public long addContainer(
1:eac0369:     long        segmentId, 
1:eac0369:     long        containerId,
1:eac0369:     int         mode, 
1:eac0369:     Properties  tableProperties, 
1:eac0369:     int         temporaryFlag) 
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Drop a container.
1:eac0369: 
1:eac0369: 	    <P><B>Synchronisation</B>
1:eac0369: 		<P>
1:eac0369: 		This call will mark the container as dropped and then obtain an CX lock
1:eac0369: 		on the container. Once a container has been marked as dropped it cannot
1:eac0369: 		be retrieved by any openContainer() call.
1:eac0369: 		<P>
1:eac0369: 		Once the exclusive lock has been obtained the container is removed
1:eac0369: 		and all its pages deallocated. The container will be fully removed
1:eac0369: 		at the commit time of the transaction.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void dropContainer(ContainerKey containerId)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add a new stream container to the segment and load the stream container.
1:eac0369: 		
1:eac0369: 		This stream container doesn't not have locks, and do not log.
1:eac0369: 		It does not have the concept of a page.
1:eac0369: 		It is used by the external sort only.
1:eac0369: 
1:eac0369: 	    <P><B>Synchronisation</B>
1:eac0369: 		<P>
1:eac0369: 		This call will mark the container as dropped and then obtain an CX lock
1:eac0369: 		on the container. Once a container has been marked as dropped it cannot
1:eac0369: 		be retrieved by any openContainer() call.
1:eac0369: 		<P>
1:eac0369: 		Once the exclusive lock has been obtained the container is removed
1:eac0369: 		and all its pages deallocated. The container will be fully removed
1:eac0369: 		at the commit time of the transaction.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public long addAndLoadStreamContainer(
1:eac0369: 			long segmentId, Properties tableProperties, RowSource rowSource)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Open a stream container.
1:eac0369: 
1:eac0369: 		@return a valid StreamContainerHandle or null if the container does not exist.
1:eac0369: 
1:3fd26f3: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public StreamContainerHandle openStreamContainer(
1:eac0369:     long    segmentId, 
1:eac0369:     long    containerId,
1:eac0369:     boolean hold)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Drop a stream container.
1:eac0369: 
1:eac0369: 	    <P><B>Synchronisation</B>
1:eac0369: 		<P>
1:eac0369: 		This call will remove the container.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public abstract void dropStreamContainer(long segmentId, long containerId)
1:eac0369: 		throws StandardException;
1:eac0369: 		
1:eac0369: 	/**
1:eac0369: 		Log an operation and then action it in the context of this transaction.
1:eac0369: 		The Loggable Operation is logged in the transaction log file and then 
1:eac0369:         its doMe method is called to perform the required change. If this 
1:eac0369:         transaction aborts or a rollback is performed of the current savepoint 
1:eac0369:         (if any) then a compensation Operation needs to be generated that will 
1:eac0369:         compensate for the change of this Operation. 
1:eac0369: 
1:eac0369: 		@param operation the operation that is to be applied
1:eac0369: 
1:eac0369: 		@see Loggable
1:eac0369: 
1:3fd26f3: 		@exception StandardException  Standard Derby exception policy
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void logAndDo(Loggable operation) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Add to the list of post commit work that may be processed after this
1:eac0369: 		transaction commits.  If this transaction aborts, then the post commit
1:eac0369: 		work list will be thrown away.  No post commit work will be taken out
1:eac0369: 		on a rollback to save point.
1:eac0369: 
1:eac0369: 		@param work the post commit work that is added
1:eac0369: 	*/
1:eac0369: 	public void addPostCommitWork(Serviceable work);
1:eac0369: 
1:eac0369: 	/**
1:888d12e: 		Add to the list of post abort work that may be processed after this
1:888d12e: 		transaction aborts.  
1:888d12e: 
1:888d12e: 		@param work the post commit work that is added
1:888d12e: 	*/
1:888d12e: 	public void addPostAbortWork(Serviceable work);
1:888d12e: 
1:888d12e: 	/**
1:eac0369: 		Add to the list of post termination work that may be processed after this
1:eac0369: 		transaction commits or aborts.
1:eac0369: 
1:eac0369: 		@param work the post termination work that is added
1:eac0369: 	*/
1:eac0369: 	public void addPostTerminationWork(Serviceable work);
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Reveals whether the transaction has ever read or written data.
1:eac0369:      *
1:eac0369: 	 * @return true If the transaction has never read or written data.
1:eac0369:      **/
1:eac0369: 	public boolean isIdle();
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	  Reveal whether the transaction is in a pristine state, which
1:eac0369: 	  means it hasn't done any updates since the last commit.
1:eac0369: 	  @return true if so, false otherwise
1:eac0369: 	  */
1:eac0369:     public boolean isPristine();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get an object to handle non-transactional files.
1:eac0369: 	*/
1:eac0369: 	public FileResource getFileHandler();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return true if any transaction is blocked, even if not by this one.
1:eac0369: 	 */
1:eac0369: 	public  boolean anyoneBlocked();
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Convert a local transaction to a global transaction.
1:eac0369:      * <p>
1:eac0369: 	 * Get a transaction controller with which to manipulate data within
1:eac0369: 	 * the access manager.  Tbis controller allows one to manipulate a 
1:eac0369:      * global XA conforming transaction.
1:eac0369:      * <p>
1:eac0369:      * Must only be called a previous local transaction was created and exists
1:eac0369:      * in the context.  Can only be called if the current transaction is in
1:eac0369:      * the idle state.  
1:eac0369:      * <p>
1:eac0369:      * The (format_id, global_id, branch_id) triplet is meant to come exactly
1:eac0369:      * from a javax.transaction.xa.Xid.  We don't use Xid so that the system
1:eac0369:      * can be delivered on a non-1.2 vm system and not require the javax classes
1:eac0369:      * in the path.  
1:eac0369:      *
1:eac0369:      * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
1:eac0369:      * @param global_id the global transaction identifier part of XID - ie.
1:eac0369:      *                  Xid.getGlobalTransactionId().
1:eac0369:      * @param branch_id The branch qualifier of the Xid - ie. 
1:eac0369:      *                  Xid.getBranchQaulifier()
1:eac0369:      * 	
1:eac0369: 	 * @exception StandardException Standard exception policy.
1:eac0369: 	 **/
1:eac0369: 	void createXATransactionFromLocalTransaction(
1:eac0369:     int                     format_id,
1:eac0369:     byte[]                  global_id,
1:eac0369:     byte[]                  branch_id)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * This method is called to commit the current XA global transaction.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE - how do we map to the "right" XAExceptions.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      *
1:eac0369:      * @param onePhase If true, the resource manager should use a one-phase
1:eac0369:      *                 commit protocol to commit the work done on behalf of 
1:eac0369:      *                 current xid.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void xa_commit(
1:eac0369:     boolean onePhase)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * This method is called to ask the resource manager to prepare for
1:eac0369:      * a transaction commit of the transaction specified in xid.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @return         A value indicating the resource manager's vote on the
1:eac0369:      *                 the outcome of the transaction.  The possible values
1:eac0369:      *                 are:  XA_RDONLY or XA_OK.  If the resource manager wants
1:eac0369:      *                 to roll back the transaction, it should do so by 
1:eac0369:      *                 throwing an appropriate XAException in the prepare
1:eac0369:      *                 method.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public int xa_prepare()
1:eac0369: 		throws StandardException;
1:eac0369:     public static final int XA_RDONLY = 1; 
1:eac0369:     public static final int XA_OK     = 2; 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * rollback the current global transaction.
1:eac0369:      * <p>
1:eac0369:      * The given transaction is roll'ed back and it's history is not
1:eac0369:      * maintained in the transaction table or long term log.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void xa_rollback()
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 	
1:eac0369:     /**
1:eac0369: 	 * get string ID of the actual transaction ID that will 
1:eac0369: 	 * be used when transaction is in  active state. 
1:eac0369: 	 */
1:eac0369: 	public String getActiveStateTxIdString();
1:eac0369: 
1:eac0369: 
1:722a889:     /**
1:722a889:      * Get DataValueFactory.
1:722a889:      * <p>
1:722a889:      * Return a DataValueFactory that can be used to allocate objects.  Used
1:722a889:      * to make calls to: 
1:722a889:      *     DataValueFactory.getInstanceUsingFormatIdAndCollationType()
1:722a889:      *
1:722a889: 	 * @return a booted data value factory.
1:722a889:      *
1:722a889: 	 * @exception  StandardException  Standard exception policy.
1:722a889:      **/
1:722a889:     public DataValueFactory getDataValueFactory()
1:722a889: 		throws StandardException;
1:eac0369: }
============================================================================
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1: 		Add to the list of post abort work that may be processed after this
1: 		transaction aborts.  
1: 
1: 		@param work the post commit work that is added
1: 	*/
1: 	public void addPostAbortWork(Serviceable work);
1: 
1: 	/**
commit:722a889
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.types.DataValueFactory;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get DataValueFactory.
1:      * <p>
1:      * Return a DataValueFactory that can be used to allocate objects.  Used
1:      * to make calls to: 
1:      *     DataValueFactory.getInstanceUsingFormatIdAndCollationType()
1:      *
1: 	 * @return a booted data value factory.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public DataValueFactory getDataValueFactory()
1: 		throws StandardException;
commit:12c6ed9
/////////////////////////////////////////////////////////////////////////
1: 		@param stricterOk True if a stricter level of locking is acceptable, 
/////////////////////////////////////////////////////////////////////////
1: 		@param locking The lock policy to use, if null then then a no locking 
1:                        policy will be used.
/////////////////////////////////////////////////////////////////////////
1: 	public ContainerHandle openContainer(
1:     ContainerKey    containerId,
1:     LockingPolicy   locking, 
1:     int             mode) 
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
1:         Any exception more severe than a
/////////////////////////////////////////////////////////////////////////
1:         Any exception more severe than a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5431e03
/////////////////////////////////////////////////////////////////////////
1:      * cannot be granted without waiting. This could be used in a nested
1:      * transaction to prevent long waits if there is a lock conflict between
1:      * the nested transaction and its parent. If it is used this way, the
1:      * calling code should catch timeout exceptions from the nested transaction
1:      * and retry the operation (without disabling waiting) in the parent
1:      * transaction.
1:      * @see org.apache.derby.iapi.services.locks.LockOwner#noWait()
commit:85e3e12
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Tell this transaction whether it should time out immediately if a lock
0:      * cannot be granted without waiting.
1:      *
1:      * @param noWait if {@code true} never wait for a lock in this transaction,
1:      * but time out immediately
1:      */
1:     void setNoLockWait(boolean noWait);
commit:721f895
/////////////////////////////////////////////////////////////////////////
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.locks.CompatibilitySpace;
/////////////////////////////////////////////////////////////////////////
1:     CompatibilitySpace getCompatibilitySpace();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException  Standard Derby exception policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException  Standard Derby exception policy
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.raw.Transaction
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
1: public interface Transaction {
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.raw;
1: 
1: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: import org.apache.derby.iapi.store.access.FileResource;
1: import org.apache.derby.iapi.store.access.RowSource;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.services.property.PersistentSet;
1: 
1: import org.apache.derby.iapi.error.ExceptionSeverity;
1: /**
1: */
1: 
0: public interface Transaction { 
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/**
1: 		Return the context manager this transaction is associated with.
1: 	*/
1: 	public ContextManager getContextManager();
1: 
1:     /**
1:      * Get the compatibility space of the transaction.
1:      * <p>
1:      * Returns an object that can be used with the lock manager to provide
1:      * the compatibility space of a transaction.  2 transactions with the
1:      * same compatibility space will not conflict in locks.  The usual case
1:      * is that each transaction has it's own unique compatibility space.
1:      * <p>
1:      *
1: 	 * @return The compatibility space of the transaction.
1:      **/
0:     Object getCompatibilitySpace();
1: 
1: 
1: 	/**
1: 		Called after the transaction has been attached to an Access Manger
1: 		TransactionController. Thus may not be called for all transactions.
1: 		Purpose is to allow a transaction access to database (service) properties.
1: 
1: 		Will not be called for transactions early in the boot process, ie. before
1: 		the property conglomerate is set up.
0: 		@exception StandardException  Standard cloudscape exception policy
1: 	*/
1: 	public void setup(PersistentSet set)
1: 		throws StandardException;
1: 
1: 	/**
1: 		Return my transaction identifier. Transaction identifiers may be 
1:         re-used for transactions that do not modify the raw store.
1: 		May return null if this transaction has no globalId.
1: 	*/
1: 	public GlobalTransactionId getGlobalId();
1: 
1: 	/**
1: 		Get the current default locking policy for all operations within this
1: 		transaction. The transaction is initially started with a default
1: 		locking policy equivalent to
1: 		<PRE>
1: 			 newLockingPolicy(
1:               LockingPolicy.MODE_RECORD, LockingPolicy.ISOLATION_SERIALIZABLE, true);
1: 		</PRE>
1:         This default can be changed by subsequent calls to 
1:         setDefaultLockingPolicy(LockingPolicy policy).
1: 
1: 
1: 		@return The current default locking policy in this transaction.
1: 	*/
1: 
1: 	public LockingPolicy getDefaultLockingPolicy();
1: 
1: 
1: 	/**
1: 		Obtain a locking policy for use in openContainer(). The mode
1: 		and isolation must be constants from LockingPolicy. If higherOK is true
1: 		then the object returned may implement a stricter form of locking than
1: 		the one requested.
1: 		<BR>
1: 		A null LockingPolicy reference is identical to a LockingPolicy obtained 
1:         by using MODE_NONE which is guaranteed to exist.
1: 
1: 		@param mode A constant of the form LockingPolicy.MODE_*
1: 		@param isolation A constant of the form LockingPolicy.ISOLATION_*
0: 		@param stricterOK True if a stricter level of locking is acceptable, 
1:         false if an exact match is required.
1: 
1: 		@return A object that can be used in an openContainer call, 
1:         null if a matching policy cannot be found.
1: 	*/
1: 
1: 	public LockingPolicy newLockingPolicy(int mode, int isolation, boolean stricterOk);
1: 
1: 
1: 	/**
1: 		Set the default locking policy for all operations within this
1: 		transaction. The transaction is intially started with a default
1: 		locking policy equivalent to
1: 		<PRE>
1: 			 newLockingPolicy(
1:               LockingPolicy.MODE_RECORD, LockingPolicy.ISOLATION_SERIALIZABLE, true);
1: 		</PRE>
1: 
1: 		@param policy The lock policy to use, if null then then a no locking 
1:         policy will be installed as the default.
1: 
0: 		@return true if a new locking policy was installed as the default, false
0: 		of a matching policy could not be found.
1: 	*/
1: 
1: 	public void setDefaultLockingPolicy(LockingPolicy policy);
1: 
1: 
1: 	/**
1: 		Commit this transaction. All savepoints within this transaction are 
1:         released.
1: 
1: 		@return the commit instant of this transaction, or null if it
1: 		didn't make any changes 
1: 		
1: 		@exception StandardException
1:         A transaction level exception is thrown
1:         if the transaction was aborted due to some error. Any exceptions that 
1:         occur of lower severity than Transaction severity are caught, the 
1:         transaction is then aborted and then an exception of Transaction
1: 		severity is thrown nesting the original exception.
1: 
0: 		@exception StandardException Any exception more severe than a
1:         Transaction exception is not caught and the transaction is not aborted.
1:         The transaction will be aborted by the standard context mechanism.
1: 
1: 	*/
1: 
1: 	public LogInstant commit() throws StandardException;
1: 
1: 	/**
1: 	    "Commit" this transaction without sync'ing the log.
1: 		Everything else is identical to commit(), use this at your own risk.
1: 		
1: 		<BR>bits in the commitflag can turn on to fine tuned the "commit":
1: 		KEEP_LOCKS - no locks will be released by the commit and no post commit
1: 		processing will be initiated.  If, for some reasons, the locks cannot be
1: 		kept even if this flag is set, then the commit will sync the log, i.e.,
1: 		it will revert to the normal commit.
1: 
1: 		@exception StandardException
1:         A transaction level exception is thrown
1:         if the transaction was aborted due to some error. Any exceptions that 
1:         occur of lower severity than Transaction severity are caught, the 
1:         transaction is then aborted and then an exception of Transaction
1: 		severity is thrown nesting the original exception.
1: 
0: 		@exception StandardException Any exception more severe than a
1:         Transaction exception is not caught and the transaction is not aborted.
1:         The transaction will be aborted by the standard context mechanism.
1: 	*/
1: 
1: 	public LogInstant commitNoSync(int commitflag) throws StandardException;
1: 	public final int RELEASE_LOCKS = TransactionController.RELEASE_LOCKS;
1: 	public final int KEEP_LOCKS = TransactionController.KEEP_LOCKS;
1: 
1: 
1: 	/**
1: 		Abort all changes made by this transaction since the last commit, abort
1: 		or the point the transaction was started, whichever is the most recent.
1: 		All savepoints within this transaction are released.
1: 
1: 		@exception StandardException Only exceptions with severities greater 
1:         than ExceptionSeverity.TRANSACTION_SEVERITY will be thrown.
1: 		
1: 	*/
1: 	public void abort() throws StandardException;
1: 
1: 	/**
1: 		Close this transaction, the transaction must be idle. This close will
1: 		pop the transaction context off the stack that was pushed when the 
1:         transaction was started.
1: 
1: 		@see RawStoreFactory#startTransaction
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 		@exception StandardException A transaction level exception is 
1:         thrown if the transaction is not idle.
1: 
1: 		
1: 	*/
1: 	public void close() throws StandardException;
1: 
1: 	/**
1:         If this transaction is not idle, abort it.  After this call close().
1: 
1: 		@see RawStoreFactory#startTransaction
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 		@exception StandardException A transaction level exception is 
1:         thrown if the transaction is not idle.
1: 
1: 		
1: 	*/
1: 	public void destroy() throws StandardException;
1: 
1: 
1: 	/**
1: 		Set a save point in the current transaction. A save point defines a 
1:         point in time in the transaction that changes can be rolled back to. 
1:         Savepoints can be nested and they behave like a stack. Setting save 
1:         points "one" and "two" and the rolling back "one" will rollback all 
1:         the changes made since "one" (including those made since "two") and 
1:         release savepoint "two".
1:     @param name     The user provided name of the savepoint
1: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1:                     Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1:                     A String value for kindOfSavepoint would mean it is SQL savepoint
1:                     A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1: 
1: 		@return returns total number of savepoints in the stack.
0: 		@exception StandardException  Standard cloudscape exception policy
1: 		@exception StandardException
1:         A statement level exception is thrown if a savepoint already 
1:         exists in the current transaction with the same name.
1: 		
1: 	*/
1: 
1: 	public int setSavePoint(String name, Object kindOfSavepoint) throws StandardException;
1: 
1: 	/**
1: 		Release the save point of the given name. Relasing a savepoint removes 
1:         all knowledge from this transaction of the named savepoint and any 
1:         savepoints set since the named savepoint was set.
1:     @param name     The user provided name of the savepoint, set by the user
1:                     in the setSavePoint() call.
1: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1:                     Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1:                     A String value for kindOfSavepoint would mean it is SQL savepoint
1:                     A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1: 
1: 		@return returns total number of savepoints in the stack.
0: 		@exception StandardException  Standard cloudscape exception policy
1: 		@exception StandardException
1:         A statement level exception is thrown if a savepoint already
1:         exists in the current transaction with the same name.
1: 
1: 	*/
1: 
1: 	public int releaseSavePoint(String name, Object kindOfSavepoint) throws StandardException;
1: 
1: 	/**
1: 		Rollback all changes made since the named savepoint was set. The named
1: 		savepoint is not released, it remains valid within this transaction, and
1: 		thus can be named it future rollbackToSavePoint() calls. Any savepoints
1: 		set since this named savepoint are released (and their changes rolled
1:         back).
1:     @param name     The user provided name of the savepoint, set by the user
1:                     in the setSavePoint() call.
1: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1:                     Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1:                     A String value for kindOfSavepoint would mean it is SQL savepoint
1:                     A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1: 
1: 		@return returns total number of savepoints in the stack.
0: 		@exception StandardException  Standard cloudscape exception policy
1: 		@exception StandardException
1:         A statement level exception is thrown if no savepoint exists with 
1:         the given name.
1: 
1: 	*/
1: 	public int rollbackToSavePoint(String name, Object kindOfSavepoint) throws StandardException;
1: 
1: 	/**
1: 
1: 		Open a container, with the transaction's default locking policy.
1: 
1:         <p>
1:         Note that if NOWAIT has been specified lock will be 
1:         requested with no wait time, and if lock is not granted a 
1:         SQLState.LOCK_TIMEOUT exception will be thrown.
1: 		<P>
1: 		The release() method of ContainerHandle will be called when this 
1:         transaction is aborted or commited, it may be called explicitly to
1: 		release the ContainerHandle before the end of the transaction.
1: 
1: 
1: 		@return a valid ContainerHandle or null if the container does not exist.
1: 
0: 		@exception StandardException  Standard cloudscape exception policy
1: 
1: 	*/
1: 	public ContainerHandle openContainer(ContainerKey containerId,  int mode)
1: 		throws StandardException;
1: 
1: 	/**
1: 
1: 		Open a container, with the defined locking policy, otherwise
1: 		as openContainer(int containerId,  boolean forUpdate).
1: 
1: 		<P>
1: 		Calls locking.lockContainer(this, returnValue, forUpdate) to lock the
1:         container.  Note that if NOWAIT has been specified lock will be 
1:         requested with no wait time, and if lock is not granted a 
1:         SQLState.LOCK_TIMEOUT exception will be thrown.
1: 
1: 		@param policy The lock policy to use, if null then then a no locking 
0:         policy will be used.
1: 
1: 		@return a valid ContainerHandle or null if the container does not exist.
1: 
0: 		@exception StandardException  Standard cloudscape exception policy
1: 
1: 	*/
1: 
0: 	public ContainerHandle openContainer(ContainerKey containerId,
0: 										 LockingPolicy locking, int mode) 
1: 		throws StandardException;
1: 
1: 
1: 	/**
1: 		Add a new container to the segment. The new container initially has
1: 		one page, page Container.FIRST_PAGE_NUMBER.
1: 
1: 		<BR>
1: 		If pageSize is equal to ContainerHandle.DEFAULT_PAGESIZE or invalid 
1:         then a default page size will be picked.
1: 		<BR>
1: 		SpareSpace indicates that percent (0% - 100%) of page space that will 
1:         be attempted to be reserved for updates. E.g. with a value of 20 a page
1:         that would normally hold 40 rows will be limited to 32 rows,
1: 		actual calculation for the threshold where no more inserts are all 
1:         accepted is up to the implementation.  Whatever the value of 
1:         spaceSpace an empty page will always accept at least one insert.
1: 		If spare space is equal to ContainerHandle.DEFAULT_PAGESIZE or invalid 
1:         then a default value will be used.
1: 
1: 	    <P><B>Synchronisation</B>
1: 		<P>
1: 		The new container is exclusivly locked by this transaction until
1: 		it commits.
1: 
1: 		@param segmentId    segment to create the container in.
1: 		@param containerId  If not equal to 0 then this container id will be 
1:                             used to create the container, else if set to 0 then
1:                             the raw store will assign a number.
1: 		@param mode mode description in @see ContainerHandle.  This mode is
1: 		only effective for the duration of the addContainer call and not stored
1: 		persistently for the lifetime of the container.
1: 		@param tableProperties Implementation-specific properties of the
1: 		conglomerate.
1: 
1: 		@return a container identifer that can be used in openContainer()
1: 		This id is only valid within this RawStoreFactory.  Returns a negative 
1:         number if a container could not be allocated.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
1: 	*/
1: 	public long addContainer(
1:     long        segmentId, 
1:     long        containerId,
1:     int         mode, 
1:     Properties  tableProperties, 
1:     int         temporaryFlag) 
1: 		throws StandardException;
1: 
1: 	/**
1: 		Drop a container.
1: 
1: 	    <P><B>Synchronisation</B>
1: 		<P>
1: 		This call will mark the container as dropped and then obtain an CX lock
1: 		on the container. Once a container has been marked as dropped it cannot
1: 		be retrieved by any openContainer() call.
1: 		<P>
1: 		Once the exclusive lock has been obtained the container is removed
1: 		and all its pages deallocated. The container will be fully removed
1: 		at the commit time of the transaction.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
1: 	*/
1: 	public void dropContainer(ContainerKey containerId)
1: 		throws StandardException;
1: 
1: 	/**
1: 		Add a new stream container to the segment and load the stream container.
1: 		
1: 		This stream container doesn't not have locks, and do not log.
1: 		It does not have the concept of a page.
1: 		It is used by the external sort only.
1: 
1: 	    <P><B>Synchronisation</B>
1: 		<P>
1: 		This call will mark the container as dropped and then obtain an CX lock
1: 		on the container. Once a container has been marked as dropped it cannot
1: 		be retrieved by any openContainer() call.
1: 		<P>
1: 		Once the exclusive lock has been obtained the container is removed
1: 		and all its pages deallocated. The container will be fully removed
1: 		at the commit time of the transaction.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
1: 	*/
1: 	public long addAndLoadStreamContainer(
1: 			long segmentId, Properties tableProperties, RowSource rowSource)
1: 		throws StandardException;
1: 
1: 
1: 	/**
1: 		Open a stream container.
1: 
1: 		@return a valid StreamContainerHandle or null if the container does not exist.
1: 
0: 		@exception StandardException  Standard cloudscape exception policy
1: 
1: 	*/
1: 	public StreamContainerHandle openStreamContainer(
1:     long    segmentId, 
1:     long    containerId,
1:     boolean hold)
1: 		throws StandardException;
1: 
1: 	/**
1: 		Drop a stream container.
1: 
1: 	    <P><B>Synchronisation</B>
1: 		<P>
1: 		This call will remove the container.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 
1: 	*/
1: 	public abstract void dropStreamContainer(long segmentId, long containerId)
1: 		throws StandardException;
1: 		
1: 	/**
1: 		Log an operation and then action it in the context of this transaction.
1: 		The Loggable Operation is logged in the transaction log file and then 
1:         its doMe method is called to perform the required change. If this 
1:         transaction aborts or a rollback is performed of the current savepoint 
1:         (if any) then a compensation Operation needs to be generated that will 
1:         compensate for the change of this Operation. 
1: 
1: 		@param operation the operation that is to be applied
1: 
1: 		@see Loggable
1: 
0: 		@exception StandardException  Standard cloudscape exception policy
1: 
1: 	*/
1: 	public void logAndDo(Loggable operation) throws StandardException;
1: 
1: 
1: 	/**
1: 		Add to the list of post commit work that may be processed after this
1: 		transaction commits.  If this transaction aborts, then the post commit
1: 		work list will be thrown away.  No post commit work will be taken out
1: 		on a rollback to save point.
1: 
1: 		@param work the post commit work that is added
1: 	*/
1: 	public void addPostCommitWork(Serviceable work);
1: 
1: 	/**
1: 		Add to the list of post termination work that may be processed after this
1: 		transaction commits or aborts.
1: 
1: 		@param work the post termination work that is added
1: 	*/
1: 	public void addPostTerminationWork(Serviceable work);
1: 
1:     /**
1:      * Reveals whether the transaction has ever read or written data.
1:      *
1: 	 * @return true If the transaction has never read or written data.
1:      **/
1: 	public boolean isIdle();
1: 
1:     /**
1: 	  Reveal whether the transaction is in a pristine state, which
1: 	  means it hasn't done any updates since the last commit.
1: 	  @return true if so, false otherwise
1: 	  */
1:     public boolean isPristine();
1: 
1: 	/**
1: 		Get an object to handle non-transactional files.
1: 	*/
1: 	public FileResource getFileHandler();
1: 
1: 	/**
0: 		Get cache statistics for the specified cache
1: 	*/
0: 	public abstract long[] getCacheStats(String cacheName);
1: 
1: 	/**
0: 		Reset the cache statistics for the specified cache
1: 	*/
0: 	public abstract void resetCacheStats(String cacheName);
1: 
1: 	/**
1: 		Return true if any transaction is blocked, even if not by this one.
1: 	 */
1: 	public  boolean anyoneBlocked();
1: 
1: 	/**
1:      * Convert a local transaction to a global transaction.
1:      * <p>
1: 	 * Get a transaction controller with which to manipulate data within
1: 	 * the access manager.  Tbis controller allows one to manipulate a 
1:      * global XA conforming transaction.
1:      * <p>
1:      * Must only be called a previous local transaction was created and exists
1:      * in the context.  Can only be called if the current transaction is in
1:      * the idle state.  
1:      * <p>
1:      * The (format_id, global_id, branch_id) triplet is meant to come exactly
1:      * from a javax.transaction.xa.Xid.  We don't use Xid so that the system
1:      * can be delivered on a non-1.2 vm system and not require the javax classes
1:      * in the path.  
1:      *
0:      * @param cm        The context manager for the current context.
1:      * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
1:      * @param global_id the global transaction identifier part of XID - ie.
1:      *                  Xid.getGlobalTransactionId().
1:      * @param branch_id The branch qualifier of the Xid - ie. 
1:      *                  Xid.getBranchQaulifier()
1:      * 	
1: 	 * @exception StandardException Standard exception policy.
1: 	 **/
1: 	void createXATransactionFromLocalTransaction(
1:     int                     format_id,
1:     byte[]                  global_id,
1:     byte[]                  branch_id)
1: 		throws StandardException;
1: 
1:     /**
1:      * This method is called to commit the current XA global transaction.
1:      * <p>
1:      * RESOLVE - how do we map to the "right" XAExceptions.
1:      * <p>
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1:      * @param onePhase If true, the resource manager should use a one-phase
1:      *                 commit protocol to commit the work done on behalf of 
1:      *                 current xid.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void xa_commit(
1:     boolean onePhase)
1: 		throws StandardException;
1: 
1:     /**
1:      * This method is called to ask the resource manager to prepare for
1:      * a transaction commit of the transaction specified in xid.
1:      * <p>
1:      *
1:      * @return         A value indicating the resource manager's vote on the
1:      *                 the outcome of the transaction.  The possible values
1:      *                 are:  XA_RDONLY or XA_OK.  If the resource manager wants
1:      *                 to roll back the transaction, it should do so by 
1:      *                 throwing an appropriate XAException in the prepare
1:      *                 method.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public int xa_prepare()
1: 		throws StandardException;
1:     public static final int XA_RDONLY = 1; 
1:     public static final int XA_OK     = 2; 
1: 
1:     /**
1:      * rollback the current global transaction.
1:      * <p>
1:      * The given transaction is roll'ed back and it's history is not
1:      * maintained in the transaction table or long term log.
1:      * <p>
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void xa_rollback()
1:         throws StandardException;
1: 
1: 	
1:     /**
1: 	 * get string ID of the actual transaction ID that will 
1: 	 * be used when transaction is in  active state. 
1: 	 */
1: 	public String getActiveStateTxIdString();
1: 
1: 
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.raw;
0: 
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: import org.apache.derby.iapi.store.access.FileResource;
0: import org.apache.derby.iapi.store.access.RowSource;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import java.util.Properties;
0: 
0: import org.apache.derby.iapi.services.property.PersistentSet;
0: 
0: import org.apache.derby.iapi.error.ExceptionSeverity;
0: /**
0: */
0: 
0: public interface Transaction { 
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/**
0: 		Return the context manager this transaction is associated with.
0: 	*/
0: 	public ContextManager getContextManager();
0: 
0:     /**
0:      * Get the compatibility space of the transaction.
0:      * <p>
0:      * Returns an object that can be used with the lock manager to provide
0:      * the compatibility space of a transaction.  2 transactions with the
0:      * same compatibility space will not conflict in locks.  The usual case
0:      * is that each transaction has it's own unique compatibility space.
0:      * <p>
0:      *
0: 	 * @return The compatibility space of the transaction.
0:      **/
0:     Object getCompatibilitySpace();
0: 
0: 
0: 	/**
0: 		Called after the transaction has been attached to an Access Manger
0: 		TransactionController. Thus may not be called for all transactions.
0: 		Purpose is to allow a transaction access to database (service) properties.
0: 
0: 		Will not be called for transactions early in the boot process, ie. before
0: 		the property conglomerate is set up.
0: 		@exception StandardException  Standard cloudscape exception policy
0: 	*/
0: 	public void setup(PersistentSet set)
0: 		throws StandardException;
0: 
0: 	/**
0: 		Return my transaction identifier. Transaction identifiers may be 
0:         re-used for transactions that do not modify the raw store.
0: 		May return null if this transaction has no globalId.
0: 	*/
0: 	public GlobalTransactionId getGlobalId();
0: 
0: 	/**
0: 		Get the current default locking policy for all operations within this
0: 		transaction. The transaction is initially started with a default
0: 		locking policy equivalent to
0: 		<PRE>
0: 			 newLockingPolicy(
0:               LockingPolicy.MODE_RECORD, LockingPolicy.ISOLATION_SERIALIZABLE, true);
0: 		</PRE>
0:         This default can be changed by subsequent calls to 
0:         setDefaultLockingPolicy(LockingPolicy policy).
0: 
0: 
0: 		@return The current default locking policy in this transaction.
0: 	*/
0: 
0: 	public LockingPolicy getDefaultLockingPolicy();
0: 
0: 
0: 	/**
0: 		Obtain a locking policy for use in openContainer(). The mode
0: 		and isolation must be constants from LockingPolicy. If higherOK is true
0: 		then the object returned may implement a stricter form of locking than
0: 		the one requested.
0: 		<BR>
0: 		A null LockingPolicy reference is identical to a LockingPolicy obtained 
0:         by using MODE_NONE which is guaranteed to exist.
0: 
0: 		@param mode A constant of the form LockingPolicy.MODE_*
0: 		@param isolation A constant of the form LockingPolicy.ISOLATION_*
0: 		@param stricterOK True if a stricter level of locking is acceptable, 
0:         false if an exact match is required.
0: 
0: 		@return A object that can be used in an openContainer call, 
0:         null if a matching policy cannot be found.
0: 	*/
0: 
0: 	public LockingPolicy newLockingPolicy(int mode, int isolation, boolean stricterOk);
0: 
0: 
0: 	/**
0: 		Set the default locking policy for all operations within this
0: 		transaction. The transaction is intially started with a default
0: 		locking policy equivalent to
0: 		<PRE>
0: 			 newLockingPolicy(
0:               LockingPolicy.MODE_RECORD, LockingPolicy.ISOLATION_SERIALIZABLE, true);
0: 		</PRE>
0: 
0: 		@param policy The lock policy to use, if null then then a no locking 
0:         policy will be installed as the default.
0: 
0: 		@return true if a new locking policy was installed as the default, false
0: 		of a matching policy could not be found.
0: 	*/
0: 
0: 	public void setDefaultLockingPolicy(LockingPolicy policy);
0: 
0: 
0: 	/**
0: 		Commit this transaction. All savepoints within this transaction are 
0:         released.
0: 
0: 		@return the commit instant of this transaction, or null if it
0: 		didn't make any changes 
0: 		
0: 		@exception StandardException
0:         A transaction level exception is thrown
0:         if the transaction was aborted due to some error. Any exceptions that 
0:         occur of lower severity than Transaction severity are caught, the 
0:         transaction is then aborted and then an exception of Transaction
0: 		severity is thrown nesting the original exception.
0: 
0: 		@exception StandardException Any exception more severe than a
0:         Transaction exception is not caught and the transaction is not aborted.
0:         The transaction will be aborted by the standard context mechanism.
0: 
0: 	*/
0: 
0: 	public LogInstant commit() throws StandardException;
0: 
0: 	/**
0: 	    "Commit" this transaction without sync'ing the log.
0: 		Everything else is identical to commit(), use this at your own risk.
0: 		
0: 		<BR>bits in the commitflag can turn on to fine tuned the "commit":
0: 		KEEP_LOCKS - no locks will be released by the commit and no post commit
0: 		processing will be initiated.  If, for some reasons, the locks cannot be
0: 		kept even if this flag is set, then the commit will sync the log, i.e.,
0: 		it will revert to the normal commit.
0: 
0: 		@exception StandardException
0:         A transaction level exception is thrown
0:         if the transaction was aborted due to some error. Any exceptions that 
0:         occur of lower severity than Transaction severity are caught, the 
0:         transaction is then aborted and then an exception of Transaction
0: 		severity is thrown nesting the original exception.
0: 
0: 		@exception StandardException Any exception more severe than a
0:         Transaction exception is not caught and the transaction is not aborted.
0:         The transaction will be aborted by the standard context mechanism.
0: 	*/
0: 
0: 	public LogInstant commitNoSync(int commitflag) throws StandardException;
0: 	public final int RELEASE_LOCKS = TransactionController.RELEASE_LOCKS;
0: 	public final int KEEP_LOCKS = TransactionController.KEEP_LOCKS;
0: 
0: 
0: 	/**
0: 		Abort all changes made by this transaction since the last commit, abort
0: 		or the point the transaction was started, whichever is the most recent.
0: 		All savepoints within this transaction are released.
0: 
0: 		@exception StandardException Only exceptions with severities greater 
0:         than ExceptionSeverity.TRANSACTION_SEVERITY will be thrown.
0: 		
0: 	*/
0: 	public void abort() throws StandardException;
0: 
0: 	/**
0: 		Close this transaction, the transaction must be idle. This close will
0: 		pop the transaction context off the stack that was pushed when the 
0:         transaction was started.
0: 
0: 		@see RawStoreFactory#startTransaction
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 		@exception StandardException A transaction level exception is 
0:         thrown if the transaction is not idle.
0: 
0: 		
0: 	*/
0: 	public void close() throws StandardException;
0: 
0: 	/**
0:         If this transaction is not idle, abort it.  After this call close().
0: 
0: 		@see RawStoreFactory#startTransaction
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 		@exception StandardException A transaction level exception is 
0:         thrown if the transaction is not idle.
0: 
0: 		
0: 	*/
0: 	public void destroy() throws StandardException;
0: 
0: 
0: 	/**
0: 		Set a save point in the current transaction. A save point defines a 
0:         point in time in the transaction that changes can be rolled back to. 
0:         Savepoints can be nested and they behave like a stack. Setting save 
0:         points "one" and "two" and the rolling back "one" will rollback all 
0:         the changes made since "one" (including those made since "two") and 
0:         release savepoint "two".
0:     @param name     The user provided name of the savepoint
0: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
0:                     Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
0:                     A String value for kindOfSavepoint would mean it is SQL savepoint
0:                     A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
0: 
0: 		@return returns total number of savepoints in the stack.
0: 		@exception StandardException  Standard cloudscape exception policy
0: 		@exception StandardException
0:         A statement level exception is thrown if a savepoint already 
0:         exists in the current transaction with the same name.
0: 		
0: 	*/
0: 
0: 	public int setSavePoint(String name, Object kindOfSavepoint) throws StandardException;
0: 
0: 	/**
0: 		Release the save point of the given name. Relasing a savepoint removes 
0:         all knowledge from this transaction of the named savepoint and any 
0:         savepoints set since the named savepoint was set.
0:     @param name     The user provided name of the savepoint, set by the user
0:                     in the setSavePoint() call.
0: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
0:                     Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
0:                     A String value for kindOfSavepoint would mean it is SQL savepoint
0:                     A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
0: 
0: 		@return returns total number of savepoints in the stack.
0: 		@exception StandardException  Standard cloudscape exception policy
0: 		@exception StandardException
0:         A statement level exception is thrown if a savepoint already
0:         exists in the current transaction with the same name.
0: 
0: 	*/
0: 
0: 	public int releaseSavePoint(String name, Object kindOfSavepoint) throws StandardException;
0: 
0: 	/**
0: 		Rollback all changes made since the named savepoint was set. The named
0: 		savepoint is not released, it remains valid within this transaction, and
0: 		thus can be named it future rollbackToSavePoint() calls. Any savepoints
0: 		set since this named savepoint are released (and their changes rolled
0:         back).
0:     @param name     The user provided name of the savepoint, set by the user
0:                     in the setSavePoint() call.
0: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
0:                     Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
0:                     A String value for kindOfSavepoint would mean it is SQL savepoint
0:                     A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
0: 
0: 		@return returns total number of savepoints in the stack.
0: 		@exception StandardException  Standard cloudscape exception policy
0: 		@exception StandardException
0:         A statement level exception is thrown if no savepoint exists with 
0:         the given name.
0: 
0: 	*/
0: 	public int rollbackToSavePoint(String name, Object kindOfSavepoint) throws StandardException;
0: 
0: 	/**
0: 
0: 		Open a container, with the transaction's default locking policy.
0: 
0:         <p>
0:         Note that if NOWAIT has been specified lock will be 
0:         requested with no wait time, and if lock is not granted a 
0:         SQLState.LOCK_TIMEOUT exception will be thrown.
0: 		<P>
0: 		The release() method of ContainerHandle will be called when this 
0:         transaction is aborted or commited, it may be called explicitly to
0: 		release the ContainerHandle before the end of the transaction.
0: 
0: 
0: 		@return a valid ContainerHandle or null if the container does not exist.
0: 
0: 		@exception StandardException  Standard cloudscape exception policy
0: 
0: 	*/
0: 	public ContainerHandle openContainer(ContainerKey containerId,  int mode)
0: 		throws StandardException;
0: 
0: 	/**
0: 
0: 		Open a container, with the defined locking policy, otherwise
0: 		as openContainer(int containerId,  boolean forUpdate).
0: 
0: 		<P>
0: 		Calls locking.lockContainer(this, returnValue, forUpdate) to lock the
0:         container.  Note that if NOWAIT has been specified lock will be 
0:         requested with no wait time, and if lock is not granted a 
0:         SQLState.LOCK_TIMEOUT exception will be thrown.
0: 
0: 		@param policy The lock policy to use, if null then then a no locking 
0:         policy will be used.
0: 
0: 		@return a valid ContainerHandle or null if the container does not exist.
0: 
0: 		@exception StandardException  Standard cloudscape exception policy
0: 
0: 	*/
0: 
0: 	public ContainerHandle openContainer(ContainerKey containerId,
0: 										 LockingPolicy locking, int mode) 
0: 		throws StandardException;
0: 
0: 
0: 	/**
0: 		Add a new container to the segment. The new container initially has
0: 		one page, page Container.FIRST_PAGE_NUMBER.
0: 
0: 		<BR>
0: 		If pageSize is equal to ContainerHandle.DEFAULT_PAGESIZE or invalid 
0:         then a default page size will be picked.
0: 		<BR>
0: 		SpareSpace indicates that percent (0% - 100%) of page space that will 
0:         be attempted to be reserved for updates. E.g. with a value of 20 a page
0:         that would normally hold 40 rows will be limited to 32 rows,
0: 		actual calculation for the threshold where no more inserts are all 
0:         accepted is up to the implementation.  Whatever the value of 
0:         spaceSpace an empty page will always accept at least one insert.
0: 		If spare space is equal to ContainerHandle.DEFAULT_PAGESIZE or invalid 
0:         then a default value will be used.
0: 
0: 	    <P><B>Synchronisation</B>
0: 		<P>
0: 		The new container is exclusivly locked by this transaction until
0: 		it commits.
0: 
0: 		@param segmentId    segment to create the container in.
0: 		@param containerId  If not equal to 0 then this container id will be 
0:                             used to create the container, else if set to 0 then
0:                             the raw store will assign a number.
0: 		@param mode mode description in @see ContainerHandle.  This mode is
0: 		only effective for the duration of the addContainer call and not stored
0: 		persistently for the lifetime of the container.
0: 		@param tableProperties Implementation-specific properties of the
0: 		conglomerate.
0: 
0: 		@return a container identifer that can be used in openContainer()
0: 		This id is only valid within this RawStoreFactory.  Returns a negative 
0:         number if a container could not be allocated.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 	*/
0: 	public long addContainer(
0:     long        segmentId, 
0:     long        containerId,
0:     int         mode, 
0:     Properties  tableProperties, 
0:     int         temporaryFlag) 
0: 		throws StandardException;
0: 
0: 	/**
0: 		Drop a container.
0: 
0: 	    <P><B>Synchronisation</B>
0: 		<P>
0: 		This call will mark the container as dropped and then obtain an CX lock
0: 		on the container. Once a container has been marked as dropped it cannot
0: 		be retrieved by any openContainer() call.
0: 		<P>
0: 		Once the exclusive lock has been obtained the container is removed
0: 		and all its pages deallocated. The container will be fully removed
0: 		at the commit time of the transaction.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 	*/
0: 	public void dropContainer(ContainerKey containerId)
0: 		throws StandardException;
0: 
0: 	/**
0: 		Add a new stream container to the segment and load the stream container.
0: 		
0: 		This stream container doesn't not have locks, and do not log.
0: 		It does not have the concept of a page.
0: 		It is used by the external sort only.
0: 
0: 	    <P><B>Synchronisation</B>
0: 		<P>
0: 		This call will mark the container as dropped and then obtain an CX lock
0: 		on the container. Once a container has been marked as dropped it cannot
0: 		be retrieved by any openContainer() call.
0: 		<P>
0: 		Once the exclusive lock has been obtained the container is removed
0: 		and all its pages deallocated. The container will be fully removed
0: 		at the commit time of the transaction.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 	*/
0: 	public long addAndLoadStreamContainer(
0: 			long segmentId, Properties tableProperties, RowSource rowSource)
0: 		throws StandardException;
0: 
0: 
0: 	/**
0: 		Open a stream container.
0: 
0: 		@return a valid StreamContainerHandle or null if the container does not exist.
0: 
0: 		@exception StandardException  Standard cloudscape exception policy
0: 
0: 	*/
0: 	public StreamContainerHandle openStreamContainer(
0:     long    segmentId, 
0:     long    containerId,
0:     boolean hold)
0: 		throws StandardException;
0: 
0: 	/**
0: 		Drop a stream container.
0: 
0: 	    <P><B>Synchronisation</B>
0: 		<P>
0: 		This call will remove the container.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 
0: 	*/
0: 	public abstract void dropStreamContainer(long segmentId, long containerId)
0: 		throws StandardException;
0: 		
0: 	/**
0: 		Log an operation and then action it in the context of this transaction.
0: 		The Loggable Operation is logged in the transaction log file and then 
0:         its doMe method is called to perform the required change. If this 
0:         transaction aborts or a rollback is performed of the current savepoint 
0:         (if any) then a compensation Operation needs to be generated that will 
0:         compensate for the change of this Operation. 
0: 
0: 		@param operation the operation that is to be applied
0: 
0: 		@see Loggable
0: 
0: 		@exception StandardException  Standard cloudscape exception policy
0: 
0: 	*/
0: 	public void logAndDo(Loggable operation) throws StandardException;
0: 
0: 
0: 	/**
0: 		Add to the list of post commit work that may be processed after this
0: 		transaction commits.  If this transaction aborts, then the post commit
0: 		work list will be thrown away.  No post commit work will be taken out
0: 		on a rollback to save point.
0: 
0: 		@param work the post commit work that is added
0: 	*/
0: 	public void addPostCommitWork(Serviceable work);
0: 
0: 	/**
0: 		Add to the list of post termination work that may be processed after this
0: 		transaction commits or aborts.
0: 
0: 		@param work the post termination work that is added
0: 	*/
0: 	public void addPostTerminationWork(Serviceable work);
0: 
0:     /**
0:      * Reveals whether the transaction has ever read or written data.
0:      *
0: 	 * @return true If the transaction has never read or written data.
0:      **/
0: 	public boolean isIdle();
0: 
0:     /**
0: 	  Reveal whether the transaction is in a pristine state, which
0: 	  means it hasn't done any updates since the last commit.
0: 	  @return true if so, false otherwise
0: 	  */
0:     public boolean isPristine();
0: 
0: 	/**
0: 		Get an object to handle non-transactional files.
0: 	*/
0: 	public FileResource getFileHandler();
0: 
0: 	/**
0: 		Get cache statistics for the specified cache
0: 	*/
0: 	public abstract long[] getCacheStats(String cacheName);
0: 
0: 	/**
0: 		Reset the cache statistics for the specified cache
0: 	*/
0: 	public abstract void resetCacheStats(String cacheName);
0: 
0: 	/**
0: 		Return true if any transaction is blocked, even if not by this one.
0: 	 */
0: 	public  boolean anyoneBlocked();
0: 
0: 	/**
0:      * Convert a local transaction to a global transaction.
0:      * <p>
0: 	 * Get a transaction controller with which to manipulate data within
0: 	 * the access manager.  Tbis controller allows one to manipulate a 
0:      * global XA conforming transaction.
0:      * <p>
0:      * Must only be called a previous local transaction was created and exists
0:      * in the context.  Can only be called if the current transaction is in
0:      * the idle state.  
0:      * <p>
0:      * The (format_id, global_id, branch_id) triplet is meant to come exactly
0:      * from a javax.transaction.xa.Xid.  We don't use Xid so that the system
0:      * can be delivered on a non-1.2 vm system and not require the javax classes
0:      * in the path.  
0:      *
0:      * @param cm        The context manager for the current context.
0:      * @param format_id the format id part of the Xid - ie. Xid.getFormatId().
0:      * @param global_id the global transaction identifier part of XID - ie.
0:      *                  Xid.getGlobalTransactionId().
0:      * @param branch_id The branch qualifier of the Xid - ie. 
0:      *                  Xid.getBranchQaulifier()
0:      * 	
0: 	 * @exception StandardException Standard exception policy.
0: 	 **/
0: 	void createXATransactionFromLocalTransaction(
0:     int                     format_id,
0:     byte[]                  global_id,
0:     byte[]                  branch_id)
0: 		throws StandardException;
0: 
0:     /**
0:      * This method is called to commit the current XA global transaction.
0:      * <p>
0:      * RESOLVE - how do we map to the "right" XAExceptions.
0:      * <p>
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0:      * @param onePhase If true, the resource manager should use a one-phase
0:      *                 commit protocol to commit the work done on behalf of 
0:      *                 current xid.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void xa_commit(
0:     boolean onePhase)
0: 		throws StandardException;
0: 
0:     /**
0:      * This method is called to ask the resource manager to prepare for
0:      * a transaction commit of the transaction specified in xid.
0:      * <p>
0:      *
0:      * @return         A value indicating the resource manager's vote on the
0:      *                 the outcome of the transaction.  The possible values
0:      *                 are:  XA_RDONLY or XA_OK.  If the resource manager wants
0:      *                 to roll back the transaction, it should do so by 
0:      *                 throwing an appropriate XAException in the prepare
0:      *                 method.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public int xa_prepare()
0: 		throws StandardException;
0:     public static final int XA_RDONLY = 1; 
0:     public static final int XA_OK     = 2; 
0: 
0:     /**
0:      * rollback the current global transaction.
0:      * <p>
0:      * The given transaction is roll'ed back and it's history is not
0:      * maintained in the transaction table or long term log.
0:      * <p>
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void xa_rollback()
0:         throws StandardException;
0: 
0: 	
0:     /**
0: 	 * get string ID of the actual transaction ID that will 
0: 	 * be used when transaction is in  active state. 
0: 	 */
0: 	public String getActiveStateTxIdString();
0: 
0: 
0: 
0: }
============================================================================