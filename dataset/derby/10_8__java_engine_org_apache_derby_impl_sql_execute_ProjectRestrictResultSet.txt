1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.ProjectRestrictResultSet
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
11:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:af1c18c: import java.util.Enumeration;
1:f6d02c9: import org.apache.derby.catalog.UUID;
1:4cc0287: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1:4cc0287: import org.apache.derby.iapi.error.StandardException;
1:4cc0287: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:4cc0287: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.conn.StatementContext;
1:eac0369: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:7d0f620: import org.apache.derby.iapi.sql.execute.RowChanger;
1:4cc0287: import org.apache.derby.iapi.types.DataValueDescriptor;
1:4cc0287: import org.apache.derby.iapi.types.RowLocation;
1:af1c18c: import org.apache.derby.iapi.types.SQLRef;
1:4cc0287: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: 
1:eac0369: /**
1:eac0369:  * Takes a table and a table filter and returns
1:eac0369:  * the table's rows satisfying the filter as a result set.
1:eac0369:  *
1:eac0369:  */
1:f77f36d: class ProjectRestrictResultSet extends NoPutResultSetImpl
1:eac0369: 	implements CursorResultSet 
1:eac0369: {
1:eac0369: 	/* Run time statistics variables */
1:eac0369: 	public long restrictionTime;
1:eac0369: 	public long projectionTime;
1:eac0369: 
1:eac0369:     // set in constructor and not altered during
1:eac0369:     // life of object.
1:9f3bf4b:     final NoPutResultSet source;
1:eac0369: 	public GeneratedMethod constantRestriction;
1:eac0369:     public GeneratedMethod restriction;
1:eac0369: 	public boolean doesProjection;
1:eac0369:     private GeneratedMethod projection;
1:eac0369: 	private int[]			projectMapping;
1:1d0c809: 
1:1d0c809:     /**
1:1d0c809:      * Holds columns present more than once in the result set and which may be
1:1d0c809:      * represented by a stream, since such columns need to be cloned.
1:1d0c809:      */
1:1d0c809:     private boolean[] cloneMap;
1:1d0c809: 
1:eac0369: 	private boolean runTimeStatsOn;
1:eac0369: 	private ExecRow			mappedResultRow;
1:eac0369: 	public boolean reuseResult;
1:eac0369: 
1:eac0369: 	private boolean shortCircuitOpen;
1:eac0369: 
1:eac0369: 	private ExecRow projRow;
1:4cc0287:     private final boolean validatingCheckConstraint;
1:f6d02c9:     private final UUID validatingBaseTableUUID;
1:4cc0287:     Enumeration<Object> rowLocations;
1:eac0369: 
1:eac0369:     // class interface
1:1d0c809:     //
1:f77f36d:     ProjectRestrictResultSet(NoPutResultSet s,
1:eac0369: 					Activation a,
1:eac0369: 					GeneratedMethod r,
1:eac0369: 					GeneratedMethod p,
1:eac0369: 					int resultSetNumber,
1:eac0369: 					GeneratedMethod cr,
1:eac0369: 					int mapRefItem,
1:1d0c809:                     int cloneMapItem,
1:eac0369: 					boolean reuseResult,
1:eac0369: 					boolean doesProjection,
1:af1c18c:                     boolean validatingCheckConstraint,
1:f6d02c9:                     UUID validatingBaseTableUUID,
1:eac0369: 				    double optimizerEstimatedRowCount,
1:f77f36d: 					double optimizerEstimatedCost) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
1:eac0369:         source = s;
1:eac0369: 		// source expected to be non-null, mystery stress test bug
1:eac0369: 		// - sometimes get NullPointerException in openCore().
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(source != null,
1:eac0369: 				"PRRS(), source expected to be non-null");
1:eac0369: 		}
1:eac0369:         restriction = r;
1:eac0369:         projection = p;
1:eac0369: 		constantRestriction = cr;
1:eac0369: 		projectMapping = ((ReferencedColumnsDescriptorImpl) a.getPreparedStatement().getSavedObject(mapRefItem)).getReferencedColumnPositions();
1:eac0369: 		this.reuseResult = reuseResult;
1:eac0369: 		this.doesProjection = doesProjection;
1:af1c18c:         this.validatingCheckConstraint = validatingCheckConstraint;
1:f6d02c9:         this.validatingBaseTableUUID = validatingBaseTableUUID;
1:eac0369: 
1:eac0369: 		// Allocate a result row if all of the columns are mapped from the source
1:eac0369: 		if (projection == null)
1:eac0369: 		{
1:eac0369: 			mappedResultRow = activation.getExecutionFactory().getValueRow(projectMapping.length);
1:eac0369: 		}
1:eac0369: 
1:1d0c809:         cloneMap =
1:1d0c809:             ((boolean[])a.getPreparedStatement().getSavedObject(cloneMapItem));
1:1d0c809: 
1:eac0369: 		/* Remember whether or not RunTimeStatistics is on */
1:eac0369: 		runTimeStatsOn = getLanguageConnectionContext().getRunTimeStatisticsMode();
1:7008b63: 		recordConstructorTime();
1:eac0369:     }
1:eac0369: 
1:1d0c809: 	//
1:eac0369: 	// NoPutResultSet interface 
4:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * open a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369:      */
1:eac0369: 	public void	openCore() throws StandardException 
1:eac0369: 	{
1:eac0369: 		boolean constantEval = true;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		// source expected to be non-null, mystery stress test bug
1:eac0369: 		// - sometimes get NullPointerException in openCore().
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(source != null,
1:eac0369: 				"PRRS().openCore(), source expected to be non-null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// REVISIT: through the direct DB API, this needs to be an
1:eac0369: 		// error, not an ASSERT; users can open twice. Only through JDBC
1:eac0369: 		// is access to open controlled and ensured valid.
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		    SanityManager.ASSERT( ! isOpen, "ProjectRestrictResultSet already open");
1:eac0369: 
1:eac0369: 		if (constantRestriction != null)
1:eac0369: 		{
1:eac0369: 		    DataValueDescriptor restrictBoolean;
1:eac0369:             restrictBoolean = (DataValueDescriptor) 
1:eac0369: 					constantRestriction.invoke(activation);
1:eac0369: 
1:eac0369: 	            // if the result is null, we make it false --
1:eac0369: 				// so the row won't be returned.
1:eac0369:             constantEval = (restrictBoolean == null) ||
1:eac0369: 						((! restrictBoolean.isNull()) &&
1:eac0369: 							restrictBoolean.getBoolean());
1:eac0369: 		}
1:eac0369: 
1:af1c18c:         if (validatingCheckConstraint) {
1:4cc0287:             rowLocations = DeferredConstraintsMemory.
1:4cc0287:                 getDeferredCheckConstraintLocations(
1:f6d02c9:                         activation, validatingBaseTableUUID);
1:af1c18c:         }
1:af1c18c: 
1:af1c18c: 
1:eac0369: 		if (constantEval)
1:eac0369: 		{
1:eac0369: 	        source.openCore();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			shortCircuitOpen = true;
1:eac0369: 		}
1:eac0369: 	    isOpen = true;
1:eac0369: 
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * reopen a scan on the table. scan parameters are evaluated
1:eac0369:      * at each open, so there is probably some way of altering
1:eac0369:      * their values...
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if cursor finished.
1:eac0369:      */
1:eac0369: 	public void	reopenCore() throws StandardException 
1:eac0369: 	{
1:eac0369: 		boolean constantEval = true;
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		    SanityManager.ASSERT(isOpen, "ProjectRestrictResultSet not open, cannot reopen");
1:eac0369: 
1:eac0369: 		if (constantRestriction != null)
1:eac0369: 		{
1:eac0369: 		    DataValueDescriptor restrictBoolean;
1:eac0369:             restrictBoolean = (DataValueDescriptor) 
1:eac0369: 					constantRestriction.invoke(activation);
1:eac0369: 
1:eac0369: 	            // if the result is null, we make it false --
1:eac0369: 				// so the row won't be returned.
1:eac0369:             constantEval = (restrictBoolean == null) ||
1:eac0369: 						((! restrictBoolean.isNull()) &&
1:eac0369: 							restrictBoolean.getBoolean());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (constantEval)
1:eac0369: 		{
1:eac0369: 	        source.reopenCore();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			shortCircuitOpen = true;
1:eac0369: 		}
1:eac0369: 	    isOpen = true;
1:eac0369: 
1:eac0369: 		numOpens++;
1:eac0369: 
1:eac0369: 		openTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * Return the requested values computed
1:eac0369:      * from the next row (if any) for which
1:eac0369:      * the restriction evaluates to true.
1:eac0369:      * <p>
1:eac0369:      * restriction and projection parameters
1:eac0369:      * are evaluated for each row.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1:eac0369: 	 *
1:eac0369: 	 * @return the next row in the result
1:eac0369: 	 */
1:eac0369: 	public ExecRow	getNextRowCore() throws StandardException {
1:2a4654b: 		if( isXplainOnlyMode() )
1:2a4654b: 			return null;
1:eac0369: 
1:eac0369: 	    ExecRow candidateRow = null;
1:2700e3d: 	    ExecRow result = null;
1:eac0369: 	    boolean restrict = false;
1:eac0369: 	    DataValueDescriptor restrictBoolean;
1:eac0369: 		long	beginRT = 0;
1:eac0369: 
1:eac0369: 		/* Return null if open was short circuited by false constant expression */
1:eac0369: 		if (shortCircuitOpen)
1:eac0369: 		{
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    do 
1:eac0369: 		{
1:af1c18c: 
1:af1c18c:             if (validatingCheckConstraint) {
1:af1c18c:                 candidateRow = null;
1:af1c18c: 
1:af1c18c:                 while (rowLocations.hasMoreElements() && candidateRow == null) {
1:af1c18c:                     DataValueDescriptor[] row =
1:af1c18c:                             (DataValueDescriptor[])rowLocations.nextElement();
1:af1c18c:                     RowLocation rl = (RowLocation)((SQLRef)row[0]).getObject();
1:af1c18c:                     ((ValidateCheckConstraintResultSet)source).
1:af1c18c:                         positionScanAtRowLocation(rl);
1:af1c18c:                     candidateRow = source.getNextRowCore();
1:af1c18c:                     // if null (deleted), we move to next
1:af1c18c:                 }
1:af1c18c: 
1:af1c18c: 
1:af1c18c:             } else {
1:af1c18c:                 candidateRow = source.getNextRowCore();
1:af1c18c:             }
1:af1c18c: 
1:eac0369: 			if (candidateRow != null) 
1:eac0369: 			{
1:eac0369: 				beginRT = getCurrentTimeMillis();
1:eac0369: 				/* If restriction is null, then all rows qualify */
1:eac0369: 				if (restriction == null)
1:eac0369: 				{
1:eac0369: 					restrict = true;
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					setCurrentRow(candidateRow);
1:eac0369: 		            restrictBoolean = (DataValueDescriptor) 
1:eac0369: 											restriction.invoke(activation);
1:eac0369: 					restrictionTime += getElapsedMillis(beginRT);
1:eac0369: 
1:eac0369: 		            // if the result is null, we make it false --
1:eac0369: 					// so the row won't be returned.
1:eac0369: 				    restrict = ((! restrictBoolean.isNull()) &&
1:eac0369: 								 restrictBoolean.getBoolean());
1:eac0369: 					if (! restrict)
1:eac0369: 					{
1:eac0369: 						rowsFiltered++;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/* Update the run time statistics */
1:eac0369: 				rowsSeen++;
1:eac0369: 			}
1:eac0369: 	    } while ( (candidateRow != null) &&
1:eac0369: 	              (! restrict ) );
1:eac0369: 
1:eac0369: 	    if (candidateRow != null) 
1:eac0369: 		{
1:eac0369: 			beginRT = getCurrentTimeMillis();
1:eac0369: 
1:eac0369: 			result = doProjection(candidateRow);
1:eac0369: 
1:eac0369: 			projectionTime += getElapsedMillis(beginRT);
1:eac0369:         }
1:eac0369: 		/* Clear the current row, if null */
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			clearCurrentRow();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 		currentRow = result;
1:eac0369: 
1:eac0369: 		if (runTimeStatsOn)
1:eac0369: 		{
1:eac0369: 			if (! isTopResultSet)
1:eac0369: 			{
1:eac0369: 				/* This is simply for RunTimeStats */
1:eac0369: 				/* We first need to get the subquery tracking array via the StatementContext */
1:eac0369: 				StatementContext sc = activation.getLanguageConnectionContext().getStatementContext();
1:eac0369: 				subqueryTrackingArray = sc.getSubqueryTrackingArray();
1:eac0369: 			}
1:eac0369: 			nextTime += getElapsedMillis(beginTime);
1:eac0369: 		}
1:eac0369:     	return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1:eac0369: 
1:eac0369: 		if (type == CURRENT_RESULTSET_ONLY)
1:eac0369: 		{
1:eac0369: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return totTime;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// ResultSet interface
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * If the result set has been opened,
1:eac0369: 	 * close the open scan.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	close() throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Nothing to do if open was short circuited by false constant expression */
1:eac0369: 		if (shortCircuitOpen)
1:eac0369: 		{
1:eac0369: 			shortCircuitOpen = false;
1:9f3bf4b: 			source.close();
1:da3d219:             super.close();
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 	    if ( isOpen ) {
1:eac0369: 
1:eac0369: 			// we don't want to keep around a pointer to the
1:eac0369: 			// row ... so it can be thrown away.
1:eac0369: 			// REVISIT: does this need to be in a finally
1:eac0369: 			// block, to ensure that it is executed?
1:eac0369: 	    	clearCurrentRow();
1:f77f36d: 
1:eac0369: 	        source.close();
1:eac0369: 
1:eac0369: 			super.close();
1:eac0369: 	    }
1:eac0369: 		else
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 				SanityManager.DEBUG("CloseRepeatInfo","Close of ProjectRestrictResultSet repeated");
1:eac0369: 
1:eac0369: 		closeTime += getElapsedMillis(beginTime);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	finish() throws StandardException
1:eac0369: 	{
1:eac0369: 		source.finish();
1:eac0369: 		finishAndRTS();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	//
1:eac0369: 	// CursorResultSet interface
1:eac0369: 	//
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets information from its source. We might want
1:eac0369: 	 * to have this take a CursorResultSet in its constructor some day,
1:eac0369: 	 * instead of doing a cast here?
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the row location of the current cursor row.
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	public RowLocation getRowLocation() throws StandardException {
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source is not CursorResultSet");
1:eac0369: 		return ( (CursorResultSet)source ).getRowLocation();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets last row returned.
1:eac0369: 	 *
1:eac0369: 	 * @see CursorResultSet
1:eac0369: 	 *
1:eac0369: 	 * @return the last row returned.
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1:eac0369: 	 * once there is such a method.  (currentRow is redundant)
1:eac0369: 	 */
1:eac0369: 	public ExecRow getCurrentRow() throws StandardException {
1:eac0369: 	    ExecRow candidateRow = null;
2:eac0369: 	    ExecRow result = null;
1:eac0369: 	    boolean restrict = false;
1:eac0369: 	    DataValueDescriptor restrictBoolean;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(isOpen, "PRRS is expected to be open");
1:eac0369: 
1:eac0369: 		/* Nothing to do if we're not currently on a row */
1:eac0369: 		if (currentRow == null)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Call the child result set to get it's current row.
1:eac0369: 		 * If no row exists, then return null, else requalify it
1:eac0369: 		 * before returning.
1:eac0369: 		 */
1:eac0369: 		candidateRow = ((CursorResultSet) source).getCurrentRow();
1:eac0369: 		if (candidateRow != null) {
1:eac0369: 			setCurrentRow(candidateRow);
1:eac0369: 				/* If restriction is null, then all rows qualify */
1:eac0369:             restrictBoolean = (DataValueDescriptor) 
1:eac0369: 					((restriction == null) ? null : restriction.invoke(activation));
1:eac0369: 
1:eac0369:             // if the result is null, we make it false --
1:eac0369: 			// so the row won't be returned.
1:eac0369:             restrict = (restrictBoolean == null) ||
1:eac0369: 						((! restrictBoolean.isNull()) &&
1:eac0369: 							restrictBoolean.getBoolean());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	    if (candidateRow != null && restrict) 
1:eac0369: 		{
1:eac0369: 			result = doProjection(candidateRow);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		currentRow = result;
1:eac0369: 		/* Clear the current row, if null */
1:eac0369: 		if (result == null) {
1:eac0369: 			clearCurrentRow();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return currentRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do the projection against the source row.  Use reflection
1:eac0369: 	 * where necessary, otherwise get the source column into our
1:eac0369: 	 * result row.
1:eac0369: 	 *
1:eac0369: 	 * @param sourceRow		The source row.
1:eac0369: 	 *
1:eac0369: 	 * @return		The result of the projection
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure.
1:eac0369: 	 */
1:eac0369: 	private ExecRow doProjection(ExecRow sourceRow)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// No need to use reflection if reusing the result
1:eac0369: 		if (reuseResult && projRow != null)
1:eac0369: 		{
1:ae9260f: 			/* Make sure we reset the current row based on the re-used
1:ae9260f: 			 * result.  Otherwise, if the "current row" for this result
1:ae9260f: 			 * set was nulled out in a previous call to getNextRow(),
1:ae9260f: 			 * which can happen if this node is the right-side of
1:ae9260f: 			 * a left outer join, the "current row" stored for this
1:ae9260f: 			 * result set in activation.row would remain null, which
1:ae9260f: 			 * would be wrong. DERBY-3538.
1:ae9260f: 			 */
1:ae9260f: 			setCurrentRow(projRow);
1:eac0369: 			return projRow;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		ExecRow result;
1:eac0369: 
1:eac0369: 		// Use reflection to do as much of projection as required
1:eac0369: 		if (projection != null)
1:eac0369: 		{
1:eac0369: 	        result = (ExecRow) projection.invoke(activation);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			result = mappedResultRow;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Copy any mapped columns from the source
1:eac0369: 		for (int index = 0; index < projectMapping.length; index++)
1:eac0369: 		{
1:eac0369: 			if (projectMapping[index] != -1)
1:eac0369: 			{
1:1d0c809:                 DataValueDescriptor dvd =
1:1d0c809:                         sourceRow.getColumn(projectMapping[index]);
1:1d0c809: 
1:1d0c809:                 // See if the column has been marked for cloning.
1:1d0c809:                 // If the value isn't a stream, don't bother cloning it.
1:541361f:                 if (cloneMap[index] && dvd.hasStream()) {
1:2d733d9:                     dvd = dvd.cloneValue(false);
1:1d0c809:                 }
1:2d733d9: 
1:1d0c809:                 result.setColumn(index + 1, dvd);
1:eac0369: 			}
1:eac0369: 		}
1:1d0c809: 
1:eac0369: 		/* We need to reSet the current row after doing the projection */
1:eac0369: 		setCurrentRow(result);
1:eac0369: 
1:eac0369: 		/* Remember the result if reusing it */
1:eac0369: 		if (reuseResult)
1:eac0369: 		{
1:eac0369: 			projRow = result;
1:eac0369: 		}
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2700e3d: 	 * Do the projection against the sourceRow. If the source of the result set
1:2700e3d: 	 * is of type ProjectRestrictResultSet, the projection by that result set
1:2700e3d: 	 * will also be performed.
1:2700e3d: 	 *
1:2700e3d: 	 * @param sourceRow row to be projected
1:2700e3d: 	 *
1:2700e3d: 	 * @return The result of the projection
1:2700e3d: 	 *
1:2700e3d: 	 * @exception StandardException thrown on failure.
1:2700e3d: 	 */
1:2700e3d: 	public ExecRow doBaseRowProjection(ExecRow sourceRow)
1:2700e3d: 		throws StandardException
1:2700e3d: 	{
1:b7c1f3b: 		final ExecRow result;
1:2700e3d: 		if (source instanceof ProjectRestrictResultSet) {
1:2700e3d: 			ProjectRestrictResultSet prs = (ProjectRestrictResultSet) source;
1:2700e3d: 			result = prs.doBaseRowProjection(sourceRow);
1:2700e3d: 		} else {
1:b7c1f3b: 			result = sourceRow.getNewNullRow();
1:b7c1f3b: 			result.setRowArray(sourceRow.getRowArray());
1:2700e3d: 		}
1:2700e3d: 		return doProjection(result);
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:b7c1f3b: 	 * Get projection mapping array. The array consist of indexes which
1:b7c1f3b: 	 * maps the column in a row array to another position in the row array.
1:b7c1f3b: 	 * If the value is projected out of the row, the value is negative.
1:b7c1f3b: 	 * @return projection mapping array.
1:eac0369: 	 */
1:b7c1f3b: 	public int[] getBaseProjectMapping() 
1:eac0369: 	{
1:b7c1f3b: 		final int[] result;
1:b7c1f3b: 		if (source instanceof ProjectRestrictResultSet) {
1:b7c1f3b: 			result = new int[projectMapping.length];
1:b7c1f3b: 			final ProjectRestrictResultSet prs = (ProjectRestrictResultSet) source;
1:b7c1f3b: 			final int[] sourceMap = prs.getBaseProjectMapping();
1:b7c1f3b: 			for (int i=0; i<projectMapping.length; i++) {
1:b7c1f3b: 				if (projectMapping[i] > 0) {
1:b7c1f3b: 					result[i] = sourceMap[projectMapping[i] - 1];
1:eac0369: 				}
2:b7c1f3b: 			}
1:b7c1f3b: 		} else {
1:b7c1f3b: 			result = projectMapping;
1:b7c1f3b: 		}
1:b7c1f3b: 		return result;
1:b7c1f3b: 	} 
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Is this ResultSet or it's source result set for update
1:eac0369: 	 * 
1:eac0369: 	 * @return Whether or not the result set is for update.
1:eac0369: 	 */
1:eac0369: 	public boolean isForUpdate()
1:eac0369: 	{
1:eac0369: 		return source.isForUpdate();
1:eac0369: 	}
1:eac0369: 
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#updateRow
1:2700e3d: 	 */
1:7d0f620: 	public void updateRow (ExecRow row, RowChanger rowChanger)
1:7d0f620: 			throws StandardException {
1:7d0f620: 		source.updateRow(row, rowChanger);
1:2700e3d: 	}
1:2700e3d: 
1:2700e3d: 	/**
1:2700e3d: 	 * @see NoPutResultSet#markRowAsDeleted
1:2700e3d: 	 */
1:2700e3d: 	public void markRowAsDeleted() throws StandardException {
1:2700e3d: 		source.markRowAsDeleted();
1:2700e3d: 	}
1:2700e3d: 
1:eac0369: }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
/////////////////////////////////////////////////////////////////////////
1:     private final UUID validatingBaseTableUUID;
/////////////////////////////////////////////////////////////////////////
1:                     UUID validatingBaseTableUUID,
/////////////////////////////////////////////////////////////////////////
1:         this.validatingBaseTableUUID = validatingBaseTableUUID;
/////////////////////////////////////////////////////////////////////////
1:                         activation, validatingBaseTableUUID);
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     private final boolean validatingCheckConstraint;
0:     private final long validatingBaseTableCID;
1:     Enumeration<Object> rowLocations;
/////////////////////////////////////////////////////////////////////////
1:             rowLocations = DeferredConstraintsMemory.
1:                 getDeferredCheckConstraintLocations(
0:                         activation, validatingBaseTableCID);
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.SQLRef;
/////////////////////////////////////////////////////////////////////////
0:     private boolean validatingCheckConstraint;
0:     private long validatingBaseTableCID;
0:     DeferredConstraintsMemory.CheckInfo ci;
0:     Enumeration rowLocations;
/////////////////////////////////////////////////////////////////////////
1:                     boolean validatingCheckConstraint,
0:                     long validatingBaseTableCID,
/////////////////////////////////////////////////////////////////////////
1:         this.validatingCheckConstraint = validatingCheckConstraint;
0:         this.validatingBaseTableCID = validatingBaseTableCID;
/////////////////////////////////////////////////////////////////////////
1:         if (validatingCheckConstraint) {
0:             ci = (DeferredConstraintsMemory.CheckInfo)activation.
0:                 getLanguageConnectionContext().
0:                 getDeferredHashTables().get(
0:                     Long.valueOf(validatingBaseTableCID));
0:             rowLocations = ci.infoRows.elements();
1:         }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (validatingCheckConstraint) {
1:                 candidateRow = null;
1: 
1:                 while (rowLocations.hasMoreElements() && candidateRow == null) {
1:                     DataValueDescriptor[] row =
1:                             (DataValueDescriptor[])rowLocations.nextElement();
1:                     RowLocation rl = (RowLocation)((SQLRef)row[0]).getObject();
1:                     ((ValidateCheckConstraintResultSet)source).
1:                         positionScanAtRowLocation(rl);
1:                     candidateRow = source.getNextRowCore();
1:                     // if null (deleted), we move to next
1:                 }
1: 
1: 
1:             } else {
1:                 candidateRow = source.getNextRowCore();
1:             }
1: 
commit:2d733d9
/////////////////////////////////////////////////////////////////////////
1:                     dvd = dvd.cloneValue(false);
1: 
commit:1d0c809
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.io.StreamStorable;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Holds columns present more than once in the result set and which may be
1:      * represented by a stream, since such columns need to be cloned.
1:      */
1:     private boolean[] cloneMap;
1: 
/////////////////////////////////////////////////////////////////////////
1:                     int cloneMapItem,
/////////////////////////////////////////////////////////////////////////
1:         cloneMap =
1:             ((boolean[])a.getPreparedStatement().getSavedObject(cloneMapItem));
1: 
/////////////////////////////////////////////////////////////////////////
1:                 DataValueDescriptor dvd =
1:                         sourceRow.getColumn(projectMapping[index]);
1: 
1:                 // See if the column has been marked for cloning.
1:                 // If the value isn't a stream, don't bother cloning it.
0:                 if (cloneMap[index] && dvd.getStream() != null) {
1: 
0:                     // Enable this code after DERBY-3650 is in: FIXME
1:                     //
0:                     // long length = dvd.getLengthIfKnown();
1:                     //
0:                     // If the stream isn't clonable, we have to load the stream.
0:                     // if ((length > 32*1024 || length == -1) &&
0:                     //     dvd.getStream() instanceof CloneableStream) {
0:                     //     // Copy the stream, the value may be large.
0:                     //     dvd = dvd.copyForRead();
0:                     // } else {
0:                     //     // Load the stream, then we don't have to clone.
0:                     ((StreamStorable)dvd).loadStream();
0:                     // }
1:                 }
1:                 result.setColumn(index + 1, dvd);
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.RowChanger;
/////////////////////////////////////////////////////////////////////////
1: 	public void updateRow (ExecRow row, RowChanger rowChanger)
1: 			throws StandardException {
1: 		source.updateRow(row, rowChanger);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
commit:2a4654b
/////////////////////////////////////////////////////////////////////////
1: 		if( isXplainOnlyMode() )
1: 			return null;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:da3d219
/////////////////////////////////////////////////////////////////////////
1:             super.close();
commit:9f3bf4b
/////////////////////////////////////////////////////////////////////////
1:     final NoPutResultSet source;
/////////////////////////////////////////////////////////////////////////
1: 			source.close();
commit:2700e3d
/////////////////////////////////////////////////////////////////////////
1: 	 * Do the projection against the sourceRow. If the source of the result set
1: 	 * is of type ProjectRestrictResultSet, the projection by that result set
1: 	 * will also be performed.
1: 	 *
1: 	 * @param sourceRow row to be projected
1: 	 *
1: 	 * @return The result of the projection
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	public ExecRow doBaseRowProjection(ExecRow sourceRow)
1: 		throws StandardException
1: 	{
1: 		ExecRow result = null;
1: 		if (source instanceof ProjectRestrictResultSet) {
1: 			ProjectRestrictResultSet prs = (ProjectRestrictResultSet) source;
1: 			result = prs.doBaseRowProjection(sourceRow);
1: 		} else {
0: 			result = sourceRow.getClone();
1: 		}
1: 		return doProjection(result);
1: 	}
1: 	
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * @see NoPutResultSet#updateRow
1: 	 */
0: 	public void updateRow (ExecRow row) throws StandardException {
0: 		source.updateRow(row);
1: 	}
1: 
1: 	/**
1: 	 * @see NoPutResultSet#markRowAsDeleted
1: 	 */
1: 	public void markRowAsDeleted() throws StandardException {
1: 		source.markRowAsDeleted();
1: 	}
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:541361f
/////////////////////////////////////////////////////////////////////////
1:                 if (cloneMap[index] && dvd.hasStream()) {
commit:2707f51
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:ae9260f
/////////////////////////////////////////////////////////////////////////
1: 			/* Make sure we reset the current row based on the re-used
1: 			 * result.  Otherwise, if the "current row" for this result
1: 			 * set was nulled out in a previous call to getNextRow(),
1: 			 * which can happen if this node is the right-side of
1: 			 * a left outer join, the "current row" stored for this
1: 			 * result set in activation.row would remain null, which
1: 			 * would be wrong. DERBY-3538.
1: 			 */
1: 			setCurrentRow(projRow);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7008b63
/////////////////////////////////////////////////////////////////////////
1: 		recordConstructorTime();
commit:f77f36d
/////////////////////////////////////////////////////////////////////////
1: class ProjectRestrictResultSet extends NoPutResultSetImpl
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     ProjectRestrictResultSet(NoPutResultSet s,
/////////////////////////////////////////////////////////////////////////
1: 					double optimizerEstimatedCost) 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.ProjectRestrictResultSet
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: 
1: 
1: /**
1:  * Takes a table and a table filter and returns
1:  * the table's rows satisfying the filter as a result set.
1:  *
0:  * @author ames
1:  */
0: public class ProjectRestrictResultSet extends NoPutResultSetImpl
1: 	implements CursorResultSet 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/* Run time statistics variables */
1: 	public long restrictionTime;
1: 	public long projectionTime;
1: 
1:     // set in constructor and not altered during
1:     // life of object.
0:     public NoPutResultSet source;
1: 	public GeneratedMethod constantRestriction;
1:     public GeneratedMethod restriction;
1: 	public boolean doesProjection;
1:     private GeneratedMethod projection;
1: 	private int[]			projectMapping;
0:     private GeneratedMethod closeCleanup;
1: 	private boolean runTimeStatsOn;
1: 	private ExecRow			mappedResultRow;
1: 	public boolean reuseResult;
1: 
1: 	private boolean shortCircuitOpen;
1: 
1: 	private ExecRow projRow;
1: 
1:     //
1:     // class interface
1:     //
0:     public ProjectRestrictResultSet(NoPutResultSet s,
1: 					Activation a,
1: 					GeneratedMethod r,
1: 					GeneratedMethod p,
1: 					int resultSetNumber,
1: 					GeneratedMethod cr,
1: 					int mapRefItem,
1: 					boolean reuseResult,
1: 					boolean doesProjection,
1: 				    double optimizerEstimatedRowCount,
0: 					double optimizerEstimatedCost,
0: 					GeneratedMethod c) 
1: 		throws StandardException
1: 	{
1: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
1:         source = s;
1: 		// source expected to be non-null, mystery stress test bug
1: 		// - sometimes get NullPointerException in openCore().
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(source != null,
1: 				"PRRS(), source expected to be non-null");
1: 		}
1:         restriction = r;
1:         projection = p;
1: 		constantRestriction = cr;
1: 		projectMapping = ((ReferencedColumnsDescriptorImpl) a.getPreparedStatement().getSavedObject(mapRefItem)).getReferencedColumnPositions();
1: 		this.reuseResult = reuseResult;
1: 		this.doesProjection = doesProjection;
0:         closeCleanup = c;
1: 
1: 		// Allocate a result row if all of the columns are mapped from the source
1: 		if (projection == null)
1: 		{
1: 			mappedResultRow = activation.getExecutionFactory().getValueRow(projectMapping.length);
1: 		}
1: 
1: 		/* Remember whether or not RunTimeStatistics is on */
1: 		runTimeStatsOn = getLanguageConnectionContext().getRunTimeStatisticsMode();
0: 		constructorTime += getElapsedMillis(beginTime);
1:     }
1: 
1: 	//
1: 	// NoPutResultSet interface 
1: 	//
1: 
1: 	/**
1:      * open a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public void	openCore() throws StandardException 
1: 	{
1: 		boolean constantEval = true;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		// source expected to be non-null, mystery stress test bug
1: 		// - sometimes get NullPointerException in openCore().
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(source != null,
1: 				"PRRS().openCore(), source expected to be non-null");
1: 		}
1: 
1: 		// REVISIT: through the direct DB API, this needs to be an
1: 		// error, not an ASSERT; users can open twice. Only through JDBC
1: 		// is access to open controlled and ensured valid.
1: 		if (SanityManager.DEBUG)
1: 		    SanityManager.ASSERT( ! isOpen, "ProjectRestrictResultSet already open");
1: 
1: 		if (constantRestriction != null)
1: 		{
1: 		    DataValueDescriptor restrictBoolean;
1:             restrictBoolean = (DataValueDescriptor) 
1: 					constantRestriction.invoke(activation);
1: 
1: 	            // if the result is null, we make it false --
1: 				// so the row won't be returned.
1:             constantEval = (restrictBoolean == null) ||
1: 						((! restrictBoolean.isNull()) &&
1: 							restrictBoolean.getBoolean());
1: 		}
1: 
1: 		if (constantEval)
1: 		{
1: 	        source.openCore();
1: 		}
1: 		else
1: 		{
1: 			shortCircuitOpen = true;
1: 		}
1: 	    isOpen = true;
1: 
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1:      * reopen a scan on the table. scan parameters are evaluated
1:      * at each open, so there is probably some way of altering
1:      * their values...
1: 	 *
1: 	 * @exception StandardException thrown if cursor finished.
1:      */
1: 	public void	reopenCore() throws StandardException 
1: 	{
1: 		boolean constantEval = true;
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 
1: 		if (SanityManager.DEBUG)
1: 		    SanityManager.ASSERT(isOpen, "ProjectRestrictResultSet not open, cannot reopen");
1: 
1: 		if (constantRestriction != null)
1: 		{
1: 		    DataValueDescriptor restrictBoolean;
1:             restrictBoolean = (DataValueDescriptor) 
1: 					constantRestriction.invoke(activation);
1: 
1: 	            // if the result is null, we make it false --
1: 				// so the row won't be returned.
1:             constantEval = (restrictBoolean == null) ||
1: 						((! restrictBoolean.isNull()) &&
1: 							restrictBoolean.getBoolean());
1: 		}
1: 
1: 		if (constantEval)
1: 		{
1: 	        source.reopenCore();
1: 		}
1: 		else
1: 		{
1: 			shortCircuitOpen = true;
1: 		}
1: 	    isOpen = true;
1: 
1: 		numOpens++;
1: 
1: 		openTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	/**
1:      * Return the requested values computed
1:      * from the next row (if any) for which
1:      * the restriction evaluates to true.
1:      * <p>
1:      * restriction and projection parameters
1:      * are evaluated for each row.
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
1: 	 *
1: 	 * @return the next row in the result
1: 	 */
1: 	public ExecRow	getNextRowCore() throws StandardException {
1: 
1: 	    ExecRow candidateRow = null;
1: 	    ExecRow result = null;
1: 	    boolean restrict = false;
1: 	    DataValueDescriptor restrictBoolean;
1: 		long	beginRT = 0;
1: 
1: 		/* Return null if open was short circuited by false constant expression */
1: 		if (shortCircuitOpen)
1: 		{
1: 			return result;
1: 		}
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 	    do 
1: 		{
0: 			candidateRow = source.getNextRowCore();
1: 			if (candidateRow != null) 
1: 			{
1: 				beginRT = getCurrentTimeMillis();
1: 				/* If restriction is null, then all rows qualify */
1: 				if (restriction == null)
1: 				{
1: 					restrict = true;
1: 				}
1: 				else
1: 				{
1: 					setCurrentRow(candidateRow);
1: 		            restrictBoolean = (DataValueDescriptor) 
1: 											restriction.invoke(activation);
1: 					restrictionTime += getElapsedMillis(beginRT);
1: 
1: 		            // if the result is null, we make it false --
1: 					// so the row won't be returned.
1: 				    restrict = ((! restrictBoolean.isNull()) &&
1: 								 restrictBoolean.getBoolean());
1: 					if (! restrict)
1: 					{
1: 						rowsFiltered++;
1: 					}
1: 				}
1: 
1: 				/* Update the run time statistics */
1: 				rowsSeen++;
1: 			}
1: 	    } while ( (candidateRow != null) &&
1: 	              (! restrict ) );
1: 
1: 	    if (candidateRow != null) 
1: 		{
1: 			beginRT = getCurrentTimeMillis();
1: 
1: 			result = doProjection(candidateRow);
1: 
1: 			projectionTime += getElapsedMillis(beginRT);
1:         }
1: 		/* Clear the current row, if null */
1: 		else
1: 		{
1: 			clearCurrentRow();
1: 		}
1: 
1: 
1: 		currentRow = result;
1: 
1: 		if (runTimeStatsOn)
1: 		{
1: 			if (! isTopResultSet)
1: 			{
1: 				/* This is simply for RunTimeStats */
1: 				/* We first need to get the subquery tracking array via the StatementContext */
1: 				StatementContext sc = activation.getLanguageConnectionContext().getStatementContext();
1: 				subqueryTrackingArray = sc.getSubqueryTrackingArray();
1: 			}
1: 			nextTime += getElapsedMillis(beginTime);
1: 		}
1:     	return result;
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		long totTime = constructorTime + openTime + nextTime + closeTime;
1: 
1: 		if (type == CURRENT_RESULTSET_ONLY)
1: 		{
1: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
1: 		}
1: 		else
1: 		{
1: 			return totTime;
1: 		}
1: 	}
1: 
1: 	// ResultSet interface
1: 
1: 	/**
1: 	 * If the result set has been opened,
1: 	 * close the open scan.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	public void	close() throws StandardException
1: 	{
1: 		/* Nothing to do if open was short circuited by false constant expression */
1: 		if (shortCircuitOpen)
1: 		{
0: 			isOpen = false;
1: 			shortCircuitOpen = false;
1: 			return;
1: 		}
1: 
1: 		beginTime = getCurrentTimeMillis();
1: 	    if ( isOpen ) {
1: 
1: 			// we don't want to keep around a pointer to the
1: 			// row ... so it can be thrown away.
1: 			// REVISIT: does this need to be in a finally
1: 			// block, to ensure that it is executed?
1: 	    	clearCurrentRow();
0: 			if (closeCleanup != null) 
1: 			{
0: 				closeCleanup.invoke(activation); // let activation tidy up
1: 			}
0: 			currentRow = null;
1: 	        source.close();
1: 
1: 			super.close();
1: 	    }
1: 		else
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.DEBUG("CloseRepeatInfo","Close of ProjectRestrictResultSet repeated");
1: 
1: 		closeTime += getElapsedMillis(beginTime);
1: 	}
1: 
1: 	public void	finish() throws StandardException
1: 	{
1: 		source.finish();
1: 		finishAndRTS();
1: 	}
1: 
1: 	//
1: 	// CursorResultSet interface
1: 	//
1: 
1: 	/**
1: 	 * Gets information from its source. We might want
1: 	 * to have this take a CursorResultSet in its constructor some day,
1: 	 * instead of doing a cast here?
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the row location of the current cursor row.
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	public RowLocation getRowLocation() throws StandardException {
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source is not CursorResultSet");
1: 		return ( (CursorResultSet)source ).getRowLocation();
1: 	}
1: 
1: 	/**
1: 	 * Gets last row returned.
1: 	 *
1: 	 * @see CursorResultSet
1: 	 *
1: 	 * @return the last row returned.
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
1: 	 * once there is such a method.  (currentRow is redundant)
1: 	 */
1: 	public ExecRow getCurrentRow() throws StandardException {
1: 	    ExecRow candidateRow = null;
1: 	    ExecRow result = null;
1: 	    boolean restrict = false;
1: 	    DataValueDescriptor restrictBoolean;
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(isOpen, "PRRS is expected to be open");
1: 
1: 		/* Nothing to do if we're not currently on a row */
1: 		if (currentRow == null)
1: 		{
1: 			return null;
1: 		}
1: 
1: 		/* Call the child result set to get it's current row.
1: 		 * If no row exists, then return null, else requalify it
1: 		 * before returning.
1: 		 */
1: 		candidateRow = ((CursorResultSet) source).getCurrentRow();
1: 		if (candidateRow != null) {
1: 			setCurrentRow(candidateRow);
1: 				/* If restriction is null, then all rows qualify */
1:             restrictBoolean = (DataValueDescriptor) 
1: 					((restriction == null) ? null : restriction.invoke(activation));
1: 
1:             // if the result is null, we make it false --
1: 			// so the row won't be returned.
1:             restrict = (restrictBoolean == null) ||
1: 						((! restrictBoolean.isNull()) &&
1: 							restrictBoolean.getBoolean());
1: 		}
1: 
1: 	    if (candidateRow != null && restrict) 
1: 		{
1: 			result = doProjection(candidateRow);
1:         }
1: 
1: 		currentRow = result;
1: 		/* Clear the current row, if null */
1: 		if (result == null) {
1: 			clearCurrentRow();
1: 		}
1: 
1: 		return currentRow;
1: 	}
1: 
1: 	/**
1: 	 * Do the projection against the source row.  Use reflection
1: 	 * where necessary, otherwise get the source column into our
1: 	 * result row.
1: 	 *
1: 	 * @param sourceRow		The source row.
1: 	 *
1: 	 * @return		The result of the projection
1: 	 *
1: 	 * @exception StandardException thrown on failure.
1: 	 */
1: 	private ExecRow doProjection(ExecRow sourceRow)
1: 		throws StandardException
1: 	{
1: 		// No need to use reflection if reusing the result
1: 		if (reuseResult && projRow != null)
1: 		{
1: 			return projRow;
1: 		}
1: 
1: 		ExecRow result;
1: 
1: 		// Use reflection to do as much of projection as required
1: 		if (projection != null)
1: 		{
1: 	        result = (ExecRow) projection.invoke(activation);
1: 		}
1: 		else
1: 		{
1: 			result = mappedResultRow;
1: 		}
1: 
1: 		// Copy any mapped columns from the source
1: 		for (int index = 0; index < projectMapping.length; index++)
1: 		{
1: 			if (projectMapping[index] != -1)
1: 			{
0: 				result.setColumn(index + 1, sourceRow.getColumn(projectMapping[index]));
1: 			}
1: 		}
1: 
1: 		/* We need to reSet the current row after doing the projection */
1: 		setCurrentRow(result);
1: 
1: 		/* Remember the result if reusing it */
1: 		if (reuseResult)
1: 		{
1: 			projRow = result;
1: 		}
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	 * Is this ResultSet or it's source result set for update
1: 	 * 
1: 	 * @return Whether or not the result set is for update.
1: 	 */
1: 	public boolean isForUpdate()
1: 	{
1: 		return source.isForUpdate();
1: 	}
1: 
1: }
1: 
1: 
1: 
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:b7c1f3b
/////////////////////////////////////////////////////////////////////////
1: 		final ExecRow result;
1: 			result = sourceRow.getNewNullRow();
1: 			result.setRowArray(sourceRow.getRowArray());
0: 
0: 	/**
1: 	 * Get projection mapping array. The array consist of indexes which
1: 	 * maps the column in a row array to another position in the row array.
1: 	 * If the value is projected out of the row, the value is negative.
1: 	 * @return projection mapping array.
0: 	 */
1: 	public int[] getBaseProjectMapping() 
0: 	{
1: 		final int[] result;
1: 		if (source instanceof ProjectRestrictResultSet) {
1: 			result = new int[projectMapping.length];
1: 			final ProjectRestrictResultSet prs = (ProjectRestrictResultSet) source;
1: 			final int[] sourceMap = prs.getBaseProjectMapping();
1: 			for (int i=0; i<projectMapping.length; i++) {
1: 				if (projectMapping[i] > 0) {
1: 					result[i] = sourceMap[projectMapping[i] - 1];
1: 				}
1: 			}
1: 		} else {
1: 			result = projectMapping;
1: 		}
1: 		return result;
1: 	} 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: 
0: 
0: /**
0:  * Takes a table and a table filter and returns
0:  * the table's rows satisfying the filter as a result set.
0:  *
0:  * @author ames
0:  */
0: public class ProjectRestrictResultSet extends NoPutResultSetImpl
0: 	implements CursorResultSet 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/* Run time statistics variables */
0: 	public long restrictionTime;
0: 	public long projectionTime;
0: 
0:     // set in constructor and not altered during
0:     // life of object.
0:     public NoPutResultSet source;
0: 	public GeneratedMethod constantRestriction;
0:     public GeneratedMethod restriction;
0: 	public boolean doesProjection;
0:     private GeneratedMethod projection;
0: 	private int[]			projectMapping;
0:     private GeneratedMethod closeCleanup;
0: 	private boolean runTimeStatsOn;
0: 	private ExecRow			mappedResultRow;
0: 	public boolean reuseResult;
0: 
0: 	private boolean shortCircuitOpen;
0: 
0: 	private ExecRow projRow;
0: 
0:     //
0:     // class interface
0:     //
0:     public ProjectRestrictResultSet(NoPutResultSet s,
0: 					Activation a,
0: 					GeneratedMethod r,
0: 					GeneratedMethod p,
0: 					int resultSetNumber,
0: 					GeneratedMethod cr,
0: 					int mapRefItem,
0: 					boolean reuseResult,
0: 					boolean doesProjection,
0: 				    double optimizerEstimatedRowCount,
0: 					double optimizerEstimatedCost,
0: 					GeneratedMethod c) 
0: 		throws StandardException
0: 	{
0: 		super(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);
0:         source = s;
0: 		// source expected to be non-null, mystery stress test bug
0: 		// - sometimes get NullPointerException in openCore().
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(source != null,
0: 				"PRRS(), source expected to be non-null");
0: 		}
0:         restriction = r;
0:         projection = p;
0: 		constantRestriction = cr;
0: 		projectMapping = ((ReferencedColumnsDescriptorImpl) a.getPreparedStatement().getSavedObject(mapRefItem)).getReferencedColumnPositions();
0: 		this.reuseResult = reuseResult;
0: 		this.doesProjection = doesProjection;
0:         closeCleanup = c;
0: 
0: 		// Allocate a result row if all of the columns are mapped from the source
0: 		if (projection == null)
0: 		{
0: 			mappedResultRow = activation.getExecutionFactory().getValueRow(projectMapping.length);
0: 		}
0: 
0: 		/* Remember whether or not RunTimeStatistics is on */
0: 		runTimeStatsOn = getLanguageConnectionContext().getRunTimeStatisticsMode();
0: 		constructorTime += getElapsedMillis(beginTime);
0:     }
0: 
0: 	//
0: 	// NoPutResultSet interface 
0: 	//
0: 
0: 	/**
0:      * open a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public void	openCore() throws StandardException 
0: 	{
0: 		boolean constantEval = true;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		// source expected to be non-null, mystery stress test bug
0: 		// - sometimes get NullPointerException in openCore().
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(source != null,
0: 				"PRRS().openCore(), source expected to be non-null");
0: 		}
0: 
0: 		// REVISIT: through the direct DB API, this needs to be an
0: 		// error, not an ASSERT; users can open twice. Only through JDBC
0: 		// is access to open controlled and ensured valid.
0: 		if (SanityManager.DEBUG)
0: 		    SanityManager.ASSERT( ! isOpen, "ProjectRestrictResultSet already open");
0: 
0: 		if (constantRestriction != null)
0: 		{
0: 		    DataValueDescriptor restrictBoolean;
0:             restrictBoolean = (DataValueDescriptor) 
0: 					constantRestriction.invoke(activation);
0: 
0: 	            // if the result is null, we make it false --
0: 				// so the row won't be returned.
0:             constantEval = (restrictBoolean == null) ||
0: 						((! restrictBoolean.isNull()) &&
0: 							restrictBoolean.getBoolean());
0: 		}
0: 
0: 		if (constantEval)
0: 		{
0: 	        source.openCore();
0: 		}
0: 		else
0: 		{
0: 			shortCircuitOpen = true;
0: 		}
0: 	    isOpen = true;
0: 
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0:      * reopen a scan on the table. scan parameters are evaluated
0:      * at each open, so there is probably some way of altering
0:      * their values...
0: 	 *
0: 	 * @exception StandardException thrown if cursor finished.
0:      */
0: 	public void	reopenCore() throws StandardException 
0: 	{
0: 		boolean constantEval = true;
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 
0: 		if (SanityManager.DEBUG)
0: 		    SanityManager.ASSERT(isOpen, "ProjectRestrictResultSet not open, cannot reopen");
0: 
0: 		if (constantRestriction != null)
0: 		{
0: 		    DataValueDescriptor restrictBoolean;
0:             restrictBoolean = (DataValueDescriptor) 
0: 					constantRestriction.invoke(activation);
0: 
0: 	            // if the result is null, we make it false --
0: 				// so the row won't be returned.
0:             constantEval = (restrictBoolean == null) ||
0: 						((! restrictBoolean.isNull()) &&
0: 							restrictBoolean.getBoolean());
0: 		}
0: 
0: 		if (constantEval)
0: 		{
0: 	        source.reopenCore();
0: 		}
0: 		else
0: 		{
0: 			shortCircuitOpen = true;
0: 		}
0: 	    isOpen = true;
0: 
0: 		numOpens++;
0: 
0: 		openTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	/**
0:      * Return the requested values computed
0:      * from the next row (if any) for which
0:      * the restriction evaluates to true.
0:      * <p>
0:      * restriction and projection parameters
0:      * are evaluated for each row.
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
0: 	 *
0: 	 * @return the next row in the result
0: 	 */
0: 	public ExecRow	getNextRowCore() throws StandardException {
0: 
0: 	    ExecRow candidateRow = null;
0: 	    ExecRow result = null;
0: 	    boolean restrict = false;
0: 	    DataValueDescriptor restrictBoolean;
0: 		long	beginRT = 0;
0: 
0: 		/* Return null if open was short circuited by false constant expression */
0: 		if (shortCircuitOpen)
0: 		{
0: 			return result;
0: 		}
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 	    do 
0: 		{
0: 			candidateRow = source.getNextRowCore();
0: 			if (candidateRow != null) 
0: 			{
0: 				beginRT = getCurrentTimeMillis();
0: 				/* If restriction is null, then all rows qualify */
0: 				if (restriction == null)
0: 				{
0: 					restrict = true;
0: 				}
0: 				else
0: 				{
0: 					setCurrentRow(candidateRow);
0: 		            restrictBoolean = (DataValueDescriptor) 
0: 											restriction.invoke(activation);
0: 					restrictionTime += getElapsedMillis(beginRT);
0: 
0: 		            // if the result is null, we make it false --
0: 					// so the row won't be returned.
0: 				    restrict = ((! restrictBoolean.isNull()) &&
0: 								 restrictBoolean.getBoolean());
0: 					if (! restrict)
0: 					{
0: 						rowsFiltered++;
0: 					}
0: 				}
0: 
0: 				/* Update the run time statistics */
0: 				rowsSeen++;
0: 			}
0: 	    } while ( (candidateRow != null) &&
0: 	              (! restrict ) );
0: 
0: 	    if (candidateRow != null) 
0: 		{
0: 			beginRT = getCurrentTimeMillis();
0: 
0: 			result = doProjection(candidateRow);
0: 
0: 			projectionTime += getElapsedMillis(beginRT);
0:         }
0: 		/* Clear the current row, if null */
0: 		else
0: 		{
0: 			clearCurrentRow();
0: 		}
0: 
0: 
0: 		currentRow = result;
0: 
0: 		if (runTimeStatsOn)
0: 		{
0: 			if (! isTopResultSet)
0: 			{
0: 				/* This is simply for RunTimeStats */
0: 				/* We first need to get the subquery tracking array via the StatementContext */
0: 				StatementContext sc = activation.getLanguageConnectionContext().getStatementContext();
0: 				subqueryTrackingArray = sc.getSubqueryTrackingArray();
0: 			}
0: 			nextTime += getElapsedMillis(beginTime);
0: 		}
0:     	return result;
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		long totTime = constructorTime + openTime + nextTime + closeTime;
0: 
0: 		if (type == CURRENT_RESULTSET_ONLY)
0: 		{
0: 			return	totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
0: 		}
0: 		else
0: 		{
0: 			return totTime;
0: 		}
0: 	}
0: 
0: 	// ResultSet interface
0: 
0: 	/**
0: 	 * If the result set has been opened,
0: 	 * close the open scan.
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{
0: 		/* Nothing to do if open was short circuited by false constant expression */
0: 		if (shortCircuitOpen)
0: 		{
0: 			isOpen = false;
0: 			shortCircuitOpen = false;
0: 			return;
0: 		}
0: 
0: 		beginTime = getCurrentTimeMillis();
0: 	    if ( isOpen ) {
0: 
0: 			// we don't want to keep around a pointer to the
0: 			// row ... so it can be thrown away.
0: 			// REVISIT: does this need to be in a finally
0: 			// block, to ensure that it is executed?
0: 	    	clearCurrentRow();
0: 			if (closeCleanup != null) 
0: 			{
0: 				closeCleanup.invoke(activation); // let activation tidy up
0: 			}
0: 			currentRow = null;
0: 	        source.close();
0: 
0: 			super.close();
0: 	    }
0: 		else
0: 			if (SanityManager.DEBUG)
0: 				SanityManager.DEBUG("CloseRepeatInfo","Close of ProjectRestrictResultSet repeated");
0: 
0: 		closeTime += getElapsedMillis(beginTime);
0: 	}
0: 
0: 	public void	finish() throws StandardException
0: 	{
0: 		source.finish();
0: 		finishAndRTS();
0: 	}
0: 
0: 	//
0: 	// CursorResultSet interface
0: 	//
0: 
0: 	/**
0: 	 * Gets information from its source. We might want
0: 	 * to have this take a CursorResultSet in its constructor some day,
0: 	 * instead of doing a cast here?
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the row location of the current cursor row.
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	public RowLocation getRowLocation() throws StandardException {
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(source instanceof CursorResultSet, "source is not CursorResultSet");
0: 		return ( (CursorResultSet)source ).getRowLocation();
0: 	}
0: 
0: 	/**
0: 	 * Gets last row returned.
0: 	 *
0: 	 * @see CursorResultSet
0: 	 *
0: 	 * @return the last row returned.
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	/* RESOLVE - this should return activation.getCurrentRow(resultSetNumber),
0: 	 * once there is such a method.  (currentRow is redundant)
0: 	 */
0: 	public ExecRow getCurrentRow() throws StandardException {
0: 	    ExecRow candidateRow = null;
0: 	    ExecRow result = null;
0: 	    boolean restrict = false;
0: 	    DataValueDescriptor restrictBoolean;
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(isOpen, "PRRS is expected to be open");
0: 
0: 		/* Nothing to do if we're not currently on a row */
0: 		if (currentRow == null)
0: 		{
0: 			return null;
0: 		}
0: 
0: 		/* Call the child result set to get it's current row.
0: 		 * If no row exists, then return null, else requalify it
0: 		 * before returning.
0: 		 */
0: 		candidateRow = ((CursorResultSet) source).getCurrentRow();
0: 		if (candidateRow != null) {
0: 			setCurrentRow(candidateRow);
0: 				/* If restriction is null, then all rows qualify */
0:             restrictBoolean = (DataValueDescriptor) 
0: 					((restriction == null) ? null : restriction.invoke(activation));
0: 
0:             // if the result is null, we make it false --
0: 			// so the row won't be returned.
0:             restrict = (restrictBoolean == null) ||
0: 						((! restrictBoolean.isNull()) &&
0: 							restrictBoolean.getBoolean());
0: 		}
0: 
0: 	    if (candidateRow != null && restrict) 
0: 		{
0: 			result = doProjection(candidateRow);
0:         }
0: 
0: 		currentRow = result;
0: 		/* Clear the current row, if null */
0: 		if (result == null) {
0: 			clearCurrentRow();
0: 		}
0: 
0: 		return currentRow;
0: 	}
0: 
0: 	/**
0: 	 * Do the projection against the source row.  Use reflection
0: 	 * where necessary, otherwise get the source column into our
0: 	 * result row.
0: 	 *
0: 	 * @param sourceRow		The source row.
0: 	 *
0: 	 * @return		The result of the projection
0: 	 *
0: 	 * @exception StandardException thrown on failure.
0: 	 */
0: 	private ExecRow doProjection(ExecRow sourceRow)
0: 		throws StandardException
0: 	{
0: 		// No need to use reflection if reusing the result
0: 		if (reuseResult && projRow != null)
0: 		{
0: 			return projRow;
0: 		}
0: 
0: 		ExecRow result;
0: 
0: 		// Use reflection to do as much of projection as required
0: 		if (projection != null)
0: 		{
0: 	        result = (ExecRow) projection.invoke(activation);
0: 		}
0: 		else
0: 		{
0: 			result = mappedResultRow;
0: 		}
0: 
0: 		// Copy any mapped columns from the source
0: 		for (int index = 0; index < projectMapping.length; index++)
0: 		{
0: 			if (projectMapping[index] != -1)
0: 			{
0: 				result.setColumn(index + 1, sourceRow.getColumn(projectMapping[index]));
0: 			}
0: 		}
0: 
0: 		/* We need to reSet the current row after doing the projection */
0: 		setCurrentRow(result);
0: 
0: 		/* Remember the result if reusing it */
0: 		if (reuseResult)
0: 		{
0: 			projRow = result;
0: 		}
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * Is this ResultSet or it's source result set for update
0: 	 * 
0: 	 * @return Whether or not the result set is for update.
0: 	 */
0: 	public boolean isForUpdate()
0: 	{
0: 		return source.isForUpdate();
0: 	}
0: 
0: }
0: 
0: 
0: 
0: 
============================================================================