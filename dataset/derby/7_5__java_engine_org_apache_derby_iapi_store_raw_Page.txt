1:eac0369: /*
1:888d12e: /usr/bin/mksh: p4: not found
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.raw.Page
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
12:eac0369: 
7:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.raw;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: 
10:eac0369: /**
1:eac0369: 	A Page contains an ordered set of records which are the stored form of rows.
1:eac0369: 	A record is a stream of bytes created from a row array. The record
1:eac0369: 	contains one or more fields, fields have a one to one correlation with
1:eac0369: 	the DataValueDescriptor's contained within a row array.
1:ebb21c4:     <P>
1:eac0369: 	A Page represents <B>exclusive</B> access to a data page within a container.
1:eac0369: 	Exclusive access is released by calling the unlatch() method, once that 
1:eac0369:     occurs the caller must no longer use the Page reference.
3:eac0369: 	<P>
1:eac0369: 	Several of the methods in Page take a RecordHandle as an argument. 
1:eac0369:     RecordHandles are obtained from a Page, while holding exclusive access of 
1:eac0369:     Page or a from a previous exclusive access of a Page representing the same 
1:eac0369:     data page.
1:eac0369: 	All RecordHandle's used as arguments to methods (with the exception of 
1:eac0369:     recordExists()) must be valid for the current state of the page. If they 
1:eac0369:     are not valid then the method will throw an exception. A caller can ensure 
1:eac0369:     that a record handle is valid by:
1:eac0369: 	<UL>
1:eac0369: 	<LI> Obtaining the handle during this exclusive access of this page
1:eac0369: 	<LI> Checking the record still exists with the method recordExists()
1:ebb21c4: 	<LI> Not using a handle after a deleteAtSlot().
1:eac0369: 	</UL>
1:eac0369: 	<P>
1:eac0369: 	Several of the methods in Page take a slot number as an argument.  A slot 
1:eac0369:     always correspond to a record, which may be deleted or undeleted.
1:eac0369: 
1:eac0369:     <BR>
1:eac0369: 	MT - Latched - In general every method requires the page to be latched.
1:eac0369: 
1:eac0369:   <P>
1:eac0369:   <B>Latching</B>
1:eac0369:   <P>
1:eac0369:   All page methods which are not valid for a latched page throw an
1:eac0369:   exception if the page is not latched.  [@exception clauses on all
1:eac0369:   the methods should be updated to reflect this].
1:eac0369: 
1:eac0369:   <P>
1:eac0369:   <B>Aux Objects</B>
1:eac0369:   <BR>
1:eac0369:   The page cache will manage a client object along with the page as long
1:eac0369:   as it remains in cache.  This object is called the "aux object".  The 
1:eac0369:   aux object is associated with the page with setAuxObject(), and can be
1:eac0369:   retreived later with getAuxObject().  The aux object will remain valid
1:eac0369:   as long as the page is latched, but callers cannot assume that an aux
1:eac0369:   object will ever stick around once the page is unlatched.  However, the
1:eac0369:   page manager promises to call pageBeingEvicted() once before clearing
1:eac0369:   the aux reference from the page.
1:eac0369: 
1:eac0369: 	@see Object
1:eac0369: 	@see ContainerHandle
1:eac0369: 	@see RecordHandle
1:eac0369: 	@see AuxObject
1:eac0369: */
1:eac0369: 
1:eac0369: public interface Page  
1:eac0369: {
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constants of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The slot number of the first slot.  This is guaranteed to be zero.
4:eac0369:      **/
1:eac0369: 	public static final int FIRST_SLOT_NUMBER   = 0;
1:eac0369: 	
1:eac0369:     /**
1:eac0369:      * A slot number guaranteed to be invalid.
1:eac0369:      **/
1:eac0369: 	public static final int INVALID_SLOT_NUMBER = -1;
1:eac0369: 	
1:eac0369:     /**
1:eac0369:      * Return the page number of this page. 
6:eac0369:      * <p>
1:eac0369:      * Page numbers are unique within a container and start at 
1:eac0369:      * ContainerHandle.FIRST_PAGE_NUMBER and increment by 1 regardless of the 
1:eac0369:      * page size.
1:eac0369:      * <p>
1:47efb9b:      *
1:eac0369:      * <BR> MT - Latched
18:eac0369:      *
1:eac0369:      * @see ContainerHandle
1:eac0369:      *
1:eac0369: 	 * @return The page number of this page.
1:eac0369:      **/
1:eac0369: 	public long getPageNumber();
1:eac0369: 
1:888d12e:     /**
1:888d12e:      * Return the page key of this page. 
1:888d12e:      * <p>
1:888d12e:      *
1:888d12e:      * <BR> MT - Latched
1:888d12e:      *
1:888d12e:      * @see ContainerHandle
1:888d12e:      *
1:888d12e: 	 * @return The page key of this page.
1:888d12e:      **/
1:888d12e: 	public PageKey getPageKey();
1:888d12e: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of This class: record handle interface.
1:eac0369:      *     the following interfaces to page use the record Id or record handle
1:eac0369:      *     (rather than the slot interface).
1:eac0369:      **************************************************************************
1:47efb9b:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return an invalid record handle.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return an invalid record handle.
1:eac0369:      **/
1:eac0369: 	public RecordHandle getInvalidRecordHandle();
1:47efb9b: 
1:47efb9b:     /**
1:eac0369:      * Return a record handle for the given constant record id.
1:eac0369:      * <p>
1:eac0369:      * Return a record handle that doesn't represent a record but rather has 
1:eac0369:      * a special meaning.  Used for special cases like creating a key 
1:eac0369:      * specific to the page, but not specific to a row on the page.
1:eac0369:      * <p>
1:eac0369:      * See RecordHandle interface for a list of "special record handles."
1:eac0369:      *
1:eac0369:      * @see RecordHandle
1:eac0369:      *
1:eac0369: 	 * @return The created record handle.
1:eac0369:      *
1:eac0369:      * @param recordHandleConstant the special recordId
1:eac0369:      *
1:eac0369: 	 * @exception StandardException if input is not a special record identifier.
1:eac0369:      **/
1:eac0369: 	public RecordHandle makeRecordHandle(int recordHandleConstant) 
1:eac0369: 		 throws	StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get a record handle from a previously stored record id.
1:eac0369:      * <p>
1:eac0369:      * Get a record handle from a previously stored record identifier that was
1:eac0369:      * obtained from a RecordHandle.
1:eac0369:      * <p>
1:eac0369:      * <BR> MT - Latched
1:eac0369:      *
1:eac0369: 	 * @return A valid record handle or null if the record no longer exists.
1:eac0369:      *
1:eac0369:      * @param recordId previously stored recordId.
1:eac0369:      *
1:eac0369:      * @see RecordHandle#getId
1:eac0369:      **/
1:eac0369: 	RecordHandle getRecordHandle(int recordId);
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * does the record still exist on the page?
1:eac0369:      * <p>
1:eac0369:      * If "ignoreDelete" is true and the record handle represents a record on 
1:eac0369:      * the page (either marked deleted or not) return true.  If "ignoreDelete" 
1:eac0369:      * is false return true if the record handle represents a record on the 
1:eac0369:      * page and the record is not marked as deleted.  Return false otherwise.
1:eac0369:      *
1:eac0369:      * <BR> MT - Latched
1:eac0369:      *
1:eac0369: 	 * @return boolean indicating if the record still exists on the page.
1:eac0369:      *
1:eac0369:      * @param handle        handle of the record to look for.
1:eac0369:      * @param ignoreDelete  if true, then routine will return true even if the
1:eac0369:      *                      row is marked deleted.
1:eac0369:      *
3:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	boolean recordExists(RecordHandle handle, boolean ignoreDelete) 
4:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is it likely that an insert will fit on this page?
1:eac0369:      * <p>
1:eac0369:      * Return true if there is a good chance an insert will fit on this page, 
1:eac0369:      * false otherwise.  If this returns true then an insert may still fail by 
1:eac0369:      * throwing an exception or by returning null, see insertAtSlot for details.
1:eac0369:      * It is very probable that this call is much faster than the version that 
1:eac0369:      * takes a row. In situations where it is expected that the 
1:eac0369:      * majority of times a row will fit on a page this method should be used 
1:eac0369:      * and the null return handled from insert/insertAtSlot.
1:eac0369:      *
5:eac0369:      * <BR>
1:eac0369:      * MT - latched
1:eac0369:      *
1:eac0369: 	 * @return true if it is likely an insert will fit on the page.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	boolean spaceForInsert() 
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * will insert of this row fit on this page?
1:eac0369:      * <p>
1:eac0369:      * Return true if this record is guaranteed to be inserted successfully 
1:eac0369:      * using insert() or insertAtSlot(). This guarantee is only valid if the 
1:eac0369:      * following conditions are fulfilled before an insert is called with t
1:eac0369:      * his row.
1:eac0369:      * <UL>
1:eac0369:      * <LI> The page is not unlatched
1:eac0369:      * <LI> The page is not modified in any way, ie. no updates or other inserts
1:eac0369:      * <LI> The row is not modified in such a way that would change its 
1:eac0369:      *      storage size
1:eac0369:      * </UL>
1:eac0369:      *
1:eac0369:      * <BR>
1:eac0369:      * MT - latched
1:eac0369:      *
1:eac0369: 	 * @return true if insert of this row will fit on this page.
1:eac0369:      *
1:eac0369:      * @param row                   The row to check for insert.
1:eac0369:      * @param validColumns          bit map to interpret valid columns in row.
1:eac0369:      * @param overflowThreshold     The percentage of the page to use for the
1:eac0369:      *                              insert.  100 means use 100% of the page,
1:eac0369:      *                              50 means use 50% of page (ie. make sure
1:eac0369:      *                              2 rows fit per page).
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	boolean spaceForInsert(
1:bbc927c:     Object[]            row, 
1:bbc927c:     FormatableBitSet    validColumns, 
1:bbc927c:     int                 overflowThreshold) 
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Insert a record anywhere on the page.
3:eac0369:      * <P>
1:eac0369:      *
3:eac0369:      * <B>Locking Policy</B>
1:eac0369:      * <BR>
2:eac0369:      * Calls the lockRecordForWrite() method of the LockingPolicy object
1:eac0369:      * passed to the openContainer() call before the record is inserted.
1:eac0369:      * <BR>
1:eac0369:      * MT - latched
1:eac0369:      *
2:eac0369:      * @param row           The row version of the data
1:eac0369:      * @param validColumns  a bit map of which columns in the row is valid.  
2:eac0369:      *                      ValidColumns will not be changed by RawStore.
1:eac0369:      * @param insertFlag    see values for insertFlag below.
1:eac0369:      *
1:eac0369:      * @return A RecordHandle representing the new record.
1:eac0369:      *
1:f668d94:      * @exception StandardException if the container was not opened in update
1:f668d94:      * mode, or if the row cannot fit on the page, or if the row is null
1:eac0369:      **/
1:eac0369: 	RecordHandle insert(
1:bbc927c:     Object[]            row, 
1:bbc927c:     FormatableBitSet    validColumns,
1:bbc927c:     byte                insertFlag, 
1:bbc927c:     int                 overflowThreshold)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:bbc927c:      * Move record to a page toward the beginning of the file.
1:bbc927c:      * <p>
1:bbc927c:      * As part of compressing the table records need to be moved from the
1:bbc927c:      * end of the file toward the beginning of the file.  Only the 
1:bbc927c:      * contiguous set of free pages at the very end of the file can
1:bbc927c:      * be given back to the OS.  This call is used to purge the row from
1:bbc927c:      * the current page, insert it into a previous page, and return the
1:bbc927c:      * new row location 
1:bbc927c:      * Mark the record identified by position as deleted. The record may be 
1:bbc927c:      * undeleted sometime later using undelete() by any transaction that sees 
1:bbc927c:      * the record.
1:bbc927c:      * <p>
1:bbc927c:      * The interface is optimized to work on a number of rows at a time, 
1:bbc927c:      * optimally processing all rows on the page at once.  The call will 
1:bbc927c:      * process either all rows on the page, or the number of slots in the
1:bbc927c:      * input arrays - whichever is smaller.
1:bbc927c:      * <B>Locking Policy</B>
1:bbc927c:      * <P>
1:bbc927c:      * MUST be called with table locked, not locks are requested.  Because
1:bbc927c:      * it is called with table locks the call will go ahead and purge any
1:bbc927c:      * row which is marked deleted.  It will also use purge rather than
1:bbc927c:      * delete to remove the old row after it moves it to a new page.  This
1:bbc927c:      * is ok since the table lock insures that no other transaction will
1:bbc927c:      * use space on the table before this transaction commits.
1:bbc927c:      *
1:bbc927c:      * <BR>
1:bbc927c:      * A page latch on the new page will be requested and released.
1:bbc927c:      *
1:12c6ed9:      * @param slot           Slot of row to move.
1:12c6ed9:      * @param row            A template to read the current row into as part
1:12c6ed9:      *                       of moving it.
1:bbc927c:      * @param old_handle     An array to be filled in by the call with the 
1:bbc927c:      *                       old handles of all rows moved.
1:bbc927c:      * @param new_handle     An array to be filled in by the call with the 
1:bbc927c:      *                       new handles of all rows moved.
1:bbc927c:      *
1:bbc927c:      * @return the number of rows processed.
1:bbc927c:      *
1:3fd26f3:      * @exception StandardException	Standard Derby error policy
1:bbc927c:      *
1:bbc927c:      * @see LockingPolicy
1:bbc927c:      **/
1:bbc927c: 	public int moveRecordForCompressAtSlot(
1:bbc927c:     int             slot,
1:bbc927c:     Object[]        row,
1:bbc927c:     RecordHandle[]  old_handle,
1:bbc927c:     RecordHandle[]  new_handle)
1:bbc927c: 		throws StandardException;
1:bbc927c: 
1:bbc927c:     /**
1:eac0369:      * Fetch the number of fields in a record. 
1:eac0369:      * <p>
1:eac0369:      * <B>Locking Policy</B>
1:eac0369:      * <P>
1:eac0369:      * No locks are obtained.
1:eac0369:      *
1:eac0369:      * <BR>
1:eac0369:      * MT - latched
1:eac0369:      *
1:12c6ed9:      * @param handle    record handle to deleted or non-deleted record
1:eac0369:      *
1:eac0369:      * @return the number of fields in the record
1:eac0369:      *
1:3fd26f3:      * @exception StandardException	Standard Derby error policy, a 
1:eac0369:      *                              statement level exception is thrown if the 
1:eac0369:      *                              record handle does not match a record on 
1:eac0369:      *                              the page.
1:eac0369:      **/
1:eac0369: 	public int fetchNumFields(RecordHandle handle)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of This class: slot interface.
1:eac0369:      *     the following interfaces to page use the slot number 
1:eac0369:      *     (rather than the record handle interface).
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the slot number.
1:eac0369:      * <p>
1:eac0369:      * Get the slot number of a record on a latched page using its record 
1:eac0369:      * handle.
1:eac0369:      *
1:eac0369:      * <P><B>Note</B>
1:eac0369:      * The slot number is only good for as long as the page is latched.
1:eac0369:      *
1:eac0369:      * <BR>
1:eac0369:      * MT - latched
1:eac0369:      *
1:eac0369:      * @param handle the record handle
1:eac0369:      *
1:eac0369:      * @return the slot number
1:eac0369:      *
1:3fd26f3:      * @exception StandardException	Standard Derby error policy
1:eac0369:      **/
1:eac0369:     int getSlotNumber(RecordHandle handle) 
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the record handle of row at slot.
1:eac0369:      * <p>
1:eac0369:      * Get the record handle of a record on a latched page using its slot 
1:eac0369:      * number.
1:eac0369:      *
1:eac0369:      * <BR>
1:eac0369:      * MT - latched
1:eac0369:      *
1:eac0369:      * @param slot the slot number
1:eac0369:      *
1:eac0369:      * @return the record handle.
1:eac0369:      *
1:3fd26f3:      * @exception StandardException	Standard Derby error policy
1:eac0369:      **/
1:eac0369: 	RecordHandle getRecordHandleAtSlot(int slot) 
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Find slot for record with an id greater than the passed in identifier.
1:eac0369:      * <p>
1:eac0369:      * Find the slot for the first record on the page with an id greater than 
1:eac0369:      * the passed in identifier.
1:eac0369:      *
1:eac0369:      * <BR>
1:eac0369:      * Returns the slot of the first record on the page with an id greater than
1:eac0369:      * the one passed in.  Usefulness of this functionality depends on the 
1:eac0369:      * client's use of the raw store interfaces.  If all "new" records are 
1:eac0369:      * always inserted at the end of the page, and the raw store continues to
1:eac0369:      * guarantee that all record id's will be allocated in increasing order on 
1:eac0369:      * a given page (assuming a PAGE_REUSABLE_RECORD_ID container), then a page
1:eac0369:      * is always sorted in record id order.  For instance current heap tables 
1:eac0369:      * function this way.  If the client ever inserts at a particular slot 
1:eac0369:      * number, rather than at the "end" then the record id's will not be sorted.
1:eac0369:      * <BR>
1:eac0369:      * In the case where all record id's are always sorted on a page, then this
1:eac0369:      * routine can be used by scan's which "lose" their position because the 
1:eac0369:      * row they have as a position was purged.  They can reposition their scan 
1:eac0369:      * at the "next" row after the row that is now missing from the table.
1:eac0369:      * <BR>
1:eac0369:      * This method returns the record regardless of its deleted status.
1:eac0369:      * <BR>
1:eac0369:      * MT - latched
1:eac0369:      * 
1:eac0369:      * @param handle record handle to find the next higher id.
1:eac0369:      *
1:eac0369:      * @return  record id of the first record on the page with a record id 
1:eac0369:      *          higher than the one passed in.  If no such record exists, 
1:eac0369:      *          -1 is returned.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	int getNextSlotNumber(RecordHandle handle) 
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Insert a record at the specified slot. 
1:eac0369:      * <p>
1:eac0369:      * All records that occupy FIRST_SLOT_NUMBER to (slot - 1) are not moved. 
1:eac0369:      * <BR>
1:eac0369:      * All records that occupy slot to (recordCount() - 1) are moved up one 
1:eac0369:      * slot. 
1:eac0369:      * <BR>
1:eac0369:      * The new record is inserted at the specified slot. <BR>
1:eac0369:      * If slot == FIRST_SLOT_NUMBER, then the new record will be inserted at 
1:eac0369:      * the first slot. <BR>
1:eac0369:      * If slot == recordCount(), then the record is inserted in a new slot, no
1:eac0369:      * records are moved. <BR>
1:eac0369:      *
1:dbed020:      * If slot is &gt; recordCount() or if slot &lt; FIRST_SLOT_NUMBER, an exception
1:eac0369:      * will be thrown.
1:eac0369:      *
1:eac0369:      * <P><B>Space Policy</B><BR>
1:eac0369:      * If the row will not fit on a page then:
1:eac0369:      * <UL>
1:eac0369:      * <LI> an exception is thrown if the page has no other rows, this is an 
1:eac0369:      *      indication that the row could never fit on a page in this container.
1:eac0369:      * <LI> null is returned if there are other rows on the page, this is an 
1:eac0369:      *      indication that the row can potentially be inserted successfully 
1:eac0369:      *      onto an empty page.
1:eac0369:      * </UL>
1:eac0369:      *
1:eac0369:      * <P>
1:eac0369:      * <B>Locking Policy</B>
1:eac0369:      * <BR>
1:eac0369:      * Calls the lockRecordForWrite() method of the LockingPolicy object passed
1:eac0369:      * to the openContainer() call before the record is inserted.
1:eac0369:      * <BR>
1:eac0369:      * MT - latched
1:eac0369:      *
1:eac0369:      * @param slot          The specified slot
1:eac0369:      * @param row           The row version of the data
1:eac0369:      * @param undo          if logical undo may be necessary, a function pointer
1:eac0369:      *                      to the access code where the logical undo logic 
1:eac0369:      *                      resides. Null if logical undo is not necessary.
1:eac0369:      * @param validColumns  a bit map of which columns in the row is valid.  
1:eac0369:      *                      ValidColumns will not be changed by RawStore.
1:eac0369:      * @param insertFlag    if INSERT_UNDO_WITH_PURGE set, then the undo of this
1:eac0369:      *                      insert will purge the row rather than mark it as 
1:eac0369:      *                      deleted, which is the default bahavior for 
1:eac0369:      *                      insertAtSlot and insert.
1:eac0369:      *
1:eac0369:      * @return A RecordHandle representing the new record, or null if the row 
1:eac0369:      *         will not fit on a non-empty page.
1:eac0369:      *
1:f668d94:      * @exception StandardException if the container was not opened in update
1:f668d94:      * mode, or if the row cannot fit on the page
1:eac0369:      *
1:eac0369:      * @see LogicalUndo
1:eac0369:      * @see LogicalUndoable
1:eac0369:      **/
1:eac0369: 	RecordHandle insertAtSlot(
1:eac0369:     int                     slot, 
5:eac0369:     Object[]   row, 
4:eac0369:     FormatableBitSet                 validColumns, 
1:eac0369:     LogicalUndo             undo,
2:eac0369:     byte                    insertFlag, 
3:eac0369:     int                     overflowThreshold)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:12c6ed9:      * Values for insertFlag.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * INSERT_INITIAL			- flag initializer
1:eac0369:      *
1:eac0369:      * INSERT_DEFAULT			- default insert behavior, if the record does
1:eac0369:      *                            not fit on the page where the insert 
1:eac0369:      *                            operation is called, an error will be 
1:eac0369:      *                            returned, instead of overflowing the record.
1:eac0369:      *
1:eac0369:      * INSERT_UNDO_WITH_PURGE	- if this is set, then the undo of this insert 
1:eac0369:      *                            will purge the row rather than mark it as 
1:eac0369:      *                            deleted, which is the default behaviro for 
1:eac0369:      *                            insertAtSlot and insert.
1:eac0369:      *
1:eac0369:      * INSERT_CONDITIONAL		- if this flag is set, then, the overflow is 
1:eac0369:      *                            conditional.  The record will be overflowed 
1:eac0369:      *                            only if it exceeds the threshold specified 
1:eac0369:      *                            by the properties, or the parameter.
1:eac0369:      *
1:eac0369:      * INSERT_OVERFLOW			- if this flag is set, then the insert 
1:eac0369:      *                            operation will overflow the record if it does
1:eac0369:      *                            not fit on the page.  
1:eac0369:      *
1:eac0369:      * INSERT_FOR_SPLIT		    - a record is being updated that causes new 
1:eac0369:      *                            portions to be inserted *and* the last new 
1:eac0369:      *                            portion needs to point to an existing portion.
1:eac0369:      *
1:eac0369:      * Rules for the insert flags:
1:eac0369:      * 1. If INSERT_DEFAULT is set, INSERT_CONDITIONAL and INSERT_OVERFLOW 
1:eac0369:      *    will be ignored
1:eac0369:      * 2. INSERT_UNDO_WITH_PURGE can be set with any of the other 3 flags.
1:eac0369:      * 3. If INSERT_OVERFLOW is not set, INSERT_CONDITIONAL will be ignored.  
1:eac0369:      *    But, it is not necessary to set INSERT_CONDITIONAL when setting 
1:eac0369:      *    INSERT_OVERFLOW.
1:eac0369:      * 4. If INSERT_DEFAULT, INSERT_OVERFLOW both are not set, then, default 
1:eac0369:      *    insert action will be taken, i.e. no overflow will be allowed.
1:eac0369:      **/
1:0ce6b77: 	static final byte INSERT_INITIAL         = (byte) 0x00;	// init the flag
1:0ce6b77: 	static final byte INSERT_DEFAULT         = (byte) 0x01;	// default flag
1:eac0369: 	static final byte INSERT_UNDO_WITH_PURGE = (byte) 0x02;	// purge row on undo
1:0ce6b77: 	static final byte INSERT_CONDITIONAL     = (byte) 0x04;	// conditional 
1:eac0369:                                                             // insert
1:0ce6b77: 	static final byte INSERT_OVERFLOW        = (byte) 0x08;	// insert with 
1:eac0369:                                                             // possible overflow
1:0ce6b77: 	static final byte INSERT_FOR_SPLIT       = (byte) 0x10;	// rawstore only
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:12c6ed9:      * Fetch a record located in the passed in slot.
1:eac0369:      * <p>
1:eac0369:      * Fetch a record located in the passed in slot and fill-in the passed in 
1:eac0369:      * StorebleRow and the Object columns contained within. If row
1:eac0369:      * is null then the record is locked but is not fetched.
1:eac0369:      * <BR>
1:eac0369:      * This interface allows the caller to either return a deleted row or not. 
1:eac0369:      * If "ignoreDelete" is set to true, fetch the record regardless of whether 
1:eac0369:      * it is deleted or not (same as above fetchFromSlot).  However, if  
1:eac0369:      * "ignoreDelete" is set to false and the and the slot correspond to a 
1:eac0369:      * deleted row, null is returned.
1:eac0369:      * <BR>
1:eac0369:      * If a non-null Qualifier list is provided then the qualifier array will 
1:eac0369:      * be applied to the row and the row will only be returned if the row 
1:eac0369:      * qualifies, otherwise null will be returned.  Values in the columns of 
1:eac0369:      * row may or may not be altered while trying to apply the qualifiers, if 
1:eac0369:      * null is returned the state of the columns is undefined.  If a null 
1:eac0369:      * Qualifier list is provided then no qualification is applied.
1:eac0369:      * <BR>
1:eac0369:      * If a non-null record handle is passed in, it is assumed that the record 
1:eac0369:      * handle corresponds to the record in the slot.  If record handle is null,
1:eac0369:      * a record handle will be manufactured and returned if the record is not 
1:eac0369:      * deleted or if "ignoreDelete" is true.  This parameter is here for the 
1:eac0369:      * case where the caller have already manufactured the record handle for 
1:eac0369:      * locking or other purposes so it would make sense for the page to avoid 
1:eac0369:      * creating a new record handle object if possible.
1:eac0369:      *
1:eac0369:      *
1:eac0369:      * @param rh           the record handle of the row.  If non-null it must 
1:eac0369:      *                     refer to the same record as the slot.  
1:eac0369:      * @param slot         the slot number
1:eac0369:      * @param row          Row to be filled in with information from record.
1:eac0369:      * @param fetchDesc    A structure to efficiently carry a set of parameters
1:eac0369:      *                     needed to describe the fetch, these include:
1:eac0369:      *                     
1:eac0369:      *                     validColumns - A bit map of which columns in the 
1:eac0369:      *                     row to be fetched.  ValidColumns will not be 
1:eac0369:      *                     changed by RawStore.
1:eac0369:      *
1:eac0369:      *                     qualifier_list - 
1:eac0369:      *                     A list of Qualifiers to apply to the row to see if
1:eac0369:      *                     the row should be returned.
1:eac0369:      *
1:eac0369:      *                     An array of qualifiers which restrict whether or not
1:eac0369:      *                     the row should be returned by the fetch.  Rows for 
1:eac0369:      *                     which any one of the qualifiers returns false are 
1:eac0369:      *                     not returned by the fetch. If null, no qualification
1:eac0369:      *                     is done and the requested columns of the rows are 
1:eac0369:      *                     returned.  Qualifiers can only reference columns 
1:eac0369:      *                     which are included in the scanColumnList.  The 
1:eac0369:      *                     column id that a qualifier returns is the column id
1:eac0369:      *                     the table, not the column id in the partial row 
1:eac0369:      *                     being returned.  
1:eac0369:      *                     qualifier_scratch_space - 
1:eac0369:      *                     An array of int's that matches the size of the 
1:eac0369:      *                     row[] array.  Used to process qualifiers, if no
1:eac0369:      *                     qualifiers are input then array need not be 
1:eac0369:      *                     input.  Passed in rather than allocated so that
1:eac0369:      *                     space can be allocated a single time in a scan.
1:eac0369:      *                     If not passed in then raw store will allocate and
1:eac0369:      *                     deallocate per call.
1:eac0369:      *
1:eac0369:      * @param ignoreDelete if true, return row regardless of whether it is 
1:eac0369:      *                     deleted or not.  If false, only return non-deleted 
1:eac0369:      *                     row.
1:eac0369:      *
1:eac0369:      * @return A handle to the record.
1:eac0369:      *
1:3fd26f3:      * @exception StandardException	Standard Derby error policy
1:eac0369:      *
3:eac0369:      * @see LockingPolicy
1:eac0369:      **/
1:eac0369: 	public RecordHandle fetchFromSlot(
1:eac0369:     RecordHandle            rh, 
1:eac0369:     int                     slot, 
1:eac0369:     Object[]                row,
1:eac0369:     FetchDescriptor         fetchDesc,
1:eac0369:     boolean                 ignoreDelete)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Fetch a single field from a deleted or non-deleted record.
1:eac0369: 		Fills in the passed in Object column with the field
1:eac0369: 		identified by fieldid if column is not null, otherwise the record
1:eac0369: 		is locked but not fetched.
1:eac0369: 		<BR>
1:eac0369: 		The fieldId of the first field is 0.
1:dbed020: 		If the fieldId is &gt;= the number of fields on the record, 
1:eac0369: 		column is restored to null
1:eac0369: 		<P>
1:eac0369: 		<B>Locking Policy</B>
1:eac0369: 		<BR>
1:12c6ed9: 			No locks are obtained. 
1:12c6ed9:             It is up to the caller to obtain the correct locks.
1:eac0369: 		<BR>
1:eac0369: 
1:eac0369: 		It is guaranteed that the page latch is not released by this method
1:eac0369: 
1:eac0369: 		@param slot is the slot number
1:eac0369: 		@param fieldId is the column id
1:eac0369: 		@param column is to be filled in with information from the record.
1:eac0369: 
1:eac0369: 		@return the Handle to the record that is locked
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy, a 
1:eac0369:                                         statement level exception is thrown if
1:eac0369:                                         the slot is not on the page.
1:eac0369: 
1:eac0369: 		@see Page#fetchFromSlot
1:eac0369: 		@see LockingPolicy
1:eac0369: 	 */
1:eac0369: 	public RecordHandle fetchFieldFromSlot(
1:12c6ed9:     int    slot, 
1:12c6ed9:     int    fieldId, 
1:eac0369:     Object column)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Test if a record is deleted.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * <P>
1:eac0369:      * <B>Locking Policy</B>
1:eac0369:      * <BR>
1:eac0369:      * No locks are obtained.
1:eac0369:      *
1:eac0369:      * <BR>
1:eac0369:      * It is guaranteed that the page latch is not released by this method
1:eac0369:      *
1:eac0369:      * @param slot slot of record to be tested.
1:eac0369:      *
1:3fd26f3:      * @exception StandardException	Standard Derby error policy, a 
1:eac0369:      *                              statement level exception is thrown if the 
1:eac0369:      *                              slot is not on the page.
1:eac0369:      **/
1:eac0369: 	public boolean isDeletedAtSlot(int slot)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**		
1:eac0369: 		Update a field within the record, replacing its current value with
1:eac0369: 		the stored representation of newValue. Record is identified by slot.
1:eac0369: 		If the field does not exist then it is added to the record, but only if
1:eac0369: 		(fieldId - 1) exists.
1:eac0369: 
1:eac0369: 		<BR><B>RESOLVE</B> right now it throws an exception if fieldId is not 
1:eac0369: 		already on the record, not add the next one as advertised.
1:eac0369: 
1:eac0369: 		<P>
1:eac0369: 		<B>Locking Policy</B>
1:eac0369: 		<P>
1:eac0369: 		Calls the lockRecordForWrite() method of the LockingPolicy object
1:eac0369: 		passed to the openContainer() call before the record is updated.
1:eac0369: 
1:eac0369: 		<BR>
1:eac0369: 		It is guaranteed that the page latch is not released by this method
1:eac0369: 		
1:eac0369: 
1:eac0369: 		@param slot is the slot number
1:eac0369: 		@param fieldId is the column id
1:eac0369: 		@param newValue has the new colum value to be stored in the record
1:eac0369: 		@param undo if logical undo may be necessary, a function pointer to the
1:eac0369: 		access code where the logical undo logic resides. Null if logical undo
1:eac0369: 		is not necessary.
1:eac0369: 
1:eac0369: 		@return a Handle to the updated record.
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy, a
1:eac0369:                                         statement level exception is thrown if
1:eac0369: 		                                the slot is not on the page, or if the 
1:eac0369:                                         record is deleted, or if the fieldId 
1:eac0369:                                         is not on the record and (fieldId - 1)
1:f668d94:                                         does not exist, or if the container was
1:f668d94:                                         not opened in update mode.
1:eac0369: 
1:eac0369: 		@see LockingPolicy
1:eac0369: 		@see LogicalUndo
1:eac0369: 		@see LogicalUndoable
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public RecordHandle updateFieldAtSlot(
2:eac0369:     int                 slot, 
2:eac0369:     int                 fieldId, 
1:eac0369:     Object newValue, 
1:eac0369:     LogicalUndo         undo)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Fetch the number of fields in a record.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * <P>
1:eac0369:      * <B>Locking Policy</B>
1:eac0369:      * <P>
1:eac0369:      * No locks are obtained.
1:eac0369:      *
1:eac0369:      * <BR>
1:eac0369:      * It is guaranteed that the page latch is not released by this method
1:eac0369:      *
1:eac0369:      * @param slot is the slot number
1:eac0369:      *
1:eac0369:      * @return the number of fields in the record
1:eac0369:      *
1:3fd26f3:      * @exception StandardException	Standard Derby error policy
1:eac0369:      **/
1:eac0369: 	public int fetchNumFieldsAtSlot(int slot)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Mark the record at slot as deleted or undeleted according to delete flag.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * <P>
1:eac0369:      * <B>Locking Policy</B>
1:eac0369:      * <P>
1:eac0369:      * Calls the lockRecordForWrite() method of the LockingPolicy object passed
1:eac0369:      * to the openContainer() call before the record is deleted.  If record 
1:eac0369:      * already deleted, and an attempt is made to delete it, an exception is 
1:eac0369:      * thrown.  If record not deleted, and an attempt is made to undelete it, 
1:eac0369:      * an exception is thrown.
1:eac0369:      *
1:eac0369:      * <BR>
1:eac0369:      * MT - latched
1:eac0369:      *
1:eac0369:      * @return a Handle to the deleted/undeleted record.
1:eac0369:      *
1:eac0369:      * @param slot      is the slot number
1:eac0369:      * @param delete    true if this record is to be deleted false if this 
1:eac0369:      *                  deleted record is to be marked undeleted
2:eac0369:      * @param undo      if logical undo may be necessary, a function pointer to
2:eac0369:      *                  the access code where the logical undo logic resides.
2:eac0369:      *                  Null if logical undo is not necessary.
1:eac0369:      * 
1:f668d94:      * @exception StandardException if the container was not opened in update
1:f668d94:      * mode, or if an attempt was made to delete an already deleted record or
1:f668d94:      * undelete a not deleted record, or if the slot is not on the page
1:eac0369:      *
1:eac0369:      * @see LockingPolicy
1:eac0369:      * @see LogicalUndo
1:eac0369:      * @see LogicalUndoable
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 	public RecordHandle deleteAtSlot(
1:eac0369:     int         slot, 
1:eac0369:     boolean     delete, 
1:eac0369:     LogicalUndo undo)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Purge the row(s) from page.
1:eac0369:      * <p>
1:eac0369:      * Purge the row(s) from page, get rid of the row(s) and slot(s) - 
1:eac0369:      * <B>USE WITH CAUTION</B>, 
1:eac0369:      * please see entire description of this operation before attempting to 
1:eac0369:      * use this.
1:eac0369:      *
1:eac0369:      * Starting from the specified slot, n rows will be purged. That is, rows 
1:eac0369:      * that occupies from slot to slot+n-1 will be purged from the page.
1:eac0369:      *
1:eac0369:      * <P>
1:eac0369:      * <B>Locking Policy</B>
1:eac0369:      * <P>
1:eac0369:      * Calls the lockRecordForWrite() method of the LockingPolicy object passed
1:eac0369:      * to the openContainer() call before the records are purged.
1:eac0369:      * <P>
1:eac0369:      *
1:eac0369:      * <B>NOTE : CAVEAT</B><BR>
1:eac0369:      * This operation will physically get rid of the row from the page, so if a
1:eac0369:      * subsequent operation on this page uses a slot that has been purged, then
1:eac0369:      * the undo of this operation will fail.  It is only safe to use this 
1:eac0369:      * operation if the caller knows that it has exclusive access to the page 
1:eac0369:      * for the duration of the transaction, i.e, effectively holding a page 
1:eac0369:      * lock on the page
1:eac0369:      * <P>
1:eac0369:      * <B>NOTE</B><BR>
1:eac0369:      * Outstanding handles to purged rows are no longer valid, accessing them 
1:eac0369:      * will cause an exception to be thrown.
1:eac0369:      *
1:eac0369:      * <BR>
1:eac0369: 	 *<B>NOTE : Data Logging for Purges</B><BR>
1:12c6ed9: 	 * needDataLogged is used to specify whether data is required to be
1:eac0369: 	 * logged for purge operatios. Data Logging is required 
1:eac0369: 	 * Only if the row can be reused or required for key search if a purge is
1:eac0369: 	 * rolled back;(rollback can occur if the system crashes in the middle of
1:eac0369: 	 * purges or some unexpected error condiditions  rolled back.
1:eac0369: 	 * For example: 
1:12c6ed9: 	 * 1)Btree expects the data to be there if a purge is rolled back;
1:12c6ed9:      *   needDataLogged=true
1:eac0369: 	 * 2)Heaps does not care if data exist because only operation that can occur
1:eac0369: 	 * on a row whose purge rolled back is purging again.(needDataLogged=false)
1:eac0369: 	 * 
1:eac0369:      * MT - latched
1:eac0369:      *
1:eac0369:      *
1:12c6ed9:      * @param slot	            the starting slot number
1:dbed020:      * @param numpurges	        number of slots to purge.  If &lt;= 0, 
1:12c6ed9:      *                          just returns as a no-op.
1:12c6ed9: 	 * @param needDataLogged    if set to true data is logged for purges else 
1:12c6ed9:      *                          only headers.
1:eac0369: 	 *
1:3fd26f3:      * @exception StandardException	Standard Derby error policy
1:eac0369:      * @see LockingPolicy
1:eac0369:      **/
1:eac0369: 	public void purgeAtSlot(
1:12c6ed9:     int     slot, 
1:12c6ed9:     int     numpurges,
1:12c6ed9: 	boolean needDataLogged) 
1:12c6ed9:         throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * move rows from one page to another, purging in the process.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * Move from this page slot[src_slot] to slot[src_slot+num_rows-1] to 
1:eac0369:      * destPage slot[dest_slot] to slot[dest_slot + num_rows - 1], in that 
1:eac0369:      * order. Both this page and destPage must be latched and from the same 
1:eac0369:      * container with the same page and record format.
1:eac0369:      *
1:eac0369:      * <BR>Slot[src_slot] to slot[src_slot+numrows-1] will be purged from this 
1:eac0369:      * page.  RecordId on the dest page will be brand new and not in any 
1:eac0369:      * particular order or range.  RecordId of the purged rows in this page is 
1:eac0369:      * never reused.  Deleted and undeleted rows are copied over just the same.
1:eac0369:      *
1:eac0369:      * Exception will be thrown if this page does not have all the rows in the 
1:eac0369:      * moved over range.  
1:eac0369:      *
1:eac0369:      * <BR><B>RESOLVE: reserve space now not copied over because in btree, a
1:eac0369:      * row never shrinks.  When this routine is called by heap or by some page
1:eac0369:      * which will have shrunken row, then we need to add that </B>
1:eac0369:      *
1:eac0369:      * <BR>DestPage must have at least dest_slot row occupying slot[0] to
1:eac0369:      * slot[dest_slot-1].  DestPage must have enough space to take the copied
1:dbed020:      * over data.  Rows that occupied slot number &gt; dest_slot will be moved up
1:dbed020:      * the slot (I.e., slot[dest_slot] -&gt; slot[dest_slot + num_rows]).  
1:eac0369:      *
1:eac0369:      * <BR>If this operation rolls back, this page (the src page) will get the
1:eac0369:      * rows back and the dest page will purge the rows that were copied - this
1:eac0369:      * is as if the rows were inserted into the dest page with 
1:eac0369:      * INSERT_UNDO_WITH_PURGE.
1:eac0369:      *
1:eac0369:      * <P>
1:eac0369:      * <B>Locking Policy</B>
1:eac0369:      * <P>
1:eac0369:      * Calls the lockRecordForWrite() method of the LockingPolicy object
1:eac0369:      * passed to the openContainer() call before the rows are copied over and 
1:eac0369:      * bore the records are purged.  I.e, for num_rows moved, there will be
1:eac0369:      * 2*num_rows calls to lockRecordForWrite.
1:eac0369:      * <P>
1:eac0369:      *
1:eac0369:      * <P><B>Use with caution</B>
1:eac0369:      * <BR>As with a normal purge, no space is reserved on this page for 
1:eac0369:      * rollback of the purge, so you must commit before inserting any rows 
1:eac0369:      * onto this page - unless those inserts are INSERT_UNDO_WITH_PURGE.
1:eac0369:      *
1:eac0369:      * @param destPage the page to copy to
1:eac0369:      * @param src_slot start copying from this slot
1:eac0369:      * @param num_rows copy and purge this many rows from this page
1:eac0369:      * @param dest_slot copying into this slot of destPage
1:eac0369:      *
1:3fd26f3:      * @exception StandardException Standard Derby error policy
1:eac0369:      **/
1:eac0369: 	public void copyAndPurge(
1:eac0369:     Page    destPage, 
1:eac0369:     int     src_slot, 
1:eac0369:     int     num_rows, 
1:eac0369:     int     dest_slot)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Update the complete record identified by the slot.
1:eac0369: 
1:eac0369: 		<P>
1:eac0369: 		<B>Locking Policy</B>
1:eac0369: 		<P>
1:eac0369: 		Calls the lockRecordForWrite() method of the LockingPolicy object
1:eac0369: 		passed to the openContainer() call before the record is undeleted.
1:eac0369: 		If record already deleted, an exception is thrown.
1:eac0369: 
1:eac0369: 		<BR>
1:eac0369: 		It is guaranteed that the page latch is not released by this method
1:eac0369: 
1:eac0369: 		@return a Handle to the updated record.
1:eac0369: 		@param slot is the slot number
1:eac0369: 		@param validColumns a bit map of which columns in the row is valid.
1:eac0369: 		ValidColumns will not be changed by RawStore.
1:eac0369: 
1:f668d94:         @exception StandardException the container was not opened in update
1:f668d94:                                      mode, or the slot is not on the page
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	RecordHandle updateAtSlot(
1:eac0369:     int                     slot, 
1:eac0369:     Object[]   row, 
2:eac0369:     FormatableBitSet                 validColumns)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		Page operations
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Unlatch me, the page is exclusivly latched by its current user until
1:eac0369: 		this method call is made.
1:eac0369: 		<BR>
1:eac0369: 		After using this method the caller must throw away the
1:eac0369: 		reference to the Page object, e.g.
1:eac0369: 		<PRE>
1:eac0369: 			ref.unlatch();
1:eac0369: 			ref = null;
1:eac0369: 		</PRE>
1:eac0369: 		<BR>
1:eac0369: 		The page will be released automatically at the close of the
1:eac0369: 		container if this method is not called explictly.
1:eac0369: 
1:eac0369: 		<BR>
1:eac0369: 		MT - latched
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public void unlatch();
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:86e051f: 	/**
1:eac0369: 		Return the number of records on the page. The returned count includes rows that are deleted,
1:eac0369: 		i.e. it is the same as the number of slots on the page.
1:eac0369: 
1:eac0369: 		<BR>
1:eac0369: 		MT - latched
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public int recordCount() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the number of records on this page that are <B> not </B> marked as deleted.
1:eac0369: 		
1:eac0369: 		 <BR>
1:eac0369: 		MT - latched
1:eac0369: 
1:3fd26f3: 		@exception StandardException	Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public int nonDeletedRecordCount() throws StandardException;
1:eac0369: 
1:0ce6b77:     /**
1:0ce6b77:      * Is this page/deleted row a candidate for immediate reclaim space.
1:0ce6b77:      * <p>
1:0ce6b77:      * Used by access methods after executing a delete on "slot_just_deleted"
1:0ce6b77:      * to ask whether a post commit should be queued to try to reclaim space
1:0ce6b77:      * after the delete commits.  
1:0ce6b77:      * <p>
1:0ce6b77:      * Will return true if the number of non-deleted rows on the page is
1:dbed020:      * &lt;= "num_non_deleted_rows".  For instance 0 means schedule reclaim
1:0ce6b77:      * only if all rows are deleted, 1 if all rows but one are deleted.  
1:0ce6b77:      * <p>
1:0ce6b77:      * Will return true if the row just deleted is either a long row or long
1:0ce6b77:      * column.  In this case doing a reclaim space on the single row may
1:0ce6b77:      * reclaim multiple pages of free space, so better to do it now rather
1:0ce6b77:      * than wait for all rows on page to be deleted.  This case is to address
1:0ce6b77:      * the worst case scenario of all rows with long columns, but very short
1:0ce6b77:      * rows otherwise.  In this case there could be 1000's of rows on the 
1:0ce6b77:      * main page with many gigabytes of data on overflow pages in deleted space
1:0ce6b77:      * that would not be reclaimed until all rows on the page were deleted.
1:0ce6b77:      *
1:0ce6b77: 	 * @return true if a reclaim space should be scheduled post commit on this
1:0ce6b77:      *         page, false otherwise.
1:0ce6b77:      *
1:0ce6b77:      * @param num_non_deleted_rows threshold number of non-deleted rows to
1:0ce6b77:      *                             schedule reclaim space.
1:0ce6b77:      * @param slot_just_deleted    row on page to check for long row/long column
1:0ce6b77:      *
1:0ce6b77: 	 * @exception  StandardException  Standard exception policy.
1:0ce6b77:      **/
1:0ce6b77:     public boolean shouldReclaimSpace(
1:0ce6b77:     int     num_non_deleted_rows,
1:0ce6b77:     int     slot_just_deleted)
1:0ce6b77:         throws StandardException;
1:0ce6b77: 
1:eac0369: 	/**
1:eac0369: 	  Set the aux object for this page.
1:eac0369: 	  To clear the auxObject in the page, pass in a null AuxObject.
1:eac0369: 	  If the AuxObject has already been set, this method will
1:eac0369: 	  call auxObjectInvalidated() on the old aux objkect and replace it with aux.
1:eac0369: 
1:eac0369: 		<BR>
1:eac0369: 		MT - latched
1:eac0369: 
1:eac0369: 	  @see AuxObject
1:eac0369: 	**/
1:eac0369: 	public void setAuxObject(AuxObject aux);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Retrieve this page's aux object, returning null if there isn't one. The reference returned
1:eac0369: 	  must only be used while the page is latched, once unlatch is called the reference to the
1:eac0369: 	  aux object must be discarded.
1:eac0369: 
1:eac0369: 		<BR> MT - latched
1:eac0369: 
1:eac0369: 	  @see AuxObject
1:eac0369: 	**/
1:eac0369: 	public AuxObject getAuxObject();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Returns true if the page is latched. Only intended to be used as a Sanity check. Callers must
1:eac0369: 		discard Page references once unlatch is called.
1:eac0369: 
1:eac0369: 		<BR>
1:eac0369: 		MT - latched
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:86e051f:      * Set a hint in the page object to indicate that scans positioned on it
1:86e051f:      * need to reposition. Only called on B-tree pages.
1:86e051f:      */
1:86e051f:     void setRepositionNeeded();
1:86e051f: 
1:86e051f:     /**
1:86e051f:      * Check if this page has been changed in such a way that scans that are
1:86e051f:      * positioned on it will have to reposition. Only called on B-tree pages.
1:86e051f:      *
1:86e051f:      * @param version the version number of the page when the scan positioned
1:86e051f:      * on it (after which version the page should not have changed in a way
1:86e051f:      * that requires repositioning)
1:86e051f:      * @return {@code true} if a scan that was positioned on the page at page
1:86e051f:      * version {@code version} needs to reposition; {@code false} otherwise
1:86e051f:      */
1:86e051f:     boolean isRepositionNeeded(long version);
1:86e051f: 
1:86e051f:     /**
1:86e051f:      * Get the current version number of the page.
1:86e051f:      *
1:86e051f:      * @return page version number
1:86e051f:      */
1:86e051f:     long getPageVersion();
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * time stamp - for those implmentation that supports it
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Set the time stamp to what is on page at this instance.  No op if this
1:eac0369: 		page does not support time stamp.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy.
1:eac0369: 	*/
1:eac0369: 	void setTimeStamp(PageTimeStamp ts) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return a time stamp that can be used to identify the page of this
1:eac0369: 		specific instance.  For pages that don't support timestamp, returns
1:eac0369: 		null.
1:eac0369: 	*/
1:eac0369: 	PageTimeStamp currentTimeStamp();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		See if timeStamp for this page is the same as the current
1:eac0369: 		instance of the page.  Null timeStamp never equals the instance of the
1:eac0369: 		page.
1:eac0369: 
1:eac0369: 		@param ts the time stamp gotten from an earlier call to this page's
1:eac0369: 		getTimeStamp
1:eac0369: 		@return true if timestamp is the same
1:3fd26f3: 		@exception StandardException Standard Derby error policy.
1:eac0369: 
1:eac0369: 		@see PageTimeStamp
1:eac0369: 	*/
1:eac0369: 	boolean equalTimeStamp(PageTimeStamp ts) throws StandardException;
1:eac0369: 
1:eac0369: 	public boolean isLatched();
1:eac0369: 
1:eac0369:     public static final String DIAG_PAGE_SIZE        = "pageSize";
1:eac0369:     public static final String DIAG_RESERVED_SPACE   = "reserveSpace";
1:eac0369:     public static final String DIAG_MINIMUM_REC_SIZE = "minRecSize";
1:eac0369:     public static final String DIAG_BYTES_FREE       = "bytesFree";
1:eac0369:     public static final String DIAG_BYTES_RESERVED   = "bytesReserved";
1:eac0369:     public static final String DIAG_NUMOVERFLOWED    = "numOverFlowed";
1:eac0369:     public static final String DIAG_ROWSIZE          = "rowSize";
1:eac0369:     public static final String DIAG_MINROWSIZE       = "minRowSize";
1:eac0369:     public static final String DIAG_MAXROWSIZE       = "maxRowSize";
1:eac0369:     public static final String DIAG_PAGEOVERHEAD     = "pageOverhead";
1:eac0369:     public static final String DIAG_SLOTTABLE_SIZE   = "slotTableSize";
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * If slot is &gt; recordCount() or if slot &lt; FIRST_SLOT_NUMBER, an exception
/////////////////////////////////////////////////////////////////////////
1: 		If the fieldId is &gt;= the number of fields on the record, 
/////////////////////////////////////////////////////////////////////////
1:      * @param numpurges	        number of slots to purge.  If &lt;= 0, 
/////////////////////////////////////////////////////////////////////////
1:      * over data.  Rows that occupied slot number &gt; dest_slot will be moved up
1:      * the slot (I.e., slot[dest_slot] -&gt; slot[dest_slot + num_rows]).  
/////////////////////////////////////////////////////////////////////////
1:      * &lt;= "num_non_deleted_rows".  For instance 0 means schedule reclaim
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1: /usr/bin/mksh: p4: not found
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return the page key of this page. 
1:      * <p>
1:      *
1:      * <BR> MT - Latched
1:      *
1:      * @see ContainerHandle
1:      *
1: 	 * @return The page key of this page.
1:      **/
1: 	public PageKey getPageKey();
1: 
commit:ebb21c4
/////////////////////////////////////////////////////////////////////////
1:     <P>
/////////////////////////////////////////////////////////////////////////
1: 	<LI> Not using a handle after a deleteAtSlot().
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:0ce6b77
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	static final byte INSERT_INITIAL         = (byte) 0x00;	// init the flag
1: 	static final byte INSERT_DEFAULT         = (byte) 0x01;	// default flag
1: 	static final byte INSERT_CONDITIONAL     = (byte) 0x04;	// conditional 
1: 	static final byte INSERT_OVERFLOW        = (byte) 0x08;	// insert with 
1: 	static final byte INSERT_FOR_SPLIT       = (byte) 0x10;	// rawstore only
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Is this page/deleted row a candidate for immediate reclaim space.
1:      * <p>
1:      * Used by access methods after executing a delete on "slot_just_deleted"
1:      * to ask whether a post commit should be queued to try to reclaim space
1:      * after the delete commits.  
1:      * <p>
1:      * Will return true if the number of non-deleted rows on the page is
0:      * <= "num_non_deleted_rows".  For instance 0 means schedule reclaim
1:      * only if all rows are deleted, 1 if all rows but one are deleted.  
1:      * <p>
1:      * Will return true if the row just deleted is either a long row or long
1:      * column.  In this case doing a reclaim space on the single row may
1:      * reclaim multiple pages of free space, so better to do it now rather
1:      * than wait for all rows on page to be deleted.  This case is to address
1:      * the worst case scenario of all rows with long columns, but very short
1:      * rows otherwise.  In this case there could be 1000's of rows on the 
1:      * main page with many gigabytes of data on overflow pages in deleted space
1:      * that would not be reclaimed until all rows on the page were deleted.
1:      *
1: 	 * @return true if a reclaim space should be scheduled post commit on this
1:      *         page, false otherwise.
1:      *
1:      * @param num_non_deleted_rows threshold number of non-deleted rows to
1:      *                             schedule reclaim space.
1:      * @param slot_just_deleted    row on page to check for long row/long column
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean shouldReclaimSpace(
1:     int     num_non_deleted_rows,
1:     int     slot_just_deleted)
1:         throws StandardException;
1: 
commit:12c6ed9
/////////////////////////////////////////////////////////////////////////
1:      * @param slot           Slot of row to move.
1:      * @param row            A template to read the current row into as part
1:      *                       of moving it.
/////////////////////////////////////////////////////////////////////////
1:      * @param handle    record handle to deleted or non-deleted record
/////////////////////////////////////////////////////////////////////////
1:      * Values for insertFlag.
/////////////////////////////////////////////////////////////////////////
1:      * Fetch a record located in the passed in slot.
/////////////////////////////////////////////////////////////////////////
1: 			No locks are obtained. 
1:             It is up to the caller to obtain the correct locks.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     int    slot, 
1:     int    fieldId, 
/////////////////////////////////////////////////////////////////////////
1: 	 * needDataLogged is used to specify whether data is required to be
1: 	 * 1)Btree expects the data to be there if a purge is rolled back;
1:      *   needDataLogged=true
1:      * @param slot	            the starting slot number
0:      * @param numpurges	        number of slots to purge.  If <= 0, 
1:      *                          just returns as a no-op.
1: 	 * @param needDataLogged    if set to true data is logged for purges else 
1:      *                          only headers.
1:     int     slot, 
1:     int     numpurges,
1: 	boolean needDataLogged) 
1:         throws StandardException;
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
0:     RecordHandle        handle, 
1:     Object[]            row, 
1:     FormatableBitSet    validColumns, 
0:     boolean             forUpdate)
/////////////////////////////////////////////////////////////////////////
1:     Object[]            row, 
1:     FormatableBitSet    validColumns, 
1:     int                 overflowThreshold) 
/////////////////////////////////////////////////////////////////////////
0:     Object[]            row, 
0:     FormatableBitSet    validColumns,
1:     byte                insertFlag, 
1:     int                 overflowThreshold)
/////////////////////////////////////////////////////////////////////////
0:     RecordHandle        handle, 
0:     Object[]            row, 
/////////////////////////////////////////////////////////////////////////
1:      * Move record to a page toward the beginning of the file.
1:      * <p>
1:      * As part of compressing the table records need to be moved from the
1:      * end of the file toward the beginning of the file.  Only the 
1:      * contiguous set of free pages at the very end of the file can
1:      * be given back to the OS.  This call is used to purge the row from
1:      * the current page, insert it into a previous page, and return the
1:      * new row location 
1:      * Mark the record identified by position as deleted. The record may be 
1:      * undeleted sometime later using undelete() by any transaction that sees 
1:      * the record.
1:      * <p>
1:      * The interface is optimized to work on a number of rows at a time, 
1:      * optimally processing all rows on the page at once.  The call will 
1:      * process either all rows on the page, or the number of slots in the
1:      * input arrays - whichever is smaller.
1:      * <B>Locking Policy</B>
1:      * <P>
1:      * MUST be called with table locked, not locks are requested.  Because
1:      * it is called with table locks the call will go ahead and purge any
1:      * row which is marked deleted.  It will also use purge rather than
1:      * delete to remove the old row after it moves it to a new page.  This
1:      * is ok since the table lock insures that no other transaction will
1:      * use space on the table before this transaction commits.
1:      *
1:      * <BR>
1:      * A page latch on the new page will be requested and released.
1:      *
1:      * @param old_handle     An array to be filled in by the call with the 
1:      *                       old handles of all rows moved.
1:      * @param new_handle     An array to be filled in by the call with the 
1:      *                       new handles of all rows moved.
0:      * @param new_pageno     An array to be filled in by the call with the 
0:      *                       new page number of all rows moved.
1:      *
1:      * @return the number of rows processed.
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy
1:      *
1:      * @see LockingPolicy
1:      **/
1: 	public int moveRecordForCompressAtSlot(
1:     int             slot,
1:     Object[]        row,
1:     RecordHandle[]  old_handle,
1:     RecordHandle[]  new_handle)
1: 		throws StandardException;
1: 
1:     /**
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException if the container was not opened in update
1:      * mode, or if the row cannot fit on the page, or if the row is null
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException if the container was not opened in update
1:      * mode, or if the row cannot fit on the page
/////////////////////////////////////////////////////////////////////////
1:                                         does not exist, or if the container was
1:                                         not opened in update mode.
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException if the container was not opened in update
1:      * mode, or if an attempt was made to delete an already deleted record or
1:      * undelete a not deleted record, or if the slot is not on the page
/////////////////////////////////////////////////////////////////////////
1:         @exception StandardException the container was not opened in update
1:                                      mode, or the slot is not on the page
commit:86e051f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set a hint in the page object to indicate that scans positioned on it
1:      * need to reposition. Only called on B-tree pages.
1:      */
1:     void setRepositionNeeded();
1: 
1:     /**
1:      * Check if this page has been changed in such a way that scans that are
1:      * positioned on it will have to reposition. Only called on B-tree pages.
1:      *
1:      * @param version the version number of the page when the scan positioned
1:      * on it (after which version the page should not have changed in a way
1:      * that requires repositioning)
1:      * @return {@code true} if a scan that was positioned on the page at page
1:      * version {@code version} needs to reposition; {@code false} otherwise
1:      */
1:     boolean isRepositionNeeded(long version);
1: 
1:     /**
1:      * Get the current version number of the page.
1:      *
1:      * @return page version number
1:      */
1:     long getPageVersion();
commit:47efb9b
/////////////////////////////////////////////////////////////////////////
0:      * Get a record id protection handle.
1:      *
0:      * @return a record id protection handle
0:      * @see RecordHandle#RECORD_ID_PROTECTION_HANDLE
1:      */
0:     public RecordHandle getProtectionRecordHandle();
1: 
1:     /**
commit:00d19b5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException	Standard Derby error policy, a 
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy, a 
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException	Standard Derby error policy, a 
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy, a
/////////////////////////////////////////////////////////////////////////
0:      * @exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0:      * @exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0:      * @exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
0: 		@exception StandardException	Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy.
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.raw.Page
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.raw;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: 
1: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: 
1: /**
1: 	A Page contains an ordered set of records which are the stored form of rows.
1: 	A record is a stream of bytes created from a row array. The record
1: 	contains one or more fields, fields have a one to one correlation with
1: 	the DataValueDescriptor's contained within a row array.
1:   <P>
1: 	A Page represents <B>exclusive</B> access to a data page within a container.
1: 	Exclusive access is released by calling the unlatch() method, once that 
1:     occurs the caller must no longer use the Page reference.
1: 	<P>
1: 	Several of the methods in Page take a RecordHandle as an argument. 
1:     RecordHandles are obtained from a Page, while holding exclusive access of 
1:     Page or a from a previous exclusive access of a Page representing the same 
1:     data page.
1: 	All RecordHandle's used as arguments to methods (with the exception of 
1:     recordExists()) must be valid for the current state of the page. If they 
1:     are not valid then the method will throw an exception. A caller can ensure 
1:     that a record handle is valid by:
1: 	<UL>
1: 	<LI> Obtaining the handle during this exclusive access of this page
1: 	<LI> Checking the record still exists with the method recordExists()
0: 	<LI> Not using a handle after a delete().
1: 	</UL>
1: 	<P>
1: 	Several of the methods in Page take a slot number as an argument.  A slot 
1:     always correspond to a record, which may be deleted or undeleted.
1: 
1:     <BR>
1: 	MT - Latched - In general every method requires the page to be latched.
1: 
1:   <P>
1:   <B>Latching</B>
1:   <P>
1:   All page methods which are not valid for a latched page throw an
1:   exception if the page is not latched.  [@exception clauses on all
1:   the methods should be updated to reflect this].
1: 
1:   <P>
1:   <B>Aux Objects</B>
1:   <BR>
1:   The page cache will manage a client object along with the page as long
1:   as it remains in cache.  This object is called the "aux object".  The 
1:   aux object is associated with the page with setAuxObject(), and can be
1:   retreived later with getAuxObject().  The aux object will remain valid
1:   as long as the page is latched, but callers cannot assume that an aux
1:   object will ever stick around once the page is unlatched.  However, the
1:   page manager promises to call pageBeingEvicted() once before clearing
1:   the aux reference from the page.
1: 
1: 	@see Object
1: 	@see ContainerHandle
1: 	@see RecordHandle
1: 	@see AuxObject
1: */
1: 
1: public interface Page  
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1:     /**************************************************************************
1:      * Constants of the class
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * The slot number of the first slot.  This is guaranteed to be zero.
1:      **/
1: 	public static final int FIRST_SLOT_NUMBER   = 0;
1: 	
1:     /**
1:      * A slot number guaranteed to be invalid.
1:      **/
1: 	public static final int INVALID_SLOT_NUMBER = -1;
1: 	
1:     /**
1:      * Return the page number of this page. 
1:      * <p>
1:      * Page numbers are unique within a container and start at 
1:      * ContainerHandle.FIRST_PAGE_NUMBER and increment by 1 regardless of the 
1:      * page size.
1:      * <p>
1:      *
1:      * <BR> MT - Latched
1:      *
1:      * @see ContainerHandle
1:      *
1: 	 * @return The page number of this page.
1:      **/
1: 	public long getPageNumber();
1: 
1:     /**************************************************************************
1:      * Public Methods of This class: record handle interface.
1:      *     the following interfaces to page use the record Id or record handle
1:      *     (rather than the slot interface).
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Return an invalid record handle.
1:      * <p>
1:      *
1: 	 * @return an invalid record handle.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public RecordHandle getInvalidRecordHandle();
1: 
1:     /**
1:      * Return a record handle for the given constant record id.
1:      * <p>
1:      * Return a record handle that doesn't represent a record but rather has 
1:      * a special meaning.  Used for special cases like creating a key 
1:      * specific to the page, but not specific to a row on the page.
1:      * <p>
1:      * See RecordHandle interface for a list of "special record handles."
1:      *
1:      * @see RecordHandle
1:      *
1: 	 * @return The created record handle.
1:      *
1:      * @param recordHandleConstant the special recordId
1:      *
1: 	 * @exception StandardException if input is not a special record identifier.
1:      **/
1: 	public RecordHandle makeRecordHandle(int recordHandleConstant) 
1: 		 throws	StandardException;
1: 
1:     /**
1:      * Get a record handle from a previously stored record id.
1:      * <p>
1:      * Get a record handle from a previously stored record identifier that was
1:      * obtained from a RecordHandle.
1:      * <p>
1:      * <BR> MT - Latched
1:      *
1: 	 * @return A valid record handle or null if the record no longer exists.
1:      *
1:      * @param recordId previously stored recordId.
1:      *
1:      * @see RecordHandle#getId
1:      **/
1: 	RecordHandle getRecordHandle(int recordId);
1: 
1:     /**
1:      * does the record still exist on the page?
1:      * <p>
1:      * If "ignoreDelete" is true and the record handle represents a record on 
1:      * the page (either marked deleted or not) return true.  If "ignoreDelete" 
1:      * is false return true if the record handle represents a record on the 
1:      * page and the record is not marked as deleted.  Return false otherwise.
1:      *
1:      * <BR> MT - Latched
1:      *
1: 	 * @return boolean indicating if the record still exists on the page.
1:      *
1:      * @param handle        handle of the record to look for.
1:      * @param ignoreDelete  if true, then routine will return true even if the
1:      *                      row is marked deleted.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	boolean recordExists(RecordHandle handle, boolean ignoreDelete) 
1: 		 throws StandardException;
1: 
1:     /**
0:      * Fetch and lock a non-deleted record.
1:      * <p>
0:      * Lock and fetch a non-deleted record identified by a RecordHandle.  
0:      * Reads data from the page into row.
1:      * <P>
1:      * <B>Locking Policy</B>
1:      * <BR>
0:      * Calls the lockRecordForRead() method of the LockingPolicy object
0:      * passed to the openContainer() call before the record is accessed.
1:      * <BR>
0:      * The page latch may be released and re-latched within this method.
0:      * This will occur if the record lock has to be waited for.
1:      *
0:      * @param handle        Handle to record.
0:      * @param row           Row to be filled in with data from the record.
0:      * @param validColumns  a bit map of which columns in the row is to be 
0:      *                      fetched.  ValidColumns will not be changed by 
0:      *                      RawStore.
0:      * @param forUpdate     true if the intention is to update this record, 
0:      *                      false otherwise.
1:      *
0:      * @return A handle to the record, null if the record has been deleted.
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy, 
0:      *                              a statemente level exception is thrown if
0:      *                              the record handle does not match a record 
0:      *                              on the page.
1:      *
0:      * @see Page#delete
1:      * @see LockingPolicy
1:      **/
0: 	RecordHandle fetch(
0:     RecordHandle            handle, 
1:     Object[]   row, 
1:     FormatableBitSet                 validColumns, 
0:     boolean                 forUpdate)
1: 		throws StandardException;
1: 
1:     /**
1:      * Is it likely that an insert will fit on this page?
1:      * <p>
1:      * Return true if there is a good chance an insert will fit on this page, 
1:      * false otherwise.  If this returns true then an insert may still fail by 
1:      * throwing an exception or by returning null, see insertAtSlot for details.
1:      * It is very probable that this call is much faster than the version that 
1:      * takes a row. In situations where it is expected that the 
1:      * majority of times a row will fit on a page this method should be used 
1:      * and the null return handled from insert/insertAtSlot.
1:      *
1:      * <BR>
1:      * MT - latched
1:      *
1: 	 * @return true if it is likely an insert will fit on the page.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	boolean spaceForInsert() 
1:         throws StandardException;
1: 
1:     /**
1:      * will insert of this row fit on this page?
1:      * <p>
1:      * Return true if this record is guaranteed to be inserted successfully 
1:      * using insert() or insertAtSlot(). This guarantee is only valid if the 
1:      * following conditions are fulfilled before an insert is called with t
1:      * his row.
1:      * <UL>
1:      * <LI> The page is not unlatched
1:      * <LI> The page is not modified in any way, ie. no updates or other inserts
1:      * <LI> The row is not modified in such a way that would change its 
1:      *      storage size
1:      * </UL>
1:      *
1:      * <BR>
1:      * MT - latched
1:      *
1: 	 * @return true if insert of this row will fit on this page.
1:      *
1:      * @param row                   The row to check for insert.
1:      * @param validColumns          bit map to interpret valid columns in row.
1:      * @param overflowThreshold     The percentage of the page to use for the
1:      *                              insert.  100 means use 100% of the page,
1:      *                              50 means use 50% of page (ie. make sure
1:      *                              2 rows fit per page).
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	boolean spaceForInsert(
1:     Object[]   row, 
1:     FormatableBitSet                 validColumns, 
1:     int                     overflowThreshold) 
1:         throws StandardException;
1: 
1:     /**
1:      * Insert a record anywhere on the page.
1:      * <P>
1:      *
1:      * <B>Locking Policy</B>
1:      * <BR>
1:      * Calls the lockRecordForWrite() method of the LockingPolicy object
1:      * passed to the openContainer() call before the record is inserted.
1:      * <BR>
1:      * MT - latched
1:      *
1:      * @param row           The row version of the data
1:      * @param validColumns  a bit map of which columns in the row is valid.  
1:      *                      ValidColumns will not be changed by RawStore.
1:      * @param insertFlag    see values for insertFlag below.
1:      *
1:      * @return A RecordHandle representing the new record.
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException Row cannot fit on the page or row is null.
1:      **/
1: 	RecordHandle insert(
1:     Object[]   row, 
1:     FormatableBitSet                 validColumns,
1:     byte                    insertFlag, 
1:     int                     overflowThreshold)
1: 		throws StandardException;
1: 
1: 	/**
0: 		Update the complete record identified by the record handle.
1: 
1: 	*/
1:     /**
0:      * Update the record identified by the record handle.
1:      * <p>
0:      * Update the record, the new column values are found in row[] and if
0:      * validColumns is not-null, only use the columns indicated as valid in
0:      * the bit set.
1:      * <p>
1:      * <BR>
0:      * The page latch may be released and re-latched within this method.
0:      * This will occur if the record lock has to be waited for.
1:      *
0:      * @param handle        the record handle
1:      * @param row           The row version of the data
0:      * @param validColumns  A bit map of which columns in the row is valid.  
1:      *                      ValidColumns will not be changed by RawStore.
1:      *
0:      * @return true if the record is updated.  
0:      *         False if it is not because the record is already deleted.
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException If the record handle does not match 
0:      *                              a record on the page.
1:      *
0:      * @see Page#updateAtSlot
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0: 	boolean update(
0:     RecordHandle            handle, 
1:     Object[]   row, 
1:     FormatableBitSet                 validColumns)
1: 		throws StandardException;
1: 
1:     /**
0:      * Mark the record identified by position as deleted.
1:      * <p>
0:      * Mark the record identified by position as deleted. The record may be 
0:      * undeleted sometime later using undelete() by any transaction that sees 
0:      * the record.
1:      * <p>
1:      * <B>Locking Policy</B>
1:      * <P>
1:      * Calls the lockRecordForWrite() method of the LockingPolicy object
0:      * passed to the openContainer() call before the record is deleted.
1:      *
1:      * <BR>
0:      * The page latch may be released and re-latched within this method.
0:      * This will occur if the record lock has to be waited for.
1:      *
0:      * @param handle    record Handle to record
1:      * @param undo      if logical undo may be necessary, a function pointer to
1:      *                  the access code where the logical undo logic resides.
1:      *                  Null if logical undo is not necessary.
1:      *
0:      * @return true if the record was updated.  
0:      *         False if it wasn't because it is already deleted.
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException If the record handle does not match 
0:      *                              a record on the page.
1:      *
0:      * @see Page#deleteAtSlot
1:      * @see LockingPolicy
1:      **/
0: 	public boolean delete(
0:     RecordHandle    handle, 
0:     LogicalUndo     undo)
1: 		throws StandardException;
1: 
1:     /**
1:      * Fetch the number of fields in a record. 
1:      * <p>
1:      * <B>Locking Policy</B>
1:      * <P>
1:      * No locks are obtained.
1:      *
1:      * <BR>
1:      * MT - latched
1:      *
0:      * @param record Handle to deleted or non-deleted record
1:      *
1:      * @return the number of fields in the record
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy, a 
1:      *                              statement level exception is thrown if the 
1:      *                              record handle does not match a record on 
1:      *                              the page.
1:      **/
1: 	public int fetchNumFields(RecordHandle handle)
1: 		 throws StandardException;
1: 
1:     /**************************************************************************
1:      * Public Methods of This class: slot interface.
1:      *     the following interfaces to page use the slot number 
1:      *     (rather than the record handle interface).
1:      **************************************************************************
1:      */
1: 
1: 
1:     /**
1:      * Get the slot number.
1:      * <p>
1:      * Get the slot number of a record on a latched page using its record 
1:      * handle.
1:      *
1:      * <P><B>Note</B>
1:      * The slot number is only good for as long as the page is latched.
1:      *
1:      * <BR>
1:      * MT - latched
1:      *
1:      * @param handle the record handle
1:      *
1:      * @return the slot number
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy
1:      **/
1:     int getSlotNumber(RecordHandle handle) 
1:         throws StandardException;
1: 
1:     /**
1:      * Get the record handle of row at slot.
1:      * <p>
1:      * Get the record handle of a record on a latched page using its slot 
1:      * number.
1:      *
1:      * <BR>
1:      * MT - latched
1:      *
1:      * @param slot the slot number
1:      *
1:      * @return the record handle.
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy
1:      **/
1: 	RecordHandle getRecordHandleAtSlot(int slot) 
1:         throws StandardException;
1: 
1:     /**
1:      * Find slot for record with an id greater than the passed in identifier.
1:      * <p>
1:      * Find the slot for the first record on the page with an id greater than 
1:      * the passed in identifier.
1:      *
1:      * <BR>
1:      * Returns the slot of the first record on the page with an id greater than
1:      * the one passed in.  Usefulness of this functionality depends on the 
1:      * client's use of the raw store interfaces.  If all "new" records are 
1:      * always inserted at the end of the page, and the raw store continues to
1:      * guarantee that all record id's will be allocated in increasing order on 
1:      * a given page (assuming a PAGE_REUSABLE_RECORD_ID container), then a page
1:      * is always sorted in record id order.  For instance current heap tables 
1:      * function this way.  If the client ever inserts at a particular slot 
1:      * number, rather than at the "end" then the record id's will not be sorted.
1:      * <BR>
1:      * In the case where all record id's are always sorted on a page, then this
1:      * routine can be used by scan's which "lose" their position because the 
1:      * row they have as a position was purged.  They can reposition their scan 
1:      * at the "next" row after the row that is now missing from the table.
1:      * <BR>
1:      * This method returns the record regardless of its deleted status.
1:      * <BR>
1:      * MT - latched
1:      * 
1:      * @param handle record handle to find the next higher id.
1:      *
1:      * @return  record id of the first record on the page with a record id 
1:      *          higher than the one passed in.  If no such record exists, 
1:      *          -1 is returned.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	int getNextSlotNumber(RecordHandle handle) 
1:         throws StandardException;
1: 
1: 	/**
0: 		Insert a record at the specified slot. 
1: 		<P>
1: 	 */
1:     /**
1:      * Insert a record at the specified slot. 
1:      * <p>
1:      * All records that occupy FIRST_SLOT_NUMBER to (slot - 1) are not moved. 
1:      * <BR>
1:      * All records that occupy slot to (recordCount() - 1) are moved up one 
1:      * slot. 
1:      * <BR>
1:      * The new record is inserted at the specified slot. <BR>
1:      * If slot == FIRST_SLOT_NUMBER, then the new record will be inserted at 
1:      * the first slot. <BR>
1:      * If slot == recordCount(), then the record is inserted in a new slot, no
1:      * records are moved. <BR>
1:      *
0:      * If slot is > recordCount() or if slot < FIRST_SLOT_NUMBER, an exception
1:      * will be thrown.
1:      *
1:      * <P><B>Space Policy</B><BR>
1:      * If the row will not fit on a page then:
1:      * <UL>
1:      * <LI> an exception is thrown if the page has no other rows, this is an 
1:      *      indication that the row could never fit on a page in this container.
1:      * <LI> null is returned if there are other rows on the page, this is an 
1:      *      indication that the row can potentially be inserted successfully 
1:      *      onto an empty page.
1:      * </UL>
1:      *
1:      * <P>
1:      * <B>Locking Policy</B>
1:      * <BR>
1:      * Calls the lockRecordForWrite() method of the LockingPolicy object passed
1:      * to the openContainer() call before the record is inserted.
1:      * <BR>
1:      * MT - latched
1:      *
1:      * @param slot          The specified slot
1:      * @param row           The row version of the data
1:      * @param undo          if logical undo may be necessary, a function pointer
1:      *                      to the access code where the logical undo logic 
1:      *                      resides. Null if logical undo is not necessary.
1:      * @param validColumns  a bit map of which columns in the row is valid.  
1:      *                      ValidColumns will not be changed by RawStore.
1:      * @param insertFlag    if INSERT_UNDO_WITH_PURGE set, then the undo of this
1:      *                      insert will purge the row rather than mark it as 
1:      *                      deleted, which is the default bahavior for 
1:      *                      insertAtSlot and insert.
1:      *
1:      * @return A RecordHandle representing the new record, or null if the row 
1:      *         will not fit on a non-empty page.
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException The row cannot fit on the page
1:      *
1:      * @see LogicalUndo
1:      * @see LogicalUndoable
1:      **/
1: 	RecordHandle insertAtSlot(
1:     int                     slot, 
1:     Object[]   row, 
1:     FormatableBitSet                 validColumns, 
1:     LogicalUndo             undo,
1:     byte                    insertFlag, 
1:     int                     overflowThreshold)
1: 		throws StandardException;
1: 
1: 	/**
0: 		Values for insertFlag:
1: 		
1: 	*/
1:     /**
0:      * Values for insertFlag:
1:      * <p>
1:      *
1:      * INSERT_INITIAL			- flag initializer
1:      *
1:      * INSERT_DEFAULT			- default insert behavior, if the record does
1:      *                            not fit on the page where the insert 
1:      *                            operation is called, an error will be 
1:      *                            returned, instead of overflowing the record.
1:      *
1:      * INSERT_UNDO_WITH_PURGE	- if this is set, then the undo of this insert 
1:      *                            will purge the row rather than mark it as 
1:      *                            deleted, which is the default behaviro for 
1:      *                            insertAtSlot and insert.
1:      *
1:      * INSERT_CONDITIONAL		- if this flag is set, then, the overflow is 
1:      *                            conditional.  The record will be overflowed 
1:      *                            only if it exceeds the threshold specified 
1:      *                            by the properties, or the parameter.
1:      *
1:      * INSERT_OVERFLOW			- if this flag is set, then the insert 
1:      *                            operation will overflow the record if it does
1:      *                            not fit on the page.  
1:      *
1:      * INSERT_FOR_SPLIT		    - a record is being updated that causes new 
1:      *                            portions to be inserted *and* the last new 
1:      *                            portion needs to point to an existing portion.
1:      *
1:      * Rules for the insert flags:
1:      * 1. If INSERT_DEFAULT is set, INSERT_CONDITIONAL and INSERT_OVERFLOW 
1:      *    will be ignored
1:      * 2. INSERT_UNDO_WITH_PURGE can be set with any of the other 3 flags.
1:      * 3. If INSERT_OVERFLOW is not set, INSERT_CONDITIONAL will be ignored.  
1:      *    But, it is not necessary to set INSERT_CONDITIONAL when setting 
1:      *    INSERT_OVERFLOW.
1:      * 4. If INSERT_DEFAULT, INSERT_OVERFLOW both are not set, then, default 
1:      *    insert action will be taken, i.e. no overflow will be allowed.
1:      **/
0: 	static final byte INSERT_INITIAL =		   (byte) 0x00;	// init the flag
0: 	static final byte INSERT_DEFAULT =		   (byte) 0x01;	// default flag
1: 	static final byte INSERT_UNDO_WITH_PURGE = (byte) 0x02;	// purge row on undo
0: 	static final byte INSERT_CONDITIONAL =     (byte) 0x04;	// conditional 
1:                                                             // insert
0: 	static final byte INSERT_OVERFLOW =		   (byte) 0x08;	// insert with 
1:                                                             // possible overflow
0: 	static final byte INSERT_FOR_SPLIT =	   (byte) 0x10;	// rawstore only
1: 
1: 
1:     /**
0:      * Fetch a record located in the passed in slot
1:      * <p>
1:      * Fetch a record located in the passed in slot and fill-in the passed in 
1:      * StorebleRow and the Object columns contained within. If row
1:      * is null then the record is locked but is not fetched.
1:      * <BR>
1:      * This interface allows the caller to either return a deleted row or not. 
1:      * If "ignoreDelete" is set to true, fetch the record regardless of whether 
1:      * it is deleted or not (same as above fetchFromSlot).  However, if  
1:      * "ignoreDelete" is set to false and the and the slot correspond to a 
1:      * deleted row, null is returned.
1:      * <BR>
1:      * If a non-null Qualifier list is provided then the qualifier array will 
1:      * be applied to the row and the row will only be returned if the row 
1:      * qualifies, otherwise null will be returned.  Values in the columns of 
1:      * row may or may not be altered while trying to apply the qualifiers, if 
1:      * null is returned the state of the columns is undefined.  If a null 
1:      * Qualifier list is provided then no qualification is applied.
1:      * <BR>
1:      * If a non-null record handle is passed in, it is assumed that the record 
1:      * handle corresponds to the record in the slot.  If record handle is null,
1:      * a record handle will be manufactured and returned if the record is not 
1:      * deleted or if "ignoreDelete" is true.  This parameter is here for the 
1:      * case where the caller have already manufactured the record handle for 
1:      * locking or other purposes so it would make sense for the page to avoid 
1:      * creating a new record handle object if possible.
1:      *
1:      *
1:      * @param rh           the record handle of the row.  If non-null it must 
1:      *                     refer to the same record as the slot.  
1:      * @param slot         the slot number
1:      * @param row          Row to be filled in with information from record.
1:      * @param fetchDesc    A structure to efficiently carry a set of parameters
1:      *                     needed to describe the fetch, these include:
1:      *                     
1:      *                     validColumns - A bit map of which columns in the 
1:      *                     row to be fetched.  ValidColumns will not be 
1:      *                     changed by RawStore.
1:      *
1:      *                     qualifier_list - 
1:      *                     A list of Qualifiers to apply to the row to see if
1:      *                     the row should be returned.
1:      *
1:      *                     An array of qualifiers which restrict whether or not
1:      *                     the row should be returned by the fetch.  Rows for 
1:      *                     which any one of the qualifiers returns false are 
1:      *                     not returned by the fetch. If null, no qualification
1:      *                     is done and the requested columns of the rows are 
1:      *                     returned.  Qualifiers can only reference columns 
1:      *                     which are included in the scanColumnList.  The 
1:      *                     column id that a qualifier returns is the column id
1:      *                     the table, not the column id in the partial row 
1:      *                     being returned.  
1:      *                     qualifier_scratch_space - 
1:      *                     An array of int's that matches the size of the 
1:      *                     row[] array.  Used to process qualifiers, if no
1:      *                     qualifiers are input then array need not be 
1:      *                     input.  Passed in rather than allocated so that
1:      *                     space can be allocated a single time in a scan.
1:      *                     If not passed in then raw store will allocate and
1:      *                     deallocate per call.
1:      *
1:      * @param ignoreDelete if true, return row regardless of whether it is 
1:      *                     deleted or not.  If false, only return non-deleted 
1:      *                     row.
1:      *
1:      * @return A handle to the record.
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy
1:      *
1:      * @see LockingPolicy
1:      **/
1: 	public RecordHandle fetchFromSlot(
1:     RecordHandle            rh, 
1:     int                     slot, 
1:     Object[]                row,
1:     FetchDescriptor         fetchDesc,
1:     boolean                 ignoreDelete)
1:         throws StandardException;
1: 
1: 
1: 	/**
1: 		Fetch a single field from a deleted or non-deleted record.
1: 		Fills in the passed in Object column with the field
1: 		identified by fieldid if column is not null, otherwise the record
1: 		is locked but not fetched.
1: 		<BR>
1: 		The fieldId of the first field is 0.
0: 		If the fieldId is >= the number of fields on the record, 
1: 		column is restored to null
1: 		<P>
1: 		<B>Locking Policy</B>
1: 		<BR>
0: 			No locks are obtained. It is up to the caller to obtain the correct locks.
1: 		<BR>
1: 
1: 		It is guaranteed that the page latch is not released by this method
1: 
1: 		@param slot is the slot number
1: 		@param fieldId is the column id
1: 		@param column is to be filled in with information from the record.
0: 		@param forUpdate true if the intention is to update this record, false otherwise.
1: 
1: 		@return the Handle to the record that is locked
1: 
0: 		@exception StandardException	Standard Cloudscape error policy, a 
1:                                         statement level exception is thrown if
1:                                         the slot is not on the page.
1: 
1: 		@see Page#fetchFromSlot
1: 		@see LockingPolicy
1: 	 */
1: 	public RecordHandle fetchFieldFromSlot(
1:     int                 slot, 
1:     int                 fieldId, 
1:     Object column)
1: 		throws StandardException;
1: 
1:     /**
1:      * Test if a record is deleted.
1:      * <p>
1:      *
1:      * <P>
1:      * <B>Locking Policy</B>
1:      * <BR>
1:      * No locks are obtained.
1:      *
1:      * <BR>
1:      * It is guaranteed that the page latch is not released by this method
1:      *
1:      * @param slot slot of record to be tested.
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy, a 
1:      *                              statement level exception is thrown if the 
1:      *                              slot is not on the page.
1:      **/
1: 	public boolean isDeletedAtSlot(int slot)
1: 		 throws StandardException;
1: 
1: 	/**		
1: 		Update a field within the record, replacing its current value with
1: 		the stored representation of newValue. Record is identified by slot.
1: 		If the field does not exist then it is added to the record, but only if
1: 		(fieldId - 1) exists.
1: 
1: 		<BR><B>RESOLVE</B> right now it throws an exception if fieldId is not 
1: 		already on the record, not add the next one as advertised.
1: 
1: 		<P>
1: 		<B>Locking Policy</B>
1: 		<P>
1: 		Calls the lockRecordForWrite() method of the LockingPolicy object
1: 		passed to the openContainer() call before the record is updated.
1: 
1: 		<BR>
1: 		It is guaranteed that the page latch is not released by this method
1: 		
1: 
1: 		@param slot is the slot number
1: 		@param fieldId is the column id
1: 		@param newValue has the new colum value to be stored in the record
1: 		@param undo if logical undo may be necessary, a function pointer to the
1: 		access code where the logical undo logic resides. Null if logical undo
1: 		is not necessary.
1: 
1: 		@return a Handle to the updated record.
1: 
0: 		@exception StandardException	Standard Cloudscape error policy, a
1:                                         statement level exception is thrown if
1: 		                                the slot is not on the page, or if the 
1:                                         record is deleted, or if the fieldId 
1:                                         is not on the record and (fieldId - 1)
0:                                         does not exist.
1: 
0: 		@exception StandardException 
0: 		The container was not opened in update mode.
1: 
1: 		@see LockingPolicy
1: 		@see LogicalUndo
1: 		@see LogicalUndoable
1: 
1: 	*/
1: 	public RecordHandle updateFieldAtSlot(
1:     int                 slot, 
1:     int                 fieldId, 
1:     Object newValue, 
1:     LogicalUndo         undo)
1: 		throws StandardException;
1: 
1: 
1:     /**
1:      * Fetch the number of fields in a record.
1:      * <p>
1:      *
1:      * <P>
1:      * <B>Locking Policy</B>
1:      * <P>
1:      * No locks are obtained.
1:      *
1:      * <BR>
1:      * It is guaranteed that the page latch is not released by this method
1:      *
1:      * @param slot is the slot number
1:      *
1:      * @return the number of fields in the record
1:      *
0:      * @exception StandardException	Standard Cloudscape error policy
1:      **/
1: 	public int fetchNumFieldsAtSlot(int slot)
1: 		 throws StandardException;
1: 
1: 	/**
0: 		Mark the record identified by slot as deleted or undeleted according to the
0: 		delete flag.
1: 
1: 
1: 	*/
1:     /**
1:      * Mark the record at slot as deleted or undeleted according to delete flag.
1:      * <p>
1:      *
1:      * <P>
1:      * <B>Locking Policy</B>
1:      * <P>
1:      * Calls the lockRecordForWrite() method of the LockingPolicy object passed
1:      * to the openContainer() call before the record is deleted.  If record 
1:      * already deleted, and an attempt is made to delete it, an exception is 
1:      * thrown.  If record not deleted, and an attempt is made to undelete it, 
1:      * an exception is thrown.
1:      *
1:      * <BR>
1:      * MT - latched
1:      *
1:      * @return a Handle to the deleted/undeleted record.
1:      *
1:      * @param slot      is the slot number
1:      * @param delete    true if this record is to be deleted false if this 
1:      *                  deleted record is to be marked undeleted
1:      * @param undo      if logical undo may be necessary, a function pointer to
1:      *                  the access code where the logical undo logic resides.
1:      *                  Null if logical undo is not necessary.
1:      * 
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException A statement level exception is thrown when 
0:      *                              trying to delete an already deleted record,
0:      *                              or undelete a not deleted record.
1:      *
0:      * @exception StandardException A statement level exception is thrown if 
0:      *                              the slot is not on the page.
1:      *
1:      * @see LockingPolicy
0:      * @see Page#delete
1:      * @see LogicalUndo
1:      * @see LogicalUndoable
1:      *
1:      **/
1: 	public RecordHandle deleteAtSlot(
1:     int         slot, 
1:     boolean     delete, 
1:     LogicalUndo undo)
1: 		 throws StandardException;
1: 
1: 
1:     /**
1:      * Purge the row(s) from page.
1:      * <p>
1:      * Purge the row(s) from page, get rid of the row(s) and slot(s) - 
1:      * <B>USE WITH CAUTION</B>, 
1:      * please see entire description of this operation before attempting to 
1:      * use this.
1:      *
1:      * Starting from the specified slot, n rows will be purged. That is, rows 
1:      * that occupies from slot to slot+n-1 will be purged from the page.
1:      *
1:      * <P>
1:      * <B>Locking Policy</B>
1:      * <P>
1:      * Calls the lockRecordForWrite() method of the LockingPolicy object passed
1:      * to the openContainer() call before the records are purged.
1:      * <P>
1:      *
1:      * <B>NOTE : CAVEAT</B><BR>
1:      * This operation will physically get rid of the row from the page, so if a
1:      * subsequent operation on this page uses a slot that has been purged, then
1:      * the undo of this operation will fail.  It is only safe to use this 
1:      * operation if the caller knows that it has exclusive access to the page 
1:      * for the duration of the transaction, i.e, effectively holding a page 
1:      * lock on the page
1:      * <P>
1:      * <B>NOTE</B><BR>
1:      * Outstanding handles to purged rows are no longer valid, accessing them 
1:      * will cause an exception to be thrown.
1:      *
1:      * <BR>
1: 	 *<B>NOTE : Data Logging for Purges</B><BR>
0: 	 * @param needDataLogged is used to specify whether data is required to be
1: 	 * logged for purge operatios. Data Logging is required 
1: 	 * Only if the row can be reused or required for key search if a purge is
1: 	 * rolled back;(rollback can occur if the system crashes in the middle of
1: 	 * purges or some unexpected error condiditions  rolled back.
1: 	 * For example: 
0: 	 * 1)Btree expects the data to be there if a purge is rolled back;needDataLogged=true
1: 	 * 2)Heaps does not care if data exist because only operation that can occur
1: 	 * on a row whose purge rolled back is purging again.(needDataLogged=false)
1: 	 * 
1:      * MT - latched
1:      *
1:      *
0:      * @param slot	    the starting slot number
0:      * @param numpurges	number of slots to purge. 
0:      *                  If <= 0, just returns as a no-op.
0: 	 * @param needDataLogged  if set to true data is logged for purges else only headers.
1: 	 *
0:      * @exception StandardException	Standard Cloudscape error policy
1:      * @see LockingPolicy
1:      **/
1: 	public void purgeAtSlot(
0:     int slot, 
0:     int n,
0: 	boolean needDataLogged) throws StandardException;
1: 
1: 
1:     /**
1:      * move rows from one page to another, purging in the process.
1:      * <p>
1:      *
1:      * Move from this page slot[src_slot] to slot[src_slot+num_rows-1] to 
1:      * destPage slot[dest_slot] to slot[dest_slot + num_rows - 1], in that 
1:      * order. Both this page and destPage must be latched and from the same 
1:      * container with the same page and record format.
1:      *
1:      * <BR>Slot[src_slot] to slot[src_slot+numrows-1] will be purged from this 
1:      * page.  RecordId on the dest page will be brand new and not in any 
1:      * particular order or range.  RecordId of the purged rows in this page is 
1:      * never reused.  Deleted and undeleted rows are copied over just the same.
1:      *
1:      * Exception will be thrown if this page does not have all the rows in the 
1:      * moved over range.  
1:      *
1:      * <BR><B>RESOLVE: reserve space now not copied over because in btree, a
1:      * row never shrinks.  When this routine is called by heap or by some page
1:      * which will have shrunken row, then we need to add that </B>
1:      *
1:      * <BR>DestPage must have at least dest_slot row occupying slot[0] to
1:      * slot[dest_slot-1].  DestPage must have enough space to take the copied
0:      * over data.  Rows that occupied slot number > dest_slot will be moved up
0:      * the slot (I.e., slot[dest_slot] -> slot[dest_slot + num_rows]).  
1:      *
1:      * <BR>If this operation rolls back, this page (the src page) will get the
1:      * rows back and the dest page will purge the rows that were copied - this
1:      * is as if the rows were inserted into the dest page with 
1:      * INSERT_UNDO_WITH_PURGE.
1:      *
1:      * <P>
1:      * <B>Locking Policy</B>
1:      * <P>
1:      * Calls the lockRecordForWrite() method of the LockingPolicy object
1:      * passed to the openContainer() call before the rows are copied over and 
1:      * bore the records are purged.  I.e, for num_rows moved, there will be
1:      * 2*num_rows calls to lockRecordForWrite.
1:      * <P>
1:      *
1:      * <P><B>Use with caution</B>
1:      * <BR>As with a normal purge, no space is reserved on this page for 
1:      * rollback of the purge, so you must commit before inserting any rows 
1:      * onto this page - unless those inserts are INSERT_UNDO_WITH_PURGE.
1:      *
1:      * @param destPage the page to copy to
1:      * @param src_slot start copying from this slot
1:      * @param num_rows copy and purge this many rows from this page
1:      * @param dest_slot copying into this slot of destPage
1:      *
0:      * @exception StandardException Standard Cloudscape error policy
1:      **/
1: 	public void copyAndPurge(
1:     Page    destPage, 
1:     int     src_slot, 
1:     int     num_rows, 
1:     int     dest_slot)
1: 		 throws StandardException;
1: 
1: 	/**
1: 		Update the complete record identified by the slot.
1: 
1: 		<P>
1: 		<B>Locking Policy</B>
1: 		<P>
1: 		Calls the lockRecordForWrite() method of the LockingPolicy object
1: 		passed to the openContainer() call before the record is undeleted.
1: 		If record already deleted, an exception is thrown.
1: 
1: 		<BR>
1: 		It is guaranteed that the page latch is not released by this method
1: 
1: 		@return a Handle to the updated record.
1: 		@param slot is the slot number
1: 		@param validColumns a bit map of which columns in the row is valid.
1: 		ValidColumns will not be changed by RawStore.
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 		@exception StandardException The container was not opened in update mode.
0: 		@exception StandardException if the slot is not on the page.
1: 
0: 		@see Page#update
1: 	*/
1: 	RecordHandle updateAtSlot(
1:     int                     slot, 
1:     Object[]   row, 
1:     FormatableBitSet                 validColumns)
1: 		throws StandardException;
1: 
1: 	/*
1: 		Page operations
1: 	*/
1: 
1: 	/**
1: 		Unlatch me, the page is exclusivly latched by its current user until
1: 		this method call is made.
1: 		<BR>
1: 		After using this method the caller must throw away the
1: 		reference to the Page object, e.g.
1: 		<PRE>
1: 			ref.unlatch();
1: 			ref = null;
1: 		</PRE>
1: 		<BR>
1: 		The page will be released automatically at the close of the
1: 		container if this method is not called explictly.
1: 
1: 		<BR>
1: 		MT - latched
1: 
1: 	*/
1: 	public void unlatch();
1: 
1: 
1: 
1: 	/**
1: 		Return the number of records on the page. The returned count includes rows that are deleted,
1: 		i.e. it is the same as the number of slots on the page.
1: 
1: 		<BR>
1: 		MT - latched
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 
1: 	public int recordCount() throws StandardException;
1: 
1: 	/**
1: 		Return the number of records on this page that are <B> not </B> marked as deleted.
1: 		
1: 		 <BR>
1: 		MT - latched
1: 
0: 		@exception StandardException	Standard Cloudscape error policy
1: 	*/
1: 
1: 	public int nonDeletedRecordCount() throws StandardException;
1: 
1: 	/**
1: 	  Set the aux object for this page.
1: 	  To clear the auxObject in the page, pass in a null AuxObject.
1: 	  If the AuxObject has already been set, this method will
1: 	  call auxObjectInvalidated() on the old aux objkect and replace it with aux.
1: 
1: 		<BR>
1: 		MT - latched
1: 
1: 	  @see AuxObject
1: 	**/
1: 	public void setAuxObject(AuxObject aux);
1: 
1: 	/**
1: 	  Retrieve this page's aux object, returning null if there isn't one. The reference returned
1: 	  must only be used while the page is latched, once unlatch is called the reference to the
1: 	  aux object must be discarded.
1: 
1: 		<BR> MT - latched
1: 
1: 	  @see AuxObject
1: 	**/
1: 	public AuxObject getAuxObject();
1: 
1: 	/**
1: 		Returns true if the page is latched. Only intended to be used as a Sanity check. Callers must
1: 		discard Page references once unlatch is called.
1: 
1: 		<BR>
1: 		MT - latched
1: 	*/
1: 
1: 
1: 	/*
1: 	 * time stamp - for those implmentation that supports it
1: 	 */
1: 
1: 	/**
1: 		Set the time stamp to what is on page at this instance.  No op if this
1: 		page does not support time stamp.
1: 
0: 		@exception StandardException Standard Cloudscape error policy.
1: 	*/
1: 	void setTimeStamp(PageTimeStamp ts) throws StandardException;
1: 
1: 
1: 	/**
1: 		Return a time stamp that can be used to identify the page of this
1: 		specific instance.  For pages that don't support timestamp, returns
1: 		null.
1: 	*/
1: 	PageTimeStamp currentTimeStamp();
1: 
1: 	/**
1: 		See if timeStamp for this page is the same as the current
1: 		instance of the page.  Null timeStamp never equals the instance of the
1: 		page.
1: 
1: 		@param ts the time stamp gotten from an earlier call to this page's
1: 		getTimeStamp
1: 		@return true if timestamp is the same
0: 		@exception StandardException Standard Cloudscape error policy.
1: 
1: 		@see PageTimeStamp
1: 	*/
1: 	boolean equalTimeStamp(PageTimeStamp ts) throws StandardException;
1: 
1: 	public boolean isLatched();
1: 
1:     public static final String DIAG_PAGE_SIZE        = "pageSize";
1:     public static final String DIAG_RESERVED_SPACE   = "reserveSpace";
1:     public static final String DIAG_MINIMUM_REC_SIZE = "minRecSize";
1:     public static final String DIAG_BYTES_FREE       = "bytesFree";
1:     public static final String DIAG_BYTES_RESERVED   = "bytesReserved";
1:     public static final String DIAG_NUMOVERFLOWED    = "numOverFlowed";
1:     public static final String DIAG_ROWSIZE          = "rowSize";
1:     public static final String DIAG_MINROWSIZE       = "minRowSize";
1:     public static final String DIAG_MAXROWSIZE       = "maxRowSize";
1:     public static final String DIAG_PAGEOVERHEAD     = "pageOverhead";
1:     public static final String DIAG_SLOTTABLE_SIZE   = "slotTableSize";
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.raw;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: 
0: /**
0: 	A Page contains an ordered set of records which are the stored form of rows.
0: 	A record is a stream of bytes created from a row array. The record
0: 	contains one or more fields, fields have a one to one correlation with
0: 	the DataValueDescriptor's contained within a row array.
0:   <P>
0: 	A Page represents <B>exclusive</B> access to a data page within a container.
0: 	Exclusive access is released by calling the unlatch() method, once that 
0:     occurs the caller must no longer use the Page reference.
0: 	<P>
0: 	Several of the methods in Page take a RecordHandle as an argument. 
0:     RecordHandles are obtained from a Page, while holding exclusive access of 
0:     Page or a from a previous exclusive access of a Page representing the same 
0:     data page.
0: 	All RecordHandle's used as arguments to methods (with the exception of 
0:     recordExists()) must be valid for the current state of the page. If they 
0:     are not valid then the method will throw an exception. A caller can ensure 
0:     that a record handle is valid by:
0: 	<UL>
0: 	<LI> Obtaining the handle during this exclusive access of this page
0: 	<LI> Checking the record still exists with the method recordExists()
0: 	<LI> Not using a handle after a delete().
0: 	</UL>
0: 	<P>
0: 	Several of the methods in Page take a slot number as an argument.  A slot 
0:     always correspond to a record, which may be deleted or undeleted.
0: 
0:     <BR>
0: 	MT - Latched - In general every method requires the page to be latched.
0: 
0:   <P>
0:   <B>Latching</B>
0:   <P>
0:   All page methods which are not valid for a latched page throw an
0:   exception if the page is not latched.  [@exception clauses on all
0:   the methods should be updated to reflect this].
0: 
0:   <P>
0:   <B>Aux Objects</B>
0:   <BR>
0:   The page cache will manage a client object along with the page as long
0:   as it remains in cache.  This object is called the "aux object".  The 
0:   aux object is associated with the page with setAuxObject(), and can be
0:   retreived later with getAuxObject().  The aux object will remain valid
0:   as long as the page is latched, but callers cannot assume that an aux
0:   object will ever stick around once the page is unlatched.  However, the
0:   page manager promises to call pageBeingEvicted() once before clearing
0:   the aux reference from the page.
0: 
0: 	@see Object
0: 	@see ContainerHandle
0: 	@see RecordHandle
0: 	@see AuxObject
0: */
0: 
0: public interface Page  
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0:     /**************************************************************************
0:      * Constants of the class
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * The slot number of the first slot.  This is guaranteed to be zero.
0:      **/
0: 	public static final int FIRST_SLOT_NUMBER   = 0;
0: 	
0:     /**
0:      * A slot number guaranteed to be invalid.
0:      **/
0: 	public static final int INVALID_SLOT_NUMBER = -1;
0: 	
0:     /**
0:      * Return the page number of this page. 
0:      * <p>
0:      * Page numbers are unique within a container and start at 
0:      * ContainerHandle.FIRST_PAGE_NUMBER and increment by 1 regardless of the 
0:      * page size.
0:      * <p>
0:      *
0:      * <BR> MT - Latched
0:      *
0:      * @see ContainerHandle
0:      *
0: 	 * @return The page number of this page.
0:      **/
0: 	public long getPageNumber();
0: 
0:     /**************************************************************************
0:      * Public Methods of This class: record handle interface.
0:      *     the following interfaces to page use the record Id or record handle
0:      *     (rather than the slot interface).
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Return an invalid record handle.
0:      * <p>
0:      *
0: 	 * @return an invalid record handle.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public RecordHandle getInvalidRecordHandle();
0: 
0:     /**
0:      * Return a record handle for the given constant record id.
0:      * <p>
0:      * Return a record handle that doesn't represent a record but rather has 
0:      * a special meaning.  Used for special cases like creating a key 
0:      * specific to the page, but not specific to a row on the page.
0:      * <p>
0:      * See RecordHandle interface for a list of "special record handles."
0:      *
0:      * @see RecordHandle
0:      *
0: 	 * @return The created record handle.
0:      *
0:      * @param recordHandleConstant the special recordId
0:      *
0: 	 * @exception StandardException if input is not a special record identifier.
0:      **/
0: 	public RecordHandle makeRecordHandle(int recordHandleConstant) 
0: 		 throws	StandardException;
0: 
0:     /**
0:      * Get a record handle from a previously stored record id.
0:      * <p>
0:      * Get a record handle from a previously stored record identifier that was
0:      * obtained from a RecordHandle.
0:      * <p>
0:      * <BR> MT - Latched
0:      *
0: 	 * @return A valid record handle or null if the record no longer exists.
0:      *
0:      * @param recordId previously stored recordId.
0:      *
0:      * @see RecordHandle#getId
0:      **/
0: 	RecordHandle getRecordHandle(int recordId);
0: 
0:     /**
0:      * does the record still exist on the page?
0:      * <p>
0:      * If "ignoreDelete" is true and the record handle represents a record on 
0:      * the page (either marked deleted or not) return true.  If "ignoreDelete" 
0:      * is false return true if the record handle represents a record on the 
0:      * page and the record is not marked as deleted.  Return false otherwise.
0:      *
0:      * <BR> MT - Latched
0:      *
0: 	 * @return boolean indicating if the record still exists on the page.
0:      *
0:      * @param handle        handle of the record to look for.
0:      * @param ignoreDelete  if true, then routine will return true even if the
0:      *                      row is marked deleted.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	boolean recordExists(RecordHandle handle, boolean ignoreDelete) 
0: 		 throws StandardException;
0: 
0:     /**
0:      * Fetch and lock a non-deleted record.
0:      * <p>
0:      * Lock and fetch a non-deleted record identified by a RecordHandle.  
0:      * Reads data from the page into row.
0:      * <P>
0:      * <B>Locking Policy</B>
0:      * <BR>
0:      * Calls the lockRecordForRead() method of the LockingPolicy object
0:      * passed to the openContainer() call before the record is accessed.
0:      * <BR>
0:      * The page latch may be released and re-latched within this method.
0:      * This will occur if the record lock has to be waited for.
0:      *
0:      * @param handle        Handle to record.
0:      * @param row           Row to be filled in with data from the record.
0:      * @param validColumns  a bit map of which columns in the row is to be 
0:      *                      fetched.  ValidColumns will not be changed by 
0:      *                      RawStore.
0:      * @param forUpdate     true if the intention is to update this record, 
0:      *                      false otherwise.
0:      *
0:      * @return A handle to the record, null if the record has been deleted.
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy, 
0:      *                              a statemente level exception is thrown if
0:      *                              the record handle does not match a record 
0:      *                              on the page.
0:      *
0:      * @see Page#delete
0:      * @see LockingPolicy
0:      **/
0: 	RecordHandle fetch(
0:     RecordHandle            handle, 
0:     Object[]   row, 
0:     FormatableBitSet                 validColumns, 
0:     boolean                 forUpdate)
0: 		throws StandardException;
0: 
0:     /**
0:      * Is it likely that an insert will fit on this page?
0:      * <p>
0:      * Return true if there is a good chance an insert will fit on this page, 
0:      * false otherwise.  If this returns true then an insert may still fail by 
0:      * throwing an exception or by returning null, see insertAtSlot for details.
0:      * It is very probable that this call is much faster than the version that 
0:      * takes a row. In situations where it is expected that the 
0:      * majority of times a row will fit on a page this method should be used 
0:      * and the null return handled from insert/insertAtSlot.
0:      *
0:      * <BR>
0:      * MT - latched
0:      *
0: 	 * @return true if it is likely an insert will fit on the page.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	boolean spaceForInsert() 
0:         throws StandardException;
0: 
0:     /**
0:      * will insert of this row fit on this page?
0:      * <p>
0:      * Return true if this record is guaranteed to be inserted successfully 
0:      * using insert() or insertAtSlot(). This guarantee is only valid if the 
0:      * following conditions are fulfilled before an insert is called with t
0:      * his row.
0:      * <UL>
0:      * <LI> The page is not unlatched
0:      * <LI> The page is not modified in any way, ie. no updates or other inserts
0:      * <LI> The row is not modified in such a way that would change its 
0:      *      storage size
0:      * </UL>
0:      *
0:      * <BR>
0:      * MT - latched
0:      *
0: 	 * @return true if insert of this row will fit on this page.
0:      *
0:      * @param row                   The row to check for insert.
0:      * @param validColumns          bit map to interpret valid columns in row.
0:      * @param overflowThreshold     The percentage of the page to use for the
0:      *                              insert.  100 means use 100% of the page,
0:      *                              50 means use 50% of page (ie. make sure
0:      *                              2 rows fit per page).
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	boolean spaceForInsert(
0:     Object[]   row, 
0:     FormatableBitSet                 validColumns, 
0:     int                     overflowThreshold) 
0:         throws StandardException;
0: 
0:     /**
0:      * Insert a record anywhere on the page.
0:      * <P>
0:      *
0:      * <B>Locking Policy</B>
0:      * <BR>
0:      * Calls the lockRecordForWrite() method of the LockingPolicy object
0:      * passed to the openContainer() call before the record is inserted.
0:      * <BR>
0:      * MT - latched
0:      *
0:      * @param row           The row version of the data
0:      * @param validColumns  a bit map of which columns in the row is valid.  
0:      *                      ValidColumns will not be changed by RawStore.
0:      * @param insertFlag    see values for insertFlag below.
0:      *
0:      * @return A RecordHandle representing the new record.
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException Row cannot fit on the page or row is null.
0:      **/
0: 	RecordHandle insert(
0:     Object[]   row, 
0:     FormatableBitSet                 validColumns,
0:     byte                    insertFlag, 
0:     int                     overflowThreshold)
0: 		throws StandardException;
0: 
0: 	/**
0: 		Update the complete record identified by the record handle.
0: 
0: 	*/
0:     /**
0:      * Update the record identified by the record handle.
0:      * <p>
0:      * Update the record, the new column values are found in row[] and if
0:      * validColumns is not-null, only use the columns indicated as valid in
0:      * the bit set.
0:      * <p>
0:      * <BR>
0:      * The page latch may be released and re-latched within this method.
0:      * This will occur if the record lock has to be waited for.
0:      *
0:      * @param handle        the record handle
0:      * @param row           The row version of the data
0:      * @param validColumns  A bit map of which columns in the row is valid.  
0:      *                      ValidColumns will not be changed by RawStore.
0:      *
0:      * @return true if the record is updated.  
0:      *         False if it is not because the record is already deleted.
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException If the record handle does not match 
0:      *                              a record on the page.
0:      *
0:      * @see Page#updateAtSlot
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	boolean update(
0:     RecordHandle            handle, 
0:     Object[]   row, 
0:     FormatableBitSet                 validColumns)
0: 		throws StandardException;
0: 
0:     /**
0:      * Mark the record identified by position as deleted.
0:      * <p>
0:      * Mark the record identified by position as deleted. The record may be 
0:      * undeleted sometime later using undelete() by any transaction that sees 
0:      * the record.
0:      * <p>
0:      * <B>Locking Policy</B>
0:      * <P>
0:      * Calls the lockRecordForWrite() method of the LockingPolicy object
0:      * passed to the openContainer() call before the record is deleted.
0:      *
0:      * <BR>
0:      * The page latch may be released and re-latched within this method.
0:      * This will occur if the record lock has to be waited for.
0:      *
0:      * @param handle    record Handle to record
0:      * @param undo      if logical undo may be necessary, a function pointer to
0:      *                  the access code where the logical undo logic resides.
0:      *                  Null if logical undo is not necessary.
0:      *
0:      * @return true if the record was updated.  
0:      *         False if it wasn't because it is already deleted.
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException If the record handle does not match 
0:      *                              a record on the page.
0:      *
0:      * @see Page#deleteAtSlot
0:      * @see LockingPolicy
0:      **/
0: 	public boolean delete(
0:     RecordHandle    handle, 
0:     LogicalUndo     undo)
0: 		throws StandardException;
0: 
0:     /**
0:      * Fetch the number of fields in a record. 
0:      * <p>
0:      * <B>Locking Policy</B>
0:      * <P>
0:      * No locks are obtained.
0:      *
0:      * <BR>
0:      * MT - latched
0:      *
0:      * @param record Handle to deleted or non-deleted record
0:      *
0:      * @return the number of fields in the record
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy, a 
0:      *                              statement level exception is thrown if the 
0:      *                              record handle does not match a record on 
0:      *                              the page.
0:      **/
0: 	public int fetchNumFields(RecordHandle handle)
0: 		 throws StandardException;
0: 
0:     /**************************************************************************
0:      * Public Methods of This class: slot interface.
0:      *     the following interfaces to page use the slot number 
0:      *     (rather than the record handle interface).
0:      **************************************************************************
0:      */
0: 
0: 
0:     /**
0:      * Get the slot number.
0:      * <p>
0:      * Get the slot number of a record on a latched page using its record 
0:      * handle.
0:      *
0:      * <P><B>Note</B>
0:      * The slot number is only good for as long as the page is latched.
0:      *
0:      * <BR>
0:      * MT - latched
0:      *
0:      * @param handle the record handle
0:      *
0:      * @return the slot number
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      **/
0:     int getSlotNumber(RecordHandle handle) 
0:         throws StandardException;
0: 
0:     /**
0:      * Get the record handle of row at slot.
0:      * <p>
0:      * Get the record handle of a record on a latched page using its slot 
0:      * number.
0:      *
0:      * <BR>
0:      * MT - latched
0:      *
0:      * @param slot the slot number
0:      *
0:      * @return the record handle.
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      **/
0: 	RecordHandle getRecordHandleAtSlot(int slot) 
0:         throws StandardException;
0: 
0:     /**
0:      * Find slot for record with an id greater than the passed in identifier.
0:      * <p>
0:      * Find the slot for the first record on the page with an id greater than 
0:      * the passed in identifier.
0:      *
0:      * <BR>
0:      * Returns the slot of the first record on the page with an id greater than
0:      * the one passed in.  Usefulness of this functionality depends on the 
0:      * client's use of the raw store interfaces.  If all "new" records are 
0:      * always inserted at the end of the page, and the raw store continues to
0:      * guarantee that all record id's will be allocated in increasing order on 
0:      * a given page (assuming a PAGE_REUSABLE_RECORD_ID container), then a page
0:      * is always sorted in record id order.  For instance current heap tables 
0:      * function this way.  If the client ever inserts at a particular slot 
0:      * number, rather than at the "end" then the record id's will not be sorted.
0:      * <BR>
0:      * In the case where all record id's are always sorted on a page, then this
0:      * routine can be used by scan's which "lose" their position because the 
0:      * row they have as a position was purged.  They can reposition their scan 
0:      * at the "next" row after the row that is now missing from the table.
0:      * <BR>
0:      * This method returns the record regardless of its deleted status.
0:      * <BR>
0:      * MT - latched
0:      * 
0:      * @param handle record handle to find the next higher id.
0:      *
0:      * @return  record id of the first record on the page with a record id 
0:      *          higher than the one passed in.  If no such record exists, 
0:      *          -1 is returned.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	int getNextSlotNumber(RecordHandle handle) 
0:         throws StandardException;
0: 
0: 	/**
0: 		Insert a record at the specified slot. 
0: 		<P>
0: 	 */
0:     /**
0:      * Insert a record at the specified slot. 
0:      * <p>
0:      * All records that occupy FIRST_SLOT_NUMBER to (slot - 1) are not moved. 
0:      * <BR>
0:      * All records that occupy slot to (recordCount() - 1) are moved up one 
0:      * slot. 
0:      * <BR>
0:      * The new record is inserted at the specified slot. <BR>
0:      * If slot == FIRST_SLOT_NUMBER, then the new record will be inserted at 
0:      * the first slot. <BR>
0:      * If slot == recordCount(), then the record is inserted in a new slot, no
0:      * records are moved. <BR>
0:      *
0:      * If slot is > recordCount() or if slot < FIRST_SLOT_NUMBER, an exception
0:      * will be thrown.
0:      *
0:      * <P><B>Space Policy</B><BR>
0:      * If the row will not fit on a page then:
0:      * <UL>
0:      * <LI> an exception is thrown if the page has no other rows, this is an 
0:      *      indication that the row could never fit on a page in this container.
0:      * <LI> null is returned if there are other rows on the page, this is an 
0:      *      indication that the row can potentially be inserted successfully 
0:      *      onto an empty page.
0:      * </UL>
0:      *
0:      * <P>
0:      * <B>Locking Policy</B>
0:      * <BR>
0:      * Calls the lockRecordForWrite() method of the LockingPolicy object passed
0:      * to the openContainer() call before the record is inserted.
0:      * <BR>
0:      * MT - latched
0:      *
0:      * @param slot          The specified slot
0:      * @param row           The row version of the data
0:      * @param undo          if logical undo may be necessary, a function pointer
0:      *                      to the access code where the logical undo logic 
0:      *                      resides. Null if logical undo is not necessary.
0:      * @param validColumns  a bit map of which columns in the row is valid.  
0:      *                      ValidColumns will not be changed by RawStore.
0:      * @param insertFlag    if INSERT_UNDO_WITH_PURGE set, then the undo of this
0:      *                      insert will purge the row rather than mark it as 
0:      *                      deleted, which is the default bahavior for 
0:      *                      insertAtSlot and insert.
0:      *
0:      * @return A RecordHandle representing the new record, or null if the row 
0:      *         will not fit on a non-empty page.
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException The row cannot fit on the page
0:      *
0:      * @see LogicalUndo
0:      * @see LogicalUndoable
0:      **/
0: 	RecordHandle insertAtSlot(
0:     int                     slot, 
0:     Object[]   row, 
0:     FormatableBitSet                 validColumns, 
0:     LogicalUndo             undo,
0:     byte                    insertFlag, 
0:     int                     overflowThreshold)
0: 		throws StandardException;
0: 
0: 	/**
0: 		Values for insertFlag:
0: 		
0: 	*/
0:     /**
0:      * Values for insertFlag:
0:      * <p>
0:      *
0:      * INSERT_INITIAL			- flag initializer
0:      *
0:      * INSERT_DEFAULT			- default insert behavior, if the record does
0:      *                            not fit on the page where the insert 
0:      *                            operation is called, an error will be 
0:      *                            returned, instead of overflowing the record.
0:      *
0:      * INSERT_UNDO_WITH_PURGE	- if this is set, then the undo of this insert 
0:      *                            will purge the row rather than mark it as 
0:      *                            deleted, which is the default behaviro for 
0:      *                            insertAtSlot and insert.
0:      *
0:      * INSERT_CONDITIONAL		- if this flag is set, then, the overflow is 
0:      *                            conditional.  The record will be overflowed 
0:      *                            only if it exceeds the threshold specified 
0:      *                            by the properties, or the parameter.
0:      *
0:      * INSERT_OVERFLOW			- if this flag is set, then the insert 
0:      *                            operation will overflow the record if it does
0:      *                            not fit on the page.  
0:      *
0:      * INSERT_FOR_SPLIT		    - a record is being updated that causes new 
0:      *                            portions to be inserted *and* the last new 
0:      *                            portion needs to point to an existing portion.
0:      *
0:      * Rules for the insert flags:
0:      * 1. If INSERT_DEFAULT is set, INSERT_CONDITIONAL and INSERT_OVERFLOW 
0:      *    will be ignored
0:      * 2. INSERT_UNDO_WITH_PURGE can be set with any of the other 3 flags.
0:      * 3. If INSERT_OVERFLOW is not set, INSERT_CONDITIONAL will be ignored.  
0:      *    But, it is not necessary to set INSERT_CONDITIONAL when setting 
0:      *    INSERT_OVERFLOW.
0:      * 4. If INSERT_DEFAULT, INSERT_OVERFLOW both are not set, then, default 
0:      *    insert action will be taken, i.e. no overflow will be allowed.
0:      **/
0: 	static final byte INSERT_INITIAL =		   (byte) 0x00;	// init the flag
0: 	static final byte INSERT_DEFAULT =		   (byte) 0x01;	// default flag
0: 	static final byte INSERT_UNDO_WITH_PURGE = (byte) 0x02;	// purge row on undo
0: 	static final byte INSERT_CONDITIONAL =     (byte) 0x04;	// conditional 
0:                                                             // insert
0: 	static final byte INSERT_OVERFLOW =		   (byte) 0x08;	// insert with 
0:                                                             // possible overflow
0: 	static final byte INSERT_FOR_SPLIT =	   (byte) 0x10;	// rawstore only
0: 
0: 
0:     /**
0:      * Fetch a record located in the passed in slot
0:      * <p>
0:      * Fetch a record located in the passed in slot and fill-in the passed in 
0:      * StorebleRow and the Object columns contained within. If row
0:      * is null then the record is locked but is not fetched.
0:      * <BR>
0:      * This interface allows the caller to either return a deleted row or not. 
0:      * If "ignoreDelete" is set to true, fetch the record regardless of whether 
0:      * it is deleted or not (same as above fetchFromSlot).  However, if  
0:      * "ignoreDelete" is set to false and the and the slot correspond to a 
0:      * deleted row, null is returned.
0:      * <BR>
0:      * If a non-null Qualifier list is provided then the qualifier array will 
0:      * be applied to the row and the row will only be returned if the row 
0:      * qualifies, otherwise null will be returned.  Values in the columns of 
0:      * row may or may not be altered while trying to apply the qualifiers, if 
0:      * null is returned the state of the columns is undefined.  If a null 
0:      * Qualifier list is provided then no qualification is applied.
0:      * <BR>
0:      * If a non-null record handle is passed in, it is assumed that the record 
0:      * handle corresponds to the record in the slot.  If record handle is null,
0:      * a record handle will be manufactured and returned if the record is not 
0:      * deleted or if "ignoreDelete" is true.  This parameter is here for the 
0:      * case where the caller have already manufactured the record handle for 
0:      * locking or other purposes so it would make sense for the page to avoid 
0:      * creating a new record handle object if possible.
0:      *
0:      *
0:      * @param rh           the record handle of the row.  If non-null it must 
0:      *                     refer to the same record as the slot.  
0:      * @param slot         the slot number
0:      * @param row          Row to be filled in with information from record.
0:      * @param fetchDesc    A structure to efficiently carry a set of parameters
0:      *                     needed to describe the fetch, these include:
0:      *                     
0:      *                     validColumns - A bit map of which columns in the 
0:      *                     row to be fetched.  ValidColumns will not be 
0:      *                     changed by RawStore.
0:      *
0:      *                     qualifier_list - 
0:      *                     A list of Qualifiers to apply to the row to see if
0:      *                     the row should be returned.
0:      *
0:      *                     An array of qualifiers which restrict whether or not
0:      *                     the row should be returned by the fetch.  Rows for 
0:      *                     which any one of the qualifiers returns false are 
0:      *                     not returned by the fetch. If null, no qualification
0:      *                     is done and the requested columns of the rows are 
0:      *                     returned.  Qualifiers can only reference columns 
0:      *                     which are included in the scanColumnList.  The 
0:      *                     column id that a qualifier returns is the column id
0:      *                     the table, not the column id in the partial row 
0:      *                     being returned.  
0:      *                     qualifier_scratch_space - 
0:      *                     An array of int's that matches the size of the 
0:      *                     row[] array.  Used to process qualifiers, if no
0:      *                     qualifiers are input then array need not be 
0:      *                     input.  Passed in rather than allocated so that
0:      *                     space can be allocated a single time in a scan.
0:      *                     If not passed in then raw store will allocate and
0:      *                     deallocate per call.
0:      *
0:      * @param ignoreDelete if true, return row regardless of whether it is 
0:      *                     deleted or not.  If false, only return non-deleted 
0:      *                     row.
0:      *
0:      * @return A handle to the record.
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      *
0:      * @see LockingPolicy
0:      **/
0: 	public RecordHandle fetchFromSlot(
0:     RecordHandle            rh, 
0:     int                     slot, 
0:     Object[]                row,
0:     FetchDescriptor         fetchDesc,
0:     boolean                 ignoreDelete)
0:         throws StandardException;
0: 
0: 
0: 	/**
0: 		Fetch a single field from a deleted or non-deleted record.
0: 		Fills in the passed in Object column with the field
0: 		identified by fieldid if column is not null, otherwise the record
0: 		is locked but not fetched.
0: 		<BR>
0: 		The fieldId of the first field is 0.
0: 		If the fieldId is >= the number of fields on the record, 
0: 		column is restored to null
0: 		<P>
0: 		<B>Locking Policy</B>
0: 		<BR>
0: 			No locks are obtained. It is up to the caller to obtain the correct locks.
0: 		<BR>
0: 
0: 		It is guaranteed that the page latch is not released by this method
0: 
0: 		@param slot is the slot number
0: 		@param fieldId is the column id
0: 		@param column is to be filled in with information from the record.
0: 		@param forUpdate true if the intention is to update this record, false otherwise.
0: 
0: 		@return the Handle to the record that is locked
0: 
0: 		@exception StandardException	Standard Cloudscape error policy, a 
0:                                         statement level exception is thrown if
0:                                         the slot is not on the page.
0: 
0: 		@see Page#fetchFromSlot
0: 		@see LockingPolicy
0: 	 */
0: 	public RecordHandle fetchFieldFromSlot(
0:     int                 slot, 
0:     int                 fieldId, 
0:     Object column)
0: 		throws StandardException;
0: 
0:     /**
0:      * Test if a record is deleted.
0:      * <p>
0:      *
0:      * <P>
0:      * <B>Locking Policy</B>
0:      * <BR>
0:      * No locks are obtained.
0:      *
0:      * <BR>
0:      * It is guaranteed that the page latch is not released by this method
0:      *
0:      * @param slot slot of record to be tested.
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy, a 
0:      *                              statement level exception is thrown if the 
0:      *                              slot is not on the page.
0:      **/
0: 	public boolean isDeletedAtSlot(int slot)
0: 		 throws StandardException;
0: 
0: 	/**		
0: 		Update a field within the record, replacing its current value with
0: 		the stored representation of newValue. Record is identified by slot.
0: 		If the field does not exist then it is added to the record, but only if
0: 		(fieldId - 1) exists.
0: 
0: 		<BR><B>RESOLVE</B> right now it throws an exception if fieldId is not 
0: 		already on the record, not add the next one as advertised.
0: 
0: 		<P>
0: 		<B>Locking Policy</B>
0: 		<P>
0: 		Calls the lockRecordForWrite() method of the LockingPolicy object
0: 		passed to the openContainer() call before the record is updated.
0: 
0: 		<BR>
0: 		It is guaranteed that the page latch is not released by this method
0: 		
0: 
0: 		@param slot is the slot number
0: 		@param fieldId is the column id
0: 		@param newValue has the new colum value to be stored in the record
0: 		@param undo if logical undo may be necessary, a function pointer to the
0: 		access code where the logical undo logic resides. Null if logical undo
0: 		is not necessary.
0: 
0: 		@return a Handle to the updated record.
0: 
0: 		@exception StandardException	Standard Cloudscape error policy, a
0:                                         statement level exception is thrown if
0: 		                                the slot is not on the page, or if the 
0:                                         record is deleted, or if the fieldId 
0:                                         is not on the record and (fieldId - 1)
0:                                         does not exist.
0: 
0: 		@exception StandardException 
0: 		The container was not opened in update mode.
0: 
0: 		@see LockingPolicy
0: 		@see LogicalUndo
0: 		@see LogicalUndoable
0: 
0: 	*/
0: 	public RecordHandle updateFieldAtSlot(
0:     int                 slot, 
0:     int                 fieldId, 
0:     Object newValue, 
0:     LogicalUndo         undo)
0: 		throws StandardException;
0: 
0: 
0:     /**
0:      * Fetch the number of fields in a record.
0:      * <p>
0:      *
0:      * <P>
0:      * <B>Locking Policy</B>
0:      * <P>
0:      * No locks are obtained.
0:      *
0:      * <BR>
0:      * It is guaranteed that the page latch is not released by this method
0:      *
0:      * @param slot is the slot number
0:      *
0:      * @return the number of fields in the record
0:      *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      **/
0: 	public int fetchNumFieldsAtSlot(int slot)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Mark the record identified by slot as deleted or undeleted according to the
0: 		delete flag.
0: 
0: 
0: 	*/
0:     /**
0:      * Mark the record at slot as deleted or undeleted according to delete flag.
0:      * <p>
0:      *
0:      * <P>
0:      * <B>Locking Policy</B>
0:      * <P>
0:      * Calls the lockRecordForWrite() method of the LockingPolicy object passed
0:      * to the openContainer() call before the record is deleted.  If record 
0:      * already deleted, and an attempt is made to delete it, an exception is 
0:      * thrown.  If record not deleted, and an attempt is made to undelete it, 
0:      * an exception is thrown.
0:      *
0:      * <BR>
0:      * MT - latched
0:      *
0:      * @return a Handle to the deleted/undeleted record.
0:      *
0:      * @param slot      is the slot number
0:      * @param delete    true if this record is to be deleted false if this 
0:      *                  deleted record is to be marked undeleted
0:      * @param undo      if logical undo may be necessary, a function pointer to
0:      *                  the access code where the logical undo logic resides.
0:      *                  Null if logical undo is not necessary.
0:      * 
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @exception StandardException The container was not opened in update mode.
0:      * @exception StandardException A statement level exception is thrown when 
0:      *                              trying to delete an already deleted record,
0:      *                              or undelete a not deleted record.
0:      *
0:      * @exception StandardException A statement level exception is thrown if 
0:      *                              the slot is not on the page.
0:      *
0:      * @see LockingPolicy
0:      * @see Page#delete
0:      * @see LogicalUndo
0:      * @see LogicalUndoable
0:      *
0:      **/
0: 	public RecordHandle deleteAtSlot(
0:     int         slot, 
0:     boolean     delete, 
0:     LogicalUndo undo)
0: 		 throws StandardException;
0: 
0: 
0:     /**
0:      * Purge the row(s) from page.
0:      * <p>
0:      * Purge the row(s) from page, get rid of the row(s) and slot(s) - 
0:      * <B>USE WITH CAUTION</B>, 
0:      * please see entire description of this operation before attempting to 
0:      * use this.
0:      *
0:      * Starting from the specified slot, n rows will be purged. That is, rows 
0:      * that occupies from slot to slot+n-1 will be purged from the page.
0:      *
0:      * <P>
0:      * <B>Locking Policy</B>
0:      * <P>
0:      * Calls the lockRecordForWrite() method of the LockingPolicy object passed
0:      * to the openContainer() call before the records are purged.
0:      * <P>
0:      *
0:      * <B>NOTE : CAVEAT</B><BR>
0:      * This operation will physically get rid of the row from the page, so if a
0:      * subsequent operation on this page uses a slot that has been purged, then
0:      * the undo of this operation will fail.  It is only safe to use this 
0:      * operation if the caller knows that it has exclusive access to the page 
0:      * for the duration of the transaction, i.e, effectively holding a page 
0:      * lock on the page
0:      * <P>
0:      * <B>NOTE</B><BR>
0:      * Outstanding handles to purged rows are no longer valid, accessing them 
0:      * will cause an exception to be thrown.
0:      *
0:      * <BR>
0: 	 *<B>NOTE : Data Logging for Purges</B><BR>
0: 	 * @param needDataLogged is used to specify whether data is required to be
0: 	 * logged for purge operatios. Data Logging is required 
0: 	 * Only if the row can be reused or required for key search if a purge is
0: 	 * rolled back;(rollback can occur if the system crashes in the middle of
0: 	 * purges or some unexpected error condiditions  rolled back.
0: 	 * For example: 
0: 	 * 1)Btree expects the data to be there if a purge is rolled back;needDataLogged=true
0: 	 * 2)Heaps does not care if data exist because only operation that can occur
0: 	 * on a row whose purge rolled back is purging again.(needDataLogged=false)
0: 	 * 
0:      * MT - latched
0:      *
0:      *
0:      * @param slot	    the starting slot number
0:      * @param numpurges	number of slots to purge. 
0:      *                  If <= 0, just returns as a no-op.
0: 	 * @param needDataLogged  if set to true data is logged for purges else only headers.
0: 	 *
0:      * @exception StandardException	Standard Cloudscape error policy
0:      * @see LockingPolicy
0:      **/
0: 	public void purgeAtSlot(
0:     int slot, 
0:     int n,
0: 	boolean needDataLogged) throws StandardException;
0: 
0: 
0:     /**
0:      * move rows from one page to another, purging in the process.
0:      * <p>
0:      *
0:      * Move from this page slot[src_slot] to slot[src_slot+num_rows-1] to 
0:      * destPage slot[dest_slot] to slot[dest_slot + num_rows - 1], in that 
0:      * order. Both this page and destPage must be latched and from the same 
0:      * container with the same page and record format.
0:      *
0:      * <BR>Slot[src_slot] to slot[src_slot+numrows-1] will be purged from this 
0:      * page.  RecordId on the dest page will be brand new and not in any 
0:      * particular order or range.  RecordId of the purged rows in this page is 
0:      * never reused.  Deleted and undeleted rows are copied over just the same.
0:      *
0:      * Exception will be thrown if this page does not have all the rows in the 
0:      * moved over range.  
0:      *
0:      * <BR><B>RESOLVE: reserve space now not copied over because in btree, a
0:      * row never shrinks.  When this routine is called by heap or by some page
0:      * which will have shrunken row, then we need to add that </B>
0:      *
0:      * <BR>DestPage must have at least dest_slot row occupying slot[0] to
0:      * slot[dest_slot-1].  DestPage must have enough space to take the copied
0:      * over data.  Rows that occupied slot number > dest_slot will be moved up
0:      * the slot (I.e., slot[dest_slot] -> slot[dest_slot + num_rows]).  
0:      *
0:      * <BR>If this operation rolls back, this page (the src page) will get the
0:      * rows back and the dest page will purge the rows that were copied - this
0:      * is as if the rows were inserted into the dest page with 
0:      * INSERT_UNDO_WITH_PURGE.
0:      *
0:      * <P>
0:      * <B>Locking Policy</B>
0:      * <P>
0:      * Calls the lockRecordForWrite() method of the LockingPolicy object
0:      * passed to the openContainer() call before the rows are copied over and 
0:      * bore the records are purged.  I.e, for num_rows moved, there will be
0:      * 2*num_rows calls to lockRecordForWrite.
0:      * <P>
0:      *
0:      * <P><B>Use with caution</B>
0:      * <BR>As with a normal purge, no space is reserved on this page for 
0:      * rollback of the purge, so you must commit before inserting any rows 
0:      * onto this page - unless those inserts are INSERT_UNDO_WITH_PURGE.
0:      *
0:      * @param destPage the page to copy to
0:      * @param src_slot start copying from this slot
0:      * @param num_rows copy and purge this many rows from this page
0:      * @param dest_slot copying into this slot of destPage
0:      *
0:      * @exception StandardException Standard Cloudscape error policy
0:      **/
0: 	public void copyAndPurge(
0:     Page    destPage, 
0:     int     src_slot, 
0:     int     num_rows, 
0:     int     dest_slot)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Update the complete record identified by the slot.
0: 
0: 		<P>
0: 		<B>Locking Policy</B>
0: 		<P>
0: 		Calls the lockRecordForWrite() method of the LockingPolicy object
0: 		passed to the openContainer() call before the record is undeleted.
0: 		If record already deleted, an exception is thrown.
0: 
0: 		<BR>
0: 		It is guaranteed that the page latch is not released by this method
0: 
0: 		@return a Handle to the updated record.
0: 		@param slot is the slot number
0: 		@param validColumns a bit map of which columns in the row is valid.
0: 		ValidColumns will not be changed by RawStore.
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 		@exception StandardException The container was not opened in update mode.
0: 		@exception StandardException if the slot is not on the page.
0: 
0: 		@see Page#update
0: 	*/
0: 	RecordHandle updateAtSlot(
0:     int                     slot, 
0:     Object[]   row, 
0:     FormatableBitSet                 validColumns)
0: 		throws StandardException;
0: 
0: 	/*
0: 		Page operations
0: 	*/
0: 
0: 	/**
0: 		Unlatch me, the page is exclusivly latched by its current user until
0: 		this method call is made.
0: 		<BR>
0: 		After using this method the caller must throw away the
0: 		reference to the Page object, e.g.
0: 		<PRE>
0: 			ref.unlatch();
0: 			ref = null;
0: 		</PRE>
0: 		<BR>
0: 		The page will be released automatically at the close of the
0: 		container if this method is not called explictly.
0: 
0: 		<BR>
0: 		MT - latched
0: 
0: 	*/
0: 	public void unlatch();
0: 
0: 
0: 
0: 	/**
0: 		Return the number of records on the page. The returned count includes rows that are deleted,
0: 		i.e. it is the same as the number of slots on the page.
0: 
0: 		<BR>
0: 		MT - latched
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 	*/
0: 
0: 	public int recordCount() throws StandardException;
0: 
0: 	/**
0: 		Return the number of records on this page that are <B> not </B> marked as deleted.
0: 		
0: 		 <BR>
0: 		MT - latched
0: 
0: 		@exception StandardException	Standard Cloudscape error policy
0: 	*/
0: 
0: 	public int nonDeletedRecordCount() throws StandardException;
0: 
0: 	/**
0: 	  Set the aux object for this page.
0: 	  To clear the auxObject in the page, pass in a null AuxObject.
0: 	  If the AuxObject has already been set, this method will
0: 	  call auxObjectInvalidated() on the old aux objkect and replace it with aux.
0: 
0: 		<BR>
0: 		MT - latched
0: 
0: 	  @see AuxObject
0: 	**/
0: 	public void setAuxObject(AuxObject aux);
0: 
0: 	/**
0: 	  Retrieve this page's aux object, returning null if there isn't one. The reference returned
0: 	  must only be used while the page is latched, once unlatch is called the reference to the
0: 	  aux object must be discarded.
0: 
0: 		<BR> MT - latched
0: 
0: 	  @see AuxObject
0: 	**/
0: 	public AuxObject getAuxObject();
0: 
0: 	/**
0: 		Returns true if the page is latched. Only intended to be used as a Sanity check. Callers must
0: 		discard Page references once unlatch is called.
0: 
0: 		<BR>
0: 		MT - latched
0: 	*/
0: 
0: 
0: 	/*
0: 	 * time stamp - for those implmentation that supports it
0: 	 */
0: 
0: 	/**
0: 		Set the time stamp to what is on page at this instance.  No op if this
0: 		page does not support time stamp.
0: 
0: 		@exception StandardException Standard Cloudscape error policy.
0: 	*/
0: 	void setTimeStamp(PageTimeStamp ts) throws StandardException;
0: 
0: 
0: 	/**
0: 		Return a time stamp that can be used to identify the page of this
0: 		specific instance.  For pages that don't support timestamp, returns
0: 		null.
0: 	*/
0: 	PageTimeStamp currentTimeStamp();
0: 
0: 	/**
0: 		See if timeStamp for this page is the same as the current
0: 		instance of the page.  Null timeStamp never equals the instance of the
0: 		page.
0: 
0: 		@param ts the time stamp gotten from an earlier call to this page's
0: 		getTimeStamp
0: 		@return true if timestamp is the same
0: 		@exception StandardException Standard Cloudscape error policy.
0: 
0: 		@see PageTimeStamp
0: 	*/
0: 	boolean equalTimeStamp(PageTimeStamp ts) throws StandardException;
0: 
0: 	public boolean isLatched();
0: 
0:     public static final String DIAG_PAGE_SIZE        = "pageSize";
0:     public static final String DIAG_RESERVED_SPACE   = "reserveSpace";
0:     public static final String DIAG_MINIMUM_REC_SIZE = "minRecSize";
0:     public static final String DIAG_BYTES_FREE       = "bytesFree";
0:     public static final String DIAG_BYTES_RESERVED   = "bytesReserved";
0:     public static final String DIAG_NUMOVERFLOWED    = "numOverFlowed";
0:     public static final String DIAG_ROWSIZE          = "rowSize";
0:     public static final String DIAG_MINROWSIZE       = "minRowSize";
0:     public static final String DIAG_MAXROWSIZE       = "maxRowSize";
0:     public static final String DIAG_PAGEOVERHEAD     = "pageOverhead";
0:     public static final String DIAG_SLOTTABLE_SIZE   = "slotTableSize";
0: }
============================================================================