1:de51906: /**
1:de51906:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.NestedWhereSubqueryTest
1:de51906:  *  
1:de51906:  * Licensed to the Apache Software Foundation (ASF) under one
1:de51906:  * or more contributor license agreements.  See the NOTICE file
1:de51906:  * distributed with this work for additional information
1:de51906:  * regarding copyright ownership.  The ASF licenses this file
1:de51906:  * to you under the Apache License, Version 2.0 (the
1:de51906:  * "License"); you may not use this file except in compliance
1:de51906:  * with the License.  You may obtain a copy of the License at
1:de51906:  *
1:de51906:  *   http://www.apache.org/licenses/LICENSE-2.0
1:de51906:  *
1:de51906:  * Unless required by applicable law or agreed to in writing,
1:de51906:  * software distributed under the License is distributed on an
1:de51906:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:de51906:  * KIND, either express or implied.  See the License for the
1:de51906:  * specific language governing permissions and limitations
1:de51906:  * under the License.
1:de51906:  */
1:de51906: package org.apache.derbyTesting.functionTests.tests.lang;
1:de51906: 
1:de51906: import java.sql.ResultSet;
1:de51906: import java.sql.SQLException;
1:de51906: import java.sql.Statement;
1:de51906: 
1:de51906: import junit.framework.Test;
1:de51906: 
1:de51906: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:de51906: import org.apache.derbyTesting.junit.JDBC;
1:de51906: import org.apache.derbyTesting.junit.TestConfiguration;
1:de51906: 
1:de51906: /**
1:de51906:  * Nested WHERE subquery tests. Tests nested WHERE EXISTS | ANY | IN functionality.
1:de51906:  *
1:de51906:  * Please refer to DERBY-3301 for more details.
1:de51906:  */
1:de51906: public class NestedWhereSubqueryTest extends BaseJDBCTestCase {
1:de51906: 
1:de51906: 	public NestedWhereSubqueryTest(String name) {
1:de51906: 		super(name);
1:de51906: 	}
1:de51906: 
1:de51906: 	/**
1:de51906: 	 * Main test body
1:de51906: 	 * 
1:de51906: 	 * @throws SQLException
1:de51906: 	 */
1:de51906: 	public void testBasicOperations()
1:de51906: 		throws SQLException {
1:de51906: 		Statement s = createStatement();
1:de51906: 
1:de51906: 		/*
1:de51906: 		 * Create tables needed for DERBY-3301 regression test
1:de51906: 		 */
1:de51906: 		StringBuffer sb = new StringBuffer();
1:de51906: 		sb.append("CREATE TABLE departments ( ");
1:de51906: 		sb.append("ID INTEGER NOT NULL, ");
1:de51906: 		sb.append("NAME VARCHAR(32) NOT NULL, ");
1:de51906: 		sb.append("COMPANYID INTEGER, ");
1:de51906: 		sb.append("CONSTRAINT DEPTS_PK PRIMARY KEY (ID) ");
1:de51906: 		sb.append(")");
1:de51906: 		s.executeUpdate(sb.toString());
1:de51906: 
1:de51906: 		sb = new StringBuffer();
1:de51906: 		sb.append("CREATE TABLE employees ( ");
1:de51906: 		sb.append("EMPID INTEGER NOT NULL, ");
1:de51906: 		sb.append("FIRSTNAME VARCHAR(32) NOT NULL, ");
1:de51906: 		sb.append("DEPARTMENT INTEGER, ");
1:de51906: 		sb.append("CONSTRAINT PERS_DEPT_FK FOREIGN KEY (DEPARTMENT) REFERENCES departments, ");
1:de51906: 		sb.append("CONSTRAINT EMPS_PK PRIMARY KEY (EMPID) ");
1:de51906: 		sb.append(")");
1:de51906: 		s.executeUpdate(sb.toString());
1:de51906: 
1:de51906: 		sb = new StringBuffer();
1:de51906: 		sb.append("CREATE TABLE projects ( ");
1:de51906: 		sb.append("PROJID INTEGER NOT NULL, ");
1:de51906: 		sb.append("NAME VARCHAR(32) NOT NULL, ");
1:de51906: 		sb.append("CONSTRAINT PROJS_PK PRIMARY KEY (PROJID) ");
1:de51906: 		sb.append(")");
1:de51906: 		s.executeUpdate(sb.toString());
1:de51906: 
1:de51906: 		sb = new StringBuffer();
1:de51906: 		sb.append("CREATE TABLE project_employees ( ");
1:de51906: 		sb.append("PROJID INTEGER REFERENCES projects NOT NULL, ");
1:de51906: 		sb.append("EMPID INTEGER REFERENCES employees NOT NULL ");
1:de51906: 		sb.append(")");
1:de51906: 		s.executeUpdate(sb.toString());
1:de51906: 
1:de51906: 		/*
1:de51906: 		 * Fill some data into the tables
1:de51906: 		 */
1:de51906: 		s.executeUpdate("INSERT INTO departments VALUES (1, 'Research', 1)");
1:de51906: 		s.executeUpdate("INSERT INTO departments VALUES (2, 'Marketing', 1)");
1:de51906: 
1:de51906: 		s.executeUpdate("INSERT INTO employees VALUES (11, 'Alex', 1)");
1:de51906: 		s.executeUpdate("INSERT INTO employees VALUES (12, 'Bill', 1)");
1:de51906: 		s.executeUpdate("INSERT INTO employees VALUES (13, 'Charles', 1)");
1:de51906: 		s.executeUpdate("INSERT INTO employees VALUES (14, 'David', 2)");
1:de51906: 		s.executeUpdate("INSERT INTO employees VALUES (15, 'Earl', 2)");
1:de51906: 
1:de51906: 		s.executeUpdate("INSERT INTO projects VALUES (101, 'red')");
1:de51906: 		s.executeUpdate("INSERT INTO projects VALUES (102, 'orange')");
1:de51906: 		s.executeUpdate("INSERT INTO projects VALUES (103, 'yellow')");
1:de51906: 
1:de51906: 		s.executeUpdate("INSERT INTO project_employees VALUES (102, 13)");
1:de51906: 		s.executeUpdate("INSERT INTO project_employees VALUES (101, 13)");
1:de51906: 		s.executeUpdate("INSERT INTO project_employees VALUES (102, 12)");
1:de51906: 		s.executeUpdate("INSERT INTO project_employees VALUES (103, 15)");
1:de51906: 		s.executeUpdate("INSERT INTO project_employees VALUES (103, 14)");
1:de51906: 		s.executeUpdate("INSERT INTO project_employees VALUES (101, 12)");
1:de51906: 		s.executeUpdate("INSERT INTO project_employees VALUES (101, 11)");
1:de51906: 
1:de51906: 		/*
1:de51906: 		 * Preliminary data check
1:de51906: 		 */
1:de51906: 		ResultSet rs = s.executeQuery("select * from employees");
1:de51906: 		String[][] expectedRows = {{"11", "Alex", "1"},
1:de51906: 									{"12", "Bill", "1"},
1:de51906: 									{"13", "Charles", "1"},
1:de51906: 									{"14", "David", "2"},
1:de51906: 									{"15", "Earl", "2"}};		
1:de51906: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:de51906: 
1:de51906: 		rs = s.executeQuery("select * from departments");
1:de51906: 		expectedRows = new String [][] {{"1", "Research", "1"},
1:de51906: 										{"2","Marketing","1"}};		
1:de51906: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:de51906: 
1:de51906: 		rs = s.executeQuery("select * from projects");
1:de51906: 		expectedRows = new String [][] {{"101","red"},
1:de51906: 										{"102","orange"},
1:de51906: 										{"103","yellow"}};		
1:de51906: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:de51906: 
1:de51906: 		rs = s.executeQuery("select * from project_employees");
1:de51906: 		expectedRows = new String [][] {{"102","13"},
1:de51906: 										{"101","13"},
1:de51906: 										{"102","12"},
1:de51906: 										{"103","15"},
1:de51906: 										{"103","14"},
1:de51906: 										{"101","12"},
1:de51906: 										{"101","11"}};		
1:de51906: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:de51906: 
1:de51906: 		/*
1:de51906: 		 * DERBY-3301: This query should return 7 rows
1:de51906: 		 */
1:de51906: 		sb = new StringBuffer();
1:de51906: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1:de51906: 		sb.append("from departments this, ");
1:de51906: 		sb.append("     employees unbound_e, ");
1:de51906: 		sb.append("     projects unbound_p ");
1:de51906: 		sb.append("where exists ( ");
1:de51906: 		sb.append("  select 1 from employees this_employees_e ");
1:de51906: 		sb.append("  where exists ( ");
1:de51906: 		sb.append("    select 1 from project_employees this_employees_e_projects_p ");
1:de51906: 		sb.append("    where this_employees_e_projects_p.empid = this_employees_e.empid ");
1:de51906: 		sb.append("    and this_employees_e.department = this.id ");
1:de51906: 		sb.append("    and unbound_p.projid = this_employees_e_projects_p.projid ");
1:de51906: 		sb.append("    and unbound_e.empid = this_employees_e.empid) ");
1:de51906: 		sb.append(" )");
1:de51906: 
1:de51906: 		rs = s.executeQuery(sb.toString());
1:de51906: 		expectedRows = new String [][] {{"13", "101"},
1:de51906: 										{"12", "101"},
1:de51906: 										{"11", "101"},
1:de51906: 										{"13", "102"},
1:de51906: 										{"12", "102"},
1:de51906: 										{"15", "103"},
1:de51906: 										{"14", "103"}};
1:de51906: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:de51906: 		
1:de51906: 		/* A variation of the above WHERE EXISTS but using IN should return the same rows */
1:de51906: 		sb = new StringBuffer();
1:de51906: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1:de51906: 		sb.append("from departments this, ");
1:de51906: 		sb.append("     employees unbound_e, ");
1:de51906: 		sb.append("     projects unbound_p ");
1:de51906: 		sb.append("where exists ( "); 
1:de51906: 		sb.append(" select 1 from employees this_employees_e ");
1:de51906: 		sb.append("     where this_employees_e.empid in ( ");
1:de51906: 		sb.append("         select this_employees_e_projects_p.empid ");
1:de51906: 		sb.append("           from project_employees this_employees_e_projects_p ");
1:de51906: 		sb.append("         where this_employees_e_projects_p.empid = this_employees_e.empid ");
1:de51906: 		sb.append("         and this_employees_e.department = this.id ");
1:de51906: 		sb.append("         and unbound_p.projid = this_employees_e_projects_p.projid ");
1:de51906: 		sb.append("         and unbound_e.empid = this_employees_e.empid) ");
1:de51906: 		sb.append("     )");
1:de51906: 
1:de51906: 		rs = s.executeQuery(sb.toString());
1:de51906: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:de51906: 
1:cd8df94: 		/* A variation of the above WHERE EXISTS but using ANY should return the same rows */
1:cd8df94: 		sb = new StringBuffer();
1:cd8df94: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1:cd8df94: 		sb.append("from departments this, ");
1:cd8df94: 		sb.append("     employees unbound_e, ");
1:cd8df94: 		sb.append("     projects unbound_p ");
1:cd8df94: 		sb.append("where exists ( "); 
1:cd8df94: 		sb.append(" select 1 from employees this_employees_e ");
1:cd8df94: 		sb.append("     where this_employees_e.empid = any ( ");
1:cd8df94: 		sb.append("         select this_employees_e_projects_p.empid ");
1:cd8df94: 		sb.append("           from project_employees this_employees_e_projects_p ");
1:cd8df94: 		sb.append("         where this_employees_e_projects_p.empid = this_employees_e.empid ");
1:cd8df94: 		sb.append("         and this_employees_e.department = this.id ");
1:cd8df94: 		sb.append("         and unbound_p.projid = this_employees_e_projects_p.projid ");
1:cd8df94: 		sb.append("         and unbound_e.empid = this_employees_e.empid) ");
1:cd8df94: 		sb.append("     )");
1:cd8df94: 
1:cd8df94: 		rs = s.executeQuery(sb.toString());
1:cd8df94: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:cd8df94: 
1:cd8df94: 		/* 
1:cd8df94: 		 * The next 5 queries were also found problematic as part DERBY-3301 
1:cd8df94: 		 */
1:cd8df94: 		sb = new StringBuffer();
1:cd8df94: 		sb.append("select unbound_e.empid from departments this, employees unbound_e ");
1:cd8df94: 		sb.append("where exists ( ");
1:cd8df94: 		sb.append("   select 1 from employees this_employees_e ");
1:cd8df94: 		sb.append("      where this_employees_e.department = this.id and ");
1:cd8df94: 		sb.append("            unbound_e.empid = this_employees_e.empid and this.id = 2)");
1:cd8df94: 
1:cd8df94: 		rs = s.executeQuery(sb.toString());		
1:cd8df94: 		expectedRows = new String [][] {{"14"},{"15"}};		
1:cd8df94: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:cd8df94: 		
1:cd8df94: 		sb = new StringBuffer();
1:cd8df94: 		sb.append("select this.id,unbound_e.empid,unbound_p.projid from departments this, ");
1:cd8df94: 		sb.append("        employees unbound_e, projects unbound_p ");
1:cd8df94: 		sb.append("where exists ( ");
1:cd8df94: 		sb.append("   select 1 from employees this_employees_e ");
1:cd8df94: 		sb.append("   where exists ( ");
1:cd8df94: 		sb.append("      select 1 from project_employees this_employees_e_projects_p ");
1:cd8df94: 		sb.append("      where this_employees_e_projects_p.\"EMPID\" = this_employees_e.empid and ");
1:cd8df94: 		sb.append("         unbound_p.projid = this_employees_e_projects_p.projid and ");
1:cd8df94: 		sb.append("         this_employees_e.department = this.id and ");
1:cd8df94: 		sb.append("         unbound_e.empid = this_employees_e.empid ");
1:cd8df94: 		sb.append(" )) ");		
1:cd8df94: 		
1:cd8df94: 		rs = s.executeQuery(sb.toString());
1:cd8df94: 		expectedRows = new String [][] {{"1","11","101"},
1:cd8df94: 										{"1","12","101"},
1:cd8df94: 										{"1","13","101"},
1:cd8df94: 										{"1","12","102"},
1:cd8df94: 										{"1","13","102"},
1:cd8df94: 										{"2","14","103"},
1:cd8df94: 										{"2","15","103"}};
1:cd8df94: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:cd8df94: 		
1:cd8df94: 		sb = new StringBuffer();
1:cd8df94: 		sb.append("select unbound_e.empid,unbound_p.projid from departments this, ");
1:cd8df94: 		sb.append("       employees unbound_e, projects unbound_p ");
1:cd8df94: 		sb.append("where exists ( ");
1:cd8df94: 		sb.append("   select 1 from employees this_employees_e ");
1:cd8df94: 		sb.append("   where exists ( ");
1:cd8df94: 		sb.append("      select 1 from project_employees this_employees_e_projects_p ");
1:cd8df94: 		sb.append("      where this_employees_e_projects_p.\"EMPID\" = this_employees_e.empid ");
1:cd8df94: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1:cd8df94: 		sb.append("            and this_employees_e.department = this.id ");
1:cd8df94: 		sb.append("            and unbound_e.empid = this_employees_e.empid ");
1:cd8df94: 		sb.append("            and this.id = 1)) ");
1:cd8df94: 		
1:cd8df94: 		rs = s.executeQuery(sb.toString());
1:cd8df94: 		expectedRows = new String [][] {{"11","101"},
1:cd8df94: 										{"12","101"},
1:cd8df94: 										{"13","101"},
1:cd8df94: 										{"12","102"},
1:cd8df94: 										{"13","102"}};
1:cd8df94: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:cd8df94: 		
1:cd8df94: 		sb = new StringBuffer();
1:cd8df94: 		sb.append("select unbound_e.empid,unbound_p.projid from departments this, ");
1:cd8df94: 		sb.append("       employees unbound_e, projects unbound_p ");
1:cd8df94: 		sb.append("where exists ( ");
1:cd8df94: 		sb.append("   select 1 from employees this_employees_e ");
1:cd8df94: 		sb.append("   where exists ( ");
1:cd8df94: 		sb.append("      select 1 from project_employees this_employees_e_projects_p ");
1:cd8df94: 		sb.append("      where this_employees_e_projects_p.\"EMPID\" = this_employees_e.empid ");
1:cd8df94: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1:cd8df94: 		sb.append("            and this_employees_e.department = this.id ");
1:cd8df94: 		sb.append("            and unbound_e.empid = this_employees_e.empid ");
1:cd8df94: 		sb.append("            and this.companyid = 1))");
1:cd8df94: 		
1:cd8df94: 		rs = s.executeQuery(sb.toString());
1:cd8df94: 		expectedRows = new String [][] {{"11","101"},
1:cd8df94: 										{"12","101"},
1:cd8df94: 										{"13","101"},
1:cd8df94: 										{"12","102"},
1:cd8df94: 										{"13","102"},
1:cd8df94: 										{"14","103"},
1:cd8df94: 										{"15","103"}};
1:cd8df94: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:cd8df94: 		
1:cd8df94: 		sb = new StringBuffer();
1:cd8df94: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1:cd8df94: 		sb.append("from departments this, ");
1:cd8df94: 		sb.append("     employees unbound_e, ");
1:cd8df94: 		sb.append("     projects unbound_p ");
1:cd8df94: 		sb.append("where exists ( ");
1:cd8df94: 		sb.append("   select 1 from employees this_employees_e ");
1:cd8df94: 		sb.append("   where 1 = 1 and exists ( ");
1:cd8df94: 		sb.append("      select 1 from project_employees this_employees_e_projects_p ");
1:cd8df94: 		sb.append("      where this_employees_e_projects_p.empid = this_employees_e.empid ");
1:cd8df94: 		sb.append("            and this_employees_e.department = this.id ");
1:cd8df94: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1:cd8df94: 		sb.append("            and unbound_e.empid = this_employees_e.empid) ");
1:cd8df94: 		sb.append(")");
1:cd8df94: 
1:cd8df94: 		rs = s.executeQuery(sb.toString());
1:cd8df94: 		expectedRows = new String [][] {{"11","101"},
1:cd8df94: 										{"12","101"},
1:cd8df94: 										{"13","101"},
1:cd8df94: 										{"12","102"},
1:cd8df94: 										{"13","102"},
1:cd8df94: 										{"14","103"},
1:cd8df94: 										{"15","103"}};  
1:cd8df94: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:cd8df94: 		
1:cd8df94: 		/* Variation of the above using WHERE IN ... WHERE IN */
1:cd8df94: 		sb = new StringBuffer();
1:cd8df94: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1:cd8df94: 		sb.append("from departments this, employees unbound_e, projects unbound_p ");
1:cd8df94: 		sb.append("where this.id in ( ");
1:cd8df94: 		sb.append("   select this_employees_e.department from employees this_employees_e ");
1:cd8df94: 		sb.append("   where this_employees_e.empid in ( ");
1:cd8df94: 		sb.append("      select this_employees_e_projects_p.empid ");
1:cd8df94: 		sb.append("      from project_employees this_employees_e_projects_p ");
1:cd8df94: 		sb.append("      where this_employees_e_projects_p.empid = this_employees_e.empid ");
1:cd8df94: 		sb.append("            and this_employees_e.department = this.id ");
1:cd8df94: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1:cd8df94: 		sb.append("            and unbound_e.empid = this_employees_e.empid)");
1:cd8df94: 		sb.append(")");
1:cd8df94: 		
1:cd8df94: 		rs = s.executeQuery(sb.toString());
1:cd8df94: 		/* Expected rows are as above */
1:cd8df94: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:cd8df94: 
1:cd8df94: 		/* Variation of the above using WHERE ANY ... WHERE ANY */
1:cd8df94: 		sb = new StringBuffer();
1:cd8df94: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1:cd8df94: 		sb.append("from departments this, employees unbound_e, projects unbound_p ");
1:cd8df94: 		sb.append("where this.id = any ( ");
1:cd8df94: 		sb.append("   select this_employees_e.department from employees this_employees_e ");
1:cd8df94: 		sb.append("   where this_employees_e.empid = any ( ");
1:cd8df94: 		sb.append("      select this_employees_e_projects_p.empid ");
1:cd8df94: 		sb.append("      from project_employees this_employees_e_projects_p ");
1:cd8df94: 		sb.append("      where this_employees_e_projects_p.empid = this_employees_e.empid ");
1:cd8df94: 		sb.append("            and this_employees_e.department = this.id ");
1:cd8df94: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1:cd8df94: 		sb.append("            and unbound_e.empid = this_employees_e.empid)");
1:cd8df94: 		sb.append(")");
1:cd8df94: 		
1:cd8df94: 		rs = s.executeQuery(sb.toString());
1:cd8df94: 		/* Expected rows are as above */
1:cd8df94: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1:cd8df94: 		
1:de51906: 		/*
1:16164d5: 		 * DERBY-3321 revealed an NPE with a subquery in the [NOT] EXIST subuery FromList.
1:16164d5: 		 */
1:16164d5: 		s.executeUpdate("create table a (aa int, bb int)");
1:16164d5: 		s.executeUpdate("create table b (bb int)");
1:16164d5: 		s.executeUpdate("insert into a values (1,1),(1,2),(2,2)");
1:16164d5: 		s.executeUpdate("insert into b values (1)");
1:16164d5: 		
1:16164d5: 		/* NOT EXISTS */
1:16164d5: 		sb = new StringBuffer();
1:16164d5: 		sb.append("select * from a ");
1:16164d5: 		sb.append("where not exists ");
1:16164d5: 		sb.append("(select bb from (select bb from b) p where a.bb=p.bb)");
1:16164d5: 		rs = s.executeQuery(sb.toString());
1:16164d5: 		expectedRows = new String [][] {{"1","2"},		
1:16164d5: 										{"2","2"}};
1:16164d5: 		JDBC.assertUnorderedResultSet(rs, expectedRows);		
1:16164d5: 		
1:16164d5: 		/* EXISTS */
1:16164d5: 		sb = new StringBuffer();
1:16164d5: 		sb.append("select * from a ");
1:16164d5: 		sb.append("where exists ");
1:16164d5: 		sb.append("(select bb from (select bb from b) p where a.bb=p.bb)");
1:16164d5: 		rs = s.executeQuery(sb.toString());
1:16164d5: 		expectedRows = new String [][] {{"1","1"}};										
1:16164d5: 		JDBC.assertUnorderedResultSet(rs, expectedRows);	
1:16164d5: 		
1:16164d5: 		/*
1:de51906: 		 * Clean up the tables used.
1:de51906: 		 */				
1:de51906: 		s.executeUpdate("drop table project_employees");	
1:de51906: 		s.executeUpdate("drop table projects");
1:de51906: 		s.executeUpdate("drop table employees");
1:de51906: 		s.executeUpdate("drop table departments");			
1:de51906: 		
1:16164d5: 		s.executeUpdate("drop table a");	
1:16164d5: 		s.executeUpdate("drop table b");	
1:16164d5: 		
1:de51906: 		s.close();
1:de51906: 	}
1:de51906: 
1:28f8292:     /**
1:28f8292:      * Allow multiple columns in EXISTS subquery. SQL feature T501 "Enhanced
1:28f8292:      * EXISTS predicate".
1:28f8292:      * <p/>
1:28f8292:      * Strictly speaking, this test belongs in a general subquery test class,
1:28f8292:      * but pending conversion of subquery.sql to JUnit, testDerby5501 resides
1:28f8292:      * here (FIXME).
1:28f8292:      */
1:28f8292:     public void testDerby5501 () throws SQLException {
1:28f8292:         setAutoCommit(false);
1:28f8292:         Statement s = createStatement();
1:28f8292: 
1:28f8292:         s.executeUpdate("create table t5501a(i int, j int, primary key(i,j))");
1:28f8292:         s.executeUpdate("create table t5501b(i int)");
1:28f8292: 
1:28f8292:         s.executeUpdate("insert into t5501a values (1,1),(2,2),(3,3),(4,4)");
1:28f8292:         s.executeUpdate("insert into t5501b values 1,3,5");
1:28f8292: 
1:28f8292: 
1:28f8292:         // works before DERBY-5501
1:28f8292:         ResultSet rs = s.executeQuery(
1:28f8292:             "select i from t5501b t1 where not exists " +
1:28f8292:             "    (select i from t5501a t2 where t1.i=t2.i)");
1:28f8292:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"5"}});
1:28f8292: 
1:28f8292:         rs = s.executeQuery(
1:28f8292:             "select i+3.14 from t5501b t1 where not exists " +
1:28f8292:             "    (select i+3.14 from t5501a t2 where t1.i=t2.i)");
1:28f8292:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"8.14"}});
1:28f8292: 
1:28f8292:         // works before DERBY-5501: "*" is specially handled already
1:28f8292:         rs = s.executeQuery(
1:28f8292:             "select i from t5501b t1 where not exists " +
1:28f8292:             "    (select * from t5501a t2 where t1.i=t2.i)");
1:28f8292:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"5"}});
1:28f8292: 
1:28f8292: 
1:28f8292:         // fails before DERBY-5501
1:28f8292:         rs = s.executeQuery(
1:28f8292:             "select i from t5501b t1 where not exists " +
1:28f8292:             "    (select i,j from t5501a t2 where t1.i=t2.i)");
1:28f8292:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"5"}});
1:28f8292: 
1:28f8292:         rs = s.executeQuery(
1:28f8292:             "select i from t5501b t1 where not exists " +
1:28f8292:             "    (select true,j from t5501a t2 where t1.i=t2.i)");
1:28f8292:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"5"}});
1:28f8292: 
1:28f8292:         s.executeUpdate("delete from t5501a where i=1");
1:28f8292:         rs = s.executeQuery(
1:28f8292:             "select i from t5501b t1 where not exists " +
1:28f8292:             "    (select i,j from t5501a t2 where t1.i=t2.i)");
1:28f8292:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"1"}, {"5"}});
1:28f8292: 
1:28f8292:         // should still fail: no column "k" exists
1:28f8292:         assertCompileError(
1:28f8292:             "42X04",
1:28f8292:             "select i from t5501b t1 where not exists " +
1:28f8292:             "    (select i,k from t5501a t2 where t1.i=t2.i)");
1:28f8292: 
1:28f8292:         // should still fail: no table "foo" exists
1:28f8292:         assertCompileError(
1:28f8292:             "42X10",
1:28f8292:             "select i from t5501b t1 where not exists " +
1:28f8292:             "    (select t2.*,foo.* from t5501a t2 where t1.i=t2.i)");
1:28f8292: 
1:28f8292:         // should still fail: illegal integer format in cast
1:28f8292:         assertCompileError(
1:28f8292:             "22018",
1:28f8292:             "select i from t5501b t1 where not exists " +
1:28f8292:             "   (select t2.*,cast('a' as int) from t5501a t2 where t1.i=t2.i)");
1:28f8292:     }
1:28f8292: 
1:28f8292: 
1:28f8292:     public static Test suite() {
1:de51906: 		return TestConfiguration.defaultSuite(NestedWhereSubqueryTest.class);
1:de51906: 	}
1:de51906: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:28f8292
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Allow multiple columns in EXISTS subquery. SQL feature T501 "Enhanced
1:      * EXISTS predicate".
1:      * <p/>
1:      * Strictly speaking, this test belongs in a general subquery test class,
1:      * but pending conversion of subquery.sql to JUnit, testDerby5501 resides
1:      * here (FIXME).
1:      */
1:     public void testDerby5501 () throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1: 
1:         s.executeUpdate("create table t5501a(i int, j int, primary key(i,j))");
1:         s.executeUpdate("create table t5501b(i int)");
1: 
1:         s.executeUpdate("insert into t5501a values (1,1),(2,2),(3,3),(4,4)");
1:         s.executeUpdate("insert into t5501b values 1,3,5");
1: 
1: 
1:         // works before DERBY-5501
1:         ResultSet rs = s.executeQuery(
1:             "select i from t5501b t1 where not exists " +
1:             "    (select i from t5501a t2 where t1.i=t2.i)");
1:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"5"}});
1: 
1:         rs = s.executeQuery(
1:             "select i+3.14 from t5501b t1 where not exists " +
1:             "    (select i+3.14 from t5501a t2 where t1.i=t2.i)");
1:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"8.14"}});
1: 
1:         // works before DERBY-5501: "*" is specially handled already
1:         rs = s.executeQuery(
1:             "select i from t5501b t1 where not exists " +
1:             "    (select * from t5501a t2 where t1.i=t2.i)");
1:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"5"}});
1: 
1: 
1:         // fails before DERBY-5501
1:         rs = s.executeQuery(
1:             "select i from t5501b t1 where not exists " +
1:             "    (select i,j from t5501a t2 where t1.i=t2.i)");
1:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"5"}});
1: 
1:         rs = s.executeQuery(
1:             "select i from t5501b t1 where not exists " +
1:             "    (select true,j from t5501a t2 where t1.i=t2.i)");
1:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"5"}});
1: 
1:         s.executeUpdate("delete from t5501a where i=1");
1:         rs = s.executeQuery(
1:             "select i from t5501b t1 where not exists " +
1:             "    (select i,j from t5501a t2 where t1.i=t2.i)");
1:         JDBC.assertUnorderedResultSet(rs, new String [][] {{"1"}, {"5"}});
1: 
1:         // should still fail: no column "k" exists
1:         assertCompileError(
1:             "42X04",
1:             "select i from t5501b t1 where not exists " +
1:             "    (select i,k from t5501a t2 where t1.i=t2.i)");
1: 
1:         // should still fail: no table "foo" exists
1:         assertCompileError(
1:             "42X10",
1:             "select i from t5501b t1 where not exists " +
1:             "    (select t2.*,foo.* from t5501a t2 where t1.i=t2.i)");
1: 
1:         // should still fail: illegal integer format in cast
1:         assertCompileError(
1:             "22018",
1:             "select i from t5501b t1 where not exists " +
1:             "   (select t2.*,cast('a' as int) from t5501a t2 where t1.i=t2.i)");
1:     }
1: 
1: 
1:     public static Test suite() {
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:16164d5
/////////////////////////////////////////////////////////////////////////
1: 		 * DERBY-3321 revealed an NPE with a subquery in the [NOT] EXIST subuery FromList.
1: 		 */
1: 		s.executeUpdate("create table a (aa int, bb int)");
1: 		s.executeUpdate("create table b (bb int)");
1: 		s.executeUpdate("insert into a values (1,1),(1,2),(2,2)");
1: 		s.executeUpdate("insert into b values (1)");
1: 		
1: 		/* NOT EXISTS */
1: 		sb = new StringBuffer();
1: 		sb.append("select * from a ");
1: 		sb.append("where not exists ");
1: 		sb.append("(select bb from (select bb from b) p where a.bb=p.bb)");
1: 		rs = s.executeQuery(sb.toString());
1: 		expectedRows = new String [][] {{"1","2"},		
1: 										{"2","2"}};
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);		
1: 		
1: 		/* EXISTS */
1: 		sb = new StringBuffer();
1: 		sb.append("select * from a ");
1: 		sb.append("where exists ");
1: 		sb.append("(select bb from (select bb from b) p where a.bb=p.bb)");
1: 		rs = s.executeQuery(sb.toString());
1: 		expectedRows = new String [][] {{"1","1"}};										
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);	
1: 		
1: 		/*
/////////////////////////////////////////////////////////////////////////
1: 		s.executeUpdate("drop table a");	
1: 		s.executeUpdate("drop table b");	
1: 		
commit:cd8df94
/////////////////////////////////////////////////////////////////////////
1: 		/* A variation of the above WHERE EXISTS but using ANY should return the same rows */
1: 		sb = new StringBuffer();
1: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1: 		sb.append("from departments this, ");
1: 		sb.append("     employees unbound_e, ");
1: 		sb.append("     projects unbound_p ");
1: 		sb.append("where exists ( "); 
1: 		sb.append(" select 1 from employees this_employees_e ");
1: 		sb.append("     where this_employees_e.empid = any ( ");
1: 		sb.append("         select this_employees_e_projects_p.empid ");
1: 		sb.append("           from project_employees this_employees_e_projects_p ");
1: 		sb.append("         where this_employees_e_projects_p.empid = this_employees_e.empid ");
1: 		sb.append("         and this_employees_e.department = this.id ");
1: 		sb.append("         and unbound_p.projid = this_employees_e_projects_p.projid ");
1: 		sb.append("         and unbound_e.empid = this_employees_e.empid) ");
1: 		sb.append("     )");
1: 
1: 		rs = s.executeQuery(sb.toString());
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 
1: 		/* 
1: 		 * The next 5 queries were also found problematic as part DERBY-3301 
1: 		 */
1: 		sb = new StringBuffer();
1: 		sb.append("select unbound_e.empid from departments this, employees unbound_e ");
1: 		sb.append("where exists ( ");
1: 		sb.append("   select 1 from employees this_employees_e ");
1: 		sb.append("      where this_employees_e.department = this.id and ");
1: 		sb.append("            unbound_e.empid = this_employees_e.empid and this.id = 2)");
1: 
1: 		rs = s.executeQuery(sb.toString());		
1: 		expectedRows = new String [][] {{"14"},{"15"}};		
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 		
1: 		sb = new StringBuffer();
1: 		sb.append("select this.id,unbound_e.empid,unbound_p.projid from departments this, ");
1: 		sb.append("        employees unbound_e, projects unbound_p ");
1: 		sb.append("where exists ( ");
1: 		sb.append("   select 1 from employees this_employees_e ");
1: 		sb.append("   where exists ( ");
1: 		sb.append("      select 1 from project_employees this_employees_e_projects_p ");
1: 		sb.append("      where this_employees_e_projects_p.\"EMPID\" = this_employees_e.empid and ");
1: 		sb.append("         unbound_p.projid = this_employees_e_projects_p.projid and ");
1: 		sb.append("         this_employees_e.department = this.id and ");
1: 		sb.append("         unbound_e.empid = this_employees_e.empid ");
1: 		sb.append(" )) ");		
1: 		
1: 		rs = s.executeQuery(sb.toString());
1: 		expectedRows = new String [][] {{"1","11","101"},
1: 										{"1","12","101"},
1: 										{"1","13","101"},
1: 										{"1","12","102"},
1: 										{"1","13","102"},
1: 										{"2","14","103"},
1: 										{"2","15","103"}};
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 		
1: 		sb = new StringBuffer();
1: 		sb.append("select unbound_e.empid,unbound_p.projid from departments this, ");
1: 		sb.append("       employees unbound_e, projects unbound_p ");
1: 		sb.append("where exists ( ");
1: 		sb.append("   select 1 from employees this_employees_e ");
1: 		sb.append("   where exists ( ");
1: 		sb.append("      select 1 from project_employees this_employees_e_projects_p ");
1: 		sb.append("      where this_employees_e_projects_p.\"EMPID\" = this_employees_e.empid ");
1: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1: 		sb.append("            and this_employees_e.department = this.id ");
1: 		sb.append("            and unbound_e.empid = this_employees_e.empid ");
1: 		sb.append("            and this.id = 1)) ");
1: 		
1: 		rs = s.executeQuery(sb.toString());
1: 		expectedRows = new String [][] {{"11","101"},
1: 										{"12","101"},
1: 										{"13","101"},
1: 										{"12","102"},
1: 										{"13","102"}};
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 		
1: 		sb = new StringBuffer();
1: 		sb.append("select unbound_e.empid,unbound_p.projid from departments this, ");
1: 		sb.append("       employees unbound_e, projects unbound_p ");
1: 		sb.append("where exists ( ");
1: 		sb.append("   select 1 from employees this_employees_e ");
1: 		sb.append("   where exists ( ");
1: 		sb.append("      select 1 from project_employees this_employees_e_projects_p ");
1: 		sb.append("      where this_employees_e_projects_p.\"EMPID\" = this_employees_e.empid ");
1: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1: 		sb.append("            and this_employees_e.department = this.id ");
1: 		sb.append("            and unbound_e.empid = this_employees_e.empid ");
1: 		sb.append("            and this.companyid = 1))");
1: 		
1: 		rs = s.executeQuery(sb.toString());
1: 		expectedRows = new String [][] {{"11","101"},
1: 										{"12","101"},
1: 										{"13","101"},
1: 										{"12","102"},
1: 										{"13","102"},
1: 										{"14","103"},
1: 										{"15","103"}};
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 		
1: 		sb = new StringBuffer();
1: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1: 		sb.append("from departments this, ");
1: 		sb.append("     employees unbound_e, ");
1: 		sb.append("     projects unbound_p ");
1: 		sb.append("where exists ( ");
1: 		sb.append("   select 1 from employees this_employees_e ");
1: 		sb.append("   where 1 = 1 and exists ( ");
1: 		sb.append("      select 1 from project_employees this_employees_e_projects_p ");
1: 		sb.append("      where this_employees_e_projects_p.empid = this_employees_e.empid ");
1: 		sb.append("            and this_employees_e.department = this.id ");
1: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1: 		sb.append("            and unbound_e.empid = this_employees_e.empid) ");
1: 		sb.append(")");
1: 
1: 		rs = s.executeQuery(sb.toString());
1: 		expectedRows = new String [][] {{"11","101"},
1: 										{"12","101"},
1: 										{"13","101"},
1: 										{"12","102"},
1: 										{"13","102"},
1: 										{"14","103"},
1: 										{"15","103"}};  
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 		
1: 		/* Variation of the above using WHERE IN ... WHERE IN */
1: 		sb = new StringBuffer();
1: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1: 		sb.append("from departments this, employees unbound_e, projects unbound_p ");
1: 		sb.append("where this.id in ( ");
1: 		sb.append("   select this_employees_e.department from employees this_employees_e ");
1: 		sb.append("   where this_employees_e.empid in ( ");
1: 		sb.append("      select this_employees_e_projects_p.empid ");
1: 		sb.append("      from project_employees this_employees_e_projects_p ");
1: 		sb.append("      where this_employees_e_projects_p.empid = this_employees_e.empid ");
1: 		sb.append("            and this_employees_e.department = this.id ");
1: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1: 		sb.append("            and unbound_e.empid = this_employees_e.empid)");
1: 		sb.append(")");
1: 		
1: 		rs = s.executeQuery(sb.toString());
1: 		/* Expected rows are as above */
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 
1: 		/* Variation of the above using WHERE ANY ... WHERE ANY */
1: 		sb = new StringBuffer();
1: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1: 		sb.append("from departments this, employees unbound_e, projects unbound_p ");
1: 		sb.append("where this.id = any ( ");
1: 		sb.append("   select this_employees_e.department from employees this_employees_e ");
1: 		sb.append("   where this_employees_e.empid = any ( ");
1: 		sb.append("      select this_employees_e_projects_p.empid ");
1: 		sb.append("      from project_employees this_employees_e_projects_p ");
1: 		sb.append("      where this_employees_e_projects_p.empid = this_employees_e.empid ");
1: 		sb.append("            and this_employees_e.department = this.id ");
1: 		sb.append("            and unbound_p.projid = this_employees_e_projects_p.projid ");
1: 		sb.append("            and unbound_e.empid = this_employees_e.empid)");
1: 		sb.append(")");
1: 		
1: 		rs = s.executeQuery(sb.toString());
1: 		/* Expected rows are as above */
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 		
commit:de51906
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.NestedWhereSubqueryTest
1:  *  
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Nested WHERE subquery tests. Tests nested WHERE EXISTS | ANY | IN functionality.
1:  *
1:  * Please refer to DERBY-3301 for more details.
1:  */
1: public class NestedWhereSubqueryTest extends BaseJDBCTestCase {
1: 
1: 	public NestedWhereSubqueryTest(String name) {
1: 		super(name);
1: 	}
1: 
1: 	/**
1: 	 * Main test body
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
1: 	public void testBasicOperations()
1: 		throws SQLException {
1: 		Statement s = createStatement();
1: 
1: 		/*
1: 		 * Create tables needed for DERBY-3301 regression test
1: 		 */
1: 		StringBuffer sb = new StringBuffer();
1: 		sb.append("CREATE TABLE departments ( ");
1: 		sb.append("ID INTEGER NOT NULL, ");
1: 		sb.append("NAME VARCHAR(32) NOT NULL, ");
1: 		sb.append("COMPANYID INTEGER, ");
1: 		sb.append("CONSTRAINT DEPTS_PK PRIMARY KEY (ID) ");
1: 		sb.append(")");
1: 		s.executeUpdate(sb.toString());
1: 
1: 		sb = new StringBuffer();
1: 		sb.append("CREATE TABLE employees ( ");
1: 		sb.append("EMPID INTEGER NOT NULL, ");
1: 		sb.append("FIRSTNAME VARCHAR(32) NOT NULL, ");
1: 		sb.append("DEPARTMENT INTEGER, ");
1: 		sb.append("CONSTRAINT PERS_DEPT_FK FOREIGN KEY (DEPARTMENT) REFERENCES departments, ");
1: 		sb.append("CONSTRAINT EMPS_PK PRIMARY KEY (EMPID) ");
1: 		sb.append(")");
1: 		s.executeUpdate(sb.toString());
1: 
1: 		sb = new StringBuffer();
1: 		sb.append("CREATE TABLE projects ( ");
1: 		sb.append("PROJID INTEGER NOT NULL, ");
1: 		sb.append("NAME VARCHAR(32) NOT NULL, ");
1: 		sb.append("CONSTRAINT PROJS_PK PRIMARY KEY (PROJID) ");
1: 		sb.append(")");
1: 		s.executeUpdate(sb.toString());
1: 
1: 		sb = new StringBuffer();
1: 		sb.append("CREATE TABLE project_employees ( ");
1: 		sb.append("PROJID INTEGER REFERENCES projects NOT NULL, ");
1: 		sb.append("EMPID INTEGER REFERENCES employees NOT NULL ");
1: 		sb.append(")");
1: 		s.executeUpdate(sb.toString());
1: 
1: 		/*
1: 		 * Fill some data into the tables
1: 		 */
1: 		s.executeUpdate("INSERT INTO departments VALUES (1, 'Research', 1)");
1: 		s.executeUpdate("INSERT INTO departments VALUES (2, 'Marketing', 1)");
1: 
1: 		s.executeUpdate("INSERT INTO employees VALUES (11, 'Alex', 1)");
1: 		s.executeUpdate("INSERT INTO employees VALUES (12, 'Bill', 1)");
1: 		s.executeUpdate("INSERT INTO employees VALUES (13, 'Charles', 1)");
1: 		s.executeUpdate("INSERT INTO employees VALUES (14, 'David', 2)");
1: 		s.executeUpdate("INSERT INTO employees VALUES (15, 'Earl', 2)");
1: 
1: 		s.executeUpdate("INSERT INTO projects VALUES (101, 'red')");
1: 		s.executeUpdate("INSERT INTO projects VALUES (102, 'orange')");
1: 		s.executeUpdate("INSERT INTO projects VALUES (103, 'yellow')");
1: 
1: 		s.executeUpdate("INSERT INTO project_employees VALUES (102, 13)");
1: 		s.executeUpdate("INSERT INTO project_employees VALUES (101, 13)");
1: 		s.executeUpdate("INSERT INTO project_employees VALUES (102, 12)");
1: 		s.executeUpdate("INSERT INTO project_employees VALUES (103, 15)");
1: 		s.executeUpdate("INSERT INTO project_employees VALUES (103, 14)");
1: 		s.executeUpdate("INSERT INTO project_employees VALUES (101, 12)");
1: 		s.executeUpdate("INSERT INTO project_employees VALUES (101, 11)");
1: 
1: 		/*
1: 		 * Preliminary data check
1: 		 */
1: 		ResultSet rs = s.executeQuery("select * from employees");
1: 		String[][] expectedRows = {{"11", "Alex", "1"},
1: 									{"12", "Bill", "1"},
1: 									{"13", "Charles", "1"},
1: 									{"14", "David", "2"},
1: 									{"15", "Earl", "2"}};		
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 
1: 		rs = s.executeQuery("select * from departments");
1: 		expectedRows = new String [][] {{"1", "Research", "1"},
1: 										{"2","Marketing","1"}};		
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 
1: 		rs = s.executeQuery("select * from projects");
1: 		expectedRows = new String [][] {{"101","red"},
1: 										{"102","orange"},
1: 										{"103","yellow"}};		
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 
1: 		rs = s.executeQuery("select * from project_employees");
1: 		expectedRows = new String [][] {{"102","13"},
1: 										{"101","13"},
1: 										{"102","12"},
1: 										{"103","15"},
1: 										{"103","14"},
1: 										{"101","12"},
1: 										{"101","11"}};		
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 
1: 		/*
1: 		 * DERBY-3301: This query should return 7 rows
1: 		 */
1: 		sb = new StringBuffer();
1: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1: 		sb.append("from departments this, ");
1: 		sb.append("     employees unbound_e, ");
1: 		sb.append("     projects unbound_p ");
1: 		sb.append("where exists ( ");
1: 		sb.append("  select 1 from employees this_employees_e ");
1: 		sb.append("  where exists ( ");
1: 		sb.append("    select 1 from project_employees this_employees_e_projects_p ");
1: 		sb.append("    where this_employees_e_projects_p.empid = this_employees_e.empid ");
1: 		sb.append("    and this_employees_e.department = this.id ");
1: 		sb.append("    and unbound_p.projid = this_employees_e_projects_p.projid ");
1: 		sb.append("    and unbound_e.empid = this_employees_e.empid) ");
1: 		sb.append(" )");
1: 
1: 		rs = s.executeQuery(sb.toString());
1: 		expectedRows = new String [][] {{"13", "101"},
1: 										{"12", "101"},
1: 										{"11", "101"},
1: 										{"13", "102"},
1: 										{"12", "102"},
1: 										{"15", "103"},
1: 										{"14", "103"}};
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 		
1: 		/* A variation of the above WHERE EXISTS but using IN should return the same rows */
1: 		sb = new StringBuffer();
1: 		sb.append("select unbound_e.empid, unbound_p.projid ");
1: 		sb.append("from departments this, ");
1: 		sb.append("     employees unbound_e, ");
1: 		sb.append("     projects unbound_p ");
1: 		sb.append("where exists ( "); 
1: 		sb.append(" select 1 from employees this_employees_e ");
1: 		sb.append("     where this_employees_e.empid in ( ");
1: 		sb.append("         select this_employees_e_projects_p.empid ");
1: 		sb.append("           from project_employees this_employees_e_projects_p ");
1: 		sb.append("         where this_employees_e_projects_p.empid = this_employees_e.empid ");
1: 		sb.append("         and this_employees_e.department = this.id ");
1: 		sb.append("         and unbound_p.projid = this_employees_e_projects_p.projid ");
1: 		sb.append("         and unbound_e.empid = this_employees_e.empid) ");
1: 		sb.append("     )");
1: 
1: 		rs = s.executeQuery(sb.toString());
1: 		JDBC.assertUnorderedResultSet(rs, expectedRows);
1: 
1: 		/*
1: 		 * Clean up the tables used.
1: 		 */				
1: 		s.executeUpdate("drop table project_employees");	
1: 		s.executeUpdate("drop table projects");
1: 		s.executeUpdate("drop table employees");
1: 		s.executeUpdate("drop table departments");			
1: 		
1: 		s.close();
1: 	}
1: 
0: 	public static Test suite() {
1: 		return TestConfiguration.defaultSuite(NestedWhereSubqueryTest.class);
1: 	}
1: }
============================================================================