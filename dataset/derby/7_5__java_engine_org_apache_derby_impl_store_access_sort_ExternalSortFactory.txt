1:eac0369: /*
2:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.sort.ExternalSortFactory
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.sort;
1:eac0369: 
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedAction;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleControl;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:eac0369: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:eac0369: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.Sort;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.SortFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.SortObserver;
1:eac0369: import org.apache.derby.iapi.store.access.SortCostController;
1:eac0369: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.catalog.UUID;
1:eac0369: 
1:fa09146: // For JavaDoc references (i.e. @see)
1:fa09146: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1:fa09146: 
2:eac0369: /**
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public class ExternalSortFactory implements 
1:eac0369:     SortFactory, ModuleControl, ModuleSupportable, SortCostController
1:eac0369: {
1:eac0369: 
1:eac0369: 	private boolean userSpecified; // did the user specify sortBufferMax
1:eac0369: 	private int defaultSortBufferMax; 
1:eac0369: 	private int sortBufferMax;
1:eac0369: 
1:eac0369: 	private static final String IMPLEMENTATIONID = "sort external";
1:eac0369: 	private static final String FORMATUUIDSTRING = "D2976090-D9F5-11d0-B54D-00A024BF8879";
1:eac0369: 	private UUID formatUUID = null;
1:eac0369: 	private static final int DEFAULT_SORTBUFFERMAX = 1024;
1:eac0369: 	private static final int MINIMUM_SORTBUFFERMAX = 4;
1:eac0369: 
1:eac0369: 	protected static final int DEFAULT_MEM_USE = 1024*1024; // aim for about 1Meg
1:eac0369: 	// how many sort runs to combined into a larger sort run
1:5d3cc1e:     // (DERBY-1661)
1:5d3cc1e: 	protected static final int DEFAULT_MAX_MERGE_RUN = 512; 
1:eac0369: 
1:eac0369: 	// sizeof Node + reference to Node + 12 bytes tax
1:eac0369: 	private static final int SORT_ROW_OVERHEAD = 8*4+12; 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of MethodFactory
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	There are no default properties for the external sort..
1:eac0369: 	@see MethodFactory#defaultProperties
1:eac0369: 	**/
1:eac0369: 	public Properties defaultProperties()
1:eac0369: 	{
1:eac0369: 		return new Properties();
1:eac0369: 	}
1:56c1dc2: 
1:56c1dc2: 	/**
1:eac0369: 	@see MethodFactory#supportsImplementation
1:eac0369: 	**/
1:eac0369: 	public boolean supportsImplementation(String implementationId)
1:eac0369: 	{
1:eac0369: 		return implementationId.equals(IMPLEMENTATIONID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	@see MethodFactory#primaryImplementationType
1:eac0369: 	**/
1:eac0369: 	public String primaryImplementationType()
1:eac0369: 	{
1:eac0369: 		return IMPLEMENTATIONID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	@see MethodFactory#supportsFormat
1:eac0369: 	**/
1:eac0369: 	public boolean supportsFormat(UUID formatid)
1:eac0369: 	{
1:eac0369: 		return formatid.equals(formatUUID);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	@see MethodFactory#primaryFormat
1:eac0369: 	**/
1:eac0369: 	public UUID primaryFormat()
1:eac0369: 	{
1:eac0369: 		return formatUUID;
1:eac0369: 	}
1:28e234d:         
1:28e234d: 	/**
1:28e234d: 	 * Returns merge sort implementation. Extending classes can overide this 
1:28e234d: 	 * method to customize sorting.
1:28e234d:      *
1:435735b: 	 * @return MergeSort implementation
1:28e234d: 	 */
1:28e234d: 	protected MergeSort getMergeSort() 
1:28e234d:     {
1:28e234d: 		return new MergeSort();
1:28e234d: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of SortFactory
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Create a sort.
1:eac0369: 	This method could choose among different sort options, 
1:eac0369: 	depending on the properties etc., but currently it always
1:eac0369: 	returns a merge sort.
1:eac0369: 	@see SortFactory#createSort
1:eac0369: 	**/
1:eac0369: 	public Sort createSort(
1:eac0369:     TransactionController   tran,
1:eac0369:     int                     segment,
1:eac0369:     Properties              implParameters,
1:eac0369:     DataValueDescriptor[]   template,
1:eac0369:     ColumnOrdering          columnOrdering[],
1:eac0369:     SortObserver          	sortObserver,
1:eac0369:     boolean                 alreadyInOrder,
1:eac0369:     long                    estimatedRows,
1:eac0369:     int                     estimatedRowSize)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:28e234d: 		MergeSort sort = getMergeSort();
1:eac0369: 
1:eac0369:         // RESOLVE - mikem change this to use estimatedRows and 
1:eac0369:         // estimatedRowSize to come up with a smarter number for sortBufferMax
1:eac0369:         // than a fixed number of rows.  At least 2 possibilities:
1:eac0369:         //     1) add sortBufferMaxMem which would be the amount of memory
1:eac0369:         //        the sorter could use, and then just pick the number of 
1:eac0369:         //        rows as (sortBufferMaxMem / (estimatedRows * estimatedRowSize)
1:eac0369:         //     2) add sortBufferUsePercentFree.  This would be how much of
1:eac0369:         //        the current free memory can the current sort use.
1:eac0369:         //
1:eac0369: 
1:eac0369: 		if (!userSpecified)	
1:eac0369: 		{
1:eac0369: 			// derby.storage.sortBufferMax is not specified by the
1:eac0369: 			// user, use default or try to figure out a reasonable sort
1:eac0369: 			// size.
1:eac0369: 
1:eac0369: 			// if we have some idea on row size, set sort approx 1 meg of
1:eac0369: 			// memory sort.
1:eac0369: 			if (estimatedRowSize > 0)
1:eac0369: 			{
1:eac0369: 				// 
1:eac0369: 				// for each column, there is a reference from the key array and
1:eac0369: 				//   the 4 bytes reference to the column object plus 12 bytes
1:eac0369: 				//   tax on the  column object  
1:eac0369: 				// for each row, SORT_ROW_OVERHEAD is the Node and 4 bytes to
1:eac0369: 				// point to the column array and 4 for alignment
1:eac0369: 				//
1:eac0369: 				estimatedRowSize += SORT_ROW_OVERHEAD +
1:eac0369: 					(template.length*(4+12)) + 8; 
1:eac0369: 				sortBufferMax = DEFAULT_MEM_USE/estimatedRowSize;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				sortBufferMax = defaultSortBufferMax;
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			// if there are barely more rows than sortBufferMax, use 2
1:eac0369: 			// smaller runs of similar size instead of one larger run
1:eac0369: 			//
1:eac0369: 			// 10% slush is added to estimated Rows to catch the case where
1:eac0369: 			// estimated rows underestimate the actual number of rows by 10%.
1:eac0369: 			//
1:eac0369: 			if (estimatedRows > sortBufferMax &&
1:eac0369: 				(estimatedRows*1.1) < sortBufferMax*2)
1:eac0369: 				sortBufferMax = (int)(estimatedRows/2 + estimatedRows/10);
1:eac0369: 
1:eac0369: 			// Make sure it is at least the minimum sort buffer size
1:eac0369: 			if (sortBufferMax < MINIMUM_SORTBUFFERMAX)
1:eac0369: 				sortBufferMax = MINIMUM_SORTBUFFERMAX;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// if user specified derby.storage.sortBufferMax, use it.
1:eac0369: 				sortBufferMax = defaultSortBufferMax;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("SortTuning"))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG("SortTuning",
1:eac0369:                     "sortBufferMax = " + sortBufferMax + 
1:eac0369:                     " estimatedRows = " + estimatedRows +
1:eac0369:                     " estimatedRowSize = " + estimatedRowSize +
1:eac0369:                     " defaultSortBufferMax = " + defaultSortBufferMax);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		sort.initialize(
1:eac0369:             template, columnOrdering, sortObserver, 
1:eac0369:             alreadyInOrder, estimatedRows, sortBufferMax);
1:eac0369: 		return sort;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return an open SortCostController.
1:eac0369:      * <p>
1:eac0369:      * Return an open SortCostController which can be used to ask about 
1:eac0369:      * the estimated costs of SortController() operations.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The open SortCostController.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369:      * @see SortCostController
1:eac0369:      **/
1:eac0369:     public SortCostController openSortCostController()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return(this);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of SortCostController
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     public void close()
1:eac0369:     {
1:eac0369:         // nothing to do.
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Short one line description of routine.
1:eac0369:      * <p>
1:eac0369:      * The sort algorithm is a N * log(N) algorithm.  The following numbers
1:eac0369:      * on a PII, 400 MHZ machine, jdk117 with jit, insane.zip.  This test
1:eac0369:      * is a simple "select * from table order by first_int_column.  I then
1:eac0369:      * subtracted the time it takes to do "select * from table" from the
1:eac0369:      * result.
1:eac0369:      *
1:eac0369:      * number of rows       elaspsed time in seconds
1:eac0369:      * --------------       -----------------------------
1:eac0369:      * 1000                  0.20
1:eac0369:      * 10000                10.5
1:eac0369:      * 100000               80.0
1:eac0369:      *
1:eac0369:      * We assume that the formula for sort performance is of the form:
1:eac0369:      * performance = K * N * log(N).  Solving the equation for the 1000
1:eac0369:      * and 100000 case we come up with:
1:eac0369:      *
1:eac0369:      * performance = 1 + 0.08 N ln(n)
1:eac0369: 	 *
1:eac0369: 	 * NOTE: Apparently, these measurements were done on a faster machine
1:eac0369: 	 * than was used for other performance measurements used by the optimizer.
1:eac0369: 	 * Experiments show that the 0.8 multiplier is off by a factor of 4
1:eac0369: 	 * with respect to other measurements (such as the time it takes to
1:eac0369: 	 * scan a conglomerate).  I am correcting the formula to use 0.32
1:eac0369: 	 * rather than 0.08.
1:eac0369: 	 *
1:eac0369: 	 *					-	Jeff
1:eac0369:      *
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) - this formula is very crude at the moment and will be
1:eac0369:      * refined later.  known problems:
1:eac0369:      * 1) internal vs. external sort - we know that the performance of sort
1:eac0369:      *    is discontinuous when we go from an internal to an external sort.
1:eac0369:      *    A better model is probably a different set of contants for internal
1:eac0369:      *    vs. external sort and some way to guess when this is going to happen.
1:eac0369:      * 2) current row size is never considered but is critical to performance.
1:eac0369:      * 3) estimatedExportRows is not used.  This is a critical number to know
1:eac0369:      *    if an internal vs. an external sort will happen.  
1:eac0369:      *
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The identifier to be used to open the conglomerate later.
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public double getSortCost(
1:eac0369:     DataValueDescriptor[]   template,
1:eac0369:     ColumnOrdering          columnOrdering[],
1:eac0369:     boolean                 alreadyInOrder,
1:eac0369:     long                    estimatedInputRows,
1:eac0369:     long                    estimatedExportRows,
1:eac0369:     int                     estimatedRowSize)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369: 		/* Avoid taking the log of 0 */
1:eac0369: 		if (estimatedInputRows == 0)
1:eac0369: 			return 0.0;
1:eac0369: 
1:eac0369:         // RESOLVE - come up with some real benchmark.  For now the cost
1:eac0369:         // of sort is 3 times the cost of scanning the data.
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(estimatedInputRows  >= 0);
1:eac0369:             SanityManager.ASSERT(estimatedExportRows >= 0);
1:eac0369:         }
1:eac0369: 
1:eac0369:         double ret_val = 
1:eac0369:             1 + 
1:eac0369:             ((0.32) * (estimatedInputRows) * Math.log(estimatedInputRows));
1:eac0369: 
1:eac0369:         return(ret_val);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of ModuleControl.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public boolean canSupport(Properties startParams) {
1:eac0369: 
1:276fd51:         if (startParams == null)
1:276fd51:             return false; 
1:276fd51: 
1:eac0369: 		String impl = startParams.getProperty("derby.access.Conglomerate.type");
1:eac0369: 		if (impl == null)
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		return supportsImplementation(impl);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	public void	boot(boolean create, Properties startParams)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// Find the UUID factory.
1:56c1dc2: 		UUIDFactory uuidFactory = getMonitor().getUUIDFactory();
1:eac0369: 
1:eac0369: 		// Make a UUID that identifies this sort's format.
1:eac0369: 		formatUUID = uuidFactory.recreateUUID(FORMATUUIDSTRING);
1:eac0369: 
1:eac0369: 		// See if there's a new maximum sort buffer size.
1:eac0369: 		defaultSortBufferMax = PropertyUtil.getSystemInt("derby.storage.sortBufferMax",
1:eac0369: 								0, Integer.MAX_VALUE, 0);
1:eac0369: 
1:eac0369: 		// if defaultSortBufferMax is 0, the user did not specify
1:eac0369: 		// sortBufferMax, then just set it to DEFAULT_SORTBUFFERMAX.
1:eac0369: 		// if defaultSortBufferMax is not 0, the user specified sortBufferMax,
1:eac0369: 		// do not override it.
1:eac0369: 		if (defaultSortBufferMax == 0)
1:eac0369: 		{
1:eac0369: 			userSpecified = false;
1:eac0369: 			defaultSortBufferMax = DEFAULT_SORTBUFFERMAX;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			userSpecified = true;
1:eac0369: 			if (defaultSortBufferMax < MINIMUM_SORTBUFFERMAX)
1:eac0369: 				defaultSortBufferMax = MINIMUM_SORTBUFFERMAX;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void	stop()
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369:     
1:eac0369:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1: 		UUIDFactory uuidFactory = getMonitor().getUUIDFactory();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:435735b
/////////////////////////////////////////////////////////////////////////
1: 	 * @return MergeSort implementation
commit:28e234d
/////////////////////////////////////////////////////////////////////////
1:         
1: 	/**
1: 	 * Returns merge sort implementation. Extending classes can overide this 
1: 	 * method to customize sorting.
1:      *
0: 	 * @returns MergeSort implementation
1: 	 */
1: 	protected MergeSort getMergeSort() 
1:     {
1: 		return new MergeSort();
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 		MergeSort sort = getMergeSort();
commit:5d3cc1e
/////////////////////////////////////////////////////////////////////////
1:     // (DERBY-1661)
1: 	protected static final int DEFAULT_MAX_MERGE_RUN = 512; 
commit:7a4afea
/////////////////////////////////////////////////////////////////////////
commit:276fd51
/////////////////////////////////////////////////////////////////////////
1:         if (startParams == null)
1:             return false; 
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: // For JavaDoc references (i.e. @see)
1: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.sort.ExternalSortFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.sort
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.sort;
1: 
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.services.monitor.ModuleControl;
1: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
1: import org.apache.derby.iapi.store.access.conglomerate.Sort;
1: import org.apache.derby.iapi.store.access.conglomerate.SortFactory;
1: 
1: import org.apache.derby.iapi.store.access.SortObserver;
1: import org.apache.derby.iapi.store.access.SortCostController;
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.services.uuid.UUIDFactory;
1: 
1: import org.apache.derby.catalog.UUID;
1: 
1: /**
1: 
1: **/
1: 
1: public class ExternalSortFactory implements 
1:     SortFactory, ModuleControl, ModuleSupportable, SortCostController
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private boolean userSpecified; // did the user specify sortBufferMax
1: 	private int defaultSortBufferMax; 
1: 	private int sortBufferMax;
1: 
1: 	private static final String IMPLEMENTATIONID = "sort external";
1: 	private static final String FORMATUUIDSTRING = "D2976090-D9F5-11d0-B54D-00A024BF8879";
1: 	private UUID formatUUID = null;
1: 	private static final int DEFAULT_SORTBUFFERMAX = 1024;
1: 	private static final int MINIMUM_SORTBUFFERMAX = 4;
1: 
1: 	protected static final int DEFAULT_MEM_USE = 1024*1024; // aim for about 1Meg
1: 	// how many sort runs to combined into a larger sort run
0: 	protected static final int DEFAULT_MAX_MERGE_RUN = 1024; 
1: 
1: 	// sizeof Node + reference to Node + 12 bytes tax
1: 	private static final int SORT_ROW_OVERHEAD = 8*4+12; 
1: 
1: 
1: 	/*
1: 	** Methods of MethodFactory
1: 	*/
1: 
1: 	/**
1: 	There are no default properties for the external sort..
1: 	@see MethodFactory#defaultProperties
1: 	**/
1: 	public Properties defaultProperties()
1: 	{
1: 		return new Properties();
1: 	}
1: 
1: 	/**
1: 	@see MethodFactory#supportsImplementation
1: 	**/
1: 	public boolean supportsImplementation(String implementationId)
1: 	{
1: 		return implementationId.equals(IMPLEMENTATIONID);
1: 	}
1: 
1: 	/**
1: 	@see MethodFactory#primaryImplementationType
1: 	**/
1: 	public String primaryImplementationType()
1: 	{
1: 		return IMPLEMENTATIONID;
1: 	}
1: 
1: 	/**
1: 	@see MethodFactory#supportsFormat
1: 	**/
1: 	public boolean supportsFormat(UUID formatid)
1: 	{
1: 		return formatid.equals(formatUUID);
1: 	}
1: 
1: 	/**
1: 	@see MethodFactory#primaryFormat
1: 	**/
1: 	public UUID primaryFormat()
1: 	{
1: 		return formatUUID;
1: 	}
1: 
1: 	/*
1: 	** Methods of SortFactory
1: 	*/
1: 
1: 	/**
1: 	Create a sort.
1: 	This method could choose among different sort options, 
1: 	depending on the properties etc., but currently it always
1: 	returns a merge sort.
1: 	@see SortFactory#createSort
1: 	**/
1: 	public Sort createSort(
1:     TransactionController   tran,
1:     int                     segment,
1:     Properties              implParameters,
1:     DataValueDescriptor[]   template,
1:     ColumnOrdering          columnOrdering[],
1:     SortObserver          	sortObserver,
1:     boolean                 alreadyInOrder,
1:     long                    estimatedRows,
1:     int                     estimatedRowSize)
1:         throws StandardException
1: 	{
0: 		MergeSort sort = new MergeSort();
1: 
1:         // RESOLVE - mikem change this to use estimatedRows and 
1:         // estimatedRowSize to come up with a smarter number for sortBufferMax
1:         // than a fixed number of rows.  At least 2 possibilities:
1:         //     1) add sortBufferMaxMem which would be the amount of memory
1:         //        the sorter could use, and then just pick the number of 
1:         //        rows as (sortBufferMaxMem / (estimatedRows * estimatedRowSize)
1:         //     2) add sortBufferUsePercentFree.  This would be how much of
1:         //        the current free memory can the current sort use.
1:         //
1: 
1: 		if (!userSpecified)	
1: 		{
1: 			// derby.storage.sortBufferMax is not specified by the
1: 			// user, use default or try to figure out a reasonable sort
1: 			// size.
1: 
1: 			// if we have some idea on row size, set sort approx 1 meg of
1: 			// memory sort.
1: 			if (estimatedRowSize > 0)
1: 			{
1: 				// 
1: 				// for each column, there is a reference from the key array and
1: 				//   the 4 bytes reference to the column object plus 12 bytes
1: 				//   tax on the  column object  
1: 				// for each row, SORT_ROW_OVERHEAD is the Node and 4 bytes to
1: 				// point to the column array and 4 for alignment
1: 				//
1: 				estimatedRowSize += SORT_ROW_OVERHEAD +
1: 					(template.length*(4+12)) + 8; 
1: 				sortBufferMax = DEFAULT_MEM_USE/estimatedRowSize;
1: 			}
1: 			else
1: 			{
1: 				sortBufferMax = defaultSortBufferMax;
1: 			}
1: 			
1: 			// if there are barely more rows than sortBufferMax, use 2
1: 			// smaller runs of similar size instead of one larger run
1: 			//
1: 			// 10% slush is added to estimated Rows to catch the case where
1: 			// estimated rows underestimate the actual number of rows by 10%.
1: 			//
1: 			if (estimatedRows > sortBufferMax &&
1: 				(estimatedRows*1.1) < sortBufferMax*2)
1: 				sortBufferMax = (int)(estimatedRows/2 + estimatedRows/10);
1: 
1: 			// Make sure it is at least the minimum sort buffer size
1: 			if (sortBufferMax < MINIMUM_SORTBUFFERMAX)
1: 				sortBufferMax = MINIMUM_SORTBUFFERMAX;
1: 		}
1: 		else
1: 		{
1: 			// if user specified derby.storage.sortBufferMax, use it.
1: 				sortBufferMax = defaultSortBufferMax;
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("SortTuning"))
1:             {
1:                 SanityManager.DEBUG("SortTuning",
1:                     "sortBufferMax = " + sortBufferMax + 
1:                     " estimatedRows = " + estimatedRows +
1:                     " estimatedRowSize = " + estimatedRowSize +
1:                     " defaultSortBufferMax = " + defaultSortBufferMax);
1:             }
1:         }
1: 
1: 		sort.initialize(
1:             template, columnOrdering, sortObserver, 
1:             alreadyInOrder, estimatedRows, sortBufferMax);
1: 		return sort;
1: 	}
1: 
1:     /**
1:      * Return an open SortCostController.
1:      * <p>
1:      * Return an open SortCostController which can be used to ask about 
1:      * the estimated costs of SortController() operations.
1:      * <p>
1:      *
1: 	 * @return The open SortCostController.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1:      * @see SortCostController
1:      **/
1:     public SortCostController openSortCostController()
1: 		throws StandardException
1:     {
1:         return(this);
1:     }
1: 
1: 	/*
1: 	** Methods of SortCostController
1: 	*/
1: 
1:     public void close()
1:     {
1:         // nothing to do.
1:     }
1: 
1:     /**
1:      * Short one line description of routine.
1:      * <p>
1:      * The sort algorithm is a N * log(N) algorithm.  The following numbers
1:      * on a PII, 400 MHZ machine, jdk117 with jit, insane.zip.  This test
1:      * is a simple "select * from table order by first_int_column.  I then
1:      * subtracted the time it takes to do "select * from table" from the
1:      * result.
1:      *
1:      * number of rows       elaspsed time in seconds
1:      * --------------       -----------------------------
1:      * 1000                  0.20
1:      * 10000                10.5
1:      * 100000               80.0
1:      *
1:      * We assume that the formula for sort performance is of the form:
1:      * performance = K * N * log(N).  Solving the equation for the 1000
1:      * and 100000 case we come up with:
1:      *
1:      * performance = 1 + 0.08 N ln(n)
1: 	 *
1: 	 * NOTE: Apparently, these measurements were done on a faster machine
1: 	 * than was used for other performance measurements used by the optimizer.
1: 	 * Experiments show that the 0.8 multiplier is off by a factor of 4
1: 	 * with respect to other measurements (such as the time it takes to
1: 	 * scan a conglomerate).  I am correcting the formula to use 0.32
1: 	 * rather than 0.08.
1: 	 *
1: 	 *					-	Jeff
1:      *
1:      * <p>
1:      * RESOLVE (mikem) - this formula is very crude at the moment and will be
1:      * refined later.  known problems:
1:      * 1) internal vs. external sort - we know that the performance of sort
1:      *    is discontinuous when we go from an internal to an external sort.
1:      *    A better model is probably a different set of contants for internal
1:      *    vs. external sort and some way to guess when this is going to happen.
1:      * 2) current row size is never considered but is critical to performance.
1:      * 3) estimatedExportRows is not used.  This is a critical number to know
1:      *    if an internal vs. an external sort will happen.  
1:      *
1:      * <p>
1:      *
1: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
0:      * @param param1 param1 does this.
0:      * @param param2 param2 does this.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public double getSortCost(
1:     DataValueDescriptor[]   template,
1:     ColumnOrdering          columnOrdering[],
1:     boolean                 alreadyInOrder,
1:     long                    estimatedInputRows,
1:     long                    estimatedExportRows,
1:     int                     estimatedRowSize)
1:         throws StandardException
1:     {
1: 		/* Avoid taking the log of 0 */
1: 		if (estimatedInputRows == 0)
1: 			return 0.0;
1: 
1:         // RESOLVE - come up with some real benchmark.  For now the cost
1:         // of sort is 3 times the cost of scanning the data.
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(estimatedInputRows  >= 0);
1:             SanityManager.ASSERT(estimatedExportRows >= 0);
1:         }
1: 
1:         double ret_val = 
1:             1 + 
1:             ((0.32) * (estimatedInputRows) * Math.log(estimatedInputRows));
1: 
1:         return(ret_val);
1:     }
1: 
1: 	/*
1: 	** Methods of ModuleControl.
1: 	*/
1: 
1: 	public boolean canSupport(Properties startParams) {
1: 
1: 		String impl = startParams.getProperty("derby.access.Conglomerate.type");
1: 		if (impl == null)
1: 			return false;
1: 
1: 		return supportsImplementation(impl);
1: 	}
1: 
1: 
1: 	public void	boot(boolean create, Properties startParams)
1: 		throws StandardException
1: 	{
1: 		// Find the UUID factory.
0: 		UUIDFactory uuidFactory = Monitor.getMonitor().getUUIDFactory();
1: 
1: 		// Make a UUID that identifies this sort's format.
1: 		formatUUID = uuidFactory.recreateUUID(FORMATUUIDSTRING);
1: 
1: 		// See if there's a new maximum sort buffer size.
1: 		defaultSortBufferMax = PropertyUtil.getSystemInt("derby.storage.sortBufferMax",
1: 								0, Integer.MAX_VALUE, 0);
1: 
1: 		// if defaultSortBufferMax is 0, the user did not specify
1: 		// sortBufferMax, then just set it to DEFAULT_SORTBUFFERMAX.
1: 		// if defaultSortBufferMax is not 0, the user specified sortBufferMax,
1: 		// do not override it.
1: 		if (defaultSortBufferMax == 0)
1: 		{
1: 			userSpecified = false;
1: 			defaultSortBufferMax = DEFAULT_SORTBUFFERMAX;
1: 		}
1: 		else
1: 		{
1: 			userSpecified = true;
1: 			if (defaultSortBufferMax < MINIMUM_SORTBUFFERMAX)
1: 				defaultSortBufferMax = MINIMUM_SORTBUFFERMAX;
1: 		}
1: 
1: 	}
1: 
1: 	public void	stop()
1: 	{
1: 	}
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.sort
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.sort;
0: 
0: import java.util.Properties;
0: 
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.ModuleSupportable;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.MethodFactory;
0: import org.apache.derby.iapi.store.access.conglomerate.Sort;
0: import org.apache.derby.iapi.store.access.conglomerate.SortFactory;
0: 
0: import org.apache.derby.iapi.store.access.SortObserver;
0: import org.apache.derby.iapi.store.access.SortCostController;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.uuid.UUIDFactory;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: /**
0: 
0: **/
0: 
0: public class ExternalSortFactory implements 
0:     SortFactory, ModuleControl, ModuleSupportable, SortCostController
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private boolean userSpecified; // did the user specify sortBufferMax
0: 	private int defaultSortBufferMax; 
0: 	private int sortBufferMax;
0: 
0: 	private static final String IMPLEMENTATIONID = "sort external";
0: 	private static final String FORMATUUIDSTRING = "D2976090-D9F5-11d0-B54D-00A024BF8879";
0: 	private UUID formatUUID = null;
0: 	private static final int DEFAULT_SORTBUFFERMAX = 1024;
0: 	private static final int MINIMUM_SORTBUFFERMAX = 4;
0: 
0: 	protected static final int DEFAULT_MEM_USE = 1024*1024; // aim for about 1Meg
0: 	// how many sort runs to combined into a larger sort run
0: 	protected static final int DEFAULT_MAX_MERGE_RUN = 1024; 
0: 
0: 	// sizeof Node + reference to Node + 12 bytes tax
0: 	private static final int SORT_ROW_OVERHEAD = 8*4+12; 
0: 
0: 
0: 	/*
0: 	** Methods of MethodFactory
0: 	*/
0: 
0: 	/**
0: 	There are no default properties for the external sort..
0: 	@see MethodFactory#defaultProperties
0: 	**/
0: 	public Properties defaultProperties()
0: 	{
0: 		return new Properties();
0: 	}
0: 
0: 	/**
0: 	@see MethodFactory#supportsImplementation
0: 	**/
0: 	public boolean supportsImplementation(String implementationId)
0: 	{
0: 		return implementationId.equals(IMPLEMENTATIONID);
0: 	}
0: 
0: 	/**
0: 	@see MethodFactory#primaryImplementationType
0: 	**/
0: 	public String primaryImplementationType()
0: 	{
0: 		return IMPLEMENTATIONID;
0: 	}
0: 
0: 	/**
0: 	@see MethodFactory#supportsFormat
0: 	**/
0: 	public boolean supportsFormat(UUID formatid)
0: 	{
0: 		return formatid.equals(formatUUID);
0: 	}
0: 
0: 	/**
0: 	@see MethodFactory#primaryFormat
0: 	**/
0: 	public UUID primaryFormat()
0: 	{
0: 		return formatUUID;
0: 	}
0: 
0: 	/*
0: 	** Methods of SortFactory
0: 	*/
0: 
0: 	/**
0: 	Create a sort.
0: 	This method could choose among different sort options, 
0: 	depending on the properties etc., but currently it always
0: 	returns a merge sort.
0: 	@see SortFactory#createSort
0: 	**/
0: 	public Sort createSort(
0:     TransactionController   tran,
0:     int                     segment,
0:     Properties              implParameters,
0:     DataValueDescriptor[]   template,
0:     ColumnOrdering          columnOrdering[],
0:     SortObserver          	sortObserver,
0:     boolean                 alreadyInOrder,
0:     long                    estimatedRows,
0:     int                     estimatedRowSize)
0:         throws StandardException
0: 	{
0: 		MergeSort sort = new MergeSort();
0: 
0:         // RESOLVE - mikem change this to use estimatedRows and 
0:         // estimatedRowSize to come up with a smarter number for sortBufferMax
0:         // than a fixed number of rows.  At least 2 possibilities:
0:         //     1) add sortBufferMaxMem which would be the amount of memory
0:         //        the sorter could use, and then just pick the number of 
0:         //        rows as (sortBufferMaxMem / (estimatedRows * estimatedRowSize)
0:         //     2) add sortBufferUsePercentFree.  This would be how much of
0:         //        the current free memory can the current sort use.
0:         //
0: 
0: 		if (!userSpecified)	
0: 		{
0: 			// derby.storage.sortBufferMax is not specified by the
0: 			// user, use default or try to figure out a reasonable sort
0: 			// size.
0: 
0: 			// if we have some idea on row size, set sort approx 1 meg of
0: 			// memory sort.
0: 			if (estimatedRowSize > 0)
0: 			{
0: 				// 
0: 				// for each column, there is a reference from the key array and
0: 				//   the 4 bytes reference to the column object plus 12 bytes
0: 				//   tax on the  column object  
0: 				// for each row, SORT_ROW_OVERHEAD is the Node and 4 bytes to
0: 				// point to the column array and 4 for alignment
0: 				//
0: 				estimatedRowSize += SORT_ROW_OVERHEAD +
0: 					(template.length*(4+12)) + 8; 
0: 				sortBufferMax = DEFAULT_MEM_USE/estimatedRowSize;
0: 			}
0: 			else
0: 			{
0: 				sortBufferMax = defaultSortBufferMax;
0: 			}
0: 			
0: 			// if there are barely more rows than sortBufferMax, use 2
0: 			// smaller runs of similar size instead of one larger run
0: 			//
0: 			// 10% slush is added to estimated Rows to catch the case where
0: 			// estimated rows underestimate the actual number of rows by 10%.
0: 			//
0: 			if (estimatedRows > sortBufferMax &&
0: 				(estimatedRows*1.1) < sortBufferMax*2)
0: 				sortBufferMax = (int)(estimatedRows/2 + estimatedRows/10);
0: 
0: 			// Make sure it is at least the minimum sort buffer size
0: 			if (sortBufferMax < MINIMUM_SORTBUFFERMAX)
0: 				sortBufferMax = MINIMUM_SORTBUFFERMAX;
0: 		}
0: 		else
0: 		{
0: 			// if user specified derby.storage.sortBufferMax, use it.
0: 				sortBufferMax = defaultSortBufferMax;
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("SortTuning"))
0:             {
0:                 SanityManager.DEBUG("SortTuning",
0:                     "sortBufferMax = " + sortBufferMax + 
0:                     " estimatedRows = " + estimatedRows +
0:                     " estimatedRowSize = " + estimatedRowSize +
0:                     " defaultSortBufferMax = " + defaultSortBufferMax);
0:             }
0:         }
0: 
0: 		sort.initialize(
0:             template, columnOrdering, sortObserver, 
0:             alreadyInOrder, estimatedRows, sortBufferMax);
0: 		return sort;
0: 	}
0: 
0:     /**
0:      * Return an open SortCostController.
0:      * <p>
0:      * Return an open SortCostController which can be used to ask about 
0:      * the estimated costs of SortController() operations.
0:      * <p>
0:      *
0: 	 * @return The open SortCostController.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0:      * @see SortCostController
0:      **/
0:     public SortCostController openSortCostController()
0: 		throws StandardException
0:     {
0:         return(this);
0:     }
0: 
0: 	/*
0: 	** Methods of SortCostController
0: 	*/
0: 
0:     public void close()
0:     {
0:         // nothing to do.
0:     }
0: 
0:     /**
0:      * Short one line description of routine.
0:      * <p>
0:      * The sort algorithm is a N * log(N) algorithm.  The following numbers
0:      * on a PII, 400 MHZ machine, jdk117 with jit, insane.zip.  This test
0:      * is a simple "select * from table order by first_int_column.  I then
0:      * subtracted the time it takes to do "select * from table" from the
0:      * result.
0:      *
0:      * number of rows       elaspsed time in seconds
0:      * --------------       -----------------------------
0:      * 1000                  0.20
0:      * 10000                10.5
0:      * 100000               80.0
0:      *
0:      * We assume that the formula for sort performance is of the form:
0:      * performance = K * N * log(N).  Solving the equation for the 1000
0:      * and 100000 case we come up with:
0:      *
0:      * performance = 1 + 0.08 N ln(n)
0: 	 *
0: 	 * NOTE: Apparently, these measurements were done on a faster machine
0: 	 * than was used for other performance measurements used by the optimizer.
0: 	 * Experiments show that the 0.8 multiplier is off by a factor of 4
0: 	 * with respect to other measurements (such as the time it takes to
0: 	 * scan a conglomerate).  I am correcting the formula to use 0.32
0: 	 * rather than 0.08.
0: 	 *
0: 	 *					-	Jeff
0:      *
0:      * <p>
0:      * RESOLVE (mikem) - this formula is very crude at the moment and will be
0:      * refined later.  known problems:
0:      * 1) internal vs. external sort - we know that the performance of sort
0:      *    is discontinuous when we go from an internal to an external sort.
0:      *    A better model is probably a different set of contants for internal
0:      *    vs. external sort and some way to guess when this is going to happen.
0:      * 2) current row size is never considered but is critical to performance.
0:      * 3) estimatedExportRows is not used.  This is a critical number to know
0:      *    if an internal vs. an external sort will happen.  
0:      *
0:      * <p>
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0:      * @param param1 param1 does this.
0:      * @param param2 param2 does this.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public double getSortCost(
0:     DataValueDescriptor[]   template,
0:     ColumnOrdering          columnOrdering[],
0:     boolean                 alreadyInOrder,
0:     long                    estimatedInputRows,
0:     long                    estimatedExportRows,
0:     int                     estimatedRowSize)
0:         throws StandardException
0:     {
0: 		/* Avoid taking the log of 0 */
0: 		if (estimatedInputRows == 0)
0: 			return 0.0;
0: 
0:         // RESOLVE - come up with some real benchmark.  For now the cost
0:         // of sort is 3 times the cost of scanning the data.
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(estimatedInputRows  >= 0);
0:             SanityManager.ASSERT(estimatedExportRows >= 0);
0:         }
0: 
0:         double ret_val = 
0:             1 + 
0:             ((0.32) * (estimatedInputRows) * Math.log(estimatedInputRows));
0: 
0:         return(ret_val);
0:     }
0: 
0: 	/*
0: 	** Methods of ModuleControl.
0: 	*/
0: 
0: 	public boolean canSupport(Properties startParams) {
0: 
0: 		String impl = startParams.getProperty("derby.access.Conglomerate.type");
0: 		if (impl == null)
0: 			return false;
0: 
0: 		return supportsImplementation(impl);
0: 	}
0: 
0: 
0: 	public void	boot(boolean create, Properties startParams)
0: 		throws StandardException
0: 	{
0: 		// Find the UUID factory.
0: 		UUIDFactory uuidFactory = Monitor.getMonitor().getUUIDFactory();
0: 
0: 		// Make a UUID that identifies this sort's format.
0: 		formatUUID = uuidFactory.recreateUUID(FORMATUUIDSTRING);
0: 
0: 		// See if there's a new maximum sort buffer size.
0: 		defaultSortBufferMax = PropertyUtil.getSystemInt("derby.storage.sortBufferMax",
0: 								0, Integer.MAX_VALUE, 0);
0: 
0: 		// if defaultSortBufferMax is 0, the user did not specify
0: 		// sortBufferMax, then just set it to DEFAULT_SORTBUFFERMAX.
0: 		// if defaultSortBufferMax is not 0, the user specified sortBufferMax,
0: 		// do not override it.
0: 		if (defaultSortBufferMax == 0)
0: 		{
0: 			userSpecified = false;
0: 			defaultSortBufferMax = DEFAULT_SORTBUFFERMAX;
0: 		}
0: 		else
0: 		{
0: 			userSpecified = true;
0: 			if (defaultSortBufferMax < MINIMUM_SORTBUFFERMAX)
0: 				defaultSortBufferMax = MINIMUM_SORTBUFFERMAX;
0: 		}
0: 
0: 	}
0: 
0: 	public void	stop()
0: 	{
0: 	}
0: 
0: }
============================================================================