1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.BinaryRelationalOperatorNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.sql.Types;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:05623b6: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
2:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.Orderable;
1:3bb140c: import org.apache.derby.iapi.types.TypeId;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
1:eac0369: /**
1:eac0369:  * This class represents the 6 binary operators: LessThan, LessThanEquals,
1:eac0369:  * Equals, NotEquals, GreaterThan and GreaterThanEquals.
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class BinaryRelationalOperatorNode
1:eac0369: 	extends BinaryComparisonOperatorNode
1:eac0369: 	implements RelationalOperator
1:eac0369: {
1:2706d1f:     // Allowed kinds
1:2706d1f:     final static int K_EQUALS = 0;
1:2706d1f:     final static int K_GREATER_EQUALS = 1;
1:2706d1f:     final static int K_GREATER_THAN = 2;
1:2706d1f:     final static int K_LESS_EQUALS = 3;
1:2706d1f:     final static int K_LESS_THAN = 4;
1:2706d1f:     final static int K_NOT_EQUALS = 5;
1:2706d1f: 
1:2706d1f:     /**
1:2706d1f:      * This class is used to hold logically different objects for
1:2706d1f:      * space efficiency. {@code kind} represents the logical object
1:2706d1f:      * type. See also {@link ValueNode#isSameNodeKind}.
1:2706d1f:      */
1:2706d1f:     final int kind;
1:2706d1f: 
1:eac0369: 	/* RelationalOperator Interface */
1:2706d1f:     private int relOpType;
1:eac0369: 
1:0be2d6e: 	// Visitor for finding base tables beneath optimizables and column
1:0be2d6e: 	// references.  Created once and re-used thereafter.
1:0be2d6e: 	private BaseTableNumbersVisitor btnVis;
1:eac0369: 
1:0be2d6e: 	// Bit sets for holding base tables beneath optimizables and
1:0be2d6e: 	// column references.  Created once and re-used thereafter.
1:0be2d6e: 	JBitSet optBaseTables;
1:0be2d6e: 	JBitSet valNodeBaseTables;
1:eac0369: 
1:1ad3b32: 	/* If this BinRelOp was created for an IN-list "probe predicate"
1:1ad3b32: 	 * then we keep a pointer to the original IN-list.  This serves
1:1ad3b32: 	 * two purposes: 1) if this field is non-null then we know that
1:1ad3b32: 	 * this BinRelOp is for an IN-list probe predicate; 2) if the
1:1ad3b32: 	 * optimizer chooses a plan for which the probe predicate is
1:1ad3b32: 	 * not usable as a start/stop key then we'll "revert" the pred
1:32edb61: 	 * back to the InListOperatorNode referenced here.  NOTE: Once
1:32edb61: 	 * set, this variable should *only* ever be accessed via the
1:32edb61: 	 * isInListProbeNode() or getInListOp() methods--see comments
1:32edb61: 	 * in the latter method for more.
1:eac0369: 	 */
1:32edb61: 	private InListOperatorNode inListProbeSource = null;
1:eac0369: 
1:3bb140c:     /**
1:3bb140c:      *  Constructor.
1:3bb140c:      *  DERBY-6185 Query against view  with {@code "where name LIKE
1:3bb140c:      *  'Col1' ESCAPE '\' "} failed.
1:3bb140c:      *  Argument {@code forQueryRewrite} can be true only if this node has been
1:3bb140c:      *  added by an internal rewrite of the query. This allows binding to
1:3bb140c:      *  be more liberal when checking it against allowed syntax.
1:3bb140c:      *  This parameter will be passed FALSE when a new instance of the node
1:3bb140c:      *  is being created(which is the majority of the cases). But when an
1:3bb140c:      *  existing node is getting cloned, the value of this parameter should
1:3bb140c:      *  be passed as the originalNode.getForQueryRewrite(). Examples of this
1:3bb140c:      *  can be found in Predicate.Java and PredicateList.java
1:3bb140c:      *
1:2706d1f:      * @param kind            The kind of operator
1:2706d1f:      * @param leftOperand     The left operand
1:2706d1f:      * @param rightOperand    The right operand
1:2706d1f:      * @param forQueryRewrite See method description
1:eb88678:      * @param cm              The context manager
1:3bb140c:      */
1:3bb140c:     BinaryRelationalOperatorNode(
1:2706d1f:             int kind,
1:3bb140c:             ValueNode leftOperand,
1:3bb140c:             ValueNode rightOperand,
1:3bb140c:             boolean forQueryRewrite,
1:3bb140c:             ContextManager cm) throws StandardException
1:eac0369: 	{
1:3bb140c:         super(leftOperand,
1:3bb140c:               rightOperand,
1:2706d1f:               getOperatorName(kind),
1:2706d1f:               getMethodName(kind),
1:3bb140c:               forQueryRewrite,
1:3bb140c:               cm);
1:2706d1f:         this.kind = kind;
1:2706d1f:         constructorMinion();
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     /**
1:3bb140c:      * Same as constructor above except takes a third argument that is
1:3bb140c:      * an InListOperatorNode.  This version is used during IN-list
1:3bb140c:      * preprocessing to create a "probe predicate" for the IN-list.
1:3bb140c:      * See InListOperatorNode.preprocess() for more.
1:3bb140c:      * DERBY-6185 (Query against view  with "where name LIKE
1:3bb140c:      *  'Col1' ESCAPE '\' " failed)
1:3bb140c:      * 4th argument forQueryRewrite can be true only if this node has been
1:3bb140c:      *  added by an internal rewrite of the query. This allows binding to
1:3bb140c:      *  be more liberal when checking it against allowed syntax.
1:3bb140c:      *  This parameter will be passed FALSE when a new instance of the node
1:3bb140c:      *  is being created(which is the majority of the cases). But when an
1:3bb140c:      *  existing node is getting cloned, the value of this parameter should
1:3bb140c:      *  be passed as the originalNode.getForQueryRewrite(). Examples of this
1:3bb140c:      *  can be found in Predicate.Java and PredicateList.java
1:3bb140c:      */
1:3bb140c:     BinaryRelationalOperatorNode(
1:2706d1f:             int kind,
1:3bb140c:             ValueNode leftOperand,
1:3bb140c:             ValueNode rightOperand,
1:3bb140c:             InListOperatorNode inListOp,
1:3bb140c:             boolean forQueryRewrite,
1:3bb140c:             ContextManager cm) throws StandardException
1:3bb140c:     {
1:3bb140c:         super(leftOperand,
1:3bb140c:               rightOperand,
1:2706d1f:               getOperatorName(kind),
1:2706d1f:               getMethodName(kind),
1:3bb140c:               forQueryRewrite,
1:3bb140c:               cm);
1:2706d1f:         this.kind = kind;
1:2706d1f:         constructorMinion();
1:3bb140c:         this.inListProbeSource = inListOp;
1:3bb140c:     }
1:3bb140c: 
1:2706d1f:     private void constructorMinion() {
1:2706d1f:         this.relOpType = getRelOpType(this.kind);
1:3bb140c:         btnVis = null;
1:3bb140c:     }
1:3bb140c: 
1:2706d1f:     private static String getMethodName(int kind) {
1:3bb140c:         String methodName = "";
1:2706d1f:         switch (kind) {
1:2706d1f:         case K_EQUALS:
1:eac0369: 				methodName = "equals";
1:eac0369: 				break;
1:eac0369: 
1:2706d1f:         case K_GREATER_EQUALS:
1:eac0369: 				methodName = "greaterOrEquals";
1:eac0369: 				break;
1:eac0369: 
1:2706d1f:         case K_GREATER_THAN:
1:eac0369: 				methodName = "greaterThan";
1:eac0369: 				break;
1:eac0369: 
1:2706d1f:         case K_LESS_EQUALS:
1:eac0369: 				methodName = "lessOrEquals";
1:eac0369: 				break;
1:eac0369: 
1:2706d1f:         case K_LESS_THAN:
1:eac0369: 				methodName = "lessThan";
1:eac0369: 				break;
1:2706d1f:         case K_NOT_EQUALS:
1:eac0369: 				methodName = "notEquals";
1:3bb140c:                 break;
1:3bb140c: 
1:3bb140c:             default:
1:3bb140c:                 if (SanityManager.DEBUG) {
1:3bb140c:                     SanityManager.THROWASSERT(
1:3bb140c:                             "Constructor for BinaryRelationalOperatorNode" +
1:2706d1f:                             " called with wrong nodeType = " + kind);
1:3bb140c:                 }
1:3bb140c:                 break;
1:3bb140c:         }
1:3bb140c:         return methodName;
1:3bb140c:     }
1:3bb140c: 
1:2706d1f:     private static String getOperatorName(int kind) {
1:3bb140c:         String operatorName = "";
1:3bb140c: 
1:2706d1f:         switch (kind) {
1:2706d1f:         case K_EQUALS:
1:3bb140c:                 operatorName = "=";
1:3bb140c:                 break;
1:3bb140c: 
1:2706d1f:         case K_GREATER_EQUALS:
1:3bb140c:                 operatorName = ">=";
1:3bb140c:                 break;
1:3bb140c: 
1:2706d1f:         case K_GREATER_THAN:
1:3bb140c:                 operatorName = ">";
1:3bb140c:                 break;
1:3bb140c: 
1:2706d1f:         case K_LESS_EQUALS:
1:3bb140c:                 operatorName = "<=";
1:3bb140c:                 break;
1:3bb140c: 
1:2706d1f:         case K_LESS_THAN:
1:3bb140c:                 operatorName = "<";
1:3bb140c:                 break;
1:2706d1f:         case K_NOT_EQUALS:
1:eac0369: 				operatorName = "<>";
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			default:
1:3bb140c:                 if (SanityManager.DEBUG) {
1:3bb140c:                     SanityManager.THROWASSERT(
1:3bb140c:                             "Constructor for BinaryRelationalOperatorNode " +
1:2706d1f:                             "called with wrong nodeType = " + kind);
1:eac0369: 				}
1:eac0369: 			    break;
1:eac0369: 		}
1:eac0369: 
1:3bb140c:         return operatorName;
1:3bb140c:     }
1:3bb140c: 
1:2706d1f:     private int getRelOpType(int op) {
1:2706d1f:         switch (op) {
1:2706d1f:         case K_EQUALS:
1:3bb140c:                 return RelationalOperator.EQUALS_RELOP;
1:2706d1f:         case K_GREATER_EQUALS:
1:3bb140c:                 return RelationalOperator.GREATER_EQUALS_RELOP;
1:2706d1f:         case K_GREATER_THAN:
1:3bb140c:                 return RelationalOperator.GREATER_THAN_RELOP;
1:2706d1f:         case K_LESS_EQUALS:
1:3bb140c:                 return RelationalOperator.LESS_EQUALS_RELOP;
1:2706d1f:         case K_LESS_THAN:
1:3bb140c:                 return RelationalOperator.LESS_THAN_RELOP;
1:2706d1f:         case K_NOT_EQUALS:
1:3bb140c:                 return RelationalOperator.NOT_EQUALS_RELOP;
1:3bb140c:             default:
1:3bb140c:                 if (SanityManager.DEBUG) {
1:3bb140c:                     SanityManager.THROWASSERT(
1:3bb140c:                             "Constructor for BinaryRelationalOperatorNode " +
1:2706d1f:                             "called with wrong operator type = " + kind);
1:3bb140c:                 }
1:3bb140c:                 return 0;
1:3bb140c:         }
1:3bb140c:     }
1:eac0369: 
1:eac0369: 	/**
1:1ad3b32: 	 * If this rel op was created for an IN-list probe predicate then return
1:1ad3b32: 	 * the underlying InListOperatorNode.  Will return null if this rel
1:1ad3b32: 	 * op is a "legitimate" relational operator (as opposed to a disguised
1:32edb61: 	 * IN-list).  With the exception of nullability checking via the
1:32edb61: 	 * isInListProbeNode() method, all access to this.inListProbeSource
1:32edb61: 	 * MUST come through this method, as this method ensures that the
1:32edb61: 	 * left operand of the inListProbeSource is set correctly before
1:32edb61: 	 * returning it.
1:1ad3b32: 	 */
1:1ad3b32: 	protected InListOperatorNode getInListOp()
1:eac0369: 	{
1:32edb61: 		if (inListProbeSource != null)
1:eac0369: 		{
1:32edb61: 			/* Depending on where this probe predicate currently sits
1:32edb61: 			 * in the query tree, this.leftOperand *may* have been
1:32edb61: 			 * transformed, replaced, or remapped one or more times
1:32edb61: 			 * since inListProbeSource was last referenced. Since the
1:32edb61: 			 * leftOperand of the IN list should be the same regardless
1:32edb61: 			 * of which "version" of the operation we're looking at
1:32edb61: 			 * (i.e. the "probe predicate" version (this node) vs the
1:32edb61: 			 * original version (inListProbeSource)), we have to make
1:32edb61: 			 * sure that all of the changes made to this.leftOperand
1:32edb61: 			 * are reflected in inListProbeSource's leftOperand, as
1:32edb61: 			 * well.  In doing so we ensure the caller of this method
1:32edb61: 			 * will see an up-to-date version of the InListOperatorNode--
1:32edb61: 			 * and thus, if the caller references the InListOperatorNode's
1:32edb61: 			 * leftOperand, it will see the correct information. One
1:32edb61: 			 * notable example of this is at code generation time, where
1:32edb61: 			 * if this probe predicate is deemed "not useful", we'll
1:32edb61: 			 * generate the underlying InListOperatorNode instead of
1:32edb61: 			 * "this".  For that to work correctly, the InListOperatorNode
1:32edb61: 			 * must have the correct leftOperand. DERBY-3253.
1:32edb61: 			 *
1:32edb61: 			 * That said, since this.leftOperand will always be "up-to-
1:32edb61: 			 * date" w.r.t. the current query tree (because this probe
1:32edb61: 			 * predicate sits in the query tree and so all relevant
1:32edb61: 			 * transformations will be applied here), the simplest way
1:32edb61: 			 * to ensure the underlying InListOperatorNode also has an
1:32edb61: 			 * up-to-date leftOperand is to set it to this.leftOperand.
1:32edb61: 			 */
1:32edb61: 			inListProbeSource.setLeftOperand(this.leftOperand);
1:eac0369: 		}
1:eac0369: 
1:1ad3b32: 		return inListProbeSource;
1:32edb61: 	}
1:eac0369: 
2:eac0369: 	/** @see RelationalOperator#getColumnOperand */
2:eac0369: 	public ColumnReference getColumnOperand(
1:eac0369: 								Optimizable optTable,
3:eac0369: 								int columnPosition)
1:eac0369: 	{
1:eac0369: 		FromTable	ft = (FromTable) optTable;
1:eac0369: 
1:0be2d6e: 		// When searching for a matching column operand, we search
1:0be2d6e: 		// the entire subtree (if there is one) beneath optTable
1:0be2d6e: 		// to see if we can find any FromTables that correspond to
1:0be2d6e: 		// either of this op's column references.
1:eac0369: 
1:eac0369: 		ColumnReference	cr;
1:0be2d6e: 		boolean walkSubtree = true;
1:eac0369: 		if (leftOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The left operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) leftOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(cr, ft, false, walkSubtree))
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** The table is correct, how about the column position?
1:eac0369: 				*/
1:eac0369: 				if (cr.getSource().getColumnPosition() == columnPosition)
1:eac0369: 				{
1:eac0369: 					/* We've found the correct column - return it */
1:eac0369: 					return cr;
1:eac0369: 				}
1:eac0369: 			}
1:0be2d6e: 			walkSubtree = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (rightOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The right operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) rightOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(cr, ft, false, walkSubtree))
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** The table is correct, how about the column position?
1:eac0369: 				*/
1:eac0369: 				if (cr.getSource().getColumnPosition() == columnPosition)
1:eac0369: 				{
1:eac0369: 					/* We've found the correct column - return it */
1:eac0369: 					return cr;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Neither side is the column we're looking for */
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#getColumnOperand */
1:eac0369: 	public ColumnReference getColumnOperand(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		ColumnReference	cr;
1:eac0369: 
1:0be2d6e: 		boolean walkSubtree = true;
1:eac0369: 		if (leftOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The left operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) leftOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(
1:0be2d6e: 				cr, (FromTable)optTable, false, walkSubtree))
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** The table is correct.
1:eac0369: 				*/
1:eac0369: 				return cr;
1:eac0369: 			}
1:0be2d6e: 			walkSubtree = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (rightOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The right operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) rightOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(cr,
1:0be2d6e: 				(FromTable)optTable, false, walkSubtree))
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** The table is correct
1:eac0369: 				*/
1:eac0369: 				return cr;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Neither side is the column we're looking for */
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see RelationalOperator#getExpressionOperand
1:eac0369: 	 */
1:eac0369: 	public ValueNode getExpressionOperand(
2:eac0369: 								int tableNumber,
1:0be2d6e: 								int columnPosition,
1:05623b6: 								Optimizable ft)
1:eac0369: 	{
1:eac0369: 		ColumnReference	cr;
1:0be2d6e: 		boolean walkSubtree = true;
1:eac0369: 
1:eac0369: 		if (leftOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The left operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) leftOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(cr, ft, false, walkSubtree))
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** The table is correct, how about the column position?
1:eac0369: 				*/
1:eac0369: 				if (cr.getSource().getColumnPosition() == columnPosition)
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** We've found the correct column -
1:eac0369: 					** return the other side
1:eac0369: 					*/
1:eac0369: 					return rightOperand;
1:eac0369: 				}
1:eac0369: 			}
1:0be2d6e: 			walkSubtree = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (rightOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The right operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) rightOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(cr, ft, false, walkSubtree))
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** The table is correct, how about the column position?
1:eac0369: 				*/
1:eac0369: 				if (cr.getSource().getColumnPosition() == columnPosition)
1:eac0369: 				{
1:eac0369: 					/*
1:eac0369: 					** We've found the correct column -
1:eac0369: 					** return the other side
1:eac0369: 					*/
1:eac0369: 					return leftOperand;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:0be2d6e: 		return null;
1:9d82913: 	}
1:eac0369: 
1:1ad3b32: 	/**
1:0be2d6e: 	 * @see RelationalOperator#getOperand
1:1ad3b32: 	 */
1:0be2d6e: 	public ValueNode getOperand(ColumnReference cRef,
1:0be2d6e: 		int refSetSize, boolean otherSide)
1:eac0369: 	{
1:0be2d6e: 		// Following call will initialize/reset the btnVis,
1:0be2d6e: 		// valNodeBaseTables, and optBaseTables fields of this object.
1:0be2d6e: 		initBaseTableVisitor(refSetSize, true);
1:eac0369: 
1:0be2d6e: 		// We search for the column reference by getting the *base*
1:0be2d6e: 		// table number for each operand and checking to see if
1:0be2d6e: 		// that matches the *base* table number for the cRef
1:0be2d6e: 		// that we're looking for.  If so, then we the two
1:0be2d6e: 		// reference the same table so we go on to check
1:0be2d6e: 		// column position.
1:0be2d6e: 		try {
1:eac0369: 
1:0be2d6e: 			// Use optBaseTables for cRef's base table numbers.
1:0be2d6e: 			btnVis.setTableMap(optBaseTables);
1:0be2d6e: 			cRef.accept(btnVis);
1:eac0369: 
1:0be2d6e: 			// Use valNodeBaseTables for operand base table nums.
1:0be2d6e: 			btnVis.setTableMap(valNodeBaseTables);
1:eac0369: 
1:eac0369: 			ColumnReference	cr;
1:0be2d6e: 			if (leftOperand instanceof ColumnReference)
1:32edb61: 			{
1:0be2d6e: 				/*
1:0be2d6e: 				** The left operand is a column reference.
1:0be2d6e: 				** Is it the correct column?
1:1ad3b32: 				*/
1:0be2d6e: 				cr = (ColumnReference) leftOperand;
1:0be2d6e: 				cr.accept(btnVis);
1:0be2d6e: 				valNodeBaseTables.and(optBaseTables);
1:0be2d6e: 				if (valNodeBaseTables.getFirstSetBit() != -1)
1:9d82913: 				{
1:0be2d6e: 					/*
1:0be2d6e: 					** The table is correct, how about the column position?
1:0be2d6e: 					*/
1:0be2d6e: 					if (cr.getSource().getColumnPosition() ==
1:0be2d6e: 						cRef.getColumnNumber())
1:1ad3b32: 					{
1:0be2d6e: 						/*
1:0be2d6e: 						** We've found the correct column -
1:0be2d6e: 						** return the appropriate side.
1:0be2d6e: 						*/
1:0be2d6e: 						if (otherSide)
1:0be2d6e: 							return rightOperand;
1:0be2d6e: 						return leftOperand;
1:1ad3b32: 					}
1:1ad3b32: 				}
1:0be2d6e: 			}
1:eac0369: 
1:0be2d6e: 			if (rightOperand instanceof ColumnReference)
1:1ad3b32: 			{
1:0be2d6e: 				/*
1:0be2d6e: 				** The right operand is a column reference.
1:0be2d6e: 				** Is it the correct column?
1:0be2d6e: 				*/
1:0be2d6e: 				valNodeBaseTables.clearAll();
1:0be2d6e: 				cr = (ColumnReference) rightOperand;
1:0be2d6e: 				cr.accept(btnVis);
1:0be2d6e: 				valNodeBaseTables.and(optBaseTables);
1:0be2d6e: 				if (valNodeBaseTables.getFirstSetBit() != -1)
1:0be2d6e: 				{
1:0be2d6e: 					/*
1:0be2d6e: 					** The table is correct, how about the column position?
1:0be2d6e: 					*/
1:0be2d6e: 					if (cr.getSource().getColumnPosition() == 
1:0be2d6e: 						cRef.getColumnNumber())
1:0be2d6e: 					{
1:0be2d6e: 						/*
1:0be2d6e: 						** We've found the correct column -
1:0be2d6e: 						** return the appropriate side
1:0be2d6e: 						*/
1:0be2d6e: 						if (otherSide)
1:0be2d6e: 							return leftOperand;
1:0be2d6e: 						return rightOperand;
1:0be2d6e: 					}
1:0be2d6e: 				}
1:0be2d6e: 			}
1:eac0369: 
1:0be2d6e: 		} catch (StandardException se) {
1:eac0369:             if (SanityManager.DEBUG)
1:0be2d6e:             {
1:0be2d6e:                 SanityManager.THROWASSERT("Failed when trying to " +
1:e7d2a42:                     "find base table number for column reference check:", se);
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see RelationalOperator#generateExpressionOperand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void generateExpressionOperand(
1:eac0369: 								Optimizable optTable,
1:eac0369: 								int columnPosition,
1:05623b6: 								ExpressionClassBuilderInterface acbi,
1:eac0369: 								MethodBuilder mb)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:05623b6:         ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
1:eac0369: 		FromBaseTable	ft;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369:     		SanityManager.ASSERT(optTable instanceof FromBaseTable);
1:eac0369:     	}
1:eac0369: 		ft = (FromBaseTable) optTable;
1:eac0369: 
1:0be2d6e: 		ValueNode exprOp = getExpressionOperand(
1:0be2d6e: 			ft.getTableNumber(), columnPosition, ft);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (exprOp == null)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"ColumnReference for correct column (columnPosition = " +
1:eac0369: 					columnPosition +
1:eac0369: 					", exposed table name = " + ft.getExposedName() +
1:eac0369: 				") not found on either side of BinaryRelationalOperator");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		exprOp.generateExpression(acb, mb);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#selfComparison 
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean selfComparison(ColumnReference cr)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ValueNode	otherSide;
1:eac0369: 		JBitSet		tablesReferenced;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Figure out which side the given ColumnReference is on,
1:eac0369: 		** and look for the same table on the other side.
1:eac0369: 		*/
1:eac0369: 		if (leftOperand == cr)
1:eac0369: 		{
1:eac0369: 			otherSide = rightOperand;
1:eac0369: 		}
1:eac0369: 		else if (rightOperand == cr)
1:eac0369: 		{
1:eac0369: 			otherSide = leftOperand;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			otherSide = null;
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 			  		"ColumnReference not found on either side of binary comparison.");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		tablesReferenced = otherSide.getTablesReferenced();
1:eac0369: 
1:eac0369: 		/* Return true if the table we're looking for is in the bit map */
1:eac0369: 		return tablesReferenced.get(cr.getTableNumber());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#usefulStartKey */
1:eac0369: 	public boolean usefulStartKey(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Determine whether this operator is a useful start operator
1:eac0369: 		** with knowledge of whether the key column is on the left or right.
1:eac0369: 		*/
1:eac0369: 		int	columnSide = columnOnOneSide(optTable);
1:eac0369: 
1:eac0369: 		if (columnSide == NEITHER)
1:eac0369: 			return false;
1:eac0369: 		else
1:eac0369: 			return usefulStartKey(columnSide == LEFT);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if a key column for the given table is found on the
1:eac0369: 	 * left side of this operator, false if it is found on the right
1:eac0369: 	 * side of this operator.
1:eac0369: 	 *
1:eac0369: 	 * NOTE: This method assumes that a key column will be found on one
1:eac0369: 	 * side or the other.  If you don't know whether a key column exists,
1:eac0369: 	 * use the columnOnOneSide() method (below).
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The Optimizable table that we're looking for a key
1:eac0369: 	 *					column on.
1:eac0369: 	 *
1:eac0369: 	 * @return true if a key column for the given table is on the left
1:eac0369: 	 *			side of this operator, false if one is found on the right
1:eac0369: 	 *			side of this operator.
1:eac0369: 	 */
1:eac0369: 	protected boolean keyColumnOnLeft(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		ColumnReference	cr;
1:eac0369: 		boolean			left = false;
1:eac0369: 
1:eac0369: 		/* Is the key column on the left or the right? */
1:eac0369: 		if (leftOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The left operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) leftOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(
1:0be2d6e: 				cr, (FromTable)optTable, false, true))
1:eac0369: 			{
1:eac0369: 				/* The left operand is the key column */
1:eac0369: 				left = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:0be2d6e: 		// Else the right operand must be the key column.
1:eac0369:     	if (SanityManager.DEBUG)
1:eac0369: 		{
1:0be2d6e: 			if (!left)
1:eac0369: 			{
1:0be2d6e: 		    	SanityManager.ASSERT(
1:0be2d6e: 					(rightOperand instanceof ColumnReference) &&
1:0be2d6e: 					valNodeReferencesOptTable((ColumnReference)rightOperand,
1:0be2d6e: 			    		(FromTable)optTable, false, true),
1:eac0369: 					"Key column not found on either side.");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return left;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* Return values for columnOnOneSide */
1:eac0369: 	protected static final int LEFT = -1;
1:eac0369: 	protected static final int NEITHER = 0;
1:eac0369: 	protected static final int RIGHT = 1;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine whether there is a column from the given table on one side
1:eac0369: 	 * of this operator, and if so, which side is it on?
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The Optimizable table that we're looking for a key
1:eac0369: 	 *					column on.
1:eac0369: 	 *
1:eac0369: 	 * @return	LEFT if there is a column on the left, RIGHT if there is
1:eac0369: 	 *			a column on the right, NEITHER if no column found on either
1:eac0369: 	 *			side.
1:eac0369: 	 */
1:eac0369: 	protected int columnOnOneSide(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		ColumnReference	cr;
1:eac0369: 		boolean			left = false;
1:0be2d6e: 		boolean			walkSubtree = true;
1:eac0369: 
1:eac0369: 		/* Is a column on the left */
1:eac0369: 		if (leftOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The left operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) leftOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(
1:0be2d6e: 				cr, (FromTable)optTable, false, walkSubtree))
1:eac0369: 			{
1:eac0369: 				/* Key column found on left */
1:eac0369: 				return LEFT;
1:eac0369: 			}
1:0be2d6e: 			walkSubtree = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (rightOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The right operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) rightOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(
1:0be2d6e: 				cr, (FromTable)optTable, false, walkSubtree))
1:eac0369: 			{
1:eac0369: 				/* Key column found on right */
1:eac0369: 				return RIGHT;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return NEITHER;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#usefulStopKey */
1:eac0369: 	public boolean usefulStopKey(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Determine whether this operator is a useful start operator
1:eac0369: 		** with knowledge of whether the key column is on the left or right.
1:eac0369: 		*/
1:eac0369: 		int	columnSide = columnOnOneSide(optTable);
1:eac0369: 
1:eac0369: 		if (columnSide == NEITHER)
1:eac0369: 			return false;
1:eac0369: 		else
1:eac0369: 			return usefulStopKey(columnSide == LEFT);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine whether this comparison operator is a useful stop key
1:eac0369: 	 * with knowledge of whether the key column is on the left or right.
1:eac0369: 	 *
1:eac0369: 	 * @param left	true means the key column is on the left, false means
1:eac0369: 	 *				it is on the right.
1:eac0369: 	 *
1:eac0369: 	 * @return	true if this is a useful stop key
1:eac0369: 	 */
1:eac0369: 	/** @see RelationalOperator#generateAbsoluteColumnId */
1:eac0369: 	public void generateAbsoluteColumnId(MethodBuilder mb,
1:eac0369: 											   Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		// Get the absolute column position for the column
1:eac0369: 		int columnPosition = getAbsoluteColumnPosition(optTable);
1:eac0369: 
1:eac0369: 		mb.push(columnPosition);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#generateRelativeColumnId */
1:eac0369: 	public void generateRelativeColumnId(MethodBuilder mb,
1:eac0369: 											   Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		// Get the absolute column position for the column
1:eac0369: 		int columnPosition = getAbsoluteColumnPosition(optTable);
1:eac0369: 		// Convert the absolute to the relative 0-based column position
1:eac0369: 		columnPosition = optTable.convertAbsoluteToRelativeColumnPosition(
1:eac0369: 								columnPosition);
1:eac0369: 
1:eac0369: 		mb.push(columnPosition);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the absolute 0-based column position of the ColumnReference from 
1:eac0369: 	 * the conglomerate for this Optimizable.
1:eac0369: 	 *
1:eac0369: 	 * @param optTable	The Optimizable
1:eac0369: 	 *
1:eac0369: 	 * @return The absolute 0-based column position of the ColumnReference
1:eac0369: 	 */
1:eac0369: 	private int getAbsoluteColumnPosition(Optimizable optTable)
1:eac0369: 	{
1:eac0369: 		ColumnReference	cr;
1:eac0369: 		ConglomerateDescriptor bestCD;
1:eac0369: 		int columnPosition;
1:eac0369: 
1:eac0369: 		if (keyColumnOnLeft(optTable))
1:eac0369: 		{
1:eac0369: 			cr = (ColumnReference) leftOperand;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			cr = (ColumnReference) rightOperand;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		bestCD = optTable.getTrulyTheBestAccessPath().
1:eac0369: 												getConglomerateDescriptor();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Column positions are one-based, store is zero-based.
1:eac0369: 		*/
1:eac0369: 		columnPosition = cr.getSource().getColumnPosition();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If it's an index, find the base column position in the index
1:eac0369: 		** and translate it to an index column position.
1:eac0369: 		*/
1:eac0369: 		if (bestCD != null && bestCD.isIndex())
1:eac0369: 		{
1:eac0369: 			columnPosition = bestCD.getIndexDescriptor().
1:eac0369: 			  getKeyColumnPosition(columnPosition);
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(columnPosition > 0,
1:eac0369: 					"Base column not found in index");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// return the 0-based column position
1:eac0369: 		return columnPosition - 1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:05623b6:     public void generateQualMethod(ExpressionClassBuilderInterface acbi,
1:eac0369: 								   MethodBuilder mb,
1:eac0369: 								   Optimizable optTable)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:05623b6:         ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
1:05623b6: 
1:eac0369: 		/* Generate a method that returns the expression */
1:eac0369: 		MethodBuilder qualMethod = acb.newUserExprFun();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Generate the expression that's on the opposite side
1:eac0369: 		** of the key column
1:eac0369: 		*/
1:eac0369: 		if (keyColumnOnLeft(optTable))
1:eac0369: 		{
1:eac0369: 			rightOperand.generateExpression(acb, qualMethod);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			leftOperand.generateExpression(acb, qualMethod);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		qualMethod.methodReturn();
1:eac0369: 		qualMethod.complete();
1:eac0369: 
1:eac0369: 		/* push an expression that evaluates to the GeneratedMethod */
1:eac0369: 		acb.pushMethodReference(mb, qualMethod);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#generateOrderedNulls */
1:eac0369: 	public void generateOrderedNulls(MethodBuilder mb)
1:eac0369: 	{
1:eac0369: 		mb.push(false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#orderedNulls */
1:eac0369: 	public boolean orderedNulls()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#isQualifier 
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:0be2d6e: 	public boolean isQualifier(Optimizable optTable, boolean forPush)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:1ad3b32: 		/* If this rel op is for an IN-list probe predicate then we never
1:1ad3b32: 		 * treat it as a qualifer.  The reason is that if we treat it as
1:1ad3b32: 		 * a qualifier then we could end up generating it as a qualifier,
1:1ad3b32: 		 * which would lead to the generation of an equality qualifier
1:1ad3b32: 		 * of the form "col = <val>" (where <val> is the first value in
1:1ad3b32: 		 * the IN-list).  That would lead to wrong results (missing rows)
1:1ad3b32: 		 * because that restriction is incorrect.
1:1ad3b32: 		 */
1:32edb61: 		if (isInListProbeNode())
1:1ad3b32: 			return false;
1:eac0369: 
2:eac0369: 		FromTable	ft;
1:eac0369: 		ValueNode	otherSide = null;
1:eac0369: 		JBitSet		tablesReferenced;
1:3bb140c:         ColumnReference cr;
1:eac0369: 		boolean	found = false;
1:0be2d6e: 		boolean walkSubtree = true;
1:eac0369: 
2:eac0369: 		ft = (FromTable) optTable;
1:eac0369: 
1:eac0369: 		if (leftOperand instanceof ColumnReference)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The left operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) leftOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(cr, ft, forPush, walkSubtree))
1:eac0369: 			{
1:eac0369: 				otherSide = rightOperand;
1:eac0369: 				found = true;
1:eac0369: 			}
1:0be2d6e: 			walkSubtree = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if ( ( ! found) && (rightOperand instanceof ColumnReference) )
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** The right operand is a column reference.
1:eac0369: 			** Is it the correct column?
1:eac0369: 			*/
1:eac0369: 			cr = (ColumnReference) rightOperand;
1:0be2d6e: 			if (valNodeReferencesOptTable(cr, ft, forPush, walkSubtree))
1:eac0369: 			{
1:eac0369: 				otherSide = leftOperand;
1:eac0369: 				found = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Have we found a ColumnReference on either side? */
1:eac0369: 		if ( ! found)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Neither side is a ColumnReference to the table we're looking
1:eac0369: 			** for, so it can't be a Qualifier
1:eac0369: 			*/
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** One side is a ColumnReference to the correct table.  It is a
1:eac0369: 		** Qualifier if the other side does not refer to the table we are
1:eac0369: 		** optimizing.
1:eac0369: 		*/
1:0be2d6e: 		return !valNodeReferencesOptTable(otherSide, ft, forPush, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see RelationalOperator#getOrderableVariantType 
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException	thrown on error
1:eac0369: 	 */
1:eac0369: 	public int getOrderableVariantType(Optimizable optTable) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/* The Qualifier's orderable is on the opposite side from
1:eac0369: 		 * the key column.
1:eac0369: 		 */
1:eac0369: 		if (keyColumnOnLeft(optTable))
1:eac0369: 		{
1:eac0369: 			return rightOperand.getOrderableVariantType();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return leftOperand.getOrderableVariantType();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#compareWithKnownConstant */
1:eac0369: 	public boolean compareWithKnownConstant(Optimizable optTable, boolean considerParameters)
1:eac0369: 	{
1:3bb140c:         ValueNode node = keyColumnOnLeft(optTable) ? rightOperand : leftOperand;
1:eac0369: 
1:eac0369: 		if (considerParameters)
1:eac0369: 		{
1:eac0369: 			return (node instanceof ConstantNode) ||
1:d5bc20f: 						((node.requiresTypeFromContext()) &&
1:eac0369: 						 (((ParameterNode)node).getDefaultValue() != null));
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return node instanceof ConstantNode;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see RelationalOperator#getCompareValue
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getCompareValue(Optimizable optTable) 
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		/* The value being compared to is on the opposite side from
1:eac0369: 		** the key column.
1:eac0369: 		*/
1:3bb140c:         ValueNode node = keyColumnOnLeft(optTable) ? rightOperand : leftOperand;
1:eac0369: 
1:eac0369: 		if (node instanceof ConstantNode) 
1:eac0369: 		{
1:eac0369: 			return ((ConstantNode)node).getValue();
1:eac0369: 		}
1:d5bc20f: 		else if (node.requiresTypeFromContext())
1:eac0369: 		{
1:d5bc20f: 			ParameterNode pn;
1:d5bc20f: 			if (node instanceof UnaryOperatorNode) 
1:d5bc20f: 	  			pn = ((UnaryOperatorNode)node).getParameterOperand();
1:eac0369: 			else
1:d5bc20f: 	  			pn = (ParameterNode) (node);
1:d5bc20f: 			return pn.getDefaultValue();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{	
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return 50% if this is a comparison with a boolean column, a negative
1:eac0369: 	 * selectivity otherwise.
1:eac0369: 	 */
1:eac0369: 	protected double booleanSelectivity(Optimizable optTable)
1:6718a25: 	throws StandardException
1:eac0369: 	{
1:eac0369: 		TypeId	typeId = null;
1:eac0369: 		double				retval = -1.0d;
1:eac0369: 		int					columnSide;
1:eac0369: 
1:eac0369: 		columnSide = columnOnOneSide(optTable);
1:eac0369: 
1:eac0369: 		if (columnSide == LEFT)
1:eac0369: 			typeId = leftOperand.getTypeId();
1:eac0369: 		else if (columnSide == RIGHT)
1:eac0369: 			typeId = rightOperand.getTypeId();
1:eac0369: 
1:eac0369: 		if (typeId != null && (typeId.getJDBCTypeId() == Types.BIT ||
1:1a4ea31: 		typeId.getJDBCTypeId() == Types.BOOLEAN))
1:eac0369: 			retval = 0.5d;
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The methods generated for this node all are on Orderable.  
1:eac0369: 	 * Overrides this method
1:eac0369: 	 * in BooleanOperatorNode for code generation purposes.
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     String getReceiverInterfaceName() {
1:eac0369: 	    return ClassName.DataValueDescriptor;
1:eac0369: 	}
1:568cbf1: 
1:568cbf1:     /**
1:568cbf1:      * See if the node always evaluates to true or false, and return a Boolean
1:568cbf1:      * constant node if it does.
1:568cbf1:      *
1:377790f:      * @return a node representing a Boolean constant if the result of the
1:377790f:      * operator is known; otherwise, this operator node
1:568cbf1:      */
1:3bb140c:     @Override
1:568cbf1:     ValueNode evaluateConstantExpressions() throws StandardException {
1:568cbf1:         if (leftOperand instanceof ConstantNode &&
1:568cbf1:                 rightOperand instanceof ConstantNode) {
1:568cbf1:             ConstantNode leftOp = (ConstantNode) leftOperand;
1:568cbf1:             ConstantNode rightOp = (ConstantNode) rightOperand;
1:568cbf1:             DataValueDescriptor leftVal = leftOp.getValue();
1:568cbf1:             DataValueDescriptor rightVal = rightOp.getValue();
1:568cbf1: 
1:568cbf1:             if (!leftVal.isNull() && !rightVal.isNull()) {
1:568cbf1:                 int comp = leftVal.compare(rightVal);
1:2706d1f:                 switch (relOpType) {
1:568cbf1:                     case EQUALS_RELOP:
1:568cbf1:                         return newBool(comp == 0);
1:568cbf1:                     case NOT_EQUALS_RELOP:
1:568cbf1:                         return newBool(comp != 0);
1:568cbf1:                     case GREATER_THAN_RELOP:
1:568cbf1:                         return newBool(comp > 0);
1:568cbf1:                     case GREATER_EQUALS_RELOP:
1:568cbf1:                         return newBool(comp >= 0);
1:568cbf1:                     case LESS_THAN_RELOP:
1:568cbf1:                         return newBool(comp < 0);
1:568cbf1:                     case LESS_EQUALS_RELOP:
1:568cbf1:                         return newBool(comp <= 0);
1:568cbf1:                 }
1:568cbf1:             }
1:568cbf1:         }
1:568cbf1: 
1:568cbf1:         return this;
1:568cbf1:     }
1:568cbf1: 
1:568cbf1:     /**
1:568cbf1:      * Create a Boolean constant node with a specified value.
1:568cbf1:      *
1:568cbf1:      * @param b the value of the constant
1:568cbf1:      * @return a node representing a Boolean constant
1:568cbf1:      */
1:568cbf1:     private ValueNode newBool(boolean b) throws StandardException {
1:3bb140c:         return new BooleanConstantNode(b, getContextManager());
1:568cbf1:     }
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Returns the negation of this operator; negation of Equals is NotEquals.
1:eac0369: 	 */
1:eac0369: 	BinaryOperatorNode getNegation(ValueNode leftOperand, 
1:eac0369: 										  ValueNode rightOperand)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		BinaryOperatorNode negation;
1:eac0369: 		if (SanityManager.DEBUG)
1:ef158f2: 			SanityManager.ASSERT(getTypeServices() != null,
1:eac0369: 								 "dataTypeServices is expected to be non-null");
1:eac0369: 		/* xxxRESOLVE: look into doing this in place instead of allocating a new node */
1:3bb140c:         negation = new BinaryRelationalOperatorNode(getNegationNode(),
1:eac0369: 									 leftOperand, rightOperand,
1:3bb140c:                                      false,
1:0af1665: 									 getContextManager());
1:ef158f2: 		negation.setType(getTypeServices());
1:eac0369: 		return negation;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* map current node to its negation */
1:2706d1f:     private int getNegationNode()
1:eac0369: 	{
1:2706d1f:         switch (this.kind)
1:eac0369: 		{
1:2706d1f:             case K_EQUALS:
1:2706d1f:                 return K_NOT_EQUALS;
1:eac0369: 
1:2706d1f:             case K_GREATER_EQUALS:
1:2706d1f:                 return K_LESS_THAN;
1:eac0369: 
1:2706d1f:             case K_GREATER_THAN:
1:2706d1f:                 return K_LESS_EQUALS;
1:eac0369: 
1:2706d1f:             case K_LESS_THAN:
1:2706d1f:                 return K_GREATER_EQUALS;
1:eac0369: 				
1:2706d1f:             case K_LESS_EQUALS:
1:2706d1f:                 return K_GREATER_THAN;
1:eac0369: 
1:2706d1f:             case K_NOT_EQUALS:
1:2706d1f:                 return K_EQUALS;
1:eac0369: 
1:2706d1f:             default:
1:2706d1f:                 if (SanityManager.DEBUG) {
1:2706d1f:                     SanityManager.THROWASSERT(
1:2706d1f:                         "getNegationNode called with invalid node type: " +
1:2706d1f:                         kind);
1:2706d1f:                 }
1:2706d1f:         }
1:2706d1f:         return -1;
1:eac0369: 	}	
1:0af1665: 
1:0af1665:     /**
1:0af1665:      * Return an equivalent node with the operands swapped, and possibly with
1:0af1665:      * the operator type changed in order to preserve the meaning of the
1:0af1665:      * expression.
1:0af1665:      */
1:0af1665:     BinaryOperatorNode getSwappedEquivalent() throws StandardException {
1:3bb140c:         BinaryOperatorNode newNode = new BinaryRelationalOperatorNode(
1:2706d1f:             getKindForSwap(),
1:3bb140c:             rightOperand,
1:3bb140c:             leftOperand,
1:3bb140c:             false,
1:3bb140c:             getContextManager());
1:0af1665:         newNode.setType(getTypeServices());
1:0af1665:         return newNode;
1:0af1665:     }
1:0af1665: 
1:0af1665:     /**
1:0af1665:      * Return the node type that must be used in order to construct an
1:0af1665:      * equivalent expression if the operands are swapped. For symmetric
1:0af1665:      * operators ({@code =} and {@code <>}), the same node type is returned.
1:0af1665:      * Otherwise, the direction of the operator is switched in order to
1:0af1665:      * preserve the meaning (for instance, a node representing less-than will
1:0af1665:      * return the node type for greater-than).
1:0af1665:      *
1:0af1665:      * @return a node type that preserves the meaning of the expression if
1:0af1665:      * the operands are swapped
1:0af1665:      */
1:2706d1f:     private int getKindForSwap() {
1:2706d1f:         switch (this.kind) {
1:2706d1f:             case K_EQUALS:
1:2706d1f:                 return K_EQUALS;
1:2706d1f:             case K_GREATER_EQUALS:
1:2706d1f:                 return K_LESS_EQUALS;
1:2706d1f:             case K_GREATER_THAN:
1:2706d1f:                 return K_LESS_THAN;
1:2706d1f:             case K_LESS_THAN:
1:2706d1f:                 return K_GREATER_THAN;
1:2706d1f:             case K_LESS_EQUALS:
1:2706d1f:                 return K_GREATER_EQUALS;
1:2706d1f:             case K_NOT_EQUALS:
1:2706d1f:                 return K_NOT_EQUALS;
1:0af1665:             default:
1:0af1665:                 if (SanityManager.DEBUG) {
1:0af1665:                     SanityManager.THROWASSERT(
1:2706d1f:                             "Invalid operator type: " + kind);
1:0af1665:                 }
1:0af1665:                 return -1;
1:0af1665:         }
1:0af1665:     }
1:0af1665: 
1:eac0369: 	/**
1:eac0369: 	 * is this is useful start key? for example a predicate of the from
1:eac0369: 	 * <em>column Lessthan 5</em> is not a useful start key but is a useful stop
1:eac0369: 	 * key. However <em>5 Lessthan column </em> is a useful start key.
1:eac0369: 	 *
1:eac0369: 	 * @param columnOnLeft 	is true if the column is the left hand side of the
1:eac0369: 	 * binary operator.
1:eac0369: 	 */
1:eac0369: 	protected boolean usefulStartKey(boolean columnOnLeft)
1:eac0369: 	{
1:2706d1f:         switch (relOpType)
1:eac0369: 		{
1:eac0369: 			case RelationalOperator.EQUALS_RELOP:
2:eac0369: 				return true;
1:eac0369: 			case RelationalOperator.NOT_EQUALS_RELOP:
1:eac0369: 				return false;
1:eac0369: 			case RelationalOperator.GREATER_THAN_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1:eac0369: 				// col > 1
1:eac0369: 				return columnOnLeft;
1:eac0369: 			case RelationalOperator.LESS_THAN_RELOP:
1:eac0369: 			case RelationalOperator.LESS_EQUALS_RELOP:
1:eac0369: 				// col < 1
1:eac0369: 				return !columnOnLeft;
1:eac0369: 			default:
1:eac0369: 				return false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#usefulStopKey */
1:eac0369: 	protected boolean usefulStopKey(boolean columnOnLeft)
1:eac0369: 	{
1:2706d1f:         switch (relOpType)
1:eac0369: 		{
1:eac0369: 			case RelationalOperator.EQUALS_RELOP:
1:eac0369: 				return true;
1:eac0369: 			case RelationalOperator.NOT_EQUALS_RELOP:
1:eac0369: 				return false;
1:eac0369: 			case RelationalOperator.GREATER_THAN_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1:eac0369: 				// col > 1
1:eac0369: 				return !columnOnLeft;
1:eac0369: 			case RelationalOperator.LESS_EQUALS_RELOP:
1:eac0369: 			case RelationalOperator.LESS_THAN_RELOP:
1:eac0369: 				// col < 1
1:eac0369: 				return columnOnLeft;
1:eac0369: 			default:
1:eac0369: 				return false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/** @see RelationalOperator#getStartOperator */
1:eac0369: 	public int getStartOperator(Optimizable optTable)
1:eac0369: 	{
1:2706d1f:         switch (relOpType)
1:eac0369: 		{
1:eac0369: 			case RelationalOperator.EQUALS_RELOP:
1:eac0369: 			case RelationalOperator.LESS_EQUALS_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1:eac0369: 				return ScanController.GE;
1:eac0369: 			case RelationalOperator.LESS_THAN_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_THAN_RELOP:
1:eac0369: 				return ScanController.GT;
1:eac0369: 			case RelationalOperator.NOT_EQUALS_RELOP:				
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.THROWASSERT("!= cannot be a start operator");
1:eac0369: 				return ScanController.NA;
1:eac0369: 			default:
1:eac0369: 				return ScanController.NA;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/** @see RelationalOperator#getStopOperator */
1:eac0369: 	public int getStopOperator(Optimizable optTable)
1:eac0369: 	{
1:2706d1f:         switch (relOpType)
1:eac0369: 		{
1:eac0369: 			case RelationalOperator.EQUALS_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1:eac0369: 			case RelationalOperator.LESS_EQUALS_RELOP:
1:eac0369: 				return ScanController.GT;			
1:eac0369: 			case RelationalOperator.LESS_THAN_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_THAN_RELOP:
1:eac0369: 				return ScanController.GE;			
1:eac0369: 			case RelationalOperator.NOT_EQUALS_RELOP:				
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369: 					SanityManager.THROWASSERT("!= cannot be a stop operator");
1:eac0369: 				return ScanController.NA;				
1:eac0369: 			default:
1:eac0369: 				return ScanController.NA;				
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#generateOperator */
1:eac0369: 	public void generateOperator(MethodBuilder mb,
1:eac0369: 								 Optimizable optTable)
1:eac0369: 	{
1:2706d1f:         switch (relOpType)
1:eac0369: 		{
1:eac0369: 			case RelationalOperator.EQUALS_RELOP:
1:eac0369: 				mb.push(Orderable.ORDER_OP_EQUALS);
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case RelationalOperator.NOT_EQUALS_RELOP:
1:eac0369: 				mb.push(Orderable.ORDER_OP_EQUALS);
1:eac0369: 				break;
1:eac0369: 
1:eac0369: 			case RelationalOperator.LESS_THAN_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1:eac0369: 				mb.push(keyColumnOnLeft(optTable) ? 
1:eac0369: 						Orderable.ORDER_OP_LESSTHAN : Orderable.ORDER_OP_LESSOREQUALS);
1:eac0369: 				break;
1:eac0369: 			case RelationalOperator.LESS_EQUALS_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_THAN_RELOP:
1:eac0369: 				mb.push(keyColumnOnLeft(optTable) ? 
1:eac0369: 						Orderable.ORDER_OP_LESSOREQUALS : Orderable.ORDER_OP_LESSTHAN);
1:eac0369: 				
1:eac0369: 		}											
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/** @see RelationalOperator#generateNegate */
1:eac0369: 	public void generateNegate(MethodBuilder mb, Optimizable optTable)
1:eac0369: 	{
1:2706d1f:         switch (relOpType)
1:eac0369: 		{
1:eac0369: 			case RelationalOperator.EQUALS_RELOP:
1:eac0369: 				mb.push(false);
1:eac0369: 				break;
1:eac0369: 			case RelationalOperator.NOT_EQUALS_RELOP:
1:eac0369: 				mb.push(true);
1:eac0369: 				break;
1:eac0369: 			case RelationalOperator.LESS_THAN_RELOP:
1:eac0369: 			case RelationalOperator.LESS_EQUALS_RELOP:
1:eac0369: 				mb.push(!keyColumnOnLeft(optTable));
1:eac0369: 				break;
1:eac0369: 			case RelationalOperator.GREATER_THAN_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1:eac0369: 				mb.push(keyColumnOnLeft(optTable));
1:eac0369: 				break;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 		
1:eac0369: 	/** @see RelationalOperator#getOperator */
1:eac0369: 	public int getOperator()
1:eac0369: 	{
1:2706d1f:         return relOpType;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** return the selectivity of this predicate.
1:eac0369: 	 */
1:e1f49ca:     @Override @SuppressWarnings("fallthrough")
1:eac0369: 	public double selectivity(Optimizable optTable)
1:d5bc20f: 	throws StandardException
1:eac0369: 	{
1:eac0369: 		double retval = booleanSelectivity(optTable);
1:eac0369: 		
1:eac0369: 		if (retval >= 0.0d)
1:eac0369: 			return retval;
1:eac0369: 			
1:2706d1f:         switch (relOpType)
1:eac0369: 		{
1:eac0369: 			case RelationalOperator.EQUALS_RELOP:
1:eac0369: 				return 0.1;
1:eac0369: 			case RelationalOperator.NOT_EQUALS_RELOP:
1:eac0369: 			case RelationalOperator.LESS_THAN_RELOP:
1:eac0369: 			case RelationalOperator.LESS_EQUALS_RELOP:
1:eac0369: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1:eac0369: 				if (getBetweenSelectivity())
1:eac0369: 					return 0.5d;
1:eac0369: 				/* fallthrough -- only */
1:eac0369: 			case RelationalOperator.GREATER_THAN_RELOP:
1:eac0369: 				return 0.33;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		return 0.0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RelationalOperator#getTransitiveSearchClause */
1:3bb140c:     @Override
1:eac0369: 	public RelationalOperator getTransitiveSearchClause(ColumnReference otherCR)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:2706d1f:         return new BinaryRelationalOperatorNode(kind,
1:3bb140c:                                                 otherCR,
1:3bb140c:                                                 rightOperand,
1:3bb140c:                                                 false,
1:3bb140c:                                                 getContextManager());
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	public boolean equalsComparisonWithConstantExpression(Optimizable optTable)
1:eac0369: 	{
1:2706d1f:         if (relOpType != EQUALS_RELOP)
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		boolean retval = false;
1:eac0369: 		ValueNode comparand = null;
1:eac0369: 
1:eac0369: 		int side = columnOnOneSide(optTable);
1:eac0369: 		if (side == LEFT)
1:eac0369: 		{
1:eac0369: 			retval = rightOperand.isConstantExpression();
1:eac0369: 		}
1:eac0369: 		else if (side == RIGHT)
1:eac0369: 		{
1:eac0369: 			retval = leftOperand.isConstantExpression();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/** @see ValueNode#isRelationalOperator */
1:3bb140c:     @Override
1:3bb140c:     boolean isRelationalOperator()
1:eac0369: 	{
1:1ad3b32: 		/* If this rel op is for a probe predicate then we do not call
1:1ad3b32: 		 * it a "relational operator"; it's actually a disguised IN-list
1:1ad3b32: 		 * operator.
1:1ad3b32: 		 */
1:32edb61: 		return !isInListProbeNode();
1:eac0369: 	}
1:eac0369: 	
1:1ad3b32: 	/** @see ValueNode#isBinaryEqualsOperatorNode */
1:3bb140c:     @Override
1:3bb140c:     boolean isBinaryEqualsOperatorNode()
1:eac0369: 	{
1:1ad3b32: 		/* If this rel op is for a probe predicate then we do not treat
1:1ad3b32: 		 * it as an "equals operator"; it's actually a disguised IN-list
1:1ad3b32: 		 * operator.
1:1ad3b32: 		 */
1:32edb61: 		return !isInListProbeNode() &&
1:2706d1f:             (relOpType == RelationalOperator.EQUALS_RELOP);
1:eac0369: 	}
1:eac0369: 
1:32edb61: 	/**
1:32edb61: 	 * @see ValueNode#isInListProbeNode
1:32edb61: 	 *
1:32edb61: 	 * It's okay for this method to reference inListProbeSource directly
1:32edb61: 	 * because it does not rely on the contents of inListProbeSource's
1:32edb61: 	 * leftOperand, and a caller of this method cannot gain access to
1:32edb61: 	 * inListProbeSource's leftOperand through this method.
1:32edb61: 	 */
1:3bb140c:     @Override
1:3bb140c:     boolean isInListProbeNode()
1:eac0369: 	{
1:9d82913: 		return (inListProbeSource != null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see ValueNode#optimizableEqualityNode */
1:3bb140c:     @Override
1:3bb140c:     boolean optimizableEqualityNode(Optimizable optTable,
1:eac0369: 										   int columnNumber, 
1:eac0369: 										   boolean isNullOkay)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:2706d1f:         if (relOpType != EQUALS_RELOP)
1:eac0369: 			return false;
1:eac0369: 
1:1ad3b32: 		/* If this rel op is for a probe predicate then we do not treat
1:1ad3b32: 		 * it as an equality node; it's actually a disguised IN-list node.
1:1ad3b32: 		 */
1:32edb61: 		if (isInListProbeNode())
1:1ad3b32: 			return false;
1:eac0369: 
1:eac0369: 		ColumnReference cr = getColumnOperand(optTable,
1:eac0369: 											  columnNumber);
1:eac0369: 		if (cr == null)
1:eac0369: 			return false;
1:eac0369: 
1:eac0369: 		if (selfComparison(cr))
1:eac0369: 			return false;
1:eac0369: 		
1:eac0369: 		if (implicitVarcharComparison())
1:eac0369: 			return false;
1:eac0369: 		
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Return whether or not this binary relational predicate requires an implicit
1:eac0369: 	 * (var)char conversion.  This is important when considering
1:eac0369: 	 * hash join since this type of equality predicate is not currently
1:eac0369: 	 * supported for a hash join.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not an implicit (var)char conversion is required for
1:eac0369: 	 *			this binary relational operator.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	private boolean implicitVarcharComparison()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		TypeId leftType = leftOperand.getTypeId();
1:eac0369: 		TypeId rightType = rightOperand.getTypeId();
1:eac0369: 		
1:eac0369: 		if (leftType.isStringTypeId() && !rightType.isStringTypeId())
1:eac0369: 			return true;
1:eac0369: 
1:eac0369: 		if (rightType.isStringTypeId() && (!leftType.isStringTypeId()))
1:eac0369: 			return true;
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/* @see BinaryOperatorNode#genSQLJavaSQLTree
1:eac0369: 	 * @see BinaryComparisonOperatorNode#genSQLJavaSQLTree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode genSQLJavaSQLTree() throws StandardException
1:eac0369: 	{
1:2706d1f:         if (relOpType == EQUALS_RELOP)
1:eac0369: 			return this;
1:eac0369: 		
1:eac0369: 		return super.genSQLJavaSQLTree();
1:eac0369: 	}
1:eac0369: 
1:1ad3b32: 	/**
1:6718a25: 	 * Take a ResultSetNode and return a column reference that is scoped for
1:6718a25: 	 * for the received ResultSetNode, where "scoped" means that the column
1:6718a25: 	 * reference points to a specific column in the RSN.  This is used for
1:6718a25: 	 * remapping predicates from an outer query down to a subquery. 
1:6eeba4f: 	 *
1:6718a25: 	 * For example, assume we have the following query:
2:6718a25: 	 *
1:6718a25: 	 *  select * from
1:6718a25: 	 *    (select i,j from t1 union select i,j from t2) X1,
1:6718a25: 	 *    (select a,b from t3 union select a,b from t4) X2
1:6718a25: 	 *  where X1.j = X2.b;
1:6718a25: 	 *
1:6718a25: 	 * Then assume that this BinaryRelationalOperatorNode represents the
1:6718a25: 	 * "X1.j = X2.b" predicate and that the childRSN we received as a
1:6718a25: 	 * parameter represents one of the subqueries to which we want to push
1:6718a25: 	 * the predicate; let's say it's:
1:6718a25: 	 *
1:6718a25: 	 *    select i,j from t1
1:6718a25: 	 *
1:6718a25: 	 * Then what we want to do in this method is map one of the operands
1:6718a25: 	 * X1.j or X2.b (depending on the 'whichSide' parameter) to the childRSN,
1:6718a25: 	 * if possible.  Note that in our example, "X2.b" should _NOT_ be mapped
1:6718a25: 	 * because it doesn't apply to the childRSN for the subquery "select i,j
1:6718a25: 	 * from t1"; thus we should leave it as it is.  "X1.j", however, _does_
1:6718a25: 	 * need to be scoped, and so this method will return a ColumnReference
1:6718a25: 	 * pointing to "T1.j" (or whatever the corresponding column in T1 is).
1:6718a25: 	 *
1:6718a25: 	 * ASSUMPTION: We should only get to this method if we know that
1:df88f63: 	 * exactly one operand in the predicate to which this operator belongs
1:6718a25: 	 * can and should be mapped to the received childRSN. 
1:6718a25: 	 *
1:6718a25:      * @param whichSide The operand are we trying to scope (LEFT or RIGHT)
1:6718a25:      * @param parentRSNsTables Set of all table numbers referenced by
1:6718a25:      *  the ResultSetNode that is _parent_ to the received childRSN.
1:6718a25:      *  We need this to make sure we don't scope the operand to a
1:6718a25:      *  ResultSetNode to which it doesn't apply.
1:6718a25:      * @param childRSN The result set node to which we want to create
1:6718a25:      *  a scoped predicate.
1:df88f63:      * @param whichRC If not -1 then this tells us which ResultColumn
1:df88f63:      *  in the received childRSN we need to use for the scoped predicate;
1:df88f63:      *  if -1 then the column position of the scoped column reference
1:df88f63:      *  will be stored in this array and passed back to the caller.
1:6718a25:      * @return A column reference scoped to the received childRSN, if possible.
1:6718a25:      *  If the operand is a ColumnReference that is not supposed to be scoped,
1:6718a25: 	 *  we return a _clone_ of the reference--this is necessary because the
1:6718a25: 	 *  reference is going to be pushed to two places (left and right children
1:6718a25: 	 *  of the parentRSN) and if both children are referencing the same
1:6718a25: 	 *  instance of the column reference, they'll interfere with each other
1:6718a25: 	 *  during optimization.
1:0be2d6e: 	 */
1:3bb140c:     ValueNode getScopedOperand(int whichSide,
1:df88f63: 		JBitSet parentRSNsTables, ResultSetNode childRSN,
1:df88f63: 		int [] whichRC) throws StandardException
1:0be2d6e: 	{
1:3bb140c:         ResultColumn rc;
1:6718a25: 		ColumnReference cr = 
1:6718a25: 			whichSide == LEFT
1:6718a25: 				? (ColumnReference)leftOperand
1:6718a25: 				: (ColumnReference)rightOperand;
1:eac0369: 
1:df88f63: 		/* When we scope a predicate we only scope one side of it--the
1:df88f63: 		 * side that is to be evaluated against childRSN.  We figure out
1:df88f63: 		 * if "cr" is that side by using table numbers, as seen below.
1:df88f63: 		 * This means that for every scoped predicate there will be one
1:df88f63: 		 * operand that is scoped and one operand that is not scoped.  
1:df88f63: 		 * When we get here for the operand that will not be scoped,
1:df88f63: 		 * we'll just return a clone of that operand.  So in the example
1:df88f63: 		 * mentioned above, the scoped predicate for the left child of
1:df88f63: 		 * X1 would be
1:df88f63: 		 *
1:df88f63: 		 *   T1.j <scoped> = X2.b <clone> 
1:df88f63: 		 *
1:df88f63: 		 * That said, the first thing we need to do is see if this
1:df88f63: 		 * ColumnReference is supposed to be scoped for childRSN.  We
1:df88f63: 		 * do that by figuring out what underlying base table the column
1:df88f63: 		 * reference is pointing to and then seeing if that base table
1:df88f63: 		 * is included in the list of table numbers from the parentRSN.
1:df88f63: 		 */
1:6718a25: 		JBitSet crTables = new JBitSet(parentRSNsTables.size());
1:3bb140c:         BaseTableNumbersVisitor btnVisitor =
1:6718a25: 			new BaseTableNumbersVisitor(crTables);
1:3bb140c:         cr.accept(btnVisitor);
1:32edb61: 
1:6718a25: 		/* If the column reference in question is not intended for
1:6718a25: 		 * the received result set node, just leave the operand as
1:6718a25: 		 * it is (i.e. return a clone).  In the example mentioned at
1:6718a25: 		 * the start of this method, this will happen when the operand
1:6718a25: 		 * is X2.b and childRSN is either "select i,j from t1" or
1:6718a25: 		 * "select i,j from t2", in which case the operand does not
1:6718a25: 		 * apply to childRSN.  When we get here and try to map the
1:6718a25: 		 * "X1.j" operand, though, the following "contains" check will
1:6718a25: 		 * return true and thus we can go ahead and return a scoped
1:6718a25: 		 * version of that operand.
1:0be2d6e: 		 */
1:6718a25: 		if (!parentRSNsTables.contains(crTables))
1:df88f63: 			return (ColumnReference)cr.getClone();
1:9d82913: 
1:6718a25: 		/* Find the target ResultColumn in the received result set.  At
1:6718a25: 		 * this point we know that we do in fact need to scope the column
1:df88f63: 		 * reference for childRSN, so go ahead and do it.  The way in
1:df88f63: 		 * which we get the scope target column differs depending on
1:df88f63: 		 * if childRSN corresponds to the left or right child of the
1:df88f63: 		 * UNION node.  Before explaining that, though, note that it's
1:df88f63: 		 * not good enough to just search for the target column by
1:df88f63: 		 * name.  The reason is that it's possible the name provided
1:df88f63: 		 * for the column reference to be scoped doesn't match the
1:df88f63: 		 * name of the actual underlying column.  Ex.
1:6718a25: 		 *
1:6718a25: 		 *  select * from
1:6718a25: 		 *    (select i,j from t1 union select i,j from t2) X1 (x,y),
1:6718a25: 		 *    (select a,b from t3 union select a,b from t4) X2
1:6718a25: 		 *  where X1.x = X2.b;
1:6718a25: 		 *
1:df88f63: 		 * If we were scoping "X1.x" and we searched for "x" in the
1:df88f63: 		 * childRSN "select i,j from t1" we wouldn't find it.
1:df88f63: 		 *
1:df88f63: 		 * It is similarly incorrect to search for the target column
1:df88f63: 		 * by position (DERBY-1633).  This is a bit more subtle, but
1:df88f63: 		 * if the child to which we're scoping is a subquery whose RCL
1:df88f63: 		 * does not match the column ordering of the RCL for cr's source
1:df88f63: 		 * result set, then searching by column position can yield the
1:df88f63: 		 * wrong results, as well.  For a detailed example of how this
1:df88f63: 		 * can happen, see the fix description attached to DERBY-1633.
1:df88f63: 		 * 
1:df88f63: 		 * So how do we find the target column, then? As mentioned
1:df88f63: 		 * above, the way in which we get the scope target column
1:df88f63: 		 * differs depending on if childRSN corresponds to the left
1:df88f63: 		 * or right child of the parent UNION node.  And that said,
1:df88f63: 		 * we can tell if we're scoping a left child by looking at
1:df88f63: 		 * "whichRC" argument: if it is -1 then we know we're scoping
1:df88f63: 		 * to the left child of a Union; otherwise we're scoping to
1:df88f63: 		 * the right child.
4:6718a25: 		 */
1:df88f63: 		if (whichRC[0] == -1)
1:df88f63: 		{
1:df88f63: 			/*
1:df88f63: 			 * For the left side we start by figuring out what the source
1:df88f63: 			 * result set and column position for "cr" are.  Then, since
1:df88f63: 			 * a) cr must be pointing to a result column in the parentRSN's
1:df88f63: 			 * ResultColumnList,  b) we know that the parent RSN is a
1:df88f63: 			 * SetOperatorNode (at least for now, since we only get here
1:df88f63: 			 * for Union nodes), and c) SetOpNode's RCLs are built from the
1:df88f63: 			 * left child's RCL (see bindResultColumns() in SetOperatorNode),
1:df88f63: 			 * we know that if we search the child's RCL for a reference
1:df88f63: 			 * whose source result column is the same as cr's source result
1:df88f63: 			 * column, we'll find a match.  Once found, the position of the
1:df88f63: 			 * matching column w.r.t childRSN's RCL will be stored in the
1:df88f63: 			 * whichRC parameter.
1:df88f63: 			 */
1:1ad3b32: 
1:df88f63: 			// Find the source result set and source column position of cr.
1:df88f63: 			int [] sourceColPos = new int[] {-1};
1:df88f63: 			ResultSetNode sourceRSN = cr.getSourceResultSet(sourceColPos);
1:1ad3b32: 
1:eac0369: 			if (SanityManager.DEBUG)
1:df88f63: 			{
1:df88f63: 				/* We assumed that if we made it here "cr" was pointing
1:df88f63: 				 * to a base table somewhere down the tree.  If that's
1:df88f63: 				 * true then sourceRSN won't be null.  Make sure our
1:df88f63: 				 * assumption was correct.
1:df88f63: 				 */
1:df88f63: 				SanityManager.ASSERT(sourceRSN != null,
1:df88f63: 					"Failed to find source result set when trying to " +
1:df88f63: 					"scope column reference '" + cr.getTableName() +
1:df88f63: 					"." + cr.getColumnName());
1:df88f63: 			}
1:1ad3b32: 
1:df88f63: 			// Now search for the corresponding ResultColumn in childRSN.
1:df88f63: 			rc = childRSN.getResultColumns()
1:df88f63: 					.getResultColumn(sourceColPos[0], sourceRSN, whichRC);
1:df88f63: 		}
1:df88f63: 		else
1:df88f63: 		{
1:df88f63: 			/*
1:df88f63: 			 * For the right side the story is slightly different.  If we were
1:df88f63: 			 * to search the right child's RCL for a reference whose source
1:df88f63: 			 * result column was the same as cr's, we wouldn't find it.  This
1:df88f63: 			 * is because cr's source result column comes from the left child's
1:df88f63: 			 * RCL and thus the right child doesn't know about it.  That said,
1:df88f63: 			 * though, for set operations like UNION, the left and right RCL's
1:df88f63: 			 * are correlated by position--i.e. the operation occurs between
1:df88f63: 			 * the nth column in the left RCL and the nth column in the right
1:df88f63: 			 * RCL.  So given that we will already have found the scope target
1:df88f63: 			 * in the left child's RCL at the position in whichRC, we know that
1:df88f63: 			 * that scope target for the right child's RCL is simply the
1:df88f63: 			 * whichRC'th column in that RCL.
1:df88f63: 			 */
1:df88f63: 			rc = childRSN.getResultColumns().getResultColumn(whichRC[0]);
1:df88f63: 		}
1:1ad3b32: 
1:6718a25: 		// rc shouldn't be null; if there was no matching ResultColumn at all,
1:6718a25: 		// then we shouldn't have made it this far.
1:df88f63: 		if (SanityManager.DEBUG)
1:0be2d6e: 		{
1:6718a25: 			SanityManager.ASSERT(rc != null,
1:df88f63: 				"Failed to locate scope target result column when trying to " +
1:6718a25: 				"scope operand '" + cr.getTableName() + "." +
1:6718a25: 				cr.getColumnName() + "'.");
1:0be2d6e: 		}
1:1ad3b32: 
1:6718a25: 		/* If the ResultColumn we found has an expression that is a
1:df88f63: 		 * ColumnReference, then that column reference has all of the
1:df88f63: 		 * info we need.
1:6718a25: 		 *
1:df88f63: 		 * It is, however, possible that the ResultColumn's expression
1:df88f63: 		 * is NOT a ColumnReference.  For example, the expression would
1:df88f63: 		 * be a constant expression if childRSN represented something
1:df88f63: 		 * like:
1:6718a25: 		 *
1:6718a25: 		 *   select 1, 1 from t1
1:6718a25: 		 *
1:df88f63: 		 * In this case the expression does not directly reference a
1:df88f63: 		 * column in the underlying result set and is therefore
1:df88f63: 		 * "scoped" as far as it can go.  This means that the scoped
1:df88f63: 		 * predicate will not necessarily have column references on
1:df88f63: 		 * both sides, even though the predicate that we're scoping
1:df88f63: 		 * will.  That's not a problem, though, since a predicate with
1:df88f63: 		 * a column reference on one side and a non-ColumnReference
1:df88f63: 		 * on the other is still valid.
1:6718a25: 		 */
1:df88f63: 
1:df88f63: 		if (rc.getExpression() instanceof ColumnReference)
1:df88f63: 		{
1:df88f63: 			/* We create a clone of the column reference and mark
1:df88f63: 			 * the clone as "scoped" so that we can do the right
1:df88f63: 			 * thing when it comes time to remap the predicate;
1:df88f63: 			 * see Predicate.remapScopedPred() for more.
1:df88f63: 			 */
1:df88f63: 			ColumnReference cRef = (ColumnReference)
1:df88f63: 				((ColumnReference)rc.getExpression()).getClone();
1:df88f63: 			cRef.markAsScoped();
1:df88f63: 			return cRef;
1:df88f63: 		}
1:df88f63: 
1:df88f63: 		/* Else just return rc's expression.  This means the scoped
1:df88f63: 		 * predicate will have one operand that is _not_ a column
1:df88f63: 		 * reference--but that's okay, so long as we account for
1:df88f63: 		 * that when pushing/remapping the scoped predicate down
1:df88f63: 		 * the query tree (see esp. "isScopedToSourceResultSet()"
1:df88f63: 		 * in Predicate.java).
1:df88f63: 		 */
1:df88f63: 		return rc.getExpression();
1:0be2d6e: 	}
1:df88f63: 
1:0be2d6e: 	/**
1:0be2d6e: 	 * Determine whether or not the received ValueNode (which will
1:0be2d6e: 	 * usually be a ColumnReference) references either the received
1:0be2d6e: 	 * optTable or else a base table in the subtree beneath that
1:0be2d6e: 	 * optTable.
1:0be2d6e: 	 *
1:0be2d6e: 	 * @param valNode The ValueNode that has the reference(s).
1:0be2d6e: 	 * @param optTable The table/subtree node to which we're trying
1:0be2d6e: 	 *  to find a reference.
1:0be2d6e: 	 * @param forPush Whether or not we are searching with the intent
1:0be2d6e: 	 *  to push this operator to the target table.
1:0be2d6e: 	 * @param walkOptTableSubtree Should we walk the subtree beneath
1:0be2d6e: 	 *  optTable to find base tables, or not?  Will be false if we've
1:0be2d6e: 	 *  already done it for the left operand and now we're here
1:0be2d6e: 	 *  for the right operand.
1:0be2d6e: 	 * @return True if valNode contains a reference to optTable or
1:0be2d6e: 	 *  to a base table in the subtree beneath optTable; false
1:0be2d6e: 	 *  otherwise.
1:0be2d6e: 	 */
1:0be2d6e: 	private boolean valNodeReferencesOptTable(ValueNode valNode,
1:05623b6:         Optimizable optTable, boolean forPush, boolean walkOptTableSubtree)
1:0be2d6e: 	{
1:0be2d6e: 		// Following call will initialize/reset the btnVis,
1:0be2d6e: 		// valNodeBaseTables, and optBaseTables fields of this object.
1:0be2d6e: 		initBaseTableVisitor(optTable.getReferencedTableMap().size(),
1:0be2d6e: 			walkOptTableSubtree);
1:df88f63: 
1:0be2d6e: 		boolean found = false;
1:0be2d6e: 		try {
1:0be2d6e: 
1:0be2d6e: 			// Find all base tables beneath optTable and load them
1:0be2d6e: 			// into this object's optBaseTables map.  This is the
1:0be2d6e: 			// list of table numbers we'll search to see if the
1:0be2d6e: 			// value node references any tables in the subtree at
1:0be2d6e: 			// or beneath optTable.
1:0be2d6e: 			if (walkOptTableSubtree)
1:0be2d6e: 				buildTableNumList(optTable, forPush);
1:0be2d6e: 
1:0be2d6e: 			// Now get the base table numbers that are in valNode's
1:0be2d6e: 			// subtree.  In most cases valNode will be a ColumnReference
1:0be2d6e: 			// and this will return a single base table number.
1:0be2d6e: 			btnVis.setTableMap(valNodeBaseTables);
1:0be2d6e: 			valNode.accept(btnVis);
1:0be2d6e: 
1:0be2d6e: 			// And finally, see if there's anything in common.
1:0be2d6e: 			valNodeBaseTables.and(optBaseTables);
1:0be2d6e: 			found = (valNodeBaseTables.getFirstSetBit() != -1);
1:0be2d6e: 
1:0be2d6e: 		} catch (StandardException se) {
1:0be2d6e: 			if (SanityManager.DEBUG)
1:0be2d6e: 			{
1:0be2d6e: 				SanityManager.THROWASSERT("Failed when trying to " +
1:e7d2a42: 					"find base table numbers for reference check:", se);
1:0be2d6e: 			}
1:0be2d6e: 		}
1:0be2d6e: 
1:0be2d6e: 		return found;
1:0be2d6e: 	}
1:0be2d6e: 
2:0be2d6e: 	/**
1:0be2d6e: 	 * Initialize the fields used for retrieving base tables in
1:0be2d6e: 	 * subtrees, which allows us to do a more extensive search
1:0be2d6e: 	 * for table references.  If the fields have already been
1:0be2d6e: 	 * created, then just reset their values.
1:0be2d6e: 	 *
1:0be2d6e: 	 * @param numTablesInQuery Used for creating JBitSets that
1:0be2d6e: 	 *  can hold table numbers for the query.
1:0be2d6e: 	 * @param initOptBaseTables Whether or not we should clear out
1:0be2d6e: 	 *  or initialize the optBaseTables bit set.
1:0be2d6e: 	 */
1:0be2d6e: 	private void initBaseTableVisitor(int numTablesInQuery,
1:0be2d6e: 		boolean initOptBaseTables)
1:0be2d6e: 	{
1:0be2d6e: 		if (valNodeBaseTables == null)
1:0be2d6e: 			valNodeBaseTables = new JBitSet(numTablesInQuery);
1:0be2d6e: 		else
1:0be2d6e: 			valNodeBaseTables.clearAll();
1:0be2d6e: 
1:0be2d6e: 		if (initOptBaseTables)
1:0be2d6e: 		{
1:0be2d6e: 			if (optBaseTables == null)
1:0be2d6e: 				optBaseTables = new JBitSet(numTablesInQuery);
1:0be2d6e: 			else
1:0be2d6e: 				optBaseTables.clearAll();
1:0be2d6e: 		}
1:0be2d6e: 
1:0be2d6e: 		// Now create the visitor.  We give it valNodeBaseTables
1:0be2d6e: 		// here for sake of creation, but this can be overridden
1:0be2d6e: 		// (namely, by optBaseTables) by the caller of this method.
1:0be2d6e: 		if (btnVis == null)
1:0be2d6e: 			btnVis = new BaseTableNumbersVisitor(valNodeBaseTables);
6:0be2d6e: 	}
1:0be2d6e: 
1:0be2d6e: 	/**
1:0be2d6e: 	 * Create a set of table numbers to search when trying to find
1:0be2d6e: 	 * which (if either) of this operator's operands reference the
1:0be2d6e: 	 * received target table.  At the minimum this set should contain
1:0be2d6e: 	 * the target table's own table number.  After that, if we're
1:0be2d6e: 	 * _not_ attempting to push this operator (or more specifically,
1:0be2d6e: 	 * the predicate to which this operator belongs) to the target
1:0be2d6e: 	 * table, we go on to search the subtree beneath the target
1:0be2d6e: 	 * table and add any base table numbers to the searchable list.
1:0be2d6e: 	 *
1:0be2d6e: 	 * @param ft Target table for which we're building the search
1:0be2d6e: 	 *  list.
1:0be2d6e: 	 * @param forPush Whether or not we are searching with the intent
1:0be2d6e: 	 *  to push this operator to the target table.
1:0be2d6e: 	 */
1:05623b6:     private void buildTableNumList(Optimizable ft, boolean forPush)
1:0be2d6e: 		throws StandardException
5:0be2d6e: 	{
1:0be2d6e: 		// Start with the target table's own table number.  Note
1:0be2d6e: 		// that if ft is an instanceof SingleChildResultSet, its
1:0be2d6e: 		// table number could be negative.
1:0be2d6e: 		if (ft.getTableNumber() >= 0)
1:0be2d6e: 			optBaseTables.set(ft.getTableNumber());
1:0be2d6e: 
1:0be2d6e: 		if (forPush)
1:0be2d6e: 		// nothing else to do.
1:eac0369: 			return;
1:eac0369: 
1:0be2d6e: 		// Add any table numbers from the target table's
1:0be2d6e: 		// reference map.
1:0be2d6e: 		optBaseTables.or(ft.getReferencedTableMap());
1:eac0369: 
1:0be2d6e: 		// The table's reference map is not guaranteed to have
1:0be2d6e: 		// all of the tables that are actually used--for example,
1:0be2d6e: 		// if the table is a ProjectRestrictNode or a JoinNode
1:0be2d6e: 		// with a subquery as a child, the ref map will contain
1:0be2d6e: 		// the number for the PRN above the subquery, but it
1:0be2d6e: 		// won't contain the table numbers referenced by the
1:0be2d6e: 		// subquery.  So here we go through and find ALL base
1:0be2d6e: 		// table numbers beneath the target node.
1:0be2d6e: 		btnVis.setTableMap(optBaseTables);
1:0be2d6e: 		ft.accept(btnVis);
1:eac0369: 	}
1:0be2d6e: 
1:2706d1f:     @Override
1:2706d1f:     boolean isSameNodeKind(ValueNode o) {
1:2706d1f:         return super.isSameNodeKind(o) &&
1:2706d1f:                 ((BinaryRelationalOperatorNode)o).kind == kind;
1:2706d1f:     }
1:0be2d6e: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:eb88678
/////////////////////////////////////////////////////////////////////////
1:      * @param cm              The context manager
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // Allowed kinds
1:     final static int K_EQUALS = 0;
1:     final static int K_GREATER_EQUALS = 1;
1:     final static int K_GREATER_THAN = 2;
1:     final static int K_LESS_EQUALS = 3;
1:     final static int K_LESS_THAN = 4;
1:     final static int K_NOT_EQUALS = 5;
1: 
1:     /**
1:      * This class is used to hold logically different objects for
1:      * space efficiency. {@code kind} represents the logical object
1:      * type. See also {@link ValueNode#isSameNodeKind}.
1:      */
1:     final int kind;
1: 
1:     private int relOpType;
/////////////////////////////////////////////////////////////////////////
1:      * @param kind            The kind of operator
1:      * @param leftOperand     The left operand
1:      * @param rightOperand    The right operand
1:      * @param forQueryRewrite See method description
0:      * @paran cm              The context manager
1:             int kind,
/////////////////////////////////////////////////////////////////////////
1:               getOperatorName(kind),
1:               getMethodName(kind),
1:         this.kind = kind;
1:         constructorMinion();
/////////////////////////////////////////////////////////////////////////
1:             int kind,
/////////////////////////////////////////////////////////////////////////
1:               getOperatorName(kind),
1:               getMethodName(kind),
1:         this.kind = kind;
1:         constructorMinion();
1:     private void constructorMinion() {
1:         this.relOpType = getRelOpType(this.kind);
1:     private static String getMethodName(int kind) {
1:         switch (kind) {
1:         case K_EQUALS:
1:         case K_GREATER_EQUALS:
1:         case K_GREATER_THAN:
1:         case K_LESS_EQUALS:
1:         case K_LESS_THAN:
1:         case K_NOT_EQUALS:
/////////////////////////////////////////////////////////////////////////
1:                             " called with wrong nodeType = " + kind);
1:     private static String getOperatorName(int kind) {
1:         switch (kind) {
1:         case K_EQUALS:
1:         case K_GREATER_EQUALS:
1:         case K_GREATER_THAN:
1:         case K_LESS_EQUALS:
1:         case K_LESS_THAN:
1:         case K_NOT_EQUALS:
/////////////////////////////////////////////////////////////////////////
1:                             "called with wrong nodeType = " + kind);
/////////////////////////////////////////////////////////////////////////
1:     private int getRelOpType(int op) {
1:         switch (op) {
1:         case K_EQUALS:
1:         case K_GREATER_EQUALS:
1:         case K_GREATER_THAN:
1:         case K_LESS_EQUALS:
1:         case K_LESS_THAN:
1:         case K_NOT_EQUALS:
1:                             "called with wrong operator type = " + kind);
/////////////////////////////////////////////////////////////////////////
1:                 switch (relOpType) {
/////////////////////////////////////////////////////////////////////////
1:     private int getNegationNode()
1:         switch (this.kind)
1:             case K_EQUALS:
1:                 return K_NOT_EQUALS;
1:             case K_GREATER_EQUALS:
1:                 return K_LESS_THAN;
1:             case K_GREATER_THAN:
1:                 return K_LESS_EQUALS;
1:             case K_LESS_THAN:
1:                 return K_GREATER_EQUALS;
1:             case K_LESS_EQUALS:
1:                 return K_GREATER_THAN;
1:             case K_NOT_EQUALS:
1:                 return K_EQUALS;
1:             default:
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.THROWASSERT(
1:                         "getNegationNode called with invalid node type: " +
1:                         kind);
1:                 }
1:         }
1:         return -1;
/////////////////////////////////////////////////////////////////////////
1:             getKindForSwap(),
/////////////////////////////////////////////////////////////////////////
1:     private int getKindForSwap() {
1:         switch (this.kind) {
1:             case K_EQUALS:
1:                 return K_EQUALS;
1:             case K_GREATER_EQUALS:
1:                 return K_LESS_EQUALS;
1:             case K_GREATER_THAN:
1:                 return K_LESS_THAN;
1:             case K_LESS_THAN:
1:                 return K_GREATER_THAN;
1:             case K_LESS_EQUALS:
1:                 return K_GREATER_EQUALS;
1:             case K_NOT_EQUALS:
1:                 return K_NOT_EQUALS;
1:                             "Invalid operator type: " + kind);
/////////////////////////////////////////////////////////////////////////
1:         switch (relOpType)
/////////////////////////////////////////////////////////////////////////
1:         switch (relOpType)
/////////////////////////////////////////////////////////////////////////
1:         switch (relOpType)
/////////////////////////////////////////////////////////////////////////
1:         switch (relOpType)
/////////////////////////////////////////////////////////////////////////
1:         switch (relOpType)
/////////////////////////////////////////////////////////////////////////
1:         switch (relOpType)
/////////////////////////////////////////////////////////////////////////
1:         return relOpType;
/////////////////////////////////////////////////////////////////////////
1:         switch (relOpType)
/////////////////////////////////////////////////////////////////////////
1:         return new BinaryRelationalOperatorNode(kind,
/////////////////////////////////////////////////////////////////////////
1:         if (relOpType != EQUALS_RELOP)
/////////////////////////////////////////////////////////////////////////
1:             (relOpType == RelationalOperator.EQUALS_RELOP);
/////////////////////////////////////////////////////////////////////////
1:         if (relOpType != EQUALS_RELOP)
/////////////////////////////////////////////////////////////////////////
1:         if (relOpType == EQUALS_RELOP)
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isSameNodeKind(ValueNode o) {
1:         return super.isSameNodeKind(o) &&
1:                 ((BinaryRelationalOperatorNode)o).kind == kind;
1:     }
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     @Override @SuppressWarnings("fallthrough")
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.util.JBitSet;
/////////////////////////////////////////////////////////////////////////
1: class BinaryRelationalOperatorNode
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *  Constructor.
1:      *  DERBY-6185 Query against view  with {@code "where name LIKE
1:      *  'Col1' ESCAPE '\' "} failed.
1:      *  Argument {@code forQueryRewrite} can be true only if this node has been
1:      *  added by an internal rewrite of the query. This allows binding to
1:      *  be more liberal when checking it against allowed syntax.
1:      *  This parameter will be passed FALSE when a new instance of the node
1:      *  is being created(which is the majority of the cases). But when an
1:      *  existing node is getting cloned, the value of this parameter should
1:      *  be passed as the originalNode.getForQueryRewrite(). Examples of this
1:      *  can be found in Predicate.Java and PredicateList.java
1:      *
0:      * @param leftOperand
0:      * @param rightOperand
0:      * @param forQueryRewrite
1:      */
1:     BinaryRelationalOperatorNode(
0:             int nodeType,
1:             ValueNode leftOperand,
1:             ValueNode rightOperand,
1:             boolean forQueryRewrite,
1:             ContextManager cm) throws StandardException
1:         super(leftOperand,
1:               rightOperand,
0:               getOperatorName(nodeType),
0:               getMethodName(nodeType),
1:               forQueryRewrite,
1:               cm);
0:         constructorMinion(nodeType);
1:     }
1:     /**
1:      * Same as constructor above except takes a third argument that is
1:      * an InListOperatorNode.  This version is used during IN-list
1:      * preprocessing to create a "probe predicate" for the IN-list.
1:      * See InListOperatorNode.preprocess() for more.
1:      * DERBY-6185 (Query against view  with "where name LIKE
1:      *  'Col1' ESCAPE '\' " failed)
1:      * 4th argument forQueryRewrite can be true only if this node has been
1:      *  added by an internal rewrite of the query. This allows binding to
1:      *  be more liberal when checking it against allowed syntax.
1:      *  This parameter will be passed FALSE when a new instance of the node
1:      *  is being created(which is the majority of the cases). But when an
1:      *  existing node is getting cloned, the value of this parameter should
1:      *  be passed as the originalNode.getForQueryRewrite(). Examples of this
1:      *  can be found in Predicate.Java and PredicateList.java
1:      */
1:     BinaryRelationalOperatorNode(
0:             int nodeType,
1:             ValueNode leftOperand,
1:             ValueNode rightOperand,
1:             InListOperatorNode inListOp,
1:             boolean forQueryRewrite,
1:             ContextManager cm) throws StandardException
1:     {
1:         super(leftOperand,
1:               rightOperand,
0:               getOperatorName(nodeType),
0:               getMethodName(nodeType),
1:               forQueryRewrite,
1:               cm);
0:         constructorMinion(nodeType);
1:         this.inListProbeSource = inListOp;
1:     }
1: 
0:     private void constructorMinion(int nodeType) {
0:         this.operatorType = getOperatorType(nodeType);
0:         setNodeType(nodeType);
1:         btnVis = null;
1:     }
1: 
0:     private static String getMethodName(int nodeType) {
1:         String methodName = "";
0:         switch (nodeType) {
1:                 break;
1: 
1:             default:
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.THROWASSERT(
1:                             "Constructor for BinaryRelationalOperatorNode" +
0:                             " called with wrong nodeType = " + nodeType);
1:                 }
1:                 break;
1:         }
1:         return methodName;
1:     }
1: 
0:     private static String getOperatorName(int nodeType) {
1:         String operatorName = "";
1: 
0:         switch (nodeType) {
0:             case C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE:
1:                 operatorName = "=";
1:                 break;
1: 
0:             case C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE:
1:                 operatorName = ">=";
1:                 break;
1: 
0:             case C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE:
1:                 operatorName = ">";
1:                 break;
1: 
0:             case C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE:
1:                 operatorName = "<=";
1:                 break;
1: 
0:             case C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE:
1:                 operatorName = "<";
1:                 break;
0:             case C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE:
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.THROWASSERT(
1:                             "Constructor for BinaryRelationalOperatorNode " +
0:                             "called with wrong nodeType = " + nodeType);
1:         return operatorName;
1:     }
1: 
0:     private int getOperatorType(int nodeType) {
0:         switch (nodeType) {
0:             case C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE:
1:                 return RelationalOperator.EQUALS_RELOP;
0:             case C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE:
1:                 return RelationalOperator.GREATER_EQUALS_RELOP;
0:             case C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE:
1:                 return RelationalOperator.GREATER_THAN_RELOP;
0:             case C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE:
1:                 return RelationalOperator.LESS_EQUALS_RELOP;
0:             case C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE:
1:                 return RelationalOperator.LESS_THAN_RELOP;
0:             case C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE:
1:                 return RelationalOperator.NOT_EQUALS_RELOP;
1:             default:
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.THROWASSERT(
1:                             "Constructor for BinaryRelationalOperatorNode " +
0:                             "called with wrong nodeType = " + getNodeType());
1:                 }
1:                 return 0;
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:         ColumnReference cr;
/////////////////////////////////////////////////////////////////////////
1:         ValueNode node = keyColumnOnLeft(optTable) ? rightOperand : leftOperand;
/////////////////////////////////////////////////////////////////////////
1:         ValueNode node = keyColumnOnLeft(optTable) ? rightOperand : leftOperand;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     String getReceiverInterfaceName() {
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:         return new BooleanConstantNode(b, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:         negation = new BinaryRelationalOperatorNode(getNegationNode(),
1:                                      false,
/////////////////////////////////////////////////////////////////////////
1:         BinaryOperatorNode newNode = new BinaryRelationalOperatorNode(
0:             getNodeTypeForSwap(),
1:             rightOperand,
1:             leftOperand,
1:             false,
1:             getContextManager());
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
0:         return new BinaryRelationalOperatorNode(getNodeType(),
1:                                                 otherCR,
1:                                                 rightOperand,
1:                                                 false,
1:                                                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isRelationalOperator()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isBinaryEqualsOperatorNode()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean isInListProbeNode()
1:     @Override
1:     boolean optimizableEqualityNode(Optimizable optTable,
/////////////////////////////////////////////////////////////////////////
0:     @Override
1:     ValueNode genSQLJavaSQLTree() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     ValueNode getScopedOperand(int whichSide,
1:         ResultColumn rc;
/////////////////////////////////////////////////////////////////////////
1:         BaseTableNumbersVisitor btnVisitor =
1:         cr.accept(btnVisitor);
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:05623b6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.ExpressionClassBuilderInterface;
/////////////////////////////////////////////////////////////////////////
1: 								Optimizable ft)
/////////////////////////////////////////////////////////////////////////
1: 								ExpressionClassBuilderInterface acbi,
1:         ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
/////////////////////////////////////////////////////////////////////////
1:     public void generateQualMethod(ExpressionClassBuilderInterface acbi,
1:         ExpressionClassBuilder acb = (ExpressionClassBuilder) acbi;
1: 
/////////////////////////////////////////////////////////////////////////
1:         Optimizable optTable, boolean forPush, boolean walkOptTableSubtree)
/////////////////////////////////////////////////////////////////////////
1:     private void buildTableNumList(Optimizable ft, boolean forPush)
commit:0af1665
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return an equivalent node with the operands swapped, and possibly with
1:      * the operator type changed in order to preserve the meaning of the
1:      * expression.
1:      */
1:     BinaryOperatorNode getSwappedEquivalent() throws StandardException {
0:         BinaryOperatorNode newNode = (BinaryOperatorNode) getNodeFactory().getNode(getNodeTypeForSwap(),
0:                 rightOperand, leftOperand,
1:                 getContextManager());
1:         newNode.setType(getTypeServices());
1:         return newNode;
1:     }
1: 
1:     /**
1:      * Return the node type that must be used in order to construct an
1:      * equivalent expression if the operands are swapped. For symmetric
1:      * operators ({@code =} and {@code <>}), the same node type is returned.
1:      * Otherwise, the direction of the operator is switched in order to
1:      * preserve the meaning (for instance, a node representing less-than will
1:      * return the node type for greater-than).
1:      *
1:      * @return a node type that preserves the meaning of the expression if
1:      * the operands are swapped
1:      */
0:     private int getNodeTypeForSwap() {
0:         switch (getNodeType()) {
0:             case C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE:
0:                 return C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE;
0:             case C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE:
0:                 return C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE;
0:             case C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE:
0:                 return C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE;
0:             case C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE:
0:                 return C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE;
0:             case C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE:
0:                 return C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE;
0:             case C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE:
0:                 return C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE;
1:             default:
1:                 if (SanityManager.DEBUG) {
1:                     SanityManager.THROWASSERT(
0:                             "Invalid nodeType: " + getNodeType());
1:                 }
1:                 return -1;
1:         }
1:     }
1: 
commit:377790f
/////////////////////////////////////////////////////////////////////////
1:      * @return a node representing a Boolean constant if the result of the
1:      * operator is known; otherwise, this operator node
commit:568cbf1
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * See if the node always evaluates to true or false, and return a Boolean
1:      * constant node if it does.
1:      *
0:      * @return a Boolean constant if the result of the operator is known, or
0:      * the operator node otherwise
1:      */
1:     ValueNode evaluateConstantExpressions() throws StandardException {
1:         if (leftOperand instanceof ConstantNode &&
1:                 rightOperand instanceof ConstantNode) {
1:             ConstantNode leftOp = (ConstantNode) leftOperand;
1:             ConstantNode rightOp = (ConstantNode) rightOperand;
1:             DataValueDescriptor leftVal = leftOp.getValue();
1:             DataValueDescriptor rightVal = rightOp.getValue();
1: 
1:             if (!leftVal.isNull() && !rightVal.isNull()) {
1:                 int comp = leftVal.compare(rightVal);
0:                 switch (operatorType) {
1:                     case EQUALS_RELOP:
1:                         return newBool(comp == 0);
1:                     case NOT_EQUALS_RELOP:
1:                         return newBool(comp != 0);
1:                     case GREATER_THAN_RELOP:
1:                         return newBool(comp > 0);
1:                     case GREATER_EQUALS_RELOP:
1:                         return newBool(comp >= 0);
1:                     case LESS_THAN_RELOP:
1:                         return newBool(comp < 0);
1:                     case LESS_EQUALS_RELOP:
1:                         return newBool(comp <= 0);
1:                 }
1:             }
1:         }
1: 
1:         return this;
1:     }
1: 
1:     /**
1:      * Create a Boolean constant node with a specified value.
1:      *
1:      * @param b the value of the constant
1:      * @return a node representing a Boolean constant
1:      */
1:     private ValueNode newBool(boolean b) throws StandardException {
0:         return (ValueNode) getNodeFactory().getNode(
0:                 C_NodeTypes.BOOLEAN_CONSTANT_NODE,
0:                 Boolean.valueOf(b),
0:                 getContextManager());
1:     }
commit:e7d2a42
/////////////////////////////////////////////////////////////////////////
1:                     "find base table number for column reference check:", se);
/////////////////////////////////////////////////////////////////////////
1: 					"find base table numbers for reference check:", se);
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:8c15184
/////////////////////////////////////////////////////////////////////////
0: 	//DERBY-6185 (Query against view  with "where name LIKE 
0: 	// 'Col1' ESCAPE '\' " failed)
0: 	//4th argument forQueryRewrite can be true only if this node has been 
0: 	//  added by an internal rewrite of the query. This allows binding to 
0: 	//  be more liberal when checking it against allowed syntax.
0: 	//  This parameter will be passed FALSE when a new instance of the node
0: 	//  is being created(which is the majority of the cases). But when an 
0: 	//  existing node is getting cloned, the value of this parameter should 
0: 	//  be passed as the originalNode.getForQueryRewrite(). Examples of this
0: 	//  can be found in Predicate.Java and PredicateList.java
0: 	public void init(Object leftOperand, Object rightOperand,
0:         Object forQueryRewrite)
/////////////////////////////////////////////////////////////////////////
0: 		super.init(leftOperand, rightOperand, operatorName, methodName, forQueryRewrite);
/////////////////////////////////////////////////////////////////////////
0: 	 * DERBY-6185 (Query against view  with "where name LIKE 
0: 	 *  'Col1' ESCAPE '\' " failed)
0: 	 * 4th argument forQueryRewrite can be true only if this node has been
0: 	 *  added by an internal rewrite of the query. This allows binding to
0: 	 *  be more liberal when checking it against allowed syntax.
0: 	 *  This parameter will be passed FALSE when a new instance of the node
0: 	 *  is being created(which is the majority of the cases). But when an 
0: 	 *  existing node is getting cloned, the value of this parameter should
0: 	 *  be passed as the originalNode.getForQueryRewrite(). Examples of this
0: 	 *  can be found in Predicate.Java and PredicateList.java
0: 	public void init(Object leftOperand, Object rightOperand,
0: 			 Object inListOp, Object forQueryRewrite)
0: 		init(leftOperand, rightOperand, forQueryRewrite);
/////////////////////////////////////////////////////////////////////////
0: 									 Boolean.FALSE,
/////////////////////////////////////////////////////////////////////////
0:                 Boolean.FALSE,
/////////////////////////////////////////////////////////////////////////
0: 														  Boolean.FALSE,
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		typeId.getJDBCTypeId() == Types.BOOLEAN))
commit:ef158f2
/////////////////////////////////////////////////////////////////////////
1: 			SanityManager.ASSERT(getTypeServices() != null,
1: 		negation.setType(getTypeServices());
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.BinaryRelationalOperatorNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: 
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.ScanController;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.Orderable;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import java.sql.Types;
1: 
1: /**
1:  * This class represents the 6 binary operators: LessThan, LessThanEquals,
1:  * Equals, NotEquals, GreaterThan and GreaterThanEquals.
1:  *
0:  * @author Manish Khettry
1:  */
1: 
0: public class BinaryRelationalOperatorNode
1: 	extends BinaryComparisonOperatorNode
1: 	implements RelationalOperator
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private int operatorType;
1: 	/* RelationalOperator Interface */
1: 
0: 	public void init(Object leftOperand, Object rightOperand)
1: 	{
0: 		String methodName = "";
0: 		String operatorName = "";
1: 
0: 		switch (getNodeType())
1: 		{
0: 			case C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE:
1: 				methodName = "equals";
0: 				operatorName = "=";
0: 				operatorType = RelationalOperator.EQUALS_RELOP;
1: 				break;
1: 
0: 			case C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE:
1: 				methodName = "greaterOrEquals";
0: 				operatorName = ">=";
0: 				operatorType = RelationalOperator.GREATER_EQUALS_RELOP;
1: 				break;
1: 
0: 			case C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE:
1: 				methodName = "greaterThan";
0: 				operatorName = ">";
0: 				operatorType = RelationalOperator.GREATER_THAN_RELOP;
1: 				break;
1: 
0: 			case C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE:
1: 				methodName = "lessOrEquals";
0: 				operatorName = "<=";
0: 				operatorType =  RelationalOperator.LESS_EQUALS_RELOP;
1: 				break;
1: 
0: 			case C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE:
1: 				methodName = "lessThan";
0: 				operatorName = "<";
0: 				operatorType = RelationalOperator.LESS_THAN_RELOP;
1: 				break;
0: 			case C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE:
1: 				methodName = "notEquals";
1: 				operatorName = "<>";
0: 				operatorType = RelationalOperator.NOT_EQUALS_RELOP;
1: 				break;
1: 
1: 			default:
1: 				if (SanityManager.DEBUG)
1: 				{
0: 					SanityManager.THROWASSERT("init for BinaryRelationalOperator called with wrong nodeType = " + getNodeType());
1: 				}
1: 			    break;
1: 		}
0: 		super.init(leftOperand, rightOperand, operatorName, methodName);
1: 	}
1: 
1: 	/** @see RelationalOperator#getColumnOperand */
1: 	public ColumnReference getColumnOperand(
1: 								Optimizable optTable,
1: 								int columnPosition)
1: 	{
1: 		FromTable	ft = (FromTable) optTable;
1: 
0: 		return getColumnOperand(ft.getTableNumber(), columnPosition);
1: 	}
1: 
1: 	/** @see RelationalOperator#getColumnOperand */
1: 	public ColumnReference getColumnOperand(
1: 								int tableNumber,
1: 								int columnPosition)
1: 	{
1: 		ColumnReference	cr;
1: 
1: 		if (leftOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The left operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == tableNumber)
1: 			{
1: 				/*
1: 				** The table is correct, how about the column position?
1: 				*/
1: 				if (cr.getSource().getColumnPosition() == columnPosition)
1: 				{
1: 					/* We've found the correct column - return it */
1: 					return cr;
1: 				}
1: 			}
1: 		}
1: 
1: 		if (rightOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The right operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == tableNumber)
1: 			{
1: 				/*
1: 				** The table is correct, how about the column position?
1: 				*/
1: 				if (cr.getSource().getColumnPosition() == columnPosition)
1: 				{
1: 					/* We've found the correct column - return it */
1: 					return cr;
1: 				}
1: 			}
1: 		}
1: 
1: 		/* Neither side is the column we're looking for */
1: 		return null;
1: 	}
1: 
1: 	/** @see RelationalOperator#getColumnOperand */
1: 	public ColumnReference getColumnOperand(Optimizable optTable)
1: 	{
1: 		ColumnReference	cr;
1: 
1: 		if (leftOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The left operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == optTable.getTableNumber())
1: 			{
1: 				/*
1: 				** The table is correct.
1: 				*/
1: 				return cr;
1: 			}
1: 		}
1: 
1: 		if (rightOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The right operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == optTable.getTableNumber())
1: 			{
1: 				/*
1: 				** The table is correct
1: 				*/
1: 				return cr;
1: 			}
1: 		}
1: 
1: 		/* Neither side is the column we're looking for */
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * @see RelationalOperator#getExpressionOperand
1: 	 */
1: 	public ValueNode getExpressionOperand(
1: 								int tableNumber,
1: 								int columnPosition)
1: 	{
1: 		ColumnReference	cr;
1: 
1: 		if (leftOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The left operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == tableNumber)
1: 			{
1: 				/*
1: 				** The table is correct, how about the column position?
1: 				*/
1: 				if (cr.getSource().getColumnPosition() == columnPosition)
1: 				{
1: 					/*
1: 					** We've found the correct column -
1: 					** return the other side
1: 					*/
1: 					return rightOperand;
1: 				}
1: 			}
1: 		}
1: 
1: 		if (rightOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The right operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == tableNumber)
1: 			{
1: 				/*
1: 				** The table is correct, how about the column position?
1: 				*/
1: 				if (cr.getSource().getColumnPosition() == columnPosition)
1: 				{
1: 					/*
1: 					** We've found the correct column -
1: 					** return the other side
1: 					*/
1: 					return leftOperand;
1: 				}
1: 			}
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * @see RelationalOperator#generateExpressionOperand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void generateExpressionOperand(
1: 								Optimizable optTable,
1: 								int columnPosition,
0: 								ExpressionClassBuilder acb,
1: 								MethodBuilder mb)
1: 						throws StandardException
1: 	{
1: 		ColumnReference	cr;
1: 		FromBaseTable	ft;
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1:     		SanityManager.ASSERT(optTable instanceof FromBaseTable);
1:     	}
1: 		ft = (FromBaseTable) optTable;
1: 
0: 		ValueNode exprOp =
0: 					getExpressionOperand(ft.getTableNumber(), columnPosition);
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (exprOp == null)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"ColumnReference for correct column (columnPosition = " +
1: 					columnPosition +
1: 					", exposed table name = " + ft.getExposedName() +
1: 				") not found on either side of BinaryRelationalOperator");
1: 			}
1: 		}
1: 
1: 		exprOp.generateExpression(acb, mb);
1: 	}
1: 
1: 	/** @see RelationalOperator#selfComparison 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean selfComparison(ColumnReference cr)
1: 		throws StandardException
1: 	{
1: 		ValueNode	otherSide;
1: 		JBitSet		tablesReferenced;
1: 
1: 		/*
1: 		** Figure out which side the given ColumnReference is on,
1: 		** and look for the same table on the other side.
1: 		*/
1: 		if (leftOperand == cr)
1: 		{
1: 			otherSide = rightOperand;
1: 		}
1: 		else if (rightOperand == cr)
1: 		{
1: 			otherSide = leftOperand;
1: 		}
1: 		else
1: 		{
1: 			otherSide = null;
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.THROWASSERT(
1: 			  		"ColumnReference not found on either side of binary comparison.");
1: 			}
1: 		}
1: 
1: 		tablesReferenced = otherSide.getTablesReferenced();
1: 
1: 		/* Return true if the table we're looking for is in the bit map */
1: 		return tablesReferenced.get(cr.getTableNumber());
1: 	}
1: 
1: 	/** @see RelationalOperator#usefulStartKey */
1: 	public boolean usefulStartKey(Optimizable optTable)
1: 	{
1: 		/*
1: 		** Determine whether this operator is a useful start operator
1: 		** with knowledge of whether the key column is on the left or right.
1: 		*/
1: 		int	columnSide = columnOnOneSide(optTable);
1: 
1: 		if (columnSide == NEITHER)
1: 			return false;
1: 		else
1: 			return usefulStartKey(columnSide == LEFT);
1: 	}
1: 
1: 	/**
1: 	 * Return true if a key column for the given table is found on the
1: 	 * left side of this operator, false if it is found on the right
1: 	 * side of this operator.
1: 	 *
1: 	 * NOTE: This method assumes that a key column will be found on one
1: 	 * side or the other.  If you don't know whether a key column exists,
1: 	 * use the columnOnOneSide() method (below).
1: 	 *
1: 	 * @param optTable	The Optimizable table that we're looking for a key
1: 	 *					column on.
1: 	 *
1: 	 * @return true if a key column for the given table is on the left
1: 	 *			side of this operator, false if one is found on the right
1: 	 *			side of this operator.
1: 	 */
1: 	protected boolean keyColumnOnLeft(Optimizable optTable)
1: 	{
1: 		ColumnReference	cr;
1: 		FromTable	ft;
1: 		boolean			left = false;
1: 
1: 		ft = (FromTable) optTable;
1: 
1: 		/* Is the key column on the left or the right? */
1: 		if (leftOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The left operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == ft.getTableNumber())
1: 			{
1: 				/* The left operand is the key column */
1: 				left = true;
1: 			}
1: 		}
1: 		else
1: 		{
1:     		if (SanityManager.DEBUG)
1: 	    	{
0: 		    	SanityManager.ASSERT((rightOperand instanceof ColumnReference) &&
0: 			    		(((ColumnReference) rightOperand).getTableNumber() ==
0:     														ft.getTableNumber()),
1: 	    				"Key column not found on either side.");
1: 	    	}
0: 			/* The right operand is the key column */
0: 			left = false;
1: 		}
1: 
1: 		return left;
1: 	}
1: 
1: 	/* Return values for columnOnOneSide */
1: 	protected static final int LEFT = -1;
1: 	protected static final int NEITHER = 0;
1: 	protected static final int RIGHT = 1;
1: 
1: 	/**
1: 	 * Determine whether there is a column from the given table on one side
1: 	 * of this operator, and if so, which side is it on?
1: 	 *
1: 	 * @param optTable	The Optimizable table that we're looking for a key
1: 	 *					column on.
1: 	 *
1: 	 * @return	LEFT if there is a column on the left, RIGHT if there is
1: 	 *			a column on the right, NEITHER if no column found on either
1: 	 *			side.
1: 	 */
1: 	protected int columnOnOneSide(Optimizable optTable)
1: 	{
1: 		ColumnReference	cr;
1: 		boolean			left = false;
1: 
1: 		/* Is a column on the left */
1: 		if (leftOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The left operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == optTable.getTableNumber())
1: 			{
1: 				/* Key column found on left */
1: 				return LEFT;
1: 			}
1: 		}
1: 
1: 		if (rightOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The right operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == optTable.getTableNumber())
1: 			{
1: 				/* Key column found on right */
1: 				return RIGHT;
1: 			}
1: 		}
1: 
1: 		return NEITHER;
1: 	}
1: 
1: 	/** @see RelationalOperator#usefulStopKey */
1: 	public boolean usefulStopKey(Optimizable optTable)
1: 	{
1: 		/*
1: 		** Determine whether this operator is a useful start operator
1: 		** with knowledge of whether the key column is on the left or right.
1: 		*/
1: 		int	columnSide = columnOnOneSide(optTable);
1: 
1: 		if (columnSide == NEITHER)
1: 			return false;
1: 		else
1: 			return usefulStopKey(columnSide == LEFT);
1: 	}
1: 
1: 	/**
1: 	 * Determine whether this comparison operator is a useful stop key
1: 	 * with knowledge of whether the key column is on the left or right.
1: 	 *
1: 	 * @param left	true means the key column is on the left, false means
1: 	 *				it is on the right.
1: 	 *
1: 	 * @return	true if this is a useful stop key
1: 	 */
1: 	/** @see RelationalOperator#generateAbsoluteColumnId */
1: 	public void generateAbsoluteColumnId(MethodBuilder mb,
1: 											   Optimizable optTable)
1: 	{
1: 		// Get the absolute column position for the column
1: 		int columnPosition = getAbsoluteColumnPosition(optTable);
1: 
1: 		mb.push(columnPosition);
1: 	}
1: 
1: 	/** @see RelationalOperator#generateRelativeColumnId */
1: 	public void generateRelativeColumnId(MethodBuilder mb,
1: 											   Optimizable optTable)
1: 	{
1: 		// Get the absolute column position for the column
1: 		int columnPosition = getAbsoluteColumnPosition(optTable);
1: 		// Convert the absolute to the relative 0-based column position
1: 		columnPosition = optTable.convertAbsoluteToRelativeColumnPosition(
1: 								columnPosition);
1: 
1: 		mb.push(columnPosition);
1: 	}
1: 
1: 	/**
1: 	 * Get the absolute 0-based column position of the ColumnReference from 
1: 	 * the conglomerate for this Optimizable.
1: 	 *
1: 	 * @param optTable	The Optimizable
1: 	 *
1: 	 * @return The absolute 0-based column position of the ColumnReference
1: 	 */
1: 	private int getAbsoluteColumnPosition(Optimizable optTable)
1: 	{
1: 		ColumnReference	cr;
1: 		ConglomerateDescriptor bestCD;
1: 		int columnPosition;
1: 
1: 		if (keyColumnOnLeft(optTable))
1: 		{
1: 			cr = (ColumnReference) leftOperand;
1: 		}
1: 		else
1: 		{
1: 			cr = (ColumnReference) rightOperand;
1: 		}
1: 
1: 		bestCD = optTable.getTrulyTheBestAccessPath().
1: 												getConglomerateDescriptor();
1: 
1: 		/*
1: 		** Column positions are one-based, store is zero-based.
1: 		*/
1: 		columnPosition = cr.getSource().getColumnPosition();
1: 
1: 		/*
1: 		** If it's an index, find the base column position in the index
1: 		** and translate it to an index column position.
1: 		*/
1: 		if (bestCD != null && bestCD.isIndex())
1: 		{
1: 			columnPosition = bestCD.getIndexDescriptor().
1: 			  getKeyColumnPosition(columnPosition);
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(columnPosition > 0,
1: 					"Base column not found in index");
1: 			}
1: 		}
1: 
1: 		// return the 0-based column position
1: 		return columnPosition - 1;
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generateQualMethod(ExpressionClassBuilder acb,
1: 								   MethodBuilder mb,
1: 								   Optimizable optTable)
1: 						throws StandardException
1: 	{
1: 		/* Generate a method that returns the expression */
1: 		MethodBuilder qualMethod = acb.newUserExprFun();
1: 
1: 		/*
1: 		** Generate the expression that's on the opposite side
1: 		** of the key column
1: 		*/
1: 		if (keyColumnOnLeft(optTable))
1: 		{
1: 			rightOperand.generateExpression(acb, qualMethod);
1: 		}
1: 		else
1: 		{
1: 			leftOperand.generateExpression(acb, qualMethod);
1: 		}
1: 
1: 		qualMethod.methodReturn();
1: 		qualMethod.complete();
1: 
1: 		/* push an expression that evaluates to the GeneratedMethod */
1: 		acb.pushMethodReference(mb, qualMethod);
1: 	}
1: 
1: 	/** @see RelationalOperator#generateOrderedNulls */
1: 	public void generateOrderedNulls(MethodBuilder mb)
1: 	{
1: 		mb.push(false);
1: 	}
1: 
1: 	/** @see RelationalOperator#orderedNulls */
1: 	public boolean orderedNulls()
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/** @see RelationalOperator#isQualifier 
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public boolean isQualifier(Optimizable optTable)
1: 		throws StandardException
1: 	{
1: 		FromTable	ft;
1: 		ValueNode	otherSide = null;
1: 		JBitSet		tablesReferenced;
0: 		ColumnReference	cr = null;
1: 		boolean	found = false;
1: 
1: 		ft = (FromTable) optTable;
1: 
1: 		if (leftOperand instanceof ColumnReference)
1: 		{
1: 			/*
1: 			** The left operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == ft.getTableNumber())
1: 			{
1: 				otherSide = rightOperand;
1: 				found = true;
1: 			}
1: 		}
1: 
1: 		if ( ( ! found) && (rightOperand instanceof ColumnReference) )
1: 		{
1: 			/*
1: 			** The right operand is a column reference.
1: 			** Is it the correct column?
1: 			*/
1: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == ft.getTableNumber())
1: 			{
1: 				otherSide = leftOperand;
1: 				found = true;
1: 			}
1: 		}
1: 
1: 		/* Have we found a ColumnReference on either side? */
1: 		if ( ! found)
1: 		{
1: 			/*
1: 			** Neither side is a ColumnReference to the table we're looking
1: 			** for, so it can't be a Qualifier
1: 			*/
1: 			return false;
1: 		}
1: 
1: 		/*
1: 		** One side is a ColumnReference to the correct table.  It is a
1: 		** Qualifier if the other side does not refer to the table we are
1: 		** optimizing.
1: 		*/
1: 		tablesReferenced = otherSide.getTablesReferenced();
1: 
0: 		return  ! (tablesReferenced.get(ft.getTableNumber()));
1: 	}
1: 
1: 	/** 
1: 	 * @see RelationalOperator#getOrderableVariantType 
1: 	 *
1: 	 * @exception StandardException	thrown on error
1: 	 */
1: 	public int getOrderableVariantType(Optimizable optTable) 
1: 		throws StandardException
1: 	{
1: 		/* The Qualifier's orderable is on the opposite side from
1: 		 * the key column.
1: 		 */
1: 		if (keyColumnOnLeft(optTable))
1: 		{
1: 			return rightOperand.getOrderableVariantType();
1: 		}
1: 		else
1: 		{
1: 			return leftOperand.getOrderableVariantType();
1: 		}
1: 	}
1: 
1: 	/** @see RelationalOperator#compareWithKnownConstant */
1: 	public boolean compareWithKnownConstant(Optimizable optTable, boolean considerParameters)
1: 	{
0: 		ValueNode	node = null;
0: 		node = keyColumnOnLeft(optTable) ? rightOperand : leftOperand;
1: 
1: 		if (considerParameters)
1: 		{
1: 			return (node instanceof ConstantNode) ||
0: 						((node.isParameterNode()) &&
1: 						 (((ParameterNode)node).getDefaultValue() != null));
1: 		}
1: 		else
1: 		{
1: 			return node instanceof ConstantNode;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see RelationalOperator#getCompareValue
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public DataValueDescriptor getCompareValue(Optimizable optTable) 
1:         throws StandardException
1: 	{
0: 		ValueNode	node = null;
1: 
1: 		/* The value being compared to is on the opposite side from
1: 		** the key column.
1: 		*/
0: 		node = keyColumnOnLeft(optTable) ? rightOperand : leftOperand;
1: 
1: 		if (node instanceof ConstantNode) 
1: 		{
1: 			return ((ConstantNode)node).getValue();
1: 		}
0: 		else if (node.isParameterNode())
1: 		{
0: 			return ((ParameterNode)node).getDefaultValue();
1: 		}
1: 		else
1: 		{	
1: 			return null;
1: 		}
1: 	}
1: 
1: 
1: 	/**
1: 	 * Return 50% if this is a comparison with a boolean column, a negative
1: 	 * selectivity otherwise.
1: 	 */
1: 	protected double booleanSelectivity(Optimizable optTable)
1: 	{
1: 		TypeId	typeId = null;
1: 		double				retval = -1.0d;
1: 		int					columnSide;
1: 
1: 		columnSide = columnOnOneSide(optTable);
1: 
1: 		if (columnSide == LEFT)
1: 			typeId = leftOperand.getTypeId();
1: 		else if (columnSide == RIGHT)
1: 			typeId = rightOperand.getTypeId();
1: 
1: 		if (typeId != null && (typeId.getJDBCTypeId() == Types.BIT ||
0: 		typeId.getJDBCTypeId() == JDBC30Translation.SQL_TYPES_BOOLEAN))
1: 			retval = 0.5d;
1: 
1: 		return retval;
1: 	}
1: 
1: 	/**
1: 	 * The methods generated for this node all are on Orderable.  
1: 	 * Overrides this method
1: 	 * in BooleanOperatorNode for code generation purposes.
1: 	 */
0: 	public String getReceiverInterfaceName() {
1: 	    return ClassName.DataValueDescriptor;
1: 	}
1: 	
1: 	/**
1: 	 * Returns the negation of this operator; negation of Equals is NotEquals.
1: 	 */
1: 	BinaryOperatorNode getNegation(ValueNode leftOperand, 
1: 										  ValueNode rightOperand)
1: 		throws StandardException
1: 	{
1: 		BinaryOperatorNode negation;
1: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(dataTypeServices != null,
1: 								 "dataTypeServices is expected to be non-null");
1: 		/* xxxRESOLVE: look into doing this in place instead of allocating a new node */
0: 		negation = (BinaryOperatorNode)
0: 			getNodeFactory().getNode(getNegationNode(),
1: 									 leftOperand, rightOperand,
0: 									 getContextManager());
0: 		negation.setType(dataTypeServices);
1: 		return negation;
1: 	}
1: 
1: 	/* map current node to its negation */
0: 	private int getNegationNode()
1: 	{
0: 		switch (getNodeType())
1: 		{
0: 			case C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE;
1: 
0: 			case C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE;
1: 
0: 			case C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE;
1: 
0: 			case C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE;
1: 				
0: 			case C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE;
1: 
0: 			case C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE:				
0: 				return C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE;
1: 		}
1: 		
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			SanityManager.THROWASSERT("getNegationNode called with invalid nodeType: " + getNodeType());
1: 		}
1: 
0: 		return -1;
1: 	}	
1: 	
1: 	/**
1: 	 * is this is useful start key? for example a predicate of the from
1: 	 * <em>column Lessthan 5</em> is not a useful start key but is a useful stop
1: 	 * key. However <em>5 Lessthan column </em> is a useful start key.
1: 	 *
1: 	 * @param columnOnLeft 	is true if the column is the left hand side of the
1: 	 * binary operator.
1: 	 */
1: 	protected boolean usefulStartKey(boolean columnOnLeft)
1: 	{
0: 		switch (operatorType)
1: 		{
1: 			case RelationalOperator.EQUALS_RELOP:
1: 				return true;
1: 			case RelationalOperator.NOT_EQUALS_RELOP:
1: 				return false;
1: 			case RelationalOperator.GREATER_THAN_RELOP:
1: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1: 				// col > 1
1: 				return columnOnLeft;
1: 			case RelationalOperator.LESS_THAN_RELOP:
1: 			case RelationalOperator.LESS_EQUALS_RELOP:
1: 				// col < 1
1: 				return !columnOnLeft;
1: 			default:
1: 				return false;
1: 		}
1: 
1: 
1: 	}
1: 
1: 	/** @see RelationalOperator#usefulStopKey */
1: 	protected boolean usefulStopKey(boolean columnOnLeft)
1: 	{
0: 		switch (operatorType)
1: 		{
1: 			case RelationalOperator.EQUALS_RELOP:
1: 				return true;
1: 			case RelationalOperator.NOT_EQUALS_RELOP:
1: 				return false;
1: 			case RelationalOperator.GREATER_THAN_RELOP:
1: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1: 				// col > 1
1: 				return !columnOnLeft;
1: 			case RelationalOperator.LESS_EQUALS_RELOP:
1: 			case RelationalOperator.LESS_THAN_RELOP:
1: 				// col < 1
1: 				return columnOnLeft;
1: 			default:
1: 				return false;
1: 		}
1: 	}
1: 	
1: 	/** @see RelationalOperator#getStartOperator */
1: 	public int getStartOperator(Optimizable optTable)
1: 	{
0: 		switch (operatorType)
1: 		{
1: 			case RelationalOperator.EQUALS_RELOP:
1: 			case RelationalOperator.LESS_EQUALS_RELOP:
1: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1: 				return ScanController.GE;
1: 			case RelationalOperator.LESS_THAN_RELOP:
1: 			case RelationalOperator.GREATER_THAN_RELOP:
1: 				return ScanController.GT;
1: 			case RelationalOperator.NOT_EQUALS_RELOP:				
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.THROWASSERT("!= cannot be a start operator");
1: 				return ScanController.NA;
1: 			default:
1: 				return ScanController.NA;
1: 
1: 		}
1: 	}
1: 	
1: 	/** @see RelationalOperator#getStopOperator */
1: 	public int getStopOperator(Optimizable optTable)
1: 	{
0: 		switch (operatorType)
1: 		{
1: 			case RelationalOperator.EQUALS_RELOP:
1: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1: 			case RelationalOperator.LESS_EQUALS_RELOP:
1: 				return ScanController.GT;			
1: 			case RelationalOperator.LESS_THAN_RELOP:
1: 			case RelationalOperator.GREATER_THAN_RELOP:
1: 				return ScanController.GE;			
1: 			case RelationalOperator.NOT_EQUALS_RELOP:				
1: 				if (SanityManager.DEBUG)
1: 					SanityManager.THROWASSERT("!= cannot be a stop operator");
1: 				return ScanController.NA;				
1: 			default:
1: 				return ScanController.NA;				
1: 		}
1: 	}
1: 
1: 	/** @see RelationalOperator#generateOperator */
1: 	public void generateOperator(MethodBuilder mb,
1: 								 Optimizable optTable)
1: 	{
0: 		switch (operatorType)
1: 		{
1: 			case RelationalOperator.EQUALS_RELOP:
1: 				mb.push(Orderable.ORDER_OP_EQUALS);
1: 				break;
1: 
1: 			case RelationalOperator.NOT_EQUALS_RELOP:
1: 				mb.push(Orderable.ORDER_OP_EQUALS);
1: 				break;
1: 
1: 			case RelationalOperator.LESS_THAN_RELOP:
1: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1: 				mb.push(keyColumnOnLeft(optTable) ? 
1: 						Orderable.ORDER_OP_LESSTHAN : Orderable.ORDER_OP_LESSOREQUALS);
1: 				break;
1: 			case RelationalOperator.LESS_EQUALS_RELOP:
1: 			case RelationalOperator.GREATER_THAN_RELOP:
1: 				mb.push(keyColumnOnLeft(optTable) ? 
1: 						Orderable.ORDER_OP_LESSOREQUALS : Orderable.ORDER_OP_LESSTHAN);
1: 				
1: 		}											
1: 	}
1: 	
1: 	/** @see RelationalOperator#generateNegate */
1: 	public void generateNegate(MethodBuilder mb, Optimizable optTable)
1: 	{
0: 		switch (operatorType)
1: 		{
1: 			case RelationalOperator.EQUALS_RELOP:
1: 				mb.push(false);
1: 				break;
1: 			case RelationalOperator.NOT_EQUALS_RELOP:
1: 				mb.push(true);
1: 				break;
1: 			case RelationalOperator.LESS_THAN_RELOP:
1: 			case RelationalOperator.LESS_EQUALS_RELOP:
1: 				mb.push(!keyColumnOnLeft(optTable));
1: 				break;
1: 			case RelationalOperator.GREATER_THAN_RELOP:
1: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1: 				mb.push(keyColumnOnLeft(optTable));
1: 				break;
1: 		}
1: 		
1: 		return;
1: 	}
1: 		
1: 	/** @see RelationalOperator#getOperator */
1: 	public int getOperator()
1: 	{
0: 		return operatorType;
1: 	}
1: 
1: 	/** return the selectivity of this predicate.
1: 	 */
1: 	public double selectivity(Optimizable optTable)
1: 	{
1: 		double retval = booleanSelectivity(optTable);
1: 		
1: 		if (retval >= 0.0d)
1: 			return retval;
1: 			
0: 		switch (operatorType)
1: 		{
1: 			case RelationalOperator.EQUALS_RELOP:
1: 				return 0.1;
1: 			case RelationalOperator.NOT_EQUALS_RELOP:
1: 			case RelationalOperator.LESS_THAN_RELOP:
1: 			case RelationalOperator.LESS_EQUALS_RELOP:
1: 			case RelationalOperator.GREATER_EQUALS_RELOP:
1: 				if (getBetweenSelectivity())
1: 					return 0.5d;
1: 				/* fallthrough -- only */
1: 			case RelationalOperator.GREATER_THAN_RELOP:
1: 				return 0.33;
1: 		}
1: 		
1: 		return 0.0;
1: 	}
1: 
1: 	/** @see RelationalOperator#getTransitiveSearchClause */
1: 	public RelationalOperator getTransitiveSearchClause(ColumnReference otherCR)
1: 		throws StandardException
1: 	{
0: 		return (RelationalOperator)getNodeFactory().getNode(getNodeType(),
0: 														  otherCR,
0: 														  rightOperand,
0: 														  getContextManager());
1: 	}
1: 	
1: 	public boolean equalsComparisonWithConstantExpression(Optimizable optTable)
1: 	{
0: 		if (operatorType != EQUALS_RELOP)
1: 			return false;
1: 
1: 		boolean retval = false;
1: 		ValueNode comparand = null;
1: 
1: 		int side = columnOnOneSide(optTable);
1: 		if (side == LEFT)
1: 		{
1: 			retval = rightOperand.isConstantExpression();
1: 		}
1: 		else if (side == RIGHT)
1: 		{
1: 			retval = leftOperand.isConstantExpression();
1: 		}
1: 
1: 		return retval;
1: 	}
1: 	
1: 	/** @see ValueNode#isRelationalOperator */
0: 	public boolean isRelationalOperator()
1: 	{
1: 		return true;
1: 	}
1: 	
0: 	public boolean isBinaryEqualsOperatorNode()
1: 	{
0: 		return (operatorType == RelationalOperator.EQUALS_RELOP);
1: 	}
1: 
1: 	/** @see ValueNode#optimizableEqualityNode */
0: 	public boolean optimizableEqualityNode(Optimizable optTable, 
1: 										   int columnNumber, 
1: 										   boolean isNullOkay)
1: 		throws StandardException
1: 	{
0: 		if (operatorType != EQUALS_RELOP)
1: 			return false;
1: 
1: 		ColumnReference cr = getColumnOperand(optTable,
1: 											  columnNumber);
1: 		if (cr == null)
1: 			return false;
1: 
1: 		if (selfComparison(cr))
1: 			return false;
1: 		
1: 		if (implicitVarcharComparison())
1: 			return false;
1: 		
1: 		return true;
1: 	}
1: 	
1: 	/**
1: 	 * Return whether or not this binary relational predicate requires an implicit
1: 	 * (var)char conversion.  This is important when considering
1: 	 * hash join since this type of equality predicate is not currently
1: 	 * supported for a hash join.
1: 	 *
1: 	 * @return	Whether or not an implicit (var)char conversion is required for
1: 	 *			this binary relational operator.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	private boolean implicitVarcharComparison()
1: 		throws StandardException
1: 	{
1: 		TypeId leftType = leftOperand.getTypeId();
1: 		TypeId rightType = rightOperand.getTypeId();
1: 		
1: 		if (leftType.isStringTypeId() && !rightType.isStringTypeId())
1: 			return true;
1: 
1: 		if (rightType.isStringTypeId() && (!leftType.isStringTypeId()))
1: 			return true;
1: 
1: 		return false;
1: 	}
1: 	
1: 	/* @see BinaryOperatorNode#genSQLJavaSQLTree
1: 	 * @see BinaryComparisonOperatorNode#genSQLJavaSQLTree
1: 	 */
0: 	public ValueNode genSQLJavaSQLTree() throws StandardException
1: 	{
0: 		if (operatorType == EQUALS_RELOP)
1: 			return this;
1: 		
1: 		return super.genSQLJavaSQLTree();
1: 	}
1: }	
1: 
1: 
author:Army
-------------------------------------------------------------------------------
commit:32edb61
/////////////////////////////////////////////////////////////////////////
1: 	 * back to the InListOperatorNode referenced here.  NOTE: Once
1: 	 * set, this variable should *only* ever be accessed via the
1: 	 * isInListProbeNode() or getInListOp() methods--see comments
1: 	 * in the latter method for more.
1: 	private InListOperatorNode inListProbeSource = null;
/////////////////////////////////////////////////////////////////////////
1: 	 * IN-list).  With the exception of nullability checking via the
1: 	 * isInListProbeNode() method, all access to this.inListProbeSource
1: 	 * MUST come through this method, as this method ensures that the
1: 	 * left operand of the inListProbeSource is set correctly before
1: 	 * returning it.
1: 		if (inListProbeSource != null)
1: 		{
1: 			/* Depending on where this probe predicate currently sits
1: 			 * in the query tree, this.leftOperand *may* have been
1: 			 * transformed, replaced, or remapped one or more times
1: 			 * since inListProbeSource was last referenced. Since the
1: 			 * leftOperand of the IN list should be the same regardless
1: 			 * of which "version" of the operation we're looking at
1: 			 * (i.e. the "probe predicate" version (this node) vs the
1: 			 * original version (inListProbeSource)), we have to make
1: 			 * sure that all of the changes made to this.leftOperand
1: 			 * are reflected in inListProbeSource's leftOperand, as
1: 			 * well.  In doing so we ensure the caller of this method
1: 			 * will see an up-to-date version of the InListOperatorNode--
1: 			 * and thus, if the caller references the InListOperatorNode's
1: 			 * leftOperand, it will see the correct information. One
1: 			 * notable example of this is at code generation time, where
1: 			 * if this probe predicate is deemed "not useful", we'll
1: 			 * generate the underlying InListOperatorNode instead of
1: 			 * "this".  For that to work correctly, the InListOperatorNode
1: 			 * must have the correct leftOperand. DERBY-3253.
1: 			 *
1: 			 * That said, since this.leftOperand will always be "up-to-
1: 			 * date" w.r.t. the current query tree (because this probe
1: 			 * predicate sits in the query tree and so all relevant
1: 			 * transformations will be applied here), the simplest way
1: 			 * to ensure the underlying InListOperatorNode also has an
1: 			 * up-to-date leftOperand is to set it to this.leftOperand.
1: 			 */
1: 			inListProbeSource.setLeftOperand(this.leftOperand);
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		if (isInListProbeNode())
/////////////////////////////////////////////////////////////////////////
1: 		return !isInListProbeNode();
/////////////////////////////////////////////////////////////////////////
1: 		return !isInListProbeNode() &&
1: 	/**
1: 	 * @see ValueNode#isInListProbeNode
1: 	 *
1: 	 * It's okay for this method to reference inListProbeSource directly
1: 	 * because it does not rely on the contents of inListProbeSource's
1: 	 * leftOperand, and a caller of this method cannot gain access to
1: 	 * inListProbeSource's leftOperand through this method.
1: 	 */
/////////////////////////////////////////////////////////////////////////
1: 		if (isInListProbeNode())
commit:9d82913
/////////////////////////////////////////////////////////////////////////
0: 	/** @see ValueNode#isInListProbeNode */
0: 	public boolean isInListProbeNode()
1: 	{
1: 		return (inListProbeSource != null);
1: 	}
1: 
commit:1ad3b32
/////////////////////////////////////////////////////////////////////////
1: 	/* If this BinRelOp was created for an IN-list "probe predicate"
1: 	 * then we keep a pointer to the original IN-list.  This serves
1: 	 * two purposes: 1) if this field is non-null then we know that
1: 	 * this BinRelOp is for an IN-list probe predicate; 2) if the
1: 	 * optimizer chooses a plan for which the probe predicate is
1: 	 * not usable as a start/stop key then we'll "revert" the pred
0: 	 * back to the InListOperatorNode referenced here.
1: 	 */
0: 	InListOperatorNode inListProbeSource = null;
1: 
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Same as init() above except takes a third argument that is
0: 	 * an InListOperatorNode.  This version is used during IN-list
0: 	 * preprocessing to create a "probe predicate" for the IN-list.
0: 	 * See InListOperatorNode.preprocess() for more.
1: 	 */
0: 	public void init(Object leftOperand, Object rightOperand, Object inListOp)
1: 	{
0: 		init(leftOperand, rightOperand);
0: 		this.inListProbeSource = (InListOperatorNode)inListOp;
1: 	}
1: 
1: 	/**
1: 	 * If this rel op was created for an IN-list probe predicate then return
1: 	 * the underlying InListOperatorNode.  Will return null if this rel
1: 	 * op is a "legitimate" relational operator (as opposed to a disguised
0: 	 * IN-list).
1: 	 */
1: 	protected InListOperatorNode getInListOp()
1: 	{
1: 		return inListProbeSource;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		/* If this rel op is for an IN-list probe predicate then we never
1: 		 * treat it as a qualifer.  The reason is that if we treat it as
1: 		 * a qualifier then we could end up generating it as a qualifier,
1: 		 * which would lead to the generation of an equality qualifier
1: 		 * of the form "col = <val>" (where <val> is the first value in
1: 		 * the IN-list).  That would lead to wrong results (missing rows)
1: 		 * because that restriction is incorrect.
1: 		 */
0: 		if (inListProbeSource != null)
1: 			return false;
1: 
/////////////////////////////////////////////////////////////////////////
1: 		/* If this rel op is for a probe predicate then we do not call
1: 		 * it a "relational operator"; it's actually a disguised IN-list
1: 		 * operator.
1: 		 */
0: 		return (inListProbeSource == null);
1: 	/** @see ValueNode#isBinaryEqualsOperatorNode */
1: 		/* If this rel op is for a probe predicate then we do not treat
1: 		 * it as an "equals operator"; it's actually a disguised IN-list
1: 		 * operator.
1: 		 */
0: 		return (inListProbeSource == null) &&
0: 			(operatorType == RelationalOperator.EQUALS_RELOP);
/////////////////////////////////////////////////////////////////////////
1: 		/* If this rel op is for a probe predicate then we do not treat
1: 		 * it as an equality node; it's actually a disguised IN-list node.
1: 		 */
0: 		if (inListProbeSource != null)
1: 			return false;
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:df88f63
/////////////////////////////////////////////////////////////////////////
1: 	 * exactly one operand in the predicate to which this operator belongs
/////////////////////////////////////////////////////////////////////////
1:      * @param whichRC If not -1 then this tells us which ResultColumn
1:      *  in the received childRSN we need to use for the scoped predicate;
1:      *  if -1 then the column position of the scoped column reference
1:      *  will be stored in this array and passed back to the caller.
/////////////////////////////////////////////////////////////////////////
1: 		JBitSet parentRSNsTables, ResultSetNode childRSN,
1: 		int [] whichRC) throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 		/* When we scope a predicate we only scope one side of it--the
1: 		 * side that is to be evaluated against childRSN.  We figure out
1: 		 * if "cr" is that side by using table numbers, as seen below.
1: 		 * This means that for every scoped predicate there will be one
1: 		 * operand that is scoped and one operand that is not scoped.  
1: 		 * When we get here for the operand that will not be scoped,
1: 		 * we'll just return a clone of that operand.  So in the example
1: 		 * mentioned above, the scoped predicate for the left child of
1: 		 * X1 would be
1: 		 *
1: 		 *   T1.j <scoped> = X2.b <clone> 
1: 		 *
1: 		 * That said, the first thing we need to do is see if this
1: 		 * ColumnReference is supposed to be scoped for childRSN.  We
1: 		 * do that by figuring out what underlying base table the column
1: 		 * reference is pointing to and then seeing if that base table
1: 		 * is included in the list of table numbers from the parentRSN.
1: 		 */
/////////////////////////////////////////////////////////////////////////
1: 			return (ColumnReference)cr.getClone();
1: 		 * reference for childRSN, so go ahead and do it.  The way in
1: 		 * which we get the scope target column differs depending on
1: 		 * if childRSN corresponds to the left or right child of the
1: 		 * UNION node.  Before explaining that, though, note that it's
1: 		 * not good enough to just search for the target column by
1: 		 * name.  The reason is that it's possible the name provided
1: 		 * for the column reference to be scoped doesn't match the
1: 		 * name of the actual underlying column.  Ex.
1: 		 * If we were scoping "X1.x" and we searched for "x" in the
1: 		 * childRSN "select i,j from t1" we wouldn't find it.
1: 		 *
1: 		 * It is similarly incorrect to search for the target column
1: 		 * by position (DERBY-1633).  This is a bit more subtle, but
1: 		 * if the child to which we're scoping is a subquery whose RCL
1: 		 * does not match the column ordering of the RCL for cr's source
1: 		 * result set, then searching by column position can yield the
1: 		 * wrong results, as well.  For a detailed example of how this
1: 		 * can happen, see the fix description attached to DERBY-1633.
1: 		 * 
1: 		 * So how do we find the target column, then? As mentioned
1: 		 * above, the way in which we get the scope target column
1: 		 * differs depending on if childRSN corresponds to the left
1: 		 * or right child of the parent UNION node.  And that said,
1: 		 * we can tell if we're scoping a left child by looking at
1: 		 * "whichRC" argument: if it is -1 then we know we're scoping
1: 		 * to the left child of a Union; otherwise we're scoping to
1: 		 * the right child.
1: 		if (whichRC[0] == -1)
1: 		{
1: 			/*
1: 			 * For the left side we start by figuring out what the source
1: 			 * result set and column position for "cr" are.  Then, since
1: 			 * a) cr must be pointing to a result column in the parentRSN's
1: 			 * ResultColumnList,  b) we know that the parent RSN is a
1: 			 * SetOperatorNode (at least for now, since we only get here
1: 			 * for Union nodes), and c) SetOpNode's RCLs are built from the
1: 			 * left child's RCL (see bindResultColumns() in SetOperatorNode),
1: 			 * we know that if we search the child's RCL for a reference
1: 			 * whose source result column is the same as cr's source result
1: 			 * column, we'll find a match.  Once found, the position of the
1: 			 * matching column w.r.t childRSN's RCL will be stored in the
1: 			 * whichRC parameter.
1: 			 */
1: 			// Find the source result set and source column position of cr.
1: 			int [] sourceColPos = new int[] {-1};
1: 			ResultSetNode sourceRSN = cr.getSourceResultSet(sourceColPos);
1: 
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				/* We assumed that if we made it here "cr" was pointing
1: 				 * to a base table somewhere down the tree.  If that's
1: 				 * true then sourceRSN won't be null.  Make sure our
1: 				 * assumption was correct.
1: 				 */
1: 				SanityManager.ASSERT(sourceRSN != null,
1: 					"Failed to find source result set when trying to " +
1: 					"scope column reference '" + cr.getTableName() +
1: 					"." + cr.getColumnName());
1: 			}
1: 
1: 			// Now search for the corresponding ResultColumn in childRSN.
1: 			rc = childRSN.getResultColumns()
1: 					.getResultColumn(sourceColPos[0], sourceRSN, whichRC);
1: 		}
1: 		else
1: 		{
1: 			/*
1: 			 * For the right side the story is slightly different.  If we were
1: 			 * to search the right child's RCL for a reference whose source
1: 			 * result column was the same as cr's, we wouldn't find it.  This
1: 			 * is because cr's source result column comes from the left child's
1: 			 * RCL and thus the right child doesn't know about it.  That said,
1: 			 * though, for set operations like UNION, the left and right RCL's
1: 			 * are correlated by position--i.e. the operation occurs between
1: 			 * the nth column in the left RCL and the nth column in the right
1: 			 * RCL.  So given that we will already have found the scope target
1: 			 * in the left child's RCL at the position in whichRC, we know that
1: 			 * that scope target for the right child's RCL is simply the
1: 			 * whichRC'th column in that RCL.
1: 			 */
1: 			rc = childRSN.getResultColumns().getResultColumn(whichRC[0]);
1: 		}
1: 				"Failed to locate scope target result column when trying to " +
1: 		 * ColumnReference, then that column reference has all of the
1: 		 * info we need.
1: 		 * It is, however, possible that the ResultColumn's expression
1: 		 * is NOT a ColumnReference.  For example, the expression would
1: 		 * be a constant expression if childRSN represented something
1: 		 * like:
1: 		 * In this case the expression does not directly reference a
1: 		 * column in the underlying result set and is therefore
1: 		 * "scoped" as far as it can go.  This means that the scoped
1: 		 * predicate will not necessarily have column references on
1: 		 * both sides, even though the predicate that we're scoping
1: 		 * will.  That's not a problem, though, since a predicate with
1: 		 * a column reference on one side and a non-ColumnReference
1: 		 * on the other is still valid.
1: 
1: 		if (rc.getExpression() instanceof ColumnReference)
1: 		{
1: 			/* We create a clone of the column reference and mark
1: 			 * the clone as "scoped" so that we can do the right
1: 			 * thing when it comes time to remap the predicate;
1: 			 * see Predicate.remapScopedPred() for more.
1: 			 */
1: 			ColumnReference cRef = (ColumnReference)
1: 				((ColumnReference)rc.getExpression()).getClone();
1: 			cRef.markAsScoped();
1: 			return cRef;
1: 		}
1: 
1: 		/* Else just return rc's expression.  This means the scoped
1: 		 * predicate will have one operand that is _not_ a column
1: 		 * reference--but that's okay, so long as we account for
1: 		 * that when pushing/remapping the scoped predicate down
1: 		 * the query tree (see esp. "isScopedToSourceResultSet()"
1: 		 * in Predicate.java).
1: 		 */
1: 		return rc.getExpression();
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:0be2d6e
/////////////////////////////////////////////////////////////////////////
1: 	// Visitor for finding base tables beneath optimizables and column
1: 	// references.  Created once and re-used thereafter.
1: 	private BaseTableNumbersVisitor btnVis;
1: 
1: 	// Bit sets for holding base tables beneath optimizables and
1: 	// column references.  Created once and re-used thereafter.
1: 	JBitSet optBaseTables;
1: 	JBitSet valNodeBaseTables;
1: 
/////////////////////////////////////////////////////////////////////////
0: 		btnVis = null;
/////////////////////////////////////////////////////////////////////////
1: 		// When searching for a matching column operand, we search
1: 		// the entire subtree (if there is one) beneath optTable
1: 		// to see if we can find any FromTables that correspond to
1: 		// either of this op's column references.
1: 		boolean walkSubtree = true;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(cr, ft, false, walkSubtree))
/////////////////////////////////////////////////////////////////////////
1: 			walkSubtree = false;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(cr, ft, false, walkSubtree))
/////////////////////////////////////////////////////////////////////////
1: 		boolean walkSubtree = true;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(
1: 				cr, (FromTable)optTable, false, walkSubtree))
1: 			walkSubtree = false;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(cr,
1: 				(FromTable)optTable, false, walkSubtree))
/////////////////////////////////////////////////////////////////////////
1: 								int columnPosition,
0: 								FromTable ft)
1: 		boolean walkSubtree = true;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(cr, ft, false, walkSubtree))
/////////////////////////////////////////////////////////////////////////
1: 			walkSubtree = false;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(cr, ft, false, walkSubtree))
/////////////////////////////////////////////////////////////////////////
1: 	 * @see RelationalOperator#getOperand
1: 	 */
1: 	public ValueNode getOperand(ColumnReference cRef,
1: 		int refSetSize, boolean otherSide)
1: 	{
1: 		// Following call will initialize/reset the btnVis,
1: 		// valNodeBaseTables, and optBaseTables fields of this object.
1: 		initBaseTableVisitor(refSetSize, true);
1: 
1: 		// We search for the column reference by getting the *base*
1: 		// table number for each operand and checking to see if
1: 		// that matches the *base* table number for the cRef
1: 		// that we're looking for.  If so, then we the two
1: 		// reference the same table so we go on to check
1: 		// column position.
1: 		try {
1: 
1: 			// Use optBaseTables for cRef's base table numbers.
1: 			btnVis.setTableMap(optBaseTables);
1: 			cRef.accept(btnVis);
1: 
1: 			// Use valNodeBaseTables for operand base table nums.
1: 			btnVis.setTableMap(valNodeBaseTables);
1: 
0: 			ColumnReference	cr;
1: 			if (leftOperand instanceof ColumnReference)
1: 			{
1: 				/*
1: 				** The left operand is a column reference.
1: 				** Is it the correct column?
1: 				*/
1: 				cr = (ColumnReference) leftOperand;
1: 				cr.accept(btnVis);
1: 				valNodeBaseTables.and(optBaseTables);
1: 				if (valNodeBaseTables.getFirstSetBit() != -1)
1: 				{
1: 					/*
1: 					** The table is correct, how about the column position?
1: 					*/
1: 					if (cr.getSource().getColumnPosition() ==
1: 						cRef.getColumnNumber())
1: 					{
1: 						/*
1: 						** We've found the correct column -
1: 						** return the appropriate side.
1: 						*/
1: 						if (otherSide)
1: 							return rightOperand;
1: 						return leftOperand;
1: 					}
1: 				}
1: 			}
1: 
1: 			if (rightOperand instanceof ColumnReference)
1: 			{
1: 				/*
1: 				** The right operand is a column reference.
1: 				** Is it the correct column?
1: 				*/
1: 				valNodeBaseTables.clearAll();
1: 				cr = (ColumnReference) rightOperand;
1: 				cr.accept(btnVis);
1: 				valNodeBaseTables.and(optBaseTables);
1: 				if (valNodeBaseTables.getFirstSetBit() != -1)
1: 				{
1: 					/*
1: 					** The table is correct, how about the column position?
1: 					*/
1: 					if (cr.getSource().getColumnPosition() == 
1: 						cRef.getColumnNumber())
1: 					{
1: 						/*
1: 						** We've found the correct column -
1: 						** return the appropriate side
1: 						*/
1: 						if (otherSide)
1: 							return leftOperand;
1: 						return rightOperand;
1: 					}
1: 				}
1: 			}
1: 
1: 		} catch (StandardException se) {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.THROWASSERT("Failed when trying to " +
0:                     "find base table number for column reference check:\n" +
0:                     se.getMessage());
1:             }
1: 		}
1: 
1: 		return null;
1: 	}
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 		ValueNode exprOp = getExpressionOperand(
1: 			ft.getTableNumber(), columnPosition, ft);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(
1: 				cr, (FromTable)optTable, false, true))
1: 
1: 		// Else the right operand must be the key column.
0:     	if (SanityManager.DEBUG)
1: 			if (!left)
1: 			{
1: 		    	SanityManager.ASSERT(
1: 					(rightOperand instanceof ColumnReference) &&
1: 					valNodeReferencesOptTable((ColumnReference)rightOperand,
1: 			    		(FromTable)optTable, false, true),
0: 					"Key column not found on either side.");
1: 			}
/////////////////////////////////////////////////////////////////////////
1: 		boolean			walkSubtree = true;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(
1: 				cr, (FromTable)optTable, false, walkSubtree))
1: 			walkSubtree = false;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(
1: 				cr, (FromTable)optTable, false, walkSubtree))
/////////////////////////////////////////////////////////////////////////
1: 	public boolean isQualifier(Optimizable optTable, boolean forPush)
/////////////////////////////////////////////////////////////////////////
1: 		boolean walkSubtree = true;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(cr, ft, forPush, walkSubtree))
1: 			walkSubtree = false;
/////////////////////////////////////////////////////////////////////////
1: 			if (valNodeReferencesOptTable(cr, ft, forPush, walkSubtree))
/////////////////////////////////////////////////////////////////////////
1: 		return !valNodeReferencesOptTable(otherSide, ft, forPush, true);
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Determine whether or not the received ValueNode (which will
1: 	 * usually be a ColumnReference) references either the received
1: 	 * optTable or else a base table in the subtree beneath that
1: 	 * optTable.
1: 	 *
1: 	 * @param valNode The ValueNode that has the reference(s).
1: 	 * @param optTable The table/subtree node to which we're trying
1: 	 *  to find a reference.
1: 	 * @param forPush Whether or not we are searching with the intent
1: 	 *  to push this operator to the target table.
1: 	 * @param walkOptTableSubtree Should we walk the subtree beneath
1: 	 *  optTable to find base tables, or not?  Will be false if we've
1: 	 *  already done it for the left operand and now we're here
1: 	 *  for the right operand.
1: 	 * @return True if valNode contains a reference to optTable or
1: 	 *  to a base table in the subtree beneath optTable; false
1: 	 *  otherwise.
1: 	 */
1: 	private boolean valNodeReferencesOptTable(ValueNode valNode,
0: 		FromTable optTable, boolean forPush, boolean walkOptTableSubtree)
1: 	{
1: 		// Following call will initialize/reset the btnVis,
1: 		// valNodeBaseTables, and optBaseTables fields of this object.
1: 		initBaseTableVisitor(optTable.getReferencedTableMap().size(),
1: 			walkOptTableSubtree);
1: 		boolean found = false;
1: 		try {
1: 			// Find all base tables beneath optTable and load them
1: 			// into this object's optBaseTables map.  This is the
1: 			// list of table numbers we'll search to see if the
1: 			// value node references any tables in the subtree at
1: 			// or beneath optTable.
1: 			if (walkOptTableSubtree)
1: 				buildTableNumList(optTable, forPush);
0: 
1: 			// Now get the base table numbers that are in valNode's
1: 			// subtree.  In most cases valNode will be a ColumnReference
1: 			// and this will return a single base table number.
1: 			btnVis.setTableMap(valNodeBaseTables);
1: 			valNode.accept(btnVis);
0: 
1: 			// And finally, see if there's anything in common.
1: 			valNodeBaseTables.and(optBaseTables);
1: 			found = (valNodeBaseTables.getFirstSetBit() != -1);
0: 
1: 		} catch (StandardException se) {
0: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.THROWASSERT("Failed when trying to " +
0: 					"find base table numbers for reference check:\n" +
0: 					se.getMessage());
1: 			}
1: 		}
0: 
1: 		return found;
1: 	}
0: 
1: 	/**
1: 	 * Initialize the fields used for retrieving base tables in
1: 	 * subtrees, which allows us to do a more extensive search
1: 	 * for table references.  If the fields have already been
1: 	 * created, then just reset their values.
1: 	 *
1: 	 * @param numTablesInQuery Used for creating JBitSets that
1: 	 *  can hold table numbers for the query.
1: 	 * @param initOptBaseTables Whether or not we should clear out
1: 	 *  or initialize the optBaseTables bit set.
1: 	 */
1: 	private void initBaseTableVisitor(int numTablesInQuery,
1: 		boolean initOptBaseTables)
1: 	{
1: 		if (valNodeBaseTables == null)
1: 			valNodeBaseTables = new JBitSet(numTablesInQuery);
1: 		else
1: 			valNodeBaseTables.clearAll();
0: 
1: 		if (initOptBaseTables)
1: 		{
1: 			if (optBaseTables == null)
1: 				optBaseTables = new JBitSet(numTablesInQuery);
1: 			else
1: 				optBaseTables.clearAll();
1: 		}
0: 
1: 		// Now create the visitor.  We give it valNodeBaseTables
1: 		// here for sake of creation, but this can be overridden
1: 		// (namely, by optBaseTables) by the caller of this method.
1: 		if (btnVis == null)
1: 			btnVis = new BaseTableNumbersVisitor(valNodeBaseTables);
1: 	}
0: 
1: 	/**
1: 	 * Create a set of table numbers to search when trying to find
1: 	 * which (if either) of this operator's operands reference the
1: 	 * received target table.  At the minimum this set should contain
1: 	 * the target table's own table number.  After that, if we're
1: 	 * _not_ attempting to push this operator (or more specifically,
1: 	 * the predicate to which this operator belongs) to the target
1: 	 * table, we go on to search the subtree beneath the target
1: 	 * table and add any base table numbers to the searchable list.
1: 	 *
1: 	 * @param ft Target table for which we're building the search
1: 	 *  list.
1: 	 * @param forPush Whether or not we are searching with the intent
1: 	 *  to push this operator to the target table.
1: 	 */
0: 	private void buildTableNumList(FromTable ft, boolean forPush)
1: 		throws StandardException
1: 	{
1: 		// Start with the target table's own table number.  Note
1: 		// that if ft is an instanceof SingleChildResultSet, its
1: 		// table number could be negative.
1: 		if (ft.getTableNumber() >= 0)
1: 			optBaseTables.set(ft.getTableNumber());
0: 
1: 		if (forPush)
1: 		// nothing else to do.
0: 			return;
0: 
1: 		// Add any table numbers from the target table's
1: 		// reference map.
1: 		optBaseTables.or(ft.getReferencedTableMap());
0: 
1: 		// The table's reference map is not guaranteed to have
1: 		// all of the tables that are actually used--for example,
1: 		// if the table is a ProjectRestrictNode or a JoinNode
1: 		// with a subquery as a child, the ref map will contain
1: 		// the number for the PRN above the subquery, but it
1: 		// won't contain the table numbers referenced by the
1: 		// subquery.  So here we go through and find ALL base
1: 		// table numbers beneath the target node.
1: 		btnVis.setTableMap(optBaseTables);
1: 		ft.accept(btnVis);
0: 		return;
1: 	}
0: 
1: }
commit:6eeba4f
/////////////////////////////////////////////////////////////////////////
1: 		 *
0: 		 * As a final note, we have to be sure we only set the column
0: 		 * reference's column number if the reference points to a base table.
0: 		 * If the reference points to some other ResultSetNode--esp. another
0: 		 * subquery node--then it (the reference) already holds the correct
0: 		 * number with respect to that ResultSetNode and we don't change
0: 		 * it.  The reason is that the reference could end up getting pushed
0: 		 * down further to that ResultSetNode, in which case we'll do another
0: 		 * scoping operation and, in order for that to be successful, the
0: 		 * reference to be scoped has to know what the target column number
0: 		 * is w.r.t to that ResultSetNode (i.e. it'll be playing the role of
0: 		 * "cr" as described here).
/////////////////////////////////////////////////////////////////////////
0: 			if (cRef.pointsToBaseTable())
0: 				cRef.setColumnNumber(cr.getColumnNumber());
/////////////////////////////////////////////////////////////////////////
0: 		 * In this case we just return a clone of the column reference
0: 		return (ValueNode)cr.getClone();
commit:6718a25
/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
1: 	 * Take a ResultSetNode and return a column reference that is scoped for
1: 	 * for the received ResultSetNode, where "scoped" means that the column
1: 	 * reference points to a specific column in the RSN.  This is used for
1: 	 * remapping predicates from an outer query down to a subquery. 
1: 	 *
1: 	 * For example, assume we have the following query:
1: 	 *
1: 	 *  select * from
1: 	 *    (select i,j from t1 union select i,j from t2) X1,
1: 	 *    (select a,b from t3 union select a,b from t4) X2
1: 	 *  where X1.j = X2.b;
1: 	 *
1: 	 * Then assume that this BinaryRelationalOperatorNode represents the
1: 	 * "X1.j = X2.b" predicate and that the childRSN we received as a
1: 	 * parameter represents one of the subqueries to which we want to push
1: 	 * the predicate; let's say it's:
1: 	 *
1: 	 *    select i,j from t1
1: 	 *
1: 	 * Then what we want to do in this method is map one of the operands
1: 	 * X1.j or X2.b (depending on the 'whichSide' parameter) to the childRSN,
1: 	 * if possible.  Note that in our example, "X2.b" should _NOT_ be mapped
1: 	 * because it doesn't apply to the childRSN for the subquery "select i,j
1: 	 * from t1"; thus we should leave it as it is.  "X1.j", however, _does_
1: 	 * need to be scoped, and so this method will return a ColumnReference
1: 	 * pointing to "T1.j" (or whatever the corresponding column in T1 is).
1: 	 *
1: 	 * ASSUMPTION: We should only get to this method if we know that
0: 	 * at least one operand in the predicate to which this operator belongs
1: 	 * can and should be mapped to the received childRSN. 
1: 	 *
1:      * @param whichSide The operand are we trying to scope (LEFT or RIGHT)
1:      * @param parentRSNsTables Set of all table numbers referenced by
1:      *  the ResultSetNode that is _parent_ to the received childRSN.
1:      *  We need this to make sure we don't scope the operand to a
1:      *  ResultSetNode to which it doesn't apply.
1:      * @param childRSN The result set node to which we want to create
1:      *  a scoped predicate.
1:      * @return A column reference scoped to the received childRSN, if possible.
1:      *  If the operand is a ColumnReference that is not supposed to be scoped,
1: 	 *  we return a _clone_ of the reference--this is necessary because the
1: 	 *  reference is going to be pushed to two places (left and right children
1: 	 *  of the parentRSN) and if both children are referencing the same
1: 	 *  instance of the column reference, they'll interfere with each other
1: 	 *  during optimization.
1: 	 */
0: 	public ValueNode getScopedOperand(int whichSide,
0: 		JBitSet parentRSNsTables, ResultSetNode childRSN)
1: 		throws StandardException
0: 	{
0: 		ResultColumn rc = null;
1: 		ColumnReference cr = 
1: 			whichSide == LEFT
1: 				? (ColumnReference)leftOperand
1: 				: (ColumnReference)rightOperand;
0: 
0: 		// The first thing we need to do is see if this ColumnReference
0: 		// is supposed to be scoped for childRSN.  We do that by figuring
0: 		// out what underlying base table the column reference is pointing
0: 		// to and then seeing if that base table is included in the list of
0: 		// table numbers from the parentRSN.
1: 		JBitSet crTables = new JBitSet(parentRSNsTables.size());
0: 		BaseTableNumbersVisitor btnVis =
1: 			new BaseTableNumbersVisitor(crTables);
0: 		cr.accept(btnVis);
0: 
0: 		// If the column reference doesn't reference any tables,
0: 		// then there's no point in mapping it to the child result
0: 		// set; just return a clone of the operand.
0: 		if (crTables.getFirstSetBit() == -1)
0: 		{
0: 			return (ValueNode)cr.getClone();
0: 		}
0: 
1: 		/* If the column reference in question is not intended for
1: 		 * the received result set node, just leave the operand as
1: 		 * it is (i.e. return a clone).  In the example mentioned at
1: 		 * the start of this method, this will happen when the operand
1: 		 * is X2.b and childRSN is either "select i,j from t1" or
1: 		 * "select i,j from t2", in which case the operand does not
1: 		 * apply to childRSN.  When we get here and try to map the
1: 		 * "X1.j" operand, though, the following "contains" check will
1: 		 * return true and thus we can go ahead and return a scoped
1: 		 * version of that operand.
1: 		 */
1: 		if (!parentRSNsTables.contains(crTables))
0: 		{
0: 			return (ValueNode)cr.getClone();
0: 		}
0: 
0: 		// If the column reference is already pointing to the
0: 		// correct table, then there's no need to change it.
0: 		if ((childRSN.getReferencedTableMap() != null) &&
0: 			childRSN.getReferencedTableMap().get(cr.getTableNumber()))
0: 		{
0: 			return cr;
0: 		}
0: 
1: 		/* Find the target ResultColumn in the received result set.  At
1: 		 * this point we know that we do in fact need to scope the column
0: 		 * reference for childRSN, so go ahead and do it.  We get the
0: 		 * target column by column position instead of by name because
0: 		 * it's possible that the name given for the query doesn't match
0: 		 * the name of the actual column we're looking for.  Ex.
1: 		 *
1: 		 *  select * from
1: 		 *    (select i,j from t1 union select i,j from t2) X1 (x,y),
1: 		 *    (select a,b from t3 union select a,b from t4) X2
1: 		 *  where X1.x = X2.b;
1: 		 *
0: 		 * If we searched for "x" in the childRSN "select i,j from t1"
0: 		 * we wouldn't find it.  So we have to look based on position.
1: 		 */
0: 
0: 		rc = childRSN.getResultColumns().getResultColumn(cr.getColumnNumber());
0: 
1: 		// rc shouldn't be null; if there was no matching ResultColumn at all,
1: 		// then we shouldn't have made it this far.
0: 		if (SanityManager.DEBUG)
0: 		{
1: 			SanityManager.ASSERT(rc != null,
0: 				"Failed to locate result column when trying to " +
1: 				"scope operand '" + cr.getTableName() + "." +
1: 				cr.getColumnName() + "'.");
0: 		}
0: 
1: 		/* If the ResultColumn we found has an expression that is a
0: 		 * ColumnReference, then that column reference has all of the info
0: 		 * we need, with one exception: the columnNumber.  Depending on our
0: 		 * depth in the tree, the ResultColumn's ColumnReference could be
0: 		 * pointing to a base column in the FromBaseTable.  In that case the
0: 		 * ColumnReference will hold the column position as it is with respect
0: 		 * to the FromBaseTable.  But when we're scoping a column reference,
0: 		 * we're scoping it to a ResultSetNode that sits (either directly or
0: 		 * indirectly) above a ProjectRestrictNode that in turn sits above the
0: 		 * FromBaseTable. This means that the scoped reference's columnNumber
0: 		 * needs to be with respect to the PRN that sits above the base table,
0: 		 * _not_ with respect to the FromBaseTable itself.  This is important
0: 		 * because column "1" in the PRN might not be column "1" in the
0: 		 * underlying base table. For example, if we have base table TT with
0: 		 * four columns (a int, b int, i int, j int) and the PRN above it only
0: 		 * projects out columns (i,j), then column "1" for the PRN is "i", but
0: 		 * column "1" for base table TT is "a".  On the flip side, column "3"
0: 		 * for base table TT is "i", but if we search the PRN's result columns
0: 		 * (which match the result columns for the ResultSetNode to which
0: 		 * we're scoping) for column "3", we won't find it.
1: 		 *
0: 		 * So what does all of that mean?  It means that if the ResultColumn
0: 		 * we found has an expression that's a ColumnReference, we can simply
0: 		 * return that ColumnReference IF we set it's columnNumber correctly.
0: 		 * Thankfully the column reference we're trying to scope ("cr") came
0: 		 * from further up the tree and so it knows what the correct column
0: 		 * position (namely, the position w.r.t the ProjectRestrictNode above
0: 		 * the FromBaseTable) needs to be.  So that's the column number we
0: 		 * use.
1: 		 */
0: 		if (rc.getExpression() instanceof ColumnReference)
0: 		{
0: 			// Make sure the ColumnReference's columnNumber is correct,
0: 			// then just return that reference.  Note: it's okay to overwrite
0: 			// the columnNumber directly because when it eventually makes
0: 			// it down to the PRN over the FromBaseTable, it will be remapped
0: 			// for the FromBaseTable and the columnNumber will then be set
0: 			// correctly.  That remapping is done in the pushOptPredicate()
0: 			// method of ProjectRestrictNode.
0: 			ColumnReference cRef = (ColumnReference)rc.getExpression();
0: 			cRef.setColumnNumber(cr.getColumnNumber());
0: 			return cRef;
0: 		}
0: 
0: 		/* We can get here if the ResultColumn's expression isn't a
0: 		 * ColumnReference.  For example, the expression would be a
0: 		 * constant expression if childRSN represented something like:
1: 		 *
1: 		 *   select 1, 1 from t1
1: 		 *
0: 		 * In this case we just return the column reference as it is
0: 		 * because it's scoped as far as we can take it.
1: 		 */
0: 		return cr;
0: 	}
0: 
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
1: 						((node.requiresTypeFromContext()) &&
/////////////////////////////////////////////////////////////////////////
1: 		else if (node.requiresTypeFromContext())
1: 			ParameterNode pn;
1: 			if (node instanceof UnaryOperatorNode) 
1: 	  			pn = ((UnaryOperatorNode)node).getParameterOperand();
0: 			else
1: 	  			pn = (ParameterNode) (node);
1: 			return pn.getDefaultValue();
/////////////////////////////////////////////////////////////////////////
1: 	throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	throws StandardException
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ScanController;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.Orderable;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import java.sql.Types;
0: 
0: /**
0:  * This class represents the 6 binary operators: LessThan, LessThanEquals,
0:  * Equals, NotEquals, GreaterThan and GreaterThanEquals.
0:  *
0:  * @author Manish Khettry
0:  */
0: 
0: public class BinaryRelationalOperatorNode
0: 	extends BinaryComparisonOperatorNode
0: 	implements RelationalOperator
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private int operatorType;
0: 	/* RelationalOperator Interface */
0: 
0: 	public void init(Object leftOperand, Object rightOperand)
0: 	{
0: 		String methodName = "";
0: 		String operatorName = "";
0: 
0: 		switch (getNodeType())
0: 		{
0: 			case C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE:
0: 				methodName = "equals";
0: 				operatorName = "=";
0: 				operatorType = RelationalOperator.EQUALS_RELOP;
0: 				break;
0: 
0: 			case C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE:
0: 				methodName = "greaterOrEquals";
0: 				operatorName = ">=";
0: 				operatorType = RelationalOperator.GREATER_EQUALS_RELOP;
0: 				break;
0: 
0: 			case C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE:
0: 				methodName = "greaterThan";
0: 				operatorName = ">";
0: 				operatorType = RelationalOperator.GREATER_THAN_RELOP;
0: 				break;
0: 
0: 			case C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE:
0: 				methodName = "lessOrEquals";
0: 				operatorName = "<=";
0: 				operatorType =  RelationalOperator.LESS_EQUALS_RELOP;
0: 				break;
0: 
0: 			case C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE:
0: 				methodName = "lessThan";
0: 				operatorName = "<";
0: 				operatorType = RelationalOperator.LESS_THAN_RELOP;
0: 				break;
0: 			case C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE:
0: 				methodName = "notEquals";
0: 				operatorName = "<>";
0: 				operatorType = RelationalOperator.NOT_EQUALS_RELOP;
0: 				break;
0: 
0: 			default:
0: 				if (SanityManager.DEBUG)
0: 				{
0: 					SanityManager.THROWASSERT("init for BinaryRelationalOperator called with wrong nodeType = " + getNodeType());
0: 				}
0: 			    break;
0: 		}
0: 		super.init(leftOperand, rightOperand, operatorName, methodName);
0: 	}
0: 
0: 	/** @see RelationalOperator#getColumnOperand */
0: 	public ColumnReference getColumnOperand(
0: 								Optimizable optTable,
0: 								int columnPosition)
0: 	{
0: 		FromTable	ft = (FromTable) optTable;
0: 
0: 		return getColumnOperand(ft.getTableNumber(), columnPosition);
0: 	}
0: 
0: 	/** @see RelationalOperator#getColumnOperand */
0: 	public ColumnReference getColumnOperand(
0: 								int tableNumber,
0: 								int columnPosition)
0: 	{
0: 		ColumnReference	cr;
0: 
0: 		if (leftOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The left operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == tableNumber)
0: 			{
0: 				/*
0: 				** The table is correct, how about the column position?
0: 				*/
0: 				if (cr.getSource().getColumnPosition() == columnPosition)
0: 				{
0: 					/* We've found the correct column - return it */
0: 					return cr;
0: 				}
0: 			}
0: 		}
0: 
0: 		if (rightOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The right operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == tableNumber)
0: 			{
0: 				/*
0: 				** The table is correct, how about the column position?
0: 				*/
0: 				if (cr.getSource().getColumnPosition() == columnPosition)
0: 				{
0: 					/* We've found the correct column - return it */
0: 					return cr;
0: 				}
0: 			}
0: 		}
0: 
0: 		/* Neither side is the column we're looking for */
0: 		return null;
0: 	}
0: 
0: 	/** @see RelationalOperator#getColumnOperand */
0: 	public ColumnReference getColumnOperand(Optimizable optTable)
0: 	{
0: 		ColumnReference	cr;
0: 
0: 		if (leftOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The left operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == optTable.getTableNumber())
0: 			{
0: 				/*
0: 				** The table is correct.
0: 				*/
0: 				return cr;
0: 			}
0: 		}
0: 
0: 		if (rightOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The right operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == optTable.getTableNumber())
0: 			{
0: 				/*
0: 				** The table is correct
0: 				*/
0: 				return cr;
0: 			}
0: 		}
0: 
0: 		/* Neither side is the column we're looking for */
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * @see RelationalOperator#getExpressionOperand
0: 	 */
0: 	public ValueNode getExpressionOperand(
0: 								int tableNumber,
0: 								int columnPosition)
0: 	{
0: 		ColumnReference	cr;
0: 
0: 		if (leftOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The left operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == tableNumber)
0: 			{
0: 				/*
0: 				** The table is correct, how about the column position?
0: 				*/
0: 				if (cr.getSource().getColumnPosition() == columnPosition)
0: 				{
0: 					/*
0: 					** We've found the correct column -
0: 					** return the other side
0: 					*/
0: 					return rightOperand;
0: 				}
0: 			}
0: 		}
0: 
0: 		if (rightOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The right operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == tableNumber)
0: 			{
0: 				/*
0: 				** The table is correct, how about the column position?
0: 				*/
0: 				if (cr.getSource().getColumnPosition() == columnPosition)
0: 				{
0: 					/*
0: 					** We've found the correct column -
0: 					** return the other side
0: 					*/
0: 					return leftOperand;
0: 				}
0: 			}
0: 		}
0: 
0: 		return null;
0: 	}
0: 
0: 	/**
0: 	 * @see RelationalOperator#generateExpressionOperand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generateExpressionOperand(
0: 								Optimizable optTable,
0: 								int columnPosition,
0: 								ExpressionClassBuilder acb,
0: 								MethodBuilder mb)
0: 						throws StandardException
0: 	{
0: 		ColumnReference	cr;
0: 		FromBaseTable	ft;
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0:     		SanityManager.ASSERT(optTable instanceof FromBaseTable);
0:     	}
0: 		ft = (FromBaseTable) optTable;
0: 
0: 		ValueNode exprOp =
0: 					getExpressionOperand(ft.getTableNumber(), columnPosition);
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (exprOp == null)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"ColumnReference for correct column (columnPosition = " +
0: 					columnPosition +
0: 					", exposed table name = " + ft.getExposedName() +
0: 				") not found on either side of BinaryRelationalOperator");
0: 			}
0: 		}
0: 
0: 		exprOp.generateExpression(acb, mb);
0: 	}
0: 
0: 	/** @see RelationalOperator#selfComparison 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean selfComparison(ColumnReference cr)
0: 		throws StandardException
0: 	{
0: 		ValueNode	otherSide;
0: 		JBitSet		tablesReferenced;
0: 
0: 		/*
0: 		** Figure out which side the given ColumnReference is on,
0: 		** and look for the same table on the other side.
0: 		*/
0: 		if (leftOperand == cr)
0: 		{
0: 			otherSide = rightOperand;
0: 		}
0: 		else if (rightOperand == cr)
0: 		{
0: 			otherSide = leftOperand;
0: 		}
0: 		else
0: 		{
0: 			otherSide = null;
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.THROWASSERT(
0: 			  		"ColumnReference not found on either side of binary comparison.");
0: 			}
0: 		}
0: 
0: 		tablesReferenced = otherSide.getTablesReferenced();
0: 
0: 		/* Return true if the table we're looking for is in the bit map */
0: 		return tablesReferenced.get(cr.getTableNumber());
0: 	}
0: 
0: 	/** @see RelationalOperator#usefulStartKey */
0: 	public boolean usefulStartKey(Optimizable optTable)
0: 	{
0: 		/*
0: 		** Determine whether this operator is a useful start operator
0: 		** with knowledge of whether the key column is on the left or right.
0: 		*/
0: 		int	columnSide = columnOnOneSide(optTable);
0: 
0: 		if (columnSide == NEITHER)
0: 			return false;
0: 		else
0: 			return usefulStartKey(columnSide == LEFT);
0: 	}
0: 
0: 	/**
0: 	 * Return true if a key column for the given table is found on the
0: 	 * left side of this operator, false if it is found on the right
0: 	 * side of this operator.
0: 	 *
0: 	 * NOTE: This method assumes that a key column will be found on one
0: 	 * side or the other.  If you don't know whether a key column exists,
0: 	 * use the columnOnOneSide() method (below).
0: 	 *
0: 	 * @param optTable	The Optimizable table that we're looking for a key
0: 	 *					column on.
0: 	 *
0: 	 * @return true if a key column for the given table is on the left
0: 	 *			side of this operator, false if one is found on the right
0: 	 *			side of this operator.
0: 	 */
0: 	protected boolean keyColumnOnLeft(Optimizable optTable)
0: 	{
0: 		ColumnReference	cr;
0: 		FromTable	ft;
0: 		boolean			left = false;
0: 
0: 		ft = (FromTable) optTable;
0: 
0: 		/* Is the key column on the left or the right? */
0: 		if (leftOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The left operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == ft.getTableNumber())
0: 			{
0: 				/* The left operand is the key column */
0: 				left = true;
0: 			}
0: 		}
0: 		else
0: 		{
0:     		if (SanityManager.DEBUG)
0: 	    	{
0: 		    	SanityManager.ASSERT((rightOperand instanceof ColumnReference) &&
0: 			    		(((ColumnReference) rightOperand).getTableNumber() ==
0:     														ft.getTableNumber()),
0: 	    				"Key column not found on either side.");
0: 	    	}
0: 			/* The right operand is the key column */
0: 			left = false;
0: 		}
0: 
0: 		return left;
0: 	}
0: 
0: 	/* Return values for columnOnOneSide */
0: 	protected static final int LEFT = -1;
0: 	protected static final int NEITHER = 0;
0: 	protected static final int RIGHT = 1;
0: 
0: 	/**
0: 	 * Determine whether there is a column from the given table on one side
0: 	 * of this operator, and if so, which side is it on?
0: 	 *
0: 	 * @param optTable	The Optimizable table that we're looking for a key
0: 	 *					column on.
0: 	 *
0: 	 * @return	LEFT if there is a column on the left, RIGHT if there is
0: 	 *			a column on the right, NEITHER if no column found on either
0: 	 *			side.
0: 	 */
0: 	protected int columnOnOneSide(Optimizable optTable)
0: 	{
0: 		ColumnReference	cr;
0: 		boolean			left = false;
0: 
0: 		/* Is a column on the left */
0: 		if (leftOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The left operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == optTable.getTableNumber())
0: 			{
0: 				/* Key column found on left */
0: 				return LEFT;
0: 			}
0: 		}
0: 
0: 		if (rightOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The right operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == optTable.getTableNumber())
0: 			{
0: 				/* Key column found on right */
0: 				return RIGHT;
0: 			}
0: 		}
0: 
0: 		return NEITHER;
0: 	}
0: 
0: 	/** @see RelationalOperator#usefulStopKey */
0: 	public boolean usefulStopKey(Optimizable optTable)
0: 	{
0: 		/*
0: 		** Determine whether this operator is a useful start operator
0: 		** with knowledge of whether the key column is on the left or right.
0: 		*/
0: 		int	columnSide = columnOnOneSide(optTable);
0: 
0: 		if (columnSide == NEITHER)
0: 			return false;
0: 		else
0: 			return usefulStopKey(columnSide == LEFT);
0: 	}
0: 
0: 	/**
0: 	 * Determine whether this comparison operator is a useful stop key
0: 	 * with knowledge of whether the key column is on the left or right.
0: 	 *
0: 	 * @param left	true means the key column is on the left, false means
0: 	 *				it is on the right.
0: 	 *
0: 	 * @return	true if this is a useful stop key
0: 	 */
0: 	/** @see RelationalOperator#generateAbsoluteColumnId */
0: 	public void generateAbsoluteColumnId(MethodBuilder mb,
0: 											   Optimizable optTable)
0: 	{
0: 		// Get the absolute column position for the column
0: 		int columnPosition = getAbsoluteColumnPosition(optTable);
0: 
0: 		mb.push(columnPosition);
0: 	}
0: 
0: 	/** @see RelationalOperator#generateRelativeColumnId */
0: 	public void generateRelativeColumnId(MethodBuilder mb,
0: 											   Optimizable optTable)
0: 	{
0: 		// Get the absolute column position for the column
0: 		int columnPosition = getAbsoluteColumnPosition(optTable);
0: 		// Convert the absolute to the relative 0-based column position
0: 		columnPosition = optTable.convertAbsoluteToRelativeColumnPosition(
0: 								columnPosition);
0: 
0: 		mb.push(columnPosition);
0: 	}
0: 
0: 	/**
0: 	 * Get the absolute 0-based column position of the ColumnReference from 
0: 	 * the conglomerate for this Optimizable.
0: 	 *
0: 	 * @param optTable	The Optimizable
0: 	 *
0: 	 * @return The absolute 0-based column position of the ColumnReference
0: 	 */
0: 	private int getAbsoluteColumnPosition(Optimizable optTable)
0: 	{
0: 		ColumnReference	cr;
0: 		ConglomerateDescriptor bestCD;
0: 		int columnPosition;
0: 
0: 		if (keyColumnOnLeft(optTable))
0: 		{
0: 			cr = (ColumnReference) leftOperand;
0: 		}
0: 		else
0: 		{
0: 			cr = (ColumnReference) rightOperand;
0: 		}
0: 
0: 		bestCD = optTable.getTrulyTheBestAccessPath().
0: 												getConglomerateDescriptor();
0: 
0: 		/*
0: 		** Column positions are one-based, store is zero-based.
0: 		*/
0: 		columnPosition = cr.getSource().getColumnPosition();
0: 
0: 		/*
0: 		** If it's an index, find the base column position in the index
0: 		** and translate it to an index column position.
0: 		*/
0: 		if (bestCD != null && bestCD.isIndex())
0: 		{
0: 			columnPosition = bestCD.getIndexDescriptor().
0: 			  getKeyColumnPosition(columnPosition);
0: 
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(columnPosition > 0,
0: 					"Base column not found in index");
0: 			}
0: 		}
0: 
0: 		// return the 0-based column position
0: 		return columnPosition - 1;
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generateQualMethod(ExpressionClassBuilder acb,
0: 								   MethodBuilder mb,
0: 								   Optimizable optTable)
0: 						throws StandardException
0: 	{
0: 		/* Generate a method that returns the expression */
0: 		MethodBuilder qualMethod = acb.newUserExprFun();
0: 
0: 		/*
0: 		** Generate the expression that's on the opposite side
0: 		** of the key column
0: 		*/
0: 		if (keyColumnOnLeft(optTable))
0: 		{
0: 			rightOperand.generateExpression(acb, qualMethod);
0: 		}
0: 		else
0: 		{
0: 			leftOperand.generateExpression(acb, qualMethod);
0: 		}
0: 
0: 		qualMethod.methodReturn();
0: 		qualMethod.complete();
0: 
0: 		/* push an expression that evaluates to the GeneratedMethod */
0: 		acb.pushMethodReference(mb, qualMethod);
0: 	}
0: 
0: 	/** @see RelationalOperator#generateOrderedNulls */
0: 	public void generateOrderedNulls(MethodBuilder mb)
0: 	{
0: 		mb.push(false);
0: 	}
0: 
0: 	/** @see RelationalOperator#orderedNulls */
0: 	public boolean orderedNulls()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/** @see RelationalOperator#isQualifier 
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean isQualifier(Optimizable optTable)
0: 		throws StandardException
0: 	{
0: 		FromTable	ft;
0: 		ValueNode	otherSide = null;
0: 		JBitSet		tablesReferenced;
0: 		ColumnReference	cr = null;
0: 		boolean	found = false;
0: 
0: 		ft = (FromTable) optTable;
0: 
0: 		if (leftOperand instanceof ColumnReference)
0: 		{
0: 			/*
0: 			** The left operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) leftOperand;
0: 			if (cr.getTableNumber() == ft.getTableNumber())
0: 			{
0: 				otherSide = rightOperand;
0: 				found = true;
0: 			}
0: 		}
0: 
0: 		if ( ( ! found) && (rightOperand instanceof ColumnReference) )
0: 		{
0: 			/*
0: 			** The right operand is a column reference.
0: 			** Is it the correct column?
0: 			*/
0: 			cr = (ColumnReference) rightOperand;
0: 			if (cr.getTableNumber() == ft.getTableNumber())
0: 			{
0: 				otherSide = leftOperand;
0: 				found = true;
0: 			}
0: 		}
0: 
0: 		/* Have we found a ColumnReference on either side? */
0: 		if ( ! found)
0: 		{
0: 			/*
0: 			** Neither side is a ColumnReference to the table we're looking
0: 			** for, so it can't be a Qualifier
0: 			*/
0: 			return false;
0: 		}
0: 
0: 		/*
0: 		** One side is a ColumnReference to the correct table.  It is a
0: 		** Qualifier if the other side does not refer to the table we are
0: 		** optimizing.
0: 		*/
0: 		tablesReferenced = otherSide.getTablesReferenced();
0: 
0: 		return  ! (tablesReferenced.get(ft.getTableNumber()));
0: 	}
0: 
0: 	/** 
0: 	 * @see RelationalOperator#getOrderableVariantType 
0: 	 *
0: 	 * @exception StandardException	thrown on error
0: 	 */
0: 	public int getOrderableVariantType(Optimizable optTable) 
0: 		throws StandardException
0: 	{
0: 		/* The Qualifier's orderable is on the opposite side from
0: 		 * the key column.
0: 		 */
0: 		if (keyColumnOnLeft(optTable))
0: 		{
0: 			return rightOperand.getOrderableVariantType();
0: 		}
0: 		else
0: 		{
0: 			return leftOperand.getOrderableVariantType();
0: 		}
0: 	}
0: 
0: 	/** @see RelationalOperator#compareWithKnownConstant */
0: 	public boolean compareWithKnownConstant(Optimizable optTable, boolean considerParameters)
0: 	{
0: 		ValueNode	node = null;
0: 		node = keyColumnOnLeft(optTable) ? rightOperand : leftOperand;
0: 
0: 		if (considerParameters)
0: 		{
0: 			return (node instanceof ConstantNode) ||
0: 						((node.isParameterNode()) &&
0: 						 (((ParameterNode)node).getDefaultValue() != null));
0: 		}
0: 		else
0: 		{
0: 			return node instanceof ConstantNode;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see RelationalOperator#getCompareValue
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public DataValueDescriptor getCompareValue(Optimizable optTable) 
0:         throws StandardException
0: 	{
0: 		ValueNode	node = null;
0: 
0: 		/* The value being compared to is on the opposite side from
0: 		** the key column.
0: 		*/
0: 		node = keyColumnOnLeft(optTable) ? rightOperand : leftOperand;
0: 
0: 		if (node instanceof ConstantNode) 
0: 		{
0: 			return ((ConstantNode)node).getValue();
0: 		}
0: 		else if (node.isParameterNode())
0: 		{
0: 			return ((ParameterNode)node).getDefaultValue();
0: 		}
0: 		else
0: 		{	
0: 			return null;
0: 		}
0: 	}
0: 
0: 
0: 	/**
0: 	 * Return 50% if this is a comparison with a boolean column, a negative
0: 	 * selectivity otherwise.
0: 	 */
0: 	protected double booleanSelectivity(Optimizable optTable)
0: 	{
0: 		TypeId	typeId = null;
0: 		double				retval = -1.0d;
0: 		int					columnSide;
0: 
0: 		columnSide = columnOnOneSide(optTable);
0: 
0: 		if (columnSide == LEFT)
0: 			typeId = leftOperand.getTypeId();
0: 		else if (columnSide == RIGHT)
0: 			typeId = rightOperand.getTypeId();
0: 
0: 		if (typeId != null && (typeId.getJDBCTypeId() == Types.BIT ||
0: 		typeId.getJDBCTypeId() == JDBC30Translation.SQL_TYPES_BOOLEAN))
0: 			retval = 0.5d;
0: 
0: 		return retval;
0: 	}
0: 
0: 	/**
0: 	 * The methods generated for this node all are on Orderable.  
0: 	 * Overrides this method
0: 	 * in BooleanOperatorNode for code generation purposes.
0: 	 */
0: 	public String getReceiverInterfaceName() {
0: 	    return ClassName.DataValueDescriptor;
0: 	}
0: 	
0: 	/**
0: 	 * Returns the negation of this operator; negation of Equals is NotEquals.
0: 	 */
0: 	BinaryOperatorNode getNegation(ValueNode leftOperand, 
0: 										  ValueNode rightOperand)
0: 		throws StandardException
0: 	{
0: 		BinaryOperatorNode negation;
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(dataTypeServices != null,
0: 								 "dataTypeServices is expected to be non-null");
0: 		/* xxxRESOLVE: look into doing this in place instead of allocating a new node */
0: 		negation = (BinaryOperatorNode)
0: 			getNodeFactory().getNode(getNegationNode(),
0: 									 leftOperand, rightOperand,
0: 									 getContextManager());
0: 		negation.setType(dataTypeServices);
0: 		return negation;
0: 	}
0: 
0: 	/* map current node to its negation */
0: 	private int getNegationNode()
0: 	{
0: 		switch (getNodeType())
0: 		{
0: 			case C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE;
0: 
0: 			case C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE;
0: 
0: 			case C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE;
0: 
0: 			case C_NodeTypes.BINARY_LESS_THAN_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_GREATER_EQUALS_OPERATOR_NODE;
0: 				
0: 			case C_NodeTypes.BINARY_LESS_EQUALS_OPERATOR_NODE:
0: 				return C_NodeTypes.BINARY_GREATER_THAN_OPERATOR_NODE;
0: 
0: 			case C_NodeTypes.BINARY_NOT_EQUALS_OPERATOR_NODE:				
0: 				return C_NodeTypes.BINARY_EQUALS_OPERATOR_NODE;
0: 		}
0: 		
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("getNegationNode called with invalid nodeType: " + getNodeType());
0: 		}
0: 
0: 		return -1;
0: 	}	
0: 	
0: 	/**
0: 	 * is this is useful start key? for example a predicate of the from
0: 	 * <em>column Lessthan 5</em> is not a useful start key but is a useful stop
0: 	 * key. However <em>5 Lessthan column </em> is a useful start key.
0: 	 *
0: 	 * @param columnOnLeft 	is true if the column is the left hand side of the
0: 	 * binary operator.
0: 	 */
0: 	protected boolean usefulStartKey(boolean columnOnLeft)
0: 	{
0: 		switch (operatorType)
0: 		{
0: 			case RelationalOperator.EQUALS_RELOP:
0: 				return true;
0: 			case RelationalOperator.NOT_EQUALS_RELOP:
0: 				return false;
0: 			case RelationalOperator.GREATER_THAN_RELOP:
0: 			case RelationalOperator.GREATER_EQUALS_RELOP:
0: 				// col > 1
0: 				return columnOnLeft;
0: 			case RelationalOperator.LESS_THAN_RELOP:
0: 			case RelationalOperator.LESS_EQUALS_RELOP:
0: 				// col < 1
0: 				return !columnOnLeft;
0: 			default:
0: 				return false;
0: 		}
0: 
0: 
0: 	}
0: 
0: 	/** @see RelationalOperator#usefulStopKey */
0: 	protected boolean usefulStopKey(boolean columnOnLeft)
0: 	{
0: 		switch (operatorType)
0: 		{
0: 			case RelationalOperator.EQUALS_RELOP:
0: 				return true;
0: 			case RelationalOperator.NOT_EQUALS_RELOP:
0: 				return false;
0: 			case RelationalOperator.GREATER_THAN_RELOP:
0: 			case RelationalOperator.GREATER_EQUALS_RELOP:
0: 				// col > 1
0: 				return !columnOnLeft;
0: 			case RelationalOperator.LESS_EQUALS_RELOP:
0: 			case RelationalOperator.LESS_THAN_RELOP:
0: 				// col < 1
0: 				return columnOnLeft;
0: 			default:
0: 				return false;
0: 		}
0: 	}
0: 	
0: 	/** @see RelationalOperator#getStartOperator */
0: 	public int getStartOperator(Optimizable optTable)
0: 	{
0: 		switch (operatorType)
0: 		{
0: 			case RelationalOperator.EQUALS_RELOP:
0: 			case RelationalOperator.LESS_EQUALS_RELOP:
0: 			case RelationalOperator.GREATER_EQUALS_RELOP:
0: 				return ScanController.GE;
0: 			case RelationalOperator.LESS_THAN_RELOP:
0: 			case RelationalOperator.GREATER_THAN_RELOP:
0: 				return ScanController.GT;
0: 			case RelationalOperator.NOT_EQUALS_RELOP:				
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.THROWASSERT("!= cannot be a start operator");
0: 				return ScanController.NA;
0: 			default:
0: 				return ScanController.NA;
0: 
0: 		}
0: 	}
0: 	
0: 	/** @see RelationalOperator#getStopOperator */
0: 	public int getStopOperator(Optimizable optTable)
0: 	{
0: 		switch (operatorType)
0: 		{
0: 			case RelationalOperator.EQUALS_RELOP:
0: 			case RelationalOperator.GREATER_EQUALS_RELOP:
0: 			case RelationalOperator.LESS_EQUALS_RELOP:
0: 				return ScanController.GT;			
0: 			case RelationalOperator.LESS_THAN_RELOP:
0: 			case RelationalOperator.GREATER_THAN_RELOP:
0: 				return ScanController.GE;			
0: 			case RelationalOperator.NOT_EQUALS_RELOP:				
0: 				if (SanityManager.DEBUG)
0: 					SanityManager.THROWASSERT("!= cannot be a stop operator");
0: 				return ScanController.NA;				
0: 			default:
0: 				return ScanController.NA;				
0: 		}
0: 	}
0: 
0: 	/** @see RelationalOperator#generateOperator */
0: 	public void generateOperator(MethodBuilder mb,
0: 								 Optimizable optTable)
0: 	{
0: 		switch (operatorType)
0: 		{
0: 			case RelationalOperator.EQUALS_RELOP:
0: 				mb.push(Orderable.ORDER_OP_EQUALS);
0: 				break;
0: 
0: 			case RelationalOperator.NOT_EQUALS_RELOP:
0: 				mb.push(Orderable.ORDER_OP_EQUALS);
0: 				break;
0: 
0: 			case RelationalOperator.LESS_THAN_RELOP:
0: 			case RelationalOperator.GREATER_EQUALS_RELOP:
0: 				mb.push(keyColumnOnLeft(optTable) ? 
0: 						Orderable.ORDER_OP_LESSTHAN : Orderable.ORDER_OP_LESSOREQUALS);
0: 				break;
0: 			case RelationalOperator.LESS_EQUALS_RELOP:
0: 			case RelationalOperator.GREATER_THAN_RELOP:
0: 				mb.push(keyColumnOnLeft(optTable) ? 
0: 						Orderable.ORDER_OP_LESSOREQUALS : Orderable.ORDER_OP_LESSTHAN);
0: 				
0: 		}											
0: 	}
0: 	
0: 	/** @see RelationalOperator#generateNegate */
0: 	public void generateNegate(MethodBuilder mb, Optimizable optTable)
0: 	{
0: 		switch (operatorType)
0: 		{
0: 			case RelationalOperator.EQUALS_RELOP:
0: 				mb.push(false);
0: 				break;
0: 			case RelationalOperator.NOT_EQUALS_RELOP:
0: 				mb.push(true);
0: 				break;
0: 			case RelationalOperator.LESS_THAN_RELOP:
0: 			case RelationalOperator.LESS_EQUALS_RELOP:
0: 				mb.push(!keyColumnOnLeft(optTable));
0: 				break;
0: 			case RelationalOperator.GREATER_THAN_RELOP:
0: 			case RelationalOperator.GREATER_EQUALS_RELOP:
0: 				mb.push(keyColumnOnLeft(optTable));
0: 				break;
0: 		}
0: 		
0: 		return;
0: 	}
0: 		
0: 	/** @see RelationalOperator#getOperator */
0: 	public int getOperator()
0: 	{
0: 		return operatorType;
0: 	}
0: 
0: 	/** return the selectivity of this predicate.
0: 	 */
0: 	public double selectivity(Optimizable optTable)
0: 	{
0: 		double retval = booleanSelectivity(optTable);
0: 		
0: 		if (retval >= 0.0d)
0: 			return retval;
0: 			
0: 		switch (operatorType)
0: 		{
0: 			case RelationalOperator.EQUALS_RELOP:
0: 				return 0.1;
0: 			case RelationalOperator.NOT_EQUALS_RELOP:
0: 			case RelationalOperator.LESS_THAN_RELOP:
0: 			case RelationalOperator.LESS_EQUALS_RELOP:
0: 			case RelationalOperator.GREATER_EQUALS_RELOP:
0: 				if (getBetweenSelectivity())
0: 					return 0.5d;
0: 				/* fallthrough -- only */
0: 			case RelationalOperator.GREATER_THAN_RELOP:
0: 				return 0.33;
0: 		}
0: 		
0: 		return 0.0;
0: 	}
0: 
0: 	/** @see RelationalOperator#getTransitiveSearchClause */
0: 	public RelationalOperator getTransitiveSearchClause(ColumnReference otherCR)
0: 		throws StandardException
0: 	{
0: 		return (RelationalOperator)getNodeFactory().getNode(getNodeType(),
0: 														  otherCR,
0: 														  rightOperand,
0: 														  getContextManager());
0: 	}
0: 	
0: 	public boolean equalsComparisonWithConstantExpression(Optimizable optTable)
0: 	{
0: 		if (operatorType != EQUALS_RELOP)
0: 			return false;
0: 
0: 		boolean retval = false;
0: 		ValueNode comparand = null;
0: 
0: 		int side = columnOnOneSide(optTable);
0: 		if (side == LEFT)
0: 		{
0: 			retval = rightOperand.isConstantExpression();
0: 		}
0: 		else if (side == RIGHT)
0: 		{
0: 			retval = leftOperand.isConstantExpression();
0: 		}
0: 
0: 		return retval;
0: 	}
0: 	
0: 	/** @see ValueNode#isRelationalOperator */
0: 	public boolean isRelationalOperator()
0: 	{
0: 		return true;
0: 	}
0: 	
0: 	public boolean isBinaryEqualsOperatorNode()
0: 	{
0: 		return (operatorType == RelationalOperator.EQUALS_RELOP);
0: 	}
0: 
0: 	/** @see ValueNode#optimizableEqualityNode */
0: 	public boolean optimizableEqualityNode(Optimizable optTable, 
0: 										   int columnNumber, 
0: 										   boolean isNullOkay)
0: 		throws StandardException
0: 	{
0: 		if (operatorType != EQUALS_RELOP)
0: 			return false;
0: 
0: 		ColumnReference cr = getColumnOperand(optTable,
0: 											  columnNumber);
0: 		if (cr == null)
0: 			return false;
0: 
0: 		if (selfComparison(cr))
0: 			return false;
0: 		
0: 		if (implicitVarcharComparison())
0: 			return false;
0: 		
0: 		return true;
0: 	}
0: 	
0: 	/**
0: 	 * Return whether or not this binary relational predicate requires an implicit
0: 	 * (var)char conversion.  This is important when considering
0: 	 * hash join since this type of equality predicate is not currently
0: 	 * supported for a hash join.
0: 	 *
0: 	 * @return	Whether or not an implicit (var)char conversion is required for
0: 	 *			this binary relational operator.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	private boolean implicitVarcharComparison()
0: 		throws StandardException
0: 	{
0: 		TypeId leftType = leftOperand.getTypeId();
0: 		TypeId rightType = rightOperand.getTypeId();
0: 		
0: 		if (leftType.isStringTypeId() && !rightType.isStringTypeId())
0: 			return true;
0: 
0: 		if (rightType.isStringTypeId() && (!leftType.isStringTypeId()))
0: 			return true;
0: 
0: 		return false;
0: 	}
0: 	
0: 	/* @see BinaryOperatorNode#genSQLJavaSQLTree
0: 	 * @see BinaryComparisonOperatorNode#genSQLJavaSQLTree
0: 	 */
0: 	public ValueNode genSQLJavaSQLTree() throws StandardException
0: 	{
0: 		if (operatorType == EQUALS_RELOP)
0: 			return this;
0: 		
0: 		return super.genSQLJavaSQLTree();
0: 	}
0: }	
0: 
0: 
============================================================================