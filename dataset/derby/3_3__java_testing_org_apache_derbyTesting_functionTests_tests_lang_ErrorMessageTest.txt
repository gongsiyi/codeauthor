1:7c88053: /*
1:7c88053:  * Class org.apache.derbyTesting.functionTests.tests.lang.ErrorMessageTest
1:7c88053:  *
1:7c88053:  * Licensed to the Apache Software Foundation (ASF) under one
1:7c88053:  * or more contributor license agreements.  See the NOTICE file
1:7c88053:  * distributed with this work for additional information
1:7c88053:  * regarding copyright ownership.  The ASF licenses this file
1:7c88053:  * to you under the Apache License, Version 2.0 (the
1:7c88053:  * "License"); you may not use this file except in compliance
1:7c88053:  * with the License.  You may obtain a copy of the License at
1:7c88053:  *
1:7c88053:  *   http://www.apache.org/licenses/LICENSE-2.0
1:7c88053:  *
1:7c88053:  * Unless required by applicable law or agreed to in writing,
1:7c88053:  * software distributed under the License is distributed on an
1:7c88053:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:7c88053:  * KIND, either express or implied.  See the License for the
1:7c88053:  * specific language governing permissions and limitations
1:7c88053:  * under the License.
1:7c88053:  */
1:7c88053: 
1:7c88053: package org.apache.derbyTesting.functionTests.tests.lang;
1:7c88053: 
1:7c88053: import java.sql.Connection;
1:d34116d: import java.sql.PreparedStatement;
1:7c88053: import java.sql.SQLException;
1:7c88053: import java.sql.Statement;
1:7c88053: import java.util.regex.Matcher;
1:7c88053: import java.util.regex.Pattern;
1:7c88053: import junit.framework.Test;
1:d34116d: import org.apache.derbyTesting.functionTests.util.Barrier;
1:7c88053: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:7c88053: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:7c88053: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:7c88053: import org.apache.derbyTesting.junit.JDBC;
1:7c88053: 
1:7c88053: public class ErrorMessageTest extends BaseJDBCTestCase {
1:7c88053:     public ErrorMessageTest(String name) {
1:7c88053:         super(name);
1:7c88053:     }
1:7c88053: 
1:7c88053:     /**
1:7c88053:      * Create a test suite with all the tests in this class. The tests are only
1:7c88053:      * run in embedded mode since they test the messages generated by the
1:7c88053:      * embedded driver.
1:7c88053:      */
1:7c88053:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ErrorMessageTest");
1:7c88053: 
1:7c88053:         if (JDBC.vmSupportsJSR169()) {
1:7c88053:             // Foundation 1.1 doesn't support the regex classes. Return an
1:7c88053:             // empty test suite.
1:083db50:             return suite;
1:7c88053:         }
1:7c88053: 
1:083db50:         // Set a short wait timeout so that the expected timeout exception
1:083db50:         // is thrown faster.
1:083db50:         suite.addTest(DatabasePropertyTestSetup.setLockTimeouts(
1:083db50:                 new ErrorMessageTest("testWaitTimeout"), 1, 2));
1:083db50: 
1:083db50:         // Set a short deadlock timeout so that the expected deadlock is
1:083db50:         // found faster. Keep the lock timeout high to prevent false lock
1:083db50:         // timeouts from being reported because the deadlock detector cannot
1:083db50:         // resolve the deadlock fast enough (DERBY-6001).
1:083db50:         suite.addTest(DatabasePropertyTestSetup.setLockTimeouts(
1:083db50:                 new ErrorMessageTest("testDeadlockTimeout"), 1, 60));
1:083db50: 
1:083db50:         // testWaitTimeout wants more detailed error messages on timeout.
1:083db50:         Test test = DatabasePropertyTestSetup.singleProperty(
1:083db50:                 suite, "derby.locks.deadlockTrace", "true");
1:083db50: 
1:7c88053:         // create some data to work on
1:083db50:         return new CleanDatabaseTestSetup(test) {
1:7c88053:             protected void decorateSQL(Statement s) throws SQLException {
1:7c88053:                 s.executeUpdate("create table t (id int primary key, " +
1:7c88053:                                 "text varchar(10))");
1:7c88053:                 s.executeUpdate("insert into t (id) values 1, 2");
1:7c88053:             }
1:7c88053:         };
1:7c88053:     }
1:7c88053: 
1:7c88053:     /**
1:7c88053:      * Test that a wait timeout prints the lock table correctly when the
1:7c88053:      * <code>derby.locks.deadlockTrace</code> property is set. DERBY-2817
1:c9ef166:      *
1:c9ef166:      * After fix for DERBY-5564, the sql state for a lock timeout will be
1:c9ef166:      * the same whether diagnostics are on or not (ie. 40XL1).  
1:7c88053:      */
1:7c88053:     public void testWaitTimeout() throws SQLException {
2:7c88053:         getConnection().setAutoCommit(false);
1:7c88053:         Statement s = createStatement();
1:7c88053:         assertUpdateCount(s, 1, "update t set text='xxx' where id=1");
1:7c88053:         Connection c2 = openDefaultConnection();
1:7c88053:         Statement s2 = c2.createStatement();
1:7c88053:         try {
1:7c88053:             // the first transaction has locked row with id=1, so this query
1:7c88053:             // will time out
3:7c88053:             JDBC.assertDrainResults(
2:7c88053:                     s2.executeQuery("select * from t where id=1"));
1:7c88053:             fail("Expected lock timeout");
1:7c88053:         } catch (SQLException e) {
1:c9ef166:             assertSQLState("Not a timeout", "40XL1", e);
1:7c88053: 
1:7c88053:             // check that information about the victim is printed
1:7c88053:             String[] msg = e.getMessage().split("\n");
1:7c88053:             assertEquals("*** The following row is the victim ***", msg[4]);
1:7c88053:             assertEquals("*** The above row is the victim ***", msg[6]);
1:7c88053:             String[] victim = msg[5].split(" *\\|");
1:7c88053:             assertTrue("Invalid XID string: " + victim[0],
1:7c88053:                        victim[0].matches("\\d+"));
1:7c88053:             assertEquals("Victim should be a row lock", "ROW", victim[1]);
1:7c88053:             assertEquals("Victim should be a shared lock", "S", victim[2]);
1:7c88053:             assertEquals("Victim should be waiting", "WAIT", victim[5]);
1:7c88053: 
1:7c88053:             // check that the rest of the lock table is dumped
1:7c88053:             boolean locksDumped = false;
1:7c88053:             for (int i = 7; i < msg.length - 1; i++) {
1:7c88053:                 String[] tokens = msg[i].split(" *\\|");
1:7c88053:                 assertTrue("Invalid XID string: " + tokens[0],
1:7c88053:                            tokens[0].matches("\\d+"));
1:7c88053:                 assertTrue("Unexpected lock type: " + tokens[1],
1:7c88053:                            tokens[1].matches("ROW|TABLE"));
1:7c88053:                 assertTrue("Unexpected lock mode: " + tokens[2],
1:7c88053:                            tokens[2].matches("S|X|IX|IS"));
1:7c88053:                 assertEquals("Expected lock to be granted", "GRANT", tokens[5]);
1:7c88053:                 locksDumped = true;
1:7c88053:             }
1:7c88053:             assertTrue("No locks dumped", locksDumped);
1:7c88053:         }
1:7c88053:         s.close();
1:7c88053:         s2.close();
1:7c88053:         c2.close();
1:7c88053:     }
1:7c88053: 
1:7c88053:     /**
1:7c88053:      * Test that the error message from a deadlock timeout contains information
1:7c88053:      * about the locks involved in the deadlock. DERBY-2817
1:7c88053:      */
1:7c88053:     public void testDeadlockTimeout()
1:7c88053:             throws SQLException, InterruptedException {
1:d34116d:         setAutoCommit(false);
1:d34116d: 
1:d34116d:         // Make the main transaction (T1) lock row 1 exclusively
1:7c88053:         Statement s = createStatement();
1:7c88053:         assertUpdateCount(s, 1, "update t set text='xxx' where id=1");
1:7c88053: 
1:d34116d:         // Start another transaction (T2) that locks row 2 exclusively
1:7c88053:         Connection c2 = openDefaultConnection();
1:7c88053:         c2.setAutoCommit(false);
1:d34116d:         Statement s2 = c2.createStatement();
1:7c88053:         assertUpdateCount(s2, 1, "update t set text='yyy' where id=2");
1:d34116d: 
1:d34116d:         // Prepare statements for T1 to lock row 2 (shared), and for T2 to
1:d34116d:         // lock row 1 (shared).
1:d34116d:         PreparedStatement ps1 = prepareStatement("select * from t where id=2");
1:d34116d:         final PreparedStatement ps2 =
1:d34116d:                 c2.prepareStatement("select * from t where id=1");
1:d34116d: 
1:d34116d:         // Create a barrier for the two threads to synchronize.
1:d34116d:         final Barrier barrier = new Barrier(2);
1:d34116d: 
1:7c88053:         final SQLException[] holder = new SQLException[2];
1:d34116d:         final Throwable[] unexpected = new Throwable[1];
1:7c88053:         Thread t = new Thread(new Runnable() {
1:7c88053:                 public void run() {
1:7c88053:                     try {
1:d34116d:                         // Let the main thread know the helper thread has
1:d34116d:                         // started. The race for the locks can start.
1:d34116d:                         barrier.await();
1:d34116d: 
1:d34116d:                         // This statement will be blocked because T1 holds
1:d34116d:                         // an exclusive lock on the row we want.
1:d34116d:                         JDBC.assertDrainResults(ps2.executeQuery());
1:7c88053:                     } catch (SQLException e) {
1:7c88053:                         holder[0] = e;
1:d34116d:                     } catch (Throwable t) {
1:d34116d:                         unexpected[0] = t;
1:7c88053:                     }
1:7c88053:                 }
1:7c88053:             });
1:7c88053:         t.start();
1:7c88053: 
1:d34116d:         // Wait until the helper thread has started. Once the call returns,
1:d34116d:         // both threads are ready, and the race for the locks can start.
1:d34116d:         barrier.await();
1:d34116d: 
1:d34116d:         // This statement will be blocked because T2 holds an exclusive lock
1:d34116d:         // on the row we want. So now we have T1 waiting for T2, and T2 waiting
1:d34116d:         // for T1, and one of the transactions should be terminated because of
1:d34116d:         // the deadlock.
1:7c88053:         try {
1:d34116d:             JDBC.assertDrainResults(ps1.executeQuery());
1:7c88053:         } catch (SQLException e) {
1:7c88053:             holder[1] = e;
1:7c88053:         }
1:7c88053: 
1:d34116d:         // Wait for the helper thread to complete.
1:7c88053:         t.join();
1:7c88053: 
1:d34116d:         // If the helper thread failed with something other than an
1:d34116d:         // SQLException, report it.
1:d34116d:         if (unexpected[0] != null) {
1:d34116d:             fail("Helper thread failed unexpectedly", unexpected[0]);
1:d34116d:         }
1:d34116d: 
1:d34116d:         // Check that exactly one of the threads failed, and that the failure
1:d34116d:         // was caused by a deadlock. It is not deterministic which of the two
1:d34116d:         // threads will be terminated.
1:8467ac5:         assertFalse("No deadlock", holder[0] == null && holder[1] == null);
1:8467ac5:         if (holder[0] != null && holder[1] != null) {
1:8467ac5:             // Both threads failed. Print some more information to the log
1:8467ac5:             // so we can see what's going on.
1:8467ac5:             printStackTrace(holder[0]);
1:8467ac5:             printStackTrace(holder[1]);
1:8467ac5:             fail("Only one of the waiters should be aborted");
1:7c88053:         }
1:7c88053: 
1:8467ac5:         SQLException deadlock = holder[0] == null ? holder[1] : holder[0];
1:8467ac5:         assertSQLState("Not a deadlock", "40001", deadlock);
1:8467ac5: 
1:8467ac5:         String[] lines = deadlock.getMessage().split("\n");
1:7c88053:         assertEquals("Unexpected number of lines in message", 8, lines.length);
1:7c88053: 
1:7c88053:         Pattern[] patterns = new Pattern[] {
1:7c88053:             Pattern.compile("Lock : ROW, T, \\(\\d+,\\d+\\)"),
1:7c88053:             Pattern.compile(" *Waiting XID : \\{\\d+, S\\} , APP, " +
1:7c88053:                             "select \\* from t where id=(1|2)"),
1:7c88053:             Pattern.compile(" *Granted XID : \\{\\d+, X\\} *"),
1:7c88053:         };
1:7c88053: 
1:7c88053:         // check the descriptions of the two locks involved in the deadlock
1:7c88053:         for (int i = 0; i < patterns.length * 2; i++) {
1:7c88053:             String line = lines[i+1];
1:7c88053:             Matcher m = patterns[i%patterns.length].matcher(line);
1:7c88053:             assertTrue("mismatch: " + line, m.matches());
1:7c88053:         }
1:7c88053: 
1:7c88053:         s.close();
1:7c88053:         s2.close();
1:7c88053:         c2.rollback();
1:7c88053:         c2.close();
1:7c88053:     }
1:7c88053: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ErrorMessageTest");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:083db50
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("ErrorMessageTest");
1:             return suite;
1:         // Set a short wait timeout so that the expected timeout exception
1:         // is thrown faster.
1:         suite.addTest(DatabasePropertyTestSetup.setLockTimeouts(
1:                 new ErrorMessageTest("testWaitTimeout"), 1, 2));
1: 
1:         // Set a short deadlock timeout so that the expected deadlock is
1:         // found faster. Keep the lock timeout high to prevent false lock
1:         // timeouts from being reported because the deadlock detector cannot
1:         // resolve the deadlock fast enough (DERBY-6001).
1:         suite.addTest(DatabasePropertyTestSetup.setLockTimeouts(
1:                 new ErrorMessageTest("testDeadlockTimeout"), 1, 60));
1: 
1:         // testWaitTimeout wants more detailed error messages on timeout.
1:         Test test = DatabasePropertyTestSetup.singleProperty(
1:                 suite, "derby.locks.deadlockTrace", "true");
1: 
1:         return new CleanDatabaseTestSetup(test) {
commit:8467ac5
/////////////////////////////////////////////////////////////////////////
1:         assertFalse("No deadlock", holder[0] == null && holder[1] == null);
1:         if (holder[0] != null && holder[1] != null) {
1:             // Both threads failed. Print some more information to the log
1:             // so we can see what's going on.
1:             printStackTrace(holder[0]);
1:             printStackTrace(holder[1]);
1:             fail("Only one of the waiters should be aborted");
1:         SQLException deadlock = holder[0] == null ? holder[1] : holder[0];
1:         assertSQLState("Not a deadlock", "40001", deadlock);
1: 
1:         String[] lines = deadlock.getMessage().split("\n");
commit:d34116d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.Barrier;
/////////////////////////////////////////////////////////////////////////
1:         setAutoCommit(false);
1: 
1:         // Make the main transaction (T1) lock row 1 exclusively
1:         // Start another transaction (T2) that locks row 2 exclusively
1:         Statement s2 = c2.createStatement();
1: 
1:         // Prepare statements for T1 to lock row 2 (shared), and for T2 to
1:         // lock row 1 (shared).
1:         PreparedStatement ps1 = prepareStatement("select * from t where id=2");
1:         final PreparedStatement ps2 =
1:                 c2.prepareStatement("select * from t where id=1");
1: 
1:         // Create a barrier for the two threads to synchronize.
1:         final Barrier barrier = new Barrier(2);
1: 
1:         final Throwable[] unexpected = new Throwable[1];
1:                         // Let the main thread know the helper thread has
1:                         // started. The race for the locks can start.
1:                         barrier.await();
1: 
1:                         // This statement will be blocked because T1 holds
1:                         // an exclusive lock on the row we want.
1:                         JDBC.assertDrainResults(ps2.executeQuery());
1:                     } catch (Throwable t) {
1:                         unexpected[0] = t;
1:         // Wait until the helper thread has started. Once the call returns,
1:         // both threads are ready, and the race for the locks can start.
1:         barrier.await();
1: 
1:         // This statement will be blocked because T2 holds an exclusive lock
1:         // on the row we want. So now we have T1 waiting for T2, and T2 waiting
1:         // for T1, and one of the transactions should be terminated because of
1:         // the deadlock.
1:             JDBC.assertDrainResults(ps1.executeQuery());
1:         // Wait for the helper thread to complete.
1:         // If the helper thread failed with something other than an
1:         // SQLException, report it.
1:         if (unexpected[0] != null) {
1:             fail("Helper thread failed unexpectedly", unexpected[0]);
1:         }
1: 
1:         // Check that exactly one of the threads failed, and that the failure
1:         // was caused by a deadlock. It is not deterministic which of the two
1:         // threads will be terminated.
commit:7c88053
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Class org.apache.derbyTesting.functionTests.tests.lang.ErrorMessageTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.sql.Statement;
0: import java.util.Properties;
1: import java.util.regex.Matcher;
1: import java.util.regex.Pattern;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: 
1: public class ErrorMessageTest extends BaseJDBCTestCase {
1:     public ErrorMessageTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Create a test suite with all the tests in this class. The tests are only
1:      * run in embedded mode since they test the messages generated by the
1:      * embedded driver.
1:      */
1:     public static Test suite() {
1: 
1:         if (JDBC.vmSupportsJSR169()) {
1:             // Foundation 1.1 doesn't support the regex classes. Return an
1:             // empty test suite.
0:             return new TestSuite("ErrorMessageTest");
1:         }
1: 
0:         Test test = new TestSuite(ErrorMessageTest.class, "ErrorMessageTest");
1:         // create some data to work on
0:         test = new CleanDatabaseTestSetup(test) {
1:             protected void decorateSQL(Statement s) throws SQLException {
1:                 s.executeUpdate("create table t (id int primary key, " +
1:                                 "text varchar(10))");
1:                 s.executeUpdate("insert into t (id) values 1, 2");
1:             }
1:         };
0:         Properties prop = new Properties();
0:         // set timeouts so that the tests finish sooner
0:         prop.setProperty("derby.locks.waitTimeout", "4");
0:         prop.setProperty("derby.locks.deadlockTimeout", "2");
0:         // make sure lock table is dumped on wait timeout
0:         prop.setProperty("derby.locks.deadlockTrace", "true");
0:         test = new DatabasePropertyTestSetup(test, prop);
0:         return test;
1:     }
1: 
1:     /**
1:      * Test that a wait timeout prints the lock table correctly when the
1:      * <code>derby.locks.deadlockTrace</code> property is set. DERBY-2817
1:      */
1:     public void testWaitTimeout() throws SQLException {
1:         getConnection().setAutoCommit(false);
1:         Statement s = createStatement();
1:         assertUpdateCount(s, 1, "update t set text='xxx' where id=1");
1:         Connection c2 = openDefaultConnection();
1:         Statement s2 = c2.createStatement();
1:         try {
1:             // the first transaction has locked row with id=1, so this query
1:             // will time out
1:             JDBC.assertDrainResults(
1:                     s2.executeQuery("select * from t where id=1"));
1:             fail("Expected lock timeout");
1:         } catch (SQLException e) {
0:             assertSQLState("Not a timeout", "40XL2", e);
1: 
1:             // check that information about the victim is printed
1:             String[] msg = e.getMessage().split("\n");
1:             assertEquals("*** The following row is the victim ***", msg[4]);
1:             assertEquals("*** The above row is the victim ***", msg[6]);
1:             String[] victim = msg[5].split(" *\\|");
1:             assertTrue("Invalid XID string: " + victim[0],
1:                        victim[0].matches("\\d+"));
1:             assertEquals("Victim should be a row lock", "ROW", victim[1]);
1:             assertEquals("Victim should be a shared lock", "S", victim[2]);
1:             assertEquals("Victim should be waiting", "WAIT", victim[5]);
1: 
1:             // check that the rest of the lock table is dumped
1:             boolean locksDumped = false;
1:             for (int i = 7; i < msg.length - 1; i++) {
1:                 String[] tokens = msg[i].split(" *\\|");
1:                 assertTrue("Invalid XID string: " + tokens[0],
1:                            tokens[0].matches("\\d+"));
1:                 assertTrue("Unexpected lock type: " + tokens[1],
1:                            tokens[1].matches("ROW|TABLE"));
1:                 assertTrue("Unexpected lock mode: " + tokens[2],
1:                            tokens[2].matches("S|X|IX|IS"));
1:                 assertEquals("Expected lock to be granted", "GRANT", tokens[5]);
1:                 locksDumped = true;
1:             }
1:             assertTrue("No locks dumped", locksDumped);
1:         }
1:         s.close();
1:         s2.close();
1:         c2.close();
1:     }
1: 
1:     /**
1:      * Test that the error message from a deadlock timeout contains information
1:      * about the locks involved in the deadlock. DERBY-2817
1:      */
1:     public void testDeadlockTimeout()
1:             throws SQLException, InterruptedException {
1:         getConnection().setAutoCommit(false);
1:         Statement s = createStatement();
1:         assertUpdateCount(s, 1, "update t set text='xxx' where id=1");
1: 
0:         // start another transaction that needs to wait for the first one
1:         Connection c2 = openDefaultConnection();
1:         c2.setAutoCommit(false);
0:         final Statement s2 = c2.createStatement();
1:         assertUpdateCount(s2, 1, "update t set text='yyy' where id=2");
1:         final SQLException[] holder = new SQLException[2];
1:         Thread t = new Thread(new Runnable() {
1:                 public void run() {
1:                     try {
0:                         // will wait since the other transaction has locked the
0:                         // row exclusively
1:                         JDBC.assertDrainResults(
1:                             s2.executeQuery("select * from t where id=1"));
1:                     } catch (SQLException e) {
1:                         holder[0] = e;
1:                     }
1:                 }
1:             });
1:         t.start();
1: 
0:         // Execute a query that needs to wait for c2 to finish. Now, c1 is
0:         // waiting for c2, and c2 is waiting for c1.
1:         try {
1:             JDBC.assertDrainResults(
0:                 s.executeQuery("select * from t where id=2"));
1:         } catch (SQLException e) {
1:             holder[1] = e;
1:         }
1: 
1:         t.join();
1: 
0:         String msg;
0:         // check that only one of the transactions failed
0:         if (holder[0] != null) {
0:             assertSQLState("Not a deadlock", "40001", holder[0]);
0:             assertNull("Only one of the waiters should be aborted", holder[1]);
0:             msg = holder[0].getMessage();
0:         } else {
0:             assertSQLState("Not a deadlock", "40001", holder[1]);
0:             msg = holder[1].getMessage();
1:         }
1: 
0:         String[] lines = msg.split("\n");
1:         assertEquals("Unexpected number of lines in message", 8, lines.length);
1: 
1:         Pattern[] patterns = new Pattern[] {
1:             Pattern.compile("Lock : ROW, T, \\(\\d+,\\d+\\)"),
1:             Pattern.compile(" *Waiting XID : \\{\\d+, S\\} , APP, " +
1:                             "select \\* from t where id=(1|2)"),
1:             Pattern.compile(" *Granted XID : \\{\\d+, X\\} *"),
1:         };
1: 
1:         // check the descriptions of the two locks involved in the deadlock
1:         for (int i = 0; i < patterns.length * 2; i++) {
1:             String line = lines[i+1];
1:             Matcher m = patterns[i%patterns.length].matcher(line);
1:             assertTrue("mismatch: " + line, m.matches());
1:         }
1: 
1:         s.close();
1:         s2.close();
1:         c2.rollback();
1:         c2.close();
1:     }
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c9ef166
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * After fix for DERBY-5564, the sql state for a lock timeout will be
1:      * the same whether diagnostics are on or not (ie. 40XL1).  
/////////////////////////////////////////////////////////////////////////
1:             assertSQLState("Not a timeout", "40XL1", e);
============================================================================