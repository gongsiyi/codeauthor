1:b8d1d8a: /*
13:b8d1d8a:  
1:b8d1d8a:  Derby - Class org.apache.derbyTesting.system.nstest.utils.DbUtil
1:b8d1d8a:  
1:b8d1d8a:  Licensed to the Apache Software Foundation (ASF) under one or more
1:b8d1d8a:  contributor license agreements.  See the NOTICE file distributed with
1:b8d1d8a:  this work for additional information regarding copyright ownership.
1:b8d1d8a:  The ASF licenses this file to You under the Apache License, Version 2.0
1:b8d1d8a:  (the "License"); you may not use this file except in compliance with
1:b8d1d8a:  the License.  You may obtain a copy of the License at
1:b8d1d8a:  
1:b8d1d8a:  http://www.apache.org/licenses/LICENSE-2.0
1:b8d1d8a:  
1:b8d1d8a:  Unless required by applicable law or agreed to in writing, software
1:b8d1d8a:  distributed under the License is distributed on an "AS IS" BASIS,
1:b8d1d8a:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:b8d1d8a:  See the License for the specific language governing permissions and
1:b8d1d8a:  limitations under the License.
1:b8d1d8a:  
1:b8d1d8a:  */
1:b8d1d8a: 
1:b8d1d8a: package org.apache.derbyTesting.system.nstest.utils;
1:b8d1d8a: 
1:b8d1d8a: import java.sql.Connection;
1:b8d1d8a: import java.sql.Date;
1:b8d1d8a: import java.sql.PreparedStatement;
1:b8d1d8a: import java.sql.SQLException;
1:b8d1d8a: import java.sql.Time;
1:b8d1d8a: import java.sql.Timestamp;
1:b8d1d8a: import java.util.Random;
1:b8d1d8a: 
1:b8d1d8a: import org.apache.derbyTesting.system.nstest.NsTest;
1:b8d1d8a: 
1:b8d1d8a: /**
1:b8d1d8a:  * DbUtil - a database utility class for all IUD and Select operations
1:b8d1d8a:  */
1:b8d1d8a: public class DbUtil {
1:b8d1d8a: 	private String threadName = "";
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TCHAR = 0;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TDATE = 1;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TDECIMAL = 2;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TDECIMALNN = 3;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TDOUBLE = 4;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TFLOAT = 5;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TINT = 6;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TLONGINT = 7;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TNUMERICLARGE = 8;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TREAL = 9;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TSMALLINT = 10;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TTIME = 11;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TTIMESTAMP = 12;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int TVARCHAR = 13;
1:b8d1d8a: 	
1:b8d1d8a: 	public static final int NUMTYPES = 14;
1:b8d1d8a: 	
1:b8d1d8a: 	public static String[] colnames = { "t_char", "t_date", "t_decimal",
1:b8d1d8a: 		"t_decimal_nn", "t_double", "t_float", "t_int", "t_longint",
1:b8d1d8a: 		"t_numeric_large", "t_real", "t_smallint", "t_time", "t_timestamp",
1:b8d1d8a: 	"t_varchar" };
1:b8d1d8a: 	
1:b8d1d8a: 	public DbUtil(String thName) {
1:b8d1d8a: 		threadName = thName;
1:23e8c92: 	}
1:3d7c2ea: 	
1:b8d1d8a: 	/*
1:b8d1d8a: 	 * Add a row for each iteration
1:b8d1d8a: 	 */
1:b8d1d8a: 	
1:b8d1d8a: 	public int add_one_row(Connection conn, String thread_id) throws Exception {
1:b8d1d8a: 		
2:b8d1d8a: 		PreparedStatement ps = null;
1:b8d1d8a: 		int rowsAdded = 0;
1:b8d1d8a: 		
7:b8d1d8a: 		try {
1:b8d1d8a: 			// autoincrement feature added, so we need to specify the column
1:e276048: 			// name for prepared statement, otherwise auto increment column
1:e276048: 			// will think it is trying to update/insert a null value to the
1:e276048: 			// column.
1:b8d1d8a: 			
2:b8d1d8a: 			ps = conn
1:b8d1d8a: 			.prepareStatement(" insert into nstesttab (id, t_char,"
1:b8d1d8a: 					+ " t_date, t_decimal, t_decimal_nn, t_double, "
1:b8d1d8a: 					+ " t_float, t_int, t_longint, t_numeric_large,"
1:b8d1d8a: 					+ " t_real, t_smallint, t_time, t_timestamp,"
1:b13fb1c: 					+ " t_varchar,t_clob,t_blob,sequenceColumn) values ("
1:b13fb1c: 					+ " ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,cast('00000000000000000000000000000000031' as clob(1K)),cast(X'000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000031' as blob(10K)), next value for nstesttab_seq)");
1:b8d1d8a: 			
1:b8d1d8a: 			Random rand = new Random();
1:b8d1d8a: 			
1:b8d1d8a: 			int ind = rand.nextInt();
1:b8d1d8a: 			int id_ind = ind;
1:b8d1d8a: 			
1:b8d1d8a: 			Date dt = new Date(1);
1:b8d1d8a: 			Time tt = new Time(1);
1:b8d1d8a: 			Timestamp ts = new Timestamp(1);
1:b8d1d8a: 			String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
1:b8d1d8a: 			
1:b8d1d8a: 			// Integer ji = null;
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "id"
1:b8d1d8a: 			ps.setInt(1, ind);
1:c043274: 			// NsTest.logger.println("set int col 1 to " + ind);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_char"
1:b8d1d8a: 			// scramble the string
1:b8d1d8a: 			int i1 = Math.abs(ind % 100);
1:b8d1d8a: 			String cs2 = cs.substring(i1, 99) + cs.substring(0, i1);
1:b8d1d8a: 			int i2 = i1 < 89 ? i1 + 10 : i1;
1:b8d1d8a: 			ps.setString(2, cs2.substring(0, i2));
1:c043274: 			// NsTest.logger.println("set t_Char to " + cs2.substring(0,i2));
1:b8d1d8a: 			
1:c043274: 			// NsTest.logger.println("now setting date");
1:b8d1d8a: 			// Set value of column "t_date"
1:b8d1d8a: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
1:b8d1d8a: 			ps.setDate(3, dt);
1:c043274: 			// NsTest.logger.println("set t_date to " + dt.toString());
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_decimal"
1:b8d1d8a: 			double t_dec = rand.nextDouble()
1:b8d1d8a: 			* Math.pow(10, Math.abs(rand.nextInt() % 6));
1:b8d1d8a: 			ps.setDouble(4, t_dec);
1:c043274: 			// NsTest.logger.println("set t_decimal to "+ t_dec);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_decimal_nn"
1:b8d1d8a: 			double t_dec_nn = rand.nextDouble();
1:b8d1d8a: 			ps.setDouble(5, t_dec_nn);
1:c043274: 			// NsTest.logger.println("set t_decimal_nn " + t_dec_nn);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_double"
1:b8d1d8a: 			double t_doub = rand.nextDouble()
1:b8d1d8a: 			* Math.pow(10, Math.abs(rand.nextInt() % 300));
1:b8d1d8a: 			ps.setDouble(6, t_doub);
1:c043274: 			// NsTest.logger.println("set t_double to "+ t_doub);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_float"
1:b8d1d8a: 			float t_flt = rand.nextFloat()
1:b8d1d8a: 			* (float) Math.pow(10, Math.abs(rand.nextInt() % 30));
1:b8d1d8a: 			ps.setFloat(7, t_flt);
1:c043274: 			// NsTest.logger.println("set t_float to " + t_flt);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_int"
1:b8d1d8a: 			int t_intval = rand.nextInt();
1:b8d1d8a: 			ps.setInt(8, t_intval);
1:c043274: 			// NsTest.logger.println("set t_int to " + t_intval);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_longint"
1:b8d1d8a: 			long t_longval = rand.nextLong();
1:b8d1d8a: 			ps.setLong(9, t_longval);
1:c043274: 			// NsTest.logger.println("set t_longint " + t_longval);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_numeric_large"
1:b8d1d8a: 			double t_num_lrg = rand.nextDouble()
1:b8d1d8a: 			* Math.pow(10, Math.abs(rand.nextInt() % 20));
1:b8d1d8a: 			ps.setDouble(10, t_num_lrg);
1:c043274: 			// NsTest.logger.println("set t_numeric large to " + t_num_lrg);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_real"
1:b8d1d8a: 			float t_fltval = rand.nextFloat()
1:b8d1d8a: 			* (float) Math.pow(10, Math.abs(rand.nextInt() % 7));
1:b8d1d8a: 			ps.setFloat(11, t_fltval);
1:c043274: 			// NsTest.logger.println("set t_real to " + t_fltval);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_smallint"
1:b8d1d8a: 			int t_smlint = rand.nextInt() % (256 * 128);
1:b8d1d8a: 			ps.setInt(12, t_smlint);
1:c043274: 			// NsTest.logger.println("set t_smallint to " + t_smlint);
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_time"
1:b8d1d8a: 			tt.setTime(Math.abs(rand.nextInt()));
1:b8d1d8a: 			ps.setTime(13, tt);
1:c043274: 			// NsTest.logger.println("set t_time to " + tt.toString());
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_timestamp"
1:b8d1d8a: 			ts.setTime(Math.abs(rand.nextLong() / 50000));
1:b8d1d8a: 			ps.setTimestamp(14, ts);
1:c043274: 			// NsTest.logger.println("set t_timestamp to " + ts.toString());
1:b8d1d8a: 			
1:b8d1d8a: 			// Set value of column "t_varchar"
1:b8d1d8a: 			ps.setString(15, cs.substring(Math.abs(rand.nextInt() % 100)));
1:c043274: 			// NsTest.logger.println("set t_varchar, now executing update stmt");
1:b8d1d8a: 			try {
1:b8d1d8a: 				rowsAdded = ps.executeUpdate();
2:b8d1d8a: 			} catch (SQLException sqe) {
1:b13fb1c:                 if ( NsTest.justCountErrors() )
1:b13fb1c:                 {
1:b13fb1c:                     NsTest.addError( sqe );
1:b13fb1c:                 }
1:b13fb1c:                 else
1:b13fb1c:                 {
1:b13fb1c:                     if (sqe.getSQLState().equalsIgnoreCase("40XL1")) {
1:b13fb1c:                         NsTest.logger
1:b13fb1c:                             .println("LOCK TIMEOUT obtained during insert - add_one_row() "
1:b13fb1c:                                      + sqe.getSQLState());
1:b13fb1c:                     }
1:b13fb1c:                     else if (sqe.getSQLState().equalsIgnoreCase("23505")) {
1:b13fb1c:                         NsTest.logger
1:b13fb1c:                             .println("prevented duplicate row - add_one_row(): "
1:b13fb1c:                                      + sqe.getSQLState() + "; " + sqe.getMessage());
1:23e8c92: 
1:b13fb1c:                     } else {
1:b13fb1c:                         throw sqe;
1:b13fb1c:                     }
1:b13fb1c:                 }
1:b8d1d8a: 				
15:b8d1d8a: 			}
1:b8d1d8a: 			if (rowsAdded == 1) {
1:c043274: 				NsTest.logger.println(thread_id + " inserted 1 row with id "
1:e276048: 						//+ id_ind + NsTest.SUCCESS);
1:e276048:                         + id_ind);
1:b8d1d8a: 			} else
1:c043274: 				NsTest.logger.println("FAIL: " + thread_id + " inserted " + rowsAdded + "rows");
1:b8d1d8a: 			
6:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			NsTest.logger
1:b8d1d8a: 			.println("Exception when preparing or executing insert prepared stmt");
1:b8d1d8a: 			printException("executing/preparing insert stmt in dbUtil", e);
1:c043274: 			e.printStackTrace( NsTest.logger );
1:b8d1d8a: 			// ps.close();
1:b8d1d8a: 		}
1:3d7c2ea: 		
1:b8d1d8a: 	
1:b8d1d8a: 		return rowsAdded;
1:b8d1d8a: 	}
1:b8d1d8a: 	
1:b8d1d8a: 	/*
1:b8d1d8a: 	 * Update a random row. This method is common to all the worker threads
1:b8d1d8a: 	 */
1:b8d1d8a: 	
1:b8d1d8a: 	public int update_one_row(Connection conn, String thread_id)
1:b8d1d8a: 	throws Exception {
1:b8d1d8a: 		
1:b8d1d8a: 		PreparedStatement ps2 = null;
1:b8d1d8a: 		String column = null;
1:b8d1d8a: 		int ind = 0;
1:b8d1d8a: 		Random rand = new Random();
1:b8d1d8a: 		int rowsUpdated = 0;
1:b8d1d8a: 		conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:b8d1d8a: 		long skey = pick_one(conn, thread_id);
1:b8d1d8a: 		if (skey == 0) { // means we did not find a row
1:c043274: 			NsTest.logger.println(thread_id
1:b8d1d8a: 					+ " could not find a row to update or there was an error.");
1:b8d1d8a: 			return rowsUpdated;
1:b8d1d8a: 		}
1:b8d1d8a: 		
1:b8d1d8a: 		ind = Math.abs(rand.nextInt());
1:b8d1d8a: 		
1:b8d1d8a: 		column = colnames[ind % NUMTYPES]; // randomly gets one of the columns
1:b8d1d8a: 		// of the table
1:b8d1d8a: 		
1:b8d1d8a: 		try {
1:b8d1d8a: 			
1:b8d1d8a: 			ps2 = conn.prepareStatement(" update nstesttab set " + column
1:b8d1d8a: 					+ " = ? " + " where serialkey = " + skey);
1:b8d1d8a: 			
1:b8d1d8a: 		} catch (Exception e) {
3:b8d1d8a: 			printException(
1:b8d1d8a: 					"closing update prepared stmt in dbUtil.update_one_row() ",
4:b8d1d8a: 					e);
1:b8d1d8a: 			return rowsUpdated;
1:b8d1d8a: 		}
1:b8d1d8a: 		
1:b8d1d8a: 		String ds2 = null;
1:b8d1d8a: 		String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
1:b8d1d8a: 		double d = 0.0;
1:b8d1d8a: 		float f = 0;
1:b8d1d8a: 		int type = (ind % NUMTYPES);
1:b8d1d8a: 		
1:b8d1d8a: 		switch (type) {
1:b8d1d8a: 		
1:b8d1d8a: 		case TCHAR:
1:b8d1d8a: 			ds2 = cs.substring(Math.abs(rand.nextInt() % 100));
1:b8d1d8a: 			ps2.setString(1, ds2);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TDATE:
1:b8d1d8a: 			Date dt = new Date(1);
1:b8d1d8a: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
1:b8d1d8a: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
1:b8d1d8a: 			ps2.setDate(1, dt);
1:b8d1d8a: 			ds2 = dt.toString();
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TDECIMAL:
1:e276048: 			d = rand.nextDouble() * Math.pow(10, Math.abs(rand.nextInt() % 6));
1:b8d1d8a: 			ps2.setDouble(1, d);
1:b8d1d8a: 			ds2 = String.valueOf(d);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TDECIMALNN:
1:b8d1d8a: 			d = rand.nextDouble();
1:b8d1d8a: 			ps2.setDouble(1, d);
1:b8d1d8a: 			ds2 = String.valueOf(d);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TDOUBLE:
1:b8d1d8a: 			d = rand.nextDouble() * Math.pow(10, rand.nextInt() % 300);
1:b8d1d8a: 			ps2.setDouble(1, d);
1:b8d1d8a: 			ds2 = String.valueOf(d);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TFLOAT:
1:b8d1d8a: 			f = rand.nextFloat() * (float) Math.pow(10, rand.nextInt() % 30);
1:b8d1d8a: 			ps2.setFloat(1, f);
1:b8d1d8a: 			ds2 = String.valueOf(f);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TINT:
1:b8d1d8a: 			int i = rand.nextInt();
1:b8d1d8a: 			ds2 = String.valueOf(i);
1:b8d1d8a: 			ps2.setInt(1, i);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TLONGINT:
1:b8d1d8a: 			long l = rand.nextLong();
1:b8d1d8a: 			ds2 = String.valueOf(l);
1:b8d1d8a: 			ps2.setLong(1, l);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TNUMERICLARGE:
1:b8d1d8a: 			d = rand.nextDouble() * Math.pow(10, rand.nextInt() % 20);
1:b8d1d8a: 			ps2.setDouble(1, d);
1:b8d1d8a: 			ds2 = String.valueOf(d);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TREAL:
1:b8d1d8a: 			f = rand.nextFloat() * (float) Math.pow(10, rand.nextInt() % 7);
1:b8d1d8a: 			ps2.setFloat(1, f);
1:b8d1d8a: 			ds2 = String.valueOf(f);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TSMALLINT:
1:b8d1d8a: 			i = rand.nextInt() % (256 * 128);
1:b8d1d8a: 			short si = (short) i;
1:b8d1d8a: 			ps2.setShort(1, si);
1:b8d1d8a: 			ds2 = String.valueOf(si);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TTIME:
1:b8d1d8a: 			Time tt = new Time(1);
1:b8d1d8a: 			tt.setTime(Math.abs(rand.nextInt()));
1:b8d1d8a: 			ps2.setTime(1, tt);
1:b8d1d8a: 			ds2 = tt.toString();
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TTIMESTAMP:
1:b8d1d8a: 			Timestamp ts = new Timestamp(1);
1:b8d1d8a: 			ts.setTime(Math.abs(rand.nextLong() / 50000));
1:b8d1d8a: 			ps2.setTimestamp(1, ts);
1:b8d1d8a: 			ds2 = ts.toString();
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		case TVARCHAR:
1:b8d1d8a: 			ds2 = cs.substring(Math.abs(rand.nextInt() % 100));
1:b8d1d8a: 			ps2.setString(1, ds2);
1:b8d1d8a: 			break;
1:b8d1d8a: 			
1:b8d1d8a: 		} // end of switch(type)
1:b8d1d8a: 		
1:c043274: 		//NsTest.logger.println(thread_id + " attempting  to update col " + column
1:e276048: 		//		+ " to " + ds2);
1:b8d1d8a: 		try {
1:b8d1d8a: 			rowsUpdated = ps2.executeUpdate();
1:b8d1d8a: 		} catch (SQLException sqe) {
1:c043274: 			NsTest.logger.println(sqe.getSQLState() + " " + sqe.getErrorCode()
1:b8d1d8a: 					+ " " + sqe.getMessage());
1:c043274: 			if ( NsTest.justCountErrors() ) { NsTest.printException( DbUtil.class.getName(), sqe ); }
1:c043274: 			else { sqe.printStackTrace( NsTest.logger ); }
1:b8d1d8a: 		} catch (Exception e) {
1:b8d1d8a: 			printException("Error in update_one_row()", e);
1:c043274: 			e.printStackTrace( NsTest.logger );
1:b8d1d8a: 		} finally {
1:b8d1d8a: 			conn
1:b8d1d8a: 			.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:b8d1d8a: 		}
1:b8d1d8a: 		
1:b8d1d8a: 		if (rowsUpdated > 0)
1:c043274: 			NsTest.logger.println(thread_id + " updated " + rowsUpdated
1:b8d1d8a: 					+ " row with serialkey " + skey + NsTest.SUCCESS);
1:b8d1d8a: 		else
1:c043274: 			NsTest.logger
1:b8d1d8a: 			.println(thread_id + " update failed, no such row exists");
1:3d7c2ea: 		
1:b8d1d8a: 	
1:b8d1d8a: 		return rowsUpdated;
1:b8d1d8a: 	}
1:b8d1d8a: 	
1:b8d1d8a: 	//
1:b8d1d8a: 	// Delete one row from the table. The row to be deleted is chosen randomly
1:b8d1d8a: 	// using the
1:b8d1d8a: 	// pick_one method which randomly returns a number between the max of
1:b8d1d8a: 	// serialkey and
1:b8d1d8a: 	// the minimum serialkey value that is untouched (nstest.NUM_UNTOUCHED_ROWS)
1:b8d1d8a: 	//
1:b8d1d8a: 	public int delete_one_row(Connection conn, String thread_id)
1:b8d1d8a: 	throws Exception {
1:b8d1d8a: 		
1:b8d1d8a: 		PreparedStatement ps = null;
1:b8d1d8a: 		int rowsDeleted = 0;
1:b8d1d8a: 		conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1:b8d1d8a: 		try {
1:b8d1d8a: 			
1:b8d1d8a: 			ps = conn
1:b8d1d8a: 			.prepareStatement(" delete from nstesttab where serialkey = ?");
1:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			NsTest.logger
1:b8d1d8a: 			.println("Unexpected error preparing the statement in delete_one()");
1:b8d1d8a: 			printException("delete_one_row prepare ", e);
1:b8d1d8a: 			return rowsDeleted;
1:b8d1d8a: 		}
1:b8d1d8a: 		
1:b8d1d8a: 		long skey = pick_one(conn, thread_id);
1:c043274: 		//NsTest.logger.println(thread_id
1:e276048: 		//		+ " attempting  to delete a row with serialkey = " + skey);
1:b8d1d8a: 		if (skey == 0) { // means we did not find a row
1:c043274: 			NsTest.logger.println(thread_id
1:b8d1d8a: 					+ " could not find a row to delete or there was an error.");
1:b8d1d8a: 			return rowsDeleted;
1:b8d1d8a: 		}
1:b8d1d8a: 		
1:b8d1d8a: 		try {
1:b8d1d8a: 			ps.setLong(1, skey);
1:b8d1d8a: 			rowsDeleted = ps.executeUpdate();
1:b8d1d8a: 		} catch (Exception e) {
1:c043274: 			NsTest.logger
1:b8d1d8a: 			.println("Error in delete_one(): either with setLong() or executeUpdate");
1:b8d1d8a: 			printException("failure to execute delete stmt", e);
1:b8d1d8a: 		} finally {
1:b8d1d8a: 			conn
1:b8d1d8a: 			.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1:b8d1d8a: 			// set it back to read uncommitted
1:b8d1d8a: 		}
1:b8d1d8a: 		
1:b8d1d8a: 		if (rowsDeleted > 0)
1:c043274: 			NsTest.logger.println(thread_id + " deleted row with serialkey "
1:b8d1d8a: 					+ skey + NsTest.SUCCESS);
1:b8d1d8a: 		else
1:c043274: 			NsTest.logger.println(thread_id + " delete for serialkey " + skey
1:b8d1d8a: 					+ " failed, no such row exists.");
1:b8d1d8a: 		
1:b8d1d8a: 		return rowsDeleted;
1:b8d1d8a: 	}// end of method delete_one()
1:b8d1d8a: 	
1:b8d1d8a: 	//
1:b8d1d8a: 	// get a random serialkey value that matches the criteria:
1:b8d1d8a: 	// - should not be one of the "protected" rows (set by
1:b8d1d8a: 	// nstest.NUM_UNTOUCHED_ROWS)
1:b8d1d8a: 	// - should be less than the current value of the max(serialkey)
1:b8d1d8a: 	//
1:b8d1d8a: 	public long pick_one(Connection conn, String thread_id) throws Exception {
1:23e8c92: 				
1:b8d1d8a: 		Random rand = new Random();
1:b8d1d8a: 		
1:23e8c92: 		long minVal = NsTest.NUM_UNTOUCHED_ROWS + 1;//the max we start with
1:b8d1d8a: 		long maxVal = NsTest.numInserts;// this is an almost accurate count of
1:23e8c92: 		// the max serialkey since it keeps a count of the num of inserts made
1:23e8c92: 		// so far
1:b8d1d8a: 		
1:b8d1d8a: 		// Now choose a random value between minVal and maxVal. We use this
1:23e8c92: 		// value even if the row does not exist (i.e. in a situation where some
1:23e8c92: 		// other thread has deleted this row).
1:b8d1d8a: 		// The test should just complain and exit with a row not found exception
1:23e8c92: 		// now get a value between the original max, and the current max 
1:23e8c92: 		long rowToReturn = minVal + (long)(rand.nextDouble() * (maxVal - minVal));
1:b8d1d8a: 		return rowToReturn;
1:b8d1d8a: 		
1:3d7c2ea: 	}//of method pick_one(...)
1:b8d1d8a: 	
1:b8d1d8a: 	// ** This method abstracts exception message printing for all exception
1:b8d1d8a: 	// messages. You may want to change
1:b8d1d8a: 	// ****it if more detailed exception messages are desired.
1:b8d1d8a: 	// ***Method is synchronized so that the output file will contain sensible
1:b8d1d8a: 	// stack traces that are not
1:b8d1d8a: 	// ****mixed but rather one exception printed at a time
1:b8d1d8a: 	public synchronized void printException(String where, Exception e) {
1:c043274:         if ( NsTest.justCountErrors() )
1:c043274:         {
1:c043274:             NsTest.addError( e );
1:c043274:             return;
1:c043274:         }
1:c043274: 
1:c043274: 		NsTest.logger.println(e.toString());
1:b8d1d8a: 		if (e instanceof SQLException) {
1:b8d1d8a: 			SQLException se = (SQLException) e;
1:b8d1d8a: 			
1:b8d1d8a: 			if (se.getSQLState().equals("40001"))
1:c043274: 				NsTest.logger.println(getThreadName()
1:b8d1d8a: 						+ " dbUtil --> deadlocked detected");
1:b8d1d8a: 			if (se.getSQLState().equals("40XL1"))
1:c043274: 				NsTest.logger.println(getThreadName()
1:b8d1d8a: 						+ " dbUtil --> lock timeout exception");
1:b8d1d8a: 			if (se.getSQLState().equals("23500"))
1:c043274: 				NsTest.logger.println(getThreadName()
1:b8d1d8a: 						+ " dbUtil --> duplicate key violation");
1:b8d1d8a: 			if (se.getNextException() != null) {
1:b8d1d8a: 				String m = se.getNextException().getSQLState();
1:c043274: 				NsTest.logger.println(se.getNextException().getMessage()
1:b8d1d8a: 						+ " SQLSTATE: " + m);
1:c043274: 				NsTest.logger.println(getThreadName()
1:b8d1d8a: 						+ " dbUtil ---> Details of exception: " + se.toString()
1:b8d1d8a: 						+ " " + se.getErrorCode());
1:b8d1d8a: 			}
1:b8d1d8a: 		}
1:0a66fd0: 		if (e.getMessage() == null) {
1:c043274: 			NsTest.logger.println(getThreadName()
1:b8d1d8a: 					+ " dbUtil --> NULL error message detected");
1:c043274: 			NsTest.logger
3:b8d1d8a: 			.println(getThreadName()
1:b8d1d8a: 					+ " dbUtil --> Here is the NULL exection - "
1:b8d1d8a: 					+ e.toString());
1:c043274: 			NsTest.logger.println(getThreadName()
1:b8d1d8a: 					+ " dbUtil --> Stack trace of the NULL exception - ");
1:c043274: 			if ( NsTest.justCountErrors() ) { NsTest.printException( DbUtil.class.getName(), e ); }
1:c043274: 			else { e.printStackTrace( NsTest.logger ); }
1:b8d1d8a: 		}
1:c043274: 		NsTest.logger.println(getThreadName() + " dbUtil ----> During " + where
1:b8d1d8a: 				+ ", exception thrown was : " + e.toString());
1:b8d1d8a: 	}
1:b8d1d8a: 	
1:b8d1d8a: 	public String getThreadName() {
1:b8d1d8a: 		return threadName;
1:b8d1d8a: 	}
1:b8d1d8a: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b13fb1c
/////////////////////////////////////////////////////////////////////////
1: 					+ " t_varchar,t_clob,t_blob,sequenceColumn) values ("
1: 					+ " ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,cast('00000000000000000000000000000000031' as clob(1K)),cast(X'000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000031' as blob(10K)), next value for nstesttab_seq)");
/////////////////////////////////////////////////////////////////////////
1:                 if ( NsTest.justCountErrors() )
1:                 {
1:                     NsTest.addError( sqe );
1:                 }
1:                 else
1:                 {
1:                     if (sqe.getSQLState().equalsIgnoreCase("40XL1")) {
1:                         NsTest.logger
1:                             .println("LOCK TIMEOUT obtained during insert - add_one_row() "
1:                                      + sqe.getSQLState());
1:                     }
1:                     else if (sqe.getSQLState().equalsIgnoreCase("23505")) {
1:                         NsTest.logger
1:                             .println("prevented duplicate row - add_one_row(): "
1:                                      + sqe.getSQLState() + "; " + sqe.getMessage());
1:                     } else {
1:                         throw sqe;
1:                     }
1:                 }
commit:c043274
/////////////////////////////////////////////////////////////////////////
1: 			// NsTest.logger.println("set int col 1 to " + ind);
/////////////////////////////////////////////////////////////////////////
1: 			// NsTest.logger.println("set t_Char to " + cs2.substring(0,i2));
1: 			// NsTest.logger.println("now setting date");
1: 			// NsTest.logger.println("set t_date to " + dt.toString());
1: 			// NsTest.logger.println("set t_decimal to "+ t_dec);
1: 			// NsTest.logger.println("set t_decimal_nn " + t_dec_nn);
1: 			// NsTest.logger.println("set t_double to "+ t_doub);
1: 			// NsTest.logger.println("set t_float to " + t_flt);
1: 			// NsTest.logger.println("set t_int to " + t_intval);
1: 			// NsTest.logger.println("set t_longint " + t_longval);
1: 			// NsTest.logger.println("set t_numeric large to " + t_num_lrg);
1: 			// NsTest.logger.println("set t_real to " + t_fltval);
1: 			// NsTest.logger.println("set t_smallint to " + t_smlint);
1: 			// NsTest.logger.println("set t_time to " + tt.toString());
1: 			// NsTest.logger.println("set t_timestamp to " + ts.toString());
1: 			// NsTest.logger.println("set t_varchar, now executing update stmt");
1: 					NsTest.logger
1: 				    NsTest.logger
/////////////////////////////////////////////////////////////////////////
1: 				NsTest.logger.println(thread_id + " inserted 1 row with id "
1: 				NsTest.logger.println("FAIL: " + thread_id + " inserted " + rowsAdded + "rows");
1: 			NsTest.logger
1: 			e.printStackTrace( NsTest.logger );
/////////////////////////////////////////////////////////////////////////
1: 			NsTest.logger.println(thread_id
/////////////////////////////////////////////////////////////////////////
1: 		//NsTest.logger.println(thread_id + " attempting  to update col " + column
1: 			NsTest.logger.println(sqe.getSQLState() + " " + sqe.getErrorCode()
1: 			if ( NsTest.justCountErrors() ) { NsTest.printException( DbUtil.class.getName(), sqe ); }
1: 			else { sqe.printStackTrace( NsTest.logger ); }
1: 			e.printStackTrace( NsTest.logger );
1: 			NsTest.logger.println(thread_id + " updated " + rowsUpdated
1: 			NsTest.logger
/////////////////////////////////////////////////////////////////////////
1: 			NsTest.logger
1: 		//NsTest.logger.println(thread_id
1: 			NsTest.logger.println(thread_id
/////////////////////////////////////////////////////////////////////////
0: 			NsTest.logger
/////////////////////////////////////////////////////////////////////////
1: 			NsTest.logger.println(thread_id + " deleted row with serialkey "
1: 			NsTest.logger.println(thread_id + " delete for serialkey " + skey
/////////////////////////////////////////////////////////////////////////
1:         if ( NsTest.justCountErrors() )
1:         {
1:             NsTest.addError( e );
1:             return;
1:         }
1: 
1: 		NsTest.logger.println(e.toString());
1: 				NsTest.logger.println(getThreadName()
1: 				NsTest.logger.println(getThreadName()
1: 				NsTest.logger.println(getThreadName()
1: 				NsTest.logger.println(se.getNextException().getMessage()
1: 				NsTest.logger.println(getThreadName()
1: 			NsTest.logger.println(getThreadName()
0: 			NsTest.logger
1: 			NsTest.logger.println(getThreadName()
1: 			if ( NsTest.justCountErrors() ) { NsTest.printException( DbUtil.class.getName(), e ); }
1: 			else { e.printStackTrace( NsTest.logger ); }
1: 		NsTest.logger.println(getThreadName() + " dbUtil ----> During " + where
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:23e8c92
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					.println("LOCK TIMEOUT obtained during insert - add_one_row() "
1: 				}
0: 				else if (sqe.getSQLState().equalsIgnoreCase("23505")) {
0: 				    System.out
0: 				    .println("prevented duplicate row - add_one_row(): "
0: 				            + sqe.getSQLState() + "; " + sqe.getMessage());
1: 
/////////////////////////////////////////////////////////////////////////
1: 				
1: 		long minVal = NsTest.NUM_UNTOUCHED_ROWS + 1;//the max we start with
1: 		// the max serialkey since it keeps a count of the num of inserts made
1: 		// so far
1: 		// value even if the row does not exist (i.e. in a situation where some
1: 		// other thread has deleted this row).
1: 		// now get a value between the original max, and the current max 
1: 		long rowToReturn = minVal + (long)(rand.nextDouble() * (maxVal - minVal));
commit:e276048
/////////////////////////////////////////////////////////////////////////
1: 			// name for prepared statement, otherwise auto increment column
1: 			// will think it is trying to update/insert a null value to the
1: 			// column.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 						//+ id_ind + NsTest.SUCCESS);
1:                         + id_ind);
0: 				System.out.println("FAIL: " + thread_id + " inserted " + rowsAdded + "rows");
/////////////////////////////////////////////////////////////////////////
1: 			d = rand.nextDouble() * Math.pow(10, Math.abs(rand.nextInt() % 6));
/////////////////////////////////////////////////////////////////////////
0: 		//System.out.println(thread_id + " attempting  to update col " + column
1: 		//		+ " to " + ds2);
/////////////////////////////////////////////////////////////////////////
0: 		//System.out.println(thread_id
1: 		//		+ " attempting  to delete a row with serialkey = " + skey);
/////////////////////////////////////////////////////////////////////////
0: 					//System.out
0: 					//.println(getThreadName()
0: 					//		+ " dbutil.pick_one() -> Obtained row from the table "
0: 					//		+ rowToReturn);
commit:3d7c2ea
/////////////////////////////////////////////////////////////////////////
1: 	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	}//of method pick_one(...)
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:0a66fd0
/////////////////////////////////////////////////////////////////////////
1: 		if (e.getMessage() == null) {
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:b8d1d8a
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:  Derby - Class org.apache.derbyTesting.system.nstest.utils.DbUtil
1:  
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
1:  
1:  http://www.apache.org/licenses/LICENSE-2.0
1:  
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.system.nstest.utils;
1: 
1: import java.sql.Connection;
1: import java.sql.Date;
1: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.util.Random;
1: 
1: import org.apache.derbyTesting.system.nstest.NsTest;
1: 
1: /**
1:  * DbUtil - a database utility class for all IUD and Select operations
1:  */
1: public class DbUtil {
1: 	private String threadName = "";
1: 	
1: 	public static final int TCHAR = 0;
1: 	
1: 	public static final int TDATE = 1;
1: 	
1: 	public static final int TDECIMAL = 2;
1: 	
1: 	public static final int TDECIMALNN = 3;
1: 	
1: 	public static final int TDOUBLE = 4;
1: 	
1: 	public static final int TFLOAT = 5;
1: 	
1: 	public static final int TINT = 6;
1: 	
1: 	public static final int TLONGINT = 7;
1: 	
1: 	public static final int TNUMERICLARGE = 8;
1: 	
1: 	public static final int TREAL = 9;
1: 	
1: 	public static final int TSMALLINT = 10;
1: 	
1: 	public static final int TTIME = 11;
1: 	
1: 	public static final int TTIMESTAMP = 12;
1: 	
1: 	public static final int TVARCHAR = 13;
1: 	
1: 	public static final int NUMTYPES = 14;
1: 	
1: 	public static String[] colnames = { "t_char", "t_date", "t_decimal",
1: 		"t_decimal_nn", "t_double", "t_float", "t_int", "t_longint",
1: 		"t_numeric_large", "t_real", "t_smallint", "t_time", "t_timestamp",
1: 	"t_varchar" };
1: 	
1: 	public DbUtil(String thName) {
1: 		threadName = thName;
1: 	}
1: 	
1: 	/*
1: 	 * Add a row for each iteration
1: 	 */
1: 	
1: 	public int add_one_row(Connection conn, String thread_id) throws Exception {
1: 		
1: 		PreparedStatement ps = null;
1: 		int rowsAdded = 0;
1: 		
1: 		try {
1: 			// autoincrement feature added, so we need to specify the column
0: 			// name
0: 			// for prepared statement, otherwise auto increment column will
0: 			// think
0: 			// it is trying to update/insert a null value to the column.
1: 			
1: 			ps = conn
1: 			.prepareStatement(" insert into nstesttab (id, t_char,"
1: 					+ " t_date, t_decimal, t_decimal_nn, t_double, "
1: 					+ " t_float, t_int, t_longint, t_numeric_large,"
1: 					+ " t_real, t_smallint, t_time, t_timestamp,"
0: 					+ " t_varchar,t_clob,t_blob) values ("
0: 					+ " ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,cast('00000000000000000000000000000000031' as clob(1K)),cast(X'000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000031' as blob(10K)))");
1: 			
1: 			Random rand = new Random();
1: 			
1: 			int ind = rand.nextInt();
1: 			int id_ind = ind;
1: 			
1: 			Date dt = new Date(1);
1: 			Time tt = new Time(1);
1: 			Timestamp ts = new Timestamp(1);
1: 			String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
1: 			
1: 			// Integer ji = null;
1: 			
1: 			// Set value of column "id"
1: 			ps.setInt(1, ind);
0: 			// System.out.println("set int col 1 to " + ind);
1: 			
1: 			// Set value of column "t_char"
1: 			// scramble the string
1: 			int i1 = Math.abs(ind % 100);
1: 			String cs2 = cs.substring(i1, 99) + cs.substring(0, i1);
1: 			int i2 = i1 < 89 ? i1 + 10 : i1;
1: 			ps.setString(2, cs2.substring(0, i2));
0: 			// System.out.println("set t_Char to " + cs2.substring(0,i2));
1: 			
0: 			// System.out.println("now setting date");
1: 			// Set value of column "t_date"
1: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
1: 			ps.setDate(3, dt);
0: 			// System.out.println("set t_date to " + dt.toString());
1: 			
1: 			// Set value of column "t_decimal"
0: 			// double t_dec = rand.nextDouble() *
0: 			// Math.pow(10,Math.abs(rand.nextInt()%18));
0: 			// double t_dec = rand.nextDouble();
1: 			double t_dec = rand.nextDouble()
1: 			* Math.pow(10, Math.abs(rand.nextInt() % 6));
1: 			ps.setDouble(4, t_dec);
0: 			// System.out.println("set t_decimal to "+ t_dec);
1: 			
1: 			// Set value of column "t_decimal_nn"
1: 			double t_dec_nn = rand.nextDouble();
1: 			ps.setDouble(5, t_dec_nn);
0: 			// System.out.println("set t_decimal_nn " + t_dec_nn);
1: 			
1: 			// Set value of column "t_double"
1: 			double t_doub = rand.nextDouble()
1: 			* Math.pow(10, Math.abs(rand.nextInt() % 300));
1: 			ps.setDouble(6, t_doub);
0: 			// System.out.println("set t_double to "+ t_doub);
1: 			
1: 			// Set value of column "t_float"
1: 			float t_flt = rand.nextFloat()
1: 			* (float) Math.pow(10, Math.abs(rand.nextInt() % 30));
1: 			ps.setFloat(7, t_flt);
0: 			// System.out.println("set t_float to " + t_flt);
1: 			
1: 			// Set value of column "t_int"
1: 			int t_intval = rand.nextInt();
1: 			ps.setInt(8, t_intval);
0: 			// System.out.println("set t_int to " + t_intval);
1: 			
1: 			// Set value of column "t_longint"
1: 			long t_longval = rand.nextLong();
1: 			ps.setLong(9, t_longval);
0: 			// System.out.println("set t_longint " + t_longval);
1: 			
1: 			// Set value of column "t_numeric_large"
1: 			double t_num_lrg = rand.nextDouble()
1: 			* Math.pow(10, Math.abs(rand.nextInt() % 20));
1: 			ps.setDouble(10, t_num_lrg);
0: 			// System.out.println("set t_numeric large to " + t_num_lrg);
1: 			
1: 			// Set value of column "t_real"
1: 			float t_fltval = rand.nextFloat()
1: 			* (float) Math.pow(10, Math.abs(rand.nextInt() % 7));
1: 			ps.setFloat(11, t_fltval);
0: 			// System.out.println("set t_real to " + t_fltval);
1: 			
1: 			// Set value of column "t_smallint"
1: 			int t_smlint = rand.nextInt() % (256 * 128);
1: 			ps.setInt(12, t_smlint);
0: 			// System.out.println("set t_smallint to " + t_smlint);
1: 			
1: 			// Set value of column "t_time"
1: 			tt.setTime(Math.abs(rand.nextInt()));
1: 			ps.setTime(13, tt);
0: 			// System.out.println("set t_time to " + tt.toString());
1: 			
1: 			// Set value of column "t_timestamp"
1: 			ts.setTime(Math.abs(rand.nextLong() / 50000));
1: 			ps.setTimestamp(14, ts);
0: 			// System.out.println("set t_timestamp to " + ts.toString());
1: 			
1: 			// Set value of column "t_varchar"
1: 			ps.setString(15, cs.substring(Math.abs(rand.nextInt() % 100)));
0: 			// System.out.println("set t_varchar, now executing update stmt");
1: 			try {
1: 				rowsAdded = ps.executeUpdate();
1: 			} catch (SQLException sqe) {
0: 				if (sqe.getSQLState().equalsIgnoreCase("40XL1")) {
0: 					System.out
0: 					.println("LOCK TIMEOUT obatained during insert - add_one_row() "
0: 							+ sqe.getSQLState());
1: 					
0: 				} else {
0: 					throw sqe;
1: 				}
1: 				
1: 			}
1: 			if (rowsAdded == 1) {
0: 				System.out.println(thread_id + " inserted 1 row with id "
0: 						+ id_ind + NsTest.SUCCESS);
1: 				
1: 			} else
0: 				System.out.println("FAIL: " + thread_id + " insert failed");
1: 			
1: 		} catch (Exception e) {
0: 			e.printStackTrace();
0: 			System.out
1: 			.println("Exception when preparing or executing insert prepared stmt");
1: 			printException("executing/preparing insert stmt in dbUtil", e);
0: 			e.printStackTrace();
1: 			// ps.close();
1: 		}
1: 		
0: 		if (ps != null) {
1: 			try {
0: 				ps.close();
1: 				
1: 			} catch (Exception e) {
1: 				printException(
0: 						"closing insert stmt in dbUtil when there was a problem creating it",
1: 						e);
1: 			}
1: 		}
1: 		return rowsAdded;
1: 	}
1: 	
1: 	/*
1: 	 * Update a random row. This method is common to all the worker threads
1: 	 */
1: 	
1: 	public int update_one_row(Connection conn, String thread_id)
1: 	throws Exception {
1: 		
1: 		PreparedStatement ps2 = null;
1: 		String column = null;
1: 		int ind = 0;
1: 		Random rand = new Random();
1: 		int rowsUpdated = 0;
1: 		conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1: 		long skey = pick_one(conn, thread_id);
1: 		if (skey == 0) { // means we did not find a row
0: 			System.out.println(thread_id
1: 					+ " could not find a row to update or there was an error.");
0: 			if (ps2 != null)
0: 				ps2.close();
1: 			return rowsUpdated;
1: 		}
1: 		
1: 		ind = Math.abs(rand.nextInt());
1: 		
1: 		column = colnames[ind % NUMTYPES]; // randomly gets one of the columns
1: 		// of the table
1: 		
1: 		try {
1: 			
1: 			ps2 = conn.prepareStatement(" update nstesttab set " + column
1: 					+ " = ? " + " where serialkey = " + skey);
1: 			
1: 		} catch (Exception e) {
0: 			ps2.close();
1: 			printException(
1: 					"closing update prepared stmt in dbUtil.update_one_row() ",
1: 					e);
1: 			return rowsUpdated;
1: 		}
1: 		
1: 		String ds2 = null;
1: 		String cs = "asdf qwerqwer 12341234 ZXCVZXCVZXCV !@#$!@#$ asdfasdf 1 q a z asdf ASDF qwerasdfzxcvasdfqwer1234asd#";
1: 		double d = 0.0;
1: 		float f = 0;
1: 		int type = (ind % NUMTYPES);
1: 		
1: 		switch (type) {
1: 		
1: 		case TCHAR:
1: 			ds2 = cs.substring(Math.abs(rand.nextInt() % 100));
1: 			ps2.setString(1, ds2);
1: 			break;
1: 			
1: 		case TDATE:
1: 			Date dt = new Date(1);
1: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
1: 			dt.setTime(Math.abs(rand.nextLong() / 150000));
1: 			ps2.setDate(1, dt);
1: 			ds2 = dt.toString();
1: 			break;
1: 			
1: 		case TDECIMAL:
0: 			d = rand.nextDouble() * Math.pow(10, rand.nextInt() % 18);
1: 			ps2.setDouble(1, d);
1: 			ds2 = String.valueOf(d);
1: 			break;
1: 			
1: 		case TDECIMALNN:
1: 			d = rand.nextDouble();
1: 			ps2.setDouble(1, d);
1: 			ds2 = String.valueOf(d);
1: 			break;
1: 			
1: 		case TDOUBLE:
1: 			d = rand.nextDouble() * Math.pow(10, rand.nextInt() % 300);
1: 			ps2.setDouble(1, d);
1: 			ds2 = String.valueOf(d);
1: 			break;
1: 			
1: 		case TFLOAT:
1: 			f = rand.nextFloat() * (float) Math.pow(10, rand.nextInt() % 30);
1: 			ps2.setFloat(1, f);
1: 			ds2 = String.valueOf(f);
1: 			break;
1: 			
1: 		case TINT:
1: 			int i = rand.nextInt();
1: 			ds2 = String.valueOf(i);
1: 			ps2.setInt(1, i);
1: 			break;
1: 			
1: 		case TLONGINT:
1: 			long l = rand.nextLong();
1: 			ds2 = String.valueOf(l);
1: 			ps2.setLong(1, l);
1: 			break;
1: 			
1: 		case TNUMERICLARGE:
1: 			d = rand.nextDouble() * Math.pow(10, rand.nextInt() % 20);
1: 			ps2.setDouble(1, d);
1: 			ds2 = String.valueOf(d);
1: 			break;
1: 			
1: 		case TREAL:
1: 			f = rand.nextFloat() * (float) Math.pow(10, rand.nextInt() % 7);
1: 			ps2.setFloat(1, f);
1: 			ds2 = String.valueOf(f);
1: 			break;
1: 			
1: 		case TSMALLINT:
1: 			i = rand.nextInt() % (256 * 128);
1: 			short si = (short) i;
1: 			ps2.setShort(1, si);
1: 			ds2 = String.valueOf(si);
1: 			break;
1: 			
1: 		case TTIME:
1: 			Time tt = new Time(1);
1: 			tt.setTime(Math.abs(rand.nextInt()));
1: 			ps2.setTime(1, tt);
1: 			ds2 = tt.toString();
1: 			break;
1: 			
1: 		case TTIMESTAMP:
1: 			Timestamp ts = new Timestamp(1);
1: 			ts.setTime(Math.abs(rand.nextLong() / 50000));
1: 			ps2.setTimestamp(1, ts);
1: 			ds2 = ts.toString();
1: 			break;
1: 			
1: 		case TVARCHAR:
1: 			ds2 = cs.substring(Math.abs(rand.nextInt() % 100));
1: 			ps2.setString(1, ds2);
1: 			break;
1: 			
1: 		} // end of switch(type)
1: 		
0: 		System.out.println(thread_id + " attempting  to update col " + column
0: 				+ " to " + ds2);
1: 		try {
1: 			rowsUpdated = ps2.executeUpdate();
1: 		} catch (SQLException sqe) {
0: 			System.out.println(sqe.getSQLState() + " " + sqe.getErrorCode()
1: 					+ " " + sqe.getMessage());
0: 			sqe.printStackTrace();
1: 		} catch (Exception e) {
0: 			ps2.close();
1: 			printException("Error in update_one_row()", e);
0: 			e.printStackTrace();
1: 		} finally {
1: 			conn
1: 			.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1: 		}
1: 		
1: 		if (rowsUpdated > 0)
0: 			System.out.println(thread_id + " updated " + rowsUpdated
1: 					+ " row with serialkey " + skey + NsTest.SUCCESS);
1: 		else
0: 			System.out
1: 			.println(thread_id + " update failed, no such row exists");
1: 		
0: 		if (ps2 != null) {
1: 			try {
0: 				ps2.close();
1: 				
1: 			} catch (Exception e) {
0: 				printException("closing update stmt after work is done", e);
1: 			}
1: 		}
1: 		return rowsUpdated;
1: 	}
1: 	
1: 	//
1: 	// Delete one row from the table. The row to be deleted is chosen randomly
1: 	// using the
1: 	// pick_one method which randomly returns a number between the max of
1: 	// serialkey and
1: 	// the minimum serialkey value that is untouched (nstest.NUM_UNTOUCHED_ROWS)
1: 	//
1: 	public int delete_one_row(Connection conn, String thread_id)
1: 	throws Exception {
1: 		
1: 		PreparedStatement ps = null;
1: 		int rowsDeleted = 0;
1: 		conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
1: 		try {
1: 			
1: 			ps = conn
1: 			.prepareStatement(" delete from nstesttab where serialkey = ?");
1: 		} catch (Exception e) {
0: 			System.out
1: 			.println("Unexpected error preparing the statement in delete_one()");
1: 			printException("delete_one_row prepare ", e);
0: 			if (ps != null)
0: 				ps.close();
1: 			return rowsDeleted;
1: 		}
1: 		
1: 		long skey = pick_one(conn, thread_id);
0: 		System.out.println(thread_id
0: 				+ " attempting  to delete a row with serialkey = " + skey);
1: 		if (skey == 0) { // means we did not find a row
0: 			System.out.println(thread_id
1: 					+ " could not find a row to delete or there was an error.");
0: 			ps.close();
1: 			return rowsDeleted;
1: 		}
1: 		
1: 		try {
1: 			ps.setLong(1, skey);
1: 			rowsDeleted = ps.executeUpdate();
1: 		} catch (Exception e) {
0: 			System.out
1: 			.println("Error in delete_one(): either with setLong() or executeUpdate");
0: 			ps.close();
1: 			printException("failure to execute delete stmt", e);
1: 		} finally {
1: 			conn
1: 			.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
1: 			// set it back to read uncommitted
1: 		}
1: 		
1: 		if (rowsDeleted > 0)
0: 			System.out.println(thread_id + " deleted row with serialkey "
1: 					+ skey + NsTest.SUCCESS);
1: 		else
0: 			System.out.println(thread_id + " delete for serialkey " + skey
1: 					+ " failed, no such row exists.");
1: 		
0: 		if (ps != null) {
1: 			try {
0: 				ps.close();
1: 			} catch (Exception e) {
0: 				System.out
0: 				.println("Error in closing prepared statement of delete_one()");
0: 				printException("failure to close delete stmt after work done",
1: 						e);
1: 			}
1: 		}
1: 		return rowsDeleted;
1: 	}// end of method delete_one()
1: 	
1: 	//
1: 	// get a random serialkey value that matches the criteria:
1: 	// - should not be one of the "protected" rows (set by
1: 	// nstest.NUM_UNTOUCHED_ROWS)
1: 	// - should be less than the current value of the max(serialkey)
1: 	//
1: 	public long pick_one(Connection conn, String thread_id) throws Exception {
1: 		
1: 		PreparedStatement ps = null;
0: 		// ResultSet rs = null;
1: 		
1: 		Random rand = new Random();
1: 		
1: 		try {
1: 			
1: 			ps = conn
0: 			.prepareStatement("select max(serialkey) from nstesttab where serialkey > ?");
1: 		} catch (Exception e) {
0: 			if (ps != null)
0: 				ps.close();
0: 			System.out
0: 			.println("Unexpected error creating the select prepared statement in pick_one()");
0: 			printException("failure to prepare select stmt in pick_one()", e);
0: 			return (0);
1: 		}
1: 		
0: 		long minVal = NsTest.NUM_UNTOUCHED_ROWS + 1;
0: 		// long maxVal = nstest.MAX_INITIAL_ROWS * nstest.INIT_THREADS; //the
0: 		// max we start with
1: 		long maxVal = NsTest.numInserts;// this is an almost accurate count of
0: 		// the max serialkey
0: 		// since it keeps a count of the num of inserts made so far
1: 		
1: 		// Now choose a random value between minVal and maxVal. We use this
0: 		// value even if
0: 		// the row does not exist (i.e. in a situation where some other thread
0: 		// has deleted this row).
1: 		// The test should just complain and exit with a row not found exception
0: 		long rowToReturn = (minVal + 1)
0: 		+ (Math.abs(rand.nextLong()) % (maxVal - minVal));
1: 		try {
0: 			ps.setLong(1, rowToReturn);
0: 			ResultSet rs = ps.executeQuery();
0: 			while (rs.next()) {
0: 				if (rs.getLong(1) > 0) {
0: 					rowToReturn = rs.getLong(1);
0: 					System.out
1: 					.println(getThreadName()
0: 							+ " dbutil.pick_one() -> Obtained row from the table "
0: 							+ rowToReturn);
0: 				} else {
0: 					System.out
1: 					.println(getThreadName()
0: 							+ " dbutil.pick_one() -> Returning random serialkey of "
0: 							+ rowToReturn);
1: 				}
1: 			}
1: 		} catch (SQLException sqe) {
0: 			System.out.println(sqe + " while selecting a random row");
0: 			sqe.printStackTrace();
1: 		}
1: 		
0: 		if (ps != null) {
1: 			try {
0: 				ps.close();
1: 				
1: 			} catch (Exception e) {
0: 				System.out
0: 				.println("Error in closing prepared statement of pick_one()");
1: 				printException(
0: 						"failure closing select stmt in pick_one after work is done",
1: 						e);
1: 			}
1: 		}
1: 		
1: 		return rowToReturn;
1: 		
0: 	}// end of method pick_one(...)
1: 	
1: 	// ** This method abstracts exception message printing for all exception
1: 	// messages. You may want to change
1: 	// ****it if more detailed exception messages are desired.
1: 	// ***Method is synchronized so that the output file will contain sensible
1: 	// stack traces that are not
1: 	// ****mixed but rather one exception printed at a time
1: 	public synchronized void printException(String where, Exception e) {
0: 		System.out.println(e.toString());
1: 		if (e instanceof SQLException) {
1: 			SQLException se = (SQLException) e;
1: 			
1: 			if (se.getSQLState().equals("40001"))
0: 				System.out.println(getThreadName()
1: 						+ " dbUtil --> deadlocked detected");
1: 			if (se.getSQLState().equals("40XL1"))
0: 				System.out.println(getThreadName()
1: 						+ " dbUtil --> lock timeout exception");
1: 			if (se.getSQLState().equals("23500"))
0: 				System.out.println(getThreadName()
1: 						+ " dbUtil --> duplicate key violation");
1: 			if (se.getNextException() != null) {
1: 				String m = se.getNextException().getSQLState();
0: 				System.out.println(se.getNextException().getMessage()
1: 						+ " SQLSTATE: " + m);
0: 				System.out.println(getThreadName()
1: 						+ " dbUtil ---> Details of exception: " + se.toString()
1: 						+ " " + se.getErrorCode());
1: 			}
1: 		}
0: 		if (e.getMessage().equals(null)) {
0: 			System.out.println(getThreadName()
1: 					+ " dbUtil --> NULL error message detected");
0: 			System.out
1: 			.println(getThreadName()
1: 					+ " dbUtil --> Here is the NULL exection - "
1: 					+ e.toString());
0: 			System.out.println(getThreadName()
1: 					+ " dbUtil --> Stack trace of the NULL exception - ");
0: 			e.printStackTrace(System.out);
1: 		}
0: 		System.out.println(getThreadName() + " dbUtil ----> During " + where
1: 				+ ", exception thrown was : " + e.toString());
1: 	}
1: 	
1: 	public String getThreadName() {
1: 		return threadName;
1: 	}
1: }
============================================================================