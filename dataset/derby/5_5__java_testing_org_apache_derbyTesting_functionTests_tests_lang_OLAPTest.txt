1:1c5e43e: /**
1:1c5e43e:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.OLAPTest
2:1c5e43e:  *  
1:1c5e43e:  * Licensed to the Apache Software Foundation (ASF) under one
1:1c5e43e:  * or more contributor license agreements.  See the NOTICE file
1:1c5e43e:  * distributed with this work for additional information
1:1c5e43e:  * regarding copyright ownership.  The ASF licenses this file
1:1c5e43e:  * to you under the Apache License, Version 2.0 (the
1:1c5e43e:  * "License"); you may not use this file except in compliance
1:1c5e43e:  * with the License.  You may obtain a copy of the License at
1:1c5e43e:  *
1:1c5e43e:  *   http://www.apache.org/licenses/LICENSE-2.0
1:1c5e43e:  *
1:1c5e43e:  * Unless required by applicable law or agreed to in writing,
1:1c5e43e:  * software distributed under the License is distributed on an
1:1c5e43e:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:1c5e43e:  * KIND, either express or implied.  See the License for the
1:1c5e43e:  * specific language governing permissions and limitations
1:1c5e43e:  * under the License.
5:1c5e43e:  */
9:1c5e43e: 
1:1c5e43e: package org.apache.derbyTesting.functionTests.tests.lang;
1:1c5e43e: 
1:b5105f3: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:7a9ce7e: import java.sql.ResultSetMetaData;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:1c5e43e: import junit.framework.Test;
1:1c5e43e: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1c5e43e: import org.apache.derbyTesting.junit.JDBC;
1:1c5e43e: import org.apache.derbyTesting.junit.TestConfiguration;
1:1c5e43e: 
1:1c5e43e: /**
1:25e562c:  * OLAP functionality test.
1:1c5e43e:  * 
1:1c5e43e:  * Please refer to DERBY-581 for more details.
1:1c5e43e:  */ 
1:1c5e43e: public class OLAPTest extends BaseJDBCTestCase {
1:1c5e43e: 
1:7a9ce7e: 	private final static String LANG_WINDOW_FUNCTION_CONTEXT_ERROR = "42ZC2";
1:7a9ce7e: 	private final static String NOT_IMPLEMENTED = "0A000";
1:7a9ce7e: 	private final static String LANG_SYNTAX_ERROR = "42X01";
1:7a9ce7e: 	private final static String LANG_COLUMN_NOT_FOUND =	"42X04";
1:7a9ce7e: 
1:1c5e43e: 	public OLAPTest(String name) {
1:1c5e43e: 		super(name);    
3:1c5e43e: 	}
1:1c5e43e: 
1:7a9ce7e: 	public static Test makeSuite() {
1:7a9ce7e:         Test clean = new CleanDatabaseTestSetup(
1:1ae02c9:             new BaseTestSuite(OLAPTest.class)) {
1:7a9ce7e:                 protected void decorateSQL(Statement s)
1:7a9ce7e:                         throws SQLException
1:7a9ce7e:                 {
1:7a9ce7e:                     getConnection().setAutoCommit(false);
1:7a9ce7e:                     s.executeUpdate("create table t1 (a int, b int)");
1:7a9ce7e:                     s.executeUpdate("create table t2 (x int)");
1:7a9ce7e:                     s.executeUpdate("create table t3 (y int)");
1:7a9ce7e:                     s.executeUpdate("create table t4 (a int, b int)");
1:7a9ce7e:                     s.executeUpdate("create table t5 (a int, b int)");
1:7a9ce7e: 
1:7a9ce7e:                     s.executeUpdate(
1:7a9ce7e:                         "insert into t1 values (10,100),(20,200)," +
1:7a9ce7e:                         "                      (30,300),(40,400)," +
1:7a9ce7e:                         "                      (50,500)");
1:7a9ce7e:                     s.executeUpdate(
1:7a9ce7e:                         "insert into t2 values (1),(2),(3),(4),(5)");
1:7a9ce7e:                     s.executeUpdate(
1:7a9ce7e:                         "insert into t3 values (4),(5),(6),(7),(8)");
1:7a9ce7e:                     s.executeUpdate(
1:7a9ce7e:                         "insert into t4 values (10,100),(20,200)");
1:7a9ce7e:                     s.executeUpdate(
1:7a9ce7e:                         "insert into t5 values (1,1),(2,4),(3,4),(4,4),(5,9)");
1:7a9ce7e:                     getConnection().commit();
1:7a9ce7e:                 }
1:7a9ce7e:             };
1:7a9ce7e: 		return clean;
1:7a9ce7e: 	}
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e: 	public static Test suite()
1:7a9ce7e:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("OLAPTest");
1:7a9ce7e: 		suite.addTest(makeSuite());
1:7a9ce7e: 		suite.addTest(TestConfiguration.clientServerDecorator(makeSuite()));
1:7a9ce7e: 		return suite;
1:7a9ce7e:     }
1:7a9ce7e: 
1:7a9ce7e: 
1:1c5e43e: 	/**
1:1c5e43e: 	 * Main test body
1:c723732: 	 * 
1:1c5e43e: 	 * @throws SQLException
1:c723732: 	 */
1:c723732: 	public void testBasicOperations()
1:c723732: 		throws SQLException {
1:1f2a256: 		Statement s = createStatement();
1:c723732: 
3:1c5e43e: 		/*
1:1c5e43e: 		 * Positive testing of Statements
1:7a9ce7e: 		 */
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e: 		/*
1:c723732: 		 * Simple queries
1:c723732: 		 */		
1:c723732: 		ResultSet rs = s.executeQuery("select row_number() over (), t1.* from t1");
1:c723732: 		String[][] expectedRows = {{"1", "10", "100"}, {"2", "20", "200"}, {"3", "30", "300"}, {"4", "40", "400"}, {"5", "50", "500"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:3ecd206: 
1:c723732: 		rs = s.executeQuery("select row_number() over (), t1.* from t1 where a > 30");
1:c723732: 		expectedRows = new String[][]{{"1", "40", "400"}, {"2", "50", "500"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:3ecd206: 
1:c723732: 		rs = s.executeQuery("select row_number() over (), a from t1 where b > 300");
1:c723732: 		expectedRows = new String[][]{{"1", "40"}, {"2", "50"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:1c5e43e: 
1:c723732: 		rs = s.executeQuery("select row_number() over () as r, a from t1 where b > 300");
1:c723732: 		expectedRows = new String[][]{{"1", "40"}, {"2", "50"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:1c5e43e: 
1:c723732: 		/* Two instances of row_number columns in the same RCL */
1:c723732: 		rs = s.executeQuery("select row_number() over (), row_number() over (), b from t1 where b <= 300");
1:c723732: 		expectedRows = new String[][]{{"1", "1", "100"}, {"2", "2", "200"}, {"3", "3", "300"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:1c5e43e: 
1:c723732: 		/* Two instances of row_number columns in the same RCL, reorder columns */
1:c723732: 		rs = s.executeQuery("select row_number() over (), b, row_number() over (), a from t1 where b < 300 ");
1:c723732: 		expectedRows = new String[][]{{"1", "100", "1", "10"}, {"2", "200", "2", "20"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:c723732: 		/* Pushing predicates (... where r ... ) too far cause this join to fail */
1:c723732: 		rs = s.executeQuery("select row_number() over(),x from t2,t3 where x=y");
1:c723732: 		expectedRows = new String[][]{{"1", "4"}, {"2", "5"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:7a9ce7e: 		// DERBY-4069: ORDER BY should be applied at the cursor level, that is
1:7a9ce7e: 		// *after* a windowing clause in the. So, with the original ordering
1:7a9ce7e: 		// here, the ROW_NUMBER should come backwards:
1:7a9ce7e: 
1:c723732: 		/* Ordering */
1:c723732: 		rs = s.executeQuery("select row_number() over () as r, t1.* from t1 order by b desc");
1:7a9ce7e: 
1:7a9ce7e: 		expectedRows = new String[][]{{"5", "50", "500"},
1:7a9ce7e: 									  {"4", "40", "400"},
1:7a9ce7e: 									  {"3", "30", "300"},
1:7a9ce7e: 									  {"2", "20", "200"},
1:7a9ce7e: 									  {"1", "10", "100"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e:         // DERBY-4069: ORDER BY should be applied at the cursor level, that is
1:7a9ce7e:         // *after* a windowing clause in the. So, with the original ordering
1:7a9ce7e:         // here, the ROW_NUMBER should come backwards:
1:c723732: 
1:c723732: 		/* Ordering on a column dropped in projection */
1:c723732: 		rs = s.executeQuery("select row_number() over () as r, t1.a from t1 order by b desc");
1:7a9ce7e: 
1:7a9ce7e: 		expectedRows = new String[][]{{"5", "50"},
1:7a9ce7e: 									  {"4", "40"},
1:7a9ce7e: 									  {"3", "30"},
1:7a9ce7e: 									  {"2", "20"},
1:7a9ce7e: 									  {"1", "10"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:c723732: 		/* Only expressions in RCL */
1:c723732: 		rs = s.executeQuery("select row_number() over (), row_number() over (), 2*t1.a from t1");
1:c723732: 		expectedRows = new String[][]{{"1", "1", "20"}, {"2", "2","40"}, {"3", "3","60"}, {"4", "4", "80"}, {"5", "5", "100"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e: 
1:c723732: 		/*
1:7a9ce7e: 		 * Subqueries
1:7a9ce7e: 		 */
1:7a9ce7e: 
1:c723732: 		/* This query returned no rows at one time */
1:c723732: 		rs = s.executeQuery("select * from (select row_number() over () as r,x from t2,t3 where x=y) s(r,x) where r < 3");
1:c723732: 		expectedRows = new String[][]{{"1", "4"}, {"2", "5"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 		
1:1c5e43e: 		rs = s.executeQuery("select * from (select row_number() over () as r, t1.* from t1) as tr where r < 3");
1:c723732: 		expectedRows = new String[][]{{"1", "10", "100"}, {"2", "20", "200"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:c723732: 		rs = s.executeQuery("select * from (select row_number() over () as r, t1.* from t1) as tr where r > 3");
1:c723732: 		expectedRows = new String[][]{{"4", "40", "400"}, {"5", "50", "500"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:1c5e43e: 
1:c723732: 		/* Two instances of row_number columns */
1:c723732: 		rs = s.executeQuery("select row_number() over(), tr.* from (select row_number() over () as r, t1.* from t1) as tr where r > 2 and r < 5");
1:c723732: 		expectedRows = new String[][]{{"1", "3", "30", "300"}, {"2", "4", "40", "400"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:c723732: 		/* Two instances of row_number columns, with projection */
1:c723732: 		rs = s.executeQuery("select row_number() over(), tr.b from (select row_number() over () as r, t1.* from t1) as tr where r > 2 and r < 5");
1:c723732: 		expectedRows = new String[][]{{"1", "300"}, {"2", "400"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);		
1:c723732: 
1:c723732: 		/* Column ordering */
1:c723732: 		rs = s.executeQuery("select * from (select t1.b, row_number() over () as r from t1) as tr where r > 3");
1:c723732: 		expectedRows = new String[][]{{"400", "4"}, {"500", "5"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:c723732: 		/* Column ordering with projection*/
1:c723732: 		rs = s.executeQuery("select b from (select t1.b, row_number() over () as r from t1) as tr where r > 3");
1:c723732: 		expectedRows = new String[][]{{"400"}, {"500"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 		
1:c723732: 		/*
1:c723732: 		 * Aggregates over window functions once failed
1:c723732: 		 */
1:c723732: 		rs = s.executeQuery("select count(*) from (select row_number() over() from t1) x");
1:c723732: 		expectedRows = new String[][]{{"5"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:c723732: 		rs = s.executeQuery("select count(*) from (select row_number() over () as r from t1) as t(r) where r <=3");
1:c723732: 		expectedRows = new String[][]{{"3"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 		
1:c723732: 		/*
1:c723732: 		 * Some other joins with window functions.
1:c723732: 		 * Run off a smaller table t4 to reduce expected row count.
1:c723732: 		 */
1:c723732: 		rs = s.executeQuery("select row_number() over () from t1 union all select row_number() over () from t1");
1:c723732: 		expectedRows = new String[][]{{"1"},{"2"},{"3"},{"4"},{"5"},{"1"},{"2"},{"3"},{"4"},{"5"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);	
1:c723732: 		
1:c723732: 		rs = s.executeQuery("select 2 * r from (select row_number() over () from t1) x(r)");
1:c723732: 		expectedRows = new String[][]{{"2"},{"4"},{"6"},{"8"},{"10"},};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 		
1:c723732: 		rs = s.executeQuery("select c3, c1, c2 from " + 
1:c723732: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), " +
1:c723732: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4)");
1:c723732: 		expectedRows = new String[][]{{"100", "10", "100"},
1:c723732: 										{"200", "10", "100"},																				
1:c723732: 										{"100", "20", "200"},
1:c723732: 										{"200", "20", "200"}};										
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 					
1:c723732: 		rs = s.executeQuery("select c3, c1, c2 from " + 
1:c723732: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), " +
1:c723732: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4), " +
1:c723732: 							"t4");
1:c723732: 		expectedRows = new String[][]{{"100", "10", "100"},
1:c723732: 										{"100", "10", "100"},																				
1:c723732: 										{"200", "10", "100"},
1:c723732: 										{"200", "10", "100"},
1:c723732: 										{"100", "20", "200"},
1:c723732: 										{"100", "20", "200"},
1:c723732: 										{"200", "20", "200"},										
1:c723732: 										{"200", "20", "200"}};										
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:c723732: 		rs = s.executeQuery("select c3, c1, c2 from "+
1:c723732: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), "+
1:c723732: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4), "+
1:c723732: 							"t4 "+
1:c723732: 							"where x1.r1 = 2 * x2.r2");
1:c723732: 		expectedRows = new String[][]{{"100", "20", "200"}, {"100", "20", "200"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:c723732: 		rs = s.executeQuery("select c3, c1, c2 from "+
1:c723732: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), "+
1:c723732: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4), "+
1:c723732: 							"t4 "+
1:c723732: 							"where x1.r1 = 2 * x2.r2");
1:c723732: 		expectedRows = new String[][]{{"100", "20", "200"}, {"100", "20", "200"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 				
1:c723732: 		/* Two problematic joins reported during development */
1:c723732: 		rs = s.executeQuery("select c3, c1, c2 from "+
1:c723732: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), "+
1:c723732: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4), "+
1:c723732: 							"t4 "+
1:c723732: 							"where x2.c4 = t4.a");
1:c723732: 		expectedRows = new String[][]{{"100", "10", "100"}, 
1:c723732: 										{"100", "20", "200"},
1:c723732: 										{"200", "10", "100"},
1:c723732: 										{"200", "20", "200"}};			
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 		
1:c723732: 		rs = s.executeQuery("select c3, c1, c2 from "+
1:c723732: 							"(select a, b, row_number() over() as r from t1) x1 (c1, c2, r1), "+
1:c723732: 							"(select row_number() over() as r, b, a from t1) x2 (r2, c3, c4), "+
1:c723732: 							"t1 "+
1:c723732: 							"where x1.r1 = 2 * x2.r2 and x2.c4 = t1.a");
1:c723732: 		expectedRows = new String[][]{{"100", "20", "200"}, {"200", "40", "400"}};
1:c723732: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 
1:7a9ce7e: 		// Check that flattening does not happen when a window is used in a
1:7a9ce7e: 		// subquery
1:7a9ce7e: 
1:7a9ce7e: 		rs = s.executeQuery("select * from t5 o where o.a in " +
1:7a9ce7e: 							"(select x + row_number() over () from t2)");
1:7a9ce7e: 		expectedRows = new String[][]{{"2", "4"},
1:7a9ce7e: 									  {"4", "4"}};
1:7a9ce7e: 		JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:0af1f88:         // Subquery in SELECT list. DERBY-5954
1:0af1f88:         rs = s.executeQuery(
1:0af1f88:             "SELECT rn_t1, (" +
1:0af1f88:             "     SELECT rn_t2 FROM (" +
1:0af1f88:             "         SELECT row_number() over() as rn_t2 FROM t2) " +
1:0af1f88:             "         as T_2" +
1:0af1f88:             "         where T_2.rn_t2 = T_1.rn_t1 + 1  ) " +
1:0af1f88:             "     as rn_outer" +
1:0af1f88:             "     FROM (SELECT row_number() over() as rn_t1 from t2) as T_1");
1:0af1f88: 
1:0af1f88:         expectedRows = new String[][]{{"1", "2"},
1:0af1f88:                                       {"2", "3"},
1:0af1f88:                                       {"3", "4"},
1:0af1f88:                                       {"4", "5"},
1:0af1f88:                                       {"5", null}};
1:0af1f88:         JDBC.assertFullResultSet(rs, expectedRows);
1:0af1f88: 
1:7a9ce7e: 
1:7a9ce7e: 		/*
1:7a9ce7e: 		 * Group by and having
1:7a9ce7e: 		 */
1:3ecd206: 		rs = s.executeQuery("select r from (select a, row_number() over() as r, b from t1) x group by r");
1:3ecd206: 		expectedRows = new String[][]{{"1"}, {"2"}, {"3"}, {"4"}, {"5"}};
1:3ecd206: 		JDBC.assertFullResultSet(rs, expectedRows);
1:c723732: 		
1:3ecd206: 		rs = s.executeQuery("select * from (select a, row_number() over() as r, b from t1) x group by a, b, r");
1:3ecd206: 		expectedRows = new String[][]{{"10", "1", "100"}, 
1:3ecd206: 										{"20", "2", "200"},
1:3ecd206: 										{"30", "3", "300"},
1:3ecd206: 										{"40", "4", "400"},
1:3ecd206: 										{"50", "5", "500"}};
1:3ecd206: 		JDBC.assertFullResultSet(rs, expectedRows);
1:3ecd206: 		
1:3ecd206: 		rs = s.executeQuery("select * from (select a, row_number() over() as r, b from t1) x group by b, r, a");
1:3ecd206: 		expectedRows = new String[][]{{"10", "1", "100"}, 
1:3ecd206: 										{"20", "2", "200"},
1:3ecd206: 										{"30", "3", "300"},
1:3ecd206: 										{"40", "4", "400"},
1:3ecd206: 										{"50", "5", "500"}};
1:3ecd206: 		JDBC.assertFullResultSet(rs, expectedRows);
1:3ecd206: 		
1:3ecd206: 		rs = s.executeQuery("select * from "+
1:3ecd206: 							"(select a, row_number() over() as r, b from t1) x "+
1:3ecd206: 							"group by b, r, a "+
1:3ecd206: 							"having r > 2");
1:3ecd206: 		expectedRows = new String[][]{{"30", "3", "300"},
1:3ecd206: 										{"40", "4", "400"}, 
1:3ecd206: 										{"50", "5", "500"}};
1:3ecd206: 		JDBC.assertFullResultSet(rs, expectedRows);
1:3ecd206: 		
1:3ecd206: 		rs = s.executeQuery("select * from "+
1:3ecd206: 							"(select a, row_number() over() as r, b from t1) x "+
1:3ecd206: 							"group by b, r, a "+
1:3ecd206: 							"having r > 2 and a >=30 "+
1:3ecd206: 							"order by a desc");
1:3ecd206: 		expectedRows = new String[][]{{"50", "5", "500"},
1:3ecd206: 										{"40", "4", "400"}, 
1:3ecd206: 										{"30", "3", "300"}};
1:3ecd206: 		JDBC.assertFullResultSet(rs, expectedRows);
1:3ecd206: 		 
1:3ecd206: 		rs = s.executeQuery("select * from "+
1:3ecd206: 							"(select a, row_number() over() as r, b from t1) x "+
1:3ecd206: 							"group by b, r, a "+
1:3ecd206: 							"having r > 2 and a >=30 "+
1:3ecd206: 							"order by r desc");
1:3ecd206: 		expectedRows = new String[][]{{"50", "5", "500"},
1:3ecd206: 										{"40", "4", "400"}, 
1:3ecd206: 										{"30", "3", "300"}};
1:3ecd206: 		JDBC.assertFullResultSet(rs, expectedRows);
1:3ecd206: 		
1:3ecd206: 		rs = s.executeQuery("select * from "+
1:3ecd206: 							"(select a, row_number() over() as r, b from t1) x "+
1:3ecd206: 							"group by b, r, a "+
1:3ecd206: 							"having r > 2 and a >=30 "+
1:3ecd206: 							"order by a asc, r desc");
1:3ecd206: 		expectedRows = new String[][]{{"30", "3", "300"},
1:3ecd206: 										{"40", "4", "400"}, 
1:3ecd206: 										{"50", "5", "500"}};
1:3ecd206: 		JDBC.assertFullResultSet(rs, expectedRows);
1:3ecd206: 		
1:411d1b7: 		/* A couple of distinct queries */
1:411d1b7: 		rs = s.executeQuery("select distinct row_number() over (), 'ABC' from t1");
1:411d1b7: 		expectedRows = new String[][]{{"1", "ABC"},
1:411d1b7: 										{"2", "ABC"},
1:411d1b7: 										{"3", "ABC"},
1:411d1b7: 										{"4", "ABC"},
1:411d1b7: 										{"5", "ABC"}};
1:411d1b7: 		JDBC.assertFullResultSet(rs, expectedRows);
1:411d1b7: 		
1:7a9ce7e: 		rs = s.executeQuery(
1:7a9ce7e: 			"select * from (select distinct row_number() over (), " +
1:7a9ce7e: 			"                               'ABC' from t1) tmp");
1:411d1b7: 		expectedRows = new String[][]{{"1", "ABC"},
1:411d1b7: 										{"2", "ABC"},
1:411d1b7: 										{"3", "ABC"},
1:411d1b7: 										{"4", "ABC"},
1:411d1b7: 										{"5", "ABC"}};
1:411d1b7: 		JDBC.assertFullResultSet(rs, expectedRows);
1:411d1b7: 
1:7a9ce7e:         // Test explicitly declared window
1:7a9ce7e:         rs = s.executeQuery(
1:7a9ce7e:             "select * from (select distinct row_number() over w, 'ABC' " +
1:7a9ce7e:                             "from t1 window w as ()) tmp");
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:1c5e43e: 
1:7a9ce7e:         // DERBY-3634 Cannot use row_number() in ORDER BY clause
1:7a9ce7e:         rs = s.executeQuery(
1:7a9ce7e:             "select row_number() over () r, a from t1 order by r desc");
1:7a9ce7e:         expectedRows = new String[][]{{"5", "50"},
1:7a9ce7e:                                       {"4", "40"},
1:7a9ce7e:                                       {"3", "30"},
1:7a9ce7e:                                       {"2", "20"},
1:7a9ce7e:                                       {"1", "10"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:1c5e43e: 
1:7a9ce7e:         rs = s.executeQuery(
1:7a9ce7e:             "select a from t1 order by row_number() over () desc");
1:7a9ce7e:         expectedRows = new String[][]{{"50"},
1:7a9ce7e:                                       {"40"},
1:7a9ce7e:                                       {"30"},
1:7a9ce7e:                                       {"20"},
1:7a9ce7e:                                       {"10"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:1c5e43e: 
1:7a9ce7e:         // Another case mentioned in DERBY-3634
1:7a9ce7e:         rs = s.executeQuery("select a, row_number() over () from t1 except " +
1:7a9ce7e:                             "select a, row_number() over () from t1");
1:7a9ce7e:         JDBC.assertEmpty(rs);
1:1c5e43e: 
1:7a9ce7e:         // And yet another case mentioned in DERBY-3634 This actually also
1:7a9ce7e:         // tests that ROW_NUMBER in an ORDER BY does not get optimized away if
1:7a9ce7e:         // there is a restriction, see SelectNode's call to
1:7a9ce7e:         // orderByList.removeConstantColumns(wherePredicates).
1:7a9ce7e:         rs = s.executeQuery("select abs(a), row_number() over () c " +
1:7a9ce7e:                             "from t1 where a > 30 and a <= 50 " +
1:7a9ce7e:                             "order by c desc");
1:7a9ce7e:         expectedRows = new String[][]{{"50", "2"},
1:7a9ce7e:                                       {"40", "1"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:         // DERBY-3635 Cannot build SELECT LIST expressions involving
1:7a9ce7e:         // ROW_NUMBER()
1:7a9ce7e:         rs = s.executeQuery("select row_number() over () + 10, a from t1 " +
1:7a9ce7e:                             "order by row_number() over () desc");
1:7a9ce7e:         expectedRows = new String[][]{{"15", "50"},
1:7a9ce7e:                                       {"14", "40"},
1:7a9ce7e:                                       {"13", "30"},
1:7a9ce7e:                                       {"12", "20"},
1:7a9ce7e:                                       {"11", "10"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:         // Check that a non-used window doesn't cause problems
1:7a9ce7e:         rs = s.executeQuery("select a from t1 window r as () order by a desc");
1:7a9ce7e:         expectedRows = new String[][]{{"50"},
1:7a9ce7e:                                       {"40"},
1:7a9ce7e:                                       {"30"},
1:7a9ce7e:                                       {"20"},
1:7a9ce7e:                                       {"10"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e:         // Check that a row_number combined with group by works. Good to test
1:7a9ce7e:         // this since windowing uses a similar rewrite mechanism to group by
1:7a9ce7e:         // and could interfere (seen during development).
1:7a9ce7e:         rs = s.executeQuery("select row_number() over r, b, sum(a) from t5 " +
1:7a9ce7e:                             "group by b window r as ()");
1:7a9ce7e:         expectedRows = new String[][]{{"1", "1", "1"},
1:7a9ce7e:                                       {"2", "4", "9"},
1:7a9ce7e:                                       {"3", "9", "5"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e:         // Check that a row_number combined with group by works. Good to test
1:7a9ce7e:         // this since windowing uses a similar rewrite mechanism to group by
1:7a9ce7e:         // and could interfere (seen during development).
1:7a9ce7e:         rs = s.executeQuery("select row_number() over r, b, sum(a) from t5 " +
1:7a9ce7e:                             "group by b window r as ()");
1:7a9ce7e:         expectedRows = new String[][]{{"1", "1", "1"},
1:7a9ce7e:                                       {"2", "4", "9"},
1:7a9ce7e:                                       {"3", "9", "5"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e:         rs = s.executeQuery("select b, sum(a) from t5 " +
1:7a9ce7e:                             "group by b window r as ()");
1:7a9ce7e:         expectedRows = new String[][]{{"1", "1"},
1:7a9ce7e:                                       {"4", "9"},
1:7a9ce7e:                                       {"9", "5"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e:         // Check that row_number inside EXISTS works.
1:7a9ce7e:         rs = s.executeQuery("SELECT * FROM t2 WHERE EXISTS " +
1:7a9ce7e:                             "(SELECT ROW_NUMBER() OVER () FROM t5)");
1:7a9ce7e:         expectedRows = new String[][]{{"1"},{"2"},{"3"},{"4"},{"5"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e:         /*
1:7a9ce7e:          * Negative testing of Statements
1:7a9ce7e:          */
1:7a9ce7e: 
1:7a9ce7e:         // Missing required OVER ()
1:7a9ce7e:         assertStatementError(
1:7a9ce7e:             LANG_SYNTAX_ERROR, s,
1:7a9ce7e: 			"select row_number() as r, * from t1 where t1.a > 2");
1:7a9ce7e: 
1:7a9ce7e:         // Illegal where clause, r not a named column of t1.
1:7a9ce7e:         assertStatementError(
1:7a9ce7e:             LANG_COLUMN_NOT_FOUND, s,
1:7a9ce7e:             "select row_number() over () as r, a from t1 where r < 3");
1:7a9ce7e: 
1:7a9ce7e:         // Illegal use of asterisk with another column identifier.
1:7a9ce7e:         assertStatementError(
1:7a9ce7e:             LANG_SYNTAX_ERROR, s,
1:7a9ce7e:             "select row_number() over () as r, * from t1 where t1.a > 2");
1:7a9ce7e: 
1:7a9ce7e:         // Order by in window specification
1:7a9ce7e:         assertStatementError(
1:7a9ce7e:             NOT_IMPLEMENTED,
1:7a9ce7e:             s,
1:7a9ce7e:             "select row_number() over (order by i) as r from t1");
1:7a9ce7e: 
1:7a9ce7e:         // Other window function than row_number:
1:7a9ce7e:         assertStatementError(NOT_IMPLEMENTED,
1:7a9ce7e:                              s,
1:7a9ce7e:                              "select max(i) over () from t1");
1:7a9ce7e: 
1:7a9ce7e:         // Illegal context: WHERE, cf. SQL 2003, section 7.8 SR 2
1:7a9ce7e:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:7a9ce7e:                              s,
1:7a9ce7e:                              "select * from t4 where row_number() over () > 3");
1:7a9ce7e: 
1:7a9ce7e:         // But nested inside a subquery it should work:
1:7a9ce7e:         rs = s.executeQuery("select * from t2 where x in " +
1:7a9ce7e:                             "     (select row_number() over () from t4)");
1:7a9ce7e:         expectedRows = new String[][]{{"1"},{"2"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e:         // Illegal context: GROUP BY
1:7a9ce7e:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:7a9ce7e:                              s,
1:7a9ce7e:                              "select * from t4 group by row_number() over ()");
1:7a9ce7e: 
1:7a9ce7e:         // But nested inside a subquery it should work.
1:7a9ce7e:         // Fails: DERBY-4403, enable this test when that issue is fixed.
1:7a9ce7e:         // rs = s.executeQuery("select * from t4 group by a + " +
1:7a9ce7e:         //             "(select row_number() over () from t4 where a=10)");
1:7a9ce7e:         // JDBC.assertEmpty(rs);
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:         // Illegal context: HAVING, cf. SQL 2003, section 7.10 SR 4
1:7a9ce7e:         assertStatementError(
1:7a9ce7e: 			LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:7a9ce7e: 			s,
1:7a9ce7e: 			"select * from t4 group by a having b = row_number() over ()");
1:7a9ce7e: 
1:7a9ce7e:         // But nested inside a subquery it should work:
1:7a9ce7e:         rs = s.executeQuery(
1:7a9ce7e:             "select sum(a) from t5 group by b " +
1:7a9ce7e:             "   having b = (select row_number() over () + 3 " +
1:7a9ce7e:             "                   from t5 where a=1)");
1:7a9ce7e:         expectedRows = new String[][]{{"9"}};
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:         // Illegal context: VALUES
1:7a9ce7e:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:7a9ce7e:                              s,
1:7a9ce7e:                              "values row_number() over ()");
1:7a9ce7e: 
1:7a9ce7e:         // But nested inside a subquery it should work:
1:7a9ce7e:         rs = s.executeQuery("values 3 + " +
1:7a9ce7e:                             "(select row_number() over () from t2 where x=1)");
1:7a9ce7e:         expectedRows = new String[][]{{"4"}};
1:7a9ce7e:         JDBC.assertFullResultSet(rs, expectedRows);
1:7a9ce7e: 
1:7a9ce7e:         // Illegal context: Aggregate function, cf. SQL 2003, section 10.9 SR 7
1:7a9ce7e:         // a)
1:7a9ce7e:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:7a9ce7e:                              s,
1:7a9ce7e:                              "select sum(row_number() over ()) from t4");
1:7a9ce7e: 
1:7a9ce7e:         // Illegal context: JOIN ON clause, cf. SQL 2003, section 7.7 SR 5
1:7a9ce7e:         assertStatementError(
1:7a9ce7e:             LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:7a9ce7e:             s,
1:7a9ce7e:             "select * from t4 t_1 join t4 t_2 on " +
1:7a9ce7e:             "                     t_1.a = row_number() over () + t_2.a");
1:591ff9f: 
1:e9ac824:         // DERBY-6565: NPE before
1:591ff9f:         assertStatementError(
1:591ff9f:                 LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:591ff9f:                 s,
1:591ff9f:                 "update t3 set y = y - row_number() over ()");
1:e9ac824: 
1:e9ac824:         // DERBY-6688: subquery using SubqueryNode rather than FromSubquery
1:e9ac824:         // had problems with presence of window function in order by.
1:e9ac824: 
1:e9ac824:         JDBC.assertFullResultSet(s.executeQuery("select * from t3"),
1:e9ac824:                 new String[][]{{"4"},{"5"},{"6"},{"7"},{"8"}});
1:e9ac824: 
1:e9ac824:         // failed prior to DERBY-6688
1:e9ac824:         s.executeUpdate(
1:e9ac824:             "update t3 set y = y - " +
1:e9ac824:             "    (select y from t3 order by row_number() over () " +
1:e9ac824:             "     fetch first 1 row only)");
1:e9ac824:         JDBC.assertFullResultSet(s.executeQuery("select * from t3"),
1:e9ac824:                 new String[][]{{"0"},{"1"},{"2"},{"3"},{"4"}});
1:e9ac824: 
1:e9ac824:         // Used to work before
1:e9ac824:         JDBC.assertFullResultSet(s.executeQuery(
1:e9ac824:             "select * from  " +
1:5b0cb06:             "    (select y from t3 order by row_number() over () " + 
1:5b0cb06:             "     fetch first 1 row only) tt"),
1:e9ac824:             new String[][]{{"0"}});
1:e9ac824: 
1:e9ac824:         // failed prior to DERBY-6688
1:e9ac824:         JDBC.assertFullResultSet(s.executeQuery(
1:e9ac824:             "select * from t3 where y = " +
1:5b0cb06:             "    (select y from t3 order by row_number() over () " + 
1:5b0cb06:             "     fetch first row only)"),
1:e9ac824:             new String[][]{{"0"}});
1:ed8967c: 
1:5b0cb06:         // DERBY-6689: ArrayIndexOutOfBoundsException before
1:ed8967c:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:ed8967c:             s,
1:5b0cb06:             "merge into t2 using t3 on (t2.x=t3.y) when not matched then " + 
1:5b0cb06:             "    insert values (row_number() over ())");
1:5b0cb06:         
1:5b0cb06:         // DERBY-6691: NPE before
1:5b0cb06:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:5b0cb06:             s,
1:5b0cb06:             "call syscs_util.syscs_compress_table(" + 
1:5b0cb06:             "    'APP', 'T2', row_number() over ())");
1:b737f16: 
1:b737f16:         // DERBY-6690: a window function in generated clause was not detected
1:b737f16:         // before
1:b737f16:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:b737f16:             s,
1:b737f16:             "create table t (x int generated always as " +
1:b737f16:             "    (row_number() over ()))");
1:b737f16: 
1:b737f16:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:b737f16:             s,
1:b737f16:             "alter table t2 add column foo int generated always as " +
1:b737f16:             "    (row_number() over ())");
1:7a9ce7e:     }
1:7a9ce7e: 
1:7a9ce7e: 
1:7a9ce7e:     public void testMetaData()
1:7a9ce7e:         throws SQLException {
1:7a9ce7e: 
1:7a9ce7e:         if (JDBC.vmSupportsJSR169()) {
1:7a9ce7e:             // does not support metadata
1:7a9ce7e:             return;
1:7a9ce7e:         }
1:7a9ce7e: 
1:7a9ce7e:         Statement s = createStatement();
1:7a9ce7e:         ResultSet rs = s.executeQuery(
1:7a9ce7e:             "select row_number() over () from sys.systables");
1:7a9ce7e:         ResultSetMetaData rsmd = rs.getMetaData();
1:7a9ce7e: 
1:7a9ce7e:         assertEquals(ResultSetMetaData.columnNoNulls, rsmd.isNullable(1));
1:7a9ce7e:     }
1:7a9ce7e: 
1:b5105f3: 
1:b5105f3:     private String makeString(int len)
1:b5105f3:     {
1:b5105f3:         StringBuffer buf = new StringBuffer(len);
1:b5105f3:         for (int i = 0; i < len; i++)
1:b5105f3:             buf.append('a');
1:b5105f3:         return buf.toString();
1:b5105f3:     }
1:b5105f3:         /**
1:b5105f3:           * Basic test of GROUP BY ROLLUP capability.
1:b5105f3:           *
1:b5105f3:           * This test case has a few basic tests of GROUP BY ROLLUP, both
1:b5105f3:           * positive and negative tests.
1:b5105f3:           */
1:b5105f3:     public void testGroupByRollup()
1:b5105f3:         throws SQLException
1:b5105f3:     {
1:b5105f3:         Statement s = createStatement();
1:b5105f3:         s.executeUpdate("create table ru (a int, b int, c int, d int)");
1:b5105f3:         s.executeUpdate("insert into ru values (1,1,1,1), (1,2,3,4),"+
1:b5105f3:                 "(1,1,2,2), (4,3,2,1), (4,4,4,4)");
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:                     "select a,b,c,sum(d) from ru group by rollup(a,b,c)"),
1:b5105f3:                 new String[][]{
1:b5105f3:                     {"1","1","1","1"},
1:b5105f3:                     {"1","1","2","2"},
1:b5105f3:                     {"1","2","3","4"},
1:b5105f3:                     {"4","3","2","1"},
1:b5105f3:                     {"4","4","4","4"},
1:b5105f3:                     {"1","1",null,"3"},
1:b5105f3:                     {"1","2",null,"4"},
1:b5105f3:                     {"4","3",null,"1"},
1:b5105f3:                     {"4","4",null,"4"},
1:b5105f3:                     {"1",null,null,"7"},
1:b5105f3:                     {"4",null,null,"5"},
1:b5105f3:                     {null,null,null,"12"}});
1:b5105f3:         JDBC.assertFullResultSet( s.executeQuery(
1:b5105f3:                 "select count(*) from ru group by mod(a,b)"),
1:b5105f3:                 new String[][]{ {"3"},{"2"}});
1:b5105f3: 
1:b5105f3:         // Try a few negative tests:
1:b5105f3:         assertStatementError("42X04", s,
1:b5105f3:                 "select a,b,c,sum(d) from ru group by rollup");
1:b5105f3:         assertStatementError("42X01", s,
1:b5105f3:                 "select a,b,c,sum(d) from ru group by rollup(");
1:b5105f3:         assertStatementError("42X01", s,
1:b5105f3:                 "select a,b,c,sum(d) from ru group by rollup)");
1:b5105f3:         assertStatementError("42X01", s,
1:b5105f3:                 "select a,b,c,sum(d) from ru group by rollup()");
1:b5105f3: 
1:b5105f3:         s.executeUpdate("drop table ru");
1:b5105f3:         s.close();
1:b5105f3:     }
1:b5105f3:     /**
1:b5105f3:       * Verify that ROLLUP can still be used as the name of a column or table.
1:b5105f3:       */
1:b5105f3:     public void testRollupReservedWord()
1:b5105f3:         throws SQLException
1:b5105f3:     {
1:b5105f3:         Statement s = createStatement();
1:b5105f3:         s.executeUpdate("create table t_roll(rollup int, x int)");
1:b5105f3:         JDBC.assertEmpty( s.executeQuery(
1:b5105f3:                     "select rollup, sum(x) from t_roll group by rollup"));
1:b5105f3:         JDBC.assertEmpty( s.executeQuery(
1:b5105f3:                     "select count(*) from t_roll group by mod(rollup,x)"));
1:b5105f3:         JDBC.assertEmpty( s.executeQuery(
1:b5105f3:                     "select count(*) from t_roll group by mod(x,rollup)"));
1:b5105f3:         s.executeUpdate("create table rollup(a int, x int)");
1:b5105f3:         JDBC.assertEmpty( s.executeQuery("select a, x from rollup"));
1:b5105f3:         s.executeUpdate("insert into rollup(a,x) values(1,2)");
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:                     "select a,sum(x) from rollup group by rollup(a)"),
1:b5105f3:                 new String[][]{
1:b5105f3:                     {"1","2"}, {null,"2"}});
1:b5105f3:         s.executeUpdate("drop table rollup");
1:b5105f3:         s.executeUpdate("drop table t_roll");
1:b5105f3:         s.close();
1:b5105f3:     }
1:b5105f3:     /**
1:b5105f3:       * Verify that non-aggregate columns are returned as NULLABLE if ROLLUP.
1:b5105f3:       *
1:b5105f3:       * If a GROUP BY ROLLUP is used, the un-aggregated columns may contain
1:b5105f3:       * NULL values, so we need to verify that the DatabaseMetadata returns
1:b5105f3:       * the right values for the nullability of the columns.
1:b5105f3:       */
1:b5105f3:     public void testRollupColumnNullability()
1:b5105f3:         throws SQLException
1:b5105f3:     {
1:b5105f3:         Statement s = createStatement();
1:b5105f3:         s.executeUpdate(
1:b5105f3:                 "create table t_notnull(a int not null, b int," +
1:b5105f3:                 "                       c int not null, d int)");
1:b5105f3:         ResultSet rs = s.executeQuery(
1:b5105f3:                 "select a,b,c,sum(d) from t_notnull group by rollup(a,b,c)");
1:b5105f3:         JDBC.assertNullability(rs,
1:b5105f3:                 new boolean[]{true, true, true, true});
1:b5105f3:         rs.close();
1:b5105f3: 
1:b5105f3:         rs = s.executeQuery(
1:b5105f3:                 "select 1,2,3,sum(d) from t_notnull group by rollup(1,2,3)");
1:b5105f3:         JDBC.assertNullability(rs,
1:b5105f3:                 new boolean[]{true, true, true, true});
1:b5105f3:         rs.close();
1:b5105f3: 
1:b5105f3:         s.executeUpdate("drop table t_notnull");
1:b5105f3:         s.close();
1:b5105f3:     }
1:b5105f3: 
1:b5105f3:     /**
1:b5105f3:       * Verify the behavior of GROUP BY ROLLUP for empty result sets.
1:b5105f3:       */
1:b5105f3:     public void testRollupEmptyTables()
1:b5105f3:         throws SQLException
1:b5105f3:     {
1:b5105f3:         Statement s = createStatement();
1:b5105f3:         s.executeUpdate("create table ru (a int, b int, c int, d int)");
1:b5105f3: 
1:b5105f3:         JDBC.assertEmpty( s.executeQuery("select sum(a) from ru group by b"));
1:b5105f3:         JDBC.assertSingleValueResultSet(
1:b5105f3:                 s.executeQuery("select sum(a) from ru"), (String)null);
1:b5105f3:         s.executeUpdate("insert into ru values (1,1,1,1), (1,2,3,4),"+
1:b5105f3:                 "(1,1,2,2), (4,3,2,1), (4,4,4,4)");
1:b5105f3:         JDBC.assertEmpty( s.executeQuery(
1:b5105f3:                     "select b, sum(a) from ru where 1<>1 group by rollup(b)"));
1:b5105f3: 
1:b5105f3:         s.executeUpdate("drop table ru");
1:b5105f3:         s.close();
1:b5105f3:     }
1:b5105f3: 
1:b5105f3:     /**
1:b5105f3:       * A ROLLUP case suggested by Dag in 1-sep-2009 comment on DERBY-3002
1:b5105f3:       */
1:b5105f3:     public void testRollupNullabilityCasts()
1:b5105f3:         throws SQLException
1:b5105f3:     {
1:b5105f3:         Statement s = createStatement();
1:b5105f3:         s.executeUpdate("create table t(c varchar(2) not null," +
1:b5105f3:                 "c2 varchar(2), i integer)");
1:b5105f3:         s.executeUpdate("insert into t values('aa',null,null)");
1:b5105f3:         s.executeUpdate("insert into t values('bb',null,null)");
1:b5105f3:         String [][]rows = 
1:b5105f3:                 new String[][]{
1:b5105f3:                     {"aa",null,null},
1:b5105f3:                     {"aa",null,null},
1:b5105f3:                     {null,null,null},
1:b5105f3:                     {"bb",null,null},
1:b5105f3:                     {"bb",null,null}};
1:b5105f3:         JDBC.assertUnorderedResultSet(
1:b5105f3:             s.executeQuery("select c,c2,sum(i) from t group by rollup(c,c2)"),
1:b5105f3:             rows);
1:b5105f3:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:b5105f3:                 "select cast(c as varchar(2)),c2,sum(i) from t " +
1:b5105f3:                 "group by rollup(c,c2)"),
1:b5105f3:             rows);
1:b5105f3:         /* FIXME -- this test currently fails due to improper handling of
1:b5105f3:            the nullability of the result columns.
1:b5105f3:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:b5105f3:                 "select cast(x as varchar(2)),y,z from " +
1:b5105f3:                 " (select c,c2,sum(i) from t " +
1:b5105f3:                 "      group by rollup (c,c2)) t(x,y,z)"),
1:b5105f3:             rows);
1:b5105f3:             */
1:b5105f3: 
1:b5105f3:         s.executeUpdate("drop table t");
1:b5105f3:         s.close();
1:b5105f3:     }
1:b5105f3: 
1:b5105f3:     /**
1:b5105f3:       * Verify the behavior of GROUP BY ROLLUP when it can use a covering index.
1:b5105f3:       */
1:b5105f3:     public void testRollupOfCoveringIndex()
1:b5105f3:         throws SQLException
1:b5105f3:     {
1:b5105f3:         Statement s = createStatement();
1:b5105f3:         s.executeUpdate("create table ru (a int,b int,c int,d varchar(1000))");
1:b5105f3:         s.executeUpdate("create index ru_idx on ru(a,b,c)");
1:b5105f3:         PreparedStatement ps = prepareStatement(
1:b5105f3:                 "insert into ru (a,b,c,d) values (?,?,?,?)");
1:b5105f3:         for (int i = 0; i < 100; i++)
1:b5105f3:         {
1:b5105f3:             ps.setInt(1, (i%5));
1:b5105f3:             ps.setInt(2, 2*i);
1:b5105f3:             ps.setInt(3, 100+i);
1:b5105f3:             ps.setString(4, makeString(900));
1:b5105f3:             ps.executeUpdate();
1:b5105f3:         }
1:b5105f3:         ps.close();
1:b5105f3:         // FIXME
1:b5105f3:         //dumpIt(s, 2, "select a,sum(c) from ru group by a");
1:b5105f3:         //dumpIt(s, 3, "select a,b,sum(c) from ru group by a,b");
1:b5105f3:         //dumpIt(s, 3, "select a,b,sum(c) from ru group by rollup(a,b)");
1:b5105f3:         s.executeUpdate("drop table ru");
1:b5105f3:         s.close();
1:b5105f3:     }
1:b5105f3:     private void dumpIt(Statement s, int cols, String sql)
1:b5105f3:         throws SQLException
1:b5105f3:     {
1:b5105f3:         System.out.println(sql);
1:b5105f3:         ResultSet rs = s.executeQuery(sql);
1:b5105f3:         while (rs.next())
1:b5105f3:         {
1:b5105f3:             StringBuffer buf = new StringBuffer();
1:b5105f3:             for (int i = 1; i <= cols; i++)
1:b5105f3:             {
1:b5105f3:                 if (i > 1)
1:b5105f3:                     buf.append(",");
1:b5105f3:                 buf.append(rs.getString(i));
1:b5105f3:             }
1:b5105f3:             System.out.println(buf.toString());
1:b5105f3:         }
1:b5105f3:         rs.close();
1:b5105f3:     }
1:b5105f3:     /*
1:b5105f3:      * Various GROUP BY tests, with and without ROLLUP.
1:b5105f3:      */
1:b5105f3:     public void testGroupByWithAndWithoutRollup()
1:b5105f3:         throws SQLException
1:b5105f3:     {
1:b5105f3:         Statement s = createStatement();
1:b5105f3:         // A very simple set of master-detail ORDER and ORDER_ITEM tables,
1:b5105f3:         // with some fake customer data:
1:b5105f3:         s.executeUpdate(
1:b5105f3:                 "create table orders(order_id int primary key," +
1:b5105f3:                 "   customer varchar(10)," +
1:b5105f3:                 "   order_date date, " +
1:b5105f3:                 "   shipping int)");
1:b5105f3:         s.executeUpdate(
1:b5105f3:                 "create table order_items(item_id int primary key," +
1:b5105f3:                 "   order_id int," +
1:b5105f3:                 "   order_item varchar(10), " +
1:b5105f3:                 "   cost int)");
1:b5105f3:         s.executeUpdate(
1:b5105f3:                 "create table customers(customer varchar(10) primary key," +
1:b5105f3:                 "   name varchar(100), city varchar(100), state varchar(2))");
1:b5105f3:         s.executeUpdate("insert into customers values " +
1:b5105f3:                 "('ABC','ABC Corporation','ABC City', 'AB')," +
1:b5105f3:                 "('DEF','DEF, Inc.', 'DEFburg', 'DE')");
1:b5105f3:         s.executeUpdate("insert into orders values(1,'ABC','2009-01-01',40)");
1:b5105f3:         s.executeUpdate("insert into orders values(2,'ABC','2009-01-02',30)");
1:b5105f3:         s.executeUpdate("insert into orders values(3,'ABC','2009-01-03',25)");
1:b5105f3:         s.executeUpdate("insert into orders values(4,'DEF','2009-01-02',10)");
1:b5105f3:         s.executeUpdate("insert into order_items values(1,1,'Item A',100)");
1:b5105f3:         s.executeUpdate("insert into order_items values(2,1,'Item B',150)");
1:b5105f3:         s.executeUpdate("insert into order_items values(3,2,'Item C',125)");
1:b5105f3:         s.executeUpdate("insert into order_items values(4,2,'Item B',50)");
1:b5105f3:         s.executeUpdate("insert into order_items values(5,2,'Item H',200)");
1:b5105f3:         s.executeUpdate("insert into order_items values(6,3,'Item X',100)");
1:b5105f3:         s.executeUpdate("insert into order_items values(7,4,'Item Y',50)");
1:b5105f3:         s.executeUpdate("insert into order_items values(8,4,'Item Z',300)");
1:b5105f3:         // Joining the two tables produces one row per order item:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.order_id, o.customer, o.order_date, " +
1:b5105f3:             "o.shipping, od.item_id, od.order_item, od.cost " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             " on o.order_id = od.order_id"),
1:b5105f3:             new String[][]{
1:b5105f3:                     {"1","ABC","2009-01-01","40","1","Item A","100"},
1:b5105f3:                     {"1","ABC","2009-01-01","40","2","Item B","150"},
1:b5105f3:                     {"2","ABC","2009-01-02","30","3","Item C","125"},
1:b5105f3:                     {"2","ABC","2009-01-02","30","4","Item B","50"},
1:b5105f3:                     {"2","ABC","2009-01-02","30","5","Item H","200"},
1:b5105f3:                     {"3","ABC","2009-01-03","25","6","Item X","100"},
1:b5105f3:                     {"4","DEF","2009-01-02","10","7","Item Y","50"},
1:b5105f3:                     {"4","DEF","2009-01-02","10","8","Item Z","300"},
1:b5105f3:                 });
1:b5105f3:         // Grouping the items by customer to compute items/customer:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by o.customer"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6"},
1:b5105f3:                 {"DEF","2"},
1:b5105f3:             });
1:b5105f3:         // Also include the total cost per customer:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer, " +
1:b5105f3:             "       sum(od.cost) as order_total " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by o.customer"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6","725"},
1:b5105f3:                 {"DEF","2","350"},
1:b5105f3:             });
1:b5105f3:         // ROLLUP the items and costs to grand totals:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer, " +
1:b5105f3:             "       sum(od.cost) as order_total " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by ROLLUP(o.customer)"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6","725"},
1:b5105f3:                 {"DEF","2","350"},
1:b5105f3:                 {null,"8","1075"},
1:b5105f3:             });
1:b5105f3:         // Show a usage of Count(distinct) to compute the orders/customer,
1:b5105f3:         // which is not the same as the items/customer:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer, " +
1:b5105f3:             "       count(distinct o.order_id) as orders_per_customer " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by o.customer"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6","3"},
1:b5105f3:                 {"DEF","2","1"},
1:b5105f3:             });
1:b5105f3:         // ROLLUP should work for the distinct count, too:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer, " +
1:b5105f3:             "       count(distinct o.order_id) as orders_per_customer " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by ROLLUP(o.customer)"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6","3"},
1:b5105f3:                 {"DEF","2","1"},
1:b5105f3:                 {null,"8","4"},
1:b5105f3:             });
1:b5105f3:         // can we compute the total shipping per customer:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer, " +
1:b5105f3:             "       sum(od.cost) as order_total, " +
1:b5105f3:             "       count(distinct o.order_id) as orders_per_customer, " +
1:b5105f3:             "       sum(o.shipping) as shipping_per_customer " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by o.customer"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6","725","3","195"},
1:b5105f3:                 {"DEF","2","350","1","20"},
1:b5105f3:             });
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer, " +
1:b5105f3:             "       sum(od.cost) as order_total, " +
1:b5105f3:             "       count(distinct o.order_id) as orders_per_customer, " +
1:b5105f3:             "       sum(o.shipping) as shipping_per_customer " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by ROLLUP(o.customer)"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6","725","3","195"},
1:b5105f3:                 {"DEF","2","350","1","20"},
1:b5105f3:                 {null,"8","1075","4","215"},
1:b5105f3:             });
1:7a9ce7e:         // Show a usage of distinct shipping aggregate, similar to the
1:b5105f3:         // distinct count aggregate:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer, " +
1:b5105f3:             "       sum(od.cost) as order_total, " +
1:b5105f3:             "       count(distinct o.order_id) as orders_per_customer, " +
1:b5105f3:             "       sum(distinct o.shipping) as shipping_per_customer " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by o.customer"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6","725","3","95"},
1:b5105f3:                 {"DEF","2","350","1","10"},
1:b5105f3:             });
1:b5105f3:         // Demonstrate some of the dangers of using distinct aggregates.
1:b5105f3:         // Duplicate SUM values may be real duplicates from the data, not
1:b5105f3:         // from duplicate-producing master-detail joins. The COUNT changes
1:b5105f3:         // from 1 to 2 for customer DEF, but the shipping_per_customer is
1:b5105f3:         // still 10, which is logically wrong (there are 2 DEF orders, each
1:b5105f3:         // with value 10, so we "expected" 20 for shipping_per_customer).
1:b5105f3:         s.executeUpdate("insert into orders values(5,'DEF','2009-01-04',10)");
1:b5105f3:         s.executeUpdate("insert into order_items values(9,5,'Item J',125)");
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer, " +
1:b5105f3:             "       sum(od.cost) as order_total, " +
1:b5105f3:             "       count(distinct o.order_id) as orders_per_customer, " +
1:b5105f3:             "       sum(distinct o.shipping) as shipping_per_customer " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by o.customer"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6","725","3","95"},
1:b5105f3:                 {"DEF","3","475","2","10"},
1:b5105f3:             });
1:b5105f3:         // Same as before, but with ROLLUP:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.Customer, count(*) as items_per_customer, " +
1:b5105f3:             "       sum(od.cost) as order_total, " +
1:b5105f3:             "       count(distinct o.order_id) as orders_per_customer, " +
1:b5105f3:             "       sum(distinct o.shipping) as shipping_per_customer " +
1:b5105f3:             " from orders o inner join order_items od " +
1:b5105f3:             "      on o.order_id = od.order_id " +
1:b5105f3:             " group by ROLLUP(o.customer)"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","6","725","3","95"},
1:b5105f3:                 {"DEF","3","475","2","10"},
1:b5105f3:                 {null,"9","1200","5","105"},
1:b5105f3:             });
1:b5105f3:         // Produce the results we expected by constructing a sub-query:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select order_id, count(*) as Items_per_order, " +
1:b5105f3:             "       sum(cost) as Order_total "+
1:b5105f3:             " from order_items " +
1:b5105f3:             " group by order_id"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"1","2","250"},
1:b5105f3:                 {"2","3","375"},
1:b5105f3:                 {"3","1","100"},
1:b5105f3:                 {"4","2","350"},
1:b5105f3:                 {"5","1","125"},
1:b5105f3:             });
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select order_id, count(*) as Items_per_order, " +
1:b5105f3:             "       sum(cost) as Order_total "+
1:b5105f3:             " from order_items " +
1:b5105f3:             " group by ROLLUP(order_id)"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"1","2","250"},
1:b5105f3:                 {"2","3","375"},
1:b5105f3:                 {"3","1","100"},
1:b5105f3:                 {"4","2","350"},
1:b5105f3:                 {"5","1","125"},
1:b5105f3:                 {null,"9","1200"},
1:b5105f3:             });
1:b5105f3:         // ... then encapsulate that sub-select with a join to the orders:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.order_id, o.Customer, o.Shipping, " +
1:b5105f3:             "       d.items_per_order, d.order_total " +
1:b5105f3:             " from orders o inner join (" +
1:b5105f3:             "   select order_id, count(*) as Items_per_order, " +
1:b5105f3:             "          sum(cost) as Order_total "+
1:b5105f3:             "    from order_items " +
1:b5105f3:             "    group by order_id " +
1:b5105f3:             "   ) d on o.order_id = d.order_id"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"1","ABC","40","2","250"},
1:b5105f3:                 {"2","ABC","30","3","375"},
1:b5105f3:                 {"3","ABC","25","1","100"},
1:b5105f3:                 {"4","DEF","10","2","350"},
1:b5105f3:                 {"5","DEF","10","1","125"},
1:b5105f3:             });
1:b5105f3:         // ... and group *THAT* join, in turn, by customer, to get the
1:b5105f3:         // correct values of shipping_per_customer and items_per_customer.
1:b5105f3:         // Note that total_per_customer is a SUM(SUM()), while 
1:b5105f3:         // items_per_customer is a SUM(COUNT()). And no DISTINCT needed.
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.customer, count(*) as orders_per_customer, " +
1:b5105f3:             "       sum(o.shipping) as shipping_per_customer, " +
1:b5105f3:             "       sum(d.items_per_order) as items_per_customer, " +
1:b5105f3:             "       sum(d.order_total) as total_per_customer " +
1:b5105f3:             " from orders o inner join (" +
1:b5105f3:             "   select order_id, count(*) as Items_per_order, " +
1:b5105f3:             "          sum(cost) as Order_total "+
1:b5105f3:             "    from order_items " +
1:b5105f3:             "    group by order_id " +
1:b5105f3:             "   ) d on o.order_id = d.order_id " +
1:b5105f3:             " group by o.customer"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","3","95","6","725"},
1:b5105f3:                 {"DEF","2","20","3","475"},
1:b5105f3:             });
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.customer, count(*) as orders_per_customer, " +
1:b5105f3:             "       sum(o.shipping) as shipping_per_customer, " +
1:b5105f3:             "       sum(d.items_per_order) as items_per_customer, " +
1:b5105f3:             "       sum(d.order_total) as total_per_customer " +
1:b5105f3:             " from orders o inner join (" +
1:b5105f3:             "   select order_id, count(*) as Items_per_order, " +
1:b5105f3:             "          sum(cost) as Order_total "+
1:b5105f3:             "    from order_items " +
1:b5105f3:             "    group by order_id " +
1:b5105f3:             "   ) d on o.order_id = d.order_id " +
1:b5105f3:             " group by ROLLUP(o.customer)"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","3","95","6","725"},
1:b5105f3:                 {"DEF","2","20","3","475"},
1:b5105f3:                 {null,"5","115","9","1200"},
1:b5105f3:             });
1:b5105f3:         // Include customer address information. First by joining and grouping:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select o.customer, c.name, c.city, c.state, " +
1:b5105f3:             "       count(*) as orders_per_customer, " +
1:b5105f3:             "       sum(o.shipping) as shipping_per_customer, " +
1:b5105f3:             "       sum(d.items_per_order) as items_per_customer, " +
1:b5105f3:             "       sum(d.order_total) as total_per_customer " +
1:b5105f3:             " from orders o inner join (" +
1:b5105f3:             "   select order_id, count(*) as Items_per_order, " +
1:b5105f3:             "          sum(cost) as Order_total "+
1:b5105f3:             "    from order_items " +
1:b5105f3:             "    group by order_id " +
1:b5105f3:             "   ) d on o.order_id = d.order_id " +
1:b5105f3:             "   inner join customers c on o.customer = c.customer " +
1:b5105f3:             " group by ROLLUP(o.customer,c.name, c.city,c.state)"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","ABC Corporation","ABC City","AB","3","95","6","725"},
1:b5105f3:                 {"DEF","DEF, Inc.","DEFburg","DE","2","20","3","475"},
1:b5105f3:                 {"ABC","ABC Corporation","ABC City",null,"3","95","6","725"},
1:b5105f3:                 {"DEF","DEF, Inc.","DEFburg",null,"2","20","3","475"},
1:b5105f3:                 {"ABC","ABC Corporation",null,null,"3","95","6","725"},
1:b5105f3:                 {"DEF","DEF, Inc.",null,null,"2","20","3","475"},
1:b5105f3:                 {"ABC",null,null,null,"3","95","6","725"},
1:b5105f3:                 {"DEF",null,null,null,"2","20","3","475"},
1:b5105f3:                 {null,null,null,null,"5","115","9","1200"},
1:b5105f3:             });
1:b5105f3:         // Then, alternately, by sub-selecting and grouping:
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select c.customer, c.name, c.city, c.state, " +
1:b5105f3:             "       o.orders_per_customer, o.shipping_per_customer, " +
1:b5105f3:             "       o.items_per_customer, o.total_per_customer " +
1:b5105f3:             " from ( " +
1:b5105f3:             "   select o.customer, count(*) as orders_per_customer, " +
1:b5105f3:             "          sum(o.shipping) as shipping_per_customer, " +
1:b5105f3:             "          sum(d.items_per_order) as items_per_customer, " +
1:b5105f3:             "          sum(d.order_total) as total_per_customer " +
1:b5105f3:             "    from orders o inner join (" +
1:b5105f3:             "      select order_id, count(*) as Items_per_order, " +
1:b5105f3:             "             sum(cost) as Order_total "+
1:b5105f3:             "       from order_items " +
1:b5105f3:             "       group by order_id " +
1:b5105f3:             "      ) d on o.order_id = d.order_id " +
1:b5105f3:             "    group by o.customer) o " +
1:b5105f3:             "  inner join customers c on o.customer = c.customer"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","ABC Corporation","ABC City","AB","3","95","6","725"},
1:b5105f3:                 {"DEF","DEF, Inc.","DEFburg","DE","2","20","3","475"},
1:b5105f3:             });
1:b5105f3:         // Note that we can put the ROLLUP in the sub-query, but then we
1:b5105f3:         // need to outer-join with the customers table since the rollup
1:b5105f3:         // results will have NULL in the join key.
1:b5105f3:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:b5105f3:             "select c.customer, c.name, c.city, c.state, " +
1:b5105f3:             "       o.orders_per_customer, o.shipping_per_customer, " +
1:b5105f3:             "       o.items_per_customer, o.total_per_customer " +
1:b5105f3:             " from ( " +
1:b5105f3:             "   select o.customer, count(*) as orders_per_customer, " +
1:b5105f3:             "          sum(o.shipping) as shipping_per_customer, " +
1:b5105f3:             "          sum(d.items_per_order) as items_per_customer, " +
1:b5105f3:             "          sum(d.order_total) as total_per_customer " +
1:b5105f3:             "    from orders o inner join (" +
1:b5105f3:             "      select order_id, count(*) as Items_per_order, " +
1:b5105f3:             "             sum(cost) as Order_total "+
1:b5105f3:             "       from order_items " +
1:b5105f3:             "       group by order_id " +
1:b5105f3:             "      ) d on o.order_id = d.order_id " +
1:b5105f3:             "    group by ROLLUP(o.customer)) o " +
1:b5105f3:             "  left outer join customers c on o.customer = c.customer"),
1:b5105f3:             new String[][]{
1:b5105f3:                 {"ABC","ABC Corporation","ABC City","AB","3","95","6","725"},
1:b5105f3:                 {"DEF","DEF, Inc.","DEFburg","DE","2","20","3","475"},
1:b5105f3:                 {null,null,null,null,"5","115","9","1200"},
1:b5105f3:             });
1:b5105f3: 
1:b5105f3:         s.close();
1:b5105f3:     }
1:1c5e43e: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b737f16
/////////////////////////////////////////////////////////////////////////
1: 
1:         // DERBY-6690: a window function in generated clause was not detected
1:         // before
1:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:             s,
1:             "create table t (x int generated always as " +
1:             "    (row_number() over ()))");
1: 
1:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:             s,
1:             "alter table t2 add column foo int generated always as " +
1:             "    (row_number() over ())");
commit:5b0cb06
/////////////////////////////////////////////////////////////////////////
1:             "    (select y from t3 order by row_number() over () " + 
1:             "     fetch first 1 row only) tt"),
1:             "    (select y from t3 order by row_number() over () " + 
1:             "     fetch first row only)"),
1:         // DERBY-6689: ArrayIndexOutOfBoundsException before
1:             "merge into t2 using t3 on (t2.x=t3.y) when not matched then " + 
1:             "    insert values (row_number() over ())");
1:         
1:         // DERBY-6691: NPE before
1:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:             s,
1:             "call syscs_util.syscs_compress_table(" + 
1:             "    'APP', 'T2', row_number() over ())");
commit:ed8967c
/////////////////////////////////////////////////////////////////////////
1: 
0:         // DERBY-6689: NPE before
1:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:             s,
0:             "merge into t2 using t3 on (t2.x=t3.y) when not matched then insert values (row_number() over ())");
commit:e9ac824
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-6565: NPE before
1: 
1:         // DERBY-6688: subquery using SubqueryNode rather than FromSubquery
1:         // had problems with presence of window function in order by.
1: 
1:         JDBC.assertFullResultSet(s.executeQuery("select * from t3"),
1:                 new String[][]{{"4"},{"5"},{"6"},{"7"},{"8"}});
1: 
1:         // failed prior to DERBY-6688
1:         s.executeUpdate(
1:             "update t3 set y = y - " +
1:             "    (select y from t3 order by row_number() over () " +
1:             "     fetch first 1 row only)");
1:         JDBC.assertFullResultSet(s.executeQuery("select * from t3"),
1:                 new String[][]{{"0"},{"1"},{"2"},{"3"},{"4"}});
1: 
1:         // Used to work before
1:         JDBC.assertFullResultSet(s.executeQuery(
1:             "select * from  " +
0:             "    (select y from t3 order by row_number() over () fetch first 1 row only) tt"),
1:             new String[][]{{"0"}});
1: 
1:         // failed prior to DERBY-6688
1:         JDBC.assertFullResultSet(s.executeQuery(
1:             "select * from t3 where y = " +
0:                 "    (select y from t3 order by row_number() over () fetch first row only)"),
1:             new String[][]{{"0"}});
commit:591ff9f
/////////////////////////////////////////////////////////////////////////
1: 
0:         // DERBY-6565
1:         assertStatementError(
1:                 LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:                 s,
1:                 "update t3 set y = y - row_number() over ()");
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
1:             new BaseTestSuite(OLAPTest.class)) {
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("OLAPTest");
commit:0af1f88
/////////////////////////////////////////////////////////////////////////
1:         // Subquery in SELECT list. DERBY-5954
1:         rs = s.executeQuery(
1:             "SELECT rn_t1, (" +
1:             "     SELECT rn_t2 FROM (" +
1:             "         SELECT row_number() over() as rn_t2 FROM t2) " +
1:             "         as T_2" +
1:             "         where T_2.rn_t2 = T_1.rn_t1 + 1  ) " +
1:             "     as rn_outer" +
1:             "     FROM (SELECT row_number() over() as rn_t1 from t2) as T_1");
1: 
1:         expectedRows = new String[][]{{"1", "2"},
1:                                       {"2", "3"},
1:                                       {"3", "4"},
1:                                       {"4", "5"},
1:                                       {"5", null}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSetMetaData;
0: import junit.framework.TestSuite;
0: import junit.framework.Assert;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
1: 	private final static String LANG_WINDOW_FUNCTION_CONTEXT_ERROR = "42ZC2";
1: 	private final static String NOT_IMPLEMENTED = "0A000";
1: 	private final static String LANG_SYNTAX_ERROR = "42X01";
1: 	private final static String LANG_COLUMN_NOT_FOUND =	"42X04";
1: 
1: 	public static Test makeSuite() {
1:         Test clean = new CleanDatabaseTestSetup(
0:             new TestSuite(OLAPTest.class)) {
1:                 protected void decorateSQL(Statement s)
1:                         throws SQLException
1:                 {
1:                     getConnection().setAutoCommit(false);
1:                     s.executeUpdate("create table t1 (a int, b int)");
1:                     s.executeUpdate("create table t2 (x int)");
1:                     s.executeUpdate("create table t3 (y int)");
1:                     s.executeUpdate("create table t4 (a int, b int)");
1:                     s.executeUpdate("create table t5 (a int, b int)");
1: 
1:                     s.executeUpdate(
1:                         "insert into t1 values (10,100),(20,200)," +
1:                         "                      (30,300),(40,400)," +
1:                         "                      (50,500)");
1:                     s.executeUpdate(
1:                         "insert into t2 values (1),(2),(3),(4),(5)");
1:                     s.executeUpdate(
1:                         "insert into t3 values (4),(5),(6),(7),(8)");
1:                     s.executeUpdate(
1:                         "insert into t4 values (10,100),(20,200)");
1:                     s.executeUpdate(
1:                         "insert into t5 values (1,1),(2,4),(3,4),(4,4),(5,9)");
1:                     getConnection().commit();
1:                 }
1:             };
1: 		return clean;
1: 	}
1: 
1: 
1: 	public static Test suite()
1:     {
0: 		TestSuite suite = new TestSuite("OLAPTest");
1: 		suite.addTest(makeSuite());
1: 		suite.addTest(TestConfiguration.clientServerDecorator(makeSuite()));
1: 		return suite;
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 		 */
1: 
1: 
1: 
1: 		/*
/////////////////////////////////////////////////////////////////////////
1: 		// DERBY-4069: ORDER BY should be applied at the cursor level, that is
1: 		// *after* a windowing clause in the. So, with the original ordering
1: 		// here, the ROW_NUMBER should come backwards:
1: 
1: 
1: 		expectedRows = new String[][]{{"5", "50", "500"},
1: 									  {"4", "40", "400"},
1: 									  {"3", "30", "300"},
1: 									  {"2", "20", "200"},
1: 									  {"1", "10", "100"}};
1:         // DERBY-4069: ORDER BY should be applied at the cursor level, that is
1:         // *after* a windowing clause in the. So, with the original ordering
1:         // here, the ROW_NUMBER should come backwards:
1: 
1: 
1: 		expectedRows = new String[][]{{"5", "50"},
1: 									  {"4", "40"},
1: 									  {"3", "30"},
1: 									  {"2", "20"},
1: 									  {"1", "10"}};
1: 
1: 
1: 
1: 		 * Subqueries
1: 		 */
1: 
/////////////////////////////////////////////////////////////////////////
1: 		// Check that flattening does not happen when a window is used in a
1: 		// subquery
1: 
1: 		rs = s.executeQuery("select * from t5 o where o.a in " +
1: 							"(select x + row_number() over () from t2)");
1: 		expectedRows = new String[][]{{"2", "4"},
1: 									  {"4", "4"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 
1: 		/*
1: 		 * Group by and having
1: 		 */
/////////////////////////////////////////////////////////////////////////
1: 		rs = s.executeQuery(
1: 			"select * from (select distinct row_number() over (), " +
1: 			"                               'ABC' from t1) tmp");
1:         // Test explicitly declared window
1:         rs = s.executeQuery(
1:             "select * from (select distinct row_number() over w, 'ABC' " +
1:                             "from t1 window w as ()) tmp");
1:         JDBC.assertFullResultSet(rs, expectedRows);
1:         // DERBY-3634 Cannot use row_number() in ORDER BY clause
1:         rs = s.executeQuery(
1:             "select row_number() over () r, a from t1 order by r desc");
1:         expectedRows = new String[][]{{"5", "50"},
1:                                       {"4", "40"},
1:                                       {"3", "30"},
1:                                       {"2", "20"},
1:                                       {"1", "10"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1:         rs = s.executeQuery(
1:             "select a from t1 order by row_number() over () desc");
1:         expectedRows = new String[][]{{"50"},
1:                                       {"40"},
1:                                       {"30"},
1:                                       {"20"},
1:                                       {"10"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1:         // Another case mentioned in DERBY-3634
1:         rs = s.executeQuery("select a, row_number() over () from t1 except " +
1:                             "select a, row_number() over () from t1");
1:         JDBC.assertEmpty(rs);
1:         // And yet another case mentioned in DERBY-3634 This actually also
1:         // tests that ROW_NUMBER in an ORDER BY does not get optimized away if
1:         // there is a restriction, see SelectNode's call to
1:         // orderByList.removeConstantColumns(wherePredicates).
1:         rs = s.executeQuery("select abs(a), row_number() over () c " +
1:                             "from t1 where a > 30 and a <= 50 " +
1:                             "order by c desc");
1:         expectedRows = new String[][]{{"50", "2"},
1:                                       {"40", "1"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 
1:         // DERBY-3635 Cannot build SELECT LIST expressions involving
1:         // ROW_NUMBER()
1:         rs = s.executeQuery("select row_number() over () + 10, a from t1 " +
1:                             "order by row_number() over () desc");
1:         expectedRows = new String[][]{{"15", "50"},
1:                                       {"14", "40"},
1:                                       {"13", "30"},
1:                                       {"12", "20"},
1:                                       {"11", "10"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 
1:         // Check that a non-used window doesn't cause problems
1:         rs = s.executeQuery("select a from t1 window r as () order by a desc");
1:         expectedRows = new String[][]{{"50"},
1:                                       {"40"},
1:                                       {"30"},
1:                                       {"20"},
1:                                       {"10"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         // Check that a row_number combined with group by works. Good to test
1:         // this since windowing uses a similar rewrite mechanism to group by
1:         // and could interfere (seen during development).
1:         rs = s.executeQuery("select row_number() over r, b, sum(a) from t5 " +
1:                             "group by b window r as ()");
1:         expectedRows = new String[][]{{"1", "1", "1"},
1:                                       {"2", "4", "9"},
1:                                       {"3", "9", "5"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         // Check that a row_number combined with group by works. Good to test
1:         // this since windowing uses a similar rewrite mechanism to group by
1:         // and could interfere (seen during development).
1:         rs = s.executeQuery("select row_number() over r, b, sum(a) from t5 " +
1:                             "group by b window r as ()");
1:         expectedRows = new String[][]{{"1", "1", "1"},
1:                                       {"2", "4", "9"},
1:                                       {"3", "9", "5"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         rs = s.executeQuery("select b, sum(a) from t5 " +
1:                             "group by b window r as ()");
1:         expectedRows = new String[][]{{"1", "1"},
1:                                       {"4", "9"},
1:                                       {"9", "5"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         // Check that row_number inside EXISTS works.
1:         rs = s.executeQuery("SELECT * FROM t2 WHERE EXISTS " +
1:                             "(SELECT ROW_NUMBER() OVER () FROM t5)");
1:         expectedRows = new String[][]{{"1"},{"2"},{"3"},{"4"},{"5"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         /*
1:          * Negative testing of Statements
1:          */
1: 
1:         // Missing required OVER ()
1:         assertStatementError(
1:             LANG_SYNTAX_ERROR, s,
1: 			"select row_number() as r, * from t1 where t1.a > 2");
1: 
1:         // Illegal where clause, r not a named column of t1.
1:         assertStatementError(
1:             LANG_COLUMN_NOT_FOUND, s,
1:             "select row_number() over () as r, a from t1 where r < 3");
1: 
1:         // Illegal use of asterisk with another column identifier.
1:         assertStatementError(
1:             LANG_SYNTAX_ERROR, s,
1:             "select row_number() over () as r, * from t1 where t1.a > 2");
1: 
1:         // Order by in window specification
1:         assertStatementError(
1:             NOT_IMPLEMENTED,
1:             s,
1:             "select row_number() over (order by i) as r from t1");
1: 
1:         // Other window function than row_number:
1:         assertStatementError(NOT_IMPLEMENTED,
1:                              s,
1:                              "select max(i) over () from t1");
1: 
1:         // Illegal context: WHERE, cf. SQL 2003, section 7.8 SR 2
1:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:                              s,
1:                              "select * from t4 where row_number() over () > 3");
1: 
1:         // But nested inside a subquery it should work:
1:         rs = s.executeQuery("select * from t2 where x in " +
1:                             "     (select row_number() over () from t4)");
1:         expectedRows = new String[][]{{"1"},{"2"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         // Illegal context: GROUP BY
1:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:                              s,
1:                              "select * from t4 group by row_number() over ()");
1: 
1:         // But nested inside a subquery it should work.
1:         // Fails: DERBY-4403, enable this test when that issue is fixed.
1:         // rs = s.executeQuery("select * from t4 group by a + " +
1:         //             "(select row_number() over () from t4 where a=10)");
1:         // JDBC.assertEmpty(rs);
1: 
1: 
1:         // Illegal context: HAVING, cf. SQL 2003, section 7.10 SR 4
1:         assertStatementError(
1: 			LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1: 			s,
1: 			"select * from t4 group by a having b = row_number() over ()");
1: 
1:         // But nested inside a subquery it should work:
1:         rs = s.executeQuery(
1:             "select sum(a) from t5 group by b " +
1:             "   having b = (select row_number() over () + 3 " +
1:             "                   from t5 where a=1)");
1:         expectedRows = new String[][]{{"9"}};
1: 
1: 
1:         // Illegal context: VALUES
1:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:                              s,
1:                              "values row_number() over ()");
1: 
1:         // But nested inside a subquery it should work:
1:         rs = s.executeQuery("values 3 + " +
1:                             "(select row_number() over () from t2 where x=1)");
1:         expectedRows = new String[][]{{"4"}};
1:         JDBC.assertFullResultSet(rs, expectedRows);
1: 
1:         // Illegal context: Aggregate function, cf. SQL 2003, section 10.9 SR 7
1:         // a)
1:         assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:                              s,
1:                              "select sum(row_number() over ()) from t4");
1: 
1:         // Illegal context: JOIN ON clause, cf. SQL 2003, section 7.7 SR 5
1:         assertStatementError(
1:             LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
1:             s,
1:             "select * from t4 t_1 join t4 t_2 on " +
1:             "                     t_1.a = row_number() over () + t_2.a");
1:     }
1: 
1: 
1:     public void testMetaData()
1:         throws SQLException {
1: 
1:         if (JDBC.vmSupportsJSR169()) {
1:             // does not support metadata
1:             return;
1:         }
1: 
1:         Statement s = createStatement();
1:         ResultSet rs = s.executeQuery(
1:             "select row_number() over () from sys.systables");
1:         ResultSetMetaData rsmd = rs.getMetaData();
1: 
1:         assertEquals(ResultSetMetaData.columnNoNulls, rsmd.isNullable(1));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Show a usage of distinct shipping aggregate, similar to the
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:b5105f3
/////////////////////////////////////////////////////////////////////////
1: import java.sql.PreparedStatement;
/////////////////////////////////////////////////////////////////////////
1:     private String makeString(int len)
1:     {
1:         StringBuffer buf = new StringBuffer(len);
1:         for (int i = 0; i < len; i++)
1:             buf.append('a');
1:         return buf.toString();
1:     }
1:         /**
1:           * Basic test of GROUP BY ROLLUP capability.
1:           *
1:           * This test case has a few basic tests of GROUP BY ROLLUP, both
1:           * positive and negative tests.
1:           */
1:     public void testGroupByRollup()
1:         throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table ru (a int, b int, c int, d int)");
1:         s.executeUpdate("insert into ru values (1,1,1,1), (1,2,3,4),"+
1:                 "(1,1,2,2), (4,3,2,1), (4,4,4,4)");
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:                     "select a,b,c,sum(d) from ru group by rollup(a,b,c)"),
1:                 new String[][]{
1:                     {"1","1","1","1"},
1:                     {"1","1","2","2"},
1:                     {"1","2","3","4"},
1:                     {"4","3","2","1"},
1:                     {"4","4","4","4"},
1:                     {"1","1",null,"3"},
1:                     {"1","2",null,"4"},
1:                     {"4","3",null,"1"},
1:                     {"4","4",null,"4"},
1:                     {"1",null,null,"7"},
1:                     {"4",null,null,"5"},
1:                     {null,null,null,"12"}});
1:         JDBC.assertFullResultSet( s.executeQuery(
1:                 "select count(*) from ru group by mod(a,b)"),
1:                 new String[][]{ {"3"},{"2"}});
1: 
1:         // Try a few negative tests:
1:         assertStatementError("42X04", s,
1:                 "select a,b,c,sum(d) from ru group by rollup");
1:         assertStatementError("42X01", s,
1:                 "select a,b,c,sum(d) from ru group by rollup(");
1:         assertStatementError("42X01", s,
1:                 "select a,b,c,sum(d) from ru group by rollup)");
1:         assertStatementError("42X01", s,
1:                 "select a,b,c,sum(d) from ru group by rollup()");
1: 
1:         s.executeUpdate("drop table ru");
1:         s.close();
1:     }
1:     /**
1:       * Verify that ROLLUP can still be used as the name of a column or table.
1:       */
1:     public void testRollupReservedWord()
1:         throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table t_roll(rollup int, x int)");
1:         JDBC.assertEmpty( s.executeQuery(
1:                     "select rollup, sum(x) from t_roll group by rollup"));
1:         JDBC.assertEmpty( s.executeQuery(
1:                     "select count(*) from t_roll group by mod(rollup,x)"));
1:         JDBC.assertEmpty( s.executeQuery(
1:                     "select count(*) from t_roll group by mod(x,rollup)"));
1:         s.executeUpdate("create table rollup(a int, x int)");
1:         JDBC.assertEmpty( s.executeQuery("select a, x from rollup"));
1:         s.executeUpdate("insert into rollup(a,x) values(1,2)");
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:                     "select a,sum(x) from rollup group by rollup(a)"),
1:                 new String[][]{
1:                     {"1","2"}, {null,"2"}});
1:         s.executeUpdate("drop table rollup");
1:         s.executeUpdate("drop table t_roll");
1:         s.close();
1:     }
1:     /**
1:       * Verify that non-aggregate columns are returned as NULLABLE if ROLLUP.
1:       *
1:       * If a GROUP BY ROLLUP is used, the un-aggregated columns may contain
1:       * NULL values, so we need to verify that the DatabaseMetadata returns
1:       * the right values for the nullability of the columns.
1:       */
1:     public void testRollupColumnNullability()
1:         throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.executeUpdate(
1:                 "create table t_notnull(a int not null, b int," +
1:                 "                       c int not null, d int)");
1:         ResultSet rs = s.executeQuery(
1:                 "select a,b,c,sum(d) from t_notnull group by rollup(a,b,c)");
1:         JDBC.assertNullability(rs,
1:                 new boolean[]{true, true, true, true});
1:         rs.close();
1: 
1:         rs = s.executeQuery(
1:                 "select 1,2,3,sum(d) from t_notnull group by rollup(1,2,3)");
1:         JDBC.assertNullability(rs,
1:                 new boolean[]{true, true, true, true});
1:         rs.close();
1: 
1:         s.executeUpdate("drop table t_notnull");
1:         s.close();
1:     }
1: 
1:     /**
1:       * Verify the behavior of GROUP BY ROLLUP for empty result sets.
1:       */
1:     public void testRollupEmptyTables()
1:         throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table ru (a int, b int, c int, d int)");
1: 
1:         JDBC.assertEmpty( s.executeQuery("select sum(a) from ru group by b"));
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select sum(a) from ru"), (String)null);
1:         s.executeUpdate("insert into ru values (1,1,1,1), (1,2,3,4),"+
1:                 "(1,1,2,2), (4,3,2,1), (4,4,4,4)");
1:         JDBC.assertEmpty( s.executeQuery(
1:                     "select b, sum(a) from ru where 1<>1 group by rollup(b)"));
1: 
1:         s.executeUpdate("drop table ru");
1:         s.close();
1:     }
1: 
1:     /**
1:       * A ROLLUP case suggested by Dag in 1-sep-2009 comment on DERBY-3002
1:       */
1:     public void testRollupNullabilityCasts()
1:         throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table t(c varchar(2) not null," +
1:                 "c2 varchar(2), i integer)");
1:         s.executeUpdate("insert into t values('aa',null,null)");
1:         s.executeUpdate("insert into t values('bb',null,null)");
1:         String [][]rows = 
1:                 new String[][]{
1:                     {"aa",null,null},
1:                     {"aa",null,null},
1:                     {null,null,null},
1:                     {"bb",null,null},
1:                     {"bb",null,null}};
1:         JDBC.assertUnorderedResultSet(
1:             s.executeQuery("select c,c2,sum(i) from t group by rollup(c,c2)"),
1:             rows);
1:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:                 "select cast(c as varchar(2)),c2,sum(i) from t " +
1:                 "group by rollup(c,c2)"),
1:             rows);
1:         /* FIXME -- this test currently fails due to improper handling of
1:            the nullability of the result columns.
1:         JDBC.assertUnorderedResultSet(s.executeQuery(
1:                 "select cast(x as varchar(2)),y,z from " +
1:                 " (select c,c2,sum(i) from t " +
1:                 "      group by rollup (c,c2)) t(x,y,z)"),
1:             rows);
1:             */
1: 
1:         s.executeUpdate("drop table t");
1:         s.close();
1:     }
1: 
1:     /**
1:       * Verify the behavior of GROUP BY ROLLUP when it can use a covering index.
1:       */
1:     public void testRollupOfCoveringIndex()
1:         throws SQLException
1:     {
1:         Statement s = createStatement();
1:         s.executeUpdate("create table ru (a int,b int,c int,d varchar(1000))");
1:         s.executeUpdate("create index ru_idx on ru(a,b,c)");
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into ru (a,b,c,d) values (?,?,?,?)");
1:         for (int i = 0; i < 100; i++)
1:         {
1:             ps.setInt(1, (i%5));
1:             ps.setInt(2, 2*i);
1:             ps.setInt(3, 100+i);
1:             ps.setString(4, makeString(900));
1:             ps.executeUpdate();
1:         }
1:         ps.close();
1:         // FIXME
1:         //dumpIt(s, 2, "select a,sum(c) from ru group by a");
1:         //dumpIt(s, 3, "select a,b,sum(c) from ru group by a,b");
1:         //dumpIt(s, 3, "select a,b,sum(c) from ru group by rollup(a,b)");
1:         s.executeUpdate("drop table ru");
1:         s.close();
1:     }
1:     private void dumpIt(Statement s, int cols, String sql)
1:         throws SQLException
1:     {
1:         System.out.println(sql);
1:         ResultSet rs = s.executeQuery(sql);
1:         while (rs.next())
1:         {
1:             StringBuffer buf = new StringBuffer();
1:             for (int i = 1; i <= cols; i++)
1:             {
1:                 if (i > 1)
1:                     buf.append(",");
1:                 buf.append(rs.getString(i));
1:             }
1:             System.out.println(buf.toString());
1:         }
1:         rs.close();
1:     }
1:     /*
1:      * Various GROUP BY tests, with and without ROLLUP.
1:      */
1:     public void testGroupByWithAndWithoutRollup()
1:         throws SQLException
1:     {
1:         Statement s = createStatement();
1:         // A very simple set of master-detail ORDER and ORDER_ITEM tables,
1:         // with some fake customer data:
1:         s.executeUpdate(
1:                 "create table orders(order_id int primary key," +
1:                 "   customer varchar(10)," +
1:                 "   order_date date, " +
1:                 "   shipping int)");
1:         s.executeUpdate(
1:                 "create table order_items(item_id int primary key," +
1:                 "   order_id int," +
1:                 "   order_item varchar(10), " +
1:                 "   cost int)");
1:         s.executeUpdate(
1:                 "create table customers(customer varchar(10) primary key," +
1:                 "   name varchar(100), city varchar(100), state varchar(2))");
1:         s.executeUpdate("insert into customers values " +
1:                 "('ABC','ABC Corporation','ABC City', 'AB')," +
1:                 "('DEF','DEF, Inc.', 'DEFburg', 'DE')");
1:         s.executeUpdate("insert into orders values(1,'ABC','2009-01-01',40)");
1:         s.executeUpdate("insert into orders values(2,'ABC','2009-01-02',30)");
1:         s.executeUpdate("insert into orders values(3,'ABC','2009-01-03',25)");
1:         s.executeUpdate("insert into orders values(4,'DEF','2009-01-02',10)");
1:         s.executeUpdate("insert into order_items values(1,1,'Item A',100)");
1:         s.executeUpdate("insert into order_items values(2,1,'Item B',150)");
1:         s.executeUpdate("insert into order_items values(3,2,'Item C',125)");
1:         s.executeUpdate("insert into order_items values(4,2,'Item B',50)");
1:         s.executeUpdate("insert into order_items values(5,2,'Item H',200)");
1:         s.executeUpdate("insert into order_items values(6,3,'Item X',100)");
1:         s.executeUpdate("insert into order_items values(7,4,'Item Y',50)");
1:         s.executeUpdate("insert into order_items values(8,4,'Item Z',300)");
1:         // Joining the two tables produces one row per order item:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.order_id, o.customer, o.order_date, " +
1:             "o.shipping, od.item_id, od.order_item, od.cost " +
1:             " from orders o inner join order_items od " +
1:             " on o.order_id = od.order_id"),
1:             new String[][]{
1:                     {"1","ABC","2009-01-01","40","1","Item A","100"},
1:                     {"1","ABC","2009-01-01","40","2","Item B","150"},
1:                     {"2","ABC","2009-01-02","30","3","Item C","125"},
1:                     {"2","ABC","2009-01-02","30","4","Item B","50"},
1:                     {"2","ABC","2009-01-02","30","5","Item H","200"},
1:                     {"3","ABC","2009-01-03","25","6","Item X","100"},
1:                     {"4","DEF","2009-01-02","10","7","Item Y","50"},
1:                     {"4","DEF","2009-01-02","10","8","Item Z","300"},
1:                 });
1:         // Grouping the items by customer to compute items/customer:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by o.customer"),
1:             new String[][]{
1:                 {"ABC","6"},
1:                 {"DEF","2"},
1:             });
1:         // Also include the total cost per customer:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer, " +
1:             "       sum(od.cost) as order_total " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by o.customer"),
1:             new String[][]{
1:                 {"ABC","6","725"},
1:                 {"DEF","2","350"},
1:             });
1:         // ROLLUP the items and costs to grand totals:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer, " +
1:             "       sum(od.cost) as order_total " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by ROLLUP(o.customer)"),
1:             new String[][]{
1:                 {"ABC","6","725"},
1:                 {"DEF","2","350"},
1:                 {null,"8","1075"},
1:             });
1:         // Show a usage of Count(distinct) to compute the orders/customer,
1:         // which is not the same as the items/customer:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer, " +
1:             "       count(distinct o.order_id) as orders_per_customer " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by o.customer"),
1:             new String[][]{
1:                 {"ABC","6","3"},
1:                 {"DEF","2","1"},
1:             });
1:         // ROLLUP should work for the distinct count, too:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer, " +
1:             "       count(distinct o.order_id) as orders_per_customer " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by ROLLUP(o.customer)"),
1:             new String[][]{
1:                 {"ABC","6","3"},
1:                 {"DEF","2","1"},
1:                 {null,"8","4"},
1:             });
1:         // can we compute the total shipping per customer:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer, " +
1:             "       sum(od.cost) as order_total, " +
1:             "       count(distinct o.order_id) as orders_per_customer, " +
1:             "       sum(o.shipping) as shipping_per_customer " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by o.customer"),
1:             new String[][]{
1:                 {"ABC","6","725","3","195"},
1:                 {"DEF","2","350","1","20"},
1:             });
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer, " +
1:             "       sum(od.cost) as order_total, " +
1:             "       count(distinct o.order_id) as orders_per_customer, " +
1:             "       sum(o.shipping) as shipping_per_customer " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by ROLLUP(o.customer)"),
1:             new String[][]{
1:                 {"ABC","6","725","3","195"},
1:                 {"DEF","2","350","1","20"},
1:                 {null,"8","1075","4","215"},
1:             });
0:         // Show a usage of disinct shipping aggregate, similar to the
1:         // distinct count aggregate:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer, " +
1:             "       sum(od.cost) as order_total, " +
1:             "       count(distinct o.order_id) as orders_per_customer, " +
1:             "       sum(distinct o.shipping) as shipping_per_customer " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by o.customer"),
1:             new String[][]{
1:                 {"ABC","6","725","3","95"},
1:                 {"DEF","2","350","1","10"},
1:             });
1:         // Demonstrate some of the dangers of using distinct aggregates.
1:         // Duplicate SUM values may be real duplicates from the data, not
1:         // from duplicate-producing master-detail joins. The COUNT changes
1:         // from 1 to 2 for customer DEF, but the shipping_per_customer is
1:         // still 10, which is logically wrong (there are 2 DEF orders, each
1:         // with value 10, so we "expected" 20 for shipping_per_customer).
1:         s.executeUpdate("insert into orders values(5,'DEF','2009-01-04',10)");
1:         s.executeUpdate("insert into order_items values(9,5,'Item J',125)");
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer, " +
1:             "       sum(od.cost) as order_total, " +
1:             "       count(distinct o.order_id) as orders_per_customer, " +
1:             "       sum(distinct o.shipping) as shipping_per_customer " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by o.customer"),
1:             new String[][]{
1:                 {"ABC","6","725","3","95"},
1:                 {"DEF","3","475","2","10"},
1:             });
1:         // Same as before, but with ROLLUP:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.Customer, count(*) as items_per_customer, " +
1:             "       sum(od.cost) as order_total, " +
1:             "       count(distinct o.order_id) as orders_per_customer, " +
1:             "       sum(distinct o.shipping) as shipping_per_customer " +
1:             " from orders o inner join order_items od " +
1:             "      on o.order_id = od.order_id " +
1:             " group by ROLLUP(o.customer)"),
1:             new String[][]{
1:                 {"ABC","6","725","3","95"},
1:                 {"DEF","3","475","2","10"},
1:                 {null,"9","1200","5","105"},
1:             });
1:         // Produce the results we expected by constructing a sub-query:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select order_id, count(*) as Items_per_order, " +
1:             "       sum(cost) as Order_total "+
1:             " from order_items " +
1:             " group by order_id"),
1:             new String[][]{
1:                 {"1","2","250"},
1:                 {"2","3","375"},
1:                 {"3","1","100"},
1:                 {"4","2","350"},
1:                 {"5","1","125"},
1:             });
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select order_id, count(*) as Items_per_order, " +
1:             "       sum(cost) as Order_total "+
1:             " from order_items " +
1:             " group by ROLLUP(order_id)"),
1:             new String[][]{
1:                 {"1","2","250"},
1:                 {"2","3","375"},
1:                 {"3","1","100"},
1:                 {"4","2","350"},
1:                 {"5","1","125"},
1:                 {null,"9","1200"},
1:             });
1:         // ... then encapsulate that sub-select with a join to the orders:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.order_id, o.Customer, o.Shipping, " +
1:             "       d.items_per_order, d.order_total " +
1:             " from orders o inner join (" +
1:             "   select order_id, count(*) as Items_per_order, " +
1:             "          sum(cost) as Order_total "+
1:             "    from order_items " +
1:             "    group by order_id " +
1:             "   ) d on o.order_id = d.order_id"),
1:             new String[][]{
1:                 {"1","ABC","40","2","250"},
1:                 {"2","ABC","30","3","375"},
1:                 {"3","ABC","25","1","100"},
1:                 {"4","DEF","10","2","350"},
1:                 {"5","DEF","10","1","125"},
1:             });
1:         // ... and group *THAT* join, in turn, by customer, to get the
1:         // correct values of shipping_per_customer and items_per_customer.
1:         // Note that total_per_customer is a SUM(SUM()), while 
1:         // items_per_customer is a SUM(COUNT()). And no DISTINCT needed.
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.customer, count(*) as orders_per_customer, " +
1:             "       sum(o.shipping) as shipping_per_customer, " +
1:             "       sum(d.items_per_order) as items_per_customer, " +
1:             "       sum(d.order_total) as total_per_customer " +
1:             " from orders o inner join (" +
1:             "   select order_id, count(*) as Items_per_order, " +
1:             "          sum(cost) as Order_total "+
1:             "    from order_items " +
1:             "    group by order_id " +
1:             "   ) d on o.order_id = d.order_id " +
1:             " group by o.customer"),
1:             new String[][]{
1:                 {"ABC","3","95","6","725"},
1:                 {"DEF","2","20","3","475"},
1:             });
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.customer, count(*) as orders_per_customer, " +
1:             "       sum(o.shipping) as shipping_per_customer, " +
1:             "       sum(d.items_per_order) as items_per_customer, " +
1:             "       sum(d.order_total) as total_per_customer " +
1:             " from orders o inner join (" +
1:             "   select order_id, count(*) as Items_per_order, " +
1:             "          sum(cost) as Order_total "+
1:             "    from order_items " +
1:             "    group by order_id " +
1:             "   ) d on o.order_id = d.order_id " +
1:             " group by ROLLUP(o.customer)"),
1:             new String[][]{
1:                 {"ABC","3","95","6","725"},
1:                 {"DEF","2","20","3","475"},
1:                 {null,"5","115","9","1200"},
1:             });
1:         // Include customer address information. First by joining and grouping:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select o.customer, c.name, c.city, c.state, " +
1:             "       count(*) as orders_per_customer, " +
1:             "       sum(o.shipping) as shipping_per_customer, " +
1:             "       sum(d.items_per_order) as items_per_customer, " +
1:             "       sum(d.order_total) as total_per_customer " +
1:             " from orders o inner join (" +
1:             "   select order_id, count(*) as Items_per_order, " +
1:             "          sum(cost) as Order_total "+
1:             "    from order_items " +
1:             "    group by order_id " +
1:             "   ) d on o.order_id = d.order_id " +
1:             "   inner join customers c on o.customer = c.customer " +
1:             " group by ROLLUP(o.customer,c.name, c.city,c.state)"),
1:             new String[][]{
1:                 {"ABC","ABC Corporation","ABC City","AB","3","95","6","725"},
1:                 {"DEF","DEF, Inc.","DEFburg","DE","2","20","3","475"},
1:                 {"ABC","ABC Corporation","ABC City",null,"3","95","6","725"},
1:                 {"DEF","DEF, Inc.","DEFburg",null,"2","20","3","475"},
1:                 {"ABC","ABC Corporation",null,null,"3","95","6","725"},
1:                 {"DEF","DEF, Inc.",null,null,"2","20","3","475"},
1:                 {"ABC",null,null,null,"3","95","6","725"},
1:                 {"DEF",null,null,null,"2","20","3","475"},
1:                 {null,null,null,null,"5","115","9","1200"},
1:             });
1:         // Then, alternately, by sub-selecting and grouping:
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select c.customer, c.name, c.city, c.state, " +
1:             "       o.orders_per_customer, o.shipping_per_customer, " +
1:             "       o.items_per_customer, o.total_per_customer " +
1:             " from ( " +
1:             "   select o.customer, count(*) as orders_per_customer, " +
1:             "          sum(o.shipping) as shipping_per_customer, " +
1:             "          sum(d.items_per_order) as items_per_customer, " +
1:             "          sum(d.order_total) as total_per_customer " +
1:             "    from orders o inner join (" +
1:             "      select order_id, count(*) as Items_per_order, " +
1:             "             sum(cost) as Order_total "+
1:             "       from order_items " +
1:             "       group by order_id " +
1:             "      ) d on o.order_id = d.order_id " +
1:             "    group by o.customer) o " +
1:             "  inner join customers c on o.customer = c.customer"),
1:             new String[][]{
1:                 {"ABC","ABC Corporation","ABC City","AB","3","95","6","725"},
1:                 {"DEF","DEF, Inc.","DEFburg","DE","2","20","3","475"},
1:             });
1:         // Note that we can put the ROLLUP in the sub-query, but then we
1:         // need to outer-join with the customers table since the rollup
1:         // results will have NULL in the join key.
1:         JDBC.assertUnorderedResultSet( s.executeQuery(
1:             "select c.customer, c.name, c.city, c.state, " +
1:             "       o.orders_per_customer, o.shipping_per_customer, " +
1:             "       o.items_per_customer, o.total_per_customer " +
1:             " from ( " +
1:             "   select o.customer, count(*) as orders_per_customer, " +
1:             "          sum(o.shipping) as shipping_per_customer, " +
1:             "          sum(d.items_per_order) as items_per_customer, " +
1:             "          sum(d.order_total) as total_per_customer " +
1:             "    from orders o inner join (" +
1:             "      select order_id, count(*) as Items_per_order, " +
1:             "             sum(cost) as Order_total "+
1:             "       from order_items " +
1:             "       group by order_id " +
1:             "      ) d on o.order_id = d.order_id " +
1:             "    group by ROLLUP(o.customer)) o " +
1:             "  left outer join customers c on o.customer = c.customer"),
1:             new String[][]{
1:                 {"ABC","ABC Corporation","ABC City","AB","3","95","6","725"},
1:                 {"DEF","DEF, Inc.","DEFburg","DE","2","20","3","475"},
1:                 {null,null,null,null,"5","115","9","1200"},
1:             });
1: 
1:         s.close();
1:     }
1: 
author:Army
-------------------------------------------------------------------------------
commit:411d1b7
/////////////////////////////////////////////////////////////////////////
1: 		/* A couple of distinct queries */
1: 		rs = s.executeQuery("select distinct row_number() over (), 'ABC' from t1");
1: 		expectedRows = new String[][]{{"1", "ABC"},
1: 										{"2", "ABC"},
1: 										{"3", "ABC"},
1: 										{"4", "ABC"},
1: 										{"5", "ABC"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
0: 		rs = s.executeQuery("select * from (select distinct row_number() over (), 'ABC' from t1) tmp");
1: 		expectedRows = new String[][]{{"1", "ABC"},
1: 										{"2", "ABC"},
1: 										{"3", "ABC"},
1: 										{"4", "ABC"},
1: 										{"5", "ABC"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
commit:c723732
/////////////////////////////////////////////////////////////////////////
1: 	public void testBasicOperations()
1: 		throws SQLException {
0: 		s.executeUpdate("create table t3 (y int)");
0: 		s.executeUpdate("create table t4 (a int, b int)");
0: 		s.executeUpdate("insert into t1 values (10,100),(20,200),(30,300),(40,400),(50,500)");
0: 		s.executeUpdate("insert into t3 values (4),(5),(6),(7),(8)");		
0: 		s.executeUpdate("insert into t4 values (10,100),(20,200)");
1: 
1: 		 *
1: 		 * Simple queries
1: 		 */		
1: 		ResultSet rs = s.executeQuery("select row_number() over (), t1.* from t1");
1: 		String[][] expectedRows = {{"1", "10", "100"}, {"2", "20", "200"}, {"3", "30", "300"}, {"4", "40", "400"}, {"5", "50", "500"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		rs = s.executeQuery("select row_number() over (), t1.* from t1 where a > 30");
1: 		expectedRows = new String[][]{{"1", "40", "400"}, {"2", "50", "500"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		rs = s.executeQuery("select row_number() over (), a from t1 where b > 300");
1: 		expectedRows = new String[][]{{"1", "40"}, {"2", "50"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		rs = s.executeQuery("select row_number() over () as r, a from t1 where b > 300");
1: 		expectedRows = new String[][]{{"1", "40"}, {"2", "50"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		/* Two instances of row_number columns in the same RCL */
1: 		rs = s.executeQuery("select row_number() over (), row_number() over (), b from t1 where b <= 300");
1: 		expectedRows = new String[][]{{"1", "1", "100"}, {"2", "2", "200"}, {"3", "3", "300"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		/* Two instances of row_number columns in the same RCL, reorder columns */
1: 		rs = s.executeQuery("select row_number() over (), b, row_number() over (), a from t1 where b < 300 ");
1: 		expectedRows = new String[][]{{"1", "100", "1", "10"}, {"2", "200", "2", "20"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		/* Pushing predicates (... where r ... ) too far cause this join to fail */
1: 		rs = s.executeQuery("select row_number() over(),x from t2,t3 where x=y");
1: 		expectedRows = new String[][]{{"1", "4"}, {"2", "5"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 		/* Ordering */
1: 		rs = s.executeQuery("select row_number() over () as r, t1.* from t1 order by b desc");
0: 		expectedRows = new String[][]{{"1", "50", "500"}, {"2", "40", "400"}, {"3", "30", "300"}, {"4", "20", "200"}, {"5", "10", "100"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 		/* Ordering on a column dropped in projection */
1: 		rs = s.executeQuery("select row_number() over () as r, t1.a from t1 order by b desc");
0: 		expectedRows = new String[][]{{"1", "50"}, {"2", "40"}, {"3", "30"}, {"4", "20"}, {"5", "10"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 		/* Only expressions in RCL */
1: 		rs = s.executeQuery("select row_number() over (), row_number() over (), 2*t1.a from t1");
1: 		expectedRows = new String[][]{{"1", "1", "20"}, {"2", "2","40"}, {"3", "3","60"}, {"4", "4", "80"}, {"5", "5", "100"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		/*
0: 		 * Subquerys 
1: 		 */ 
1: 			
1: 		/* This query returned no rows at one time */
1: 		rs = s.executeQuery("select * from (select row_number() over () as r,x from t2,t3 where x=y) s(r,x) where r < 3");
1: 		expectedRows = new String[][]{{"1", "4"}, {"2", "5"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		expectedRows = new String[][]{{"1", "10", "100"}, {"2", "20", "200"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		rs = s.executeQuery("select * from (select row_number() over () as r, t1.* from t1) as tr where r > 3");
1: 		expectedRows = new String[][]{{"4", "40", "400"}, {"5", "50", "500"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		/* Two instances of row_number columns */
1: 		rs = s.executeQuery("select row_number() over(), tr.* from (select row_number() over () as r, t1.* from t1) as tr where r > 2 and r < 5");
1: 		expectedRows = new String[][]{{"1", "3", "30", "300"}, {"2", "4", "40", "400"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 		/* Two instances of row_number columns, with projection */
1: 		rs = s.executeQuery("select row_number() over(), tr.b from (select row_number() over () as r, t1.* from t1) as tr where r > 2 and r < 5");
1: 		expectedRows = new String[][]{{"1", "300"}, {"2", "400"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);		
1: 
1: 		/* Column ordering */
1: 		rs = s.executeQuery("select * from (select t1.b, row_number() over () as r from t1) as tr where r > 3");
1: 		expectedRows = new String[][]{{"400", "4"}, {"500", "5"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 		/* Column ordering with projection*/
1: 		rs = s.executeQuery("select b from (select t1.b, row_number() over () as r from t1) as tr where r > 3");
1: 		expectedRows = new String[][]{{"400"}, {"500"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		/*
1: 		 * Aggregates over window functions once failed
1: 		 */
1: 		rs = s.executeQuery("select count(*) from (select row_number() over() from t1) x");
1: 		expectedRows = new String[][]{{"5"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 		rs = s.executeQuery("select count(*) from (select row_number() over () as r from t1) as t(r) where r <=3");
1: 		expectedRows = new String[][]{{"3"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		/*
1: 		 * Some other joins with window functions.
1: 		 * Run off a smaller table t4 to reduce expected row count.
1: 		 */
1: 		rs = s.executeQuery("select row_number() over () from t1 union all select row_number() over () from t1");
1: 		expectedRows = new String[][]{{"1"},{"2"},{"3"},{"4"},{"5"},{"1"},{"2"},{"3"},{"4"},{"5"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);	
1: 		
1: 		rs = s.executeQuery("select 2 * r from (select row_number() over () from t1) x(r)");
1: 		expectedRows = new String[][]{{"2"},{"4"},{"6"},{"8"},{"10"},};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		rs = s.executeQuery("select c3, c1, c2 from " + 
1: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), " +
1: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4)");
1: 		expectedRows = new String[][]{{"100", "10", "100"},
1: 										{"200", "10", "100"},																				
1: 										{"100", "20", "200"},
1: 										{"200", "20", "200"}};										
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 					
1: 		rs = s.executeQuery("select c3, c1, c2 from " + 
1: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), " +
1: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4), " +
1: 							"t4");
1: 		expectedRows = new String[][]{{"100", "10", "100"},
1: 										{"100", "10", "100"},																				
1: 										{"200", "10", "100"},
1: 										{"200", "10", "100"},
1: 										{"100", "20", "200"},
1: 										{"100", "20", "200"},
1: 										{"200", "20", "200"},										
1: 										{"200", "20", "200"}};										
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 		rs = s.executeQuery("select c3, c1, c2 from "+
1: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), "+
1: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4), "+
1: 							"t4 "+
1: 							"where x1.r1 = 2 * x2.r2");
1: 		expectedRows = new String[][]{{"100", "20", "200"}, {"100", "20", "200"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 
1: 		rs = s.executeQuery("select c3, c1, c2 from "+
1: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), "+
1: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4), "+
1: 							"t4 "+
1: 							"where x1.r1 = 2 * x2.r2");
1: 		expectedRows = new String[][]{{"100", "20", "200"}, {"100", "20", "200"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 				
1: 		/* Two problematic joins reported during development */
1: 		rs = s.executeQuery("select c3, c1, c2 from "+
1: 							"(select a, b, row_number() over() as r from t4) x1 (c1, c2, r1), "+
1: 							"(select row_number() over() as r, b, a from t4) x2 (r2, c3, c4), "+
1: 							"t4 "+
1: 							"where x2.c4 = t4.a");
1: 		expectedRows = new String[][]{{"100", "10", "100"}, 
1: 										{"100", "20", "200"},
1: 										{"200", "10", "100"},
1: 										{"200", "20", "200"}};			
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		rs = s.executeQuery("select c3, c1, c2 from "+
1: 							"(select a, b, row_number() over() as r from t1) x1 (c1, c2, r1), "+
1: 							"(select row_number() over() as r, b, a from t1) x2 (r2, c3, c4), "+
1: 							"t1 "+
1: 							"where x1.r1 = 2 * x2.r2 and x2.c4 = t1.a");
1: 		expectedRows = new String[][]{{"100", "20", "200"}, {"200", "40", "400"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 			
0: 		// Missing required OVER () 
0: 		assertStatementError("42X01", s, "select row_number() as r, * from t1 where t1.a > 2");
1: 
0: 		assertStatementError("42X04", s, "select row_number() over () as r, a from t1 where r < 3");
0: 		assertStatementError("42X01", s, "select row_number() over () as r, * from t1 where t1.a > 2");
0: 		s.executeUpdate("drop table t1");
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:3ecd206
/////////////////////////////////////////////////////////////////////////
1: 
0: 		/* Group by and having */
1: 		rs = s.executeQuery("select r from (select a, row_number() over() as r, b from t1) x group by r");
1: 		expectedRows = new String[][]{{"1"}, {"2"}, {"3"}, {"4"}, {"5"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		rs = s.executeQuery("select * from (select a, row_number() over() as r, b from t1) x group by a, b, r");
1: 		expectedRows = new String[][]{{"10", "1", "100"}, 
1: 										{"20", "2", "200"},
1: 										{"30", "3", "300"},
1: 										{"40", "4", "400"},
1: 										{"50", "5", "500"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		rs = s.executeQuery("select * from (select a, row_number() over() as r, b from t1) x group by b, r, a");
1: 		expectedRows = new String[][]{{"10", "1", "100"}, 
1: 										{"20", "2", "200"},
1: 										{"30", "3", "300"},
1: 										{"40", "4", "400"},
1: 										{"50", "5", "500"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		rs = s.executeQuery("select * from "+
1: 							"(select a, row_number() over() as r, b from t1) x "+
1: 							"group by b, r, a "+
1: 							"having r > 2");
1: 		expectedRows = new String[][]{{"30", "3", "300"},
1: 										{"40", "4", "400"}, 
1: 										{"50", "5", "500"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		rs = s.executeQuery("select * from "+
1: 							"(select a, row_number() over() as r, b from t1) x "+
1: 							"group by b, r, a "+
1: 							"having r > 2 and a >=30 "+
1: 							"order by a desc");
1: 		expectedRows = new String[][]{{"50", "5", "500"},
1: 										{"40", "4", "400"}, 
1: 										{"30", "3", "300"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		 
1: 		rs = s.executeQuery("select * from "+
1: 							"(select a, row_number() over() as r, b from t1) x "+
1: 							"group by b, r, a "+
1: 							"having r > 2 and a >=30 "+
1: 							"order by r desc");
1: 		expectedRows = new String[][]{{"50", "5", "500"},
1: 										{"40", "4", "400"}, 
1: 										{"30", "3", "300"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
1: 		rs = s.executeQuery("select * from "+
1: 							"(select a, row_number() over() as r, b from t1) x "+
1: 							"group by b, r, a "+
1: 							"having r > 2 and a >=30 "+
1: 							"order by a asc, r desc");
1: 		expectedRows = new String[][]{{"30", "3", "300"},
1: 										{"40", "4", "400"}, 
1: 										{"50", "5", "500"}};
1: 		JDBC.assertFullResultSet(rs, expectedRows);
1: 		
commit:1c5e43e
/////////////////////////////////////////////////////////////////////////
1: /**
1:  *  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.OLAPTest
1:  *  
1:  * Licensed to the Apache Software Foundation (ASF) under one
1:  * or more contributor license agreements.  See the NOTICE file
1:  * distributed with this work for additional information
1:  * regarding copyright ownership.  The ASF licenses this file
1:  * to you under the Apache License, Version 2.0 (the
1:  * "License"); you may not use this file except in compliance
1:  * with the License.  You may obtain a copy of the License at
1:  *
1:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:  * KIND, either express or implied.  See the License for the
1:  * specific language governing permissions and limitations
1:  * under the License.
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.Connection;
0: import java.sql.ResultSet;
0: import java.sql.SQLException;
0: import java.sql.Statement;
1: 
1: import junit.framework.Test;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
0:  * OLAP functionallity test.
1:  * 
1:  * Please refer to DERBY-581 for more details.
1:  */ 
1: public class OLAPTest extends BaseJDBCTestCase {
1: 
1: 	public OLAPTest(String name) {
1: 		super(name);    
1: 	}
1: 
1: 	/**
1: 	 * Main test body
1: 	 * 
1: 	 * @throws SQLException
1: 	 */
0: 	public void testBasicOperations() 
0: 		throws SQLException 
0: 	{   
0: 		Connection conn = getConnection();
0: 		Statement s = conn.createStatement();
1: 
0: 		s.executeUpdate("create table t1 (a int, b int)");
0: 		s.executeUpdate("create table t2 (x int)");
0: 		s.executeUpdate("create table t3 (y int)");      
1: 
0: 		s.executeUpdate("insert into t1 values (1,1),(2,2),(3,3),(4,4),(5,5)");
0: 		s.executeUpdate("insert into t2 values (1),(2),(3),(4),(5)");
0: 		s.executeUpdate("insert into t3 values (4),(5),(6),(7),(8)");
1: 		/*
1: 		 * Positive testing of Statements
1: 		 */
0: 		ResultSet rs = s.executeQuery("select row_number(), t1.* from t1");
0: 		String [][] expectedRows = {{"1","1","1"},{"2","2","2"},{"3","3","3"},{"4","4","4"},{"5","5","5"}};
0: 		JDBC.assertFullResultSet(rs,expectedRows);
1: 
0: 		rs = s.executeQuery("select row_number(), t1.* from t1 where a > 3");
0: 		expectedRows = new String [][] {{"1","4","4"},{"2","5","5"}};
0: 		JDBC.assertFullResultSet(rs,expectedRows);
1: 
0: 		rs = s.executeQuery("select row_number(), a from t1 where b > 3");
0: 		expectedRows = new String [] [] {{"1","4"},{"2","5"}};
0: 		JDBC.assertFullResultSet(rs,expectedRows);
1: 
0: 		rs = s.executeQuery("select row_number() as r, a from t1 where b > 3");
0: 		expectedRows = new String [] [] {{"1","4"},{"2","5"}};
0: 		JDBC.assertFullResultSet(rs,expectedRows);
1: 
0: 		rs = s.executeQuery("select * from (select row_number() as r, t1.* from t1) as tr where r < 3");
0: 		expectedRows = new String [] [] {{"1","1","1"},{"2","2","2"}};
0: 		JDBC.assertFullResultSet(rs,expectedRows);        
1: 
0: 		rs = s.executeQuery("select * from (select row_number() as r, t1.* from t1) as tr where r > 3");
0: 		expectedRows = new String [] [] {{"4","4","4"},{"5","5","5"}};
0: 		JDBC.assertFullResultSet(rs,expectedRows);        
1: 
1: 		rs = s.executeQuery("select * from (select row_number() over () as r, t1.* from t1) as tr where r < 3");
0: 		expectedRows = new String [] [] {{"1","1","1"},{"2","2","2"}};
0: 		JDBC.assertFullResultSet(rs,expectedRows);        
1: 
0: 		// Pushing predicates (... where r ... ) too far cause this join to fail 
0: 		rs = s.executeQuery("select row_number(),x from t2,t3 where x=y");
0: 		expectedRows = new String [] [] {{"1","4"},{"2","5"}};
0: 		JDBC.assertFullResultSet(rs,expectedRows);
1: 
1: 		/*
0: 		 * Negative testing of Statements
1: 		 */
1: 
0: 		// Illegal where clause, r not a named column of t1.        
0: 		assertStatementError("42X04",s,"select row_number() as r, a from t1 where r < 3");
1: 
0: 		// Illegal use of asterix with another column identifier.        
0: 		assertStatementError("42X01",s,"select row_number() as r, * from t1 where t1.a > 2");
1: 
1: 		/*
0: 		 * Clean up the tables used.
1: 		 */
0: 		s.executeUpdate("drop table t1");        
0: 		s.executeUpdate("drop table t2");
0: 		s.executeUpdate("drop table t3");
1: 	}
1: 
0: 	public static Test suite() {
0: 		Test suite = TestConfiguration.defaultSuite(OLAPTest.class);
0: 		return DatabasePropertyTestSetup.setLockTimeouts(suite,3,3);
1: 	}
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:25e562c
/////////////////////////////////////////////////////////////////////////
1:  * OLAP functionality test.
commit:1f2a256
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		Statement s = createStatement();
/////////////////////////////////////////////////////////////////////////
0: 
0: 		s.close();
0: 		return TestConfiguration.defaultSuite(OLAPTest.class);
============================================================================