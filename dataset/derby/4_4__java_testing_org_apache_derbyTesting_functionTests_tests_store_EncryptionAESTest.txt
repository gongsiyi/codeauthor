1:acdbf5a: /*
1:acdbf5a:  *
1:9d7aba6:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.EncryptionAESTest
1:acdbf5a:  *
1:acdbf5a:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:acdbf5a:  * contributor license agreements.  See the NOTICE file distributed with
1:acdbf5a:  * this work for additional information regarding copyright ownership.
1:acdbf5a:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:acdbf5a:  * (the "License"); you may not use this file except in compliance with
1:acdbf5a:  * the License.  You may obtain a copy of the License at
1:acdbf5a:  *
1:acdbf5a:  *    http://www.apache.org/licenses/LICENSE-2.0
1:acdbf5a:  *
1:acdbf5a:  * Unless required by applicable law or agreed to in writing,
1:acdbf5a:  * software distributed under the License is distributed on an
1:acdbf5a:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:acdbf5a:  * either express or implied. See the License for the specific
1:acdbf5a:  * language governing permissions and limitations under the License.
1:acdbf5a:  */
1:acdbf5a: package org.apache.derbyTesting.functionTests.tests.store;
6:acdbf5a: 
1:acdbf5a: import java.io.File;
1:acdbf5a: import java.sql.Connection;
1:acdbf5a: import java.sql.DriverManager;
1:acdbf5a: import java.sql.PreparedStatement;
1:acdbf5a: import java.sql.ResultSet;
1:acdbf5a: import java.sql.SQLException;
1:acdbf5a: import java.sql.SQLWarning;
1:1ae02c9: import java.sql.Statement;
1:acdbf5a: import javax.sql.DataSource;
1:acdbf5a: import junit.framework.Test;
1:3f5c48a: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:acdbf5a: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:acdbf5a: import org.apache.derbyTesting.junit.JDBC;
1:acdbf5a: import org.apache.derbyTesting.junit.JDBCDataSource;
1:acdbf5a: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:acdbf5a: import org.apache.derbyTesting.junit.TestConfiguration;
1:acdbf5a: 
1:acdbf5a: /**
1:acdbf5a:  * <p>
1:acdbf5a:  * Tests various connection sequences to further test AES encrypted databases.
1:acdbf5a:  * 
1:acdbf5a:  * Top level testcases grp.
1:acdbf5a:  * <ol>
1:acdbf5a:  * <li>Case 1.x	different feedback modes (valid - CBC,ECB,OFB,unsupported - ABC)
1:acdbf5a:             2 cases for each - creating db and recovery mode
1:acdbf5a:  * <li>Case 2.x	padding ( unsupported padding )
1:acdbf5a:  * <li>Case 3.x	key lengths with bootpassword
1:acdbf5a:        case of 128 bits, 192 bits and 256 bits and unsupported 512 bits
1:acdbf5a:        mismatch keylengths (case of one keylength during creation and another 
1:acdbf5a:        during connecting)
1:acdbf5a:  * <li>Case 4.x	case of changing boot password 
1:acdbf5a:  *     ( covered by old harness test - store/encryptDatabase.sql)
1:acdbf5a:  *     Also see store/access.sql for other cases run with AES encryption
1:acdbf5a:  * <li>Case 5.x	give external encryptionKey instead of bootpassword
1:acdbf5a:  *     Not converted from original old harness test (aes.sql), for also 
1:acdbf5a:  *     covered in junit test EncryptionKeyAESTest.
1:acdbf5a:  * <p>
1:acdbf5a:  */
1:acdbf5a: //@NotThreadSafe
1:acdbf5a: public class EncryptionAESTest
1:acdbf5a: extends BaseJDBCTestCase {
1:acdbf5a: 
1:acdbf5a:     /** Table holding the test data. */
1:acdbf5a:     private static final String TABLE = "encryptionkeytestdata";
1:acdbf5a:     /** Test data inserted into database and used for verification. */
1:acdbf5a:     private static final int[] DATA = {9,4,2,34,6543,3,123,434,5436,-123,0,123};
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * Variable to hold the various connections.
1:acdbf5a:      * No guarantee is made about the state of this connection, but it is
1:acdbf5a:      * closed at tear-down.
1:acdbf5a:      */
1:acdbf5a: //    private Connection con = null;
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * Configures a new setup by specifying the encryption properties.
1:acdbf5a:      */
1:acdbf5a:     public EncryptionAESTest(String name) {
1:acdbf5a:         super(name);
4:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * Clean up the connection maintained by this test.
1:acdbf5a:      */
1:acdbf5a: /*    protected void tearDown()
1:acdbf5a:     throws java.lang.Exception {
1:acdbf5a:         if (con != null && !con.isClosed()) {
1:acdbf5a:             con.rollback();
1:acdbf5a:             con.close();
1:acdbf5a:             con = null;
1:acdbf5a:         }
1:acdbf5a:         super.tearDown();
1:acdbf5a:     }
1:acdbf5a: */
1:acdbf5a:     
1:acdbf5a:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Encryption AES suite");
1:acdbf5a:         // we're using SupportFilesSetup so the created databases will get 
1:acdbf5a:         // removed. Databases get created in subdirectory EXTINOUT.
1:acdbf5a:         // However, this only happens after the test is finished, so we
1:acdbf5a:         // can't run both embedded and networkserver for the database
1:acdbf5a:         // wouldn't get created with networkserver.
1:acdbf5a:         suite.addTest(
1:acdbf5a:             TestConfiguration.embeddedSuite(EncryptionAESTest.class));
1:acdbf5a:         return new SupportFilesSetup(suite);
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * Case 1.x
1:acdbf5a:      * Test connection attempts for 5 different feedback modes:
1:acdbf5a:      * valid/supported: CBC(case 1.1), ECB(case 1.2), OFB(case 1.3), CFB(case 1.4)
1:acdbf5a:      * unsupported:     ABC(case 1.5)
1:acdbf5a:      */
1:acdbf5a:     public void testFeedbackModes() throws SQLException {
1:acdbf5a:         String[] feedbackModes = {"CBC", "ECB", "OFB", "CFB", "ABC"};
1:acdbf5a:         for (int i=0 ; i<feedbackModes.length ; i++)
2:acdbf5a:         {
1:acdbf5a:             runTestFeedbackModes(feedbackModes[i]);
1:acdbf5a:         }
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * test connection attempts for a passed in feedback mode:
1:acdbf5a:      * Connect-and-Create(test case 1.*.1, shutdown, reconnect(1.*.2).
1:acdbf5a:      */
1:acdbf5a:     protected void runTestFeedbackModes(String feedbackMode)
1:acdbf5a:     throws SQLException {
1:acdbf5a:         String dbName = "encryptedDB_Feedback" + feedbackMode;
1:acdbf5a:         // Create database.
1:acdbf5a:         String encryptionAlgorithm = "AES/" + feedbackMode + "/NoPadding";
1:acdbf5a:         String[] bootPassword = {"bootPassword=Thursday"};
1:acdbf5a:         if (feedbackMode=="ABC")
1:acdbf5a:         {
1:acdbf5a:             // expect unsupported feedbackMode error
1:acdbf5a:             assertNoDBCreated("XBCXI", dbName, encryptionAlgorithm, bootPassword);
1:acdbf5a:             return;
1:acdbf5a:         }
1:acdbf5a:         Connection con = createAndPopulateDB(dbName, encryptionAlgorithm, bootPassword );
1:acdbf5a:         validateDBContents(con);
2:acdbf5a:         // Shutdown the database.
1:acdbf5a:         con.close();
1:9d7aba6:         shutdown(dbName);
1:acdbf5a:         // Reconnect using correct key.
1:acdbf5a:         con = getConnection(dbName, encryptionAlgorithm, bootPassword);
1:acdbf5a:         validateDBContents(con);
1:acdbf5a:         con.close();
1:acdbf5a:         // Shutdown the database.
5:acdbf5a:         shutdown(dbName);
1:acdbf5a:     }
1:acdbf5a:     
1:acdbf5a:     /**
1:acdbf5a:      * Case 2.1 - Unsupported padding mode
1:acdbf5a:      */
1:acdbf5a:     public void testUnsupportedPadding() throws SQLException {
1:acdbf5a:         assertNoDBCreated("XBCXB", "badPadDB", "AES/ECB/PKCS5Padding", 
1:acdbf5a:             new String[] {"bootPassword=Thursday"});
1:acdbf5a:     }
1:acdbf5a:     
1:acdbf5a:     /**
1:acdbf5a:      * Case 3.x
1:acdbf5a:      * Test connection attempts for 4 different keyLength values:
1:acdbf5a:      * valid/supported: 128(case 3.1), 192(case 3.2), 256(case 3.3)
1:acdbf5a:      * Create-and-connect is test case 3.*.1, reconnection 3.*.2.
1:acdbf5a:      * unsupported:     512(case 3.5)
1:acdbf5a:      * Also test creating the database with one length, then attempt
1:acdbf5a:      * to reconnect with another encryptionKeyLength value (case 3.4.)
1:acdbf5a:      * Connections with encryptionKeyLength 192 or 256 require an unrestricted
1:acdbf5a:      * encryption policy, which may not be available on all machines, so
1:acdbf5a:      * we need to handle that situation.
1:acdbf5a:      */
1:acdbf5a:     public void testEncryptionKeyLengths() throws SQLException {
1:acdbf5a:         String[] encryptionKeyLengths = {"128", "192", "256"};
1:acdbf5a:         for (int i=0 ; i<encryptionKeyLengths.length ; i++)
1:acdbf5a:         {
1:acdbf5a:             runTestEncryptionKeyLengths(encryptionKeyLengths[i]);
1:acdbf5a:         }
1:acdbf5a:         // case 3.5 - bad key length
1:acdbf5a:         assertNoDBCreated("XJ001", "badKeyLengthDB", "AES/ECB/NoPadding", 
1:acdbf5a:             new String[] {"encryptionKeyLength=512", "bootPassword=Thursday"});
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * test connection attempts for a passed in feedback mode:
1:acdbf5a:      * does most of the work for fixture testEncryptionKeyLength
1:acdbf5a:      * Connect-and-Create(test case 1.*.1, shutdown, reconnect(1.*.2).
1:acdbf5a:      */
1:acdbf5a:     protected void runTestEncryptionKeyLengths(
1:acdbf5a:             String encryptionKeyLength)
1:acdbf5a:     throws SQLException {
1:acdbf5a:         String dbName = "encrKeyLength" + encryptionKeyLength + "DB";
1:acdbf5a:         // Create database.
1:acdbf5a:         String encryptionAlgorithm = "AES/CBC/NoPadding";
1:acdbf5a:         String[] attributes = 
2:acdbf5a:             {("encryptionKeyLength=" + encryptionKeyLength),
2:acdbf5a:              "bootPassword=Thursday"};
1:acdbf5a:         Connection con = createAndPopulateDB(dbName, encryptionAlgorithm, attributes );
1:acdbf5a:         // If we didn't get a connection and the test did not stop because 
1:acdbf5a:         // of a failure, the policy jars in the jvm must be restrictive.
1:acdbf5a:         // Pop a message to the console and only test encryptionKeyLength 128.
1:acdbf5a:         if (con == null)
1:acdbf5a:         {
1:d49612c:             if (TestConfiguration.getCurrent().doTrace())
1:d49612c:                 System.out.println("no unrestricted policy jars; cannot test AES " +
1:d49612c:                     "encryption with encryptionKeyLengths 192 nor 256");
1:acdbf5a:             return;
1:acdbf5a:         }
1:acdbf5a:         validateDBContents(con);
1:acdbf5a:         // Shutdown the database.
1:acdbf5a:         con.close();
1:acdbf5a:         shutdown(dbName);
1:acdbf5a:         // Reconnect using correct key length.
1:acdbf5a:         con = getConnection(dbName, encryptionAlgorithm, attributes);
1:acdbf5a:         validateDBContents(con);
1:acdbf5a:         con.close();
1:acdbf5a:         // just for fun, try this with a DriverManager connection
1:acdbf5a:         con = getDriverManagerConnection(dbName, encryptionAlgorithm, attributes);
1:acdbf5a:         validateDBContents(con);
1:acdbf5a:         con.close();
1:9d7aba6:         shutdown(dbName);
1:acdbf5a:         String[] keyLengths = {"128", "192", "256", "512"};
1:acdbf5a:         for (int i=0 ; i < keyLengths.length ; i++) {
1:acdbf5a:             if (!encryptionKeyLength.equals(keyLengths[i])){
2:acdbf5a:                 attributes = new String[] 
1:acdbf5a:                    {("encryptionKeyLength=" + keyLengths[i]),
1:acdbf5a:                      "bootPassword=Thursday"};
1:acdbf5a:                 // Reconnect using a valid, but different key length
1:acdbf5a:                 runMismatchKeyLength(dbName, encryptionAlgorithm,
1:acdbf5a:                     encryptionKeyLength, attributes);
1:acdbf5a:             }
1:acdbf5a:         }
1:9d7aba6: 
1:9d7aba6:         // now try re-encrypting with a different boot password
1:9d7aba6:         attributes = new String[]
1:9d7aba6:             {
1:9d7aba6:                 ("encryptionKeyLength=" + encryptionKeyLength),
1:9d7aba6:                 "bootPassword=Thursday",
1:9d7aba6:                 "newBootPassword=Saturday"
1:9d7aba6:             };
1:9d7aba6:         con = getDriverManagerConnection(dbName, encryptionAlgorithm, attributes);
1:9d7aba6:         validateDBContents(con);
1:9d7aba6:         con.close();
1:9d7aba6:         shutdown(dbName);
1:9d7aba6: 
1:9d7aba6:         // reconnect to make sure we don't have another variant of DERBY-3710
1:9d7aba6:         attributes = new String[]
1:9d7aba6:             {
1:9d7aba6:                 ("encryptionKeyLength=" + encryptionKeyLength),
1:9d7aba6:                 "bootPassword=Saturday"
1:9d7aba6:             };
1:9d7aba6:         con = getDriverManagerConnection(dbName, encryptionAlgorithm, attributes);
1:9d7aba6:         validateDBContents(con);
1:9d7aba6:         con.close();
1:9d7aba6:         shutdown(dbName);
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * attempt to connect and verify the SQLState if it's expected to fail
1:acdbf5a:      * does the last bit of work for fixture testEncryptionKeyLength
1:acdbf5a:      */
1:acdbf5a:     public void runMismatchKeyLength(String dbName, String encryptionAlgorithm,
1:acdbf5a:             String encryptionKeyLength, String[] attributes) throws SQLException {
1:acdbf5a:         Connection con = null;
1:acdbf5a:         // try connecting
1:acdbf5a:         // all combinations work - (if unrestricted policy jars are
1:9d7aba6:         // in place)
1:acdbf5a:         try {
1:acdbf5a:             con = getConnection(dbName, encryptionAlgorithm, attributes );
1:acdbf5a:             validateDBContents(con);
1:acdbf5a:             con.close();
1:9d7aba6:             shutdown(dbName);
1:acdbf5a:         } catch (SQLException e) {
1:acdbf5a:             e.printStackTrace();
1:acdbf5a:             con.close();
1:acdbf5a:             shutdown(dbName);
1:acdbf5a:             assertSQLState("XBM06", e);
1:acdbf5a:         }
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /* ********************************************************************* *
1:acdbf5a:      *                     H E L P E R  M E T H O D S                        *
1:acdbf5a:      * ********************************************************************* */
1:acdbf5a: 
1:acdbf5a:     
1:acdbf5a:     /**
1:acdbf5a:      * Obtain absolute path for the specified database name.
1:acdbf5a:      * <p>
1:acdbf5a:      * This absolute path is the name of the database (specified) prefixed with
1:acdbf5a:      * the absolute path to the EXTINOUT directory. The latter is determined by
1:acdbf5a:      * consulting <code>SupportFilesSetup</code>.
1:acdbf5a:      *
1:acdbf5a:      * @param dbName name of the database
1:acdbf5a:      * Note that the database name will be prefixed
1:acdbf5a:      *      with the path to the EXTINOUT directory
1:acdbf5a:      * @return A string with the absolute path to the database.
1:acdbf5a:      * @see SupportFilesSetup
1:acdbf5a:      */
1:acdbf5a:     private String obtainDbName(String dbName) {
1:acdbf5a:         File tmp = new File(dbName);
1:3f5c48a:         return PrivilegedFileOpsForTests.getAbsolutePath(
1:3f5c48a:                 new File(SupportFilesSetup.EXTINOUT, tmp.getPath()));
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * Attempt to create a new database and expect a failure.
1:acdbf5a:      * <p>
1:acdbf5a:      * The method expects a failure
1:acdbf5a:      * This is because it is the creation process that is to be tested.
1:acdbf5a:      *
1:acdbf5a:      * @param expectedSQLState SQLState for the expected error
1:acdbf5a:      * @param dbName name of the database attempted to create
1:acdbf5a:      * @param algorithm EncryptionAlgorithm
1:acdbf5a:      * @param otherAttributes array for all other attributes 
1:acdbf5a:      *        (Note: dataEncryption=true is already set in getConnection) 
1:acdbf5a:      * @throws SQLException if the database already exist, or
1:acdbf5a:      *      a general error happens during database interaction
1:acdbf5a:      */
1:acdbf5a:     protected void assertNoDBCreated(String expectedSQLState,
1:acdbf5a:         String dbName, String algorithm, String[] otherAttributes)
1:acdbf5a:     throws SQLException {
1:acdbf5a:         try {
1:acdbf5a:             getConnection(dbName, algorithm, otherAttributes );
1:acdbf5a:             fail ("expected error message re unsupported functionality");
1:acdbf5a:         } catch (SQLException e) {
1:acdbf5a:             assertSQLState(expectedSQLState, e);
1:acdbf5a:         }
1:acdbf5a:     }
1:acdbf5a:     
1:acdbf5a:     /**
1:acdbf5a:      * Create a new database and populate it.
1:acdbf5a:      * <p>
1:acdbf5a:      * The method fails with an exception if the database already exists.
1:acdbf5a:      * This is because it is the creation process that is to be tested.
1:acdbf5a:      *
1:acdbf5a:      * @param dbName name of the database to create
1:acdbf5a:      * @param algorithm EncryptionAlgorithm
1:acdbf5a:      * @param otherAttributes array for all other attributes 
1:acdbf5a:      *        (Note: dataEncryption=true is already set in getConnection) 
1:acdbf5a:      * @return A connection the to the newly created database.
1:acdbf5a:      * @throws SQLException if the database already exist, or
1:acdbf5a:      *      a general error happens during database interaction
1:acdbf5a:      */
1:acdbf5a:     protected Connection createAndPopulateDB(
1:acdbf5a:         String dbName, String algorithm, String[] otherAttributes)
1:acdbf5a:     throws SQLException {
1:acdbf5a:         try {
1:acdbf5a:             Connection con = getConnection(dbName, algorithm, otherAttributes);
1:acdbf5a:             SQLWarning warning = con.getWarnings();
1:acdbf5a:             // If the database already exists, fail the test.
1:acdbf5a:             if (warning != null) {
1:acdbf5a:                 if ("01J01".equals(warning.getSQLState())) {
1:acdbf5a:                     fail("Refusing to continue, database already exists <" +
1:acdbf5a:                         warning.getMessage() + ">");
1:acdbf5a:                 }
1:acdbf5a:             }
1:acdbf5a:             Statement stmt = con.createStatement();
1:acdbf5a:             stmt.executeUpdate("CREATE TABLE " + TABLE + " (id int NOT NULL, " +
1:acdbf5a:             "val int NOT NULL, PRIMARY KEY(id))");
1:acdbf5a:             stmt.close();
1:acdbf5a:             PreparedStatement ps = con.prepareStatement("INSERT INTO " + TABLE +
1:acdbf5a:             " (id, val) VALUES (?,?)");
1:acdbf5a:             for (int i=0; i < DATA.length; i++) {
1:acdbf5a:                 ps.setInt(1, i);
1:acdbf5a:                 ps.setInt(2, DATA[i]);
1:acdbf5a:                 ps.executeUpdate();
1:acdbf5a:             }
1:acdbf5a:             ps.close();
1:acdbf5a:             return con;
1:acdbf5a:         }
1:acdbf5a:         catch (SQLException e) {
1:acdbf5a:             // if it fails, it should only be because of non-existing
1:acdbf5a:             // support for unrestricted encryption policy.
1:acdbf5a:             assertSQLState("XJ001", e);
1:acdbf5a:             return null;
1:acdbf5a:         }
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * Create a new connection to the specified database, using the given
1:acdbf5a:      * connection attributes.
1:acdbf5a:      *
1:acdbf5a:      * @param dbName name of the database
1:acdbf5a:      * @param algorithm EncryptionAlgorithm
1:acdbf5a:      * @param otherAttributes array for all other attributes 
1:acdbf5a:      *        (Note: dataEncryption=true is already set in this method) 
1:acdbf5a:      * @return A connection to the database.
1:acdbf5a:      * @throws SQLException if connection fails
1:acdbf5a:      */
1:acdbf5a:     private Connection getConnection(String dbName,
1:acdbf5a:             String algorithm,
1:acdbf5a:             String[] otherAttributes)
1:acdbf5a:     throws SQLException {
1:acdbf5a:         DataSource ds = JDBCDataSource.getDataSource(obtainDbName(dbName));
1:acdbf5a:         StringBuffer str = new StringBuffer(75);
1:acdbf5a:         // Enable data encryption and mark for creation
1:acdbf5a:         // (will connect to existing db if already exists.)
1:acdbf5a:         JDBCDataSource.setBeanProperty(ds, "CreateDatabase", "create");
1:acdbf5a:         str.append("dataEncryption=true;");
1:acdbf5a:         // Add the encryption algorithm.
1:acdbf5a:         str.append("encryptionAlgorithm=");
1:acdbf5a:         str.append(algorithm);
1:acdbf5a:         str.append(";");
1:acdbf5a:         // Add whatever else is being passed in.
1:acdbf5a:         for (int i=0 ; i < otherAttributes.length ; i++) {
1:acdbf5a:             str.append(otherAttributes[i]);
1:acdbf5a:             str.append(";");
1:acdbf5a:         }
1:acdbf5a:         JDBCDataSource.setBeanProperty(
1:acdbf5a:                 ds, "connectionAttributes", str.toString());
1:acdbf5a:         return ds.getConnection();
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     // does the same thing as getConnection, but uses DriverManager
1:acdbf5a:     // temp method to see if this worked for encryptionKeyLength
1:acdbf5a:     // test. But no...
1:acdbf5a:     private Connection getDriverManagerConnection(String dbName,
1:acdbf5a:             String algorithm,
1:acdbf5a:             String[] otherAttributes)
1:acdbf5a:     throws SQLException {
1:acdbf5a:         String url = TestConfiguration.getCurrent().getJDBCUrl(obtainDbName(dbName));
1:acdbf5a:         url = url + ";create=true;dataEncryption=true;encryptionAlgorithm=" +
1:acdbf5a:             algorithm + ";";
1:acdbf5a:         for (int i=0 ; i < otherAttributes.length ; i++) {
1:acdbf5a:             url = url + otherAttributes[i] + ";";
1:acdbf5a:         }
1:acdbf5a:         // as we're only using SupportingFilesSetup, not default,
1:acdbf5a:         // we need to explicitly load the driver.
1:acdbf5a:         String driver =
1:acdbf5a:             getTestConfiguration().getJDBCClient().getJDBCDriverName();
1:acdbf5a:         try {
1:4469400:             Class<?> clazz = Class.forName(driver);
1:4469400:             clazz.getConstructor().newInstance();
1:acdbf5a:         } catch (ClassNotFoundException cnfe) {
1:acdbf5a:             fail("\nUnable to load the JDBC driver " + driver);
1:acdbf5a:         } catch (InstantiationException ie) {
1:acdbf5a:             fail("\nUnable to instantiate the JDBC driver " + driver);
1:acdbf5a:         } catch (IllegalAccessException iae) {
1:acdbf5a:             fail("\nNot allowed to access the JDBC driver " + driver);
1:4469400:         } catch (NoSuchMethodException iae) {
1:4469400:             fail("\nNo such constructor for the JDBC driver " + driver);
1:4469400:         } catch (java.lang.reflect.InvocationTargetException iae) {
1:4469400:             fail("\nCannot invoke the constructor for the the JDBC driver " + driver);
1:acdbf5a:         }
1:acdbf5a:         Connection conn = DriverManager.getConnection(url);
1:acdbf5a:         return conn;
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * Shutdown the specified database.
1:acdbf5a:      *
1:acdbf5a:      * @throws SQLException if fails
1:acdbf5a:      * @param databaseName the name of the database
1:acdbf5a:      */
1:acdbf5a:     protected void shutdown(String databaseName)
1:acdbf5a:     throws SQLException {
1:acdbf5a:         DataSource ds = JDBCDataSource.getDataSource(obtainDbName(databaseName));
1:acdbf5a:         JDBCDataSource.shutdownDatabase(ds);
1:acdbf5a:     }
1:acdbf5a: 
1:acdbf5a:     /**
1:acdbf5a:      * Validate the data in the database against the data model.
1:acdbf5a:      *
1:acdbf5a:      * @param con the database to validate the contents of
1:acdbf5a:      * @throws junit.framework.AssertionFailedError if there is a mismatch
1:acdbf5a:      *      between the data in the database and the model
1:acdbf5a:      */
1:acdbf5a:     protected void validateDBContents(Connection con)
1:acdbf5a:     throws SQLException {
1:acdbf5a:         Statement stmt = con.createStatement();
1:acdbf5a:         ResultSet rs = stmt.executeQuery("SELECT id, val FROM " + TABLE +
1:acdbf5a:         " ORDER BY id");
1:acdbf5a:         JDBC.assertFullResultSet(rs, new String[][] {
1:acdbf5a:                 {"0","9"},
1:acdbf5a:                 {"1","4"},
1:acdbf5a:                 {"2","2"},
1:acdbf5a:                 {"3","34"},
1:acdbf5a:                 {"4","6543"},
1:acdbf5a:                 {"5","3"},
1:acdbf5a:                 {"6","123"},
1:acdbf5a:                 {"7","434"},
1:acdbf5a:                 {"8","5436"},
1:acdbf5a:                 {"9","-123"},
1:acdbf5a:                 {"10","0"},
1:acdbf5a:                 {"11","123"}});
1:acdbf5a:         //Utilities.showResultSet(rs);
1:acdbf5a:         /* 
1:acdbf5a:         int id, val;
1:acdbf5a:         while (rs.next()) {
1:acdbf5a:             id = rs.getInt(1);
1:acdbf5a:             val = rs.getInt(2);
1:acdbf5a:             if (id >= DATA.length) {
1:acdbf5a:                 fail("Id in database out of bounds for data model; " +
1:acdbf5a:                         id + " >= " + DATA.length);
1:acdbf5a:             }
1:acdbf5a:             if (val != DATA[id]) {
1:acdbf5a:                 fail("Mismatch between db and model for id " + id + ";" +
1:acdbf5a:                         val + " != " + DATA[id]);
1:acdbf5a:             }
1:acdbf5a:         }
1:acdbf5a:         */
1:acdbf5a:         rs.close();
1:acdbf5a:         stmt.close();
1:acdbf5a:     }
1:acdbf5a: } // End EncryptionAESTest
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:             Class<?> clazz = Class.forName(driver);
1:             clazz.getConstructor().newInstance();
1:         } catch (NoSuchMethodException iae) {
1:             fail("\nNo such constructor for the JDBC driver " + driver);
1:         } catch (java.lang.reflect.InvocationTargetException iae) {
1:             fail("\nCannot invoke the constructor for the the JDBC driver " + driver);
commit:9d7aba6
/////////////////////////////////////////////////////////////////////////
1:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.EncryptionAESTest
/////////////////////////////////////////////////////////////////////////
1:         shutdown(dbName);
/////////////////////////////////////////////////////////////////////////
1:         shutdown(dbName);
/////////////////////////////////////////////////////////////////////////
1: 
1:         // now try re-encrypting with a different boot password
1:         attributes = new String[]
1:             {
1:                 ("encryptionKeyLength=" + encryptionKeyLength),
1:                 "bootPassword=Thursday",
1:                 "newBootPassword=Saturday"
1:             };
1:         con = getDriverManagerConnection(dbName, encryptionAlgorithm, attributes);
1:         validateDBContents(con);
1:         con.close();
1:         shutdown(dbName);
1: 
1:         // reconnect to make sure we don't have another variant of DERBY-3710
1:         attributes = new String[]
1:             {
1:                 ("encryptionKeyLength=" + encryptionKeyLength),
1:                 "bootPassword=Saturday"
1:             };
1:         con = getDriverManagerConnection(dbName, encryptionAlgorithm, attributes);
1:         validateDBContents(con);
1:         con.close();
1:         shutdown(dbName);
/////////////////////////////////////////////////////////////////////////
1:         // in place)
1:             shutdown(dbName);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Encryption AES suite");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
/////////////////////////////////////////////////////////////////////////
1:         return PrivilegedFileOpsForTests.getAbsolutePath(
1:                 new File(SupportFilesSetup.EXTINOUT, tmp.getPath()));
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:d49612c
/////////////////////////////////////////////////////////////////////////
1:             if (TestConfiguration.getCurrent().doTrace())
1:                 System.out.println("no unrestricted policy jars; cannot test AES " +
1:                     "encryption with encryptionKeyLengths 192 nor 256");
commit:acdbf5a
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
0:  * Derby - Class org.apache.derbyTesting.functionTests.tests.store.EncryptionKeyTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
1: import java.io.File;
1: 
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.Statement;
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: 
1: import javax.sql.DataSource;
1: 
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
0: import java.security.PrivilegedActionException;
0: import java.security.PrivilegedExceptionAction;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.JDBCClient;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: import org.apache.derbyTesting.junit.Utilities;
1: 
1: /**
1:  * <p>
1:  * Tests various connection sequences to further test AES encrypted databases.
1:  * 
1:  * Top level testcases grp.
1:  * <ol>
1:  * <li>Case 1.x	different feedback modes (valid - CBC,ECB,OFB,unsupported - ABC)
1:             2 cases for each - creating db and recovery mode
1:  * <li>Case 2.x	padding ( unsupported padding )
1:  * <li>Case 3.x	key lengths with bootpassword
1:        case of 128 bits, 192 bits and 256 bits and unsupported 512 bits
1:        mismatch keylengths (case of one keylength during creation and another 
1:        during connecting)
1:  * <li>Case 4.x	case of changing boot password 
1:  *     ( covered by old harness test - store/encryptDatabase.sql)
1:  *     Also see store/access.sql for other cases run with AES encryption
1:  * <li>Case 5.x	give external encryptionKey instead of bootpassword
1:  *     Not converted from original old harness test (aes.sql), for also 
1:  *     covered in junit test EncryptionKeyAESTest.
1:  * <p>
1:  */
1: //@NotThreadSafe
1: public class EncryptionAESTest
1: extends BaseJDBCTestCase {
1: 
1:     /** Table holding the test data. */
1:     private static final String TABLE = "encryptionkeytestdata";
1:     /** Test data inserted into database and used for verification. */
1:     private static final int[] DATA = {9,4,2,34,6543,3,123,434,5436,-123,0,123};
1: 
1:     /**
1:      * Variable to hold the various connections.
1:      * No guarantee is made about the state of this connection, but it is
1:      * closed at tear-down.
1:      */
1: //    private Connection con = null;
1: 
1:     /**
1:      * Configures a new setup by specifying the encryption properties.
1:      */
1:     public EncryptionAESTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Clean up the connection maintained by this test.
1:      */
1: /*    protected void tearDown()
1:     throws java.lang.Exception {
1:         if (con != null && !con.isClosed()) {
1:             con.rollback();
1:             con.close();
1:             con = null;
1:         }
1:         super.tearDown();
1:     }
1: */
1:     
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("Encryption AES suite");
1:         // we're using SupportFilesSetup so the created databases will get 
1:         // removed. Databases get created in subdirectory EXTINOUT.
1:         // However, this only happens after the test is finished, so we
1:         // can't run both embedded and networkserver for the database
1:         // wouldn't get created with networkserver.
1:         suite.addTest(
1:             TestConfiguration.embeddedSuite(EncryptionAESTest.class));
1:         return new SupportFilesSetup(suite);
1:     }
1: 
1:     /**
1:      * Case 1.x
1:      * Test connection attempts for 5 different feedback modes:
1:      * valid/supported: CBC(case 1.1), ECB(case 1.2), OFB(case 1.3), CFB(case 1.4)
1:      * unsupported:     ABC(case 1.5)
1:      */
1:     public void testFeedbackModes() throws SQLException {
1:         String[] feedbackModes = {"CBC", "ECB", "OFB", "CFB", "ABC"};
1:         for (int i=0 ; i<feedbackModes.length ; i++)
1:         {
1:             runTestFeedbackModes(feedbackModes[i]);
1:         }
1:     }
1: 
1:     /**
1:      * test connection attempts for a passed in feedback mode:
1:      * Connect-and-Create(test case 1.*.1, shutdown, reconnect(1.*.2).
1:      */
1:     protected void runTestFeedbackModes(String feedbackMode)
1:     throws SQLException {
1:         String dbName = "encryptedDB_Feedback" + feedbackMode;
1:         // Create database.
1:         String encryptionAlgorithm = "AES/" + feedbackMode + "/NoPadding";
1:         String[] bootPassword = {"bootPassword=Thursday"};
1:         if (feedbackMode=="ABC")
1:         {
1:             // expect unsupported feedbackMode error
1:             assertNoDBCreated("XBCXI", dbName, encryptionAlgorithm, bootPassword);
1:             return;
1:         }
1:         Connection con = createAndPopulateDB(dbName, encryptionAlgorithm, bootPassword );
1:         validateDBContents(con);
1:         // Shutdown the database.
1:         con.close();
1:         shutdown(dbName);
1:         // Reconnect using correct key.
1:         con = getConnection(dbName, encryptionAlgorithm, bootPassword);
1:         validateDBContents(con);
1:         con.close();
1:         // Shutdown the database.
1:         shutdown(dbName);
1:     }
1:     
1:     /**
1:      * Case 2.1 - Unsupported padding mode
1:      */
1:     public void testUnsupportedPadding() throws SQLException {
1:         assertNoDBCreated("XBCXB", "badPadDB", "AES/ECB/PKCS5Padding", 
1:             new String[] {"bootPassword=Thursday"});
1:     }
1:     
1:     /**
1:      * Case 3.x
1:      * Test connection attempts for 4 different keyLength values:
1:      * valid/supported: 128(case 3.1), 192(case 3.2), 256(case 3.3)
1:      * Create-and-connect is test case 3.*.1, reconnection 3.*.2.
1:      * unsupported:     512(case 3.5)
1:      * Also test creating the database with one length, then attempt
1:      * to reconnect with another encryptionKeyLength value (case 3.4.)
1:      * Connections with encryptionKeyLength 192 or 256 require an unrestricted
1:      * encryption policy, which may not be available on all machines, so
1:      * we need to handle that situation.
1:      */
1:     public void testEncryptionKeyLengths() throws SQLException {
1:         String[] encryptionKeyLengths = {"128", "192", "256"};
1:         for (int i=0 ; i<encryptionKeyLengths.length ; i++)
1:         {
1:             runTestEncryptionKeyLengths(encryptionKeyLengths[i]);
1:         }
1:         // case 3.5 - bad key length
1:         assertNoDBCreated("XJ001", "badKeyLengthDB", "AES/ECB/NoPadding", 
1:             new String[] {"encryptionKeyLength=512", "bootPassword=Thursday"});
1:     }
1: 
1:     /**
1:      * test connection attempts for a passed in feedback mode:
1:      * does most of the work for fixture testEncryptionKeyLength
1:      * Connect-and-Create(test case 1.*.1, shutdown, reconnect(1.*.2).
1:      */
1:     protected void runTestEncryptionKeyLengths(
1:             String encryptionKeyLength)
1:     throws SQLException {
1:         String dbName = "encrKeyLength" + encryptionKeyLength + "DB";
1:         // Create database.
1:         String encryptionAlgorithm = "AES/CBC/NoPadding";
1:         String[] attributes = 
1:             {("encryptionKeyLength=" + encryptionKeyLength),
1:              "bootPassword=Thursday"};
1:         Connection con = createAndPopulateDB(dbName, encryptionAlgorithm, attributes );
1:         // If we didn't get a connection and the test did not stop because 
1:         // of a failure, the policy jars in the jvm must be restrictive.
1:         // Pop a message to the console and only test encryptionKeyLength 128.
1:         if (con == null)
1:         {
0:             System.out.println("no unrestricted policy jars; cannot test AES " +
0:                 "encryption with encryptionKeyLengths 192 nor 256");
1:             return;
1:         }
1:         validateDBContents(con);
1:         // Shutdown the database.
1:         con.close();
0:         // bug DERBY-3710 - with encryptionKeyLength=192,
0:         // we cannot connect after a shutdown. Works fine with 128 and 256.
0:         // the if is to workaround DERBY-3710, can be removed when it's fixed.
0:         if (!encryptionKeyLength.equals("192"))
1:             shutdown(dbName);
1:         // Reconnect using correct key length.
1:         con = getConnection(dbName, encryptionAlgorithm, attributes);
1:         validateDBContents(con);
1:         con.close();
1:         // just for fun, try this with a DriverManager connection
1:         con = getDriverManagerConnection(dbName, encryptionAlgorithm, attributes);
1:         validateDBContents(con);
1:         con.close();
1:         // Shutdown the database.
0:         // the if is to workaround DERBY-3710
0:         if (!encryptionKeyLength.equals("192"))
1:             shutdown(dbName);
1:         String[] keyLengths = {"128", "192", "256", "512"};
1:         for (int i=0 ; i < keyLengths.length ; i++) {
1:             if (!encryptionKeyLength.equals(keyLengths[i])){
1:                 attributes = new String[] 
1:                    {("encryptionKeyLength=" + keyLengths[i]),
1:                      "bootPassword=Thursday"};
1:                 // Reconnect using a valid, but different key length
1:                 runMismatchKeyLength(dbName, encryptionAlgorithm,
1:                     encryptionKeyLength, attributes);
1:             }
1:         }
0:         // workaround DERBY-3710; otherwise the db was shutdown
0:         // in the method runMismatchKeyLength.
0:         if (encryptionKeyLength.equals("192"))
1:         {
1:             attributes = new String[] 
1:                {("encryptionKeyLength=" + encryptionKeyLength),
1:                  "bootPassword=Thursday"};
1:             shutdown(dbName);
1:         }
1:     }
1: 
1:     /**
1:      * attempt to connect and verify the SQLState if it's expected to fail
1:      * does the last bit of work for fixture testEncryptionKeyLength
1:      */
1:     public void runMismatchKeyLength(String dbName, String encryptionAlgorithm,
1:             String encryptionKeyLength, String[] attributes) throws SQLException {
1:         Connection con = null;
1:         // try connecting
1:         // all combinations work - (if unrestricted policy jars are
0:         // in place) except with length 192 if we've done a shutdown.
1:         try {
1:             con = getConnection(dbName, encryptionAlgorithm, attributes );
1:             validateDBContents(con);
1:             con.close();
0:             // workaround DERBY-3710
0:             if (!encryptionKeyLength.equals("192"))
1:                 shutdown(dbName);
1:         } catch (SQLException e) {
1:             e.printStackTrace();
1:             con.close();
1:             shutdown(dbName);
1:             assertSQLState("XBM06", e);
1:         }
1:     }
1: 
1:     /* ********************************************************************* *
1:      *                     H E L P E R  M E T H O D S                        *
1:      * ********************************************************************* */
1: 
1:     
1:     /**
1:      * Obtain absolute path for the specified database name.
1:      * <p>
1:      * This absolute path is the name of the database (specified) prefixed with
1:      * the absolute path to the EXTINOUT directory. The latter is determined by
1:      * consulting <code>SupportFilesSetup</code>.
1:      *
1:      * @param dbName name of the database
1:      * Note that the database name will be prefixed
1:      *      with the path to the EXTINOUT directory
1:      * @return A string with the absolute path to the database.
1:      * @see SupportFilesSetup
1:      */
1:     private String obtainDbName(String dbName) {
1:         File tmp = new File(dbName);
0:         final File db = tmp;
0:         return (String)AccessController.doPrivileged(
0:                 new PrivilegedAction() {
0:                     public Object run() {
0:                         return new File(SupportFilesSetup.EXTINOUT,
0:                                 db.getPath()).getAbsolutePath();
1:                     }
1:                 }
0:         );
1:     }
1: 
1:     /**
1:      * Attempt to create a new database and expect a failure.
1:      * <p>
1:      * The method expects a failure
1:      * This is because it is the creation process that is to be tested.
1:      *
1:      * @param expectedSQLState SQLState for the expected error
1:      * @param dbName name of the database attempted to create
1:      * @param algorithm EncryptionAlgorithm
1:      * @param otherAttributes array for all other attributes 
1:      *        (Note: dataEncryption=true is already set in getConnection) 
1:      * @throws SQLException if the database already exist, or
1:      *      a general error happens during database interaction
1:      */
1:     protected void assertNoDBCreated(String expectedSQLState,
1:         String dbName, String algorithm, String[] otherAttributes)
1:     throws SQLException {
1:         try {
1:             getConnection(dbName, algorithm, otherAttributes );
1:             fail ("expected error message re unsupported functionality");
1:         } catch (SQLException e) {
1:             assertSQLState(expectedSQLState, e);
1:         }
1:     }
1:     
1:     /**
1:      * Create a new database and populate it.
1:      * <p>
1:      * The method fails with an exception if the database already exists.
1:      * This is because it is the creation process that is to be tested.
1:      *
1:      * @param dbName name of the database to create
1:      * @param algorithm EncryptionAlgorithm
1:      * @param otherAttributes array for all other attributes 
1:      *        (Note: dataEncryption=true is already set in getConnection) 
1:      * @return A connection the to the newly created database.
1:      * @throws SQLException if the database already exist, or
1:      *      a general error happens during database interaction
1:      */
1:     protected Connection createAndPopulateDB(
1:         String dbName, String algorithm, String[] otherAttributes)
1:     throws SQLException {
1:         try {
1:             Connection con = getConnection(dbName, algorithm, otherAttributes);
1:             SQLWarning warning = con.getWarnings();
1:             // If the database already exists, fail the test.
1:             if (warning != null) {
1:                 if ("01J01".equals(warning.getSQLState())) {
1:                     fail("Refusing to continue, database already exists <" +
1:                         warning.getMessage() + ">");
1:                 }
1:             }
1:             Statement stmt = con.createStatement();
1:             stmt.executeUpdate("CREATE TABLE " + TABLE + " (id int NOT NULL, " +
1:             "val int NOT NULL, PRIMARY KEY(id))");
1:             stmt.close();
1:             PreparedStatement ps = con.prepareStatement("INSERT INTO " + TABLE +
1:             " (id, val) VALUES (?,?)");
1:             for (int i=0; i < DATA.length; i++) {
1:                 ps.setInt(1, i);
1:                 ps.setInt(2, DATA[i]);
1:                 ps.executeUpdate();
1:             }
1:             ps.close();
1:             return con;
1:         }
1:         catch (SQLException e) {
1:             // if it fails, it should only be because of non-existing
1:             // support for unrestricted encryption policy.
1:             assertSQLState("XJ001", e);
1:             return null;
1:         }
1:     }
1: 
1:     /**
1:      * Create a new connection to the specified database, using the given
1:      * connection attributes.
1:      *
1:      * @param dbName name of the database
1:      * @param algorithm EncryptionAlgorithm
1:      * @param otherAttributes array for all other attributes 
1:      *        (Note: dataEncryption=true is already set in this method) 
1:      * @return A connection to the database.
1:      * @throws SQLException if connection fails
1:      */
1:     private Connection getConnection(String dbName,
1:             String algorithm,
1:             String[] otherAttributes)
1:     throws SQLException {
1:         DataSource ds = JDBCDataSource.getDataSource(obtainDbName(dbName));
1:         StringBuffer str = new StringBuffer(75);
1:         // Enable data encryption and mark for creation
1:         // (will connect to existing db if already exists.)
1:         JDBCDataSource.setBeanProperty(ds, "CreateDatabase", "create");
1:         str.append("dataEncryption=true;");
1:         // Add the encryption algorithm.
1:         str.append("encryptionAlgorithm=");
1:         str.append(algorithm);
1:         str.append(";");
1:         // Add whatever else is being passed in.
1:         for (int i=0 ; i < otherAttributes.length ; i++) {
1:             str.append(otherAttributes[i]);
1:             str.append(";");
1:         }
1:         JDBCDataSource.setBeanProperty(
1:                 ds, "connectionAttributes", str.toString());
1:         return ds.getConnection();
1:     }
1: 
1:     // does the same thing as getConnection, but uses DriverManager
1:     // temp method to see if this worked for encryptionKeyLength
1:     // test. But no...
1:     private Connection getDriverManagerConnection(String dbName,
1:             String algorithm,
1:             String[] otherAttributes)
1:     throws SQLException {
1:         String url = TestConfiguration.getCurrent().getJDBCUrl(obtainDbName(dbName));
1:         url = url + ";create=true;dataEncryption=true;encryptionAlgorithm=" +
1:             algorithm + ";";
1:         for (int i=0 ; i < otherAttributes.length ; i++) {
1:             url = url + otherAttributes[i] + ";";
1:         }
1:         // as we're only using SupportingFilesSetup, not default,
1:         // we need to explicitly load the driver.
1:         String driver =
1:             getTestConfiguration().getJDBCClient().getJDBCDriverName();
1:         try {
0:             Class.forName(driver).newInstance();
1:         } catch (ClassNotFoundException cnfe) {
1:             fail("\nUnable to load the JDBC driver " + driver);
1:         } catch (InstantiationException ie) {
1:             fail("\nUnable to instantiate the JDBC driver " + driver);
1:         } catch (IllegalAccessException iae) {
1:             fail("\nNot allowed to access the JDBC driver " + driver);
1:         }
1:         Connection conn = DriverManager.getConnection(url);
1:         return conn;
1:     }
1: 
1:     /**
1:      * Shutdown the specified database.
1:      *
1:      * @throws SQLException if fails
1:      * @param databaseName the name of the database
1:      */
1:     protected void shutdown(String databaseName)
1:     throws SQLException {
1:         DataSource ds = JDBCDataSource.getDataSource(obtainDbName(databaseName));
1:         JDBCDataSource.shutdownDatabase(ds);
1:     }
1: 
1:     /**
1:      * Validate the data in the database against the data model.
1:      *
1:      * @param con the database to validate the contents of
1:      * @throws junit.framework.AssertionFailedError if there is a mismatch
1:      *      between the data in the database and the model
1:      */
1:     protected void validateDBContents(Connection con)
1:     throws SQLException {
1:         Statement stmt = con.createStatement();
1:         ResultSet rs = stmt.executeQuery("SELECT id, val FROM " + TABLE +
1:         " ORDER BY id");
1:         JDBC.assertFullResultSet(rs, new String[][] {
1:                 {"0","9"},
1:                 {"1","4"},
1:                 {"2","2"},
1:                 {"3","34"},
1:                 {"4","6543"},
1:                 {"5","3"},
1:                 {"6","123"},
1:                 {"7","434"},
1:                 {"8","5436"},
1:                 {"9","-123"},
1:                 {"10","0"},
1:                 {"11","123"}});
1:         //Utilities.showResultSet(rs);
1:         /* 
1:         int id, val;
1:         while (rs.next()) {
1:             id = rs.getInt(1);
1:             val = rs.getInt(2);
1:             if (id >= DATA.length) {
1:                 fail("Id in database out of bounds for data model; " +
1:                         id + " >= " + DATA.length);
1:             }
1:             if (val != DATA[id]) {
1:                 fail("Mismatch between db and model for id " + id + ";" +
1:                         val + " != " + DATA[id]);
1:             }
1:         }
1:         */
1:         rs.close();
1:         stmt.close();
1:     }
1: } // End EncryptionAESTest
============================================================================