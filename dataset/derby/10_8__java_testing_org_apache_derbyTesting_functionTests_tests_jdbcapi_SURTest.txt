1:bc50840: /*
2:bc50840:  *
1:bc50840:  * Derby - Class SURTest
1:bc50840:  *
1:dff95a1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:dff95a1:  * contributor license agreements.  See the NOTICE file distributed with
1:dff95a1:  * this work for additional information regarding copyright ownership.
1:dff95a1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:dff95a1:  * (the "License"); you may not use this file except in compliance with
1:dff95a1:  * the License.  You may obtain a copy of the License at
1:bc50840:  *
1:bc50840:  *    http://www.apache.org/licenses/LICENSE-2.0
1:bc50840:  *
1:bc50840:  * Unless required by applicable law or agreed to in writing,
1:bc50840:  * software distributed under the License is distributed on an
1:bc50840:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:bc50840:  * either express or implied. See the License for the specific
1:bc50840:  * language governing permissions and limitations under the License.
1:bc50840:  */
1:bc50840: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:ff65830: 
1:bc50840: import java.sql.PreparedStatement;
1:bc50840: import java.sql.ResultSet;
1:bc50840: import java.sql.SQLException;
1:bc50840: import java.sql.SQLWarning;
1:bc50840: import java.sql.Statement;
1:1ae02c9: import java.util.Iterator;
1:bc50840: import junit.extensions.TestSetup;
1:bc50840: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:6b0118a: 
1:bc50840: /**
1:bc50840:  * Tests for variants of scrollable updatable resultsets.
1:bc50840:  *
1:bc50840:  */
1:bc50840: public class SURTest extends SURBaseTest {
7:bc50840:     
1:bc50840:     /** Creates a new instance of SURTest */
1:bc50840:     public SURTest(String name) {
1:bc50840:         super(name);
2:bc50840:     }
1:ff65830: 
1:bc50840:     /**
1:bc50840:      * Test that you get a warning when specifying a query which is not
1:bc50840:      * updatable and concurrency mode CONCUR_UPDATABLE.
1:bc50840:      * In this case, the query contains an "order by"
1:bc50840:      */
1:bc50840:     public void testConcurrencyModeWarning1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 order by a");
1:bc50840:         
1:bc50840:         SQLWarning warn = rs.getWarnings();
1:bc50840:         assertEquals("Expected resultset to be read only",
1:bc50840:                      ResultSet.CONCUR_READ_ONLY,
1:bc50840:                      rs.getConcurrency());
1:c247315:         assertWarning(warn, QUERY_NOT_QUALIFIED_FOR_UPDATABLE_RESULTSET);
1:bc50840:         scrollForward(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:7d0f620:     
1:1b7b14f:     /**
1:bc50840:      * Test that you get a warning when specifying a query which is not
1:bc50840:      * updatable and concurrency mode CONCUR_UPDATABLE.
1:bc50840:      * In this case, the query contains a join.
1:bc50840:      */
1:bc50840:     public void testConcurrencyModeWarning2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery
1:bc50840:             ("select * from t1 as table1,t1 as table2 where " +
1:bc50840:              "table1.a=table2.a");
1:bc50840:         
1:bc50840:         SQLWarning warn = rs.getWarnings();
1:bc50840:         assertEquals("Expected resultset to be read only",
1:bc50840:                      ResultSet.CONCUR_READ_ONLY,
1:bc50840:                      rs.getConcurrency());
1:c247315:         assertWarning(warn, QUERY_NOT_QUALIFIED_FOR_UPDATABLE_RESULTSET);
1:bc50840:         scrollForward(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that you get an exception when specifying update clause
1:bc50840:      * "FOR UPDATE"
1:bc50840:      * along with a query which is not updatable.
1:bc50840:      * In this case, the query contains and order by.
1:bc50840:      */
1:bc50840:     public void testForUpdateException1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         try {
1:bc50840:             String queryString =
1:bc50840:                 "select * from t1 order by a for update";
1:bc50840:             s.setCursorName(getNextCursorName());
1:bc50840:             ResultSet rs = s.executeQuery(queryString);
1:bc50840:             
1:bc50840:             assertTrue("Expected query '" + queryString +
1:bc50840:                        "' to fail", false);
1:bc50840:         } catch (SQLException e) {
1:bc50840:             assertEquals("Unexpected SQLState", 
1:bc50840:                          FOR_UPDATE_NOT_PERMITTED_SQL_STATE,
1:bc50840:                          e.getSQLState());
1:bc50840:         }
1:ff65830:         rollback();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that you get an exception when specifying update clause
1:bc50840:      * "FOR UPDATE" along with a query which is not updatable.
1:bc50840:      * In this case, the query contains a join
1:bc50840:      */
1:bc50840:     public void testForUpdateException2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         try {
1:bc50840:             String queryString =
1:bc50840:                 "select * from t1 as table1,t1 as table2" +
1:bc50840:                 " where table1.a=table2.a for update";
1:bc50840:             s.setCursorName(getNextCursorName());
1:bc50840:             ResultSet rs = s.executeQuery(queryString);
1:bc50840:             
1:bc50840:             assertTrue("Expected query '" + queryString + "' to fail",
1:bc50840:                        false);
1:bc50840:         } catch (SQLException e) {
1:bc50840:             assertEquals("Unexpected SQLState", 
1:bc50840:                          FOR_UPDATE_NOT_PERMITTED_SQL_STATE,
1:bc50840:                          e.getSQLState());
1:bc50840:         }
1:ff65830:         rollback();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that you can scroll forward and read all records in the
1:bc50840:      * ResultSet
1:bc50840:      */
1:bc50840:     public void testForwardOnlyReadOnly1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_READ_ONLY);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         scrollForward(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that you get an exception if you try to update a ResultSet
1:bc50840:      * with concurrency mode CONCUR_READ_ONLY.
1:bc50840:      */
1:bc50840:     public void testFailOnUpdateOfReadOnlyResultSet1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_READ_ONLY);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         rs.next();
1:bc50840:         assertFailOnUpdate(rs);
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:9634cd2:     /**
1:bc50840:      * Test that you get an exception when attempting to update a
1:bc50840:      * ResultSet which has been downgraded to a read only ResultSet.
1:bc50840:      */
1:bc50840:     public void testFailOnUpdateOfReadOnlyResultSet2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 order by id");
1:bc50840:         
1:bc50840:         rs.next();
1:bc50840:         assertFailOnUpdate(rs);
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that you get an exception when attempting to update a
1:bc50840:      * ResultSet which has been downgraded to a read only ResultSet.
1:bc50840:      */
1:bc50840:     public void testFailOnUpdateOfReadOnlyResultSet3()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs =
1:bc50840:             s.executeQuery("select * from t1 for read only");
1:bc50840:         
1:bc50840:         rs.next();
1:bc50840:         assertFailOnUpdate(rs);
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that you get an exception when attempting to update a
1:bc50840:      * ResultSet which has been downgraded to a read only ResultSet.
1:bc50840:      */
1:bc50840:     public void testFailOnUpdateOfReadOnlyResultSet4()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery
1:bc50840:             ("select * from t1 where a=1 for read only");
1:bc50840:         
1:bc50840:         rs.next();
1:bc50840:         verifyTuple(rs);
1:bc50840:         assertFailOnUpdate(rs);
1:ff65830:         s.close();
1:bc50840:     }
1:a1c5d5f:     
1:bc50840:     
1:a1c5d5f:     /**
1:bc50840:      * Test that you get an exception if you try to update a ResultSet
1:bc50840:      * with concurrency mode CONCUR_READ_ONLY.
1:bc50840:      */
1:bc50840:     public void testFailOnUpdateOfReadOnlyResultSet5()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.
1:bc50840:                                           TYPE_SCROLL_INSENSITIVE,
1:bc50840:                                           ResultSet.CONCUR_READ_ONLY);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery
1:bc50840:             ("select * from t1 where a=1 for read only");
1:bc50840:         
1:bc50840:         rs.next();
1:bc50840:         verifyTuple(rs);
1:bc50840:         assertFailOnUpdate(rs);
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840: 
1:bc50840:     /** 
1:9634cd2:      * Test that when doing an update immediately after
1:9634cd2:      * a commit, the update fails, because the cursor has been 
1:9634cd2:      * postioned between the current row and the next row.
1:9634cd2:      * The test uses a FORWARD_ONLY resultset and ResultSet update methods
1:9634cd2:      * when doing the update.
1:9634cd2:      */
1:9634cd2:     public void testCursorStateAfterCommit1() 
1:9634cd2:         throws SQLException
1:9634cd2:     {
1:9634cd2:         testCursorStateAfterCommit(false, ResultSet.TYPE_FORWARD_ONLY);
1:9634cd2:     }
1:9634cd2: 
1:9634cd2:     /** 
1:9634cd2:      * Test that when doing an update immediately after
1:9634cd2:      * a commit, the update fails, because the cursor has been 
1:9634cd2:      * postioned between the current row and the next row.
1:9634cd2:      * The test uses a SCROLL_INSENSITIVE resultset and ResultSet update methods
1:9634cd2:      * when doing the update.
1:9634cd2:      */
1:9634cd2:     public void testCursorStateAfterCommit2() 
1:9634cd2:         throws SQLException
1:9634cd2:     {
1:9634cd2:         testCursorStateAfterCommit(false, ResultSet.TYPE_SCROLL_INSENSITIVE);
1:9634cd2:     }
1:9634cd2:     
1:9634cd2:      /** 
1:9634cd2:      * Test that when doing an update immediately after
1:9634cd2:      * a commit, the update fails, because the cursor has been 
1:9634cd2:      * postioned between the current row and the next row.
1:9634cd2:      * The test uses a FORWARD_ONLY resultset and positioned updates.
1:9634cd2:      */
1:9634cd2:     public void testCursorStateAfterCommit3() 
1:9634cd2:         throws SQLException
1:9634cd2:     {
1:9634cd2:         testCursorStateAfterCommit(true, ResultSet.TYPE_FORWARD_ONLY);
1:9634cd2:     }
1:9634cd2: 
1:9634cd2:     /** 
1:9634cd2:      * Test that when doing an update immediately after
1:9634cd2:      * a commit, the update fails, because the cursor has been 
1:9634cd2:      * postioned between the current row and the next row.
1:9634cd2:      * The test uses a SCROLL_INSENSITIVE resultset and positioned updates.
1:9634cd2:      */
1:9634cd2:     public void testCursorStateAfterCommit4() 
1:9634cd2:         throws SQLException
1:9634cd2:     {
1:9634cd2:         testCursorStateAfterCommit(true, ResultSet.TYPE_SCROLL_INSENSITIVE);
1:9634cd2:     }
1:9634cd2:     
1:9634cd2:     /** 
1:9634cd2:      * Test that when doing an update immediately after
1:9634cd2:      * a commit, the update fails, because the cursor has been 
1:9634cd2:      * postioned between the current row and the next row.
1:9634cd2:      * If the cursor gets repositioned, it allows an update.
1:9634cd2:      * @param positioned true to use positioned update, otherwise use 
1:9634cd2:      *                   ResultSet.updateRow()
1:9634cd2:      * @param resultSetType type of result set (as in ResultSet.getType())
1:9634cd2:      */
1:9634cd2:     private void testCursorStateAfterCommit(final boolean positioned, 
1:9634cd2:                                             final int resultSetType) 
1:9634cd2:         throws SQLException
1:9634cd2:     {
1:ff65830:         final Statement s = createStatement(resultSetType, 
1:9634cd2:                                                 ResultSet.CONCUR_UPDATABLE);
1:9634cd2:         final String cursorName = getNextCursorName();
1:9634cd2:         s.setCursorName(cursorName);
1:9634cd2:         
1:9634cd2:         final ResultSet rs = s.executeQuery("select a from t1");
1:9634cd2:         final int recordToUpdate = 5;
1:9634cd2:         
1:9634cd2:         if (resultSetType==ResultSet.TYPE_FORWARD_ONLY) {
1:9634cd2:             for (int i = 0; i < recordToUpdate; i++) {
1:9634cd2:                 rs.next();
1:9634cd2:             }
1:9634cd2:         } else {
1:9634cd2:             rs.absolute(recordToUpdate);
1:9634cd2:         }
1:9634cd2:         
1:ff65830:         commit();
1:9634cd2:         
1:9634cd2:         PreparedStatement ps = 
1:ff65830:             prepareStatement("update t1 set a=? where current of " +
1:9634cd2:                                  cursorName);
1:9634cd2:         // First: check that we get an exception on update without repositioning:
1:9634cd2:         try {
1:9634cd2:             if (positioned) {
1:9634cd2:                 ps.setInt(1, -1);
1:9634cd2:                 ps.executeUpdate();                
1:9634cd2:                 fail("Expected exception to be thrown on positioned update " + 
1:9634cd2:                      "since cursor is not positioned");
1:9634cd2:             } else {
1:9634cd2:                 rs.updateInt(1, -1);
1:9634cd2:                 rs.updateRow();
1:9634cd2:                 fail("Expected exception to be thrown on updateRow() since " +
1:9634cd2:                      "cursor is not positioned");
1:9634cd2:             }
1:9634cd2:         } catch (SQLException e) {
1:9634cd2:             assertSQLState("Unexpected SQLState when updating row after commit",
1:9634cd2:                            SQLStateConstants.INVALID_CURSOR_STATE_NO_SUBCLASS,
1:9634cd2:                            e);
1:9634cd2:         }
1:9634cd2:         
1:9634cd2:         // Check that we after a repositioning can update:
1:9634cd2:         if (resultSetType==ResultSet.TYPE_FORWARD_ONLY) {
1:9634cd2:             rs.next();
1:9634cd2:         } else {
1:9634cd2:             rs.relative(0);
1:9634cd2:         }
1:9634cd2:         if (positioned) {
1:9634cd2:             ps.setInt(1, -1);
1:9634cd2:             ps.executeUpdate();                
1:9634cd2:         } else {
1:9634cd2:             rs.updateInt(1, -1);
1:9634cd2:             rs.updateRow();
1:9634cd2:         }
1:9634cd2:         
1:ff65830:         s.close();
1:ff65830:         ps.close();
1:ff65830:         
1:9634cd2:     }
1:9634cd2: 
1:bc50840:     /**
1:a1c5d5f:      * Test that you can correctly run multiple updateXXX() + updateRow() 
1:a1c5d5f:      * combined with cancelRowUpdates().
1:a1c5d5f:      */
1:a1c5d5f:     public void testMultiUpdateRow1() 
1:a1c5d5f:         throws SQLException 
1:a1c5d5f:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:a1c5d5f:                                           ResultSet.CONCUR_UPDATABLE);
1:a1c5d5f:         s.setCursorName(getNextCursorName());
1:a1c5d5f:         ResultSet rs = s.executeQuery("select * from t1");
1:a1c5d5f:         rs.absolute(5);
1:a1c5d5f:         final int oldCol2 = rs.getInt(2);
1:a1c5d5f:         final int newCol2 = -2222;
1:a1c5d5f:         final int oldCol3 = rs.getInt(3);
1:a1c5d5f:         final int newCol3 = -3333;
1:a1c5d5f:                 
1:a1c5d5f:         rs.updateInt(2, newCol2);
1:a1c5d5f:         assertEquals("Expected the resultset to be updated after updateInt",
1:a1c5d5f:                      newCol2, rs.getInt(2));
1:a1c5d5f:         rs.cancelRowUpdates();
1:a1c5d5f:         assertEquals("Expected updateXXX to have no effect after cancelRowUpdated",
1:a1c5d5f:                      oldCol2, rs.getInt(2));
1:a1c5d5f:         rs.updateInt(2, newCol2);
1:a1c5d5f:         assertEquals("Expected the resultset to be updated after updateInt", 
1:a1c5d5f:                      newCol2, rs.getInt(2));
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be false before updateRow", 
1:a1c5d5f:                    !rs.rowUpdated());
1:a1c5d5f:         rs.updateRow();
1:a1c5d5f:         
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be true after updateRow", 
1:a1c5d5f:                    rs.rowUpdated());
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous " + 
1:a1c5d5f:                      "updateRow", newCol2, rs.getInt(2));
1:a1c5d5f:         
1:a1c5d5f:         rs.updateInt(3, newCol3);
1:a1c5d5f:         
1:a1c5d5f:         assertEquals("Expected the resultset to be updated after updateInt", 
1:a1c5d5f:                      newCol3, rs.getInt(3));
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous " + 
1:a1c5d5f:                      "updateRow", newCol2, rs.getInt(2));
1:a1c5d5f:         
1:a1c5d5f:         rs.cancelRowUpdates();
1:a1c5d5f:         
1:a1c5d5f:         assertEquals("Expected updateXXX to have no effect after " +
1:a1c5d5f:                      "cancelRowUpdated", oldCol3, rs.getInt(3));
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous " +
1:a1c5d5f:                      "updateRow after cancelRowUpdated", newCol2, rs.getInt(2));
1:a1c5d5f:         rs.updateInt(3, newCol3);
1:a1c5d5f:         rs.updateRow();
1:a1c5d5f:         assertEquals("Expected the resultset to be updated after updateInt", 
1:a1c5d5f:                      newCol3, rs.getInt(3));
1:a1c5d5f:         rs.cancelRowUpdates();
1:a1c5d5f:         
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous" + 
1:a1c5d5f:                      "updateRow after cancelRowUpdates", newCol2, rs.getInt(2));
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous" + 
1:a1c5d5f:                      "updateRow after cancelRowUpdates", newCol3, rs.getInt(3));
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be true after " + 
1:a1c5d5f:                    "updateRow and cancelRowUpdates", rs.rowUpdated());
1:a1c5d5f:         
1:a1c5d5f:         rs.close();
1:ff65830:         s.close();
1:a1c5d5f:     }
1:a1c5d5f: 
1:a1c5d5f:     /**
1:a1c5d5f:      * Test that you can correctly run multiple updateNull() + updateRow() 
1:a1c5d5f:      * combined with cancelRowUpdates().
1:a1c5d5f:      */
1:a1c5d5f:     public void testMultiUpdateRow2() 
1:a1c5d5f:         throws SQLException 
1:a1c5d5f:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:a1c5d5f:                                           ResultSet.CONCUR_UPDATABLE);
1:a1c5d5f:         s.setCursorName(getNextCursorName());
1:a1c5d5f:         ResultSet rs = s.executeQuery("select * from t1");
1:a1c5d5f:         rs.absolute(5);
1:a1c5d5f:         final int oldCol2 = rs.getInt(2);
1:a1c5d5f:         final int oldCol3 = rs.getInt(3);
1:a1c5d5f:         
1:a1c5d5f:         rs.updateNull(2);
1:a1c5d5f:         assertEquals("Expected the resultset to be updated after updateNull",
1:a1c5d5f:                      0, rs.getInt(2));
1:a1c5d5f:         assertTrue("Expected wasNull to be true after updateNull", rs.wasNull());
1:a1c5d5f:         rs.cancelRowUpdates();
1:a1c5d5f:         assertEquals("Expected updateXXX to have no effect after cancelRowUpdated",
1:a1c5d5f:                      oldCol2, rs.getInt(2));
1:a1c5d5f:         rs.updateNull(2);
1:a1c5d5f:         assertEquals("Expected the resultset to be updated after updateNull", 
1:a1c5d5f:                      0, rs.getInt(2));
1:a1c5d5f:         assertTrue("Expected wasNull to be true after updateNull", rs.wasNull());
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be false before updateRow", 
1:a1c5d5f:                    !rs.rowUpdated());
1:a1c5d5f:         rs.updateRow();
1:a1c5d5f:         
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be true after updateRow", 
1:a1c5d5f:                    rs.rowUpdated());
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous " + 
1:a1c5d5f:                      "updateRow", 0, rs.getInt(2));
1:a1c5d5f:         
1:a1c5d5f:         rs.updateNull(3);
1:a1c5d5f:         
1:a1c5d5f:         assertEquals("Expected the resultset to be updated after updateNull", 
1:a1c5d5f:                      0, rs.getInt(3));
1:a1c5d5f:         assertTrue("Expected wasNull to be true after updateNull", rs.wasNull());
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous " + 
1:a1c5d5f:                      "updateRow", 0, rs.getInt(2));
1:a1c5d5f:         
1:a1c5d5f:         rs.cancelRowUpdates();
1:a1c5d5f:         
1:a1c5d5f:         assertEquals("Expected updateXXX to have no effect after " +
1:a1c5d5f:                      "cancelRowUpdated", oldCol3, rs.getInt(3));
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous " +
1:a1c5d5f:                      "updateRow after cancelRowUpdated", 0, rs.getInt(2));
1:a1c5d5f:         rs.updateNull(3);
1:a1c5d5f:         rs.updateRow();
1:a1c5d5f:         assertEquals("Expected the resultset to be updated after updateNull", 
1:a1c5d5f:                      0, rs.getInt(3));
1:a1c5d5f:         rs.cancelRowUpdates();
1:a1c5d5f:         
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous" + 
1:a1c5d5f:                      "updateRow after cancelRowUpdates", 0, rs.getInt(2));
1:a1c5d5f:         assertEquals("Expected the resultset detect the updates of previous" + 
1:a1c5d5f:                      "updateRow after cancelRowUpdates", 0, rs.getInt(3));
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be true after " + 
1:a1c5d5f:                    "updateRow and cancelRowUpdates", rs.rowUpdated());
1:a1c5d5f:         
1:a1c5d5f:         rs.close();
1:ff65830:         s.close();
1:a1c5d5f:     }
1:a1c5d5f: 
1:a1c5d5f:     /**
1:a1c5d5f:      * Test that you get cursor operation conflict warning if updating 
1:a1c5d5f:      * a row which has been deleted from the table.
1:a1c5d5f:      */
1:a1c5d5f:     public void testCursorOperationConflictWarning1() 
1:a1c5d5f:         throws SQLException 
1:a1c5d5f:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:a1c5d5f:                                           ResultSet.CONCUR_UPDATABLE);
1:a1c5d5f:         s.setCursorName(getNextCursorName());
1:a1c5d5f:         ResultSet rs = s.executeQuery("select * from t1");
1:a1c5d5f:         rs.next();
1:ff65830:         createStatement().executeUpdate("delete from t1 where id=" +
1:a1c5d5f:                                             rs.getString("ID"));
1:a1c5d5f:         final int newValue = -3333;
1:a1c5d5f:         final int oldValue = rs.getInt(2);
1:a1c5d5f:         rs.updateInt(2, newValue);
1:a1c5d5f:         rs.updateRow();
1:a1c5d5f:         
1:a1c5d5f:         SQLWarning warn = rs.getWarnings();
1:a1c5d5f:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:a1c5d5f:         assertEquals("Did not expect the resultset to be updated", oldValue, rs.getInt(2));
1:a1c5d5f:         assertTrue("Expected rs.rowDeleted() to be false", !rs.rowDeleted());
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be false", !rs.rowUpdated());
1:a1c5d5f:         
1:a1c5d5f:         rs.clearWarnings();
1:a1c5d5f:         rs.deleteRow();
1:a1c5d5f:         warn = rs.getWarnings();
1:a1c5d5f:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:a1c5d5f:         rs.relative(0);
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be false", !rs.rowUpdated());
1:a1c5d5f:         assertTrue("Expected rs.rowDeleted() to be false", !rs.rowDeleted());
1:a1c5d5f:         assertEquals("Did not expect the resultset to be updated", oldValue, rs.getInt(2));
1:a1c5d5f:         
1:a1c5d5f:         rs.close();
1:ff65830:         s.close();
1:a1c5d5f:     }
1:a1c5d5f: 
1:a1c5d5f:     /**
1:a1c5d5f:      * Test that you get cursor operation conflict warning if updating 
1:a1c5d5f:      * a row which has been deleted from the table, now using 
1:a1c5d5f:      * positioned updates / deletes.
1:a1c5d5f:      */
1:a1c5d5f:     public void testCursorOperationConflictWarning2() 
1:a1c5d5f:         throws SQLException 
1:a1c5d5f:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:a1c5d5f:                                           ResultSet.CONCUR_UPDATABLE);
1:a1c5d5f:         s.setCursorName(getNextCursorName());
1:a1c5d5f:         ResultSet rs = s.executeQuery("select * from t1");
1:a1c5d5f:         rs.next();
1:ff65830:         createStatement().executeUpdate ("delete from t1 where id=" +
1:a1c5d5f:                                              rs.getString("ID"));
1:a1c5d5f:         
1:a1c5d5f:         final int newValue = -3333;
1:a1c5d5f:         final int oldValue = rs.getInt(2);
1:a1c5d5f:         
1:ff65830:         Statement s3 = createStatement();
1:a1c5d5f:         int updateCount = s3.executeUpdate
1:a1c5d5f:             ("update t1 set A=" + newValue + 
1:a1c5d5f:              " where current of " + rs.getCursorName());
1:a1c5d5f:         
1:a1c5d5f:         rs.relative(0);
1:a1c5d5f:         SQLWarning warn = s3.getWarnings();
1:a1c5d5f:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be false", !rs.rowUpdated());
1:a1c5d5f:         assertTrue("Expected rs.rowDeleted() to be false", !rs.rowDeleted());
1:a1c5d5f:         assertEquals("Did not expect the resultset to be updated", oldValue, rs.getInt(2));
1:a1c5d5f:         assertEquals("Expected update count to be 0", 0, updateCount);
1:a1c5d5f:         
1:ff65830:         Statement s4 = createStatement();
1:a1c5d5f:         updateCount = s4.executeUpdate("delete from t1 where current of " +
1:a1c5d5f:                                        rs.getCursorName());
1:a1c5d5f:         
1:a1c5d5f:         rs.relative(0);
1:a1c5d5f:         warn = s4.getWarnings();
1:a1c5d5f:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:a1c5d5f:         assertTrue("Expected rs.rowUpdated() to be false", !rs.rowUpdated());
1:a1c5d5f:         assertTrue("Expected rs.rowDeleted() to be false", !rs.rowDeleted());
1:a1c5d5f:         assertEquals("Did not expect the resultset to be updated", oldValue, rs.getInt(2));
1:a1c5d5f:         assertEquals("Expected update count to be 0", 0, updateCount);
1:a1c5d5f:         
1:a1c5d5f:         rs.close();
1:ff65830:         s.close();
1:ff65830:         s3.close();
1:ff65830:         s4.close();
1:a1c5d5f:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test that you can scroll forward and update indexed records in
1:bc50840:      * the ResultSet (not using FOR UPDATE)
1:bc50840:      */
1:bc50840:     public void testIndexedUpdateCursor1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 where a=1");
1:bc50840:         
1:bc50840:         assertTrue("Expected to get a tuple on rs.next()", rs.next());
1:bc50840:         verifyTuple(rs);
1:bc50840:         updateTuple(rs);
1:ff65830:         s.close();
1:bc50840:         
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      *  Test that you can scroll forward and update indexed records
1:bc50840:      *  in the ResultSet (using FOR UPDATE).
1:bc50840:      */
1:bc50840:     public void testIndexedUpdateCursor2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs =
1:bc50840:             s.executeQuery("select * from t1 where a=1 for update");
1:bc50840:         
1:bc50840:         assertTrue("Expected to get a tuple on rs.next()", rs.next());
1:bc50840:         verifyTuple(rs);
1:bc50840:         updateTuple(rs);
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:10b9cb1:      * Tests that it is possible to move using positioning methods after
1:10b9cb1:      * moveToInsertRow and that it is possible to delete a row after 
1:10b9cb1:      * positioning back from insertRow. Also tests that it is possible to 
1:10b9cb1:      * insert a row when positioned on insert row, that it is not possible
1:10b9cb1:      * to update or delete a row from insertRow and that it also is not possible
1:10b9cb1:      * to insert a row without being on insert row.
1:10b9cb1:      */
1:10b9cb1:     public void testInsertRowWithScrollCursor() throws SQLException {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:10b9cb1:                                           ResultSet.CONCUR_UPDATABLE);
1:10b9cb1:         
1:10b9cb1:         int currentPosition, lastRow;
1:10b9cb1:         
1:10b9cb1:         s.setCursorName(getNextCursorName());
1:10b9cb1:         ResultSet rs =
1:10b9cb1:             s.executeQuery("select * from t1");
1:10b9cb1:         
1:10b9cb1:         rs.last();
1:10b9cb1:         lastRow = rs.getRow();
1:10b9cb1:         
1:10b9cb1:         rs.beforeFirst();
1:10b9cb1:         
1:10b9cb1:         rs.next();
1:10b9cb1:         
1:10b9cb1:         // Test that it is possible to move to next row from insertRow
1:10b9cb1:         currentPosition = rs.getRow();
1:10b9cb1:         rs.moveToInsertRow();
1:10b9cb1:         rs.updateInt(1, currentPosition + 1000);
1:10b9cb1:         rs.next();
1:10b9cb1:         assertEquals("CurrentPosition should be " + (currentPosition + 1), 
1:10b9cb1:                 rs.getRow(), currentPosition + 1);
1:10b9cb1:         // should be able to delete the row
1:10b9cb1:         rs.deleteRow();
1:10b9cb1: 
1:10b9cb1:         // Test that it is possible to move using relative from insertRow
1:10b9cb1:         currentPosition = rs.getRow();
1:10b9cb1:         rs.moveToInsertRow();
1:10b9cb1:         rs.updateInt(1, currentPosition + 1000);
1:10b9cb1:         rs.relative(2);
1:10b9cb1:         assertEquals("CurrentPosition should be " + (currentPosition + 2), 
1:10b9cb1:                 rs.getRow(), currentPosition + 2);
1:10b9cb1:         // should be able to delete the row
1:10b9cb1:         rs.deleteRow();
1:10b9cb1: 
1:10b9cb1:         // Test that it is possible to move using absolute from insertRow
1:10b9cb1:         currentPosition = rs.getRow();
1:10b9cb1:         rs.moveToInsertRow();
1:10b9cb1:         rs.updateInt(1, currentPosition + 1000);
1:10b9cb1:         rs.absolute(6);
1:10b9cb1:         assertEquals("CurrentPosition should be 6", rs.getRow(), 6);
1:10b9cb1:         // should be able to delete the row
1:10b9cb1:         rs.deleteRow();
1:10b9cb1: 
1:10b9cb1:         // Test that it is possible to move to previous row from insertRow
1:10b9cb1:         currentPosition = rs.getRow();
1:10b9cb1:         rs.moveToInsertRow();
1:10b9cb1:         rs.updateInt(1, currentPosition + 1000);
1:10b9cb1:         rs.previous();
1:10b9cb1:         assertEquals("CurrentPosition should be " + (currentPosition - 1), 
1:10b9cb1:                 rs.getRow(), currentPosition - 1);
1:10b9cb1:         // should be able to delete the row
1:10b9cb1:         rs.deleteRow();
1:10b9cb1: 
1:10b9cb1:         // Test that it is possible to move to first row from insertRow
1:10b9cb1:         currentPosition = rs.getRow();
1:10b9cb1:         rs.moveToInsertRow();
1:10b9cb1:         rs.updateInt(1, currentPosition + 1000);
1:10b9cb1:         rs.first();
1:10b9cb1:         assertEquals("CurrentPosition should be 1", rs.getRow(), 1);
1:10b9cb1:         assertTrue("isFirst() should return true", rs.isFirst());
1:10b9cb1:         // should be able to delete the row
1:10b9cb1:         rs.deleteRow();
1:10b9cb1: 
1:10b9cb1:         // Test that it is possible to move to last row from insertRow
1:10b9cb1:         currentPosition = rs.getRow();
1:10b9cb1:         rs.moveToInsertRow();
1:10b9cb1:         rs.updateInt(1, currentPosition + 1000);
1:10b9cb1:         rs.last();
1:10b9cb1:         assertEquals("CurrentPosition should be " + lastRow, 
1:10b9cb1:                 rs.getRow(), lastRow);
1:10b9cb1:         assertTrue("isLast() should return true", rs.isLast());
1:10b9cb1:         // should be able to delete the row
1:10b9cb1:         rs.deleteRow();
1:10b9cb1: 
1:10b9cb1:         // Test that it is possible to move beforeFirst from insertRow
1:10b9cb1:         currentPosition = rs.getRow();
1:10b9cb1:         rs.moveToInsertRow();
1:10b9cb1:         rs.updateInt(1, currentPosition + 1000);
1:10b9cb1:         rs.beforeFirst();
1:10b9cb1:         assertTrue("isBeforeFirst() should return true", rs.isBeforeFirst());
1:10b9cb1:         rs.next();
1:10b9cb1:         assertEquals("CurrentPosition should be 1", rs.getRow(), 1);
1:10b9cb1:         assertTrue("isFirst() should return true", rs.isFirst());
1:10b9cb1: 
1:10b9cb1:         // Test that it is possible to move afterLast from insertRow
1:10b9cb1:         currentPosition = rs.getRow();
1:10b9cb1:         rs.moveToInsertRow();
1:10b9cb1:         rs.updateInt(1, currentPosition + 1000);
1:10b9cb1:         rs.afterLast();
1:10b9cb1:         assertTrue("isAfterLast() should return true", rs.isAfterLast());
1:10b9cb1:         rs.previous();
1:10b9cb1:         assertEquals("CurrentPosition should be " + lastRow, 
1:10b9cb1:                 rs.getRow(), lastRow);
1:10b9cb1:         assertTrue("isLast() should return true", rs.isLast());
1:10b9cb1: 
1:10b9cb1:         // Test that it is possible to insert a row and move back to current row
1:10b9cb1:         rs.previous();
1:10b9cb1:         currentPosition = rs.getRow();
1:10b9cb1:         rs.moveToInsertRow();
1:10b9cb1:         rs.updateInt(1, currentPosition + 1000);
1:10b9cb1:         rs.insertRow();
1:10b9cb1:         rs.moveToCurrentRow();
1:10b9cb1:         assertEquals("CurrentPosition should be " + currentPosition, 
1:10b9cb1:                 rs.getRow(), currentPosition);
1:10b9cb1: 
1:10b9cb1:         
1:10b9cb1:         try {
1:10b9cb1:             rs.moveToInsertRow();
1:10b9cb1:             rs.updateInt(1, currentPosition + 2000);
1:10b9cb1:             rs.updateRow();
1:10b9cb1:         } catch (SQLException se) {
1:10b9cb1:             assertEquals("Expected exception", 
1:10b9cb1:                     se.getSQLState().substring(0, 5), 
1:10b9cb1:                     INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:10b9cb1:         }
1:10b9cb1:         
1:10b9cb1:         try {
1:10b9cb1:             rs.moveToInsertRow();
1:10b9cb1:             rs.updateInt(1, currentPosition + 2000);
1:10b9cb1:             rs.deleteRow();
1:10b9cb1:         } catch (SQLException se) {
1:10b9cb1:             assertEquals("Expected exception", 
1:10b9cb1:                     se.getSQLState().substring(0, 5), 
1:10b9cb1:                     INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:10b9cb1:         }
1:10b9cb1:         
1:10b9cb1:         try {
1:10b9cb1:             rs.moveToCurrentRow();
1:10b9cb1:             rs.updateInt(1, currentPosition + 2000);
1:10b9cb1:             rs.insertRow();
1:10b9cb1:         } catch (SQLException se) {
1:10b9cb1:             assertEquals("Expected exception", 
1:10b9cb1:                     se.getSQLState().substring(0, 5), 
1:10b9cb1:                     CURSOR_NOT_POSITIONED_ON_INSERT_ROW);
1:10b9cb1:         }
1:10b9cb1:         
1:10b9cb1:         rs.close();
1:10b9cb1:         
1:ff65830:         s.close();
1:10b9cb1:     }
1:10b9cb1:     
1:10b9cb1:     /**
1:bc50840:      *  Test that you can scroll forward and update indexed records
1:bc50840:      *  in the scrollable ResultSet (not using FOR UPDATE).
1:bc50840:      */
1:bc50840:     public void
1:bc50840:         testIndexedScrollInsensitiveUpdateCursorWithoutForUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs =
1:bc50840:             s.executeQuery("select * from t1 where a=1 or a=2");
1:bc50840:         
1:bc50840:         rs.next();
1:bc50840:         rs.next();
1:bc50840:         rs.previous();
1:bc50840:         verifyTuple(rs);
1:bc50840:         updateTuple(rs);
1:10b9cb1:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      *  Test that you can scroll forward and update indexed records
1:bc50840:      *  in the scrollable ResultSet (using FOR UPDATE).
1:bc50840:      */
1:bc50840:     public void
1:bc50840:         testIndexedScrollInsensitiveUpdateCursorWithForUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery
1:bc50840:             ("select * from t1 where a=1 or a=2 for update");
1:bc50840:         
1:bc50840:         rs.next();
1:bc50840:         rs.next();
1:bc50840:         rs.previous();
1:bc50840:         verifyTuple(rs);
1:bc50840:         updateTuple(rs);
1:bc50840:         rs.close();
1:bc50840:         s.close();
1:bc50840:     }
1:bc50840:    
1:bc50840:     /**
1:bc50840:      * Test update of a keyed record using scrollable updatable
1:bc50840:      * resultset.
1:bc50840:      */
1:bc50840:     public void testPrimaryKeyUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         rs.last();
1:bc50840:         rs.next();
1:bc50840:         while(rs.previous()) {
1:bc50840:             // Update the key of every second row.
1:bc50840:             int key = rs.getInt(1);
1:bc50840:             if (key%2==0) {
1:bc50840:                 int newKey = -key;
1:bc50840:                 rs.updateInt(1, newKey);
1:bc50840:                 rs.updateRow();
1:bc50840:             }
1:bc50840:         }
1:ff65830:         PreparedStatement ps = prepareStatement
1:bc50840:             ("select * from t1 where id=?");
1:bc50840:         for (int i=0; i<recordCount; i++) {
1:bc50840:             int key = (i%2==0) ? -i : i;
1:bc50840:             ps.setInt(1, key);
1:bc50840:             ResultSet rs2 = ps.executeQuery();
1:bc50840:             assertTrue("Expected query to have 1 row", rs2.next());
1:bc50840:             println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:bc50840:                     rs2.getInt(2) + "," +
1:bc50840:                     rs2.getInt(3) + ")");
1:bc50840:             assertEquals("Unexpected value of id", key, rs2.getInt(1));
1:bc50840:             assertTrue("Did not expect more than 1 row, " +
1:bc50840:                        "however rs2.next returned another row",
1:bc50840:                        !rs2.next());
1:bc50840:         }
1:ff65830:         s.close();
1:ff65830:         ps.close();
1:bc50840:     }
1:ff65830:         
1:bc50840:     /**
1:bc50840:      * Test update of a keyed record using other statement
1:bc50840:      * object.
1:bc50840:      */
1:bc50840:     public void testOtherPrimaryKeyUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         rs.last();
1:bc50840:         int primaryKey = rs.getInt(1);
1:ff65830:         PreparedStatement ps = prepareStatement
1:bc50840:             ("update t1 set id = ? where id= ?");
1:bc50840:         ps.setInt(1, -primaryKey);
1:bc50840:         ps.setInt(2, primaryKey);
1:bc50840:         assertEquals("Expected one row to be updated", 1,
1:bc50840:                      ps.executeUpdate());
1:bc50840:         
1:bc50840:         rs.updateInt(2, -555);
1:bc50840:         rs.updateInt(3, -777);
1:bc50840:         rs.updateRow();
1:bc50840:         
1:ff65830:         PreparedStatement ps2 = prepareStatement
1:bc50840:             ("select * from t1 where id=?");
1:bc50840:         ps2.setInt(1, -primaryKey);
1:bc50840:         ResultSet rs2 = ps2.executeQuery();
1:bc50840:         assertTrue("Expected query to have 1 row", rs2.next());
1:bc50840:         println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:bc50840:                 rs2.getInt(2) + "," +
1:bc50840:                 rs2.getInt(3) + ")");
1:bc50840:         assertEquals("Expected a=-555", -555, rs2.getInt(2));
1:bc50840:         assertEquals("Expected b=-777", -777, rs2.getInt(3));
1:bc50840:         assertTrue("Did not expect more than 1 row, however " +
1:bc50840:                    "rs2.next() returned another row", !rs2.next());
1:ff65830:         
1:ff65830:         
1:ff65830:         s.close();
1:9cd0190:         ps.close();
1:ff65830:         ps2.close();
1:bc50840:     }
1:ff65830:     
1:bc50840:     /**
1:bc50840:      * Test update of a keyed record using other both the
1:bc50840:      * scrollable updatable resultset and using another statement
1:bc50840:      * object.
1:bc50840:      */
1:bc50840:     public void testOtherAndOwnPrimaryKeyUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:ff65830:         
1:bc50840:         rs.last();
1:bc50840:         int primaryKey = rs.getInt(1);
1:ff65830:         PreparedStatement ps = prepareStatement
1:bc50840:             ("update t1 set id = ? where id= ?");
1:bc50840:         ps.setInt(1, -primaryKey);
1:bc50840:         ps.setInt(2, primaryKey);
1:bc50840:         assertEquals("Expected one row to be updated", 1,
1:bc50840:                      ps.executeUpdate());
1:bc50840:         rs.updateInt(1, primaryKey*10);
1:bc50840:         rs.updateInt(2, -555);
1:bc50840:         rs.updateInt(3, -777);
1:bc50840:         rs.updateRow();
1:bc50840:         
1:bc50840:         PreparedStatement ps2 =
1:ff65830:             prepareStatement("select * from t1 where id=?");
1:bc50840:         ps2.setInt(1, primaryKey*10);
1:bc50840:         ResultSet rs2 = ps2.executeQuery();
1:bc50840:         assertTrue("Expected query to have 1 row", rs2.next());
1:bc50840:         println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:bc50840:                 rs2.getInt(2) + "," +
1:bc50840:                 rs2.getInt(3) + ")");
1:bc50840:         assertEquals("Expected a=-555", -555, rs2.getInt(2));
1:bc50840:         assertEquals("Expected b=-777", -777, rs2.getInt(3));
1:bc50840:         assertTrue("Did not expect more than 1 row, however " +
1:bc50840:                    "rs2.next() returned another row", !rs2.next());
1:bc50840:         
1:ff65830:         s.close();
1:ff65830:         ps.close();
1:ff65830:         ps2.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Update multiple keyed records using scrollable updatable resultset
1:bc50840:      */
1:bc50840:     public void testMultipleKeyUpdates()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         rs.last();
1:bc50840:         int primaryKey = rs.getInt(1);
1:ff65830:         PreparedStatement ps = s.getConnection().prepareStatement
1:bc50840:             ("update t1 set id = ? where id= ?");
1:bc50840:         ps.setInt(1, -primaryKey);
1:bc50840:         ps.setInt(2, primaryKey);
1:bc50840:         assertEquals("Expected one row to be updated", 1,
1:bc50840:                      ps.executeUpdate());
1:ff65830:         ps.close();
1:bc50840:         rs.updateInt(1, primaryKey*10);
1:bc50840:         rs.updateInt(2, -555);
1:bc50840:         rs.updateInt(3, -777);
1:bc50840:         rs.updateRow();
1:bc50840:         rs.first();
1:bc50840:         rs.last();
1:bc50840:         for (int i=0; i<10; i++) {
1:bc50840:             rs.first();
1:bc50840:             rs.last();
1:bc50840:             rs.next();
1:bc50840:             rs.previous();
1:bc50840:             rs.updateInt(1, primaryKey*10 +i);
1:bc50840:             rs.updateInt(2, (-555 -i));
1:bc50840:             rs.updateInt(3, (-777 -i));
1:bc50840:             rs.updateRow();
1:bc50840:         }
1:ff65830:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test update indexed records using scrollable updatable resultset 
1:bc50840:      */
1:bc50840:     public void testSecondaryIndexKeyUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:bc50840:         
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         rs.last();
1:bc50840:         rs.next();
1:bc50840:         int newKey = 0;
1:bc50840:         while(rs.previous()) {
1:bc50840:             // Update the secondary key of all rows
1:bc50840:             rs.updateInt(2, newKey--);
1:bc50840:             rs.updateRow();
1:bc50840:         }
1:ff65830:         PreparedStatement ps = prepareStatement
1:bc50840:             ("select * from t1 where a=?");
1:bc50840:         for (int i=0; i<recordCount; i++) {
1:bc50840:             int key = -i;
1:bc50840:             ps.setInt(1, key);
1:bc50840:             ResultSet rs2 = ps.executeQuery();
1:bc50840:             assertTrue("Expected query to have 1 row", rs2.next());
1:bc50840:             println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:bc50840:                     rs2.getInt(2) + "," +
1:bc50840:                     rs2.getInt(3) + ")");
1:bc50840:             assertEquals("Unexpected value of id", key, rs2.getInt(2));
1:bc50840:             assertTrue("Did not expect more than 1 row, " +
1:bc50840:                        "however rs2.next returned another row",
1:bc50840:                        !rs2.next());
1:bc50840:         }
1:bc50840:         
1:ff65830:         s.close();
1:ff65830:         ps.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test update indexed records using other statement object
1:bc50840:      * and using resultset.
1:bc50840:      */
1:bc50840:     public void testOtherSecondaryKeyUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         rs.last();
1:bc50840:         int indexedKey = rs.getInt(2);
1:bc50840:         PreparedStatement ps =
1:ff65830:             prepareStatement("update t1 set a = ? where a= ?");
1:bc50840:         ps.setInt(1, -indexedKey);
1:bc50840:         ps.setInt(2, indexedKey);
1:bc50840:         assertEquals("Expected one row to be updated", 1,
1:bc50840:                      ps.executeUpdate());
1:bc50840:         
1:bc50840:         rs.updateInt(1, -555);
1:bc50840:         rs.updateInt(3, -777);
1:bc50840:         rs.updateRow();
1:bc50840:         
1:bc50840:         PreparedStatement ps2 =
1:ff65830:             prepareStatement("select * from t1 where a=?");
1:bc50840:         ps2.setInt(1, -indexedKey);
1:bc50840:         ResultSet rs2 = ps2.executeQuery();
1:bc50840:         assertTrue("Expected query to have 1 row", rs2.next());
1:bc50840:         println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:bc50840:                 rs2.getInt(2) + "," +
1:bc50840:                 rs2.getInt(3) + ")");
1:bc50840:         assertEquals("Expected id=-555", -555, rs2.getInt(1));
1:bc50840:         assertEquals("Expected b=-777", -777, rs2.getInt(3));
1:bc50840:         assertTrue("Did not expect more than 1 row, however " +
1:bc50840:                    "rs2.next() returned another row", !rs2.next());
1:bc50840:         
1:ff65830:         s.close();
1:ff65830:         ps.close();
1:ff65830:         ps2.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test scrolling in a read only resultset
1:bc50840:      */
1:bc50840:     public void testScrollInsensitiveReadOnly1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_READ_ONLY);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         scrollForward(rs);
1:bc50840:         scrollBackward(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test updating a forward only resultset (with FOR UPDATE)
1:bc50840:      */
1:bc50840:     public void testForwardOnlyConcurUpdatableWithForUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:bc50840:         
1:bc50840:         scrollForwardAndUpdate(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test updating a forward only resultset (without FOR UPDATE)
1:bc50840:      */
1:bc50840:     public void testForwardOnlyConcurUpdatableWithoutForUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         scrollForwardAndUpdate(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test updating a forward only resultset (without FOR UPDATE)
1:bc50840:      * and using positioned update
1:bc50840:      */
1:bc50840:     public void testPositionedUpdateWithoutForUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName("MYCURSOR");
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         scrollForwardAndUpdatePositioned(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test updating a forward only resultset (with FOR UPDATE)
1:bc50840:      * and using positioned update
1:bc50840:      */
1:bc50840:     public void testPositionedUpdateWithForUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement();
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:bc50840:         
1:bc50840:         scrollForwardAndUpdatePositioned(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test positioned update of a scrollable resultset (with FOR UPDATE) 
1:bc50840:      */
1:bc50840:     public void testScrollablePositionedUpdateWithForUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement
1:bc50840:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:bc50840:              ResultSet.CONCUR_READ_ONLY);
1:bc50840:         s.setCursorName("MYCURSOR");
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:bc50840:         
1:bc50840:         rs.next();
1:bc50840:         int pKey = rs.getInt(1);
1:bc50840:         rs.previous();
1:bc50840:         rs.next();
1:bc50840:         assertEquals("Expecting to be on the same row after previous() " + 
1:bc50840:                      "+ next() ", pKey, rs.getInt(1));
1:bc50840:         rs.next();
1:bc50840:         rs.previous();
1:bc50840:         assertEquals("Expecting to be on the same row after next() + " + 
1:bc50840:                      "previous()", pKey, rs.getInt(1));
1:bc50840:         final int previousA = rs.getInt(2);
1:bc50840:         final int previousB = rs.getInt(3);
1:bc50840:         println(rs.getCursorName());
1:ff65830:         PreparedStatement ps = prepareStatement
1:bc50840:             ("update T1 set a=?,b=? where current of " + rs.getCursorName());
1:bc50840:         ps.setInt(1, 666);
1:bc50840:         ps.setInt(2, 777);
1:bc50840:         ps.executeUpdate();
1:bc50840:         rs.next();
1:bc50840:         rs.previous();
1:bc50840:         assertEquals("Expected to be on the same row after next() + previous()",
1:bc50840:                      pKey, rs.getInt(1));
1:bc50840:         assertEquals("Expected row to be updated by own change, " + 
1:bc50840:                      " however did not get updated value for column a", 
1:bc50840:                      666, rs.getInt(2));
1:bc50840:         assertEquals("Expected row to be updated by own change, however did " +
1:bc50840:                      "not get updated value for column b", 777, rs.getInt(3));
1:bc50840:         rs.close();
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         rs = s.executeQuery("select * from t1 order by b");
1:bc50840:         
1:bc50840:         while (rs.next()) {
1:bc50840:             if (rs.getInt(1)==pKey) {
1:bc50840:                 assertEquals("Expected row with primary key = " + pKey + 
1:bc50840:                              " to be updated", 666, rs.getInt(2));
1:bc50840:                 assertEquals("Expected row with primary key = " + pKey + 
1:bc50840:                              " to be updated", 777, rs.getInt(3));
1:bc50840:             } else {
1:bc50840:                 println("Got tuple (" + rs.getInt(1) + "," + rs.getInt(2) + 
1:bc50840:                         "," + rs.getInt(3) + "," + rs.getString(4)+ ")");
1:bc50840:             }
1:bc50840:         }
1:ff65830: 
1:ff65830:         s.close();
1:ff65830:         ps.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test update of a scrollable resultset (with FOR UPDATE)
1:bc50840:      * Only scrolling forward
1:bc50840:      */
1:bc50840:     public void testScrollInsensitiveConcurUpdatableWithForUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:bc50840:         scrollForwardAndUpdate(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test update of a scrollable resultset (with FOR UPDATE) 
1:bc50840:      * Scrolling forward and backward.
1:bc50840:      */
1:bc50840:     public void testScrollInsensitiveConcurUpdatableWithForUpdate2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         assertEquals("Invalid resultset concurrency on statement", 
1:bc50840:                      ResultSet.CONCUR_UPDATABLE, s.getResultSetConcurrency());
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:bc50840:         
1:bc50840:         assertEquals("Invalid resultset concurrency on resultset", 
1:bc50840:                      ResultSet.CONCUR_UPDATABLE, rs.getConcurrency());
1:bc50840:         scrollForward(rs);
1:bc50840:         scrollBackwardAndUpdate(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test update of a scrollable resultset
1:bc50840:      * Scrolling forward and backward. Then open another
1:bc50840:      * resultset and verify the data.
1:bc50840:      */
1:bc50840:     private void testScrollInsensistiveConurUpdatable3(ResultSet rs) 
1:bc50840:         throws SQLException 
1:bc50840:     {
1:bc50840:         while (rs.next()) {
1:bc50840:         }
1:bc50840:         while (rs.previous()) {
1:bc50840:             int a = rs.getInt(1);
1:bc50840:             int b = rs.getInt(2);
1:bc50840:             int id = b - 17 - a;
1:bc50840:             int newA = 1000;
1:bc50840:             int newB = id + newA + 17;
1:bc50840:             rs.updateInt(1, newA); // Set a to 1000
1:bc50840:             rs.updateInt(2, newB); // Set b to checksum value
1:bc50840:             rs.updateRow();
1:bc50840:             
1:bc50840:             assertEquals("Expected a to be 1000", 1000, rs.getInt(1));
1:bc50840:         }
1:bc50840:         int count = 0;
1:bc50840:         while (rs.next()) {
1:bc50840:             int a = rs.getInt(1);
1:bc50840:             count++;
1:bc50840:             assertEquals("Incorrect row updated for row " + count, 1000, a);
1:bc50840:         }
1:bc50840:         assertEquals("Expected count to be the same as number of records", 
1:bc50840:                      recordCount, count);
1:bc50840:         while (rs.previous()) {
1:bc50840:             int a = rs.getInt(1);
1:bc50840:             count--;
1:bc50840:             assertEquals("Incorrect row updated for row " + count, 1000, a);
1:bc50840:         }
1:bc50840:         rs.close();
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:bc50840:                                           ResultSet.CONCUR_READ_ONLY);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         while (rs.next()) {
1:bc50840:             int id = rs.getInt(1);
1:bc50840:             int a = rs.getInt(2);
1:bc50840:             int b = rs.getInt(3);
1:bc50840:             println("Updated tuple:" + id + "," + a + "," + b);
1:bc50840:         }
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test update of a scrollable resultset (with FOR UPDATE)
1:bc50840:      * Scrolling forward and backward. Then open another
1:bc50840:      * resultset and verify the data.
1:bc50840:      */
1:bc50840:     public void testScrollInsensitiveConcurUpdatableWithForUpdate3()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select a,b from t1 for update");
1:bc50840:         
1:bc50840:         testScrollInsensistiveConurUpdatable3(rs);
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test update of a scrollable resultset (without FOR UPDATE) 
1:bc50840:      * Scrolling forward only
1:bc50840:      */
1:bc50840:     public void testScrollInsensitiveConcurUpdatableWithoutForUpdate1()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         scrollForwardAndUpdate(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test update of a scrollable resultset (without FOR UPDATE) 
1:bc50840:      * Scrolling forward and backward.
1:bc50840:      */
1:bc50840:     public void testScrollInsensitiveConcurUpdatableWithoutForUpdate2()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select * from t1");
1:bc50840:         
1:bc50840:         scrollForward(rs);
1:bc50840:         scrollBackwardAndUpdate(rs);
1:bc50840:         rs.close();
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:bc50840:      * Test update of a scrollable resultset (without FOR UPDATE)
1:bc50840:      * Scrolling forward and backward. Then open another
1:bc50840:      * resultset and verify the data.
1:bc50840:      */
1:bc50840:     public void testScrollInsensitiveConcurUpdatableWithoutForUpdate3()
1:bc50840:         throws SQLException 
1:bc50840:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:bc50840:                                           ResultSet.CONCUR_UPDATABLE);
1:bc50840:         s.setCursorName(getNextCursorName());
1:bc50840:         ResultSet rs = s.executeQuery("select a,b from t1");
1:bc50840:         
1:bc50840:         testScrollInsensistiveConurUpdatable3(rs);
1:ff65830:         s.close();
1:bc50840:     }
1:bc50840:     
1:bc50840:     /**
1:7d0f620:      * DERBY-4198 "When using the FOR UPDATE OF clause with SUR
1:7d0f620:      * (Scroll-insensive updatable result sets), the updateRow() method crashes"
1:7d0f620:      *
1:7d0f620:      * This bug revealed missing logic to handle the fact the the ExecRow
1:7d0f620:      * passed down to ScrollInsensitiveResultSet.updateRow does not always
1:7d0f620:      * contain all the rows of the basetable, cf. the logic of RowChangerImpl.
1:7d0f620:      * When an explicit list of columns is given as in FOR UPDATE OF
1:dbed020:      * &lt;column-list&gt;, the ExecRow may contains a subset of the the base table
1:7d0f620:      * columns and ScrollInsensitiveResultSet was not ready to handle that.
1:7d0f620:      *
1:7d0f620:      * Test some of the cases which went wrong before the fix.
1:7d0f620:      *
1:7d0f620:      */
1:7d0f620:     public void testForUpdateWithColumnList() throws SQLException {
1:7d0f620:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:7d0f620:                                           ResultSet.CONCUR_UPDATABLE);
1:7d0f620: 
1:7d0f620:         // case a)
1:7d0f620:         ResultSet rs = s.executeQuery("select c from t1 for update of c");
1:7d0f620: 
1:7d0f620:         rs.next();
1:7d0f620:         rs.updateString(1,"foobar");
1:7d0f620:         rs.updateRow();
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         assertEquals("foobar", rs.getString(1));
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // case b)
1:7d0f620:         rs = s.executeQuery("select id from t1 for update of id");
1:7d0f620:         rs.next();
1:7d0f620:         rs.updateInt(1,20);
1:7d0f620:         rs.updateRow();
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         assertEquals(20, rs.getInt(1));
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // case c)
1:7d0f620:         rs = s.executeQuery("select * from t1 for update of id");
1:7d0f620:         rs.next();
1:7d0f620:         rs.updateInt(1,20);
1:7d0f620:         rs.updateRow();
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         assertEquals(20, rs.getInt(1));
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // case d)
1:7d0f620:         rs = s.executeQuery("SELECT * from t1 for update of c");
1:7d0f620:         rs.next();
1:7d0f620:         int id = rs.getInt(1);
1:7d0f620:         int a =  rs.getInt(2);
1:7d0f620:         int b =  rs.getInt(3);
1:7d0f620:         rs.updateString(4,"foobar");
1:7d0f620:         rs.updateRow();
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         assertEquals(id, rs.getInt(1));
1:7d0f620:         assertEquals(a, rs.getInt(2));
1:7d0f620:         assertEquals(b, rs.getInt(3));
1:7d0f620:         assertEquals("foobar", rs.getString(4));
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // case e)
1:7d0f620:         rs = s.executeQuery("SELECT * from t1 for update of id,a,b,c");
1:7d0f620:         rs.next();
1:7d0f620:         rs.updateInt(1, -20);
1:7d0f620:         rs.updateInt(2, 20);
1:7d0f620:         rs.updateInt(3, 21);
1:7d0f620:         rs.updateString(4,"foobar");
1:7d0f620:         rs.updateRow();
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         assertEquals(-20, rs.getInt(1));
1:7d0f620:         assertEquals(20, rs.getInt(2));
1:7d0f620:         assertEquals(21, rs.getInt(3));
1:7d0f620:         assertEquals("foobar", rs.getString(4));
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // case f)
1:7d0f620:         rs = s.executeQuery("SELECT * from t1 for update of id, a,b,c");
1:7d0f620:         rs.next();
1:7d0f620:         rs.updateInt(1, 20);
1:7d0f620:         rs.updateRow();
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         assertEquals(20, rs.getInt(1));
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // case h)
1:7d0f620:         rs = s.executeQuery("SELECT id from t1 for update of id, c");
1:7d0f620:            String cursorname = rs.getCursorName();
1:7d0f620:         rs.next();
1:7d0f620:            Statement s2 = createStatement();
1:7d0f620:         s2.executeUpdate("update t1 set c='foobar' where current of " +
1:7d0f620:                          cursorname);
1:7d0f620:         s2.close();
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         rs.getInt(1); // gives error state 22018 before fix
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // case i)
1:7d0f620:         rs = s.executeQuery("SELECT id from t1 for update");
1:7d0f620:         cursorname = rs.getCursorName();
1:7d0f620:         rs.next();
1:7d0f620:         s2 = createStatement();
1:7d0f620:         s2.executeUpdate("update t1 set c='foobar' where current of " +
1:7d0f620:                          cursorname);
1:7d0f620:         s2.close();
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         rs.getInt(1); // ok before fix
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // Odd cases: base row mentioned twice in rs, update 1st instance
1:7d0f620:         rs = s.executeQuery("SELECT id,a,id from t1");
1:7d0f620:         rs.next();
1:7d0f620:         rs.updateInt(1, 20);
1:7d0f620:         rs.updateRow();
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         assertEquals(20, rs.getInt(1));
1:7d0f620:         assertEquals(20, rs.getInt(3));
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // Odd cases: base row mentioned twice in rs, update 2nd instance
1:7d0f620:         // with explicit column list; fails, see DERBY-4226.
1:7d0f620:         rs = s.executeQuery("SELECT id,a,id from t1 for update of id");
1:7d0f620:         rs.next();
1:7d0f620:         try {
1:7d0f620:             rs.updateInt(3, 20);
1:7d0f620:             fail("should fail");
1:7d0f620:         } catch (SQLException e) {
1:7d0f620:             String sqlState = usingEmbedded() ? "42X31" : "XJ124";
1:7d0f620:             assertSQLState(sqlState, e);
1:7d0f620:         }
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         // Odd cases: base row mentioned twice in rs, update 2nd instance
1:7d0f620:         // without explicit column list; works
1:7d0f620:         rs = s.executeQuery("SELECT id,a,id from t1 for update");
1:7d0f620:         rs.next();
1:7d0f620:         rs.updateInt(3, 20);
1:7d0f620:         rs.updateRow();
1:7d0f620:         assertEquals(20, rs.getInt(1));
1:7d0f620:         assertEquals(20, rs.getInt(3));
1:7d0f620:         rs.next();
1:7d0f620:         rs.previous();
1:7d0f620:         assertEquals(20, rs.getInt(1));
1:7d0f620:         assertEquals(20, rs.getInt(3));
1:7d0f620:         rs.close();
1:7d0f620: 
1:7d0f620:         s.close();
1:7d0f620:     }
1:7d0f620: 
1:7d0f620: 
1:7d0f620:     /**
1:6b0118a:      * Check that detectability methods throw the correct exception
1:6b0118a:      * when called in an illegal row state, that is, somehow not
1:6b0118a:      * positioned on a row. Minion of testDetectabilityExceptions.
1:6b0118a:      *
1:6b0118a:      * @param rs An open updatable result set.
1:6b0118a:      * @param state A string describing the illegal state.
1:6b0118a:      */
1:6b0118a:     private void checkDetectabilityCallsOutsideRow(ResultSet rs, 
1:6b0118a:                                                    String state)
1:6b0118a:     {
1:6b0118a:         boolean b;
1:6b0118a:         
1:6b0118a:         try {
1:6b0118a:             b = rs.rowUpdated();
1:6b0118a:             fail("rowUpdated while " + state + 
1:6b0118a:                  " did not throw exception: " + b);
1:6b0118a:         } catch (SQLException e) {
1:6b0118a:             assertEquals(e.getSQLState(),
1:6b0118a:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:6b0118a:         }
1:6b0118a: 
1:6b0118a:         try {
1:6b0118a:             b = rs.rowDeleted();
1:6b0118a:             fail("rowdeleted while " + state + 
1:6b0118a:                  " did not throw exception: " + b);
1:6b0118a:         } catch (SQLException e) {
1:6b0118a:             assertEquals(e.getSQLState(),
1:6b0118a:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:6b0118a:         }
1:6b0118a: 
1:6b0118a:         try {
1:6b0118a:             b = rs.rowInserted();
1:6b0118a:             fail("rowInserted while " + state + 
1:6b0118a:                  " did not throw exception: " + b);
1:6b0118a:         } catch (SQLException e) {
1:6b0118a:             assertEquals(e.getSQLState(),
1:6b0118a:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:6b0118a:         }
1:6b0118a:     }
1:6b0118a: 
1:6b0118a: 
1:6b0118a:     /**
1:4e091b6:      * Test that rowUpdated() and rowDeleted() methods both return true when
1:4e091b6:      * the row has first been updated and then deleted using the updateRow()
1:4e091b6:      * and deleteRow() methods.
1:4e091b6:      */
1:4e091b6:     public void testRowUpdatedAndRowDeleted() throws SQLException {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:4e091b6:                                            ResultSet.CONCUR_UPDATABLE);
1:4e091b6:         s.setCursorName(getNextCursorName());
1:4e091b6:         ResultSet rs = s.executeQuery("select a,b from t1");
1:4e091b6:         rs.next();
1:4e091b6:         rs.updateInt(1, rs.getInt(1) + 2 * recordCount);
1:4e091b6:         rs.updateRow();
1:4e091b6:         assertTrue("Expected rowUpdated() to return true", rs.rowUpdated());
1:4e091b6:         rs.deleteRow();
1:4e091b6:         rs.next();
1:4e091b6:         rs.previous();
1:4e091b6:         assertTrue("Expected rowUpdated() to return true", rs.rowUpdated());
1:4e091b6:         assertTrue("Expected rowDeleted() to return true", rs.rowDeleted());
1:4e091b6:         rs.next();
1:4e091b6:         assertFalse("Expected rowUpdated() to return false", rs.rowUpdated());
1:4e091b6:         assertFalse("Expected rowDeleted() to return false", rs.rowDeleted());
1:4e091b6:         rs.previous();
1:4e091b6:         assertTrue("Expected rowUpdated() to return true", rs.rowUpdated());
1:4e091b6:         assertTrue("Expected rowDeleted() to return true", rs.rowDeleted());
1:4e091b6:         rs.close();
1:4e091b6:         s.close();
1:4e091b6:     }
1:4e091b6: 
1:4e091b6: 
1:4e091b6:     /**
1:6b0118a:      * Test that the JDBC detectability calls throw correct exceptions when
1:6b0118a:      * called in in wrong row states. 
1:6b0118a:      * This is done for both supported updatable result set types.
1:6b0118a:      */
1:6b0118a:     public void testDetectabilityExceptions() throws SQLException 
1:6b0118a:     {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:6b0118a:                                           ResultSet.CONCUR_UPDATABLE);
1:6b0118a:         ResultSet rs = s.executeQuery("select * from t1");
1:6b0118a:         
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "before positioning");
1:6b0118a: 
1:6b0118a:         rs.moveToInsertRow();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, 
1:6b0118a:                                           "on insertRow before positioning");
1:6b0118a: 
1:6b0118a:         rs.next();
1:6b0118a:         rs.moveToInsertRow();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "on insertRow");
1:6b0118a:         rs.moveToCurrentRow(); // needed until to DERBY-1322 is fixed
1:6b0118a: 
1:6b0118a:         rs.beforeFirst();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "on beforeFirst row");
1:6b0118a: 
1:6b0118a:         rs.afterLast();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "on afterLast row");
1:6b0118a: 
1:6b0118a:         rs.first();
1:6b0118a:         rs.deleteRow();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "after deleteRow");
1:6b0118a: 
1:6b0118a:         rs.last();
1:6b0118a:         rs.deleteRow();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "after deleteRow of last row");
1:6b0118a: 
1:6b0118a:         rs.close();
1:6b0118a:         s.close();
1:6b0118a: 
1:6b0118a:         // Not strictly SUR, but fixed in same patch, so we test it here.
1:ff65830:         s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:6b0118a:                                 ResultSet.CONCUR_UPDATABLE);
1:6b0118a:         rs = s.executeQuery("select * from t1");
1:6b0118a: 
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "before FO positioning");
1:6b0118a: 
1:6b0118a:         rs.moveToInsertRow();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, 
1:6b0118a:                                           "on insertRow before FO positioning");
1:6b0118a: 
1:6b0118a:         rs.next();
1:6b0118a:         rs.moveToInsertRow();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "on FO insertRow");
1:6b0118a: 
1:6b0118a:         rs.next();
1:6b0118a:         rs.updateInt(2, 666);
1:6b0118a:         rs.updateRow();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "after FO updateRow");
1:6b0118a: 
1:6b0118a:         rs.next();
1:6b0118a:         rs.deleteRow();
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "after FO deleteRow");
1:6b0118a: 
1:6b0118a:         while (rs.next()) {};
1:6b0118a:         checkDetectabilityCallsOutsideRow(rs, "after FO emptied out");
1:6b0118a: 
1:6b0118a:         rs.close();
1:6b0118a:         s.close();
1:6b0118a:     }
1:6b0118a: 
1:6b0118a:     /**
1:1b7b14f:      * DERBY-1481 - ResultSet.beforeFirst() gives protocol error on scrollable,
1:1b7b14f:      * updatable result sets that are downgraded to read-only
1:1b7b14f:      * 
1:1b7b14f:      * Check that no exception is thrown when calling positioning methods on a
1:1b7b14f:      * result set that has been downgraded to read-only.
1:1b7b14f:      *
1:1b7b14f:      */
1:1b7b14f:     public void testDowngradeToScrollReadOnly() throws SQLException {
1:ff65830:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:1b7b14f:                                           ResultSet.CONCUR_UPDATABLE);
1:1b7b14f:         ResultSet rs = s.executeQuery("select * from t1 order by b");
1:1b7b14f: 
1:1b7b14f:         // check that the ResultSet was downgraded
1:1b7b14f:         assertWarning(rs.getWarnings(), 
1:1b7b14f:                 QUERY_NOT_QUALIFIED_FOR_UPDATABLE_RESULTSET);
1:1b7b14f:         
1:1b7b14f:         // call positioning methods
1:1b7b14f:         rs.next();
1:1b7b14f:         rs.next();
1:1b7b14f:         rs.previous();
1:1b7b14f:         rs.relative(1);
1:1b7b14f:         rs.absolute(3);
1:1b7b14f:         rs.relative(-1);
1:1b7b14f:         rs.first();
1:1b7b14f:         rs.last();
1:1b7b14f:         rs.beforeFirst();
1:1b7b14f:         rs.afterLast();
1:1b7b14f:         
1:1b7b14f:         // close result set and statement
1:1b7b14f:         rs.close();
1:1b7b14f:         s.close();
1:1b7b14f:     }
1:6b0118a: 
1:bc50840: 
1:bc50840:     /**
1:e41dc70:      * Get a cursor name. We use the same cursor name for all cursors.
1:bc50840:      */
1:bc50840:     private final String getNextCursorName() {
1:e41dc70:         return "MYCURSOR";
1:bc50840:     }
1:a708311:     
1:a708311:     /**
1:a708311:      * Run the base suite in embedded and client mode.
1:a708311:      */
1:a708311:     public static Test suite() {
1:1ae02c9:         BaseTestSuite mainSuite = new BaseTestSuite("SURTest");
1:a708311:         mainSuite.addTest(baseSuite("SURTest:embedded"));
1:a708311:         mainSuite.addTest(
1:a708311:                 TestConfiguration.clientServerDecorator(baseSuite("SURTest:client")));
1:a708311:         return mainSuite;      
1:a708311:     }
1:d038483:     
1:bc50840:     /**
1:bc50840:      * The suite contains all testcases in this class running on different 
1:bc50840:      * data models
1:bc50840:      */
1:a708311:     private static Test baseSuite(String name) { 
1:41c47be:         
1:1ae02c9:         BaseTestSuite mainSuite = new BaseTestSuite(name);
1:bc50840:         
1:bc50840:         // Iterate over all data models and decorate the tests:
1:bc50840:         for (Iterator i = SURDataModelSetup.SURDataModel.values().iterator();
1:bc50840:              i.hasNext();) {
1:bc50840:             
1:bc50840:             SURDataModelSetup.SURDataModel model = 
1:bc50840:                 (SURDataModelSetup.SURDataModel) i.next();
1:bc50840:             
1:1ae02c9:             BaseTestSuite suite = new BaseTestSuite(SURTest.class);
1:bc50840:             TestSetup decorator = new SURDataModelSetup
1:bc50840:                 (suite, model);
1:bc50840:             
1:bc50840:             mainSuite.addTest(decorator);    
1:41c47be:         }
1:bc50840:         
1:a708311:         return mainSuite;
1:bc50840:     }
1:bc50840: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * &lt;column-list&gt;, the ExecRow may contains a subset of the the base table
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.util.Iterator;
1: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite mainSuite = new BaseTestSuite("SURTest");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite mainSuite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:             BaseTestSuite suite = new BaseTestSuite(SURTest.class);
commit:7d0f620
/////////////////////////////////////////////////////////////////////////
1:      * DERBY-4198 "When using the FOR UPDATE OF clause with SUR
1:      * (Scroll-insensive updatable result sets), the updateRow() method crashes"
1:      *
1:      * This bug revealed missing logic to handle the fact the the ExecRow
1:      * passed down to ScrollInsensitiveResultSet.updateRow does not always
1:      * contain all the rows of the basetable, cf. the logic of RowChangerImpl.
1:      * When an explicit list of columns is given as in FOR UPDATE OF
0:      * <column-list>, the ExecRow may contains a subset of the the base table
1:      * columns and ScrollInsensitiveResultSet was not ready to handle that.
1:      *
1:      * Test some of the cases which went wrong before the fix.
1:      *
1:      */
1:     public void testForUpdateWithColumnList() throws SQLException {
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                           ResultSet.CONCUR_UPDATABLE);
1: 
1:         // case a)
1:         ResultSet rs = s.executeQuery("select c from t1 for update of c");
1: 
1:         rs.next();
1:         rs.updateString(1,"foobar");
1:         rs.updateRow();
1:         rs.next();
1:         rs.previous();
1:         assertEquals("foobar", rs.getString(1));
1:         rs.close();
1: 
1:         // case b)
1:         rs = s.executeQuery("select id from t1 for update of id");
1:         rs.next();
1:         rs.updateInt(1,20);
1:         rs.updateRow();
1:         rs.next();
1:         rs.previous();
1:         assertEquals(20, rs.getInt(1));
1:         rs.close();
1: 
1:         // case c)
1:         rs = s.executeQuery("select * from t1 for update of id");
1:         rs.next();
1:         rs.updateInt(1,20);
1:         rs.updateRow();
1:         rs.next();
1:         rs.previous();
1:         assertEquals(20, rs.getInt(1));
1:         rs.close();
1: 
1:         // case d)
1:         rs = s.executeQuery("SELECT * from t1 for update of c");
1:         rs.next();
1:         int id = rs.getInt(1);
1:         int a =  rs.getInt(2);
1:         int b =  rs.getInt(3);
1:         rs.updateString(4,"foobar");
1:         rs.updateRow();
1:         rs.next();
1:         rs.previous();
1:         assertEquals(id, rs.getInt(1));
1:         assertEquals(a, rs.getInt(2));
1:         assertEquals(b, rs.getInt(3));
1:         assertEquals("foobar", rs.getString(4));
1:         rs.close();
1: 
1:         // case e)
1:         rs = s.executeQuery("SELECT * from t1 for update of id,a,b,c");
1:         rs.next();
1:         rs.updateInt(1, -20);
1:         rs.updateInt(2, 20);
1:         rs.updateInt(3, 21);
1:         rs.updateString(4,"foobar");
1:         rs.updateRow();
1:         rs.next();
1:         rs.previous();
1:         assertEquals(-20, rs.getInt(1));
1:         assertEquals(20, rs.getInt(2));
1:         assertEquals(21, rs.getInt(3));
1:         assertEquals("foobar", rs.getString(4));
1:         rs.close();
1: 
1:         // case f)
1:         rs = s.executeQuery("SELECT * from t1 for update of id, a,b,c");
1:         rs.next();
1:         rs.updateInt(1, 20);
1:         rs.updateRow();
1:         rs.next();
1:         rs.previous();
1:         assertEquals(20, rs.getInt(1));
1:         rs.close();
1: 
1:         // case h)
1:         rs = s.executeQuery("SELECT id from t1 for update of id, c");
1:            String cursorname = rs.getCursorName();
1:         rs.next();
1:            Statement s2 = createStatement();
1:         s2.executeUpdate("update t1 set c='foobar' where current of " +
1:                          cursorname);
1:         s2.close();
1:         rs.next();
1:         rs.previous();
1:         rs.getInt(1); // gives error state 22018 before fix
1:         rs.close();
1: 
1:         // case i)
1:         rs = s.executeQuery("SELECT id from t1 for update");
1:         cursorname = rs.getCursorName();
1:         rs.next();
1:         s2 = createStatement();
1:         s2.executeUpdate("update t1 set c='foobar' where current of " +
1:                          cursorname);
1:         s2.close();
1:         rs.next();
1:         rs.previous();
1:         rs.getInt(1); // ok before fix
1:         rs.close();
1: 
1:         // Odd cases: base row mentioned twice in rs, update 1st instance
1:         rs = s.executeQuery("SELECT id,a,id from t1");
1:         rs.next();
1:         rs.updateInt(1, 20);
1:         rs.updateRow();
1:         rs.next();
1:         rs.previous();
1:         assertEquals(20, rs.getInt(1));
1:         assertEquals(20, rs.getInt(3));
1:         rs.close();
1: 
1:         // Odd cases: base row mentioned twice in rs, update 2nd instance
1:         // with explicit column list; fails, see DERBY-4226.
1:         rs = s.executeQuery("SELECT id,a,id from t1 for update of id");
1:         rs.next();
1:         try {
1:             rs.updateInt(3, 20);
1:             fail("should fail");
1:         } catch (SQLException e) {
1:             String sqlState = usingEmbedded() ? "42X31" : "XJ124";
1:             assertSQLState(sqlState, e);
1:         }
1:         rs.close();
1: 
1:         // Odd cases: base row mentioned twice in rs, update 2nd instance
1:         // without explicit column list; works
1:         rs = s.executeQuery("SELECT id,a,id from t1 for update");
1:         rs.next();
1:         rs.updateInt(3, 20);
1:         rs.updateRow();
1:         assertEquals(20, rs.getInt(1));
1:         assertEquals(20, rs.getInt(3));
1:         rs.next();
1:         rs.previous();
1:         assertEquals(20, rs.getInt(1));
1:         assertEquals(20, rs.getInt(3));
1:         rs.close();
1: 
1:         s.close();
1:     }
1: 
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1: 
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:7dc89cf
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cd1bd2a
/////////////////////////////////////////////////////////////////////////
0:         if (usingDB2Client())
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:dff95a1
/////////////////////////////////////////////////////////////////////////
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9cd0190
/////////////////////////////////////////////////////////////////////////
1:         ps.close();
commit:a708311
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Run the base suite in embedded and client mode.
0:      * @return
1:      */
1:     public static Test suite() {
0:         TestSuite mainSuite = new TestSuite("SURTest");
0:         // DB2 client doesn't support this functionality
0:         if (usingDerbyNet())
1:             return mainSuite;
1:         
1:         mainSuite.addTest(baseSuite("SURTest:embedded"));
1:         mainSuite.addTest(
1:                 TestConfiguration.clientServerDecorator(baseSuite("SURTest:client")));
1:         return mainSuite;      
1:     }
1:     private static Test baseSuite(String name) { 
0:         TestSuite mainSuite = new TestSuite(name);
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite mainSuite = new TestSuite("SURTest");
commit:985662b
/////////////////////////////////////////////////////////////////////////
commit:ff65830
/////////////////////////////////////////////////////////////////////////
1: 
0: import java.sql.Connection;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:         rollback();
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:         rollback();
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         final Statement s = createStatement(resultSetType, 
/////////////////////////////////////////////////////////////////////////
1:         commit();
1:             prepareStatement("update t1 set a=? where current of " +
/////////////////////////////////////////////////////////////////////////
1:         s.close();
1:         ps.close();
1:         
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:         createStatement().executeUpdate("delete from t1 where id=" +
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:         createStatement().executeUpdate ("delete from t1 where id=" +
1:         Statement s3 = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         Statement s4 = createStatement();
/////////////////////////////////////////////////////////////////////////
1:         s.close();
1:         s3.close();
1:         s4.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement
/////////////////////////////////////////////////////////////////////////
1:         s.close();
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps2 = prepareStatement
/////////////////////////////////////////////////////////////////////////
1:         
1:         
1:         s.close();
1:         ps.close();
1:         ps2.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("select * from t1 where id=?");
/////////////////////////////////////////////////////////////////////////
1:         
1:         s.close();
1:         ps.close();
1:         ps2.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = s.getConnection().prepareStatement
/////////////////////////////////////////////////////////////////////////
1:         rs.close();
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement
/////////////////////////////////////////////////////////////////////////
1:         
1:         s.close();
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("update t1 set a = ? where a= ?");
/////////////////////////////////////////////////////////////////////////
1:             prepareStatement("select * from t1 where a=?");
/////////////////////////////////////////////////////////////////////////
1:         
1:         s.close();
1:         ps.close();
1:         ps2.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement();
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = prepareStatement
/////////////////////////////////////////////////////////////////////////
1: 
1:         s.close();
1:         ps.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:         s.close();
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
/////////////////////////////////////////////////////////////////////////
1:         s = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement s = createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
commit:d038483
/////////////////////////////////////////////////////////////////////////
0:         // DB2 client doesn't support this functionality
0:         if (usingDerbyNet())
0:             return mainSuite;
1:         
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:41c47be
/////////////////////////////////////////////////////////////////////////
1: 
0:     protected void tearDown() throws Exception {
0:         super.tearDown();
0:         con = null;
1:     }
commit:1b7b14f
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-1481 - ResultSet.beforeFirst() gives protocol error on scrollable,
1:      * updatable result sets that are downgraded to read-only
1:      * 
1:      * Check that no exception is thrown when calling positioning methods on a
1:      * result set that has been downgraded to read-only.
1:      *
1:      */
1:     public void testDowngradeToScrollReadOnly() throws SQLException {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1 order by b");
1: 
1:         // check that the ResultSet was downgraded
1:         assertWarning(rs.getWarnings(), 
1:                 QUERY_NOT_QUALIFIED_FOR_UPDATABLE_RESULTSET);
1:         
1:         // call positioning methods
1:         rs.next();
1:         rs.next();
1:         rs.previous();
1:         rs.relative(1);
1:         rs.absolute(3);
1:         rs.relative(-1);
1:         rs.first();
1:         rs.last();
1:         rs.beforeFirst();
1:         rs.afterLast();
1:         
1:         // close result set and statement
1:         rs.close();
1:         s.close();
1:     }
commit:a1c5d5f
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Test that you can correctly run multiple updateXXX() + updateRow() 
1:      * combined with cancelRowUpdates().
1:      */
1:     public void testMultiUpdateRow1() 
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.absolute(5);
1:         final int oldCol2 = rs.getInt(2);
1:         final int newCol2 = -2222;
1:         final int oldCol3 = rs.getInt(3);
1:         final int newCol3 = -3333;
1:                 
1:         rs.updateInt(2, newCol2);
1:         assertEquals("Expected the resultset to be updated after updateInt",
1:                      newCol2, rs.getInt(2));
1:         rs.cancelRowUpdates();
1:         assertEquals("Expected updateXXX to have no effect after cancelRowUpdated",
1:                      oldCol2, rs.getInt(2));
1:         rs.updateInt(2, newCol2);
1:         assertEquals("Expected the resultset to be updated after updateInt", 
1:                      newCol2, rs.getInt(2));
1:         assertTrue("Expected rs.rowUpdated() to be false before updateRow", 
1:                    !rs.rowUpdated());
1:         rs.updateRow();
1:         
1:         assertTrue("Expected rs.rowUpdated() to be true after updateRow", 
1:                    rs.rowUpdated());
1:         assertEquals("Expected the resultset detect the updates of previous " + 
1:                      "updateRow", newCol2, rs.getInt(2));
1:         
1:         rs.updateInt(3, newCol3);
1:         
1:         assertEquals("Expected the resultset to be updated after updateInt", 
1:                      newCol3, rs.getInt(3));
1:         assertEquals("Expected the resultset detect the updates of previous " + 
1:                      "updateRow", newCol2, rs.getInt(2));
1:         
1:         rs.cancelRowUpdates();
1:         
1:         assertEquals("Expected updateXXX to have no effect after " +
1:                      "cancelRowUpdated", oldCol3, rs.getInt(3));
1:         assertEquals("Expected the resultset detect the updates of previous " +
1:                      "updateRow after cancelRowUpdated", newCol2, rs.getInt(2));
1:         rs.updateInt(3, newCol3);
1:         rs.updateRow();
1:         assertEquals("Expected the resultset to be updated after updateInt", 
1:                      newCol3, rs.getInt(3));
1:         rs.cancelRowUpdates();
1:         
1:         assertEquals("Expected the resultset detect the updates of previous" + 
1:                      "updateRow after cancelRowUpdates", newCol2, rs.getInt(2));
1:         assertEquals("Expected the resultset detect the updates of previous" + 
1:                      "updateRow after cancelRowUpdates", newCol3, rs.getInt(3));
1:         assertTrue("Expected rs.rowUpdated() to be true after " + 
1:                    "updateRow and cancelRowUpdates", rs.rowUpdated());
1:         
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Test that you can correctly run multiple updateNull() + updateRow() 
1:      * combined with cancelRowUpdates().
1:      */
1:     public void testMultiUpdateRow2() 
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.absolute(5);
1:         final int oldCol2 = rs.getInt(2);
1:         final int oldCol3 = rs.getInt(3);
1:         
1:         rs.updateNull(2);
1:         assertEquals("Expected the resultset to be updated after updateNull",
1:                      0, rs.getInt(2));
1:         assertTrue("Expected wasNull to be true after updateNull", rs.wasNull());
1:         rs.cancelRowUpdates();
1:         assertEquals("Expected updateXXX to have no effect after cancelRowUpdated",
1:                      oldCol2, rs.getInt(2));
1:         rs.updateNull(2);
1:         assertEquals("Expected the resultset to be updated after updateNull", 
1:                      0, rs.getInt(2));
1:         assertTrue("Expected wasNull to be true after updateNull", rs.wasNull());
1:         assertTrue("Expected rs.rowUpdated() to be false before updateRow", 
1:                    !rs.rowUpdated());
1:         rs.updateRow();
1:         
1:         assertTrue("Expected rs.rowUpdated() to be true after updateRow", 
1:                    rs.rowUpdated());
1:         assertEquals("Expected the resultset detect the updates of previous " + 
1:                      "updateRow", 0, rs.getInt(2));
1:         
1:         rs.updateNull(3);
1:         
1:         assertEquals("Expected the resultset to be updated after updateNull", 
1:                      0, rs.getInt(3));
1:         assertTrue("Expected wasNull to be true after updateNull", rs.wasNull());
1:         assertEquals("Expected the resultset detect the updates of previous " + 
1:                      "updateRow", 0, rs.getInt(2));
1:         
1:         rs.cancelRowUpdates();
1:         
1:         assertEquals("Expected updateXXX to have no effect after " +
1:                      "cancelRowUpdated", oldCol3, rs.getInt(3));
1:         assertEquals("Expected the resultset detect the updates of previous " +
1:                      "updateRow after cancelRowUpdated", 0, rs.getInt(2));
1:         rs.updateNull(3);
1:         rs.updateRow();
1:         assertEquals("Expected the resultset to be updated after updateNull", 
1:                      0, rs.getInt(3));
1:         rs.cancelRowUpdates();
1:         
1:         assertEquals("Expected the resultset detect the updates of previous" + 
1:                      "updateRow after cancelRowUpdates", 0, rs.getInt(2));
1:         assertEquals("Expected the resultset detect the updates of previous" + 
1:                      "updateRow after cancelRowUpdates", 0, rs.getInt(3));
1:         assertTrue("Expected rs.rowUpdated() to be true after " + 
1:                    "updateRow and cancelRowUpdates", rs.rowUpdated());
1:         
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Test that you get cursor operation conflict warning if updating 
1:      * a row which has been deleted from the table.
1:      */
1:     public void testCursorOperationConflictWarning1() 
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next();
0:         con.createStatement().executeUpdate("delete from t1 where id=" +
1:                                             rs.getString("ID"));
1:         final int newValue = -3333;
1:         final int oldValue = rs.getInt(2);
1:         rs.updateInt(2, newValue);
1:         rs.updateRow();
1:         
1:         SQLWarning warn = rs.getWarnings();
1:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:         assertEquals("Did not expect the resultset to be updated", oldValue, rs.getInt(2));
1:         assertTrue("Expected rs.rowDeleted() to be false", !rs.rowDeleted());
1:         assertTrue("Expected rs.rowUpdated() to be false", !rs.rowUpdated());
1:         
1:         rs.clearWarnings();
1:         rs.deleteRow();
1:         warn = rs.getWarnings();
1:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:         rs.relative(0);
1:         assertTrue("Expected rs.rowUpdated() to be false", !rs.rowUpdated());
1:         assertTrue("Expected rs.rowDeleted() to be false", !rs.rowDeleted());
1:         assertEquals("Did not expect the resultset to be updated", oldValue, rs.getInt(2));
1:         
1:         rs.close();
1:     }
1: 
1:     /**
1:      * Test that you get cursor operation conflict warning if updating 
1:      * a row which has been deleted from the table, now using 
1:      * positioned updates / deletes.
1:      */
1:     public void testCursorOperationConflictWarning2() 
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         rs.next();
0:         con.createStatement().executeUpdate ("delete from t1 where id=" +
1:                                              rs.getString("ID"));
1:         
1:         final int newValue = -3333;
1:         final int oldValue = rs.getInt(2);
1:         
0:         Statement s3 = con.createStatement();
1:         int updateCount = s3.executeUpdate
1:             ("update t1 set A=" + newValue + 
1:              " where current of " + rs.getCursorName());
1:         
1:         rs.relative(0);
1:         SQLWarning warn = s3.getWarnings();
1:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:         assertTrue("Expected rs.rowUpdated() to be false", !rs.rowUpdated());
1:         assertTrue("Expected rs.rowDeleted() to be false", !rs.rowDeleted());
1:         assertEquals("Did not expect the resultset to be updated", oldValue, rs.getInt(2));
1:         assertEquals("Expected update count to be 0", 0, updateCount);
1:         
0:         Statement s4 = con.createStatement();
1:         updateCount = s4.executeUpdate("delete from t1 where current of " +
1:                                        rs.getCursorName());
1:         
1:         rs.relative(0);
1:         warn = s4.getWarnings();
1:         assertWarning(warn, CURSOR_OPERATION_CONFLICT);
1:         assertTrue("Expected rs.rowUpdated() to be false", !rs.rowUpdated());
1:         assertTrue("Expected rs.rowDeleted() to be false", !rs.rowDeleted());
1:         assertEquals("Did not expect the resultset to be updated", oldValue, rs.getInt(2));
1:         assertEquals("Expected update count to be 0", 0, updateCount);
1:         
1:         rs.close();
1:     }
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:9634cd2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
/////////////////////////////////////////////////////////////////////////
1:     /** 
1:      * Test that when doing an update immediately after
1:      * a commit, the update fails, because the cursor has been 
1:      * postioned between the current row and the next row.
1:      * The test uses a FORWARD_ONLY resultset and ResultSet update methods
1:      * when doing the update.
1:      */
1:     public void testCursorStateAfterCommit1() 
1:         throws SQLException
1:     {
1:         testCursorStateAfterCommit(false, ResultSet.TYPE_FORWARD_ONLY);
1:     }
1: 
1:     /** 
1:      * Test that when doing an update immediately after
1:      * a commit, the update fails, because the cursor has been 
1:      * postioned between the current row and the next row.
1:      * The test uses a SCROLL_INSENSITIVE resultset and ResultSet update methods
1:      * when doing the update.
1:      */
1:     public void testCursorStateAfterCommit2() 
1:         throws SQLException
1:     {
1:         testCursorStateAfterCommit(false, ResultSet.TYPE_SCROLL_INSENSITIVE);
1:     }
1:     
1:      /** 
1:      * Test that when doing an update immediately after
1:      * a commit, the update fails, because the cursor has been 
1:      * postioned between the current row and the next row.
1:      * The test uses a FORWARD_ONLY resultset and positioned updates.
1:      */
1:     public void testCursorStateAfterCommit3() 
1:         throws SQLException
1:     {
1:         testCursorStateAfterCommit(true, ResultSet.TYPE_FORWARD_ONLY);
1:     }
1: 
1:     /** 
1:      * Test that when doing an update immediately after
1:      * a commit, the update fails, because the cursor has been 
1:      * postioned between the current row and the next row.
1:      * The test uses a SCROLL_INSENSITIVE resultset and positioned updates.
1:      */
1:     public void testCursorStateAfterCommit4() 
1:         throws SQLException
1:     {
1:         testCursorStateAfterCommit(true, ResultSet.TYPE_SCROLL_INSENSITIVE);
1:     }
1:     
1:     /** 
1:      * Test that when doing an update immediately after
1:      * a commit, the update fails, because the cursor has been 
1:      * postioned between the current row and the next row.
1:      * If the cursor gets repositioned, it allows an update.
1:      * @param positioned true to use positioned update, otherwise use 
1:      *                   ResultSet.updateRow()
1:      * @param resultSetType type of result set (as in ResultSet.getType())
1:      */
1:     private void testCursorStateAfterCommit(final boolean positioned, 
1:                                             final int resultSetType) 
1:         throws SQLException
1:     {
0:         final Statement s = con.createStatement(resultSetType, 
1:                                                 ResultSet.CONCUR_UPDATABLE);
1:         final String cursorName = getNextCursorName();
1:         s.setCursorName(cursorName);
1:         
1:         final ResultSet rs = s.executeQuery("select a from t1");
1:         final int recordToUpdate = 5;
1:         
1:         if (resultSetType==ResultSet.TYPE_FORWARD_ONLY) {
1:             for (int i = 0; i < recordToUpdate; i++) {
1:                 rs.next();
1:             }
1:         } else {
1:             rs.absolute(recordToUpdate);
1:         }
1:         
0:         con.commit();
1:         
1:         PreparedStatement ps = 
0:             con.prepareStatement("update t1 set a=? where current of " +
1:                                  cursorName);
1:         // First: check that we get an exception on update without repositioning:
1:         try {
1:             if (positioned) {
1:                 ps.setInt(1, -1);
1:                 ps.executeUpdate();                
1:                 fail("Expected exception to be thrown on positioned update " + 
1:                      "since cursor is not positioned");
1:             } else {
1:                 rs.updateInt(1, -1);
1:                 rs.updateRow();
1:                 fail("Expected exception to be thrown on updateRow() since " +
1:                      "cursor is not positioned");
1:             }
1:         } catch (SQLException e) {
1:             assertSQLState("Unexpected SQLState when updating row after commit",
1:                            SQLStateConstants.INVALID_CURSOR_STATE_NO_SUBCLASS,
1:                            e);
1:         }
1:         
1:         // Check that we after a repositioning can update:
1:         if (resultSetType==ResultSet.TYPE_FORWARD_ONLY) {
1:             rs.next();
1:         } else {
1:             rs.relative(0);
1:         }
1:         if (positioned) {
1:             ps.setInt(1, -1);
1:             ps.executeUpdate();                
1:         } else {
1:             rs.updateInt(1, -1);
1:             rs.updateRow();
1:         }
1:         
1:     }
1: 
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:4e091b6
/////////////////////////////////////////////////////////////////////////
1:      * Test that rowUpdated() and rowDeleted() methods both return true when
1:      * the row has first been updated and then deleted using the updateRow()
1:      * and deleteRow() methods.
1:      */
1:     public void testRowUpdatedAndRowDeleted() throws SQLException {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                            ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select a,b from t1");
1:         rs.next();
1:         rs.updateInt(1, rs.getInt(1) + 2 * recordCount);
1:         rs.updateRow();
1:         assertTrue("Expected rowUpdated() to return true", rs.rowUpdated());
1:         rs.deleteRow();
1:         rs.next();
1:         rs.previous();
1:         assertTrue("Expected rowUpdated() to return true", rs.rowUpdated());
1:         assertTrue("Expected rowDeleted() to return true", rs.rowDeleted());
1:         rs.next();
1:         assertFalse("Expected rowUpdated() to return false", rs.rowUpdated());
1:         assertFalse("Expected rowDeleted() to return false", rs.rowDeleted());
1:         rs.previous();
1:         assertTrue("Expected rowUpdated() to return true", rs.rowUpdated());
1:         assertTrue("Expected rowDeleted() to return true", rs.rowDeleted());
1:         rs.close();
1:         s.close();
1:     }
1: 
1: 
1:     /**
commit:10b9cb1
/////////////////////////////////////////////////////////////////////////
1:      * Tests that it is possible to move using positioning methods after
1:      * moveToInsertRow and that it is possible to delete a row after 
1:      * positioning back from insertRow. Also tests that it is possible to 
1:      * insert a row when positioned on insert row, that it is not possible
1:      * to update or delete a row from insertRow and that it also is not possible
1:      * to insert a row without being on insert row.
1:      */
1:     public void testInsertRowWithScrollCursor() throws SQLException {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         
1:         int currentPosition, lastRow;
1:         
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs =
1:             s.executeQuery("select * from t1");
1:         
1:         rs.last();
1:         lastRow = rs.getRow();
1:         
1:         rs.beforeFirst();
1:         
1:         rs.next();
1:         
1:         // Test that it is possible to move to next row from insertRow
1:         currentPosition = rs.getRow();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, currentPosition + 1000);
1:         rs.next();
1:         assertEquals("CurrentPosition should be " + (currentPosition + 1), 
1:                 rs.getRow(), currentPosition + 1);
1:         // should be able to delete the row
1:         rs.deleteRow();
1: 
1:         // Test that it is possible to move using relative from insertRow
1:         currentPosition = rs.getRow();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, currentPosition + 1000);
1:         rs.relative(2);
1:         assertEquals("CurrentPosition should be " + (currentPosition + 2), 
1:                 rs.getRow(), currentPosition + 2);
1:         // should be able to delete the row
1:         rs.deleteRow();
1: 
1:         // Test that it is possible to move using absolute from insertRow
1:         currentPosition = rs.getRow();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, currentPosition + 1000);
1:         rs.absolute(6);
1:         assertEquals("CurrentPosition should be 6", rs.getRow(), 6);
1:         // should be able to delete the row
1:         rs.deleteRow();
1: 
1:         // Test that it is possible to move to previous row from insertRow
1:         currentPosition = rs.getRow();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, currentPosition + 1000);
1:         rs.previous();
1:         assertEquals("CurrentPosition should be " + (currentPosition - 1), 
1:                 rs.getRow(), currentPosition - 1);
1:         // should be able to delete the row
1:         rs.deleteRow();
1: 
1:         // Test that it is possible to move to first row from insertRow
1:         currentPosition = rs.getRow();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, currentPosition + 1000);
1:         rs.first();
1:         assertEquals("CurrentPosition should be 1", rs.getRow(), 1);
1:         assertTrue("isFirst() should return true", rs.isFirst());
1:         // should be able to delete the row
1:         rs.deleteRow();
1: 
1:         // Test that it is possible to move to last row from insertRow
1:         currentPosition = rs.getRow();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, currentPosition + 1000);
1:         rs.last();
1:         assertEquals("CurrentPosition should be " + lastRow, 
1:                 rs.getRow(), lastRow);
1:         assertTrue("isLast() should return true", rs.isLast());
1:         // should be able to delete the row
1:         rs.deleteRow();
1: 
1:         // Test that it is possible to move beforeFirst from insertRow
1:         currentPosition = rs.getRow();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, currentPosition + 1000);
1:         rs.beforeFirst();
1:         assertTrue("isBeforeFirst() should return true", rs.isBeforeFirst());
1:         rs.next();
1:         assertEquals("CurrentPosition should be 1", rs.getRow(), 1);
1:         assertTrue("isFirst() should return true", rs.isFirst());
1: 
1:         // Test that it is possible to move afterLast from insertRow
1:         currentPosition = rs.getRow();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, currentPosition + 1000);
1:         rs.afterLast();
1:         assertTrue("isAfterLast() should return true", rs.isAfterLast());
1:         rs.previous();
1:         assertEquals("CurrentPosition should be " + lastRow, 
1:                 rs.getRow(), lastRow);
1:         assertTrue("isLast() should return true", rs.isLast());
1: 
1:         // Test that it is possible to insert a row and move back to current row
1:         rs.previous();
1:         currentPosition = rs.getRow();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, currentPosition + 1000);
1:         rs.insertRow();
1:         rs.moveToCurrentRow();
1:         assertEquals("CurrentPosition should be " + currentPosition, 
1:                 rs.getRow(), currentPosition);
1: 
1:         
1:         try {
1:             rs.moveToInsertRow();
1:             rs.updateInt(1, currentPosition + 2000);
1:             rs.updateRow();
1:         } catch (SQLException se) {
1:             assertEquals("Expected exception", 
1:                     se.getSQLState().substring(0, 5), 
1:                     INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:         }
1:         
1:         try {
1:             rs.moveToInsertRow();
1:             rs.updateInt(1, currentPosition + 2000);
1:             rs.deleteRow();
1:         } catch (SQLException se) {
1:             assertEquals("Expected exception", 
1:                     se.getSQLState().substring(0, 5), 
1:                     INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:         }
1:         
1:         try {
1:             rs.moveToCurrentRow();
1:             rs.updateInt(1, currentPosition + 2000);
1:             rs.insertRow();
1:         } catch (SQLException se) {
1:             assertEquals("Expected exception", 
1:                     se.getSQLState().substring(0, 5), 
1:                     CURSOR_NOT_POSITIONED_ON_INSERT_ROW);
1:         }
1:         
1:         rs.close();
1:         
1:         s.close();
1:     }
1:     
1:     /**
commit:6b0118a
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Check that detectability methods throw the correct exception
1:      * when called in an illegal row state, that is, somehow not
1:      * positioned on a row. Minion of testDetectabilityExceptions.
1:      *
1:      * @param rs An open updatable result set.
1:      * @param state A string describing the illegal state.
0:      * @return No return value.
1:      */
1:     private void checkDetectabilityCallsOutsideRow(ResultSet rs, 
1:                                                    String state)
1:     {
1:         boolean b;
1:         
1:         try {
1:             b = rs.rowUpdated();
1:             fail("rowUpdated while " + state + 
1:                  " did not throw exception: " + b);
1:         } catch (SQLException e) {
1:             assertEquals(e.getSQLState(),
1:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:         }
1: 
1:         try {
1:             b = rs.rowDeleted();
1:             fail("rowdeleted while " + state + 
1:                  " did not throw exception: " + b);
1:         } catch (SQLException e) {
1:             assertEquals(e.getSQLState(),
1:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:         }
1: 
1:         try {
1:             b = rs.rowInserted();
1:             fail("rowInserted while " + state + 
1:                  " did not throw exception: " + b);
1:         } catch (SQLException e) {
1:             assertEquals(e.getSQLState(),
1:                          INVALID_CURSOR_STATE_NO_CURRENT_ROW);
1:         }
1:     }
1: 
1: 
1:     /**
1:      * Test that the JDBC detectability calls throw correct exceptions when
1:      * called in in wrong row states. 
1:      * This is done for both supported updatable result set types.
1:      */
1:     public void testDetectabilityExceptions() throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         checkDetectabilityCallsOutsideRow(rs, "before positioning");
1: 
1:         rs.moveToInsertRow();
1:         checkDetectabilityCallsOutsideRow(rs, 
1:                                           "on insertRow before positioning");
1: 
1:         rs.next();
1:         rs.moveToInsertRow();
1:         checkDetectabilityCallsOutsideRow(rs, "on insertRow");
1:         rs.moveToCurrentRow(); // needed until to DERBY-1322 is fixed
1: 
1:         rs.beforeFirst();
1:         checkDetectabilityCallsOutsideRow(rs, "on beforeFirst row");
1: 
1:         rs.afterLast();
1:         checkDetectabilityCallsOutsideRow(rs, "on afterLast row");
1: 
1:         rs.first();
1:         rs.deleteRow();
1:         checkDetectabilityCallsOutsideRow(rs, "after deleteRow");
1: 
1:         rs.last();
1:         rs.deleteRow();
1:         checkDetectabilityCallsOutsideRow(rs, "after deleteRow of last row");
1: 
1:         rs.close();
1:         s.close();
1: 
1:         // Not strictly SUR, but fixed in same patch, so we test it here.
0:         s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         rs = s.executeQuery("select * from t1");
1: 
1:         checkDetectabilityCallsOutsideRow(rs, "before FO positioning");
1: 
1:         rs.moveToInsertRow();
1:         checkDetectabilityCallsOutsideRow(rs, 
1:                                           "on insertRow before FO positioning");
1: 
1:         rs.next();
1:         rs.moveToInsertRow();
1:         checkDetectabilityCallsOutsideRow(rs, "on FO insertRow");
1: 
1:         rs.next();
1:         rs.updateInt(2, 666);
1:         rs.updateRow();
1:         checkDetectabilityCallsOutsideRow(rs, "after FO updateRow");
1: 
1:         rs.next();
1:         rs.deleteRow();
1:         checkDetectabilityCallsOutsideRow(rs, "after FO deleteRow");
1: 
1:         while (rs.next()) {};
1:         checkDetectabilityCallsOutsideRow(rs, "after FO emptied out");
1: 
1:         rs.close();
1:         s.close();
1:     }
1: 
1: 
1:     /**
commit:c247315
/////////////////////////////////////////////////////////////////////////
1:         assertWarning(warn, QUERY_NOT_QUALIFIED_FOR_UPDATABLE_RESULTSET);
/////////////////////////////////////////////////////////////////////////
1:         assertWarning(warn, QUERY_NOT_QUALIFIED_FOR_UPDATABLE_RESULTSET);
commit:e41dc70
/////////////////////////////////////////////////////////////////////////
1:      * Get a cursor name. We use the same cursor name for all cursors.
1:         return "MYCURSOR";
author:David Van Couvering
-------------------------------------------------------------------------------
commit:bc50840
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class SURTest
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its
0:  * licensors, as applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License")
0:  * you may not use this file except in compliance with the License.
0:  * You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing,
1:  * software distributed under the License is distributed on an
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
1:  * either express or implied. See the License for the specific
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.SQLWarning;
1: import java.sql.Statement;
1: import junit.extensions.TestSetup;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import java.util.Iterator;
1: /**
1:  * Tests for variants of scrollable updatable resultsets.
1:  *
0:  * @author Andreas Korneliussen
1:  */
1: public class SURTest extends SURBaseTest {
1:     
1:     /** Creates a new instance of SURTest */
1:     public SURTest(String name) {
1:         super(name);
1:     }
1:     
1:     /**
1:      * Test that you get a warning when specifying a query which is not
1:      * updatable and concurrency mode CONCUR_UPDATABLE.
1:      * In this case, the query contains an "order by"
1:      */
1:     public void testConcurrencyModeWarning1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1 order by a");
1:         
1:         SQLWarning warn = rs.getWarnings();
1:         assertEquals("Expected resultset to be read only",
1:                      ResultSet.CONCUR_READ_ONLY,
1:                      rs.getConcurrency());
0:         assertNotNull("Expected to get a warning", warn);
1:         scrollForward(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test that you get a warning when specifying a query which is not
1:      * updatable and concurrency mode CONCUR_UPDATABLE.
1:      * In this case, the query contains a join.
1:      */
1:     public void testConcurrencyModeWarning2()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery
1:             ("select * from t1 as table1,t1 as table2 where " +
1:              "table1.a=table2.a");
1:         
1:         SQLWarning warn = rs.getWarnings();
1:         assertEquals("Expected resultset to be read only",
1:                      ResultSet.CONCUR_READ_ONLY,
1:                      rs.getConcurrency());
0:         assertNotNull("Expected to get a warning", warn);
1:         scrollForward(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test that you get an exception when specifying update clause
1:      * "FOR UPDATE"
1:      * along with a query which is not updatable.
1:      * In this case, the query contains and order by.
1:      */
1:     public void testForUpdateException1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         try {
1:             String queryString =
1:                 "select * from t1 order by a for update";
1:             s.setCursorName(getNextCursorName());
1:             ResultSet rs = s.executeQuery(queryString);
1:             
1:             assertTrue("Expected query '" + queryString +
1:                        "' to fail", false);
1:         } catch (SQLException e) {
1:             assertEquals("Unexpected SQLState", 
1:                          FOR_UPDATE_NOT_PERMITTED_SQL_STATE,
1:                          e.getSQLState());
1:         }
0:         con.rollback();
1:     }
1:     
1:     /**
1:      * Test that you get an exception when specifying update clause
1:      * "FOR UPDATE" along with a query which is not updatable.
1:      * In this case, the query contains a join
1:      */
1:     public void testForUpdateException2()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         try {
1:             String queryString =
1:                 "select * from t1 as table1,t1 as table2" +
1:                 " where table1.a=table2.a for update";
1:             s.setCursorName(getNextCursorName());
1:             ResultSet rs = s.executeQuery(queryString);
1:             
1:             assertTrue("Expected query '" + queryString + "' to fail",
1:                        false);
1:         } catch (SQLException e) {
1:             assertEquals("Unexpected SQLState", 
1:                          FOR_UPDATE_NOT_PERMITTED_SQL_STATE,
1:                          e.getSQLState());
1:         }
0:         con.rollback();
1:     }
1:     
1:     /**
1:      * Test that you can scroll forward and read all records in the
1:      * ResultSet
1:      */
1:     public void testForwardOnlyReadOnly1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_READ_ONLY);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         scrollForward(rs);
1:         rs.close();
1:     }
1:     
1:     
1:     /**
1:      * Test that you get an exception if you try to update a ResultSet
1:      * with concurrency mode CONCUR_READ_ONLY.
1:      */
1:     public void testFailOnUpdateOfReadOnlyResultSet1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_READ_ONLY);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         rs.next();
1:         assertFailOnUpdate(rs);
1:     }
1:     
1:     /**
1:      * Test that you get an exception when attempting to update a
1:      * ResultSet which has been downgraded to a read only ResultSet.
1:      */
1:     public void testFailOnUpdateOfReadOnlyResultSet2()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1 order by id");
1:         
1:         rs.next();
1:         assertFailOnUpdate(rs);
1:     }
1:     
1:     /**
1:      * Test that you get an exception when attempting to update a
1:      * ResultSet which has been downgraded to a read only ResultSet.
1:      */
1:     public void testFailOnUpdateOfReadOnlyResultSet3()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs =
1:             s.executeQuery("select * from t1 for read only");
1:         
1:         rs.next();
1:         assertFailOnUpdate(rs);
1:     }
1:     
1:     /**
1:      * Test that you get an exception when attempting to update a
1:      * ResultSet which has been downgraded to a read only ResultSet.
1:      */
1:     public void testFailOnUpdateOfReadOnlyResultSet4()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery
1:             ("select * from t1 where a=1 for read only");
1:         
1:         rs.next();
1:         verifyTuple(rs);
1:         assertFailOnUpdate(rs);
1:     }
1:     
1:     
1:     /**
1:      * Test that you get an exception if you try to update a ResultSet
1:      * with concurrency mode CONCUR_READ_ONLY.
1:      */
1:     public void testFailOnUpdateOfReadOnlyResultSet5()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.
1:                                           TYPE_SCROLL_INSENSITIVE,
1:                                           ResultSet.CONCUR_READ_ONLY);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery
1:             ("select * from t1 where a=1 for read only");
1:         
1:         rs.next();
1:         verifyTuple(rs);
1:         assertFailOnUpdate(rs);
1:     }
1:     
1:     /**
1:      * Test that you can scroll forward and update indexed records in
1:      * the ResultSet (not using FOR UPDATE)
1:      */
1:     public void testIndexedUpdateCursor1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1 where a=1");
1:         
1:         assertTrue("Expected to get a tuple on rs.next()", rs.next());
1:         verifyTuple(rs);
1:         updateTuple(rs);
1:         
1:     }
1:     
1:     /**
1:      *  Test that you can scroll forward and update indexed records
1:      *  in the ResultSet (using FOR UPDATE).
1:      */
1:     public void testIndexedUpdateCursor2()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs =
1:             s.executeQuery("select * from t1 where a=1 for update");
1:         
1:         assertTrue("Expected to get a tuple on rs.next()", rs.next());
1:         verifyTuple(rs);
1:         updateTuple(rs);
1:     }
1:     
1:     /**
1:      *  Test that you can scroll forward and update indexed records
1:      *  in the scrollable ResultSet (not using FOR UPDATE).
1:      */
1:     public void
1:         testIndexedScrollInsensitiveUpdateCursorWithoutForUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs =
1:             s.executeQuery("select * from t1 where a=1 or a=2");
1:         
1:         rs.next();
1:         rs.next();
1:         rs.previous();
1:         verifyTuple(rs);
1:         updateTuple(rs);
1:     }
1:     
1:     /**
1:      *  Test that you can scroll forward and update indexed records
1:      *  in the scrollable ResultSet (using FOR UPDATE).
1:      */
1:     public void
1:         testIndexedScrollInsensitiveUpdateCursorWithForUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery
1:             ("select * from t1 where a=1 or a=2 for update");
1:         
1:         rs.next();
1:         rs.next();
1:         rs.previous();
1:         verifyTuple(rs);
1:         updateTuple(rs);
1:         rs.close();
1:         s.close();
1:     }
1:    
1:     /**
1:      * Test update of a keyed record using scrollable updatable
1:      * resultset.
1:      */
1:     public void testPrimaryKeyUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         rs.last();
1:         rs.next();
1:         while(rs.previous()) {
1:             // Update the key of every second row.
1:             int key = rs.getInt(1);
1:             if (key%2==0) {
1:                 int newKey = -key;
1:                 rs.updateInt(1, newKey);
1:                 rs.updateRow();
1:             }
1:         }
0:         PreparedStatement ps = con.prepareStatement
1:             ("select * from t1 where id=?");
1:         for (int i=0; i<recordCount; i++) {
1:             int key = (i%2==0) ? -i : i;
1:             ps.setInt(1, key);
1:             ResultSet rs2 = ps.executeQuery();
1:             assertTrue("Expected query to have 1 row", rs2.next());
1:             println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:                     rs2.getInt(2) + "," +
1:                     rs2.getInt(3) + ")");
1:             assertEquals("Unexpected value of id", key, rs2.getInt(1));
1:             assertTrue("Did not expect more than 1 row, " +
1:                        "however rs2.next returned another row",
1:                        !rs2.next());
1:         }
1:     }
1:         
1:     /**
1:      * Test update of a keyed record using other statement
1:      * object.
1:      */
1:     public void testOtherPrimaryKeyUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         rs.last();
1:         int primaryKey = rs.getInt(1);
0:         PreparedStatement ps = con.prepareStatement
1:             ("update t1 set id = ? where id= ?");
1:         ps.setInt(1, -primaryKey);
1:         ps.setInt(2, primaryKey);
1:         assertEquals("Expected one row to be updated", 1,
1:                      ps.executeUpdate());
1:         
1:         rs.updateInt(2, -555);
1:         rs.updateInt(3, -777);
1:         rs.updateRow();
1:         
0:         PreparedStatement ps2 = con.prepareStatement
1:             ("select * from t1 where id=?");
1:         ps2.setInt(1, -primaryKey);
1:         ResultSet rs2 = ps2.executeQuery();
1:         assertTrue("Expected query to have 1 row", rs2.next());
1:         println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:                 rs2.getInt(2) + "," +
1:                 rs2.getInt(3) + ")");
1:         assertEquals("Expected a=-555", -555, rs2.getInt(2));
1:         assertEquals("Expected b=-777", -777, rs2.getInt(3));
1:         assertTrue("Did not expect more than 1 row, however " +
1:                    "rs2.next() returned another row", !rs2.next());
1:     }
1:     
1:     /**
1:      * Test update of a keyed record using other both the
1:      * scrollable updatable resultset and using another statement
1:      * object.
1:      */
1:     public void testOtherAndOwnPrimaryKeyUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         rs.last();
1:         int primaryKey = rs.getInt(1);
0:         PreparedStatement ps = con.prepareStatement
1:             ("update t1 set id = ? where id= ?");
1:         ps.setInt(1, -primaryKey);
1:         ps.setInt(2, primaryKey);
1:         assertEquals("Expected one row to be updated", 1,
1:                      ps.executeUpdate());
1:         rs.updateInt(1, primaryKey*10);
1:         rs.updateInt(2, -555);
1:         rs.updateInt(3, -777);
1:         rs.updateRow();
1:         
1:         PreparedStatement ps2 =
0:             con.prepareStatement("select * from t1 where id=?");
1:         ps2.setInt(1, primaryKey*10);
1:         ResultSet rs2 = ps2.executeQuery();
1:         assertTrue("Expected query to have 1 row", rs2.next());
1:         println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:                 rs2.getInt(2) + "," +
1:                 rs2.getInt(3) + ")");
1:         assertEquals("Expected a=-555", -555, rs2.getInt(2));
1:         assertEquals("Expected b=-777", -777, rs2.getInt(3));
1:         assertTrue("Did not expect more than 1 row, however " +
1:                    "rs2.next() returned another row", !rs2.next());
1:     }
1:     
1:     /**
1:      * Update multiple keyed records using scrollable updatable resultset
1:      */
1:     public void testMultipleKeyUpdates()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         rs.last();
1:         int primaryKey = rs.getInt(1);
0:         PreparedStatement ps = con.prepareStatement
1:             ("update t1 set id = ? where id= ?");
1:         ps.setInt(1, -primaryKey);
1:         ps.setInt(2, primaryKey);
1:         assertEquals("Expected one row to be updated", 1,
1:                      ps.executeUpdate());
1:         rs.updateInt(1, primaryKey*10);
1:         rs.updateInt(2, -555);
1:         rs.updateInt(3, -777);
1:         rs.updateRow();
1:         rs.first();
1:         rs.last();
1:         for (int i=0; i<10; i++) {
1:             rs.first();
1:             rs.last();
1:             rs.next();
1:             rs.previous();
1:             rs.updateInt(1, primaryKey*10 +i);
1:             rs.updateInt(2, (-555 -i));
1:             rs.updateInt(3, (-777 -i));
1:             rs.updateRow();
1:         }
1:     }
1:     
1:     /**
1:      * Test update indexed records using scrollable updatable resultset 
1:      */
1:     public void testSecondaryIndexKeyUpdate1()
1:         throws SQLException 
1:     {
1:         
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         rs.last();
1:         rs.next();
1:         int newKey = 0;
1:         while(rs.previous()) {
1:             // Update the secondary key of all rows
1:             rs.updateInt(2, newKey--);
1:             rs.updateRow();
1:         }
0:         PreparedStatement ps = con.prepareStatement
1:             ("select * from t1 where a=?");
1:         for (int i=0; i<recordCount; i++) {
1:             int key = -i;
1:             ps.setInt(1, key);
1:             ResultSet rs2 = ps.executeQuery();
1:             assertTrue("Expected query to have 1 row", rs2.next());
1:             println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:                     rs2.getInt(2) + "," +
1:                     rs2.getInt(3) + ")");
1:             assertEquals("Unexpected value of id", key, rs2.getInt(2));
1:             assertTrue("Did not expect more than 1 row, " +
1:                        "however rs2.next returned another row",
1:                        !rs2.next());
1:         }
1:     }
1:     
1:     /**
1:      * Test update indexed records using other statement object
1:      * and using resultset.
1:      */
1:     public void testOtherSecondaryKeyUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         rs.last();
1:         int indexedKey = rs.getInt(2);
1:         PreparedStatement ps =
0:             con.prepareStatement("update t1 set a = ? where a= ?");
1:         ps.setInt(1, -indexedKey);
1:         ps.setInt(2, indexedKey);
1:         assertEquals("Expected one row to be updated", 1,
1:                      ps.executeUpdate());
1:         
1:         rs.updateInt(1, -555);
1:         rs.updateInt(3, -777);
1:         rs.updateRow();
1:         
1:         PreparedStatement ps2 =
0:             con.prepareStatement("select * from t1 where a=?");
1:         ps2.setInt(1, -indexedKey);
1:         ResultSet rs2 = ps2.executeQuery();
1:         assertTrue("Expected query to have 1 row", rs2.next());
1:         println("T1: Read Tuple:(" + rs2.getInt(1) + "," +
1:                 rs2.getInt(2) + "," +
1:                 rs2.getInt(3) + ")");
1:         assertEquals("Expected id=-555", -555, rs2.getInt(1));
1:         assertEquals("Expected b=-777", -777, rs2.getInt(3));
1:         assertTrue("Did not expect more than 1 row, however " +
1:                    "rs2.next() returned another row", !rs2.next());
1:     }
1:     
1:     /**
1:      * Test scrolling in a read only resultset
1:      */
1:     public void testScrollInsensitiveReadOnly1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_READ_ONLY);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         scrollForward(rs);
1:         scrollBackward(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test updating a forward only resultset (with FOR UPDATE)
1:      */
1:     public void testForwardOnlyConcurUpdatableWithForUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:         
1:         scrollForwardAndUpdate(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test updating a forward only resultset (without FOR UPDATE)
1:      */
1:     public void testForwardOnlyConcurUpdatableWithoutForUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         scrollForwardAndUpdate(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test updating a forward only resultset (without FOR UPDATE)
1:      * and using positioned update
1:      */
1:     public void testPositionedUpdateWithoutForUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName("MYCURSOR");
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         scrollForwardAndUpdatePositioned(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test updating a forward only resultset (with FOR UPDATE)
1:      * and using positioned update
1:      */
1:     public void testPositionedUpdateWithForUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement();
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:         
1:         scrollForwardAndUpdatePositioned(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test positioned update of a scrollable resultset (with FOR UPDATE) 
1:      */
1:     public void testScrollablePositionedUpdateWithForUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement
1:             (ResultSet.TYPE_SCROLL_INSENSITIVE,
1:              ResultSet.CONCUR_READ_ONLY);
1:         s.setCursorName("MYCURSOR");
1:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:         
1:         rs.next();
1:         int pKey = rs.getInt(1);
1:         rs.previous();
1:         rs.next();
1:         assertEquals("Expecting to be on the same row after previous() " + 
1:                      "+ next() ", pKey, rs.getInt(1));
1:         rs.next();
1:         rs.previous();
1:         assertEquals("Expecting to be on the same row after next() + " + 
1:                      "previous()", pKey, rs.getInt(1));
1:         final int previousA = rs.getInt(2);
1:         final int previousB = rs.getInt(3);
1:         println(rs.getCursorName());
0:         PreparedStatement ps = con.prepareStatement
1:             ("update T1 set a=?,b=? where current of " + rs.getCursorName());
1:         ps.setInt(1, 666);
1:         ps.setInt(2, 777);
1:         ps.executeUpdate();
1:         rs.next();
1:         rs.previous();
1:         assertEquals("Expected to be on the same row after next() + previous()",
1:                      pKey, rs.getInt(1));
1:         assertEquals("Expected row to be updated by own change, " + 
1:                      " however did not get updated value for column a", 
1:                      666, rs.getInt(2));
1:         assertEquals("Expected row to be updated by own change, however did " +
1:                      "not get updated value for column b", 777, rs.getInt(3));
1:         rs.close();
1:         s.setCursorName(getNextCursorName());
1:         rs = s.executeQuery("select * from t1 order by b");
1:         
1:         while (rs.next()) {
1:             if (rs.getInt(1)==pKey) {
1:                 assertEquals("Expected row with primary key = " + pKey + 
1:                              " to be updated", 666, rs.getInt(2));
1:                 assertEquals("Expected row with primary key = " + pKey + 
1:                              " to be updated", 777, rs.getInt(3));
1:             } else {
1:                 println("Got tuple (" + rs.getInt(1) + "," + rs.getInt(2) + 
1:                         "," + rs.getInt(3) + "," + rs.getString(4)+ ")");
1:             }
1:         }
1:         
1:     }
1:     
1:     /**
1:      * Test update of a scrollable resultset (with FOR UPDATE)
1:      * Only scrolling forward
1:      */
1:     public void testScrollInsensitiveConcurUpdatableWithForUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:         scrollForwardAndUpdate(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test update of a scrollable resultset (with FOR UPDATE) 
1:      * Scrolling forward and backward.
1:      */
1:     public void testScrollInsensitiveConcurUpdatableWithForUpdate2()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         assertEquals("Invalid resultset concurrency on statement", 
1:                      ResultSet.CONCUR_UPDATABLE, s.getResultSetConcurrency());
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1 for update");
1:         
1:         assertEquals("Invalid resultset concurrency on resultset", 
1:                      ResultSet.CONCUR_UPDATABLE, rs.getConcurrency());
1:         scrollForward(rs);
1:         scrollBackwardAndUpdate(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test update of a scrollable resultset
1:      * Scrolling forward and backward. Then open another
1:      * resultset and verify the data.
1:      */
1:     private void testScrollInsensistiveConurUpdatable3(ResultSet rs) 
1:         throws SQLException 
1:     {
1:         while (rs.next()) {
1:         }
1:         while (rs.previous()) {
1:             int a = rs.getInt(1);
1:             int b = rs.getInt(2);
1:             int id = b - 17 - a;
1:             int newA = 1000;
1:             int newB = id + newA + 17;
1:             rs.updateInt(1, newA); // Set a to 1000
1:             rs.updateInt(2, newB); // Set b to checksum value
1:             rs.updateRow();
1:             
1:             assertEquals("Expected a to be 1000", 1000, rs.getInt(1));
1:         }
1:         int count = 0;
1:         while (rs.next()) {
1:             int a = rs.getInt(1);
1:             count++;
1:             assertEquals("Incorrect row updated for row " + count, 1000, a);
1:         }
1:         assertEquals("Expected count to be the same as number of records", 
1:                      recordCount, count);
1:         while (rs.previous()) {
1:             int a = rs.getInt(1);
1:             count--;
1:             assertEquals("Incorrect row updated for row " + count, 1000, a);
1:         }
1:         rs.close();
0:         Statement s = con.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                                           ResultSet.CONCUR_READ_ONLY);
1:         s.setCursorName(getNextCursorName());
1:         rs = s.executeQuery("select * from t1");
1:         
1:         while (rs.next()) {
1:             int id = rs.getInt(1);
1:             int a = rs.getInt(2);
1:             int b = rs.getInt(3);
1:             println("Updated tuple:" + id + "," + a + "," + b);
1:         }
1:     }
1:     
1:     /**
1:      * Test update of a scrollable resultset (with FOR UPDATE)
1:      * Scrolling forward and backward. Then open another
1:      * resultset and verify the data.
1:      */
1:     public void testScrollInsensitiveConcurUpdatableWithForUpdate3()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select a,b from t1 for update");
1:         
1:         testScrollInsensistiveConurUpdatable3(rs);
1:     }
1:     
1:     /**
1:      * Test update of a scrollable resultset (without FOR UPDATE) 
1:      * Scrolling forward only
1:      */
1:     public void testScrollInsensitiveConcurUpdatableWithoutForUpdate1()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         scrollForwardAndUpdate(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test update of a scrollable resultset (without FOR UPDATE) 
1:      * Scrolling forward and backward.
1:      */
1:     public void testScrollInsensitiveConcurUpdatableWithoutForUpdate2()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select * from t1");
1:         
1:         scrollForward(rs);
1:         scrollBackwardAndUpdate(rs);
1:         rs.close();
1:     }
1:     
1:     /**
1:      * Test update of a scrollable resultset (without FOR UPDATE)
1:      * Scrolling forward and backward. Then open another
1:      * resultset and verify the data.
1:      */
1:     public void testScrollInsensitiveConcurUpdatableWithoutForUpdate3()
1:         throws SQLException 
1:     {
0:         Statement s = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, 
1:                                           ResultSet.CONCUR_UPDATABLE);
1:         s.setCursorName(getNextCursorName());
1:         ResultSet rs = s.executeQuery("select a,b from t1");
1:         
1:         testScrollInsensistiveConurUpdatable3(rs);
1:     }
1:     
1:     /**
0:      * Get a new cursor name. WORKAROUND FOR DERBY-787, since
0:      * the cursors have side-effects..!
0:      * To reproduce DERBY-787, just return the same cursor name.
1:      */
1:     private final String getNextCursorName() {
0:         return "MYCURSOR" + cursorIndex++;
1:     }
1:     
0:     private static int cursorIndex = 0;
1: 
1:     
1:     /**
1:      * The suite contains all testcases in this class running on different 
1:      * data models
1:      */
0:     public static Test suite() {
1:         
0:         TestSuite mainSuite = new TestSuite();
1:         
1:         // Iterate over all data models and decorate the tests:
1:         for (Iterator i = SURDataModelSetup.SURDataModel.values().iterator();
1:              i.hasNext();) {
1:             
1:             SURDataModelSetup.SURDataModel model = 
1:                 (SURDataModelSetup.SURDataModel) i.next();
1:             
0:             TestSuite suite = new TestSuite(SURTest.class);
1:             TestSetup decorator = new SURDataModelSetup
1:                 (suite, model);
1:             
1:             mainSuite.addTest(decorator);    
1:         }
1:         
0:         return mainSuite;
1:     }
1: }
============================================================================