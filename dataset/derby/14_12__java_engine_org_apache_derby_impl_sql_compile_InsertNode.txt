1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.InsertNode
1:a180287: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
5:eac0369:  */
1:a8db665: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
34:eac0369: 
1:3bb140c: import java.util.Properties;
1:3bb140c: import org.apache.derby.catalog.UUID;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.StatementType;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:3d2d88b: import org.apache.derby.iapi.sql.compile.IgnoreFilter;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:3bb140c: import org.apache.derby.iapi.sql.conn.Authorizer;
1:959fef2: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:959fef2: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.IndexLister;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:3bb140c: import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:3bb140c: import org.apache.derby.iapi.util.StringUtil;
1:3bb140c: import org.apache.derby.impl.sql.execute.FKInfo;
1:3bb140c: import org.apache.derby.vti.DeferModification;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * An InsertNode is the top node in a query tree for an
1:eac0369:  * insert statement.
1:eac0369:  * <p>
1:eac0369:  * After parsing, the node contains
1:eac0369:  *   targetTableName: the target table for the insert
1:eac0369:  *   collist: a list of column names, if specified
1:eac0369:  *   queryexpr: the expression being inserted, either
1:eac0369:  *				a values clause or a select form; both
1:eac0369:  *			    of these are represented via the SelectNode,
1:eac0369:  *				potentially with a TableOperatorNode such as
1:eac0369:  *				UnionNode above it.
1:eac0369:  * <p>
1:eac0369:  * After binding, the node has had the target table's
1:eac0369:  * descriptor located and inserted, and the queryexpr
1:eac0369:  * and collist have been massaged so that they are identical
1:eac0369:  * to the table layout.  This involves adding any default
1:eac0369:  * values for missing columns, and reordering the columns
1:eac0369:  * to match the table's ordering of them.
1:eac0369:  * <p>
1:eac0369:  * After optimizing, ...
1:eac0369:  */
1:a826375: public final class InsertNode extends DMLModGeneratedColumnsStatementNode
6:eac0369: {
1:e1f49ca:     private     ResultColumnList    targetColumnList;
1:e1f49ca:     private     boolean             deferred;
1:eac0369: 	public		ValueNode			checkConstraints;
1:af1c18c:     public      boolean             hasDeferrableCheckConstraints;
1:eac0369: 	public		Properties			targetProperties;
1:eac0369: 	public		FKInfo				fkInfo;
1:eac0369: 	protected	boolean				bulkInsert;
1:eac0369: 	private 	boolean				bulkInsertReplace;
1:2060c4a: 	private     OrderByList         orderByList;
1:108305b:     private     ValueNode           offset;
1:108305b:     private     ValueNode           fetchFirst;
1:57c1b5c:     private     boolean           hasJDBClimitClause; // true if using JDBC limit/offset escape syntax
1:a180287:     
1:eac0369: 	/**
1:3bb140c:      * Constructor for an InsertNode.
5:eac0369: 	 *
1:3bb140c:      * @param targetName         The name of the table/VTI to insert into
1:3bb140c:      * @param insertColumns      A ResultColumnList with the names of the
1:eac0369: 	 *			columns to insert into.  May be null if the
1:eac0369: 	 *			user did not specify the columns - in this
1:eac0369: 	 *			case, the binding phase will have to figure
1:eac0369: 	 *			it out.
1:3bb140c:      * @param queryExpression    The query expression that will generate
1:3bb140c:      *                           the rows to insert into the given table
1:508a010:      * @param matchingClause   Non-null if this DML is part of a MATCHED clause of a MERGE statement.
1:3bb140c:      * @param targetProperties   The properties specified on the target table
1:3bb140c:      * @param orderByList        The order by list for the source result set,
1:3bb140c:      *                           null if no order by list
1:3bb140c:      * @param offset             The value of a <result offset clause> if
1:3bb140c:      *                           present
1:3bb140c:      * @param fetchFirst         The value of a <fetch first clause> if present
1:3bb140c:      * @param hasJDBClimitClause True if the offset/fetchFirst clauses come
1:3bb140c:      *                           from JDBC limit/offset escape syntax
1:3bb140c:      * @param cm                 The context manager
1:eac0369: 	 */
1:3bb140c:     InsertNode(
1:3bb140c:             QueryTreeNode    targetName,
1:3bb140c:             ResultColumnList insertColumns,
1:3bb140c:             ResultSetNode    queryExpression,
1:508a010:             MatchingClauseNode matchingClause,
1:3bb140c:             Properties       targetProperties,
1:3bb140c:             OrderByList      orderByList,
1:3bb140c:             ValueNode        offset,
1:3bb140c:             ValueNode        fetchFirst,
1:3bb140c:             boolean          hasJDBClimitClause,
1:3bb140c:             ContextManager   cm)
1:eac0369: 	{
1:eac0369: 		/* statementType gets set in super() before we've validated
1:eac0369: 		 * any properties, so we've kludged the code to get the
1:eac0369: 		 * right statementType for a bulk insert replace.
1:eac0369: 		 */
1:508a010:         super(queryExpression, matchingClause, getStatementType(targetProperties), cm);
1:3bb140c:         setTarget(targetName);
1:3bb140c:         targetColumnList = insertColumns;
1:3bb140c:         this.targetProperties = targetProperties;
1:3bb140c:         this.orderByList = orderByList;
1:3bb140c:         this.offset = offset;
1:3bb140c:         this.fetchFirst = fetchFirst;
1:3bb140c:         this.hasJDBClimitClause = hasJDBClimitClause;
1:108305b: 
1:eac0369: 		/* Remember that the query expression is the source to an INSERT */
1:eac0369: 		getResultSetNode().setInsertSource();
8:eac0369: 	}
1:2060c4a: 
1:9d08b6a: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:e1f49ca:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369:             try {
1:eac0369:                 return ( (targetTableName!=null) ? targetTableName : targetVTI.getTableName() ).toString() + "\n"
1:eac0369:                     + targetProperties + "\n"
1:eac0369:                     + super.toString();
1:eac0369:             } catch (org.apache.derby.iapi.error.StandardException e) {
1:eac0369:                 return "tableName: <not_known>\n"
1:eac0369:                     + targetProperties + "\n"
1:eac0369:                     + super.toString();
1:eac0369:             }
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:e1f49ca:     @Override
1:3bb140c:     String statementToString()
1:eac0369: 	{
1:eac0369: 		return "INSERT";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:e1f49ca:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (targetTableName != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "targetTableName: ");
1:eac0369: 				targetTableName.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (targetColumnList != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "targetColumnList: ");
1:eac0369: 				targetColumnList.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 
1:2060c4a: 			if (orderByList != null) {
1:2060c4a: 				printLabel(depth, "orderByList: ");
1:2060c4a: 				orderByList.treePrint(depth + 1);
1:2060c4a: 			}
1:2060c4a: 
1:4d044a3:             if (offset != null) {
1:4d044a3:                 printLabel(depth, "offset:");
1:4d044a3:                 offset.treePrint(depth + 1);
1:4d044a3:             }
1:4d044a3: 
1:4d044a3:             if (fetchFirst != null) {
1:4d044a3:                 printLabel(depth, "fetch first/next:");
1:4d044a3:                 fetchFirst.treePrint(depth + 1);
1:4d044a3:             }
1:4d044a3: 
1:eac0369: 			/* RESOLVE - need to print out targetTableDescriptor */
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this InsertNode.  This means looking up tables and columns and
1:eac0369: 	 * getting their types, and figuring out the result types of all
1:eac0369: 	 * expressions, as well as doing view resolution, permissions checking,
1:eac0369: 	 * etc.
1:eac0369: 	 * <p>
1:eac0369: 	 * Binding an insert will also massage the tree so that
1:eac0369: 	 * the collist and select column order/number are the
1:eac0369: 	 * same as the layout of the table in the store. 
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:e1f49ca:     @Override
1:cc770d8: 	public void bindStatement() throws StandardException
1:eac0369: 	{
1:c45f5b1: 		// We just need select privilege on the expressions
1:c45f5b1: 		getCompilerContext().pushCurrentPrivType( Authorizer.SELECT_PRIV);
1:eac0369: 
1:3bb140c:         FromList fromList = new FromList(
1:3bb140c:                 getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                 getContextManager());
1:eac0369: 
1:eac0369: 		/* If any underlying ResultSetNode is a SelectNode, then we
1:eac0369: 		 * need to do a full bind(), including the expressions
1:eac0369: 		 * (since the fromList may include a FromSubquery).
1:eac0369: 		 */
1:eac0369:         DataDictionary dataDictionary = getDataDictionary();
1:eac0369: 		super.bindResultSetsWithTables(dataDictionary);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Get the TableDescriptor for the table we are inserting into
1:eac0369: 		*/
1:eac0369: 		verifyTargetTable();
1:eac0369: 
1:eac0369: 		// Check the validity of the targetProperties, if they exist
1:eac0369: 		if (targetProperties != null)
1:eac0369: 		{
1:eac0369: 			verifyTargetProperties(dataDictionary);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Get the resultColumnList representing the columns in the base
1:3d2d88b: 		** table or VTI. We don't bother adding any permission checks here
1:3d2d88b:         ** because they are assumed by INSERT permission on the table.
1:eac0369: 		*/
1:3d2d88b:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:3d2d88b:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:eac0369: 		getResultColumnList();
1:eac0369: 
1:eac0369: 		/* If we have a target column list, then it must have the same # of
1:eac0369: 		 * entries as the result set's RCL.
1:eac0369: 		 */
1:eac0369: 		if (targetColumnList != null)
1:eac0369: 		{
1:eac0369: 			/*
1:b6c6e95: 			 * Normalize synonym qualifers for column references.
1:eac0369: 			 */
1:b6c6e95: 			if (synonymTableName != null)
1:eac0369: 			{
1:b6c6e95: 				normalizeSynonymColumns ( targetColumnList, targetTableName );
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			/* Bind the target column list */
1:c45f5b1: 			getCompilerContext().pushCurrentPrivType( getPrivType());
1:eac0369: 			if (targetTableDescriptor != null)
1:eac0369: 			{
1:eac0369: 				targetColumnList.bindResultColumnsByName(targetTableDescriptor,
1:b7730e4: 														(DMLStatementNode) this);
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				targetColumnList.bindResultColumnsByName(targetVTI.getResultColumns(), targetVTI,
2:eac0369: 														this);
1:3d2d88b: 			}	
1:c45f5b1: 			getCompilerContext().popCurrentPrivType();
1:3d2d88b:         }
1:c533cd2: 
1:d1ad6c9:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:d1ad6c9: 
1:eac0369: 		/* Verify that all underlying ResultSets reclaimed their FromList */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(fromList.size() == 0,
1:eac0369: 				"fromList.size() is expected to be 0, not " + 
1:eac0369: 				fromList.size() +
1:eac0369: 				" on return from RS.bindExpressions()");
1:eac0369: 		}
1:eac0369: 
1:c341dc4:         /* Replace any DEFAULTs with the associated tree, or flag DEFAULTs if
1:c341dc4:          * not allowed (inside top level set operator nodes). Subqueries are
1:c341dc4:          * checked for illegal DEFAULTs elsewhere.
1:c341dc4:          */
1:c341dc4:         boolean isTableConstructor =
1:c341dc4:             (resultSet instanceof UnionNode &&
1:c341dc4:              ((UnionNode)resultSet).tableConstructor()) ||
1:c341dc4:             resultSet instanceof RowResultSetNode;
1:c341dc4: 
1:661c2e6:         //
1:661c2e6:         // For the MERGE statement, DEFAULT expressions in the SELECT node
1:661c2e6:         // may have been replaced with generated expressions already.
1:661c2e6:         //
1:661c2e6:         ResultColumnList    tempRCL = resultSet.getResultColumns();
1:661c2e6:         boolean defaultsWereReplaced = false;
1:661c2e6:         for ( int i = 0; i < tempRCL.size(); i++ )
1:661c2e6:         {
1:661c2e6:             ResultColumn    rc = tempRCL.getResultColumn( i+1 );
1:661c2e6:             if ( rc.wasDefaultColumn() ) { defaultsWereReplaced = true; }
1:661c2e6:         }
1:661c2e6: 
1:c341dc4:         resultSet.replaceOrForbidDefaults(targetTableDescriptor,
1:c341dc4:                                           targetColumnList,
1:c341dc4:                                           isTableConstructor);
1:eac0369: 
1:eac0369: 		/* Bind the expressions now that the result columns are bound 
1:eac0369: 		 * NOTE: This will be the 2nd time for those underlying ResultSets
1:eac0369: 		 * that have tables (no harm done), but it is necessary for those
1:eac0369: 		 * that do not have tables.  It's too hard/not work the effort to
1:eac0369: 		 * avoid the redundancy.
1:eac0369: 		 */
1:eac0369: 		super.bindExpressions();
1:eac0369: 
1:3d2d88b:         //
1:3d2d88b:         // At this point, we have added permissions checks for the driving query.
1:3d2d88b:         // Now add a check for INSERT privilege on the target table.
1:3d2d88b:         //
1:3d2d88b:         if (isPrivilegeCollectionRequired())
1:3d2d88b:         {
1:3d2d88b:             getCompilerContext().pushCurrentPrivType( getPrivType());
1:3d2d88b:             getCompilerContext().addRequiredTablePriv( targetTableDescriptor );
1:3d2d88b:             getCompilerContext().popCurrentPrivType();
1:3d2d88b:         }
1:3d2d88b: 
1:3d2d88b:         // Now stop adding permissions checks.
1:3d2d88b:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:3d2d88b: 
1:eac0369: 		/*
1:eac0369: 		** If the result set is a union, it could be a table constructor.
1:eac0369: 		** Bind any nulls in the result columns of the table constructor
1:eac0369: 		** to the types of the table being inserted into.
1:eac0369: 		**
1:eac0369: 		** The types of ? parameters in row constructors and table constructors
1:eac0369: 		** in an INSERT statement come from the result columns.
1:eac0369: 		**
1:eac0369: 		** If there is a target column list, use that instead of the result
1:eac0369: 		** columns for the whole table, since the columns in the result set
1:eac0369: 		** correspond to the target column list.
1:eac0369: 		*/
1:eac0369: 		if (targetColumnList != null)
1:eac0369: 		{
1:d5ef906: 			if (resultSet.getResultColumns().visibleSize() > targetColumnList.size())
1:eac0369: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
1:eac0369: 			resultSet.bindUntypedNullsToResultColumns(targetColumnList);
1:eac0369: 			resultSet.setTableConstructorTypes(targetColumnList);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:d5ef906: 			if (resultSet.getResultColumns().visibleSize() > resultColumnList.size())
1:eac0369: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
1:eac0369: 			resultSet.bindUntypedNullsToResultColumns(resultColumnList);
1:eac0369: 			resultSet.setTableConstructorTypes(resultColumnList);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Bind the columns of the result set to their expressions */
1:eac0369: 		resultSet.bindResultColumns(fromList);
1:eac0369: 
1:d5ef906: 		int resCols = resultSet.getResultColumns().visibleSize();
1:eac0369: 		DataDictionary dd = getDataDictionary();
1:eac0369: 		if (targetColumnList != null)
1:eac0369: 		{
1:eac0369: 			if (targetColumnList.size() != resCols)
1:eac0369: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
1:eac0369: 		}
1:eac0369: 		else 
1:eac0369: 		{
1:eac0369: 			if (targetTableDescriptor != null &&
1:eac0369: 						targetTableDescriptor.getNumberOfColumns() != resCols)
1:eac0369: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* See if the ResultSet's RCL needs to be ordered to match the target
1:eac0369: 		 * list, or "enhanced" to accommodate defaults.  It can only need to
1:eac0369: 		 * be ordered if there is a target column list.  It needs to be
1:eac0369: 		 * enhanced if there are fewer source columns than there are columns
1:eac0369: 		 * in the table.
1:eac0369: 		 */
1:eac0369: 		boolean inOrder = true;
1:eac0369: 		int numTableColumns = resultColumnList.size();
1:eac0369: 
1:eac0369: 		/* colMap[] will be the size of the target list, which could be larger
1:eac0369: 		 * than the current size of the source list.  In that case, the source
1:eac0369: 		 * list will be "enhanced" to include defaults.
1:eac0369: 		 */
1:eac0369: 		int[] colMap = new int[numTableColumns];
1:eac0369: 
1:eac0369: 		// set the fields to an unused value
1:eac0369: 		for (int i = 0; i < colMap.length; i++) 
1:eac0369: 		{
1:eac0369: 			colMap[i] = -1;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Create the source/target list mapping */
1:eac0369: 		if (targetColumnList != null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** There is a target column list, so the result columns might
1:eac0369: 			** need to be ordered.  Step through the target column list
1:eac0369: 			** and remember the position in the target table of each column.
1:eac0369: 			** Remember if any of the columns are out of order.
1:eac0369: 			*/
1:eac0369: 			int targetSize = targetColumnList.size();
1:eac0369: 			for (int index = 0; index < targetSize; index++)
1:eac0369: 			{
1:e1f49ca:                 int position = targetColumnList.elementAt(index).
1:b0456a0:                     getColumnDescriptor().getPosition();
1:eac0369: 
1:eac0369: 				if (index != position-1)
1:eac0369: 				{
1:eac0369: 					inOrder = false;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// position is 1-base; colMap indexes and entries are 0-based.
1:eac0369: 				colMap[position-1] = index;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** There is no target column list, so the result columns in the
1:eac0369: 			** source are presumed to be in the same order as the target
1:eac0369: 			** table.
1:eac0369: 			*/
1:eac0369: 			for (int position = 0;
1:d5ef906: 				position < resultSet.getResultColumns().visibleSize();
1:eac0369: 				position++)
1:eac0369: 			{
1:eac0369: 				colMap[position] = position;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:2060c4a: 		// Bind the ORDER BY columns
1:2060c4a: 		if (orderByList != null)
1:2060c4a: 		{
1:2060c4a: 			orderByList.pullUpOrderByColumns(resultSet);
1:2060c4a: 
1:2060c4a: 			// The select list may have new columns now, make sure to bind
1:2060c4a: 			// those.
1:2060c4a: 			super.bindExpressions();
1:2060c4a: 
1:2060c4a: 			orderByList.bindOrderByColumns(resultSet);
1:2060c4a: 		}
1:2060c4a: 
1:108305b:         bindOffsetFetch(offset, fetchFirst);
1:108305b: 
1:661c2e6: 		resultSet = enhanceAndCheckForAutoincrement( resultSet, inOrder, colMap, defaultsWereReplaced );
1:eac0369: 
1:eac0369: 		resultColumnList.checkStorableExpressions(resultSet.getResultColumns());
1:eac0369: 		/* Insert a NormalizeResultSetNode above the source if the source
1:eac0369: 		 * and target column types and lengths do not match.
1:eac0369:  		 */
1:eac0369: 		if (! resultColumnList.columnTypesAndLengthsMatch(
1:eac0369: 												resultSet.getResultColumns()))
1:eac0369: 		{
1:bfc59e5:             
1:3bb140c:             resultSet = new NormalizeResultSetNode(
1:3bb140c:                 resultSet, resultColumnList, null, false, getContextManager());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (targetTableDescriptor != null)
1:eac0369: 		{
1:eac0369: 			ResultColumnList sourceRCL = resultSet.getResultColumns();
1:eac0369: 			sourceRCL.copyResultColumnNames(resultColumnList);
1:c533cd2: 
1:c533cd2:             /* bind all generation clauses for generated columns */
1:c533cd2:             parseAndBindGenerationClauses
1:c533cd2:                 ( dataDictionary, targetTableDescriptor, sourceRCL, resultColumnList, false, null );
1:c533cd2:             
1:c533cd2: 			/* Get and bind all constraints on the table */
1:af1c18c:             boolean[] hasDCC = new boolean[]{false /* a priori*/ };
1:af1c18c: 
1:af1c18c:             checkConstraints = bindConstraints(
1:af1c18c:                     dataDictionary,
1:af1c18c:                     getOptimizerFactory(),
1:af1c18c:                     targetTableDescriptor,
1:af1c18c:                     null,
1:af1c18c:                     sourceRCL,
1:af1c18c:                     (int[]) null,
1:af1c18c:                     (FormatableBitSet) null,
1:af1c18c:                     true, // we always include triggers in core language
1:af1c18c:                     hasDCC);
1:af1c18c: 
1:af1c18c:             hasDeferrableCheckConstraints = hasDCC[0];
1:af1c18c: 
1:eac0369: 			/* Do we need to do a deferred mode insert */
1:eac0369: 			/* 
1:eac0369: 		 	** Deferred if:
1:eac0369: 			**	If the target table is also a source table
1:eac0369: 			**	Self-referencing foreign key constraint 
1:eac0369: 			**	trigger
1:eac0369: 			*/
1:eac0369: 			if (resultSet.referencesTarget(
1:eac0369: 									targetTableDescriptor.getName(), true) ||
1:eac0369: 				 requiresDeferredProcessing())
1:a180287: 			{
1:eac0369: 				deferred = true;
1:eac0369: 
1:eac0369: 				/* Disallow bulk insert replace when target table
1:eac0369: 				 * is also a source table.
1:eac0369: 				 */
1:eac0369: 				if (bulkInsertReplace &&
1:eac0369: 					resultSet.referencesTarget(
1:eac0369: 									targetTableDescriptor.getName(), true))
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_INVALID_BULK_INSERT_REPLACE, 
1:eac0369: 									targetTableDescriptor.getQualifiedName());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Get the list of indexes on the table being inserted into */
1:eac0369: 			getAffectedIndexes(targetTableDescriptor);
1:eac0369: 			TransactionController tc = 
1:eac0369: 				getLanguageConnectionContext().getTransactionCompile();
1:eac0369: 
1:eac0369: 			autoincRowLocation = 
1:eac0369: 				dd.computeAutoincRowLocations(tc, targetTableDescriptor);
1:2d2e717: 		}
1:eac0369: 		else
1:2d2e717: 		{
1:eac0369:             deferred = VTIDeferModPolicy.deferIt( DeferModification.INSERT_STATEMENT,
1:eac0369:                                                   targetVTI,
2:eac0369:                                                   null,
1:eac0369:                                                   resultSet);
1:eac0369: 		}
1:a180287: 
1:a826375:         identitySequenceUUIDString = getUUIDofSequenceGenerator();
1:2d2e717:         
1:18792e2:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:2d2e717: 		getCompilerContext().popCurrentPrivType();
1:eac0369: 	}
1:eac0369: 
1:0958c84: 	/**
1:0958c84: 	 * Process ResultSet column lists for projection and autoincrement.
1:0958c84: 	 *
1:0958c84: 	 * This method recursively descends the result set node tree. When
1:0958c84: 	 * it finds a simple result set, it processes any autoincrement
1:0958c84: 	 * columns in that rs by calling checkAutoIncrement. When it finds
1:0958c84: 	 * a compound result set, like a Union or a PRN, it recursively
1:0958c84: 	 * descends to the child(ren) nodes. Union nodes can arise due to
1:0958c84: 	 * multi-rows in VALUES clause), PRN nodes can arise when the set
1:0958c84: 	 * of columns being inserted is a subset of the set of columns in 
1:0958c84: 	 * the table.
1:0958c84: 	 *
1:0958c84: 	 * In addition to checking for autoincrement columns in the result set,
1:0958c84: 	 * we may need to enhance and re-order the column list to match the
1:0958c84: 	 * column list of the table we are inserting into. This work is handled
1:0958c84: 	 * by ResultsetNode.enhanceRCLForInsert.
1:0958c84: 	 *
1:0958c84: 	 * Note that, at the leaf level, we need to enhance the RCL first, then
1:0958c84: 	 * check for autoincrement columns. At the non-leaf levels, we have
1:0958c84: 	 * to enhance the RCL, but we don't have to check for autoincrement
1:0958c84: 	 * columns, since they only occur at the leaf level.
1:0958c84: 	 *
1:0958c84: 	 * This way, all ColumnDescriptor of all rows will be set properly.
1:0958c84: 	 *
1:0958c84: 	 * @param resultSet			current node in the result set tree
1:0958c84: 	 * @param inOrder			FALSE if the column list needs reordering
1:0958c84: 	 * @param colMap            correspondence between RCLs
1:661c2e6: 	 * @param defaultsWereReplaced  true if DEFAULT clauses were replaced with generated expressions
1:a8db665: 	 * @return a node representing the source for the insert
1:0958c84: 	 *
1:0958c84: 	 * @exception StandardException Thrown on error
1:0958c84: 	 */
1:661c2e6: 	ResultSetNode enhanceAndCheckForAutoincrement
1:a180287:         (
1:661c2e6:          ResultSetNode resultSet,
1:661c2e6:          boolean inOrder,
1:661c2e6:          int[] colMap,
1:661c2e6:          boolean    defaultsWereReplaced
1:a180287:          )
1:0958c84: 		throws StandardException
1:0958c84: 	{
1:0958c84: 		/*
1:0958c84: 		 * Some implementation notes:
1:0958c84: 		 * 
1:0958c84: 		 * colmap[x] == y means that column x in the target table
1:0958c84: 		 * maps to column y in the source result set.
1:0958c84: 		 * colmap[x] == -1 means that column x in the target table
1:0958c84: 		 * maps to its default value.
1:0958c84: 		 * both colmap indexes and values are 0-based.
1:0958c84: 		 *
1:0958c84: 		 * if the list is in order and complete, we don't have to change
1:0958c84: 		 * the tree. If it is not, then we call RSN.enhanceRCLForInsert() 
1:0958c84: 		 * which will reorder ("enhance") the source RCL within the same RSN)
1:0958c84: 		 *
1:0958c84: 		 * one thing we do know is that all of the resultsets underneath
1:0958c84: 		 * us have their resultColumn names filled in with the names of
1:0958c84: 		 * the target table columns.  That makes generating the mapping
1:0958c84: 		 * "easier" -- we simply generate the names of the target table columns
1:0958c84: 		 * that are included.  For the missing columns, we generate default
1:0958c84: 		 * value expressions.
1:0958c84: 		 */
1:0958c84: 
1:a8db665: 		resultSet = resultSet.enhanceRCLForInsert(this, inOrder, colMap);
1:0958c84: 
1:a8db665: 		// Forbid overrides for generated columns and identity columns that
1:a8db665: 		// are defined as GENERATED ALWAYS.
1:a8db665: 		if ((resultSet instanceof UnionNode) &&
1:a8db665: 				((UnionNode) resultSet).tableConstructor()) {
1:a8db665: 			// If this is a multi-row table constructor, we are not really
1:a8db665: 			// interested in the result column list of the top-level UnionNode.
1:a8db665: 			// The interesting RCLs are those of the RowResultSetNode children
1:a8db665: 			// of the UnionNode, and they have already been checked from
1:a8db665: 			// UnionNode.enhanceRCLForInsert(). Since the RCL of the UnionNode
1:a8db665: 			// doesn't tell whether or not DEFAULT is specified at the leaf
1:a8db665: 			// level, we need to skip it here to avoid false positives.
1:a8db665: 		} else {
1:661c2e6: 			resultColumnList.forbidOverrides( resultSet.getResultColumns(), defaultsWereReplaced );
1:0958c84: 		}
1:a8db665: 
1:a8db665: 		return resultSet;
1:0958c84: 	}
1:eac0369: 
1:e1f49ca:     @Override
1:c45f5b1: 	int getPrivType()
1:0958c84: 	{
1:c45f5b1: 		return Authorizer.INSERT_PRIV;
1:0958c84: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1:eac0369: 	 *
1:eac0369: 	 * @return	true if references SESSION schema tables, else false
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:e1f49ca:     @Override
1:eac0369: 	public boolean referencesSessionSchema()
1:eac0369: 		throws StandardException
1:0958c84: 	{
1:eac0369: 		boolean returnValue = false;
1:eac0369: 
1:eac0369: 		//If this node references a SESSION schema table, then return true. 
1:eac0369: 		if (targetTableDescriptor != null)
1:eac0369: 			returnValue = isSessionSchema(targetTableDescriptor.getSchemaDescriptor());
1:eac0369: 
1:eac0369: 		if (returnValue == false)
1:eac0369: 			returnValue = resultSet.referencesSessionSchema();
1:eac0369: 
1:eac0369: 		return returnValue;
1:0958c84: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Verify that the target properties that we are interested in
1:eac0369: 	 * all hold valid values.
1:eac0369: 	 * NOTE: Any target property which is valid but cannot be supported
1:eac0369: 	 * due to a target database, etc. will be turned off quietly.
1:eac0369: 	 *
1:eac0369: 	 * @param dd	The DataDictionary
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private void verifyTargetProperties(DataDictionary dd)
1:eac0369: 		throws StandardException
1:0958c84: 	{
1:eac0369: 		// The only property that we're currently interested in is insertMode
1:eac0369: 		String insertMode = targetProperties.getProperty("insertMode");
1:eac0369: 		if (insertMode != null)
1:eac0369: 		{
1:eac0369: 			String upperValue = StringUtil.SQLToUpperCase(insertMode);
1:eac0369: 			if (! upperValue.equals("BULKINSERT") &&
1:eac0369: 				! upperValue.equals("REPLACE"))
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.LANG_INVALID_INSERT_MODE, 
1:eac0369: 								insertMode,
1:eac0369: 								targetTableName);
1:eac0369: 			}
1:0958c84: 			else
1:eac0369: 			{
1:eac0369: 				/* Turn off bulkInsert if it is on and we can't support it. */
1:eac0369: 				if (! verifyBulkInsert(dd, upperValue))
1:eac0369: 				{
1:eac0369: 					targetProperties.remove("insertMode");
1:eac0369: 				}
1:eac0369: 				else
1:eac0369: 				{
1:eac0369: 					/* Now we know we're doing bulk insert */
1:eac0369: 					bulkInsert = true;
1:eac0369: 
1:eac0369: 					if (upperValue.equals("REPLACE"))
1:eac0369: 					{
1:eac0369: 						bulkInsertReplace = true;
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					// Validate the bulkFetch property if specified
1:eac0369: 					String bulkFetchStr = targetProperties.getProperty("bulkFetch");
1:eac0369: 					if (bulkFetchStr != null)
1:eac0369: 					{
1:eac0369: 						int bulkFetch = getIntProperty(bulkFetchStr, "bulkFetch");
1:eac0369: 
1:eac0369: 						// verify that the specified value is valid
1:eac0369: 						if (bulkFetch <= 0)
1:eac0369: 						{
1:eac0369: 							throw StandardException.newException(SQLState.LANG_INVALID_BULK_FETCH_VALUE,
1:eac0369: 									String.valueOf(bulkFetch));
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do the bind time checks to see if bulkInsert is allowed on
1:eac0369: 	 * this table.  bulkInsert is disallowed at bind time for:
1:eac0369: 	 *		o  target databases
1:eac0369: 	 *		o  (tables with triggers?)
1:eac0369: 	 * (It is disallowed at execution time if the table has at
1:eac0369: 	 * least 1 row in it or if it is a deferred mode insert.)
1:eac0369: 	 *
1:eac0369: 	 * @param dd	The DataDictionary
1:eac0369: 	 * @param mode	The insert mode
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not bulkInsert is allowed.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private boolean verifyBulkInsert(DataDictionary dd, String mode)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Compile constants that Execution will use
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:e1f49ca:     @Override
1:3bb140c:     public ConstantAction makeConstantAction() throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		/* Different constant actions for base tables and updatable VTIs */
1:eac0369: 		if (targetTableDescriptor != null)
1:eac0369: 		{
1:eac0369: 			// Base table
1:eac0369: 
1:eac0369: 			long heapConglomId = targetTableDescriptor.getHeapConglomerateId();
1:eac0369: 			TransactionController tc = 
1:eac0369: 				getLanguageConnectionContext().getTransactionCompile();
1:eac0369: 			int numIndexes = (targetTableDescriptor != null) ?
1:eac0369: 								indexConglomerateNumbers.length : 0;
1:eac0369: 			StaticCompiledOpenConglomInfo[] indexSCOCIs = 
1:eac0369: 				new StaticCompiledOpenConglomInfo[numIndexes];
1:eac0369: 
1:eac0369: 			for (int index = 0; index < numIndexes; index++)
1:eac0369: 			{
1:eac0369: 				indexSCOCIs[index] = tc.getStaticCompiledConglomInfo(indexConglomerateNumbers[index]);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If we're doing bulk insert, do table locking regardless of
1:eac0369: 			** what the optimizer decided.  This is because bulk insert is
1:eac0369: 			** generally done with a large number of rows into an empty table.
1:eac0369: 			** We also do table locking if the table's lock granularity is
1:eac0369: 			** set to table.
1:eac0369: 			*/
1:eac0369: 			if (bulkInsert ||
1:eac0369: 				targetTableDescriptor.getLockGranularity() == TableDescriptor.TABLE_LOCK_GRANULARITY)
1:eac0369: 			{
1:eac0369: 				lockMode = TransactionController.MODE_TABLE;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return	getGenericConstantActionFactory().getInsertConstantAction
1:eac0369: 				( targetTableDescriptor,
1:eac0369: 				  heapConglomId,
1:eac0369: 				  tc.getStaticCompiledConglomInfo(heapConglomId),
1:eac0369: 				  indicesToMaintain,
1:eac0369: 				  indexConglomerateNumbers,
1:eac0369: 				  indexSCOCIs,
1:eac0369: 				  indexNames,
1:eac0369: 				  deferred,
2:eac0369: 				  false,
1:af1c18c:                   hasDeferrableCheckConstraints,
1:eac0369: 				  targetTableDescriptor.getUUID(),
1:eac0369: 				  lockMode,
1:eac0369: 				  null, null, 
1:eac0369: 				  targetProperties,
1:eac0369: 				  getFKInfo(),
1:eac0369: 				  getTriggerInfo(),
1:eac0369: 				  resultColumnList.getStreamStorableColIds(targetTableDescriptor.getNumberOfColumns()),
1:eac0369: 				  getIndexedCols(),
1:eac0369: 				  (UUID) null,
1:eac0369: 				  null,
1:eac0369: 				  null,
1:eac0369: 				  resultSet.isOneRowResultSet(), 
1:01632c2: 				  autoincRowLocation,
1:a180287: 				  inMatchingClause(),
1:a180287: 				  identitySequenceUUIDString
1:a180287: 				  );
1:a180287: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/* Return constant action for VTI
1:eac0369: 			 * NOTE: ConstantAction responsible for preserving instantiated
1:eac0369: 			 * VTIs for in-memory queries and for only preserving VTIs
1:eac0369: 			 * that implement Serializable for SPSs.
1:eac0369: 			 */
1:eac0369: 			return	getGenericConstantActionFactory().getUpdatableVTIConstantAction( DeferModification.INSERT_STATEMENT,
1:eac0369: 						deferred);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create a boolean[] to track the (0-based) columns which are indexed.
1:eac0369: 	 *
1:eac0369: 	 * @return A boolean[] to track the (0-based) columns which are indexed.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:3bb140c:     boolean[] getIndexedCols() throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Create a boolean[] to track the (0-based) columns which are indexed */
1:eac0369: 		boolean[] indexedCols = new boolean[targetTableDescriptor.getNumberOfColumns()];
1:eac0369: 		for (int index = 0; index < indicesToMaintain.length; index++)
1:eac0369: 		{
1:eac0369: 			int[] colIds = indicesToMaintain[index].getIndexDescriptor().baseColumnPositions();
1:eac0369: 
1:eac0369: 			for (int index2 = 0; index2 < colIds.length; index2++)
1:eac0369: 			{
1:eac0369: 				indexedCols[colIds[index2] - 1] = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return indexedCols;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2060c4a:      * {@inheritDoc}
1:2060c4a:      * <p>
1:2060c4a:      * Remove any duplicate ORDER BY columns and push an ORDER BY if present
1:2060c4a:      * down to the source result set, before calling super.optimizeStatement.
1:2060c4a:      * </p>
1:2060c4a: 	 */
1:e1f49ca:     @Override
1:2060c4a: 	public void optimizeStatement() throws StandardException
1:2060c4a: 	{
1:b4cda60:         resultSet.pushQueryExpressionSuffix();
1:2060c4a: 		// Push the order by list down to the ResultSet
1:2060c4a: 		if (orderByList != null)
1:2060c4a: 		{
1:2060c4a: 			// If we have more than 1 ORDERBY columns, we may be able to
1:2060c4a: 			// remove duplicate columns, e.g., "ORDER BY 1, 1, 2".
1:2060c4a: 			if (orderByList.size() > 1)
1:2060c4a: 			{
1:2060c4a: 				orderByList.removeDupColumns();
1:2060c4a: 			}
1:2060c4a: 
1:2060c4a: 			resultSet.pushOrderByList(orderByList);
1:108305b: 
1:2060c4a: 			orderByList = null;
1:2060c4a: 		}
1:108305b: 
1:57c1b5c:         resultSet.pushOffsetFetchFirst( offset, fetchFirst, hasJDBClimitClause );
1:108305b: 
1:2060c4a: 		super.optimizeStatement();
1:d7ee7fa:         
1:d7ee7fa:         //
1:d7ee7fa:         // If the insert stream involves a table function, attempt the bulk-insert
1:d7ee7fa:         // optimization. See https://issues.apache.org/jira/browse/DERBY-4789
1:d7ee7fa:         // We perform this check after optimization because the table function may be
1:d7ee7fa:         // wrapped in a view, which is only expanded at optimization time.
1:d7ee7fa:         //
1:d7ee7fa:         HasTableFunctionVisitor tableFunctionVisitor = new HasTableFunctionVisitor();
1:d7ee7fa:         this.accept( tableFunctionVisitor );
1:063dd55:         // DERBY-5614: See if the target is a global temporary table (GTT),
1:063dd55:         // in which case we don't support bulk insert.
1:063dd55:         if ( tableFunctionVisitor.hasNode() &&
1:063dd55:                 !isSessionSchema(targetTableDescriptor.getSchemaDescriptor())) {
1:063dd55:             requestBulkInsert();
1:2060c4a:         }
1:063dd55:     }
1:2060c4a: 
1:d7ee7fa:     /**
1:d7ee7fa:      * Request bulk insert optimization at run time.
1:d7ee7fa:      */
1:d7ee7fa:     private void requestBulkInsert()
1:d7ee7fa:     {
1:d7ee7fa:         if ( targetProperties == null ) { targetProperties = new Properties(); }
1:d7ee7fa: 
1:d7ee7fa:         // Set bulkInsert if insertMode not already set. For the import procedures,
1:d7ee7fa:         // the insertMode property may be set already
1:d7ee7fa:         String key = "insertMode";
1:d7ee7fa:         String value = "bulkInsert";
1:d7ee7fa: 
1:d7ee7fa:         if ( targetProperties.getProperty( key ) == null )
1:d7ee7fa:         { targetProperties.put( key, value ); }
1:d7ee7fa: 
1:959fef2:         bulkInsert = true;
1:d7ee7fa:     }
1:959fef2: 
1:2060c4a: 	/**
1:eac0369: 	 * Code generation for insert
1:eac0369: 	 * creates an expression for:
1:c533cd2: 	 *   ResultSetFactory.getInsertResultSet(resultSet.generate(ps), generationClausesResult, checkConstrainResult, this )
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ActivationClassBuilder for the class being built
1:eac0369: 	 * @param mb the method  for the execute() method to be built
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:e1f49ca:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:ccee531: 		// If the DML is on the temporary table, generate the code to
1:ccee531: 		// mark temporary table as modified in the current UOW. After
1:ccee531: 		// DERBY-827 this must be done in execute() since
1:d11ed08: 		// createResultSet() will only be called once.
1:d11ed08: 		generateCodeForTemporaryTable(acb);
1:eac0369: 
1:eac0369: 		/* generate the parameters */
1:eac0369: 		generateParameterValueSet(acb);
1:eac0369: 		// Base table
1:eac0369: 		if (targetTableDescriptor != null)
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Generate the insert result set, giving it either the original
1:eac0369: 			** source or the normalize result set, the constant action,
2:eac0369: 			** and "this".
1:eac0369: 			*/
1:eac0369: 
1:eac0369: 			acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 
1:eac0369: 			// arg 1
1:01632c2:             if ( inMatchingClause() )
1:01632c2:             {
1:01632c2:                 matchingClause.generateResultSetField( acb, mb );
1:01632c2:             }
1:01632c2:             else
1:01632c2:             {
1:01632c2:                 resultSet.generate( acb, mb );
1:01632c2:             }
1:eac0369: 
1:c533cd2: 			// arg 2 generate code to evaluate generation clauses
1:0397292: 			generateGenerationClauses( resultColumnList, resultSet.getResultSetNumber(), false, acb, mb );
1:c533cd2: 
1:c533cd2: 			// arg 3 generate code to evaluate CHECK CONSTRAINTS
1:eac0369: 			generateCheckConstraints( checkConstraints, acb, mb );
1:eac0369: 
1:959fef2:             // arg 4 row template used by bulk insert
1:959fef2:             if (bulkInsert) {
1:959fef2:                 ColumnDescriptorList cdl =
1:959fef2:                         targetTableDescriptor.getColumnDescriptorList();
1:959fef2:                 ExecRowBuilder builder =
1:959fef2:                         new ExecRowBuilder(cdl.size(), false);
1:959fef2:                 for (int i = 0; i < cdl.size(); i++) {
1:3bb140c:                     ColumnDescriptor cd = cdl.get(i);
1:959fef2:                     builder.setColumn(i + 1, cd.getType());
1:959fef2:                 }
1:959fef2:                 mb.push(acb.addItem(builder));
1:959fef2:             } else {
1:959fef2:                 mb.push(-1);
1:959fef2:             }
1:959fef2: 
1:af1c18c:             // arg 5, 6 table name
1:af1c18c:             if (targetTableName.getSchemaName() == null) {
1:af1c18c:                 mb.pushNull("java.lang.String");
1:af1c18c:             } else {
1:af1c18c:                 mb.push(targetTableName.getSchemaName());
1:af1c18c:             }
1:af1c18c: 
1:af1c18c:             mb.push(targetTableName.getTableName());
1:af1c18c: 
1:959fef2:             mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
1:af1c18c:                     "getInsertResultSet", ClassName.ResultSet, 6);
1:063dd55: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/* Generate code for the VTI
1:eac0369: 			 * NOTE: we need to create a dummy cost estimate for the
1:eac0369: 			 * targetVTI since we never optimized it.
1:eac0369: 			 * RESOLVEVTI - we will have to optimize it in order to 
1:eac0369: 			 * push predicates into the VTI.
1:eac0369: 			 */
1:eac0369: 			targetVTI.assignCostEstimate(resultSet.getNewCostEstimate());
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Generate the insert VTI result set, giving it either the original
1:eac0369: 			** source or the normalize result set, the constant action,
1:eac0369: 			*/
1:eac0369: 			acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 
1:eac0369: 			// arg 1
2:eac0369: 			resultSet.generate(acb, mb);
1:eac0369: 
1:eac0369: 			// arg 2
1:eac0369: 			targetVTI.generate(acb, mb);
1:eac0369: 
1:6b26ee1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getInsertVTIResultSet", ClassName.ResultSet, 2);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the type of statement, something from
1:eac0369: 	 * StatementType.
1:eac0369: 	 *
1:eac0369: 	 * @return the type of statement
1:eac0369: 	 */
1:e1f49ca:     @Override
1:eac0369: 	protected final int getStatementType()
1:eac0369: 	{
1:eac0369: 		return StatementType.INSERT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the statement type, where it is dependent on
1:eac0369: 	 * the targetProperties.  (insertMode = replace causes
1:eac0369: 	 * statement type to be BULK_INSERT_REPLACE.
1:eac0369: 	 *
1:eac0369: 	 * @return the type of statement
1:eac0369: 	 */
1:e1f49ca:     static int getStatementType(Properties targetProperties)
1:eac0369: 	{
1:eac0369: 		int retval = StatementType.INSERT;
1:eac0369: 
1:eac0369: 		// The only property that we're currently interested in is insertMode
1:eac0369: 		String insertMode = (targetProperties == null) ? null : targetProperties.getProperty("insertMode");
1:eac0369: 		if (insertMode != null)
1:eac0369: 		{
1:eac0369: 			String upperValue = StringUtil.SQLToUpperCase(insertMode);
1:eac0369: 			if (upperValue.equals("REPLACE"))
1:eac0369: 			{
1:eac0369: 				retval = StatementType.BULK_INSERT_REPLACE;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the list of indexes on the table being inserted into.  This
1:eac0369: 	 * is used by INSERT.  This is an optimized version of what
1:eac0369: 	 * UPDATE and DELETE use. 
1:eac0369: 	 *
1:eac0369: 	 * @param td	TableDescriptor for the table being inserted into
1:eac0369: 	 *				or deleted from
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private void getAffectedIndexes
1:661c2e6: 	(
1:eac0369: 		TableDescriptor 	td
1:661c2e6: 	)	
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		IndexLister	indexLister = td.getIndexLister( );
1:eac0369: 
1:eac0369: 		indicesToMaintain = indexLister.getDistinctIndexRowGenerators();
1:eac0369: 		indexConglomerateNumbers = indexLister.getDistinctIndexConglomerateNumbers();
1:eac0369: 		indexNames = indexLister.getDistinctIndexNames();
1:eac0369: 
1:eac0369: 		/* Add dependencies on all indexes in the list */
1:eac0369: 		ConglomerateDescriptor[]	cds = td.getConglomerateDescriptors();
1:eac0369: 		CompilerContext cc = getCompilerContext();
1:eac0369: 
1:eac0369:  		for (int index = 0; index < cds.length; index++)
1:eac0369: 		{
1:eac0369: 			cc.createDependency(cds[index]);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:9d08b6a: 	 * Accept the visitor for all visitable children of this node.
1:9d08b6a: 	 * 
1:9d08b6a: 	 * @param v the visitor
1:9d08b6a: 	 *
1:9d08b6a: 	 * @exception StandardException on error
1:9d08b6a: 	 */
1:e1f49ca:     @Override
1:9d08b6a: 	void acceptChildren(Visitor v)
1:9d08b6a: 		throws StandardException
1:9d08b6a: 	{
1:9d08b6a: 		super.acceptChildren(v);
1:9d08b6a: 
1:9d08b6a: 		if (targetColumnList != null)
1:9d08b6a: 		{
1:9d08b6a: 			targetColumnList.accept(v);
1:9d08b6a: 		}
1:9d08b6a: 	}
1:9d08b6a: 
1:eac0369: } // end of class InsertNode
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:a826375
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: public final class InsertNode extends DMLModGeneratedColumnsStatementNode
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         identitySequenceUUIDString = getUUIDofSequenceGenerator();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a180287
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 
0:     private     String              identitySequenceUUIDString;
1:     
/////////////////////////////////////////////////////////////////////////
1: 
0:         // if this is 10.11 or higher and the table has an identity column,
0:         // get the uuid of the sequence generator backing the identity column
0:         if (
0:             targetTableDescriptor.tableHasAutoincrement() &&
0:             dd.checkVersion( DataDictionary.DD_VERSION_DERBY_10_11, null )
1:             )
1:         {
0:             SequenceDescriptor  seq = dd.getSequenceDescriptor
1:                 (
0:                  dd.getSystemSchemaDescriptor(),
0:                  TableDescriptor.makeSequenceName( targetTableDescriptor.getUUID() )
1:                  );
0:             identitySequenceUUIDString = seq.getUUID().toString();
1:         }
/////////////////////////////////////////////////////////////////////////
1: 				  inMatchingClause(),
1: 				  identitySequenceUUIDString
commit:18792e2
/////////////////////////////////////////////////////////////////////////
1:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
1:                     getColumnDescriptor().getPosition();
commit:d1ad6c9
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1: 
commit:3d2d88b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.IgnoreFilter;
/////////////////////////////////////////////////////////////////////////
1: 		** table or VTI. We don't bother adding any permission checks here
1:         ** because they are assumed by INSERT permission on the table.
1:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
0:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
/////////////////////////////////////////////////////////////////////////
1: 			}	
1:         }
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // At this point, we have added permissions checks for the driving query.
1:         // Now add a check for INSERT privilege on the target table.
1:         //
1:         if (isPrivilegeCollectionRequired())
1:         {
1:             getCompilerContext().pushCurrentPrivType( getPrivType());
1:             getCompilerContext().addRequiredTablePriv( targetTableDescriptor );
1:             getCompilerContext().popCurrentPrivType();
1:         }
1: 
1:         // Now stop adding permissions checks.
1:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1: 
/////////////////////////////////////////////////////////////////////////
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1: 				  autoincRowLocation,
0: 				  inMatchingClause()
/////////////////////////////////////////////////////////////////////////
1:             if ( inMatchingClause() )
1:             {
1:                 matchingClause.generateResultSetField( acb, mb );
1:             }
1:             else
1:             {
1:                 resultSet.generate( acb, mb );
1:             }
commit:508a010
/////////////////////////////////////////////////////////////////////////
1:      * @param matchingClause   Non-null if this DML is part of a MATCHED clause of a MERGE statement.
/////////////////////////////////////////////////////////////////////////
1:             MatchingClauseNode matchingClause,
/////////////////////////////////////////////////////////////////////////
1:         super(queryExpression, matchingClause, getStatementType(targetProperties), cm);
commit:661c2e6
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // For the MERGE statement, DEFAULT expressions in the SELECT node
1:         // may have been replaced with generated expressions already.
1:         //
1:         ResultColumnList    tempRCL = resultSet.getResultColumns();
1:         boolean defaultsWereReplaced = false;
1:         for ( int i = 0; i < tempRCL.size(); i++ )
1:         {
1:             ResultColumn    rc = tempRCL.getResultColumn( i+1 );
1:             if ( rc.wasDefaultColumn() ) { defaultsWereReplaced = true; }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 		resultSet = enhanceAndCheckForAutoincrement( resultSet, inOrder, colMap, defaultsWereReplaced );
/////////////////////////////////////////////////////////////////////////
1: 	 * @param defaultsWereReplaced  true if DEFAULT clauses were replaced with generated expressions
1: 	ResultSetNode enhanceAndCheckForAutoincrement
1:         (
1:          ResultSetNode resultSet,
1:          boolean inOrder,
1:          int[] colMap,
1:          boolean    defaultsWereReplaced
1:          )
/////////////////////////////////////////////////////////////////////////
1: 			resultColumnList.forbidOverrides( resultSet.getResultColumns(), defaultsWereReplaced );
commit:57c1b5c
/////////////////////////////////////////////////////////////////////////
1:     private     boolean           hasJDBClimitClause; // true if using JDBC limit/offset escape syntax
/////////////////////////////////////////////////////////////////////////
0:      * @param orderByList The order by list for the source result set, null if no order by list
0: 	 * @param offset The value of a <result offset clause> if present
0: 	 * @param fetchFirst The value of a <fetch first clause> if present
0: 	 * @param hasJDBClimitClause True if the offset/fetchFirst clauses come from JDBC limit/offset escape syntax
/////////////////////////////////////////////////////////////////////////
0:             Object fetchFirst,
0:             Object hasJDBClimitClause)
/////////////////////////////////////////////////////////////////////////
0:         this.hasJDBClimitClause = (hasJDBClimitClause == null) ? false : ((Boolean) hasJDBClimitClause).booleanValue();
/////////////////////////////////////////////////////////////////////////
1:         resultSet.pushOffsetFetchFirst( offset, fetchFirst, hasJDBClimitClause );
commit:d7ee7fa
/////////////////////////////////////////////////////////////////////////
1:         
1:         //
1:         // If the insert stream involves a table function, attempt the bulk-insert
1:         // optimization. See https://issues.apache.org/jira/browse/DERBY-4789
1:         // We perform this check after optimization because the table function may be
1:         // wrapped in a view, which is only expanded at optimization time.
1:         //
1:         HasTableFunctionVisitor tableFunctionVisitor = new HasTableFunctionVisitor();
1:         this.accept( tableFunctionVisitor );
0:         if ( tableFunctionVisitor.hasNode() ) { requestBulkInsert(); }
1:     /**
1:      * Request bulk insert optimization at run time.
1:      */
1:     private void requestBulkInsert()
1:     {
1:         if ( targetProperties == null ) { targetProperties = new Properties(); }
1: 
1:         // Set bulkInsert if insertMode not already set. For the import procedures,
1:         // the insertMode property may be set already
1:         String key = "insertMode";
1:         String value = "bulkInsert";
1: 
1:         if ( targetProperties.getProperty( key ) == null )
1:         { targetProperties.put( key, value ); }
1:     }
1: 
commit:9d08b6a
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Accept the visitor for all visitable children of this node.
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	void acceptChildren(Visitor v)
1: 		throws StandardException
1: 	{
1: 		super.acceptChildren(v);
1: 
1: 		if (targetColumnList != null)
1: 		{
1: 			targetColumnList.accept(v);
1: 		}
1: 	}
1: 
commit:0397292
/////////////////////////////////////////////////////////////////////////
1: 			generateGenerationClauses( resultColumnList, resultSet.getResultSetNumber(), false, acb, mb );
commit:97a8b1c
/////////////////////////////////////////////////////////////////////////
0: 			resultColumnList.forbidOverrides(resultSet.getResultColumns());
commit:c533cd2
/////////////////////////////////////////////////////////////////////////
1: 
0:             // don't allow overriding of generation clauses
0:             forbidGenerationOverrides( targetColumnList, false, null );
/////////////////////////////////////////////////////////////////////////
0:                 targetTableDescriptor, targetVTI );
/////////////////////////////////////////////////////////////////////////
1: 
1:             /* bind all generation clauses for generated columns */
1:             parseAndBindGenerationClauses
1:                 ( dataDictionary, targetTableDescriptor, sourceRCL, resultColumnList, false, null );
1:             
1: 			/* Get and bind all constraints on the table */
/////////////////////////////////////////////////////////////////////////
0:             FromVTI targetVTI)
/////////////////////////////////////////////////////////////////////////
0: 						targetTableDescriptor,targetVTI);
/////////////////////////////////////////////////////////////////////////
1: 	 *   ResultSetFactory.getInsertResultSet(resultSet.generate(ps), generationClausesResult, checkConstrainResult, this )
/////////////////////////////////////////////////////////////////////////
1: 			// arg 2 generate code to evaluate generation clauses
0: 			generateGenerationClauses( resultColumnList, resultSet.getResultSetNumber(), acb, mb );
1: 
1: 			// arg 3 generate code to evaluate CHECK CONSTRAINTS
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getInsertResultSet", ClassName.ResultSet, 3);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1:     public      boolean             hasDeferrableCheckConstraints;
/////////////////////////////////////////////////////////////////////////
1:             boolean[] hasDCC = new boolean[]{false /* a priori*/ };
1: 
1:             checkConstraints = bindConstraints(
1:                     dataDictionary,
1:                     getOptimizerFactory(),
1:                     targetTableDescriptor,
1:                     null,
1:                     sourceRCL,
1:                     (int[]) null,
1:                     (FormatableBitSet) null,
1:                     true, // we always include triggers in core language
1:                     hasDCC);
1: 
1:             hasDeferrableCheckConstraints = hasDCC[0];
1: 
/////////////////////////////////////////////////////////////////////////
1:                   hasDeferrableCheckConstraints,
/////////////////////////////////////////////////////////////////////////
1:             // arg 5, 6 table name
1:             if (targetTableName.getSchemaName() == null) {
1:                 mb.pushNull("java.lang.String");
1:             } else {
1:                 mb.push(targetTableName.getSchemaName());
1:             }
1: 
1:             mb.push(targetTableName.getTableName());
1: 
1:                     "getInsertResultSet", ClassName.ResultSet, 6);
commit:f167762
/////////////////////////////////////////////////////////////////////////
commit:b4cda60
/////////////////////////////////////////////////////////////////////////
1:         resultSet.pushQueryExpressionSuffix();
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private     ResultColumnList    targetColumnList;
1:     private     boolean             deferred;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 int position = targetColumnList.elementAt(index).
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     static int getStatementType(Properties targetProperties)
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.sql.StatementType;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
1: import org.apache.derby.iapi.util.StringUtil;
1: import org.apache.derby.impl.sql.execute.FKInfo;
1: import org.apache.derby.vti.DeferModification;
/////////////////////////////////////////////////////////////////////////
0:             boolean             deferred;
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for an InsertNode.
1:      * @param targetName         The name of the table/VTI to insert into
1:      * @param insertColumns      A ResultColumnList with the names of the
1:      * @param queryExpression    The query expression that will generate
1:      *                           the rows to insert into the given table
1:      * @param targetProperties   The properties specified on the target table
1:      * @param orderByList        The order by list for the source result set,
1:      *                           null if no order by list
1:      * @param offset             The value of a <result offset clause> if
1:      *                           present
1:      * @param fetchFirst         The value of a <fetch first clause> if present
1:      * @param hasJDBClimitClause True if the offset/fetchFirst clauses come
1:      *                           from JDBC limit/offset escape syntax
1:      * @param cm                 The context manager
1:     InsertNode(
1:             QueryTreeNode    targetName,
1:             ResultColumnList insertColumns,
1:             ResultSetNode    queryExpression,
1:             Properties       targetProperties,
1:             OrderByList      orderByList,
1:             ValueNode        offset,
1:             ValueNode        fetchFirst,
1:             boolean          hasJDBClimitClause,
1:             ContextManager   cm)
0:         super(queryExpression, getStatementType(targetProperties), cm);
0:         setNodeType(C_NodeTypes.INSERT_NODE);
1:         setTarget(targetName);
1:         targetColumnList = insertColumns;
1:         this.targetProperties = targetProperties;
1:         this.orderByList = orderByList;
1:         this.offset = offset;
1:         this.fetchFirst = fetchFirst;
1:         this.hasJDBClimitClause = hasJDBClimitClause;
/////////////////////////////////////////////////////////////////////////
1:     String statementToString()
/////////////////////////////////////////////////////////////////////////
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList = new FromList(
1:                 getOptimizerFactory().doJoinOrderOptimization(),
1:                 getContextManager());
/////////////////////////////////////////////////////////////////////////
1:             resultSet = new NormalizeResultSetNode(
1:                 resultSet, resultColumnList, null, false, getContextManager());
/////////////////////////////////////////////////////////////////////////
0:                                                 getOptimizerFactory(),
/////////////////////////////////////////////////////////////////////////
1:     public ConstantAction makeConstantAction() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:     boolean[] getIndexedCols() throws StandardException
/////////////////////////////////////////////////////////////////////////
1:                     ColumnDescriptor cd = cdl.get(i);
commit:4d044a3
/////////////////////////////////////////////////////////////////////////
1:             if (offset != null) {
1:                 printLabel(depth, "offset:");
1:                 offset.treePrint(depth + 1);
1:             }
1: 
1:             if (fetchFirst != null) {
1:                 printLabel(depth, "fetch first/next:");
1:                 fetchFirst.treePrint(depth + 1);
1:             }
1: 
commit:108305b
/////////////////////////////////////////////////////////////////////////
1:     private     ValueNode           offset;
1:     private     ValueNode           fetchFirst;
1: 
/////////////////////////////////////////////////////////////////////////
0:             Object orderByList,
0:             Object offset,
0:             Object fetchFirst)
/////////////////////////////////////////////////////////////////////////
0:         this.offset = (ValueNode)offset;
0:         this.fetchFirst = (ValueNode)fetchFirst;
/////////////////////////////////////////////////////////////////////////
1:         bindOffsetFetch(offset, fetchFirst);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
0:         resultSet.pushOffsetFetchFirst(offset, fetchFirst);
1: 
commit:2060c4a
/////////////////////////////////////////////////////////////////////////
1: 	private     OrderByList         orderByList;
/////////////////////////////////////////////////////////////////////////
0:      * @param orderByList The order by list for the source result set, null if
0: 	 *			no order by list
0: 			Object targetProperties,
0:             Object orderByList)
/////////////////////////////////////////////////////////////////////////
0: 		this.orderByList = (OrderByList) orderByList;
/////////////////////////////////////////////////////////////////////////
1: 			if (orderByList != null) {
1: 				printLabel(depth, "orderByList: ");
1: 				orderByList.treePrint(depth + 1);
1: 			}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		// Bind the ORDER BY columns
1: 		if (orderByList != null)
1: 		{
1: 			orderByList.pullUpOrderByColumns(resultSet);
1: 
1: 			// The select list may have new columns now, make sure to bind
1: 			// those.
1: 			super.bindExpressions();
1: 
1: 			orderByList.bindOrderByColumns(resultSet);
1: 		}
1: 
/////////////////////////////////////////////////////////////////////////
1:      * {@inheritDoc}
1:      * <p>
1:      * Remove any duplicate ORDER BY columns and push an ORDER BY if present
1:      * down to the source result set, before calling super.optimizeStatement.
1:      * </p>
1: 	 */
1: 
1: 	public void optimizeStatement() throws StandardException
1: 	{
1: 		// Push the order by list down to the ResultSet
1: 		if (orderByList != null)
1: 		{
1: 			// If we have more than 1 ORDERBY columns, we may be able to
1: 			// remove duplicate columns, e.g., "ORDER BY 1, 1, 2".
1: 			if (orderByList.size() > 1)
1: 			{
1: 				orderByList.removeDupColumns();
1: 			}
1: 
1: 			resultSet.pushOrderByList(orderByList);
1: 			orderByList = null;
1: 		}
1: 		super.optimizeStatement();
1: 	}
1: 
1: 	/**
commit:c341dc4
/////////////////////////////////////////////////////////////////////////
1:         /* Replace any DEFAULTs with the associated tree, or flag DEFAULTs if
1:          * not allowed (inside top level set operator nodes). Subqueries are
1:          * checked for illegal DEFAULTs elsewhere.
1:          */
1:         boolean isTableConstructor =
1:             (resultSet instanceof UnionNode &&
1:              ((UnionNode)resultSet).tableConstructor()) ||
1:             resultSet instanceof RowResultSetNode;
1: 
1:         resultSet.replaceOrForbidDefaults(targetTableDescriptor,
1:                                           targetColumnList,
1:                                           isTableConstructor);
commit:47611b1
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:cd66ed9
/////////////////////////////////////////////////////////////////////////
0: 	 * @param targetTableDescriptor    Table Descriptor for target
commit:0958c84
/////////////////////////////////////////////////////////////////////////
0: 		enhanceAndCheckForAutoincrement(resultSet, inOrder,
0: 				numTableColumns, colMap, dataDictionary,
0: 				targetTableDescriptor, targetVTI);
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Process ResultSet column lists for projection and autoincrement.
1: 	 *
1: 	 * This method recursively descends the result set node tree. When
1: 	 * it finds a simple result set, it processes any autoincrement
1: 	 * columns in that rs by calling checkAutoIncrement. When it finds
1: 	 * a compound result set, like a Union or a PRN, it recursively
1: 	 * descends to the child(ren) nodes. Union nodes can arise due to
1: 	 * multi-rows in VALUES clause), PRN nodes can arise when the set
1: 	 * of columns being inserted is a subset of the set of columns in 
1: 	 * the table.
1: 	 *
1: 	 * In addition to checking for autoincrement columns in the result set,
1: 	 * we may need to enhance and re-order the column list to match the
1: 	 * column list of the table we are inserting into. This work is handled
1: 	 * by ResultsetNode.enhanceRCLForInsert.
1: 	 *
1: 	 * Note that, at the leaf level, we need to enhance the RCL first, then
1: 	 * check for autoincrement columns. At the non-leaf levels, we have
1: 	 * to enhance the RCL, but we don't have to check for autoincrement
1: 	 * columns, since they only occur at the leaf level.
1: 	 *
1: 	 * This way, all ColumnDescriptor of all rows will be set properly.
1: 	 *
1: 	 * @param resultSet			current node in the result set tree
1: 	 * @param inOrder			FALSE if the column list needs reordering
0: 	 * @param numTableColumns   # of columns in target RCL
1: 	 * @param colMap            correspondence between RCLs
0: 	 * @param dataDictionary    DataDictionary to use
0: 	 * @param targetTD          Table Descriptor for target
0: 	 * @param targetVTI         Target description if it is a VTI
1: 	 *
1: 	 * @exception StandardException Thrown on error
1: 	 */
0: 	private void enhanceAndCheckForAutoincrement(ResultSetNode resultSet, 
0: 			boolean inOrder, int numTableColumns, int []colMap, 
0: 			DataDictionary dataDictionary,
0: 			TableDescriptor targetTableDescriptor,
0: 			FromVTI targetVTI)
1: 		throws StandardException
1: 	{
1: 		/*
1: 		 * Some implementation notes:
1: 		 * 
1: 		 * colmap[x] == y means that column x in the target table
1: 		 * maps to column y in the source result set.
1: 		 * colmap[x] == -1 means that column x in the target table
1: 		 * maps to its default value.
1: 		 * both colmap indexes and values are 0-based.
1: 		 *
1: 		 * if the list is in order and complete, we don't have to change
1: 		 * the tree. If it is not, then we call RSN.enhanceRCLForInsert() 
1: 		 * which will reorder ("enhance") the source RCL within the same RSN)
1: 		 *
1: 		 * one thing we do know is that all of the resultsets underneath
1: 		 * us have their resultColumn names filled in with the names of
1: 		 * the target table columns.  That makes generating the mapping
1: 		 * "easier" -- we simply generate the names of the target table columns
1: 		 * that are included.  For the missing columns, we generate default
1: 		 * value expressions.
1: 		 */
1: 
0: 		if (resultSet instanceof SingleChildResultSetNode)
1: 		{
0: 			enhanceAndCheckForAutoincrement(
0: 				((SingleChildResultSetNode)resultSet).getChildResult(),
0: 				inOrder, numTableColumns, colMap, dataDictionary,
0: 				targetTableDescriptor, targetVTI);
0: 			if (! inOrder || resultSet.resultColumns.size() < numTableColumns)
0: 				resultSet.enhanceRCLForInsert(
0: 						numTableColumns, colMap, dataDictionary,
0: 						targetTableDescriptor, targetVTI);
1: 		}
0: 		else if (resultSet instanceof UnionNode)
1: 		{
0: 			enhanceAndCheckForAutoincrement(
0: 				((TableOperatorNode)resultSet).getLeftResultSet(),
0: 				inOrder, numTableColumns, colMap, dataDictionary,
0: 				targetTableDescriptor, targetVTI);
0: 			enhanceAndCheckForAutoincrement(
0: 				((TableOperatorNode)resultSet).getRightResultSet(),
0: 				inOrder, numTableColumns, colMap, dataDictionary,
0: 				targetTableDescriptor, targetVTI);
0: 			if (! inOrder || resultSet.resultColumns.size() < numTableColumns)
0: 				resultSet.enhanceRCLForInsert(
0: 						numTableColumns, colMap, dataDictionary,
0: 						targetTableDescriptor, targetVTI);
1: 		}
1: 		else
1: 		{
0: 			if (! inOrder || resultSet.resultColumns.size() < numTableColumns)
0: 				resultSet.enhanceRCLForInsert(
0: 						numTableColumns, colMap, dataDictionary,
0: 						targetTableDescriptor, targetVTI);
0: 			resultColumnList.checkAutoincrement(resultSet.getResultColumns());
1: 		}
1: 	}
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:959fef2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.execute.ExecRowBuilder;
/////////////////////////////////////////////////////////////////////////
1: 
1:         bulkInsert = true;
/////////////////////////////////////////////////////////////////////////
1:             // arg 4 row template used by bulk insert
1:             if (bulkInsert) {
1:                 ColumnDescriptorList cdl =
1:                         targetTableDescriptor.getColumnDescriptorList();
1:                 ExecRowBuilder builder =
1:                         new ExecRowBuilder(cdl.size(), false);
1:                 for (int i = 0; i < cdl.size(); i++) {
0:                     ColumnDescriptor cd = (ColumnDescriptor) cdl.get(i);
1:                     builder.setColumn(i + 1, cd.getType());
1:                 }
1:                 mb.push(acb.addItem(builder));
1:             } else {
1:                 mb.push(-1);
1:             }
1: 
1:             mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
0:                     "getInsertResultSet", ClassName.ResultSet, 4);
commit:d11ed08
/////////////////////////////////////////////////////////////////////////
1: 		// createResultSet() will only be called once.
1: 		generateCodeForTemporaryTable(acb);
commit:7af858d
/////////////////////////////////////////////////////////////////////////
0: 			(ResultSetNode) getNodeFactory().getNode(
commit:a8db665
/////////////////////////////////////////////////////////////////////////
0: 		resultSet = enhanceAndCheckForAutoincrement(resultSet, inOrder, colMap);
/////////////////////////////////////////////////////////////////////////
1: 	 * @return a node representing the source for the insert
0: 	ResultSetNode enhanceAndCheckForAutoincrement(
0: 			ResultSetNode resultSet, boolean inOrder, int[] colMap)
/////////////////////////////////////////////////////////////////////////
1: 		resultSet = resultSet.enhanceRCLForInsert(this, inOrder, colMap);
1: 
1: 		// Forbid overrides for generated columns and identity columns that
1: 		// are defined as GENERATED ALWAYS.
1: 		if ((resultSet instanceof UnionNode) &&
1: 				((UnionNode) resultSet).tableConstructor()) {
1: 			// If this is a multi-row table constructor, we are not really
1: 			// interested in the result column list of the top-level UnionNode.
1: 			// The interesting RCLs are those of the RowResultSetNode children
1: 			// of the UnionNode, and they have already been checked from
1: 			// UnionNode.enhanceRCLForInsert(). Since the RCL of the UnionNode
1: 			// doesn't tell whether or not DEFAULT is specified at the leaf
1: 			// level, we need to skip it here to avoid false positives.
1: 		} else {
1: 
1: 		return resultSet;
commit:ccee531
/////////////////////////////////////////////////////////////////////////
1: 		// If the DML is on the temporary table, generate the code to
1: 		// mark temporary table as modified in the current UOW. After
1: 		// DERBY-827 this must be done in execute() since
0: 		// fillResultSet() will only be called once.
0: 		generateCodeForTemporaryTable(acb, acb.getExecuteMethod());
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:063dd55
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-5614: See if the target is a global temporary table (GTT),
1:         // in which case we don't support bulk insert.
1:         if ( tableFunctionVisitor.hasNode() &&
1:                 !isSessionSchema(targetTableDescriptor.getSchemaDescriptor())) {
1:             requestBulkInsert();
1:         }
1:     }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:860148c
/////////////////////////////////////////////////////////////////////////
0: 			C_NodeTypes.NORMALIZE_RESULT_SET_NODE, resultSet,
0: 			resultColumnList, null, Boolean.FALSE,
commit:bfc59e5
/////////////////////////////////////////////////////////////////////////
1:             
0: 			resultSet = 
0: 			(NormalizeResultSetNode) getNodeFactory().getNode(
0: 			C_NodeTypes.NORMALIZE_RESULT_SET_NODE,
0: 			resultSet, null, Boolean.FALSE,
0: 			getContextManager());
commit:318307e
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:0dfa31c
/////////////////////////////////////////////////////////////////////////
0: 			resultSet = resultSet.genNormalizeResultSetNode(false);
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	public void bindStatement() throws StandardException
/////////////////////////////////////////////////////////////////////////
commit:2d2e717
/////////////////////////////////////////////////////////////////////////
0: 			if (isPrivilegeCollectionRequired())
1: 			{
0: 				getCompilerContext().pushCurrentPrivType(getPrivType());
0: 				getCompilerContext().addRequiredTablePriv(targetTableDescriptor);
1: 				getCompilerContext().popCurrentPrivType();				
1: 			}
1: 
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getInsertResultSet", ClassName.ResultSet, 2);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getInsertVTIResultSet", ClassName.ResultSet, 2);
commit:7736829
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.InsertNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
1: import org.apache.derby.iapi.reference.ClassName;
1: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.IndexLister;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.StatementType;
1: 
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: 
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.vti.DeferModification;
1: 
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.util.StringUtil;
1: 
0: import org.apache.derby.catalog.UUID;
1: 
0: import org.apache.derby.impl.sql.execute.FKInfo;
1: 
0: import java.util.Properties;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
1: 
1: /**
1:  * An InsertNode is the top node in a query tree for an
1:  * insert statement.
1:  * <p>
1:  * After parsing, the node contains
1:  *   targetTableName: the target table for the insert
1:  *   collist: a list of column names, if specified
1:  *   queryexpr: the expression being inserted, either
1:  *				a values clause or a select form; both
1:  *			    of these are represented via the SelectNode,
1:  *				potentially with a TableOperatorNode such as
1:  *				UnionNode above it.
1:  * <p>
1:  * After binding, the node has had the target table's
1:  * descriptor located and inserted, and the queryexpr
1:  * and collist have been massaged so that they are identical
1:  * to the table layout.  This involves adding any default
1:  * values for missing columns, and reordering the columns
1:  * to match the table's ordering of them.
1:  * <p>
1:  * After optimizing, ...
1:  */
0: public final class InsertNode extends DMLModStatementNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public		ResultColumnList	targetColumnList;
0: 	public 		boolean				deferred;
1: 	public		ValueNode			checkConstraints;
1: 	public		Properties			targetProperties;
1: 	public		FKInfo				fkInfo;
1: 	protected	boolean				bulkInsert;
1: 	private 	boolean				bulkInsertReplace;
1: 	
0: 	protected   RowLocation[] 		autoincRowLocation;
1: 	/**
0: 	 * Initializer for an InsertNode.
1: 	 *
0: 	 * @param targetName	The name of the table/VTI to insert into
0: 	 * @param insertColumns	A ResultColumnList with the names of the
1: 	 *			columns to insert into.  May be null if the
1: 	 *			user did not specify the columns - in this
1: 	 *			case, the binding phase will have to figure
1: 	 *			it out.
0: 	 * @param queryExpresssion	The query expression that will generate
0: 	 *				the rows to insert into the given table
0: 	 * @param targetProperties	The properties specified on the target table
1: 	 */
1: 
0: 	public void init(
0: 			Object targetName,
0: 			Object insertColumns,
0: 			Object queryExpression,
0: 			Object targetProperties)
1: 	{
1: 		/* statementType gets set in super() before we've validated
1: 		 * any properties, so we've kludged the code to get the
1: 		 * right statementType for a bulk insert replace.
1: 		 */
0: 		super.init(
0: 				queryExpression,
0: 				ReuseFactory.getInteger(getStatementType(
0: 												(Properties) targetProperties))
0: 				);
0: 		setTarget((QueryTreeNode) targetName);
0: 		targetColumnList = (ResultColumnList) insertColumns;
0: 		this.targetProperties = (Properties) targetProperties;
1: 
1: 		/* Remember that the query expression is the source to an INSERT */
1: 		getResultSetNode().setInsertSource();
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1:             try {
1:                 return ( (targetTableName!=null) ? targetTableName : targetVTI.getTableName() ).toString() + "\n"
1:                     + targetProperties + "\n"
1:                     + super.toString();
1:             } catch (org.apache.derby.iapi.error.StandardException e) {
1:                 return "tableName: <not_known>\n"
1:                     + targetProperties + "\n"
1:                     + super.toString();
1:             }
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
0: 	public String statementToString()
1: 	{
1: 		return "INSERT";
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (targetTableName != null)
1: 			{
1: 				printLabel(depth, "targetTableName: ");
1: 				targetTableName.treePrint(depth + 1);
1: 			}
1: 
1: 			if (targetColumnList != null)
1: 			{
1: 				printLabel(depth, "targetColumnList: ");
1: 				targetColumnList.treePrint(depth + 1);
1: 			}
1: 
1: 			/* RESOLVE - need to print out targetTableDescriptor */
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Bind this InsertNode.  This means looking up tables and columns and
1: 	 * getting their types, and figuring out the result types of all
1: 	 * expressions, as well as doing view resolution, permissions checking,
1: 	 * etc.
1: 	 * <p>
1: 	 * Binding an insert will also massage the tree so that
1: 	 * the collist and select column order/number are the
1: 	 * same as the layout of the table in the store. 
1: 	 *
0: 	 * @return	The bound query tree
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public QueryTreeNode bind() throws StandardException
1: 	{
0: 		FromList	fromList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
1: 
1: 		/* If any underlying ResultSetNode is a SelectNode, then we
1: 		 * need to do a full bind(), including the expressions
1: 		 * (since the fromList may include a FromSubquery).
1: 		 */
1:         DataDictionary dataDictionary = getDataDictionary();
1: 		super.bindResultSetsWithTables(dataDictionary);
1: 
1: 		/*
1: 		** Get the TableDescriptor for the table we are inserting into
1: 		*/
1: 		verifyTargetTable();
1: 
1: 		// Check the validity of the targetProperties, if they exist
1: 		if (targetProperties != null)
1: 		{
1: 			verifyTargetProperties(dataDictionary);
1: 		}
1: 
1: 		/*
1: 		** Get the resultColumnList representing the columns in the base
0: 		** table or VTI.
1: 		*/
1: 		getResultColumnList();
1: 
1: 		/* If we have a target column list, then it must have the same # of
1: 		 * entries as the result set's RCL.
1: 		 */
1: 		if (targetColumnList != null)
1: 		{
1: 			/* Bind the target column list */
1: 			if (targetTableDescriptor != null)
1: 			{
1: 				targetColumnList.bindResultColumnsByName(targetTableDescriptor,
1: 														this);
1: 			}
1: 			else
1: 			{
1: 				targetColumnList.bindResultColumnsByName(targetVTI.getResultColumns(), targetVTI,
1: 														this);
1: 			}
1: 
1: 		}
1: 
1: 		/* Verify that all underlying ResultSets reclaimed their FromList */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(fromList.size() == 0,
1: 				"fromList.size() is expected to be 0, not " + 
1: 				fromList.size() +
1: 				" on return from RS.bindExpressions()");
1: 		}
1: 
0: 		/* Replace any DEFAULTs with the associated tree */
0: 		resultSet.replaceDefaults(targetTableDescriptor, targetColumnList);
1: 
1: 		/* Bind the expressions now that the result columns are bound 
1: 		 * NOTE: This will be the 2nd time for those underlying ResultSets
1: 		 * that have tables (no harm done), but it is necessary for those
1: 		 * that do not have tables.  It's too hard/not work the effort to
1: 		 * avoid the redundancy.
1: 		 */
1: 		super.bindExpressions();
1: 
1: 		/*
1: 		** If the result set is a union, it could be a table constructor.
1: 		** Bind any nulls in the result columns of the table constructor
1: 		** to the types of the table being inserted into.
1: 		**
1: 		** The types of ? parameters in row constructors and table constructors
1: 		** in an INSERT statement come from the result columns.
1: 		**
1: 		** If there is a target column list, use that instead of the result
1: 		** columns for the whole table, since the columns in the result set
1: 		** correspond to the target column list.
1: 		*/
1: 		if (targetColumnList != null)
1: 		{
0: 			if (resultSet.getResultColumns().size() > targetColumnList.size())
1: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
1: 			resultSet.bindUntypedNullsToResultColumns(targetColumnList);
1: 			resultSet.setTableConstructorTypes(targetColumnList);
1: 		}
1: 		else
1: 		{
0: 			if (resultSet.getResultColumns().size() > resultColumnList.size())
1: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
1: 			resultSet.bindUntypedNullsToResultColumns(resultColumnList);
1: 			resultSet.setTableConstructorTypes(resultColumnList);
1: 		}
1: 
1: 		/* Bind the columns of the result set to their expressions */
1: 		resultSet.bindResultColumns(fromList);
1: 
0: 		/* DB2 doesn't allow different number of target columns and result columns.
0: 		 * RESOLVE: Enforce the limit only in DB2 mode for now. Too many tests need to be
0: 		 * migrated to DB2 mode first.  Only now we would have expanded STAR (*) to all columns.
1: 		 */
0: 		int resCols = resultSet.getResultColumns().size();
1: 		DataDictionary dd = getDataDictionary();
1: 		if (targetColumnList != null)
1: 		{
1: 			if (targetColumnList.size() != resCols)
1: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
1: 		}
1: 		else 
1: 		{
1: 			if (targetTableDescriptor != null &&
1: 						targetTableDescriptor.getNumberOfColumns() != resCols)
1: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
1: 		}
1: 
1: 		/* See if the ResultSet's RCL needs to be ordered to match the target
1: 		 * list, or "enhanced" to accommodate defaults.  It can only need to
1: 		 * be ordered if there is a target column list.  It needs to be
1: 		 * enhanced if there are fewer source columns than there are columns
1: 		 * in the table.
1: 		 */
1: 		boolean inOrder = true;
1: 		int numTableColumns = resultColumnList.size();
1: 
1: 		/* colMap[] will be the size of the target list, which could be larger
1: 		 * than the current size of the source list.  In that case, the source
1: 		 * list will be "enhanced" to include defaults.
1: 		 */
1: 		int[] colMap = new int[numTableColumns];
1: 
1: 		// set the fields to an unused value
1: 		for (int i = 0; i < colMap.length; i++) 
1: 		{
1: 			colMap[i] = -1;
1: 		}
1: 
1: 		/* Create the source/target list mapping */
1: 		if (targetColumnList != null)
1: 		{
1: 			/*
1: 			** There is a target column list, so the result columns might
1: 			** need to be ordered.  Step through the target column list
1: 			** and remember the position in the target table of each column.
1: 			** Remember if any of the columns are out of order.
1: 			*/
1: 			int targetSize = targetColumnList.size();
1: 			for (int index = 0; index < targetSize; index++)
1: 			{
0: 				int position =
0: 					((ResultColumn) (targetColumnList.elementAt(index))).
0: 												columnDescriptor.getPosition();
1: 
1: 				if (index != position-1)
1: 				{
1: 					inOrder = false;
1: 				}
1: 
1: 				// position is 1-base; colMap indexes and entries are 0-based.
1: 				colMap[position-1] = index;
1: 			}
1: 		}
1: 		else
1: 		{
1: 			/*
1: 			** There is no target column list, so the result columns in the
1: 			** source are presumed to be in the same order as the target
1: 			** table.
1: 			*/
1: 			for (int position = 0;
0: 				position < resultSet.getResultColumns().size();
1: 				position++)
1: 			{
1: 				colMap[position] = position;
1: 			}
1: 		}
1: 
0: 		// colmap[x] == y means that column x in the target table
0: 		// maps to column y in the source result set.
0: 		// colmap[x] == -1 means that column x in the target table
0: 		// maps to its default value.
0: 		// both colmap indexes and values are 0-based.
1: 
0: 		/* if the list is in order and complete, we don't have to change
0: 		 * the tree. If it is not, then we call RSN.enhanceRCLForInsert() 
0: 		 * which will either
0: 		 * (reorder and/or "enhance" the source RCL within the same RSN) or
0: 		 * (generate and return a PRN with a new reordered/enhanced RCL above
0: 		 * the existing RSN).  This way, RSN's that understand how to do projections
0: 		 * can avoid the additional PRN while those that do not will get one.
1: 		 */
0: 		/* NOTE - javascope gives confusing branch coverage info here.  By
0: 		 * breaking apart the following if condition, I have verified that
0: 		 * we test all cases.  (Jerry 7/17/97)
1: 		 */
0: 		if (! inOrder || resultSet.resultColumns.size() < numTableColumns)
1: 		{
0: 			// one thing we do know is that all of the resultsets underneath
0: 			// us have their resultColumn names filled in with the names of
0: 			// the target table columns.  That makes generating the mapping
0: 			// "easier" -- we simply generate the names of the target table columns
0: 			// that are included.  For the missing columns, we generate default
0: 			// value expressions.
1: 
0: 			resultSet = resultSet.enhanceRCLForInsert(numTableColumns, colMap, 
0: 													  dataDictionary,
0: 													  targetTableDescriptor, targetVTI);
1: 		}
1: 
0: 		if (resultSet instanceof UnionNode)
1: 		{
0: 			// If we are inserting a number of rows in VALUES clause, we need to
0: 			// examine each row for 'autoincrement'.
0: 			resultColumnList.checkAutoincrementUnion(resultSet);
1: 		}
0: 		else resultColumnList.checkAutoincrement(resultSet.getResultColumns());
1: 		resultColumnList.checkStorableExpressions(resultSet.getResultColumns());
1: 		/* Insert a NormalizeResultSetNode above the source if the source
1: 		 * and target column types and lengths do not match.
1:  		 */
1: 		if (! resultColumnList.columnTypesAndLengthsMatch(
1: 												resultSet.getResultColumns()))
1: 		{
0: 			resultSet = resultSet.genNormalizeResultSetNode(resultSet, false);
0: 			resultColumnList.copyTypesAndLengthsToSource(resultSet.getResultColumns());
1: 		}
1: 
1: 		if (targetTableDescriptor != null)
1: 		{
0: 			/* Get and bind all constraints on the table */
1: 			ResultColumnList sourceRCL = resultSet.getResultColumns();
1: 			sourceRCL.copyResultColumnNames(resultColumnList);
0: 			checkConstraints = bindConstraints(dataDictionary,
0: 												getNodeFactory(),
0: 												targetTableDescriptor,
1: 												null,
0: 												sourceRCL,
0: 												(int[]) null,
0: 												(FormatableBitSet) null,
1: 												false,
0: 											    true);  /* we always include
0: 														 * triggers in core language */
1: 	
1: 			/* Do we need to do a deferred mode insert */
1: 			/* 
1: 		 	** Deferred if:
1: 			**	If the target table is also a source table
1: 			**	Self-referencing foreign key constraint 
1: 			**	trigger
1: 			*/
1: 			if (resultSet.referencesTarget(
1: 									targetTableDescriptor.getName(), true) ||
1: 				 requiresDeferredProcessing())
1: 			{
1: 				deferred = true;
1: 
1: 				/* Disallow bulk insert replace when target table
1: 				 * is also a source table.
1: 				 */
1: 				if (bulkInsertReplace &&
1: 					resultSet.referencesTarget(
1: 									targetTableDescriptor.getName(), true))
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_INVALID_BULK_INSERT_REPLACE, 
1: 									targetTableDescriptor.getQualifiedName());
1: 				}
1: 			}
1: 
1: 			/* Get the list of indexes on the table being inserted into */
1: 			getAffectedIndexes(targetTableDescriptor);
1: 			TransactionController tc = 
1: 				getLanguageConnectionContext().getTransactionCompile();
1: 
1: 			autoincRowLocation = 
1: 				dd.computeAutoincRowLocations(tc, targetTableDescriptor);
1: 		}
1: 		else
1: 		{
1:             deferred = VTIDeferModPolicy.deferIt( DeferModification.INSERT_STATEMENT,
1:                                                   targetVTI,
1:                                                   null,
1:                                                   resultSet);
1: 		}
1:         
0: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
1: 	 *
1: 	 * @return	true if references SESSION schema tables, else false
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean referencesSessionSchema()
1: 		throws StandardException
1: 	{
1: 		boolean returnValue = false;
1: 
1: 		//If this node references a SESSION schema table, then return true. 
1: 		if (targetTableDescriptor != null)
1: 			returnValue = isSessionSchema(targetTableDescriptor.getSchemaDescriptor());
1: 
1: 		if (returnValue == false)
1: 			returnValue = resultSet.referencesSessionSchema();
1: 
1: 		return returnValue;
1: 	}
1: 
1: 	/**
1: 	 * Verify that the target properties that we are interested in
1: 	 * all hold valid values.
1: 	 * NOTE: Any target property which is valid but cannot be supported
1: 	 * due to a target database, etc. will be turned off quietly.
1: 	 *
1: 	 * @param dd	The DataDictionary
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private void verifyTargetProperties(DataDictionary dd)
1: 		throws StandardException
1: 	{
1: 		// The only property that we're currently interested in is insertMode
1: 		String insertMode = targetProperties.getProperty("insertMode");
1: 		if (insertMode != null)
1: 		{
1: 			String upperValue = StringUtil.SQLToUpperCase(insertMode);
1: 			if (! upperValue.equals("BULKINSERT") &&
1: 				! upperValue.equals("REPLACE"))
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_INVALID_INSERT_MODE, 
1: 								insertMode,
1: 								targetTableName);
1: 			}
1: 			else
1: 			{
1: 				/* Turn off bulkInsert if it is on and we can't support it. */
1: 				if (! verifyBulkInsert(dd, upperValue))
1: 				{
1: 					targetProperties.remove("insertMode");
1: 				}
1: 				else
1: 				{
1: 					/* Now we know we're doing bulk insert */
1: 					bulkInsert = true;
1: 
1: 					if (upperValue.equals("REPLACE"))
1: 					{
1: 						bulkInsertReplace = true;
1: 					}
1: 
1: 					// Validate the bulkFetch property if specified
1: 					String bulkFetchStr = targetProperties.getProperty("bulkFetch");
1: 					if (bulkFetchStr != null)
1: 					{
1: 						int bulkFetch = getIntProperty(bulkFetchStr, "bulkFetch");
1: 
1: 						// verify that the specified value is valid
1: 						if (bulkFetch <= 0)
1: 						{
1: 							throw StandardException.newException(SQLState.LANG_INVALID_BULK_FETCH_VALUE,
1: 									String.valueOf(bulkFetch));
1: 						}
1: 					}
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Do the bind time checks to see if bulkInsert is allowed on
1: 	 * this table.  bulkInsert is disallowed at bind time for:
1: 	 *		o  target databases
1: 	 *		o  (tables with triggers?)
1: 	 * (It is disallowed at execution time if the table has at
1: 	 * least 1 row in it or if it is a deferred mode insert.)
1: 	 *
1: 	 * @param dd	The DataDictionary
1: 	 * @param mode	The insert mode
1: 	 *
1: 	 * @return Whether or not bulkInsert is allowed.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private boolean verifyBulkInsert(DataDictionary dd, String mode)
1: 		throws StandardException
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Compile constants that Execution will use
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
1: 	{
1: 
1: 		/* Different constant actions for base tables and updatable VTIs */
1: 		if (targetTableDescriptor != null)
1: 		{
1: 			// Base table
1: 
1: 			long heapConglomId = targetTableDescriptor.getHeapConglomerateId();
1: 			TransactionController tc = 
1: 				getLanguageConnectionContext().getTransactionCompile();
1: 			int numIndexes = (targetTableDescriptor != null) ?
1: 								indexConglomerateNumbers.length : 0;
1: 			StaticCompiledOpenConglomInfo[] indexSCOCIs = 
1: 				new StaticCompiledOpenConglomInfo[numIndexes];
1: 
1: 			for (int index = 0; index < numIndexes; index++)
1: 			{
1: 				indexSCOCIs[index] = tc.getStaticCompiledConglomInfo(indexConglomerateNumbers[index]);
1: 			}
1: 
1: 			/*
1: 			** If we're doing bulk insert, do table locking regardless of
1: 			** what the optimizer decided.  This is because bulk insert is
1: 			** generally done with a large number of rows into an empty table.
1: 			** We also do table locking if the table's lock granularity is
1: 			** set to table.
1: 			*/
1: 			if (bulkInsert ||
1: 				targetTableDescriptor.getLockGranularity() == TableDescriptor.TABLE_LOCK_GRANULARITY)
1: 			{
1: 				lockMode = TransactionController.MODE_TABLE;
1: 			}
1: 
1: 			return	getGenericConstantActionFactory().getInsertConstantAction
1: 				( targetTableDescriptor,
1: 				  heapConglomId,
1: 				  tc.getStaticCompiledConglomInfo(heapConglomId),
1: 				  indicesToMaintain,
1: 				  indexConglomerateNumbers,
1: 				  indexSCOCIs,
1: 				  indexNames,
1: 				  deferred,
1: 				  false,
1: 				  targetTableDescriptor.getUUID(),
1: 				  lockMode,
1: 				  null, null, 
1: 				  targetProperties,
1: 				  getFKInfo(),
1: 				  getTriggerInfo(),
1: 				  resultColumnList.getStreamStorableColIds(targetTableDescriptor.getNumberOfColumns()),
1: 				  getIndexedCols(),
1: 				  (UUID) null,
1: 				  null,
1: 				  null,
1: 				  resultSet.isOneRowResultSet(), 
0: 				  autoincRowLocation
0: 				  );
1: 		}
1: 		else
1: 		{
1: 			/* Return constant action for VTI
1: 			 * NOTE: ConstantAction responsible for preserving instantiated
1: 			 * VTIs for in-memory queries and for only preserving VTIs
1: 			 * that implement Serializable for SPSs.
1: 			 */
1: 			return	getGenericConstantActionFactory().getUpdatableVTIConstantAction( DeferModification.INSERT_STATEMENT,
1: 						deferred);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Create a boolean[] to track the (0-based) columns which are indexed.
1: 	 *
1: 	 * @return A boolean[] to track the (0-based) columns which are indexed.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public boolean[] getIndexedCols() throws StandardException
1: 	{
1: 		/* Create a boolean[] to track the (0-based) columns which are indexed */
1: 		boolean[] indexedCols = new boolean[targetTableDescriptor.getNumberOfColumns()];
1: 		for (int index = 0; index < indicesToMaintain.length; index++)
1: 		{
1: 			int[] colIds = indicesToMaintain[index].getIndexDescriptor().baseColumnPositions();
1: 
1: 			for (int index2 = 0; index2 < colIds.length; index2++)
1: 			{
1: 				indexedCols[colIds[index2] - 1] = true;
1: 			}
1: 		}
1: 
1: 		return indexedCols;
1: 	}
1: 
1: 	/**
1: 	 * Code generation for insert
1: 	 * creates an expression for:
0: 	 *   ResultSetFactory.getInsertResultSet(resultSet.generate(ps), this )
1: 	 *
1: 	 * @param acb	The ActivationClassBuilder for the class being built
1: 	 * @param mb the method  for the execute() method to be built
1: 	 *
0: 	 * @return		A compiled Expression returning an InsertResultSet
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
0: 		//If the DML is on the temporary table, generate the code to mark temporary table as modified in the current UOW
0: 		generateCodeForTemporaryTable(acb, mb);
1: 
1: 		/* generate the parameters */
1: 		generateParameterValueSet(acb);
1: 		// Base table
1: 		if (targetTableDescriptor != null)
1: 		{
1: 			/*
1: 			** Generate the insert result set, giving it either the original
1: 			** source or the normalize result set, the constant action,
1: 			** and "this".
1: 			*/
1: 
1: 			acb.pushGetResultSetFactoryExpression(mb);
1: 
1: 			// arg 1
1: 			resultSet.generate(acb, mb);
1: 
0: 			// arg 2 generate code to evaluate CHECK CONSTRAINTS
1: 			generateCheckConstraints( checkConstraints, acb, mb );
1: 
0: 			acb.pushThisAsActivation(mb); // arg 3
1: 
1: 
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getInsertResultSet", ClassName.ResultSet, 3);
1: 		}
1: 		else
1: 		{
1: 			/* Generate code for the VTI
1: 			 * NOTE: we need to create a dummy cost estimate for the
1: 			 * targetVTI since we never optimized it.
1: 			 * RESOLVEVTI - we will have to optimize it in order to 
1: 			 * push predicates into the VTI.
1: 			 */
1: 			targetVTI.assignCostEstimate(resultSet.getNewCostEstimate());
1: 
1: 			/*
1: 			** Generate the insert VTI result set, giving it either the original
1: 			** source or the normalize result set, the constant action,
1: 			** and "this".
1: 			*/
1: 			acb.pushGetResultSetFactoryExpression(mb);
1: 
1: 			// arg 1
1: 			resultSet.generate(acb, mb);
1: 
1: 			// arg 2
1: 			targetVTI.generate(acb, mb);
1: 
0: 			acb.pushThisAsActivation(mb); // arg 3
1: 
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getInsertVTIResultSet", ClassName.ResultSet, 3);
1: 		}
1: 
1: 		/*
0: 		** ensure all parameters have been generated
1: 		*/
0: 		generateParameterHolders(acb);
1: 	}
1: 
1: 	/**
1: 	 * Return the type of statement, something from
1: 	 * StatementType.
1: 	 *
1: 	 * @return the type of statement
1: 	 */
1: 	protected final int getStatementType()
1: 	{
1: 		return StatementType.INSERT;
1: 	}
1: 
1: 	/**
1: 	 * Return the statement type, where it is dependent on
1: 	 * the targetProperties.  (insertMode = replace causes
1: 	 * statement type to be BULK_INSERT_REPLACE.
1: 	 *
1: 	 * @return the type of statement
1: 	 */
0: 	static final int getStatementType(Properties targetProperties)
1: 	{
1: 		int retval = StatementType.INSERT;
1: 
1: 		// The only property that we're currently interested in is insertMode
1: 		String insertMode = (targetProperties == null) ? null : targetProperties.getProperty("insertMode");
1: 		if (insertMode != null)
1: 		{
1: 			String upperValue = StringUtil.SQLToUpperCase(insertMode);
1: 			if (upperValue.equals("REPLACE"))
1: 			{
1: 				retval = StatementType.BULK_INSERT_REPLACE;
1: 			}
1: 		}
1: 		return retval;
1: 	}
1: 
1: 	/**
1: 	 * Get the list of indexes on the table being inserted into.  This
1: 	 * is used by INSERT.  This is an optimized version of what
1: 	 * UPDATE and DELETE use. 
1: 	 *
1: 	 * @param td	TableDescriptor for the table being inserted into
1: 	 *				or deleted from
1: 	 *
0: 	 * @return	Nothing
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private void getAffectedIndexes
0: 	(
1: 		TableDescriptor 	td
0: 	)	
1: 					throws StandardException
1: 	{
1: 		IndexLister	indexLister = td.getIndexLister( );
1: 
1: 		indicesToMaintain = indexLister.getDistinctIndexRowGenerators();
1: 		indexConglomerateNumbers = indexLister.getDistinctIndexConglomerateNumbers();
1: 		indexNames = indexLister.getDistinctIndexNames();
1: 
1: 		/* Add dependencies on all indexes in the list */
1: 		ConglomerateDescriptor[]	cds = td.getConglomerateDescriptors();
1: 		CompilerContext cc = getCompilerContext();
1: 
1:  		for (int index = 0; index < cds.length; index++)
1: 		{
1: 			cc.createDependency(cds[index]);
1: 		}
1: 	}
1: } // end of class InsertNode
author:Army
-------------------------------------------------------------------------------
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
1: 			if (resultSet.getResultColumns().visibleSize() > targetColumnList.size())
1: 			if (resultSet.getResultColumns().visibleSize() > resultColumnList.size())
/////////////////////////////////////////////////////////////////////////
1: 		int resCols = resultSet.getResultColumns().visibleSize();
/////////////////////////////////////////////////////////////////////////
1: 				position < resultSet.getResultColumns().visibleSize();
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b6c6e95
/////////////////////////////////////////////////////////////////////////
0: 			/*
1: 			 * Normalize synonym qualifers for column references.
0: 			 */
1: 			if (synonymTableName != null)
0: 			{
1: 				normalizeSynonymColumns ( targetColumnList, targetTableName );
0: 			}
0: 			
/////////////////////////////////////////////////////////////////////////
0: 	
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	 * @param queryExpression	The query expression that will generate
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c45f5b1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.conn.Authorizer;
0: 
/////////////////////////////////////////////////////////////////////////
1: 		// We just need select privilege on the expressions
1: 		getCompilerContext().pushCurrentPrivType( Authorizer.SELECT_PRIV);
0: 
/////////////////////////////////////////////////////////////////////////
1: 			getCompilerContext().pushCurrentPrivType( getPrivType());
/////////////////////////////////////////////////////////////////////////
1: 			getCompilerContext().popCurrentPrivType();
/////////////////////////////////////////////////////////////////////////
0: 
0: 			getCompilerContext().pushCurrentPrivType(getPrivType());
0: 			getCompilerContext().addRequiredTablePriv(targetTableDescriptor);
0: 			getCompilerContext().popCurrentPrivType();
/////////////////////////////////////////////////////////////////////////
0: 		getCompilerContext().popCurrentPrivType();
1: 	int getPrivType()
0: 	{
1: 		return Authorizer.INSERT_PRIV;
0: 	}
0: 
commit:b7730e4
/////////////////////////////////////////////////////////////////////////
1: 														(DMLStatementNode) this);
commit:83793ec
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.compiler.JavaFactory;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.IndexLister;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.StatementType;
0: 
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: 
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.vti.DeferModification;
0: 
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import org.apache.derby.catalog.UUID;
0: 
0: import org.apache.derby.impl.sql.execute.FKInfo;
0: 
0: import java.util.Properties;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.util.ReuseFactory;
0: 
0: /**
0:  * An InsertNode is the top node in a query tree for an
0:  * insert statement.
0:  * <p>
0:  * After parsing, the node contains
0:  *   targetTableName: the target table for the insert
0:  *   collist: a list of column names, if specified
0:  *   queryexpr: the expression being inserted, either
0:  *				a values clause or a select form; both
0:  *			    of these are represented via the SelectNode,
0:  *				potentially with a TableOperatorNode such as
0:  *				UnionNode above it.
0:  * <p>
0:  * After binding, the node has had the target table's
0:  * descriptor located and inserted, and the queryexpr
0:  * and collist have been massaged so that they are identical
0:  * to the table layout.  This involves adding any default
0:  * values for missing columns, and reordering the columns
0:  * to match the table's ordering of them.
0:  * <p>
0:  * After optimizing, ...
0:  */
0: public final class InsertNode extends DMLModStatementNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	public		ResultColumnList	targetColumnList;
0: 	public 		boolean				deferred;
0: 	public		ValueNode			checkConstraints;
0: 	public		Properties			targetProperties;
0: 	public		FKInfo				fkInfo;
0: 	protected	boolean				bulkInsert;
0: 	private 	boolean				bulkInsertReplace;
0: 	
0: 	protected   RowLocation[] 		autoincRowLocation;
0: 	/**
0: 	 * Initializer for an InsertNode.
0: 	 *
0: 	 * @param targetName	The name of the table/VTI to insert into
0: 	 * @param insertColumns	A ResultColumnList with the names of the
0: 	 *			columns to insert into.  May be null if the
0: 	 *			user did not specify the columns - in this
0: 	 *			case, the binding phase will have to figure
0: 	 *			it out.
0: 	 * @param queryExpresssion	The query expression that will generate
0: 	 *				the rows to insert into the given table
0: 	 * @param targetProperties	The properties specified on the target table
0: 	 */
0: 
0: 	public void init(
0: 			Object targetName,
0: 			Object insertColumns,
0: 			Object queryExpression,
0: 			Object targetProperties)
0: 	{
0: 		/* statementType gets set in super() before we've validated
0: 		 * any properties, so we've kludged the code to get the
0: 		 * right statementType for a bulk insert replace.
0: 		 */
0: 		super.init(
0: 				queryExpression,
0: 				ReuseFactory.getInteger(getStatementType(
0: 												(Properties) targetProperties))
0: 				);
0: 		setTarget((QueryTreeNode) targetName);
0: 		targetColumnList = (ResultColumnList) insertColumns;
0: 		this.targetProperties = (Properties) targetProperties;
0: 
0: 		/* Remember that the query expression is the source to an INSERT */
0: 		getResultSetNode().setInsertSource();
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0:             try {
0:                 return ( (targetTableName!=null) ? targetTableName : targetVTI.getTableName() ).toString() + "\n"
0:                     + targetProperties + "\n"
0:                     + super.toString();
0:             } catch (org.apache.derby.iapi.error.StandardException e) {
0:                 return "tableName: <not_known>\n"
0:                     + targetProperties + "\n"
0:                     + super.toString();
0:             }
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	public String statementToString()
0: 	{
0: 		return "INSERT";
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (targetTableName != null)
0: 			{
0: 				printLabel(depth, "targetTableName: ");
0: 				targetTableName.treePrint(depth + 1);
0: 			}
0: 
0: 			if (targetColumnList != null)
0: 			{
0: 				printLabel(depth, "targetColumnList: ");
0: 				targetColumnList.treePrint(depth + 1);
0: 			}
0: 
0: 			/* RESOLVE - need to print out targetTableDescriptor */
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Bind this InsertNode.  This means looking up tables and columns and
0: 	 * getting their types, and figuring out the result types of all
0: 	 * expressions, as well as doing view resolution, permissions checking,
0: 	 * etc.
0: 	 * <p>
0: 	 * Binding an insert will also massage the tree so that
0: 	 * the collist and select column order/number are the
0: 	 * same as the layout of the table in the store. 
0: 	 *
0: 	 * @return	The bound query tree
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public QueryTreeNode bind() throws StandardException
0: 	{
0: 		FromList	fromList = (FromList) getNodeFactory().getNode(
0: 									C_NodeTypes.FROM_LIST,
0: 									getNodeFactory().doJoinOrderOptimization(),
0: 									getContextManager());
0: 
0: 		/* If any underlying ResultSetNode is a SelectNode, then we
0: 		 * need to do a full bind(), including the expressions
0: 		 * (since the fromList may include a FromSubquery).
0: 		 */
0:         DataDictionary dataDictionary = getDataDictionary();
0: 		super.bindResultSetsWithTables(dataDictionary);
0: 
0: 		/*
0: 		** Get the TableDescriptor for the table we are inserting into
0: 		*/
0: 		verifyTargetTable();
0: 
0: 		// Check the validity of the targetProperties, if they exist
0: 		if (targetProperties != null)
0: 		{
0: 			verifyTargetProperties(dataDictionary);
0: 		}
0: 
0: 		/*
0: 		** Get the resultColumnList representing the columns in the base
0: 		** table or VTI.
0: 		*/
0: 		getResultColumnList();
0: 
0: 		/* If we have a target column list, then it must have the same # of
0: 		 * entries as the result set's RCL.
0: 		 */
0: 		if (targetColumnList != null)
0: 		{
0: 			/* Bind the target column list */
0: 			if (targetTableDescriptor != null)
0: 			{
0: 				targetColumnList.bindResultColumnsByName(targetTableDescriptor,
0: 														this);
0: 			}
0: 			else
0: 			{
0: 				targetColumnList.bindResultColumnsByName(targetVTI.getResultColumns(), targetVTI,
0: 														this);
0: 			}
0: 
0: 		}
0: 
0: 		/* Verify that all underlying ResultSets reclaimed their FromList */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(fromList.size() == 0,
0: 				"fromList.size() is expected to be 0, not " + 
0: 				fromList.size() +
0: 				" on return from RS.bindExpressions()");
0: 		}
0: 
0: 		/* Replace any DEFAULTs with the associated tree */
0: 		resultSet.replaceDefaults(targetTableDescriptor, targetColumnList);
0: 
0: 		/* Bind the expressions now that the result columns are bound 
0: 		 * NOTE: This will be the 2nd time for those underlying ResultSets
0: 		 * that have tables (no harm done), but it is necessary for those
0: 		 * that do not have tables.  It's too hard/not work the effort to
0: 		 * avoid the redundancy.
0: 		 */
0: 		super.bindExpressions();
0: 
0: 		/*
0: 		** If the result set is a union, it could be a table constructor.
0: 		** Bind any nulls in the result columns of the table constructor
0: 		** to the types of the table being inserted into.
0: 		**
0: 		** The types of ? parameters in row constructors and table constructors
0: 		** in an INSERT statement come from the result columns.
0: 		**
0: 		** If there is a target column list, use that instead of the result
0: 		** columns for the whole table, since the columns in the result set
0: 		** correspond to the target column list.
0: 		*/
0: 		if (targetColumnList != null)
0: 		{
0: 			if (resultSet.getResultColumns().size() > targetColumnList.size())
0: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
0: 			resultSet.bindUntypedNullsToResultColumns(targetColumnList);
0: 			resultSet.setTableConstructorTypes(targetColumnList);
0: 		}
0: 		else
0: 		{
0: 			if (resultSet.getResultColumns().size() > resultColumnList.size())
0: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
0: 			resultSet.bindUntypedNullsToResultColumns(resultColumnList);
0: 			resultSet.setTableConstructorTypes(resultColumnList);
0: 		}
0: 
0: 		/* Bind the columns of the result set to their expressions */
0: 		resultSet.bindResultColumns(fromList);
0: 
0: 		/* DB2 doesn't allow different number of target columns and result columns.
0: 		 * RESOLVE: Enforce the limit only in DB2 mode for now. Too many tests need to be
0: 		 * migrated to DB2 mode first.  Only now we would have expanded STAR (*) to all columns.
0: 		 */
0: 		int resCols = resultSet.getResultColumns().size();
0: 		DataDictionary dd = getDataDictionary();
0: 		if (targetColumnList != null)
0: 		{
0: 			if (targetColumnList.size() != resCols)
0: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
0: 		}
0: 		else 
0: 		{
0: 			if (targetTableDescriptor != null &&
0: 						targetTableDescriptor.getNumberOfColumns() != resCols)
0: 				throw StandardException.newException(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED); 
0: 		}
0: 
0: 		/* See if the ResultSet's RCL needs to be ordered to match the target
0: 		 * list, or "enhanced" to accommodate defaults.  It can only need to
0: 		 * be ordered if there is a target column list.  It needs to be
0: 		 * enhanced if there are fewer source columns than there are columns
0: 		 * in the table.
0: 		 */
0: 		boolean inOrder = true;
0: 		int numTableColumns = resultColumnList.size();
0: 
0: 		/* colMap[] will be the size of the target list, which could be larger
0: 		 * than the current size of the source list.  In that case, the source
0: 		 * list will be "enhanced" to include defaults.
0: 		 */
0: 		int[] colMap = new int[numTableColumns];
0: 
0: 		// set the fields to an unused value
0: 		for (int i = 0; i < colMap.length; i++) 
0: 		{
0: 			colMap[i] = -1;
0: 		}
0: 
0: 		/* Create the source/target list mapping */
0: 		if (targetColumnList != null)
0: 		{
0: 			/*
0: 			** There is a target column list, so the result columns might
0: 			** need to be ordered.  Step through the target column list
0: 			** and remember the position in the target table of each column.
0: 			** Remember if any of the columns are out of order.
0: 			*/
0: 			int targetSize = targetColumnList.size();
0: 			for (int index = 0; index < targetSize; index++)
0: 			{
0: 				int position =
0: 					((ResultColumn) (targetColumnList.elementAt(index))).
0: 												columnDescriptor.getPosition();
0: 
0: 				if (index != position-1)
0: 				{
0: 					inOrder = false;
0: 				}
0: 
0: 				// position is 1-base; colMap indexes and entries are 0-based.
0: 				colMap[position-1] = index;
0: 			}
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** There is no target column list, so the result columns in the
0: 			** source are presumed to be in the same order as the target
0: 			** table.
0: 			*/
0: 			for (int position = 0;
0: 				position < resultSet.getResultColumns().size();
0: 				position++)
0: 			{
0: 				colMap[position] = position;
0: 			}
0: 		}
0: 
0: 		// colmap[x] == y means that column x in the target table
0: 		// maps to column y in the source result set.
0: 		// colmap[x] == -1 means that column x in the target table
0: 		// maps to its default value.
0: 		// both colmap indexes and values are 0-based.
0: 
0: 		/* if the list is in order and complete, we don't have to change
0: 		 * the tree. If it is not, then we call RSN.enhanceRCLForInsert() 
0: 		 * which will either
0: 		 * (reorder and/or "enhance" the source RCL within the same RSN) or
0: 		 * (generate and return a PRN with a new reordered/enhanced RCL above
0: 		 * the existing RSN).  This way, RSN's that understand how to do projections
0: 		 * can avoid the additional PRN while those that do not will get one.
0: 		 */
0: 		/* NOTE - javascope gives confusing branch coverage info here.  By
0: 		 * breaking apart the following if condition, I have verified that
0: 		 * we test all cases.  (Jerry 7/17/97)
0: 		 */
0: 		if (! inOrder || resultSet.resultColumns.size() < numTableColumns)
0: 		{
0: 			// one thing we do know is that all of the resultsets underneath
0: 			// us have their resultColumn names filled in with the names of
0: 			// the target table columns.  That makes generating the mapping
0: 			// "easier" -- we simply generate the names of the target table columns
0: 			// that are included.  For the missing columns, we generate default
0: 			// value expressions.
0: 
0: 			resultSet = resultSet.enhanceRCLForInsert(numTableColumns, colMap, 
0: 													  dataDictionary,
0: 													  targetTableDescriptor, targetVTI);
0: 		}
0: 
0: 		if (resultSet instanceof UnionNode)
0: 		{
0: 			// If we are inserting a number of rows in VALUES clause, we need to
0: 			// examine each row for 'autoincrement'.
0: 			resultColumnList.checkAutoincrementUnion(resultSet);
0: 		}
0: 		else resultColumnList.checkAutoincrement(resultSet.getResultColumns());
0: 		resultColumnList.checkStorableExpressions(resultSet.getResultColumns());
0: 		/* Insert a NormalizeResultSetNode above the source if the source
0: 		 * and target column types and lengths do not match.
0:  		 */
0: 		if (! resultColumnList.columnTypesAndLengthsMatch(
0: 												resultSet.getResultColumns()))
0: 		{
0: 			resultSet = resultSet.genNormalizeResultSetNode(resultSet, false);
0: 			resultColumnList.copyTypesAndLengthsToSource(resultSet.getResultColumns());
0: 		}
0: 
0: 		if (targetTableDescriptor != null)
0: 		{
0: 			/* Get and bind all constraints on the table */
0: 			ResultColumnList sourceRCL = resultSet.getResultColumns();
0: 			sourceRCL.copyResultColumnNames(resultColumnList);
0: 			checkConstraints = bindConstraints(dataDictionary,
0: 												getNodeFactory(),
0: 												targetTableDescriptor,
0: 												null,
0: 												sourceRCL,
0: 												(int[]) null,
0: 												(FormatableBitSet) null,
0: 												false,
0: 											    true);  /* we always include
0: 														 * triggers in core language */
0: 	
0: 			/* Do we need to do a deferred mode insert */
0: 			/* 
0: 		 	** Deferred if:
0: 			**	If the target table is also a source table
0: 			**	Self-referencing foreign key constraint 
0: 			**	trigger
0: 			*/
0: 			if (resultSet.referencesTarget(
0: 									targetTableDescriptor.getName(), true) ||
0: 				 requiresDeferredProcessing())
0: 			{
0: 				deferred = true;
0: 
0: 				/* Disallow bulk insert replace when target table
0: 				 * is also a source table.
0: 				 */
0: 				if (bulkInsertReplace &&
0: 					resultSet.referencesTarget(
0: 									targetTableDescriptor.getName(), true))
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_INVALID_BULK_INSERT_REPLACE, 
0: 									targetTableDescriptor.getQualifiedName());
0: 				}
0: 			}
0: 
0: 			/* Get the list of indexes on the table being inserted into */
0: 			getAffectedIndexes(targetTableDescriptor);
0: 			TransactionController tc = 
0: 				getLanguageConnectionContext().getTransactionCompile();
0: 
0: 			autoincRowLocation = 
0: 				dd.computeAutoincRowLocations(tc, targetTableDescriptor);
0: 		}
0: 		else
0: 		{
0:             deferred = VTIDeferModPolicy.deferIt( DeferModification.INSERT_STATEMENT,
0:                                                   targetVTI,
0:                                                   null,
0:                                                   resultSet);
0: 		}
0:         
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Return true if the node references SESSION schema tables (temporary or permanent)
0: 	 *
0: 	 * @return	true if references SESSION schema tables, else false
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean referencesSessionSchema()
0: 		throws StandardException
0: 	{
0: 		boolean returnValue = false;
0: 
0: 		//If this node references a SESSION schema table, then return true. 
0: 		if (targetTableDescriptor != null)
0: 			returnValue = isSessionSchema(targetTableDescriptor.getSchemaDescriptor());
0: 
0: 		if (returnValue == false)
0: 			returnValue = resultSet.referencesSessionSchema();
0: 
0: 		return returnValue;
0: 	}
0: 
0: 	/**
0: 	 * Verify that the target properties that we are interested in
0: 	 * all hold valid values.
0: 	 * NOTE: Any target property which is valid but cannot be supported
0: 	 * due to a target database, etc. will be turned off quietly.
0: 	 *
0: 	 * @param dd	The DataDictionary
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private void verifyTargetProperties(DataDictionary dd)
0: 		throws StandardException
0: 	{
0: 		// The only property that we're currently interested in is insertMode
0: 		String insertMode = targetProperties.getProperty("insertMode");
0: 		if (insertMode != null)
0: 		{
0: 			String upperValue = StringUtil.SQLToUpperCase(insertMode);
0: 			if (! upperValue.equals("BULKINSERT") &&
0: 				! upperValue.equals("REPLACE"))
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_INVALID_INSERT_MODE, 
0: 								insertMode,
0: 								targetTableName);
0: 			}
0: 			else
0: 			{
0: 				/* Turn off bulkInsert if it is on and we can't support it. */
0: 				if (! verifyBulkInsert(dd, upperValue))
0: 				{
0: 					targetProperties.remove("insertMode");
0: 				}
0: 				else
0: 				{
0: 					/* Now we know we're doing bulk insert */
0: 					bulkInsert = true;
0: 
0: 					if (upperValue.equals("REPLACE"))
0: 					{
0: 						bulkInsertReplace = true;
0: 					}
0: 
0: 					// Validate the bulkFetch property if specified
0: 					String bulkFetchStr = targetProperties.getProperty("bulkFetch");
0: 					if (bulkFetchStr != null)
0: 					{
0: 						int bulkFetch = getIntProperty(bulkFetchStr, "bulkFetch");
0: 
0: 						// verify that the specified value is valid
0: 						if (bulkFetch <= 0)
0: 						{
0: 							throw StandardException.newException(SQLState.LANG_INVALID_BULK_FETCH_VALUE,
0: 									String.valueOf(bulkFetch));
0: 						}
0: 					}
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Do the bind time checks to see if bulkInsert is allowed on
0: 	 * this table.  bulkInsert is disallowed at bind time for:
0: 	 *		o  target databases
0: 	 *		o  (tables with triggers?)
0: 	 * (It is disallowed at execution time if the table has at
0: 	 * least 1 row in it or if it is a deferred mode insert.)
0: 	 *
0: 	 * @param dd	The DataDictionary
0: 	 * @param mode	The insert mode
0: 	 *
0: 	 * @return Whether or not bulkInsert is allowed.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private boolean verifyBulkInsert(DataDictionary dd, String mode)
0: 		throws StandardException
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Compile constants that Execution will use
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public ConstantAction	makeConstantAction() throws StandardException
0: 	{
0: 
0: 		/* Different constant actions for base tables and updatable VTIs */
0: 		if (targetTableDescriptor != null)
0: 		{
0: 			// Base table
0: 
0: 			long heapConglomId = targetTableDescriptor.getHeapConglomerateId();
0: 			TransactionController tc = 
0: 				getLanguageConnectionContext().getTransactionCompile();
0: 			int numIndexes = (targetTableDescriptor != null) ?
0: 								indexConglomerateNumbers.length : 0;
0: 			StaticCompiledOpenConglomInfo[] indexSCOCIs = 
0: 				new StaticCompiledOpenConglomInfo[numIndexes];
0: 
0: 			for (int index = 0; index < numIndexes; index++)
0: 			{
0: 				indexSCOCIs[index] = tc.getStaticCompiledConglomInfo(indexConglomerateNumbers[index]);
0: 			}
0: 
0: 			/*
0: 			** If we're doing bulk insert, do table locking regardless of
0: 			** what the optimizer decided.  This is because bulk insert is
0: 			** generally done with a large number of rows into an empty table.
0: 			** We also do table locking if the table's lock granularity is
0: 			** set to table.
0: 			*/
0: 			if (bulkInsert ||
0: 				targetTableDescriptor.getLockGranularity() == TableDescriptor.TABLE_LOCK_GRANULARITY)
0: 			{
0: 				lockMode = TransactionController.MODE_TABLE;
0: 			}
0: 
0: 			return	getGenericConstantActionFactory().getInsertConstantAction
0: 				( targetTableDescriptor,
0: 				  heapConglomId,
0: 				  tc.getStaticCompiledConglomInfo(heapConglomId),
0: 				  indicesToMaintain,
0: 				  indexConglomerateNumbers,
0: 				  indexSCOCIs,
0: 				  indexNames,
0: 				  deferred,
0: 				  false,
0: 				  targetTableDescriptor.getUUID(),
0: 				  lockMode,
0: 				  null, null, 
0: 				  targetProperties,
0: 				  getFKInfo(),
0: 				  getTriggerInfo(),
0: 				  resultColumnList.getStreamStorableColIds(targetTableDescriptor.getNumberOfColumns()),
0: 				  getIndexedCols(),
0: 				  (UUID) null,
0: 				  null,
0: 				  null,
0: 				  resultSet.isOneRowResultSet(), 
0: 				  autoincRowLocation
0: 				  );
0: 		}
0: 		else
0: 		{
0: 			/* Return constant action for VTI
0: 			 * NOTE: ConstantAction responsible for preserving instantiated
0: 			 * VTIs for in-memory queries and for only preserving VTIs
0: 			 * that implement Serializable for SPSs.
0: 			 */
0: 			return	getGenericConstantActionFactory().getUpdatableVTIConstantAction( DeferModification.INSERT_STATEMENT,
0: 						deferred);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Create a boolean[] to track the (0-based) columns which are indexed.
0: 	 *
0: 	 * @return A boolean[] to track the (0-based) columns which are indexed.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public boolean[] getIndexedCols() throws StandardException
0: 	{
0: 		/* Create a boolean[] to track the (0-based) columns which are indexed */
0: 		boolean[] indexedCols = new boolean[targetTableDescriptor.getNumberOfColumns()];
0: 		for (int index = 0; index < indicesToMaintain.length; index++)
0: 		{
0: 			int[] colIds = indicesToMaintain[index].getIndexDescriptor().baseColumnPositions();
0: 
0: 			for (int index2 = 0; index2 < colIds.length; index2++)
0: 			{
0: 				indexedCols[colIds[index2] - 1] = true;
0: 			}
0: 		}
0: 
0: 		return indexedCols;
0: 	}
0: 
0: 	/**
0: 	 * Code generation for insert
0: 	 * creates an expression for:
0: 	 *   ResultSetFactory.getInsertResultSet(resultSet.generate(ps), this )
0: 	 *
0: 	 * @param acb	The ActivationClassBuilder for the class being built
0: 	 * @param mb the method  for the execute() method to be built
0: 	 *
0: 	 * @return		A compiled Expression returning an InsertResultSet
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		//If the DML is on the temporary table, generate the code to mark temporary table as modified in the current UOW
0: 		generateCodeForTemporaryTable(acb, mb);
0: 
0: 		/* generate the parameters */
0: 		generateParameterValueSet(acb);
0: 		// Base table
0: 		if (targetTableDescriptor != null)
0: 		{
0: 			/*
0: 			** Generate the insert result set, giving it either the original
0: 			** source or the normalize result set, the constant action,
0: 			** and "this".
0: 			*/
0: 
0: 			acb.pushGetResultSetFactoryExpression(mb);
0: 
0: 			// arg 1
0: 			resultSet.generate(acb, mb);
0: 
0: 			// arg 2 generate code to evaluate CHECK CONSTRAINTS
0: 			generateCheckConstraints( checkConstraints, acb, mb );
0: 
0: 			acb.pushThisAsActivation(mb); // arg 3
0: 
0: 
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getInsertResultSet", ClassName.ResultSet, 3);
0: 		}
0: 		else
0: 		{
0: 			/* Generate code for the VTI
0: 			 * NOTE: we need to create a dummy cost estimate for the
0: 			 * targetVTI since we never optimized it.
0: 			 * RESOLVEVTI - we will have to optimize it in order to 
0: 			 * push predicates into the VTI.
0: 			 */
0: 			targetVTI.assignCostEstimate(resultSet.getNewCostEstimate());
0: 
0: 			/*
0: 			** Generate the insert VTI result set, giving it either the original
0: 			** source or the normalize result set, the constant action,
0: 			** and "this".
0: 			*/
0: 			acb.pushGetResultSetFactoryExpression(mb);
0: 
0: 			// arg 1
0: 			resultSet.generate(acb, mb);
0: 
0: 			// arg 2
0: 			targetVTI.generate(acb, mb);
0: 
0: 			acb.pushThisAsActivation(mb); // arg 3
0: 
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getInsertVTIResultSet", ClassName.ResultSet, 3);
0: 		}
0: 
0: 		/*
0: 		** ensure all parameters have been generated
0: 		*/
0: 		generateParameterHolders(acb);
0: 	}
0: 
0: 	/**
0: 	 * Return the type of statement, something from
0: 	 * StatementType.
0: 	 *
0: 	 * @return the type of statement
0: 	 */
0: 	protected final int getStatementType()
0: 	{
0: 		return StatementType.INSERT;
0: 	}
0: 
0: 	/**
0: 	 * Return the statement type, where it is dependent on
0: 	 * the targetProperties.  (insertMode = replace causes
0: 	 * statement type to be BULK_INSERT_REPLACE.
0: 	 *
0: 	 * @return the type of statement
0: 	 */
0: 	static final int getStatementType(Properties targetProperties)
0: 	{
0: 		int retval = StatementType.INSERT;
0: 
0: 		// The only property that we're currently interested in is insertMode
0: 		String insertMode = (targetProperties == null) ? null : targetProperties.getProperty("insertMode");
0: 		if (insertMode != null)
0: 		{
0: 			String upperValue = StringUtil.SQLToUpperCase(insertMode);
0: 			if (upperValue.equals("REPLACE"))
0: 			{
0: 				retval = StatementType.BULK_INSERT_REPLACE;
0: 			}
0: 		}
0: 		return retval;
0: 	}
0: 
0: 	/**
0: 	 * Get the list of indexes on the table being inserted into.  This
0: 	 * is used by INSERT.  This is an optimized version of what
0: 	 * UPDATE and DELETE use. 
0: 	 *
0: 	 * @param td	TableDescriptor for the table being inserted into
0: 	 *				or deleted from
0: 	 *
0: 	 * @return	Nothing
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private void getAffectedIndexes
0: 	(
0: 		TableDescriptor 	td
0: 	)	
0: 					throws StandardException
0: 	{
0: 		IndexLister	indexLister = td.getIndexLister( );
0: 
0: 		indicesToMaintain = indexLister.getDistinctIndexRowGenerators();
0: 		indexConglomerateNumbers = indexLister.getDistinctIndexConglomerateNumbers();
0: 		indexNames = indexLister.getDistinctIndexNames();
0: 
0: 		/* Add dependencies on all indexes in the list */
0: 		ConglomerateDescriptor[]	cds = td.getConglomerateDescriptors();
0: 		CompilerContext cc = getCompilerContext();
0: 
0:  		for (int index = 0; index < cds.length; index++)
0: 		{
0: 			cc.createDependency(cds[index]);
0: 		}
0: 	}
0: } // end of class InsertNode
============================================================================