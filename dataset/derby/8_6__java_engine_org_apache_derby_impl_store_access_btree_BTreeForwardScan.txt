1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.BTreeForwardScan
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
18:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:eac0369: 
4:eac0369: /**
1:eac0369: 
1:eac0369:   A b-tree scan controller corresponds to an instance of an open b-tree scan.
1:eac0369:   <P>
1:227eaef:   <B>Concurrency Notes</B>
1:eac0369:   <P>
1:eac0369:   The concurrency rules are derived from OpenBTree.
1:eac0369:   <P>
1:eac0369:   @see OpenBTree
1:eac0369: 
3:eac0369: **/
1:eac0369: 
1:eac0369: public class BTreeForwardScan extends BTreeScan
9:eac0369: {
1:eac0369: 	/*
1:eac0369: 	** Private/Protected methods of This class, sorted alphabetically
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Position scan at "start" position.
3:eac0369: 	<p>
1:eac0369:     Positions the scan to the slot just before the first record to be returned
1:eac0369:     from the scan.  Returns the start page latched, and sets "current_slot" to
1:eac0369:     the slot number.
1:eac0369: 
2:eac0369: 	@exception  StandardException  Standard exception policy.
1:eac0369: 	**/
1:eac0369:     protected void positionAtStartPosition(
1:eac0369:     BTreeRowPosition    pos)
3:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         positionAtStartForForwardScan(pos);
9:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Fetch the next N rows from the table.
1:eac0369:      * <p>
1:eac0369:      * Utility routine used by both fetchSet() and fetchNextGroup().
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected int fetchRows(
1:eac0369:     BTreeRowPosition        pos,
1:eac0369:     DataValueDescriptor[][] row_array,
1:eac0369:     RowLocation[]           rowloc_array,
1:eac0369:     BackingStoreHashtable   hash_table,
1:eac0369:     long                    max_rowcnt,
1:eac0369:     int[]                   key_column_numbers)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:e81e52c:         if (SanityManager.DEBUG)
1:e81e52c:         {
1:e81e52c:             // RowLocations in the BTree itself are unstable and should
1:e81e52c:             // not be put in long-lived structures like persistent hash tables.
1:e81e52c:             SanityManager.ASSERT
1:e81e52c:                 ( (hash_table == null) || !hash_table.includeRowLocations() );
1:e81e52c:         }
1:eac0369: 
1:eac0369:         int                     ret_row_count     = 0;
1:eac0369:         DataValueDescriptor[]   fetch_row         = null;
1:eac0369:         RecordHandle            rh;
1:eac0369: 
1:eac0369:         if (max_rowcnt == -1)
1:eac0369:             max_rowcnt = Long.MAX_VALUE;
1:eac0369: 
1:eac0369: 
1:eac0369:         if (this.scan_state == BTreeScan.SCAN_INPROGRESS)
1:eac0369:         {
1:eac0369:             // reposition the scan at the row just before the next one to 
1:eac0369:             // return.
1:eac0369:             // This routine handles the mess of repositioning if the row or 
1:eac0369:             // the page has disappeared. This can happen if a lock was not 
1:eac0369:             // held on the row while not holding the latch (can happen if
1:eac0369:             // this scan is read uncommitted).
3:eac0369:             //
1:eac0369:             // code path tested by readUncommitted.sql:TEST 1
1:eac0369:             //
1:eac0369:             if (!reposition(pos, true))
1:eac0369:             {
3:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
3:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "can not fail with 2nd param true.");
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:         }
1:eac0369:         else if (this.scan_state == SCAN_INIT)
1:eac0369:         {
1:eac0369:             // 1st positioning of scan (delayed from openScan).
1:eac0369:             positionAtStartPosition(pos);
1:eac0369:         }
1:eac0369:         else if (this.scan_state == SCAN_HOLD_INPROGRESS)
1:eac0369:         {
1:eac0369:             reopen();
1:eac0369: 
1:eac0369:             this.scan_state = SCAN_INPROGRESS;
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(scan_position.current_positionKey != null);
1:eac0369:             }
1:eac0369: 
1:eac0369:             // reposition the scan at the row just before the next one to 
1:eac0369:             // return.
1:eac0369:             // This routine handles the mess of repositioning if the row or 
1:eac0369:             // the page has disappeared. This can happen if a lock was not 
1:eac0369:             // held on the row while not holding the latch.
1:eac0369:             //
1:eac0369:             // code path tested by holdCursor.sql: TEST 9
1:eac0369:             if (!reposition(pos, true))
1:eac0369:             {
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "can not fail with 2nd param true.");
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:         }
1:eac0369:         else if (this.scan_state == SCAN_HOLD_INIT)
1:eac0369:         {
1:eac0369:             reopen();
1:eac0369: 
1:eac0369:             positionAtStartForForwardScan(scan_position);
1:eac0369:         }
2:eac0369:         else
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(this.scan_state == SCAN_DONE);
1:eac0369: 
1:eac0369:             return(0);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(
1:eac0369:                 init_template != null, "init_template is null");
1:eac0369: 		}
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(this.container != null,
1:eac0369:                 "BTreeScan.next() called on a closed scan.");
1:eac0369: 
1:eac0369:             if (row_array != null)
1:eac0369:                 SanityManager.ASSERT(row_array[0] != null,
1:eac0369:                     "first array slot in fetchNextGroup() must be non-null.");
1:eac0369: 
1:eac0369:             // Btree's don't support RowLocations yet.
1:eac0369:             if (rowloc_array != null)
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                         SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // System.out.println("top of fetchRows, fetch_row = " + fetch_row);
1:eac0369: 
1:eac0369: 
1:eac0369:         // At this point:
1:eac0369:         // current_page is latched.  current_slot is the slot on current_page
1:eac0369:         // just before the "next" record this routine should process.
1:eac0369: 
1:eac0369:         // loop through successive leaf pages and successive slots on those
1:eac0369:         // leaf pages.  Stop when either the last leaf is reached (current_page
1:eac0369:         // will be null), or when stopKeyValue is reached/passed.  Along the
1:eac0369:         // way apply qualifiers to skip rows which don't qualify.
1:eac0369: 
1:86e051f:         leaf_loop:
1:eac0369: 		while (pos.current_leaf != null)
1:eac0369: 		{
1:eac0369:             // System.out.println(
1:eac0369:               //   "1 of fetchSet loop, ret_row_count = " + ret_row_count +
1:eac0369:                 // "fetch_row = " + fetch_row);
1:eac0369: 
1:86e051f:             slot_loop:
1:eac0369: 			while ((pos.current_slot + 1) < pos.current_leaf.page.recordCount())
1:eac0369: 			{
1:eac0369: 
1:eac0369:                 // System.out.println(
1:eac0369:                 // "2 of fetchSet loop, ret_row_count = " + ret_row_count +
1:eac0369:                 // "fetch_row = " + fetch_row + 
1:eac0369:                 // "hash_table = " + hash_table);
1:eac0369: 
1:eac0369: 
1:eac0369:                 // unlock the previous row if doing read.
1:eac0369:                 if (pos.current_rh != null)
1:eac0369:                 {
1:eac0369:                     this.getLockingPolicy().unlockScanRecordAfterRead(
1:eac0369:                         pos, init_forUpdate);
1:eac0369: 
1:eac0369:                     // current_rh is used to track which row we need to unlock,
1:eac0369:                     // at this point no row needs to be unlocked.
1:eac0369:                     pos.current_rh = null;
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // Allocate a new row to read the row into.
1:eac0369:                 if (fetch_row == null)
1:eac0369:                 {
1:eac0369:                     if (hash_table == null)
1:eac0369:                     {
1:eac0369:                         // point at allocated row in array if one exists.
1:eac0369:                         if (row_array[ret_row_count] == null)
1:eac0369:                         {
1:eac0369:                             row_array[ret_row_count] = 
1:722a889:                                 runtime_mem.get_row_for_export(getRawTran());
1:eac0369:                         }
1:eac0369: 
1:eac0369:                         fetch_row = row_array[ret_row_count];
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                     {
1:eac0369:                         // get a brand new row.
1:722a889:                         fetch_row = 
1:722a889:                             runtime_mem.get_row_for_export(getRawTran()); 
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // move scan current position forward.
1:eac0369:                 pos.current_slot++;
1:eac0369:                 this.stat_numrows_visited++;
1:eac0369: 
1:eac0369:                 rh =
1:eac0369:                     pos.current_leaf.page.fetchFromSlot(
1:eac0369:                         (RecordHandle) null,
1:eac0369:                         pos.current_slot, fetch_row, 
1:eac0369:                         init_fetchDesc,
1:eac0369:                         true);
1:eac0369: 
1:eac0369: 
1:eac0369:                 pos.current_rh_qualified = true;
1:eac0369: 
1:eac0369:                 // See if this is the stop row.
1:eac0369:                 if (init_stopKeyValue != null)
1:eac0369:                 {
1:eac0369:                     // See if current row is the >= the stopKeyValue.
1:eac0369:                     //
1:eac0369:                     // ret >  0: key is greater than row on page.
1:eac0369:                     // ret == 0: key is exactly the row on page if full key,
1:eac0369:                     //           or partial match if partial key.
1:eac0369:                     // ret <  0: key is less    than row on page.
1:eac0369:                     //
1:4a2b0d9:                     int ret = ControlRow.compareIndexRowToKey(
1:eac0369:                                 fetch_row,
1:eac0369:                                 init_stopKeyValue,
1:eac0369:                                 fetch_row.length,
1:eac0369:                                 0, this.getConglomerate().ascDescInfo);
1:eac0369: 
1:eac0369:                     if ((ret == 0) && 
1:eac0369:                         (init_stopSearchOperator == ScanController.GE))
1:eac0369:                     {
1:eac0369:                         // if (partial) matched and stop is GE, end the scan.
1:eac0369:                         ret = 1;
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     if (ret > 0)
1:eac0369:                     {
1:eac0369:                         // This is the first non-qualifying row. We're done.
1:eac0369: 
2:eac0369:                         pos.current_leaf.release();
2:eac0369:                         pos.current_leaf = null;
1:eac0369:                         positionAtDoneScan(pos);
1:eac0369: 
1:eac0369:                         return(ret_row_count);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369: 
1:eac0369:                 // Only lock rows that are < the stopKeyValue.  No need to
1:eac0369:                 // requalify against stop position after losing the latch
1:eac0369:                 // as the only change that could have happened is that the
1:eac0369:                 // row was marked deleted - the key value cannot change.
1:eac0369:                 boolean latch_released =
1:eac0369:                     !this.getLockingPolicy().lockScanRow(
1:f6fea40:                         this, pos,
1:eac0369:                         init_lock_fetch_desc,
1:eac0369:                         pos.current_lock_template,
1:eac0369:                         pos.current_lock_row_loc,
1:eac0369:                         false, init_forUpdate, lock_operation);
1:eac0369: 
1:eac0369:                 // special test to see if latch release code works
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     latch_released = 
1:eac0369:                         test_errors(
1:eac0369:                             this,
1:86e051f:                             "BTreeScan_fetchNextGroup", pos,
1:eac0369:                             this.getLockingPolicy(),
1:eac0369:                             pos.current_leaf, latch_released);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 // At this point we have successfully locked this record, so
1:eac0369:                 // remember the record handle so that it can be unlocked if
1:eac0369:                 // necessary.  If the above lock deadlocks, we will not try
1:eac0369:                 // to unlock a lock we never got in close(), because current_rh
1:eac0369:                 // is null until after the lock is granted.
1:eac0369:                 pos.current_rh = rh;
1:eac0369: 
1:86e051f:                 while (latch_released)
1:eac0369:                 {
1:eac0369:                     // lost latch on page in order to wait for row lock.
1:86e051f:                     // reposition() will take care of the complexity with
1:86e051f:                     // finding the correct spot to position on if the row
1:86e051f:                     // has been moved to another page.
1:86e051f: 
1:86e051f:                     if (!reposition(pos, false))
1:86e051f:                     {
1:86e051f:                         // Could not position on the exact same row that was
1:86e051f:                         // saved, which means that it has been purged.
1:86e051f:                         // Reposition on the row immediately to the left of
1:86e051f:                         // the purged row instead.
1:86e051f:                         if (!reposition(pos, true))
1:86e051f:                         {
1:86e051f:                             if (SanityManager.DEBUG)
1:86e051f:                             {
1:86e051f:                                 SanityManager.THROWASSERT(
1:86e051f:                                         "Cannot fail with 2nd param true");
1:86e051f:                             }
1:86e051f:                             // reposition will set pos.current_leaf to null if
1:86e051f:                             // it returns false, so if this ever does fail in
1:86e051f:                             // delivered code, expect a NullPointerException at
1:86e051f:                             // the top of this loop when we call recordCount().
1:86e051f:                         }
1:86e051f: 
1:86e051f:                         // Now we're positioned to the left of our saved
1:86e051f:                         // position. Go to the top of the loop so that we move
1:86e051f:                         // the scan to the next row and release the lock on
1:86e051f:                         // the purged row.
1:86e051f:                         continue slot_loop;
1:86e051f:                     }
1:86e051f: 
1:86e051f:                     // At this point, the scan is positioned and the latch
1:86e051f:                     // is held.
1:86e051f:                     latch_released = false;
1:eac0369: 
1:eac0369:                     if (this.getConglomerate().isUnique())
1:eac0369:                     {
1:eac0369:                         // Handle row location changing since lock request was 
1:eac0369:                         // initiated.
1:eac0369:                         // In unique indexes, there is one case where an index 
1:eac0369:                         // row can have it's data lock key change (this usually
1:eac0369:                         // cannot happen because only inserts and deletes are 
1:eac0369:                         // allowed - no updates).  This case is an insert of a 
1:eac0369:                         // key, that exactly matches a committed deleted row, 
1:eac0369:                         // in a unique index.  In that case the code updates 
1:eac0369:                         // the RowLocation column and flips the deleted bit to
1:eac0369:                         // mark the row valid.  The problem is that if this 
1:eac0369:                         // happens while we are waiting on a lock on the old
1:eac0369:                         // RowLocation then when we wake up we have the wrong 
1:eac0369:                         // lock, and the row location we fetched earlier in
1:eac0369:                         // this loop is invalid.
1:eac0369: 
1:eac0369:                             pos.current_leaf.page.fetchFromSlot(
1:eac0369:                                 (RecordHandle) null,
1:eac0369:                                 pos.current_slot, fetch_row, 
1:eac0369:                                 init_fetchDesc,
1:eac0369:                                 true);
1:eac0369: 
1:eac0369:                             latch_released =
1:eac0369:                                 !this.getLockingPolicy().lockScanRow(
1:eac0369:                                     this, 
1:eac0369:                                     pos, 
1:eac0369:                                     init_lock_fetch_desc,
1:eac0369:                                     pos.current_lock_template,
1:eac0369:                                     pos.current_lock_row_loc,
1:eac0369:                                     false, init_forUpdate, lock_operation);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 
1:eac0369: 
1:eac0369:                 if (pos.current_leaf.page.isDeletedAtSlot(pos.current_slot))
1:eac0369:                 {
1:eac0369:                     this.stat_numdeleted_rows_visited++;
1:eac0369:                     pos.current_rh_qualified = false;
1:eac0369:                 }
1:eac0369:                 else if (init_qualifier != null)
1:eac0369:                 {
1:eac0369:                     // Apply qualifiers if there are any.
1:eac0369:                     pos.current_rh_qualified = 
1:eac0369:                         this.process_qualifier(fetch_row);
1:eac0369:                 }
1:eac0369: 
1:eac0369:                 if (pos.current_rh_qualified)
1:eac0369:                 {
1:eac0369:                     // qualifying row.  Save position, release latch and return.
1:eac0369: 
1:eac0369:                     // this.current_rh is save position of scan while latch is
1:eac0369:                     // not held.  It currently points at the current_slot in
1:eac0369:                     // search (while latch is held).
1:eac0369:                     if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         SanityManager.ASSERT(
1:eac0369:                             pos.current_leaf.page.getSlotNumber(pos.current_rh)
1:eac0369:                                 == pos.current_slot);
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     // Found qualifying row.  Are we done fetching rows for the
1:eac0369:                     // group?
1:eac0369:                     ret_row_count++;
1:eac0369:                     stat_numrows_qualified++;
1:eac0369: 
1:86e051f:                     final boolean doneWithGroup = max_rowcnt <= ret_row_count;
1:86e051f: 
1:86e051f:                     if (doneWithGroup) {
1:86e051f:                         if (SanityManager.DEBUG) {
1:86e051f:                             SanityManager.ASSERT(pos == scan_position);
1:86e051f:                         }
1:86e051f:                         int[] vcols = init_fetchDesc.getValidColumnsArray();
1:86e051f:                         savePositionAndReleasePage(fetch_row, vcols);
1:86e051f:                     }
1:86e051f: 
1:eac0369:                     if (hash_table != null)
1:eac0369:                     {
1:e81e52c:                         if (hash_table.putRow(false, fetch_row, null))
1:eac0369:                             fetch_row = null;
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                     {
1:eac0369:                         fetch_row = null;
1:eac0369:                     }
1:eac0369: 
1:86e051f:                     if (doneWithGroup)
1:eac0369:                     {
1:eac0369:                         return(ret_row_count);
1:eac0369:                     }
1:eac0369:                 }
1:eac0369: 			}
1:eac0369: 
1:eac0369:             // Move position of the scan to slot 0 of the next page.  If there
1:eac0369:             // is no next page current_page will be null.
1:eac0369:             positionAtNextPage(pos);
1:eac0369: 
1:eac0369:             this.stat_numpages_visited++;
1:eac0369: 		}
1:eac0369: 
1:eac0369:         // Reached last leaf of tree.
1:eac0369:         positionAtDoneScan(pos);
1:eac0369: 
1:eac0369: 
1:eac0369:         // we need to decrement when we stop scan at the end of the table.
1:eac0369:         this.stat_numpages_visited--;
1:eac0369: 
1:eac0369: 		return(ret_row_count);
1:eac0369: 	}
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:e81e52c
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG)
1:         {
1:             // RowLocations in the BTree itself are unstable and should
1:             // not be put in long-lived structures like persistent hash tables.
1:             SanityManager.ASSERT
1:                 ( (hash_table == null) || !hash_table.includeRowLocations() );
1:         }
/////////////////////////////////////////////////////////////////////////
1:                         if (hash_table.putRow(false, fetch_row, null))
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f6fea40
/////////////////////////////////////////////////////////////////////////
1:                         this, pos,
/////////////////////////////////////////////////////////////////////////
commit:86e051f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         leaf_loop:
1:             slot_loop:
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                             "BTreeScan_fetchNextGroup", pos,
/////////////////////////////////////////////////////////////////////////
1:                 while (latch_released)
1:                     // reposition() will take care of the complexity with
1:                     // finding the correct spot to position on if the row
1:                     // has been moved to another page.
1: 
1:                     if (!reposition(pos, false))
1:                     {
1:                         // Could not position on the exact same row that was
1:                         // saved, which means that it has been purged.
1:                         // Reposition on the row immediately to the left of
1:                         // the purged row instead.
1:                         if (!reposition(pos, true))
1:                         {
1:                             if (SanityManager.DEBUG)
1:                             {
1:                                 SanityManager.THROWASSERT(
1:                                         "Cannot fail with 2nd param true");
1:                             }
1:                             // reposition will set pos.current_leaf to null if
1:                             // it returns false, so if this ever does fail in
1:                             // delivered code, expect a NullPointerException at
1:                             // the top of this loop when we call recordCount().
1:                         }
1: 
1:                         // Now we're positioned to the left of our saved
1:                         // position. Go to the top of the loop so that we move
1:                         // the scan to the next row and release the lock on
1:                         // the purged row.
1:                         continue slot_loop;
1:                     }
1: 
1:                     // At this point, the scan is positioned and the latch
1:                     // is held.
1:                     latch_released = false;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     final boolean doneWithGroup = max_rowcnt <= ret_row_count;
1: 
1:                     if (doneWithGroup) {
1:                         if (SanityManager.DEBUG) {
1:                             SanityManager.ASSERT(pos == scan_position);
1:                         }
1:                         int[] vcols = init_fetchDesc.getValidColumnsArray();
1:                         savePositionAndReleasePage(fetch_row, vcols);
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                     if (doneWithGroup)
commit:227eaef
/////////////////////////////////////////////////////////////////////////
1:   <B>Concurrency Notes</B>
commit:f962ae7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:e8e04bf
/////////////////////////////////////////////////////////////////////////
0:                         if (hash_table.putRow(false, fetch_row))
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.BTreeForwardScan
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.ScanInfo;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.impl.store.access.conglomerate.TemplateRow;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: 
1: /**
1: 
1:   A b-tree scan controller corresponds to an instance of an open b-tree scan.
1:   <P>
0:   <B>Concurrency Notes<\B>
1:   <P>
1:   The concurrency rules are derived from OpenBTree.
1:   <P>
1:   @see OpenBTree
1: 
1: **/
1: 
1: public class BTreeForwardScan extends BTreeScan
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/*
1: 	** Private/Protected methods of This class, sorted alphabetically
1: 	*/
1: 
1: 	/**
1: 	Position scan at "start" position.
1: 	<p>
1:     Positions the scan to the slot just before the first record to be returned
1:     from the scan.  Returns the start page latched, and sets "current_slot" to
1:     the slot number.
1: 
1: 	@exception  StandardException  Standard exception policy.
1: 	**/
1:     protected void positionAtStartPosition(
1:     BTreeRowPosition    pos)
1:         throws StandardException
1: 	{
1:         positionAtStartForForwardScan(pos);
1: 	}
1: 
0: 	///////////////////////////////////////////////
1: 	// 
0: 	// RESOLVE (jamie): i had to add these simple
0: 	// super.init() super.close() calls to get mssdk302
0: 	// to work.  I could not determine what the problem
0: 	// is.  For the time being, please don't remove
0: 	// them even though they don't appear to serve a
0: 	// useful purpose.
1: 	// 
0: 	///////////////////////////////////////////////
1: 	
1: 	/**
0: 	Initialize the scan for use.
1: 	<p>
0: 	Any changes to this method may have to be reflected in close as well.
1:     <p>
0:     The btree init opens the container (super.init), and stores away the
0:     state of the qualifiers.  The actual searching for the first position
0:     is delayed until the first next() call.
1: 
1: 	@exception  StandardException  Standard exception policy.
1: 	**/
0: 	public void init(
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran,
0:     boolean                         hold,
0:     int                             open_mode,
0:     int                             lock_level,
0:     BTreeLockingPolicy              btree_locking_policy,
0:     FormatableBitSet                         scanColumnList,
0:     DataValueDescriptor[]	        startKeyValue,
0:     int                             startSearchOperator,
0:     Qualifier                       qualifier[][],
0:     DataValueDescriptor[]	        stopKeyValue,
0:     int                             stopSearchOperator,
0:     BTree                           conglomerate,
0:     LogicalUndo                     undo,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:         throws StandardException
1: 	{
0: 		super.init(
0:             xact_manager, rawtran, hold, open_mode, lock_level,
0:             btree_locking_policy, scanColumnList, startKeyValue,
0:             startSearchOperator, qualifier, stopKeyValue,
0: 			stopSearchOperator, conglomerate, undo, static_info, dynamic_info);
1: 	}
1: 
1:     /**
0:     Close the scan.
1:     **/
0:     public void close()
1:         throws StandardException
1: 	{
0: 		super.close();
1: 	}
1: 
1: 
1:     /**
1:      * Fetch the next N rows from the table.
1:      * <p>
1:      * Utility routine used by both fetchSet() and fetchNextGroup().
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected int fetchRows(
1:     BTreeRowPosition        pos,
1:     DataValueDescriptor[][] row_array,
1:     RowLocation[]           rowloc_array,
1:     BackingStoreHashtable   hash_table,
1:     long                    max_rowcnt,
1:     int[]                   key_column_numbers)
1:         throws StandardException
1: 	{
1: 
1:         int                     ret_row_count     = 0;
1:         DataValueDescriptor[]   fetch_row         = null;
1:         RecordHandle            rh;
1: 
1:         if (max_rowcnt == -1)
1:             max_rowcnt = Long.MAX_VALUE;
1: 
1: 
1:         if (this.scan_state == BTreeScan.SCAN_INPROGRESS)
1:         {
1:             // reposition the scan at the row just before the next one to 
1:             // return.
1:             // This routine handles the mess of repositioning if the row or 
1:             // the page has disappeared. This can happen if a lock was not 
1:             // held on the row while not holding the latch (can happen if
1:             // this scan is read uncommitted).
1:             //
1:             // code path tested by readUncommitted.sql:TEST 1
1:             //
1:             if (!reposition(pos, true))
1:             {
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "can not fail with 2nd param true.");
1:                 }
1:             }
1: 
1:         }
1:         else if (this.scan_state == SCAN_INIT)
1:         {
1:             // 1st positioning of scan (delayed from openScan).
1:             positionAtStartPosition(pos);
1:         }
1:         else if (this.scan_state == SCAN_HOLD_INPROGRESS)
1:         {
1:             reopen();
1: 
1:             this.scan_state = SCAN_INPROGRESS;
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(scan_position.current_positionKey != null);
1:             }
1: 
1:             // reposition the scan at the row just before the next one to 
1:             // return.
1:             // This routine handles the mess of repositioning if the row or 
1:             // the page has disappeared. This can happen if a lock was not 
1:             // held on the row while not holding the latch.
1:             //
1:             // code path tested by holdCursor.sql: TEST 9
1:             if (!reposition(pos, true))
1:             {
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "can not fail with 2nd param true.");
1:                 }
1:             }
1: 
1:         }
1:         else if (this.scan_state == SCAN_HOLD_INIT)
1:         {
1:             reopen();
1: 
1:             positionAtStartForForwardScan(scan_position);
1:         }
1:         else
1:         {
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(this.scan_state == SCAN_DONE);
1: 
1:             return(0);
1:         }
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(
1:                 init_template != null, "init_template is null");
1: 		}
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(this.container != null,
1:                 "BTreeScan.next() called on a closed scan.");
1: 
1:             if (row_array != null)
1:                 SanityManager.ASSERT(row_array[0] != null,
1:                     "first array slot in fetchNextGroup() must be non-null.");
1: 
1:             // Btree's don't support RowLocations yet.
1:             if (rowloc_array != null)
1:             {
1:                 throw StandardException.newException(
1:                         SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:             }
1:         }
1: 
1:         // System.out.println("top of fetchRows, fetch_row = " + fetch_row);
1: 
1: 
1:         // At this point:
1:         // current_page is latched.  current_slot is the slot on current_page
1:         // just before the "next" record this routine should process.
1: 
1:         // loop through successive leaf pages and successive slots on those
1:         // leaf pages.  Stop when either the last leaf is reached (current_page
1:         // will be null), or when stopKeyValue is reached/passed.  Along the
1:         // way apply qualifiers to skip rows which don't qualify.
1: 
1: 		while (pos.current_leaf != null)
1: 		{
1:             // System.out.println(
1:               //   "1 of fetchSet loop, ret_row_count = " + ret_row_count +
1:                 // "fetch_row = " + fetch_row);
1: 
1: 			while ((pos.current_slot + 1) < pos.current_leaf.page.recordCount())
1: 			{
1: 
1:                 // System.out.println(
1:                 // "2 of fetchSet loop, ret_row_count = " + ret_row_count +
1:                 // "fetch_row = " + fetch_row + 
1:                 // "hash_table = " + hash_table);
1: 
1: 
1:                 // unlock the previous row if doing read.
1:                 if (pos.current_rh != null)
1:                 {
1:                     this.getLockingPolicy().unlockScanRecordAfterRead(
1:                         pos, init_forUpdate);
1: 
1:                     // current_rh is used to track which row we need to unlock,
1:                     // at this point no row needs to be unlocked.
1:                     pos.current_rh = null;
1:                 }
1: 
1:                 // Allocate a new row to read the row into.
1:                 if (fetch_row == null)
1:                 {
1:                     if (hash_table == null)
1:                     {
1:                         // point at allocated row in array if one exists.
1:                         if (row_array[ret_row_count] == null)
1:                         {
1:                             row_array[ret_row_count] = 
0:                                 runtime_mem.get_row_for_export();
1:                         }
1: 
1:                         fetch_row = row_array[ret_row_count];
1:                     }
1:                     else
1:                     {
1:                         // get a brand new row.
0:                         fetch_row = runtime_mem.get_row_for_export(); 
1:                     }
1:                 }
1: 
1:                 // move scan current position forward.
1:                 pos.current_slot++;
1:                 this.stat_numrows_visited++;
1: 
1:                 rh =
1:                     pos.current_leaf.page.fetchFromSlot(
1:                         (RecordHandle) null,
1:                         pos.current_slot, fetch_row, 
1:                         init_fetchDesc,
1:                         true);
1: 
1: 
1:                 pos.current_rh_qualified = true;
1: 
1:                 // See if this is the stop row.
1:                 if (init_stopKeyValue != null)
1:                 {
1:                     // See if current row is the >= the stopKeyValue.
1:                     //
1:                     // ret >  0: key is greater than row on page.
1:                     // ret == 0: key is exactly the row on page if full key,
1:                     //           or partial match if partial key.
1:                     // ret <  0: key is less    than row on page.
1:                     //
0:                     int ret = ControlRow.CompareIndexRowToKey(
1:                                 fetch_row,
1:                                 init_stopKeyValue,
1:                                 fetch_row.length,
1:                                 0, this.getConglomerate().ascDescInfo);
1: 
1:                     if ((ret == 0) && 
1:                         (init_stopSearchOperator == ScanController.GE))
1:                     {
1:                         // if (partial) matched and stop is GE, end the scan.
1:                         ret = 1;
1:                     }
1: 
1:                     if (ret > 0)
1:                     {
1:                         // This is the first non-qualifying row. We're done.
1: 
1:                         pos.current_leaf.release();
1:                         pos.current_leaf = null;
1:                         positionAtDoneScan(pos);
1: 
1:                         return(ret_row_count);
1:                     }
1:                 }
1: 
1: 
1:                 // Only lock rows that are < the stopKeyValue.  No need to
1:                 // requalify against stop position after losing the latch
1:                 // as the only change that could have happened is that the
1:                 // row was marked deleted - the key value cannot change.
1:                 boolean latch_released =
1:                     !this.getLockingPolicy().lockScanRow(
0:                         this, this.getConglomerate(), pos, 
0:                         false, 
1:                         init_lock_fetch_desc,
1:                         pos.current_lock_template,
1:                         pos.current_lock_row_loc,
1:                         false, init_forUpdate, lock_operation);
1: 
1:                 // special test to see if latch release code works
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     latch_released = 
1:                         test_errors(
1:                             this,
0:                             "BTreeScan_fetchNextGroup", false, 
1:                             this.getLockingPolicy(),
1:                             pos.current_leaf, latch_released);
1:                 }
1: 
1:                 // At this point we have successfully locked this record, so
1:                 // remember the record handle so that it can be unlocked if
1:                 // necessary.  If the above lock deadlocks, we will not try
1:                 // to unlock a lock we never got in close(), because current_rh
1:                 // is null until after the lock is granted.
1:                 pos.current_rh = rh;
1: 
0:                 if (latch_released)
1:                 {
1:                     // lost latch on page in order to wait for row lock.
0:                     // Because we have scan lock on page, we need only
0:                     // call reposition() which will use the saved record
0:                     // handle to reposition to the same spot on the page.
0:                     // We don't have to search the
0:                     // tree again, as we have the a scan lock on the page
0:                     // which means the current_rh is valid to reposition on.
1: 
1:                     if (this.getConglomerate().isUnique())
1:                     {
1:                         // Handle row location changing since lock request was 
1:                         // initiated.
1:                         // In unique indexes, there is one case where an index 
1:                         // row can have it's data lock key change (this usually
1:                         // cannot happen because only inserts and deletes are 
1:                         // allowed - no updates).  This case is an insert of a 
1:                         // key, that exactly matches a committed deleted row, 
1:                         // in a unique index.  In that case the code updates 
1:                         // the RowLocation column and flips the deleted bit to
1:                         // mark the row valid.  The problem is that if this 
1:                         // happens while we are waiting on a lock on the old
1:                         // RowLocation then when we wake up we have the wrong 
1:                         // lock, and the row location we fetched earlier in
1:                         // this loop is invalid.
1: 
0:                         while (latch_released)
1:                         {
0:                             if (!reposition(pos, false))
1:                             {
1:                                 if (SanityManager.DEBUG)
1:                                 {
0:                                     // can't fail while with scan lock
1:                                     SanityManager.THROWASSERT(
0:                                         "can not fail holding scan lock.");
1:                                 }
1: 
0:                                 // reposition will set pos.current_leaf to 
0:                                 // null, if it returns false so if the this
0:                                 // ever does fail in delivered code, expect
0:                                 // a null pointer exception on the next line,
0:                                 // trying to call fetchFromSlot().
1: 
1:                             }
1: 
1:                             pos.current_leaf.page.fetchFromSlot(
1:                                 (RecordHandle) null,
1:                                 pos.current_slot, fetch_row, 
1:                                 init_fetchDesc,
1:                                 true);
1: 
1:                             latch_released =
1:                                 !this.getLockingPolicy().lockScanRow(
1:                                     this, 
0:                                     this.getConglomerate(), 
1:                                     pos, 
0:                                     false, 
1:                                     init_lock_fetch_desc,
1:                                     pos.current_lock_template,
1:                                     pos.current_lock_row_loc,
1:                                     false, init_forUpdate, lock_operation);
1:                         }
1:                     }
1:                     else
1:                     {
0:                         if (!reposition(pos, false))
1:                         {
1:                             if (SanityManager.DEBUG)
1:                             {
0:                                 // can't fail while with scan lock
1:                                 SanityManager.THROWASSERT(
0:                                     "can not fail holding scan lock.");
1:                             }
1: 
0:                             // reposition will set pos.current_leaf to 
0:                             // null, if it returns false so if the this
0:                             // ever does fail in delivered code, expect
0:                             // a null pointer exception on the next line,
0:                             // trying to call isDeletedAtSlot().
1: 
1:                         }
1: 
1:                     }
1:                 }
1: 
1: 
1:                 if (pos.current_leaf.page.isDeletedAtSlot(pos.current_slot))
1:                 {
1:                     this.stat_numdeleted_rows_visited++;
1:                     pos.current_rh_qualified = false;
1:                 }
1:                 else if (init_qualifier != null)
1:                 {
1:                     // Apply qualifiers if there are any.
1:                     pos.current_rh_qualified = 
1:                         this.process_qualifier(fetch_row);
1:                 }
1: 
1:                 if (pos.current_rh_qualified)
1:                 {
1:                     // qualifying row.  Save position, release latch and return.
1: 
1:                     // this.current_rh is save position of scan while latch is
1:                     // not held.  It currently points at the current_slot in
1:                     // search (while latch is held).
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         SanityManager.ASSERT(
1:                             pos.current_leaf.page.getSlotNumber(pos.current_rh)
1:                                 == pos.current_slot);
1:                     }
1: 
1:                     // Found qualifying row.  Are we done fetching rows for the
1:                     // group?
1:                     ret_row_count++;
1:                     stat_numrows_qualified++;
1: 
1:                     if (hash_table != null)
1:                     {
0:                         if (hash_table.put(false, fetch_row))
1:                             fetch_row = null;
1:                     }
1:                     else
1:                     {
1:                         fetch_row = null;
1:                     }
1: 
0:                     if (max_rowcnt <= ret_row_count) 
1:                     {
0:                         // current_slot is invalid after releasing latch
0:                         pos.current_slot = Page.INVALID_SLOT_NUMBER;
1: 
0:                         // exit fetch row loop and return to the client.
1:                         pos.current_leaf.release();
1:                         pos.current_leaf = null;
1: 
1:                         return(ret_row_count);
1:                     }
1:                 }
1: 			}
1: 
1:             // Move position of the scan to slot 0 of the next page.  If there
1:             // is no next page current_page will be null.
1:             positionAtNextPage(pos);
1: 
1:             this.stat_numpages_visited++;
1: 		}
1: 
1:         // Reached last leaf of tree.
1:         positionAtDoneScan(pos);
1: 
1: 
1:         // we need to decrement when we stop scan at the end of the table.
1:         this.stat_numpages_visited--;
1: 
1: 		return(ret_row_count);
1: 	}
1: }
1: 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:                                 runtime_mem.get_row_for_export(getRawTran());
/////////////////////////////////////////////////////////////////////////
1:                         fetch_row = 
1:                             runtime_mem.get_row_for_export(getRawTran()); 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:                     int ret = ControlRow.compareIndexRowToKey(
commit:fa09146
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.ScanInfo;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.impl.store.access.conglomerate.TemplateRow;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: 
0: /**
0: 
0:   A b-tree scan controller corresponds to an instance of an open b-tree scan.
0:   <P>
0:   <B>Concurrency Notes<\B>
0:   <P>
0:   The concurrency rules are derived from OpenBTree.
0:   <P>
0:   @see OpenBTree
0: 
0: **/
0: 
0: public class BTreeForwardScan extends BTreeScan
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/*
0: 	** Private/Protected methods of This class, sorted alphabetically
0: 	*/
0: 
0: 	/**
0: 	Position scan at "start" position.
0: 	<p>
0:     Positions the scan to the slot just before the first record to be returned
0:     from the scan.  Returns the start page latched, and sets "current_slot" to
0:     the slot number.
0: 
0: 	@exception  StandardException  Standard exception policy.
0: 	**/
0:     protected void positionAtStartPosition(
0:     BTreeRowPosition    pos)
0:         throws StandardException
0: 	{
0:         positionAtStartForForwardScan(pos);
0: 	}
0: 
0: 	///////////////////////////////////////////////
0: 	// 
0: 	// RESOLVE (jamie): i had to add these simple
0: 	// super.init() super.close() calls to get mssdk302
0: 	// to work.  I could not determine what the problem
0: 	// is.  For the time being, please don't remove
0: 	// them even though they don't appear to serve a
0: 	// useful purpose.
0: 	// 
0: 	///////////////////////////////////////////////
0: 	
0: 	/**
0: 	Initialize the scan for use.
0: 	<p>
0: 	Any changes to this method may have to be reflected in close as well.
0:     <p>
0:     The btree init opens the container (super.init), and stores away the
0:     state of the qualifiers.  The actual searching for the first position
0:     is delayed until the first next() call.
0: 
0: 	@exception  StandardException  Standard exception policy.
0: 	**/
0: 	public void init(
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran,
0:     boolean                         hold,
0:     int                             open_mode,
0:     int                             lock_level,
0:     BTreeLockingPolicy              btree_locking_policy,
0:     FormatableBitSet                         scanColumnList,
0:     DataValueDescriptor[]	        startKeyValue,
0:     int                             startSearchOperator,
0:     Qualifier                       qualifier[][],
0:     DataValueDescriptor[]	        stopKeyValue,
0:     int                             stopSearchOperator,
0:     BTree                           conglomerate,
0:     LogicalUndo                     undo,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0:         throws StandardException
0: 	{
0: 		super.init(
0:             xact_manager, rawtran, hold, open_mode, lock_level,
0:             btree_locking_policy, scanColumnList, startKeyValue,
0:             startSearchOperator, qualifier, stopKeyValue,
0: 			stopSearchOperator, conglomerate, undo, static_info, dynamic_info);
0: 	}
0: 
0:     /**
0:     Close the scan.
0:     **/
0:     public void close()
0:         throws StandardException
0: 	{
0: 		super.close();
0: 	}
0: 
0: 
0:     /**
0:      * Fetch the next N rows from the table.
0:      * <p>
0:      * Utility routine used by both fetchSet() and fetchNextGroup().
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected int fetchRows(
0:     BTreeRowPosition        pos,
0:     DataValueDescriptor[][] row_array,
0:     RowLocation[]           rowloc_array,
0:     BackingStoreHashtable   hash_table,
0:     long                    max_rowcnt,
0:     int[]                   key_column_numbers)
0:         throws StandardException
0: 	{
0: 
0:         int                     ret_row_count     = 0;
0:         DataValueDescriptor[]   fetch_row         = null;
0:         RecordHandle            rh;
0: 
0:         if (max_rowcnt == -1)
0:             max_rowcnt = Long.MAX_VALUE;
0: 
0: 
0:         if (this.scan_state == BTreeScan.SCAN_INPROGRESS)
0:         {
0:             // reposition the scan at the row just before the next one to 
0:             // return.
0:             // This routine handles the mess of repositioning if the row or 
0:             // the page has disappeared. This can happen if a lock was not 
0:             // held on the row while not holding the latch (can happen if
0:             // this scan is read uncommitted).
0:             //
0:             // code path tested by readUncommitted.sql:TEST 1
0:             //
0:             if (!reposition(pos, true))
0:             {
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "can not fail with 2nd param true.");
0:                 }
0:             }
0: 
0:         }
0:         else if (this.scan_state == SCAN_INIT)
0:         {
0:             // 1st positioning of scan (delayed from openScan).
0:             positionAtStartPosition(pos);
0:         }
0:         else if (this.scan_state == SCAN_HOLD_INPROGRESS)
0:         {
0:             reopen();
0: 
0:             this.scan_state = SCAN_INPROGRESS;
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(scan_position.current_positionKey != null);
0:             }
0: 
0:             // reposition the scan at the row just before the next one to 
0:             // return.
0:             // This routine handles the mess of repositioning if the row or 
0:             // the page has disappeared. This can happen if a lock was not 
0:             // held on the row while not holding the latch.
0:             //
0:             // code path tested by holdCursor.sql: TEST 9
0:             if (!reposition(pos, true))
0:             {
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "can not fail with 2nd param true.");
0:                 }
0:             }
0: 
0:         }
0:         else if (this.scan_state == SCAN_HOLD_INIT)
0:         {
0:             reopen();
0: 
0:             positionAtStartForForwardScan(scan_position);
0:         }
0:         else
0:         {
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(this.scan_state == SCAN_DONE);
0: 
0:             return(0);
0:         }
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(
0:                 init_template != null, "init_template is null");
0: 		}
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(this.container != null,
0:                 "BTreeScan.next() called on a closed scan.");
0: 
0:             if (row_array != null)
0:                 SanityManager.ASSERT(row_array[0] != null,
0:                     "first array slot in fetchNextGroup() must be non-null.");
0: 
0:             // Btree's don't support RowLocations yet.
0:             if (rowloc_array != null)
0:             {
0:                 throw StandardException.newException(
0:                         SQLState.BTREE_UNIMPLEMENTED_FEATURE);
0:             }
0:         }
0: 
0:         // System.out.println("top of fetchRows, fetch_row = " + fetch_row);
0: 
0: 
0:         // At this point:
0:         // current_page is latched.  current_slot is the slot on current_page
0:         // just before the "next" record this routine should process.
0: 
0:         // loop through successive leaf pages and successive slots on those
0:         // leaf pages.  Stop when either the last leaf is reached (current_page
0:         // will be null), or when stopKeyValue is reached/passed.  Along the
0:         // way apply qualifiers to skip rows which don't qualify.
0: 
0: 		while (pos.current_leaf != null)
0: 		{
0:             // System.out.println(
0:               //   "1 of fetchSet loop, ret_row_count = " + ret_row_count +
0:                 // "fetch_row = " + fetch_row);
0: 
0: 			while ((pos.current_slot + 1) < pos.current_leaf.page.recordCount())
0: 			{
0: 
0:                 // System.out.println(
0:                 // "2 of fetchSet loop, ret_row_count = " + ret_row_count +
0:                 // "fetch_row = " + fetch_row + 
0:                 // "hash_table = " + hash_table);
0: 
0: 
0:                 // unlock the previous row if doing read.
0:                 if (pos.current_rh != null)
0:                 {
0:                     this.getLockingPolicy().unlockScanRecordAfterRead(
0:                         pos, init_forUpdate);
0: 
0:                     // current_rh is used to track which row we need to unlock,
0:                     // at this point no row needs to be unlocked.
0:                     pos.current_rh = null;
0:                 }
0: 
0:                 // Allocate a new row to read the row into.
0:                 if (fetch_row == null)
0:                 {
0:                     if (hash_table == null)
0:                     {
0:                         // point at allocated row in array if one exists.
0:                         if (row_array[ret_row_count] == null)
0:                         {
0:                             row_array[ret_row_count] = 
0:                                 runtime_mem.get_row_for_export();
0:                         }
0: 
0:                         fetch_row = row_array[ret_row_count];
0:                     }
0:                     else
0:                     {
0:                         // get a brand new row.
0:                         fetch_row = runtime_mem.get_row_for_export(); 
0:                     }
0:                 }
0: 
0:                 // move scan current position forward.
0:                 pos.current_slot++;
0:                 this.stat_numrows_visited++;
0: 
0:                 rh =
0:                     pos.current_leaf.page.fetchFromSlot(
0:                         (RecordHandle) null,
0:                         pos.current_slot, fetch_row, 
0:                         init_fetchDesc,
0:                         true);
0: 
0: 
0:                 pos.current_rh_qualified = true;
0: 
0:                 // See if this is the stop row.
0:                 if (init_stopKeyValue != null)
0:                 {
0:                     // See if current row is the >= the stopKeyValue.
0:                     //
0:                     // ret >  0: key is greater than row on page.
0:                     // ret == 0: key is exactly the row on page if full key,
0:                     //           or partial match if partial key.
0:                     // ret <  0: key is less    than row on page.
0:                     //
0:                     int ret = ControlRow.CompareIndexRowToKey(
0:                                 fetch_row,
0:                                 init_stopKeyValue,
0:                                 fetch_row.length,
0:                                 0, this.getConglomerate().ascDescInfo);
0: 
0:                     if ((ret == 0) && 
0:                         (init_stopSearchOperator == ScanController.GE))
0:                     {
0:                         // if (partial) matched and stop is GE, end the scan.
0:                         ret = 1;
0:                     }
0: 
0:                     if (ret > 0)
0:                     {
0:                         // This is the first non-qualifying row. We're done.
0: 
0:                         pos.current_leaf.release();
0:                         pos.current_leaf = null;
0:                         positionAtDoneScan(pos);
0: 
0:                         return(ret_row_count);
0:                     }
0:                 }
0: 
0: 
0:                 // Only lock rows that are < the stopKeyValue.  No need to
0:                 // requalify against stop position after losing the latch
0:                 // as the only change that could have happened is that the
0:                 // row was marked deleted - the key value cannot change.
0:                 boolean latch_released =
0:                     !this.getLockingPolicy().lockScanRow(
0:                         this, this.getConglomerate(), pos, 
0:                         false, 
0:                         init_lock_fetch_desc,
0:                         pos.current_lock_template,
0:                         pos.current_lock_row_loc,
0:                         false, init_forUpdate, lock_operation);
0: 
0:                 // special test to see if latch release code works
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     latch_released = 
0:                         test_errors(
0:                             this,
0:                             "BTreeScan_fetchNextGroup", false, 
0:                             this.getLockingPolicy(),
0:                             pos.current_leaf, latch_released);
0:                 }
0: 
0:                 // At this point we have successfully locked this record, so
0:                 // remember the record handle so that it can be unlocked if
0:                 // necessary.  If the above lock deadlocks, we will not try
0:                 // to unlock a lock we never got in close(), because current_rh
0:                 // is null until after the lock is granted.
0:                 pos.current_rh = rh;
0: 
0:                 if (latch_released)
0:                 {
0:                     // lost latch on page in order to wait for row lock.
0:                     // Because we have scan lock on page, we need only
0:                     // call reposition() which will use the saved record
0:                     // handle to reposition to the same spot on the page.
0:                     // We don't have to search the
0:                     // tree again, as we have the a scan lock on the page
0:                     // which means the current_rh is valid to reposition on.
0: 
0:                     if (this.getConglomerate().isUnique())
0:                     {
0:                         // Handle row location changing since lock request was 
0:                         // initiated.
0:                         // In unique indexes, there is one case where an index 
0:                         // row can have it's data lock key change (this usually
0:                         // cannot happen because only inserts and deletes are 
0:                         // allowed - no updates).  This case is an insert of a 
0:                         // key, that exactly matches a committed deleted row, 
0:                         // in a unique index.  In that case the code updates 
0:                         // the RowLocation column and flips the deleted bit to
0:                         // mark the row valid.  The problem is that if this 
0:                         // happens while we are waiting on a lock on the old
0:                         // RowLocation then when we wake up we have the wrong 
0:                         // lock, and the row location we fetched earlier in
0:                         // this loop is invalid.
0: 
0:                         while (latch_released)
0:                         {
0:                             if (!reposition(pos, false))
0:                             {
0:                                 if (SanityManager.DEBUG)
0:                                 {
0:                                     // can't fail while with scan lock
0:                                     SanityManager.THROWASSERT(
0:                                         "can not fail holding scan lock.");
0:                                 }
0: 
0:                                 // reposition will set pos.current_leaf to 
0:                                 // null, if it returns false so if the this
0:                                 // ever does fail in delivered code, expect
0:                                 // a null pointer exception on the next line,
0:                                 // trying to call fetchFromSlot().
0: 
0:                             }
0: 
0:                             pos.current_leaf.page.fetchFromSlot(
0:                                 (RecordHandle) null,
0:                                 pos.current_slot, fetch_row, 
0:                                 init_fetchDesc,
0:                                 true);
0: 
0:                             latch_released =
0:                                 !this.getLockingPolicy().lockScanRow(
0:                                     this, 
0:                                     this.getConglomerate(), 
0:                                     pos, 
0:                                     false, 
0:                                     init_lock_fetch_desc,
0:                                     pos.current_lock_template,
0:                                     pos.current_lock_row_loc,
0:                                     false, init_forUpdate, lock_operation);
0:                         }
0:                     }
0:                     else
0:                     {
0:                         if (!reposition(pos, false))
0:                         {
0:                             if (SanityManager.DEBUG)
0:                             {
0:                                 // can't fail while with scan lock
0:                                 SanityManager.THROWASSERT(
0:                                     "can not fail holding scan lock.");
0:                             }
0: 
0:                             // reposition will set pos.current_leaf to 
0:                             // null, if it returns false so if the this
0:                             // ever does fail in delivered code, expect
0:                             // a null pointer exception on the next line,
0:                             // trying to call isDeletedAtSlot().
0: 
0:                         }
0: 
0:                     }
0:                 }
0: 
0: 
0:                 if (pos.current_leaf.page.isDeletedAtSlot(pos.current_slot))
0:                 {
0:                     this.stat_numdeleted_rows_visited++;
0:                     pos.current_rh_qualified = false;
0:                 }
0:                 else if (init_qualifier != null)
0:                 {
0:                     // Apply qualifiers if there are any.
0:                     pos.current_rh_qualified = 
0:                         this.process_qualifier(fetch_row);
0:                 }
0: 
0:                 if (pos.current_rh_qualified)
0:                 {
0:                     // qualifying row.  Save position, release latch and return.
0: 
0:                     // this.current_rh is save position of scan while latch is
0:                     // not held.  It currently points at the current_slot in
0:                     // search (while latch is held).
0:                     if (SanityManager.DEBUG)
0:                     {
0:                         SanityManager.ASSERT(
0:                             pos.current_leaf.page.getSlotNumber(pos.current_rh)
0:                                 == pos.current_slot);
0:                     }
0: 
0:                     // Found qualifying row.  Are we done fetching rows for the
0:                     // group?
0:                     ret_row_count++;
0:                     stat_numrows_qualified++;
0: 
0:                     if (hash_table != null)
0:                     {
0:                         if (hash_table.put(false, fetch_row))
0:                             fetch_row = null;
0:                     }
0:                     else
0:                     {
0:                         fetch_row = null;
0:                     }
0: 
0:                     if (max_rowcnt <= ret_row_count) 
0:                     {
0:                         // current_slot is invalid after releasing latch
0:                         pos.current_slot = Page.INVALID_SLOT_NUMBER;
0: 
0:                         // exit fetch row loop and return to the client.
0:                         pos.current_leaf.release();
0:                         pos.current_leaf = null;
0: 
0:                         return(ret_row_count);
0:                     }
0:                 }
0: 			}
0: 
0:             // Move position of the scan to slot 0 of the next page.  If there
0:             // is no next page current_page will be null.
0:             positionAtNextPage(pos);
0: 
0:             this.stat_numpages_visited++;
0: 		}
0: 
0:         // Reached last leaf of tree.
0:         positionAtDoneScan(pos);
0: 
0: 
0:         // we need to decrement when we stop scan at the end of the table.
0:         this.stat_numpages_visited--;
0: 
0: 		return(ret_row_count);
0: 	}
0: }
0: 
============================================================================