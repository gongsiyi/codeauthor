1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.HalfOuterJoinNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
16:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.util.Properties;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:eac0369: import org.apache.derby.iapi.sql.compile.Optimizable;
1:eac0369: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * An HalfOuterJoinNode represents a left or a right outer join result set.
1:eac0369:  * Right outer joins are always transformed into left outer joins during
1:eac0369:  * preprocessing for simplicity.
1:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class HalfOuterJoinNode extends JoinNode
10:eac0369: {
1:eac0369: 	private boolean rightOuterJoin;
1:eac0369: 	private boolean transformed = false;
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a HalfOuterJoinNode.
1:eac0369: 	 *
1:eac0369: 	 * @param leftResult		The ResultSetNode on the left side of this join
1:eac0369: 	 * @param rightResult		The ResultSetNode on the right side of this join
1:eac0369: 	 * @param onClause			The ON clause
1:eac0369: 	 * @param usingClause		The USING clause
1:eac0369: 	 * @param rightOuterJoin	Whether or not this node represents a user
1:eac0369: 	 *							specified right outer join
1:eac0369: 	 * @param tableProperties	Properties list associated with the table
1:3bb140c:      * @param cm                The context manager
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     HalfOuterJoinNode(ResultSetNode leftResult,
1:3bb140c:                       ResultSetNode rightResult,
1:3bb140c:                       ValueNode onClause,
1:3bb140c:                       ResultColumnList usingClause,
1:3bb140c:                       boolean rightOuterJoin,
1:3bb140c:                       Properties tableProperties,
1:3bb140c:                       ContextManager cm)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:3bb140c:         super(  leftResult,
1:3bb140c:                 rightResult,
1:3bb140c:                 onClause,
1:3bb140c:                 usingClause,
1:3bb140c:                 null,
1:c7248d5: 				tableProperties,
1:3bb140c:                 null,
1:3bb140c:                 cm);
1:3bb140c:         this.rightOuterJoin = rightOuterJoin;
1:eac0369: 
1:eac0369: 		/* We can only flatten an outer join
1:eac0369: 		 * using the null intolerant predicate xform.
1:eac0369: 		 * In that case, we will return an InnerJoin.
1:eac0369: 		 */
1:eac0369: 		flattenableJoin = false;
12:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 *  Optimizable interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#pushOptPredicate
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We should never push the predicate to joinPredicates as in JoinNode.  joinPredicates
1:eac0369: 		 * should only be predicates relating the two joining tables.  In the case of half join,
1:eac0369: 		 * it is biased.  If the general predicate (not join predicate) contains refernce to right
1:eac0369: 		 * result set, and if doesn't qualify, we shouldn't return the row for the result to be
1:eac0369: 		 * correct, but half join will fill right side NULL and return the row.  So we can only
1:eac0369: 		 * push predicate to the left, as we do in "pushExpression".  bug 5055
1:eac0369: 		 */
1:eac0369: 		FromTable		leftFromTable = (FromTable) leftResultSet;
1:eac0369: 		if (leftFromTable.getReferencedTableMap().contains(optimizablePredicate.getReferencedMap()))
1:eac0369: 			return leftFromTable.pushOptPredicate(optimizablePredicate);
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1:eac0369: 	 * for how this should be done for tree printing.
1:eac0369: 	 *
1:eac0369: 	 * @return	This object as a String
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			return 	"rightOuterJoin: " + rightOuterJoin + "\n" +
1:eac0369: 				"transformed: " + transformed + "\n" + 
1:eac0369: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:1c8ca70: 
1:eac0369: 	/** 
1:eac0369: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1:eac0369: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1:eac0369: 	 * that ResultColumn must percolate up to the new PRN.  However,
1:eac0369: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1:eac0369: 	 * which points to the FromTable and the ResultColumn that is the source for
1:eac0369: 	 * the ColumnReference.  
1:eac0369: 	 * (The new PRN will have the original of the ResultColumnList and
1:eac0369: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1:eac0369: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1:eac0369: 	 * will remain at the FromTable, with the PRN getting a new 
1:eac0369: 	 * VirtualColumnNode for each ResultColumn.expression.)
1:eac0369: 	 * We then project out the non-referenced columns.  If there are no referenced
1:eac0369: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1:eac0369: 	 * whose expression is 1.
1:eac0369: 	 *
1:eac0369: 	 * @param numTables			Number of tables in the DML Statement
1:eac0369: 	 * @param gbl				The group by list, if any
1:eac0369: 	 * @param fromList			The from list, if any
1:eac0369: 	 *
1:eac0369: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     ResultSetNode preprocess(int numTables,
1:eac0369: 									GroupByList gbl,
1:eac0369: 									FromList fromList)
1:eac0369: 								throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultSetNode newTreeTop;
1:eac0369: 
1:eac0369: 		/* Transform right outer joins to the equivalent left outer join */
1:eac0369: 		if (rightOuterJoin)
1:eac0369: 		{
1:eac0369: 			/* Verify that a user specifed right outer join is transformed into
1:eac0369: 			 * a left outer join exactly once.
1:eac0369: 			 */
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(! transformed,
1:eac0369: 					"Attempting to transform a right outer join multiple times");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			ResultSetNode tmp = leftResultSet;
1:eac0369: 
1:eac0369: 			leftResultSet = rightResultSet;
1:eac0369: 			rightResultSet = tmp;
1:eac0369: 			transformed = true;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		newTreeTop = super.preprocess(numTables, gbl, fromList);
1:eac0369: 
1:eac0369: 		return newTreeTop;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Push expressions down to the first ResultSetNode which can do expression
1:eac0369: 	 * evaluation and has the same referenced table map.
1:eac0369: 	 * RESOLVE - This means only pushing down single table expressions to
1:eac0369: 	 * DistinctNodes today.  Once we have a better understanding of how
1:eac0369: 	 * the optimizer will work, we can push down join clauses.
1:eac0369: 	 *
1:eac0369: 	 * @param outerPredicateList	The PredicateList from the outer RS.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void pushExpressions(PredicateList outerPredicateList)
1:eac0369: 					throws StandardException
1:eac0369: 	{
1:eac0369: 		FromTable		leftFromTable = (FromTable) leftResultSet;
1:eac0369: 		FromTable		rightFromTable = (FromTable) rightResultSet;
1:eac0369: 
1:eac0369: 		/* We only try to push single table predicates to the left.
1:eac0369: 		 * Pushing them to the right would give incorrect semantics.
1:eac0369: 		 * We use the logic for pushing down single table predicates here.
1:eac0369: 		 */
1:eac0369: 		pushExpressionsToLeft(outerPredicateList);
1:eac0369: 
1:eac0369: 		/* Push the pushable outer join predicates to the right.  This is done
1:eac0369: 		 * bottom up, hence at the end of this method, so that outer join
1:eac0369: 		 * conditions only get pushed down 1 level.
1:eac0369: 		 * We use the optimizer's logic for pushing down join clause here.
1:eac0369: 		 */
1:eac0369: 		// Walk joinPredicates backwards due to possible deletes
1:eac0369: 		for (int index = joinPredicates.size() - 1; index >= 0; index --)
1:eac0369: 		{
1:eac0369: 			Predicate predicate;
1:eac0369: 
1:e1f49ca:             predicate = joinPredicates.elementAt(index);
1:eac0369: 			if (! predicate.getPushable())
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			getRightPredicateList().addPredicate(predicate);
1:eac0369: 
1:eac0369: 			/* Remove the matching predicate from the outer list */
1:eac0369: 			joinPredicates.removeElementAt(index);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Recurse down both sides of tree */
1:3bb140c:         PredicateList noPredicates = new PredicateList(getContextManager());
1:eac0369: 		leftFromTable.pushExpressions(getLeftPredicateList());
1:eac0369: 		rightFromTable.pushExpressions(noPredicates);
1:eac0369: 	}
1:eac0369: 
1:1c8ca70:     /**
1:1c8ca70:      * This method recursively:
1:1c8ca70:      * <ul>
1:1c8ca70:      *    <li>determines if this part of the query tree is a compound OJ of
1:1c8ca70:      *            the shape required for reordering and if so,</li>
1:1c8ca70:      *    <li>does a reordering.</li>
1:1c8ca70:      * </ul>
1:1c8ca70:      * <pre>
1:1c8ca70:      *
1:1c8ca70:      *    OJ1  pT1T2                      OJ1  pT2T3
1:1c8ca70:      *   /  \                             / \
1:1c8ca70:      *  /    \                 can       /   t3
1:1c8ca70:      * t1    OJ2 pT2T3       reorder    /
1:1c8ca70:      *       /  \              to      OJ2  pT1T2
1:1c8ca70:      *      /    \                    /   \
1:1c8ca70:      *     t2    t3                  /     \
1:1c8ca70:      *                             t1     t2
1:1c8ca70:      *
1:1c8ca70:      * where pR1R2 is a null-rejecting predicate which references the schema
1:1c8ca70:      * of joinee R1 and R2, cf. terminology explanation in #isNullRejecting.
1:1c8ca70:      * <p/>
1:1c8ca70:      * OJ1 represents <em>this</em> before and after the reordering.
1:1c8ca70:      * </pre>
1:1c8ca70:      * <p/>
1:1c8ca70:      * The join predicates are assumed to be in CNF form.
1:1c8ca70:      * <p/>
1:1c8ca70:      * <em>Note:</em> Present implementation limitations
1:1c8ca70:      * <ul>
1:1c8ca70:      *   <li>Only left outer joins are considered, i.e. both OJs in diagram
1:1c8ca70:      *       above must be LOJ.</li>
1:1c8ca70:      *   <li>Top left side must be a base table (t1 above). The bottow right
1:1c8ca70:      *       side
1:1c8ca70: *       (t3 above) may be another OJ, so reordering can happen
1:1c8ca70:      *       recursively.</li>
1:1c8ca70:      * </ul>
1:1c8ca70:      *
1:1c8ca70:      * @param numTables number of tables involved (needed to right size the
1:1c8ca70:      *                  bitmaps)
1:1c8ca70:      * @return boolean true if any reordering took place at this level or deeper
1:1c8ca70:      *                 so caller can know whether rebinding may be necessary
1:1c8ca70:      * @throws StandardException standard error policy
1:1c8ca70:      */
1:3bb140c:     @Override
1:3bb140c:     boolean LOJ_reorderable(int numTables)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		boolean anyChange = false;
1:eac0369: 
1:eac0369: 		ResultSetNode logicalLeftResultSet;  // row-preserving side
1:eac0369: 		ResultSetNode logicalRightResultSet; // null-producing side
1:eac0369: 
1:eac0369: 		// Figure out which is the row-preserving side and which is
1:eac0369: 		// null-producing side.
1:eac0369: 		if (rightOuterJoin)
1:eac0369: 		{ // right outer join
1:eac0369: 			logicalLeftResultSet  = rightResultSet;
1:eac0369: 			logicalRightResultSet = leftResultSet;
1:eac0369: 		}
1:eac0369: 		else 
1:eac0369: 		{
1:eac0369: 			logicalLeftResultSet  = leftResultSet;
1:eac0369: 			logicalRightResultSet = rightResultSet;
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		// Redundantly normalize the ON predicate (it will also be called in preprocess()).
1:eac0369: 		super.normExpressions();
1:eac0369: 
1:1c8ca70:         // This is a very simple OJ of base tables. Do nothing.
1:eac0369: 		if (logicalLeftResultSet instanceof FromBaseTable &&
1:eac0369: 			logicalRightResultSet instanceof FromBaseTable)
1:eac0369: 			return anyChange;
1:eac0369: 
1:1c8ca70:         // Recursively check if we can reordering OJ, and build the table
1:eac0369: 		// references. Note that joins may have been reordered and therefore the
1:eac0369: 		// table references need to be recomputed.
1:eac0369: 		if (logicalLeftResultSet instanceof HalfOuterJoinNode)
1:eac0369: 		{
1:eac0369: 			anyChange =	((HalfOuterJoinNode)logicalLeftResultSet).LOJ_reorderable(numTables) || anyChange;
1:eac0369: 		}
1:eac0369: 		else if (!(logicalLeftResultSet instanceof FromBaseTable))
1:1c8ca70:         {// left operand must be either a base table or another OJ
1:eac0369: 			// In principle, we don't care about the left operand.  However, we
1:eac0369: 			// need to re-bind the resultColumns.  If the left operand is a
1:eac0369: 			// view, we may have to re-bind the where clause etc...
1:eac0369: 			// We ran into difficulty for the following query:
1:eac0369: 			//  create view v8 (cv, bv, av) as (select c, b, a from t union select f, e, d from s);
1:eac0369: 			//  select * from v8 left outer join (s left outer join r on (f = i)) on (e=v8.bv);
1:eac0369: 			return anyChange;
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		if (logicalRightResultSet instanceof HalfOuterJoinNode)
1:eac0369: 		{
1:eac0369: 			anyChange = ((HalfOuterJoinNode)logicalRightResultSet).LOJ_reorderable(numTables) || anyChange;
1:eac0369: 		}
1:eac0369: 		else if (!(logicalRightResultSet instanceof FromBaseTable))
1:1c8ca70:         {// right operand must be either a base table or another OJ
1:eac0369: 			return anyChange;
1:eac0369: 		}
1:eac0369: 
1:1c8ca70:         // It is much easier to do OJ reordering if there is no ROJ.
1:eac0369: 		// However, we ran into some problem downstream when we transform an ROJ
1:eac0369: 		// into LOJ -- transformOuterJoin() didn't expect ROJ to be transformed
1:eac0369: 		// into LOJ alread.  So, we skip optimizing ROJ at the moment.
1:eac0369: 		if (rightOuterJoin || (logicalRightResultSet instanceof HalfOuterJoinNode && 
1:eac0369: 							   ((HalfOuterJoinNode)logicalRightResultSet).rightOuterJoin))
1:eac0369: 		{
6:eac0369: 			return LOJ_bindResultColumns(anyChange);
1:eac0369: 		}
1:1c8ca70: 
1:1c8ca70:         // Build the data structure for testing/doing OJ reordering.  Fill in
1:1c8ca70:         // the table references on row-preserving and null-producing sides.  It
1:1c8ca70:         // may be possible that either operand is a complex view.
1:1c8ca70: 
1:1c8ca70:         JBitSet RPReferencedTableMap; // Row-preserving
1:1c8ca70:         JBitSet NPReferencedTableMap; // Null-producing
1:eac0369: 
1:eac0369: 		RPReferencedTableMap = logicalLeftResultSet.LOJgetReferencedTables(numTables);
1:eac0369: 		NPReferencedTableMap = logicalRightResultSet.LOJgetReferencedTables(numTables);
1:eac0369: 
1:eac0369: 		if ((RPReferencedTableMap == null || NPReferencedTableMap == null) &&
1:eac0369: 			anyChange)
1:eac0369: 		{
1:eac0369: 			return LOJ_bindResultColumns(anyChange);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 
1:1c8ca70:         // Check if logical right operand is another OJ... so we may be able
1:1c8ca70:         // to push the join.
1:1c8ca70:         if (logicalRightResultSet instanceof HalfOuterJoinNode)
1:eac0369: 		{
1:1c8ca70:             // Get the row-preserving map of the  child OJ
1:1c8ca70:             JBitSet  nestedChildOJRPRefTableMap =
1:1c8ca70:                 ((HalfOuterJoinNode)logicalRightResultSet).
1:1c8ca70:                 LOJgetRPReferencedTables(numTables);
1:eac0369: 
1:1c8ca70:             // Checks that top has p(t1,t2)
1:1c8ca70:             if ( ! isNullRejecting(
1:1c8ca70:                          joinClause,
1:1c8ca70:                          RPReferencedTableMap,
1:1c8ca70:                          nestedChildOJRPRefTableMap)) {
1:1c8ca70:                 // No, give up.
1:1c8ca70:                 return LOJ_bindResultColumns(anyChange);
1:1c8ca70:             }
1:eac0369: 
1:1c8ca70:             // Get the null-producing map of the child OJ
1:1c8ca70:             JBitSet  nestedChildOJNPRefTableMap =
1:1c8ca70:                 ((HalfOuterJoinNode)logicalRightResultSet).
1:1c8ca70:                 LOJgetNPReferencedTables(numTables);
1:eac0369: 
1:1c8ca70:             // Checks that right child has p(t2,t3)
1:1c8ca70:             if ( isNullRejecting(
1:1c8ca70:                          ((HalfOuterJoinNode)logicalRightResultSet).joinClause,
1:1c8ca70:                          nestedChildOJRPRefTableMap,
1:1c8ca70:                          nestedChildOJNPRefTableMap)) {
1:1c8ca70:                 // Push the current OJ into the next level For safety, check
1:1c8ca70:                 // the JoinNode data members: they should null or empty list
1:1c8ca70:                 // before we proceed.
1:1c8ca70:                 if (super.subqueryList.size() != 0 ||
1:1c8ca70:                     ((JoinNode)logicalRightResultSet).
1:1c8ca70:                         subqueryList.size() != 0 ||
1:1c8ca70:                     super.joinPredicates.size() != 0 ||
1:1c8ca70:                     ((JoinNode)logicalRightResultSet).
1:1c8ca70:                         joinPredicates.size() != 0 ||
1:1c8ca70:                     super.usingClause != null ||
1:1c8ca70:                     ((JoinNode)logicalRightResultSet).
1:1c8ca70:                         usingClause != null) {
1:eac0369: 
1:1c8ca70:                     return LOJ_bindResultColumns(anyChange); //  get out of here
1:1c8ca70:                 }
1:1c8ca70:                 anyChange = true; // we are reordering the OJs.
1:eac0369: 
1:1c8ca70:                 ResultSetNode tmp = logicalLeftResultSet;
1:1c8ca70:                 ResultSetNode LChild, RChild;
1:eac0369: 
1:1c8ca70:                 //            this OJ
1:1c8ca70:                 //            /      \
1:1c8ca70:                 //  logicalLeftRS   LogicalRightRS
1:1c8ca70:                 //                   /     \
1:1c8ca70:                 //                LChild  RChild
1:1c8ca70:                 // becomes
1:1c8ca70:                 //
1:1c8ca70:                 //               this OJ
1:1c8ca70:                 //               /      \
1:1c8ca70:                 //     LogicalRightRS   RChild
1:1c8ca70:                 //           /     \
1:1c8ca70:                 // logicalLeftRS LChild <<< we need to be careful about this
1:1c8ca70:                 //                          order as the "LogicalRightRS
1:1c8ca70:                 //                          may be a ROJ
1:1c8ca70:                 //
1:eac0369: 
1:1c8ca70:                 // handle the lower level OJ node
1:1c8ca70:                 LChild = ((HalfOuterJoinNode)logicalRightResultSet).
1:1c8ca70:                     leftResultSet;
1:1c8ca70:                 RChild = ((HalfOuterJoinNode)logicalRightResultSet).
1:1c8ca70:                     rightResultSet;
1:eac0369: 
1:1c8ca70:                 ((HalfOuterJoinNode)logicalRightResultSet).
1:1c8ca70:                     rightResultSet = LChild;
1:1c8ca70:                 ((HalfOuterJoinNode)logicalRightResultSet).
1:1c8ca70:                     leftResultSet  = tmp;
1:eac0369: 
1:1c8ca70:                 // switch the ON clause
1:1c8ca70:                 {
1:1c8ca70:                     ValueNode vn = joinClause;
1:1c8ca70:                     joinClause =
1:1c8ca70:                         ((HalfOuterJoinNode)logicalRightResultSet).joinClause;
1:1c8ca70:                     ((HalfOuterJoinNode)logicalRightResultSet).joinClause = vn;
1:1c8ca70:                 }
1:eac0369: 
1:1c8ca70:                 // No need to switch HalfOuterJoinNode data members for now
1:1c8ca70:                 // because we are handling only OJ.
1:1c8ca70:                 // boolean local_rightOuterJoin = rightOuterJoin;
1:1c8ca70:                 // boolean local_transformed    = transformed;
1:1c8ca70:                 // rightOuterJoin = ((HalfOuterJoinNode)logicalRightResultSet).
1:1c8ca70:                 //     rightOuterJoin;
1:1c8ca70:                 // transformed = ((HalfOuterJoinNode)logicalRightResultSet).
1:1c8ca70:                 //     transformed;
1:1c8ca70:                 // ((HalfOuterJoinNode)logicalRightResultSet).rightOuterJoin =
1:1c8ca70:                 //     local_rightOuterJoin;
1:1c8ca70:                 // ((HalfOuterJoinNode)logicalRightResultSet).transformed =
1:1c8ca70:                 //     local_transformed;
1:eac0369: 
1:3bb140c:                 FromList localFromList = new FromList(
1:3bb140c:                         getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                         getContextManager());
1:eac0369: 
1:1c8ca70:                 // switch OJ nodes: by handling the current OJ node
1:1c8ca70:                 leftResultSet  = logicalRightResultSet;
1:1c8ca70:                 rightResultSet = RChild;
1:eac0369: 
1:1c8ca70:                 // rebuild the result columns and re-bind column references
1:11f7ee3:                 ((HalfOuterJoinNode)leftResultSet).setResultColumns( null );
1:1c8ca70:                  // localFromList is empty:
1:1c8ca70:                 ((JoinNode)leftResultSet).bindResultColumns(localFromList);
1:eac0369: 
1:1c8ca70:                 // left operand must be another OJ, so recurse.
1:1c8ca70:                 boolean localChange = ((HalfOuterJoinNode)leftResultSet).
1:1c8ca70:                     LOJ_reorderable(numTables);
1:1c8ca70:             }
1:1c8ca70:         }
1:eac0369: 
1:1c8ca70:         return LOJ_bindResultColumns(anyChange);
1:1c8ca70:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:1c8ca70:     /**
1:1c8ca70:      * Tests pRiRj in the sense of Galindo-Legaria et al: <em>Outerjoin
1:1c8ca70:      * Simplification and Reordering for Query Optimization</em>, ACM
1:1c8ca70:      * Transactions on Database Systems, Vol. 22, No. 1, March 1997, Pages
1:1c8ca70:      * 43-74:
1:1c8ca70:      * <quote>
1:1c8ca70:      *  "The set of attributes referenced by a predicate p is called the schema
1:1c8ca70:      *  of p, and denoted sch(p). As a notational convention, we annotate
1:1c8ca70:      *  predicates to reflect their schema. If sch(p) includes attributes of
1:1c8ca70:      *  both Ri, Rj and only those relations, we can write the predicate as
1:1c8ca70:      *  pRiRj.
1:1c8ca70:      * </quote>
1:1c8ca70:      *
1:1c8ca70:      * If a null-valued column is compared in a predicate that
1:1c8ca70:      * contains no OR connectives, the predicate evaluates to undefined, and
1:1c8ca70:      * the tuple is rejected. The relops satisfy this criterion.
1:1c8ca70:      * <p/>
1:1c8ca70:      * To simplify analysis, we only accept predicates of the form:
1:1c8ca70:      * <pre>
1:1c8ca70:      * X relop Y [and .. and X-n relop Y-n]
1:1c8ca70:      * </pre>
1:1c8ca70:      *
1:1c8ca70:      * At least one of the relops should reference both {@code leftTableMap}
1:1c8ca70:      * and {@code rightTableMap}, so that we know that sch(p) includes
1:1c8ca70:      * attributes of both Ri, Rj. I.e.
1:1c8ca70:      *
1:1c8ca70:      * <p/>
1:1c8ca70:      * {@code X} should be a table in {@code leftTableMap}, and
1:1c8ca70:      * {@code Y} should be a table in {@code rightTableMap}.
1:1c8ca70:      * <p/>
1:1c8ca70:      * <b>or</b>
1:1c8ca70:      * {@code X} should be a table in {@code rightTableMap}, and
1:1c8ca70:      * {@code Y} should be a table in {@code leftTableMap}.
1:1c8ca70:      *
1:1c8ca70:      * @param joinClause The join clause (i.e. predicate) we want to check
1:1c8ca70:      * @param leftTableMap a bit map representing the tables expected for the
1:1c8ca70:      *                     predicate (logical left)
1:1c8ca70:      * @param rightTableMap a bit map representing the tables expected for the
1:1c8ca70:      *                      predicate (logical right)
1:1c8ca70:      * @return true if the {@code joinClause} has at least one relop that
1:1c8ca70:      *              references both {@code leftTableMap} and {@code
1:1c8ca70:      *              rightTableMap}
1:1c8ca70:      * @throws StandardException standard exception policy
1:1c8ca70:      */
1:eac0369: 
1:1c8ca70: private boolean isNullRejecting (
1:1c8ca70:         ValueNode joinClause,
1:1c8ca70:         JBitSet leftTableMap,
1:1c8ca70:         JBitSet rightTableMap)
1:1c8ca70:         throws StandardException {
1:eac0369: 
1:1c8ca70:         ValueNode vn = joinClause;
1:1c8ca70:         boolean foundPred = false;
1:eac0369: 
1:1c8ca70:         while (vn != null) {
1:1c8ca70:             AndNode andNode = null;
1:eac0369: 
1:1c8ca70:             if (vn instanceof AndNode) {
1:1c8ca70:                 andNode = (AndNode)vn;
1:1c8ca70:                 vn = andNode.getLeftOperand();
1:1c8ca70:             }
1:eac0369: 
1:1c8ca70:             if (vn instanceof BinaryRelationalOperatorNode) {
1:eac0369: 
1:1c8ca70:                 BinaryRelationalOperatorNode relop =
1:1c8ca70:                     (BinaryRelationalOperatorNode)vn;
1:1c8ca70:                 ValueNode leftCol = relop.getLeftOperand();
1:1c8ca70:                 ValueNode rightCol = relop.getRightOperand();
1:eac0369: 
1:1c8ca70:                 boolean leftFound = false;
1:1c8ca70:                 boolean rightFound = false;
1:eac0369: 
1:1c8ca70:                 if (leftCol instanceof ColumnReference) {
1:1c8ca70:                     if (leftTableMap.get(
1:1c8ca70:                                 ((ColumnReference)leftCol).getTableNumber())) {
1:1c8ca70: 
1:1c8ca70:                         leftFound = true;
1:1c8ca70: 
1:1c8ca70:                     } else if (
1:1c8ca70:                         rightTableMap.get(
1:1c8ca70:                             ((ColumnReference)leftCol).getTableNumber())) {
1:1c8ca70: 
1:1c8ca70:                         rightFound = true;
1:1c8ca70:                     } else {
1:1c8ca70:                         // references unexpected table
1:1c8ca70:                         return false;
1:1c8ca70:                     }
1:1c8ca70: 
1:1c8ca70:                 }
1:1c8ca70: 
1:1c8ca70:                 if (rightCol instanceof ColumnReference) {
1:1c8ca70:                     if (leftTableMap.get(
1:1c8ca70:                                 ((ColumnReference)rightCol).getTableNumber())) {
1:1c8ca70:                         leftFound = true;
1:1c8ca70: 
1:1c8ca70:                     } else if (rightTableMap.get(
1:1c8ca70:                                        ((ColumnReference)rightCol).
1:1c8ca70:                                        getTableNumber())) {
1:1c8ca70:                         rightFound = true;
1:1c8ca70:                     } else {
1:1c8ca70:                         // references unexpected table, sch(p) is wrong
1:1c8ca70:                         return false;
1:1c8ca70:                     }
1:1c8ca70:                 }
1:1c8ca70: 
1:1c8ca70: 
1:1c8ca70:                 if (leftFound && rightFound) {
1:1c8ca70:                     foundPred = true; // sch(p) covers both R1 and R2
1:1c8ca70:                 }
1:1c8ca70:             } else if ((vn instanceof BooleanConstantNode) && foundPred) {
1:1c8ca70:                 // OK, simple predicate which covers both R1 and R2 found
1:1c8ca70:             } else {
1:1c8ca70:                 // reject other operators, e.g. OR
1:1c8ca70:                 return false;
1:1c8ca70:             }
1:1c8ca70: 
1:1c8ca70:             if (andNode != null) {
1:1c8ca70:                 vn = andNode.getRightOperand();
1:1c8ca70:             } else {
1:1c8ca70:                 vn = null;
1:1c8ca70:             }
1:1c8ca70:         }
1:1c8ca70: 
1:1c8ca70:         return foundPred;
1:1c8ca70:     }
1:1c8ca70: 
1:1c8ca70: 
1:eac0369: 
1:eac0369: 	// This method re-binds the result columns which may be referenced in the ON
1:eac0369: 	// clause in this node.
1:3bb140c:     boolean LOJ_bindResultColumns(boolean anyChange)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (anyChange)
1:eac0369: 		{
1:11f7ee3: 			setResultColumns( null );
1:3bb140c:             FromList localFromList = new FromList(
1:3bb140c:                     getOptimizerFactory().doJoinOrderOptimization(),
1:3bb140c:                     getContextManager());
1:eac0369: 			((JoinNode)this).bindResultColumns(localFromList);
1:eac0369: 		}
1:eac0369: 		return anyChange;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Transform any Outer Join into an Inner Join where applicable.
1:eac0369: 	 * (Based on the existence of a null intolerant
1:eac0369: 	 * predicate on the inner table.)
1:eac0369: 	 *
1:eac0369: 	 * @param predicateTree	The predicate tree for the query block
1:eac0369: 	 *
1:eac0369: 	 * @return The new tree top (OuterJoin or InnerJoin).
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     FromTable transformOuterJoins(ValueNode predicateTree, int numTables)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ResultSetNode innerRS;
1:eac0369: 
1:eac0369: 		if (predicateTree == null)
1:eac0369: 		{
1:eac0369: 			/* We can't transform this node, so tell both sides of the 
1:eac0369: 			 * outer join that they can't get flattened into outer query block.
1:eac0369: 			 */
1:eac0369: 			leftResultSet.notFlattenableJoin();
1:eac0369: 			rightResultSet.notFlattenableJoin();
1:eac0369: 			return this;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		super.transformOuterJoins(predicateTree, numTables);
1:eac0369: 
1:eac0369: 		if (rightOuterJoin)
1:eac0369: 		{
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(! transformed,
1:eac0369: 					"right OJ not expected to be transformed into left OJ yet");
1:eac0369: 			}
1:eac0369: 			innerRS = leftResultSet;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			innerRS = rightResultSet;
1:eac0369: 		}
1:eac0369: 
1:7ff4f83:         // We a relooking for a null intolerant predicate on an inner table.
1:7ff4f83:         // Collect base table numbers, also if they are located inside a join
1:7ff4f83:         // (inner or outer), that is, the inner operand is itself a join,
1:7ff4f83:         // recursively.
1:7ff4f83:         JBitSet innerMap = innerRS.LOJgetReferencedTables(numTables);
1:eac0369: 
1:eac0369: 		/* Walk predicates looking for 
1:eac0369: 		 * a null intolerant predicate on the inner table.
1:eac0369: 		 */
1:eac0369: 		ValueNode vn = predicateTree;
3:eac0369: 		while (vn instanceof AndNode)
1:eac0369: 		{
1:eac0369: 			AndNode and = (AndNode) vn;
1:eac0369: 			ValueNode left = and.getLeftOperand();
1:eac0369: 
1:eac0369: 			/* Skip IS NULL predicates as they are not null intolerant */
1:2706d1f:             if (left.getClass().equals(IsNullNode.class) &&
1:2706d1f:                 ((IsNullNode)left).isNullNode())
1:eac0369: 			{
3:eac0369: 				vn = and.getRightOperand();
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Only consider predicates that are relops */
1:eac0369: 			if (left instanceof RelationalOperator)
1:eac0369: 			{
1:eac0369: 				JBitSet refMap = new JBitSet(numTables);
1:eac0369: 				/* Do not consider method calls, 
1:eac0369: 				 * conditionals, field references, etc. */
1:eac0369: 				if (! (left.categorize(refMap, true)))
1:eac0369: 				{
1:eac0369: 					vn = and.getRightOperand();
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/* If the predicate is a null intolerant predicate
1:eac0369: 				 * on the right side then we can flatten to an
1:eac0369: 				 * inner join.  We do the xform here, flattening
1:eac0369: 				 * will happen later.
1:eac0369: 				 */
1:eac0369: 				for (int bit = 0; bit < numTables; bit++)
1:eac0369: 				{
1:eac0369: 					if (refMap.get(bit) && innerMap.get(bit))
1:eac0369: 					{
1:eac0369: 						// OJ -> IJ
1:3bb140c:                         JoinNode ij =  new JoinNode(
1:eac0369: 												leftResultSet,
1:eac0369: 												rightResultSet,
1:eac0369: 												joinClause,
1:c7248d5: 												null,
1:11f7ee3: 												getResultColumns(),
2:eac0369: 												null,
1:eac0369: 												null,
1:1c8ca70: 												getContextManager());
1:eac0369: 						ij.setTableNumber(tableNumber);
1:eac0369: 						ij.setSubqueryList(subqueryList);
1:09c2697:                         ij.setAggregates(aggregates);
1:eac0369: 						return ij;
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			vn = and.getRightOperand();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* We can't transform this node, so tell both sides of the 
1:eac0369: 		 * outer join that they can't get flattened into outer query block.
1:eac0369: 		 */
1:eac0369: 		leftResultSet.notFlattenableJoin();
1:eac0369: 		rightResultSet.notFlattenableJoin();
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see JoinNode#adjustNumberOfRowsReturned */
1:3bb140c:     @Override
1:eac0369: 	protected void adjustNumberOfRowsReturned(CostEstimate costEstimate)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** An outer join returns at least as many rows as in the outer
1:eac0369: 		** table. Even if this started as a right outer join, it will
1:eac0369: 		** have been transformed to a left outer join by this point.
1:eac0369: 		*/
1:eac0369: 		CostEstimate outerCost = getLeftResultSet().getCostEstimate();
1:eac0369: 
1:eac0369: 		if (costEstimate.rowCount() < outerCost.rowCount())
1:eac0369: 		{
1:eac0369: 			costEstimate.setCost(costEstimate.getEstimatedCost(),
1:eac0369: 								 outerCost.rowCount(),
1:eac0369: 								 outerCost.rowCount());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Generate the code for an inner join node.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369:      */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Verify that a user specifed right outer join is transformed into
1:eac0369: 		 * a left outer join exactly once.
1:eac0369: 		 */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(rightOuterJoin == transformed,
1:eac0369: 				"rightOuterJoin (" + rightOuterJoin +
1:eac0369: 				") is expected to equal transformed (" + transformed + ")");
1:eac0369: 		}
1:eac0369: 		super.generateCore(acb, mb, LEFTOUTERJOIN);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Generate	and add any arguments specifict to outer joins.
1:eac0369: 	 * Generate	the methods (and add them as parameters) for
1:eac0369: 	 * returning an empty row from 1 or more sides of an outer join,
1:eac0369: 	 * if required.  Pass whether or not this was originally a
1:eac0369: 	 * right outer join.
1:eac0369: 	 *
1:eac0369: 	 * @param acb		The ActivationClassBuilder
1:eac0369: 	 * @param mb the method the generate code is to go into
1:eac0369: 	 *
1:eac0369: 	 * return The args that have been added
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:9f2ed7d:     int addOuterJoinArguments(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 		 throws StandardException
1:eac0369: 	 {
1:eac0369: 		/* Nulls always generated from the right */
1:eac0369: 		rightResultSet.getResultColumns().generateNulls(acb, mb);
1:eac0369: 
1:eac0369: 		/* Was this originally a right outer join? */
1:eac0369: 		mb.push(rightOuterJoin);
1:eac0369: 
1:eac0369: 		return 2;
1:eac0369: 	 }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the number of arguments to the join result set.
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	protected int getNumJoinArguments()
1:eac0369: 	{
1:eac0369: 		/* We add two more arguments than the superclass does */
1:eac0369: 		return super.getNumJoinArguments() + 2;
1:eac0369: 	}
1:eac0369: 
1:3bb140c:     @Override
1:9f2ed7d:     void oneRowRightSide(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 	{
1:eac0369: 		// always return false for now
1:eac0369: 		mb.push(false);
1:eac0369: 		mb.push(false);  //isNotExists?
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the logical left result set for this qualified
1:eac0369: 	 * join node.
1:eac0369: 	 * (For RIGHT OUTER JOIN, the left is the right
1:eac0369: 	 * and the right is the left and the JOIN is the NIOJ).
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	ResultSetNode getLogicalLeftResultSet()
1:eac0369: 	{
1:eac0369: 		if (rightOuterJoin)
1:eac0369: 		{
1:eac0369: 			return rightResultSet;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return leftResultSet;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the logical right result set for this qualified
1:eac0369: 	 * join node.
1:eac0369: 	 * (For RIGHT OUTER JOIN, the left is the right
1:eac0369: 	 * and the right is the left and the JOIN is the NIOJ).
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	ResultSetNode getLogicalRightResultSet()
1:eac0369: 	{
1:eac0369: 		if (rightOuterJoin)
1:eac0369: 		{
1:eac0369: 			return leftResultSet;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return rightResultSet;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if right outer join or false if left outer join
1:eac0369: 	 * Used to set Nullability correctly in JoinNode
1:eac0369: 	 */
1:3bb140c:     boolean isRightOuterJoin()
1:eac0369: 	{
1:eac0369: 		return rightOuterJoin;
1:eac0369: 	}
1:0eb98f1:     
1:0eb98f1: 	/**
1:0eb98f1: 	 * If this is a right outer join node with USING/NATURAL clause, then
1:0eb98f1: 	 *  check if the passed ResultColumn is a join column. If yes, then 
1:0eb98f1: 	 *  ResultColumn should be marked such. DERBY-4631
1:0eb98f1: 	 */
1:3bb140c:     @Override
1:3bb140c:     void isJoinColumnForRightOuterJoin(ResultColumn rc)
1:0eb98f1: 	{
1:0eb98f1: 		if (isRightOuterJoin() && usingClause != null &&  
1:0eb98f1: 				usingClause.getResultColumn(rc.getUnderlyingOrAliasName()) != null) {
1:0eb98f1: 			rc.setRightOuterJoinUsingClause(true);
1:0eb98f1: 			rc.setJoinResultset(this);
1:0eb98f1: 		}
1:0eb98f1: 	}
1:eac0369: 
1:eac0369: 	// return the Null-producing table references
1:3bb140c:     JBitSet LOJgetNPReferencedTables(int numTables)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		if (rightOuterJoin && !transformed)
1:3bb140c:             return leftResultSet.LOJgetReferencedTables(numTables);
1:eac0369: 		else
1:3bb140c:             return rightResultSet.LOJgetReferencedTables(numTables);
1:eac0369: 	}
1:eac0369: 
1:1c8ca70:     // return the row-preserving table references
1:1c8ca70:     public JBitSet LOJgetRPReferencedTables(int numTables)
1:1c8ca70:                 throws StandardException
1:1c8ca70:     {
1:1c8ca70:         if (rightOuterJoin && !transformed)
1:3bb140c:             return rightResultSet.LOJgetReferencedTables(numTables);
1:1c8ca70:         else
1:3bb140c:             return leftResultSet.LOJgetReferencedTables(numTables);
1:1c8ca70:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:                 ((HalfOuterJoinNode)leftResultSet).setResultColumns( null );
/////////////////////////////////////////////////////////////////////////
1: 			setResultColumns( null );
/////////////////////////////////////////////////////////////////////////
1: 												getResultColumns(),
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (left.getClass().equals(IsNullNode.class) &&
1:                 ((IsNullNode)left).isNullNode())
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:             predicate = joinPredicates.elementAt(index);
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
/////////////////////////////////////////////////////////////////////////
1: class HalfOuterJoinNode extends JoinNode
1:      * Constructor for a HalfOuterJoinNode.
/////////////////////////////////////////////////////////////////////////
1:      * @param cm                The context manager
1:     HalfOuterJoinNode(ResultSetNode leftResult,
1:                       ResultSetNode rightResult,
1:                       ValueNode onClause,
1:                       ResultColumnList usingClause,
1:                       boolean rightOuterJoin,
1:                       Properties tableProperties,
1:                       ContextManager cm)
1:         super(  leftResult,
1:                 rightResult,
1:                 onClause,
1:                 usingClause,
1:                 null,
1:                 null,
1:                 cm);
0:         setNodeType(C_NodeTypes.HALF_OUTER_JOIN_NODE);
1:         this.rightOuterJoin = rightOuterJoin;
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ResultSetNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void pushExpressions(PredicateList outerPredicateList)
/////////////////////////////////////////////////////////////////////////
1:         PredicateList noPredicates = new PredicateList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     boolean LOJ_reorderable(int numTables)
/////////////////////////////////////////////////////////////////////////
1:                 FromList localFromList = new FromList(
1:                         getOptimizerFactory().doJoinOrderOptimization(),
1:                         getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     boolean LOJ_bindResultColumns(boolean anyChange)
1:             FromList localFromList = new FromList(
1:                     getOptimizerFactory().doJoinOrderOptimization(),
1:                     getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                         JoinNode ij =  new JoinNode(
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     boolean isRightOuterJoin()
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void isJoinColumnForRightOuterJoin(ResultColumn rc)
/////////////////////////////////////////////////////////////////////////
1:     JBitSet LOJgetNPReferencedTables(int numTables)
1:             return leftResultSet.LOJgetReferencedTables(numTables);
1:             return rightResultSet.LOJgetReferencedTables(numTables);
/////////////////////////////////////////////////////////////////////////
1:             return rightResultSet.LOJgetReferencedTables(numTables);
1:             return leftResultSet.LOJgetReferencedTables(numTables);
commit:1c8ca70
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This method recursively:
1:      * <ul>
1:      *    <li>determines if this part of the query tree is a compound OJ of
1:      *            the shape required for reordering and if so,</li>
1:      *    <li>does a reordering.</li>
1:      * </ul>
1:      * <pre>
1:      *
1:      *    OJ1  pT1T2                      OJ1  pT2T3
1:      *   /  \                             / \
1:      *  /    \                 can       /   t3
1:      * t1    OJ2 pT2T3       reorder    /
1:      *       /  \              to      OJ2  pT1T2
1:      *      /    \                    /   \
1:      *     t2    t3                  /     \
1:      *                             t1     t2
1:      *
1:      * where pR1R2 is a null-rejecting predicate which references the schema
1:      * of joinee R1 and R2, cf. terminology explanation in #isNullRejecting.
1:      * <p/>
1:      * OJ1 represents <em>this</em> before and after the reordering.
1:      * </pre>
1:      * <p/>
1:      * The join predicates are assumed to be in CNF form.
1:      * <p/>
1:      * <em>Note:</em> Present implementation limitations
1:      * <ul>
1:      *   <li>Only left outer joins are considered, i.e. both OJs in diagram
1:      *       above must be LOJ.</li>
1:      *   <li>Top left side must be a base table (t1 above). The bottow right
1:      *       side
1: *       (t3 above) may be another OJ, so reordering can happen
1:      *       recursively.</li>
1:      * </ul>
1:      *
1:      * @param numTables number of tables involved (needed to right size the
1:      *                  bitmaps)
1:      * @return boolean true if any reordering took place at this level or deeper
1:      *                 so caller can know whether rebinding may be necessary
1:      * @throws StandardException standard error policy
1:      */
/////////////////////////////////////////////////////////////////////////
1:         // This is a very simple OJ of base tables. Do nothing.
1:         // Recursively check if we can reordering OJ, and build the table
/////////////////////////////////////////////////////////////////////////
1:         {// left operand must be either a base table or another OJ
/////////////////////////////////////////////////////////////////////////
1:         {// right operand must be either a base table or another OJ
1:         // It is much easier to do OJ reordering if there is no ROJ.
/////////////////////////////////////////////////////////////////////////
1:         // Build the data structure for testing/doing OJ reordering.  Fill in
1:         // the table references on row-preserving and null-producing sides.  It
1:         // may be possible that either operand is a complex view.
1: 
1:         JBitSet RPReferencedTableMap; // Row-preserving
1:         JBitSet NPReferencedTableMap; // Null-producing
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Check if logical right operand is another OJ... so we may be able
1:         // to push the join.
1:         if (logicalRightResultSet instanceof HalfOuterJoinNode)
1:             // Get the row-preserving map of the  child OJ
1:             JBitSet  nestedChildOJRPRefTableMap =
1:                 ((HalfOuterJoinNode)logicalRightResultSet).
1:                 LOJgetRPReferencedTables(numTables);
1:             // Checks that top has p(t1,t2)
1:             if ( ! isNullRejecting(
1:                          joinClause,
1:                          RPReferencedTableMap,
1:                          nestedChildOJRPRefTableMap)) {
1:                 // No, give up.
1:                 return LOJ_bindResultColumns(anyChange);
1:             }
1:             // Get the null-producing map of the child OJ
1:             JBitSet  nestedChildOJNPRefTableMap =
1:                 ((HalfOuterJoinNode)logicalRightResultSet).
1:                 LOJgetNPReferencedTables(numTables);
1:             // Checks that right child has p(t2,t3)
1:             if ( isNullRejecting(
1:                          ((HalfOuterJoinNode)logicalRightResultSet).joinClause,
1:                          nestedChildOJRPRefTableMap,
1:                          nestedChildOJNPRefTableMap)) {
1:                 // Push the current OJ into the next level For safety, check
1:                 // the JoinNode data members: they should null or empty list
1:                 // before we proceed.
1:                 if (super.subqueryList.size() != 0 ||
1:                     ((JoinNode)logicalRightResultSet).
1:                         subqueryList.size() != 0 ||
1:                     super.joinPredicates.size() != 0 ||
1:                     ((JoinNode)logicalRightResultSet).
1:                         joinPredicates.size() != 0 ||
1:                     super.usingClause != null ||
1:                     ((JoinNode)logicalRightResultSet).
1:                         usingClause != null) {
1:                     return LOJ_bindResultColumns(anyChange); //  get out of here
1:                 }
1:                 anyChange = true; // we are reordering the OJs.
1:                 ResultSetNode tmp = logicalLeftResultSet;
1:                 ResultSetNode LChild, RChild;
1:                 //            this OJ
1:                 //            /      \
1:                 //  logicalLeftRS   LogicalRightRS
1:                 //                   /     \
1:                 //                LChild  RChild
1:                 // becomes
1:                 //
1:                 //               this OJ
1:                 //               /      \
1:                 //     LogicalRightRS   RChild
1:                 //           /     \
1:                 // logicalLeftRS LChild <<< we need to be careful about this
1:                 //                          order as the "LogicalRightRS
1:                 //                          may be a ROJ
1:                 //
1:                 // handle the lower level OJ node
1:                 LChild = ((HalfOuterJoinNode)logicalRightResultSet).
1:                     leftResultSet;
1:                 RChild = ((HalfOuterJoinNode)logicalRightResultSet).
1:                     rightResultSet;
1:                 ((HalfOuterJoinNode)logicalRightResultSet).
1:                     rightResultSet = LChild;
1:                 ((HalfOuterJoinNode)logicalRightResultSet).
1:                     leftResultSet  = tmp;
1:                 // switch the ON clause
1:                 {
1:                     ValueNode vn = joinClause;
1:                     joinClause =
1:                         ((HalfOuterJoinNode)logicalRightResultSet).joinClause;
1:                     ((HalfOuterJoinNode)logicalRightResultSet).joinClause = vn;
1:                 }
1:                 // No need to switch HalfOuterJoinNode data members for now
1:                 // because we are handling only OJ.
1:                 // boolean local_rightOuterJoin = rightOuterJoin;
1:                 // boolean local_transformed    = transformed;
1:                 // rightOuterJoin = ((HalfOuterJoinNode)logicalRightResultSet).
1:                 //     rightOuterJoin;
1:                 // transformed = ((HalfOuterJoinNode)logicalRightResultSet).
1:                 //     transformed;
1:                 // ((HalfOuterJoinNode)logicalRightResultSet).rightOuterJoin =
1:                 //     local_rightOuterJoin;
1:                 // ((HalfOuterJoinNode)logicalRightResultSet).transformed =
1:                 //     local_transformed;
0:                 FromList localFromList = (FromList) getNodeFactory().getNode(
0:                     C_NodeTypes.FROM_LIST,
0:                     getNodeFactory().doJoinOrderOptimization(),
1:                     getContextManager());
1:                 // switch OJ nodes: by handling the current OJ node
1:                 leftResultSet  = logicalRightResultSet;
1:                 rightResultSet = RChild;
1:                 // rebuild the result columns and re-bind column references
0:                 ((HalfOuterJoinNode)leftResultSet).resultColumns = null;
1:                  // localFromList is empty:
1:                 ((JoinNode)leftResultSet).bindResultColumns(localFromList);
1:                 // left operand must be another OJ, so recurse.
1:                 boolean localChange = ((HalfOuterJoinNode)leftResultSet).
1:                     LOJ_reorderable(numTables);
1:             }
1:         }
1:         return LOJ_bindResultColumns(anyChange);
1:     }
1:     /**
1:      * Tests pRiRj in the sense of Galindo-Legaria et al: <em>Outerjoin
1:      * Simplification and Reordering for Query Optimization</em>, ACM
1:      * Transactions on Database Systems, Vol. 22, No. 1, March 1997, Pages
1:      * 43-74:
1:      * <quote>
1:      *  "The set of attributes referenced by a predicate p is called the schema
1:      *  of p, and denoted sch(p). As a notational convention, we annotate
1:      *  predicates to reflect their schema. If sch(p) includes attributes of
1:      *  both Ri, Rj and only those relations, we can write the predicate as
1:      *  pRiRj.
1:      * </quote>
1:      *
1:      * If a null-valued column is compared in a predicate that
1:      * contains no OR connectives, the predicate evaluates to undefined, and
1:      * the tuple is rejected. The relops satisfy this criterion.
1:      * <p/>
1:      * To simplify analysis, we only accept predicates of the form:
1:      * <pre>
1:      * X relop Y [and .. and X-n relop Y-n]
1:      * </pre>
1:      *
1:      * At least one of the relops should reference both {@code leftTableMap}
1:      * and {@code rightTableMap}, so that we know that sch(p) includes
1:      * attributes of both Ri, Rj. I.e.
1:      *
1:      * <p/>
1:      * {@code X} should be a table in {@code leftTableMap}, and
1:      * {@code Y} should be a table in {@code rightTableMap}.
1:      * <p/>
1:      * <b>or</b>
1:      * {@code X} should be a table in {@code rightTableMap}, and
1:      * {@code Y} should be a table in {@code leftTableMap}.
1:      *
1:      * @param joinClause The join clause (i.e. predicate) we want to check
1:      * @param leftTableMap a bit map representing the tables expected for the
1:      *                     predicate (logical left)
1:      * @param rightTableMap a bit map representing the tables expected for the
1:      *                      predicate (logical right)
1:      * @return true if the {@code joinClause} has at least one relop that
1:      *              references both {@code leftTableMap} and {@code
1:      *              rightTableMap}
1:      * @throws StandardException standard exception policy
1:      */
1: private boolean isNullRejecting (
1:         ValueNode joinClause,
1:         JBitSet leftTableMap,
1:         JBitSet rightTableMap)
1:         throws StandardException {
1:         ValueNode vn = joinClause;
1:         boolean foundPred = false;
1:         while (vn != null) {
1:             AndNode andNode = null;
1:             if (vn instanceof AndNode) {
1:                 andNode = (AndNode)vn;
1:                 vn = andNode.getLeftOperand();
1:             }
1:             if (vn instanceof BinaryRelationalOperatorNode) {
1:                 BinaryRelationalOperatorNode relop =
1:                     (BinaryRelationalOperatorNode)vn;
1:                 ValueNode leftCol = relop.getLeftOperand();
1:                 ValueNode rightCol = relop.getRightOperand();
1:                 boolean leftFound = false;
1:                 boolean rightFound = false;
1:                 if (leftCol instanceof ColumnReference) {
1:                     if (leftTableMap.get(
1:                                 ((ColumnReference)leftCol).getTableNumber())) {
1: 
1:                         leftFound = true;
1: 
1:                     } else if (
1:                         rightTableMap.get(
1:                             ((ColumnReference)leftCol).getTableNumber())) {
1: 
1:                         rightFound = true;
1:                     } else {
1:                         // references unexpected table
1:                         return false;
1:                     }
1: 
1:                 }
1: 
1:                 if (rightCol instanceof ColumnReference) {
1:                     if (leftTableMap.get(
1:                                 ((ColumnReference)rightCol).getTableNumber())) {
1:                         leftFound = true;
1: 
1:                     } else if (rightTableMap.get(
1:                                        ((ColumnReference)rightCol).
1:                                        getTableNumber())) {
1:                         rightFound = true;
1:                     } else {
1:                         // references unexpected table, sch(p) is wrong
1:                         return false;
1:                     }
1:                 }
1: 
1: 
1:                 if (leftFound && rightFound) {
1:                     foundPred = true; // sch(p) covers both R1 and R2
1:                 }
1:             } else if ((vn instanceof BooleanConstantNode) && foundPred) {
1:                 // OK, simple predicate which covers both R1 and R2 found
1:             } else {
1:                 // reject other operators, e.g. OR
1:                 return false;
1:             }
1: 
1:             if (andNode != null) {
1:                 vn = andNode.getRightOperand();
1:             } else {
1:                 vn = null;
1:             }
1:         }
1: 
1:         return foundPred;
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     // return the row-preserving table references
1:     public JBitSet LOJgetRPReferencedTables(int numTables)
1:                 throws StandardException
1:     {
1:         if (rightOuterJoin && !transformed)
0:             return (JBitSet) rightResultSet.LOJgetReferencedTables(numTables);
1:         else
0:             return (JBitSet) leftResultSet.LOJgetReferencedTables(numTables);
1:     }
commit:7ff4f83
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // We a relooking for a null intolerant predicate on an inner table.
1:         // Collect base table numbers, also if they are located inside a join
1:         // (inner or outer), that is, the inner operand is itself a join,
1:         // recursively.
1:         JBitSet innerMap = innerRS.LOJgetReferencedTables(numTables);
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     FromTable transformOuterJoins(ValueNode predicateTree, int numTables)
/////////////////////////////////////////////////////////////////////////
1:     int addOuterJoinArguments(ActivationClassBuilder acb, MethodBuilder mb)
/////////////////////////////////////////////////////////////////////////
1:     void oneRowRightSide(ActivationClassBuilder acb, MethodBuilder mb)
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:                         ij.setAggregates(aggregates);
commit:402f3c2
/////////////////////////////////////////////////////////////////////////
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:0eb98f1
/////////////////////////////////////////////////////////////////////////
1:     
1: 	/**
1: 	 * If this is a right outer join node with USING/NATURAL clause, then
1: 	 *  check if the passed ResultColumn is a join column. If yes, then 
1: 	 *  ResultColumn should be marked such. DERBY-4631
1: 	 */
0: 	public void isJoinColumnForRightOuterJoin(ResultColumn rc) 
1: 	{
1: 		if (isRightOuterJoin() && usingClause != null &&  
1: 				usingClause.getResultColumn(rc.getUnderlyingOrAliasName()) != null) {
1: 			rc.setRightOuterJoinUsingClause(true);
1: 			rc.setJoinResultset(this);
1: 		}
1: 	}
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c7248d5
/////////////////////////////////////////////////////////////////////////
1: 				tableProperties,
0: 				null);
/////////////////////////////////////////////////////////////////////////
1: 												null,
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.HalfOuterJoinNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * An HalfOuterJoinNode represents a left or a right outer join result set.
1:  * Right outer joins are always transformed into left outer joins during
1:  * preprocessing for simplicity.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class HalfOuterJoinNode extends JoinNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	private boolean rightOuterJoin;
1: 	private boolean transformed = false;
1: 
1: 	/**
0: 	 * Initializer for a HalfOuterJoinNode.
1: 	 *
1: 	 * @param leftResult		The ResultSetNode on the left side of this join
1: 	 * @param rightResult		The ResultSetNode on the right side of this join
1: 	 * @param onClause			The ON clause
1: 	 * @param usingClause		The USING clause
1: 	 * @param rightOuterJoin	Whether or not this node represents a user
1: 	 *							specified right outer join
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void init(
0: 							Object leftResult,
0: 							Object rightResult,
0: 							Object onClause,
0: 							Object usingClause,
0: 							Object rightOuterJoin,
0: 							Object tableProperties)
1: 		throws StandardException
1: 	{
0: 		super.init(
0: 				leftResult,
0: 				rightResult,
0: 				onClause,
0: 				usingClause,
1: 				null,
0: 				tableProperties);
0: 		this.rightOuterJoin = ((Boolean) rightOuterJoin).booleanValue();
1: 
1: 		/* We can only flatten an outer join
1: 		 * using the null intolerant predicate xform.
1: 		 * In that case, we will return an InnerJoin.
1: 		 */
1: 		flattenableJoin = false;
1: 	}
1: 
1: 	/*
1: 	 *  Optimizable interface
1: 	 */
1: 
1: 	/**
1: 	 * @see Optimizable#pushOptPredicate
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
1: 			throws StandardException
1: 	{
1: 		/* We should never push the predicate to joinPredicates as in JoinNode.  joinPredicates
1: 		 * should only be predicates relating the two joining tables.  In the case of half join,
1: 		 * it is biased.  If the general predicate (not join predicate) contains refernce to right
1: 		 * result set, and if doesn't qualify, we shouldn't return the row for the result to be
1: 		 * correct, but half join will fill right side NULL and return the row.  So we can only
1: 		 * push predicate to the left, as we do in "pushExpression".  bug 5055
1: 		 */
1: 		FromTable		leftFromTable = (FromTable) leftResultSet;
1: 		if (leftFromTable.getReferencedTableMap().contains(optimizablePredicate.getReferencedMap()))
1: 			return leftFromTable.pushOptPredicate(optimizablePredicate);
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
1: 	 * for how this should be done for tree printing.
1: 	 *
1: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return 	"rightOuterJoin: " + rightOuterJoin + "\n" +
1: 				"transformed: " + transformed + "\n" + 
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: 	/** 
1: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
1: 	 * ColumnReferences must continue to point to the same ResultColumn, so
1: 	 * that ResultColumn must percolate up to the new PRN.  However,
1: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
1: 	 * which points to the FromTable and the ResultColumn that is the source for
1: 	 * the ColumnReference.  
1: 	 * (The new PRN will have the original of the ResultColumnList and
1: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
1: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
1: 	 * will remain at the FromTable, with the PRN getting a new 
1: 	 * VirtualColumnNode for each ResultColumn.expression.)
1: 	 * We then project out the non-referenced columns.  If there are no referenced
1: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
1: 	 * whose expression is 1.
1: 	 *
1: 	 * @param numTables			Number of tables in the DML Statement
1: 	 * @param gbl				The group by list, if any
1: 	 * @param fromList			The from list, if any
1: 	 *
1: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ResultSetNode preprocess(int numTables,
1: 									GroupByList gbl,
1: 									FromList fromList)
1: 								throws StandardException
1: 	{
1: 		ResultSetNode newTreeTop;
1: 
1: 		/* Transform right outer joins to the equivalent left outer join */
1: 		if (rightOuterJoin)
1: 		{
1: 			/* Verify that a user specifed right outer join is transformed into
1: 			 * a left outer join exactly once.
1: 			 */
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(! transformed,
1: 					"Attempting to transform a right outer join multiple times");
1: 			}
1: 
1: 			ResultSetNode tmp = leftResultSet;
1: 
1: 			leftResultSet = rightResultSet;
1: 			rightResultSet = tmp;
1: 			transformed = true;
1: 		}
1: 		
1: 		newTreeTop = super.preprocess(numTables, gbl, fromList);
1: 
1: 		return newTreeTop;
1: 	}
1: 
1: 	/**
1: 	 * Push expressions down to the first ResultSetNode which can do expression
1: 	 * evaluation and has the same referenced table map.
1: 	 * RESOLVE - This means only pushing down single table expressions to
1: 	 * DistinctNodes today.  Once we have a better understanding of how
1: 	 * the optimizer will work, we can push down join clauses.
1: 	 *
1: 	 * @param outerPredicateList	The PredicateList from the outer RS.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void pushExpressions(PredicateList outerPredicateList)
1: 					throws StandardException
1: 	{
1: 		FromTable		leftFromTable = (FromTable) leftResultSet;
1: 		FromTable		rightFromTable = (FromTable) rightResultSet;
1: 
1: 		/* We only try to push single table predicates to the left.
1: 		 * Pushing them to the right would give incorrect semantics.
1: 		 * We use the logic for pushing down single table predicates here.
1: 		 */
1: 		pushExpressionsToLeft(outerPredicateList);
1: 
1: 		/* Push the pushable outer join predicates to the right.  This is done
1: 		 * bottom up, hence at the end of this method, so that outer join
1: 		 * conditions only get pushed down 1 level.
1: 		 * We use the optimizer's logic for pushing down join clause here.
1: 		 */
1: 		// Walk joinPredicates backwards due to possible deletes
1: 		for (int index = joinPredicates.size() - 1; index >= 0; index --)
1: 		{
1: 			Predicate predicate;
1: 
0: 			predicate = (Predicate) joinPredicates.elementAt(index);
1: 			if (! predicate.getPushable())
1: 			{
1: 				continue;
1: 			}
1: 
1: 			getRightPredicateList().addPredicate(predicate);
1: 
1: 			/* Remove the matching predicate from the outer list */
1: 			joinPredicates.removeElementAt(index);
1: 		}
1: 
1: 		/* Recurse down both sides of tree */
0: 		PredicateList	noPredicates =
0: 						(PredicateList) getNodeFactory().getNode(
0: 											C_NodeTypes.PREDICATE_LIST,
0: 											getContextManager());
1: 		leftFromTable.pushExpressions(getLeftPredicateList());
1: 		rightFromTable.pushExpressions(noPredicates);
1: 	}
1: 
1: 	/**
0: 	 * This method determines if (1) the query is a LOJ, and (2) if the LOJ is a candidate for
0: 	 * reordering (i.e., linearization).  The condition for LOJ linearization is:
0: 	 * 1. only LOJ in the fromList, i.e., no INNER, no FULL JOINs, no ROJs
0: 	 * 2. ON clause must be equality join between left and right operands and in CNF (i.e., AND is allowed)
1: 	 */
0: 	public boolean LOJ_reorderable(int numTables)
1: 		throws StandardException
1: 	{
1: 		boolean anyChange = false;
1: 
1: 		ResultSetNode logicalLeftResultSet;  // row-preserving side
1: 		ResultSetNode logicalRightResultSet; // null-producing side
1: 
1: 		// Figure out which is the row-preserving side and which is
1: 		// null-producing side.
1: 		if (rightOuterJoin)
1: 		{ // right outer join
1: 			logicalLeftResultSet  = rightResultSet;
1: 			logicalRightResultSet = leftResultSet;
1: 		}
1: 		else 
1: 		{
1: 			logicalLeftResultSet  = leftResultSet;
1: 			logicalRightResultSet = rightResultSet;
1: 		}
1: 		
1: 		// Redundantly normalize the ON predicate (it will also be called in preprocess()).
1: 		super.normExpressions();
1: 
0: 		// This is a very simple LOJ of base tables. Do nothing.
1: 		if (logicalLeftResultSet instanceof FromBaseTable &&
1: 			logicalRightResultSet instanceof FromBaseTable)
1: 			return anyChange;
1: 
0: 		// Recursively check if we can reordering LOJ, and build the table
1: 		// references. Note that joins may have been reordered and therefore the
1: 		// table references need to be recomputed.
1: 		if (logicalLeftResultSet instanceof HalfOuterJoinNode)
1: 		{
1: 			anyChange =	((HalfOuterJoinNode)logicalLeftResultSet).LOJ_reorderable(numTables) || anyChange;
1: 		}
1: 		else if (!(logicalLeftResultSet instanceof FromBaseTable))
0: 		{// left operand must be either a base table or another LOJ
1: 			// In principle, we don't care about the left operand.  However, we
1: 			// need to re-bind the resultColumns.  If the left operand is a
1: 			// view, we may have to re-bind the where clause etc...
1: 			// We ran into difficulty for the following query:
1: 			//  create view v8 (cv, bv, av) as (select c, b, a from t union select f, e, d from s);
1: 			//  select * from v8 left outer join (s left outer join r on (f = i)) on (e=v8.bv);
1: 			return anyChange;
1: 		}
1: 
1: 		if (logicalRightResultSet instanceof HalfOuterJoinNode)
1: 		{
1: 			anyChange = ((HalfOuterJoinNode)logicalRightResultSet).LOJ_reorderable(numTables) || anyChange;
1: 		}
1: 		else if (!(logicalRightResultSet instanceof FromBaseTable))
0: 		{// right operand must be either a base table or another LOJ
1: 			return anyChange;
1: 		}
1: 
0: 		// It is much easier to do LOJ reordering if there is no ROJ.
1: 		// However, we ran into some problem downstream when we transform an ROJ
1: 		// into LOJ -- transformOuterJoin() didn't expect ROJ to be transformed
1: 		// into LOJ alread.  So, we skip optimizing ROJ at the moment.
1: 		if (rightOuterJoin || (logicalRightResultSet instanceof HalfOuterJoinNode && 
1: 							   ((HalfOuterJoinNode)logicalRightResultSet).rightOuterJoin))
1: 		{
1: 			return LOJ_bindResultColumns(anyChange);
1: 		}
1: 
0: 		// Build the data structure for testing/doing LOJ reordering.
0: 		// Fill in the table references on row-preserving and null-producing sides.
0: 		// It may be possible that either operand is a complex view.
0: 		JBitSet				NPReferencedTableMap; // Null-producing
0: 		JBitSet				RPReferencedTableMap; // Row-preserving
1: 
1: 		RPReferencedTableMap = logicalLeftResultSet.LOJgetReferencedTables(numTables);
1: 		NPReferencedTableMap = logicalRightResultSet.LOJgetReferencedTables(numTables);
1: 
1: 		if ((RPReferencedTableMap == null || NPReferencedTableMap == null) &&
1: 			anyChange)
1: 		{
1: 			return LOJ_bindResultColumns(anyChange);
1: 		}
1: 			
0: 		// Check if the predicate is equality predicate in CNF (i.e., AND only)
0: 		// and left/right column references must come from either operand.
0: 		// That is, we don't allow:
0: 		// 1. A=A
0: 		// 2. 1=1
0: 		// 3. B=C where both B and C are either from left or right operand.
1: 
0: 		// we probably need to make the joinClause "left-deep" so that we can
0: 		// walk it easier.
0: 		BinaryRelationalOperatorNode equals;
0: 		ValueNode leftCol;
0: 		ValueNode rightCol;
0: 		AndNode   and;
0: 		ValueNode left;
0: 		ValueNode vn = joinClause;
1: 		while (vn instanceof AndNode)
1: 		{
0: 			and = (AndNode) vn;
0: 			left = and.getLeftOperand();
1: 
0: 			// Make sure that this is an equijoin of the form "C = D" where C
0: 			// and D references tables from both left and right operands.
0: 			if (left instanceof RelationalOperator &&
0: 				((ValueNode)left).isBinaryEqualsOperatorNode())
1: 			{
0: 				equals = (BinaryRelationalOperatorNode) left;
0: 				leftCol = equals.getLeftOperand();
0: 				rightCol = equals.getRightOperand();
1: 
0: 				if (!( leftCol instanceof ColumnReference && rightCol instanceof ColumnReference))
1: 					return LOJ_bindResultColumns(anyChange);
1: 
0: 				boolean refCheck = false;
0: 				boolean leftOperandCheck = false;
1: 
0: 				if (RPReferencedTableMap.get(((ColumnReference)leftCol).getTableNumber()))
1: 				{
0: 					refCheck = true;
0: 					leftOperandCheck = true;
1: 				}
0: 				else if (NPReferencedTableMap.get(((ColumnReference)leftCol).getTableNumber()))
1: 				{
0: 					refCheck = true;
1: 				}
1: 
0: 				if (refCheck == false)
1: 					return LOJ_bindResultColumns(anyChange);
1: 
0: 				refCheck = false;
0: 				if (leftOperandCheck == false && RPReferencedTableMap.get(((ColumnReference)rightCol).getTableNumber()))
1: 				{
0: 					refCheck = true;
1: 				}
0: 				else if (leftOperandCheck == true && NPReferencedTableMap.get(((ColumnReference)rightCol).getTableNumber()))
1: 				{
0: 					refCheck = true;
1: 				}
1: 
0: 				if (refCheck == false)
1: 					return LOJ_bindResultColumns(anyChange);
1: 			}
0: 			else return LOJ_bindResultColumns(anyChange); //  get out of here
1: 
1: 			vn = and.getRightOperand();
1: 		}
1: 
0: 		// Check if the logical right resultset is a composite inner and as such
0: 		// that this current LOJ can be pushed through it.
0: 		boolean       push = false;
0: 		// logical right operand is another LOJ... so we may be able to push the
0: 		// join
1: 		if (logicalRightResultSet instanceof HalfOuterJoinNode)
1: 		{
0: 			// get the Null-producing operand of the child
0: 			JBitSet  logicalNPRefTableMap = ((HalfOuterJoinNode)logicalRightResultSet).LOJgetNPReferencedTables(numTables);
1: 
0: 			// does the current LOJ join predicate reference
0: 			// logicalNPRefTableMap?  If not, we can push the current
0: 			// join.
0: 			vn = joinClause;
0: 			push = true;
1: 			while (vn instanceof AndNode)
1: 			{
0: 				and = (AndNode) vn;
0: 				left = and.getLeftOperand();
0: 				equals = (BinaryRelationalOperatorNode) left;
0: 				leftCol = equals.getLeftOperand();
0: 				rightCol = equals.getRightOperand();
1: 
0: 				if (logicalNPRefTableMap.get(((ColumnReference)leftCol).getTableNumber()) ||
0: 					logicalNPRefTableMap.get(((ColumnReference)rightCol).getTableNumber()))
1: 				{
0: 					push = false;
0: 					break;
1: 				}
1: 
1: 				vn = and.getRightOperand();
1: 			}
1: 		}
1: 
0: 		// Push the current LOJ into the next level
0: 		if (push)
1: 		{
0: 			// For safety, check the JoinNode data members: they should null or
0: 			// empty list before we proceed.
0: 			if (super.subqueryList.size() != 0 ||
0: 				((JoinNode)logicalRightResultSet).subqueryList.size() != 0 ||
0: 				super.joinPredicates.size() != 0 ||
0: 				((JoinNode)logicalRightResultSet).joinPredicates.size() != 0 ||
0: 				super.usingClause != null ||
0: 				((JoinNode)logicalRightResultSet).usingClause != null)
0: 				return LOJ_bindResultColumns(anyChange); //  get out of here
1: 
0: 			anyChange = true; // we are reordering the LOJs.
1: 
0: 			ResultSetNode tmp = logicalLeftResultSet;
0: 			ResultSetNode LChild, RChild;
1: 
0: 			//            this LOJ
0: 			//            /      \
0: 			//  logicalLeftRS   LogicalRightRS
0: 			//                   /     \
0: 			//                LChild  RChild
0: 			// becomes
0: 			//
0: 			//               this LOJ
0: 			//               /      \
0: 			//     LogicalRightRS   RChild
0: 			//           /     \
0: 			// logicalLeftRS   LChild  <<<  we need to be careful about this order
0: 			//                              as the "LogicalRightRS may be a ROJ
0: 			//
1: 
0: 			// handle the lower level LOJ node
0: 			LChild = ((HalfOuterJoinNode)logicalRightResultSet).leftResultSet;
0: 			RChild = ((HalfOuterJoinNode)logicalRightResultSet).rightResultSet;
1: 
0: 			((HalfOuterJoinNode)logicalRightResultSet).rightResultSet = LChild;
0: 			((HalfOuterJoinNode)logicalRightResultSet).leftResultSet  = tmp;
1: 
0: 			// switch the ON clause
0: 			vn = joinClause;
0: 			joinClause   = ((HalfOuterJoinNode)logicalRightResultSet).joinClause;
0: 			((HalfOuterJoinNode)logicalRightResultSet).joinClause = vn;
1: 
0: 			// No need to switch HalfOuterJoinNode data members for now because
0: 			// we are handling only LOJ.
0: 			// boolean local_rightOuterJoin = rightOuterJoin;
0: 			// boolean local_transformed    = transformed;
0: 			// rightOuterJoin = ((HalfOuterJoinNode)logicalRightResultSet).rightOuterJoin;
0: 			// transformed    = ((HalfOuterJoinNode)logicalRightResultSet).transformed;
0: 			// ((HalfOuterJoinNode)logicalRightResultSet).rightOuterJoin = local_rightOuterJoin;
0: 			// ((HalfOuterJoinNode)logicalRightResultSet).transformed    = local_transformed;
1: 
0: 			FromList localFromList = (FromList) getNodeFactory().getNode(
0: 																		 C_NodeTypes.FROM_LIST,
0: 																		 getNodeFactory().doJoinOrderOptimization(),
0: 																		 getContextManager());
1: 
0: 			// switch LOJ nodes: by handling the current LOJ node
0: 			leftResultSet  = logicalRightResultSet;
0: 			rightResultSet = RChild;
1: 
0: 			// rebuild the result columns and re-bind column references
0: 			((HalfOuterJoinNode)leftResultSet).resultColumns = null;
0: 			((JoinNode)leftResultSet).bindResultColumns(localFromList); // localFromList is empty
1: 
0: 			// left operand must be another LOJ, try again until a fixpoint
0: 			boolean localChange = ((HalfOuterJoinNode)leftResultSet).LOJ_reorderable(numTables);
1: 
0: 			// rebuild the result columns and re-bind column references for 'this'
1: 			return LOJ_bindResultColumns(anyChange);
1: 		}
1: 
1: 		return LOJ_bindResultColumns(anyChange);
1: 	}
1: 
1: 	// This method re-binds the result columns which may be referenced in the ON
1: 	// clause in this node.
0: 	public boolean LOJ_bindResultColumns(boolean anyChange)
1: 		throws StandardException
1: 	{
1: 		if (anyChange)
1: 		{
0: 			this.resultColumns = null;
0: 			FromList localFromList = (FromList) getNodeFactory().getNode(C_NodeTypes.FROM_LIST,
0: 																		 getNodeFactory().doJoinOrderOptimization(),
0: 																		 getContextManager());
1: 			((JoinNode)this).bindResultColumns(localFromList);
1: 		}
1: 		return anyChange;
1: 	}
1: 	
1: 
1: 	/**
1: 	 * Transform any Outer Join into an Inner Join where applicable.
1: 	 * (Based on the existence of a null intolerant
1: 	 * predicate on the inner table.)
1: 	 *
1: 	 * @param predicateTree	The predicate tree for the query block
1: 	 *
1: 	 * @return The new tree top (OuterJoin or InnerJoin).
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public FromTable transformOuterJoins(ValueNode predicateTree, int numTables)
1: 		throws StandardException
1: 	{
1: 		ResultSetNode innerRS;
1: 
1: 		if (predicateTree == null)
1: 		{
1: 			/* We can't transform this node, so tell both sides of the 
1: 			 * outer join that they can't get flattened into outer query block.
1: 			 */
1: 			leftResultSet.notFlattenableJoin();
1: 			rightResultSet.notFlattenableJoin();
1: 			return this;
1: 		}
1: 
1: 		super.transformOuterJoins(predicateTree, numTables);
1: 
0: 		JBitSet innerMap = new JBitSet(numTables);
1: 		if (rightOuterJoin)
1: 		{
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(! transformed,
1: 					"right OJ not expected to be transformed into left OJ yet");
1: 			}
1: 			innerRS = leftResultSet;
1: 		}
1: 		else
1: 		{
1: 			innerRS = rightResultSet;
1: 		}
1: 
0: 		innerRS.fillInReferencedTableMap(innerMap);
1: 
1: 		/* Walk predicates looking for 
1: 		 * a null intolerant predicate on the inner table.
1: 		 */
1: 		ValueNode vn = predicateTree;
1: 		while (vn instanceof AndNode)
1: 		{
1: 			AndNode and = (AndNode) vn;
1: 			ValueNode left = and.getLeftOperand();
1: 
1: 			/* Skip IS NULL predicates as they are not null intolerant */
0: 			if (left.isInstanceOf(C_NodeTypes.IS_NULL_NODE))
1: 			{
1: 				vn = and.getRightOperand();
1: 				continue;
1: 			}
1: 
1: 			/* Only consider predicates that are relops */
1: 			if (left instanceof RelationalOperator)
1: 			{
1: 				JBitSet refMap = new JBitSet(numTables);
1: 				/* Do not consider method calls, 
1: 				 * conditionals, field references, etc. */
1: 				if (! (left.categorize(refMap, true)))
1: 				{
1: 					vn = and.getRightOperand();
1: 					continue;
1: 				}
1: 
1: 				/* If the predicate is a null intolerant predicate
1: 				 * on the right side then we can flatten to an
1: 				 * inner join.  We do the xform here, flattening
1: 				 * will happen later.
1: 				 */
1: 				for (int bit = 0; bit < numTables; bit++)
1: 				{
1: 					if (refMap.get(bit) && innerMap.get(bit))
1: 					{
1: 						// OJ -> IJ
0: 						JoinNode ij =  (JoinNode)
0: 											getNodeFactory().getNode(
0: 												C_NodeTypes.JOIN_NODE,
1: 												leftResultSet,
1: 												rightResultSet,
1: 												joinClause,
1: 												null,
0: 												resultColumns,
1: 												null,
0: 												getContextManager());
1: 						ij.setTableNumber(tableNumber);
1: 						ij.setSubqueryList(subqueryList);
0: 						ij.setAggregateVector(aggregateVector);
1: 						return ij;
1: 					}
1: 				}
1: 			}
1: 
1: 			vn = and.getRightOperand();
1: 		}
1: 
1: 		/* We can't transform this node, so tell both sides of the 
1: 		 * outer join that they can't get flattened into outer query block.
1: 		 */
1: 		leftResultSet.notFlattenableJoin();
1: 		rightResultSet.notFlattenableJoin();
1: 
1: 		return this;
1: 	}
1: 
1: 	/** @see JoinNode#adjustNumberOfRowsReturned */
1: 	protected void adjustNumberOfRowsReturned(CostEstimate costEstimate)
1: 	{
1: 		/*
1: 		** An outer join returns at least as many rows as in the outer
1: 		** table. Even if this started as a right outer join, it will
1: 		** have been transformed to a left outer join by this point.
1: 		*/
1: 		CostEstimate outerCost = getLeftResultSet().getCostEstimate();
1: 
1: 		if (costEstimate.rowCount() < outerCost.rowCount())
1: 		{
1: 			costEstimate.setCost(costEstimate.getEstimatedCost(),
1: 								 outerCost.rowCount(),
1: 								 outerCost.rowCount());
1: 		}
1: 	}
1: 
1:     /**
1:      * Generate the code for an inner join node.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 						throws StandardException
1: 	{
1: 		/* Verify that a user specifed right outer join is transformed into
1: 		 * a left outer join exactly once.
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(rightOuterJoin == transformed,
1: 				"rightOuterJoin (" + rightOuterJoin +
1: 				") is expected to equal transformed (" + transformed + ")");
1: 		}
1: 		super.generateCore(acb, mb, LEFTOUTERJOIN);
1: 	}
1: 
1: 	/**
1: 	 * Generate	and add any arguments specifict to outer joins.
1: 	 * Generate	the methods (and add them as parameters) for
1: 	 * returning an empty row from 1 or more sides of an outer join,
1: 	 * if required.  Pass whether or not this was originally a
1: 	 * right outer join.
1: 	 *
1: 	 * @param acb		The ActivationClassBuilder
1: 	 * @param mb the method the generate code is to go into
1: 	 *
1: 	 * return The args that have been added
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	 protected int addOuterJoinArguments(ActivationClassBuilder acb,
0: 											MethodBuilder mb)
1: 		 throws StandardException
1: 	 {
1: 		/* Nulls always generated from the right */
1: 		rightResultSet.getResultColumns().generateNulls(acb, mb);
1: 
1: 		/* Was this originally a right outer join? */
1: 		mb.push(rightOuterJoin);
1: 
1: 		return 2;
1: 	 }
1: 
1: 	/**
1: 	 * Return the number of arguments to the join result set.
1: 	 */
1: 	protected int getNumJoinArguments()
1: 	{
1: 		/* We add two more arguments than the superclass does */
1: 		return super.getNumJoinArguments() + 2;
1: 	}
1: 
0: 	protected void oneRowRightSide(ActivationClassBuilder acb,
0: 									   MethodBuilder mb)
1: 	{
1: 		// always return false for now
1: 		mb.push(false);
1: 		mb.push(false);  //isNotExists?
1: 	}
1: 
1: 	/**
1: 	 * Return the logical left result set for this qualified
1: 	 * join node.
1: 	 * (For RIGHT OUTER JOIN, the left is the right
1: 	 * and the right is the left and the JOIN is the NIOJ).
1: 	 */
1: 	ResultSetNode getLogicalLeftResultSet()
1: 	{
1: 		if (rightOuterJoin)
1: 		{
1: 			return rightResultSet;
1: 		}
1: 		else
1: 		{
1: 			return leftResultSet;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return the logical right result set for this qualified
1: 	 * join node.
1: 	 * (For RIGHT OUTER JOIN, the left is the right
1: 	 * and the right is the left and the JOIN is the NIOJ).
1: 	 */
1: 	ResultSetNode getLogicalRightResultSet()
1: 	{
1: 		if (rightOuterJoin)
1: 		{
1: 			return leftResultSet;
1: 		}
1: 		else
1: 		{
1: 			return rightResultSet;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Return true if right outer join or false if left outer join
1: 	 * Used to set Nullability correctly in JoinNode
1: 	 */
0: 	public boolean isRightOuterJoin()
1: 	{
1: 		return rightOuterJoin;
1: 	}
1: 
1: 	// return the Null-producing table references
0: 	public JBitSet LOJgetNPReferencedTables(int numTables)
1: 				throws StandardException
1: 	{
1: 		if (rightOuterJoin && !transformed)
0: 			return (JBitSet) leftResultSet.LOJgetReferencedTables(numTables);
1: 		else
0: 			return (JBitSet) rightResultSet.LOJgetReferencedTables(numTables);
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * An HalfOuterJoinNode represents a left or a right outer join result set.
0:  * Right outer joins are always transformed into left outer joins during
0:  * preprocessing for simplicity.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class HalfOuterJoinNode extends JoinNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private boolean rightOuterJoin;
0: 	private boolean transformed = false;
0: 
0: 	/**
0: 	 * Initializer for a HalfOuterJoinNode.
0: 	 *
0: 	 * @param leftResult		The ResultSetNode on the left side of this join
0: 	 * @param rightResult		The ResultSetNode on the right side of this join
0: 	 * @param onClause			The ON clause
0: 	 * @param usingClause		The USING clause
0: 	 * @param rightOuterJoin	Whether or not this node represents a user
0: 	 *							specified right outer join
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void init(
0: 							Object leftResult,
0: 							Object rightResult,
0: 							Object onClause,
0: 							Object usingClause,
0: 							Object rightOuterJoin,
0: 							Object tableProperties)
0: 		throws StandardException
0: 	{
0: 		super.init(
0: 				leftResult,
0: 				rightResult,
0: 				onClause,
0: 				usingClause,
0: 				null,
0: 				tableProperties);
0: 		this.rightOuterJoin = ((Boolean) rightOuterJoin).booleanValue();
0: 
0: 		/* We can only flatten an outer join
0: 		 * using the null intolerant predicate xform.
0: 		 * In that case, we will return an InnerJoin.
0: 		 */
0: 		flattenableJoin = false;
0: 	}
0: 
0: 	/*
0: 	 *  Optimizable interface
0: 	 */
0: 
0: 	/**
0: 	 * @see Optimizable#pushOptPredicate
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public boolean pushOptPredicate(OptimizablePredicate optimizablePredicate)
0: 			throws StandardException
0: 	{
0: 		/* We should never push the predicate to joinPredicates as in JoinNode.  joinPredicates
0: 		 * should only be predicates relating the two joining tables.  In the case of half join,
0: 		 * it is biased.  If the general predicate (not join predicate) contains refernce to right
0: 		 * result set, and if doesn't qualify, we shouldn't return the row for the result to be
0: 		 * correct, but half join will fill right side NULL and return the row.  So we can only
0: 		 * push predicate to the left, as we do in "pushExpression".  bug 5055
0: 		 */
0: 		FromTable		leftFromTable = (FromTable) leftResultSet;
0: 		if (leftFromTable.getReferencedTableMap().contains(optimizablePredicate.getReferencedMap()))
0: 			return leftFromTable.pushOptPredicate(optimizablePredicate);
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return 	"rightOuterJoin: " + rightOuterJoin + "\n" +
0: 				"transformed: " + transformed + "\n" + 
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	/** 
0: 	 * Put a ProjectRestrictNode on top of each FromTable in the FromList.
0: 	 * ColumnReferences must continue to point to the same ResultColumn, so
0: 	 * that ResultColumn must percolate up to the new PRN.  However,
0: 	 * that ResultColumn will point to a new expression, a VirtualColumnNode, 
0: 	 * which points to the FromTable and the ResultColumn that is the source for
0: 	 * the ColumnReference.  
0: 	 * (The new PRN will have the original of the ResultColumnList and
0: 	 * the ResultColumns from that list.  The FromTable will get shallow copies
0: 	 * of the ResultColumnList and its ResultColumns.  ResultColumn.expression
0: 	 * will remain at the FromTable, with the PRN getting a new 
0: 	 * VirtualColumnNode for each ResultColumn.expression.)
0: 	 * We then project out the non-referenced columns.  If there are no referenced
0: 	 * columns, then the PRN's ResultColumnList will consist of a single ResultColumn
0: 	 * whose expression is 1.
0: 	 *
0: 	 * @param numTables			Number of tables in the DML Statement
0: 	 * @param gbl				The group by list, if any
0: 	 * @param fromList			The from list, if any
0: 	 *
0: 	 * @return The generated ProjectRestrictNode atop the original FromTable.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ResultSetNode preprocess(int numTables,
0: 									GroupByList gbl,
0: 									FromList fromList)
0: 								throws StandardException
0: 	{
0: 		ResultSetNode newTreeTop;
0: 
0: 		/* Transform right outer joins to the equivalent left outer join */
0: 		if (rightOuterJoin)
0: 		{
0: 			/* Verify that a user specifed right outer join is transformed into
0: 			 * a left outer join exactly once.
0: 			 */
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(! transformed,
0: 					"Attempting to transform a right outer join multiple times");
0: 			}
0: 
0: 			ResultSetNode tmp = leftResultSet;
0: 
0: 			leftResultSet = rightResultSet;
0: 			rightResultSet = tmp;
0: 			transformed = true;
0: 		}
0: 		
0: 		newTreeTop = super.preprocess(numTables, gbl, fromList);
0: 
0: 		return newTreeTop;
0: 	}
0: 
0: 	/**
0: 	 * Push expressions down to the first ResultSetNode which can do expression
0: 	 * evaluation and has the same referenced table map.
0: 	 * RESOLVE - This means only pushing down single table expressions to
0: 	 * DistinctNodes today.  Once we have a better understanding of how
0: 	 * the optimizer will work, we can push down join clauses.
0: 	 *
0: 	 * @param outerPredicateList	The PredicateList from the outer RS.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void pushExpressions(PredicateList outerPredicateList)
0: 					throws StandardException
0: 	{
0: 		FromTable		leftFromTable = (FromTable) leftResultSet;
0: 		FromTable		rightFromTable = (FromTable) rightResultSet;
0: 
0: 		/* We only try to push single table predicates to the left.
0: 		 * Pushing them to the right would give incorrect semantics.
0: 		 * We use the logic for pushing down single table predicates here.
0: 		 */
0: 		pushExpressionsToLeft(outerPredicateList);
0: 
0: 		/* Push the pushable outer join predicates to the right.  This is done
0: 		 * bottom up, hence at the end of this method, so that outer join
0: 		 * conditions only get pushed down 1 level.
0: 		 * We use the optimizer's logic for pushing down join clause here.
0: 		 */
0: 		// Walk joinPredicates backwards due to possible deletes
0: 		for (int index = joinPredicates.size() - 1; index >= 0; index --)
0: 		{
0: 			Predicate predicate;
0: 
0: 			predicate = (Predicate) joinPredicates.elementAt(index);
0: 			if (! predicate.getPushable())
0: 			{
0: 				continue;
0: 			}
0: 
0: 			getRightPredicateList().addPredicate(predicate);
0: 
0: 			/* Remove the matching predicate from the outer list */
0: 			joinPredicates.removeElementAt(index);
0: 		}
0: 
0: 		/* Recurse down both sides of tree */
0: 		PredicateList	noPredicates =
0: 						(PredicateList) getNodeFactory().getNode(
0: 											C_NodeTypes.PREDICATE_LIST,
0: 											getContextManager());
0: 		leftFromTable.pushExpressions(getLeftPredicateList());
0: 		rightFromTable.pushExpressions(noPredicates);
0: 	}
0: 
0: 	/**
0: 	 * This method determines if (1) the query is a LOJ, and (2) if the LOJ is a candidate for
0: 	 * reordering (i.e., linearization).  The condition for LOJ linearization is:
0: 	 * 1. only LOJ in the fromList, i.e., no INNER, no FULL JOINs, no ROJs
0: 	 * 2. ON clause must be equality join between left and right operands and in CNF (i.e., AND is allowed)
0: 	 */
0: 	public boolean LOJ_reorderable(int numTables)
0: 		throws StandardException
0: 	{
0: 		boolean anyChange = false;
0: 
0: 		ResultSetNode logicalLeftResultSet;  // row-preserving side
0: 		ResultSetNode logicalRightResultSet; // null-producing side
0: 
0: 		// Figure out which is the row-preserving side and which is
0: 		// null-producing side.
0: 		if (rightOuterJoin)
0: 		{ // right outer join
0: 			logicalLeftResultSet  = rightResultSet;
0: 			logicalRightResultSet = leftResultSet;
0: 		}
0: 		else 
0: 		{
0: 			logicalLeftResultSet  = leftResultSet;
0: 			logicalRightResultSet = rightResultSet;
0: 		}
0: 		
0: 		// Redundantly normalize the ON predicate (it will also be called in preprocess()).
0: 		super.normExpressions();
0: 
0: 		// This is a very simple LOJ of base tables. Do nothing.
0: 		if (logicalLeftResultSet instanceof FromBaseTable &&
0: 			logicalRightResultSet instanceof FromBaseTable)
0: 			return anyChange;
0: 
0: 		// Recursively check if we can reordering LOJ, and build the table
0: 		// references. Note that joins may have been reordered and therefore the
0: 		// table references need to be recomputed.
0: 		if (logicalLeftResultSet instanceof HalfOuterJoinNode)
0: 		{
0: 			anyChange =	((HalfOuterJoinNode)logicalLeftResultSet).LOJ_reorderable(numTables) || anyChange;
0: 		}
0: 		else if (!(logicalLeftResultSet instanceof FromBaseTable))
0: 		{// left operand must be either a base table or another LOJ
0: 			// In principle, we don't care about the left operand.  However, we
0: 			// need to re-bind the resultColumns.  If the left operand is a
0: 			// view, we may have to re-bind the where clause etc...
0: 			// We ran into difficulty for the following query:
0: 			//  create view v8 (cv, bv, av) as (select c, b, a from t union select f, e, d from s);
0: 			//  select * from v8 left outer join (s left outer join r on (f = i)) on (e=v8.bv);
0: 			return anyChange;
0: 		}
0: 
0: 		if (logicalRightResultSet instanceof HalfOuterJoinNode)
0: 		{
0: 			anyChange = ((HalfOuterJoinNode)logicalRightResultSet).LOJ_reorderable(numTables) || anyChange;
0: 		}
0: 		else if (!(logicalRightResultSet instanceof FromBaseTable))
0: 		{// right operand must be either a base table or another LOJ
0: 			return anyChange;
0: 		}
0: 
0: 		// It is much easier to do LOJ reordering if there is no ROJ.
0: 		// However, we ran into some problem downstream when we transform an ROJ
0: 		// into LOJ -- transformOuterJoin() didn't expect ROJ to be transformed
0: 		// into LOJ alread.  So, we skip optimizing ROJ at the moment.
0: 		if (rightOuterJoin || (logicalRightResultSet instanceof HalfOuterJoinNode && 
0: 							   ((HalfOuterJoinNode)logicalRightResultSet).rightOuterJoin))
0: 		{
0: 			return LOJ_bindResultColumns(anyChange);
0: 		}
0: 
0: 		// Build the data structure for testing/doing LOJ reordering.
0: 		// Fill in the table references on row-preserving and null-producing sides.
0: 		// It may be possible that either operand is a complex view.
0: 		JBitSet				NPReferencedTableMap; // Null-producing
0: 		JBitSet				RPReferencedTableMap; // Row-preserving
0: 
0: 		RPReferencedTableMap = logicalLeftResultSet.LOJgetReferencedTables(numTables);
0: 		NPReferencedTableMap = logicalRightResultSet.LOJgetReferencedTables(numTables);
0: 
0: 		if ((RPReferencedTableMap == null || NPReferencedTableMap == null) &&
0: 			anyChange)
0: 		{
0: 			return LOJ_bindResultColumns(anyChange);
0: 		}
0: 			
0: 		// Check if the predicate is equality predicate in CNF (i.e., AND only)
0: 		// and left/right column references must come from either operand.
0: 		// That is, we don't allow:
0: 		// 1. A=A
0: 		// 2. 1=1
0: 		// 3. B=C where both B and C are either from left or right operand.
0: 
0: 		// we probably need to make the joinClause "left-deep" so that we can
0: 		// walk it easier.
0: 		BinaryRelationalOperatorNode equals;
0: 		ValueNode leftCol;
0: 		ValueNode rightCol;
0: 		AndNode   and;
0: 		ValueNode left;
0: 		ValueNode vn = joinClause;
0: 		while (vn instanceof AndNode)
0: 		{
0: 			and = (AndNode) vn;
0: 			left = and.getLeftOperand();
0: 
0: 			// Make sure that this is an equijoin of the form "C = D" where C
0: 			// and D references tables from both left and right operands.
0: 			if (left instanceof RelationalOperator &&
0: 				((ValueNode)left).isBinaryEqualsOperatorNode())
0: 			{
0: 				equals = (BinaryRelationalOperatorNode) left;
0: 				leftCol = equals.getLeftOperand();
0: 				rightCol = equals.getRightOperand();
0: 
0: 				if (!( leftCol instanceof ColumnReference && rightCol instanceof ColumnReference))
0: 					return LOJ_bindResultColumns(anyChange);
0: 
0: 				boolean refCheck = false;
0: 				boolean leftOperandCheck = false;
0: 
0: 				if (RPReferencedTableMap.get(((ColumnReference)leftCol).getTableNumber()))
0: 				{
0: 					refCheck = true;
0: 					leftOperandCheck = true;
0: 				}
0: 				else if (NPReferencedTableMap.get(((ColumnReference)leftCol).getTableNumber()))
0: 				{
0: 					refCheck = true;
0: 				}
0: 
0: 				if (refCheck == false)
0: 					return LOJ_bindResultColumns(anyChange);
0: 
0: 				refCheck = false;
0: 				if (leftOperandCheck == false && RPReferencedTableMap.get(((ColumnReference)rightCol).getTableNumber()))
0: 				{
0: 					refCheck = true;
0: 				}
0: 				else if (leftOperandCheck == true && NPReferencedTableMap.get(((ColumnReference)rightCol).getTableNumber()))
0: 				{
0: 					refCheck = true;
0: 				}
0: 
0: 				if (refCheck == false)
0: 					return LOJ_bindResultColumns(anyChange);
0: 			}
0: 			else return LOJ_bindResultColumns(anyChange); //  get out of here
0: 
0: 			vn = and.getRightOperand();
0: 		}
0: 
0: 		// Check if the logical right resultset is a composite inner and as such
0: 		// that this current LOJ can be pushed through it.
0: 		boolean       push = false;
0: 		// logical right operand is another LOJ... so we may be able to push the
0: 		// join
0: 		if (logicalRightResultSet instanceof HalfOuterJoinNode)
0: 		{
0: 			// get the Null-producing operand of the child
0: 			JBitSet  logicalNPRefTableMap = ((HalfOuterJoinNode)logicalRightResultSet).LOJgetNPReferencedTables(numTables);
0: 
0: 			// does the current LOJ join predicate reference
0: 			// logicalNPRefTableMap?  If not, we can push the current
0: 			// join.
0: 			vn = joinClause;
0: 			push = true;
0: 			while (vn instanceof AndNode)
0: 			{
0: 				and = (AndNode) vn;
0: 				left = and.getLeftOperand();
0: 				equals = (BinaryRelationalOperatorNode) left;
0: 				leftCol = equals.getLeftOperand();
0: 				rightCol = equals.getRightOperand();
0: 
0: 				if (logicalNPRefTableMap.get(((ColumnReference)leftCol).getTableNumber()) ||
0: 					logicalNPRefTableMap.get(((ColumnReference)rightCol).getTableNumber()))
0: 				{
0: 					push = false;
0: 					break;
0: 				}
0: 
0: 				vn = and.getRightOperand();
0: 			}
0: 		}
0: 
0: 		// Push the current LOJ into the next level
0: 		if (push)
0: 		{
0: 			// For safety, check the JoinNode data members: they should null or
0: 			// empty list before we proceed.
0: 			if (super.subqueryList.size() != 0 ||
0: 				((JoinNode)logicalRightResultSet).subqueryList.size() != 0 ||
0: 				super.joinPredicates.size() != 0 ||
0: 				((JoinNode)logicalRightResultSet).joinPredicates.size() != 0 ||
0: 				super.usingClause != null ||
0: 				((JoinNode)logicalRightResultSet).usingClause != null)
0: 				return LOJ_bindResultColumns(anyChange); //  get out of here
0: 
0: 			anyChange = true; // we are reordering the LOJs.
0: 
0: 			ResultSetNode tmp = logicalLeftResultSet;
0: 			ResultSetNode LChild, RChild;
0: 
0: 			//            this LOJ
0: 			//            /      \
0: 			//  logicalLeftRS   LogicalRightRS
0: 			//                   /     \
0: 			//                LChild  RChild
0: 			// becomes
0: 			//
0: 			//               this LOJ
0: 			//               /      \
0: 			//     LogicalRightRS   RChild
0: 			//           /     \
0: 			// logicalLeftRS   LChild  <<<  we need to be careful about this order
0: 			//                              as the "LogicalRightRS may be a ROJ
0: 			//
0: 
0: 			// handle the lower level LOJ node
0: 			LChild = ((HalfOuterJoinNode)logicalRightResultSet).leftResultSet;
0: 			RChild = ((HalfOuterJoinNode)logicalRightResultSet).rightResultSet;
0: 
0: 			((HalfOuterJoinNode)logicalRightResultSet).rightResultSet = LChild;
0: 			((HalfOuterJoinNode)logicalRightResultSet).leftResultSet  = tmp;
0: 
0: 			// switch the ON clause
0: 			vn = joinClause;
0: 			joinClause   = ((HalfOuterJoinNode)logicalRightResultSet).joinClause;
0: 			((HalfOuterJoinNode)logicalRightResultSet).joinClause = vn;
0: 
0: 			// No need to switch HalfOuterJoinNode data members for now because
0: 			// we are handling only LOJ.
0: 			// boolean local_rightOuterJoin = rightOuterJoin;
0: 			// boolean local_transformed    = transformed;
0: 			// rightOuterJoin = ((HalfOuterJoinNode)logicalRightResultSet).rightOuterJoin;
0: 			// transformed    = ((HalfOuterJoinNode)logicalRightResultSet).transformed;
0: 			// ((HalfOuterJoinNode)logicalRightResultSet).rightOuterJoin = local_rightOuterJoin;
0: 			// ((HalfOuterJoinNode)logicalRightResultSet).transformed    = local_transformed;
0: 
0: 			FromList localFromList = (FromList) getNodeFactory().getNode(
0: 																		 C_NodeTypes.FROM_LIST,
0: 																		 getNodeFactory().doJoinOrderOptimization(),
0: 																		 getContextManager());
0: 
0: 			// switch LOJ nodes: by handling the current LOJ node
0: 			leftResultSet  = logicalRightResultSet;
0: 			rightResultSet = RChild;
0: 
0: 			// rebuild the result columns and re-bind column references
0: 			((HalfOuterJoinNode)leftResultSet).resultColumns = null;
0: 			((JoinNode)leftResultSet).bindResultColumns(localFromList); // localFromList is empty
0: 
0: 			// left operand must be another LOJ, try again until a fixpoint
0: 			boolean localChange = ((HalfOuterJoinNode)leftResultSet).LOJ_reorderable(numTables);
0: 
0: 			// rebuild the result columns and re-bind column references for 'this'
0: 			return LOJ_bindResultColumns(anyChange);
0: 		}
0: 
0: 		return LOJ_bindResultColumns(anyChange);
0: 	}
0: 
0: 	// This method re-binds the result columns which may be referenced in the ON
0: 	// clause in this node.
0: 	public boolean LOJ_bindResultColumns(boolean anyChange)
0: 		throws StandardException
0: 	{
0: 		if (anyChange)
0: 		{
0: 			this.resultColumns = null;
0: 			FromList localFromList = (FromList) getNodeFactory().getNode(C_NodeTypes.FROM_LIST,
0: 																		 getNodeFactory().doJoinOrderOptimization(),
0: 																		 getContextManager());
0: 			((JoinNode)this).bindResultColumns(localFromList);
0: 		}
0: 		return anyChange;
0: 	}
0: 	
0: 
0: 	/**
0: 	 * Transform any Outer Join into an Inner Join where applicable.
0: 	 * (Based on the existence of a null intolerant
0: 	 * predicate on the inner table.)
0: 	 *
0: 	 * @param predicateTree	The predicate tree for the query block
0: 	 *
0: 	 * @return The new tree top (OuterJoin or InnerJoin).
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public FromTable transformOuterJoins(ValueNode predicateTree, int numTables)
0: 		throws StandardException
0: 	{
0: 		ResultSetNode innerRS;
0: 
0: 		if (predicateTree == null)
0: 		{
0: 			/* We can't transform this node, so tell both sides of the 
0: 			 * outer join that they can't get flattened into outer query block.
0: 			 */
0: 			leftResultSet.notFlattenableJoin();
0: 			rightResultSet.notFlattenableJoin();
0: 			return this;
0: 		}
0: 
0: 		super.transformOuterJoins(predicateTree, numTables);
0: 
0: 		JBitSet innerMap = new JBitSet(numTables);
0: 		if (rightOuterJoin)
0: 		{
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(! transformed,
0: 					"right OJ not expected to be transformed into left OJ yet");
0: 			}
0: 			innerRS = leftResultSet;
0: 		}
0: 		else
0: 		{
0: 			innerRS = rightResultSet;
0: 		}
0: 
0: 		innerRS.fillInReferencedTableMap(innerMap);
0: 
0: 		/* Walk predicates looking for 
0: 		 * a null intolerant predicate on the inner table.
0: 		 */
0: 		ValueNode vn = predicateTree;
0: 		while (vn instanceof AndNode)
0: 		{
0: 			AndNode and = (AndNode) vn;
0: 			ValueNode left = and.getLeftOperand();
0: 
0: 			/* Skip IS NULL predicates as they are not null intolerant */
0: 			if (left.isInstanceOf(C_NodeTypes.IS_NULL_NODE))
0: 			{
0: 				vn = and.getRightOperand();
0: 				continue;
0: 			}
0: 
0: 			/* Only consider predicates that are relops */
0: 			if (left instanceof RelationalOperator)
0: 			{
0: 				JBitSet refMap = new JBitSet(numTables);
0: 				/* Do not consider method calls, 
0: 				 * conditionals, field references, etc. */
0: 				if (! (left.categorize(refMap, true)))
0: 				{
0: 					vn = and.getRightOperand();
0: 					continue;
0: 				}
0: 
0: 				/* If the predicate is a null intolerant predicate
0: 				 * on the right side then we can flatten to an
0: 				 * inner join.  We do the xform here, flattening
0: 				 * will happen later.
0: 				 */
0: 				for (int bit = 0; bit < numTables; bit++)
0: 				{
0: 					if (refMap.get(bit) && innerMap.get(bit))
0: 					{
0: 						// OJ -> IJ
0: 						JoinNode ij =  (JoinNode)
0: 											getNodeFactory().getNode(
0: 												C_NodeTypes.JOIN_NODE,
0: 												leftResultSet,
0: 												rightResultSet,
0: 												joinClause,
0: 												null,
0: 												resultColumns,
0: 												null,
0: 												getContextManager());
0: 						ij.setTableNumber(tableNumber);
0: 						ij.setSubqueryList(subqueryList);
0: 						ij.setAggregateVector(aggregateVector);
0: 						return ij;
0: 					}
0: 				}
0: 			}
0: 
0: 			vn = and.getRightOperand();
0: 		}
0: 
0: 		/* We can't transform this node, so tell both sides of the 
0: 		 * outer join that they can't get flattened into outer query block.
0: 		 */
0: 		leftResultSet.notFlattenableJoin();
0: 		rightResultSet.notFlattenableJoin();
0: 
0: 		return this;
0: 	}
0: 
0: 	/** @see JoinNode#adjustNumberOfRowsReturned */
0: 	protected void adjustNumberOfRowsReturned(CostEstimate costEstimate)
0: 	{
0: 		/*
0: 		** An outer join returns at least as many rows as in the outer
0: 		** table. Even if this started as a right outer join, it will
0: 		** have been transformed to a left outer join by this point.
0: 		*/
0: 		CostEstimate outerCost = getLeftResultSet().getCostEstimate();
0: 
0: 		if (costEstimate.rowCount() < outerCost.rowCount())
0: 		{
0: 			costEstimate.setCost(costEstimate.getEstimatedCost(),
0: 								 outerCost.rowCount(),
0: 								 outerCost.rowCount());
0: 		}
0: 	}
0: 
0:     /**
0:      * Generate the code for an inner join node.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 						throws StandardException
0: 	{
0: 		/* Verify that a user specifed right outer join is transformed into
0: 		 * a left outer join exactly once.
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(rightOuterJoin == transformed,
0: 				"rightOuterJoin (" + rightOuterJoin +
0: 				") is expected to equal transformed (" + transformed + ")");
0: 		}
0: 		super.generateCore(acb, mb, LEFTOUTERJOIN);
0: 	}
0: 
0: 	/**
0: 	 * Generate	and add any arguments specifict to outer joins.
0: 	 * Generate	the methods (and add them as parameters) for
0: 	 * returning an empty row from 1 or more sides of an outer join,
0: 	 * if required.  Pass whether or not this was originally a
0: 	 * right outer join.
0: 	 *
0: 	 * @param acb		The ActivationClassBuilder
0: 	 * @param mb the method the generate code is to go into
0: 	 *
0: 	 * return The args that have been added
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	 protected int addOuterJoinArguments(ActivationClassBuilder acb,
0: 											MethodBuilder mb)
0: 		 throws StandardException
0: 	 {
0: 		/* Nulls always generated from the right */
0: 		rightResultSet.getResultColumns().generateNulls(acb, mb);
0: 
0: 		/* Was this originally a right outer join? */
0: 		mb.push(rightOuterJoin);
0: 
0: 		return 2;
0: 	 }
0: 
0: 	/**
0: 	 * Return the number of arguments to the join result set.
0: 	 */
0: 	protected int getNumJoinArguments()
0: 	{
0: 		/* We add two more arguments than the superclass does */
0: 		return super.getNumJoinArguments() + 2;
0: 	}
0: 
0: 	protected void oneRowRightSide(ActivationClassBuilder acb,
0: 									   MethodBuilder mb)
0: 	{
0: 		// always return false for now
0: 		mb.push(false);
0: 		mb.push(false);  //isNotExists?
0: 	}
0: 
0: 	/**
0: 	 * Return the logical left result set for this qualified
0: 	 * join node.
0: 	 * (For RIGHT OUTER JOIN, the left is the right
0: 	 * and the right is the left and the JOIN is the NIOJ).
0: 	 */
0: 	ResultSetNode getLogicalLeftResultSet()
0: 	{
0: 		if (rightOuterJoin)
0: 		{
0: 			return rightResultSet;
0: 		}
0: 		else
0: 		{
0: 			return leftResultSet;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return the logical right result set for this qualified
0: 	 * join node.
0: 	 * (For RIGHT OUTER JOIN, the left is the right
0: 	 * and the right is the left and the JOIN is the NIOJ).
0: 	 */
0: 	ResultSetNode getLogicalRightResultSet()
0: 	{
0: 		if (rightOuterJoin)
0: 		{
0: 			return leftResultSet;
0: 		}
0: 		else
0: 		{
0: 			return rightResultSet;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Return true if right outer join or false if left outer join
0: 	 * Used to set Nullability correctly in JoinNode
0: 	 */
0: 	public boolean isRightOuterJoin()
0: 	{
0: 		return rightOuterJoin;
0: 	}
0: 
0: 	// return the Null-producing table references
0: 	public JBitSet LOJgetNPReferencedTables(int numTables)
0: 				throws StandardException
0: 	{
0: 		if (rightOuterJoin && !transformed)
0: 			return (JBitSet) leftResultSet.LOJgetReferencedTables(numTables);
0: 		else
0: 			return (JBitSet) rightResultSet.LOJgetReferencedTables(numTables);
0: 	}
0: }
============================================================================