1:6409b40: /*
4:6409b40: 
1:6409b40: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeTrajectoryTest
1:6409b40: 
1:6409b40: Licensed to the Apache Software Foundation (ASF) under one or more
1:6409b40: contributor license agreements.  See the NOTICE file distributed with
1:6409b40: this work for additional information regarding copyright ownership.
1:6409b40: The ASF licenses this file to You under the Apache License, Version 2.0
1:6409b40: (the "License"); you may not use this file except in compliance with
1:6409b40: the License.  You may obtain a copy of the License at
1:6409b40: 
1:6409b40:    http://www.apache.org/licenses/LICENSE-2.0
1:6409b40: 
1:6409b40: Unless required by applicable law or agreed to in writing, software
1:6409b40: distributed under the License is distributed on an "AS IS" BASIS,
1:6409b40: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6409b40: See the License for the specific language governing permissions and
1:6409b40: limitations under the License.
1:6409b40: 
1:6409b40: */
1:6409b40: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1:6409b40: 
1:6409b40: import java.lang.reflect.Method;
1:6409b40: import java.sql.Connection;
1:6409b40: import java.sql.PreparedStatement;
1:6409b40: import java.sql.ResultSet;
1:6409b40: import java.sql.ResultSetMetaData;
1:6409b40: import java.sql.SQLException;
1:6409b40: import java.util.ArrayList;
1:6409b40: import java.util.HashMap;
1:6409b40: import java.util.Properties;
1:6409b40: import javax.sql.DataSource;
1:6409b40: import junit.extensions.TestSetup;
1:6409b40: import junit.framework.Test;
1:6409b40: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:493b80e: import org.apache.derbyTesting.junit.ClassLoaderTestSetup;
1:d15f717: import org.apache.derbyTesting.junit.JDBCClient;
1:d15f717: import org.apache.derbyTesting.junit.JDBCClientSetup;
1:6409b40: import org.apache.derbyTesting.junit.JDBCDataSource;
1:6409b40: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:6409b40: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:6409b40: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:6409b40: import org.apache.derbyTesting.junit.TestConfiguration;
1:6409b40: 
1:6409b40: /**
1:6409b40:  * <p>
1:6409b40:  * Test upgrade trajectories. This test compares the metadata in
1:6409b40:  * upgraded databases to the metadata in databases created from scratch.
1:6409b40:  * Given a collection of releases, this test does the following:
1:6409b40:  * </p>
1:6409b40:  *
1:6409b40:  * <ul>
1:6409b40:  * <li>Builds either a minimal set of trajectories or the full set of possible
1:6409b40:  * trajectories:
1:6409b40:  *  <ul>
1:6409b40:  *   <li>By default, just builds a minimal set of trajectories. These are all
1:6409b40:  *   trajectories which begin with some release, then upgrade through all
1:6409b40:  *   intermediate releases to the highest release in the original collection of
1:6409b40:  *   all releases. A set of N releases gives rise to N-1 minimal trajectories.</li>
1:7b5f964:  *
1:7b5f964:  *   <li>Otherwise, if the system property {@code derbyTesting.allTrajectories}
1:7b5f964:  *   is set to true, builds the set of all upgrade trajectories possible on
1:7b5f964:  *   that collection of releases. An upgrade trajectory is a sorted subset of
1:7b5f964:  *   those releases. Each subset is sorted in ascending release order. We
1:7b5f964:  *   exclude the vacuous empty subset and the uninteresting singleton
1:7b5f964:  *   subsets. A set of N releases gives rise to ((2**N) - N) - 1 hard-upgrade
1:7b5f964:  *   trajectories.</li>
1:6409b40:  *  </ul>
1:6409b40:  * </li>
1:6409b40:  * <li>For each trajectory, we create two databases:
1:6409b40:  *  <ul>
1:6409b40:  *   <li>A starting point database created with the first release in the
1:6409b40:  *   trajectory. This database is then upgraded through all of the intermediate
1:6409b40:  *   releases in the trajectory until it is at the level of the last release in
1:6409b40:  *   the trajectory.</li>
1:6409b40:  *   <li>An ending point database created with the last release in the
1:6409b40:  *   trajectory.</li>
1:6409b40:  *  </ul>
1:6409b40:  *</li>
1:6409b40:  * <li>We then compare the metadata in the starting point and ending point
1:6409b40:  * databases.</li>
1:6409b40:  * </ul>
1:6409b40:  *
1:6409b40:  * <p>
1:6409b40:  * By default we don't consider soft-upgrades. Also by default, we consider
1:6409b40:  * trajectories with more than one release from the same branch. You can
1:6409b40:  * parameterize or customize some constants (see below) if you want to change
1:6409b40:  * these decisions.
1:6409b40:  * </p>
1:6409b40:  *
1:6409b40:  * <p>
1:7b5f964:  * By default we consider all  trajectories possible on the collection
1:7b5f964:  * of releases listed in {@link OldVersions}. If you want to consider
1:7b5f964:  * a different  collection of  releases, you  can override  the {@code
1:7b5f964:  * OldVersions}  collection  by  setting the  system  property  {@code
1:7b5f964:  * "derbyTesting.oldVersionsPath"}. Here, for instance, is the command
1:6409b40:  * line to run this test against a customized list of releases:
1:6409b40:  * </p>
1:6409b40:  *
1:6409b40:  * <blockquote><pre>
1:6409b40:  *  java -XX:MaxPermSize=128M -Xmx512m \
1:6409b40:  *  -DderbyTesting.oldReleasePath=/Users/me/myDerbyReleaseDirectory \
1:6409b40:  *  -DderbyTesting.oldVersionsPath=/Users/me/fileContainingMyListOfTastyReleases \
1:6409b40:  *  junit.textui.TestRunner org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeTrajectoryTest
1:6409b40:  * </pre></blockquote>
1:6409b40:  *
1:6409b40:  * <p>
1:6409b40:  * For extra verbose output, you can set the "derby.tests.debug" property too:
1:6409b40:  * </p>
1:6409b40:  *
1:6409b40:  * <blockquote><pre>
1:6409b40:  *  java -XX:MaxPermSize=128M -Xmx512m \
1:6409b40:  *  -DderbyTesting.oldReleasePath=/Users/me/myDerbyReleaseDirectory \
1:6409b40:  *  -DderbyTesting.oldVersionsPath=/Users/me/fileContainingMyListOfTastyReleases \
1:6409b40:  *  -Dderby.tests.debug=true \
1:6409b40:  *  junit.textui.TestRunner org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeTrajectoryTest
1:6409b40:  * </pre></blockquote>
1:6409b40:  *
1:6409b40:  * <p>
1:6409b40:  * Here is the command line to run all upgrade trajectories against a customized list of releases:
1:6409b40:  * </p>
1:6409b40:  *
1:6409b40:  * <blockquote><pre>
1:6409b40:  *  java -XX:MaxPermSize=128M -Xmx512m \
1:6409b40:  *  -DderbyTesting.allTrajectories=true \
1:6409b40:  *  -DderbyTesting.oldReleasePath=/Users/me/myDerbyReleaseDirectory \
1:6409b40:  *  -DderbyTesting.oldVersionsPath=/Users/me/fileContainingMyListOfTastyReleases \
1:6409b40:  *  junit.textui.TestRunner org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeTrajectoryTest
1:6409b40:  * </pre></blockquote>
1:6409b40:  *
1:6409b40:  * <p>
1:6409b40:  * If you need to test a particular trajectory, you can hand-edit
1:7b5f964:  * {@code makeSampleTrajectories()} and uncomment the call to it.
1:6409b40:  * </p>
1:6409b40:  *
1:6409b40:  */
1:6409b40: public class UpgradeTrajectoryTest extends BaseJDBCTestCase
1:6409b40: {
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40:     //
1:6409b40:     // CONSTANTS
1:6409b40:     //
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40: 
1:6409b40:     public static final String ALL_TRAJECTORIES_PROPERTY = "derbyTesting.allTrajectories";
1:6409b40: 
1:6409b40:     public static Version VERSION_10_0_2_1 = new Version( 10, 0, 2, 1 );
1:6409b40:     public static Version VERSION_10_1_3_1 = new Version( 10, 1, 3, 1 );
1:d15f717:     public static Version VERSION_10_2_2_0 = new Version( 10, 2, 2, 0 );
1:6409b40:     public static Version VERSION_10_5_1_1 = new Version( 10, 5, 1, 1 );
1:b05fa6e:     public static Version VERSION_10_6_0_0 = new Version( 10, 6, 0, 0 );
1:6409b40: 
1:6409b40:     public static Version.Trajectory TRAJECTORY_10_0_2_1_TO_10_1_3_1 = new Version.Trajectory( new Version[] { VERSION_10_0_2_1, VERSION_10_1_3_1 } );
1:6409b40: 
1:6409b40:     public static String BRANCH_10_0 = "10.0";
1:6409b40:     public static String BRANCH_10_1 = "10.1";
1:b05fa6e:     public static String BRANCH_10_2 = "10.2";
1:b05fa6e:     public static String BRANCH_10_3 = "10.3";
1:b05fa6e:     public static String BRANCH_10_4 = "10.4";
1:b05fa6e:     public static String BRANCH_10_5 = "10.5";
1:6409b40: 
1:6409b40:     public static final String UPGRADED_DATABASE = "old_database";
1:6409b40:     public static final String VIRGIN_DATABASE = "new_database";
1:6409b40:     public static final String COMPARISON_DATABASE = "comparison_database";
1:6409b40:     private static final String DUMMY_NUMBER = "123";
1:6409b40:     private static final String DUMMY_STRING = "BLAHBLAH";
1:6409b40:     private static final String DUMMY_TIMESTAMP = "123456";
1:6409b40: 
1:6409b40:     private static final String DERBY_4214_1 = "RETURNS VARCHAR(32672)";
1:6409b40:     private static final String DERBY_4214_2 = "RETURNS VARCHAR(10890)";
1:6409b40:     private static final String DERBY_4215 = "SYSCS_INPLACE_COMPRESS_TABLE";
1:6409b40: 
1:6409b40:     //
1:6409b40:     // Parameterize or change these switches if you want to alter the set of
1:6409b40:     // trajectories which we consider:
1:6409b40:     //
1:6409b40:     private static final boolean TRJ_IGNORE_SOFT_UPGRADE = true;
1:6409b40:     private static final boolean TRJ_SAME_BRANCH_NEIGHBORS = false;
1:6409b40: 
1:6409b40:     private static final String SYSALIASES = "SYSALIASES";
1:6409b40:     private static final String SYSCONGLOMERATES = "SYSCONGLOMERATES";
1:6409b40:     private static final String SYSSTATEMENTS = "SYSSTATEMENTS";
1:6409b40:     private static final String SYSROUTINEPERMS = "SYSROUTINEPERMS";
1:6409b40: 
1:6409b40:     private static final String CONGLOMERATENUMBER = "CONGLOMERATENUMBER";
1:6409b40:     private static final String ALIAS = "ALIAS";
1:6409b40:     private static final String ALIASID = "ALIASID";
1:6409b40:     private static final String SPECIFICNAME = "SPECIFICNAME";
1:6409b40:     private static final String STMTID = "STMTID";
1:6409b40:     private static final String STMTNAME = "STMTNAME";
1:6409b40:     private static final String TEXT = "TEXT";
1:6409b40:     private static final String ROUTINEPERMSID = "ROUTINEPERMSID";
1:6409b40:     private static final String LASTCOMPILED = "LASTCOMPILED";
1:6409b40: 
1:6409b40:     private static final boolean LOQUACIOUS = false;
1:6409b40: 
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40:     //
1:6409b40:     // STATE
1:6409b40:     //
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40: 
1:6409b40:     private Version.Trajectory _trajectory;
1:6409b40:     private String             _trajectoryName;
1:6409b40:     private boolean[]          _hardUpgradeRequests;
1:6409b40:     
1:eec86ed:     private HashMap<String,String>     _unstableColumnValues = new HashMap<String,String>();
1:6409b40: 
1:eec86ed:     private static ThreadLocal<ClassLoader> _originalClassLoader = new ThreadLocal<ClassLoader>();
1:6409b40: 
1:6409b40:     // these are the system tables which must be read first in order to
1:6409b40:     // prep the mapping of unstable identifiers
1:6409b40:     private static String[] INITIAL_TABLES = new String[]
1:6409b40:     {
1:6409b40:         "SYSALIASES",
1:6409b40:     };
1:6409b40: 
1:6409b40: 
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40:     //
1:6409b40:     // CONSTRUCTOR
1:6409b40:     //
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40: 
1:6409b40:     public UpgradeTrajectoryTest( Version.Trajectory trajectory, boolean[] hardUpgradeRequests )
1:6409b40:     {
1:6409b40:         super( "testTrajectory" );
1:6409b40: 
1:6409b40:         _trajectory = trajectory;
1:6409b40:         _hardUpgradeRequests = hardUpgradeRequests;
1:6409b40:     }
1:6409b40: 
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40:     //
1:6409b40:     // JUnit BEHAVIOR
1:6409b40:     //
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * Return the suite of tests.
1:6409b40:      */
1:6409b40:     public static Test suite()
1:6409b40:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Upgrade trajectory test");
1:6409b40: 
1:6409b40:         addTrajectories( suite );
1:6409b40:         
1:6409b40:         Test sfs = new SupportFilesSetup((Test) suite);
1:6409b40: 
1:6409b40:         return SecurityManagerSetup.noSecurityManager( sfs );
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Add all of the trajectories we intend to test.
1:6409b40:      * </p>
1:6409b40:      */
1:1ae02c9:     private static void addTrajectories( BaseTestSuite suite )
1:6409b40:     {
1:6409b40:         Version.Trajectory[] trajectories = makeTrajectories();
1:6409b40:         int                  count = trajectories.length;
1:6409b40: 
1:6409b40:         println( "Found " + count + " trajectories." );
1:6409b40: 
1:6409b40:         for ( int i = 0; i < count; i++ )
1:6409b40:         {
1:6409b40:             // right now, we're only testing hard upgrade.
1:6409b40:             addHardUpgradeOnlyTrajectory( suite, trajectories[ i ] );
1:6409b40:         }
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Make all known upgrade trajectories. This amounts to every non-vacuous
1:6409b40:      * subset of the known versions.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private static Version.Trajectory[] makeTrajectories()
1:6409b40:     {
1:6409b40:         Version[]   supportedVersions = getSupportedVersions();
1:6409b40:         Version.Trajectory[] result;
1:6409b40: 
1:6409b40:         //
1:6409b40:         // If requested to, we construct the power set of supported versions, throwing
1:6409b40:         // out the non-upgradable subsets, viz., the empty set and the
1:6409b40:         // singletons. We include hard upgrades between releases on the same
1:6409b40:         // branch.
1:6409b40:         //
1:6409b40:         // By default we don't test all trajectories. We only test the
1:6409b40:         // trajectories which are complete sequences from a starting point up to
1:6409b40:         // the last release.
1:6409b40:         //
1:6409b40:         if ( shouldBuildAllTrajectories() ) { result = buildPowerSet( supportedVersions ); }
1:6409b40:         else { result = buildMinimalSet( supportedVersions ); }
1:6409b40:         
1:6409b40:         //
1:6409b40:         // Uncomment this line if you just want to test a couple sample
1:6409b40:         // trajectories.
1:6409b40:         //
1:6409b40:         //result = makeSampleTrajectories();
1:6409b40:         
1:6409b40:         return result;
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Return true if we should build all trajectories.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private static boolean shouldBuildAllTrajectories()
1:6409b40:     {
1:ce40a31:         Boolean bool = Boolean.valueOf(getSystemProperty( ALL_TRAJECTORIES_PROPERTY ));
1:6409b40: 
1:6409b40:         return bool.booleanValue();
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Sample trajectory for debugging this program.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private static Version.Trajectory[] makeSampleTrajectories()
1:6409b40:     {
1:6409b40:         return new Version.Trajectory[]
1:6409b40:         {
1:6409b40:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 1, 3, 1 ) } ),
1:6409b40:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 3, 3, 0 ) } ),
1:b05fa6e:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 3, 3, 0 ), new Version( 10, 5, 1, 1 ) } ),
1:b05fa6e:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 3, 3, 0 ), new Version( 10, 6, 0, 0 ) } ),
1:6409b40:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 5, 1, 1 ) } ),
1:6409b40:             new Version.Trajectory( new Version[] { new Version( 10, 4, 2, 1), new Version( 10, 5, 1, 1 ) } ),
1:6409b40:         };
1:6409b40: 
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Get the supported versions.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private static Version[] getSupportedVersions()
1:6409b40:     {
1:6409b40:         int[][]      raw = OldVersions.getSupportedVersions();
1:6409b40:         int          count = raw.length;
1:6409b40:         Version[] result = new Version[ count ];
1:6409b40: 
1:6409b40:         for ( int i = 0; i < count; i++ ) { result[ i ] = new Version( raw[ i ] ); }
1:6409b40: 
1:6409b40:         return result;
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Add only the test case which hard-upgrades along all edges of the Trajectory.
1:6409b40:      * </p>
1:6409b40:      */
1:1ae02c9:     private static void addHardUpgradeOnlyTrajectory(
1:1ae02c9:         BaseTestSuite suite, Version.Trajectory trajectory )
1:6409b40:     {
1:6409b40:         // a valid trajectory must have a start point and a different end point
1:6409b40:         int       versionCount = trajectory.getVersionCount();
1:6409b40:         if ( versionCount < 2 ) { return; }
1:6409b40:         
1:6409b40:         boolean[] hardUpgradeRequests = new boolean[ versionCount ];
1:6409b40: 
1:6409b40:         // the start point is always hard
1:6409b40:         for ( int i = 0; i < versionCount; i++ ) { hardUpgradeRequests[ i ] = true; }
1:6409b40: 
1:6409b40:         addTrajectory( suite, trajectory, hardUpgradeRequests );
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Add a single trajectory to the suite, looping through all combinations of
1:6409b40:      * hard and softupgrade.
1:6409b40:      * </p>
1:6409b40:      */
1:1ae02c9:     private static void addTrajectory(
1:1ae02c9:         BaseTestSuite suite, Version.Trajectory trajectory )
1:6409b40:     {
1:6409b40:         // a valid trajectory must have a start point and a different end point
1:6409b40:         int       versionCount = trajectory.getVersionCount();
1:6409b40:         if ( versionCount < 2 ) { return; }
1:6409b40:         
1:6409b40:         boolean[] hardUpgradeRequests = new boolean[ versionCount ];
1:6409b40: 
1:6409b40:         // the start point is always hard unless you parameterize the following constant
1:6409b40:         hardUpgradeRequests[ 0 ] = TRJ_IGNORE_SOFT_UPGRADE;
1:6409b40: 
1:6409b40:         addTrajectory( suite, trajectory, hardUpgradeRequests, 1 );
1:6409b40:     }
1:6409b40: 
1:1ae02c9:     private static void addTrajectory(
1:1ae02c9:         BaseTestSuite suite,
1:1ae02c9:         Version.Trajectory trajectory,
1:1ae02c9:         boolean[] hardUpgradeRequests,
1:1ae02c9:         int idx )
1:6409b40:     {
1:6409b40:         if ( idx >= trajectory.getVersionCount() )
1:6409b40:         {
1:6409b40:             addTrajectory( suite, trajectory, hardUpgradeRequests );
1:6409b40:         }
1:6409b40:         else
1:6409b40:         {
1:6409b40:             boolean[] hard = clone( hardUpgradeRequests );
1:6409b40:             boolean[] soft = clone( hardUpgradeRequests );
1:6409b40:             
1:6409b40:             hard[ idx ] = true;
1:6409b40:             addTrajectory( suite, trajectory, hard, idx + 1 );
1:6409b40: 
1:6409b40:             soft[ idx ] = false;
1:6409b40:             addTrajectory( suite, trajectory, soft, idx + 1 );
1:6409b40:         }
1:6409b40:     }
1:6409b40: 
1:6409b40:     private static boolean[] clone( boolean[] input )
1:6409b40:     {
1:6409b40:         int       count = input.length;
1:6409b40:         boolean[] output = new boolean[ count ];
1:6409b40: 
1:6409b40:         for ( int i = 0; i < count; i++ ) { output[ i ] = input[ i ]; }
1:6409b40: 
1:6409b40:         return output;
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Add a single trajectory to the suite, with upgrade instructions.
1:6409b40:      * </p>
1:6409b40:      */
1:1ae02c9:     private static void addTrajectory(
1:1ae02c9:         BaseTestSuite suite,
1:1ae02c9:         Version.Trajectory trajectory,
1:1ae02c9:         boolean[] hardUpgradeRequests )
1:6409b40:     {
1:6409b40:         UpgradeTrajectoryTest utt = new UpgradeTrajectoryTest( trajectory, hardUpgradeRequests );
1:6409b40:         TestSetup setup = TestConfiguration.additionalDatabaseDecorator( utt, UPGRADED_DATABASE );
1:6409b40:         setup =  TestConfiguration.additionalDatabaseDecorator( setup, VIRGIN_DATABASE );
1:6409b40:         setup =  TestConfiguration.additionalDatabaseDecorator( setup, COMPARISON_DATABASE );
1:6409b40: 
1:6409b40:         Properties preReleaseUpgrade = new Properties();
1:6409b40:         preReleaseUpgrade.setProperty( "derby.database.allowPreReleaseUpgrade", "true");
1:6409b40:         
1:6409b40:         setup = new SystemPropertyTestSetup(setup, preReleaseUpgrade );
1:d15f717: 
1:d15f717:         // If the first release in the trajectory pre-dates the release which
1:d15f717:         // introduced JDBC4, force the client to be the JDBC3 client. This
1:d15f717:         // prevents us from falling through and picking up the JDBC4 data source from
1:d15f717:         // the system classpath rather than picking up a datasource from
1:d15f717:         // the version-specific classloader.
1:d15f717:         if ( trajectory.getVersion( 0 ).compareTo( VERSION_10_2_2_0 ) < 0 )
1:d15f717:         {
1:d15f717:             setup = new JDBCClientSetup( setup, JDBCClient.EMBEDDED_30 );
1:d15f717:         }
1:d15f717:         
1:6409b40:         suite.addTest( setup );
1:6409b40:     }
1:6409b40: 
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40:     //
1:6409b40:     // TESTS
1:6409b40:     //
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Test a single trajectory.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     public void testTrajectory() throws Exception
1:6409b40:     {
1:6409b40:         _trajectoryName = _trajectory.toString() + ' ' + stringifyUpgradeRequests();
1:6409b40: 
1:6409b40:         println( "Testing trajectory: " + _trajectoryName );
1:6409b40: 
1:6409b40:         // there must be at least 2 versions in a trajectory, otherwise the
1:6409b40:         // test is vacuous
1:6409b40:         int  versionCount = _trajectory.getVersionCount();
1:6409b40:         assertTrue( _trajectoryName, versionCount > 1 );
1:6409b40: 
1:6409b40:         // remember the original class loader
1:6409b40:         saveOriginalClassLoader();
1:6409b40: 
1:6409b40:         try {
1:6409b40:             Version startDataVersion = _trajectory.getVersion( 0 );
1:6409b40:             Version endDataVersion = startDataVersion;
1:6409b40: 
1:6409b40:             createDatabase( startDataVersion, UPGRADED_DATABASE );
1:6409b40: 
1:6409b40:             // now upgrade the database through the whole chain
1:6409b40:             for ( int i = 1; i < versionCount; i++ )
1:6409b40:             {
1:6409b40:                 Version nextSoftwareVersion = _trajectory.getVersion( i );
1:6409b40:                 boolean hardUpgrade = _hardUpgradeRequests[ i ];
1:6409b40: 
1:6409b40:                 if ( hardUpgrade ) { endDataVersion = nextSoftwareVersion; }
1:6409b40: 
1:6409b40:                 upgradeDatabase( nextSoftwareVersion, endDataVersion, hardUpgrade, UPGRADED_DATABASE );
1:6409b40:             }
1:6409b40: 
1:6409b40:             createDatabase( endDataVersion, VIRGIN_DATABASE );
1:6409b40: 
1:6409b40:             if ( LOQUACIOUS) { println( "    End version is " + endDataVersion ); }
1:6409b40: 
1:6409b40:             compareDatabases( endDataVersion, UPGRADED_DATABASE, VIRGIN_DATABASE );
1:6409b40:         }
1:6409b40:         finally
1:6409b40:         {
1:6409b40:             restoreOriginalClassLoader();
1:6409b40: 
1:6409b40:             // reboot the databases so that DropDatabaseSetup can remove them
1:6409b40:             bootDatabase( UPGRADED_DATABASE );
1:6409b40:             bootDatabase( VIRGIN_DATABASE );
1:6409b40:         }
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Compare the metadata in two databases.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void compareDatabases( Version version, String leftDatabaseName, String rightDatabaseName )
1:6409b40:         throws Exception
1:6409b40:     {
1:493b80e:         ClassLoaderTestSetup.setThreadLoader( version.getClassLoader() );
1:6409b40: 
1:6409b40:         DataSource leftDS = makeDataSource( leftDatabaseName );
1:6409b40:         DataSource rightDS = makeDataSource( rightDatabaseName );
1:6409b40:         DataSource comparisonDS = bootDatabase( COMPARISON_DATABASE );
1:6409b40:         Connection leftConn = leftDS.getConnection();
1:6409b40:         Connection rightConn = rightDS.getConnection();
1:6409b40:         Connection comparisonConn = comparisonDS.getConnection();
1:6409b40: 
1:6409b40:         //        compareQueries( leftConn, rightConn, 2, "select stmtname, lastcompiled from sys.sysroutineperms order by stmtname" );
1:6409b40:         //        boolean b = true;
1:6409b40:         //        if ( b ) { return; }
1:6409b40: 
1:6409b40: 
1:6409b40:         try {
1:6409b40: 
1:6409b40:             goodStatement( comparisonConn, "create schema " + leftDatabaseName );
1:6409b40:             goodStatement( comparisonConn, "create schema " + rightDatabaseName );
1:6409b40: 
1:6409b40:             compareResults
1:6409b40:                 ( leftConn, rightConn, comparisonConn, leftDatabaseName, rightDatabaseName, "first_table", "select tablename from sys.systables where tabletype = 'S'" );
1:6409b40: 
1:6409b40:             // compare the tables which must come first
1:6409b40:             int initialTableCount = INITIAL_TABLES.length;
1:6409b40:             for ( int i = 0; i < initialTableCount; i++ )
1:6409b40:             {
1:6409b40:                 String systemTableName = INITIAL_TABLES[ i ];
1:6409b40:                 compareResults
1:6409b40:                     ( leftConn, rightConn, comparisonConn, leftDatabaseName, rightDatabaseName, systemTableName, "select * from sys." + systemTableName );
1:6409b40:             }
1:6409b40: 
1:6409b40:             // now compare the other tables
1:6409b40:             ArrayList systemTables = listSystemTables( comparisonConn );
1:6409b40:             int          count = systemTables.size();
1:6409b40: 
1:6409b40:             for ( int i = 0; i < count; i++ )
1:6409b40:             {
1:6409b40:                 String systemTableName = (String) systemTables.get( i );
1:6409b40:                 compareResults
1:6409b40:                     ( leftConn, rightConn, comparisonConn, leftDatabaseName, rightDatabaseName, systemTableName, "select * from sys." + systemTableName );
1:6409b40:             }
1:6409b40: 
1:6409b40:         }
1:6409b40:         finally
1:6409b40:         {
1:6409b40:             shutdownDatabase( leftDS );
1:6409b40:             shutdownDatabase( rightDS );
1:6409b40:             shutdownDatabase( comparisonDS );
1:6409b40:         }
1:6409b40: 
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Get the names of all the system tables in the database except for the
1:6409b40:      * list of initial tables.
1:6409b40:      * </p>
1:6409b40:      */
1:eec86ed:     private ArrayList<String> listSystemTables
1:6409b40:         ( Connection conn )
1:6409b40:         throws Exception
1:6409b40:     {
1:eec86ed:         ArrayList<String> result = new ArrayList<String>();
1:6409b40: 
1:6409b40:         StringBuffer buffer = new StringBuffer();
1:6409b40: 
1:6409b40:         buffer.append( "select tablename from sys.systables where tabletype = 'S' and tablename != 'SYSDUMMY1'" );
1:6409b40:         int initialTableCount = INITIAL_TABLES.length;
1:6409b40:         for ( int i = 0; i < initialTableCount; i++ )
1:6409b40:         {
1:6409b40:             buffer.append( " and tablename != '" );
1:6409b40:             buffer.append( INITIAL_TABLES[ i ] );
1:6409b40:             buffer.append( "'" );
1:6409b40:         }
1:6409b40:         buffer.append( " order by tablename" );
1:6409b40:         
1:6409b40:         PreparedStatement ps = chattyPrepare( conn,  buffer.toString() );
1:6409b40:         ResultSet               rs = ps.executeQuery();
1:6409b40: 
1:6409b40:         while ( rs.next() )
1:6409b40:         {
1:6409b40:             result.add( rs.getString( 1 ) );
1:6409b40:         }
1:6409b40: 
1:6409b40:         rs.close();
1:6409b40:         ps.close();
1:6409b40: 
1:6409b40:         return result;
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Compare the results of a query in two databases.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void compareResults
1:6409b40:         ( Connection leftConn, Connection rightConn, Connection comparisonConn, String leftSchema, String rightSchema, String tableName, String query )
1:6409b40:         throws Exception
1:6409b40:     {
1:6409b40:         String leftTableName = leftSchema + "." + tableName;
1:6409b40:         String rightTableName = rightSchema + "." + tableName;
1:6409b40:         StringBuffer columnList = new StringBuffer();
1:6409b40:         StringBuffer insertList = new StringBuffer();
1:eec86ed:         ArrayList<String> columnNames = new ArrayList<String>();
1:6409b40: 
1:6409b40:         PreparedStatement leftPS = chattyPrepare( leftConn, query );
1:6409b40:         PreparedStatement rightPS = chattyPrepare( rightConn, query );
1:6409b40:         ResultSet leftSelect = leftPS.executeQuery();
1:6409b40:         ResultSet rightSelect = rightPS.executeQuery();
1:6409b40:         PreparedStatement leftInsert = null;
1:6409b40:         PreparedStatement rightInsert = null;
1:6409b40: 
1:6409b40:         try {
1:6409b40:             //
1:6409b40:             // First create the tables to hold the left and right results.
1:6409b40:             //
1:6409b40:             ResultSetMetaData leftRSMD = leftSelect.getMetaData();
1:6409b40:             ResultSetMetaData rightRSMD = rightSelect.getMetaData();
1:6409b40:             int columnCount = leftRSMD.getColumnCount();
1:6409b40:             String sampleColumnName = null;
1:6409b40: 
1:6409b40:             assertEquals( _trajectoryName, leftRSMD.getColumnCount(), rightRSMD.getColumnCount() );
1:6409b40: 
1:6409b40:             columnList.append( "\n( " );
1:6409b40:             insertList.append( "\n( " );
1:6409b40:             for ( int i = 1; i <= columnCount; i++ )
1:6409b40:             {
1:6409b40:                 if ( i > 1 )
1:6409b40:                 {
1:6409b40:                     columnList.append( ", " );
1:6409b40:                     insertList.append( ", " );
1:6409b40:                 }
1:6409b40:                 String columnName = leftRSMD.getColumnName(  i );
1:6409b40:                 if ( i == 1 ) { sampleColumnName = columnName; }
1:6409b40:                 columnNames.add( columnName );
1:6409b40:                 
1:6409b40:                 assertEquals( _trajectoryName, leftRSMD.getColumnName( i ), rightRSMD.getColumnName( i ) );
1:6409b40:                 assertEquals( _trajectoryName, leftRSMD.getColumnType( i ), rightRSMD.getColumnType( i  ) );
1:6409b40: 
1:6409b40:                 columnList.append( columnName );
1:6409b40:                 columnList.append( " varchar( 10000 )" );
1:6409b40:                 insertList.append( "?" );
1:6409b40:             }
1:6409b40:             columnList.append( "\n)" );
1:6409b40:             insertList.append( "\n)" );
1:6409b40: 
1:6409b40:             String colList = columnList.toString();
1:6409b40:             String insList = insertList.toString();
1:6409b40: 
1:6409b40:             goodStatement( comparisonConn, "create table " + leftTableName + colList );
1:6409b40:             goodStatement( comparisonConn, "create table " + rightTableName + colList );
1:6409b40:             
1:6409b40:             leftInsert = chattyPrepare( comparisonConn, "insert into " + leftTableName + " values " + insList );
1:6409b40:             rightInsert = chattyPrepare( comparisonConn, "insert into " + rightTableName + " values " + insList );
1:6409b40: 
1:6409b40:             // now loop through the metadata rows, copying them into the
1:6409b40:             // comparison tables
1:6409b40:             int leftCount = stuffTable( tableName, leftSelect, leftInsert );
1:6409b40:             int rightCount = stuffTable( tableName, rightSelect, rightInsert );
1:6409b40: 
1:6409b40:             if (
1:6409b40:                 (!suffersDERBY_4215( tableName )) &&
1:6409b40:                 (!suffersDERBY_4216( tableName ))
1:6409b40:                 )
1:6409b40:             { assertEquals( _trajectoryName + ": " + tableName, leftCount, rightCount ); }
1:6409b40:             else { assertTrue( _trajectoryName + ": " + tableName, leftCount != rightCount ); }
1:6409b40: 
1:6409b40:             // now compare the copied metadata, using left joins
1:6409b40:             leftJoin( comparisonConn, columnNames, tableName, leftTableName, rightTableName );
1:6409b40:             if ( !suffersDERBY_4216( tableName ) )
1:6409b40:             { leftJoin( comparisonConn, columnNames, tableName, rightTableName, leftTableName ); }
1:6409b40:         }
1:6409b40:         finally
1:6409b40:         {
1:6409b40:             leftSelect.close();
1:6409b40:             rightSelect.close();
1:6409b40:             leftPS.close();
1:6409b40:             rightPS.close();
1:6409b40: 
1:6409b40:             if ( leftInsert != null ) { leftInsert.close(); }
1:6409b40:             if ( rightInsert != null ) { rightInsert.close(); }
1:6409b40:         }
1:6409b40:         
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Copy metadata from a source table into a target table.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private int stuffTable( String tableName, ResultSet select, PreparedStatement insert ) throws Exception
1:6409b40:     {
1:6409b40:         ResultSetMetaData rsmd = select.getMetaData();
1:6409b40:         int  columnCount = rsmd.getColumnCount();
1:6409b40:         int  rowCount = 0;
1:6409b40: 
1:6409b40:         String[] columnNames = new String[ columnCount ];
1:6409b40:         for ( int i = 0; i < columnCount; i++ ) { columnNames[ i ] = rsmd.getColumnName( i + 1 ); }
1:6409b40: 
1:6409b40:         String[] row = new String[ columnCount ];
1:6409b40: 
1:6409b40:         while ( select.next() )
1:6409b40:         {
1:6409b40:             for ( int i = 0; i < columnCount; i++ )
1:6409b40:             {
1:6409b40:                 row[ i ] = select.getString( i + 1 );
1:6409b40:             }
1:6409b40:             normalizeRow( tableName, columnNames, row );
1:6409b40:             
1:6409b40:             for ( int i = 0; i < columnCount; i++ )
1:6409b40:             {
1:6409b40:                 insert.setString( i + 1, row[ i ]  );
1:6409b40:             }
1:6409b40:             insert.executeUpdate();
1:6409b40:             rowCount++;
1:6409b40:         }
1:6409b40: 
1:6409b40:         return rowCount;
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Left join two tables and verify that the result is empty.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void leftJoin( Connection conn, ArrayList columnNames, String tableName, String leftTableName, String rightTableName )
1:6409b40:         throws Exception
1:6409b40:     {
1:6409b40:         PreparedStatement selectPS = null;
1:6409b40:         ResultSet select = null;
1:6409b40: 
1:6409b40:         String sampleColumn = (String) columnNames.get( 0 );
1:6409b40:         StringBuffer buffer = new StringBuffer();
1:6409b40: 
1:6409b40:         buffer.append( "select *\nfrom " );
1:6409b40:         buffer.append( leftTableName );
1:6409b40:         buffer.append( " l left join " );
1:6409b40:         buffer.append( rightTableName );
1:6409b40:         buffer.append( " r\non " );
1:6409b40:         int count = columnNames.size();
1:6409b40:         for ( int i = 0; i < count; i++ )
1:6409b40:         {
1:6409b40:             if ( i > 0 ) { buffer.append( "and " ); }
1:6409b40: 
1:6409b40:             String columnName = (String) columnNames.get( i );
1:6409b40:             buffer.append( "( ( l." );
1:6409b40:             buffer.append( columnName );
1:6409b40:             buffer.append( " = r." );
1:6409b40:             buffer.append( columnName );
1:6409b40:             buffer.append( " ) or ( l." );
1:6409b40:             buffer.append( columnName );
1:6409b40:             buffer.append( " is null and r." );
1:6409b40:             buffer.append( columnName );
1:6409b40:             buffer.append( " is null ) )\n" );
1:6409b40:         }
1:6409b40:         buffer.append( "where r." );
1:6409b40:         buffer.append( sampleColumn );
1:6409b40:         buffer.append( " is null" );
1:6409b40:         
1:6409b40: 
1:6409b40:         try {
1:6409b40:             selectPS = chattyPrepare
1:6409b40:                 (
1:6409b40:                  conn,
1:6409b40:                  buffer.toString()
1:6409b40:                  );
1:6409b40:             select = selectPS.executeQuery();
1:6409b40: 
1:6409b40:             String expected = "";
1:6409b40:             String actual = filterKnownProblems( tableName, printResultSet( select ) );
1:6409b40: 
1:6409b40:             assertEquals( _trajectoryName + ": " + leftTableName + " vs. " + rightTableName, expected, actual );
1:6409b40:         }
1:6409b40:         finally
1:6409b40:         {
1:6409b40:             if ( select != null ) { select.close(); }
1:6409b40:             if ( selectPS != null ) { selectPS.close(); }
1:6409b40:         }
1:6409b40: 
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Create a database using the indicated version of Derby.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void createDatabase( Version version, String logicalDatabaseName )
1:6409b40:         throws Exception
1:6409b40:     {
1:493b80e:         ClassLoaderTestSetup.setThreadLoader( version.getClassLoader() );
1:6409b40: 
1:6409b40:         DataSource ds = bootDatabase( logicalDatabaseName );
1:6409b40: 
1:6409b40:         Connection conn = ds.getConnection();
1:6409b40: 
1:6409b40:         vetDBVersion( version, version, conn );
1:6409b40: 
1:6409b40:         shutdownDatabase( ds );
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Upgrade a database to the indicated version of Derby.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void upgradeDatabase( Version softwareVersion, Version dataVersion, boolean hardUpgrade, String logicalDatabaseName )
1:6409b40:         throws Exception
1:6409b40:     {
1:493b80e:         ClassLoaderTestSetup.setThreadLoader(softwareVersion.getClassLoader());
1:6409b40: 
1:6409b40:         DataSource ds = upgradeDatabase( logicalDatabaseName, hardUpgrade );
1:6409b40: 
1:6409b40:         Connection conn = ds.getConnection();
1:6409b40: 
1:6409b40:         vetDBVersion( softwareVersion, dataVersion, conn );
1:6409b40: 
1:6409b40:         shutdownDatabase( ds );
1:6409b40:     }
1:6409b40: 
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40:     //
1:6409b40:     // MINIONS
1:6409b40:     //
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Boot a database.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private DataSource bootDatabase( String logicalDatabaseName )
1:6409b40:         throws Exception
1:6409b40:     {
1:6409b40:         DataSource ds = makeDataSource( logicalDatabaseName );
1:6409b40:         Method     setMethod = ds.getClass().getMethod( "setCreateDatabase", new Class[] { String.class } );
1:6409b40:         
1:6409b40:         setMethod.invoke( ds, new Object[] { "create" } );
1:6409b40:         
1:6409b40:         Connection conn = ds.getConnection();
1:6409b40:         
1:6409b40:         return ds;
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Hard-upgrade a database.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private DataSource upgradeDatabase( String logicalDatabaseName, boolean hardUpgrade )
1:6409b40:         throws Exception
1:6409b40:     {
1:6409b40:         DataSource ds = makeDataSource( logicalDatabaseName );
1:6409b40: 
1:6409b40:         if ( hardUpgrade )
1:6409b40:         {
1:6409b40:             Method     setMethod = ds.getClass().getMethod( "setConnectionAttributes", new Class[] { String.class } );
1:6409b40:         
1:6409b40:             setMethod.invoke( ds, new Object[] { "upgrade=true" } );
1:6409b40:         }
1:6409b40:         
1:6409b40:         Connection conn = ds.getConnection();
1:6409b40:         
1:6409b40:         return ds;
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Make a DataSource given a logical database name.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private DataSource makeDataSource( String logicalDatabaseName )
1:6409b40:         throws Exception
1:6409b40:     {
1:6409b40:         return JDBCDataSource.getDataSourceLogical( logicalDatabaseName );
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Shutdown a database.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void shutdownDatabase( DataSource ds )
1:6409b40:     {
1:6409b40:         JDBCDataSource.shutdownDatabase( ds );
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Verify that the database has the expected version.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void vetDBVersion( Version softwareVersion, Version dataVersion, Connection conn )
1:6409b40:         throws Exception
1:6409b40:     {
1:6409b40:         String expectedSoftwareVersion = softwareVersion.toString();
1:6409b40:         String expectedDataVersion = dataVersion.getBranchID();
1:6409b40:         String actualSoftwareVersion = trimDriverVersion( conn.getMetaData().getDriverVersion() );
1:6409b40:         String actualDataVersion = getDataVersion( conn );
1:6409b40: 
1:6409b40:         assertEquals( _trajectoryName, expectedSoftwareVersion, actualSoftwareVersion );
1:6409b40:         assertEquals( _trajectoryName, expectedDataVersion, actualDataVersion );
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Get the version of the data in the database.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private String getDataVersion( Connection conn )
1:6409b40:         throws Exception
1:6409b40:     {
1:6409b40:         PreparedStatement ps = null;
1:6409b40:         ResultSet               rs = null;
1:6409b40: 
1:6409b40:         try {
1:6409b40:             ps = conn.prepareStatement( "values syscs_util.syscs_get_database_property('DataDictionaryVersion')" );
1:6409b40:             rs = ps.executeQuery();
1:6409b40: 
1:6409b40:             rs.next();
1:6409b40: 
1:6409b40:             return rs.getString( 1 );
1:6409b40:         }
1:6409b40:         catch (SQLException se)
1:6409b40:         {
1:6409b40:             printStackTrace( se );
1:6409b40:             return null;
1:6409b40:         }
1:6409b40:         finally
1:6409b40:         {
1:6409b40:             if ( rs != null ) { rs.close(); }
1:6409b40:             if ( ps != null ) { ps.close(); }
1:6409b40:         }
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Strip the trailing subversion stamp from a Derby version number.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private String trimDriverVersion( String driverVersion)
1:6409b40:     {
1:6409b40:         int idx = driverVersion.indexOf( ' ' );
1:6409b40:         if ( idx > 0 ) { return driverVersion.substring( 0, idx ); }
1:6409b40:         else { return driverVersion; }
1:6409b40:     }
1:6409b40: 
1:6409b40:     private void saveOriginalClassLoader()
1:6409b40:     {
1:6409b40:         // remember the original class loader so that we can reset
1:493b80e:         if ( _originalClassLoader.get() == null ) { 
1:493b80e:             _originalClassLoader.set( ClassLoaderTestSetup.getThreadLoader() ); 
1:6409b40:         }
1:493b80e:     }
1:6409b40:     private void restoreOriginalClassLoader()
1:6409b40:     {
1:493b80e:         ClassLoaderTestSetup.setThreadLoader(
1:493b80e:                 (ClassLoader) _originalClassLoader.get() );
1:6409b40:     }
1:6409b40: 
1:6409b40:     private String stringifyUpgradeRequests()
1:6409b40:     {
1:6409b40:         StringBuffer buffer = new StringBuffer();
1:6409b40:         int          count = _hardUpgradeRequests.length;
1:6409b40: 
1:6409b40:         buffer.append( "( " );
1:6409b40: 
1:6409b40:         for ( int i = 0; i < count; i++ )
1:6409b40:         {
1:6409b40:             if ( i > 0 ) { buffer.append( ", " ); }
1:6409b40:             if ( _hardUpgradeRequests[ i ] ) { buffer.append( "hard" ); }
1:6409b40:             else { buffer.append( "soft" ); }
1:6409b40:         }
1:6409b40: 
1:6409b40:         buffer.append( " )" );
1:6409b40: 
1:6409b40:         return buffer.toString();
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * Run good DDL.
1:6409b40:      */
1:6409b40:     protected void    goodStatement( Connection conn, String ddl ) throws SQLException
1:6409b40:     {
1:6409b40:         PreparedStatement    ps = chattyPrepare( conn, ddl );
1:6409b40: 
1:6409b40:         ps.execute();
1:6409b40:         ps.close();
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * Prepare a statement and report its sql text.
1:6409b40:      */
1:6409b40:     protected PreparedStatement   chattyPrepare( Connection conn, String text )
1:6409b40:         throws SQLException
1:6409b40:     {
1:6409b40:         if ( LOQUACIOUS) { println( "Preparing statement:\n\t" + text ); }
1:6409b40:         
1:6409b40:         return conn.prepareStatement( text );
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * Stringify a result set.
1:6409b40:      */
1:6409b40: 	private	String	printResultSet( ResultSet rs )
1:6409b40: 		throws SQLException
1:6409b40: 	{
1:6409b40: 		if ( rs == null )
1:6409b40: 		{
1:6409b40: 			return "Null ResultSet!";
1:6409b40: 		}
1:6409b40: 
1:6409b40: 		ResultSetMetaData	rsmd = rs.getMetaData();
1:6409b40: 		int					count = rsmd.getColumnCount();
1:6409b40: 		StringBuffer		buffer = new StringBuffer();
1:6409b40: 
1:6409b40: 		while ( rs.next() )
1:6409b40: 		{
1:6409b40: 			for ( int i = 1; i <= count; i++ )
1:6409b40: 			{
1:6409b40:                 if ( i > 1 ) { buffer.append( " | " ); }
1:6409b40: 				buffer.append( rs.getString( i ) );
1:6409b40: 			}
1:6409b40: 			buffer.append( "\n" );
1:6409b40: 		}
1:6409b40: 
1:6409b40: 		return buffer.toString();
1:6409b40: 	}
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Replace values which are known to be unstable.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void normalizeRow( String tableName, String[] columnNames, String[] row )
1:6409b40:     {
1:6409b40:         int count = row.length;
1:6409b40: 
1:6409b40:         for ( int i = 0; i < count; i++ )
1:6409b40:         {
1:6409b40:             String value = row[ i ];
1:6409b40: 
1:6409b40:             if ( isColumn( SYSCONGLOMERATES, CONGLOMERATENUMBER, tableName, columnNames[ i ] ) ) { value = DUMMY_NUMBER; }
1:6409b40:             else if ( isColumn( SYSALIASES, ALIASID, tableName, columnNames[ i ] ) )
1:6409b40:             {
1:6409b40:                 String original = value;
1:6409b40:                 value = getColumnValue( ALIAS, columnNames, row );
1:6409b40:                 _unstableColumnValues.put( original, value );
1:6409b40:             }
1:6409b40:             else if ( isColumn( SYSALIASES, SPECIFICNAME, tableName, columnNames[ i ] ) )
1:6409b40:             {
1:6409b40:                 String original = value;
1:6409b40:                 value = getColumnValue( ALIAS, columnNames, row );
1:6409b40:                 _unstableColumnValues.put( original, value );
1:6409b40:             }
1:6409b40:             else if ( isColumn( SYSSTATEMENTS, STMTID, tableName, columnNames[ i ] ) )
1:6409b40:             {
1:6409b40:                 String original = value;
1:6409b40:                 value = getColumnValue( STMTNAME, columnNames, row );
1:6409b40:                 _unstableColumnValues.put( original, value );
1:6409b40:             }
1:6409b40:             else if ( isColumn( SYSSTATEMENTS, LASTCOMPILED, tableName, columnNames[ i ] ) )
1:6409b40:             {
1:6409b40:                 value = DUMMY_TIMESTAMP;
1:6409b40:             }
1:6409b40:             else if ( isColumn( SYSSTATEMENTS, TEXT, tableName, columnNames[ i ] ) && suffersDERBY_4216( tableName ) )
1:6409b40:             {
1:6409b40:                 value = DUMMY_STRING;
1:6409b40:             }
1:6409b40:             else if ( isColumn( SYSROUTINEPERMS, ALIASID, tableName, columnNames[ i ] ) )
1:6409b40:             {
1:6409b40:                 // replace with corresponding value that was substituted into SYSALIASES
1:6409b40:                 value = (String) _unstableColumnValues.get( value );
1:6409b40:             }
1:6409b40:             else if ( isColumn( SYSROUTINEPERMS, ROUTINEPERMSID, tableName, columnNames[ i ] ) )
1:6409b40:             {
1:6409b40:                 value = DUMMY_STRING;
1:6409b40:             }
1:6409b40:             
1:6409b40:             row[ i ] = value;
1:6409b40:         }
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Return true if we are dealing with the indicated column.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private boolean isColumn( String expectedTableName, String expectedColumnName, String actualTableName, String actualColumnName )
1:6409b40:     {
1:6409b40:         return ( expectedTableName.equals( actualTableName ) && expectedColumnName.equals( actualColumnName ) );
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Return the value for the indicated columns.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private String getColumnValue( String columnName, String[] columnNames, String[] row )
1:6409b40:     {
1:6409b40:         int  count = columnNames.length;
1:6409b40:         for ( int i = 0; i < count; i++ )
1:6409b40:         {
1:6409b40:             if ( columnName.equals( columnNames[ i ] ) ) { return row[ i ]; }
1:6409b40:         }
1:6409b40: 
1:6409b40:         return null;
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Return true if the string looks like a UUID.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private boolean isUUID( String raw )
1:6409b40:     {
1:6409b40:         if (
1:6409b40:             ( raw != null ) &&
1:6409b40:             ( raw.length() == 36 ) &&
1:6409b40:             ( raw.charAt( 8 ) == '-' ) &&
1:6409b40:             ( raw.charAt( 13 ) == '-' ) &&
1:6409b40:             ( raw.charAt( 18 ) == '-' )
1:6409b40:             )
1:6409b40:         { return true; }
1:6409b40:         else { return false; }
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Debug method to print out a result set.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void printQueryResults( Connection conn, String query )
1:6409b40:         throws Exception
1:6409b40:     {
1:6409b40:         PreparedStatement ps = chattyPrepare( conn, query );
1:6409b40:         ResultSet               rs = ps.executeQuery();
1:6409b40: 
1:6409b40:         if ( LOQUACIOUS) { println( printResultSet( rs ) ); }
1:6409b40: 
1:6409b40:         rs.close();
1:6409b40:         ps.close();
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Debug method to compare the results of a query on two databases.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private void compareQueries( Connection leftConn, Connection rightConn, int colCount, String query )
1:6409b40:         throws Exception
1:6409b40:     {
1:6409b40:         PreparedStatement leftPS = chattyPrepare( leftConn, query );
1:6409b40:         PreparedStatement rightPS = chattyPrepare( rightConn, query );
1:6409b40:         ResultSet               leftRS = leftPS.executeQuery();
1:6409b40:         ResultSet               rightRS = rightPS.executeQuery();
1:6409b40:         while( leftRS.next() )
1:6409b40:         {
1:6409b40:             rightRS.next();
1:6409b40: 
1:6409b40:             for ( int i = 1; i <= colCount; i++ )
1:6409b40:             {
1:6409b40:                 String leftValue = leftRS.getString( i );
1:6409b40:                 String rightValue = rightRS.getString( i );
1:6409b40:                 boolean unequal = false;
1:6409b40: 
1:6409b40:                 if ( leftValue == null )
1:6409b40:                 {
1:6409b40:                     if ( rightValue != null ) { unequal = true; }
1:6409b40:                 }
1:6409b40:                 else if ( !leftValue.equals( rightValue ) ) { unequal = true; }
1:6409b40: 
1:6409b40:                 if ( unequal )
1:6409b40:                 {
1:6409b40:                     if ( LOQUACIOUS) { println( "Column values different for column " + i + ". Left = " + leftValue + ", right = " + rightValue ); }
1:6409b40:                 }
1:6409b40:             }
1:6409b40:         }
1:6409b40: 
1:6409b40:         leftRS.close();
1:6409b40:         rightRS.close();
1:6409b40:         leftPS.close();
1:6409b40:         rightPS.close();
1:6409b40:     }
1:6409b40:     
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40:     //
1:6409b40:     // POWER SET BUILDING MINIONS
1:6409b40:     //
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Builds the minimal set of trajectories for the supported versions. This
1:6409b40:      * is all trajectories which start at some release, then hard upgrade to
1:6409b40:      * every subsequent release up to the very last release. For a set of N
1:6409b40:      * releases, there are N-1 non-vacuous trajectories of this shape.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private static Version.Trajectory[] buildMinimalSet( Version[] supportedVersions )
1:6409b40:     {
1:eec86ed:         ArrayList<Version.Trajectory>   trajectoryList = new ArrayList<Version.Trajectory>();
1:6409b40:         int  versionCount = supportedVersions.length;
1:6409b40:         boolean[]  include = new boolean[ versionCount ];
1:6409b40: 
1:6409b40:         for ( int i = 0; i < versionCount; i++ ) { include[ i ] = true; }
1:6409b40:         addSubset( supportedVersions, trajectoryList, include, false ); 
1:6409b40: 
1:6409b40:         for ( int i = 0; i < versionCount - 1; i++ )
1:6409b40:         {
1:6409b40:             include[ i ] = false;
1:6409b40:             addSubset( supportedVersions, trajectoryList, include, false ); 
1:6409b40:         }
1:6409b40: 
1:6409b40:         return squeezeArray( trajectoryList );
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Build the power set of all supported versions.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private static Version.Trajectory[] buildPowerSet( Version[] supportedVersions )
1:6409b40:     {
1:eec86ed:         ArrayList<Version.Trajectory>   trajectoryList = new ArrayList<Version.Trajectory>();
1:6409b40:         int            versionCount = supportedVersions.length;
1:6409b40:         boolean[]  include = new boolean[ versionCount ];
1:6409b40: 
1:6409b40:         buildPowerSetMinion( supportedVersions, trajectoryList, include, 0, TRJ_SAME_BRANCH_NEIGHBORS );
1:6409b40: 
1:6409b40:         return squeezeArray( trajectoryList );
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Turn a list of trajectories into an array.
1:6409b40:      * </p>
1:6409b40:      */
1:eec86ed:     private static Version.Trajectory[] squeezeArray( ArrayList<Version.Trajectory> trajectoryList )
1:6409b40:     {
1:6409b40:         Version.Trajectory[] result = new Version.Trajectory[ trajectoryList.size() ];
1:6409b40:         trajectoryList.toArray( result );
1:6409b40: 
1:6409b40:         return result;
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Recursive workhorse to build the power set of supported versions. If
1:6409b40:      * requested, we also prune out all trajectories which have adjacent
1:6409b40:      * versions from the same branch. If we're hard-upgrading, between releases,
1:6409b40:      * then these SHOULD be uninteresting combinations.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private static void buildPowerSetMinion
1:eec86ed:         ( Version[] supportedVersions, ArrayList<Version.Trajectory> result, boolean[] include, int idx, boolean removeSameBranchNeighbors )
1:6409b40:     {
1:6409b40:         int  versionCount = supportedVersions.length;
1:6409b40: 
1:6409b40:         if ( idx >= versionCount ) { addSubset( supportedVersions, result, include, removeSameBranchNeighbors ); }
1:6409b40:         else
1:6409b40:         {
1:6409b40:             include[ idx ] = true;
1:6409b40:             buildPowerSetMinion( supportedVersions, result, include, idx + 1, removeSameBranchNeighbors );
1:6409b40:             
1:6409b40:             include[ idx ] = false;
1:6409b40:             buildPowerSetMinion( supportedVersions, result, include, idx + 1, removeSameBranchNeighbors );
1:6409b40:         }
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Add a subset to the evolving list of subsets of supported versions. Throw
1:6409b40:      * out the empty set and singletons. We sort each trajectory so that its
1:6409b40:      * versions are in ascending order.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private static void addSubset
1:eec86ed:         ( Version[] supportedVersions, ArrayList<Version.Trajectory> result, boolean[] include, boolean removeSameBranchNeighbors )
1:6409b40:     {
1:6409b40:         int  versionCount = supportedVersions.length;
1:6409b40: 
1:eec86ed:         ArrayList<Version> seed = new ArrayList<Version>();
1:6409b40:         Version   previousVersion = null;
1:6409b40:         
1:6409b40:         for ( int i = 0; i < versionCount; i++ )
1:6409b40:         {
1:6409b40:             Version  thisVersion = supportedVersions[ i  ];
1:6409b40: 
1:6409b40:             if ( include[ i ] )
1:6409b40:             {
1:6409b40:                 //
1:6409b40:                 // If adjacent version are from the same branch, remove them if
1:6409b40:                 // requested to.
1:6409b40:                 //
1:6409b40:                 if ( removeSameBranchNeighbors && ( previousVersion != null ) )
1:6409b40:                 {
1:6409b40:                     if ( previousVersion.getBranchID().equals( thisVersion.getBranchID() ) )
1:6409b40:                     {
1:6409b40:                         continue;
1:6409b40:                     }
1:6409b40:                 }
1:6409b40:                 
1:6409b40:                 previousVersion = thisVersion;                
1:6409b40:                 seed.add( thisVersion );
1:6409b40:             }
1:6409b40:         }
1:6409b40:         int  seedSize = seed.size();
1:6409b40:         
1:6409b40:         if ( seedSize > 1 )
1:6409b40:         {
1:6409b40:             Version[] subset = new Version[ seedSize ];
1:6409b40:             seed.toArray( subset );
1:6409b40:             
1:6409b40:             result.add( (new Version.Trajectory( subset )).sort() );
1:6409b40:         }
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Return empty string if passed in result is a known problem.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private String filterKnownProblems( String tableName, String actual )
1:6409b40:     {
1:6409b40:         if (
1:8298d7c:             _trajectory.endsAt( BRANCH_10_5 ) &&
1:6409b40:             ( contains( actual, DERBY_4214_1 ) || contains( actual, DERBY_4214_2 ) )
1:6409b40:            )
1:6409b40:         { return ""; }
1:6409b40: 
1:6409b40:         if (
1:6409b40:             suffersDERBY_4215( tableName ) &&
1:6409b40:             ( contains( actual, DERBY_4215 ) )
1:6409b40:            )
1:6409b40:         { return ""; }
1:6409b40: 
1:6409b40:         return actual;
1:6409b40:     }
1:6409b40: 
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Return true if the conditions of DERBY-4215 exist.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private boolean suffersDERBY_4215( String tableName )
1:6409b40:     {
1:6409b40:         return
1:6409b40:                  (
1:6409b40:                      SYSROUTINEPERMS.equals( tableName ) &&
1:6409b40:                      _trajectory.startsAt( BRANCH_10_0 ) &&
1:6409b40:                      ( !_trajectory.contains( BRANCH_10_1 ) ) &&
1:b05fa6e:                      (
1:b05fa6e:                       _trajectory.contains( BRANCH_10_2 ) ||
1:b05fa6e:                       _trajectory.contains( BRANCH_10_3 ) ||
1:b05fa6e:                       _trajectory.contains( BRANCH_10_4 )
1:b05fa6e:                       ) &&
1:b05fa6e:                      ( _trajectory.getEndingVersion().compareTo( VERSION_10_6_0_0 )  < 0 )
1:6409b40:                  );
1:6409b40:     }
1:6409b40:     
1:6409b40:     /**
1:6409b40:      * <p>
1:6409b40:      * Return true if the conditions of DERBY-4216 exist.
1:6409b40:      * </p>
1:6409b40:      */
1:6409b40:     private boolean suffersDERBY_4216( String tableName )
1:6409b40:     {
1:6409b40:         return
1:6409b40:                  (
1:6409b40:                      SYSSTATEMENTS.equals( tableName ) &&
1:6409b40:                      _trajectory.startsAt( BRANCH_10_0 ) &&
1:6409b40:                      _trajectory.endsAt( BRANCH_10_1 )
1:6409b40:                  );
1:6409b40:     }
1:6409b40:     
1:6409b40:     private boolean contains( String left, String right )
1:6409b40:     {
1:6409b40:         return ( left.indexOf( right ) >= 0 );
1:6409b40:     }
1:6409b40:     
1:6409b40:     
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40:     //
1:6409b40:     // INNER CLASSES
1:6409b40:     //
1:6409b40:     ///////////////////////////////////////////////////////////////////////////////////
1:6409b40: 
1:6409b40: 
1:6409b40: }
1:6409b40: 
1:6409b40: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:         Boolean bool = Boolean.valueOf(getSystemProperty( ALL_TRAJECTORIES_PROPERTY ));
commit:eec86ed
/////////////////////////////////////////////////////////////////////////
1:     private HashMap<String,String>     _unstableColumnValues = new HashMap<String,String>();
1:     private static ThreadLocal<ClassLoader> _originalClassLoader = new ThreadLocal<ClassLoader>();
/////////////////////////////////////////////////////////////////////////
1:     private ArrayList<String> listSystemTables
1:         ArrayList<String> result = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<String> columnNames = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Version.Trajectory>   trajectoryList = new ArrayList<Version.Trajectory>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<Version.Trajectory>   trajectoryList = new ArrayList<Version.Trajectory>();
/////////////////////////////////////////////////////////////////////////
1:     private static Version.Trajectory[] squeezeArray( ArrayList<Version.Trajectory> trajectoryList )
/////////////////////////////////////////////////////////////////////////
1:         ( Version[] supportedVersions, ArrayList<Version.Trajectory> result, boolean[] include, int idx, boolean removeSameBranchNeighbors )
/////////////////////////////////////////////////////////////////////////
1:         ( Version[] supportedVersions, ArrayList<Version.Trajectory> result, boolean[] include, boolean removeSameBranchNeighbors )
1:         ArrayList<Version> seed = new ArrayList<Version>();
commit:d15f717
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBCClient;
1: import org.apache.derbyTesting.junit.JDBCClientSetup;
/////////////////////////////////////////////////////////////////////////
1:     public static Version VERSION_10_2_2_0 = new Version( 10, 2, 2, 0 );
/////////////////////////////////////////////////////////////////////////
1: 
1:         // If the first release in the trajectory pre-dates the release which
1:         // introduced JDBC4, force the client to be the JDBC3 client. This
1:         // prevents us from falling through and picking up the JDBC4 data source from
1:         // the system classpath rather than picking up a datasource from
1:         // the version-specific classloader.
1:         if ( trajectory.getVersion( 0 ).compareTo( VERSION_10_2_2_0 ) < 0 )
1:         {
1:             setup = new JDBCClientSetup( setup, JDBCClient.EMBEDDED_30 );
1:         }
1:         
commit:8298d7c
/////////////////////////////////////////////////////////////////////////
1:             _trajectory.endsAt( BRANCH_10_5 ) &&
commit:b05fa6e
/////////////////////////////////////////////////////////////////////////
1:     public static Version VERSION_10_6_0_0 = new Version( 10, 6, 0, 0 );
1:     public static String BRANCH_10_2 = "10.2";
1:     public static String BRANCH_10_3 = "10.3";
1:     public static String BRANCH_10_4 = "10.4";
1:     public static String BRANCH_10_5 = "10.5";
/////////////////////////////////////////////////////////////////////////
1:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 3, 3, 0 ), new Version( 10, 5, 1, 1 ) } ),
1:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 3, 3, 0 ), new Version( 10, 6, 0, 0 ) } ),
/////////////////////////////////////////////////////////////////////////
1:                      (
1:                       _trajectory.contains( BRANCH_10_2 ) ||
1:                       _trajectory.contains( BRANCH_10_3 ) ||
1:                       _trajectory.contains( BRANCH_10_4 )
1:                       ) &&
1:                      ( _trajectory.getEndingVersion().compareTo( VERSION_10_6_0_0 )  < 0 )
commit:6409b40
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeTrajectoryTest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.upgradeTests;
1: 
1: import java.lang.reflect.Method;
1: import java.sql.Connection;
0: import java.sql.DatabaseMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
0: import java.sql.Statement;
1: import java.util.ArrayList;
1: import java.util.HashMap;
1: import java.util.Properties;
1: import javax.sql.DataSource;
1: 
1: import junit.extensions.TestSetup;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derby.jdbc.ClientBaseDataSource;
0: import org.apache.derby.jdbc.EmbeddedDataSource;
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * <p>
1:  * Test upgrade trajectories. This test compares the metadata in
1:  * upgraded databases to the metadata in databases created from scratch.
1:  * Given a collection of releases, this test does the following:
1:  * </p>
1:  *
1:  * <ul>
1:  * <li>Builds either a minimal set of trajectories or the full set of possible
1:  * trajectories:
1:  *  <ul>
1:  *   <li>By default, just builds a minimal set of trajectories. These are all
1:  *   trajectories which begin with some release, then upgrade through all
1:  *   intermediate releases to the highest release in the original collection of
1:  *   all releases. A set of N releases gives rise to N-1 minimal trajectories.</li>
0:  *   <li>Otherwise, if the system property derbyTesting.allTrajectories is set to true, builds the set of all upgrade trajectories possible on that collection of
0:  *   releases. An upgrade trajectory is a sorted subset of those releases. Each
0:  *   subset is sorted in ascending release order. We exclude the vacuous empty
0:  *   subset and the uninteresting singleton subsets. A set of N releases
0:  *   gives rise to ((2**N) - N) - 1 hard-upgrade trajectories.</li>
1:  *  </ul>
1:  * </li>
1:  * <li>For each trajectory, we create two databases:
1:  *  <ul>
1:  *   <li>A starting point database created with the first release in the
1:  *   trajectory. This database is then upgraded through all of the intermediate
1:  *   releases in the trajectory until it is at the level of the last release in
1:  *   the trajectory.</li>
1:  *   <li>An ending point database created with the last release in the
1:  *   trajectory.</li>
1:  *  </ul>
1:  *</li>
1:  * <li>We then compare the metadata in the starting point and ending point
1:  * databases.</li>
1:  * </ul>
1:  *
1:  * <p>
1:  * By default we don't consider soft-upgrades. Also by default, we consider
1:  * trajectories with more than one release from the same branch. You can
1:  * parameterize or customize some constants (see below) if you want to change
1:  * these decisions.
1:  * </p>
1:  *
1:  * <p>
0:  * By default we consider all trajectories possible on the collection of
0:  * releases listed in _Suite. If you want to consider a different collection of
0:  * releases, you can override the _Suite collection by setting the system
0:  * property "derbyTesting.oldVersionsPath". Here, for instance, is the command
1:  * line to run this test against a customized list of releases:
1:  * </p>
1:  *
1:  * <blockquote><pre>
1:  *  java -XX:MaxPermSize=128M -Xmx512m \
1:  *  -DderbyTesting.oldReleasePath=/Users/me/myDerbyReleaseDirectory \
1:  *  -DderbyTesting.oldVersionsPath=/Users/me/fileContainingMyListOfTastyReleases \
1:  *  junit.textui.TestRunner org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeTrajectoryTest
1:  * </pre></blockquote>
1:  *
1:  * <p>
1:  * For extra verbose output, you can set the "derby.tests.debug" property too:
1:  * </p>
1:  *
1:  * <blockquote><pre>
1:  *  java -XX:MaxPermSize=128M -Xmx512m \
1:  *  -DderbyTesting.oldReleasePath=/Users/me/myDerbyReleaseDirectory \
1:  *  -DderbyTesting.oldVersionsPath=/Users/me/fileContainingMyListOfTastyReleases \
1:  *  -Dderby.tests.debug=true \
1:  *  junit.textui.TestRunner org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeTrajectoryTest
1:  * </pre></blockquote>
1:  *
1:  * <p>
1:  * Here is the command line to run all upgrade trajectories against a customized list of releases:
1:  * </p>
1:  *
1:  * <blockquote><pre>
1:  *  java -XX:MaxPermSize=128M -Xmx512m \
1:  *  -DderbyTesting.allTrajectories=true \
1:  *  -DderbyTesting.oldReleasePath=/Users/me/myDerbyReleaseDirectory \
1:  *  -DderbyTesting.oldVersionsPath=/Users/me/fileContainingMyListOfTastyReleases \
1:  *  junit.textui.TestRunner org.apache.derbyTesting.functionTests.tests.upgradeTests.UpgradeTrajectoryTest
1:  * </pre></blockquote>
1:  *
1:  * <p>
1:  * If you need to test a particular trajectory, you can hand-edit
0:  * makeSampleTrajectories() and uncomment the call to it.
1:  * </p>
1:  *
1:  */
1: public class UpgradeTrajectoryTest extends BaseJDBCTestCase
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public static final String ALL_TRAJECTORIES_PROPERTY = "derbyTesting.allTrajectories";
1: 
1:     public static Version VERSION_10_0_2_1 = new Version( 10, 0, 2, 1 );
1:     public static Version VERSION_10_1_3_1 = new Version( 10, 1, 3, 1 );
1:     public static Version VERSION_10_5_1_1 = new Version( 10, 5, 1, 1 );
1: 
1:     public static Version.Trajectory TRAJECTORY_10_0_2_1_TO_10_1_3_1 = new Version.Trajectory( new Version[] { VERSION_10_0_2_1, VERSION_10_1_3_1 } );
0:     public static Version.Trajectory TRAJECTORY_10_0_2_1_TO_10_5_1_1 = new Version.Trajectory( new Version[] { VERSION_10_0_2_1, VERSION_10_5_1_1 } );
1: 
1:     public static String BRANCH_10_0 = "10.0";
1:     public static String BRANCH_10_1 = "10.1";
1: 
1:     public static final String UPGRADED_DATABASE = "old_database";
1:     public static final String VIRGIN_DATABASE = "new_database";
1:     public static final String COMPARISON_DATABASE = "comparison_database";
1:     private static final String DUMMY_NUMBER = "123";
1:     private static final String DUMMY_STRING = "BLAHBLAH";
1:     private static final String DUMMY_TIMESTAMP = "123456";
1: 
1:     private static final String DERBY_4214_1 = "RETURNS VARCHAR(32672)";
1:     private static final String DERBY_4214_2 = "RETURNS VARCHAR(10890)";
1:     private static final String DERBY_4215 = "SYSCS_INPLACE_COMPRESS_TABLE";
1: 
1:     //
1:     // Parameterize or change these switches if you want to alter the set of
1:     // trajectories which we consider:
1:     //
1:     private static final boolean TRJ_IGNORE_SOFT_UPGRADE = true;
1:     private static final boolean TRJ_SAME_BRANCH_NEIGHBORS = false;
1: 
1:     private static final String SYSALIASES = "SYSALIASES";
1:     private static final String SYSCONGLOMERATES = "SYSCONGLOMERATES";
1:     private static final String SYSSTATEMENTS = "SYSSTATEMENTS";
1:     private static final String SYSROUTINEPERMS = "SYSROUTINEPERMS";
1: 
1:     private static final String CONGLOMERATENUMBER = "CONGLOMERATENUMBER";
1:     private static final String ALIAS = "ALIAS";
1:     private static final String ALIASID = "ALIASID";
1:     private static final String SPECIFICNAME = "SPECIFICNAME";
1:     private static final String STMTID = "STMTID";
1:     private static final String STMTNAME = "STMTNAME";
1:     private static final String TEXT = "TEXT";
1:     private static final String ROUTINEPERMSID = "ROUTINEPERMSID";
1:     private static final String LASTCOMPILED = "LASTCOMPILED";
1: 
1:     private static final boolean LOQUACIOUS = false;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private Version.Trajectory _trajectory;
1:     private String             _trajectoryName;
1:     private boolean[]          _hardUpgradeRequests;
1:     
0:     private HashMap     _unstableColumnValues = new HashMap();
1: 
0:     private static ThreadLocal _originalClassLoader = new ThreadLocal();
1: 
1:     // these are the system tables which must be read first in order to
1:     // prep the mapping of unstable identifiers
1:     private static String[] INITIAL_TABLES = new String[]
1:     {
1:         "SYSALIASES",
1:     };
1: 
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public UpgradeTrajectoryTest( Version.Trajectory trajectory, boolean[] hardUpgradeRequests )
1:     {
1:         super( "testTrajectory" );
1: 
1:         _trajectory = trajectory;
1:         _hardUpgradeRequests = hardUpgradeRequests;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return the suite of tests.
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("Upgrade trajectory test");
1: 
1:         addTrajectories( suite );
1:         
1:         Test sfs = new SupportFilesSetup((Test) suite);
1: 
1:         return SecurityManagerSetup.noSecurityManager( sfs );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Add all of the trajectories we intend to test.
1:      * </p>
1:      */
0:     private static void addTrajectories( TestSuite suite )
1:     {
1:         Version.Trajectory[] trajectories = makeTrajectories();
1:         int                  count = trajectories.length;
1: 
1:         println( "Found " + count + " trajectories." );
1: 
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             // right now, we're only testing hard upgrade.
1:             addHardUpgradeOnlyTrajectory( suite, trajectories[ i ] );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Make all known upgrade trajectories. This amounts to every non-vacuous
1:      * subset of the known versions.
1:      * </p>
1:      */
1:     private static Version.Trajectory[] makeTrajectories()
1:     {
1:         Version[]   supportedVersions = getSupportedVersions();
1:         Version.Trajectory[] result;
1: 
1:         //
1:         // If requested to, we construct the power set of supported versions, throwing
1:         // out the non-upgradable subsets, viz., the empty set and the
1:         // singletons. We include hard upgrades between releases on the same
1:         // branch.
1:         //
1:         // By default we don't test all trajectories. We only test the
1:         // trajectories which are complete sequences from a starting point up to
1:         // the last release.
1:         //
1:         if ( shouldBuildAllTrajectories() ) { result = buildPowerSet( supportedVersions ); }
1:         else { result = buildMinimalSet( supportedVersions ); }
1:         
1:         //
1:         // Uncomment this line if you just want to test a couple sample
1:         // trajectories.
1:         //
1:         //result = makeSampleTrajectories();
1:         
1:         return result;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Return true if we should build all trajectories.
1:      * </p>
1:      */
1:     private static boolean shouldBuildAllTrajectories()
1:     {
0:         Boolean bool = new Boolean( getSystemProperty( ALL_TRAJECTORIES_PROPERTY ) );
1: 
1:         return bool.booleanValue();
1:     }
1:     
1:     /**
1:      * <p>
1:      * Sample trajectory for debugging this program.
1:      * </p>
1:      */
1:     private static Version.Trajectory[] makeSampleTrajectories()
1:     {
1:         return new Version.Trajectory[]
1:         {
1:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 1, 3, 1 ) } ),
1:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 3, 3, 0 ) } ),
1:             new Version.Trajectory( new Version[] { new Version( 10, 0, 2, 1), new Version( 10, 5, 1, 1 ) } ),
1:             new Version.Trajectory( new Version[] { new Version( 10, 4, 2, 1), new Version( 10, 5, 1, 1 ) } ),
1:         };
1: 
1:     }
1:     
1:     /**
1:      * <p>
1:      * Get the supported versions.
1:      * </p>
1:      */
1:     private static Version[] getSupportedVersions()
1:     {
1:         int[][]      raw = OldVersions.getSupportedVersions();
1:         int          count = raw.length;
1:         Version[] result = new Version[ count ];
1: 
1:         for ( int i = 0; i < count; i++ ) { result[ i ] = new Version( raw[ i ] ); }
1: 
1:         return result;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Add only the test case which hard-upgrades along all edges of the Trajectory.
1:      * </p>
1:      */
0:     private static void addHardUpgradeOnlyTrajectory( TestSuite suite, Version.Trajectory trajectory )
1:     {
1:         // a valid trajectory must have a start point and a different end point
1:         int       versionCount = trajectory.getVersionCount();
1:         if ( versionCount < 2 ) { return; }
1:         
1:         boolean[] hardUpgradeRequests = new boolean[ versionCount ];
1: 
1:         // the start point is always hard
1:         for ( int i = 0; i < versionCount; i++ ) { hardUpgradeRequests[ i ] = true; }
1: 
1:         addTrajectory( suite, trajectory, hardUpgradeRequests );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Add a single trajectory to the suite, looping through all combinations of
1:      * hard and softupgrade.
1:      * </p>
1:      */
0:     private static void addTrajectory( TestSuite suite, Version.Trajectory trajectory )
1:     {
1:         // a valid trajectory must have a start point and a different end point
1:         int       versionCount = trajectory.getVersionCount();
1:         if ( versionCount < 2 ) { return; }
1:         
1:         boolean[] hardUpgradeRequests = new boolean[ versionCount ];
1: 
1:         // the start point is always hard unless you parameterize the following constant
1:         hardUpgradeRequests[ 0 ] = TRJ_IGNORE_SOFT_UPGRADE;
1: 
1:         addTrajectory( suite, trajectory, hardUpgradeRequests, 1 );
1:     }
1: 
0:     private static void addTrajectory( TestSuite suite, Version.Trajectory trajectory, boolean[] hardUpgradeRequests, int idx )
1:     {
1:         if ( idx >= trajectory.getVersionCount() )
1:         {
1:             addTrajectory( suite, trajectory, hardUpgradeRequests );
1:         }
1:         else
1:         {
1:             boolean[] hard = clone( hardUpgradeRequests );
1:             boolean[] soft = clone( hardUpgradeRequests );
1:             
1:             hard[ idx ] = true;
1:             addTrajectory( suite, trajectory, hard, idx + 1 );
1: 
1:             soft[ idx ] = false;
1:             addTrajectory( suite, trajectory, soft, idx + 1 );
1:         }
1:     }
1: 
1:     private static boolean[] clone( boolean[] input )
1:     {
1:         int       count = input.length;
1:         boolean[] output = new boolean[ count ];
1: 
1:         for ( int i = 0; i < count; i++ ) { output[ i ] = input[ i ]; }
1: 
1:         return output;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Add a single trajectory to the suite, with upgrade instructions.
1:      * </p>
1:      */
0:     private static void addTrajectory( TestSuite suite, Version.Trajectory trajectory, boolean[] hardUpgradeRequests )
1:     {
1:         UpgradeTrajectoryTest utt = new UpgradeTrajectoryTest( trajectory, hardUpgradeRequests );
1:         TestSetup setup = TestConfiguration.additionalDatabaseDecorator( utt, UPGRADED_DATABASE );
1:         setup =  TestConfiguration.additionalDatabaseDecorator( setup, VIRGIN_DATABASE );
1:         setup =  TestConfiguration.additionalDatabaseDecorator( setup, COMPARISON_DATABASE );
1: 
1:         Properties preReleaseUpgrade = new Properties();
1:         preReleaseUpgrade.setProperty( "derby.database.allowPreReleaseUpgrade", "true");
1:         
1:         setup = new SystemPropertyTestSetup(setup, preReleaseUpgrade );
1:         suite.addTest( setup );
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Test a single trajectory.
1:      * </p>
1:      */
1:     public void testTrajectory() throws Exception
1:     {
1:         _trajectoryName = _trajectory.toString() + ' ' + stringifyUpgradeRequests();
1: 
1:         println( "Testing trajectory: " + _trajectoryName );
1: 
1:         // there must be at least 2 versions in a trajectory, otherwise the
1:         // test is vacuous
1:         int  versionCount = _trajectory.getVersionCount();
1:         assertTrue( _trajectoryName, versionCount > 1 );
1: 
1:         // remember the original class loader
1:         saveOriginalClassLoader();
1: 
1:         try {
1:             Version startDataVersion = _trajectory.getVersion( 0 );
1:             Version endDataVersion = startDataVersion;
1: 
1:             createDatabase( startDataVersion, UPGRADED_DATABASE );
1: 
1:             // now upgrade the database through the whole chain
1:             for ( int i = 1; i < versionCount; i++ )
1:             {
1:                 Version nextSoftwareVersion = _trajectory.getVersion( i );
1:                 boolean hardUpgrade = _hardUpgradeRequests[ i ];
1: 
1:                 if ( hardUpgrade ) { endDataVersion = nextSoftwareVersion; }
1: 
1:                 upgradeDatabase( nextSoftwareVersion, endDataVersion, hardUpgrade, UPGRADED_DATABASE );
1:             }
1: 
1:             createDatabase( endDataVersion, VIRGIN_DATABASE );
1: 
1:             if ( LOQUACIOUS) { println( "    End version is " + endDataVersion ); }
1: 
1:             compareDatabases( endDataVersion, UPGRADED_DATABASE, VIRGIN_DATABASE );
1:         }
1:         finally
1:         {
1:             restoreOriginalClassLoader();
1: 
1:             // reboot the databases so that DropDatabaseSetup can remove them
1:             bootDatabase( UPGRADED_DATABASE );
1:             bootDatabase( VIRGIN_DATABASE );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Compare the metadata in two databases.
1:      * </p>
1:      */
1:     private void compareDatabases( Version version, String leftDatabaseName, String rightDatabaseName )
1:         throws Exception
1:     {
0:         UpgradeClassLoader.setThreadLoader( version.getClassLoader() );
1: 
1:         DataSource leftDS = makeDataSource( leftDatabaseName );
1:         DataSource rightDS = makeDataSource( rightDatabaseName );
1:         DataSource comparisonDS = bootDatabase( COMPARISON_DATABASE );
1:         Connection leftConn = leftDS.getConnection();
1:         Connection rightConn = rightDS.getConnection();
1:         Connection comparisonConn = comparisonDS.getConnection();
1: 
1:         //        compareQueries( leftConn, rightConn, 2, "select stmtname, lastcompiled from sys.sysroutineperms order by stmtname" );
1:         //        boolean b = true;
1:         //        if ( b ) { return; }
1: 
1: 
1:         try {
1: 
1:             goodStatement( comparisonConn, "create schema " + leftDatabaseName );
1:             goodStatement( comparisonConn, "create schema " + rightDatabaseName );
1: 
1:             compareResults
1:                 ( leftConn, rightConn, comparisonConn, leftDatabaseName, rightDatabaseName, "first_table", "select tablename from sys.systables where tabletype = 'S'" );
1: 
1:             // compare the tables which must come first
1:             int initialTableCount = INITIAL_TABLES.length;
1:             for ( int i = 0; i < initialTableCount; i++ )
1:             {
1:                 String systemTableName = INITIAL_TABLES[ i ];
1:                 compareResults
1:                     ( leftConn, rightConn, comparisonConn, leftDatabaseName, rightDatabaseName, systemTableName, "select * from sys." + systemTableName );
1:             }
1: 
1:             // now compare the other tables
1:             ArrayList systemTables = listSystemTables( comparisonConn );
1:             int          count = systemTables.size();
1: 
1:             for ( int i = 0; i < count; i++ )
1:             {
1:                 String systemTableName = (String) systemTables.get( i );
1:                 compareResults
1:                     ( leftConn, rightConn, comparisonConn, leftDatabaseName, rightDatabaseName, systemTableName, "select * from sys." + systemTableName );
1:             }
1: 
1:         }
1:         finally
1:         {
1:             shutdownDatabase( leftDS );
1:             shutdownDatabase( rightDS );
1:             shutdownDatabase( comparisonDS );
1:         }
1: 
1:     }
1:     
1:     /**
1:      * <p>
1:      * Get the names of all the system tables in the database except for the
1:      * list of initial tables.
1:      * </p>
1:      */
0:     private ArrayList listSystemTables
1:         ( Connection conn )
1:         throws Exception
1:     {
0:         ArrayList result = new ArrayList();
1: 
1:         StringBuffer buffer = new StringBuffer();
1: 
1:         buffer.append( "select tablename from sys.systables where tabletype = 'S' and tablename != 'SYSDUMMY1'" );
1:         int initialTableCount = INITIAL_TABLES.length;
1:         for ( int i = 0; i < initialTableCount; i++ )
1:         {
1:             buffer.append( " and tablename != '" );
1:             buffer.append( INITIAL_TABLES[ i ] );
1:             buffer.append( "'" );
1:         }
1:         buffer.append( " order by tablename" );
1:         
1:         PreparedStatement ps = chattyPrepare( conn,  buffer.toString() );
1:         ResultSet               rs = ps.executeQuery();
1: 
1:         while ( rs.next() )
1:         {
1:             result.add( rs.getString( 1 ) );
1:         }
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         return result;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Compare the results of a query in two databases.
1:      * </p>
1:      */
1:     private void compareResults
1:         ( Connection leftConn, Connection rightConn, Connection comparisonConn, String leftSchema, String rightSchema, String tableName, String query )
1:         throws Exception
1:     {
1:         String leftTableName = leftSchema + "." + tableName;
1:         String rightTableName = rightSchema + "." + tableName;
1:         StringBuffer columnList = new StringBuffer();
1:         StringBuffer insertList = new StringBuffer();
0:         ArrayList columnNames = new ArrayList();
1: 
1:         PreparedStatement leftPS = chattyPrepare( leftConn, query );
1:         PreparedStatement rightPS = chattyPrepare( rightConn, query );
1:         ResultSet leftSelect = leftPS.executeQuery();
1:         ResultSet rightSelect = rightPS.executeQuery();
1:         PreparedStatement leftInsert = null;
1:         PreparedStatement rightInsert = null;
1: 
1:         try {
1:             //
1:             // First create the tables to hold the left and right results.
1:             //
1:             ResultSetMetaData leftRSMD = leftSelect.getMetaData();
1:             ResultSetMetaData rightRSMD = rightSelect.getMetaData();
1:             int columnCount = leftRSMD.getColumnCount();
1:             String sampleColumnName = null;
1: 
1:             assertEquals( _trajectoryName, leftRSMD.getColumnCount(), rightRSMD.getColumnCount() );
1: 
1:             columnList.append( "\n( " );
1:             insertList.append( "\n( " );
1:             for ( int i = 1; i <= columnCount; i++ )
1:             {
1:                 if ( i > 1 )
1:                 {
1:                     columnList.append( ", " );
1:                     insertList.append( ", " );
1:                 }
1:                 String columnName = leftRSMD.getColumnName(  i );
1:                 if ( i == 1 ) { sampleColumnName = columnName; }
1:                 columnNames.add( columnName );
1:                 
1:                 assertEquals( _trajectoryName, leftRSMD.getColumnName( i ), rightRSMD.getColumnName( i ) );
1:                 assertEquals( _trajectoryName, leftRSMD.getColumnType( i ), rightRSMD.getColumnType( i  ) );
1: 
1:                 columnList.append( columnName );
1:                 columnList.append( " varchar( 10000 )" );
1:                 insertList.append( "?" );
1:             }
1:             columnList.append( "\n)" );
1:             insertList.append( "\n)" );
1: 
1:             String colList = columnList.toString();
1:             String insList = insertList.toString();
1: 
1:             goodStatement( comparisonConn, "create table " + leftTableName + colList );
1:             goodStatement( comparisonConn, "create table " + rightTableName + colList );
1:             
1:             leftInsert = chattyPrepare( comparisonConn, "insert into " + leftTableName + " values " + insList );
1:             rightInsert = chattyPrepare( comparisonConn, "insert into " + rightTableName + " values " + insList );
1: 
1:             // now loop through the metadata rows, copying them into the
1:             // comparison tables
1:             int leftCount = stuffTable( tableName, leftSelect, leftInsert );
1:             int rightCount = stuffTable( tableName, rightSelect, rightInsert );
1: 
1:             if (
1:                 (!suffersDERBY_4215( tableName )) &&
1:                 (!suffersDERBY_4216( tableName ))
1:                 )
1:             { assertEquals( _trajectoryName + ": " + tableName, leftCount, rightCount ); }
1:             else { assertTrue( _trajectoryName + ": " + tableName, leftCount != rightCount ); }
1: 
1:             // now compare the copied metadata, using left joins
1:             leftJoin( comparisonConn, columnNames, tableName, leftTableName, rightTableName );
1:             if ( !suffersDERBY_4216( tableName ) )
1:             { leftJoin( comparisonConn, columnNames, tableName, rightTableName, leftTableName ); }
1:         }
1:         finally
1:         {
1:             leftSelect.close();
1:             rightSelect.close();
1:             leftPS.close();
1:             rightPS.close();
1: 
1:             if ( leftInsert != null ) { leftInsert.close(); }
1:             if ( rightInsert != null ) { rightInsert.close(); }
1:         }
1:         
1:     }
1: 
1:     /**
1:      * <p>
1:      * Copy metadata from a source table into a target table.
1:      * </p>
1:      */
1:     private int stuffTable( String tableName, ResultSet select, PreparedStatement insert ) throws Exception
1:     {
1:         ResultSetMetaData rsmd = select.getMetaData();
1:         int  columnCount = rsmd.getColumnCount();
1:         int  rowCount = 0;
1: 
1:         String[] columnNames = new String[ columnCount ];
1:         for ( int i = 0; i < columnCount; i++ ) { columnNames[ i ] = rsmd.getColumnName( i + 1 ); }
1: 
1:         String[] row = new String[ columnCount ];
1: 
1:         while ( select.next() )
1:         {
1:             for ( int i = 0; i < columnCount; i++ )
1:             {
1:                 row[ i ] = select.getString( i + 1 );
1:             }
1:             normalizeRow( tableName, columnNames, row );
1:             
1:             for ( int i = 0; i < columnCount; i++ )
1:             {
1:                 insert.setString( i + 1, row[ i ]  );
1:             }
1:             insert.executeUpdate();
1:             rowCount++;
1:         }
1: 
1:         return rowCount;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Left join two tables and verify that the result is empty.
1:      * </p>
1:      */
1:     private void leftJoin( Connection conn, ArrayList columnNames, String tableName, String leftTableName, String rightTableName )
1:         throws Exception
1:     {
1:         PreparedStatement selectPS = null;
1:         ResultSet select = null;
1: 
1:         String sampleColumn = (String) columnNames.get( 0 );
1:         StringBuffer buffer = new StringBuffer();
1: 
1:         buffer.append( "select *\nfrom " );
1:         buffer.append( leftTableName );
1:         buffer.append( " l left join " );
1:         buffer.append( rightTableName );
1:         buffer.append( " r\non " );
1:         int count = columnNames.size();
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             if ( i > 0 ) { buffer.append( "and " ); }
1: 
1:             String columnName = (String) columnNames.get( i );
1:             buffer.append( "( ( l." );
1:             buffer.append( columnName );
1:             buffer.append( " = r." );
1:             buffer.append( columnName );
1:             buffer.append( " ) or ( l." );
1:             buffer.append( columnName );
1:             buffer.append( " is null and r." );
1:             buffer.append( columnName );
1:             buffer.append( " is null ) )\n" );
1:         }
1:         buffer.append( "where r." );
1:         buffer.append( sampleColumn );
1:         buffer.append( " is null" );
1:         
1: 
1:         try {
1:             selectPS = chattyPrepare
1:                 (
1:                  conn,
1:                  buffer.toString()
1:                  );
1:             select = selectPS.executeQuery();
1: 
1:             String expected = "";
1:             String actual = filterKnownProblems( tableName, printResultSet( select ) );
1: 
1:             assertEquals( _trajectoryName + ": " + leftTableName + " vs. " + rightTableName, expected, actual );
1:         }
1:         finally
1:         {
1:             if ( select != null ) { select.close(); }
1:             if ( selectPS != null ) { selectPS.close(); }
1:         }
1: 
1:     }
1:     
1:     /**
1:      * <p>
1:      * Create a database using the indicated version of Derby.
1:      * </p>
1:      */
1:     private void createDatabase( Version version, String logicalDatabaseName )
1:         throws Exception
1:     {
0:         UpgradeClassLoader.setThreadLoader( version.getClassLoader() );
1: 
1:         DataSource ds = bootDatabase( logicalDatabaseName );
1: 
1:         Connection conn = ds.getConnection();
1: 
1:         vetDBVersion( version, version, conn );
1: 
1:         shutdownDatabase( ds );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Upgrade a database to the indicated version of Derby.
1:      * </p>
1:      */
1:     private void upgradeDatabase( Version softwareVersion, Version dataVersion, boolean hardUpgrade, String logicalDatabaseName )
1:         throws Exception
1:     {
0:         UpgradeClassLoader.setThreadLoader( softwareVersion.getClassLoader() );
1: 
1:         DataSource ds = upgradeDatabase( logicalDatabaseName, hardUpgrade );
1: 
1:         Connection conn = ds.getConnection();
1: 
1:         vetDBVersion( softwareVersion, dataVersion, conn );
1: 
1:         shutdownDatabase( ds );
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Boot a database.
1:      * </p>
1:      */
1:     private DataSource bootDatabase( String logicalDatabaseName )
1:         throws Exception
1:     {
1:         DataSource ds = makeDataSource( logicalDatabaseName );
1:         Method     setMethod = ds.getClass().getMethod( "setCreateDatabase", new Class[] { String.class } );
1:         
1:         setMethod.invoke( ds, new Object[] { "create" } );
1:         
1:         Connection conn = ds.getConnection();
1:         
1:         return ds;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Hard-upgrade a database.
1:      * </p>
1:      */
1:     private DataSource upgradeDatabase( String logicalDatabaseName, boolean hardUpgrade )
1:         throws Exception
1:     {
1:         DataSource ds = makeDataSource( logicalDatabaseName );
1: 
1:         if ( hardUpgrade )
1:         {
1:             Method     setMethod = ds.getClass().getMethod( "setConnectionAttributes", new Class[] { String.class } );
1:         
1:             setMethod.invoke( ds, new Object[] { "upgrade=true" } );
1:         }
1:         
1:         Connection conn = ds.getConnection();
1:         
1:         return ds;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Make a DataSource given a logical database name.
1:      * </p>
1:      */
1:     private DataSource makeDataSource( String logicalDatabaseName )
1:         throws Exception
1:     {
1:         return JDBCDataSource.getDataSourceLogical( logicalDatabaseName );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Shutdown a database.
1:      * </p>
1:      */
1:     private void shutdownDatabase( DataSource ds )
1:     {
1:         JDBCDataSource.shutdownDatabase( ds );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Verify that the database has the expected version.
1:      * </p>
1:      */
1:     private void vetDBVersion( Version softwareVersion, Version dataVersion, Connection conn )
1:         throws Exception
1:     {
1:         String expectedSoftwareVersion = softwareVersion.toString();
1:         String expectedDataVersion = dataVersion.getBranchID();
1:         String actualSoftwareVersion = trimDriverVersion( conn.getMetaData().getDriverVersion() );
1:         String actualDataVersion = getDataVersion( conn );
1: 
1:         assertEquals( _trajectoryName, expectedSoftwareVersion, actualSoftwareVersion );
1:         assertEquals( _trajectoryName, expectedDataVersion, actualDataVersion );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Get the version of the data in the database.
1:      * </p>
1:      */
1:     private String getDataVersion( Connection conn )
1:         throws Exception
1:     {
1:         PreparedStatement ps = null;
1:         ResultSet               rs = null;
1: 
1:         try {
1:             ps = conn.prepareStatement( "values syscs_util.syscs_get_database_property('DataDictionaryVersion')" );
1:             rs = ps.executeQuery();
1: 
1:             rs.next();
1: 
1:             return rs.getString( 1 );
1:         }
1:         catch (SQLException se)
1:         {
1:             printStackTrace( se );
1:             return null;
1:         }
1:         finally
1:         {
1:             if ( rs != null ) { rs.close(); }
1:             if ( ps != null ) { ps.close(); }
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Strip the trailing subversion stamp from a Derby version number.
1:      * </p>
1:      */
1:     private String trimDriverVersion( String driverVersion)
1:     {
1:         int idx = driverVersion.indexOf( ' ' );
1:         if ( idx > 0 ) { return driverVersion.substring( 0, idx ); }
1:         else { return driverVersion; }
1:     }
1: 
1:     private void saveOriginalClassLoader()
1:     {
1:         // remember the original class loader so that we can reset
0:         if ( _originalClassLoader.get() == null ) { _originalClassLoader.set( UpgradeClassLoader.getThreadLoader() ); }
1:     }
1:     private void restoreOriginalClassLoader()
1:     {
0:         UpgradeClassLoader.setThreadLoader( (ClassLoader) _originalClassLoader.get() );
1:     }
1: 
1:     private String stringifyUpgradeRequests()
1:     {
1:         StringBuffer buffer = new StringBuffer();
1:         int          count = _hardUpgradeRequests.length;
1: 
1:         buffer.append( "( " );
1: 
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             if ( i > 0 ) { buffer.append( ", " ); }
1:             if ( _hardUpgradeRequests[ i ] ) { buffer.append( "hard" ); }
1:             else { buffer.append( "soft" ); }
1:         }
1: 
1:         buffer.append( " )" );
1: 
1:         return buffer.toString();
1:     }
1: 
1:     /**
1:      * Run good DDL.
1:      */
1:     protected void    goodStatement( Connection conn, String ddl ) throws SQLException
1:     {
1:         PreparedStatement    ps = chattyPrepare( conn, ddl );
1: 
1:         ps.execute();
1:         ps.close();
1:     }
1:     
1:     /**
1:      * Prepare a statement and report its sql text.
1:      */
1:     protected PreparedStatement   chattyPrepare( Connection conn, String text )
1:         throws SQLException
1:     {
1:         if ( LOQUACIOUS) { println( "Preparing statement:\n\t" + text ); }
1:         
1:         return conn.prepareStatement( text );
1:     }
1: 
1:     /**
1:      * Stringify a result set.
1:      */
1: 	private	String	printResultSet( ResultSet rs )
1: 		throws SQLException
1: 	{
1: 		if ( rs == null )
1: 		{
1: 			return "Null ResultSet!";
1: 		}
1: 
1: 		ResultSetMetaData	rsmd = rs.getMetaData();
1: 		int					count = rsmd.getColumnCount();
1: 		StringBuffer		buffer = new StringBuffer();
1: 
1: 		while ( rs.next() )
1: 		{
1: 			for ( int i = 1; i <= count; i++ )
1: 			{
1:                 if ( i > 1 ) { buffer.append( " | " ); }
1: 				buffer.append( rs.getString( i ) );
1: 			}
1: 			buffer.append( "\n" );
1: 		}
1: 
1: 		return buffer.toString();
1: 	}
1: 
1:     /**
1:      * <p>
1:      * Replace values which are known to be unstable.
1:      * </p>
1:      */
1:     private void normalizeRow( String tableName, String[] columnNames, String[] row )
1:     {
1:         int count = row.length;
1: 
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             String value = row[ i ];
1: 
1:             if ( isColumn( SYSCONGLOMERATES, CONGLOMERATENUMBER, tableName, columnNames[ i ] ) ) { value = DUMMY_NUMBER; }
1:             else if ( isColumn( SYSALIASES, ALIASID, tableName, columnNames[ i ] ) )
1:             {
1:                 String original = value;
1:                 value = getColumnValue( ALIAS, columnNames, row );
1:                 _unstableColumnValues.put( original, value );
1:             }
1:             else if ( isColumn( SYSALIASES, SPECIFICNAME, tableName, columnNames[ i ] ) )
1:             {
1:                 String original = value;
1:                 value = getColumnValue( ALIAS, columnNames, row );
1:                 _unstableColumnValues.put( original, value );
1:             }
1:             else if ( isColumn( SYSSTATEMENTS, STMTID, tableName, columnNames[ i ] ) )
1:             {
1:                 String original = value;
1:                 value = getColumnValue( STMTNAME, columnNames, row );
1:                 _unstableColumnValues.put( original, value );
1:             }
1:             else if ( isColumn( SYSSTATEMENTS, LASTCOMPILED, tableName, columnNames[ i ] ) )
1:             {
1:                 value = DUMMY_TIMESTAMP;
1:             }
1:             else if ( isColumn( SYSSTATEMENTS, TEXT, tableName, columnNames[ i ] ) && suffersDERBY_4216( tableName ) )
1:             {
1:                 value = DUMMY_STRING;
1:             }
1:             else if ( isColumn( SYSROUTINEPERMS, ALIASID, tableName, columnNames[ i ] ) )
1:             {
1:                 // replace with corresponding value that was substituted into SYSALIASES
1:                 value = (String) _unstableColumnValues.get( value );
1:             }
1:             else if ( isColumn( SYSROUTINEPERMS, ROUTINEPERMSID, tableName, columnNames[ i ] ) )
1:             {
1:                 value = DUMMY_STRING;
1:             }
1:             
1:             row[ i ] = value;
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Return true if we are dealing with the indicated column.
1:      * </p>
1:      */
1:     private boolean isColumn( String expectedTableName, String expectedColumnName, String actualTableName, String actualColumnName )
1:     {
1:         return ( expectedTableName.equals( actualTableName ) && expectedColumnName.equals( actualColumnName ) );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Return the value for the indicated columns.
1:      * </p>
1:      */
1:     private String getColumnValue( String columnName, String[] columnNames, String[] row )
1:     {
1:         int  count = columnNames.length;
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             if ( columnName.equals( columnNames[ i ] ) ) { return row[ i ]; }
1:         }
1: 
1:         return null;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Return true if the string looks like a UUID.
1:      * </p>
1:      */
1:     private boolean isUUID( String raw )
1:     {
1:         if (
1:             ( raw != null ) &&
1:             ( raw.length() == 36 ) &&
1:             ( raw.charAt( 8 ) == '-' ) &&
1:             ( raw.charAt( 13 ) == '-' ) &&
1:             ( raw.charAt( 18 ) == '-' )
1:             )
1:         { return true; }
1:         else { return false; }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Debug method to print out a result set.
1:      * </p>
1:      */
1:     private void printQueryResults( Connection conn, String query )
1:         throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare( conn, query );
1:         ResultSet               rs = ps.executeQuery();
1: 
1:         if ( LOQUACIOUS) { println( printResultSet( rs ) ); }
1: 
1:         rs.close();
1:         ps.close();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Debug method to compare the results of a query on two databases.
1:      * </p>
1:      */
1:     private void compareQueries( Connection leftConn, Connection rightConn, int colCount, String query )
1:         throws Exception
1:     {
1:         PreparedStatement leftPS = chattyPrepare( leftConn, query );
1:         PreparedStatement rightPS = chattyPrepare( rightConn, query );
1:         ResultSet               leftRS = leftPS.executeQuery();
1:         ResultSet               rightRS = rightPS.executeQuery();
1:         while( leftRS.next() )
1:         {
1:             rightRS.next();
1: 
1:             for ( int i = 1; i <= colCount; i++ )
1:             {
1:                 String leftValue = leftRS.getString( i );
1:                 String rightValue = rightRS.getString( i );
1:                 boolean unequal = false;
1: 
1:                 if ( leftValue == null )
1:                 {
1:                     if ( rightValue != null ) { unequal = true; }
1:                 }
1:                 else if ( !leftValue.equals( rightValue ) ) { unequal = true; }
1: 
1:                 if ( unequal )
1:                 {
1:                     if ( LOQUACIOUS) { println( "Column values different for column " + i + ". Left = " + leftValue + ", right = " + rightValue ); }
1:                 }
1:             }
1:         }
1: 
1:         leftRS.close();
1:         rightRS.close();
1:         leftPS.close();
1:         rightPS.close();
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // POWER SET BUILDING MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Builds the minimal set of trajectories for the supported versions. This
1:      * is all trajectories which start at some release, then hard upgrade to
1:      * every subsequent release up to the very last release. For a set of N
1:      * releases, there are N-1 non-vacuous trajectories of this shape.
1:      * </p>
1:      */
1:     private static Version.Trajectory[] buildMinimalSet( Version[] supportedVersions )
1:     {
0:         ArrayList   trajectoryList = new ArrayList();
1:         int  versionCount = supportedVersions.length;
1:         boolean[]  include = new boolean[ versionCount ];
1: 
1:         for ( int i = 0; i < versionCount; i++ ) { include[ i ] = true; }
1:         addSubset( supportedVersions, trajectoryList, include, false ); 
1: 
1:         for ( int i = 0; i < versionCount - 1; i++ )
1:         {
1:             include[ i ] = false;
1:             addSubset( supportedVersions, trajectoryList, include, false ); 
1:         }
1: 
1:         return squeezeArray( trajectoryList );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Build the power set of all supported versions.
1:      * </p>
1:      */
1:     private static Version.Trajectory[] buildPowerSet( Version[] supportedVersions )
1:     {
0:         ArrayList   trajectoryList = new ArrayList();
1:         int            versionCount = supportedVersions.length;
1:         boolean[]  include = new boolean[ versionCount ];
1: 
1:         buildPowerSetMinion( supportedVersions, trajectoryList, include, 0, TRJ_SAME_BRANCH_NEIGHBORS );
1: 
1:         return squeezeArray( trajectoryList );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Turn a list of trajectories into an array.
1:      * </p>
1:      */
0:     private static Version.Trajectory[] squeezeArray( ArrayList trajectoryList )
1:     {
1:         Version.Trajectory[] result = new Version.Trajectory[ trajectoryList.size() ];
1:         trajectoryList.toArray( result );
1: 
1:         return result;
1:     }
1:     
1:     /**
1:      * <p>
1:      * Recursive workhorse to build the power set of supported versions. If
1:      * requested, we also prune out all trajectories which have adjacent
1:      * versions from the same branch. If we're hard-upgrading, between releases,
1:      * then these SHOULD be uninteresting combinations.
1:      * </p>
1:      */
1:     private static void buildPowerSetMinion
0:         ( Version[] supportedVersions, ArrayList result, boolean[] include, int idx, boolean removeSameBranchNeighbors )
1:     {
1:         int  versionCount = supportedVersions.length;
1: 
1:         if ( idx >= versionCount ) { addSubset( supportedVersions, result, include, removeSameBranchNeighbors ); }
1:         else
1:         {
1:             include[ idx ] = true;
1:             buildPowerSetMinion( supportedVersions, result, include, idx + 1, removeSameBranchNeighbors );
1:             
1:             include[ idx ] = false;
1:             buildPowerSetMinion( supportedVersions, result, include, idx + 1, removeSameBranchNeighbors );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Add a subset to the evolving list of subsets of supported versions. Throw
1:      * out the empty set and singletons. We sort each trajectory so that its
1:      * versions are in ascending order.
1:      * </p>
1:      */
1:     private static void addSubset
0:         ( Version[] supportedVersions, ArrayList result, boolean[] include, boolean removeSameBranchNeighbors )
1:     {
1:         int  versionCount = supportedVersions.length;
1: 
0:         ArrayList seed = new ArrayList();
1:         Version   previousVersion = null;
1:         
1:         for ( int i = 0; i < versionCount; i++ )
1:         {
1:             Version  thisVersion = supportedVersions[ i  ];
1: 
1:             if ( include[ i ] )
1:             {
1:                 //
1:                 // If adjacent version are from the same branch, remove them if
1:                 // requested to.
1:                 //
1:                 if ( removeSameBranchNeighbors && ( previousVersion != null ) )
1:                 {
1:                     if ( previousVersion.getBranchID().equals( thisVersion.getBranchID() ) )
1:                     {
1:                         continue;
1:                     }
1:                 }
1:                 
1:                 previousVersion = thisVersion;                
1:                 seed.add( thisVersion );
1:             }
1:         }
1:         int  seedSize = seed.size();
1:         
1:         if ( seedSize > 1 )
1:         {
1:             Version[] subset = new Version[ seedSize ];
1:             seed.toArray( subset );
1:             
1:             result.add( (new Version.Trajectory( subset )).sort() );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Return empty string if passed in result is a known problem.
1:      * </p>
1:      */
1:     private String filterKnownProblems( String tableName, String actual )
1:     {
1:         if (
0:             _trajectory.endsAt( VERSION_10_5_1_1 ) &&
1:             ( contains( actual, DERBY_4214_1 ) || contains( actual, DERBY_4214_2 ) )
1:            )
1:         { return ""; }
1: 
1:         if (
1:             suffersDERBY_4215( tableName ) &&
1:             ( contains( actual, DERBY_4215 ) )
1:            )
1:         { return ""; }
1: 
1:         return actual;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Return true if the conditions of DERBY-4215 exist.
1:      * </p>
1:      */
1:     private boolean suffersDERBY_4215( String tableName )
1:     {
1:         return
1:                  (
1:                      SYSROUTINEPERMS.equals( tableName ) &&
1:                      _trajectory.startsAt( BRANCH_10_0 ) &&
1:                      ( !_trajectory.contains( BRANCH_10_1 ) ) &&
0:                      ( !_trajectory.equals( TRAJECTORY_10_0_2_1_TO_10_5_1_1 ) )
1:                  );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Return true if the conditions of DERBY-4216 exist.
1:      * </p>
1:      */
1:     private boolean suffersDERBY_4216( String tableName )
1:     {
1:         return
1:                  (
1:                      SYSSTATEMENTS.equals( tableName ) &&
1:                      _trajectory.startsAt( BRANCH_10_0 ) &&
1:                      _trajectory.endsAt( BRANCH_10_1 )
1:                  );
1:     }
1:     
1:     private boolean contains( String left, String right )
1:     {
1:         return ( left.indexOf( right ) >= 0 );
1:     }
1:     
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // INNER CLASSES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1: }
1: 
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:493b80e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.ClassLoaderTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         ClassLoaderTestSetup.setThreadLoader( version.getClassLoader() );
/////////////////////////////////////////////////////////////////////////
1:         ClassLoaderTestSetup.setThreadLoader( version.getClassLoader() );
/////////////////////////////////////////////////////////////////////////
1:         ClassLoaderTestSetup.setThreadLoader(softwareVersion.getClassLoader());
/////////////////////////////////////////////////////////////////////////
1:         if ( _originalClassLoader.get() == null ) { 
1:             _originalClassLoader.set( ClassLoaderTestSetup.getThreadLoader() ); 
1:         }
1:         ClassLoaderTestSetup.setThreadLoader(
1:                 (ClassLoader) _originalClassLoader.get() );
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Upgrade trajectory test");
/////////////////////////////////////////////////////////////////////////
1:     private static void addTrajectories( BaseTestSuite suite )
/////////////////////////////////////////////////////////////////////////
1:     private static void addHardUpgradeOnlyTrajectory(
1:         BaseTestSuite suite, Version.Trajectory trajectory )
/////////////////////////////////////////////////////////////////////////
1:     private static void addTrajectory(
1:         BaseTestSuite suite, Version.Trajectory trajectory )
/////////////////////////////////////////////////////////////////////////
1:     private static void addTrajectory(
1:         BaseTestSuite suite,
1:         Version.Trajectory trajectory,
1:         boolean[] hardUpgradeRequests,
1:         int idx )
/////////////////////////////////////////////////////////////////////////
1:     private static void addTrajectory(
1:         BaseTestSuite suite,
1:         Version.Trajectory trajectory,
1:         boolean[] hardUpgradeRequests )
commit:7b5f964
/////////////////////////////////////////////////////////////////////////
1:  *
1:  *   <li>Otherwise, if the system property {@code derbyTesting.allTrajectories}
1:  *   is set to true, builds the set of all upgrade trajectories possible on
1:  *   that collection of releases. An upgrade trajectory is a sorted subset of
1:  *   those releases. Each subset is sorted in ascending release order. We
1:  *   exclude the vacuous empty subset and the uninteresting singleton
1:  *   subsets. A set of N releases gives rise to ((2**N) - N) - 1 hard-upgrade
1:  *   trajectories.</li>
/////////////////////////////////////////////////////////////////////////
1:  * By default we consider all  trajectories possible on the collection
1:  * of releases listed in {@link OldVersions}. If you want to consider
1:  * a different  collection of  releases, you  can override  the {@code
1:  * OldVersions}  collection  by  setting the  system  property  {@code
1:  * "derbyTesting.oldVersionsPath"}. Here, for instance, is the command
/////////////////////////////////////////////////////////////////////////
1:  * {@code makeSampleTrajectories()} and uncomment the call to it.
commit:8269b78
/////////////////////////////////////////////////////////////////////////
============================================================================