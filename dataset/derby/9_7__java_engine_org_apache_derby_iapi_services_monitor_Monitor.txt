1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.monitor.Monitor
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
10:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.services.monitor;
1:eac0369: 
1:850aba4: import java.io.PrintWriter;
1:a2ecbd3: import java.security.AccessControlException;
1:850aba4: import java.util.Locale;
1:850aba4: import java.util.Properties;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:850aba4: import org.apache.derby.iapi.reference.Attribute;
1:850aba4: import org.apache.derby.iapi.reference.EngineType;
1:850aba4: import org.apache.derby.iapi.reference.Property;
1:850aba4: import org.apache.derby.iapi.reference.SQLState;
1:56c1dc2: import org.apache.derby.iapi.security.SecurityUtil;
1:eac0369: import org.apache.derby.iapi.services.i18n.MessageService;
1:850aba4: import org.apache.derby.iapi.services.info.ProductVersionHolder;
1:850aba4: import org.apache.derby.iapi.services.loader.InstanceGetter;
1:850aba4: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:eac0369: 
2:eac0369: /**
1:eac0369: 	<P><B>Services</B><BR>
1:eac0369: 
1:eac0369: 	A service is a collection of modules that combine to provide
1:eac0369: 	the full functionality defined by the service. A service is defined
1:eac0369: 	by three pieces of information:
1:eac0369: 	<OL>
1:eac0369: 	<LI>A fully qualified java class name that identifies the functionality or API
1:eac0369: 	that the service must provide. Typically this class represents a java interface.
1:eac0369: 	This class name is termed the <EM>factory interface</EM>.
1:eac0369: 	<LI>The <EM>identifier</EM> of the service. Services are identified by a String, this may
1:eac0369: 	be hard-coded, come from a UUID or any other source.
1:eac0369: 	<LI>An optional java.util.Properties set.
1:eac0369: 	</OL>
1:eac0369: 	<BR>
1:eac0369: 	The running functionality of the service is provided by a module
1:eac0369: 	that implements the factory interface. The identifier of the this module
1:eac0369: 	is not (need not be) the same as the identifier of the service. The identifier
1:eac0369: 	of the service is held by the monitor in its service tables.
1:eac0369: 	<BR>
1:eac0369: 	Each module in a service is keyed by at least one factory interface, identifier}
1:eac0369: 	pair. This pair is guaranteed to be unique within the service.
1:eac0369: 	<BR>
1:eac0369: 	The lifetime of a module in a service is no longer than the lifetime of the service.
1:eac0369: 	Thus shutting down a service shuts down all the modules within a service.
1:eac0369: 	<B>Optionally - </B> an individual module within a service may be shutdown, this will
1:eac0369: 	in turn shutdown any modules it started if those module are not in use by other
1:eac0369: 	modules within the service. This would be handled by the monitor, not the module itself.
1:eac0369: 	<BR>
1:eac0369: 	A service may be persistent, it goes through a boot in create mode, and subsequently boot
1:eac0369: 	in non-create mode, or a non-peristent service, it always boots in non-create mode.
1:eac0369: 	Persistent services can store their re-start parameters in their properties set, the monitor
1:eac0369: 	provides the persistent storage of the properties set.
1:eac0369: 	Non-persistent services do not have a properties set.
1:eac0369: 
1:eac0369: 	<P><B>Booting Services</B><BR>
1:eac0369: 	Services can be booted a number of ways
1:eac0369: 	<UL>
1:eac0369: 	<LI>A non-persistent service can be booted by having a property in the application properties
1:eac0369: 	or the system (JVM) set.
1:eac0369: 	<PRE>
1:eac0369: 	derby.service.<EM>service name</EM>=<EM>class name</EM>
1:eac0369: 	e.g.
1:eac0369: 	# Added to the properties automatically by the class org.apache.derby.jdbc.EmbeddedDriver
1:eac0369: 	derby.service.jdbc=java.sql.Driver
1:eac0369: 	</PRE>
1:eac0369: 	<LI>A persistent service can be booted by having a property in the application properties
1:eac0369: 	or the system (JVM) set.
1:eac0369: 	<PRE>
1:eac0369: 	derby.service.<EM>service name</EM>=<EM>persistent storage type</EM>
1:eac0369: 	e.g.
1:eac0369: 	derby.service.mydatabase=serviceDirectory
1:eac0369: 	</PRE>
1:eac0369: 	serviceDirectory is a type understood by the monitor which means that there is a directory
1:eac0369: 	named mydatabase within the system directory and within it is a properties file service.properties. This properties
1:eac0369: 	set is the set for the service and must contain a property
1:eac0369: 	<PRE>
1:eac0369: 	derby.protocol=<EM>class name</EM>
1:eac0369: 	</PRE>
1:eac0369: 	This is then the factory interface for the service. Other storage types could be added in
1:eac0369: 	the future.
1:eac0369: 	<LI>
1:eac0369: 	The monitor at start time looks for all persistent services that it can find and starts them.
1:eac0369: 	E.g. all directories in the system directory that have a file service.properties are started
1:eac0369: 	as services.
1:eac0369: 	<LI>Services are started on demand, e.g. a findService attempts to boot a service if it
1:eac0369: 	cannot be found.
1:eac0369: 	</UL>
1:eac0369: 	<B>Any or all of these three latter methods can be implemented. A first release may
1:eac0369: 	just implement the look for all services and boot them.</B>
1:eac0369: 	.
1:eac0369: 	<P><B>System Service</B><BR>
1:eac0369: 	A special service exists, the System Service. This service has no factory interface,
1:eac0369: 	no identifier and no Properties set. It allows modules to be started that are required
1:eac0369: 	by another service (or the monitor itself) but are not fundamentally part of the service.
1:eac0369: 	Modules within this service are unidentified.
1:eac0369: 	Typically these modules are system wide types of functionality like streams, uuid creation etc.
1:eac0369: 	<BR>
1:eac0369: 	The lifetime of a system module is the lifetime of the monitor.
1:eac0369: 	<B>Optionally - </B> this could be changed to reference count on individual modules, requires
1:eac0369: 	some minor api changes.
1:eac0369: 
1:eac0369: 	<P><B>Modules</B><BR>
1:eac0369: 
1:eac0369: 	A module is found or booted using four pieces of information:
1:eac0369: 	<OL>
1:eac0369: 	<LI>The service the module lives in or will live in.
1:eac0369: 	<LI>A fully qualified java class name that identifies the functionality or API
1:eac0369: 	that the module must provide. Typically this class represents a java interface.
1:eac0369: 	This class name is termed the <EM>factory interface</EM>.
1:eac0369: 	<LI>The <EM>identifier</EM> of the module. Modules are identified by a String, this may
1:eac0369: 	be null, be hard-coded, come from a UUID or any other source. If the identifier
1:eac0369: 	is null then the module is described as <EM>unidentified</EM>.
1:eac0369: 	<LI>Boot time only - A java.util.Properties set. This Properties set is service wide
1:eac0369: 	and typically contains parameters used to determine module implementation or runtime
1:eac0369: 	behaviour.
1:eac0369: 	</OL>
1:eac0369: 	<BR>
1:eac0369: 	The service is identified by explicitly identifiying the System Service or
1:eac0369: 	by providing a reference to a module that already exists with the required service.
1:eac0369: 	<BR>
1:eac0369: 	The factory interface is provided by a String constant of the form class.MODULE
1:eac0369: 	from the required interface.
1:eac0369: 	<BR>
1:eac0369: 	The module identifier is provided in a fashion determined by the code, in most
1:eac0369: 	cases a unidentified module will suffice.
1:eac0369: 	<BR>
1:eac0369: 	The Properties set is also determined in a fashion determined by the code at
1:eac0369: 	create or add service time.
1:eac0369: 
1:eac0369:   <P><B>Module Implementations</B><BR>
1:eac0369: 
1:eac0369: 	When creating an instance of a module, an implementation is found through lists of
1:eac0369: 	potential implementations.
1:eac0369: 	<BR>
1:eac0369: 	A list of potential implementations is obtained from a Properties set. Any property
1:eac0369: 	within this set that is of the form
1:eac0369: 	<PRE>
1:eac0369: 	derby.module.<EM>tag</EM>=<EM>java class name</EM>
1:eac0369: 	</PRE>
1:eac0369: 	is seen by the monitor as a possible implementation. <EM>tag</EM> has no meaning within
1:eac0369: 	the monitor, it is only there to provide uniqueness within the properties file. Typically
1:eac0369: 	the tag is to provide some description for human readers of the properties file, e.g.
1:eac0369: 	derby.module.lockManager for an implementation of a lock manager.
1:eac0369: 	<BR>
1:eac0369: 	The monitor looks through four properties sets for lists of potential implementations in this
1:eac0369: 	order. 
1:eac0369: 	<OL>
1:eac0369: 	<LI>The properties set of the service (i.e. that passed into Monitor.createPersistentService()
1:eac0369: 	or Monitor.startService()).
1:eac0369: 	<LI>The System (JVM) properties set (i.e. java.lang.System.getProperties()).
1:3fd26f3: 	<LI>The application properties set (i.e. obtained from the derby.properties file).
1:eac0369: 	<LI>The default implementation properties set (i.e. obtained from the
1:eac0369: 	/org/apache/derby/modules.properties resource).
1:eac0369: 	</OL>
1:eac0369: 	Any one of the properties can be missing or not have any implementations listed within it.
1:eac0369: 	<BR>
1:eac0369: 	Every request to create an instance of a module searches the four implementation
1:eac0369: 	lists in the order above. Which list the current running code or the passed in service
1:eac0369: 	module came from is not relevant.
1:eac0369: 	<BR>
1:eac0369: 	Within each list of potential implementations the search is conducted as follows:
1:eac0369: 	<OL>
1:eac0369: 	<LI>Attempt to load the class, if the class cannot be loaded skip to the next potential
1:eac0369: 	implementation.
1:eac0369: 	<LI>See if the factory interface is assignable from the class (isAssignableFrom() method
1:eac0369: 	of java.lang.Class), if not skip to the next potential implementation.
1:eac0369: 	<LI>See if an instance of the class can be created without any exceptions (newInstance() method
1:eac0369: 	of java.lang.Class), if not skip to the next potential implementation.
1:eac0369: 	<LI>[boot time only] See if the canSupport() method of ModuleControl returns true when called with the
1:eac0369: 	Properties set of the service, if not skip to the next potential implementation.
1:eac0369: 	</OL>
1:eac0369: 	If all these checks pass then the instance is a valid implementation and its boot() method
1:eac0369: 	of ModuleControl is called to activate it. Note that the search order within
1:eac0369: 	the list obtained from a Properties set is not guaranteed.
1:eac0369: 
1:eac0369: 	 <P><B>Module Searching</B><BR>
1:eac0369: 
1:eac0369: 	When searching for a module the search space is always restricted to a single service.
1:eac0369: 	This service is usually the system service or the service of the module making the
1:eac0369: 	search request. It would be very rare (wrong?) to search for a module in a service that
1:eac0369: 	was not the current service and not the system service.
1:eac0369: 	<BR>
1:eac0369: 	Within the list of modules in the service the search is conducted as follows:
1:eac0369: 	<OL>
1:eac0369: 	<LI>See if the instance of the module an instance of the factory interface (isInstance() method
1:eac0369: 	of java.lang.Class), if not skip to the next module.
1:eac0369: 	<LI>See if the identifier of the module matches the required identifier, if not skip to the next module.
1:eac0369: 	<LI>See if the canSupport() method of ModuleControl returns true when called with the
1:eac0369: 	Properties set of the service, if not skip to the next module.
1:eac0369: 	</OL>
1:eac0369: 	Note that no search order of the modules is guaranteed.
1:eac0369: 	<BR>
1:eac0369: 	Also note that a module may be found by a different factory interface to the one
1:eac0369: 	it was created under. Thus a class may implement multiple factory interfaces, its boot
1:eac0369: 	method has no knowledge of which factory interface it was requested by.
1:eac0369: 
1:eac0369:   <P><B>Service Properties</B><BR>
1:eac0369: 
1:eac0369: 	Within the service's Properties a module may search for its parameters. It identifies
1:eac0369: 	its parameters using a unqiue parameter name and its identifier.
1:eac0369: 	<BR>
1:eac0369: 	Unique parameter names are made unique through the 'dot' convention of Properties
1:eac0369: 	files. A module protocol picks some unique key portion to start, e.g. RawStore for the RawStoreFactory
1:eac0369: 	and then extends that for specific parameters, e.g. RawStore.PageSize. Thus
1:eac0369: 	parameters that are typically understood by all implementations of that protocol would
1:eac0369: 	start with that key portion. Parameters for specific implementations add another key portion
1:eac0369: 	onto the protocol key portion, e.g. RawStore.FileSystem for an file system implementation
1:eac0369: 	of the raw store, with a specific parameter being RawStore.FileSystem.SectorSize.
1:eac0369: 
1:eac0369: 	<BR>These are general guidelines, UUID's could be used as the properties keys but
1:eac0369: 	would make the parameters hard to read.
1:eac0369: 	<BR>
1:eac0369: 	When a module is unidentified it should look for a parameter using just
1:eac0369: 	the property key for that parameter, e.g. getProperty("RawStore.PageSize").
1:eac0369: 	<BR>
1:eac0369: 	When a module has an identifier is should look for a property using the
1:eac0369: 	key with a dot and the identifier appended, e.g. getProperty("RawStore.PageSize" + "." + identifier).
1:eac0369: 	<BR>
1:eac0369: 	In addition to searching for parameters in the service properties set, the system and
1:eac0369: 	application set may be searched using the getProperty() method of ModuleFactory.
1:eac0369: 	<BR><B>Should any order be defined for this, should it be automatic?</B>
1:eac0369: */
1:eac0369: public class Monitor {
1:eac0369: 
1:eac0369: 	public static final String SERVICE_TYPE_DIRECTORY = "serviceDirectory";
1:eac0369: 
1:eac0369: 	public static final Object syncMe = new Object();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Global debug flag to turn on tracing of reads calls newInstanceFromIdentifier()
1:eac0369: 	  */
1:eac0369: 	public final static String
1:eac0369: 		NEW_INSTANCE_FROM_ID_TRACE_DEBUG_FLAG = SanityManager.DEBUG ? "MonitorNewInstanceFromId" : null;
1:eac0369: 	
1:eac0369: 	public static final String DEBUG_TRUE = SanityManager.DEBUG ? "derby.debug.true" : null;
1:eac0369: 	public static final String DEBUG_FALSE = SanityManager.DEBUG ? "derby.debug.false" : null;
1:eac0369: 
1:eac0369: 
1:eac0369: 	private static ModuleFactory monitor;
1:eac0369: 	private static boolean active;
1:eac0369: 
1:eac0369: 	public Monitor() {
5:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Start a Monitor based software system.
1:eac0369: 
1:eac0369: 		This method will execute the following steps.
1:eac0369: 
1:eac0369:   <OL>
1:eac0369:   <LI> Create an instance of a module (monitor) of the required implementation.
1:eac0369:   <LI> Start the monitor which will in turn start any requested services
1:eac0369:   <LI> Execute the run() method of startCode (if startCode was not null).
1:eac0369:   <LI> Return.
1:eac0369:   </OL>
1:eac0369:   <P> If MonitorBoot.start() is called more then once then subsequent calls
1:eac0369:   have no effect.
1:eac0369: 
1:3fcea8a: 		@param bootProperties The application properties
1:eac0369: 		@param logging Where to place initial error output. This location will be used
1:eac0369: 			until an InfoStreams module is successfully started.
1:eac0369: 	*/
1:eac0369: 
1:a2ecbd3:     @SuppressWarnings("ResultOfObjectAllocationIgnored")
1:850aba4: 	public static void startMonitor(Properties bootProperties, PrintWriter logging) {
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:a2ecbd3:         try {
1:a2ecbd3:             new org.apache.derby.impl.services.monitor.FileMonitor(bootProperties, logging);
1:a2ecbd3:         } catch (AccessControlException e) {
1:a2ecbd3:             clearMonitor();
1:a2ecbd3:             throw e;
1:a2ecbd3:         }
1:eac0369: 	}
1:eac0369: 	/**
1:a2ecbd3:         Initialize this class, must only be called by an implementation
1:eac0369: 		of the monitor (ModuleFactory).
1:eac0369: 	*/
1:eac0369: 	public static boolean setMonitor(ModuleFactory theMonitor) {
1:56c1dc2: 
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:eac0369:         
1:eac0369: 		synchronized (syncMe) {
1:eac0369: 			if (active)
1:eac0369: 				return false;
1:eac0369: 
1:eac0369: 			monitor = theMonitor;
1:eac0369: 			active = true;
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static void clearMonitor() {
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:eac0369: 		// the monitor reference needs to remain valid
1:eac0369: 		// as there are some accesses to getMonitor()
1:eac0369: 		// after the system has been shutdown.
1:eac0369: 		synchronized (syncMe) {
1:eac0369: 			active = false;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the monitor.
1:eac0369: 	*/
1:eac0369: 	public static ModuleFactory getMonitor() {
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:eac0369: 		return monitor;
1:eac0369: 	}
1:eac0369: 	public static ModuleFactory getMonitorLite() {
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:eac0369: 		synchronized (syncMe) {
1:eac0369: 			if (active && monitor != null)
1:eac0369: 				return monitor;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// initialize a monitor just to get system properties
1:eac0369: 		// with the right secuirty checks and the correct sematics
1:eac0369: 		// for lookup of derby.system.home.
1:eac0369: 		// This instance will be discarded once it is used.				;
1:eac0369: 
1:eac0369: 		return new org.apache.derby.impl.services.monitor.FileMonitor();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static HeaderPrintWriter getStream() {
1:eac0369: 		return monitor.getSystemStreams().stream();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the name of the service that the passed in module lives in.
1:eac0369: 	*/
1:eac0369: 	public static String getServiceName(Object serviceModule) {
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:eac0369: 		return monitor.getServiceName(serviceModule);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Start or find a module in the system service. This call allows modules
1:eac0369: 		to explictly start services they require.
1:eac0369: 		If no module matching the criteria is found (see this class's prologue for details)
1:eac0369: 		then an instance will be created (see prologue) and booted as follows.
1:eac0369: 		<PRE>
1:eac0369: 		((ModuleControl) instance).boot(false, (String) null, (Properties) null);
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 		@return a reference to a module.
1:eac0369: 
1:eac0369: 		@exception StandardException An attempt to start the module failed.
1:eac0369: 
1:eac0369: 		@see ModuleControl#boot
1:eac0369: 	*/
1:eac0369: 	public static Object startSystemModule(String factoryInterface)
1:56c1dc2:         throws StandardException {
1:56c1dc2: 
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:eac0369:         
1:eac0369: 		Object module = monitor.startModule(false, (Object) null, factoryInterface, (String) null, (Properties) null);
1:eac0369: 		
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(module != null, "module is null - " + factoryInterface);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return module;
1:eac0369: 	}
1:eac0369: 
1:b69d62b: 	/**
1:eac0369: 		Find a module in the system service.
1:eac0369: 
1:eac0369: 		@return a reference to a module or null if one cannot be found.
1:eac0369: 	*/
1:eac0369: 	public static Object findSystemModule(String factoryInterface) throws StandardException
2:eac0369: 	{
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
2:eac0369: 		Object module = getMonitor().findModule((Object) null,
1:eac0369: 									  factoryInterface, (String) null);
1:eac0369: 		if (module == null)
1:eac0369: 			throw Monitor.missingImplementation(factoryInterface);
1:eac0369: 
1:eac0369: 		return module;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:b69d62b:      * Return a system module. If it cannot be found or the monitor is
1:b69d62b:      * not running then null is returned.
1:b69d62b:      */
1:b69d62b:     public static Object getSystemModule(String factoryInterface)
1:b69d62b:     {
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:b69d62b:         ModuleFactory monitor = getMonitor();
1:b69d62b:         if (monitor == null)
1:b69d62b:             return null;
1:b69d62b:         
1:b69d62b: 		Object module = monitor.findModule((Object) null,
1:eac0369: 									  factoryInterface, (String) null);
1:eac0369: 		return module;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Boot or find a unidentified module within a service. This call allows modules
1:eac0369: 		to start or create any modules they explicitly require to exist within
1:eac0369: 		their service. If no module matching the criteria is found (see this class's prologue for details)
1:eac0369: 		then an instance will be created (see prologue) and booted as follows.
1:eac0369: 		<PRE>
1:eac0369: 		((ModuleControl) instance).boot(create, (String) null, properties);
1:eac0369: 		</PRE>
1:eac0369: 		<BR>
1:eac0369: 		The service is defined by the service that the module serviceModule lives in,
1:eac0369: 		typically this call is made from the boot method of a module and thus
1:eac0369: 		'this' is passed in for serviceModule.
1:eac0369: 
1:eac0369: 		@return a reference to a module.
1:eac0369: 
1:eac0369: 		@exception StandardException An attempt to start the module failed.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public static Object bootServiceModule(boolean create, Object serviceModule,
1:eac0369: 		String factoryInterface, Properties properties)
2:eac0369: 		throws StandardException {
1:56c1dc2: 
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:eac0369:         
1:eac0369: 		Object module = monitor.startModule(create, serviceModule, factoryInterface,
1:eac0369: 						(String) null, properties);
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(module != null, "module is null - " + factoryInterface);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return module;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Boot or find a identified module within a service. This call allows modules
1:eac0369: 		to start or create any modules they explicitly require to exist within
1:eac0369: 		their service. If no module matching the criteria is found (see this class's prologue for details)
1:eac0369: 		then an instance will be created (see prologue) and booted as follows.
1:eac0369: 		<PRE>
1:eac0369: 		((ModuleControl) instance).boot(create, identifer, properties);
1:eac0369: 		</PRE>
1:eac0369: 		<BR>
1:eac0369: 		The service is defined by the service that the module serviceModule lives in,
1:eac0369: 		typically this call is made from the boot method of a module and thus
1:eac0369: 		'this' is passed in for serviceModule.
1:eac0369: 
1:eac0369: 		@return a reference to a module.
1:eac0369: 
1:eac0369: 		@exception StandardException An attempt to start the module failed.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public static Object bootServiceModule(boolean create, Object serviceModule,
1:eac0369: 		String factoryInterface, String identifier, Properties properties)
1:eac0369: 		throws StandardException {
1:56c1dc2: 
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:eac0369:         
1:eac0369: 		Object module = monitor.startModule(create, serviceModule, factoryInterface, identifier, properties);
1:eac0369: 		
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(module != null, "module is null - " + factoryInterface);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return module;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Find an unidentified module within a service.
1:eac0369: 		<BR>
1:eac0369: 		The service is defined by the service that the module serviceModule lives in.
1:eac0369: 
1:eac0369: 		@return a reference to a module or null if one cannot be found.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public static Object findServiceModule(Object serviceModule, String factoryInterface)
1:eac0369: 		throws StandardException {
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:eac0369: 		Object module = getMonitor().findModule(serviceModule, factoryInterface, (String) null);
1:eac0369: 		if (module == null)
1:eac0369: 			throw Monitor.missingImplementation(factoryInterface);
1:eac0369: 		return module;
1:eac0369: 	}
1:eac0369: 	public static Object getServiceModule(Object serviceModule, String factoryInterface)
1:eac0369: 	{
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:eac0369: 		Object module = getMonitor().findModule(serviceModule, factoryInterface, (String) null);
1:eac0369: 		return module;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Find an identified module within a service.
1:eac0369: 		<BR>
1:eac0369: 		The service is defined by the service that the module serviceModule lives in.
1:eac0369: 
1:eac0369: 		@return a reference to a module or null if one cannot be found.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	//public static Object findServiceModule(Object serviceModule, String factoryInterface, String identifier) {
1:eac0369: 	//	return monitor.findModule(serviceModule, factoryInterface, identifier);
1:eac0369: 	//}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Find a service.
1:eac0369: 
1:eac0369: 		@return a refrence to a module represeting the service or null if the service does not exist.
1:eac0369: 
1:eac0369: 	*/
1:eac0369: 	public static Object findService(String factoryInterface, String serviceName) {
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:eac0369: 		return monitor.findService(factoryInterface, serviceName);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Start a persistent service. The name of the service can include a
1:eac0369: 		service type, in the form 'type:serviceName'.
1:eac0369: 		<BR>
1:eac0369: 		Note that the return type only indicates
1:eac0369: 		if the service can be handled by the monitor. It does not indicate
1:eac0369: 		the service was started successfully. The cases are
1:eac0369: 		<OL>
1:eac0369: 		<LI> Service type not handled - false returned.
1:eac0369: 		<LI> Service type handled, service does not exist, true returned.
1:eac0369: 		<LI> Service type handled, service exists and booted OK, true returned.
1:eac0369: 		<LI> Service type handled, service exists and failed to boot, exception thrown.
1:eac0369: 		</OL>
1:eac0369: 
1:eac0369: 		If true is returned then findService should be used to see if the service
1:eac0369: 		exists or not.
1:00c5b52: 		
1:00c5b52: 		<P> The poperty set passed in is for boot options for the modules
1:00c5b52: 		required to start the service. It does not support defining different
1:00c5b52: 		or new modules implementations.
1:00c5b52: 		
1:00c5b52: 		@param serviceName Name of the service to be started
1:00c5b52: 		@param properties Property set made available to all modules booted
1:00c5b52: 		for this service, through their ModuleControl.boot method.
1:eac0369: 
1:eac0369: 		@return true if the service type is handled by the monitor, false if it isn't
1:eac0369: 
1:eac0369: 		@exception StandardException An attempt to start the service failed.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	public static boolean startPersistentService(String serviceName, 
1:eac0369: 												 Properties properties) 
1:eac0369: 		throws StandardException {
1:56c1dc2: 
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:eac0369:         
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(serviceName != null, "serviceName is null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return monitor.startPersistentService(serviceName, properties);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Start a non-persistent service. 
1:eac0369: 		<P><B>Context</B><BR>
1:eac0369: 		A context manager will be created and installed at the start of this method and destroyed
1:eac0369: 		just before this method returns.
1:eac0369: 
1:eac0369: 		@return The module from the service if it was started successfully. 
1:eac0369: 
1:eac0369: 		@exception StandardException An exception was thrown trying to start the service.
1:eac0369: 	*/
1:eac0369: 	public static Object startNonPersistentService(String factoryInterface, String serviceName, Properties properties)
1:eac0369: 		throws StandardException {
1:56c1dc2: 
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:eac0369:         
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(factoryInterface != null, "serviceName is null");
1:eac0369: 			SanityManager.ASSERT(serviceName != null, "serviceName is null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return monitor.startNonPersistentService(factoryInterface, serviceName, properties);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Create a named service that implements the java interface (or class) fully qualified by factoryInterface.
1:eac0369: 		The Properties object specifies create time parameters to be used by the modules within the
1:eac0369: 		service. Any module created by this service may add or remove parameters within the
1:eac0369: 		properties object in their ModuleControl.boot() method. The properties set will be saved
1:eac0369: 		by the Monitor for later use when the monitor is started.
1:eac0369: 		<P><B>Context</B><BR>
1:eac0369: 		A context manager will be created and installed at the start of this method and destroyed
1:eac0369: 		just before this method returns.
1:eac0369: 
1:eac0369: 		@return The module from the service if it was created successfully, null if a service already existed. 
1:eac0369: 
1:eac0369: 		@exception StandardException An exception was thrown trying to create the service.
1:eac0369: 	*/
1:eac0369: 	public static Object createPersistentService(String factoryInterface, String serviceName, Properties properties) 
1:eac0369: 		throws StandardException {
1:56c1dc2: 
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:eac0369:         
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			SanityManager.ASSERT(factoryInterface != null, "serviceName is null");
1:eac0369: 			SanityManager.ASSERT(serviceName != null, "serviceName is null");
1:eac0369: 		}
1:eac0369: 		
1:eac0369: 		return monitor.createPersistentService(factoryInterface, serviceName, properties);
1:eac0369: 	}
1:eac0369:     public static void removePersistentService(String name)
1:eac0369:         throws StandardException
1:eac0369:     {
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:56c1dc2:         
1:c406220:         // For now we only allow dropping in-memory databases.
1:c406220:         // This is mostly due to the fact that the current implementation for
1:c406220:         // the on-disk back end doesn't handle logDevice when dropping.
1:c406220:         // Security is another concern.
1:fa2af29:         if (!name.startsWith(PersistentService.INMEMORY + ":")) {
1:c406220:             throw StandardException.newException(
1:c406220:                     SQLState.SERVICE_DIRECTORY_REMOVE_ERROR, name);
1:c406220:         }
1:eac0369: 		monitor.removePersistentService(name);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Obtain the class object for a class that supports the given identifier.
1:eac0369: 
1:eac0369: 		If no class has been registered for the identifier then a StandardException
1:eac0369: 		is thrown with no attached java.lang exception (nextException).
1:eac0369: 		If a problem loading or accessing the class is obtained then a StandardException
1:eac0369: 		is thrown with the real java.lang exception attached.
1:eac0369: 
1:eac0369: 		@return a valid class object
1:eac0369: 
1:eac0369: 		@exception StandardException See text above.
1:eac0369: 	*/
1:eac0369: 	public static InstanceGetter classFromIdentifier(int identifier) 
1:eac0369: 		throws StandardException {
1:eac0369: 		return monitor.classFromIdentifier(identifier);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Obtain an new instance of a class that supports the given identifier.
1:eac0369: 
1:eac0369: 		If no class has been registered for the identifier then a StandardException
1:eac0369: 		is thrown with no attached java.lang exception (getNestedException).
1:eac0369: 		If a problem loading or accessing the class or creating the object is obtained
1:eac0369: 		then a StandardException is thrown with the real java.lang exception attached.
1:eac0369: 
1:eac0369: 		@return a reference to a newly created object
1:eac0369: 
1:eac0369: 		@exception StandardException See text above.
1:eac0369: 	*/
1:eac0369: 	public static Object newInstanceFromIdentifier(int identifier) 
1:eac0369: 		throws StandardException {
1:56c1dc2:         
1:eac0369: 		return monitor.newInstanceFromIdentifier(identifier);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/* 
1:eac0369: 	** Static methods for startup type exceptions.
1:eac0369: 	*/
1:eac0369: 		/**
1:eac0369: 		return a StandardException to indicate that a module failed to
1:eac0369: 		start because it could not obtain the version of a required product.
1:eac0369: 
1:eac0369: 		@param productGenusName The genus name of the product.
1:eac0369: 		@return The exception.
1:eac0369: 	*/
1:eac0369: 	public static StandardException missingProductVersion(String productGenusName)
1:eac0369: 	{
1:eac0369: 		return StandardException.newException(SQLState.MISSING_PRODUCT_VERSION, productGenusName);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		return a StandardException to indicate a missing
1:eac0369: 		implementation.
1:eac0369: 
1:eac0369: 		@param implementation the module name of the missing implementation.
1:eac0369: 
1:eac0369: 		@return The exception.
1:eac0369: 	*/
1:eac0369: 	public static StandardException missingImplementation(String implementation) 
1:eac0369: 	{
1:eac0369: 		return StandardException.newException(SQLState.SERVICE_MISSING_IMPLEMENTATION, implementation);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		return a StandardException to indicate that an exception caused
1:eac0369: 		starting the module to fail.
1:eac0369: 
1:eac0369: 		@param t the exception which caused starting the module to fail.
1:eac0369: 
1:eac0369: 		@return The exception.
1:eac0369: 	*/
1:eac0369: 	public static StandardException exceptionStartingModule(Throwable t)
1:eac0369: 	{
1:eac0369: 		return StandardException.newException(SQLState.SERVICE_STARTUP_EXCEPTION, t);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static void logMessage(String messageText) {
1:eac0369: 		getStream().println(messageText);
1:eac0369: 	}
1:eac0369: 
1:1f18dc3:     public static void logTextMessage(String messageID, Object... args) {
1:1f18dc3:         getStream().println(MessageService.getTextMessage(messageID, args));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *  Translate a localeDescription of the form ll[_CC[_variant]] to
1:eac0369: 	 *  a Locale object.
1:eac0369: 	 */
1:eac0369: 	public static Locale getLocaleFromString(String localeDescription)
1:eac0369: 								throws StandardException {
1:eac0369: 		return monitor.getLocaleFromString(localeDescription);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Single point for checking if an upgrade is allowed.
1:703bc91: 		@return true a full upgrade has been requested, false soft upgrade mode is active.
1:eac0369: 	 */
1:eac0369: 	public static boolean isFullUpgrade(Properties startParams, String oldVersionInfo) throws StandardException {
1:56c1dc2: 
1:56c1dc2:         // Verify that we have permission to execute this method.
1:56c1dc2:         SecurityUtil.checkDerbyInternalsPrivilege();
1:eac0369:         
1:eac0369: 		boolean fullUpgrade = Boolean.valueOf(startParams.getProperty(org.apache.derby.iapi.reference.Attribute.UPGRADE_ATTR)).booleanValue();
1:eac0369: 
1:703bc91: 		ProductVersionHolder engineVersion = Monitor.getMonitor().getEngineVersion();
1:eac0369: 
1:703bc91: 		if (engineVersion.isBeta() || engineVersion.isAlpha()) {
1:703bc91: 					
1:703bc91: 			if (!PropertyUtil.getSystemBoolean(Property.ALPHA_BETA_ALLOW_UPGRADE))
1:703bc91: 			{
1:703bc91: 				//  upgrade not supported for alpha/beta.
1:703bc91: 				throw StandardException.newException(SQLState.UPGRADE_UNSUPPORTED,
1:703bc91: 						oldVersionInfo, engineVersion.getSimpleVersionString());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return fullUpgrade;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *
1:eac0369: 	  *	@param	startParams			startup parameters
1:eac0369: 	  *	@param	desiredProperty		property we're interested in
1:eac0369: 	  *
1:eac0369: 	  *	@return	true		type is as desired.
1:eac0369: 	  *			false		otherwise
1:eac0369: 	  *
1:eac0369: 	  */
1:eac0369: 	public static boolean isDesiredType(Properties startParams, int desiredProperty )
1:eac0369: 	{
1:dcd3fec: 		int		engineType = EngineType.STANDALONE_DB;
1:eac0369: 
1:eac0369: 		if ( startParams != null )
1:eac0369: 		{
1:eac0369: 			engineType = Monitor.getEngineType( startParams );
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		return (engineType & desiredProperty) != 0;
1:eac0369: 	}
1:dcd3fec:     
1:dcd3fec:     /**
1:dcd3fec:      * Is engineType a match for desiredType. A match exists
1:dcd3fec:      * if the bit intersect of the two values is no zero.
1:dcd3fec:      */
1:dcd3fec: 	public static boolean isDesiredType(int engineType, int desiredType) {
1:dcd3fec: 		return (engineType & desiredType) != 0;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	  *	@param	startParams		startup parameters
1:eac0369: 	  *
1:eac0369: 	  *	@return	type of engine
1:eac0369: 	  *
1:eac0369: 	  */
1:eac0369: 
1:eac0369: 	static	public	int	getEngineType(Properties startParams)
1:eac0369: 	{
1:eac0369: 		if ( startParams != null )
1:eac0369: 		{
1:eac0369: 			String etp = startParams.getProperty(EngineType.PROPERTY);
1:eac0369: 
1:eac0369: 			int engineType = etp == null ? EngineType.STANDALONE_DB : Integer.parseInt(etp.trim());
1:eac0369: 
1:eac0369: 			return engineType;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return EngineType.STANDALONE_DB;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return true if the properties set provided contains
1:eac0369: 	  database creation attributes for a database
1:eac0369: 	  of the correct type
1:eac0369: 	  */
1:eac0369: 	public static boolean isDesiredCreateType(Properties p, int type)
1:eac0369: 	{
1:eac0369: 		boolean plainCreate = Boolean.valueOf(p.getProperty(Attribute.CREATE_ATTR)).booleanValue();
1:eac0369: 
1:eac0369: 		if (plainCreate) {
1:dcd3fec: 			return (type & EngineType.STANDALONE_DB) != 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// database must already exist
1:eac0369: 		return isDesiredType(p, type);
1:eac0369: 	}
1:cccf5dd: 
1:cccf5dd:     /**
1:cccf5dd:      * Logs the stack trace of the specified throwable object.
1:cccf5dd:      */
1:cccf5dd:     public static void logThrowable(Throwable t) {
1:cccf5dd:         t.printStackTrace(getStream().getPrintWriter());
1:cccf5dd:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.security.SecurityUtil;
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException {
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:a2ecbd3
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessControlException;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("ResultOfObjectAllocationIgnored")
1:         try {
1:             new org.apache.derby.impl.services.monitor.FileMonitor(bootProperties, logging);
1:         } catch (AccessControlException e) {
1:             clearMonitor();
1:             throw e;
1:         }
1:         Initialize this class, must only be called by an implementation
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1f18dc3
/////////////////////////////////////////////////////////////////////////
1:     public static void logTextMessage(String messageID, Object... args) {
1:         getStream().println(MessageService.getTextMessage(messageID, args));
commit:850aba4
/////////////////////////////////////////////////////////////////////////
1: import java.io.PrintWriter;
1: import java.util.Locale;
1: import java.util.Properties;
1: import org.apache.derby.iapi.reference.Attribute;
1: import org.apache.derby.iapi.reference.EngineType;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.info.ProductVersionHolder;
1: import org.apache.derby.iapi.services.loader.InstanceGetter;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
/////////////////////////////////////////////////////////////////////////
1: 	public static void startMonitor(Properties bootProperties, PrintWriter logging) {
commit:cccf5dd
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Logs the stack trace of the specified throwable object.
1:      */
1:     public static void logThrowable(Throwable t) {
1:         t.printStackTrace(getStream().getPrintWriter());
1:     }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa2af29
/////////////////////////////////////////////////////////////////////////
1:         if (!name.startsWith(PersistentService.INMEMORY + ":")) {
commit:c406220
/////////////////////////////////////////////////////////////////////////
1:         // For now we only allow dropping in-memory databases.
1:         // This is mostly due to the fact that the current implementation for
1:         // the on-disk back end doesn't handle logDevice when dropping.
1:         // Security is another concern.
0:         if (!name.startsWith(PersistentService.INMEMORY)) {
1:             throw StandardException.newException(
1:                     SQLState.SERVICE_DIRECTORY_REMOVE_ERROR, name);
1:         }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:b69d62b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return a system module. If it cannot be found or the monitor is
1:      * not running then null is returned.
1:      */
1:     public static Object getSystemModule(String factoryInterface)
1:     {
1:         ModuleFactory monitor = getMonitor();
1:         if (monitor == null)
1:             return null;
1:         
1: 		Object module = monitor.findModule((Object) null,
commit:dcd3fec
/////////////////////////////////////////////////////////////////////////
1: 		int		engineType = EngineType.STANDALONE_DB;
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Is engineType a match for desiredType. A match exists
1:      * if the bit intersect of the two values is no zero.
1:      */
1: 	public static boolean isDesiredType(int engineType, int desiredType) {
1: 		return (engineType & desiredType) != 0;
/////////////////////////////////////////////////////////////////////////
1: 			return (type & EngineType.STANDALONE_DB) != 0;
commit:00c5b52
/////////////////////////////////////////////////////////////////////////
1: 		
1: 		<P> The poperty set passed in is for boot options for the modules
1: 		required to start the service. It does not support defining different
1: 		or new modules implementations.
1: 		
1: 		@param serviceName Name of the service to be started
1: 		@param properties Property set made available to all modules booted
1: 		for this service, through their ModuleControl.boot method.
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
1: 		@param bootProperties The application properties
commit:703bc91
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.property.PropertyUtil;
/////////////////////////////////////////////////////////////////////////
1: 		@return true a full upgrade has been requested, false soft upgrade mode is active.
1: 		ProductVersionHolder engineVersion = Monitor.getMonitor().getEngineVersion();
1: 		if (engineVersion.isBeta() || engineVersion.isAlpha()) {
1: 					
1: 			if (!PropertyUtil.getSystemBoolean(Property.ALPHA_BETA_ALLOW_UPGRADE))
1: 			{
1: 				//  upgrade not supported for alpha/beta.
1: 				throw StandardException.newException(SQLState.UPGRADE_UNSUPPORTED,
1: 						oldVersionInfo, engineVersion.getSimpleVersionString());
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.monitor.Monitor
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.monitor
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.monitor;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.info.ProductGenusNames;
0: import org.apache.derby.iapi.services.info.ProductVersionHolder;
0: import org.apache.derby.iapi.reference.EngineType;
0: import org.apache.derby.iapi.reference.Attribute;
1: 
0: import org.apache.derby.iapi.services.loader.InstanceGetter;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.Property;
1: 
0: import java.util.Properties;
0: import java.util.Locale;
0: import java.io.PrintStream;
1: 
1: /**
1: 	<P><B>Services</B><BR>
1: 
1: 	A service is a collection of modules that combine to provide
1: 	the full functionality defined by the service. A service is defined
1: 	by three pieces of information:
1: 	<OL>
1: 	<LI>A fully qualified java class name that identifies the functionality or API
1: 	that the service must provide. Typically this class represents a java interface.
1: 	This class name is termed the <EM>factory interface</EM>.
1: 	<LI>The <EM>identifier</EM> of the service. Services are identified by a String, this may
1: 	be hard-coded, come from a UUID or any other source.
1: 	<LI>An optional java.util.Properties set.
1: 	</OL>
1: 	<BR>
1: 	The running functionality of the service is provided by a module
1: 	that implements the factory interface. The identifier of the this module
1: 	is not (need not be) the same as the identifier of the service. The identifier
1: 	of the service is held by the monitor in its service tables.
1: 	<BR>
1: 	Each module in a service is keyed by at least one factory interface, identifier}
1: 	pair. This pair is guaranteed to be unique within the service.
1: 	<BR>
1: 	The lifetime of a module in a service is no longer than the lifetime of the service.
1: 	Thus shutting down a service shuts down all the modules within a service.
1: 	<B>Optionally - </B> an individual module within a service may be shutdown, this will
1: 	in turn shutdown any modules it started if those module are not in use by other
1: 	modules within the service. This would be handled by the monitor, not the module itself.
1: 	<BR>
1: 	A service may be persistent, it goes through a boot in create mode, and subsequently boot
1: 	in non-create mode, or a non-peristent service, it always boots in non-create mode.
1: 	Persistent services can store their re-start parameters in their properties set, the monitor
1: 	provides the persistent storage of the properties set.
1: 	Non-persistent services do not have a properties set.
1: 
1: 	<P><B>Booting Services</B><BR>
1: 	Services can be booted a number of ways
1: 	<UL>
1: 	<LI>A non-persistent service can be booted by having a property in the application properties
1: 	or the system (JVM) set.
1: 	<PRE>
1: 	derby.service.<EM>service name</EM>=<EM>class name</EM>
1: 	e.g.
1: 	# Added to the properties automatically by the class org.apache.derby.jdbc.EmbeddedDriver
1: 	derby.service.jdbc=java.sql.Driver
1: 	</PRE>
1: 	<LI>A persistent service can be booted by having a property in the application properties
1: 	or the system (JVM) set.
1: 	<PRE>
1: 	derby.service.<EM>service name</EM>=<EM>persistent storage type</EM>
1: 	e.g.
1: 	derby.service.mydatabase=serviceDirectory
1: 	</PRE>
1: 	serviceDirectory is a type understood by the monitor which means that there is a directory
1: 	named mydatabase within the system directory and within it is a properties file service.properties. This properties
1: 	set is the set for the service and must contain a property
1: 	<PRE>
1: 	derby.protocol=<EM>class name</EM>
1: 	</PRE>
1: 	This is then the factory interface for the service. Other storage types could be added in
1: 	the future.
1: 	<LI>
1: 	The monitor at start time looks for all persistent services that it can find and starts them.
1: 	E.g. all directories in the system directory that have a file service.properties are started
1: 	as services.
1: 	<LI>Services are started on demand, e.g. a findService attempts to boot a service if it
1: 	cannot be found.
1: 	</UL>
1: 	<B>Any or all of these three latter methods can be implemented. A first release may
1: 	just implement the look for all services and boot them.</B>
1: 	.
1: 	<P><B>System Service</B><BR>
1: 	A special service exists, the System Service. This service has no factory interface,
1: 	no identifier and no Properties set. It allows modules to be started that are required
1: 	by another service (or the monitor itself) but are not fundamentally part of the service.
1: 	Modules within this service are unidentified.
1: 	Typically these modules are system wide types of functionality like streams, uuid creation etc.
1: 	<BR>
1: 	The lifetime of a system module is the lifetime of the monitor.
1: 	<B>Optionally - </B> this could be changed to reference count on individual modules, requires
1: 	some minor api changes.
1: 
1: 	<P><B>Modules</B><BR>
1: 
1: 	A module is found or booted using four pieces of information:
1: 	<OL>
1: 	<LI>The service the module lives in or will live in.
1: 	<LI>A fully qualified java class name that identifies the functionality or API
1: 	that the module must provide. Typically this class represents a java interface.
1: 	This class name is termed the <EM>factory interface</EM>.
1: 	<LI>The <EM>identifier</EM> of the module. Modules are identified by a String, this may
1: 	be null, be hard-coded, come from a UUID or any other source. If the identifier
1: 	is null then the module is described as <EM>unidentified</EM>.
1: 	<LI>Boot time only - A java.util.Properties set. This Properties set is service wide
1: 	and typically contains parameters used to determine module implementation or runtime
1: 	behaviour.
1: 	</OL>
1: 	<BR>
1: 	The service is identified by explicitly identifiying the System Service or
1: 	by providing a reference to a module that already exists with the required service.
1: 	<BR>
1: 	The factory interface is provided by a String constant of the form class.MODULE
1: 	from the required interface.
1: 	<BR>
1: 	The module identifier is provided in a fashion determined by the code, in most
1: 	cases a unidentified module will suffice.
1: 	<BR>
1: 	The Properties set is also determined in a fashion determined by the code at
1: 	create or add service time.
1: 
1:   <P><B>Module Implementations</B><BR>
1: 
1: 	When creating an instance of a module, an implementation is found through lists of
1: 	potential implementations.
1: 	<BR>
1: 	A list of potential implementations is obtained from a Properties set. Any property
1: 	within this set that is of the form
1: 	<PRE>
1: 	derby.module.<EM>tag</EM>=<EM>java class name</EM>
1: 	</PRE>
1: 	is seen by the monitor as a possible implementation. <EM>tag</EM> has no meaning within
1: 	the monitor, it is only there to provide uniqueness within the properties file. Typically
1: 	the tag is to provide some description for human readers of the properties file, e.g.
1: 	derby.module.lockManager for an implementation of a lock manager.
1: 	<BR>
1: 	The monitor looks through four properties sets for lists of potential implementations in this
1: 	order. 
1: 	<OL>
1: 	<LI>The properties set of the service (i.e. that passed into Monitor.createPersistentService()
1: 	or Monitor.startService()).
1: 	<LI>The System (JVM) properties set (i.e. java.lang.System.getProperties()).
0: 	<LI>The application properties set (i.e. obtained from the cloudscape.properties file).
1: 	<LI>The default implementation properties set (i.e. obtained from the
1: 	/org/apache/derby/modules.properties resource).
1: 	</OL>
1: 	Any one of the properties can be missing or not have any implementations listed within it.
1: 	<BR>
1: 	Every request to create an instance of a module searches the four implementation
1: 	lists in the order above. Which list the current running code or the passed in service
1: 	module came from is not relevant.
1: 	<BR>
1: 	Within each list of potential implementations the search is conducted as follows:
1: 	<OL>
1: 	<LI>Attempt to load the class, if the class cannot be loaded skip to the next potential
1: 	implementation.
1: 	<LI>See if the factory interface is assignable from the class (isAssignableFrom() method
1: 	of java.lang.Class), if not skip to the next potential implementation.
1: 	<LI>See if an instance of the class can be created without any exceptions (newInstance() method
1: 	of java.lang.Class), if not skip to the next potential implementation.
1: 	<LI>[boot time only] See if the canSupport() method of ModuleControl returns true when called with the
1: 	Properties set of the service, if not skip to the next potential implementation.
1: 	</OL>
1: 	If all these checks pass then the instance is a valid implementation and its boot() method
1: 	of ModuleControl is called to activate it. Note that the search order within
1: 	the list obtained from a Properties set is not guaranteed.
1: 
1: 	 <P><B>Module Searching</B><BR>
1: 
1: 	When searching for a module the search space is always restricted to a single service.
1: 	This service is usually the system service or the service of the module making the
1: 	search request. It would be very rare (wrong?) to search for a module in a service that
1: 	was not the current service and not the system service.
1: 	<BR>
1: 	Within the list of modules in the service the search is conducted as follows:
1: 	<OL>
1: 	<LI>See if the instance of the module an instance of the factory interface (isInstance() method
1: 	of java.lang.Class), if not skip to the next module.
1: 	<LI>See if the identifier of the module matches the required identifier, if not skip to the next module.
1: 	<LI>See if the canSupport() method of ModuleControl returns true when called with the
1: 	Properties set of the service, if not skip to the next module.
1: 	</OL>
1: 	Note that no search order of the modules is guaranteed.
1: 	<BR>
1: 	Also note that a module may be found by a different factory interface to the one
1: 	it was created under. Thus a class may implement multiple factory interfaces, its boot
1: 	method has no knowledge of which factory interface it was requested by.
1: 
1:   <P><B>Service Properties</B><BR>
1: 
1: 	Within the service's Properties a module may search for its parameters. It identifies
1: 	its parameters using a unqiue parameter name and its identifier.
1: 	<BR>
1: 	Unique parameter names are made unique through the 'dot' convention of Properties
1: 	files. A module protocol picks some unique key portion to start, e.g. RawStore for the RawStoreFactory
1: 	and then extends that for specific parameters, e.g. RawStore.PageSize. Thus
1: 	parameters that are typically understood by all implementations of that protocol would
1: 	start with that key portion. Parameters for specific implementations add another key portion
1: 	onto the protocol key portion, e.g. RawStore.FileSystem for an file system implementation
1: 	of the raw store, with a specific parameter being RawStore.FileSystem.SectorSize.
1: 
1: 	<BR>These are general guidelines, UUID's could be used as the properties keys but
1: 	would make the parameters hard to read.
1: 	<BR>
1: 	When a module is unidentified it should look for a parameter using just
1: 	the property key for that parameter, e.g. getProperty("RawStore.PageSize").
1: 	<BR>
1: 	When a module has an identifier is should look for a property using the
1: 	key with a dot and the identifier appended, e.g. getProperty("RawStore.PageSize" + "." + identifier).
1: 	<BR>
1: 	In addition to searching for parameters in the service properties set, the system and
1: 	application set may be searched using the getProperty() method of ModuleFactory.
1: 	<BR><B>Should any order be defined for this, should it be automatic?</B>
1: */
1: public class Monitor {
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	public static final String SERVICE_TYPE_DIRECTORY = "serviceDirectory";
1: 
1: 	public static final Object syncMe = new Object();
1: 
1: 	/**
1: 	  Global debug flag to turn on tracing of reads calls newInstanceFromIdentifier()
1: 	  */
1: 	public final static String
1: 		NEW_INSTANCE_FROM_ID_TRACE_DEBUG_FLAG = SanityManager.DEBUG ? "MonitorNewInstanceFromId" : null;
1: 	
1: 	public static final String DEBUG_TRUE = SanityManager.DEBUG ? "derby.debug.true" : null;
1: 	public static final String DEBUG_FALSE = SanityManager.DEBUG ? "derby.debug.false" : null;
1: 
1: 
1: 	private static ModuleFactory monitor;
1: 	private static boolean active;
1: 
1: 	public Monitor() {
1: 	}
1: 
1: 	/**
1: 		Start a Monitor based software system.
1: 
1: 		This method will execute the following steps.
1: 
1:   <OL>
1:   <LI> Create an instance of a module (monitor) of the required implementation.
1:   <LI> Start the monitor which will in turn start any requested services
1:   <LI> Execute the run() method of startCode (if startCode was not null).
1:   <LI> Return.
1:   </OL>
1:   <P> If MonitorBoot.start() is called more then once then subsequent calls
1:   have no effect.
1: 
0: 		@param properties The application properties
1: 		@param logging Where to place initial error output. This location will be used
1: 			until an InfoStreams module is successfully started.
1: 	*/
1: 
0: 	public static void startMonitor(Properties bootProperties, PrintStream logging) {
1: 
0: 		new org.apache.derby.impl.services.monitor.FileMonitor(bootProperties, logging);			
1: 	}
1: 	/**
0: 		Initialise this class, must only be called by an implementation
1: 		of the monitor (ModuleFactory).
1: 	*/
1: 	public static boolean setMonitor(ModuleFactory theMonitor) {
1: 
1: 		synchronized (syncMe) {
1: 			if (active)
1: 				return false;
1: 
1: 			monitor = theMonitor;
1: 			active = true;
1: 			return true;
1: 		}
1: 	}
1: 
1: 	public static void clearMonitor() {
1: 		// the monitor reference needs to remain valid
1: 		// as there are some accesses to getMonitor()
1: 		// after the system has been shutdown.
1: 		synchronized (syncMe) {
1: 			active = false;
1: 		}
1: 	}
1: 
1: 	/**
1: 		Get the monitor.
1: 	*/
1: 	public static ModuleFactory getMonitor() {
1: 		return monitor;
1: 	}
1: 	public static ModuleFactory getMonitorLite() {
1: 		synchronized (syncMe) {
1: 			if (active && monitor != null)
1: 				return monitor;
1: 		}
1: 
1: 		// initialize a monitor just to get system properties
1: 		// with the right secuirty checks and the correct sematics
1: 		// for lookup of derby.system.home.
1: 		// This instance will be discarded once it is used.				;
1: 
1: 		return new org.apache.derby.impl.services.monitor.FileMonitor();
1: 	}
1: 
1: 	public static HeaderPrintWriter getStream() {
1: 		return monitor.getSystemStreams().stream();
1: 	}
1: 
1: 	/**
1: 		Return the name of the service that the passed in module lives in.
1: 	*/
1: 	public static String getServiceName(Object serviceModule) {
1: 		return monitor.getServiceName(serviceModule);
1: 	}
1: 
1: 
1: 	/**
1: 		Start or find a module in the system service. This call allows modules
1: 		to explictly start services they require.
1: 		If no module matching the criteria is found (see this class's prologue for details)
1: 		then an instance will be created (see prologue) and booted as follows.
1: 		<PRE>
1: 		((ModuleControl) instance).boot(false, (String) null, (Properties) null);
1: 		</PRE>
1: 
1: 		@return a reference to a module.
1: 
1: 		@exception StandardException An attempt to start the module failed.
1: 
1: 		@see ModuleControl#boot
1: 	*/
1: 	public static Object startSystemModule(String factoryInterface)
1: 		throws StandardException {
1: 
1: 		Object module = monitor.startModule(false, (Object) null, factoryInterface, (String) null, (Properties) null);
1: 		
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(module != null, "module is null - " + factoryInterface);
1: 		}
1: 
1: 		return module;
1: 	}
1: 
1: 	/**
1: 		Find a module in the system service.
1: 
1: 		@return a reference to a module or null if one cannot be found.
1: 	*/
1: 	public static Object findSystemModule(String factoryInterface) throws StandardException
1: 	{
1: 		Object module = getMonitor().findModule((Object) null,
1: 									  factoryInterface, (String) null);
1: 		if (module == null)
1: 			throw Monitor.missingImplementation(factoryInterface);
1: 
1: 		return module;
1: 	}
1: 
0: 	public static Object getSystemModule(String factoryInterface)
1: 	{
1: 		Object module = getMonitor().findModule((Object) null,
1: 									  factoryInterface, (String) null);
1: 		return module;
1: 	}
1: 
1: 	/**
1: 		Boot or find a unidentified module within a service. This call allows modules
1: 		to start or create any modules they explicitly require to exist within
1: 		their service. If no module matching the criteria is found (see this class's prologue for details)
1: 		then an instance will be created (see prologue) and booted as follows.
1: 		<PRE>
1: 		((ModuleControl) instance).boot(create, (String) null, properties);
1: 		</PRE>
1: 		<BR>
1: 		The service is defined by the service that the module serviceModule lives in,
1: 		typically this call is made from the boot method of a module and thus
1: 		'this' is passed in for serviceModule.
1: 
1: 		@return a reference to a module.
1: 
1: 		@exception StandardException An attempt to start the module failed.
1: 
1: 	*/
1: 	public static Object bootServiceModule(boolean create, Object serviceModule,
1: 		String factoryInterface, Properties properties)
1: 		throws StandardException {
1: 
1: 		Object module = monitor.startModule(create, serviceModule, factoryInterface,
1: 						(String) null, properties);
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(module != null, "module is null - " + factoryInterface);
1: 		}
1: 
1: 		return module;
1: 	}
1: 
1: 	/**
1: 		Boot or find a identified module within a service. This call allows modules
1: 		to start or create any modules they explicitly require to exist within
1: 		their service. If no module matching the criteria is found (see this class's prologue for details)
1: 		then an instance will be created (see prologue) and booted as follows.
1: 		<PRE>
1: 		((ModuleControl) instance).boot(create, identifer, properties);
1: 		</PRE>
1: 		<BR>
1: 		The service is defined by the service that the module serviceModule lives in,
1: 		typically this call is made from the boot method of a module and thus
1: 		'this' is passed in for serviceModule.
1: 
1: 		@return a reference to a module.
1: 
1: 		@exception StandardException An attempt to start the module failed.
1: 
1: 	*/
1: 	public static Object bootServiceModule(boolean create, Object serviceModule,
1: 		String factoryInterface, String identifier, Properties properties)
1: 		throws StandardException {
1: 
1: 		Object module = monitor.startModule(create, serviceModule, factoryInterface, identifier, properties);
1: 		
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(module != null, "module is null - " + factoryInterface);
1: 		}
1: 
1: 		return module;
1: 	}
1: 
1: 	/**
1: 		Find an unidentified module within a service.
1: 		<BR>
1: 		The service is defined by the service that the module serviceModule lives in.
1: 
1: 		@return a reference to a module or null if one cannot be found.
1: 
1: 	*/
1: 	public static Object findServiceModule(Object serviceModule, String factoryInterface)
1: 		throws StandardException {
1: 		Object module = getMonitor().findModule(serviceModule, factoryInterface, (String) null);
1: 		if (module == null)
1: 			throw Monitor.missingImplementation(factoryInterface);
1: 		return module;
1: 	}
1: 	public static Object getServiceModule(Object serviceModule, String factoryInterface)
1: 	{
1: 		Object module = getMonitor().findModule(serviceModule, factoryInterface, (String) null);
1: 		return module;
1: 	}
1: 
1: 	/**
1: 		Find an identified module within a service.
1: 		<BR>
1: 		The service is defined by the service that the module serviceModule lives in.
1: 
1: 		@return a reference to a module or null if one cannot be found.
1: 
1: 	*/
1: 	//public static Object findServiceModule(Object serviceModule, String factoryInterface, String identifier) {
1: 	//	return monitor.findModule(serviceModule, factoryInterface, identifier);
1: 	//}
1: 
1: 
1: 	/**
1: 		Find a service.
1: 
1: 		@return a refrence to a module represeting the service or null if the service does not exist.
1: 
1: 	*/
1: 	public static Object findService(String factoryInterface, String serviceName) {
1: 		return monitor.findService(factoryInterface, serviceName);
1: 	}
1: 
1: 	/**
1: 		Start a persistent service. The name of the service can include a
1: 		service type, in the form 'type:serviceName'.
1: 		<BR>
1: 		Note that the return type only indicates
1: 		if the service can be handled by the monitor. It does not indicate
1: 		the service was started successfully. The cases are
1: 		<OL>
1: 		<LI> Service type not handled - false returned.
1: 		<LI> Service type handled, service does not exist, true returned.
1: 		<LI> Service type handled, service exists and booted OK, true returned.
1: 		<LI> Service type handled, service exists and failed to boot, exception thrown.
1: 		</OL>
1: 
1: 		If true is returned then findService should be used to see if the service
1: 		exists or not.
1: 
1: 		@return true if the service type is handled by the monitor, false if it isn't
1: 
1: 		@exception StandardException An attempt to start the service failed.
1: 	*/
1: 
1: 	public static boolean startPersistentService(String serviceName, 
1: 												 Properties properties) 
1: 		throws StandardException {
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(serviceName != null, "serviceName is null");
1: 		}
1: 
1: 		return monitor.startPersistentService(serviceName, properties);
1: 	}
1: 
1: 	/**
1: 		Start a non-persistent service. 
1: 		<P><B>Context</B><BR>
1: 		A context manager will be created and installed at the start of this method and destroyed
1: 		just before this method returns.
1: 
1: 		@return The module from the service if it was started successfully. 
1: 
1: 		@exception StandardException An exception was thrown trying to start the service.
1: 	*/
1: 	public static Object startNonPersistentService(String factoryInterface, String serviceName, Properties properties)
1: 		throws StandardException {
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(factoryInterface != null, "serviceName is null");
1: 			SanityManager.ASSERT(serviceName != null, "serviceName is null");
1: 		}
1: 
1: 		return monitor.startNonPersistentService(factoryInterface, serviceName, properties);
1: 	}
1: 
1: 	/**
1: 		Create a named service that implements the java interface (or class) fully qualified by factoryInterface.
1: 		The Properties object specifies create time parameters to be used by the modules within the
1: 		service. Any module created by this service may add or remove parameters within the
1: 		properties object in their ModuleControl.boot() method. The properties set will be saved
1: 		by the Monitor for later use when the monitor is started.
1: 		<P><B>Context</B><BR>
1: 		A context manager will be created and installed at the start of this method and destroyed
1: 		just before this method returns.
1: 
1: 		@return The module from the service if it was created successfully, null if a service already existed. 
1: 
1: 		@exception StandardException An exception was thrown trying to create the service.
1: 	*/
1: 	public static Object createPersistentService(String factoryInterface, String serviceName, Properties properties) 
1: 		throws StandardException {
1: 
1: 		if (SanityManager.DEBUG) {
1: 			SanityManager.ASSERT(factoryInterface != null, "serviceName is null");
1: 			SanityManager.ASSERT(serviceName != null, "serviceName is null");
1: 		}
1: 		
1: 		return monitor.createPersistentService(factoryInterface, serviceName, properties);
1: 	}
1:     public static void removePersistentService(String name)
1:         throws StandardException
1:     {
1: 		monitor.removePersistentService(name);
1:     }
1: 
1: 	/**
1: 		Obtain the class object for a class that supports the given identifier.
1: 
1: 		If no class has been registered for the identifier then a StandardException
1: 		is thrown with no attached java.lang exception (nextException).
1: 		If a problem loading or accessing the class is obtained then a StandardException
1: 		is thrown with the real java.lang exception attached.
1: 
1: 		@return a valid class object
1: 
1: 		@exception StandardException See text above.
1: 	*/
1: 	public static InstanceGetter classFromIdentifier(int identifier) 
1: 		throws StandardException {
1: 		return monitor.classFromIdentifier(identifier);
1: 	}
1: 
1: 	/**
1: 		Obtain an new instance of a class that supports the given identifier.
1: 
1: 		If no class has been registered for the identifier then a StandardException
1: 		is thrown with no attached java.lang exception (getNestedException).
1: 		If a problem loading or accessing the class or creating the object is obtained
1: 		then a StandardException is thrown with the real java.lang exception attached.
1: 
1: 		@return a reference to a newly created object
1: 
1: 		@exception StandardException See text above.
1: 	*/
1: 	public static Object newInstanceFromIdentifier(int identifier) 
1: 		throws StandardException {
1: 		return monitor.newInstanceFromIdentifier(identifier);
1: 	}
1: 
1: 
1: 	/* 
1: 	** Static methods for startup type exceptions.
1: 	*/
1: 		/**
1: 		return a StandardException to indicate that a module failed to
1: 		start because it could not obtain the version of a required product.
1: 
1: 		@param productGenusName The genus name of the product.
1: 		@return The exception.
1: 	*/
1: 	public static StandardException missingProductVersion(String productGenusName)
1: 	{
1: 		return StandardException.newException(SQLState.MISSING_PRODUCT_VERSION, productGenusName);
1: 	}
1: 
1: 	/**
1: 		return a StandardException to indicate a missing
1: 		implementation.
1: 
1: 		@param implementation the module name of the missing implementation.
1: 
1: 		@return The exception.
1: 	*/
1: 	public static StandardException missingImplementation(String implementation) 
1: 	{
1: 		return StandardException.newException(SQLState.SERVICE_MISSING_IMPLEMENTATION, implementation);
1: 	}
1: 
1: 	/**
1: 		return a StandardException to indicate that an exception caused
1: 		starting the module to fail.
1: 
1: 		@param t the exception which caused starting the module to fail.
1: 
1: 		@return The exception.
1: 	*/
1: 	public static StandardException exceptionStartingModule(Throwable t)
1: 	{
1: 		return StandardException.newException(SQLState.SERVICE_STARTUP_EXCEPTION, t);
1: 	}
1: 
1: 	public static void logMessage(String messageText) {
1: 		getStream().println(messageText);
1: 	}
1: 
0: 	public static void logTextMessage(String messageID) {
0: 		getStream().println(MessageService.getTextMessage(messageID));
1: 	}
0: 	public static void logTextMessage(String messageID, Object a1) {
0: 		getStream().println(MessageService.getTextMessage(messageID, a1));
1: 	}
0: 	public static void logTextMessage(String messageID, Object a1, Object a2) {
0: 		getStream().println(MessageService.getTextMessage(messageID, a1, a2));
1: 	}
0: 	public static void logTextMessage(String messageID, Object a1, Object a2, Object a3) {
0: 		getStream().println(MessageService.getTextMessage(messageID, a1, a2, a3));
1: 	}
0: 	public static void logTextMessage(String messageID, Object a1, Object a2, Object a3, Object a4) {
0: 		getStream().println(MessageService.getTextMessage(messageID, a1, a2, a3, a4));
1: 	}
1: 
1: 	/**
1: 	 *  Translate a localeDescription of the form ll[_CC[_variant]] to
1: 	 *  a Locale object.
1: 	 */
1: 	public static Locale getLocaleFromString(String localeDescription)
1: 								throws StandardException {
1: 		return monitor.getLocaleFromString(localeDescription);
1: 	}
1: 
1: 
1: 	/**
1: 		Single point for checking if an upgrade is allowed.
1: 	 */
1: 	public static boolean isFullUpgrade(Properties startParams, String oldVersionInfo) throws StandardException {
1: 
1: 		boolean fullUpgrade = Boolean.valueOf(startParams.getProperty(org.apache.derby.iapi.reference.Attribute.UPGRADE_ATTR)).booleanValue();
1: 
0: 		if (true || !fullUpgrade) {
1: 
0: 			ProductVersionHolder engineVersion = Monitor.getMonitor().getEngineVersion();
1: 
0: 			if (engineVersion.isBeta() || engineVersion.isAlpha()) {
0: 				// soft upgrade not supported for beta.
0: 				throw StandardException.newException(SQLState.NO_UPGRADE, oldVersionInfo, engineVersion.getSimpleVersionString());
1: 			}
1: 
0: 			// Gandalf release does not support any soft or hard upgrade,
0: 			// remove this exception when upgrade support is added, and
0: 			// add back in the following code which has been commented out
0: 			// as it is currently unreachable.
0: 			throw StandardException.newException(
0: 				SQLState.LANG_CANT_UPGRADE_DATABASE, oldVersionInfo, engineVersion);
1: 		}
1: 
1: 
1: 		return fullUpgrade;
1: 	}
1: 
1: 	/**
1: 	  *
1: 	  *	@param	startParams			startup parameters
1: 	  *	@param	desiredProperty		property we're interested in
1: 	  *
1: 	  *	@return	true		type is as desired.
1: 	  *			false		otherwise
1: 	  *
1: 	  */
1: 	public static boolean isDesiredType(Properties startParams, int desiredProperty )
1: 	{
0: 		boolean	retval = false;
0: 		int		engineType = EngineType.NONE;
1: 
1: 		if ( startParams != null )
1: 		{
1: 			engineType = Monitor.getEngineType( startParams );
1: 		}
1: 
1: 		return (engineType & desiredProperty) != 0;
1: 	}
0: 	public static boolean isDesiredType(int engineType, int desiredProperty) {
1: 		return (engineType & desiredProperty) != 0;
1: 	}
1: 	
1: 	/**
1: 	  *	@param	startParams		startup parameters
1: 	  *
1: 	  *	@return	type of engine
1: 	  *
1: 	  */
1: 
1: 	static	public	int	getEngineType(Properties startParams)
1: 	{
1: 		if ( startParams != null )
1: 		{
1: 			String etp = startParams.getProperty(EngineType.PROPERTY);
1: 
1: 			int engineType = etp == null ? EngineType.STANDALONE_DB : Integer.parseInt(etp.trim());
1: 
1: 			return engineType;
1: 		}
1: 
1: 		return EngineType.STANDALONE_DB;
1: 	}
1: 
1: 	/**
1: 	  Return true if the properties set provided contains
1: 	  database creation attributes for a database
1: 	  of the correct type
1: 	  */
1: 	public static boolean isDesiredCreateType(Properties p, int type)
1: 	{
1: 		boolean plainCreate = Boolean.valueOf(p.getProperty(Attribute.CREATE_ATTR)).booleanValue();
1: 
1: 		if (plainCreate) {
0: 			return (type & EngineType.NONE) != 0;
1: 		}
1: 
1: 		// database must already exist
1: 		return isDesiredType(p, type);
1: 	}
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 	<LI>The application properties set (i.e. obtained from the derby.properties file).
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.monitor
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.monitor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.info.ProductGenusNames;
0: import org.apache.derby.iapi.services.info.ProductVersionHolder;
0: import org.apache.derby.iapi.reference.EngineType;
0: import org.apache.derby.iapi.reference.Attribute;
0: 
0: import org.apache.derby.iapi.services.loader.InstanceGetter;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.Property;
0: 
0: import java.util.Properties;
0: import java.util.Locale;
0: import java.io.PrintStream;
0: 
0: /**
0: 	<P><B>Services</B><BR>
0: 
0: 	A service is a collection of modules that combine to provide
0: 	the full functionality defined by the service. A service is defined
0: 	by three pieces of information:
0: 	<OL>
0: 	<LI>A fully qualified java class name that identifies the functionality or API
0: 	that the service must provide. Typically this class represents a java interface.
0: 	This class name is termed the <EM>factory interface</EM>.
0: 	<LI>The <EM>identifier</EM> of the service. Services are identified by a String, this may
0: 	be hard-coded, come from a UUID or any other source.
0: 	<LI>An optional java.util.Properties set.
0: 	</OL>
0: 	<BR>
0: 	The running functionality of the service is provided by a module
0: 	that implements the factory interface. The identifier of the this module
0: 	is not (need not be) the same as the identifier of the service. The identifier
0: 	of the service is held by the monitor in its service tables.
0: 	<BR>
0: 	Each module in a service is keyed by at least one factory interface, identifier}
0: 	pair. This pair is guaranteed to be unique within the service.
0: 	<BR>
0: 	The lifetime of a module in a service is no longer than the lifetime of the service.
0: 	Thus shutting down a service shuts down all the modules within a service.
0: 	<B>Optionally - </B> an individual module within a service may be shutdown, this will
0: 	in turn shutdown any modules it started if those module are not in use by other
0: 	modules within the service. This would be handled by the monitor, not the module itself.
0: 	<BR>
0: 	A service may be persistent, it goes through a boot in create mode, and subsequently boot
0: 	in non-create mode, or a non-peristent service, it always boots in non-create mode.
0: 	Persistent services can store their re-start parameters in their properties set, the monitor
0: 	provides the persistent storage of the properties set.
0: 	Non-persistent services do not have a properties set.
0: 
0: 	<P><B>Booting Services</B><BR>
0: 	Services can be booted a number of ways
0: 	<UL>
0: 	<LI>A non-persistent service can be booted by having a property in the application properties
0: 	or the system (JVM) set.
0: 	<PRE>
0: 	derby.service.<EM>service name</EM>=<EM>class name</EM>
0: 	e.g.
0: 	# Added to the properties automatically by the class org.apache.derby.jdbc.EmbeddedDriver
0: 	derby.service.jdbc=java.sql.Driver
0: 	</PRE>
0: 	<LI>A persistent service can be booted by having a property in the application properties
0: 	or the system (JVM) set.
0: 	<PRE>
0: 	derby.service.<EM>service name</EM>=<EM>persistent storage type</EM>
0: 	e.g.
0: 	derby.service.mydatabase=serviceDirectory
0: 	</PRE>
0: 	serviceDirectory is a type understood by the monitor which means that there is a directory
0: 	named mydatabase within the system directory and within it is a properties file service.properties. This properties
0: 	set is the set for the service and must contain a property
0: 	<PRE>
0: 	derby.protocol=<EM>class name</EM>
0: 	</PRE>
0: 	This is then the factory interface for the service. Other storage types could be added in
0: 	the future.
0: 	<LI>
0: 	The monitor at start time looks for all persistent services that it can find and starts them.
0: 	E.g. all directories in the system directory that have a file service.properties are started
0: 	as services.
0: 	<LI>Services are started on demand, e.g. a findService attempts to boot a service if it
0: 	cannot be found.
0: 	</UL>
0: 	<B>Any or all of these three latter methods can be implemented. A first release may
0: 	just implement the look for all services and boot them.</B>
0: 	.
0: 	<P><B>System Service</B><BR>
0: 	A special service exists, the System Service. This service has no factory interface,
0: 	no identifier and no Properties set. It allows modules to be started that are required
0: 	by another service (or the monitor itself) but are not fundamentally part of the service.
0: 	Modules within this service are unidentified.
0: 	Typically these modules are system wide types of functionality like streams, uuid creation etc.
0: 	<BR>
0: 	The lifetime of a system module is the lifetime of the monitor.
0: 	<B>Optionally - </B> this could be changed to reference count on individual modules, requires
0: 	some minor api changes.
0: 
0: 	<P><B>Modules</B><BR>
0: 
0: 	A module is found or booted using four pieces of information:
0: 	<OL>
0: 	<LI>The service the module lives in or will live in.
0: 	<LI>A fully qualified java class name that identifies the functionality or API
0: 	that the module must provide. Typically this class represents a java interface.
0: 	This class name is termed the <EM>factory interface</EM>.
0: 	<LI>The <EM>identifier</EM> of the module. Modules are identified by a String, this may
0: 	be null, be hard-coded, come from a UUID or any other source. If the identifier
0: 	is null then the module is described as <EM>unidentified</EM>.
0: 	<LI>Boot time only - A java.util.Properties set. This Properties set is service wide
0: 	and typically contains parameters used to determine module implementation or runtime
0: 	behaviour.
0: 	</OL>
0: 	<BR>
0: 	The service is identified by explicitly identifiying the System Service or
0: 	by providing a reference to a module that already exists with the required service.
0: 	<BR>
0: 	The factory interface is provided by a String constant of the form class.MODULE
0: 	from the required interface.
0: 	<BR>
0: 	The module identifier is provided in a fashion determined by the code, in most
0: 	cases a unidentified module will suffice.
0: 	<BR>
0: 	The Properties set is also determined in a fashion determined by the code at
0: 	create or add service time.
0: 
0:   <P><B>Module Implementations</B><BR>
0: 
0: 	When creating an instance of a module, an implementation is found through lists of
0: 	potential implementations.
0: 	<BR>
0: 	A list of potential implementations is obtained from a Properties set. Any property
0: 	within this set that is of the form
0: 	<PRE>
0: 	derby.module.<EM>tag</EM>=<EM>java class name</EM>
0: 	</PRE>
0: 	is seen by the monitor as a possible implementation. <EM>tag</EM> has no meaning within
0: 	the monitor, it is only there to provide uniqueness within the properties file. Typically
0: 	the tag is to provide some description for human readers of the properties file, e.g.
0: 	derby.module.lockManager for an implementation of a lock manager.
0: 	<BR>
0: 	The monitor looks through four properties sets for lists of potential implementations in this
0: 	order. 
0: 	<OL>
0: 	<LI>The properties set of the service (i.e. that passed into Monitor.createPersistentService()
0: 	or Monitor.startService()).
0: 	<LI>The System (JVM) properties set (i.e. java.lang.System.getProperties()).
0: 	<LI>The application properties set (i.e. obtained from the cloudscape.properties file).
0: 	<LI>The default implementation properties set (i.e. obtained from the
0: 	/org/apache/derby/modules.properties resource).
0: 	</OL>
0: 	Any one of the properties can be missing or not have any implementations listed within it.
0: 	<BR>
0: 	Every request to create an instance of a module searches the four implementation
0: 	lists in the order above. Which list the current running code or the passed in service
0: 	module came from is not relevant.
0: 	<BR>
0: 	Within each list of potential implementations the search is conducted as follows:
0: 	<OL>
0: 	<LI>Attempt to load the class, if the class cannot be loaded skip to the next potential
0: 	implementation.
0: 	<LI>See if the factory interface is assignable from the class (isAssignableFrom() method
0: 	of java.lang.Class), if not skip to the next potential implementation.
0: 	<LI>See if an instance of the class can be created without any exceptions (newInstance() method
0: 	of java.lang.Class), if not skip to the next potential implementation.
0: 	<LI>[boot time only] See if the canSupport() method of ModuleControl returns true when called with the
0: 	Properties set of the service, if not skip to the next potential implementation.
0: 	</OL>
0: 	If all these checks pass then the instance is a valid implementation and its boot() method
0: 	of ModuleControl is called to activate it. Note that the search order within
0: 	the list obtained from a Properties set is not guaranteed.
0: 
0: 	 <P><B>Module Searching</B><BR>
0: 
0: 	When searching for a module the search space is always restricted to a single service.
0: 	This service is usually the system service or the service of the module making the
0: 	search request. It would be very rare (wrong?) to search for a module in a service that
0: 	was not the current service and not the system service.
0: 	<BR>
0: 	Within the list of modules in the service the search is conducted as follows:
0: 	<OL>
0: 	<LI>See if the instance of the module an instance of the factory interface (isInstance() method
0: 	of java.lang.Class), if not skip to the next module.
0: 	<LI>See if the identifier of the module matches the required identifier, if not skip to the next module.
0: 	<LI>See if the canSupport() method of ModuleControl returns true when called with the
0: 	Properties set of the service, if not skip to the next module.
0: 	</OL>
0: 	Note that no search order of the modules is guaranteed.
0: 	<BR>
0: 	Also note that a module may be found by a different factory interface to the one
0: 	it was created under. Thus a class may implement multiple factory interfaces, its boot
0: 	method has no knowledge of which factory interface it was requested by.
0: 
0:   <P><B>Service Properties</B><BR>
0: 
0: 	Within the service's Properties a module may search for its parameters. It identifies
0: 	its parameters using a unqiue parameter name and its identifier.
0: 	<BR>
0: 	Unique parameter names are made unique through the 'dot' convention of Properties
0: 	files. A module protocol picks some unique key portion to start, e.g. RawStore for the RawStoreFactory
0: 	and then extends that for specific parameters, e.g. RawStore.PageSize. Thus
0: 	parameters that are typically understood by all implementations of that protocol would
0: 	start with that key portion. Parameters for specific implementations add another key portion
0: 	onto the protocol key portion, e.g. RawStore.FileSystem for an file system implementation
0: 	of the raw store, with a specific parameter being RawStore.FileSystem.SectorSize.
0: 
0: 	<BR>These are general guidelines, UUID's could be used as the properties keys but
0: 	would make the parameters hard to read.
0: 	<BR>
0: 	When a module is unidentified it should look for a parameter using just
0: 	the property key for that parameter, e.g. getProperty("RawStore.PageSize").
0: 	<BR>
0: 	When a module has an identifier is should look for a property using the
0: 	key with a dot and the identifier appended, e.g. getProperty("RawStore.PageSize" + "." + identifier).
0: 	<BR>
0: 	In addition to searching for parameters in the service properties set, the system and
0: 	application set may be searched using the getProperty() method of ModuleFactory.
0: 	<BR><B>Should any order be defined for this, should it be automatic?</B>
0: */
0: public class Monitor {
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	public static final String SERVICE_TYPE_DIRECTORY = "serviceDirectory";
0: 
0: 	public static final Object syncMe = new Object();
0: 
0: 	/**
0: 	  Global debug flag to turn on tracing of reads calls newInstanceFromIdentifier()
0: 	  */
0: 	public final static String
0: 		NEW_INSTANCE_FROM_ID_TRACE_DEBUG_FLAG = SanityManager.DEBUG ? "MonitorNewInstanceFromId" : null;
0: 	
0: 	public static final String DEBUG_TRUE = SanityManager.DEBUG ? "derby.debug.true" : null;
0: 	public static final String DEBUG_FALSE = SanityManager.DEBUG ? "derby.debug.false" : null;
0: 
0: 
0: 	private static ModuleFactory monitor;
0: 	private static boolean active;
0: 
0: 	public Monitor() {
0: 	}
0: 
0: 	/**
0: 		Start a Monitor based software system.
0: 
0: 		This method will execute the following steps.
0: 
0:   <OL>
0:   <LI> Create an instance of a module (monitor) of the required implementation.
0:   <LI> Start the monitor which will in turn start any requested services
0:   <LI> Execute the run() method of startCode (if startCode was not null).
0:   <LI> Return.
0:   </OL>
0:   <P> If MonitorBoot.start() is called more then once then subsequent calls
0:   have no effect.
0: 
0: 		@param properties The application properties
0: 		@param logging Where to place initial error output. This location will be used
0: 			until an InfoStreams module is successfully started.
0: 	*/
0: 
0: 	public static void startMonitor(Properties bootProperties, PrintStream logging) {
0: 
0: 		new org.apache.derby.impl.services.monitor.FileMonitor(bootProperties, logging);			
0: 	}
0: 	/**
0: 		Initialise this class, must only be called by an implementation
0: 		of the monitor (ModuleFactory).
0: 	*/
0: 	public static boolean setMonitor(ModuleFactory theMonitor) {
0: 
0: 		synchronized (syncMe) {
0: 			if (active)
0: 				return false;
0: 
0: 			monitor = theMonitor;
0: 			active = true;
0: 			return true;
0: 		}
0: 	}
0: 
0: 	public static void clearMonitor() {
0: 		// the monitor reference needs to remain valid
0: 		// as there are some accesses to getMonitor()
0: 		// after the system has been shutdown.
0: 		synchronized (syncMe) {
0: 			active = false;
0: 		}
0: 	}
0: 
0: 	/**
0: 		Get the monitor.
0: 	*/
0: 	public static ModuleFactory getMonitor() {
0: 		return monitor;
0: 	}
0: 	public static ModuleFactory getMonitorLite() {
0: 		synchronized (syncMe) {
0: 			if (active && monitor != null)
0: 				return monitor;
0: 		}
0: 
0: 		// initialize a monitor just to get system properties
0: 		// with the right secuirty checks and the correct sematics
0: 		// for lookup of derby.system.home.
0: 		// This instance will be discarded once it is used.				;
0: 
0: 		return new org.apache.derby.impl.services.monitor.FileMonitor();
0: 	}
0: 
0: 	public static HeaderPrintWriter getStream() {
0: 		return monitor.getSystemStreams().stream();
0: 	}
0: 
0: 	/**
0: 		Return the name of the service that the passed in module lives in.
0: 	*/
0: 	public static String getServiceName(Object serviceModule) {
0: 		return monitor.getServiceName(serviceModule);
0: 	}
0: 
0: 
0: 	/**
0: 		Start or find a module in the system service. This call allows modules
0: 		to explictly start services they require.
0: 		If no module matching the criteria is found (see this class's prologue for details)
0: 		then an instance will be created (see prologue) and booted as follows.
0: 		<PRE>
0: 		((ModuleControl) instance).boot(false, (String) null, (Properties) null);
0: 		</PRE>
0: 
0: 		@return a reference to a module.
0: 
0: 		@exception StandardException An attempt to start the module failed.
0: 
0: 		@see ModuleControl#boot
0: 	*/
0: 	public static Object startSystemModule(String factoryInterface)
0: 		throws StandardException {
0: 
0: 		Object module = monitor.startModule(false, (Object) null, factoryInterface, (String) null, (Properties) null);
0: 		
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(module != null, "module is null - " + factoryInterface);
0: 		}
0: 
0: 		return module;
0: 	}
0: 
0: 	/**
0: 		Find a module in the system service.
0: 
0: 		@return a reference to a module or null if one cannot be found.
0: 	*/
0: 	public static Object findSystemModule(String factoryInterface) throws StandardException
0: 	{
0: 		Object module = getMonitor().findModule((Object) null,
0: 									  factoryInterface, (String) null);
0: 		if (module == null)
0: 			throw Monitor.missingImplementation(factoryInterface);
0: 
0: 		return module;
0: 	}
0: 
0: 	public static Object getSystemModule(String factoryInterface)
0: 	{
0: 		Object module = getMonitor().findModule((Object) null,
0: 									  factoryInterface, (String) null);
0: 		return module;
0: 	}
0: 
0: 	/**
0: 		Boot or find a unidentified module within a service. This call allows modules
0: 		to start or create any modules they explicitly require to exist within
0: 		their service. If no module matching the criteria is found (see this class's prologue for details)
0: 		then an instance will be created (see prologue) and booted as follows.
0: 		<PRE>
0: 		((ModuleControl) instance).boot(create, (String) null, properties);
0: 		</PRE>
0: 		<BR>
0: 		The service is defined by the service that the module serviceModule lives in,
0: 		typically this call is made from the boot method of a module and thus
0: 		'this' is passed in for serviceModule.
0: 
0: 		@return a reference to a module.
0: 
0: 		@exception StandardException An attempt to start the module failed.
0: 
0: 	*/
0: 	public static Object bootServiceModule(boolean create, Object serviceModule,
0: 		String factoryInterface, Properties properties)
0: 		throws StandardException {
0: 
0: 		Object module = monitor.startModule(create, serviceModule, factoryInterface,
0: 						(String) null, properties);
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(module != null, "module is null - " + factoryInterface);
0: 		}
0: 
0: 		return module;
0: 	}
0: 
0: 	/**
0: 		Boot or find a identified module within a service. This call allows modules
0: 		to start or create any modules they explicitly require to exist within
0: 		their service. If no module matching the criteria is found (see this class's prologue for details)
0: 		then an instance will be created (see prologue) and booted as follows.
0: 		<PRE>
0: 		((ModuleControl) instance).boot(create, identifer, properties);
0: 		</PRE>
0: 		<BR>
0: 		The service is defined by the service that the module serviceModule lives in,
0: 		typically this call is made from the boot method of a module and thus
0: 		'this' is passed in for serviceModule.
0: 
0: 		@return a reference to a module.
0: 
0: 		@exception StandardException An attempt to start the module failed.
0: 
0: 	*/
0: 	public static Object bootServiceModule(boolean create, Object serviceModule,
0: 		String factoryInterface, String identifier, Properties properties)
0: 		throws StandardException {
0: 
0: 		Object module = monitor.startModule(create, serviceModule, factoryInterface, identifier, properties);
0: 		
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(module != null, "module is null - " + factoryInterface);
0: 		}
0: 
0: 		return module;
0: 	}
0: 
0: 	/**
0: 		Find an unidentified module within a service.
0: 		<BR>
0: 		The service is defined by the service that the module serviceModule lives in.
0: 
0: 		@return a reference to a module or null if one cannot be found.
0: 
0: 	*/
0: 	public static Object findServiceModule(Object serviceModule, String factoryInterface)
0: 		throws StandardException {
0: 		Object module = getMonitor().findModule(serviceModule, factoryInterface, (String) null);
0: 		if (module == null)
0: 			throw Monitor.missingImplementation(factoryInterface);
0: 		return module;
0: 	}
0: 	public static Object getServiceModule(Object serviceModule, String factoryInterface)
0: 	{
0: 		Object module = getMonitor().findModule(serviceModule, factoryInterface, (String) null);
0: 		return module;
0: 	}
0: 
0: 	/**
0: 		Find an identified module within a service.
0: 		<BR>
0: 		The service is defined by the service that the module serviceModule lives in.
0: 
0: 		@return a reference to a module or null if one cannot be found.
0: 
0: 	*/
0: 	//public static Object findServiceModule(Object serviceModule, String factoryInterface, String identifier) {
0: 	//	return monitor.findModule(serviceModule, factoryInterface, identifier);
0: 	//}
0: 
0: 
0: 	/**
0: 		Find a service.
0: 
0: 		@return a refrence to a module represeting the service or null if the service does not exist.
0: 
0: 	*/
0: 	public static Object findService(String factoryInterface, String serviceName) {
0: 		return monitor.findService(factoryInterface, serviceName);
0: 	}
0: 
0: 	/**
0: 		Start a persistent service. The name of the service can include a
0: 		service type, in the form 'type:serviceName'.
0: 		<BR>
0: 		Note that the return type only indicates
0: 		if the service can be handled by the monitor. It does not indicate
0: 		the service was started successfully. The cases are
0: 		<OL>
0: 		<LI> Service type not handled - false returned.
0: 		<LI> Service type handled, service does not exist, true returned.
0: 		<LI> Service type handled, service exists and booted OK, true returned.
0: 		<LI> Service type handled, service exists and failed to boot, exception thrown.
0: 		</OL>
0: 
0: 		If true is returned then findService should be used to see if the service
0: 		exists or not.
0: 
0: 		@return true if the service type is handled by the monitor, false if it isn't
0: 
0: 		@exception StandardException An attempt to start the service failed.
0: 	*/
0: 
0: 	public static boolean startPersistentService(String serviceName, 
0: 												 Properties properties) 
0: 		throws StandardException {
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(serviceName != null, "serviceName is null");
0: 		}
0: 
0: 		return monitor.startPersistentService(serviceName, properties);
0: 	}
0: 
0: 	/**
0: 		Start a non-persistent service. 
0: 		<P><B>Context</B><BR>
0: 		A context manager will be created and installed at the start of this method and destroyed
0: 		just before this method returns.
0: 
0: 		@return The module from the service if it was started successfully. 
0: 
0: 		@exception StandardException An exception was thrown trying to start the service.
0: 	*/
0: 	public static Object startNonPersistentService(String factoryInterface, String serviceName, Properties properties)
0: 		throws StandardException {
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(factoryInterface != null, "serviceName is null");
0: 			SanityManager.ASSERT(serviceName != null, "serviceName is null");
0: 		}
0: 
0: 		return monitor.startNonPersistentService(factoryInterface, serviceName, properties);
0: 	}
0: 
0: 	/**
0: 		Create a named service that implements the java interface (or class) fully qualified by factoryInterface.
0: 		The Properties object specifies create time parameters to be used by the modules within the
0: 		service. Any module created by this service may add or remove parameters within the
0: 		properties object in their ModuleControl.boot() method. The properties set will be saved
0: 		by the Monitor for later use when the monitor is started.
0: 		<P><B>Context</B><BR>
0: 		A context manager will be created and installed at the start of this method and destroyed
0: 		just before this method returns.
0: 
0: 		@return The module from the service if it was created successfully, null if a service already existed. 
0: 
0: 		@exception StandardException An exception was thrown trying to create the service.
0: 	*/
0: 	public static Object createPersistentService(String factoryInterface, String serviceName, Properties properties) 
0: 		throws StandardException {
0: 
0: 		if (SanityManager.DEBUG) {
0: 			SanityManager.ASSERT(factoryInterface != null, "serviceName is null");
0: 			SanityManager.ASSERT(serviceName != null, "serviceName is null");
0: 		}
0: 		
0: 		return monitor.createPersistentService(factoryInterface, serviceName, properties);
0: 	}
0:     public static void removePersistentService(String name)
0:         throws StandardException
0:     {
0: 		monitor.removePersistentService(name);
0:     }
0: 
0: 	/**
0: 		Obtain the class object for a class that supports the given identifier.
0: 
0: 		If no class has been registered for the identifier then a StandardException
0: 		is thrown with no attached java.lang exception (nextException).
0: 		If a problem loading or accessing the class is obtained then a StandardException
0: 		is thrown with the real java.lang exception attached.
0: 
0: 		@return a valid class object
0: 
0: 		@exception StandardException See text above.
0: 	*/
0: 	public static InstanceGetter classFromIdentifier(int identifier) 
0: 		throws StandardException {
0: 		return monitor.classFromIdentifier(identifier);
0: 	}
0: 
0: 	/**
0: 		Obtain an new instance of a class that supports the given identifier.
0: 
0: 		If no class has been registered for the identifier then a StandardException
0: 		is thrown with no attached java.lang exception (getNestedException).
0: 		If a problem loading or accessing the class or creating the object is obtained
0: 		then a StandardException is thrown with the real java.lang exception attached.
0: 
0: 		@return a reference to a newly created object
0: 
0: 		@exception StandardException See text above.
0: 	*/
0: 	public static Object newInstanceFromIdentifier(int identifier) 
0: 		throws StandardException {
0: 		return monitor.newInstanceFromIdentifier(identifier);
0: 	}
0: 
0: 
0: 	/* 
0: 	** Static methods for startup type exceptions.
0: 	*/
0: 		/**
0: 		return a StandardException to indicate that a module failed to
0: 		start because it could not obtain the version of a required product.
0: 
0: 		@param productGenusName The genus name of the product.
0: 		@return The exception.
0: 	*/
0: 	public static StandardException missingProductVersion(String productGenusName)
0: 	{
0: 		return StandardException.newException(SQLState.MISSING_PRODUCT_VERSION, productGenusName);
0: 	}
0: 
0: 	/**
0: 		return a StandardException to indicate a missing
0: 		implementation.
0: 
0: 		@param implementation the module name of the missing implementation.
0: 
0: 		@return The exception.
0: 	*/
0: 	public static StandardException missingImplementation(String implementation) 
0: 	{
0: 		return StandardException.newException(SQLState.SERVICE_MISSING_IMPLEMENTATION, implementation);
0: 	}
0: 
0: 	/**
0: 		return a StandardException to indicate that an exception caused
0: 		starting the module to fail.
0: 
0: 		@param t the exception which caused starting the module to fail.
0: 
0: 		@return The exception.
0: 	*/
0: 	public static StandardException exceptionStartingModule(Throwable t)
0: 	{
0: 		return StandardException.newException(SQLState.SERVICE_STARTUP_EXCEPTION, t);
0: 	}
0: 
0: 	public static void logMessage(String messageText) {
0: 		getStream().println(messageText);
0: 	}
0: 
0: 	public static void logTextMessage(String messageID) {
0: 		getStream().println(MessageService.getTextMessage(messageID));
0: 	}
0: 	public static void logTextMessage(String messageID, Object a1) {
0: 		getStream().println(MessageService.getTextMessage(messageID, a1));
0: 	}
0: 	public static void logTextMessage(String messageID, Object a1, Object a2) {
0: 		getStream().println(MessageService.getTextMessage(messageID, a1, a2));
0: 	}
0: 	public static void logTextMessage(String messageID, Object a1, Object a2, Object a3) {
0: 		getStream().println(MessageService.getTextMessage(messageID, a1, a2, a3));
0: 	}
0: 	public static void logTextMessage(String messageID, Object a1, Object a2, Object a3, Object a4) {
0: 		getStream().println(MessageService.getTextMessage(messageID, a1, a2, a3, a4));
0: 	}
0: 
0: 	/**
0: 	 *  Translate a localeDescription of the form ll[_CC[_variant]] to
0: 	 *  a Locale object.
0: 	 */
0: 	public static Locale getLocaleFromString(String localeDescription)
0: 								throws StandardException {
0: 		return monitor.getLocaleFromString(localeDescription);
0: 	}
0: 
0: 
0: 	/**
0: 		Single point for checking if an upgrade is allowed.
0: 	 */
0: 	public static boolean isFullUpgrade(Properties startParams, String oldVersionInfo) throws StandardException {
0: 
0: 		boolean fullUpgrade = Boolean.valueOf(startParams.getProperty(org.apache.derby.iapi.reference.Attribute.UPGRADE_ATTR)).booleanValue();
0: 
0: 		if (true || !fullUpgrade) {
0: 
0: 			ProductVersionHolder engineVersion = Monitor.getMonitor().getEngineVersion();
0: 
0: 			if (engineVersion.isBeta() || engineVersion.isAlpha()) {
0: 				// soft upgrade not supported for beta.
0: 				throw StandardException.newException(SQLState.NO_UPGRADE, oldVersionInfo, engineVersion.getSimpleVersionString());
0: 			}
0: 
0: 			// Gandalf release does not support any soft or hard upgrade,
0: 			// remove this exception when upgrade support is added, and
0: 			// add back in the following code which has been commented out
0: 			// as it is currently unreachable.
0: 			throw StandardException.newException(
0: 				SQLState.LANG_CANT_UPGRADE_DATABASE, oldVersionInfo, engineVersion);
0: 		}
0: 
0: 
0: 		return fullUpgrade;
0: 	}
0: 
0: 	/**
0: 	  *
0: 	  *	@param	startParams			startup parameters
0: 	  *	@param	desiredProperty		property we're interested in
0: 	  *
0: 	  *	@return	true		type is as desired.
0: 	  *			false		otherwise
0: 	  *
0: 	  */
0: 	public static boolean isDesiredType(Properties startParams, int desiredProperty )
0: 	{
0: 		boolean	retval = false;
0: 		int		engineType = EngineType.NONE;
0: 
0: 		if ( startParams != null )
0: 		{
0: 			engineType = Monitor.getEngineType( startParams );
0: 		}
0: 
0: 		return (engineType & desiredProperty) != 0;
0: 	}
0: 	public static boolean isDesiredType(int engineType, int desiredProperty) {
0: 		return (engineType & desiredProperty) != 0;
0: 	}
0: 	
0: 	/**
0: 	  *	@param	startParams		startup parameters
0: 	  *
0: 	  *	@return	type of engine
0: 	  *
0: 	  */
0: 
0: 	static	public	int	getEngineType(Properties startParams)
0: 	{
0: 		if ( startParams != null )
0: 		{
0: 			String etp = startParams.getProperty(EngineType.PROPERTY);
0: 
0: 			int engineType = etp == null ? EngineType.STANDALONE_DB : Integer.parseInt(etp.trim());
0: 
0: 			return engineType;
0: 		}
0: 
0: 		return EngineType.STANDALONE_DB;
0: 	}
0: 
0: 	/**
0: 	  Return true if the properties set provided contains
0: 	  database creation attributes for a database
0: 	  of the correct type
0: 	  */
0: 	public static boolean isDesiredCreateType(Properties p, int type)
0: 	{
0: 		boolean plainCreate = Boolean.valueOf(p.getProperty(Attribute.CREATE_ATTR)).booleanValue();
0: 
0: 		if (plainCreate) {
0: 			return (type & EngineType.NONE) != 0;
0: 		}
0: 
0: 		// database must already exist
0: 		return isDesiredType(p, type);
0: 	}
0: }
============================================================================