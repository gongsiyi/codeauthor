1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.conn.LanguageConnectionContext
1:7ecc1f2: 
1:75588ca:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75588ca:    contributor license agreements.  See the NOTICE file distributed with
1:75588ca:    this work for additional information regarding copyright ownership.
1:75588ca:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75588ca:    (the "License"); you may not use this file except in compliance with
1:75588ca:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
42:eac0369: 
25:eac0369:  */
1:3a6f4cf: 
1:eac0369: package org.apache.derby.iapi.sql.conn;
1:ee59de8: 
1:0c5bc3a: import java.util.HashMap;
1:0c5bc3a: import java.util.Map;
1:0c5bc3a: import org.apache.derby.catalog.UUID;
1:0c5bc3a: import org.apache.derby.iapi.db.Database;
1:0c5bc3a: import org.apache.derby.iapi.db.TriggerExecutionContext;
1:0c5bc3a: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.context.Context;
1:f29303b: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: import org.apache.derby.iapi.sql.LanguageFactory;
1:eac0369: import org.apache.derby.iapi.sql.ParameterValueSet;
1:0c5bc3a: import org.apache.derby.iapi.sql.PreparedStatement;
1:3ff5ce3: import org.apache.derby.iapi.sql.compile.ASTVisitor;
1:0c5bc3a: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:049f993: import org.apache.derby.iapi.sql.compile.OptTrace;
1:0c5bc3a: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1:0c5bc3a: import org.apache.derby.iapi.sql.depend.Provider;
1:f6d02c9: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
1:0c5bc3a: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:0c5bc3a: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:0c5bc3a: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:0c5bc3a: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:0c5bc3a: import org.apache.derby.iapi.sql.execute.CursorActivation;
1:0c5bc3a: import org.apache.derby.iapi.sql.execute.ExecutionStmtValidator;
1:eac0369: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1:0c5bc3a: import org.apache.derby.iapi.store.access.TransactionController;
1:0c5bc3a: import org.apache.derby.iapi.types.DataValueFactory;
1:af1c18c: import org.apache.derby.impl.sql.execute.DeferredConstraintsMemory;
1:48a9884: 
1:ee59de8: /**
1:eac0369:  * LanguageConnectionContext keeps the result sets,
1:eac0369:  * and activations in use by the current connection.
1:eac0369:  * <p>
1:eac0369:  * More stable items, like other factories, are accessible through
1:eac0369:  * the LanguageConnectionFactory or the LanguageFactory.
1:0c5bc3a:  *
1:eac0369:  * @see LanguageConnectionFactory
1:eac0369:  * @see org.apache.derby.iapi.sql.LanguageFactory
1:e3883f5:  */
1:eac0369: public interface LanguageConnectionContext extends Context {
1:e3883f5: 
1:99d7d8b: 	/**
1:eac0369: 	 * this is the ID we expect these contexts
1:eac0369: 	 * to be stored into a context manager under.
1:99d7d8b: 	 */
1:eac0369: 	public static final String CONTEXT_ID = org.apache.derby.iapi.reference.ContextId.LANG_CONNECTION;
1:99d7d8b: 
1:eac0369: 	public	static	final	int	OUTERMOST_STATEMENT = 1;
1:99d7d8b: 
1:eac0369:     // Constants describing how this connection handles schemas
1:eac0369:     public static final int SQL92_SCHEMAS = 0;
1:eac0369:     public static final int USER_NAME_SCHEMA = 1; // User names are schema names.
1:eac0369:     public static final int NO_SCHEMAS = 2; // Schemas not implemented.
1:99d7d8b: 
1:eac0369: 	/* String for logStatementText output */
1:eac0369: 	public static final String xidStr = "(XID = ";
1:eac0369: 	public static final String lccStr = "(SESSIONID = ";
1:eac0369: 	public static final String dbnameStr = "(DATABASE = ";
1:eac0369: 	public static final String drdaStr = "(DRDAID = ";
1:ee59de8: 
1:eac0369: 	// Lock Management
1:ee59de8: 
1:eac0369: 	public	static	final	int	SINGLE_TRANSACTION_LOCK = 1;
1:eac0369: 	public	static	final	int	MULTI_TRANSACTION_LOCK = 2;
1:48a9884: 
1:eac0369: 	// controls casing of NON-delimited identifiers. ANSI casing forces all
1:eac0369: 	// non-delimited identifiers to be lower case.
1:48a9884: 
1:eac0369: 	public	static	final	int	UNKNOWN_CASING = -1;
1:eac0369: 	public	static	final	int	ANSI_CASING = 0;
1:eac0369: 	public	static	final	int	ANTI_ANSI_CASING = 1;
1:eac0369: 
1:99d7d8b: 	/**
1:eac0369: 	 * Initialize. For use after pushing the contexts that initialization needs.
1:6950a39: 	 *
1:6950a39: 	 *
4:eac0369: 	 * @exception StandardException thrown if something goes wrong
1:99d7d8b: 	 */
1:9ac3a76: 	void initialize() throws StandardException;
1:eac0369: 
1:99d7d8b: 	/**
1:eac0369: 	 * Get value of logStatementText.
1:eac0369: 	 * (Whether or not to write info on currently
1:eac0369: 	 * executing statement to error log.)
1:ee59de8: 	 *
1:eac0369: 	 * @return value of logStatementText
1:ee59de8: 	 */
1:eac0369: 	public boolean getLogStatementText();
1:eac0369: 
1:ee59de8: 	/**
1:eac0369: 	 * Set value of logStatementText
1:eac0369: 	 * (Whether or not to write info on currently
1:eac0369: 	 * executing statement to error log.)
1:48a9884: 	 *
1:eac0369: 	 * @param logStatementText	Whether or not logStatementText property is set.
1:48a9884: 	 */
1:eac0369: 	public void setLogStatementText(boolean logStatementText);
1:eac0369: 
1:48a9884: 	/**
1:eac0369: 	 * Get value of logQueryPlan.
1:eac0369: 	 * (Whether or not to write query plan info on currently
1:eac0369: 	 * executing statement to error log.)
33:eac0369: 	 *
1:eac0369: 	 * @return value of logQueryPlan
1:48a9884: 	 */
1:eac0369: 	public boolean getLogQueryPlan();
1:eac0369: 
25:eac0369: 	/**
1:eac0369: 	 * get the lock escalation threshold to use with this connection.
1:48a9884: 	 */
1:eac0369: 	int getLockEscalationThreshold();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Add the activation to those known about by this connection.
1:eac0369: 	 *
1:eac0369: 	 */
1:68c8e7d: 	void addActivation(Activation a)
1:9f60172: 		throws StandardException;
1:4cc0287: 
1:4cc0287: 	/**
1:68c8e7d: 	 * Make a note that some activations are marked unused
1:68c8e7d: 	 */
1:68c8e7d: 	void notifyUnusedActivation();
1:68c8e7d: 
1:68c8e7d: 	/**
1:eac0369: 	 * Remove the activation from those known about by this connection.
1:af1c18c: 	 *
1:eac0369: 	 * @exception StandardException thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void removeActivation(Activation a)
1:9f60172: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the number of activation known for this connection.
1:6950a39: 	 *
1:eac0369: 	 */
1:eac0369: 	int getActivationCount();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * See if a given cursor is available for use.  This is used
1:eac0369: 	 * to locate the cursor during its execution.
1:eac0369: 	 *
1:eac0369: 	 * @return the activation for the given cursor, null if none exists.
1:eac0369: 	 */
1:eac0369: 	CursorActivation lookupCursorActivation(String cursorName);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the last activation added
1:eac0369: 	 * This is used to find the drop activation in dropViewCascade
1:eac0369: 	 * so we can add warning messages to the activation
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public Activation getLastActivation();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a connection unique system generated name for a cursor.
1:eac0369: 	*/
1:eac0369: 	public String getUniqueCursorName();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a connection unique system generated name for an unnamed savepoint.
1:eac0369: 	*/
1:eac0369: 	public String getUniqueSavepointName();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a connection unique system generated id for an unnamed savepoint.
1:eac0369: 	*/
1:eac0369: 	public int getUniqueSavepointID();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Check if there are any global temporary tables declared for this connection.
1:eac0369: 	 * @return true if there are declared temp tables for this connectoin else false
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public boolean checkIfAnyDeclaredGlobalTempTablesForThisConnection();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Mark the passed temporary table as modified in the current unit of work. That information will be used at rollback time
1:eac0369: 	 * The compile phase will generate code to call this method if the DML is on a temporary table
1:eac0369: 	 *
1:3fcea8a: 	 * @param tableName Mark the passed temporary table name as modified
1:eac0369: 	 */
1:eac0369: 	public void markTempTableAsModifiedInUnitOfWork(String tableName);
1:eac0369:   
1:eac0369: 	/**
1:eac0369: 	 * Add the declared global temporary table to the list of temporary tables known by this connection.
1:3fcea8a: 	 * @param td Corresponding to the temporary table
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void addDeclaredGlobalTempTable(TableDescriptor td) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Drop (mark the declared global temporary table for dropping) from the list of temporary tables known by this connection.
1:3fcea8a: 	 * @param tableName look for this table name in the saved list and drop it if found
1:eac0369: 	 * @return true if dropped the temporary table. False if no such temporary table exists.
1:eac0369: 	 *
1:eac0369: 	 * @see org.apache.derby.impl.sql.conn.TempTableInfo
1:eac0369: 	 */
1:eac0369: 	public boolean dropDeclaredGlobalTempTable(String tableName);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get table descriptor for the declared global temporary table from the list of temporary
1:eac0369: 	 * tables known by this connection.
1:3fcea8a: 	 * @param tableName Get table descriptor for the passed table name
1:eac0369: 	 * @return TableDescriptor if found the temporary table. Else return null
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public TableDescriptor getTableDescriptorForDeclaredGlobalTempTable(String tableName);
1:eac0369: 
1:eac0369: 	/**
1:588f766: 		Reset the connection before it is returned (indirectly) by
1:588f766: 		a PooledConnection object. See EmbeddedConnection.
1:eac0369: 	 */
1:588f766: 	public void resetFromPool()
1:68c8e7d: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:3fd26f3: 		Do a commit, as internally needed by Derby.  E.g.
1:eac0369: 	 	a commit for sync, or a commit for autocommit.  Skips
1:eac0369: 		checks that a user isn't doing something bad like issuing
1:eac0369: 		a commit in a nested xact.
1:eac0369: 
1:eac0369: 		@param	commitStore	true if we should commit the Store transaction
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void internalCommit( boolean commitStore )
2:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Similar to internalCommit() but has logic for an unsynchronized commit
1:eac0369: 
1:eac0369: 		@param	commitflag	the flags to pass to commitNoSync in the store's
1:eac0369: 							TransactionController
1:eac0369: 
1:eac0369: 		@exception StandardException	thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void internalCommitNoSync(int commitflag) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Do a commit, as issued directly by a user (e.g. via Connection.commit()
1:eac0369: 		or the JSQL 'COMMIT' statement.
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void userCommit() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Commit a distrubuted transaction.
1:eac0369: 
1:eac0369: 		@param onePhase if true, allow it to commit without first going thru a
1:eac0369: 		prepared state.
1:eac0369: 
1:eac0369: 		@exception StandardException	thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void xaCommit(boolean onePhase) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:3fd26f3: 		Do a rollback, as internally needed by Derby.  E.g.
1:eac0369: 	 	a rollback for sync, or a rollback for an internal error.  Skips
1:eac0369: 		checks that a user isn't doing something bad like issuing
1:eac0369: 		a rollback in a nested xact.
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void internalRollback() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Do a rollback, as issued directly by a user (e.g. via Connection.rollback()
1:eac0369: 		or the JSQL 'ROLLBACK' statement.
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void userRollback() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Let the context deal with a rollback to savepoint
1:eac0369: 	 *
1:eac0369: 	 * @param	savepointName	Name of the savepoint that needs to be rolled back
1:eac0369: 	 * @param	refreshStyle	boolean indicating whether or not the controller should close
1:eac0369: 	 * open conglomerates and scans. Also used to determine if language should close
1:eac0369: 	 * open activations.
1:eac0369: 	 * @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1:eac0369: 	 * Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1:eac0369: 	 *   A String value for kindOfSavepoint would mean it is SQL savepoint
1:eac0369: 	 *   A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void internalRollbackToSavepoint
1:eac0369: 	( String savepointName, boolean refreshStyle, Object kindOfSavepoint ) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Let the context deal with a release of a savepoint
1:eac0369: 	 *
1:eac0369: 	 * @param	savepointName	Name of the savepoint that needs to be released
1:eac0369: 	 * @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1:eac0369: 	 * Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1:eac0369: 	 *   A String value for kindOfSavepoint would mean it is SQL savepoint
1:eac0369: 	 *   A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void releaseSavePoint ( String savepointName, Object kindOfSavepoint ) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Roll back a distrubuted transaction.
1:eac0369: 
1:eac0369: 		@exception StandardException	thrown if something goes wrong
1:eac0369: 	 */
1:eac0369: 	void xaRollback() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Sets a savepoint. Causes the Store to set a savepoint.
1:eac0369: 
1:eac0369: 	  @param	savepointName	name of savepoint
1:eac0369: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1:eac0369: 	  Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1:eac0369: 	  A String value for kindOfSavepoint would mean it is SQL savepoint
1:eac0369: 	  A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1:eac0369: 
1:eac0369: 		@exception StandardException thrown if something goes wrong
1:eac0369: 	  */
1:eac0369: 	void	languageSetSavePoint( String savepointName, Object kindOfSavepoint )  throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Begin a nested transaction.
1:eac0369: 	 *
1:eac0369: 	 * @param readOnly The nested transaction would be read only if param value true
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error.
1:eac0369: 	 * @see TransactionController#startNestedUserTransaction
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	void beginNestedTransaction(boolean readOnly) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * commit a nested transaction.
1:eac0369: 	 * We do not provide a abortNestedTransaction. 
1:eac0369: 	 * If a nested xaction is aborted, then this results in the parent xaction
1:eac0369: 	 * also being aborted. This is not what we need for releasing
1:eac0369: 	 * compile time locks or autoincrement-- hence we do not provide 
1:eac0369: 	 * abortNestedTransaction. 
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on erro
1:eac0369: 	 *
1:eac0369: 	 * @see TransactionController#startNestedUserTransaction
1:eac0369: 	 */
1:eac0369: 	void commitNestedTransaction() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the transaction controller to use with this language connection
1:eac0369: 		context at compile time.
1:eac0369: 	 */
1:eac0369: 	TransactionController getTransactionCompile();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the transaction controller to use with this language connection
1:eac0369: 		context during execute time.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	TransactionController getTransactionExecute();
1:d3ebb3c:    
1:eac0369: 	/**
1:eac0369: 		Get the data dictionary 
1:eac0369: 
1:eac0369: 		@return the data dictionary
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	public DataDictionary getDataDictionary();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the data value factory to use with this language connection
2:eac0369: 		context.
1:eac0369: 	 */
1:eac0369: 	DataValueFactory getDataValueFactory();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the language factory to use with this language connection
1:eac0369: 		context.
1:eac0369: 	 */
1:eac0369: 	LanguageFactory getLanguageFactory();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * get the optimizer factory to use with this language connection context.
1:eac0369: 	 */
1:eac0369: 	OptimizerFactory getOptimizerFactory();
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 		Get the language connection factory to use with this language connection
1:eac0369: 		context.
1:eac0369: 	 */
1:eac0369: 	LanguageConnectionFactory getLanguageConnectionFactory();
1:eac0369: 
1:9f60172:     /**
1:9f60172:      * Get the Authorization Id of the current user
1:9f60172:      *
1:9f60172:      * @param a activation
1:9f60172:      * @return String the authorization id
1:9f60172:      */
1:9f60172:     public String getCurrentUserId(Activation a);
1:9f60172: 
1:9f60172:     /**
1:9f60172:      *  Get the Authorization Id of the session user
1:9f60172:      *
1:9f60172:      * @return String   the authorization id
1:9f60172:      */
1:9f60172:     public String getSessionUserId();
1:9f60172: 
1:eac0369: 
1:eac0369: 	/**
1:6950a39: 	 * Get the default schema (used at compile-time when no activation
1:6950a39: 	 * is yet available, cf. the activation argument overload version.
1:eac0369: 	 *
1:6950a39: 	 * @return SchemaDescriptor	the default schema
1:eac0369: 	 */
1:eac0369: 	public SchemaDescriptor getDefaultSchema(); 
1:eac0369: 
1:eac0369: 	/**
1:6950a39: 	 * Get the default schema (used at execution time).  At execution
1:6950a39: 	 * time, the current statement context is not always a reliable
1:6950a39: 	 * place to find the correct SQL session context, viz. when a
1:6950a39: 	 * dynamic result set referencing CURRENT SCHEMA is accessed after
1:6950a39: 	 * a called procedure has returned only the activation of the call
1:6950a39: 	 * is live and still holds the correct session context.
1:6950a39: 	 * @param a current activation
1:eac0369: 	 *
1:6950a39: 	 * @return SchemaDescriptor	the default schema
1:6950a39: 	 */
1:6950a39: 	public SchemaDescriptor getDefaultSchema(Activation a);
1:6950a39: 
1:6950a39: 	/**
1:6950a39: 	 * Set the default schema (at compile-time, see explanations for
1:6950a39: 	 * getDefaultSchema overloads).
1:6950a39: 	 *
1:6950a39: 	 * @param sd the new default schema.
1:6950a39: 	 * If null, then the default schema descriptor is used.
1:eac0369: 	 *
4:eac0369: 	 * @exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public void setDefaultSchema(SchemaDescriptor sd)
1:6950a39: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:6950a39: 	 * Set the default schema (at execution time, see explanations for
1:6950a39: 	 * getDefaultSchema overloads); This version is used by SET SCHEMA.
1:6950a39: 	 *
1:6950a39: 	 * @param a current activation
1:6950a39: 	 * @param sd the new default schema.
1:6950a39: 	 * If null, then the default schema descriptor is used.
1:eac0369: 	 *
1:6950a39: 	 * @exception StandardException thrown on failure
1:6950a39: 	 */
1:6950a39: 	public void setDefaultSchema(Activation a, SchemaDescriptor sd)
1:6950a39: 		throws StandardException;
1:6950a39: 
1:6950a39: 	/**
1:6950a39: 	 * Reset any occurence of schemaName as current default schema in
1:e3883f5: 	 * the SQLSessionContext stack to the initial default,
1:6950a39: 	 * because schemaName is no longer a valid schema.
1:6950a39: 	 *
1:6950a39: 	 * @param activation current activation
1:6950a39: 	 * @param schemaName the schema name occurences of which is to be reset
1:6950a39: 	 *
1:4cc0287: 	 * @throws StandardException
1:0c5bc3a: 	 */
1:6950a39: 	public void resetSchemaUsages(Activation activation, String schemaName)
1:0c5bc3a: 		throws StandardException;
1:af1c18c: 
1:af1c18c: 	/**
1:6950a39: 	 *	Get the current schema name (at compile-time, see explanations for
1:6950a39: 	 * getDefaultSchema overloads).
1:eac0369: 	 *
2:eac0369: 	 * @return SchemaDescriptor	the current schema
1:6950a39: 	 */
1:eac0369: 	public String getCurrentSchemaName();
1:6950a39: 
1:6950a39: 	/**
1:6950a39: 	 * Get the current schema name (at execution time, see explanations for
1:6950a39: 	 * getDefaultSchema overloads); This version is used by CURRENT SCHEMA.
1:6950a39: 	 *
1:6950a39: 	 * @return SchemaDescriptor	the current schema
1:6950a39: 	 */
1:6950a39: 	public String getCurrentSchemaName(Activation a);
1:9e04f69: 
1:6950a39: 
1:9e04f69: 	/**
1:9e04f69: 	 * Return true if this schema name is the initial default schema for the
1:9e04f69: 	 * current session.
1:ddae94a: 	 * @param schemaName
1:9e04f69: 	 * @return true
1:9e04f69: 	 */
1:9e04f69: 	public boolean isInitialDefaultSchema(String schemaName);
1:9e04f69: 
1:6950a39: 	/**
1:eac0369: 	 * Get the identity column value most recently generated.
1:eac0369: 	 *
1:eac0369: 	 * @return the generated identity column value
1:eac0369: 	 */
1:cf58aec: 	public Long getIdentityValue();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the field of most recently generated identity column value.
1:eac0369: 	 *
1:3fcea8a: 	 * @param val the generated identity column value
1:eac0369: 	 */
1:eac0369: 	public void setIdentityValue(long val);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Verify that there are no activations with open result sets
1:eac0369: 	 * on the specified prepared statement.
1:eac0369: 	 *
1:eac0369: 	 * @param pStmt		The prepared Statement
1:eac0369: 	 * @param provider	The object precipitating a possible invalidation
1:eac0369: 	 * @param action	The action causing the possible invalidation
1:eac0369: 	 *
5:eac0369: 	 * @return Nothing.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	boolean verifyNoOpenResultSets(PreparedStatement pStmt, Provider provider, 
1:eac0369: 									   int action)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Verify that there are no activations with open held result sets.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean  Found no open resultsets.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure
1:eac0369: 	 */
1:eac0369: 	public boolean verifyAllHeldResultSetsAreClosed()
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Push a CompilerContext on the context stack with
1:eac0369: 	 * the current default schema as the default schema
1:eac0369: 	 * which we compile against.
1:eac0369: 	 *
1:eac0369: 	 * @return the compiler context
1:eac0369: 	 */
1:eac0369: 	public	CompilerContext pushCompilerContext();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Push a CompilerContext on the context stack with
1:eac0369: 	 * the passed in default schema as the default schema
1:eac0369: 	 * we compile against.
1:eac0369: 	 *
1:eac0369: 	 * @param sd the default schema 
1:eac0369: 	 *
1:eac0369: 	 * @return the compiler context
1:eac0369: 	 */
1:eac0369: 	public	CompilerContext pushCompilerContext(SchemaDescriptor sd);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Pop a CompilerContext off the context stack.
1:eac0369: 	 *
1:eac0369: 	 * @param compilerContext  The compiler context.
1:eac0369: 	 */
1:eac0369: 	public void popCompilerContext(CompilerContext compilerContext);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Push a StatementContext on the context stack.
1:eac0369: 	 *
1:eac0369: 	 * @param isAtomic whether a commit/rollback is permitted
1:eac0369: 	 *	from a nested connection under this statement
1:eac0369: 	 *
1:eac0369: 	 * @param stmtText the text of the statement.  Needed for any language
1:eac0369: 	 * 	statement (currently, for any statement that can cause a trigger
1:eac0369: 	 * 	to fire).  Please set this unless you are some funky jdbc setXXX
1:eac0369: 	 *	method or something.
1:eac0369: 	 *
1:eac0369: 	 * @param pvs parameter value set, if it has one
1:eac0369: 	 *
1:eac0369: 	 * @param rollbackParentContext True if 1) the statement context is
1:eac0369: 	 * 	NOT a top-level context, AND 2) in the event of a statement-level
1:eac0369: 	 *	exception, the parent context needs to be rolled back, too.
1:3fcea8a:      *
1:3fcea8a:      * @param timeoutMillis Timeout value for this statement, in milliseconds.
1:3fcea8a:      *  Zero means no timeout.
1:eac0369: 	 *
1:6950a39: 	 * @return StatementContext The statement context.
1:eac0369: 	 *
1:eac0369: 	 */
1:5087be8: 	StatementContext pushStatementContext(boolean isAtomic, boolean isForReadOnly, String stmtText,
1:3fcea8a: 		ParameterValueSet pvs, boolean rollbackParentContext, long timeoutMillis);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Pop a StatementContext of the context stack.
1:eac0369: 	 *
1:eac0369: 	 * @param statementContext  The statement context.
1:eac0369: 	 * @param error				The error, if any  (Only relevant for DEBUG)
1:eac0369: 	 */
1:eac0369: 	public void popStatementContext(StatementContext statementContext,
1:eac0369: 									Throwable error);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Push a new execution statement validator.  An execution statement 
1:eac0369: 	 * validator is an object that validates the current statement to
1:eac0369: 	 * ensure that it is permitted given the current execution context.
1:eac0369: 	 * An example of a validator a trigger ExecutionStmtValidator that
1:eac0369: 	 * doesn't allow ddl on the trigger target table.
1:eac0369: 	 * <p>
1:eac0369: 	 * Multiple ExecutionStmtValidators may be active at any given time.
1:eac0369: 	 * This mirrors the way there can be multiple connection nestings
1:eac0369: 	 * at a single time.  The validation is performed by calling each
1:eac0369: 	 * validator's validateStatement() method.  This yields the union
1:eac0369: 	 * of all validations.
1:eac0369: 	 *
1:eac0369: 	 * @param validator the validator to add
1:eac0369: 	 */
1:eac0369: 	public void pushExecutionStmtValidator(ExecutionStmtValidator validator);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remove the validator.  Does an object identity (validator == validator)
1:eac0369:  	 * comparison.  Asserts that the validator is found.
1:eac0369: 	 *
1:eac0369: 	 * @param validator the validator to remove
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void popExecutionStmtValidator(ExecutionStmtValidator validator)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Validate a statement.  Does so by stepping through all the validators
1:eac0369: 	 * and executing them.  If a validator throws and exception, then the
1:eac0369: 	 * checking is stopped and the exception is passed up.
1:eac0369: 	 *
1:eac0369: 	 * @param constantAction the constantAction that is about to be executed (and
1:eac0369: 	 *	should be validated
1:eac0369:  	 *
1:eac0369: 	 * @exception StandardException on validation failure
1:eac0369: 	 */
1:eac0369: 	public void validateStmtExecution(ConstantAction constantAction)
1:eac0369: 		throws StandardException;
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Push a new trigger execution context.
1:eac0369: 	 * <p>
1:eac0369: 	 * Multiple TriggerExecutionContexts may be active at any given time.
1:eac0369: 	 *
1:eac0369: 	 * @param tec the trigger execution context
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on trigger recursion error
1:eac0369: 	 */
1:eac0369: 	public void pushTriggerExecutionContext(TriggerExecutionContext tec)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remove the tec.  Does an object identity (tec == tec)
1:eac0369:  	 * comparison.  Asserts that the tec is found.
1:eac0369: 	 *
1:eac0369: 	 * @param tec the tec to remove
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:eac0369: 	public void popTriggerExecutionContext(TriggerExecutionContext tec)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the topmost tec.  
1:eac0369: 	 *
1:eac0369: 	 * @return the tec
1:eac0369: 	 */
1:eac0369: 	public TriggerExecutionContext getTriggerExecutionContext();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the trigger table descriptor.  Used to compile
1:eac0369: 	 * statements that may special trigger pseudo tables.
1:eac0369: 	 *
1:eac0369: 	 * @param td the table that the trigger is 
1:eac0369: 	 * defined upon
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void pushTriggerTable(TableDescriptor td);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remove the trigger table descriptor.
1:eac0369: 	 *
1:eac0369: 	 * @param td the table to remove from the stack.
1:eac0369: 	 */
1:eac0369: 	public void popTriggerTable(TableDescriptor td);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the topmost trigger table descriptor
1:eac0369: 	 *
1:eac0369: 	 * @return the table descriptor, or null if we
1:eac0369: 	 * aren't in the middle of compiling a create
1:eac0369: 	 * trigger.
1:eac0369: 	 */
1:eac0369: 	public TableDescriptor getTriggerTable();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Increment the DataDictionary bind count.  This is for keeping track
1:eac0369: 	 * of nested binding, which can happen if SQL statements are bound from
1:eac0369: 	 * within static initializers.
1:eac0369: 	 *
1:eac0369: 	 * @return	The new bind count
1:eac0369: 	 */
1:eac0369: 	int incrementBindCount();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Decrement the DataDictionary bind count.
1:eac0369: 	 *
1:eac0369: 	 * @return	The new bind count
1:eac0369: 	 */
1:eac0369: 	int decrementBindCount();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the DataDictionary bind count.
1:eac0369: 	 *
1:eac0369: 	 * @return	The current bind count.
1:eac0369: 	 */
1:eac0369: 	int getBindCount();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remember that the DataDictionary is in write mode, so we can take
1:eac0369: 	 * it out of write mode at the end of the transaction.
1:eac0369: 	 */
1:eac0369: 	void setDataDictionaryWriteMode();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return true if the data dictionary is in write mode (that is, this
1:eac0369: 	 * context was informed that is is in write mode by the method call
1:eac0369: 	 * setDataDictionaryWriteMode().
1:eac0369: 	 */
1:eac0369: 	boolean dataDictionaryInWriteMode();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Turn RUNTIMESTATISTICS  on or off.
1:eac0369: 	 */
1:eac0369: 	public void setRunTimeStatisticsMode(boolean onOrOff);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the RUNTIMESTATISTICS mode.
1:eac0369: 	 */
1:eac0369: 	public boolean getRunTimeStatisticsMode();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Turn STATISTICS TIMING on or off.
1:eac0369: 	 */
1:eac0369: 	public void setStatisticsTiming(boolean onOrOff);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the STATISTICS TIMING mode.
1:eac0369: 	 */
1:eac0369: 	public boolean getStatisticsTiming();
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Set the RUNTIMESTATISTICS object. 
1:eac0369: 	 */
1:eac0369: 	public void setRunTimeStatisticsObject(RunTimeStatistics runTimeStatisticsObject);
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Get the RUNTIMESTATISTICS object. 
1:eac0369: 	 */
1:eac0369: 	public RunTimeStatistics getRunTimeStatisticsObject();
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	  *	Reports how many statement levels deep we are.
1:eac0369: 	  *
1:dbed020: 	  *	@return	a statement level &gt;= OUTERMOST_STATEMENT
1:eac0369: 	  */
1:eac0369: 	public	int		getStatementDepth();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Returns the Database of this connection.
1:eac0369:      */
1:eac0369:     public Database getDatabase();
1:eac0369: 
1:eac0369: 	/**
1:08cd3aa: 	 * Returns true if isolation level has been set using JDBC/SQL.
1:08cd3aa: 	 */
1:08cd3aa: 	public boolean isIsolationLevelSetUsingSQLorJDBC();
1:08cd3aa: 	/**
1:08cd3aa: 	 * Reset the isolation level flag used to keep correct isolation level
1:08cd3aa: 	 * state in BrokeredConnection. This resetting will happen at the start 
1:08cd3aa: 	 * and end of a global transaction, after the BrokeredConection's 
1:08cd3aa: 	 * isolation level state is brought upto date with the EmbedConnection's
1:08cd3aa: 	 * isolation state.
1:08cd3aa: 	 * The flag gets set to true when isolation level is set using JDBC/SQL.
1:08cd3aa: 	 */
1:08cd3aa: 	public void resetIsolationLevelFlagUsedForSQLandJDBC();
1:08cd3aa: 
1:08cd3aa: 	/**
1:eac0369: 	 * Set current isolation level.
1:08cd3aa: 	 *
1:eac0369: 	 * @param isolationLevel	The new isolationLevel.
1:eac0369: 	 */
1:eac0369: 	public void setIsolationLevel(int isolationLevel) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current isolation level.
1:eac0369: 	 *
1:eac0369: 	 * @return The current isolation level.
1:eac0369: 	 */
1:eac0369: 	public int getCurrentIsolationLevel();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the current isolation level in DB2 format.
1:eac0369: 	 *
1:eac0369: 	 * @return The current isolation level as a 2 character string.
1:eac0369: 	 */
1:eac0369: 	public String getCurrentIsolationLevelStr();
1:eac0369: 	public void setPrepareIsolationLevel(int isolationLevel) ;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the prepare isolation level.
1:eac0369: 	 * If the isolation level has been explicitly set with a SQL statement or
1:eac0369: 	 * embedded call to setTransactionIsolation, this will return
1:38f02ec: 	 * TransactionControl.UNSPECIFIED_ISOLATION_LEVEL 
1:eac0369: 	 * SET ISOLATION always takes priority.
1:eac0369: 	 * 
1:eac0369: 	 */
1:eac0369: 	public int getPrepareIsolationLevel();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the readOnly status for the current connection. This can
1:eac0369: 	 * only be called when the current transaction has not done
1:eac0369: 	 * any work.
1:eac0369: 	 *
1:eac0369: 	 * @param onOrOff true sets the connection to be readOnly and
1:eac0369: 	 *                false sets it to readWrite.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException The call failed and the readOnly
1:eac0369: 	 *                status has not changed.
1:eac0369: 	 */
1:eac0369: 	public void setReadOnly(boolean onOrOff) throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  * Get the readOnly status for the current connection. 
1:eac0369: 	  */
1:eac0369: 	public boolean isReadOnly();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get an Authorizer for this connection.
1:eac0369: 	 */
1:eac0369: 	public Authorizer getAuthorizer(); 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 *	Get the current StatementContext.
1:eac0369: 	 */
1:eac0369: 	StatementContext getStatementContext();
1:eac0369: 
1:eac0369:     /**
1:5087be8: 	 * Return a PreparedStatement object for the query.
1:5087be8: 	 * This method first tries to locate the PreparedStatement object from a statement
1:5087be8: 	 * cache.  If the statement is not found in the cache, the query will be compiled and
1:5087be8: 	 * put into the cache.
1:5087be8: 	 * @param compilationSchema schema
1:5087be8: 	 * @param sqlText sql query string
1:5087be8: 	 * @param isForReadOnly read only status for resultset. Set to true if the concurrency mode for the resultset 
1:5087be8: 	 *                      is CONCUR_READ_ONLY
1:2dc0b91: 	 * @param allowInternalSyntax If true, then this query is allowed to use internal 
1:2dc0b91: 	 *                      sql syntax. One instance where this will be true is if a
1:2dc0b91: 	 *                      metadata query is getting executed.
1:eac0369: 	 */
1:2dc0b91:          public PreparedStatement prepareInternalStatement(SchemaDescriptor compilationSchema, 
1:2dc0b91:          		String sqlText, boolean isForReadOnly, boolean allowInternalSyntax) 
1:eac0369: 	    throws StandardException;
1:eac0369: 
1:eac0369:         /**
1:5087be8: 	 * Return a PreparedStatement object for the query.
1:5087be8: 	 * This method first tries to locate the PreparedStatement object from a statement
1:5087be8: 	 * cache.  If the statement is not found in the cache, the query will be compiled and 
1:5087be8: 	 * put into the cache.
1:5087be8: 	 * The schema used when compiling the statement is the same schema as returned by
1:5087be8: 	 * getDefaultSchema().  For internal statements, the read only status is set to
1:5087be8: 	 * true.
1:5087be8: 	 * Calling this method is equivalent to calling 
1:5087be8: 	 * prepareExternalStatement(lcc.getDefaultSchema(), sqlText, true);
1:eac0369: 	 * 
1:5087be8: 	 * @param sqlText sql query string
1:eac0369: 	 */
1:5087be8:         public PreparedStatement prepareInternalStatement(String sqlText) 
1:eac0369: 	    throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:049f993: 	 * Install an optimizer tracer (to enable tracing) or uninstall the current optimizer tracer
1:049f993:      * (to disable tracing).
1:eac0369: 	 *
1:049f993: 	 * @param tracer    Null if tracing is being turned off, otherwise an optimizer tracer
1:eac0369: 	 */
1:049f993: 	public void setOptimizerTracer( OptTrace tracer );
1:049f993: 
1:049f993: 	/**
1:049f993: 	 * Get the optimizer tracer (could be null if we aren't tracing the optimizer).
1:049f993: 	 */
1:049f993: 	public OptTrace getOptimizerTracer();
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Get whether or not optimizer trace is on.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not optimizer trace is on.
1:eac0369: 	 */
1:049f993: 	public boolean optimizerTracingIsOn();
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	  *	Reports whether there is any outstanding work in the transaction.
1:eac0369: 	  *
1:eac0369: 	  *	@return		true if there is outstanding work in the transaction
1:eac0369: 	  *				false otherwise
1:eac0369: 	  */
1:eac0369: 	public	boolean	isTransactionPristine();
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the last autoincrement value inserted by this connection.
1:eac0369: 	 * If no values have been inserted into the given column a NULL value
1:eac0369: 	 * is returned.
1:eac0369: 	 * 
1:9e04f69: 	 * @param schemaName
1:eac0369: 	 * @param tableName
1:eac0369: 	 * @param columnName
1:eac0369: 	 */
1:eac0369: 	public Long lastAutoincrementValue(String schemaName,
1:eac0369: 									   String tableName,
1:eac0369: 									   String columnName);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets autoincrementUpdate-- this variable allows updates to autoincrement
1:eac0369: 	 * columns if it is set to true. The default is ofcourse false; i.e 
1:eac0369: 	 * ai columns cannot be directly modified by the user. This is set to 
1:eac0369: 	 * true by AlterTableConstantAction, when a new ai column is being added 
1:eac0369: 	 * to an existing table.
1:eac0369: 	 * 
1:eac0369: 	 * @param flag 	the value for autoincrementUpdate (TRUE or FALSE)
1:eac0369: 	 */
1:eac0369: 	public void setAutoincrementUpdate(boolean flag);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the current value of autoincrementUpdate.
1:eac0369: 	 *
1:eac0369: 	 * @return true if updates to autoincrement columns is permitted.
1:eac0369: 	 */
1:eac0369: 	public boolean getAutoincrementUpdate();
1:eac0369: 
1:eac0369: 	/**
1:44370a8: 	 * Copy a map of autoincrement key value pairs into the cache of
1:eac0369: 	 * ai values stored in the language connection context.
1:eac0369: 	 */
1:71c8e86: 	public void copyHashtableToAIHT(Map<String,Long> from);
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * returns the <b>next</b> value to be inserted into an autoincrement col.
1:eac0369: 	 * This is used internally by the system to generate autoincrement values
1:eac0369: 	 * which are going to be inserted into a autoincrement column. This is
1:eac0369: 	 * used when as autoincrement column is added to a table by an alter 
1:eac0369: 	 * table statemenet and during bulk insert.
1:eac0369: 	 *
2:eac0369: 	 * @param schemaName
1:eac0369: 	 * @param tableName
1:eac0369: 	 * @param columnName identify the column uniquely in the system.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error.
1:eac0369: 	 */
1:eac0369: 	public long nextAutoincrementValue(String schemaName, String tableName,
1:eac0369: 									   String columnName)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Flush the cache of autoincrement values being kept by the lcc.
1:eac0369: 	 * This will result in the autoincrement values being written to the
1:eac0369: 	 * SYSCOLUMNS table as well as the mapping used by lastAutoincrementValue
1:eac0369: 	 * 
1:eac0369: 	 * @param tableUUID the table which is being flushed; we need this value to
1:eac0369: 	 * identify the table for which the autoincrement counter is being
1:eac0369: 	 * maintained.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on error.
1:eac0369: 	 *
1:eac0369: 	 * @see LanguageConnectionContext#lastAutoincrementValue
1:eac0369: 	 * @see org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext#lastAutoincrementValue
1:eac0369: 	 */
1:eac0369: 	public void autoincrementFlushCache(UUID tableUUID)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Create an autoincrement counter to be used on behalf of a SQL-J 
1:eac0369: 	 * statement. The counter is identified by (schemaName, tableName,
1:eac0369: 	 * columnName). The counter must be freed up by calling 
1:eac0369: 	 * autoincrementFlushCache at the end of the statement. It is expected
1:eac0369: 	 * that a ai-counter with the same signaure doesn't exist when the 
1:eac0369: 	 * method is called.
1:eac0369: 	 * 
1:eac0369: 	 * @param 		s					SchemaName
1:eac0369: 	 * @param		t					TableName
1:eac0369: 	 * @param		c					ColumnName
1:eac0369: 	 * @param		initialValue		initial value of the counter.
1:eac0369: 	 * @param		increment			increment for the counter.
1:eac0369: 	 * @param		position			column position (1-based).
1:eac0369: 	 */
1:eac0369: 	public void autoincrementCreateCounter(String s, String t, String c,
1:eac0369: 										   Long initialValue, long increment,
1:eac0369: 										   int position);
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 * Get the instance number of this LCC.
1:eac0369: 	 *
1:eac0369: 	 * @return instance number of this LCC.
1:eac0369: 	 */
1:eac0369: 	public int getInstanceNumber();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the DRDA ID of this LCC.
1:eac0369: 	 *
1:eac0369: 	 * @return DRDA ID this LCC.
1:eac0369: 	 */
1:eac0369: 	public String getDrdaID();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the DRDA ID of this LCC.
1:eac0369: 	 *
1:3fcea8a: 	 * @param drdaID DRDA ID.
1:eac0369: 	 */
1:eac0369: 	public void setDrdaID(String drdaID);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the database name of this LCC.
1:eac0369: 	 *
1:eac0369: 	 * @return database name of this LCC.
1:eac0369: 	 */
1:eac0369: 	public String getDbname();
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * Check if in SQL standard mode, with support for Grant and Revoke
1:eac0369: 	 *
1:2c6ca76: 	 * @return True if SQL standard permissions are being used
1:eac0369: 	 */
1:5ec8510: 	public boolean usesSqlAuthorization();
1:77603a1: 
1:77603a1: 	/**
1:77603a1: 	 * Close any unused activations in this connection context.
1:99d7d8b: 	 */
1:77603a1: 	public void closeUnusedActivations() throws StandardException;
1:99d7d8b: 
1:99d7d8b: 	/**
1:99d7d8b: 	 * Set the current role
1:99d7d8b: 	 *
1:f04dc44: 	 * @param a activation of set role statement
1:99d7d8b: 	 * @param role  the id of the role to be set to current
1:99d7d8b: 	 */
1:99d7d8b:     public void setCurrentRole(Activation a, String role);
1:99d7d8b: 
1:99d7d8b: 	/**
1:34b59c6: 	 * Get the current role authorization identifier of the dynamic
1:99d7d8b: 	 * call context associated with this activation.
1:99d7d8b: 	 *
1:34b59c6: 	 * @param a activation of statement needing current role
1:34b59c6: 	 * @return String	the role id
1:99d7d8b: 	 */
1:99d7d8b: 	public String getCurrentRoleId(Activation a);
1:99d7d8b: 
1:6950a39: 	/**
1:44ea4f0: 	 * Get the current role authorization identifier in external delimited form
1:44ea4f0: 	 * (not case normal form) of the dynamic call context associated with this
1:44ea4f0: 	 * activation.
1:f04dc44: 	 * @param a activation of statement needing current role
1:44ea4f0: 	 * @return String the role id in delimited form (i.e. <b>not</b>
1:44ea4f0: 	 * internal case normal form</b>)
1:34b59c6: 	 *
1:34b59c6: 	 * @throws StandardException  standard exception policy
1:34b59c6: 	 */
1:44ea4f0: 	public String getCurrentRoleIdDelimited(Activation a)
1:34b59c6: 			throws StandardException;
1:34b59c6: 
1:34b59c6: 	/**
1:34b59c6: 	 * Checks whether the given role can be legally set for the current user.
1:34b59c6: 	 *
1:34b59c6: 	 * This method will read (potentially) the dictionary, so it needs
1:34b59c6: 	 * a transaction context.
1:34b59c6: 	 *
1:9f60172:      * @param a activation
1:34b59c6: 	 * @param role string containing role name
1:34b59c6: 	 *
1:34b59c6: 	 * @return true if the role can be set
1:34b59c6: 	 * @throws StandardException standard exception policy
1:34b59c6: 	 */
1:9f60172:     public boolean roleIsSettable(Activation a, String role)
1:9f60172:             throws StandardException;
1:34b59c6: 
1:34b59c6: 	/**
1:e3883f5: 	 * Create a new SQL session context for the current activation on the basis
1:e3883f5: 	 * of the existing SQL session context. This happens when a stored
1:e3883f5: 	 * procedure or function that can contain SQL is invoked, cf. SQL 2003
1:e3883f5: 	 * section 4.27.3, since this gives rise to a nested connection.
1:e3883f5: 	 * <p>
1:e3883f5: 	 * Called from generated code, see
1:0c5bc3a:      * {@link org.apache.derby.impl.sql.compile.StaticMethodCallNode#generatePushNestedSessionContext}.
1:e3883f5: 	 * <p>
1:6950a39: 	 * The new SQL session context is also set in the current statement
1:6950a39: 	 * context (of the invocation).
1:6950a39: 	 *
1:0c5bc3a:      * @see org.apache.derby.impl.sql.compile.StaticMethodCallNode#generatePushNestedSessionContext
1:6950a39: 	 * @see StatementContext#getSQLSessionContext
1:e3883f5: 	 * @see #setupSubStatementSessionContext
1:e3883f5: 	 *
1:6950a39: 	 * @param a activation of the statement which performs the call.
1:b86c38b:      * @param definersRights if the method should run with definer's rights
1:9f60172:      * @param definer authorization id of the definer
1:af1c18c:      * @throws StandardException standard error policy
1:af1c18c: 	 */
1:0c5bc3a:     public void pushNestedSessionContext(Activation a,
1:0c5bc3a:                                         boolean definersRights,
1:0c5bc3a:                                         String definer)
1:af1c18c:             throws StandardException;
1:af1c18c: 
1:af1c18c:     /**
1:0c5bc3a:      * If returning from a routine that can execute SQL, perform any
1:0c5bc3a:      * actions needed when popping the SQL session context.
1:0c5bc3a:      *
1:0c5bc3a:      * @param a activation
2:0c5bc3a:      * @throws StandardException standard error policy
1:0c5bc3a:      */
1:0c5bc3a:     public void popNestedSessionContext(Activation a) throws StandardException;
1:0c5bc3a: 
1:0c5bc3a: 	/**
1:e3883f5: 	 * Get the value of top level session context of the top level connection.
1:0c5bc3a:      * @return the requested session context
1:0c5bc3a: 	 */
1:e3883f5: 	public SQLSessionContext getTopLevelSQLSessionContext();
1:0c5bc3a: 
1:e3883f5: 	/**
1:e3883f5: 	 * Used when a statement as part of its operation executes an other
1:0c5bc3a:      * statement. In contrast to pushNestedSessionContext, the activation (for
1:e3883f5: 	 * the substatement) just inherits the current session context from the
1:e3883f5: 	 * parent statements activation, it does <b>not</b> push a new copy on the
1:e3883f5: 	 * stack of session contexts.
1:0c5bc3a: 	 *
1:e3883f5: 	 * Currently, this is used in the following situations:
1:e3883f5: 	 * <ul>
1:e3883f5: 	 *     <li>With {@code ALTER TABLE} adding a column which has a default
1:e3883f5: 	 *         values, the default value for all the existing rows is added
1:e3883f5: 	 *         using an {@code UPDATE} substatement.
1:e3883f5: 	 *     <li>With {@code ALTER TABLE} adding a a check constraint, we will use
1:e3883f5: 	 *         a substatement {@code SELECT} to check if all rows satisfy the
1:e3883f5: 	 *         constraint.
1:e3883f5: 	 *     <li>{@code ResultSet.insertRow}, {@code updateRow}
1:e3883f5: 	 *         and {@code deleteRow}.
1:e3883f5: 	 *     <li>During trigger body execution.
1:e3883f5: 	 * </ul>
1:0c5bc3a:      * @see #pushNestedSessionContext
1:e3883f5: 	 */
1:9f60172:     public void setupSubStatementSessionContext(Activation a)
1:0c5bc3a:             throws StandardException;
1:e3883f5: 
1:e3883f5: 	/**
1:e3883f5: 	 * Create a fresh SQLSessionContext for this connection.
1:6950a39: 	 * @return new SQLSessionContext
1:6950a39: 	 */
1:6950a39: 	public SQLSessionContext createSQLSessionContext();
1:a19a896: 
1:a19a896: 	/**
1:a19a896:      * Debug method for remembering the last query tree.
1:a19a896: 	 */
1:a19a896:     public  void    setLastQueryTree( Object queryTree );
1:a19a896: 
1:a19a896: 	/**
1:a19a896:      * Debug method for retrieving the last query tree.
1:a19a896: 	 */
1:a19a896:     public  Object    getLastQueryTree();
1:a19a896: 
1:c9a1206: 	/**
1:c9a1206: 	 * Return a map of AST nodes that have already been printed during a
1:c9a1206: 	 * compiler phase, so as to be able to avoid printing a node more than once.
1:c9a1206: 	 * @see org.apache.derby.impl.sql.compile.QueryTreeNode#treePrint(int)
1:c9a1206: 	 * @return the map
1:c9a1206: 	 */
1:71c8e86:     public Map<Object,Object> getPrintedObjectsMap();
1:6950a39: 	
1:6950a39:     /**
1:48a9884:      * sets the XplainOnlyMode.
1:ee59de8:      *
1:48a9884:      * If a connection is in XplainOnlyMode, then the statements are not
1:48a9884:      * actually being executed, but are just being compiled and the
1:48a9884:      * runtime statistics collected into the XPLAIN tables. This can be
1:48a9884:      * set on and off by calling SYSCS_SET_XPLAIN_MODE.
1:48a9884:      *
1:48a9884:      * @param onOrOff true if statements are to be XPLAINed only.
1:6950a39:      */
1:48a9884:     public void setXplainOnlyMode(boolean onOrOff);
1:ee59de8: 
1:48a9884:     /**
1:48a9884:      * gets the current set XplainOnlyMode
1:ee59de8:      */
1:48a9884:     public boolean getXplainOnlyMode();
1:ee59de8: 
1:48a9884:     /**
1:48a9884:      * sets the XplainSchema
1:48a9884:      * @param schema the schema to use for storing XPLAIN'd statements
1:48a9884:      * null means don't store the xplain information
1:48a9884:      * non-null means persistent style, use the indicated schema
1:77603a1:      */
1:48a9884:     public void setXplainSchema(String schema);
1:48a9884: 
1:48a9884:     /**
1:48a9884:      * gets the current set XplainSchema
1:48a9884:      * @return the Schema of Xplain, may be null.
1:48a9884:      */
1:48a9884:     public String getXplainSchema();
1:48a9884:     public void setXplainStatement(Object key, Object stmt);
1:48a9884:     public Object getXplainStatement(Object key);
1:3ff5ce3: 
1:3ff5ce3:     /**
1:3ff5ce3:      * Set a Visitor which walks the AST at various stages. This is useful
1:3ff5ce3:      * for poking user-written inspectors into the parse, bind, and optimize phases.
1:3ff5ce3:      *
1:3ff5ce3:      * @param visitor The Visitor which should walk the tree. Could be null.
1:3ff5ce3:      */
1:3ff5ce3:     public void setASTVisitor( ASTVisitor visitor );
1:3ff5ce3: 
1:3ff5ce3:     /**
1:3ff5ce3:      * Get the Visitor which should walk the AST.
1:3ff5ce3:      *
1:3ff5ce3:      * @return The Visitor for that phase. Could be null.
1:3ff5ce3:      */
1:3ff5ce3:     public ASTVisitor getASTVisitor( );
1:3ff5ce3: 
1:3a6f4cf:     /**
1:3a6f4cf:      * Set the exception created and associated with the detected interruped
1:3a6f4cf:      * status flag.
1:3a6f4cf:      *
1:3a6f4cf:      * @param e the created exception
1:3a6f4cf:      */
1:3a6f4cf:     public void setInterruptedException(StandardException e);
1:3a6f4cf: 
1:3a6f4cf:     /**
1:3a6f4cf:      * Get exception created when we detected interruped status
1:3a6f4cf:      * flag.
1:3a6f4cf:      *
1:3a6f4cf:      * @return saved exception
1:3a6f4cf:      */
1:3a6f4cf:     public StandardException getInterruptedException();
1:f29303b: 
1:f29303b:     /**
1:f29303b:      * Get the referenced column map for a table
1:f29303b:      *
1:f29303b:      * @return the map
1:f29303b:      */
1:f29303b:     public FormatableBitSet getReferencedColumnMap(TableDescriptor td);
1:f29303b: 
1:f29303b:     /**
1:f29303b:      * Set the referenced column map for a table
1:f29303b:      *
1:f29303b:      * @param td the table descriptor
1:f29303b:      * @param map the map
1:f29303b:      */
1:f29303b:     public void setReferencedColumnMap(TableDescriptor td,
1:f29303b:                                        FormatableBitSet map);
1:0c5bc3a: 
1:0c5bc3a:     /**
1:f6d02c9:      * Set the constraint mode for this constraint to {@code deferred}.
1:af1c18c:      * If {@code deferred} is {@code false}, to immediate checking,
1:af1c18c:      * if {@code true} to deferred checking.
1:af1c18c:      *
1:af1c18c:      * @param a         Activation
1:f6d02c9:      * @param cd        The descriptor of the constraint
1:af1c18c:      * @param deferred  The new constraint mode
1:af1c18c:      * @throws StandardException
1:af1c18c:      */
2:af1c18c:     public void setConstraintDeferred(Activation a,
1:f6d02c9:                                     ConstraintDescriptor cd,
2:af1c18c:                                     boolean deferred) throws StandardException;
1:4cc0287: 
1:0c5bc3a:     /**
1:4cc0287:      * Determines if a check or foreign key constraint has deferred
2:4cc0287:      * mode.
1:0c5bc3a:      *
1:4cc0287:      * @param sc           The SQL session context for which we are asking the status
1:4cc0287:      * @param constraintId The constraint id we are inquiring about.
1:4cc0287:      * @return             {@code true} if the constraint is deferred
1:4cc0287:      * @throws StandardException
1:4cc0287:      *                     Standard error policy
1:0c5bc3a:      */
1:4cc0287:     public boolean isEffectivelyDeferred(SQLSessionContext sc, UUID constraintId)
1:0c5bc3a:             throws StandardException;
1:0c5bc3a: 
1:0c5bc3a:     /**
1:4cc0287:      * Set the constraint mode of all deferrable constraints to the value of
1:4cc0287:      * {@code deferred}. If the value is {@code false}, this method might
1:4cc0287:      * throw with a constraint violation error, i.e. if some constraint
1:4cc0287:      * has deferred mode before this call and had seen violations.
1:0c5bc3a:      *
1:4cc0287:      * @param a         The activation
1:4cc0287:      * @param deferred  The value which holds the constraint mode
1:4cc0287:      * @throws          StandardException Standard error policy
1:0c5bc3a:      */
1:0c5bc3a:     public void setDeferredAll(Activation a, boolean deferred)
1:0c5bc3a:             throws StandardException;
1:0c5bc3a: 
1:0c5bc3a:     /**
1:af1c18c:      * Get the set of disk backed hash tables containing any index
1:af1c18c:      * rows saved for deferred unique/PK constraints in this
1:af1c18c:      * transaction, keyed by the conglomerate id, or rows saved
1:af1c18c:      * containing row locations violating rows for deferred check
1:af1c18c:      * constraints.
1:0c5bc3a:      * @return the set
1:0c5bc3a:      */
1:f6d02c9:     HashMap<UUID, DeferredConstraintsMemory.ValidationInfo>
1:af1c18c:         getDeferredHashTables();
1:0c5bc3a: 
1:0c5bc3a:     /**
1:0c5bc3a:      * Check that deferred constraints are valid, if not roll back the
1:0c5bc3a:      * transaction.
1:0c5bc3a:      *
3:0c5bc3a:      * @throws StandardException
1:0c5bc3a:      */
1:0c5bc3a:     public void checkIntegrity() throws StandardException;
1:0c5bc3a: 
1:0c5bc3a:     /**
1:4cc0287:      * Get the SQL session context of the given activation.
1:4cc0287:      * @param activation The activation
1:4cc0287:      * @return           The SQL session object
1:4cc0287:      */
1:4cc0287:     public SQLSessionContext getCurrentSQLSessionContext(Activation activation);
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	  *	@return	a statement level &gt;= OUTERMOST_STATEMENT
/////////////////////////////////////////////////////////////////////////
1: 	 * Check if in SQL standard mode, with support for Grant and Revoke
commit:a180287
/////////////////////////////////////////////////////////////////////////
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1: 	public void copyHashtableToAIHT(Map<String,Long> from);
/////////////////////////////////////////////////////////////////////////
1:     public Map<Object,Object> getPrintedObjectsMap();
commit:274c5ba
/////////////////////////////////////////////////////////////////////////
0: 	public void copyHashtableToAIHT(Map<Object,Long> from);
commit:049f993
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.OptTrace;
/////////////////////////////////////////////////////////////////////////
1: 	 * Install an optimizer tracer (to enable tracing) or uninstall the current optimizer tracer
1:      * (to disable tracing).
1: 	 * @param tracer    Null if tracing is being turned off, otherwise an optimizer tracer
1: 	public void setOptimizerTracer( OptTrace tracer );
1: 
1: 	/**
1: 	 * Get the optimizer tracer (could be null if we aren't tracing the optimizer).
1: 	 */
1: 	public OptTrace getOptimizerTracer();
1: 	public boolean optimizerTracingIsOn();
commit:38f02ec
/////////////////////////////////////////////////////////////////////////
1: 	 * TransactionControl.UNSPECIFIED_ISOLATION_LEVEL 
commit:3ff5ce3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.ASTVisitor;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Set a Visitor which walks the AST at various stages. This is useful
1:      * for poking user-written inspectors into the parse, bind, and optimize phases.
1:      *
1:      * @param visitor The Visitor which should walk the tree. Could be null.
1:      */
1:     public void setASTVisitor( ASTVisitor visitor );
1: 
1:     /**
1:      * Get the Visitor which should walk the AST.
1:      *
1:      * @return The Visitor for that phase. Could be null.
1:      */
1:     public ASTVisitor getASTVisitor( );
1:     
commit:a19a896
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1:      * Debug method for remembering the last query tree.
1: 	 */
1:     public  void    setLastQueryTree( Object queryTree );
1: 
1: 	/**
1:      * Debug method for retrieving the last query tree.
1: 	 */
1:     public  Object    getLastQueryTree();
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f6d02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.ConstraintDescriptor;
/////////////////////////////////////////////////////////////////////////
1:      * Set the constraint mode for this constraint to {@code deferred}.
1:      * @param cd        The descriptor of the constraint
1:                                     ConstraintDescriptor cd,
/////////////////////////////////////////////////////////////////////////
1:     HashMap<UUID, DeferredConstraintsMemory.ValidationInfo>
/////////////////////////////////////////////////////////////////////////
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:      * Determines if a unique or primary key constraint currently has deferred
1:      * mode.
0:      * @param sc       The session context for which we are asking the status
0:      * @param indexCID The conglomerate id of the supporting index of the
0:      *                 constraint.
0:      * @return         {@code true} if the constraint is deferred
1:      * @throws StandardException
0:      *                 Standard error policy
0:     public boolean isEffectivelyDeferred(SQLSessionContext sc, long indexCID)
1:      * Determines if a check or foreign key constraint has deferred
1:      * mode.
1:      * @param sc           The SQL session context for which we are asking the status
1:      * @param constraintId The constraint id we are inquiring about.
1:      * @return             {@code true} if the constraint is deferred
1:      * @throws StandardException
1:      *                     Standard error policy
1:     public boolean isEffectivelyDeferred(SQLSessionContext sc, UUID constraintId)
1:      * Set the constraint mode of all deferrable constraints to the value of
1:      * {@code deferred}. If the value is {@code false}, this method might
1:      * throw with a constraint violation error, i.e. if some constraint
1:      * has deferred mode before this call and had seen violations.
1:      * @param a         The activation
1:      * @param deferred  The value which holds the constraint mode
1:      * @throws          StandardException Standard error policy
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the SQL session context of the given activation.
1:      * @param activation The activation
1:      * @return           The SQL session object
1:      */
1:     public SQLSessionContext getCurrentSQLSessionContext(Activation activation);
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.impl.sql.execute.DeferredConstraintsMemory;
/////////////////////////////////////////////////////////////////////////
0:      * Set the constraint mode for this primary key or unique constraint to
0:      * {@code deferred}.
/////////////////////////////////////////////////////////////////////////
1:     public void setConstraintDeferred(Activation a,
0:                                     long conglomId,
1:                                     boolean deferred) throws StandardException;
1: 
1:     /**
0:      * Set the constraint mode for this check constraint to {@code deferred}.
1:      * If {@code deferred} is {@code false}, to immediate checking,
1:      * if {@code true} to deferred checking.
1:      *
1:      * @param a         Activation
0:      * @param baseTableCID conglomerate id of constraint's base table
0:      * @param constraintId The constraint id
1:      * @param deferred  The new constraint mode
1:      * @throws StandardException
1:      */
1:     public void setConstraintDeferred(Activation a,
0:                                  long baseTableCID,
0:                                  UUID constraintId,
1:                                  boolean deferred) throws StandardException;
/////////////////////////////////////////////////////////////////////////
0:      * Get the constraint mode set, if any.
1:      *
0:      * @param a         Activation
0:      * @param constraintId The constraint id
0:      * @return         {@code true} if the constraint mode
0:      *                  for this constraint/index is effectively
0:      *                  deferred, {@code false} if it is immediate.
1:      * @throws StandardException standard error policy
1:      */
0:     public boolean isEffectivelyDeferred(Activation a, UUID constraintId)
1:             throws StandardException;
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Get the set of disk backed hash tables containing any index
1:      * rows saved for deferred unique/PK constraints in this
1:      * transaction, keyed by the conglomerate id, or rows saved
1:      * containing row locations violating rows for deferred check
1:      * constraints.
0:     HashMap<Long, DeferredConstraintsMemory.ValidationInfo>
1:         getDeferredHashTables();
/////////////////////////////////////////////////////////////////////////
0:      * Forget any violating rows for the deferred constraint associated
0:      * by conglomId,
0:      * @param conglomId The conglomerate identifier of the backing
0:      *        index, or a base table conglomerate id of it is a CHECK
0:      *        constraint.
0:     public void forgetDeferredConstraintsData(long conglomId)
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Map;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.db.Database;
1: import org.apache.derby.iapi.db.TriggerExecutionContext;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.compile.ASTVisitor;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.OptTrace;
1: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
1: import org.apache.derby.iapi.sql.depend.Provider;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.CursorActivation;
1: import org.apache.derby.iapi.sql.execute.ExecutionStmtValidator;
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.types.DataValueFactory;
/////////////////////////////////////////////////////////////////////////
1:      * {@link org.apache.derby.impl.sql.compile.StaticMethodCallNode#generatePushNestedSessionContext}.
1:      * @see org.apache.derby.impl.sql.compile.StaticMethodCallNode#generatePushNestedSessionContext
1:      * @throws StandardException standard error policy
1:     public void pushNestedSessionContext(Activation a,
1:                                         boolean definersRights,
1:                                         String definer)
1:     /**
1:      * If returning from a routine that can execute SQL, perform any
1:      * actions needed when popping the SQL session context.
1:      *
1:      * @param a activation
1:      * @throws StandardException standard error policy
1:      */
1:     public void popNestedSessionContext(Activation a) throws StandardException;
1: 
1:      * @return the requested session context
1:      * statement. In contrast to pushNestedSessionContext, the activation (for
/////////////////////////////////////////////////////////////////////////
1:      * @see #pushNestedSessionContext
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Set the constraint mode for this constraint/index to {@code deferred}.
0:      * If {@code deferred} is {@code false}, to immediate checking,
0:      * if {@code true} to deferred checking.
1:      *
0:      * @param a         Activation
0:      * @param conglomId The conglomerate id of the backing index for the
0:      *                  constraint .
0:      * @param deferred  The new constraint mode
1:      * @throws StandardException
1:      */
0:     public void setDeferred(Activation a, long conglomId, boolean deferred)
1:             throws StandardException;
1: 
1:     /**
0:      * Get the constraint mode set, if any.
1:      *
0:      * @param a         Activation
0:      * @param conglomId The conglomerate id of the backing index
0:      * @return         {@code true} if the constraint mode
0:      *                  for this constraint/index is effectively
0:      *                  deferred, {@code false} if it is immediate.
0:      * @throws StandardException standard error policy
1:      */
0:     public boolean isEffectivelyDeferred(Activation a, long conglomId)
1:             throws StandardException;
1: 
1:     /**
0:      * Set the constraint mode for all deferrable constraints to
0:      * {@code deferred}.
0:      * If {@code deferred} is {@code false}, to immediate checking,
0:      * if {@code true} to deferred checking.
1:      *
0:      * @param a        Activation
0:      * @param deferred The new constraint mode
1:      */
1:     public void setDeferredAll(Activation a, boolean deferred)
1:             throws StandardException;
1: 
1:     /**
0:      * Get the set of disk backed hash tables containing any index rows
0:      * saved for deferred constraints in this transaction, keyed by the
0:      * conglomerate id.
1:      * @return the set
1:      */
0:     HashMap<Long, BackingStoreHashtable> getDeferredHashTables();
1: 
1:     /**
1:      * Check that deferred constraints are valid, if not roll back the
1:      * transaction.
1:      *
1:      * @throws StandardException
1:      */
1:     public void checkIntegrity() throws StandardException;
1: 
1:     /**
0:      * Forget any violating rows for the deferred constraint backed by
0:      * {@code indexCID}, if any. Typically used when an index gets dropped
0:      * and/or recreated.
1:      *
0:      * @param indexCID The conglomerate identifier of the backing index
1:      * @throws StandardException
1:      */
0:     public void invalidateDeferredConstraintsData(long indexCID)
1:             throws StandardException;
commit:f29303b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the referenced column map for a table
1:      *
1:      * @return the map
1:      */
1:     public FormatableBitSet getReferencedColumnMap(TableDescriptor td);
1: 
1:     /**
1:      * Set the referenced column map for a table
1:      *
1:      * @param td the table descriptor
1:      * @param map the map
1:      */
1:     public void setReferencedColumnMap(TableDescriptor td,
1:                                        FormatableBitSet map);
commit:3a6f4cf
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Set the exception created and associated with the detected interruped
1:      * status flag.
1:      *
1:      * @param e the created exception
1:      */
1:     public void setInterruptedException(StandardException e);
1: 
1:     /**
1:      * Get exception created when we detected interruped status
1:      * flag.
1:      *
1:      * @return saved exception
1:      */
1:     public StandardException getInterruptedException();
commit:b86c38b
/////////////////////////////////////////////////////////////////////////
1:      * @param definersRights if the method should run with definer's rights
commit:9f60172
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the Authorization Id of the current user
1:      *
1:      * @param a activation
1:      * @return String the authorization id
1:      */
1:     public String getCurrentUserId(Activation a);
1: 
1:     /**
1:      *  Get the Authorization Id of the session user
1:      *
1:      * @return String   the authorization id
1:      */
1:     public String getSessionUserId();
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param a activation
1:     public boolean roleIsSettable(Activation a, String role)
1:             throws StandardException;
/////////////////////////////////////////////////////////////////////////
0:      * @param true if the method should run with definer's rights
1:      * @param definer authorization id of the definer
0:     public void setupNestedSessionContext(Activation a,
0:                                           boolean definersRights,
0:                                           String definer)
1:             throws StandardException;
/////////////////////////////////////////////////////////////////////////
1:     public void setupSubStatementSessionContext(Activation a)
1:             throws StandardException;
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
0: import java.util.AbstractMap;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Return a map of AST nodes that have already been printed during a
1: 	 * compiler phase, so as to be able to avoid printing a node more than once.
1: 	 * @see org.apache.derby.impl.sql.compile.QueryTreeNode#treePrint(int)
1: 	 * @return the map
1: 	 */
0:     public Map getPrintedObjectsMap();
commit:e3883f5
/////////////////////////////////////////////////////////////////////////
1: 	 * the SQLSessionContext stack to the initial default,
/////////////////////////////////////////////////////////////////////////
1: 	 * Create a new SQL session context for the current activation on the basis
1: 	 * of the existing SQL session context. This happens when a stored
1: 	 * procedure or function that can contain SQL is invoked, cf. SQL 2003
1: 	 * section 4.27.3, since this gives rise to a nested connection.
1: 	 * <p>
1: 	 * Called from generated code, see
0: 	 * {@code StaticMethodCallNode#generateSetupNestedSessionContext}.
1: 	 * <p>
1: 	 * @see #setupSubStatementSessionContext
1: 	 * Get the value of top level session context of the top level connection.
1: 	 */
1: 	public SQLSessionContext getTopLevelSQLSessionContext();
1: 
1: 	/**
1: 	 * Used when a statement as part of its operation executes an other
0: 	 * statement. In contrast to setupNestedSessionContext, the activation (for
1: 	 * the substatement) just inherits the current session context from the
1: 	 * parent statements activation, it does <b>not</b> push a new copy on the
1: 	 * stack of session contexts.
1: 	 *
1: 	 * Currently, this is used in the following situations:
1: 	 * <ul>
1: 	 *     <li>With {@code ALTER TABLE} adding a column which has a default
1: 	 *         values, the default value for all the existing rows is added
1: 	 *         using an {@code UPDATE} substatement.
1: 	 *     <li>With {@code ALTER TABLE} adding a a check constraint, we will use
1: 	 *         a substatement {@code SELECT} to check if all rows satisfy the
1: 	 *         constraint.
1: 	 *     <li>{@code ResultSet.insertRow}, {@code updateRow}
1: 	 *         and {@code deleteRow}.
1: 	 *     <li>During trigger body execution.
1: 	 * </ul>
0: 	 * @see #setupNestedSessionContext
1: 	 */
0: 	public void setupSubStatementSessionContext(Activation a);
1: 
1: 	/**
1: 	 * Create a fresh SQLSessionContext for this connection.
commit:44ea4f0
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the current role authorization identifier in external delimited form
1: 	 * (not case normal form) of the dynamic call context associated with this
1: 	 * activation.
1: 	 * @return String the role id in delimited form (i.e. <b>not</b>
1: 	 * internal case normal form</b>)
1: 	public String getCurrentRoleIdDelimited(Activation a)
commit:ddae94a
/////////////////////////////////////////////////////////////////////////
1: 	 * @param schemaName
commit:9e04f69
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Return true if this schema name is the initial default schema for the
1: 	 * current session.
1: 	 * @param schemaName 
1: 	 * @return true
1: 	 */
1: 	public boolean isInitialDefaultSchema(String schemaName);
1: 
commit:4e3ddd7
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.RoleGrantDescriptor;
commit:34b59c6
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the current role authorization identifier of the dynamic
0: 	 * call context associated with this activation. It is checked
0: 	 * whether it is still valid, that is, not revoked or dropped.
1: 	 * @param a activation of statement needing current role
1: 	 * @return String	the role id
1: 	 *
1: 	 * @throws StandardException  standard exception policy
1: 	 */
0: 	public String getCurrentRoleIdChecked(Activation a)
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Checks whether the given role can be legally set for the current user.
1: 	 *
1: 	 * This method will read (potentially) the dictionary, so it needs
1: 	 * a transaction context.
1: 	 *
1: 	 * @param role string containing role name
1: 	 *
1: 	 * @return true if the role can be set
1: 	 * @throws StandardException standard exception policy
1: 	 */
0: 	public boolean roleIsSettable(String role) throws StandardException;
1: 
1: 	/**
commit:6950a39
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the default schema (used at compile-time when no activation
1: 	 * is yet available, cf. the activation argument overload version.
1: 	 * @return SchemaDescriptor	the default schema
1: 	 * Get the default schema (used at execution time).  At execution
1: 	 * time, the current statement context is not always a reliable
1: 	 * place to find the correct SQL session context, viz. when a
1: 	 * dynamic result set referencing CURRENT SCHEMA is accessed after
1: 	 * a called procedure has returned only the activation of the call
1: 	 * is live and still holds the correct session context.
1: 	 * @param a current activation
1: 	 * @return SchemaDescriptor	the default schema
1: 	 */
1: 	public SchemaDescriptor getDefaultSchema(Activation a);
1: 
1: 	/**
1: 	 * Set the default schema (at compile-time, see explanations for
1: 	 * getDefaultSchema overloads).
1: 	 *
1: 	 * @param sd the new default schema.
1: 	 * If null, then the default schema descriptor is used.
/////////////////////////////////////////////////////////////////////////
1: 	 * Set the default schema (at execution time, see explanations for
1: 	 * getDefaultSchema overloads); This version is used by SET SCHEMA.
1: 	 *
1: 	 * @param a current activation
1: 	 * @param sd the new default schema.
1: 	 * If null, then the default schema descriptor is used.
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public void setDefaultSchema(Activation a, SchemaDescriptor sd)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Reset any occurence of schemaName as current default schema in
0: 	 * the SQLSessionContext stack to the initial default, presumably
1: 	 * because schemaName is no longer a valid schema.
1: 	 *
1: 	 * @param activation current activation
1: 	 * @param schemaName the schema name occurences of which is to be reset
1: 	 *
0: 	 * @throws StandardException
1: 	 */
1: 	public void resetSchemaUsages(Activation activation, String schemaName)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 *	Get the current schema name (at compile-time, see explanations for
1: 	 * getDefaultSchema overloads).
1: 	 * Get the current schema name (at execution time, see explanations for
1: 	 * getDefaultSchema overloads); This version is used by CURRENT SCHEMA.
1: 	 *
1: 	 * @return SchemaDescriptor	the current schema
1: 	 */
1: 	public String getCurrentSchemaName(Activation a);
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
1: 	 * @return StatementContext The statement context.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	/**
0: 	 * Create a new SQL session context for the current activation
0: 	 * on the basis of the existing SQL session context (logical
0: 	 * session context analogue to call stack push, i.e. this happens
0: 	 * when a stored procedure or function that can contain SQL is
0: 	 * invoked. Called from generated code, see
0: 	 * StaticMethodCallNode#generateSetupNestedSessionContext.
1: 	 *
1: 	 * The new SQL session context is also set in the current statement
1: 	 * context (of the invocation).
1: 	 *
0: 	 * @see org.apache.derby.impl.sql.compile.StaticMethodCallNode#generateSetupNestedSessionContext
1: 	 * @see StatementContext#getSQLSessionContext
1: 	 *
1: 	 * @param a activation of the statement which performs the call.
1: 	 */
0: 	public void setupNestedSessionContext(Activation a);
1: 
1: 	/**
0: 	 * Create a fresh SQLSessionContext
1: 	 * @return new SQLSessionContext
1: 	 */
1: 	public SQLSessionContext createSQLSessionContext();
commit:f04dc44
/////////////////////////////////////////////////////////////////////////
1: 	 * @param a activation of set role statement
/////////////////////////////////////////////////////////////////////////
1: 	 * @param a activation of statement needing current role
commit:99d7d8b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * Remember most recent (call stack top) caller's activation when
0: 	 * invoking a method, see CallStatementResultSet#open.
1: 	 */
0: 	public void pushCaller(Activation a);
1: 
1: 	/**
0: 	 * Companion of pushCaller. See usage in CallStatementResultSet#open.
1: 	 */
0: 	public void popCaller();
1: 
1: 	/**
0: 	 * Get most recent (call stack top) caller's activation
1: 	 */
0: 	public Activation getCaller();
1: 
1:     /**
1: 	 * Set the current role
1: 	 *
0: 	 * @param activation activation of set role statement
1: 	 * @param role  the id of the role to be set to current
1: 	 */
1:     public void setCurrentRole(Activation a, String role);
1: 
1: 	/**
0: 	 * Get the current role authorization identifier of the dynamic
1: 	 * call context associated with this activation.
1: 	 *
0: 	 * @param activation activation of statement needing current role
0: 	 * @return String	the role id
1: 	 */
1: 	public String getCurrentRoleId(Activation a);
1: 
commit:ee59de8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.dictionary.RoleDescriptor;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 *	Get the current role authorization identifier
1: 	 *
0: 	 * @return String	the role id
1: 	 */
0: 	public String getCurrentRoleId();
1: 
1: 
1:     /**
0: 	 * Set the current role
1: 	 *
0: 	 * @param rd	the descriptor of the role to be set to current
1: 	 */
0:     public void setCurrentRole(RoleDescriptor rd);
1: 
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:77603a1
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Close any unused activations in this connection context.
1: 	 */
1: 	public void closeUnusedActivations() throws StandardException;
commit:06f0810
/////////////////////////////////////////////////////////////////////////
commit:44370a8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1: 	 * Copy a map of autoincrement key value pairs into the cache of
0: 	public void copyHashtableToAIHT(Map from);
commit:68c8e7d
/////////////////////////////////////////////////////////////////////////
1: 	void addActivation(Activation a)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Make a note that some activations are marked unused
1: 	 */
1: 	void notifyUnusedActivation();
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:44db2d0
/////////////////////////////////////////////////////////////////////////
commit:48a9884
/////////////////////////////////////////////////////////////////////////
1: 	
1:     /**
1:      * sets the XplainOnlyMode.
1:      *
1:      * If a connection is in XplainOnlyMode, then the statements are not
1:      * actually being executed, but are just being compiled and the
1:      * runtime statistics collected into the XPLAIN tables. This can be
1:      * set on and off by calling SYSCS_SET_XPLAIN_MODE.
1:      *
1:      * @param onOrOff true if statements are to be XPLAINed only.
1:      */
1:     public void setXplainOnlyMode(boolean onOrOff);
1: 
1:     /**
1:      * gets the current set XplainOnlyMode
1:      */
1:     public boolean getXplainOnlyMode();
1: 
1:     /**
1:      * sets the XplainSchema
1:      * @param schema the schema to use for storing XPLAIN'd statements
1:      * null means don't store the xplain information
1:      * non-null means persistent style, use the indicated schema
1:      */
1:     public void setXplainSchema(String schema);
1: 
1:     /**
1:      * gets the current set XplainSchema
1:      * @return the Schema of Xplain, may be null.
1:      */
1:     public String getXplainSchema();
1:     public void setXplainStatement(Object key, Object stmt);
1:     public Object getXplainStatement(Object key);
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:53ce71e
/////////////////////////////////////////////////////////////////////////
commit:9ac3a76
/////////////////////////////////////////////////////////////////////////
1: 	void initialize() throws StandardException;
commit:03f03b6
/////////////////////////////////////////////////////////////////////////
commit:20d5490
/////////////////////////////////////////////////////////////////////////
0: 	 *	Get the current default schema for the connection.
commit:d3ebb3c
/////////////////////////////////////////////////////////////////////////
1:    
/////////////////////////////////////////////////////////////////////////
commit:95031f0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:08cd3aa
/////////////////////////////////////////////////////////////////////////
1: 	 * Returns true if isolation level has been set using JDBC/SQL.
1: 	 */
1: 	public boolean isIsolationLevelSetUsingSQLorJDBC();
1: 	/**
1: 	 * Reset the isolation level flag used to keep correct isolation level
1: 	 * state in BrokeredConnection. This resetting will happen at the start 
1: 	 * and end of a global transaction, after the BrokeredConection's 
1: 	 * isolation level state is brought upto date with the EmbedConnection's
1: 	 * isolation state.
1: 	 * The flag gets set to true when isolation level is set using JDBC/SQL.
1: 	 */
1: 	public void resetIsolationLevelFlagUsedForSQLandJDBC();
1: 
1: 	/**
1: 	 *
commit:3fcea8a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param tableName Mark the passed temporary table name as modified
1: 	 * @param td Corresponding to the temporary table
1: 	 * @param tableName look for this table name in the saved list and drop it if found
/////////////////////////////////////////////////////////////////////////
1: 	 * @param tableName Get table descriptor for the passed table name
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * @param sd the new default schema
/////////////////////////////////////////////////////////////////////////
1: 	 * @param val the generated identity column value
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param timeoutMillis Timeout value for this statement, in milliseconds.
1:      *  Zero means no timeout.
1: 		ParameterValueSet pvs, boolean rollbackParentContext, long timeoutMillis);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:      * @param id an identifier string
/////////////////////////////////////////////////////////////////////////
1: 	 * @param drdaID DRDA ID.
commit:588f766
/////////////////////////////////////////////////////////////////////////
1: 		Reset the connection before it is returned (indirectly) by
1: 		a PooledConnection object. See EmbeddedConnection.
1: 	public void resetFromPool()
commit:cf58aec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	public Long getIdentityValue();
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.conn.LanguageConnectionContext
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.conn
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.conn;
1: 
1: import org.apache.derby.iapi.services.context.Context;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.db.Database;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.CursorActivation;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionStmtValidator;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.ParameterValueSet;
1: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.db.TriggerExecutionContext;
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
1: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
0: import org.apache.derby.catalog.UUID;
1: 
0: import java.util.Locale;
0: import java.util.Hashtable;
0: import java.util.Vector;
0: import java.math.BigDecimal;
1: 
1: /**
1:  * LanguageConnectionContext keeps the result sets,
1:  * and activations in use by the current connection.
1:  * <p>
1:  * More stable items, like other factories, are accessible through
1:  * the LanguageConnectionFactory or the LanguageFactory.
1:  *
1:  * @see LanguageConnectionFactory
1:  * @see org.apache.derby.iapi.sql.LanguageFactory
1:  */
1: public interface LanguageConnectionContext extends Context {
1: 
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/**
1: 	 * this is the ID we expect these contexts
1: 	 * to be stored into a context manager under.
1: 	 */
1: 	public static final String CONTEXT_ID = org.apache.derby.iapi.reference.ContextId.LANG_CONNECTION;
1: 
1: 	public	static	final	int	OUTERMOST_STATEMENT = 1;
1: 
1:     // Constants describing how this connection handles schemas
1:     public static final int SQL92_SCHEMAS = 0;
1:     public static final int USER_NAME_SCHEMA = 1; // User names are schema names.
1:     public static final int NO_SCHEMAS = 2; // Schemas not implemented.
1: 
1: 	/* String for logStatementText output */
1: 	public static final String xidStr = "(XID = ";
1: 	public static final String lccStr = "(SESSIONID = ";
1: 	public static final String dbnameStr = "(DATABASE = ";
1: 	public static final String drdaStr = "(DRDAID = ";
1: 
1: 	// Lock Management
1: 
1: 	public	static	final	int	SINGLE_TRANSACTION_LOCK = 1;
1: 	public	static	final	int	MULTI_TRANSACTION_LOCK = 2;
1: 
1: 	// controls casing of NON-delimited identifiers. ANSI casing forces all
1: 	// non-delimited identifiers to be lower case.
1: 
1: 	public	static	final	int	UNKNOWN_CASING = -1;
1: 	public	static	final	int	ANSI_CASING = 0;
1: 	public	static	final	int	ANTI_ANSI_CASING = 1;
1: 
1: 	/**
1: 	 * Initialize. For use after pushing the contexts that initialization needs.
1: 	 *
0: 	 * @param sqlConnection	Whether or not this is called from a sql connection.
1: 	 *
1: 	 * @exception StandardException thrown if something goes wrong
1: 	 */
0: 	void initialize(boolean sqlConnection) throws StandardException;
1: 
1: 	/**
1: 	 * Get value of logStatementText.
1: 	 * (Whether or not to write info on currently
1: 	 * executing statement to error log.)
1: 	 *
1: 	 * @return value of logStatementText
1: 	 */
1: 	public boolean getLogStatementText();
1: 
1: 	/**
1: 	 * Set value of logStatementText
1: 	 * (Whether or not to write info on currently
1: 	 * executing statement to error log.)
1: 	 *
1: 	 * @param logStatementText	Whether or not logStatementText property is set.
1: 	 *
1: 	 * @return Nothing.
1: 	 */
1: 	public void setLogStatementText(boolean logStatementText);
1: 
1: 	/**
1: 	 * Get value of logQueryPlan.
1: 	 * (Whether or not to write query plan info on currently
1: 	 * executing statement to error log.)
1: 	 *
1: 	 * @return value of logQueryPlan
1: 	 */
1: 	public boolean getLogQueryPlan();
1: 
1: 	/**
1: 	 * get the lock escalation threshold to use with this connection.
1: 	 */
1: 	int getLockEscalationThreshold();
1: 
1: 	/**
1: 	 * Add the activation to those known about by this connection.
1: 	 *
1: 	 */
0: 	void addActivation(Activation a);
1: 
1: 	/**
1: 	 * Remove the activation from those known about by this connection.
1: 	 *
1: 	 * @exception StandardException thrown if something goes wrong
1: 	 */
1: 	void removeActivation(Activation a)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Return the number of activation known for this connection.
1: 	 *
1: 	 */
1: 	int getActivationCount();
1: 
1: 	/**
1: 	 * See if a given cursor is available for use.  This is used
1: 	 * to locate the cursor during its execution.
1: 	 *
1: 	 * @return the activation for the given cursor, null if none exists.
1: 	 */
1: 	CursorActivation lookupCursorActivation(String cursorName);
1: 
1: 	/**
1: 	 * Return the last activation added
1: 	 * This is used to find the drop activation in dropViewCascade
1: 	 * so we can add warning messages to the activation
1: 	 *
1: 	 */
1: 	public Activation getLastActivation();
1: 
1: 	/**
1: 		Get a connection unique system generated name for a cursor.
1: 	*/
1: 	public String getUniqueCursorName();
1: 
1: 	/**
1: 		Get a connection unique system generated name for an unnamed savepoint.
1: 	*/
1: 	public String getUniqueSavepointName();
1: 
1: 	/**
1: 		Get a connection unique system generated id for an unnamed savepoint.
1: 	*/
1: 	public int getUniqueSavepointID();
1: 
1: 	/**
1: 	 * Check if there are any global temporary tables declared for this connection.
1: 	 * @return true if there are declared temp tables for this connectoin else false
1: 	 *
1: 	 */
1: 	public boolean checkIfAnyDeclaredGlobalTempTablesForThisConnection();
1: 
1: 	/**
1: 	 * Mark the passed temporary table as modified in the current unit of work. That information will be used at rollback time
1: 	 * The compile phase will generate code to call this method if the DML is on a temporary table
1: 	 *
0: 	 * @param String tableName Mark the passed temporary table name as modified
1: 	 */
1: 	public void markTempTableAsModifiedInUnitOfWork(String tableName);
1:   
1: 	/**
1: 	 * Add the declared global temporary table to the list of temporary tables known by this connection.
0: 	 * @param TableDescriptor td Corresponding to the temporary table
1: 	 *
1: 	 */
1: 	public void addDeclaredGlobalTempTable(TableDescriptor td) throws StandardException;
1: 
1: 	/**
1: 	 * Drop (mark the declared global temporary table for dropping) from the list of temporary tables known by this connection.
0: 	 * @param String tableName look for this table name in the saved list and drop it if found
1: 	 * @return true if dropped the temporary table. False if no such temporary table exists.
1: 	 *
1: 	 * @see org.apache.derby.impl.sql.conn.TempTableInfo
1: 	 */
1: 	public boolean dropDeclaredGlobalTempTable(String tableName);
1: 
1: 	/**
1: 	 * Get table descriptor for the declared global temporary table from the list of temporary
1: 	 * tables known by this connection.
0: 	 * @param String tableName Get table descriptor for the passed table name
1: 	 * @return TableDescriptor if found the temporary table. Else return null
1: 	 *
1: 	 */
1: 	public TableDescriptor getTableDescriptorForDeclaredGlobalTempTable(String tableName);
1: 
1: 	/**
0: 	 * Drop all the declared global temporary tables associated with this connection. This gets called
0: 	 * when a getConnection() is done on a PooledConnection. This will ensure all the temporary tables
0: 	 * declared on earlier connection handle associated with this physical database connection are dropped
0: 	 * before a new connection handle is issued on that same physical database connection.
1: 	 */
0: 	public void dropAllDeclaredGlobalTempTables()
1: 		 throws StandardException;
1: 
1: 	/**
0: 		Do a commit, as internally needed by Cloudscape.  E.g.
1: 	 	a commit for sync, or a commit for autocommit.  Skips
1: 		checks that a user isn't doing something bad like issuing
1: 		a commit in a nested xact.
1: 
1: 		@param	commitStore	true if we should commit the Store transaction
1: 
0: 		@return	the commit instant
1: 
1: 		@exception StandardException thrown if something goes wrong
1: 	 */
1: 	void internalCommit( boolean commitStore )
1: 		 throws StandardException;
1: 
1: 	/**
1: 		Similar to internalCommit() but has logic for an unsynchronized commit
1: 
1: 		@param	commitflag	the flags to pass to commitNoSync in the store's
1: 							TransactionController
1: 
0: 		@return	the commit instant
1: 
1: 		@exception StandardException	thrown if something goes wrong
1: 	 */
1: 	void internalCommitNoSync(int commitflag) throws StandardException;
1: 
1: 	/**
1: 		Do a commit, as issued directly by a user (e.g. via Connection.commit()
1: 		or the JSQL 'COMMIT' statement.
1: 
0: 		@return	the commit instant
1: 
1: 		@exception StandardException thrown if something goes wrong
1: 	 */
1: 	void userCommit() throws StandardException;
1: 
1: 	/**
1: 		Commit a distrubuted transaction.
1: 
1: 		@param onePhase if true, allow it to commit without first going thru a
1: 		prepared state.
1: 
0: 		@return	the commit instant
1: 
1: 		@exception StandardException	thrown if something goes wrong
1: 	 */
1: 	void xaCommit(boolean onePhase) throws StandardException;
1: 
1: 
1: 	/**
0: 		Do a rollback, as internally needed by Cloudscape.  E.g.
1: 	 	a rollback for sync, or a rollback for an internal error.  Skips
1: 		checks that a user isn't doing something bad like issuing
1: 		a rollback in a nested xact.
1: 
1: 		@exception StandardException thrown if something goes wrong
1: 	 */
1: 	void internalRollback() throws StandardException;
1: 
1: 	/**
1: 		Do a rollback, as issued directly by a user (e.g. via Connection.rollback()
1: 		or the JSQL 'ROLLBACK' statement.
1: 
1: 		@exception StandardException thrown if something goes wrong
1: 	 */
1: 	void userRollback() throws StandardException;
1: 
1: 	/**
1: 	 * Let the context deal with a rollback to savepoint
1: 	 *
1: 	 * @param	savepointName	Name of the savepoint that needs to be rolled back
1: 	 * @param	refreshStyle	boolean indicating whether or not the controller should close
1: 	 * open conglomerates and scans. Also used to determine if language should close
1: 	 * open activations.
1: 	 * @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1: 	 * Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1: 	 *   A String value for kindOfSavepoint would mean it is SQL savepoint
1: 	 *   A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1: 	 *
1: 	 * @exception StandardException thrown if something goes wrong
1: 	 */
1: 	void internalRollbackToSavepoint
1: 	( String savepointName, boolean refreshStyle, Object kindOfSavepoint ) throws StandardException;
1: 
1: 	/**
1: 	 * Let the context deal with a release of a savepoint
1: 	 *
1: 	 * @param	savepointName	Name of the savepoint that needs to be released
1: 	 * @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1: 	 * Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1: 	 *   A String value for kindOfSavepoint would mean it is SQL savepoint
1: 	 *   A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1: 	 *
1: 	 * @exception StandardException thrown if something goes wrong
1: 	 */
1: 	void releaseSavePoint ( String savepointName, Object kindOfSavepoint ) throws StandardException;
1: 
1: 
1: 	/**
1: 		Roll back a distrubuted transaction.
1: 
1: 		@exception StandardException	thrown if something goes wrong
1: 	 */
1: 	void xaRollback() throws StandardException;
1: 
1: 	/**
1: 	  Sets a savepoint. Causes the Store to set a savepoint.
1: 
1: 	  @param	savepointName	name of savepoint
1: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
1: 	  Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
1: 	  A String value for kindOfSavepoint would mean it is SQL savepoint
1: 	  A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
1: 
1: 		@exception StandardException thrown if something goes wrong
1: 	  */
1: 	void	languageSetSavePoint( String savepointName, Object kindOfSavepoint )  throws StandardException;
1: 
1: 	/**
0: 		Returns true if any transaction is blocked (even if not by this one)
1: 
1: 	 */
0: 	boolean anyoneBlocked();
1: 
1: 	/**
0: 		Sets the transaction controller to use with this language connection
1: 		context.
1: 
0: 		@param	tran	the transaction to use with this language connection context
1: 	 */
0: 	void setTransaction( TransactionController tran );
1: 
1: 	/**
1: 	 * Begin a nested transaction.
1: 	 *
1: 	 * @param readOnly The nested transaction would be read only if param value true
1: 	 *
1: 	 * @exception StandardException on error.
1: 	 * @see TransactionController#startNestedUserTransaction
1: 	 */
1: 
1: 	void beginNestedTransaction(boolean readOnly) throws StandardException;
1: 
1: 	/**
1: 	 * commit a nested transaction.
1: 	 * We do not provide a abortNestedTransaction. 
1: 	 * If a nested xaction is aborted, then this results in the parent xaction
1: 	 * also being aborted. This is not what we need for releasing
1: 	 * compile time locks or autoincrement-- hence we do not provide 
1: 	 * abortNestedTransaction. 
1: 	 *
1: 	 * @exception StandardException thrown on erro
1: 	 *
1: 	 * @see TransactionController#startNestedUserTransaction
1: 	 */
1: 	void commitNestedTransaction() throws StandardException;
1: 
1: 	/**
1: 		Get the transaction controller to use with this language connection
1: 		context at compile time.
1: 	 */
1: 	TransactionController getTransactionCompile();
1: 
1: 	/**
1: 		Get the transaction controller to use with this language connection
1: 		context during execute time.
1: 	 */
1: 
1: 	TransactionController getTransactionExecute();
1: 
1:     /**
0:      * Get the system schema name.
1:      *
0:      * @return a String containing the system schema name.
1:      */
0:     public String getSystemSchemaName() throws StandardException;
1:     
1:     /**
0:      * Get the SYSIBM schema name.
1:      *
0:      * @return a String containing the SYSIBM schema name.
1:      */
0:     public String getSysIBMSchemaName() throws StandardException;
1: 
1:     /**
0:      * Get the SYSCS_DIAG schema name.
1:      *
0:      * @return a String containing the SYSIBM schema name.
1:      */
0:     public String getSystemDiagSchemaName() throws StandardException;
1: 
1:     /**
0:      * Get the SYSCS_UTIL schema name.
1:      *
0:      * @return a String containing the SYSIBM schema name.
1:      */
0:     public String getSystemUtilSchemaName() throws StandardException;
1:     
1: 	/**
1: 		Get the data dictionary 
1: 
1: 		@return the data dictionary
1: 
1: 	 */
1: 	public DataDictionary getDataDictionary();
1: 
1: 	/**
1: 		Get the data value factory to use with this language connection
1: 		context.
1: 	 */
1: 	DataValueFactory getDataValueFactory();
1: 
1: 	/**
1: 		Get the language factory to use with this language connection
1: 		context.
1: 	 */
1: 	LanguageFactory getLanguageFactory();
1: 
1: 	/**
1: 	 * get the optimizer factory to use with this language connection context.
1: 	 */
1: 	OptimizerFactory getOptimizerFactory();
1: 	
1: 	/**
1: 		Get the language connection factory to use with this language connection
1: 		context.
1: 	 */
1: 	LanguageConnectionFactory getLanguageConnectionFactory();
1: 
1: 	/**
0: 	 *	Get the Authorization Id
1: 	 *
0: 	 * @return String	the authorization id
1: 	 */
0: 	public String getAuthorizationId();
1: 
1:     /**
0:      * Get the declared global temporary tables schema name.
1:      *
0:      * @return a String containing the declared global temporary tables schema name.
1:      */
0:     public String getDeclaredGlobalTemporaryTablesSchemaName() throws StandardException;
1:   
1: 	/**
0: 	 *	Get the current default schema
1: 	 *
1: 	 * @return SchemaDescriptor	the current schema
1: 	 */
1: 	public SchemaDescriptor getDefaultSchema(); 
1: 
1: 	/**
0: 	 *	Set the current default schema
1: 	 *
0: 	 * @param SchemaDescriptor	the new default schema
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public void setDefaultSchema(SchemaDescriptor sd)
1: 		throws StandardException;
1: 
1: 	/**
0: 	 *	Get the current schema name
1: 	 *
1: 	 * @return SchemaDescriptor	the current schema
1: 	 */
1: 	public String getCurrentSchemaName();
1: 
1: 	/**
1: 	 * Get the identity column value most recently generated.
1: 	 *
1: 	 * @return the generated identity column value
1: 	 */
0: 	public BigDecimal getIdentityValue();
1: 
1: 	/**
1: 	 * Set the field of most recently generated identity column value.
1: 	 *
0: 	 * @param the generated identity column value
1: 	 */
1: 	public void setIdentityValue(long val);
1: 
1: 	/**
1: 	 * Verify that there are no activations with open result sets
1: 	 * on the specified prepared statement.
1: 	 *
1: 	 * @param pStmt		The prepared Statement
1: 	 * @param provider	The object precipitating a possible invalidation
1: 	 * @param action	The action causing the possible invalidation
1: 	 *
1: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	boolean verifyNoOpenResultSets(PreparedStatement pStmt, Provider provider, 
1: 									   int action)
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Verify that there are no activations with open held result sets.
1: 	 *
1: 	 * @return boolean  Found no open resultsets.
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public boolean verifyAllHeldResultSetsAreClosed()
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Push a CompilerContext on the context stack with
1: 	 * the current default schema as the default schema
1: 	 * which we compile against.
1: 	 *
1: 	 * @return the compiler context
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public	CompilerContext pushCompilerContext();
1: 
1: 	/**
1: 	 * Push a CompilerContext on the context stack with
1: 	 * the passed in default schema as the default schema
1: 	 * we compile against.
1: 	 *
1: 	 * @param sd the default schema 
1: 	 *
1: 	 * @return the compiler context
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public	CompilerContext pushCompilerContext(SchemaDescriptor sd);
1: 
1: 	/**
1: 	 * Pop a CompilerContext off the context stack.
1: 	 *
1: 	 * @param compilerContext  The compiler context.
1: 	 *
1: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	public void popCompilerContext(CompilerContext compilerContext);
1: 
1: 	/**
1: 	 * Push a StatementContext on the context stack.
1: 	 *
1: 	 * @param isAtomic whether a commit/rollback is permitted
1: 	 *	from a nested connection under this statement
1: 	 *
1: 	 * @param stmtText the text of the statement.  Needed for any language
1: 	 * 	statement (currently, for any statement that can cause a trigger
1: 	 * 	to fire).  Please set this unless you are some funky jdbc setXXX
1: 	 *	method or something.
1: 	 *
1: 	 * @param pvs parameter value set, if it has one
1: 	 *
1: 	 * @param rollbackParentContext True if 1) the statement context is
1: 	 * 	NOT a top-level context, AND 2) in the event of a statement-level
1: 	 *	exception, the parent context needs to be rolled back, too.
1: 	 *
0: 	 * @return StatementContext	The statement context.
1: 	 *
1: 	 */
0: 	StatementContext pushStatementContext(boolean isAtomic, String stmtText,
0: 		ParameterValueSet pvs, boolean rollbackParentContext);
1: 
1: 	/**
1: 	 * Pop a StatementContext of the context stack.
1: 	 *
1: 	 * @param statementContext  The statement context.
1: 	 * @param error				The error, if any  (Only relevant for DEBUG)
1: 	 *
1: 	 * @return Nothing.
1: 	 *
1: 	 */
1: 	public void popStatementContext(StatementContext statementContext,
1: 									Throwable error);
1: 
1: 	/**
1: 	 * Push a new execution statement validator.  An execution statement 
1: 	 * validator is an object that validates the current statement to
1: 	 * ensure that it is permitted given the current execution context.
1: 	 * An example of a validator a trigger ExecutionStmtValidator that
1: 	 * doesn't allow ddl on the trigger target table.
1: 	 * <p>
1: 	 * Multiple ExecutionStmtValidators may be active at any given time.
1: 	 * This mirrors the way there can be multiple connection nestings
1: 	 * at a single time.  The validation is performed by calling each
1: 	 * validator's validateStatement() method.  This yields the union
1: 	 * of all validations.
1: 	 *
1: 	 * @param validator the validator to add
1: 	 */
1: 	public void pushExecutionStmtValidator(ExecutionStmtValidator validator);
1: 
1: 	/**
1: 	 * Remove the validator.  Does an object identity (validator == validator)
1:  	 * comparison.  Asserts that the validator is found.
1: 	 *
1: 	 * @param validator the validator to remove
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public void popExecutionStmtValidator(ExecutionStmtValidator validator)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Validate a statement.  Does so by stepping through all the validators
1: 	 * and executing them.  If a validator throws and exception, then the
1: 	 * checking is stopped and the exception is passed up.
1: 	 *
1: 	 * @param constantAction the constantAction that is about to be executed (and
1: 	 *	should be validated
1:  	 *
1: 	 * @exception StandardException on validation failure
1: 	 */
1: 	public void validateStmtExecution(ConstantAction constantAction)
1: 		throws StandardException;
1: 	
1: 	/**
1: 	 * Push a new trigger execution context.
1: 	 * <p>
1: 	 * Multiple TriggerExecutionContexts may be active at any given time.
1: 	 *
1: 	 * @param tec the trigger execution context
1: 	 *
1: 	 * @exception StandardException on trigger recursion error
1: 	 */
1: 	public void pushTriggerExecutionContext(TriggerExecutionContext tec)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Remove the tec.  Does an object identity (tec == tec)
1:  	 * comparison.  Asserts that the tec is found.
1: 	 *
1: 	 * @param tec the tec to remove
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1: 	public void popTriggerExecutionContext(TriggerExecutionContext tec)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Get the topmost tec.  
1: 	 *
1: 	 * @return the tec
1: 	 */
1: 	public TriggerExecutionContext getTriggerExecutionContext();
1: 
1: 	/**
1: 	 * Set the trigger table descriptor.  Used to compile
1: 	 * statements that may special trigger pseudo tables.
1: 	 *
1: 	 * @param td the table that the trigger is 
1: 	 * defined upon
1: 	 *
1: 	 */
1: 	public void pushTriggerTable(TableDescriptor td);
1: 
1: 	/**
1: 	 * Remove the trigger table descriptor.
1: 	 *
1: 	 * @param td the table to remove from the stack.
1: 	 */
1: 	public void popTriggerTable(TableDescriptor td);
1: 
1: 	/**
1: 	 * Get the topmost trigger table descriptor
1: 	 *
1: 	 * @return the table descriptor, or null if we
1: 	 * aren't in the middle of compiling a create
1: 	 * trigger.
1: 	 */
1: 	public TableDescriptor getTriggerTable();
1: 
1: 	/**
1: 	 * Increment the DataDictionary bind count.  This is for keeping track
1: 	 * of nested binding, which can happen if SQL statements are bound from
1: 	 * within static initializers.
1: 	 *
1: 	 * @return	The new bind count
1: 	 */
1: 	int incrementBindCount();
1: 
1: 	/**
1: 	 * Decrement the DataDictionary bind count.
1: 	 *
1: 	 * @return	The new bind count
1: 	 */
1: 	int decrementBindCount();
1: 
1: 	/**
1: 	 * Get the DataDictionary bind count.
1: 	 *
1: 	 * @return	The current bind count.
1: 	 */
1: 	int getBindCount();
1: 
1: 	/**
1: 	 * Remember that the DataDictionary is in write mode, so we can take
1: 	 * it out of write mode at the end of the transaction.
1: 	 */
1: 	void setDataDictionaryWriteMode();
1: 
1: 	/**
1: 	 * Return true if the data dictionary is in write mode (that is, this
1: 	 * context was informed that is is in write mode by the method call
1: 	 * setDataDictionaryWriteMode().
1: 	 */
1: 	boolean dataDictionaryInWriteMode();
1: 
1: 	/**
1: 	 * Turn RUNTIMESTATISTICS  on or off.
1: 	 */
1: 	public void setRunTimeStatisticsMode(boolean onOrOff);
1: 
1: 	/**
1: 	 * Get the RUNTIMESTATISTICS mode.
1: 	 */
1: 	public boolean getRunTimeStatisticsMode();
1: 
1: 	/**
1: 	 * Turn STATISTICS TIMING on or off.
1: 	 */
1: 	public void setStatisticsTiming(boolean onOrOff);
1: 
1: 	/**
1: 	 * Get the STATISTICS TIMING mode.
1: 	 */
1: 	public boolean getStatisticsTiming();
1: 
1: 	/** 
1: 	 * Set the RUNTIMESTATISTICS object. 
1: 	 */
1: 	public void setRunTimeStatisticsObject(RunTimeStatistics runTimeStatisticsObject);
1: 
1: 	/** 
1: 	 * Get the RUNTIMESTATISTICS object. 
1: 	 */
1: 	public RunTimeStatistics getRunTimeStatisticsObject();
1: 
1: 
1:     /**
1: 	  *	Reports how many statement levels deep we are.
1: 	  *
0: 	  *	@return	a statement level >= OUTERMOST_STATEMENT
1: 	  */
1: 	public	int		getStatementDepth();
1: 
1: 	/**
1: 	  Returns the Database of this connection.
1:      */
1:     public Database getDatabase();
1: 
1: 	/**
1: 	 * Set current isolation level.
1: 	 * 
1: 	 * @param isolationLevel	The new isolationLevel.
1: 	 *
1: 	 * @return Nothing.
1: 	 */
1: 	public void setIsolationLevel(int isolationLevel) throws StandardException;
1: 
1: 	/**
1: 	 * Get the current isolation level.
1: 	 *
1: 	 * @return The current isolation level.
1: 	 */
1: 	public int getCurrentIsolationLevel();
1: 
1: 	/**
1: 	 * Get the current isolation level in DB2 format.
1: 	 *
1: 	 * @return The current isolation level as a 2 character string.
1: 	 */
1: 	public String getCurrentIsolationLevelStr();
1: 	public void setPrepareIsolationLevel(int isolationLevel) ;
1: 
1: 	/**
1: 	 * Get the prepare isolation level.
1: 	 * If the isolation level has been explicitly set with a SQL statement or
1: 	 * embedded call to setTransactionIsolation, this will return
0: 	 * ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL 
1: 	 * SET ISOLATION always takes priority.
1: 	 * 
1: 	 */
1: 	public int getPrepareIsolationLevel();
1: 
1: 	/**
1: 	 * Set the readOnly status for the current connection. This can
1: 	 * only be called when the current transaction has not done
1: 	 * any work.
1: 	 *
1: 	 * @param onOrOff true sets the connection to be readOnly and
1: 	 *                false sets it to readWrite.
1: 	 *
1: 	 * @exception StandardException The call failed and the readOnly
1: 	 *                status has not changed.
1: 	 */
1: 	public void setReadOnly(boolean onOrOff) throws StandardException;
1: 
1: 	/**
1: 	  * Get the readOnly status for the current connection. 
1: 	  */
1: 	public boolean isReadOnly();
1: 
1: 	/**
1: 	 * Get an Authorizer for this connection.
1: 	 */
1: 	public Authorizer getAuthorizer(); 
1: 
1: 	/**
0: 	 *	Get the current ExecutionContext.
1: 	 */
0: 	ExecutionContext getExecutionContext();
1: 
1: 	/**
1: 	 *	Get the current StatementContext.
1: 	 */
1: 	StatementContext getStatementContext();
1: 
0: 	/** Get the AccessFactory cached in this LanguageConnectionContext */
0: 	AccessFactory getAccessFactory();
1: 
1: 	/**
0: 		Return a compiled Statement object. The schema and unicode
0: 		setting fo the returned statement are that of this connection.
1: 	*/
0: 	public PreparedStatement prepareInternalStatement(String sqlText) throws StandardException;
0: 	public PreparedStatement prepareInternalStatement(SchemaDescriptor compilationSchema, String sqlText) throws StandardException;
1: 
1: 	/**
0: 	 * Control whether or not optimizer trace is on.
1: 	 *
0: 	 * @param onOrOff    Whether to turn optimizer trace on (true) or off (false).
1: 	 *
0: 	 * @return Whether or not the call was successful.  (false will be returned when optimizer tracing is not supported.)
1: 	 */
0: 	public boolean setOptimizerTrace(boolean onOrOff);
1: 
1: 	/** 
1: 	 * Get whether or not optimizer trace is on.
1: 	 *
1: 	 * @return Whether or not optimizer trace is on.
1: 	 */
0: 	public boolean getOptimizerTrace();
1: 
1: 	/**
0: 	 * Control whether or not optimizer trace is generated in html.
1: 	 *
0: 	 * @param onOrOff    Whether or not optimizer trace will be in html (true) or not (false).
1: 	 *
0: 	 * @return Whether or not the call was successful.  (false will be returned when optimizer tracing is not supported.)
1: 	 */
0: 	public boolean setOptimizerTraceHtml(boolean onOrOff);
1: 
1: 	/** 
0: 	 * Get whether or not optimizer trace html is on.
1: 	 *
0: 	 * @return Whether or not optimizer trace html is on.
1: 	 */
0: 	public boolean getOptimizerTraceHtml();
1: 
1: 	/**
0: 	 * Get the optimizer trace output for the last optimized query as a String.  If optimizer trace
0: 	 * html is on, then the String will contain the html tags.
1: 	 *
0: 	 * @return The optimizer trace output for the last optimized query as a String.
0: 	 *    Null will be returned if optimizer trace output is off or not supported 
0: 	 *    or no trace output was found or an exception occurred.
1: 	 */
0: 	public String getOptimizerTraceOutput();
1: 
1: 	/**
0: 	 * Set the optimizer trace output to the specified String.
0: 	 * (Done at the beginning of each statement.)
1: 	 */
0: 	public void setOptimizerTraceOutput(String startingText);
1: 
1: 	/**
0: 	 * Append the latest output to the optimizer trace output.
1: 	 */
0: 	public void appendOptimizerTraceOutput(String output);
1: 
1:     /**
1: 	  *	Reports whether there is any outstanding work in the transaction.
1: 	  *
1: 	  *	@return		true if there is outstanding work in the transaction
1: 	  *				false otherwise
1: 	  */
1: 	public	boolean	isTransactionPristine();
1: 
1:     /**
0: 	  *	Get the lock handle for the current transaction.
1: 	  *
0: 	  *	@param	lockScope	SINGLE_TRANSACTION_LOCK or MULTI_TRANSACTION_LOCK
1: 	  *
0: 	  *	@return	the current lock handle
1: 	  *
1: 	  * @exception StandardException thrown if something goes wrong
1: 	  */
0: 	public	Object	getLockObject( int lockScope ) throws StandardException;
1: 
1: 	/**
0: 	  *	Get casing for delimited identifiers. This feature is here to
0: 	  *	support the Plugin.
1: 	  *
0: 	  *	@return	ANSI_CASING or ANTI_ANSI_CASING.
1: 	  *
1: 	  * @exception StandardException thrown if something goes wrong
1: 	  */
0:     public	int	getIdentifierCasing() throws StandardException;
1: 
1:     /**
0:      * Convert an identifier to the proper case for this connection. This method
0:      * is here to support the Plugin.
1:      *
0:      * @param	an identifier string
0:      * @return  the string converted to upper or lower case, as appropriate
1:      *
1:      * @exception StandardException thrown if something goes wrong
1:      */
0:     public	String convertIdentifierCase( String id) throws StandardException;
1: 
1: 
1: 	/**
1: 	 * Returns the last autoincrement value inserted by this connection.
1: 	 * If no values have been inserted into the given column a NULL value
1: 	 * is returned.
1: 	 * 
1: 	 * @param schemaName
1: 	 * @param tableName
1: 	 * @param columnName
1: 	 */
1: 	public Long lastAutoincrementValue(String schemaName,
1: 									   String tableName,
1: 									   String columnName);
1: 
1: 	/**
1: 	 * Sets autoincrementUpdate-- this variable allows updates to autoincrement
1: 	 * columns if it is set to true. The default is ofcourse false; i.e 
1: 	 * ai columns cannot be directly modified by the user. This is set to 
1: 	 * true by AlterTableConstantAction, when a new ai column is being added 
1: 	 * to an existing table.
1: 	 * 
1: 	 * @param flag 	the value for autoincrementUpdate (TRUE or FALSE)
0: 	 * @see org.apache.derby.impl.sql.execute.AlterTableConstantAction#updateNewAutoincrementColumn
1: 	 *
1: 	 */
1: 	public void setAutoincrementUpdate(boolean flag);
1: 
1: 	/**
1: 	 * Returns the current value of autoincrementUpdate.
1: 	 *
1: 	 * @return true if updates to autoincrement columns is permitted.
1: 	 */
1: 	public boolean getAutoincrementUpdate();
1: 
1: 	/**
0: 	 * copy a hashtable of autoincrement key value pairs into the cache of 
1: 	 * ai values stored in the language connection context.
1: 	 */
0: 	public void copyHashtableToAIHT(Hashtable from);
1: 	
1: 	/**
1: 	 * returns the <b>next</b> value to be inserted into an autoincrement col.
1: 	 * This is used internally by the system to generate autoincrement values
1: 	 * which are going to be inserted into a autoincrement column. This is
1: 	 * used when as autoincrement column is added to a table by an alter 
1: 	 * table statemenet and during bulk insert.
1: 	 *
1: 	 * @param schemaName
1: 	 * @param tableName
1: 	 * @param columnName identify the column uniquely in the system.
1: 	 *
1: 	 * @exception StandardException on error.
1: 	 */
1: 	public long nextAutoincrementValue(String schemaName, String tableName,
1: 									   String columnName)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Flush the cache of autoincrement values being kept by the lcc.
1: 	 * This will result in the autoincrement values being written to the
1: 	 * SYSCOLUMNS table as well as the mapping used by lastAutoincrementValue
1: 	 * 
1: 	 * @param tableUUID the table which is being flushed; we need this value to
1: 	 * identify the table for which the autoincrement counter is being
1: 	 * maintained.
1: 	 *
1: 	 * @exception StandardException thrown on error.
1: 	 *
1: 	 * @see LanguageConnectionContext#lastAutoincrementValue
1: 	 * @see org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext#lastAutoincrementValue
0: 	 * @see org.apache.derby.iapi.db.ConnectionInfo#lastAutoincrementValue
1: 	 */
1: 	public void autoincrementFlushCache(UUID tableUUID)
1: 		throws StandardException;
1: 
1: 	/**
1: 	 * Create an autoincrement counter to be used on behalf of a SQL-J 
1: 	 * statement. The counter is identified by (schemaName, tableName,
1: 	 * columnName). The counter must be freed up by calling 
1: 	 * autoincrementFlushCache at the end of the statement. It is expected
1: 	 * that a ai-counter with the same signaure doesn't exist when the 
1: 	 * method is called.
1: 	 * 
1: 	 * @param 		s					SchemaName
1: 	 * @param		t					TableName
1: 	 * @param		c					ColumnName
1: 	 * @param		initialValue		initial value of the counter.
1: 	 * @param		increment			increment for the counter.
1: 	 * @param		position			column position (1-based).
1: 	 */
1: 	public void autoincrementCreateCounter(String s, String t, String c,
1: 										   Long initialValue, long increment,
1: 										   int position);
1: 	
1: 	/**
1: 	 * Get the instance number of this LCC.
1: 	 *
1: 	 * @return instance number of this LCC.
1: 	 */
1: 	public int getInstanceNumber();
1: 
1: 	/**
1: 	 * Get the DRDA ID of this LCC.
1: 	 *
1: 	 * @return DRDA ID this LCC.
1: 	 */
1: 	public String getDrdaID();
1: 
1: 	/**
1: 	 * Set the DRDA ID of this LCC.
1: 	 *
0: 	 * @param	DRDA ID.
1: 	 */
1: 	public void setDrdaID(String drdaID);
1: 
1: 	/**
1: 	 * Get the database name of this LCC.
1: 	 *
1: 	 * @return database name of this LCC.
1: 	 */
1: 	public String getDbname();
1: 
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 		Do a commit, as internally needed by Derby.  E.g.
/////////////////////////////////////////////////////////////////////////
1: 		Do a rollback, as internally needed by Derby.  E.g.
author:David Van Couvering
-------------------------------------------------------------------------------
commit:75588ca
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:318307e
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:5ec8510
/////////////////////////////////////////////////////////////////////////
1: 	public boolean usesSqlAuthorization();
commit:2c6ca76
/////////////////////////////////////////////////////////////////////////
0: 	/**
0: 	 * Check if in SQL standard mode, with support for Grant & Revoke
0: 	 *
1: 	 * @return True if SQL standard permissions are being used
0: 	 */
0: 	public boolean usesSqlStandardPermissions();
commit:2dc0b91
/////////////////////////////////////////////////////////////////////////
0:     /**
/////////////////////////////////////////////////////////////////////////
1: 	 * @param allowInternalSyntax If true, then this query is allowed to use internal 
1: 	 *                      sql syntax. One instance where this will be true is if a
1: 	 *                      metadata query is getting executed.
1:          public PreparedStatement prepareInternalStatement(SchemaDescriptor compilationSchema, 
1:          		String sqlText, boolean isForReadOnly, boolean allowInternalSyntax) 
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5087be8
/////////////////////////////////////////////////////////////////////////
1: 	StatementContext pushStatementContext(boolean isAtomic, boolean isForReadOnly, String stmtText,
/////////////////////////////////////////////////////////////////////////
0:         /**
1: 	 * Return a PreparedStatement object for the query.
1: 	 * This method first tries to locate the PreparedStatement object from a statement
1: 	 * cache.  If the statement is not found in the cache, the query will be compiled and
1: 	 * put into the cache.
1: 	 * @param compilationSchema schema
1: 	 * @param sqlText sql query string
1: 	 * @param isForReadOnly read only status for resultset. Set to true if the concurrency mode for the resultset 
1: 	 *                      is CONCUR_READ_ONLY
0: 	 */
0:          public PreparedStatement prepareInternalStatement(SchemaDescriptor compilationSchema, String sqlText, boolean isForReadOnly) 
0: 	    throws StandardException;
0: 
0:         /**
1: 	 * Return a PreparedStatement object for the query.
1: 	 * This method first tries to locate the PreparedStatement object from a statement
1: 	 * cache.  If the statement is not found in the cache, the query will be compiled and 
1: 	 * put into the cache.
1: 	 * The schema used when compiling the statement is the same schema as returned by
1: 	 * getDefaultSchema().  For internal statements, the read only status is set to
1: 	 * true.
1: 	 * Calling this method is equivalent to calling 
1: 	 * prepareExternalStatement(lcc.getDefaultSchema(), sqlText, true);
0: 	 * 
1: 	 * @param sqlText sql query string
0: 	 */
1:         public PreparedStatement prepareInternalStatement(String sqlText) 
0: 	    throws StandardException;
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.conn
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.conn;
0: 
0: import org.apache.derby.iapi.services.context.Context;
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.db.Database;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: import org.apache.derby.iapi.sql.compile.OptimizerFactory;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.sql.depend.Provider;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.CursorActivation;
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionStmtValidator;
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.LanguageFactory;
0: import org.apache.derby.iapi.sql.PreparedStatement;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ParameterValueSet;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.db.TriggerExecutionContext;
0: import org.apache.derby.iapi.services.i18n.LocaleFinder;
0: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
0: import org.apache.derby.catalog.UUID;
0: 
0: import java.util.Locale;
0: import java.util.Hashtable;
0: import java.util.Vector;
0: import java.math.BigDecimal;
0: 
0: /**
0:  * LanguageConnectionContext keeps the result sets,
0:  * and activations in use by the current connection.
0:  * <p>
0:  * More stable items, like other factories, are accessible through
0:  * the LanguageConnectionFactory or the LanguageFactory.
0:  *
0:  * @see LanguageConnectionFactory
0:  * @see org.apache.derby.iapi.sql.LanguageFactory
0:  */
0: public interface LanguageConnectionContext extends Context {
0: 
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/**
0: 	 * this is the ID we expect these contexts
0: 	 * to be stored into a context manager under.
0: 	 */
0: 	public static final String CONTEXT_ID = org.apache.derby.iapi.reference.ContextId.LANG_CONNECTION;
0: 
0: 	public	static	final	int	OUTERMOST_STATEMENT = 1;
0: 
0:     // Constants describing how this connection handles schemas
0:     public static final int SQL92_SCHEMAS = 0;
0:     public static final int USER_NAME_SCHEMA = 1; // User names are schema names.
0:     public static final int NO_SCHEMAS = 2; // Schemas not implemented.
0: 
0: 	/* String for logStatementText output */
0: 	public static final String xidStr = "(XID = ";
0: 	public static final String lccStr = "(SESSIONID = ";
0: 	public static final String dbnameStr = "(DATABASE = ";
0: 	public static final String drdaStr = "(DRDAID = ";
0: 
0: 	// Lock Management
0: 
0: 	public	static	final	int	SINGLE_TRANSACTION_LOCK = 1;
0: 	public	static	final	int	MULTI_TRANSACTION_LOCK = 2;
0: 
0: 	// controls casing of NON-delimited identifiers. ANSI casing forces all
0: 	// non-delimited identifiers to be lower case.
0: 
0: 	public	static	final	int	UNKNOWN_CASING = -1;
0: 	public	static	final	int	ANSI_CASING = 0;
0: 	public	static	final	int	ANTI_ANSI_CASING = 1;
0: 
0: 	/**
0: 	 * Initialize. For use after pushing the contexts that initialization needs.
0: 	 *
0: 	 * @param sqlConnection	Whether or not this is called from a sql connection.
0: 	 *
0: 	 * @exception StandardException thrown if something goes wrong
0: 	 */
0: 	void initialize(boolean sqlConnection) throws StandardException;
0: 
0: 	/**
0: 	 * Get value of logStatementText.
0: 	 * (Whether or not to write info on currently
0: 	 * executing statement to error log.)
0: 	 *
0: 	 * @return value of logStatementText
0: 	 */
0: 	public boolean getLogStatementText();
0: 
0: 	/**
0: 	 * Set value of logStatementText
0: 	 * (Whether or not to write info on currently
0: 	 * executing statement to error log.)
0: 	 *
0: 	 * @param logStatementText	Whether or not logStatementText property is set.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setLogStatementText(boolean logStatementText);
0: 
0: 	/**
0: 	 * Get value of logQueryPlan.
0: 	 * (Whether or not to write query plan info on currently
0: 	 * executing statement to error log.)
0: 	 *
0: 	 * @return value of logQueryPlan
0: 	 */
0: 	public boolean getLogQueryPlan();
0: 
0: 	/**
0: 	 * get the lock escalation threshold to use with this connection.
0: 	 */
0: 	int getLockEscalationThreshold();
0: 
0: 	/**
0: 	 * Add the activation to those known about by this connection.
0: 	 *
0: 	 */
0: 	void addActivation(Activation a);
0: 
0: 	/**
0: 	 * Remove the activation from those known about by this connection.
0: 	 *
0: 	 * @exception StandardException thrown if something goes wrong
0: 	 */
0: 	void removeActivation(Activation a)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Return the number of activation known for this connection.
0: 	 *
0: 	 */
0: 	int getActivationCount();
0: 
0: 	/**
0: 	 * See if a given cursor is available for use.  This is used
0: 	 * to locate the cursor during its execution.
0: 	 *
0: 	 * @return the activation for the given cursor, null if none exists.
0: 	 */
0: 	CursorActivation lookupCursorActivation(String cursorName);
0: 
0: 	/**
0: 	 * Return the last activation added
0: 	 * This is used to find the drop activation in dropViewCascade
0: 	 * so we can add warning messages to the activation
0: 	 *
0: 	 */
0: 	public Activation getLastActivation();
0: 
0: 	/**
0: 		Get a connection unique system generated name for a cursor.
0: 	*/
0: 	public String getUniqueCursorName();
0: 
0: 	/**
0: 		Get a connection unique system generated name for an unnamed savepoint.
0: 	*/
0: 	public String getUniqueSavepointName();
0: 
0: 	/**
0: 		Get a connection unique system generated id for an unnamed savepoint.
0: 	*/
0: 	public int getUniqueSavepointID();
0: 
0: 	/**
0: 	 * Check if there are any global temporary tables declared for this connection.
0: 	 * @return true if there are declared temp tables for this connectoin else false
0: 	 *
0: 	 */
0: 	public boolean checkIfAnyDeclaredGlobalTempTablesForThisConnection();
0: 
0: 	/**
0: 	 * Mark the passed temporary table as modified in the current unit of work. That information will be used at rollback time
0: 	 * The compile phase will generate code to call this method if the DML is on a temporary table
0: 	 *
0: 	 * @param String tableName Mark the passed temporary table name as modified
0: 	 */
0: 	public void markTempTableAsModifiedInUnitOfWork(String tableName);
0:   
0: 	/**
0: 	 * Add the declared global temporary table to the list of temporary tables known by this connection.
0: 	 * @param TableDescriptor td Corresponding to the temporary table
0: 	 *
0: 	 */
0: 	public void addDeclaredGlobalTempTable(TableDescriptor td) throws StandardException;
0: 
0: 	/**
0: 	 * Drop (mark the declared global temporary table for dropping) from the list of temporary tables known by this connection.
0: 	 * @param String tableName look for this table name in the saved list and drop it if found
0: 	 * @return true if dropped the temporary table. False if no such temporary table exists.
0: 	 *
0: 	 * @see org.apache.derby.impl.sql.conn.TempTableInfo
0: 	 */
0: 	public boolean dropDeclaredGlobalTempTable(String tableName);
0: 
0: 	/**
0: 	 * Get table descriptor for the declared global temporary table from the list of temporary
0: 	 * tables known by this connection.
0: 	 * @param String tableName Get table descriptor for the passed table name
0: 	 * @return TableDescriptor if found the temporary table. Else return null
0: 	 *
0: 	 */
0: 	public TableDescriptor getTableDescriptorForDeclaredGlobalTempTable(String tableName);
0: 
0: 	/**
0: 	 * Drop all the declared global temporary tables associated with this connection. This gets called
0: 	 * when a getConnection() is done on a PooledConnection. This will ensure all the temporary tables
0: 	 * declared on earlier connection handle associated with this physical database connection are dropped
0: 	 * before a new connection handle is issued on that same physical database connection.
0: 	 */
0: 	public void dropAllDeclaredGlobalTempTables()
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Do a commit, as internally needed by Cloudscape.  E.g.
0: 	 	a commit for sync, or a commit for autocommit.  Skips
0: 		checks that a user isn't doing something bad like issuing
0: 		a commit in a nested xact.
0: 
0: 		@param	commitStore	true if we should commit the Store transaction
0: 
0: 		@return	the commit instant
0: 
0: 		@exception StandardException thrown if something goes wrong
0: 	 */
0: 	void internalCommit( boolean commitStore )
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Similar to internalCommit() but has logic for an unsynchronized commit
0: 
0: 		@param	commitflag	the flags to pass to commitNoSync in the store's
0: 							TransactionController
0: 
0: 		@return	the commit instant
0: 
0: 		@exception StandardException	thrown if something goes wrong
0: 	 */
0: 	void internalCommitNoSync(int commitflag) throws StandardException;
0: 
0: 	/**
0: 		Do a commit, as issued directly by a user (e.g. via Connection.commit()
0: 		or the JSQL 'COMMIT' statement.
0: 
0: 		@return	the commit instant
0: 
0: 		@exception StandardException thrown if something goes wrong
0: 	 */
0: 	void userCommit() throws StandardException;
0: 
0: 	/**
0: 		Commit a distrubuted transaction.
0: 
0: 		@param onePhase if true, allow it to commit without first going thru a
0: 		prepared state.
0: 
0: 		@return	the commit instant
0: 
0: 		@exception StandardException	thrown if something goes wrong
0: 	 */
0: 	void xaCommit(boolean onePhase) throws StandardException;
0: 
0: 
0: 	/**
0: 		Do a rollback, as internally needed by Cloudscape.  E.g.
0: 	 	a rollback for sync, or a rollback for an internal error.  Skips
0: 		checks that a user isn't doing something bad like issuing
0: 		a rollback in a nested xact.
0: 
0: 		@exception StandardException thrown if something goes wrong
0: 	 */
0: 	void internalRollback() throws StandardException;
0: 
0: 	/**
0: 		Do a rollback, as issued directly by a user (e.g. via Connection.rollback()
0: 		or the JSQL 'ROLLBACK' statement.
0: 
0: 		@exception StandardException thrown if something goes wrong
0: 	 */
0: 	void userRollback() throws StandardException;
0: 
0: 	/**
0: 	 * Let the context deal with a rollback to savepoint
0: 	 *
0: 	 * @param	savepointName	Name of the savepoint that needs to be rolled back
0: 	 * @param	refreshStyle	boolean indicating whether or not the controller should close
0: 	 * open conglomerates and scans. Also used to determine if language should close
0: 	 * open activations.
0: 	 * @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
0: 	 * Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
0: 	 *   A String value for kindOfSavepoint would mean it is SQL savepoint
0: 	 *   A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
0: 	 *
0: 	 * @exception StandardException thrown if something goes wrong
0: 	 */
0: 	void internalRollbackToSavepoint
0: 	( String savepointName, boolean refreshStyle, Object kindOfSavepoint ) throws StandardException;
0: 
0: 	/**
0: 	 * Let the context deal with a release of a savepoint
0: 	 *
0: 	 * @param	savepointName	Name of the savepoint that needs to be released
0: 	 * @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
0: 	 * Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
0: 	 *   A String value for kindOfSavepoint would mean it is SQL savepoint
0: 	 *   A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
0: 	 *
0: 	 * @exception StandardException thrown if something goes wrong
0: 	 */
0: 	void releaseSavePoint ( String savepointName, Object kindOfSavepoint ) throws StandardException;
0: 
0: 
0: 	/**
0: 		Roll back a distrubuted transaction.
0: 
0: 		@exception StandardException	thrown if something goes wrong
0: 	 */
0: 	void xaRollback() throws StandardException;
0: 
0: 	/**
0: 	  Sets a savepoint. Causes the Store to set a savepoint.
0: 
0: 	  @param	savepointName	name of savepoint
0: 	  @param	kindOfSavepoint	 A NULL value means it is an internal savepoint (ie not a user defined savepoint)
0: 	  Non NULL value means it is a user defined savepoint which can be a SQL savepoint or a JDBC savepoint
0: 	  A String value for kindOfSavepoint would mean it is SQL savepoint
0: 	  A JDBC Savepoint object value for kindOfSavepoint would mean it is JDBC savepoint
0: 
0: 		@exception StandardException thrown if something goes wrong
0: 	  */
0: 	void	languageSetSavePoint( String savepointName, Object kindOfSavepoint )  throws StandardException;
0: 
0: 	/**
0: 		Returns true if any transaction is blocked (even if not by this one)
0: 
0: 	 */
0: 	boolean anyoneBlocked();
0: 
0: 	/**
0: 		Sets the transaction controller to use with this language connection
0: 		context.
0: 
0: 		@param	tran	the transaction to use with this language connection context
0: 	 */
0: 	void setTransaction( TransactionController tran );
0: 
0: 	/**
0: 	 * Begin a nested transaction.
0: 	 *
0: 	 * @param readOnly The nested transaction would be read only if param value true
0: 	 *
0: 	 * @exception StandardException on error.
0: 	 * @see TransactionController#startNestedUserTransaction
0: 	 */
0: 
0: 	void beginNestedTransaction(boolean readOnly) throws StandardException;
0: 
0: 	/**
0: 	 * commit a nested transaction.
0: 	 * We do not provide a abortNestedTransaction. 
0: 	 * If a nested xaction is aborted, then this results in the parent xaction
0: 	 * also being aborted. This is not what we need for releasing
0: 	 * compile time locks or autoincrement-- hence we do not provide 
0: 	 * abortNestedTransaction. 
0: 	 *
0: 	 * @exception StandardException thrown on erro
0: 	 *
0: 	 * @see TransactionController#startNestedUserTransaction
0: 	 */
0: 	void commitNestedTransaction() throws StandardException;
0: 
0: 	/**
0: 		Get the transaction controller to use with this language connection
0: 		context at compile time.
0: 	 */
0: 	TransactionController getTransactionCompile();
0: 
0: 	/**
0: 		Get the transaction controller to use with this language connection
0: 		context during execute time.
0: 	 */
0: 
0: 	TransactionController getTransactionExecute();
0: 
0:     /**
0:      * Get the system schema name.
0:      *
0:      * @return a String containing the system schema name.
0:      */
0:     public String getSystemSchemaName() throws StandardException;
0:     
0:     /**
0:      * Get the SYSIBM schema name.
0:      *
0:      * @return a String containing the SYSIBM schema name.
0:      */
0:     public String getSysIBMSchemaName() throws StandardException;
0: 
0:     /**
0:      * Get the SYSCS_DIAG schema name.
0:      *
0:      * @return a String containing the SYSIBM schema name.
0:      */
0:     public String getSystemDiagSchemaName() throws StandardException;
0: 
0:     /**
0:      * Get the SYSCS_UTIL schema name.
0:      *
0:      * @return a String containing the SYSIBM schema name.
0:      */
0:     public String getSystemUtilSchemaName() throws StandardException;
0:     
0: 	/**
0: 		Get the data dictionary 
0: 
0: 		@return the data dictionary
0: 
0: 	 */
0: 	public DataDictionary getDataDictionary();
0: 
0: 	/**
0: 		Get the data value factory to use with this language connection
0: 		context.
0: 	 */
0: 	DataValueFactory getDataValueFactory();
0: 
0: 	/**
0: 		Get the language factory to use with this language connection
0: 		context.
0: 	 */
0: 	LanguageFactory getLanguageFactory();
0: 
0: 	/**
0: 	 * get the optimizer factory to use with this language connection context.
0: 	 */
0: 	OptimizerFactory getOptimizerFactory();
0: 	
0: 	/**
0: 		Get the language connection factory to use with this language connection
0: 		context.
0: 	 */
0: 	LanguageConnectionFactory getLanguageConnectionFactory();
0: 
0: 	/**
0: 	 *	Get the Authorization Id
0: 	 *
0: 	 * @return String	the authorization id
0: 	 */
0: 	public String getAuthorizationId();
0: 
0:     /**
0:      * Get the declared global temporary tables schema name.
0:      *
0:      * @return a String containing the declared global temporary tables schema name.
0:      */
0:     public String getDeclaredGlobalTemporaryTablesSchemaName() throws StandardException;
0:   
0: 	/**
0: 	 *	Get the current default schema
0: 	 *
0: 	 * @return SchemaDescriptor	the current schema
0: 	 */
0: 	public SchemaDescriptor getDefaultSchema(); 
0: 
0: 	/**
0: 	 *	Set the current default schema
0: 	 *
0: 	 * @param SchemaDescriptor	the new default schema
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public void setDefaultSchema(SchemaDescriptor sd)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 *	Get the current schema name
0: 	 *
0: 	 * @return SchemaDescriptor	the current schema
0: 	 */
0: 	public String getCurrentSchemaName();
0: 
0: 	/**
0: 	 * Get the identity column value most recently generated.
0: 	 *
0: 	 * @return the generated identity column value
0: 	 */
0: 	public BigDecimal getIdentityValue();
0: 
0: 	/**
0: 	 * Set the field of most recently generated identity column value.
0: 	 *
0: 	 * @param the generated identity column value
0: 	 */
0: 	public void setIdentityValue(long val);
0: 
0: 	/**
0: 	 * Verify that there are no activations with open result sets
0: 	 * on the specified prepared statement.
0: 	 *
0: 	 * @param pStmt		The prepared Statement
0: 	 * @param provider	The object precipitating a possible invalidation
0: 	 * @param action	The action causing the possible invalidation
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	boolean verifyNoOpenResultSets(PreparedStatement pStmt, Provider provider, 
0: 									   int action)
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * Verify that there are no activations with open held result sets.
0: 	 *
0: 	 * @return boolean  Found no open resultsets.
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public boolean verifyAllHeldResultSetsAreClosed()
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * Push a CompilerContext on the context stack with
0: 	 * the current default schema as the default schema
0: 	 * which we compile against.
0: 	 *
0: 	 * @return the compiler context
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public	CompilerContext pushCompilerContext();
0: 
0: 	/**
0: 	 * Push a CompilerContext on the context stack with
0: 	 * the passed in default schema as the default schema
0: 	 * we compile against.
0: 	 *
0: 	 * @param sd the default schema 
0: 	 *
0: 	 * @return the compiler context
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public	CompilerContext pushCompilerContext(SchemaDescriptor sd);
0: 
0: 	/**
0: 	 * Pop a CompilerContext off the context stack.
0: 	 *
0: 	 * @param compilerContext  The compiler context.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	public void popCompilerContext(CompilerContext compilerContext);
0: 
0: 	/**
0: 	 * Push a StatementContext on the context stack.
0: 	 *
0: 	 * @param isAtomic whether a commit/rollback is permitted
0: 	 *	from a nested connection under this statement
0: 	 *
0: 	 * @param stmtText the text of the statement.  Needed for any language
0: 	 * 	statement (currently, for any statement that can cause a trigger
0: 	 * 	to fire).  Please set this unless you are some funky jdbc setXXX
0: 	 *	method or something.
0: 	 *
0: 	 * @param pvs parameter value set, if it has one
0: 	 *
0: 	 * @param rollbackParentContext True if 1) the statement context is
0: 	 * 	NOT a top-level context, AND 2) in the event of a statement-level
0: 	 *	exception, the parent context needs to be rolled back, too.
0: 	 *
0: 	 * @return StatementContext	The statement context.
0: 	 *
0: 	 */
0: 	StatementContext pushStatementContext(boolean isAtomic, String stmtText,
0: 		ParameterValueSet pvs, boolean rollbackParentContext);
0: 
0: 	/**
0: 	 * Pop a StatementContext of the context stack.
0: 	 *
0: 	 * @param statementContext  The statement context.
0: 	 * @param error				The error, if any  (Only relevant for DEBUG)
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 */
0: 	public void popStatementContext(StatementContext statementContext,
0: 									Throwable error);
0: 
0: 	/**
0: 	 * Push a new execution statement validator.  An execution statement 
0: 	 * validator is an object that validates the current statement to
0: 	 * ensure that it is permitted given the current execution context.
0: 	 * An example of a validator a trigger ExecutionStmtValidator that
0: 	 * doesn't allow ddl on the trigger target table.
0: 	 * <p>
0: 	 * Multiple ExecutionStmtValidators may be active at any given time.
0: 	 * This mirrors the way there can be multiple connection nestings
0: 	 * at a single time.  The validation is performed by calling each
0: 	 * validator's validateStatement() method.  This yields the union
0: 	 * of all validations.
0: 	 *
0: 	 * @param validator the validator to add
0: 	 */
0: 	public void pushExecutionStmtValidator(ExecutionStmtValidator validator);
0: 
0: 	/**
0: 	 * Remove the validator.  Does an object identity (validator == validator)
0:  	 * comparison.  Asserts that the validator is found.
0: 	 *
0: 	 * @param validator the validator to remove
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void popExecutionStmtValidator(ExecutionStmtValidator validator)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Validate a statement.  Does so by stepping through all the validators
0: 	 * and executing them.  If a validator throws and exception, then the
0: 	 * checking is stopped and the exception is passed up.
0: 	 *
0: 	 * @param constantAction the constantAction that is about to be executed (and
0: 	 *	should be validated
0:  	 *
0: 	 * @exception StandardException on validation failure
0: 	 */
0: 	public void validateStmtExecution(ConstantAction constantAction)
0: 		throws StandardException;
0: 	
0: 	/**
0: 	 * Push a new trigger execution context.
0: 	 * <p>
0: 	 * Multiple TriggerExecutionContexts may be active at any given time.
0: 	 *
0: 	 * @param tec the trigger execution context
0: 	 *
0: 	 * @exception StandardException on trigger recursion error
0: 	 */
0: 	public void pushTriggerExecutionContext(TriggerExecutionContext tec)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Remove the tec.  Does an object identity (tec == tec)
0:  	 * comparison.  Asserts that the tec is found.
0: 	 *
0: 	 * @param tec the tec to remove
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void popTriggerExecutionContext(TriggerExecutionContext tec)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Get the topmost tec.  
0: 	 *
0: 	 * @return the tec
0: 	 */
0: 	public TriggerExecutionContext getTriggerExecutionContext();
0: 
0: 	/**
0: 	 * Set the trigger table descriptor.  Used to compile
0: 	 * statements that may special trigger pseudo tables.
0: 	 *
0: 	 * @param td the table that the trigger is 
0: 	 * defined upon
0: 	 *
0: 	 */
0: 	public void pushTriggerTable(TableDescriptor td);
0: 
0: 	/**
0: 	 * Remove the trigger table descriptor.
0: 	 *
0: 	 * @param td the table to remove from the stack.
0: 	 */
0: 	public void popTriggerTable(TableDescriptor td);
0: 
0: 	/**
0: 	 * Get the topmost trigger table descriptor
0: 	 *
0: 	 * @return the table descriptor, or null if we
0: 	 * aren't in the middle of compiling a create
0: 	 * trigger.
0: 	 */
0: 	public TableDescriptor getTriggerTable();
0: 
0: 	/**
0: 	 * Increment the DataDictionary bind count.  This is for keeping track
0: 	 * of nested binding, which can happen if SQL statements are bound from
0: 	 * within static initializers.
0: 	 *
0: 	 * @return	The new bind count
0: 	 */
0: 	int incrementBindCount();
0: 
0: 	/**
0: 	 * Decrement the DataDictionary bind count.
0: 	 *
0: 	 * @return	The new bind count
0: 	 */
0: 	int decrementBindCount();
0: 
0: 	/**
0: 	 * Get the DataDictionary bind count.
0: 	 *
0: 	 * @return	The current bind count.
0: 	 */
0: 	int getBindCount();
0: 
0: 	/**
0: 	 * Remember that the DataDictionary is in write mode, so we can take
0: 	 * it out of write mode at the end of the transaction.
0: 	 */
0: 	void setDataDictionaryWriteMode();
0: 
0: 	/**
0: 	 * Return true if the data dictionary is in write mode (that is, this
0: 	 * context was informed that is is in write mode by the method call
0: 	 * setDataDictionaryWriteMode().
0: 	 */
0: 	boolean dataDictionaryInWriteMode();
0: 
0: 	/**
0: 	 * Turn RUNTIMESTATISTICS  on or off.
0: 	 */
0: 	public void setRunTimeStatisticsMode(boolean onOrOff);
0: 
0: 	/**
0: 	 * Get the RUNTIMESTATISTICS mode.
0: 	 */
0: 	public boolean getRunTimeStatisticsMode();
0: 
0: 	/**
0: 	 * Turn STATISTICS TIMING on or off.
0: 	 */
0: 	public void setStatisticsTiming(boolean onOrOff);
0: 
0: 	/**
0: 	 * Get the STATISTICS TIMING mode.
0: 	 */
0: 	public boolean getStatisticsTiming();
0: 
0: 	/** 
0: 	 * Set the RUNTIMESTATISTICS object. 
0: 	 */
0: 	public void setRunTimeStatisticsObject(RunTimeStatistics runTimeStatisticsObject);
0: 
0: 	/** 
0: 	 * Get the RUNTIMESTATISTICS object. 
0: 	 */
0: 	public RunTimeStatistics getRunTimeStatisticsObject();
0: 
0: 
0:     /**
0: 	  *	Reports how many statement levels deep we are.
0: 	  *
0: 	  *	@return	a statement level >= OUTERMOST_STATEMENT
0: 	  */
0: 	public	int		getStatementDepth();
0: 
0: 	/**
0: 	  Returns the Database of this connection.
0:      */
0:     public Database getDatabase();
0: 
0: 	/**
0: 	 * Set current isolation level.
0: 	 * 
0: 	 * @param isolationLevel	The new isolationLevel.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setIsolationLevel(int isolationLevel) throws StandardException;
0: 
0: 	/**
0: 	 * Get the current isolation level.
0: 	 *
0: 	 * @return The current isolation level.
0: 	 */
0: 	public int getCurrentIsolationLevel();
0: 
0: 	/**
0: 	 * Get the current isolation level in DB2 format.
0: 	 *
0: 	 * @return The current isolation level as a 2 character string.
0: 	 */
0: 	public String getCurrentIsolationLevelStr();
0: 	public void setPrepareIsolationLevel(int isolationLevel) ;
0: 
0: 	/**
0: 	 * Get the prepare isolation level.
0: 	 * If the isolation level has been explicitly set with a SQL statement or
0: 	 * embedded call to setTransactionIsolation, this will return
0: 	 * ExecutionContext.UNSPECIFIED_ISOLATION_LEVEL 
0: 	 * SET ISOLATION always takes priority.
0: 	 * 
0: 	 */
0: 	public int getPrepareIsolationLevel();
0: 
0: 	/**
0: 	 * Set the readOnly status for the current connection. This can
0: 	 * only be called when the current transaction has not done
0: 	 * any work.
0: 	 *
0: 	 * @param onOrOff true sets the connection to be readOnly and
0: 	 *                false sets it to readWrite.
0: 	 *
0: 	 * @exception StandardException The call failed and the readOnly
0: 	 *                status has not changed.
0: 	 */
0: 	public void setReadOnly(boolean onOrOff) throws StandardException;
0: 
0: 	/**
0: 	  * Get the readOnly status for the current connection. 
0: 	  */
0: 	public boolean isReadOnly();
0: 
0: 	/**
0: 	 * Get an Authorizer for this connection.
0: 	 */
0: 	public Authorizer getAuthorizer(); 
0: 
0: 	/**
0: 	 *	Get the current ExecutionContext.
0: 	 */
0: 	ExecutionContext getExecutionContext();
0: 
0: 	/**
0: 	 *	Get the current StatementContext.
0: 	 */
0: 	StatementContext getStatementContext();
0: 
0: 	/** Get the AccessFactory cached in this LanguageConnectionContext */
0: 	AccessFactory getAccessFactory();
0: 
0: 	/**
0: 		Return a compiled Statement object. The schema and unicode
0: 		setting fo the returned statement are that of this connection.
0: 	*/
0: 	public PreparedStatement prepareInternalStatement(String sqlText) throws StandardException;
0: 	public PreparedStatement prepareInternalStatement(SchemaDescriptor compilationSchema, String sqlText) throws StandardException;
0: 
0: 	/**
0: 	 * Control whether or not optimizer trace is on.
0: 	 *
0: 	 * @param onOrOff    Whether to turn optimizer trace on (true) or off (false).
0: 	 *
0: 	 * @return Whether or not the call was successful.  (false will be returned when optimizer tracing is not supported.)
0: 	 */
0: 	public boolean setOptimizerTrace(boolean onOrOff);
0: 
0: 	/** 
0: 	 * Get whether or not optimizer trace is on.
0: 	 *
0: 	 * @return Whether or not optimizer trace is on.
0: 	 */
0: 	public boolean getOptimizerTrace();
0: 
0: 	/**
0: 	 * Control whether or not optimizer trace is generated in html.
0: 	 *
0: 	 * @param onOrOff    Whether or not optimizer trace will be in html (true) or not (false).
0: 	 *
0: 	 * @return Whether or not the call was successful.  (false will be returned when optimizer tracing is not supported.)
0: 	 */
0: 	public boolean setOptimizerTraceHtml(boolean onOrOff);
0: 
0: 	/** 
0: 	 * Get whether or not optimizer trace html is on.
0: 	 *
0: 	 * @return Whether or not optimizer trace html is on.
0: 	 */
0: 	public boolean getOptimizerTraceHtml();
0: 
0: 	/**
0: 	 * Get the optimizer trace output for the last optimized query as a String.  If optimizer trace
0: 	 * html is on, then the String will contain the html tags.
0: 	 *
0: 	 * @return The optimizer trace output for the last optimized query as a String.
0: 	 *    Null will be returned if optimizer trace output is off or not supported 
0: 	 *    or no trace output was found or an exception occurred.
0: 	 */
0: 	public String getOptimizerTraceOutput();
0: 
0: 	/**
0: 	 * Set the optimizer trace output to the specified String.
0: 	 * (Done at the beginning of each statement.)
0: 	 */
0: 	public void setOptimizerTraceOutput(String startingText);
0: 
0: 	/**
0: 	 * Append the latest output to the optimizer trace output.
0: 	 */
0: 	public void appendOptimizerTraceOutput(String output);
0: 
0:     /**
0: 	  *	Reports whether there is any outstanding work in the transaction.
0: 	  *
0: 	  *	@return		true if there is outstanding work in the transaction
0: 	  *				false otherwise
0: 	  */
0: 	public	boolean	isTransactionPristine();
0: 
0:     /**
0: 	  *	Get the lock handle for the current transaction.
0: 	  *
0: 	  *	@param	lockScope	SINGLE_TRANSACTION_LOCK or MULTI_TRANSACTION_LOCK
0: 	  *
0: 	  *	@return	the current lock handle
0: 	  *
0: 	  * @exception StandardException thrown if something goes wrong
0: 	  */
0: 	public	Object	getLockObject( int lockScope ) throws StandardException;
0: 
0: 	/**
0: 	  *	Get casing for delimited identifiers. This feature is here to
0: 	  *	support the Plugin.
0: 	  *
0: 	  *	@return	ANSI_CASING or ANTI_ANSI_CASING.
0: 	  *
0: 	  * @exception StandardException thrown if something goes wrong
0: 	  */
0:     public	int	getIdentifierCasing() throws StandardException;
0: 
0:     /**
0:      * Convert an identifier to the proper case for this connection. This method
0:      * is here to support the Plugin.
0:      *
0:      * @param	an identifier string
0:      * @return  the string converted to upper or lower case, as appropriate
0:      *
0:      * @exception StandardException thrown if something goes wrong
0:      */
0:     public	String convertIdentifierCase( String id) throws StandardException;
0: 
0: 
0: 	/**
0: 	 * Returns the last autoincrement value inserted by this connection.
0: 	 * If no values have been inserted into the given column a NULL value
0: 	 * is returned.
0: 	 * 
0: 	 * @param schemaName
0: 	 * @param tableName
0: 	 * @param columnName
0: 	 */
0: 	public Long lastAutoincrementValue(String schemaName,
0: 									   String tableName,
0: 									   String columnName);
0: 
0: 	/**
0: 	 * Sets autoincrementUpdate-- this variable allows updates to autoincrement
0: 	 * columns if it is set to true. The default is ofcourse false; i.e 
0: 	 * ai columns cannot be directly modified by the user. This is set to 
0: 	 * true by AlterTableConstantAction, when a new ai column is being added 
0: 	 * to an existing table.
0: 	 * 
0: 	 * @param flag 	the value for autoincrementUpdate (TRUE or FALSE)
0: 	 * @see org.apache.derby.impl.sql.execute.AlterTableConstantAction#updateNewAutoincrementColumn
0: 	 *
0: 	 */
0: 	public void setAutoincrementUpdate(boolean flag);
0: 
0: 	/**
0: 	 * Returns the current value of autoincrementUpdate.
0: 	 *
0: 	 * @return true if updates to autoincrement columns is permitted.
0: 	 */
0: 	public boolean getAutoincrementUpdate();
0: 
0: 	/**
0: 	 * copy a hashtable of autoincrement key value pairs into the cache of 
0: 	 * ai values stored in the language connection context.
0: 	 */
0: 	public void copyHashtableToAIHT(Hashtable from);
0: 	
0: 	/**
0: 	 * returns the <b>next</b> value to be inserted into an autoincrement col.
0: 	 * This is used internally by the system to generate autoincrement values
0: 	 * which are going to be inserted into a autoincrement column. This is
0: 	 * used when as autoincrement column is added to a table by an alter 
0: 	 * table statemenet and during bulk insert.
0: 	 *
0: 	 * @param schemaName
0: 	 * @param tableName
0: 	 * @param columnName identify the column uniquely in the system.
0: 	 *
0: 	 * @exception StandardException on error.
0: 	 */
0: 	public long nextAutoincrementValue(String schemaName, String tableName,
0: 									   String columnName)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Flush the cache of autoincrement values being kept by the lcc.
0: 	 * This will result in the autoincrement values being written to the
0: 	 * SYSCOLUMNS table as well as the mapping used by lastAutoincrementValue
0: 	 * 
0: 	 * @param tableUUID the table which is being flushed; we need this value to
0: 	 * identify the table for which the autoincrement counter is being
0: 	 * maintained.
0: 	 *
0: 	 * @exception StandardException thrown on error.
0: 	 *
0: 	 * @see LanguageConnectionContext#lastAutoincrementValue
0: 	 * @see org.apache.derby.impl.sql.conn.GenericLanguageConnectionContext#lastAutoincrementValue
0: 	 * @see org.apache.derby.iapi.db.ConnectionInfo#lastAutoincrementValue
0: 	 */
0: 	public void autoincrementFlushCache(UUID tableUUID)
0: 		throws StandardException;
0: 
0: 	/**
0: 	 * Create an autoincrement counter to be used on behalf of a SQL-J 
0: 	 * statement. The counter is identified by (schemaName, tableName,
0: 	 * columnName). The counter must be freed up by calling 
0: 	 * autoincrementFlushCache at the end of the statement. It is expected
0: 	 * that a ai-counter with the same signaure doesn't exist when the 
0: 	 * method is called.
0: 	 * 
0: 	 * @param 		s					SchemaName
0: 	 * @param		t					TableName
0: 	 * @param		c					ColumnName
0: 	 * @param		initialValue		initial value of the counter.
0: 	 * @param		increment			increment for the counter.
0: 	 * @param		position			column position (1-based).
0: 	 */
0: 	public void autoincrementCreateCounter(String s, String t, String c,
0: 										   Long initialValue, long increment,
0: 										   int position);
0: 	
0: 	/**
0: 	 * Get the instance number of this LCC.
0: 	 *
0: 	 * @return instance number of this LCC.
0: 	 */
0: 	public int getInstanceNumber();
0: 
0: 	/**
0: 	 * Get the DRDA ID of this LCC.
0: 	 *
0: 	 * @return DRDA ID this LCC.
0: 	 */
0: 	public String getDrdaID();
0: 
0: 	/**
0: 	 * Set the DRDA ID of this LCC.
0: 	 *
0: 	 * @param	DRDA ID.
0: 	 */
0: 	public void setDrdaID(String drdaID);
0: 
0: 	/**
0: 	 * Get the database name of this LCC.
0: 	 *
0: 	 * @return database name of this LCC.
0: 	 */
0: 	public String getDbname();
0: 
0: }
============================================================================