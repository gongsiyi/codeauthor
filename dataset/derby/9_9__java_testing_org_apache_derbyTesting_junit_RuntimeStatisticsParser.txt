1:9f0e445: /*
1:9f0e445:  *
1:70b8905:  * Derby - Class org.apache.derbyTesting.functionTests.util.RuntimeStatisticsParser
1:9f0e445:  *
1:9f0e445:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:9f0e445:  * contributor license agreements.  See the NOTICE file distributed with
1:9f0e445:  * this work for additional information regarding copyright ownership.
1:9f0e445:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:9f0e445:  * (the "License"); you may not use this file except in compliance with
1:9f0e445:  * the License.  You may obtain a copy of the License at
1:9f0e445:  *
1:9f0e445:  *    http://www.apache.org/licenses/LICENSE-2.0
1:9f0e445:  *
1:9f0e445:  * Unless required by applicable law or agreed to in writing, 
1:9f0e445:  * software distributed under the License is distributed on an 
1:9f0e445:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:9f0e445:  * either express or implied. See the License for the specific 
1:9f0e445:  * language governing permissions and limitations under the License.
1:9f0e445:  */
1:9f0e445: package org.apache.derbyTesting.junit;
3:9f0e445: 
1:9f0e445: import java.sql.Connection;
1:cd1bd87: import java.util.HashSet;
1:cd1bd87: import java.util.StringTokenizer;
1:1a36302: 
1:9f0e445: public class RuntimeStatisticsParser {
1:9f0e445: 
1:9f0e445:     private int isolationLevel = Connection.TRANSACTION_NONE;
1:0b2eeba:     private boolean distinctScan = false;
1:0b2eeba:     private boolean eliminatedDuplicates = false;
1:0b2eeba:     private boolean tableScan = false;
1:7257ae6:     private final boolean indexScan;
1:7257ae6:     private final boolean indexRowToBaseRow;
1:57191b4: 	private final boolean lastKeyIndexScan;
1:0b2eeba:     private String statistics = "";
1:1d94b69:     private boolean scrollInsensitive = false;
1:2510115:     private final HashSet<Qualifier> qualifiers;
1:1a36302:     private String [] startPosition = {"None"};
1:1a36302:     private String [] stopPosition = {"None"};
1:9f0e445: 
1:9f0e445:     /**
1:9f0e445:      * Create a RuntimeStatistics object to parse the text and extract
1:7257ae6:      * information.
1:9f0e445:      * 
1:9f0e445:      * @param rts
1:9f0e445:      *            Runtime Statistics string
1:9f0e445:      * 
1:9f0e445:      */
1:9f0e445:     public RuntimeStatisticsParser(String rts) {
1:0b2eeba:     	statistics = rts;
1:9f0e445:         if (rts.indexOf(" at serializable isolation level ") != -1)
1:9f0e445:             isolationLevel = Connection.TRANSACTION_SERIALIZABLE;
1:9f0e445:         else if (rts.indexOf("at read uncommitted isolation level") != -1)
1:9f0e445:             isolationLevel = Connection.TRANSACTION_READ_UNCOMMITTED;
1:9f0e445:         else if (rts.indexOf("at read committed isolation level") != -1)
1:9f0e445:             isolationLevel = Connection.TRANSACTION_READ_COMMITTED;
1:9f0e445:         else if (rts.indexOf("at repeatable read isolation level") != -1)
1:9f0e445:             isolationLevel = Connection.TRANSACTION_REPEATABLE_READ;
1:9f0e445: 
1:0b2eeba:         if (rts.indexOf("Distinct Scan ResultSet") > 0) {
1:0b2eeba:         	distinctScan = true;
1:9f0e445:         }
1:56583c3:         
1:0b2eeba:         if (rts.indexOf("Table Scan ResultSet") > 0) {
1:0b2eeba:         	tableScan = true;
1:56583c3:         }
1:7257ae6: 
1:7257ae6:         indexScan = (rts.indexOf("Index Scan ResultSet") >= 0);
1:7257ae6:         indexRowToBaseRow =
1:7257ae6:             (rts.indexOf("Index Row to Base Row ResultSet") >= 0);
1:57191b4:         lastKeyIndexScan = (rts.indexOf("Last Key Index Scan ResultSet") >= 0);
1:da360eb:         
1:0b2eeba:         if (rts.indexOf("Eliminate duplicates = true") > 0) {
1:0b2eeba:         	eliminatedDuplicates = true;
1:da360eb:         }
1:1d94b69:         if (rts.indexOf("Scroll Insensitive ResultSet:") > 0)
1:1d94b69:             scrollInsensitive = true;
1:cd1bd87: 
1:cd1bd87:         qualifiers = findQualifiers();
1:cd1bd87:         
1:1a36302:         startPosition = getStartPosition();
1:1a36302:         stopPosition = getStopPosition();
1:cd1bd87:     }
1:6bd82a5:     
1:6bd82a5: 
1:cd1bd87:     /**
1:cd1bd87:      * Class which represents a qualifier used in a scan.
1:cd1bd87:      */
1:cd1bd87:     private static class Qualifier {
1:cd1bd87:         String operator;
1:cd1bd87:         boolean negated;
1:cd1bd87:         Qualifier(String operator, boolean negated) {
1:cd1bd87:             this.operator = operator;
1:cd1bd87:             this.negated = negated;
1:cd1bd87:         }
1:cd1bd87:         public int hashCode() {
1:cd1bd87:             if (negated) {
1:cd1bd87:                 return ~(operator.hashCode());
1:cd1bd87:             }
1:cd1bd87:             return operator.hashCode();
1:cd1bd87:         }
1:cd1bd87:         public boolean equals(Object o) {
1:cd1bd87:             if (o instanceof Qualifier) {
1:cd1bd87:                 Qualifier q = (Qualifier) o;
1:cd1bd87:                 return (negated == q.negated) && operator.equals(q.operator);
1:cd1bd87:             }
1:cd1bd87:             return false;
1:cd1bd87:         }
1:cd1bd87:         /**
1:cd1bd87:          * Represent the qualifier as a string for debugging.
1:cd1bd87:          */
1:cd1bd87:         public String toString() {
1:cd1bd87:             return (negated ? "\u00ac" : "" ) + operator;
1:cd1bd87:         }
1:cd1bd87:     }
1:cd1bd87: 
1:cd1bd87:     /**
1:cd1bd87:      * Find all qualifiers in a query plan.
1:cd1bd87:      *
1:cd1bd87:      * @return set of <code>Qualifier</code>s
1:cd1bd87:      */
1:2510115:     private HashSet<Qualifier> findQualifiers() {
1:2510115:         HashSet<Qualifier> set = new HashSet<Qualifier>();
1:cd1bd87:         int startPos = statistics.indexOf("qualifiers:\n");
1:cd1bd87:         if (startPos >= 0) {
1:cd1bd87:             // start search after "qualifiers:\n"
1:cd1bd87:             String searchString = statistics.substring(startPos + 12);
1:cd1bd87:             StringTokenizer t = new StringTokenizer(searchString, "\n");
1:ae848fd: 
1:cd1bd87:             while (t.hasMoreTokens()) {
1:cd1bd87:                 String s = t.nextToken();
1:ae848fd:                 StringTokenizer t2 = new StringTokenizer(s, "\t ");
1:ae848fd: 
1:ae848fd:                 if (t2.nextToken().equals("Operator:")) {
1:ae848fd:                     String operator = t2.nextToken();
1:ae848fd: 
1:cd1bd87:                     t.nextToken();  // skip "Ordered nulls: ..."
1:cd1bd87:                     t.nextToken();  // skip "Unknown return value: ..."
1:cd1bd87:                     s = t.nextToken();
1:ae848fd: 
1:ae848fd:                     t2 = new StringTokenizer(s, "\t ");
1:ae848fd:                     String neg = t2.nextToken();
1:ae848fd: 
1:ae848fd:                     if (!neg.equals("Negate")) {
1:cd1bd87:                         throw new AssertionError(
1:ae848fd:                             "Expected to find \"Negate comparison result\", " +
1:ae848fd:                             "found: " + neg);
1:cd1bd87:                     }
1:ae848fd:                     t2.nextToken(); // skip "comparison"
1:ae848fd:                     t2.nextToken(); // skip "result:"
1:ae848fd: 
1:cd1bd87:                     boolean negated =
1:ae848fd:                         Boolean.valueOf(t2.nextToken()).booleanValue();
1:cd1bd87:                     set.add(new Qualifier(operator, negated));
1:cd1bd87:                 }
1:cd1bd87:             }
1:cd1bd87:         }
1:cd1bd87:         return set;
1:6bd82a5:     }
1:6bd82a5: 
1:56583c3:     /**
1:9f0e445:      * @return Isolation level from parsed RuntimeStatistics
1:9f0e445:      */
1:9f0e445:     public int getIsolationLevel() {
1:9f0e445:         return isolationLevel;
1:6bd82a5:     }
1:6bd82a5:     
1:c2b03c4:     /**
1:0b2eeba:      * Return whether or not a Distinct Scan result set was used in the
1:0b2eeba:      * query.
1:0b2eeba:      */
1:0b2eeba:     public boolean usedDistinctScan() {
1:0b2eeba:     	return distinctScan;
1:6bd82a5:     }
1:6bd82a5:     
1:6bd82a5:     /**
1:0b2eeba:      * Return whether or not a Table Scan result set was used in the
1:0b2eeba:      * query.
1:0b2eeba:      */
1:0b2eeba:     public boolean usedTableScan() {
1:0b2eeba:     	return tableScan;
1:6bd82a5:     }
1:7257ae6:     
1:7257ae6:     /**
1:c2b03c4:      * @param tableName
1:6bd82a5:      * @return true if a Table Scan ResultSet was used for tableName
1:6bd82a5:      */
1:6bd82a5:     public boolean usedTableScan(String tableName){
1:6bd82a5:         return (statistics.indexOf("Table Scan ResultSet for " + 
1:a90874a:                     tableName + " ")!= -1);
1:6bd82a5:     }
1:c2b03c4: 
1:1a36302:     /**
1:1a36302:      * @param tableName
1:1a36302:      * @param indexName
1:1a36302:      * @return true if passed indexName was used for Index Scan ResultSet 
1:1a36302:      *     for the passed tableName
1:1a36302:      */
1:c2b03c4:     public boolean usedSpecificIndexForIndexScan(
1:c2b03c4:     		String tableName, String indexName){
1:c2b03c4:         return (statistics.indexOf("Index Scan ResultSet for " + 
1:a90874a:                     tableName + " using index " + indexName + " ")!= -1);
1:c2b03c4:     }
1:c2b03c4: 
1:6bd82a5:     /**
1:6bd82a5:      * @param tableName
1:6bd82a5:      * @return true if an Index Scan ResultSet was used for tableName
1:c2b03c4:      */
1:6bd82a5:     public boolean usedIndexScan(String tableName){
1:6bd82a5:         return (statistics.indexOf("Index Scan ResultSet for " + 
1:a90874a:                     tableName + " ")!= -1);
1:6bd82a5:     }
1:6bd82a5:     
1:9f0e445:     /**
1:6bd82a5:      * @param tableName
1:c2b03c4:      * @return true if passed indexName was used for Index Scan ResultSet 
1:c2b03c4:      *     for the passed tableName
1:6bd82a5:      */
1:1a36302:     public boolean usedConstraintForIndexScan(String tableName){
1:1a36302:         return (statistics.indexOf("Index Scan ResultSet for " + 
1:1a36302:                     tableName + " using constraint")!= -1);
1:1a36302:     }
1:6bd82a5:     
1:0b2eeba:     /**
1:7257ae6:      * Return whether or not an index scan result set was used in the query.
1:7257ae6:      */
1:7257ae6:     public boolean usedIndexScan() {
1:7257ae6:         return indexScan;
1:7257ae6:     }
1:7257ae6: 
1:7257ae6:     /**
1:57191b4:      * Return whether or not a last key index scan result set was used
1:57191b4: 	 * in the query. A last key index scan is a special optimization for
1:57191b4: 	 * MIN and MAX queries against an indexed column (SELECT MAX(ID) FROM T).
1:57191b4:      */
1:57191b4:     public boolean usedLastKeyIndexScan() {
1:57191b4:         return lastKeyIndexScan;
1:9f0e445:     }
1:6bd82a5: 
1:57191b4:     /**
1:7257ae6:      * Return whether or not an index row to base row result set was used in
1:7257ae6:      * the query.
1:7257ae6:      */
1:7257ae6:     public boolean usedIndexRowToBaseRow() {
1:7257ae6:         return indexRowToBaseRow;
1:7257ae6:     }
1:6bd82a5:     
1:0b2eeba:     /**
1:6bd82a5:      * @param tableName
1:6bd82a5:      * @return true if Index Row to Base Row ResultSet was used for tableName
1:6bd82a5:      */
1:6bd82a5:     public boolean usedIndexRowToBaseRow(String tableName) {
1:6bd82a5:        
1:6bd82a5:             return (statistics.indexOf("Index Row to Base Row ResultSet for " + 
1:a90874a:                         tableName + ":")!= -1);       
1:6bd82a5:     }
1:a90874a:         
1:6bd82a5:     /**
1:6bd82a5:      * @param tableName
1:6bd82a5:      * @return true if Used Distinct Scan ResultSet for tablenName
1:6bd82a5:      */
1:6bd82a5:     public boolean usedDistinctScan(String tableName) {
1:6bd82a5:         return (statistics.indexOf("Distinct Scan ResultSet for " + 
1:a90874a:                 tableName + " ")!= -1);
1:6bd82a5: 
1:6bd82a5:     }
1:6bd82a5:    
1:6bd82a5:     
1:6bd82a5:     
1:6bd82a5:     /**
1:0b2eeba:      * Return whether or not the query involved a sort that eliminated
1:0b2eeba:      * duplicates
1:0b2eeba:      */
1:0b2eeba:     public boolean eliminatedDuplicates() {
1:0b2eeba:     	return eliminatedDuplicates;
1:9f0e445:     }
1:1d94b69:     
1:1d94b69:     public boolean isScrollInsensitive(){
1:1d94b69:         return scrollInsensitive;
1:1d94b69:     }
1:cd1bd87: 
1:cd1bd87:     /**
1:cd1bd87:      * Return whether or not the query used a &gt;= scan qualifier.
1:cd1bd87:      */
1:cd1bd87:     public boolean hasGreaterThanOrEqualQualifier() {
1:cd1bd87:         // < negated is equivalent to >=
1:cd1bd87:         return qualifiers.contains(new Qualifier("<", true));
1:cd1bd87:     }
1:cd1bd87: 
1:cd1bd87:     /**
1:cd1bd87:      * Return whether or not the query used a &lt; scan qualifier.
1:cd1bd87:      */
1:cd1bd87:     public boolean hasLessThanQualifier() {
1:cd1bd87:         return qualifiers.contains(new Qualifier("<", false));
1:cd1bd87:     }
1:6bd82a5:     
1:1a36302:     /**
1:1a36302:      * Return whether or not the query used an equals scan qualifier.
1:1a36302:      */
1:1a36302:     public boolean hasEqualsQualifier() {
1:1a36302:         return qualifiers.contains(new Qualifier("=", false));
1:1a36302:     }
1:1a36302:     
1:1a36302:     /**
1:1a36302:      * Return whether there are no qualifiers (i.e. qualifiers: None)
1:1a36302:      */
1:1a36302:     public boolean hasNoQualifiers() {
1:1a36302:         int startPos = statistics.indexOf("qualifiers:\n");
1:1a36302:         if (startPos >= 0) {
1:1a36302:             // start search after "qualifiers:\n"
1:1a36302:             String searchString = statistics.substring(startPos + 12);
1:1a36302:             if (searchString.indexOf("None")>1)
1:1a36302:                 return true;
1:1a36302:             else
1:1a36302:             {
1:1a36302:                 System.out.println("statistics.substring: " + searchString);
1:1a36302:                 return false;
1:4deb981:             }
1:4deb981:         }
1:1a36302:         else {
1:1a36302:             throw new AssertionError(
1:1a36302:                     "Expected to find \"qualifiers: None\", " +
1:1a36302:                     "but didn't even find 'qualifiers'");
1:1a36302:         }
1:1a36302:     }  
1:eddb67d: 
1:9fd3c00:     /**
1:9fd3c00:      * Return whether or not the query plan includes a line of the form
1:9fd3c00:      *
1:9fd3c00:      *   "Number of rows qualified=n"
1:9fd3c00:      *
1:9fd3c00:      * where "n" is the received qualRows argument.  Note that this
1:9fd3c00:      * method will return true if the above string is found anywhere
1:9fd3c00:      * in the query plan.  For queries which specifying more than one
1:9fd3c00:      * table, more advanced parsing will be required to associate the
1:9fd3c00:      * number of rows qualified with the correct table.
1:9fd3c00:      */
1:9fd3c00:     public boolean rowsQualifiedEquals(int qualRows)
1:4deb981:     {
1:9fd3c00:         return (statistics.indexOf("Number of rows qualified=" +
1:9fd3c00:             qualRows + "\n") != -1);
1:1a36302:     }
1:6bd82a5:     
1:6bd82a5:     /**
1:6bd82a5:      * @return true if a hash join was used
1:6bd82a5:      */
1:6bd82a5:     public boolean usedHashJoin()
1:4deb981:     {
1:6bd82a5:         return (statistics.indexOf("Hash Join ResultSet") != -1);
1:1a36302:     }
1:6bd82a5: 
1:6bd82a5:     /**
1:7ff4f83:      * @return true if a nested loop left outer join was used
1:7ff4f83:      */
1:7ff4f83:     public boolean usedNLLeftOuterJoin()
1:1a36302:     {
1:7ff4f83:         return (statistics.indexOf("Nested Loop Left Outer Join") != -1);
1:7ff4f83:     }
1:7ff4f83: 
1:7ff4f83:     /**
1:7e21093:      * Check if an exists join (or a not exists join) was used.
1:7e21093:      *
1:7e21093:      * @return {@code true} if the query used a (not) exists join
1:7e21093:      */
1:7e21093:     public boolean usedExistsJoin() {
1:7e21093:         return statistics.indexOf("Exists Join ResultSet") != -1;
1:7e21093:     }
1:7e21093: 
1:7e21093:     /**
1:6bd82a5:      * Search the RuntimeStatistics for a string.  It must occur
1:6bd82a5:      * at least instances times.
1:5ab1ac2:      * @param stringToFind the string to search for
1:5ab1ac2:      * @param instances the minimum number of occurrences of the string
1:5ab1ac2:      * @return true if stringToFind is found at least {@code instances} times
1:6bd82a5:      */
1:6bd82a5:     public boolean findString(String stringToFind, int instances)
1:1a36302:     {
1:6bd82a5:         int foundCount=0;
1:6bd82a5:         int currentOffset=0;
1:6bd82a5:         String stat = statistics;
1:6bd82a5:         for (int i = 0; i < instances; i++) {
1:6bd82a5:             currentOffset = stat.indexOf(stringToFind);
1:6bd82a5:             if (currentOffset != -1) {
1:6bd82a5:                 foundCount++;
1:6bd82a5:                 stat = stat.substring(currentOffset + stringToFind.length());
1:5ab1ac2:             } else {
1:6bd82a5:                 break;
1:5ab1ac2:             }
1:5ab1ac2:         }
1:5ab1ac2:         return (foundCount >= instances);
1:f7967ea:     }
1:6bd82a5: 
1:0b2eeba:     /**
1:56583c3:      * Check if sorting node was added for the query.
1:56583c3:      * @return true if sorting node was required
1:56583c3:      */
1:56583c3:     public boolean whatSortingRequired() {
1:56583c3:         return (statistics.indexOf("Sort information: ") != -1 );
1:56583c3:     }
1:6bd82a5: 
1:da360eb:     public boolean usedExternalSort() {
1:da360eb:         return (statistics.indexOf("Sort type=external") != -1 );
1:da360eb:     }
1:da360eb: 
1:da360eb:     public String toString() {
1:da360eb:         return statistics;
1:1a36302:     }
1:1a36302:     
1:1a36302:     /**
1:1a36302:      * Find the start position ; sometimes using a scan start / stop is
1:1a36302:      * a way of doing qualifiers using an index
1:282c2ba:      * @return the String array following start position:
1:1a36302:      */
1:1a36302:     public String [] getStartPosition() {
1:1a36302:         int startStartIndex = statistics.indexOf("start position:");
1:1a36302:         int endStartIndex = statistics.indexOf("stop position:");
1:1a36302:         if (startStartIndex >= 0 && endStartIndex >= 0)
1:4deb981:         {
1:1a36302:             String positionLines = statistics.substring(startStartIndex, endStartIndex);
1:eddb67d:             
1:eddb67d:             return Utilities.split(positionLines, '\n');
1:4deb981:         }
1:4deb981:         else 
1:1a36302:             return null;
1:1a36302:         
1:4deb981:     }
1:1a36302: 
1:1a36302:     /**
1:1a36302:      * Find the stop position ; sometimes using a scan start / stop is
1:1a36302:      * a way of doing qualifiers using an index
1:282c2ba:      * @return the String array following start position:
1:1a36302:      */
1:1a36302:     public String [] getStopPosition() {
1:1a36302:         int startStopIndex = statistics.indexOf("stop position:");
1:1a36302:         int endStopIndex = statistics.indexOf("qualifiers:");
1:1a36302:         if (startStopIndex >= 0 && endStopIndex >= 0)
1:4deb981:         {
1:1a36302:             String positionLines = statistics.substring(startStopIndex, endStopIndex);
1:1a36302:             
1:eddb67d:             return Utilities.split(positionLines, '\n');
1:4deb981:         }
1:4deb981:         else 
1:1a36302:             return null;
1:4deb981:     }
1:1d94b69: 
1:f7967ea:     /**
1:f7967ea:      * Assert that a sequence of string exists in the statistics.
1:f7967ea:      * <p>/
1:f7967ea:      * The strings in the argument are each assumed to start a line. Leading
1:f7967ea:      * underscores are converted to tab characters before comparing.
1:f7967ea:      *
1:f7967ea:      * @param strings The sequence of string expected to be found.
1:f7967ea:      */
1:f7967ea:     public void assertSequence(String[] strings) {
1:f7967ea: 
1:f7967ea:         // Make strings ready for comparison:
1:f7967ea:         for (int i=0; i < strings.length; i++) {
1:f7967ea:             StringBuffer sb = new StringBuffer();
1:f7967ea: 
1:f7967ea:             sb.append('\n');
1:f7967ea:             
1:f7967ea:             for (int j=0; j < strings[i].length(); j++) {
1:f7967ea:                 if (strings[i].charAt(j) == '_') {
1:48f6c5d:                     // this would mess up if the string has an _ somewhere in
1:48f6c5d:                     // the middle, e.g. if a table name has an _ in it. So, 
1:48f6c5d:                     // only do this for the first 15 characters.
1:48f6c5d:                     if (j < 15)
1:48f6c5d:                         sb.append('\t');
1:48f6c5d:                     else
1:48f6c5d:                         sb.append(strings[i].substring(j));                        
1:f7967ea:                 } else {
1:f7967ea:                     sb.append(strings[i].substring(j));
1:f7967ea:                     break;
1:1a36302:                 }
1:f7967ea:             }
1:f7967ea:             strings[i] = sb.toString();
1:f7967ea:         }
1:f7967ea: 
1:f7967ea:         String window = statistics;
1:f7967ea:         for (int i = 0; i < strings.length; i++) {
1:f7967ea:             int pos = window.indexOf(strings[i]);
1:f7967ea: 
1:f7967ea:             if (pos == -1) {
1:f7967ea:                 throw new AssertionError(
1:48f6c5d:                     "Sequence " + strings[i] + "not found in statistics");
1:f7967ea:             }
1:f7967ea: 
1:f7967ea:             window = window.substring(pos + 1);
1:48f6c5d:         }
1:f7967ea:     }     
1:f7967ea: }
1:9f0e445:     
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2510115
/////////////////////////////////////////////////////////////////////////
1:     private final HashSet<Qualifier> qualifiers;
/////////////////////////////////////////////////////////////////////////
1:     private HashSet<Qualifier> findQualifiers() {
1:         HashSet<Qualifier> set = new HashSet<Qualifier>();
commit:5ab1ac2
/////////////////////////////////////////////////////////////////////////
1:      * @param stringToFind the string to search for
1:      * @param instances the minimum number of occurrences of the string
1:      * @return true if stringToFind is found at least {@code instances} times
/////////////////////////////////////////////////////////////////////////
1:             } else {
1:             }
1:         }
1:         return (foundCount >= instances);
commit:7e21093
/////////////////////////////////////////////////////////////////////////
1:      * Check if an exists join (or a not exists join) was used.
1:      *
1:      * @return {@code true} if the query used a (not) exists join
1:      */
1:     public boolean usedExistsJoin() {
1:         return statistics.indexOf("Exists Join ResultSet") != -1;
1:     }
1: 
1:     /**
commit:cd1bd87
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
1: import java.util.StringTokenizer;
/////////////////////////////////////////////////////////////////////////
0:     private final HashSet qualifiers;
/////////////////////////////////////////////////////////////////////////
1: 
1:         qualifiers = findQualifiers();
1:     }
1: 
1:     /**
1:      * Class which represents a qualifier used in a scan.
1:      */
1:     private static class Qualifier {
1:         String operator;
1:         boolean negated;
1:         Qualifier(String operator, boolean negated) {
1:             this.operator = operator;
1:             this.negated = negated;
1:         }
1:         public int hashCode() {
1:             if (negated) {
1:                 return ~(operator.hashCode());
1:             }
1:             return operator.hashCode();
1:         }
1:         public boolean equals(Object o) {
1:             if (o instanceof Qualifier) {
1:                 Qualifier q = (Qualifier) o;
1:                 return (negated == q.negated) && operator.equals(q.operator);
1:             }
1:             return false;
1:         }
1:         /**
1:          * Represent the qualifier as a string for debugging.
1:          */
1:         public String toString() {
1:             return (negated ? "\u00ac" : "" ) + operator;
1:         }
1:     }
1: 
1:     /**
1:      * Find all qualifiers in a query plan.
1:      *
1:      * @return set of <code>Qualifier</code>s
1:      */
0:     private HashSet findQualifiers() {
0:         HashSet set = new HashSet();
1:         int startPos = statistics.indexOf("qualifiers:\n");
1:         if (startPos >= 0) {
1:             // start search after "qualifiers:\n"
1:             String searchString = statistics.substring(startPos + 12);
1:             StringTokenizer t = new StringTokenizer(searchString, "\n");
1:             while (t.hasMoreTokens()) {
1:                 String s = t.nextToken();
0:                 if (s.startsWith("Operator: ")) {
0:                     String operator = s.substring(10);
1:                     t.nextToken();  // skip "Ordered nulls: ..."
1:                     t.nextToken();  // skip "Unknown return value: ..."
1:                     s = t.nextToken();
0:                     if (!s.startsWith("Negate comparison result: ")) {
1:                         throw new AssertionError(
0:                             "Expected to find \"Negate comparison result\"");
1:                     }
1:                     boolean negated =
0:                         Boolean.valueOf(s.substring(26)).booleanValue();
1:                     set.add(new Qualifier(operator, negated));
1:                 }
1:             }
1:         }
1:         return set;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return whether or not the query used a &gt;= scan qualifier.
1:      */
1:     public boolean hasGreaterThanOrEqualQualifier() {
1:         // < negated is equivalent to >=
1:         return qualifiers.contains(new Qualifier("<", true));
1:     }
1: 
1:     /**
1:      * Return whether or not the query used a &lt; scan qualifier.
1:      */
1:     public boolean hasLessThanQualifier() {
1:         return qualifiers.contains(new Qualifier("<", false));
1:     }
commit:7257ae6
/////////////////////////////////////////////////////////////////////////
1:     private final boolean indexScan;
1:     private final boolean indexRowToBaseRow;
1:      * information.
/////////////////////////////////////////////////////////////////////////
1: 
1:         indexScan = (rts.indexOf("Index Scan ResultSet") >= 0);
1:         indexRowToBaseRow =
1:             (rts.indexOf("Index Row to Base Row ResultSet") >= 0);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Return whether or not an index scan result set was used in the query.
1:      */
1:     public boolean usedIndexScan() {
1:         return indexScan;
1:     }
1: 
1:     /**
1:      * Return whether or not an index row to base row result set was used in
1:      * the query.
1:      */
1:     public boolean usedIndexRowToBaseRow() {
1:         return indexRowToBaseRow;
1:     }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:48f6c5d
/////////////////////////////////////////////////////////////////////////
1:                     // this would mess up if the string has an _ somewhere in
1:                     // the middle, e.g. if a table name has an _ in it. So, 
1:                     // only do this for the first 15 characters.
1:                     if (j < 15)
1:                         sb.append('\t');
1:                     else
1:                         sb.append(strings[i].substring(j));                        
/////////////////////////////////////////////////////////////////////////
1:                     "Sequence " + strings[i] + "not found in statistics");
1:     }     
commit:4deb981
/////////////////////////////////////////////////////////////////////////
0:             if (JDBC.vmSupportsJSR169())
1:             {
0:                 // do something else then split.
0:                 String [] startPositionLines = Utilities.split(positionLines, '\n');
0:                 return startPositionLines;
1:             }
1:             else
1:             {
0:                 String [] startPositionLines = positionLines.split("\n");
0:                 return startPositionLines;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:             if (JDBC.vmSupportsJSR169())
1:             {
0:                 // do something else then split.
0:                 String [] stopPositionLines = Utilities.split(positionLines, '\n');
0:                 return stopPositionLines;
1:             }
1:             else
1:             {
0:                 String [] stopPositionLines = positionLines.split("\n");
0:                 return stopPositionLines;
1:             }
1:         }
commit:1a36302
/////////////////////////////////////////////////////////////////////////
1:     private String [] startPosition = {"None"};
1:     private String [] stopPosition = {"None"};
/////////////////////////////////////////////////////////////////////////
1:         
1:         startPosition = getStartPosition();
1:         stopPosition = getStopPosition();
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @param tableName
1:      * @param indexName
1:      * @return true if passed indexName was used for Index Scan ResultSet 
1:      *     for the passed tableName
1:      */
1:     public boolean usedConstraintForIndexScan(String tableName){
1:         return (statistics.indexOf("Index Scan ResultSet for " + 
1:                     tableName + " using constraint")!= -1);
1:     }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return whether or not the query used an equals scan qualifier.
1:      */
1:     public boolean hasEqualsQualifier() {
1:         return qualifiers.contains(new Qualifier("=", false));
1:     }
1:     
1:     /**
1:      * Return whether there are no qualifiers (i.e. qualifiers: None)
1:      */
1:     public boolean hasNoQualifiers() {
1:         int startPos = statistics.indexOf("qualifiers:\n");
1:         if (startPos >= 0) {
1:             // start search after "qualifiers:\n"
1:             String searchString = statistics.substring(startPos + 12);
1:             if (searchString.indexOf("None")>1)
1:                 return true;
1:             else
1:             {
1:                 System.out.println("statistics.substring: " + searchString);
1:                 return false;
1:             }
1:         }
1:         else {
1:             throw new AssertionError(
1:                     "Expected to find \"qualifiers: None\", " +
1:                     "but didn't even find 'qualifiers'");
1:         }
1:     }  
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Find the start position ; sometimes using a scan start / stop is
1:      * a way of doing qualifiers using an index
0:      * @ return the String array following start position:
1:      */
1:     public String [] getStartPosition() {
1:         int startStartIndex = statistics.indexOf("start position:");
1:         int endStartIndex = statistics.indexOf("stop position:");
1:         if (startStartIndex >= 0 && endStartIndex >= 0)
1:         {
1:             String positionLines = statistics.substring(startStartIndex, endStartIndex);
0:             String [] startPositionLines = positionLines.split("\n");
0:             return startPositionLines;}
0:         else 
1:             return null;
1:         
1:     }
1: 
1:     /**
1:      * Find the stop position ; sometimes using a scan start / stop is
1:      * a way of doing qualifiers using an index
0:      * @ return the String array following start position:
1:      */
1:     public String [] getStopPosition() {
1:         int startStopIndex = statistics.indexOf("stop position:");
1:         int endStopIndex = statistics.indexOf("qualifiers:");
1:         if (startStopIndex >= 0 && endStopIndex >= 0)
1:         {
1:             String positionLines = statistics.substring(startStopIndex, endStopIndex);
0:             String [] startPositionLines = positionLines.split("\n");
0:             return startPositionLines;}
0:         else 
1:             return null;
1:     }
1: 
commit:a90874a
/////////////////////////////////////////////////////////////////////////
1:                     tableName + " ")!= -1);
/////////////////////////////////////////////////////////////////////////
1:                     tableName + " using index " + indexName + " ")!= -1);
/////////////////////////////////////////////////////////////////////////
1:                     tableName + " ")!= -1);
/////////////////////////////////////////////////////////////////////////
1:                         tableName + ":")!= -1);       
1:         
1:                 tableName + " ")!= -1);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:eddb67d
/////////////////////////////////////////////////////////////////////////
1:             
1:             return Utilities.split(positionLines, '\n');
/////////////////////////////////////////////////////////////////////////
1:             
1:             return Utilities.split(positionLines, '\n');
commit:282c2ba
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @return the String array following start position:
/////////////////////////////////////////////////////////////////////////
1:      * @return the String array following start position:
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:f7967ea
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Assert that a sequence of string exists in the statistics.
1:      * <p>/
1:      * The strings in the argument are each assumed to start a line. Leading
1:      * underscores are converted to tab characters before comparing.
1:      *
1:      * @param strings The sequence of string expected to be found.
1:      */
1:     public void assertSequence(String[] strings) {
1: 
1:         // Make strings ready for comparison:
1:         for (int i=0; i < strings.length; i++) {
1:             StringBuffer sb = new StringBuffer();
1: 
1:             sb.append('\n');
1:             
1:             for (int j=0; j < strings[i].length(); j++) {
1:                 if (strings[i].charAt(j) == '_') {
0:                     sb.append('\t');
1:                 } else {
1:                     sb.append(strings[i].substring(j));
1:                     break;
1:                 }
1:             }
1:             strings[i] = sb.toString();
1:         }
1: 
0:         int matchIdx = 0; // which string to match next
1:         String window = statistics;
1:         for (int i = 0; i < strings.length; i++) {
1:             int pos = window.indexOf(strings[i]);
1: 
1:             if (pos == -1) {
1:                 throw new AssertionError(
0:                     "Sequence not found in statistics");
1:             }
1: 
1:             window = window.substring(pos + 1);
1:         }
1:     }
commit:7ff4f83
/////////////////////////////////////////////////////////////////////////
1:      * @return true if a nested loop left outer join was used
1:      */
1:     public boolean usedNLLeftOuterJoin()
0:     {
1:         return (statistics.indexOf("Nested Loop Left Outer Join") != -1);
1:     }
1: 
1:     /**
commit:ae848fd
/////////////////////////////////////////////////////////////////////////
1: 
1:                 StringTokenizer t2 = new StringTokenizer(s, "\t ");
1: 
1:                 if (t2.nextToken().equals("Operator:")) {
1:                     String operator = t2.nextToken();
1: 
1: 
1:                     t2 = new StringTokenizer(s, "\t ");
1:                     String neg = t2.nextToken();
1: 
1:                     if (!neg.equals("Negate")) {
1:                             "Expected to find \"Negate comparison result\", " +
1:                             "found: " + neg);
1:                     t2.nextToken(); // skip "comparison"
1:                     t2.nextToken(); // skip "result:"
1: 
1:                         Boolean.valueOf(t2.nextToken()).booleanValue();
commit:70b8905
/////////////////////////////////////////////////////////////////////////
1:  * Derby - Class org.apache.derbyTesting.functionTests.util.RuntimeStatisticsParser
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:56583c3
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /**
1:      * Check if sorting node was added for the query.
1:      * @return true if sorting node was required
1:      */
1:     public boolean whatSortingRequired() {
1:         return (statistics.indexOf("Sort information: ") != -1 );
1:     }
commit:c2b03c4
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @param tableName
0:      * @param indexName
1:      * @return true if passed indexName was used for Index Scan ResultSet 
1:      *     for the passed tableName
1:      */
1:     public boolean usedSpecificIndexForIndexScan(
1:     		String tableName, String indexName){
1:         return (statistics.indexOf("Index Scan ResultSet for " + 
0:                     tableName + " using index " + indexName)!= -1);
1:     }
1: 
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:da360eb
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean usedExternalSort() {
1:         return (statistics.indexOf("Sort type=external") != -1 );
1:     }
1: 
1:     public String toString() {
1:         return statistics;
1:     }
commit:6bd82a5
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @param tableName
1:      * @return true if a Table Scan ResultSet was used for tableName
1:      */
1:     public boolean usedTableScan(String tableName){
1:         return (statistics.indexOf("Table Scan ResultSet for " + 
0:                     tableName)!= -1);
1:     }
1:     /**
1:      * @param tableName
1:      * @return true if an Index Scan ResultSet was used for tableName
1:      */
1:     public boolean usedIndexScan(String tableName){
1:         return (statistics.indexOf("Index Scan ResultSet for " + 
0:                     tableName)!= -1);
1:     }
1:     
1:     
1:     
/////////////////////////////////////////////////////////////////////////
1:      * @param tableName
1:      * @return true if Index Row to Base Row ResultSet was used for tableName
1:      */
1:     public boolean usedIndexRowToBaseRow(String tableName) {
1:        
1:             return (statistics.indexOf("Index Row to Base Row ResultSet for " + 
0:                         tableName)!= -1);
1:        
1:     }
1:     
1:     
1:     /**
1:      * @param tableName
1:      * @return true if Used Distinct Scan ResultSet for tablenName
1:      */
1:     public boolean usedDistinctScan(String tableName) {
1:         return (statistics.indexOf("Distinct Scan ResultSet for " + 
0:                 tableName)!= -1);
1: 
1:     }
1:    
1:     
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:   
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * @return true if a hash join was used
1:      */
1:     public boolean usedHashJoin()
0:     {
1:         return (statistics.indexOf("Hash Join ResultSet") != -1);
1:     }
1: 
1:     /**
1:      * Search the RuntimeStatistics for a string.  It must occur
1:      * at least instances times.
0:      * @param stringToFind
0:      * @param instances
0:      * @return true if stringToFind is found instances times.
1:      */
1:     public boolean findString(String stringToFind, int instances)
0:     {
1:         int foundCount=0;
1:         int currentOffset=0;
1:         String stat = statistics;
1:         for (int i = 0; i < instances; i++) {
1:             currentOffset = stat.indexOf(stringToFind);
1:             if (currentOffset != -1) {
1:                 foundCount++;
1:                 stat = stat.substring(currentOffset + stringToFind.length());
0:             } else {    
1:                 break;
1:             }   
1:             }    
0:             return (foundCount >=instances);
1:                 
1:         }
1:     
commit:1d94b69
/////////////////////////////////////////////////////////////////////////
1:     private boolean scrollInsensitive = false;
/////////////////////////////////////////////////////////////////////////
1:         if (rts.indexOf("Scroll Insensitive ResultSet:") > 0)
1:             scrollInsensitive = true;
/////////////////////////////////////////////////////////////////////////
1:     
1:     public boolean isScrollInsensitive(){
1:         return scrollInsensitive;
1:     }
1:     
commit:9f0e445
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
0:  * Derby - Class org.apache.derbyTesting.functionTests.util.RunTimeStatisticsParser
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.junit;
1: 
1: import java.sql.Connection;
1: 
1: public class RuntimeStatisticsParser {
1: 
1:     private int isolationLevel = Connection.TRANSACTION_NONE;
1: 
1:     /**
1:      * Create a RuntimeStatistics object to parse the text and extract
0:      * information. Currently only isolation level is the only thing extracted.
1:      * 
1:      * @param rts
1:      *            Runtime Statistics string
1:      * 
1:      */
1:     public RuntimeStatisticsParser(String rts) {
1:         if (rts.indexOf(" at serializable isolation level ") != -1)
1:             isolationLevel = Connection.TRANSACTION_SERIALIZABLE;
1:         else if (rts.indexOf("at read uncommitted isolation level") != -1)
1:             isolationLevel = Connection.TRANSACTION_READ_UNCOMMITTED;
1:         else if (rts.indexOf("at read committed isolation level") != -1)
1:             isolationLevel = Connection.TRANSACTION_READ_COMMITTED;
1:         else if (rts.indexOf("at repeatable read isolation level") != -1)
1:             isolationLevel = Connection.TRANSACTION_REPEATABLE_READ;
1: 
1:     }
1: 
1:     /**
1:      * @return Isolation level from parsed RuntimeStatistics
1:      */
1:     public int getIsolationLevel() {
1:         return isolationLevel;
1:     }
1:     
1: }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:57191b4
/////////////////////////////////////////////////////////////////////////
1: 	private final boolean lastKeyIndexScan;
/////////////////////////////////////////////////////////////////////////
1:         lastKeyIndexScan = (rts.indexOf("Last Key Index Scan ResultSet") >= 0);
/////////////////////////////////////////////////////////////////////////
1:      * Return whether or not a last key index scan result set was used
1: 	 * in the query. A last key index scan is a special optimization for
1: 	 * MIN and MAX queries against an indexed column (SELECT MAX(ID) FROM T).
1:      */
1:     public boolean usedLastKeyIndexScan() {
1:         return lastKeyIndexScan;
0:     }
0: 
1:     /**
author:Army
-------------------------------------------------------------------------------
commit:9fd3c00
/////////////////////////////////////////////////////////////////////////
0: 
1:     /**
1:      * Return whether or not the query plan includes a line of the form
1:      *
1:      *   "Number of rows qualified=n"
1:      *
1:      * where "n" is the received qualRows argument.  Note that this
1:      * method will return true if the above string is found anywhere
1:      * in the query plan.  For queries which specifying more than one
1:      * table, more advanced parsing will be required to associate the
1:      * number of rows qualified with the correct table.
1:      */
1:     public boolean rowsQualifiedEquals(int qualRows)
0:     {
1:         return (statistics.indexOf("Number of rows qualified=" +
1:             qualRows + "\n") != -1);
0:     }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:0b2eeba
/////////////////////////////////////////////////////////////////////////
1:     private boolean distinctScan = false;
1:     private boolean eliminatedDuplicates = false;
1:     private boolean tableScan = false;
1:     private String statistics = "";
/////////////////////////////////////////////////////////////////////////
1:     	statistics = rts;
/////////////////////////////////////////////////////////////////////////
1:         if (rts.indexOf("Distinct Scan ResultSet") > 0) {
1:         	distinctScan = true;
0:         }
0:         
1:         if (rts.indexOf("Table Scan ResultSet") > 0) {
1:         	tableScan = true;
0:         }
0:         
1:         if (rts.indexOf("Eliminate duplicates = true") > 0) {
1:         	eliminatedDuplicates = true;
0:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return whether or not a Distinct Scan result set was used in the
1:      * query.
1:      */
1:     public boolean usedDistinctScan() {
1:     	return distinctScan;
0:     }
0:     
1:     /**
1:      * Return whether or not a Table Scan result set was used in the
1:      * query.
1:      */
1:     public boolean usedTableScan() {
1:     	return tableScan;
0:     }
0:     
1:     /**
1:      * Return whether or not the query involved a sort that eliminated
1:      * duplicates
1:      */
1:     public boolean eliminatedDuplicates() {
1:     	return eliminatedDuplicates;
0:     }
============================================================================