1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.NoRowsResultSetImpl
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
19:eac0369: 
7:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:75ec275: import java.sql.SQLWarning;
1:1e2aae0: import java.sql.Timestamp;
1:b197ffa: import org.w3c.dom.Element;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:1e2aae0: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.i18n.MessageService;
1:1e2aae0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:1e2aae0: import org.apache.derby.iapi.sql.Activation;
1:ec4aa98: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
1:1e2aae0: import org.apache.derby.iapi.sql.ResultDescription;
1:1e2aae0: import org.apache.derby.iapi.sql.ResultSet;
1:1e2aae0: import org.apache.derby.iapi.sql.Row;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.sql.conn.StatementContext;
1:1e2aae0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:1e2aae0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:1e2aae0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:eac0369: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
1:48a9884: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1:48a9884: import org.apache.derby.iapi.sql.execute.xplain.XPLAINVisitor;
1:af1c18c: import org.apache.derby.iapi.types.BooleanDataValue;
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
5:eac0369: /**
1:3237ef5:  * Abstract ResultSet for implementations that do not return rows.
1:3237ef5:  * Examples are DDL statements, CALL statements and DML.
1:3237ef5:  * <P>
1:3237ef5:  * An implementation must provide a ResultSet.open() method
1:3237ef5:  * that performs the required action. 
1:3237ef5:  * <P>
1:3237ef5:  * ResultSet.returnsRows() returns false and any method
1:3237ef5:  * that fetches a row will throw an exception.
6:eac0369:  *
1:eac0369:  */
1:eac0369: abstract class NoRowsResultSetImpl implements ResultSet
7:eac0369: {
1:6bc9897: 	final Activation    activation;
1:300bbeb:     private NoPutResultSet[] subqueryTrackingArray;
1:eac0369: 
1:eac0369: 	private final boolean statisticsTimingOn;
1:6369b54: 	/** True if the result set has been opened, and not yet closed. */
1:6369b54: 	private boolean isOpen;
1:eac0369: 
1:eac0369: 	/* Run time statistics variables */
1:6bc9897: 	final LanguageConnectionContext lcc;
1:eac0369: 	protected long beginTime;
1:eac0369: 	protected long endTime;
1:eac0369: 	protected long beginExecutionTime;
1:eac0369: 	protected long endExecutionTime;
1:ec4aa98: 
1:4e6df7a:     private int                             firstColumn = -1;    // First column being stuffed. For UPDATES, this lies in the second half of the row.
1:4e6df7a:     private int[]                           generatedColumnPositions; // 1-based positions of generated columns in the target row
1:4e6df7a: 
1:4e6df7a:     // One cell for  each slot in generatedColumnPositions. These are temporary
1:4e6df7a:     // values which hold the result of running the generation clause before we
1:4e6df7a:     // stuff the result into the target row.
1:4e6df7a:     private DataValueDescriptor[]  normalizedGeneratedValues;
1:eac0369: 
1:eac0369: 	NoRowsResultSetImpl(Activation activation)
1:eac0369: 	{
1:eac0369: 		this.activation = activation;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 			if (activation == null)
1:eac0369: 				SanityManager.THROWASSERT("activation is null in result set " + getClass());
8:eac0369: 		}
1:eac0369: 
1:eac0369: 		lcc = activation.getLanguageConnectionContext();
1:eac0369: 		statisticsTimingOn = lcc.getStatisticsTiming();
1:eac0369: 
1:eac0369: 		/* NOTE - We can't get the current time until after setting up the
1:eac0369: 		 * activation, as we end up using the activation to get the 
1:eac0369: 		 * LanguageConnectionContext.
1:ec4aa98: 		 */
1:eac0369: 		beginTime = getCurrentTimeMillis();
1:eac0369: 		beginExecutionTime = beginTime;
1:eac0369: 	}
1:eac0369: 
1:6369b54: 	/**
1:6369b54: 	 * Set up the result set for use. Should always be called from
1:6369b54: 	 * <code>open()</code>.
1:6369b54: 	 *
1:6369b54: 	 * @exception StandardException thrown on error
1:c533cd2: 	 */
1:6369b54: 	void setup() throws StandardException {
1:6369b54: 		isOpen = true;
1:300bbeb: 
1:300bbeb:         StatementContext sc = lcc.getStatementContext();
1:300bbeb:         sc.setTopResultSet(this, subqueryTrackingArray);
1:300bbeb: 
1:300bbeb:         // Pick up any materialized subqueries
1:300bbeb:         if (subqueryTrackingArray == null) {
1:300bbeb:             subqueryTrackingArray = sc.getSubqueryTrackingArray();
1:300bbeb:         }
1:6369b54: 	}
1:6369b54: 
1:eac0369:     /**
1:eac0369: 	 * Returns FALSE
1:6369b54: 	 */
1:eac0369: 	 public final boolean	returnsRows() { return false; }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns zero.
1:eac0369: 	 */
1:7fb9956: 	public long	modifiedRowCount() { return 0L; }
1:c69c8b0: 
1:c69c8b0: 	/**
1:c69c8b0: 	 * Returns null.
1:c69c8b0: 	 */
1:c69c8b0: 	public ResultDescription	getResultDescription()
1:c69c8b0: 	{
1:c69c8b0: 	    return (ResultDescription)null;
1:c69c8b0: 	}
1:6b26ee1: 	
1:6b26ee1: 	public final Activation getActivation()
1:6b26ee1: 	{
1:6b26ee1: 		return activation;
1:6b26ee1: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row at the absolute position from the query, 
1:eac0369: 	 * and returns NULL when there is no such position.
1:eac0369: 	 * (Negative position means from the end of the result set.)
1:eac0369: 	 * Moving the cursor to an invalid position leaves the cursor
1:eac0369: 	 * positioned either before the first row (negative position)
1:eac0369: 	 * or after the last row (positive position).
1:eac0369: 	 * NOTE: An exception will be thrown on 0.
1:eac0369: 	 *
1:eac0369: 	 * @param row	The position.
1:eac0369: 	 * @return	The row at the absolute position, or NULL if no such position.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:3237ef5: 	public final ExecRow	getAbsoluteRow(int row) throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 			The JDBC use of this class will never call here.
1:eac0369: 			Only the DB API used directly can get this exception.
1:eac0369: 		 */
1:eac0369: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "absolute");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row at the relative position from the current
1:eac0369: 	 * cursor position, and returns NULL when there is no such position.
1:eac0369: 	 * (Negative position means toward the beginning of the result set.)
1:eac0369: 	 * Moving the cursor to an invalid position leaves the cursor
1:eac0369: 	 * positioned either before the first row (negative position)
1:eac0369: 	 * or after the last row (positive position).
1:eac0369: 	 * NOTE: 0 is valid.
1:eac0369: 	 * NOTE: An exception is thrown if the cursor is not currently
1:eac0369: 	 * positioned on a row.
1:eac0369: 	 *
1:eac0369: 	 * @param row	The position.
1:eac0369: 	 * @return	The row at the relative position, or NULL if no such position.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:3237ef5: 	public final ExecRow	getRelativeRow(int row) throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 			The JDBC use of this class will never call here.
1:eac0369: 			Only the DB API used directly can get this exception.
1:eac0369: 		 */
1:eac0369: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "relative");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the current position to before the first row and returns NULL
1:eac0369: 	 * because there is no current row.
1:eac0369: 	 *
1:eac0369: 	 * @return	NULL.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:3237ef5: 	public final ExecRow	setBeforeFirstRow() 
4:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 			The JDBC use of this class will never call here.
1:eac0369: 			Only the DB API used directly can get this exception.
1:eac0369: 		 */
1:eac0369: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "beforeFirst");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the first row from the query, and returns NULL when there
1:eac0369: 	 * are no rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The first row, or NULL if no rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:3237ef5: 	public final ExecRow	getFirstRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 			The JDBC use of this class will never call here.
1:eac0369: 			Only the DB API used directly can get this exception.
1:eac0369: 		 */
1:eac0369: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "first");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:      * No rows to return, so throw an exception.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Always throws a
1:eac0369: 	 *									StandardException to indicate
1:eac0369: 	 *									that this method is not intended to
1:eac0369: 	 *									be used.
1:eac0369: 	 */
1:3237ef5: 	public final ExecRow	getNextRow() throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 			The JDBC use of this class will never call here.
1:eac0369: 			Only the DB API used directly can get this exception.
1:eac0369: 		 */
1:eac0369: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "next");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the previous row from the query, and returns NULL when there
1:eac0369: 	 * are no more previous rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The previous row, or NULL if no more previous rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:3237ef5: 	public final ExecRow	getPreviousRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 			The JDBC use of this class will never call here.
1:eac0369: 			Only the DB API used directly can get this exception.
1:eac0369: 		 */
1:eac0369: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "previous");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the last row from the query, and returns NULL when there
1:eac0369: 	 * are no rows.
1:eac0369: 	 *
1:eac0369: 	 * @return	The last row, or NULL if no rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:3237ef5: 	public final ExecRow	getLastRow()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 			The JDBC use of this class will never call here.
1:eac0369: 			Only the DB API used directly can get this exception.
1:eac0369: 		 */
1:eac0369: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "last");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Sets the current position to after the last row and returns NULL
1:eac0369: 	 * because there is no current row.
1:eac0369: 	 *
1:eac0369: 	 * @return	NULL.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 * @see Row
1:eac0369: 	 */
1:3237ef5: 	public final ExecRow	setAfterLastRow() 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 			The JDBC use of this class will never call here.
1:eac0369: 			Only the DB API used directly can get this exception.
1:eac0369: 		 */
1:eac0369: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "afterLast");
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:9634cd2: 	 * Clear the current row. This is done after a commit on holdable
1:9634cd2: 	 * result sets.
1:9634cd2: 	 * This is a no-op on result set which do not provide rows.
1:eac0369: 	 */
1:9634cd2: 	public final void clearCurrentRow() 
1:eac0369: 	{
1:eac0369: 		
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Determine if the cursor is before the first row in the result 
1:eac0369:      * set.   
1:eac0369:      *
1:eac0369:      * @return true if before the first row, false otherwise. Returns
1:eac0369:      * false when the result set contains no rows.
1:eac0369:      */
1:3237ef5:     public final boolean checkRowPosition(int isType)
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Returns the row number of the current row.  Row
1:eac0369: 	 * numbers start from 1 and go to 'n'.  Corresponds
1:eac0369: 	 * to row numbering used to position current row
1:eac0369: 	 * in the result set (as per JDBC).
1:eac0369: 	 *
1:eac0369: 	 * @return	the row number, or 0 if not on a row
1:eac0369: 	 *
1:eac0369: 	 */
1:3237ef5: 	public final int getRowNumber()
1:eac0369: 	{
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:0f4ab91:      * Dump the stat if not already done so. Close all of the open subqueries.
1:eac0369: 	 *
1:01632c2: 	 * @param underMerge    True if this is part of an action of a MERGE statement.
1:01632c2: 	 *
3:eac0369: 	 * @exception StandardException thrown on error
1:eac0369: 	 */
1:01632c2: 	public void	close( boolean underMerge ) throws StandardException
1:eac0369: 	{ 
1:49e9a9b: 		if (!isOpen)
1:49e9a9b: 			return;
1:eac0369: 
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** If run time statistics tracing is turned on, then now is the
1:eac0369: 			** time to dump out the information.
1:eac0369: 			** NOTE - We make a special exception for commit.  If autocommit
1:eac0369: 			** is on, then the run time statistics from the autocommit is the
1:eac0369: 			** only one that the user would ever see.  So, we don't overwrite
1:eac0369: 			** the run time statistics object for a commit.
1:9a428e4:             ** DERBY-2353: Also make an exception when the activation is
1:9a428e4:             ** closed. If the activation is closed, the run time statistics
1:9a428e4:             ** object is null and there's nothing to print. This may happen
1:9a428e4:             ** if a top-level result set closes the activation and close() is
1:9a428e4:             ** subsequently called on the child result sets. The information
1:9a428e4:             ** about the children is also printed by the parent, so it's safe
1:9a428e4:             ** to skip printing it.
1:eac0369: 			*/
1:eac0369: 			if (lcc.getRunTimeStatisticsMode() &&
1:b4885a6:                 !doesCommit() && !activation.isClosed() &&
1:b4885a6:                 !lcc.getStatementContext().getStatementWasInvalidated())
1:eac0369: 			{
1:eac0369: 				endExecutionTime = getCurrentTimeMillis();
1:eac0369: 
1:53ce71e: 				ResultSetStatisticsFactory rssf =
1:53ce71e:                     lcc.getLanguageConnectionFactory().
1:53ce71e:                          getExecutionFactory().getResultSetStatisticsFactory();
1:eac0369: 
1:48a9884:                 // get the RuntimeStatisticsImpl object which is the wrapper for all 
1:48a9884:                 // statistics
1:48a9884:                 RunTimeStatistics rsImpl = rssf.getRunTimeStatistics(activation, this, subqueryTrackingArray); 
1:eac0369: 
1:48a9884:                 // save RTS object in lcc
1:48a9884:                 lcc.setRunTimeStatisticsObject(rsImpl);
1:48a9884:                 
1:48a9884:                 // explain gathered statistics
1:48a9884:                 XPLAINVisitor visitor =  lcc.getLanguageConnectionFactory().getExecutionFactory().getXPLAINFactory().getXPLAINVisitor();
1:48a9884:                 visitor.doXPLAIN(rsImpl,activation);
1:48a9884: 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* This is the top ResultSet, 
1:eac0369: 		 * close all of the open subqueries.
1:eac0369: 		 */
1:eac0369: 		int staLength = (subqueryTrackingArray == null) ? 0 :
1:eac0369: 							subqueryTrackingArray.length;
1:eac0369: 
1:eac0369: 		for (int index = 0; index < staLength; index++)
1:eac0369: 		{
1:eac0369: 			if (subqueryTrackingArray[index] == null)
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 			if (subqueryTrackingArray[index].isClosed())
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 			subqueryTrackingArray[index].close();
1:eac0369: 		}
1:eac0369: 
1:6369b54: 		isOpen = false;
1:eac0369: 
1:01632c2: 		if (activation.isSingleExecution() && !underMerge)
1:49e9a9b: 			activation.close();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:4eafcf8: 	 * Find out if the <code>ResultSet</code> is closed.
1:4eafcf8: 	 *
1:4eafcf8: 	 * @return <code>true</code> if closed, <code>false</code> otherwise
1:eac0369: 	 */
1:eac0369: 	public boolean isClosed() {
1:6369b54: 		return !isOpen;
1:eac0369: 	}
1:eac0369: 
1:0f4ab91: 	public void	finish() throws StandardException
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the execution time in milliseconds.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The execution time in milliseconds.
1:eac0369: 	 */
1:eac0369: 	public long getExecuteTime()
1:eac0369: 	{
1:eac0369: 		return endTime - beginTime;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Timestamp for the beginning of execution.
1:eac0369: 	 *
1:eac0369: 	 * @return Timestamp		The Timestamp for the beginning of execution.
1:eac0369: 	 */
1:eac0369: 	public Timestamp getBeginExecutionTimestamp()
1:eac0369: 	{
1:eac0369: 		if (beginExecutionTime == 0)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return new Timestamp(beginExecutionTime);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Timestamp for the end of execution.
1:eac0369: 	 *
1:eac0369: 	 * @return Timestamp		The Timestamp for the end of execution.
1:eac0369: 	 */
1:eac0369: 	public Timestamp getEndExecutionTimestamp()
1:eac0369: 	{
1:eac0369: 		if (endExecutionTime == 0)
1:eac0369: 		{
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return new Timestamp(endExecutionTime);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * RESOLVE - This method will go away once it is overloaded in all subclasses.
1:eac0369: 	 * Return the query plan as a String.
1:eac0369: 	 *
1:eac0369: 	 * @param depth	Indentation level.
1:eac0369: 	 *
1:eac0369: 	 * @return String	The query plan as a String.
1:eac0369: 	 */
1:eac0369: 	public String getQueryPlanText(int depth)
1:eac0369: 	{
1:eac0369: 		return MessageService.getTextMessage(
1:eac0369: 				SQLState.LANG_GQPT_NOT_SUPPORTED,
1:eac0369: 				getClass().getName());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the total amount of time spent in this ResultSet
1:eac0369: 	 *
1:eac0369: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1:eac0369: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1:eac0369: 	 *
1:eac0369: 	 * @return long		The total amount of time spent (in milliseconds).
1:eac0369: 	 */
1:eac0369: 	public long getTimeSpent(int type)
1:eac0369: 	{
1:eac0369: 		/* RESOLVE - this should be overloaded in all subclasses */
1:eac0369: 		return 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSet#getSubqueryTrackingArray
1:eac0369: 	 */
1:eac0369: 	public final NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
1:eac0369: 	{
2:eac0369: 		if (subqueryTrackingArray == null)
1:eac0369: 		{
1:eac0369: 			subqueryTrackingArray = new NoPutResultSet[numSubqueries];
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return subqueryTrackingArray;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see ResultSet#getAutoGeneratedKeysResultset
1:eac0369: 	 */
1:eac0369: 	public ResultSet getAutoGeneratedKeysResultset()
1:eac0369: 	{
1:eac0369: 		//A non-null resultset would be returned only for an insert statement 
1:eac0369: 		return (ResultSet)null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the cursor name, null in this case.
1:eac0369: 
1:eac0369: 		@see ResultSet#getCursorName
1:eac0369: 	*/
1:eac0369: 	public String getCursorName() {
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// class implementation
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the current time in milliseconds, if DEBUG and RunTimeStats is
1:eac0369: 	 * on, else return 0.  (Only pay price of system call if need to.)
1:eac0369: 	 *
1:eac0369: 	 * @return long		Current time in milliseconds.
1:eac0369: 	 */
1:eac0369: 	protected final long getCurrentTimeMillis()
1:eac0369: 	{
1:eac0369: 		if (statisticsTimingOn)
1:eac0369: 		{
1:eac0369: 			return System.currentTimeMillis();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:15b837e: 	  * Compute the generation clauses on the current row in order to fill in
1:15b837e: 	  * computed columns.
1:15b837e:       *
1:15b837e:       * @param generationClauses    the generated method which evaluates generation clauses
1:15b837e:       * @param activation               the thread-specific instance of the generated class
1:15b837e:       * @param source                   the tuple stream driving this INSERT/UPDATE
1:15b837e:       * @param newRow                   the base row being stuffed
1:15b837e:       * @param isUpdate                 true if this is an UPDATE. false otherwise.
1:eac0369: 	  */
1:c533cd2: 	public	void	evaluateGenerationClauses
1:c533cd2: 	(
1:c533cd2: 	  GeneratedMethod generationClauses,
1:c533cd2: 	  Activation activation,
1:c533cd2:       NoPutResultSet    source,
1:ec4aa98:       ExecRow           newRow,
1:ec4aa98:       boolean           isUpdate
1:c533cd2: 	)
1:c533cd2: 		throws StandardException
1:c533cd2: 	{
1:c533cd2: 		if (generationClauses != null)
1:c533cd2: 		{
1:c533cd2:             ExecRow oldRow = (ExecRow) activation.getCurrentRow( source.resultSetNumber() );
1:c533cd2: 
1:c533cd2:             //
1:c533cd2:             // We may need to poke the current row into the Activation so that
1:c533cd2:             // it is visible to the method which evaluates the generation
1:c533cd2:             // clause. This is because the generation clause may refer to other
1:c533cd2:             // columns in that row.
1:c533cd2:             //
1:c533cd2:             try {
1:c533cd2:                 source.setCurrentRow( newRow );
1:01632c2:                 activation.setCurrentRow( newRow, source.resultSetNumber() );
1:c533cd2:                 generationClauses.invoke(activation);
1:ec4aa98: 
1:ec4aa98:                 //
1:ec4aa98:                 // Now apply NOT NULL checks and other coercions. For non-generated columns, these
1:ec4aa98:                 // are performed in the driving ResultSet.
1:ec4aa98:                 //
1:ec4aa98:                 if ( firstColumn < 0 ) { firstColumn = NormalizeResultSet.computeStartColumn( isUpdate, activation.getResultDescription() ); }
1:ec4aa98:                 if ( generatedColumnPositions == null ) { setupGeneratedColumns( activation, (ValueRow) newRow ); }
1:ec4aa98:                 
1:ec4aa98:                 ResultDescription   resultDescription = activation.getResultDescription();
1:ec4aa98:                 int                         count = generatedColumnPositions.length;
1:ec4aa98: 
1:ec4aa98:                 for ( int i = 0; i < count; i++ )
1:ec4aa98:                 {
1:ec4aa98:                     int         position = generatedColumnPositions[ i ];
1:ec4aa98: 
1:ec4aa98:                     DataValueDescriptor normalizedColumn = NormalizeResultSet.normalizeColumn
1:ec4aa98:                         (
1:ec4aa98:                          resultDescription.getColumnDescriptor( position ).getType(),
1:ec4aa98:                          newRow,
1:ec4aa98:                          position,
1:ec4aa98:                          normalizedGeneratedValues[ i ],
1:ec4aa98:                          resultDescription
1:ec4aa98:                          );
1:ec4aa98: 
1:ec4aa98:                     newRow.setColumn( position, normalizedColumn );
1:ec4aa98:                 }
1:c533cd2:             }
1:c533cd2:             finally
1:c533cd2:             {
1:c533cd2:                 //
1:c533cd2:                 // We restore the Activation to its state before we ran the generation
1:c533cd2:                 // clause. This may not be necessary but I don't understand all of
1:c533cd2:                 // the paths through the Insert and Update result sets. This
1:c533cd2:                 // defensive coding seems prudent to me.
1:c533cd2:                 //
1:c533cd2:                 if ( oldRow == null ) { source.clearCurrentRow(); }
1:c533cd2:                 else { source.setCurrentRow( oldRow ); }
1:c533cd2:             }
1:c533cd2: 		}
1:c533cd2: 	}
1:c533cd2: 
1:c533cd2: 	/**
1:4e6df7a: 	  * Construct support for normalizing generated columns. This figures out
1:4e6df7a: 	  * which columns in the target row have generation clauses which need to be run.
1:eac0369: 	  */
1:ec4aa98:     private void    setupGeneratedColumns( Activation activation, ValueRow newRow )
1:ec4aa98:         throws StandardException
1:ec4aa98:     {
1:ec4aa98:         ResultDescription   resultDescription = activation.getResultDescription();
1:ec4aa98:         int                         columnCount = resultDescription.getColumnCount();
1:ec4aa98:         ExecRow                 emptyRow = newRow.getNewNullRow();
1:ec4aa98:         int                         generatedColumnCount = 0;
1:ec4aa98: 
1:ec4aa98:         // first count the number of generated columns
1:ec4aa98:         for ( int i = 1; i <= columnCount; i++ )
1:ec4aa98:         {
1:ec4aa98:             if ( i < firstColumn ) { continue; }
1:ec4aa98:             
1:ec4aa98:             ResultColumnDescriptor  rcd = resultDescription.getColumnDescriptor( i );
1:ec4aa98: 
1:ec4aa98:             if ( rcd.hasGenerationClause() ) { generatedColumnCount++; }
1:ec4aa98:         }
1:ec4aa98: 
1:ec4aa98:         // now allocate and populate support structures
1:ec4aa98:         generatedColumnPositions = new int[ generatedColumnCount ];
1:ec4aa98:         normalizedGeneratedValues = new DataValueDescriptor[ generatedColumnCount ];
1:ec4aa98: 
1:ec4aa98:         int     idx = 0;
1:ec4aa98:         for ( int i = 1; i <= columnCount; i++ )
1:ec4aa98:         {
1:ec4aa98:             if ( i < firstColumn ) { continue; }
1:ec4aa98:             
1:ec4aa98:             ResultColumnDescriptor  rcd = resultDescription.getColumnDescriptor( i );
1:ec4aa98: 
1:ec4aa98:             if ( rcd.hasGenerationClause() )
1:ec4aa98:             {
1:ec4aa98:                 generatedColumnPositions[ idx ] = i;
1:ec4aa98:                 normalizedGeneratedValues[ idx ] = emptyRow.getColumn( i );
1:ec4aa98: 
1:ec4aa98:                 idx++;
1:ec4aa98:             }
1:ec4aa98:         }
1:ec4aa98:     }
1:ec4aa98:     
1:ec4aa98: 	/**
1:eac0369: 	 * Does this ResultSet cause a commit or rollback.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this ResultSet cause a commit or rollback.
1:eac0369: 	 */
1:eac0369: 	public boolean doesCommit()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:75ec275:     public void addWarning(SQLWarning w) {
1:75ec275:         // We're not returning a (JDBC) ResultSet, so add the warning to
1:75ec275:         // the Activation so that it's included in the warning chain of the
1:75ec275:         // executing Statement.
1:75ec275:         getActivation().addWarning(w);
1:75ec275:     }
1:75ec275: 
1:75ec275: 	public SQLWarning getWarnings() {
1:eac0369: 		return null;
1:eac0369: 	}
1:eac0369: 
1:b197ffa:     public Element toXML( Element parentNode, String tag ) throws Exception
1:b197ffa:     {
1:b197ffa:         return BasicNoPutResultSetImpl.childrenToXML( BasicNoPutResultSetImpl.toXML( parentNode, tag, this ), this );
1:b197ffa:     }
1:b197ffa: 
1:eac0369: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.BooleanDataValue;
/////////////////////////////////////////////////////////////////////////
commit:f167762
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1: 	 * @param underMerge    True if this is part of an action of a MERGE statement.
1: 	 *
1: 	public void	close( boolean underMerge ) throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 		if (activation.isSingleExecution() && !underMerge)
/////////////////////////////////////////////////////////////////////////
1:                 activation.setCurrentRow( newRow, source.resultSetNumber() );
commit:b197ffa
/////////////////////////////////////////////////////////////////////////
1: import org.w3c.dom.Element;
/////////////////////////////////////////////////////////////////////////
1:     public Element toXML( Element parentNode, String tag ) throws Exception
1:     {
1:         return BasicNoPutResultSetImpl.childrenToXML( BasicNoPutResultSetImpl.toXML( parentNode, tag, this ), this );
1:     }
1: 
commit:7fb9956
/////////////////////////////////////////////////////////////////////////
1: 	public long	modifiedRowCount() { return 0L; }
commit:4e6df7a
/////////////////////////////////////////////////////////////////////////
1:     private int                             firstColumn = -1;    // First column being stuffed. For UPDATES, this lies in the second half of the row.
1:     private int[]                           generatedColumnPositions; // 1-based positions of generated columns in the target row
1: 
1:     // One cell for  each slot in generatedColumnPositions. These are temporary
1:     // values which hold the result of running the generation clause before we
1:     // stuff the result into the target row.
1:     private DataValueDescriptor[]  normalizedGeneratedValues;
/////////////////////////////////////////////////////////////////////////
1: 	  * Construct support for normalizing generated columns. This figures out
1: 	  * which columns in the target row have generation clauses which need to be run.
commit:15b837e
/////////////////////////////////////////////////////////////////////////
1: 	  * Compute the generation clauses on the current row in order to fill in
1: 	  * computed columns.
1:       *
1:       * @param generationClauses    the generated method which evaluates generation clauses
1:       * @param activation               the thread-specific instance of the generated class
1:       * @param source                   the tuple stream driving this INSERT/UPDATE
1:       * @param newRow                   the base row being stuffed
1:       * @param isUpdate                 true if this is an UPDATE. false otherwise.
commit:ec4aa98
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.ResultColumnDescriptor;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
/////////////////////////////////////////////////////////////////////////
0:     private int                             firstColumn = -1;
0:     private int[]                           generatedColumnPositions; // 1-based positions
0:     private DataValueDescriptor[]  normalizedGeneratedValues; // one for  each slot in generatedColumnPositions
1: 
/////////////////////////////////////////////////////////////////////////
1:       ExecRow           newRow,
1:       boolean           isUpdate
/////////////////////////////////////////////////////////////////////////
1: 
1:                 //
1:                 // Now apply NOT NULL checks and other coercions. For non-generated columns, these
1:                 // are performed in the driving ResultSet.
1:                 //
1:                 if ( firstColumn < 0 ) { firstColumn = NormalizeResultSet.computeStartColumn( isUpdate, activation.getResultDescription() ); }
1:                 if ( generatedColumnPositions == null ) { setupGeneratedColumns( activation, (ValueRow) newRow ); }
1:                 
1:                 ResultDescription   resultDescription = activation.getResultDescription();
1:                 int                         count = generatedColumnPositions.length;
1: 
1:                 for ( int i = 0; i < count; i++ )
1:                 {
1:                     int         position = generatedColumnPositions[ i ];
1: 
1:                     DataValueDescriptor normalizedColumn = NormalizeResultSet.normalizeColumn
1:                         (
1:                          resultDescription.getColumnDescriptor( position ).getType(),
1:                          newRow,
1:                          position,
1:                          normalizedGeneratedValues[ i ],
1:                          resultDescription
1:                          );
1: 
1:                     newRow.setColumn( position, normalizedColumn );
1:                 }
/////////////////////////////////////////////////////////////////////////
0: 	  * Construct support for normalizing generated columns.
1: 	  */
1:     private void    setupGeneratedColumns( Activation activation, ValueRow newRow )
1:         throws StandardException
1:     {
1:         ResultDescription   resultDescription = activation.getResultDescription();
1:         int                         columnCount = resultDescription.getColumnCount();
1:         ExecRow                 emptyRow = newRow.getNewNullRow();
1:         int                         generatedColumnCount = 0;
1: 
1:         // first count the number of generated columns
1:         for ( int i = 1; i <= columnCount; i++ )
1:         {
1:             if ( i < firstColumn ) { continue; }
1:             
1:             ResultColumnDescriptor  rcd = resultDescription.getColumnDescriptor( i );
1: 
1:             if ( rcd.hasGenerationClause() ) { generatedColumnCount++; }
1:         }
1: 
1:         // now allocate and populate support structures
1:         generatedColumnPositions = new int[ generatedColumnCount ];
1:         normalizedGeneratedValues = new DataValueDescriptor[ generatedColumnCount ];
1: 
1:         int     idx = 0;
1:         for ( int i = 1; i <= columnCount; i++ )
1:         {
1:             if ( i < firstColumn ) { continue; }
1:             
1:             ResultColumnDescriptor  rcd = resultDescription.getColumnDescriptor( i );
1: 
1:             if ( rcd.hasGenerationClause() )
1:             {
1:                 generatedColumnPositions[ idx ] = i;
1:                 normalizedGeneratedValues[ idx ] = emptyRow.getColumn( i );
1: 
1:                 idx++;
1:             }
1:         }
1:     }
1:     
1: 	/**
commit:c533cd2
/////////////////////////////////////////////////////////////////////////
0: 	  * Compute the generation clauses on the current row in order to fill in computed columns.
1: 	  */
1: 	public	void	evaluateGenerationClauses
1: 	(
1: 	  GeneratedMethod generationClauses,
1: 	  Activation activation,
1:       NoPutResultSet    source,
0:       ExecRow           newRow
1: 	)
1: 		throws StandardException
1: 	{
1: 		if (generationClauses != null)
1: 		{
1:             ExecRow oldRow = (ExecRow) activation.getCurrentRow( source.resultSetNumber() );
1: 
1:             //
1:             // We may need to poke the current row into the Activation so that
1:             // it is visible to the method which evaluates the generation
1:             // clause. This is because the generation clause may refer to other
1:             // columns in that row.
1:             //
1:             try {
1:                 source.setCurrentRow( newRow );
1:                 generationClauses.invoke(activation);
1:             }
1:             finally
1:             {
1:                 //
1:                 // We restore the Activation to its state before we ran the generation
1:                 // clause. This may not be necessary but I don't understand all of
1:                 // the paths through the Insert and Update result sets. This
1:                 // defensive coding seems prudent to me.
1:                 //
1:                 if ( oldRow == null ) { source.clearCurrentRow(); }
1:                 else { source.setCurrentRow( oldRow ); }
1:             }
1: 		}
1: 	}
1: 
1: 	/**
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:48a9884
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
1: import org.apache.derby.iapi.sql.execute.xplain.XPLAINVisitor;
/////////////////////////////////////////////////////////////////////////
1:                 // get the RuntimeStatisticsImpl object which is the wrapper for all 
1:                 // statistics
1:                 RunTimeStatistics rsImpl = rssf.getRunTimeStatistics(activation, this, subqueryTrackingArray); 
1:                 // save RTS object in lcc
1:                 lcc.setRunTimeStatisticsObject(rsImpl);
1:                 
1:                 // explain gathered statistics
1:                 XPLAINVisitor visitor =  lcc.getLanguageConnectionFactory().getExecutionFactory().getXPLAINFactory().getXPLAINVisitor();
1:                 visitor.doXPLAIN(rsImpl,activation);
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:75ec275
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void addWarning(SQLWarning w) {
1:         // We're not returning a (JDBC) ResultSet, so add the warning to
1:         // the Activation so that it's included in the warning chain of the
1:         // executing Statement.
1:         getActivation().addWarning(w);
1:     }
1: 
1: 	public SQLWarning getWarnings() {
commit:c69c8b0
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Returns null.
1: 	 */
1: 	public ResultDescription	getResultDescription()
1: 	{
1: 	    return (ResultDescription)null;
1: 	}
commit:300bbeb
/////////////////////////////////////////////////////////////////////////
1:     private NoPutResultSet[] subqueryTrackingArray;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         StatementContext sc = lcc.getStatementContext();
1:         sc.setTopResultSet(this, subqueryTrackingArray);
1: 
1:         // Pick up any materialized subqueries
1:         if (subqueryTrackingArray == null) {
1:             subqueryTrackingArray = sc.getSubqueryTrackingArray();
1:         }
commit:698ab62
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:9a428e4
/////////////////////////////////////////////////////////////////////////
1:             ** DERBY-2353: Also make an exception when the activation is
1:             ** closed. If the activation is closed, the run time statistics
1:             ** object is null and there's nothing to print. This may happen
1:             ** if a top-level result set closes the activation and close() is
1:             ** subsequently called on the child result sets. The information
1:             ** about the children is also printed by the parent, so it's safe
1:             ** to skip printing it.
0: 				!doesCommit() && !activation.isClosed())
commit:6369b54
/////////////////////////////////////////////////////////////////////////
1: 	/** True if the result set has been opened, and not yet closed. */
1: 	private boolean isOpen;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Set up the result set for use. Should always be called from
1: 	 * <code>open()</code>.
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
1: 	void setup() throws StandardException {
1: 		isOpen = true;
1: 	}
1: 
/////////////////////////////////////////////////////////////////////////
1: 		isOpen = false;
/////////////////////////////////////////////////////////////////////////
1: 		return !isOpen;
commit:4eafcf8
/////////////////////////////////////////////////////////////////////////
1: 	 * Find out if the <code>ResultSet</code> is closed.
1: 	 *
1: 	 * @return <code>true</code> if closed, <code>false</code> otherwise
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b4885a6
/////////////////////////////////////////////////////////////////////////
1:                 !doesCommit() && !activation.isClosed() &&
1:                 !lcc.getStatementContext().getStatementWasInvalidated())
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:53ce71e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				ResultSetStatisticsFactory rssf =
1:                     lcc.getLanguageConnectionFactory().
1:                          getExecutionFactory().getResultSetStatisticsFactory();
commit:24e3f7e
/////////////////////////////////////////////////////////////////////////
commit:4358952
/////////////////////////////////////////////////////////////////////////
commit:3237ef5
/////////////////////////////////////////////////////////////////////////
1:  * Abstract ResultSet for implementations that do not return rows.
1:  * Examples are DDL statements, CALL statements and DML.
1:  * <P>
1:  * An implementation must provide a ResultSet.open() method
1:  * that performs the required action. 
1:  * <P>
1:  * ResultSet.returnsRows() returns false and any method
1:  * that fetches a row will throw an exception.
/////////////////////////////////////////////////////////////////////////
0: 		subqueryTrackingArray = sc.getSubqueryTrackingArray();
/////////////////////////////////////////////////////////////////////////
1: 	public final ExecRow	getAbsoluteRow(int row) throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 	public final ExecRow	getRelativeRow(int row) throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 	public final ExecRow	setBeforeFirstRow() 
/////////////////////////////////////////////////////////////////////////
1: 	public final ExecRow	getFirstRow() 
/////////////////////////////////////////////////////////////////////////
1: 	public final ExecRow	getNextRow() throws StandardException
/////////////////////////////////////////////////////////////////////////
1: 	public final ExecRow	getPreviousRow() 
/////////////////////////////////////////////////////////////////////////
1: 	public final ExecRow	getLastRow()
/////////////////////////////////////////////////////////////////////////
1: 	public final ExecRow	setAfterLastRow() 
/////////////////////////////////////////////////////////////////////////
1:     public final boolean checkRowPosition(int isType)
/////////////////////////////////////////////////////////////////////////
1: 	public final int getRowNumber()
commit:1e2aae0
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Timestamp;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.ResultDescription;
1: import org.apache.derby.iapi.sql.ResultSet;
1: import org.apache.derby.iapi.sql.Row;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
commit:6bc9897
/////////////////////////////////////////////////////////////////////////
1: 	final Activation    activation;
0: 	NoPutResultSet[]	subqueryTrackingArray;
/////////////////////////////////////////////////////////////////////////
1: 	final LanguageConnectionContext lcc;
commit:6b26ee1
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	public final Activation getActivation()
1: 	{
1: 		return activation;
1: 	}
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.NoRowsResultSetImpl
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.conn.StatementContext;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
1: 
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.Row;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
0: import java.sql.Timestamp;
0: import java.sql.SQLWarning;
1: 
1: /**
0:  * This implementation of ResultSet
0:  * is meant to be overridden by subtypes
0:  * in the execution engine. Its primary users
0:  * will be DDL, which only need to define a
0:  * constructor to create the DDL object being
0:  * defined. All other ResultSet operations will
0:  * be handled by this superclass -- i.e., nothing
0:  * is allowed to be done to a DDL Result Set, since
0:  * it has no rows to provide.
0:  * <p>
0:  * This abstract class does not define the entire ResultSet
0:  * interface, but leaves the 'get' half of the interface
0:  * for subtypes to implement. It is package-visible only,
0:  * with its methods being public for exposure by its subtypes.
0:  * <p>
1:  *
0:  * @author ames
1:  */
1: abstract class NoRowsResultSetImpl implements ResultSet
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	protected final Activation    activation;
0: 	private boolean isTopResultSet = true;
0: 	private boolean dumpedStats;
0: 	protected NoPutResultSet[]	subqueryTrackingArray;
1: 
1: 	private final boolean statisticsTimingOn;
0: 	private boolean isClosed;
1: 
0: 	/* fields used for formating run time statistics output */
0: 	protected String indent;
0: 	protected String subIndent;
0: 	protected int sourceDepth;
1: 
1: 	/* Run time statistics variables */
0: 	protected final LanguageConnectionContext lcc;
1: 	protected long beginTime;
1: 	protected long endTime;
1: 	protected long beginExecutionTime;
1: 	protected long endExecutionTime;
1: 
1: 	NoRowsResultSetImpl(Activation activation)
1: 		throws StandardException
1: 	{
1: 		this.activation = activation;
1: 
1: 		if (SanityManager.DEBUG) {
1: 			if (activation == null)
1: 				SanityManager.THROWASSERT("activation is null in result set " + getClass());
1: 		}
1: 
1: 		lcc = activation.getLanguageConnectionContext();
1: 		statisticsTimingOn = lcc.getStatisticsTiming();
1: 
1: 		/* NOTE - We can't get the current time until after setting up the
1: 		 * activation, as we end up using the activation to get the 
1: 		 * LanguageConnectionContext.
1: 		 */
1: 		beginTime = getCurrentTimeMillis();
1: 		beginExecutionTime = beginTime;
1: 
0: 		StatementContext sc = lcc.getStatementContext();
0: 		sc.setTopResultSet(this, (NoPutResultSet[]) null);
1: 
0: 		// Pick up any materialized subqueries
1: 		if (subqueryTrackingArray == null)
1: 		{
0: 			subqueryTrackingArray = sc.getSubqueryTrackingArray();
1: 		}
1: 	}
1: 
1:     /**
1: 	 * Returns FALSE
1: 	 */
1: 	 public final boolean	returnsRows() { return false; }
1: 
1: 	/**
1: 	 * Returns zero.
1: 	 */
0: 	public int	modifiedRowCount() { return 0; }
1: 
1: 	/**
0: 	 * Returns null.
1: 	 */
0: 	public ResultDescription	getResultDescription()
1: 	{
0: 	    return (ResultDescription)null;
1: 	}
1: 
1: 	/**
1: 	 * Returns the row at the absolute position from the query, 
1: 	 * and returns NULL when there is no such position.
1: 	 * (Negative position means from the end of the result set.)
1: 	 * Moving the cursor to an invalid position leaves the cursor
1: 	 * positioned either before the first row (negative position)
1: 	 * or after the last row (positive position).
1: 	 * NOTE: An exception will be thrown on 0.
1: 	 *
1: 	 * @param row	The position.
1: 	 * @return	The row at the absolute position, or NULL if no such position.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
0: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
1: 	{
1: 		/*
1: 			The JDBC use of this class will never call here.
1: 			Only the DB API used directly can get this exception.
1: 		 */
1: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "absolute");
1: 	}
1: 
1: 	/**
1: 	 * Returns the row at the relative position from the current
1: 	 * cursor position, and returns NULL when there is no such position.
1: 	 * (Negative position means toward the beginning of the result set.)
1: 	 * Moving the cursor to an invalid position leaves the cursor
1: 	 * positioned either before the first row (negative position)
1: 	 * or after the last row (positive position).
1: 	 * NOTE: 0 is valid.
1: 	 * NOTE: An exception is thrown if the cursor is not currently
1: 	 * positioned on a row.
1: 	 *
1: 	 * @param row	The position.
1: 	 * @return	The row at the relative position, or NULL if no such position.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
0: 	public ExecRow	getRelativeRow(int row) throws StandardException
1: 	{
1: 		/*
1: 			The JDBC use of this class will never call here.
1: 			Only the DB API used directly can get this exception.
1: 		 */
1: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "relative");
1: 	}
1: 
1: 	/**
1: 	 * Sets the current position to before the first row and returns NULL
1: 	 * because there is no current row.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
0: 	public ExecRow	setBeforeFirstRow() 
1: 		throws StandardException
1: 	{
1: 		/*
1: 			The JDBC use of this class will never call here.
1: 			Only the DB API used directly can get this exception.
1: 		 */
1: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "beforeFirst");
1: 	}
1: 
1: 	/**
1: 	 * Returns the first row from the query, and returns NULL when there
1: 	 * are no rows.
1: 	 *
1: 	 * @return	The first row, or NULL if no rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
0: 	public ExecRow	getFirstRow() 
1: 		throws StandardException
1: 	{
1: 		/*
1: 			The JDBC use of this class will never call here.
1: 			Only the DB API used directly can get this exception.
1: 		 */
1: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "first");
1: 	}
1: 
1: 	/**
1:      * No rows to return, so throw an exception.
1: 	 *
1: 	 * @exception StandardException		Always throws a
1: 	 *									StandardException to indicate
1: 	 *									that this method is not intended to
1: 	 *									be used.
1: 	 */
0: 	public ExecRow	getNextRow() throws StandardException
1: 	{
1: 		/*
1: 			The JDBC use of this class will never call here.
1: 			Only the DB API used directly can get this exception.
1: 		 */
1: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "next");
1: 	}
1: 
1: 	/**
1: 	 * Returns the previous row from the query, and returns NULL when there
1: 	 * are no more previous rows.
1: 	 *
1: 	 * @return	The previous row, or NULL if no more previous rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
0: 	public ExecRow	getPreviousRow() 
1: 		throws StandardException
1: 	{
1: 		/*
1: 			The JDBC use of this class will never call here.
1: 			Only the DB API used directly can get this exception.
1: 		 */
1: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "previous");
1: 	}
1: 
1: 	/**
1: 	 * Returns the last row from the query, and returns NULL when there
1: 	 * are no rows.
1: 	 *
1: 	 * @return	The last row, or NULL if no rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
0: 	public ExecRow	getLastRow()
1: 		throws StandardException
1: 	{
1: 		/*
1: 			The JDBC use of this class will never call here.
1: 			Only the DB API used directly can get this exception.
1: 		 */
1: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "last");
1: 	}
1: 
1: 	/**
1: 	 * Sets the current position to after the last row and returns NULL
1: 	 * because there is no current row.
1: 	 *
1: 	 * @return	NULL.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 * @see Row
1: 	 */
0: 	public ExecRow	setAfterLastRow() 
1: 		throws StandardException
1: 	{
1: 		/*
1: 			The JDBC use of this class will never call here.
1: 			Only the DB API used directly can get this exception.
1: 		 */
1: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "afterLast");
1: 	}
1: 
1:     /**
1:      * Determine if the cursor is before the first row in the result 
1:      * set.   
1:      *
1:      * @return true if before the first row, false otherwise. Returns
1:      * false when the result set contains no rows.
1:      */
0:     public boolean checkRowPosition(int isType)
1: 	{
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 * Returns the row number of the current row.  Row
1: 	 * numbers start from 1 and go to 'n'.  Corresponds
1: 	 * to row numbering used to position current row
1: 	 * in the result set (as per JDBC).
1: 	 *
1: 	 * @return	the row number, or 0 if not on a row
1: 	 *
1: 	 */
0: 	public int getRowNumber()
1: 	{
1: 		return 0;
1: 	}
1: 
1: 	/**
0:      * No rows to return, does nothing
1: 	 *
1: 	 * @exception StandardException thrown on error
1: 	 */
0: 	public void	close() throws StandardException
1: 	{ 
0: 		isClosed = true;
1: 	}
1: 
1: 	/**
0: 		Just report that it is always closed.
0: 		RESOLVE: if we don't report that we are closed,
0: 		then we will wind up with a dependency problem when
0: 		we send an invalidateFor on our own Statement.  It
0: 		will call lcc.verifyNoOpenResultSets(), which is really
0: 		supposed to be verify that there are no read only
0: 		result sets that are open.
1: 	 */
1: 	public boolean isClosed() {
0: 		return isClosed;
0: 		//return true;
1: 	}
1: 
1: 	/**
0: 	 *	doesn't need to do anything, as no calls
0: 	 *	are made that need to be restricted once
0: 	 *	the result set is 'finished'.
1: 	 *
0: 	 * @exception StandardException on error
1: 	 */
0: 	public void finish() throws StandardException {
0: 		if (! dumpedStats)
1: 		{
1: 			/*
1: 			** If run time statistics tracing is turned on, then now is the
1: 			** time to dump out the information.
1: 			** NOTE - We make a special exception for commit.  If autocommit
1: 			** is on, then the run time statistics from the autocommit is the
1: 			** only one that the user would ever see.  So, we don't overwrite
1: 			** the run time statistics object for a commit.
1: 			*/
1: 			if (lcc.getRunTimeStatisticsMode() &&
0: 				! doesCommit())
1: 			{
1: 				endExecutionTime = getCurrentTimeMillis();
1: 
0: 				ExecutionContext ec = lcc.getExecutionContext();
0: 				ResultSetStatisticsFactory rssf;
0: 				rssf = ec.getResultSetStatisticsFactory();
1: 
0: 				lcc.setRunTimeStatisticsObject(
0: 					rssf.getRunTimeStatistics(activation, this, subqueryTrackingArray));
1: 
0: 				HeaderPrintWriter istream = lcc.getLogQueryPlan() ? Monitor.getStream() : null;
0: 				if (istream != null)
1: 				{
0: 					istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
0: 											  lcc.getTransactionExecute().getTransactionIdString() +
0: 											  "), " +
0: 											  LanguageConnectionContext.lccStr +
0: 											  lcc.getInstanceNumber() +
0: 											  "), " +
0: 											  lcc.getRunTimeStatisticsObject().getStatementText() + " ******* " +
0: 											  lcc.getRunTimeStatisticsObject().getStatementExecutionPlanText());
1: 				}
1: 			}
0: 			dumpedStats = true;
1: 		}
1: 
1: 		/* This is the top ResultSet, 
1: 		 * close all of the open subqueries.
1: 		 */
1: 		int staLength = (subqueryTrackingArray == null) ? 0 :
1: 							subqueryTrackingArray.length;
1: 
1: 		for (int index = 0; index < staLength; index++)
1: 		{
1: 			if (subqueryTrackingArray[index] == null)
1: 			{
1: 				continue;
1: 			}
1: 			if (subqueryTrackingArray[index].isClosed())
1: 			{
1: 				continue;
1: 			}
1: 			subqueryTrackingArray[index].close();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the execution time in milliseconds.
1: 	 *
1: 	 * @return long		The execution time in milliseconds.
1: 	 */
1: 	public long getExecuteTime()
1: 	{
1: 		return endTime - beginTime;
1: 	}
1: 
1: 	/**
1: 	 * Get the Timestamp for the beginning of execution.
1: 	 *
1: 	 * @return Timestamp		The Timestamp for the beginning of execution.
1: 	 */
1: 	public Timestamp getBeginExecutionTimestamp()
1: 	{
1: 		if (beginExecutionTime == 0)
1: 		{
1: 			return null;
1: 		}
1: 		else
1: 		{
1: 			return new Timestamp(beginExecutionTime);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get the Timestamp for the end of execution.
1: 	 *
1: 	 * @return Timestamp		The Timestamp for the end of execution.
1: 	 */
1: 	public Timestamp getEndExecutionTimestamp()
1: 	{
1: 		if (endExecutionTime == 0)
1: 		{
1: 			return null;
1: 		}
1: 		else
1: 		{
1: 			return new Timestamp(endExecutionTime);
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * RESOLVE - This method will go away once it is overloaded in all subclasses.
1: 	 * Return the query plan as a String.
1: 	 *
1: 	 * @param depth	Indentation level.
1: 	 *
1: 	 * @return String	The query plan as a String.
1: 	 */
1: 	public String getQueryPlanText(int depth)
1: 	{
1: 		return MessageService.getTextMessage(
1: 				SQLState.LANG_GQPT_NOT_SUPPORTED,
1: 				getClass().getName());
1: 	}
1: 
1: 	/**
1: 	 * Return the total amount of time spent in this ResultSet
1: 	 *
1: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
1: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
1: 	 *
1: 	 * @return long		The total amount of time spent (in milliseconds).
1: 	 */
1: 	public long getTimeSpent(int type)
1: 	{
1: 		/* RESOLVE - this should be overloaded in all subclasses */
1: 		return 0;
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSet#getSubqueryTrackingArray
1: 	 */
1: 	public final NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
1: 	{
1: 		if (subqueryTrackingArray == null)
1: 		{
1: 			subqueryTrackingArray = new NoPutResultSet[numSubqueries];
1: 		}
1: 
1: 		return subqueryTrackingArray;
1: 	}
1: 
1: 	/**
1: 	 * @see ResultSet#getAutoGeneratedKeysResultset
1: 	 */
1: 	public ResultSet getAutoGeneratedKeysResultset()
1: 	{
1: 		//A non-null resultset would be returned only for an insert statement 
1: 		return (ResultSet)null;
1: 	}
1: 
1: 	/**
1: 		Return the cursor name, null in this case.
1: 
1: 		@see ResultSet#getCursorName
1: 	*/
1: 	public String getCursorName() {
1: 		return null;
1: 	}
1: 
1: 	// class implementation
1: 
1: 	/**
1: 	 * Return the current time in milliseconds, if DEBUG and RunTimeStats is
1: 	 * on, else return 0.  (Only pay price of system call if need to.)
1: 	 *
1: 	 * @return long		Current time in milliseconds.
1: 	 */
1: 	protected final long getCurrentTimeMillis()
1: 	{
1: 		if (statisticsTimingOn)
1: 		{
1: 			return System.currentTimeMillis();
1: 		}
1: 		else
1: 		{
1: 			return 0;
1: 		}
1: 	}
1: 
1: 	/**
0: 	  *	Run a check constraint against the current row. Raise an error if
0: 	  * the check constraint is violated.
1: 	  *
0: 	  *	@param	checkGM			Generated code to run the check constraint.
0: 	  * @param	checkName		Name of the constraint to check.
0: 	  *	@param	heapConglom		Number of heap conglomerate.
0: 	  *	@param	Activation		Class in which checkGM lives.
1: 	  *
1: 	  * @exception StandardException thrown on error
1: 	  */
0: 	public	static	void	evaluateACheckConstraint
0: 	(
0: 	  GeneratedMethod checkGM,
0: 	  String checkName,
0: 	  long heapConglom,
0: 	  Activation activation
0: 	)
1: 		throws StandardException
1: 	{
0: 		if (checkGM != null)
1: 		{
0: 			DataValueDescriptor checkBoolean;
1: 
0: 			checkBoolean = (DataValueDescriptor) checkGM.invoke(activation);
1: 
0: 			/* Throw exception if check constraint is violated.
0: 			 * (Only if check constraint evaluates to false.)
1: 			 */ 
0: 			if ((checkBoolean != null) &&
0: 				(! checkBoolean.isNull()) &&
0: 				(! checkBoolean.getBoolean()))
1: 			{
0: 				/* Now we have a lot of painful work to get the
0: 				 * table name for the error message.  All we have 
0: 				 * is the conglomerate number to work with.
1: 				 */
0: 				DataDictionary dd = activation.getLanguageConnectionContext().getDataDictionary();
0: 				ConglomerateDescriptor cd = dd.getConglomerateDescriptor( heapConglom );
0: 				TableDescriptor td = dd.getTableDescriptor(cd.getTableID());
1: 
0: 				StandardException se = StandardException.newException(SQLState.LANG_CHECK_CONSTRAINT_VIOLATED, 
0: 					td.getQualifiedName(), checkName);
1: 
0: 				throw se;
1: 			}
1: 		}
1: 
1: 	}
1: 
1: 	/**
0: 	  *	Run check constraints against the current row. Raise an error if
0: 	  * a check constraint is violated.
1: 	  *
0: 	  *	@param	checkGM			Generated code to run the check constraint.
0: 	  *	@param	Activation		Class in which checkGM lives.
1: 	  *
1: 	  * @exception StandardException thrown on error
1: 	  */
0: 	public	static	void	evaluateCheckConstraints
0: 	(
0: 	  GeneratedMethod checkGM,
0: 	  Activation activation
0: 	)
1: 		throws StandardException
1: 	{
0: 		if (checkGM != null)
1: 		{
0: 			// Evaluate the expression containing the check constraints.
0: 			// This expression will throw an exception if there is a
0: 			// violation, so there is no need to check the result.
0: 			checkGM.invoke(activation);
1: 		}
1: 
1: 	}
1: 	  
1: 	/**
1: 	 * Does this ResultSet cause a commit or rollback.
1: 	 *
1: 	 * @return Whether or not this ResultSet cause a commit or rollback.
1: 	 */
1: 	public boolean doesCommit()
1: 	{
1: 		return false;
1: 	}
1: 
0: 	public java.sql.SQLWarning getWarnings() {
1: 		return null;
1: 	}
1: 
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:49e9a9b
/////////////////////////////////////////////////////////////////////////
1: 		if (!isOpen)
1: 			return;
0: 
/////////////////////////////////////////////////////////////////////////
0: 
0: 
0: 		if (activation.isSingleExecution())
1: 			activation.close();
commit:0f4ab91
/////////////////////////////////////////////////////////////////////////
1:      * Dump the stat if not already done so. Close all of the open subqueries.
/////////////////////////////////////////////////////////////////////////
0: 		isOpen = false;
0: 	}
0: 
0: 	/**
0: 	 * Find out if the <code>ResultSet</code> is closed.
0: 	 *
0: 	 * @return <code>true</code> if closed, <code>false</code> otherwise
0: 	 */
0: 	public boolean isClosed() {
0: 		return !isOpen;
0: 	}
0: 
1: 	public void	finish() throws StandardException
0: 	{
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0: 	  *	@param	activation		Class in which checkGM lives.
/////////////////////////////////////////////////////////////////////////
0: 	  *	@param	activation		Class in which checkGM lives.
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:9634cd2
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 * Clear the current row. This is done after a commit on holdable
1: 	 * result sets.
1: 	 * This is a no-op on result set which do not provide rows.
0: 	 */
1: 	public final void clearCurrentRow() 
0: 	{
0: 		
0: 	}
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: import org.apache.derby.iapi.services.stream.InfoStreams;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.conn.StatementContext;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: 
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ResultSetStatisticsFactory;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: import org.apache.derby.iapi.sql.ResultDescription;
0: import org.apache.derby.iapi.sql.Row;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionaryContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import java.sql.Timestamp;
0: import java.sql.SQLWarning;
0: 
0: /**
0:  * This implementation of ResultSet
0:  * is meant to be overridden by subtypes
0:  * in the execution engine. Its primary users
0:  * will be DDL, which only need to define a
0:  * constructor to create the DDL object being
0:  * defined. All other ResultSet operations will
0:  * be handled by this superclass -- i.e., nothing
0:  * is allowed to be done to a DDL Result Set, since
0:  * it has no rows to provide.
0:  * <p>
0:  * This abstract class does not define the entire ResultSet
0:  * interface, but leaves the 'get' half of the interface
0:  * for subtypes to implement. It is package-visible only,
0:  * with its methods being public for exposure by its subtypes.
0:  * <p>
0:  *
0:  * @author ames
0:  */
0: abstract class NoRowsResultSetImpl implements ResultSet
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	protected final Activation    activation;
0: 	private boolean isTopResultSet = true;
0: 	private boolean dumpedStats;
0: 	protected NoPutResultSet[]	subqueryTrackingArray;
0: 
0: 	private final boolean statisticsTimingOn;
0: 	private boolean isClosed;
0: 
0: 	/* fields used for formating run time statistics output */
0: 	protected String indent;
0: 	protected String subIndent;
0: 	protected int sourceDepth;
0: 
0: 	/* Run time statistics variables */
0: 	protected final LanguageConnectionContext lcc;
0: 	protected long beginTime;
0: 	protected long endTime;
0: 	protected long beginExecutionTime;
0: 	protected long endExecutionTime;
0: 
0: 	NoRowsResultSetImpl(Activation activation)
0: 		throws StandardException
0: 	{
0: 		this.activation = activation;
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (activation == null)
0: 				SanityManager.THROWASSERT("activation is null in result set " + getClass());
0: 		}
0: 
0: 		lcc = activation.getLanguageConnectionContext();
0: 		statisticsTimingOn = lcc.getStatisticsTiming();
0: 
0: 		/* NOTE - We can't get the current time until after setting up the
0: 		 * activation, as we end up using the activation to get the 
0: 		 * LanguageConnectionContext.
0: 		 */
0: 		beginTime = getCurrentTimeMillis();
0: 		beginExecutionTime = beginTime;
0: 
0: 		StatementContext sc = lcc.getStatementContext();
0: 		sc.setTopResultSet(this, (NoPutResultSet[]) null);
0: 
0: 		// Pick up any materialized subqueries
0: 		if (subqueryTrackingArray == null)
0: 		{
0: 			subqueryTrackingArray = sc.getSubqueryTrackingArray();
0: 		}
0: 	}
0: 
0:     /**
0: 	 * Returns FALSE
0: 	 */
0: 	 public final boolean	returnsRows() { return false; }
0: 
0: 	/**
0: 	 * Returns zero.
0: 	 */
0: 	public int	modifiedRowCount() { return 0; }
0: 
0: 	/**
0: 	 * Returns null.
0: 	 */
0: 	public ResultDescription	getResultDescription()
0: 	{
0: 	    return (ResultDescription)null;
0: 	}
0: 
0: 	/**
0: 	 * Returns the row at the absolute position from the query, 
0: 	 * and returns NULL when there is no such position.
0: 	 * (Negative position means from the end of the result set.)
0: 	 * Moving the cursor to an invalid position leaves the cursor
0: 	 * positioned either before the first row (negative position)
0: 	 * or after the last row (positive position).
0: 	 * NOTE: An exception will be thrown on 0.
0: 	 *
0: 	 * @param row	The position.
0: 	 * @return	The row at the absolute position, or NULL if no such position.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getAbsoluteRow(int row) throws StandardException
0: 	{
0: 		/*
0: 			The JDBC use of this class will never call here.
0: 			Only the DB API used directly can get this exception.
0: 		 */
0: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "absolute");
0: 	}
0: 
0: 	/**
0: 	 * Returns the row at the relative position from the current
0: 	 * cursor position, and returns NULL when there is no such position.
0: 	 * (Negative position means toward the beginning of the result set.)
0: 	 * Moving the cursor to an invalid position leaves the cursor
0: 	 * positioned either before the first row (negative position)
0: 	 * or after the last row (positive position).
0: 	 * NOTE: 0 is valid.
0: 	 * NOTE: An exception is thrown if the cursor is not currently
0: 	 * positioned on a row.
0: 	 *
0: 	 * @param row	The position.
0: 	 * @return	The row at the relative position, or NULL if no such position.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getRelativeRow(int row) throws StandardException
0: 	{
0: 		/*
0: 			The JDBC use of this class will never call here.
0: 			Only the DB API used directly can get this exception.
0: 		 */
0: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "relative");
0: 	}
0: 
0: 	/**
0: 	 * Sets the current position to before the first row and returns NULL
0: 	 * because there is no current row.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	setBeforeFirstRow() 
0: 		throws StandardException
0: 	{
0: 		/*
0: 			The JDBC use of this class will never call here.
0: 			Only the DB API used directly can get this exception.
0: 		 */
0: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "beforeFirst");
0: 	}
0: 
0: 	/**
0: 	 * Returns the first row from the query, and returns NULL when there
0: 	 * are no rows.
0: 	 *
0: 	 * @return	The first row, or NULL if no rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getFirstRow() 
0: 		throws StandardException
0: 	{
0: 		/*
0: 			The JDBC use of this class will never call here.
0: 			Only the DB API used directly can get this exception.
0: 		 */
0: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "first");
0: 	}
0: 
0: 	/**
0:      * No rows to return, so throw an exception.
0: 	 *
0: 	 * @exception StandardException		Always throws a
0: 	 *									StandardException to indicate
0: 	 *									that this method is not intended to
0: 	 *									be used.
0: 	 */
0: 	public ExecRow	getNextRow() throws StandardException
0: 	{
0: 		/*
0: 			The JDBC use of this class will never call here.
0: 			Only the DB API used directly can get this exception.
0: 		 */
0: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "next");
0: 	}
0: 
0: 	/**
0: 	 * Returns the previous row from the query, and returns NULL when there
0: 	 * are no more previous rows.
0: 	 *
0: 	 * @return	The previous row, or NULL if no more previous rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getPreviousRow() 
0: 		throws StandardException
0: 	{
0: 		/*
0: 			The JDBC use of this class will never call here.
0: 			Only the DB API used directly can get this exception.
0: 		 */
0: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "previous");
0: 	}
0: 
0: 	/**
0: 	 * Returns the last row from the query, and returns NULL when there
0: 	 * are no rows.
0: 	 *
0: 	 * @return	The last row, or NULL if no rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	getLastRow()
0: 		throws StandardException
0: 	{
0: 		/*
0: 			The JDBC use of this class will never call here.
0: 			Only the DB API used directly can get this exception.
0: 		 */
0: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "last");
0: 	}
0: 
0: 	/**
0: 	 * Sets the current position to after the last row and returns NULL
0: 	 * because there is no current row.
0: 	 *
0: 	 * @return	NULL.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see Row
0: 	 */
0: 	public ExecRow	setAfterLastRow() 
0: 		throws StandardException
0: 	{
0: 		/*
0: 			The JDBC use of this class will never call here.
0: 			Only the DB API used directly can get this exception.
0: 		 */
0: 		throw StandardException.newException(SQLState.LANG_DOES_NOT_RETURN_ROWS, "afterLast");
0: 	}
0: 
0:     /**
0:      * Determine if the cursor is before the first row in the result 
0:      * set.   
0:      *
0:      * @return true if before the first row, false otherwise. Returns
0:      * false when the result set contains no rows.
0:      */
0:     public boolean checkRowPosition(int isType)
0: 	{
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 * Returns the row number of the current row.  Row
0: 	 * numbers start from 1 and go to 'n'.  Corresponds
0: 	 * to row numbering used to position current row
0: 	 * in the result set (as per JDBC).
0: 	 *
0: 	 * @return	the row number, or 0 if not on a row
0: 	 *
0: 	 */
0: 	public int getRowNumber()
0: 	{
0: 		return 0;
0: 	}
0: 
0: 	/**
0:      * No rows to return, does nothing
0: 	 *
0: 	 * @exception StandardException thrown on error
0: 	 */
0: 	public void	close() throws StandardException
0: 	{ 
0: 		isClosed = true;
0: 	}
0: 
0: 	/**
0: 		Just report that it is always closed.
0: 		RESOLVE: if we don't report that we are closed,
0: 		then we will wind up with a dependency problem when
0: 		we send an invalidateFor on our own Statement.  It
0: 		will call lcc.verifyNoOpenResultSets(), which is really
0: 		supposed to be verify that there are no read only
0: 		result sets that are open.
0: 	 */
0: 	public boolean isClosed() {
0: 		return isClosed;
0: 		//return true;
0: 	}
0: 
0: 	/**
0: 	 *	doesn't need to do anything, as no calls
0: 	 *	are made that need to be restricted once
0: 	 *	the result set is 'finished'.
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void finish() throws StandardException {
0: 		if (! dumpedStats)
0: 		{
0: 			/*
0: 			** If run time statistics tracing is turned on, then now is the
0: 			** time to dump out the information.
0: 			** NOTE - We make a special exception for commit.  If autocommit
0: 			** is on, then the run time statistics from the autocommit is the
0: 			** only one that the user would ever see.  So, we don't overwrite
0: 			** the run time statistics object for a commit.
0: 			*/
0: 			if (lcc.getRunTimeStatisticsMode() &&
0: 				! doesCommit())
0: 			{
0: 				endExecutionTime = getCurrentTimeMillis();
0: 
0: 				ExecutionContext ec = lcc.getExecutionContext();
0: 				ResultSetStatisticsFactory rssf;
0: 				rssf = ec.getResultSetStatisticsFactory();
0: 
0: 				lcc.setRunTimeStatisticsObject(
0: 					rssf.getRunTimeStatistics(activation, this, subqueryTrackingArray));
0: 
0: 				HeaderPrintWriter istream = lcc.getLogQueryPlan() ? Monitor.getStream() : null;
0: 				if (istream != null)
0: 				{
0: 					istream.printlnWithHeader(LanguageConnectionContext.xidStr + 
0: 											  lcc.getTransactionExecute().getTransactionIdString() +
0: 											  "), " +
0: 											  LanguageConnectionContext.lccStr +
0: 											  lcc.getInstanceNumber() +
0: 											  "), " +
0: 											  lcc.getRunTimeStatisticsObject().getStatementText() + " ******* " +
0: 											  lcc.getRunTimeStatisticsObject().getStatementExecutionPlanText());
0: 				}
0: 			}
0: 			dumpedStats = true;
0: 		}
0: 
0: 		/* This is the top ResultSet, 
0: 		 * close all of the open subqueries.
0: 		 */
0: 		int staLength = (subqueryTrackingArray == null) ? 0 :
0: 							subqueryTrackingArray.length;
0: 
0: 		for (int index = 0; index < staLength; index++)
0: 		{
0: 			if (subqueryTrackingArray[index] == null)
0: 			{
0: 				continue;
0: 			}
0: 			if (subqueryTrackingArray[index].isClosed())
0: 			{
0: 				continue;
0: 			}
0: 			subqueryTrackingArray[index].close();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the execution time in milliseconds.
0: 	 *
0: 	 * @return long		The execution time in milliseconds.
0: 	 */
0: 	public long getExecuteTime()
0: 	{
0: 		return endTime - beginTime;
0: 	}
0: 
0: 	/**
0: 	 * Get the Timestamp for the beginning of execution.
0: 	 *
0: 	 * @return Timestamp		The Timestamp for the beginning of execution.
0: 	 */
0: 	public Timestamp getBeginExecutionTimestamp()
0: 	{
0: 		if (beginExecutionTime == 0)
0: 		{
0: 			return null;
0: 		}
0: 		else
0: 		{
0: 			return new Timestamp(beginExecutionTime);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get the Timestamp for the end of execution.
0: 	 *
0: 	 * @return Timestamp		The Timestamp for the end of execution.
0: 	 */
0: 	public Timestamp getEndExecutionTimestamp()
0: 	{
0: 		if (endExecutionTime == 0)
0: 		{
0: 			return null;
0: 		}
0: 		else
0: 		{
0: 			return new Timestamp(endExecutionTime);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * RESOLVE - This method will go away once it is overloaded in all subclasses.
0: 	 * Return the query plan as a String.
0: 	 *
0: 	 * @param depth	Indentation level.
0: 	 *
0: 	 * @return String	The query plan as a String.
0: 	 */
0: 	public String getQueryPlanText(int depth)
0: 	{
0: 		return MessageService.getTextMessage(
0: 				SQLState.LANG_GQPT_NOT_SUPPORTED,
0: 				getClass().getName());
0: 	}
0: 
0: 	/**
0: 	 * Return the total amount of time spent in this ResultSet
0: 	 *
0: 	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
0: 	 *				ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
0: 	 *
0: 	 * @return long		The total amount of time spent (in milliseconds).
0: 	 */
0: 	public long getTimeSpent(int type)
0: 	{
0: 		/* RESOLVE - this should be overloaded in all subclasses */
0: 		return 0;
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSet#getSubqueryTrackingArray
0: 	 */
0: 	public final NoPutResultSet[] getSubqueryTrackingArray(int numSubqueries)
0: 	{
0: 		if (subqueryTrackingArray == null)
0: 		{
0: 			subqueryTrackingArray = new NoPutResultSet[numSubqueries];
0: 		}
0: 
0: 		return subqueryTrackingArray;
0: 	}
0: 
0: 	/**
0: 	 * @see ResultSet#getAutoGeneratedKeysResultset
0: 	 */
0: 	public ResultSet getAutoGeneratedKeysResultset()
0: 	{
0: 		//A non-null resultset would be returned only for an insert statement 
0: 		return (ResultSet)null;
0: 	}
0: 
0: 	/**
0: 		Return the cursor name, null in this case.
0: 
0: 		@see ResultSet#getCursorName
0: 	*/
0: 	public String getCursorName() {
0: 		return null;
0: 	}
0: 
0: 	// class implementation
0: 
0: 	/**
0: 	 * Return the current time in milliseconds, if DEBUG and RunTimeStats is
0: 	 * on, else return 0.  (Only pay price of system call if need to.)
0: 	 *
0: 	 * @return long		Current time in milliseconds.
0: 	 */
0: 	protected final long getCurrentTimeMillis()
0: 	{
0: 		if (statisticsTimingOn)
0: 		{
0: 			return System.currentTimeMillis();
0: 		}
0: 		else
0: 		{
0: 			return 0;
0: 		}
0: 	}
0: 
0: 	/**
0: 	  *	Run a check constraint against the current row. Raise an error if
0: 	  * the check constraint is violated.
0: 	  *
0: 	  *	@param	checkGM			Generated code to run the check constraint.
0: 	  * @param	checkName		Name of the constraint to check.
0: 	  *	@param	heapConglom		Number of heap conglomerate.
0: 	  *	@param	Activation		Class in which checkGM lives.
0: 	  *
0: 	  * @exception StandardException thrown on error
0: 	  */
0: 	public	static	void	evaluateACheckConstraint
0: 	(
0: 	  GeneratedMethod checkGM,
0: 	  String checkName,
0: 	  long heapConglom,
0: 	  Activation activation
0: 	)
0: 		throws StandardException
0: 	{
0: 		if (checkGM != null)
0: 		{
0: 			DataValueDescriptor checkBoolean;
0: 
0: 			checkBoolean = (DataValueDescriptor) checkGM.invoke(activation);
0: 
0: 			/* Throw exception if check constraint is violated.
0: 			 * (Only if check constraint evaluates to false.)
0: 			 */ 
0: 			if ((checkBoolean != null) &&
0: 				(! checkBoolean.isNull()) &&
0: 				(! checkBoolean.getBoolean()))
0: 			{
0: 				/* Now we have a lot of painful work to get the
0: 				 * table name for the error message.  All we have 
0: 				 * is the conglomerate number to work with.
0: 				 */
0: 				DataDictionary dd = activation.getLanguageConnectionContext().getDataDictionary();
0: 				ConglomerateDescriptor cd = dd.getConglomerateDescriptor( heapConglom );
0: 				TableDescriptor td = dd.getTableDescriptor(cd.getTableID());
0: 
0: 				StandardException se = StandardException.newException(SQLState.LANG_CHECK_CONSTRAINT_VIOLATED, 
0: 					td.getQualifiedName(), checkName);
0: 
0: 				throw se;
0: 			}
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	  *	Run check constraints against the current row. Raise an error if
0: 	  * a check constraint is violated.
0: 	  *
0: 	  *	@param	checkGM			Generated code to run the check constraint.
0: 	  *	@param	Activation		Class in which checkGM lives.
0: 	  *
0: 	  * @exception StandardException thrown on error
0: 	  */
0: 	public	static	void	evaluateCheckConstraints
0: 	(
0: 	  GeneratedMethod checkGM,
0: 	  Activation activation
0: 	)
0: 		throws StandardException
0: 	{
0: 		if (checkGM != null)
0: 		{
0: 			// Evaluate the expression containing the check constraints.
0: 			// This expression will throw an exception if there is a
0: 			// violation, so there is no need to check the result.
0: 			checkGM.invoke(activation);
0: 		}
0: 
0: 	}
0: 	  
0: 	/**
0: 	 * Does this ResultSet cause a commit or rollback.
0: 	 *
0: 	 * @return Whether or not this ResultSet cause a commit or rollback.
0: 	 */
0: 	public boolean doesCommit()
0: 	{
0: 		return false;
0: 	}
0: 
0: 	public java.sql.SQLWarning getWarnings() {
0: 		return null;
0: 	}
0: 
0: }
============================================================================