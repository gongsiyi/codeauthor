1:33776ff: /*
59:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.ColumnMetaData
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
2:33776ff: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:d506170: 
1:69e3d06: import java.sql.ResultSet;
1:69e3d06: import java.sql.ResultSetMetaData;
1:d506170: import java.sql.SQLException;
1:69e3d06: import java.sql.Types;
1:4772c7e: import java.util.Hashtable;
1:90731d5: import org.apache.derby.iapi.reference.DRDAConstants;
1:e33b8d8: import org.apache.derby.iapi.reference.JDBC40Translation;
1:ed225ae: import org.apache.derby.shared.common.reference.SQLState;
1:90731d5: 
1:33776ff: // Under JDBC 2, we must new up our parameter meta data as column meta data instances
1:33776ff: // Once we move to JDK 1.4 pre-req, create a ResultSetMetaData class and make this class abstract
1:33776ff: 
1:69e3d06: public class ColumnMetaData implements ResultSetMetaData {
1:33776ff: 
1:70f7692:     public int columns_;
1:33776ff: 
1:70f7692:     public boolean[] nullable_;
1:33776ff: 
1:70f7692:     // All of the following state data comes from the SQLDA reply.
1:33776ff: 
1:70f7692:     //Data from SQLDHGRP
1:70f7692:     public short sqldHold_;
1:70f7692:     public short sqldReturn_;
1:70f7692:     public short sqldScroll_;
1:70f7692:     public short sqldSensitive_;
1:70f7692:     public short sqldFcode_;
1:70f7692:     public short sqldKeytype_;
1:70f7692:     public String sqldRdbnam_; // catalog name, not used by driver, placeholder only
1:70f7692:     public String sqldSchema_; // schema name, not used by driver, placeholder only
1:33776ff: 
1:70f7692:     //data comes from SQLDAGRP
1:70f7692:     public int[] sqlPrecision_; // adjusted sqllen;
1:70f7692:     public int[] sqlScale_;
1:70f7692:     public long[] sqlLength_;  // This is maximum length for varchar fields
1:70f7692:     // These are the derby sql types, for use only by ResultSetMetaData, other code should use jdbcTypes_.
1:70f7692:     // sqlTypes_ is currently not set for input column meta data.
1:70f7692:     public int[] sqlType_;
1:70f7692:     public int[] sqlCcsid_;
1:33776ff: 
1:70f7692:     // With the exception of sqlNames_ and sqlxParmmode_, the following members are only allocated when needed
1:33776ff: 
1:70f7692:     //Data from SQLDOPTGRP
1:70f7692:     public String[] sqlName_;   // column name, pre-allocated
1:70f7692:     public String[] sqlLabel_;  // column label
1:70f7692:     public short[] sqlUnnamed_;
1:70f7692:     public String[] sqlComment_;
1:506f4c8:     public String[] sqlUDTname_;
1:506f4c8:     public String[] sqlUDTclassName_;
1:33776ff: 
1:70f7692:     //Data from SQLDXGRP
1:70f7692:     public short[] sqlxKeymem_;
1:70f7692:     public short[] sqlxGenerated_;
1:70f7692:     public short[] sqlxParmmode_; // pre-allocated
1:70f7692:     public String[] sqlxCorname_;
1:70f7692:     public String[] sqlxName_;
1:70f7692:     public String[] sqlxBasename_;  // table name
1:70f7692:     public int[] sqlxUpdatable_;
1:70f7692:     public String[] sqlxSchema_;    // schema name
1:70f7692:     public String[] sqlxRdbnam_;    // catalog name
1:33776ff: 
1:70f7692:     //-----------------------------transient state--------------------------------
1:33776ff: 
1:70f7692:     // For performance only, not part of logical model.
1:70f7692:     public transient int[][] protocolTypesCache_ = null;
1:33776ff: 
1:70f7692:     public transient int[] types_;
1:70f7692:     public transient int[] clientParamtertype_;
1:33776ff: 
1:0326967:     private transient LogWriter logWriter_;
1:33776ff: 
1:70f7692:     // only set on execute replies, this is not describe information.
1:70f7692:     // only used for result set meta data.
1:33776ff: 
1:0326967:     transient int resultSetConcurrency_;
1:33776ff: 
1:4772c7e:     transient private Hashtable<String, Integer> columnNameToIndexCache_;
1:33776ff: 
1:70f7692:     transient private boolean statementClosed_ = false;
1:70f7692: 
1:70f7692:     void markClosed() {
1:70f7692:         statementClosed_ = true;
1:70f7692:         nullDataForGC();
40:70f7692:     }
1:70f7692: 
1:0326967:     private void checkForClosedStatement() throws SqlException {
1:70f7692:         // agent_.checkForDeferredExceptions();
1:70f7692:         if (statementClosed_) {
1:ed225ae:             throw new SqlException(logWriter_, 
1:6eb29f6:                     new ClientMessageId (SQLState.LANG_STATEMENT_CLOSED_NO_REASON));
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     //---------------------navigational members-----------------------------------
1:33776ff: 
1:70f7692:     //---------------------constructors/finalizer---------------------------------
1:33776ff: 
1:70f7692:     // Called by NETColumnMetaData constructor before #columns is parsed out yet.
1:70f7692:     public ColumnMetaData(LogWriter logWriter) {
1:70f7692:         logWriter_ = logWriter;
1:70f7692:     }
1:33776ff: 
1:70f7692:     // For creating column meta data when describe input is not available.
1:70f7692:     // The upper bound that is passed in is determined by counting the number of parameter markers.
1:70f7692:     // Called by PreparedStatement.flowPrepareStatement() and flowDescribeInputOutput()
1:70f7692:     // only when describe input is not available.
1:70f7692:     public ColumnMetaData(LogWriter logWriter, int upperBound) {
1:70f7692:         logWriter_ = logWriter;
1:70f7692:         initializeCache(upperBound);
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     public void initializeCache(int upperBound) {
1:70f7692:         columns_ = upperBound;
1:70f7692:         nullable_ = new boolean[upperBound];
1:70f7692:         types_ = new int[upperBound];
1:70f7692:         clientParamtertype_ = new int[upperBound];
1:33776ff: 
1:70f7692:         sqlPrecision_ = new int[upperBound];
1:70f7692:         sqlScale_ = new int[upperBound];
1:70f7692:         sqlLength_ = new long[upperBound];
1:70f7692:         sqlType_ = new int[upperBound];
1:70f7692:         sqlCcsid_ = new int[upperBound];
1:33776ff: 
1:70f7692:         sqlName_ = new String[upperBound];
1:70f7692:         sqlxParmmode_ = new short[upperBound];
1:506f4c8: 
1:506f4c8:         sqlUDTname_ = new String[upperBound];
1:506f4c8:         sqlUDTclassName_ = new String[upperBound];
1:70f7692:     }
1:33776ff: 
1:70f7692:     //--------------------Abstract material layer call-down methods-----------------
1:33776ff: 
1:70f7692:     //------------------material layer event callback methods-----------------------
1:70f7692: 
1:70f7692:     // ---------------------------jdbc 1------------------------------------------
1:70f7692: 
1:d506170:     public int getColumnCount() throws SQLException {
1:d506170:         try
1:d506170:         {            
1:d506170:             checkForClosedStatement();
1:d506170:             return columns_;
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean isAutoIncrement(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:2dabb85:             if( sqlxGenerated_[column - 1] == 2) {
1:2dabb85:                 return true;
1:2dabb85:             }
1:d506170:             return false;
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean isCaseSensitive(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             //return true if the SQLTYPE is CHAR, VARCHAR, LOGVARCHAR or CLOB
1:d506170:             int type = types_[column - 1];
1:69e3d06:             return
1:69e3d06:                     type == ClientTypes.CHAR ||
1:69e3d06:                     type == ClientTypes.VARCHAR ||
1:69e3d06:                     type == ClientTypes.LONGVARCHAR ||
1:69e3d06:                     type == ClientTypes.CLOB;
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // all searchable except distinct
1:d506170:     public boolean isSearchable(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             return true;
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean isCurrency(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             return false;
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public int isNullable(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             if (nullable_[column - 1]) {
1:69e3d06:                 return ResultSetMetaData.columnNullable;
1:d506170:             } else {
1:69e3d06:                 return ResultSetMetaData.columnNoNulls;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean isSigned(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             //return true only if the SQLType is SMALLINT, INT, BIGINT, FLOAT, REAL, DOUBLE, NUMERIC OR DECIMAL
1:d506170:             int type = types_[column - 1];
2:d506170:             return
1:69e3d06:                     type == ClientTypes.SMALLINT ||
1:69e3d06:                     type == ClientTypes.INTEGER ||
1:69e3d06:                     type == ClientTypes.BIGINT ||
1:69e3d06:                     type == Types.FLOAT ||
1:69e3d06:                     type == ClientTypes.REAL ||
1:69e3d06:                     type == ClientTypes.DOUBLE ||
1:69e3d06:                     type == Types.NUMERIC ||
1:69e3d06:                     type == ClientTypes.DECIMAL;
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:70f7692: }
1:70f7692: 
1:d506170:     public int getColumnDisplaySize(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             int jdbcType = types_[column - 1];
1:d506170:             switch (jdbcType) {
1:69e3d06:             case ClientTypes.BOOLEAN:
1:eff3919:                 return 5;
1:69e3d06:             case ClientTypes.INTEGER:
1:d506170:                 return 11;
1:69e3d06:             case ClientTypes.SMALLINT:
2:d506170:                 return 6;
1:69e3d06:             case ClientTypes.BIGINT:
1:d506170:                 return 20;
1:69e3d06:             case ClientTypes.REAL:
1:c0a5ce1:                 return 15;
1:69e3d06:             case ClientTypes.DOUBLE:
1:69e3d06:             case Types.FLOAT:
1:c0a5ce1:                 return 24;
1:69e3d06:             case ClientTypes.DECIMAL:
1:69e3d06:             case Types.NUMERIC:
1:6eb29f6:         // There are 3 possible cases with respect to finding the correct max width for DECIMAL type.
1:6eb29f6:         // 1. If scale = 0, only sign should be added to precision.
1:6eb29f6:         // 2. scale = precision, 3 should be added to precision for sign, decimal and an additional char '0'.
1:6eb29f6:         // 3. precision > scale > 0, 2 should be added to precision for sign and decimal.
1:6eb29f6:         int scale = getScale(column);
1:6eb29f6:         int precision = getPrecision(column);
1:6eb29f6:         return (scale == 0) ? (precision + 1) : ((scale == precision) ? (precision + 3) : (precision + 2));
1:69e3d06:             case ClientTypes.CHAR:
1:69e3d06:             case ClientTypes.VARCHAR:
1:69e3d06:             case ClientTypes.LONGVARCHAR:
1:69e3d06:             case ClientTypes.CLOB:
1:d506170:                 return (int) sqlLength_[column - 1];
1:69e3d06:             case ClientTypes.DATE:
1:d506170:                 return 10;
1:69e3d06:             case ClientTypes.TIME:
1:d506170:                 return 8;
1:69e3d06:             case ClientTypes.TIMESTAMP:
1:1e90bf4:                 return 29;
1:69e3d06:             case ClientTypes.JAVA_OBJECT:
1:e33b8d8:                 return JDBC40Translation.DEFAULT_COLUMN_DISPLAY_SIZE;
1:69e3d06:             case ClientTypes.BINARY:
1:69e3d06:             case ClientTypes.VARBINARY:
1:69e3d06:             case ClientTypes.LONGVARBINARY:
1:69e3d06:             case ClientTypes.BLOB:
1:6eb29f6:         // Derby-2425. For long length values, size overflows the int 
1:6eb29f6:         // range. In such cases, the size is limited to the max. int value
1:6eb29f6:         // This behavior is consistent with the same in Embedded mode.
1:6eb29f6:         int size = (int) (2 * sqlLength_[column - 1]);  // eg. "FF" represents just one byte
1:6eb29f6:         if ( size < 0 )
1:6eb29f6:             size = Integer.MAX_VALUE;
1:96c0a0e:                 return size;
1:d506170:             default:
1:ed225ae:                 throw new SqlException(logWriter_, 
1:6eb29f6:                         new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public String getColumnLabel(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             // return labels if label is turned on, otherwise, return column name
1:d506170:             if (sqlLabel_ != null && sqlLabel_[column - 1] != null) {
1:d506170:                 return sqlLabel_[column - 1];
1:d506170:             }
1:d506170:             if (sqlName_ == null || sqlName_[column - 1] == null) {
1:d506170:                 assignColumnName(column);
1:d506170:             }
1:d506170:             return sqlName_[column - 1];
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:70f7692:     }
1:d506170: 
1:d506170:     public String getColumnName(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             // The Javadoc and Jdbc book explicitly state that the empty string ("") is returned if "not applicable"
1:d506170:             // for the following methods:
1:d506170:             //   getSchemaName()
1:d506170:             //   getTableName()
1:d506170:             //   getCatalogName()
1:d506170:             // Since the empty string is a valid string and is not really a proper table name, schema name, or catalog name,
1:d506170:             // we're not sure why the empty string was chosen over null, except possibly to be friendly to lazy jdbc apps
1:d506170:             // that may not be checking for nulls, thereby minimizing potential NPE's.
1:d506170:             // By induction, it would make sense to return the empty string when column name is not available/applicable.
3:d506170:             //
1:d506170:             // The JDBC specification contains blanket statements about SQL compliance levels,
1:d506170:             // so elaboration within the JDBC specification is often bypassed.
1:d506170:             // Personally, I would prefer to return Java null for all the not-applicable cases,
1:d506170:             // but it appears that we have precedent for the empty ("") string.
1:d506170:             //
1:d506170:             // We assume a straightforward induction from jdbc spec that the column name be "" (empty)
1:d506170:             // in preference to null or NULL for the not applicable case.
1:d506170:             //
1:d506170:             if (sqlName_ == null || sqlName_[column - 1] == null) {
1:d506170:                 assignColumnName(column);
1:d506170:             }
1:d506170:             return sqlName_[column - 1];
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:d506170:     }
1:d506170: 
1:d506170:     public String getSchemaName(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             if (sqlxSchema_ == null || sqlxSchema_[column - 1] == null) {
1:d506170:                 return ""; // Per jdbc spec
1:d506170:             }
1:d506170:             return sqlxSchema_[column - 1];
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:d506170:     }
1:d506170: 
1:d506170:     public int getPrecision(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             int jdbcType = types_[column - 1];
1:d506170: 
1:d506170:             switch (jdbcType) {
1:69e3d06:             case ClientTypes.BOOLEAN:
1:eff3919:                 return 1;
1:69e3d06:             case Types.NUMERIC:
1:69e3d06:             case ClientTypes.DECIMAL:
1:d506170:                 return sqlPrecision_[column - 1];
1:69e3d06:             case ClientTypes.SMALLINT:
1:90731d5:                 return 5;
1:69e3d06:             case ClientTypes.INTEGER:
1:d506170:                 return 10;
1:69e3d06:             case ClientTypes.BIGINT:
1:d506170:                 return 19;
1:69e3d06:             case Types.FLOAT:
1:d506170:                 return 15;
1:69e3d06:             case ClientTypes.REAL:
1:d506170:                 return 7;  // This is the number of signed digits for IEEE float with mantissa 24, ie. 2^24
1:69e3d06:             case ClientTypes.DOUBLE:
1:d506170:                 return 15; // This is the number of signed digits for IEEE float with mantissa 24, ie. 2^24
1:69e3d06:             case ClientTypes.CHAR:
1:69e3d06:             case ClientTypes.VARCHAR:
1:69e3d06:             case ClientTypes.LONGVARCHAR:
1:69e3d06:             case ClientTypes.BINARY:
1:69e3d06:             case ClientTypes.VARBINARY:
1:69e3d06:             case ClientTypes.LONGVARBINARY:
1:69e3d06:             case ClientTypes.CLOB:
1:69e3d06:             case ClientTypes.BLOB:
1:d506170:                 return (int) sqlLength_[column - 1];
1:69e3d06:             case ClientTypes.DATE:
1:d506170:                 return 10;
1:69e3d06:             case ClientTypes.TIME:
1:d506170:                 return 8;
1:69e3d06:             case ClientTypes.TIMESTAMP:
1:1e90bf4:                 return 29;
1:69e3d06:             case ClientTypes.JAVA_OBJECT:
1:e33b8d8:                 return JDBC40Translation.UNKNOWN_PRECISION;
1:d506170:             default:
1:ed225ae:                 throw new SqlException(logWriter_, 
1:6eb29f6:                         new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:d506170:     }
1:d506170: 
1:d506170:     public int getScale(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170: 
1:d506170:             return sqlScale_[column - 1];
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:d506170:     }
1:d506170: 
1:d506170:     public String getTableName(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             if (sqlxBasename_ == null || sqlxBasename_[column - 1] == null) {
1:d506170:                 return ""; // Per jdbc spec
1:d506170:             }
1:d506170:             return sqlxBasename_[column - 1];
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:d506170: 
1:33776ff:     /**
1:33776ff:      * What's a column's table's catalog name?
1:33776ff:      *
1:33776ff:      * @param column the first column is 1, the second is 2, ...
1:70f7692:      *
1:33776ff:      * @return column name or "" if not applicable.
1:70f7692:      *
1:70f7692:      * @throws SQLException thrown on failure
1:ed225ae:      */
1:d506170:     public String getCatalogName(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             return "";
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public int getColumnType(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170: 
1:d506170:             return types_[column - 1];
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public String getColumnTypeName(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170: 
1:d506170:             int jdbcType = types_[column - 1];
1:d506170:             // So these all come back zero for downlevel servers in PROTOCOL.
1:d506170:             // John is going to write some code to construct the sqlType_ array
1:d506170:             // based on the protocol types from the query descriptor.
1:d506170:             int sqlType = sqlType_[column - 1];
1:d506170: 
1:d506170:             switch (sqlType) {
1:eff3919:             case DRDAConstants.DB2_SQLTYPE_BOOLEAN:
1:eff3919:             case DRDAConstants.DB2_SQLTYPE_NBOOLEAN:
1:eff3919:                 return "BOOLEAN";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_DATE:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NDATE:
1:d506170:                 return "DATE";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_TIME:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NTIME:
1:d506170:                 return "TIME";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_TIMESTAMP:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NTIMESTAMP:
1:d506170:                 return "TIMESTAMP";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_BLOB:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NBLOB:
1:d506170:                 return "BLOB";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_CLOB:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NCLOB:
1:d506170:                 return "CLOB";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_VARCHAR:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NVARCHAR:
1:69e3d06:                 if (jdbcType == ClientTypes.VARBINARY) {
1:d506170:                     return "VARCHAR FOR BIT DATA";
1:d506170:                 } else {
1:d506170:                     return "VARCHAR";
1:d506170:                 }
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_CHAR:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NCHAR:
1:69e3d06:                 if (jdbcType == ClientTypes.BINARY) {
1:d506170:                     return "CHAR FOR BIT DATA";
1:d506170:                 } else {
1:d506170:                     return "CHAR";
1:d506170:                 }
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_LONG:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NLONG:
1:69e3d06:                 if (jdbcType == ClientTypes.LONGVARBINARY) {
1:d506170:                     return "LONG VARCHAR FOR BIT DATA";
1:d506170:                 } else {
1:d506170:                     return "LONG VARCHAR";
1:d506170:                 }
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_CSTR:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NCSTR:
1:d506170:                 return "SBCS";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_FLOAT:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NFLOAT:
1:69e3d06:                 if (jdbcType == ClientTypes.DOUBLE) {
1:d506170:                     return "DOUBLE";
1:d506170:                 }
1:69e3d06:                 if (jdbcType == ClientTypes.REAL) {
1:d506170:                     return "REAL";
1:d506170:                 }
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_DECIMAL:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NDECIMAL:
1:d506170:                 return "DECIMAL";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_BIGINT:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NBIGINT:
1:d506170:                 return "BIGINT";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_INTEGER:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NINTEGER:
1:d506170:                 return "INTEGER";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_SMALL:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NSMALL:
1:d506170:                 return "SMALLINT";
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NUMERIC:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_NNUMERIC:
1:d506170:                 return "NUMERIC";
1:506f4c8:             case DRDAConstants.DB2_SQLTYPE_FAKE_UDT:
1:506f4c8:             case DRDAConstants.DB2_SQLTYPE_FAKE_NUDT:
1:506f4c8:                 return sqlUDTname_[ column - 1 ];
1:d506170:             default:
1:ed225ae:                 throw new SqlException(logWriter_, 
1:6eb29f6:                         new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean isReadOnly(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             if (sqlxUpdatable_ == null) {
1:69e3d06:                 // If no extended describe, return resultSet's concurrency
1:69e3d06:                 return resultSetConcurrency_ ==
1:69e3d06:                        ResultSet.CONCUR_READ_ONLY;
1:d506170:             }
1:d506170:             return sqlxUpdatable_[column - 1] == 0; // PROTOCOL 0 means not updatable, 1 means updatable
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:d506170:     }
1:d506170: 
1:d506170:     public boolean isWritable(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             if (sqlxUpdatable_ == null) {
1:69e3d06:                 // If no extended describe, return resultSet's concurrency
1:69e3d06:                 return resultSetConcurrency_ ==
1:69e3d06:                        ResultSet.CONCUR_UPDATABLE;
1:d506170:             }
1:d506170:             return sqlxUpdatable_[column - 1] == 1; // PROTOCOL 0 means not updatable, 1 means updatable
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:d506170:     }
1:d506170: 
1:d506170:     public boolean isDefinitelyWritable(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:d506170:             if (sqlxUpdatable_ == null) {
1:d506170:                 return false;
1:d506170:             }
1:d506170:             return sqlxUpdatable_[column - 1] == 1; // PROTOCOL 0 means not updatable, 1 means updatable
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     //--------------------------jdbc 2.0-----------------------------------
1:70f7692: 
1:d506170:     public String getColumnClassName(int column) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             checkForClosedStatement();
1:d506170:             checkForValidColumnIndex(column);
1:70f7692: 
1:d506170:             int jdbcType = types_[column - 1];
1:d506170:             switch (jdbcType) {
1:69e3d06:             case Types.BOOLEAN:
1:eff3919:                 return "java.lang.Boolean";
1:69e3d06:             case Types.BIT:
1:d506170:                 return "java.lang.Boolean";
1:69e3d06:             case Types.TINYINT:
1:d506170:                 return "java.lang.Integer";
1:69e3d06:             case ClientTypes.SMALLINT:
1:d506170:                 return "java.lang.Integer";
1:69e3d06:             case ClientTypes.INTEGER:
1:d506170:                 return "java.lang.Integer";
1:69e3d06:             case ClientTypes.BIGINT:
1:d506170:                 return "java.lang.Long";
1:69e3d06:             case Types.FLOAT:
1:d506170:                 return "java.lang.Double";
1:69e3d06:             case ClientTypes.REAL:
1:d506170:                 return "java.lang.Float";
1:69e3d06:             case ClientTypes.DOUBLE:
1:d506170:                 return "java.lang.Double";
1:69e3d06:             case Types.NUMERIC:
1:69e3d06:             case ClientTypes.DECIMAL:
1:d506170:                 return "java.math.BigDecimal";
1:69e3d06:             case ClientTypes.CHAR:
1:69e3d06:             case ClientTypes.VARCHAR:
1:69e3d06:             case ClientTypes.LONGVARCHAR:
1:d506170:                 return "java.lang.String";
1:69e3d06:             case ClientTypes.DATE:
1:d506170:                 return "java.sql.Date";
1:69e3d06:             case ClientTypes.TIME:
1:d506170:                 return "java.sql.Time";
1:69e3d06:             case ClientTypes.TIMESTAMP:
1:d506170:                 return "java.sql.Timestamp";
1:69e3d06:             case ClientTypes.BINARY:
1:69e3d06:             case ClientTypes.VARBINARY:
1:69e3d06:             case ClientTypes.LONGVARBINARY:
1:d506170:                 return "byte[]";
1:69e3d06:             case Types.STRUCT:
1:d506170:                 return "java.sql.Struct";
1:69e3d06:             case Types.ARRAY:
1:d506170:                 return "java.sql.Array";
1:69e3d06:             case ClientTypes.BLOB:
1:d506170:                 return "java.sql.Blob";
1:69e3d06:             case ClientTypes.CLOB:
1:d506170:                 return "java.sql.Clob";
1:69e3d06:             case Types.REF:
1:d506170:                 return "java.sql.Ref";
1:69e3d06:             case Types.JAVA_OBJECT:
1:506f4c8:                 return sqlUDTclassName_[ column - 1 ];
1:d506170:             default:
1:ed225ae:                 throw new SqlException(logWriter_, 
1:6eb29f6:                         new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException e )
1:d506170:         {
1:d506170:             throw e.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:70f7692:     //----------------------------helper methods----------------------------------
1:70f7692: 
1:70f7692: 
1:70f7692:     void checkForValidColumnIndex(int column) throws SqlException {
1:70f7692:         if (column < 1 || column > columns_) {
1:ed225ae:             throw new SqlException(logWriter_, 
1:6eb29f6:                     new ClientMessageId (SQLState.LANG_INVALID_COLUMN_POSITION),
1:66527ec:                     column, columns_);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void setLogWriter(LogWriter logWriter) {
1:70f7692:         logWriter_ = logWriter;
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void nullDataForGC() {
1:70f7692:         columns_ = 0;
1:70f7692:         nullable_ = null;
1:70f7692:         types_ = null;
1:70f7692:         sqldRdbnam_ = null;
1:70f7692:         sqldSchema_ = null;
1:70f7692:         sqlPrecision_ = null;
1:70f7692:         sqlScale_ = null;
1:70f7692:         sqlLength_ = null;
1:70f7692:         sqlType_ = null;
1:70f7692:         sqlCcsid_ = null;
1:70f7692:         sqlName_ = null;
1:70f7692:         sqlLabel_ = null;
1:70f7692:         sqlUnnamed_ = null;
1:70f7692:         sqlComment_ = null;
1:506f4c8:         sqlUDTname_ = null;
1:506f4c8:         sqlUDTclassName_ = null;
1:70f7692:         sqlxKeymem_ = null;
1:70f7692:         sqlxGenerated_ = null;
1:70f7692:         sqlxParmmode_ = null;
1:70f7692:         sqlxCorname_ = null;
1:70f7692:         sqlxName_ = null;
1:70f7692:         sqlxBasename_ = null;
1:70f7692:         sqlxUpdatable_ = null;
1:70f7692:         sqlxSchema_ = null;
1:70f7692:         sqlxRdbnam_ = null;
1:70f7692:         clientParamtertype_ = null;
1:70f7692:         types_ = null;
1:70f7692:     }
1:70f7692: 
1:0326967:     boolean hasLobColumns() {
1:70f7692:         for (int i = 0; i < columns_; i++) {
1:b13b17c:             switch (Utils.getNonNullableSqlType(sqlType_[i])) {
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_BLOB:
1:90731d5:             case DRDAConstants.DB2_SQLTYPE_CLOB:
3:70f7692:                 return true;
8:70f7692:             default:
1:90731d5:                 break;
1:70f7692:             }
1:70f7692:         }
5:70f7692:         return false;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Cache the hashtable in ColumnMetaData.
1:70f7692:     int findColumnX(String columnName) throws SqlException {
1:70f7692:         // Create cache if it doesn't exist
1:70f7692:         if (columnNameToIndexCache_ == null) {
1:4772c7e:             columnNameToIndexCache_ = new Hashtable<String, Integer>();
1:70f7692:         } else { // Check cache for mapping
1:4772c7e:             Integer index = columnNameToIndexCache_.get(columnName);
1:70f7692:             if (index != null) {
1:70f7692:                 return index.intValue();
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         // Ok, we'll have to search the metadata
1:70f7692:         for (int col = 0; col < this.columns_; col++) {
1:70f7692:             if (this.sqlName_ != null && // sqlName comes from an optional group
1:70f7692:                     this.sqlName_[col] != null &&
1:70f7692:                     this.sqlName_[col].equalsIgnoreCase(columnName)) {
1:70f7692:                 // Found it, add it to the cache
1:4772c7e:                 columnNameToIndexCache_.put(columnName, col + 1);
1:70f7692:                 return col + 1;
1:70f7692:             }
1:70f7692:         }
2:ed225ae:         throw new SqlException(logWriter_, 
1:6eb29f6:                 new ClientMessageId (SQLState.INVALID_COLUMN_NAME), columnName);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // assign ordinal position as the column name if null.
1:0326967:     private void assignColumnName(int column) {
1:70f7692:         if (columnNameToIndexCache_ == null) {
1:4772c7e:             columnNameToIndexCache_ = new Hashtable<String, Integer>();
1:70f7692:         }
1:4772c7e:         String columnName = Integer.toString(column);
1:4772c7e:         columnNameToIndexCache_.put(columnName, column);
1:70f7692:         sqlName_[column - 1] = columnName;
1:70f7692:     }
1:70f7692: 
1:5ef7a0d:     // JDBC 4.0 java.sql.Wrapper interface methods
1:5ef7a0d: 
1:5ef7a0d:     /**
1:5ef7a0d:      * Check whether this instance wraps an object that implements the interface
1:5ef7a0d:      * specified by {@code iface}.
1:5ef7a0d:      *
1:5ef7a0d:      * @param iface a class defining an interface
1:5ef7a0d:      * @return {@code true} if this instance implements {@code iface}, or
1:5ef7a0d:      * {@code false} otherwise
1:5ef7a0d:      * @throws SQLException if an error occurs while determining if this
1:5ef7a0d:      * instance implements {@code iface}
1:5ef7a0d:      */
1:5ef7a0d:     public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:5ef7a0d:         return iface.isInstance(this);
1:5ef7a0d:     }
1:5ef7a0d: 
1:5ef7a0d:     /**
1:5ef7a0d:      * Returns {@code this} if this class implements the specified interface.
1:5ef7a0d:      *
1:5ef7a0d:      * @param  iface a class defining an interface
1:5ef7a0d:      * @return an object that implements the interface
1:5ef7a0d:      * @throws SQLException if no object is found that implements the
1:5ef7a0d:      * interface
1:5ef7a0d:      */
1:5ef7a0d:     public <T> T unwrap(Class<T> iface) throws SQLException {
1:5ef7a0d:         try {
1:5ef7a0d:             return iface.cast(this);
1:5ef7a0d:         } catch (ClassCastException cce) {
1:5ef7a0d:             throw new SqlException(null,
1:5ef7a0d:                     new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
1:5ef7a0d:                     iface).getSQLException();
1:5ef7a0d:         }
1:5ef7a0d:     }
1:70f7692: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
1:                 return JDBC40Translation.DEFAULT_COLUMN_DISPLAY_SIZE;
/////////////////////////////////////////////////////////////////////////
1:                 return JDBC40Translation.UNKNOWN_PRECISION;
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:             		column, columns_);
commit:5ef7a0d
/////////////////////////////////////////////////////////////////////////
1:     // JDBC 4.0 java.sql.Wrapper interface methods
1: 
1:     /**
1:      * Check whether this instance wraps an object that implements the interface
1:      * specified by {@code iface}.
1:      *
1:      * @param iface a class defining an interface
1:      * @return {@code true} if this instance implements {@code iface}, or
1:      * {@code false} otherwise
1:      * @throws SQLException if an error occurs while determining if this
1:      * instance implements {@code iface}
1:      */
1:     public boolean isWrapperFor(Class<?> iface) throws SQLException {
1:         return iface.isInstance(this);
1:     }
1: 
1:     /**
1:      * Returns {@code this} if this class implements the specified interface.
1:      *
1:      * @param  iface a class defining an interface
1:      * @return an object that implements the interface
1:      * @throws SQLException if no object is found that implements the
1:      * interface
1:      */
1:     public <T> T unwrap(Class<T> iface) throws SQLException {
1:         try {
1:             return iface.cast(this);
1:         } catch (ClassCastException cce) {
1:             throw new SqlException(null,
1:                     new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
1:                     iface).getSQLException();
1:         }
1:     }
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
1: import java.util.Hashtable;
/////////////////////////////////////////////////////////////////////////
1:     transient private Hashtable<String, Integer> columnNameToIndexCache_;
/////////////////////////////////////////////////////////////////////////
1:             columnNameToIndexCache_ = new Hashtable<String, Integer>();
1:             Integer index = columnNameToIndexCache_.get(columnName);
/////////////////////////////////////////////////////////////////////////
1:                 columnNameToIndexCache_.put(columnName, col + 1);
/////////////////////////////////////////////////////////////////////////
1:             columnNameToIndexCache_ = new Hashtable<String, Integer>();
1:         String columnName = Integer.toString(column);
1:         columnNameToIndexCache_.put(columnName, column);
commit:c50ba59
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
commit:0326967
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private transient LogWriter logWriter_;
1:     transient int resultSetConcurrency_;
/////////////////////////////////////////////////////////////////////////
1:     private void checkForClosedStatement() throws SqlException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     boolean hasLobColumns() {
/////////////////////////////////////////////////////////////////////////
1:     private void assignColumnName(int column) {
/////////////////////////////////////////////////////////////////////////
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.Types;
0: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1: public class ColumnMetaData implements ResultSetMetaData {
/////////////////////////////////////////////////////////////////////////
0:     public transient Hashtable protocolTypeToOverrideLidMapping_ = null;
0:     public transient ArrayList mddOverrideArray_ = null;
/////////////////////////////////////////////////////////////////////////
1:                     type == ClientTypes.CHAR ||
1:                     type == ClientTypes.VARCHAR ||
1:                     type == ClientTypes.LONGVARCHAR ||
1:                     type == ClientTypes.CLOB;
/////////////////////////////////////////////////////////////////////////
1:                 return ResultSetMetaData.columnNullable;
1:                 return ResultSetMetaData.columnNoNulls;
/////////////////////////////////////////////////////////////////////////
1:                     type == ClientTypes.SMALLINT ||
1:                     type == ClientTypes.INTEGER ||
1:                     type == ClientTypes.BIGINT ||
1:                     type == Types.FLOAT ||
1:                     type == ClientTypes.REAL ||
1:                     type == ClientTypes.DOUBLE ||
1:                     type == Types.NUMERIC ||
1:                     type == ClientTypes.DECIMAL;
/////////////////////////////////////////////////////////////////////////
1:             case ClientTypes.BOOLEAN:
1:             case ClientTypes.INTEGER:
1:             case ClientTypes.SMALLINT:
1:             case ClientTypes.BIGINT:
1:             case ClientTypes.REAL:
1:             case ClientTypes.DOUBLE:
1:             case Types.FLOAT:
1:             case ClientTypes.DECIMAL:
1:             case Types.NUMERIC:
/////////////////////////////////////////////////////////////////////////
1:             case ClientTypes.CHAR:
1:             case ClientTypes.VARCHAR:
1:             case ClientTypes.LONGVARCHAR:
1:             case ClientTypes.CLOB:
1:             case ClientTypes.DATE:
1:             case ClientTypes.TIME:
1:             case ClientTypes.TIMESTAMP:
1:             case ClientTypes.JAVA_OBJECT:
1:             case ClientTypes.BINARY:
1:             case ClientTypes.VARBINARY:
1:             case ClientTypes.LONGVARBINARY:
1:             case ClientTypes.BLOB:
/////////////////////////////////////////////////////////////////////////
1:             case ClientTypes.BOOLEAN:
1:             case Types.NUMERIC:
1:             case ClientTypes.DECIMAL:
1:             case ClientTypes.SMALLINT:
1:             case ClientTypes.INTEGER:
1:             case ClientTypes.BIGINT:
1:             case Types.FLOAT:
1:             case ClientTypes.REAL:
1:             case ClientTypes.DOUBLE:
1:             case ClientTypes.CHAR:
1:             case ClientTypes.VARCHAR:
1:             case ClientTypes.LONGVARCHAR:
1:             case ClientTypes.BINARY:
1:             case ClientTypes.VARBINARY:
1:             case ClientTypes.LONGVARBINARY:
1:             case ClientTypes.CLOB:
1:             case ClientTypes.BLOB:
1:             case ClientTypes.DATE:
1:             case ClientTypes.TIME:
1:             case ClientTypes.TIMESTAMP:
1:             case ClientTypes.JAVA_OBJECT:
/////////////////////////////////////////////////////////////////////////
1:                 if (jdbcType == ClientTypes.VARBINARY) {
1:                 if (jdbcType == ClientTypes.BINARY) {
1:                 if (jdbcType == ClientTypes.LONGVARBINARY) {
/////////////////////////////////////////////////////////////////////////
1:                 if (jdbcType == ClientTypes.DOUBLE) {
1:                 if (jdbcType == ClientTypes.REAL) {
/////////////////////////////////////////////////////////////////////////
1:                 // If no extended describe, return resultSet's concurrency
1:                 return resultSetConcurrency_ ==
1:                        ResultSet.CONCUR_READ_ONLY;
/////////////////////////////////////////////////////////////////////////
1:                 // If no extended describe, return resultSet's concurrency
1:                 return resultSetConcurrency_ ==
1:                        ResultSet.CONCUR_UPDATABLE;
/////////////////////////////////////////////////////////////////////////
1:             case Types.BOOLEAN:
1:             case Types.BIT:
1:             case Types.TINYINT:
1:             case ClientTypes.SMALLINT:
1:             case ClientTypes.INTEGER:
1:             case ClientTypes.BIGINT:
1:             case Types.FLOAT:
1:             case ClientTypes.REAL:
1:             case ClientTypes.DOUBLE:
1:             case Types.NUMERIC:
1:             case ClientTypes.DECIMAL:
1:             case ClientTypes.CHAR:
1:             case ClientTypes.VARCHAR:
1:             case ClientTypes.LONGVARCHAR:
1:             case ClientTypes.DATE:
1:             case ClientTypes.TIME:
1:             case ClientTypes.TIMESTAMP:
1:             case ClientTypes.BINARY:
1:             case ClientTypes.VARBINARY:
1:             case ClientTypes.LONGVARBINARY:
1:             case Types.STRUCT:
1:             case Types.ARRAY:
1:             case ClientTypes.BLOB:
1:             case ClientTypes.CLOB:
1:             case Types.REF:
1:             case Types.JAVA_OBJECT:
/////////////////////////////////////////////////////////////////////////
1:         return
0:             sqlxParmmode_[parameterIndex - 1] >=
0:             ClientParameterMetaData.parameterModeInOut;
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
1:             switch (Utils.getNonNullableSqlType(sqlType_[i])) {
commit:c0a5ce1
/////////////////////////////////////////////////////////////////////////
1:                 return 15;
1:                 return 24;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId (SQLState.LANG_STATEMENT_CLOSED_NO_REASON));
/////////////////////////////////////////////////////////////////////////
1:         // There are 3 possible cases with respect to finding the correct max width for DECIMAL type.
1:         // 1. If scale = 0, only sign should be added to precision.
1:         // 2. scale = precision, 3 should be added to precision for sign, decimal and an additional char '0'.
1:         // 3. precision > scale > 0, 2 should be added to precision for sign and decimal.
1:         int scale = getScale(column);
1:         int precision = getPrecision(column);
1:         return (scale == 0) ? (precision + 1) : ((scale == precision) ? (precision + 3) : (precision + 2));
/////////////////////////////////////////////////////////////////////////
1:         // Derby-2425. For long length values, size overflows the int 
1:         // range. In such cases, the size is limited to the max. int value
1:         // This behavior is consistent with the same in Embedded mode.
1:         int size = (int) (2 * sqlLength_[column - 1]);  // eg. "FF" represents just one byte
1:         if ( size < 0 )
1:             size = Integer.MAX_VALUE;
1:                         new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId (SQLState.LANG_INVALID_COLUMN_POSITION),
0:                     column, columns_);
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId (SQLState.INVALID_COLUMN_NAME), columnName);
commit:96c0a0e
/////////////////////////////////////////////////////////////////////////
0: 		// Derby-2425. For long length values, size overflows the int 
0: 		// range. In such cases, the size is limited to the max. int value
0: 		// This behavior is consistent with the same in Embedded mode.
0: 		int size = (int) (2 * sqlLength_[column - 1]);  // eg. "FF" represents just one byte
0: 		if ( size < 0 )
0: 		    size = Integer.MAX_VALUE;
1:                 return size;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4cded85
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:1e90bf4
/////////////////////////////////////////////////////////////////////////
1:                 return 29;
/////////////////////////////////////////////////////////////////////////
1:                 return 29;
/////////////////////////////////////////////////////////////////////////
commit:eff3919
/////////////////////////////////////////////////////////////////////////
0:             case Types.BOOLEAN:
1:                 return 5;
/////////////////////////////////////////////////////////////////////////
0:             case Types.BOOLEAN:
1:                 return 1;
/////////////////////////////////////////////////////////////////////////
1:             case DRDAConstants.DB2_SQLTYPE_BOOLEAN:
1:             case DRDAConstants.DB2_SQLTYPE_NBOOLEAN:
1:                 return "BOOLEAN";
/////////////////////////////////////////////////////////////////////////
0:             case java.sql.Types.BOOLEAN:
1:                 return "java.lang.Boolean";
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.BOOLEAN:
0:             return Types.BOOLEAN;
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
1:     public String[] sqlUDTname_;
1:     public String[] sqlUDTclassName_;
/////////////////////////////////////////////////////////////////////////
1: 
1:         sqlUDTname_ = new String[upperBound];
1:         sqlUDTclassName_ = new String[upperBound];
/////////////////////////////////////////////////////////////////////////
0:             case Types.JAVA_OBJECT:
0:                 return JDBC30Translation.DEFAULT_COLUMN_DISPLAY_SIZE;
/////////////////////////////////////////////////////////////////////////
0:             case Types.JAVA_OBJECT:
0:                 return JDBC30Translation.UNKNOWN_PRECISION;
/////////////////////////////////////////////////////////////////////////
1:             case DRDAConstants.DB2_SQLTYPE_FAKE_UDT:
1:             case DRDAConstants.DB2_SQLTYPE_FAKE_NUDT:
1:                 return sqlUDTname_[ column - 1 ];
/////////////////////////////////////////////////////////////////////////
0:             case java.sql.Types.JAVA_OBJECT:
1:                 return sqlUDTclassName_[ column - 1 ];
/////////////////////////////////////////////////////////////////////////
0:         case java.sql.Types.JAVA_OBJECT:
0:             return Types.JAVA_OBJECT;
/////////////////////////////////////////////////////////////////////////
1:         sqlUDTname_ = null;
1:         sqlUDTclassName_ = null;
commit:93cfc7f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2dabb85
/////////////////////////////////////////////////////////////////////////
1:             if( sqlxGenerated_[column - 1] == 2) {
1:                 return true;
1:             }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:55e0679
/////////////////////////////////////////////////////////////////////////
0: 		// There are 3 possible cases with respect to finding the correct max width for DECIMAL type.
0: 		// 1. If scale = 0, only sign should be added to precision.
0: 		// 2. scale = precision, 3 should be added to precision for sign, decimal and an additional char '0'.
0: 		// 3. precision > scale > 0, 2 should be added to precision for sign and decimal.
0: 		int scale = getScale(column);
0: 		int precision = getPrecision(column);
0: 		return (scale == 0) ? (precision + 1) : ((scale == precision) ? (precision + 3) : (precision + 2));
commit:90731d5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.DRDAConstants;
0: import org.apache.derby.iapi.reference.JDBC30Translation;
1: 
/////////////////////////////////////////////////////////////////////////
0:         case Types.BOOLEAN:
1:             return 5;
/////////////////////////////////////////////////////////////////////////
0:         case DRDAConstants.DB2_SQLTYPE_BOOLEAN:
0:         case DRDAConstants.DB2_SQLTYPE_NBOOLEAN:
0:             return "BOOLEAN";
1:         case DRDAConstants.DB2_SQLTYPE_DATE:
1:         case DRDAConstants.DB2_SQLTYPE_NDATE:
1:         case DRDAConstants.DB2_SQLTYPE_TIME:
1:         case DRDAConstants.DB2_SQLTYPE_NTIME:
1:         case DRDAConstants.DB2_SQLTYPE_TIMESTAMP:
1:         case DRDAConstants.DB2_SQLTYPE_NTIMESTAMP:
1:         case DRDAConstants.DB2_SQLTYPE_BLOB:
1:         case DRDAConstants.DB2_SQLTYPE_NBLOB:
1:         case DRDAConstants.DB2_SQLTYPE_CLOB:
1:         case DRDAConstants.DB2_SQLTYPE_NCLOB:
1:         case DRDAConstants.DB2_SQLTYPE_VARCHAR:
1:         case DRDAConstants.DB2_SQLTYPE_NVARCHAR:
1:         case DRDAConstants.DB2_SQLTYPE_CHAR:
1:         case DRDAConstants.DB2_SQLTYPE_NCHAR:
1:         case DRDAConstants.DB2_SQLTYPE_LONG:
1:         case DRDAConstants.DB2_SQLTYPE_NLONG:
1:         case DRDAConstants.DB2_SQLTYPE_CSTR:
1:         case DRDAConstants.DB2_SQLTYPE_NCSTR:
1:         case DRDAConstants.DB2_SQLTYPE_FLOAT:
1:         case DRDAConstants.DB2_SQLTYPE_NFLOAT:
1:         case DRDAConstants.DB2_SQLTYPE_DECIMAL:
1:         case DRDAConstants.DB2_SQLTYPE_NDECIMAL:
1:         case DRDAConstants.DB2_SQLTYPE_BIGINT:
1:         case DRDAConstants.DB2_SQLTYPE_NBIGINT:
1:         case DRDAConstants.DB2_SQLTYPE_INTEGER:
1:         case DRDAConstants.DB2_SQLTYPE_NINTEGER:
1:         case DRDAConstants.DB2_SQLTYPE_SMALL:
1:         case DRDAConstants.DB2_SQLTYPE_NSMALL:
1:         case DRDAConstants.DB2_SQLTYPE_NUMERIC:
1:         case DRDAConstants.DB2_SQLTYPE_NNUMERIC:
/////////////////////////////////////////////////////////////////////////
0:         case JDBC30Translation.BOOLEAN:
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NBOOLEAN;
1:             break;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NSMALL;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NINTEGER;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NBIGINT;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NFLOAT;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NDATE;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NTIME;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NTIMESTAMP;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NVARCHAR;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NLONG;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NVARCHAR;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NLONG;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NDECIMAL;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NBLOB;
0:             sqlType = DRDAConstants.DB2_SQLTYPE_NCLOB;
/////////////////////////////////////////////////////////////////////////
1:             case DRDAConstants.DB2_SQLTYPE_BLOB:
1:             case DRDAConstants.DB2_SQLTYPE_CLOB:
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
0:             		new ClientMessageId (SQLState.LANG_STATEMENT_CLOSED_NO_REASON));
/////////////////////////////////////////////////////////////////////////
0:                 		new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
0:                 		new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
0:                 		new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
0:                 		new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
0:             		new ClientMessageId (SQLState.LANG_INVALID_COLUMN_POSITION),
/////////////////////////////////////////////////////////////////////////
0:             		new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
0:             		new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
0:         		new ClientMessageId (SQLState.INVALID_COLUMN_NAME), columnName);
commit:ed225ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(logWriter_, 
0:             		new MessageId (SQLState.LANG_STATEMENT_CLOSED_NO_REASON));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(logWriter_, 
0:                 		new MessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(logWriter_, 
0:                 		new MessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(logWriter_, 
0:                 		new MessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(logWriter_, 
0:                 		new MessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(logWriter_, 
0:             		new MessageId (SQLState.LANG_INVALID_COLUMN_POSITION),
0:             		new Integer (column), new Integer(columns_));
/////////////////////////////////////////////////////////////////////////
0:     /** This method does not appear to be in use -- davidvc@apache.org
1:      */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(logWriter_, 
0:             		new MessageId (SQLState.UNSUPPORTED_TYPE));
1:             throw new SqlException(logWriter_, 
0:             		new MessageId (SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
0:         throw new SqlException(logWriter_, 
0:         		new MessageId (SQLState.INVALID_COLUMN_NAME), columnName);
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: 
/////////////////////////////////////////////////////////////////////////
1:     public int getColumnCount() throws SQLException {
1:         try
1:         {            
1:             checkForClosedStatement();
1:             return columns_;
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     public boolean isAutoIncrement(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             return false;
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     public boolean isCaseSensitive(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             //return true if the SQLTYPE is CHAR, VARCHAR, LOGVARCHAR or CLOB
1:             int type = types_[column - 1];
1:             return
0:                     type == Types.CHAR ||
0:                     type == Types.VARCHAR ||
0:                     type == Types.LONGVARCHAR ||
0:                     type == Types.CLOB;
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     public boolean isSearchable(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             return true;
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:     public boolean isCurrency(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             return false;
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:     public int isNullable(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             if (nullable_[column - 1]) {
0:                 return java.sql.ResultSetMetaData.columnNullable;
1:             } else {
0:                 return java.sql.ResultSetMetaData.columnNoNulls;
1:             }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:     public boolean isSigned(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             //return true only if the SQLType is SMALLINT, INT, BIGINT, FLOAT, REAL, DOUBLE, NUMERIC OR DECIMAL
1:             int type = types_[column - 1];
1:             return
0:                     type == Types.SMALLINT ||
0:                     type == Types.INTEGER ||
0:                     type == Types.BIGINT ||
0:                     type == java.sql.Types.FLOAT ||
0:                     type == Types.REAL ||
0:                     type == Types.DOUBLE ||
0:                     type == java.sql.Types.NUMERIC ||
0:                     type == Types.DECIMAL;
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1: }
1:     public int getColumnDisplaySize(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             int jdbcType = types_[column - 1];
1:             switch (jdbcType) {
0:             case Types.BOOLEAN:
0:                 return 5;
0:             case Types.INTEGER:
1:                 return 11;
0:             case Types.SMALLINT:
1:                 return 6;
0:             case Types.BIGINT:
1:                 return 20;
0:             case Types.REAL:
0:                 return 13;
0:             case Types.DOUBLE:
0:             case java.sql.Types.FLOAT:
0:                 return 22;
0:             case Types.DECIMAL:
0:             case java.sql.Types.NUMERIC:
0:                 return getPrecision(column) + 2;  // add 1 for sign and 1 for decimal
0:             case Types.CHAR:
0:             case Types.VARCHAR:
0:             case Types.LONGVARCHAR:
0:             case Types.CLOB:
1:                 return (int) sqlLength_[column - 1];
0:             case Types.DATE:
1:                 return 10;
0:             case Types.TIME:
1:                 return 8;
0:             case Types.TIMESTAMP:
0:                 return 26;
0:             case Types.BINARY:
0:             case Types.VARBINARY:
0:             case Types.LONGVARBINARY:
0:             case Types.BLOB:
0:                 return (int) (2 * sqlLength_[column - 1]); // eg. "FF" represents just one byte
1:             default:
0:                 throw new SqlException(logWriter_, "not supported");
1:             }
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     public String getColumnLabel(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             // return labels if label is turned on, otherwise, return column name
1:             if (sqlLabel_ != null && sqlLabel_[column - 1] != null) {
1:                 return sqlLabel_[column - 1];
1:             }
1:             if (sqlName_ == null || sqlName_[column - 1] == null) {
1:                 assignColumnName(column);
1:             }
1:             return sqlName_[column - 1];
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     }
1: 
1:     public String getColumnName(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             // The Javadoc and Jdbc book explicitly state that the empty string ("") is returned if "not applicable"
1:             // for the following methods:
1:             //   getSchemaName()
1:             //   getTableName()
1:             //   getCatalogName()
1:             // Since the empty string is a valid string and is not really a proper table name, schema name, or catalog name,
1:             // we're not sure why the empty string was chosen over null, except possibly to be friendly to lazy jdbc apps
1:             // that may not be checking for nulls, thereby minimizing potential NPE's.
1:             // By induction, it would make sense to return the empty string when column name is not available/applicable.
1:             //
1:             // The JDBC specification contains blanket statements about SQL compliance levels,
1:             // so elaboration within the JDBC specification is often bypassed.
1:             // Personally, I would prefer to return Java null for all the not-applicable cases,
1:             // but it appears that we have precedent for the empty ("") string.
1:             //
1:             // We assume a straightforward induction from jdbc spec that the column name be "" (empty)
1:             // in preference to null or NULL for the not applicable case.
1:             //
1:             if (sqlName_ == null || sqlName_[column - 1] == null) {
1:                 assignColumnName(column);
1:             }
1:             return sqlName_[column - 1];
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     }
1: 
1:     public String getSchemaName(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             if (sqlxSchema_ == null || sqlxSchema_[column - 1] == null) {
1:                 return ""; // Per jdbc spec
1:             }
1:             return sqlxSchema_[column - 1];
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     }
1: 
1:     public int getPrecision(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             int jdbcType = types_[column - 1];
1: 
1:             switch (jdbcType) {
0:             case java.sql.Types.NUMERIC:
0:             case Types.DECIMAL:
1:                 return sqlPrecision_[column - 1];
0:             case Types.SMALLINT:
0:                 return 5;
0:             case Types.INTEGER:
1:                 return 10;
0:             case Types.BIGINT:
1:                 return 19;
0:             case java.sql.Types.FLOAT:
1:                 return 15;
0:             case Types.REAL:
1:                 return 7;  // This is the number of signed digits for IEEE float with mantissa 24, ie. 2^24
0:             case Types.DOUBLE:
1:                 return 15; // This is the number of signed digits for IEEE float with mantissa 24, ie. 2^24
0:             case Types.CHAR:
0:             case Types.VARCHAR:
0:             case Types.LONGVARCHAR:
0:             case Types.BINARY:
0:             case Types.VARBINARY:
0:             case Types.LONGVARBINARY:
0:             case Types.CLOB:
0:             case Types.BLOB:
1:                 return (int) sqlLength_[column - 1];
0:             case Types.DATE:
1:                 return 10;
0:             case Types.TIME:
1:                 return 8;
0:             case Types.TIMESTAMP:
0:                 return 26;
1:             default:
0:                 throw new SqlException(logWriter_, "Unregistered column type");
1:             }
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     }
1: 
1:     public int getScale(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1: 
0:             // We get the scale from the SQLDA as returned by DERBY, but DERBY does not return the ANSI-defined
0:             // value of scale 6 for TIMESTAMP.
1:             //
0:             //   The JDBC drivers should hardcode this info as a short/near term solution.
1:             //
0:             if (types_[column - 1] == Types.TIMESTAMP) {
1:                 return 6;
1:             }
1: 
1:             return sqlScale_[column - 1];
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     }
1: 
1:     public String getTableName(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             if (sqlxBasename_ == null || sqlxBasename_[column - 1] == null) {
1:                 return ""; // Per jdbc spec
1:             }
1:             return sqlxBasename_[column - 1];
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public String getCatalogName(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             return "";
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:     public int getColumnType(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1: 
1:             return types_[column - 1];
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     public String getColumnTypeName(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1: 
1:             int jdbcType = types_[column - 1];
1:             // So these all come back zero for downlevel servers in PROTOCOL.
1:             // John is going to write some code to construct the sqlType_ array
1:             // based on the protocol types from the query descriptor.
1:             int sqlType = sqlType_[column - 1];
1: 
1:             switch (sqlType) {
0:             case DRDAConstants.DB2_SQLTYPE_BOOLEAN:
0:             case DRDAConstants.DB2_SQLTYPE_NBOOLEAN:
0:                 return "BOOLEAN";
0:             case DRDAConstants.DB2_SQLTYPE_DATE:
0:             case DRDAConstants.DB2_SQLTYPE_NDATE:
1:                 return "DATE";
0:             case DRDAConstants.DB2_SQLTYPE_TIME:
0:             case DRDAConstants.DB2_SQLTYPE_NTIME:
1:                 return "TIME";
0:             case DRDAConstants.DB2_SQLTYPE_TIMESTAMP:
0:             case DRDAConstants.DB2_SQLTYPE_NTIMESTAMP:
1:                 return "TIMESTAMP";
0:             case DRDAConstants.DB2_SQLTYPE_BLOB:
0:             case DRDAConstants.DB2_SQLTYPE_NBLOB:
1:                 return "BLOB";
0:             case DRDAConstants.DB2_SQLTYPE_CLOB:
0:             case DRDAConstants.DB2_SQLTYPE_NCLOB:
1:                 return "CLOB";
0:             case DRDAConstants.DB2_SQLTYPE_VARCHAR:
0:             case DRDAConstants.DB2_SQLTYPE_NVARCHAR:
0:                 if (jdbcType == Types.VARBINARY) {
1:                     return "VARCHAR FOR BIT DATA";
1:                 } else {
1:                     return "VARCHAR";
1:                 }
0:             case DRDAConstants.DB2_SQLTYPE_CHAR:
0:             case DRDAConstants.DB2_SQLTYPE_NCHAR:
0:                 if (jdbcType == Types.BINARY) {
1:                     return "CHAR FOR BIT DATA";
1:                 } else {
1:                     return "CHAR";
1:                 }
0:             case DRDAConstants.DB2_SQLTYPE_LONG:
0:             case DRDAConstants.DB2_SQLTYPE_NLONG:
0:                 if (jdbcType == Types.LONGVARBINARY) {
1:                     return "LONG VARCHAR FOR BIT DATA";
1:                 } else {
1:                     return "LONG VARCHAR";
1:                 }
0:             case DRDAConstants.DB2_SQLTYPE_CSTR:
0:             case DRDAConstants.DB2_SQLTYPE_NCSTR:
1:                 return "SBCS";
0:             case DRDAConstants.DB2_SQLTYPE_FLOAT:
0:             case DRDAConstants.DB2_SQLTYPE_NFLOAT:
0:                 if (jdbcType == Types.DOUBLE) {
1:                     return "DOUBLE";
1:                 }
0:                 if (jdbcType == Types.REAL) {
1:                     return "REAL";
1:                 }
0:             case DRDAConstants.DB2_SQLTYPE_DECIMAL:
0:             case DRDAConstants.DB2_SQLTYPE_NDECIMAL:
1:                 return "DECIMAL";
0:             case DRDAConstants.DB2_SQLTYPE_BIGINT:
0:             case DRDAConstants.DB2_SQLTYPE_NBIGINT:
1:                 return "BIGINT";
0:             case DRDAConstants.DB2_SQLTYPE_INTEGER:
0:             case DRDAConstants.DB2_SQLTYPE_NINTEGER:
1:                 return "INTEGER";
0:             case DRDAConstants.DB2_SQLTYPE_SMALL:
0:             case DRDAConstants.DB2_SQLTYPE_NSMALL:
1:                 return "SMALLINT";
0:             case DRDAConstants.DB2_SQLTYPE_NUMERIC:
0:             case DRDAConstants.DB2_SQLTYPE_NNUMERIC:
1:                 return "NUMERIC";
1:             default:
0:                 throw new SqlException(logWriter_, "Not supported");
1:             }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     public boolean isReadOnly(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             if (sqlxUpdatable_ == null) {
0:                 return (resultSetConcurrency_ == java.sql.ResultSet.CONCUR_READ_ONLY); // If no extended describe, return resultSet's concurrecnty
1:             }
1:             return sqlxUpdatable_[column - 1] == 0; // PROTOCOL 0 means not updatable, 1 means updatable
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     }
1: 
1:     public boolean isWritable(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             if (sqlxUpdatable_ == null) {
0:                 return (resultSetConcurrency_ == java.sql.ResultSet.CONCUR_UPDATABLE); // If no extended describe, return resultSet's concurrency
1:             }
1:             return sqlxUpdatable_[column - 1] == 1; // PROTOCOL 0 means not updatable, 1 means updatable
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     }
1: 
1:     public boolean isDefinitelyWritable(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             if (sqlxUpdatable_ == null) {
1:                 return false;
1:             }
1:             return sqlxUpdatable_[column - 1] == 1; // PROTOCOL 0 means not updatable, 1 means updatable
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
1:         }
1:     public String getColumnClassName(int column) throws SQLException {
1:         try
1:         {
1:             checkForClosedStatement();
1:             checkForValidColumnIndex(column);
1:             int jdbcType = types_[column - 1];
1:             switch (jdbcType) {
0:             case java.sql.Types.BIT:
1:                 return "java.lang.Boolean";
0:             case java.sql.Types.TINYINT:
1:                 return "java.lang.Integer";
0:             case Types.SMALLINT:
1:                 return "java.lang.Integer";
0:             case Types.INTEGER:
1:                 return "java.lang.Integer";
0:             case Types.BIGINT:
1:                 return "java.lang.Long";
0:             case java.sql.Types.FLOAT:
1:                 return "java.lang.Double";
0:             case Types.REAL:
1:                 return "java.lang.Float";
0:             case Types.DOUBLE:
1:                 return "java.lang.Double";
0:             case java.sql.Types.NUMERIC:
0:             case Types.DECIMAL:
1:                 return "java.math.BigDecimal";
0:             case Types.CHAR:
0:             case Types.VARCHAR:
0:             case Types.LONGVARCHAR:
1:                 return "java.lang.String";
0:             case Types.DATE:
1:                 return "java.sql.Date";
0:             case Types.TIME:
1:                 return "java.sql.Time";
0:             case Types.TIMESTAMP:
1:                 return "java.sql.Timestamp";
0:             case Types.BINARY:
0:             case Types.VARBINARY:
0:             case Types.LONGVARBINARY:
1:                 return "byte[]";
0:             case java.sql.Types.STRUCT:
1:                 return "java.sql.Struct";
0:             case java.sql.Types.ARRAY:
1:                 return "java.sql.Array";
0:             case Types.BLOB:
1:                 return "java.sql.Blob";
0:             case Types.CLOB:
1:                 return "java.sql.Clob";
0:             case java.sql.Types.REF:
1:                 return "java.sql.Ref";
1:             default:
0:                 throw new SqlException(logWriter_, "Not supported");
1:             }
1:         }
1:         catch ( SqlException e )
1:         {
1:             throw e.getSQLException();
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: public class ColumnMetaData implements java.sql.ResultSetMetaData {
1:     public int columns_;
1:     public boolean[] nullable_;
0:     // Although this is describe information, it is tagged transient for now becuase it is not currently used.
0:     transient public int[] singleMixedByteOrDouble_; // 1 means single, 2 means double, 3 means mixed-byte, 0 not applicable
1:     // All of the following state data comes from the SQLDA reply.
1:     //Data from SQLDHGRP
1:     public short sqldHold_;
1:     public short sqldReturn_;
1:     public short sqldScroll_;
1:     public short sqldSensitive_;
1:     public short sqldFcode_;
1:     public short sqldKeytype_;
1:     public String sqldRdbnam_; // catalog name, not used by driver, placeholder only
1:     public String sqldSchema_; // schema name, not used by driver, placeholder only
1:     //data comes from SQLDAGRP
1:     public int[] sqlPrecision_; // adjusted sqllen;
1:     public int[] sqlScale_;
1:     public long[] sqlLength_;  // This is maximum length for varchar fields
1:     // These are the derby sql types, for use only by ResultSetMetaData, other code should use jdbcTypes_.
1:     // sqlTypes_ is currently not set for input column meta data.
1:     public int[] sqlType_;
1:     public int[] sqlCcsid_;
1:     // With the exception of sqlNames_ and sqlxParmmode_, the following members are only allocated when needed
1:     //Data from SQLDOPTGRP
1:     public String[] sqlName_;   // column name, pre-allocated
1:     public String[] sqlLabel_;  // column label
1:     public short[] sqlUnnamed_;
1:     public String[] sqlComment_;
1:     //Data from SQLDXGRP
1:     public short[] sqlxKeymem_;
1:     public short[] sqlxGenerated_;
1:     public short[] sqlxParmmode_; // pre-allocated
1:     public String[] sqlxCorname_;
1:     public String[] sqlxName_;
1:     public String[] sqlxBasename_;  // table name
1:     public int[] sqlxUpdatable_;
1:     public String[] sqlxSchema_;    // schema name
1:     public String[] sqlxRdbnam_;    // catalog name
1:     //-----------------------------transient state--------------------------------
1:     // For performance only, not part of logical model.
1:     public transient int[][] protocolTypesCache_ = null;
0:     public transient java.util.Hashtable protocolTypeToOverrideLidMapping_ = null;
0:     public transient java.util.ArrayList mddOverrideArray_ = null;
1:     public transient int[] types_;
1:     public transient int[] clientParamtertype_;
0:     public transient LogWriter logWriter_;
1:     // only set on execute replies, this is not describe information.
1:     // only used for result set meta data.
0:     public transient int resultSetConcurrency_;
0:     transient private java.util.Hashtable columnNameToIndexCache_ = null;
1:     transient private boolean statementClosed_ = false;
1: 
1:     void markClosed() {
1:         statementClosed_ = true;
1:         nullDataForGC();
1:     }
1: 
0:     void checkForClosedStatement() throws SqlException {
1:         // agent_.checkForDeferredExceptions();
1:         if (statementClosed_) {
0:             throw new SqlException(logWriter_, "Statement closed");
1:         }
1:     }
1:     //---------------------navigational members-----------------------------------
1:     //---------------------constructors/finalizer---------------------------------
1:     // Called by NETColumnMetaData constructor before #columns is parsed out yet.
1:     public ColumnMetaData(LogWriter logWriter) {
1:         logWriter_ = logWriter;
1:     }
1:     // For creating column meta data when describe input is not available.
1:     // The upper bound that is passed in is determined by counting the number of parameter markers.
1:     // Called by PreparedStatement.flowPrepareStatement() and flowDescribeInputOutput()
1:     // only when describe input is not available.
1:     public ColumnMetaData(LogWriter logWriter, int upperBound) {
1:         logWriter_ = logWriter;
1:         initializeCache(upperBound);
1:     }
1:     public void initializeCache(int upperBound) {
1:         columns_ = upperBound;
1:         nullable_ = new boolean[upperBound];
1:         types_ = new int[upperBound];
1:         clientParamtertype_ = new int[upperBound];
0:         singleMixedByteOrDouble_ = new int[upperBound]; // 1 means single, 2 means double, 3 means mixed-byte, 0 not applicable
1:         sqlPrecision_ = new int[upperBound];
1:         sqlScale_ = new int[upperBound];
1:         sqlLength_ = new long[upperBound];
1:         sqlType_ = new int[upperBound];
1:         sqlCcsid_ = new int[upperBound];
1:         sqlName_ = new String[upperBound];
1:         sqlxParmmode_ = new short[upperBound];
1:     }
0:     protected void finalize() throws java.lang.Throwable {
0:         super.finalize();
1:     }
1:     //--------------------Abstract material layer call-down methods-----------------
1:     //------------------material layer event callback methods-----------------------
1:     // ---------------------------jdbc 1------------------------------------------
0:     public int getColumnCount() throws SqlException {
0:         checkForClosedStatement();
0:         return columns_;
1:     }
0:     public boolean isAutoIncrement(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
1:         return false;
1:     }
0:     public boolean isCaseSensitive(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         //return true if the SQLTYPE is CHAR, VARCHAR, LOGVARCHAR or CLOB
0:         int type = types_[column - 1];
0:         return
0:                 type == Types.CHAR ||
0:                 type == Types.VARCHAR ||
0:                 type == Types.LONGVARCHAR ||
0:                 type == Types.CLOB;
1:     }
1:     // all searchable except distinct
0:     public boolean isSearchable(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
1:         return true;
1:     }
0:     public boolean isCurrency(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
1:         return false;
1:     }
0:     public int isNullable(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         if (nullable_[column - 1]) {
0:             return java.sql.ResultSetMetaData.columnNullable;
0:         } else {
0:             return java.sql.ResultSetMetaData.columnNoNulls;
1:         }
1:     }
0:     public boolean isSigned(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         //return true only if the SQLType is SMALLINT, INT, BIGINT, FLOAT, REAL, DOUBLE, NUMERIC OR DECIMAL
0:         int type = types_[column - 1];
0:         return
0:                 type == Types.SMALLINT ||
0:                 type == Types.INTEGER ||
0:                 type == Types.BIGINT ||
0:                 type == java.sql.Types.FLOAT ||
0:                 type == Types.REAL ||
0:                 type == Types.DOUBLE ||
0:                 type == java.sql.Types.NUMERIC ||
0:                 type == Types.DECIMAL;
1:     }
0:     public int getColumnDisplaySize(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         int jdbcType = types_[column - 1];
0:         switch (jdbcType) {
0:         case Types.INTEGER:
0:             return 11;
0:         case Types.SMALLINT:
0:             return 6;
0:         case Types.BIGINT:
0:             return 20;
0:         case Types.REAL:
0:             return 13;
0:         case Types.DOUBLE:
0:         case java.sql.Types.FLOAT:
0:             return 22;
0:         case Types.DECIMAL:
0:         case java.sql.Types.NUMERIC:
0:             return getPrecision(column) + 2;  // add 1 for sign and 1 for decimal
0:         case Types.CHAR:
0:         case Types.VARCHAR:
0:         case Types.LONGVARCHAR:
0:         case Types.CLOB:
0:             return (int) sqlLength_[column - 1];
0:         case Types.DATE:
0:             return 10;
0:         case Types.TIME:
0:             return 8;
0:         case Types.TIMESTAMP:
0:             return 26;
0:         case Types.BINARY:
0:         case Types.VARBINARY:
0:         case Types.LONGVARBINARY:
0:         case Types.BLOB:
0:             return (int) (2 * sqlLength_[column - 1]); // eg. "FF" represents just one byte
1:         default:
0:             throw new SqlException(logWriter_, "not supported");
1:         }
1:     }
0:     public String getColumnLabel(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         // return labels if label is turned on, otherwise, return column name
0:         if (sqlLabel_ != null && sqlLabel_[column - 1] != null) {
0:             return sqlLabel_[column - 1];
1:         }
0:         if (sqlName_ == null || sqlName_[column - 1] == null) {
0:             assignColumnName(column);
1:         }
0:         return sqlName_[column - 1];
1:     }
0:     public String getColumnName(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         // The Javadoc and Jdbc book explicitly state that the empty string ("") is returned if "not applicable"
0:         // for the following methods:
0:         //   getSchemaName()
0:         //   getTableName()
0:         //   getCatalogName()
0:         // Since the empty string is a valid string and is not really a proper table name, schema name, or catalog name,
0:         // we're not sure why the empty string was chosen over null, except possibly to be friendly to lazy jdbc apps
0:         // that may not be checking for nulls, thereby minimizing potential NPE's.
0:         // By induction, it would make sense to return the empty string when column name is not available/applicable.
0:         //
0:         // The JDBC specification contains blanket statements about SQL compliance levels,
0:         // so elaboration within the JDBC specification is often bypassed.
0:         // Personally, I would prefer to return Java null for all the not-applicable cases,
0:         // but it appears that we have precedent for the empty ("") string.
0:         //
0:         // We assume a straightforward induction from jdbc spec that the column name be "" (empty)
0:         // in preference to null or NULL for the not applicable case.
0:         //
0:         if (sqlName_ == null || sqlName_[column - 1] == null) {
0:             assignColumnName(column);
1:         }
0:         return sqlName_[column - 1];
1:     }
0:     public String getSchemaName(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         if (sqlxSchema_ == null || sqlxSchema_[column - 1] == null) {
0:             return ""; // Per jdbc spec
1:         }
0:         return sqlxSchema_[column - 1];
1:     }
0:     public int getPrecision(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         int jdbcType = types_[column - 1];
0:         switch (jdbcType) {
0:         case java.sql.Types.NUMERIC:
0:         case Types.DECIMAL:
0:             return sqlPrecision_[column - 1];
0:         case Types.SMALLINT:
0:             return 5;
0:         case Types.INTEGER:
0:             return 10;
0:         case Types.BIGINT:
0:             return 19;
0:         case java.sql.Types.FLOAT:
0:             return 15;
0:         case Types.REAL:
0:             return 7;  // This is the number of signed digits for IEEE float with mantissa 24, ie. 2^24
0:         case Types.DOUBLE:
0:             return 15; // This is the number of signed digits for IEEE float with mantissa 24, ie. 2^24
0:         case Types.CHAR:
0:         case Types.VARCHAR:
0:         case Types.LONGVARCHAR:
0:         case Types.BINARY:
0:         case Types.VARBINARY:
0:         case Types.LONGVARBINARY:
0:         case Types.CLOB:
0:         case Types.BLOB:
0:             return (int) sqlLength_[column - 1];
0:         case Types.DATE:
0:             return 10;
0:         case Types.TIME:
0:             return 8;
0:         case Types.TIMESTAMP:
0:             return 26;
1:         default:
0:             throw new SqlException(logWriter_, "Unregistered column type");
1:         }
1:     }
0:     public int getScale(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         // We get the scale from the SQLDA as returned by DERBY, but DERBY does not return the ANSI-defined
0:         // value of scale 6 for TIMESTAMP.
0:         //
0:         //   The JDBC drivers should hardcode this info as a short/near term solution.
0:         //
0:         if (types_[column - 1] == Types.TIMESTAMP) {
0:             return 6;
1:         }
0:         return sqlScale_[column - 1];
1:     }
0:     public String getTableName(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         if (sqlxBasename_ == null || sqlxBasename_[column - 1] == null) {
0:             return ""; // Per jdbc spec
1:         }
0:         return sqlxBasename_[column - 1];
1:     }
1:      *
1:      *
1:      * @throws SQLException thrown on failure
0:     public String getCatalogName(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         return "";
0:     public int getColumnType(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         return types_[column - 1];
0:     public String getColumnTypeName(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         int jdbcType = types_[column - 1];
0:         // So these all come back zero for downlevel servers in PROTOCOL.
0:         // John is going to write some code to construct the sqlType_ array
0:         // based on the protocol types from the query descriptor.
0:         int sqlType = sqlType_[column - 1];
0:         switch (sqlType) {
0:         case Types.DERBY_SQLTYPE_DATE:
0:         case Types.DERBY_SQLTYPE_NDATE:
0:             return "DATE";
0:         case Types.DERBY_SQLTYPE_TIME:
0:         case Types.DERBY_SQLTYPE_NTIME:
0:             return "TIME";
0:         case Types.DERBY_SQLTYPE_TIMESTAMP:
0:         case Types.DERBY_SQLTYPE_NTIMESTAMP:
0:             return "TIMESTAMP";
0:         case Types.DERBY_SQLTYPE_BLOB:
0:         case Types.DERBY_SQLTYPE_NBLOB:
0:             return "BLOB";
0:         case Types.DERBY_SQLTYPE_CLOB:
0:         case Types.DERBY_SQLTYPE_NCLOB:
0:             return "CLOB";
0:         case Types.DERBY_SQLTYPE_VARCHAR:
0:         case Types.DERBY_SQLTYPE_NVARCHAR:
0:             if (jdbcType == Types.VARBINARY) {
0:                 return "VARCHAR FOR BIT DATA";
0:             } else {
0:                 return "VARCHAR";
1:             }
0:         case Types.DERBY_SQLTYPE_CHAR:
0:         case Types.DERBY_SQLTYPE_NCHAR:
0:             if (jdbcType == Types.BINARY) {
0:                 return "CHAR FOR BIT DATA";
0:             } else {
0:                 return "CHAR";
1:             }
0:         case Types.DERBY_SQLTYPE_LONG:
0:         case Types.DERBY_SQLTYPE_NLONG:
0:             if (jdbcType == Types.LONGVARBINARY) {
0:                 return "LONG VARCHAR FOR BIT DATA";
0:             } else {
0:                 return "LONG VARCHAR";
1:             }
0:         case Types.DERBY_SQLTYPE_CSTR:
0:         case Types.DERBY_SQLTYPE_NCSTR:
0:             return "SBCS";
0:         case Types.DERBY_SQLTYPE_FLOAT:
0:         case Types.DERBY_SQLTYPE_NFLOAT:
0:             if (jdbcType == Types.DOUBLE) {
0:                 return "DOUBLE";
1:             }
0:             if (jdbcType == Types.REAL) {
0:                 return "REAL";
1:             }
0:         case Types.DERBY_SQLTYPE_DECIMAL:
0:         case Types.DERBY_SQLTYPE_NDECIMAL:
0:             return "DECIMAL";
0:         case Types.DERBY_SQLTYPE_BIGINT:
0:         case Types.DERBY_SQLTYPE_NBIGINT:
0:             return "BIGINT";
0:         case Types.DERBY_SQLTYPE_INTEGER:
0:         case Types.DERBY_SQLTYPE_NINTEGER:
0:             return "INTEGER";
0:         case Types.DERBY_SQLTYPE_SMALL:
0:         case Types.DERBY_SQLTYPE_NSMALL:
0:             return "SMALLINT";
0:         case Types.DERBY_SQLTYPE_NUMERIC:
0:         case Types.DERBY_SQLTYPE_NNUMERIC:
0:             return "NUMERIC";
0:             throw new SqlException(logWriter_, "Not supported");
1:         }
0:     public boolean isReadOnly(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         if (sqlxUpdatable_ == null) {
0:             return (resultSetConcurrency_ == java.sql.ResultSet.CONCUR_READ_ONLY); // If no extended describe, return resultSet's concurrecnty
1:         }
0:         return sqlxUpdatable_[column - 1] == 0; // PROTOCOL 0 means not updatable, 1 means updatable
0:     public boolean isWritable(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         if (sqlxUpdatable_ == null) {
0:             return (resultSetConcurrency_ == java.sql.ResultSet.CONCUR_UPDATABLE); // If no extended describe, return resultSet's concurrency
1:         }
0:         return sqlxUpdatable_[column - 1] == 1; // PROTOCOL 0 means not updatable, 1 means updatable
1:     }
0:     public boolean isDefinitelyWritable(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
0:         if (sqlxUpdatable_ == null) {
1:             return false;
1:         }
0:         return sqlxUpdatable_[column - 1] == 1; // PROTOCOL 0 means not updatable, 1 means updatable
1:     }
1: 
1:     //--------------------------jdbc 2.0-----------------------------------
1: 
0:     public String getColumnClassName(int column) throws SqlException {
0:         checkForClosedStatement();
0:         checkForValidColumnIndex(column);
1: 
0:         int jdbcType = types_[column - 1];
0:         switch (jdbcType) {
0:         case java.sql.Types.BIT:
0:             return "java.lang.Boolean";
0:         case java.sql.Types.TINYINT:
0:             return "java.lang.Integer";
0:         case Types.SMALLINT:
0:             return "java.lang.Integer";
0:         case Types.INTEGER:
0:             return "java.lang.Integer";
0:         case Types.BIGINT:
0:             return "java.lang.Long";
0:         case java.sql.Types.FLOAT:
0:             return "java.lang.Double";
0:         case Types.REAL:
0:             return "java.lang.Float";
0:         case Types.DOUBLE:
0:             return "java.lang.Double";
0:         case java.sql.Types.NUMERIC:
0:         case Types.DECIMAL:
0:             return "java.math.BigDecimal";
0:         case Types.CHAR:
0:         case Types.VARCHAR:
0:         case Types.LONGVARCHAR:
0:             return "java.lang.String";
0:         case Types.DATE:
0:             return "java.sql.Date";
0:         case Types.TIME:
0:             return "java.sql.Time";
0:         case Types.TIMESTAMP:
0:             return "java.sql.Timestamp";
0:         case Types.BINARY:
0:         case Types.VARBINARY:
0:         case Types.LONGVARBINARY:
0:             return "byte[]";
0:         case java.sql.Types.STRUCT:
0:             return "java.sql.Struct";
0:         case java.sql.Types.ARRAY:
0:             return "java.sql.Array";
0:         case Types.BLOB:
0:             return "java.sql.Blob";
0:         case Types.CLOB:
0:             return "java.sql.Clob";
0:         case java.sql.Types.REF:
0:             return "java.sql.Ref";
1:         default:
0:             throw new SqlException(logWriter_, "Not supported");
1:         }
1:     }
1: 
1:     //----------------------------helper methods----------------------------------
1: 
1: 
1:     void checkForValidColumnIndex(int column) throws SqlException {
1:         if (column < 1 || column > columns_) {
0:             throw new SqlException(logWriter_, "Invalid argument: column index " +
0:                     column + " is out of range.");
1:         }
1:     }
1: 
0:     // If the input parameter has been set, return true, else return false.
0:     private boolean isParameterModeGuessedAsAnInput(int parameterIndex) {
0:         if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeIn ||
0:                 sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeInOut) {
1:             return true;
1:         }
1:         return false;
1:     }
1: 
0:     // Does OUT parm registration rely on extended describe?
0:     // If the output parameter has been registered, return true, else return false.
0:     public boolean isParameterModeGuessedAsOutput(int parameterIndex) {
0:         return sqlxParmmode_[parameterIndex - 1] >= java.sql.ParameterMetaData.parameterModeInOut;
1:     }
1: 
0:     // Only called when column meta data is not described. Called by setXXX methods.
0:     public void guessInputParameterMetaData(int parameterIndex,
0:                                             int jdbcType) throws SqlException {
0:         guessInputParameterMetaData(parameterIndex, jdbcType, 0);
1:     }
1: 
0:     private void setParmModeForInputParameter(int parameterIndex) {
0:         if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeOut) {
0:             sqlxParmmode_[parameterIndex - 1] = java.sql.ParameterMetaData.parameterModeInOut;
0:         } else if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeUnknown) {
0:             sqlxParmmode_[parameterIndex - 1] = java.sql.ParameterMetaData.parameterModeIn;
1:         }
1:     }
1: 
0:     // Only called when column meta data is not described. Called by setXXX methods.
0:     // Scale is only applied for Decimal or Numeric JDBC type.
0:     public void guessInputParameterMetaData(int parameterIndex,
0:                                             int jdbcType,
0:                                             int scale) throws SqlException {
0:         setParmModeForInputParameter(parameterIndex);
0:         int driverType = getInternalTypeForGuessedOrRegisteredJdbcType(jdbcType);
0:         // if output parameter has been registered already
0:         if (isParameterModeGuessedAsOutput(parameterIndex)) {
0:             if (!isCompatibleDriverTypes(types_[parameterIndex - 1], driverType)) {
0:                 throw new SqlException(logWriter_, "The jdbcType " + jdbcType + " does not match between the setter method and " +
0:                         "the registerOutParameter method.");
0:             } else {
0:                 return; // don't bother guessing if the parameter was already registered
1:             }
1:         }
0:         guessParameterMetaDataBasedOnSupportedDriverType(parameterIndex, jdbcType == java.sql.Types.BIGINT, driverType, scale);
1:     }
1: 
0:     private void setParmModeForOutputParameter(int parameterIndex) {
0:         if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeIn) {
0:             sqlxParmmode_[parameterIndex - 1] = java.sql.ParameterMetaData.parameterModeInOut;
0:         } else if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeUnknown) {
0:             sqlxParmmode_[parameterIndex - 1] = java.sql.ParameterMetaData.parameterModeOut;
1:         }
1:     }
1: 
0:     // Only called when column meta data is not described, called by registerOutParameter methods.
0:     public void guessOutputParameterMetaData(int parameterIndex,
0:                                              int jdbcType,
0:                                              int scale) throws SqlException {
0:         setParmModeForOutputParameter(parameterIndex);
0:         int driverType = getInternalTypeForGuessedOrRegisteredJdbcType(jdbcType);
0:         if (isParameterModeGuessedAsAnInput(parameterIndex)) { // if input parameter has been set already
0:             // Verify that "set" and "registered" types are compatible.
0:             if (!isCompatibleDriverTypes(driverType, types_[parameterIndex - 1])) {
0:                 throw new SqlException(logWriter_, "The jdbcType does not match between the setter method and " +
0:                         "the registerOutParameter method.");
1:             }
0:             // the registered type will take precedence over any previously guessed input "set" type
1:         }
0:         guessParameterMetaDataBasedOnSupportedDriverType(parameterIndex, jdbcType == java.sql.Types.BIGINT, driverType, scale);
1:     }
1: 
0:     private boolean isCompatibleDriverTypes(int registeredType, int guessedInputType) {
0:         switch (registeredType) {
0:         case Types.CHAR:
0:         case Types.VARCHAR:
0:         case Types.LONGVARCHAR:
0:             return guessedInputType == Types.CHAR || guessedInputType == Types.VARCHAR || guessedInputType == Types.LONGVARCHAR;
0:         case Types.BINARY:
0:         case Types.VARBINARY:
0:         case Types.LONGVARBINARY:
0:             return guessedInputType == Types.BINARY || guessedInputType == Types.VARBINARY || guessedInputType == Types.LONGVARBINARY;
1:         default:
0:             return registeredType == guessedInputType;
1:         }
1:     }
1: 
0:     // Only used when describe information is not available.
0:     private int getInternalTypeForGuessedOrRegisteredJdbcType(int guessedOrRegisteredJdbcType) throws SqlException {
0:         switch (guessedOrRegisteredJdbcType) {
0:         case java.sql.Types.BIT:
0:         case java.sql.Types.TINYINT:
0:         case java.sql.Types.SMALLINT:
0:             return Types.SMALLINT;
0:         case java.sql.Types.INTEGER:
0:             return Types.INTEGER;
0:         case java.sql.Types.BIGINT:
0:             return Types.BIGINT;
0:         case java.sql.Types.REAL:
0:             return Types.REAL;
0:         case java.sql.Types.DOUBLE:
0:         case java.sql.Types.FLOAT:
0:             return Types.DOUBLE;
0:         case java.sql.Types.DECIMAL:
0:         case java.sql.Types.NUMERIC:
0:             return Types.DECIMAL;
0:         case java.sql.Types.DATE:
0:             return Types.DATE;
0:         case java.sql.Types.TIME:
0:             return Types.TIME;
0:         case java.sql.Types.TIMESTAMP:
0:             return Types.TIMESTAMP;
0:         case java.sql.Types.CHAR:
0:             return Types.CHAR;
0:         case java.sql.Types.VARCHAR:
0:             return Types.VARCHAR;
0:         case java.sql.Types.LONGVARCHAR:
0:             return Types.LONGVARCHAR;
0:         case java.sql.Types.BINARY:
0:             return Types.BINARY;
0:         case java.sql.Types.VARBINARY:
0:             return Types.VARBINARY;
0:         case java.sql.Types.LONGVARBINARY:
0:             return Types.LONGVARBINARY;
0:         case java.sql.Types.BLOB:
0:             return Types.BLOB;
0:         case java.sql.Types.CLOB:
0:             return Types.CLOB;
0:         case java.sql.Types.NULL:
0:         case java.sql.Types.OTHER:
0:             throw new SqlException(logWriter_, "Jdbc type " + guessedOrRegisteredJdbcType + " not yet supported.");
1:         default:
0:             throw new SqlException(logWriter_, "Unrecognized jdbc type " + guessedOrRegisteredJdbcType);
1:         }
1:     }
1: 
0:     private void guessParameterMetaDataBasedOnSupportedDriverType(int parameterIndex,
0:                                                                   boolean isBigInt,
0:                                                                   int driverType,
0:                                                                   int scale) throws SqlException {
0:         switch (driverType) {
0:         case Types.SMALLINT:
0:             guessParameterMetaData(parameterIndex, driverType, 2, 0, 0);
0:             break;
0:         case Types.INTEGER:
0:             guessParameterMetaData(parameterIndex, driverType, 4, 0, 0);
0:             break;
0:         case Types.BIGINT:
0:             guessParameterMetaData(parameterIndex, driverType, 8, 0, 0);
0:             break;
0:         case Types.REAL:
0:             guessParameterMetaData(parameterIndex, driverType, 4, 0, 0);
0:             break;
0:         case Types.DOUBLE:
0:             guessParameterMetaData(parameterIndex, driverType, 8, 0, 0);
0:             break;
0:         case Types.DECIMAL:
0:             if (isBigInt) {
0:                 guessParameterMetaData(parameterIndex, driverType, 0, 19, 0);
0:             } else {
0:                 guessParameterMetaData(parameterIndex, driverType, 0, 31, scale);
1:             }
0:             break;
0:         case Types.DATE:
0:             guessParameterMetaData(parameterIndex, driverType, 10, 0, 0);
0:             break;
0:         case Types.TIME:
0:             guessParameterMetaData(parameterIndex, driverType, 8, 0, 0);
0:             break;
0:         case Types.TIMESTAMP:
0:             guessParameterMetaData(parameterIndex, driverType, 26, 0, 0);
0:             break;
0:         case Types.CHAR:
0:         case Types.VARCHAR:
0:             guessParameterMetaData(parameterIndex, driverType, 32672, 0, 0);
0:             break;
0:         case Types.LONGVARCHAR:
0:             guessParameterMetaData(parameterIndex, driverType, 32700, 0, 0);
0:             break;
0:         case Types.BINARY:
0:         case Types.VARBINARY:
0:             guessParameterMetaData(parameterIndex, driverType, 4000, 0, 0);
0:             break;
0:         case Types.LONGVARBINARY:
0:             guessParameterMetaData(parameterIndex, driverType, 32700, 0, 0);
0:             break;
0:         case Types.BLOB:
0:             // 32768 will cause 8004 for a null placeholder length (could hard code in NET layer)
0:             guessParameterMetaData(parameterIndex, driverType, 32768, 0, 0);
0:             break;
0:         case Types.CLOB:
0:             // 32768 will cause 8004 for a null placeholder length (could hard code in NET layer)
0:             guessParameterMetaData(parameterIndex, driverType, 32768, 0, 0);
0:             break;
1:         default:
0:             throw new SqlException(logWriter_, "Unrecognized driver type " + driverType);
1:         }
1:     }
1: 
0:     // Only called when column meta data is not described
0:     private void guessParameterMetaData(int parameterIndex,
0:                                         int type,
0:                                         int length,
0:                                         int precision,
0:                                         int scale) {
0:         // Always guess that the column is nullable
0:         nullable_[parameterIndex - 1] = true;
0:         types_[parameterIndex - 1] = type;
0:         sqlLength_[parameterIndex - 1] = length;
0:         sqlPrecision_[parameterIndex - 1] = precision;
0:         sqlScale_[parameterIndex - 1] = scale;
0:         sqlType_[parameterIndex - 1] = mapDriverToSqlType(type, true);
1:     }
1: 
0:     int mapDriverToSqlType(int type, boolean nullable) {
0:         int sqlType = 0;
0:         switch (type) {
0:         case java.sql.Types.SMALLINT:
0:             sqlType = Types.DERBY_SQLTYPE_NSMALL;
0:             break;
0:         case java.sql.Types.INTEGER:
0:             sqlType = Types.DERBY_SQLTYPE_NINTEGER;
0:             break;
0:         case java.sql.Types.BIGINT:
0:             sqlType = Types.DERBY_SQLTYPE_NBIGINT;
0:             break;
0:         case java.sql.Types.REAL:
0:         case java.sql.Types.DOUBLE:
0:         case java.sql.Types.FLOAT:
0:             sqlType = Types.DERBY_SQLTYPE_NFLOAT;
0:             break;
0:         case java.sql.Types.DATE:
0:             sqlType = Types.DERBY_SQLTYPE_NDATE;
0:             break;
0:         case java.sql.Types.TIME:
0:             sqlType = Types.DERBY_SQLTYPE_NTIME;
0:             break;
0:         case java.sql.Types.TIMESTAMP:
0:             sqlType = Types.DERBY_SQLTYPE_NTIMESTAMP;
0:             break;
0:         case java.sql.Types.CHAR:
0:         case java.sql.Types.VARCHAR:
0:             sqlType = Types.DERBY_SQLTYPE_NVARCHAR;
0:             break;
0:         case java.sql.Types.LONGVARCHAR:
0:             sqlType = Types.DERBY_SQLTYPE_NLONG;
0:             break;
0:         case java.sql.Types.BINARY:
0:         case java.sql.Types.VARBINARY:
0:             sqlType = Types.DERBY_SQLTYPE_NVARCHAR;
0:             break;
0:         case java.sql.Types.LONGVARBINARY:
0:             sqlType = Types.DERBY_SQLTYPE_NLONG;
0:             break;
0:         case java.sql.Types.NUMERIC:
0:         case java.sql.Types.DECIMAL:
0:             sqlType = Types.DERBY_SQLTYPE_NDECIMAL;
0:             break;
0:         case java.sql.Types.BLOB:
0:             sqlType = Types.DERBY_SQLTYPE_NBLOB;
0:             break;
0:         case java.sql.Types.CLOB:
0:             sqlType = Types.DERBY_SQLTYPE_NCLOB;
0:             break;
1:         default:
0:             break; // bug check
1:         }
0:         if (!nullable) {
0:             sqlType--;
1:         }
0:         return sqlType;
1:     }
1: 
1: 
1:     public void setLogWriter(LogWriter logWriter) {
1:         logWriter_ = logWriter;
1:     }
1: 
1:     private void nullDataForGC() {
1:         columns_ = 0;
1:         nullable_ = null;
1:         types_ = null;
0:         singleMixedByteOrDouble_ = null;
1:         sqldRdbnam_ = null;
1:         sqldSchema_ = null;
1:         sqlPrecision_ = null;
1:         sqlScale_ = null;
1:         sqlLength_ = null;
1:         sqlType_ = null;
1:         sqlCcsid_ = null;
1:         sqlName_ = null;
1:         sqlLabel_ = null;
1:         sqlUnnamed_ = null;
1:         sqlComment_ = null;
1:         sqlxKeymem_ = null;
1:         sqlxGenerated_ = null;
1:         sqlxParmmode_ = null;
1:         sqlxCorname_ = null;
1:         sqlxName_ = null;
1:         sqlxBasename_ = null;
1:         sqlxUpdatable_ = null;
1:         sqlxSchema_ = null;
1:         sqlxRdbnam_ = null;
1:         clientParamtertype_ = null;
1:         types_ = null;
1:     }
1: 
0:     public boolean hasLobColumns() {
1:         for (int i = 0; i < columns_; i++) {
0:             switch (org.apache.derby.client.am.Utils.getNonNullableSqlType(sqlType_[i])) {
0:             case org.apache.derby.client.am.Types.DERBY_SQLTYPE_BLOB:
0:             case org.apache.derby.client.am.Types.DERBY_SQLTYPE_CLOB:
1:                 return true;
1:             default:
0:                 break;
1:             }
1:         }
1:         return false;
1:     }
1: 
1:     // Cache the hashtable in ColumnMetaData.
1:     int findColumnX(String columnName) throws SqlException {
1:         // Create cache if it doesn't exist
1:         if (columnNameToIndexCache_ == null) {
0:             columnNameToIndexCache_ = new java.util.Hashtable();
1:         } else { // Check cache for mapping
0:             Integer index = (Integer) columnNameToIndexCache_.get(columnName);
1:             if (index != null) {
1:                 return index.intValue();
1:             }
1:         }
1: 
1:         // Ok, we'll have to search the metadata
1:         for (int col = 0; col < this.columns_; col++) {
1:             if (this.sqlName_ != null && // sqlName comes from an optional group
1:                     this.sqlName_[col] != null &&
1:                     this.sqlName_[col].equalsIgnoreCase(columnName)) {
1:                 // Found it, add it to the cache
0:                 columnNameToIndexCache_.put(columnName, new Integer(col + 1));
1:                 return col + 1;
1:             }
1:         }
0:         throw new SqlException(logWriter_, "Invalid argument: unknown column name " + columnName);
1:     }
1: 
1:     // assign ordinal position as the column name if null.
0:     void assignColumnName(int column) {
1:         if (columnNameToIndexCache_ == null) {
0:             columnNameToIndexCache_ = new java.util.Hashtable();
1:         }
0:         String columnName = (new Integer(column)).toString();
0:         columnNameToIndexCache_.put(columnName, new Integer(column));
1:         sqlName_[column - 1] = columnName;
1:     }
1: 
0:     public boolean columnIsNotInUnicode(int index) {
0:         return (sqlCcsid_[index] != 1208);
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.ColumnMetaData
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: 
1: package org.apache.derby.client.am;
1: 
1: // Under JDBC 2, we must new up our parameter meta data as column meta data instances
1: // Once we move to JDK 1.4 pre-req, create a ResultSetMetaData class and make this class abstract
0: public class ColumnMetaData implements java.sql.ResultSetMetaData
0: {
1: 
0:   public int columns_;
1: 
0:   public boolean[] nullable_;
1: 
0:   // Although this is describe information, it is tagged transient for now becuase it is not currently used.
0:   transient public int[] singleMixedByteOrDouble_; // 1 means single, 2 means double, 3 means mixed-byte, 0 not applicable
1: 
0:   // All of the following state data comes from the SQLDA reply.
1: 
0:   //Data from SQLDHGRP
0:   public short sqldHold_;
0:   public short sqldReturn_;
0:   public short sqldScroll_;
0:   public short sqldSensitive_;
0:   public short sqldFcode_;
0:   public short sqldKeytype_;
0:   public String sqldRdbnam_; // catalog name, not used by driver, placeholder only
0:   public String sqldSchema_; // schema name, not used by driver, placeholder only
1: 
0:   //data comes from SQLDAGRP
0:   public int[] sqlPrecision_; // adjusted sqllen;
0:   public int[] sqlScale_;
0:   public long[] sqlLength_;  // This is maximum length for varchar fields
0:   // These are the derby sql types, for use only by ResultSetMetaData, other code should use jdbcTypes_.
0:   // sqlTypes_ is currently not set for input column meta data.
0:   public int[] sqlType_;
0:   public int[] sqlCcsid_;
1: 
0:   // With the exception of sqlNames_ and sqlxParmmode_, the following members are only allocated when needed
1: 
0:   //Data from SQLDOPTGRP
0:   public String[] sqlName_;   // column name, pre-allocated
0:   public String[] sqlLabel_;  // column label
0:   public short[] sqlUnnamed_;
0:   public String[] sqlComment_;
1: 
0:   //Data from SQLDXGRP
0:   public short[] sqlxKeymem_;
0:   public short[] sqlxGenerated_;
0:   public short[] sqlxParmmode_; // pre-allocated
0:   public String[] sqlxCorname_;
0:   public String[] sqlxName_;
0:   public String[] sqlxBasename_;  // table name
0:   public int[] sqlxUpdatable_;
0:   public String[] sqlxSchema_;    // schema name
0:   public String[] sqlxRdbnam_;    // catalog name
1: 
0:   //-----------------------------transient state--------------------------------
1: 
0:   // For performance only, not part of logical model.
0:   public transient int[][] protocolTypesCache_ = null;
0:   public transient java.util.Hashtable protocolTypeToOverrideLidMapping_ = null;
0:   public transient java.util.ArrayList mddOverrideArray_ = null;
1: 
0:   public transient int[] types_;
0:   public transient int[] clientParamtertype_;
1: 
0:   public transient LogWriter logWriter_;
1: 
0:   // only set on execute replies, this is not describe information.
0:   // only used for result set meta data. 
1: 
0:   public transient int resultSetConcurrency_;
1: 
0:   transient private java.util.Hashtable columnNameToIndexCache_ = null;
1: 
0:   transient private boolean statementClosed_ = false;
0:   void markClosed() {
0:     statementClosed_ = true;
0:     nullDataForGC();  
0:   }
1: 
0:   void checkForClosedStatement() throws SqlException
0:   {
0:     // agent_.checkForDeferredExceptions(); 
0:     if (statementClosed_) throw new SqlException (logWriter_, "Statement closed");
0:   }
1: 
1: 
0:   //---------------------navigational members-----------------------------------
1: 
0:   //---------------------constructors/finalizer---------------------------------
1: 
0:   // Called by NETColumnMetaData constructor before #columns is parsed out yet.
0:   public ColumnMetaData (LogWriter logWriter)
0:   {
0:     logWriter_ = logWriter;
0:   }
1: 
0:   // For creating column meta data when describe input is not available.
0:   // The upper bound that is passed in is determined by counting the number of parameter markers.
0:   // Called by PreparedStatement.flowPrepareStatement() and flowDescribeInputOutput()
0:   // only when describe input is not available.
0:   public ColumnMetaData (LogWriter logWriter, int upperBound)
0:   {
0:     logWriter_ = logWriter;
0:     initializeCache (upperBound);
0:   }
1: 
1: 
0:   public void initializeCache (int upperBound)
0:   {
0:     columns_ = upperBound;
0:     nullable_ = new boolean[upperBound];
0:     types_ = new int[upperBound];
0:     clientParamtertype_ = new int[upperBound];
0:     singleMixedByteOrDouble_ = new int[upperBound]; // 1 means single, 2 means double, 3 means mixed-byte, 0 not applicable
1: 
0:     sqlPrecision_ = new int[upperBound];
0:     sqlScale_ = new int[upperBound];
0:     sqlLength_ = new long[upperBound];
0:     sqlType_ = new int[upperBound];
0:     sqlCcsid_ = new int[upperBound];
1: 
0:     sqlName_ = new String[upperBound];
0:     sqlxParmmode_ = new short[upperBound];
0:   }
1: 
0:   protected void finalize () throws java.lang.Throwable
0:   {
0:     super.finalize();
0:   }
1: 
0:   //--------------------Abstract material layer call-down methods-----------------
1: 
0:   //------------------material layer event callback methods-----------------------
1: 
0:   // ---------------------------jdbc 1------------------------------------------
1: 
0:   public int getColumnCount () throws SqlException
0:   {
0:     checkForClosedStatement();
0:     return columns_;
0:   }
1: 
0:   public boolean isAutoIncrement (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     return false;
0:   }
1: 
0:   public boolean isCaseSensitive (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     //return true if the SQLTYPE is CHAR, VARCHAR, LOGVARCHAR or CLOB
0:       int type = types_[column-1];
0:       return
0:         type == Types.CHAR ||
0:         type == Types.VARCHAR ||
0:         type == Types.LONGVARCHAR ||
0:         type == Types.CLOB;
0:   }
1: 
0:   // all searchable except distinct
0:   public boolean isSearchable (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     return true;
0:   }
1: 
0:   public boolean isCurrency (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     return false;
0:   }
1: 
0:   public int isNullable (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     if (nullable_[column-1])
0:       return java.sql.ResultSetMetaData.columnNullable;
0:     else
0:       return java.sql.ResultSetMetaData.columnNoNulls;
0:   }
1: 
0:   public boolean isSigned (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     //return true only if the SQLType is SMALLINT, INT, BIGINT, FLOAT, REAL, DOUBLE, NUMERIC OR DECIMAL
0:       int type = types_[column-1];
0:       return
0:         type == Types.SMALLINT ||
0:         type == Types.INTEGER ||
0:         type == Types.BIGINT ||
0:         type == java.sql.Types.FLOAT ||
0:         type == Types.REAL ||
0:         type == Types.DOUBLE ||
0:         type == java.sql.Types.NUMERIC ||
0:         type == Types.DECIMAL;
0:   }
1: 
0:   public int getColumnDisplaySize (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:       int jdbcType = types_[column-1];
0:       switch (jdbcType){
0:       case Types.INTEGER:
0: 	return 11;
0:       case Types.SMALLINT:
0: 	return 6;
0:       case Types.BIGINT:
0: 	return 20;
0:       case Types.REAL:
0: 	return 13;
0:       case Types.DOUBLE:
0:       case java.sql.Types.FLOAT:
0: 	return 22;
0:       case Types.DECIMAL:
0:       case java.sql.Types.NUMERIC:
0: 	return getPrecision(column) + 2;  // add 1 for sign and 1 for decimal
0:       case Types.CHAR:
0:       case Types.VARCHAR:
0:       case Types.LONGVARCHAR:
0:       case Types.CLOB:
0: 	return (int) sqlLength_[column-1];
0:       case Types.DATE:
0: 	return 10;
0:       case Types.TIME:
0: 	return 8;
0:       case Types.TIMESTAMP:
0: 	return 26;
0:       case Types.BINARY:
0:       case Types.VARBINARY:
0:       case Types.LONGVARBINARY:
0:       case Types.BLOB:
0:         return (int) (2*sqlLength_[column-1]); // eg. "FF" represents just one byte
0:       default:
0: 	throw new SqlException (logWriter_, "not supported");
0:       }
0:   }
1: 
0:   public String getColumnLabel (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:       // return labels if label is turned on, otherwise, return column name
0:       if (sqlLabel_ != null && sqlLabel_[column-1] != null) return sqlLabel_[column-1];
0:       if (sqlName_ == null || sqlName_[column-1] == null)
0:         assignColumnName (column);
0:       return sqlName_[column-1];
0:   }
1: 
0:   public String getColumnName (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:       // The Javadoc and Jdbc book explicitly state that the empty string ("") is returned if "not applicable"
0:       // for the following methods:
0:       //   getSchemaName()
0:       //   getTableName()
0:       //   getCatalogName()
0:       // Since the empty string is a valid string and is not really a proper table name, schema name, or catalog name,
0:       // we're not sure why the empty string was chosen over null, except possibly to be friendly to lazy jdbc apps
0:       // that may not be checking for nulls, thereby minimizing potential NPE's.
0:       // By induction, it would make sense to return the empty string when column name is not available/applicable.
0:       //
0:       // The JDBC specification contains blanket statements about SQL compliance levels,
0:       // so elaboration within the JDBC specification is often bypassed.
0:       // Personally, I would prefer to return Java null for all the not-applicable cases,
0:       // but it appears that we have precedent for the empty ("") string.
0:       //
0:       // We assume a straightforward induction from jdbc spec that the column name be "" (empty)
0:       // in preference to null or NULL for the not applicable case.
0:       //
0:       if (sqlName_ == null || sqlName_[column-1] == null)
0:         assignColumnName (column);
0:       return sqlName_[column-1];
0:   }
1: 
0:   public String getSchemaName (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     if (sqlxSchema_ == null || sqlxSchema_[column-1] == null) return ""; // Per jdbc spec
0:     return sqlxSchema_[column-1];
0:   }
1: 
0:   public int getPrecision (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     int jdbcType = types_[column-1];
1: 
0:       switch (jdbcType) {
0:       case java.sql.Types.NUMERIC:
0:       case Types.DECIMAL:
0: 	return sqlPrecision_[column-1];
0:       case Types.SMALLINT:
0: 	return 5;
0:       case Types.INTEGER:
0: 	return 10;
0:       case Types.BIGINT:
0: 	return 19;
0:       case java.sql.Types.FLOAT:
0: 	return 15;
0:       case Types.REAL:
0: 	return 7;  // This is the number of signed digits for IEEE float with mantissa 24, ie. 2^24
0:       case Types.DOUBLE:
0: 	return 15; // This is the number of signed digits for IEEE float with mantissa 24, ie. 2^24
0:       case Types.CHAR:
0:       case Types.VARCHAR:
0:       case Types.LONGVARCHAR:
0:       case Types.BINARY:
0:       case Types.VARBINARY:
0:       case Types.LONGVARBINARY:
0:       case Types.CLOB:
0:       case Types.BLOB:
0: 	return (int) sqlLength_[column-1];
0:       case Types.DATE:
0: 	return 10;
0:       case Types.TIME:
0: 	return 8;
0:       case Types.TIMESTAMP:
0: 	return 26;
0:       default:
0:         throw new SqlException (logWriter_, "Unregistered column type");
0:       }
0:   }
1: 
0:   public int getScale (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
1: 
0:     // We get the scale from the SQLDA as returned by DERBY, but DERBY does not return the ANSI-defined
0:     // value of scale 6 for TIMESTAMP.
0:     //
0:     //   The JDBC drivers should hardcode this info as a short/near term solution.
0:     //
0:     if (types_[column-1] == Types.TIMESTAMP) return 6;
1: 
0:     return sqlScale_[column-1];
0:   }
1: 
0:   public String getTableName (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     if (sqlxBasename_ == null || sqlxBasename_[column-1] == null) return ""; // Per jdbc spec
0:     return sqlxBasename_[column-1];
0:   }
1: 
1:     /**
1:      * What's a column's table's catalog name?
1:      *
1:      * @param column the first column is 1, the second is 2, ...
1:      * @return column name or "" if not applicable.
0:      * @exception SQLException thrown on failure
1:      */
0:   public String getCatalogName (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0: 	return "";
0:   }
1: 
0:   public int getColumnType (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
1: 
0:     return types_[column-1];
0:   }
1: 
0:   public String getColumnTypeName (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
1: 
0:       int jdbcType = types_[column-1];
0:       // So these all come back zero for downlevel servers in PROTOCOL.
0:       // John is going to write some code to construct the sqlType_ array
0:       // based on the protocol types from the query descriptor.
0:       int sqlType = sqlType_[column-1];
1: 
0:       switch (sqlType) {
0:       case Types.DERBY_SQLTYPE_DATE:
0:       case Types.DERBY_SQLTYPE_NDATE:
0: 	return "DATE";
0:       case Types.DERBY_SQLTYPE_TIME:
0:       case Types.DERBY_SQLTYPE_NTIME:
0: 	return "TIME";
0:       case Types.DERBY_SQLTYPE_TIMESTAMP:
0:       case Types.DERBY_SQLTYPE_NTIMESTAMP:
0: 	return "TIMESTAMP";
0:       case Types.DERBY_SQLTYPE_BLOB:
0:       case Types.DERBY_SQLTYPE_NBLOB:
0: 	return "BLOB";
0:       case Types.DERBY_SQLTYPE_CLOB:
0:       case Types.DERBY_SQLTYPE_NCLOB:
0: 	return "CLOB";
0:       case Types.DERBY_SQLTYPE_VARCHAR:
0:       case Types.DERBY_SQLTYPE_NVARCHAR:
0: 	if (jdbcType == Types.VARBINARY)
0: 	  return "VARCHAR FOR BIT DATA";
0: 	else
0: 	  return "VARCHAR";
0:       case Types.DERBY_SQLTYPE_CHAR:
0:       case Types.DERBY_SQLTYPE_NCHAR:
0: 	if(jdbcType == Types.BINARY)
0: 	  return "CHAR FOR BIT DATA";
0: 	else
0: 	  return "CHAR";
0:       case Types.DERBY_SQLTYPE_LONG:
0:       case Types.DERBY_SQLTYPE_NLONG:
0: 	if(jdbcType == Types.LONGVARBINARY)
0: 	  return "LONG VARCHAR FOR BIT DATA";
0: 	else
0: 	  return "LONG VARCHAR";
0:       case Types.DERBY_SQLTYPE_CSTR:
0:       case Types.DERBY_SQLTYPE_NCSTR:
0: 	return "SBCS";
0:       case Types.DERBY_SQLTYPE_FLOAT:
0:       case Types.DERBY_SQLTYPE_NFLOAT:
0:         if(jdbcType == Types.DOUBLE)
0:           return "DOUBLE";
0:         if(jdbcType == Types.REAL)
0:           return "REAL";
0:       case Types.DERBY_SQLTYPE_DECIMAL:
0:       case Types.DERBY_SQLTYPE_NDECIMAL:
0: 	return "DECIMAL";
0:       case Types.DERBY_SQLTYPE_BIGINT:
0:       case Types.DERBY_SQLTYPE_NBIGINT:
0: 	return "BIGINT";
0:       case Types.DERBY_SQLTYPE_INTEGER:
0:       case Types.DERBY_SQLTYPE_NINTEGER:
0: 	return "INTEGER";
0:       case Types.DERBY_SQLTYPE_SMALL:
0:       case Types.DERBY_SQLTYPE_NSMALL:
0: 	return "SMALLINT";
0:       case Types.DERBY_SQLTYPE_NUMERIC:
0:       case Types.DERBY_SQLTYPE_NNUMERIC:
0: 	return "NUMERIC";
0:       default:
0: 	throw new SqlException (logWriter_, "Not supported");
0:       }
0:   }
1: 
0:   public boolean isReadOnly (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     if (sqlxUpdatable_ == null)
0:       return (resultSetConcurrency_ == java.sql.ResultSet.CONCUR_READ_ONLY); // If no extended describe, return resultSet's concurrecnty
0:     return sqlxUpdatable_[column-1] == 0; // PROTOCOL 0 means not updatable, 1 means updatable
0:   }
1: 
0:   public boolean isWritable (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     if (sqlxUpdatable_ == null)
0:       return (resultSetConcurrency_ == java.sql.ResultSet.CONCUR_UPDATABLE); // If no extended describe, return resultSet's concurrency
0:     return sqlxUpdatable_[column-1] == 1; // PROTOCOL 0 means not updatable, 1 means updatable
0:   }
1: 
0:   public boolean isDefinitelyWritable (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
0:     if (sqlxUpdatable_ == null) return false;
0:     return sqlxUpdatable_[column-1] == 1; // PROTOCOL 0 means not updatable, 1 means updatable
0:   }
1: 
0:   //--------------------------jdbc 2.0-----------------------------------
1: 
0:   public String getColumnClassName (int column) throws SqlException
0:   {
0:     checkForClosedStatement();
0:     checkForValidColumnIndex (column);
1: 
0:       int jdbcType = types_[column-1];
0:       switch (jdbcType) {
0:       case java.sql.Types.BIT:
0: 	return "java.lang.Boolean";
0:       case java.sql.Types.TINYINT:
0: 	return "java.lang.Integer";
0:       case Types.SMALLINT:
0: 	return "java.lang.Integer";
0:       case Types.INTEGER:
0: 	return "java.lang.Integer";
0:       case Types.BIGINT:
0: 	return "java.lang.Long";
0:       case java.sql.Types.FLOAT:
0: 	return "java.lang.Double";
0:       case Types.REAL:
0: 	return "java.lang.Float";
0:       case Types.DOUBLE:
0: 	return "java.lang.Double";
0:       case java.sql.Types.NUMERIC:
0:       case Types.DECIMAL:
0: 	return "java.math.BigDecimal";
0:       case Types.CHAR:
0:       case Types.VARCHAR:
0:       case Types.LONGVARCHAR:
0: 	return "java.lang.String";
0:       case Types.DATE:
0: 	return "java.sql.Date";
0:       case Types.TIME:
0: 	  return "java.sql.Time";
0:       case Types.TIMESTAMP:
0: 	  return "java.sql.Timestamp";
0:       case Types.BINARY:
0:       case Types.VARBINARY:
0:       case Types.LONGVARBINARY:
0: 	return "byte[]";
0:       case java.sql.Types.STRUCT:
0: 	return "java.sql.Struct";
0:       case java.sql.Types.ARRAY:
0: 	  return "java.sql.Array";
0:       case Types.BLOB:
0: 	  return "java.sql.Blob";
0:       case Types.CLOB:
0: 	  return "java.sql.Clob";
0:       case java.sql.Types.REF:
0: 	  return "java.sql.Ref";
0:       default:
0: 	throw new SqlException (logWriter_, "Not supported");
0:       }
0:   }
1: 
0:   //----------------------------helper methods----------------------------------
1: 
1: 
0:   void checkForValidColumnIndex (int column) throws SqlException
0:   {
0:     if (column < 1 || column > columns_)
0:       throw new SqlException (logWriter_, "Invalid argument: column index " +
0:                               column + " is out of range.");
0:   }
1: 
0:   // If the input parameter has been set, return true, else return false.
0:   private boolean isParameterModeGuessedAsAnInput (int parameterIndex)
0:   {
0:     if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeIn ||
0:         sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeInOut) {
0:       return true;
0:     }
0:     return false;
0:   }
1: 
0:   // Does OUT parm registration rely on extended describe?
0:   // If the output parameter has been registered, return true, else return false.
0:   public boolean isParameterModeGuessedAsOutput (int parameterIndex)
0:   {
0:     return sqlxParmmode_[parameterIndex - 1] >= java.sql.ParameterMetaData.parameterModeInOut;
0:   }
1: 
0:   // Only called when column meta data is not described. Called by setXXX methods.
0:   public void guessInputParameterMetaData (int parameterIndex,
0:                                             int jdbcType) throws SqlException
0:   {
0:     guessInputParameterMetaData (parameterIndex, jdbcType, 0);
0:   }
1: 
0:   private void setParmModeForInputParameter (int parameterIndex)
0:   {
0:     if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeOut)
0:       sqlxParmmode_[parameterIndex - 1] = java.sql.ParameterMetaData.parameterModeInOut;
0:     else if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeUnknown)
0:       sqlxParmmode_[parameterIndex - 1] = java.sql.ParameterMetaData.parameterModeIn;
0:   }
1: 
0:   // Only called when column meta data is not described. Called by setXXX methods.
0:   // Scale is only applied for Decimal or Numeric JDBC type.
0:   public void guessInputParameterMetaData (int parameterIndex,
0:                                             int jdbcType,
0:                                            int scale) throws SqlException
0:   {
0:     setParmModeForInputParameter (parameterIndex);
0:     int driverType = getInternalTypeForGuessedOrRegisteredJdbcType (jdbcType);
0:     // if output parameter has been registered already
0:     if (isParameterModeGuessedAsOutput (parameterIndex)) {
0:       if (!isCompatibleDriverTypes (types_[parameterIndex-1], driverType)) {
0:         throw new SqlException (logWriter_, "The jdbcType " + jdbcType + " does not match between the setter method and " +
0:                                 "the registerOutParameter method.");
0:       }
0:       else return; // don't bother guessing if the parameter was already registered
0:     }
0:     guessParameterMetaDataBasedOnSupportedDriverType (parameterIndex, jdbcType==java.sql.Types.BIGINT, driverType, scale);
0:   }
1: 
0:   private void setParmModeForOutputParameter (int parameterIndex)
0:   {
0:     if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeIn)
0:       sqlxParmmode_[parameterIndex - 1] = java.sql.ParameterMetaData.parameterModeInOut;
0:     else if (sqlxParmmode_[parameterIndex - 1] == java.sql.ParameterMetaData.parameterModeUnknown)
0:       sqlxParmmode_[parameterIndex - 1] = java.sql.ParameterMetaData.parameterModeOut;
0:   }
1: 
0:   // Only called when column meta data is not described, called by registerOutParameter methods.
0:   public void guessOutputParameterMetaData (int parameterIndex,
0:                                             int jdbcType,
0:                                             int scale) throws SqlException
0:   {
0:     setParmModeForOutputParameter (parameterIndex);
0:     int driverType = getInternalTypeForGuessedOrRegisteredJdbcType (jdbcType);
0:     if (isParameterModeGuessedAsAnInput (parameterIndex)) { // if input parameter has been set already
0:       // Verify that "set" and "registered" types are compatible.
0:       if (!isCompatibleDriverTypes (driverType, types_[parameterIndex -1])) {
0:          throw new SqlException (logWriter_, "The jdbcType does not match between the setter method and " +
0:           "the registerOutParameter method.");
0:       }
0:       // the registered type will take precedence over any previously guessed input "set" type
0:     }
0:     guessParameterMetaDataBasedOnSupportedDriverType (parameterIndex, jdbcType==java.sql.Types.BIGINT, driverType, scale);
0:   }
1: 
0:   private boolean isCompatibleDriverTypes (int registeredType, int guessedInputType)
0:   {
0:     switch (registeredType) {
0:     case Types.CHAR:
0:     case Types.VARCHAR:
0:     case Types.LONGVARCHAR:
0:       return guessedInputType == Types.CHAR || guessedInputType == Types.VARCHAR || guessedInputType == Types.LONGVARCHAR;
0:     case Types.BINARY:
0:     case Types.VARBINARY:
0:     case Types.LONGVARBINARY:
0:       return guessedInputType == Types.BINARY || guessedInputType == Types.VARBINARY || guessedInputType == Types.LONGVARBINARY;
0:     default:
0:       return registeredType == guessedInputType;
0:     }
0:   }
1: 
0:   // Only used when describe information is not available.
0:   private int getInternalTypeForGuessedOrRegisteredJdbcType (int guessedOrRegisteredJdbcType) throws SqlException
0:   {
0:     switch (guessedOrRegisteredJdbcType) {
0:     case java.sql.Types.BIT:
0:     case java.sql.Types.TINYINT:
0:     case java.sql.Types.SMALLINT:
0:       return Types.SMALLINT;
0:     case java.sql.Types.INTEGER:
0:       return Types.INTEGER;
0:     case java.sql.Types.BIGINT:
0: 		return Types.BIGINT;
0:     case java.sql.Types.REAL:
0:       return Types.REAL;
0:     case java.sql.Types.DOUBLE:
0:     case java.sql.Types.FLOAT:
0:       return Types.DOUBLE;
0:     case java.sql.Types.DECIMAL:
0:     case java.sql.Types.NUMERIC:
0:       return Types.DECIMAL;
0:     case java.sql.Types.DATE:
0:       return Types.DATE;
0:     case java.sql.Types.TIME:
0:       return Types.TIME;
0:     case java.sql.Types.TIMESTAMP:
0:       return Types.TIMESTAMP;
0:     case java.sql.Types.CHAR:
0:       return Types.CHAR;
0:     case java.sql.Types.VARCHAR:
0:       return Types.VARCHAR;
0:     case java.sql.Types.LONGVARCHAR:
0:       return Types.LONGVARCHAR;
0:     case java.sql.Types.BINARY:
0:       return Types.BINARY;
0:     case java.sql.Types.VARBINARY:
0:       return Types.VARBINARY;
0:     case java.sql.Types.LONGVARBINARY:
0:       return Types.LONGVARBINARY;
0:     case java.sql.Types.BLOB:
0:       return Types.BLOB;
0:     case java.sql.Types.CLOB:
0:       return Types.CLOB;
0:     case java.sql.Types.NULL:
0:     case java.sql.Types.OTHER:
0:       throw new SqlException (logWriter_,  "Jdbc type " + guessedOrRegisteredJdbcType + " not yet supported.");
0:     default:
0:       throw new SqlException (logWriter_, "Unrecognized jdbc type " + guessedOrRegisteredJdbcType);
0:     }
0:   }
1: 
0:   private void guessParameterMetaDataBasedOnSupportedDriverType (int parameterIndex,
0:                                                                  boolean isBigInt,
0:                                                                  int driverType,
0:                                                                  int scale) throws SqlException
0:   {
0:     switch (driverType) {
0:     case Types.SMALLINT:
0:       guessParameterMetaData (parameterIndex, driverType, 2, 0, 0);
0:         break;
0:     case Types.INTEGER:
0:       guessParameterMetaData (parameterIndex, driverType, 4, 0, 0);
0:         break;
0:     case Types.BIGINT:
0:       guessParameterMetaData (parameterIndex, driverType, 8, 0, 0);
0:         break;
0:     case Types.REAL:
0:       guessParameterMetaData (parameterIndex, driverType, 4, 0, 0);
0:         break;
0:     case Types.DOUBLE:
0:       guessParameterMetaData (parameterIndex, driverType, 8, 0, 0);
0:         break;
0:     case Types.DECIMAL:
0:       if (isBigInt)
0:         guessParameterMetaData (parameterIndex, driverType, 0, 19, 0);
0:       else
0:         guessParameterMetaData (parameterIndex, driverType, 0, 31, scale);
0:         break;
0:     case Types.DATE:
0:       guessParameterMetaData (parameterIndex, driverType, 10, 0, 0);
0:         break;
0:     case Types.TIME:
0:       guessParameterMetaData (parameterIndex, driverType, 8, 0, 0);
0:         break;
0:     case Types.TIMESTAMP:
0:       guessParameterMetaData (parameterIndex, driverType, 26, 0, 0);
0:         break;
0:     case Types.CHAR:
0:     case Types.VARCHAR:
0:       guessParameterMetaData (parameterIndex, driverType, 32672, 0, 0);
0:         break;
0:     case Types.LONGVARCHAR:
0:       guessParameterMetaData (parameterIndex, driverType, 32700, 0, 0);
0:         break;
0:     case Types.BINARY:
0:     case Types.VARBINARY:
0:       guessParameterMetaData (parameterIndex, driverType, 4000, 0, 0);
0:       break;
0:     case Types.LONGVARBINARY:
0:       guessParameterMetaData (parameterIndex, driverType, 32700, 0, 0);
0:       break;
0:     case Types.BLOB:
0:       // 32768 will cause 8004 for a null placeholder length (could hard code in NET layer)
0:       guessParameterMetaData (parameterIndex, driverType, 32768, 0, 0);
0:       break;
0:     case Types.CLOB:
0:       // 32768 will cause 8004 for a null placeholder length (could hard code in NET layer)
0:       guessParameterMetaData (parameterIndex, driverType, 32768, 0, 0);
0:         break;
0:     default:
0:       throw new SqlException (logWriter_, "Unrecognized driver type " + driverType);
0:       }
0:   }
1: 
0:   // Only called when column meta data is not described
0:   private void guessParameterMetaData (int parameterIndex,
0:                                       int type,
0:                                       int length,
0:                                       int precision,
0:                                       int scale)
0:   {
0:     // Always guess that the column is nullable
0:     nullable_[parameterIndex-1] = true;
0:     types_[parameterIndex-1] = type;
0:     sqlLength_[parameterIndex-1] = length;
0:     sqlPrecision_[parameterIndex-1] = precision;
0:     sqlScale_[parameterIndex-1] = scale;
0:     sqlType_[parameterIndex-1] = mapDriverToSqlType(type, true);
0:   }
1: 
0:   int mapDriverToSqlType(int type, boolean nullable)
0:   {
0:     int sqlType = 0;
0:     switch (type)
0:     {
0:       case java.sql.Types.SMALLINT:
0:         sqlType = Types.DERBY_SQLTYPE_NSMALL;
0:         break;
0:       case java.sql.Types.INTEGER:
0:         sqlType = Types.DERBY_SQLTYPE_NINTEGER;
0:         break;
0:       case java.sql.Types.BIGINT:
0:         sqlType = Types.DERBY_SQLTYPE_NBIGINT;
0:         break;
0:       case java.sql.Types.REAL:
0:       case java.sql.Types.DOUBLE:
0:       case java.sql.Types.FLOAT:
0:         sqlType = Types.DERBY_SQLTYPE_NFLOAT;
0:         break;
0:       case java.sql.Types.DATE:
0:         sqlType = Types.DERBY_SQLTYPE_NDATE;
0:         break;
0:       case java.sql.Types.TIME:
0:         sqlType = Types.DERBY_SQLTYPE_NTIME;
0:         break;
0:       case java.sql.Types.TIMESTAMP:
0:         sqlType = Types.DERBY_SQLTYPE_NTIMESTAMP;
0:         break;
0:       case java.sql.Types.CHAR:
0:       case java.sql.Types.VARCHAR:
0:         sqlType = Types.DERBY_SQLTYPE_NVARCHAR;
0:         break;
0:       case java.sql.Types.LONGVARCHAR:
0:         sqlType = Types.DERBY_SQLTYPE_NLONG;
0:         break;
0:       case java.sql.Types.BINARY:
0:       case java.sql.Types.VARBINARY:
0:         sqlType = Types.DERBY_SQLTYPE_NVARCHAR;
0:         break;
0:       case java.sql.Types.LONGVARBINARY:
0:         sqlType = Types.DERBY_SQLTYPE_NLONG;
0:         break;
0:       case java.sql.Types.NUMERIC:
0:       case java.sql.Types.DECIMAL:
0:         sqlType = Types.DERBY_SQLTYPE_NDECIMAL;
0:         break;
0:       case java.sql.Types.BLOB:
0:         sqlType = Types.DERBY_SQLTYPE_NBLOB;
0:         break;
0:       case java.sql.Types.CLOB:
0:         sqlType = Types.DERBY_SQLTYPE_NCLOB;
0:       break;
0:       default:
0:         break; // bug check
0:       }
0:       if (!nullable)
0:         sqlType--;
0:       return sqlType;
0:   }
1: 
1: 
0:   public void setLogWriter (LogWriter logWriter)
0:   {
0:     logWriter_ = logWriter;
0:   }
1: 
0:   private void nullDataForGC()
0:   {
0:     columns_ = 0;
0:     nullable_ = null;
0:     types_ = null;
0:     singleMixedByteOrDouble_ = null;
0:     sqldRdbnam_ = null;
0:     sqldSchema_ = null;
0:     sqlPrecision_ = null;
0:     sqlScale_ = null;
0:     sqlLength_ = null;
0:     sqlType_ = null;
0:     sqlCcsid_ = null;
0:     sqlName_ = null;
0:     sqlLabel_ = null;
0:     sqlUnnamed_ = null;
0:     sqlComment_ = null;
0:     sqlxKeymem_ = null;
0:     sqlxGenerated_ = null;
0:     sqlxParmmode_ = null;
0:     sqlxCorname_ = null;
0:     sqlxName_ = null;
0:     sqlxBasename_ = null;
0:     sqlxUpdatable_ = null;
0:     sqlxSchema_ = null;
0:     sqlxRdbnam_ = null;
0:     clientParamtertype_ = null;
0:     types_ = null;
0:   }
1: 
0:   public boolean hasLobColumns ()
0:   {
0:     for (int i=0; i<columns_; i++) {
0:       switch (org.apache.derby.client.am.Utils.getNonNullableSqlType (sqlType_[i])) {
0:         case org.apache.derby.client.am.Types.DERBY_SQLTYPE_BLOB:
0:         case org.apache.derby.client.am.Types.DERBY_SQLTYPE_CLOB:
0:           return true;
0:         default:
0:           break;
0:       }
0:     }
0:     return false;
0:   }
1: 
0:   // Cache the hashtable in ColumnMetaData.
0:   int findColumnX (String columnName) throws SqlException
0:   {
0:     // Create cache if it doesn't exist
0:     if (columnNameToIndexCache_ == null) {
0:       columnNameToIndexCache_ = new java.util.Hashtable ();
0:     }
0:     else { // Check cache for mapping
0:       Integer index = (Integer) columnNameToIndexCache_.get (columnName);
0:       if (index != null)
0:         return index.intValue ();
0:     }
1: 
0:     // Ok, we'll have to search the metadata
0:     for (int col = 0; col < this.columns_; col++) {
0:       if (this.sqlName_ != null && // sqlName comes from an optional group
0:           this.sqlName_[col] != null &&
0:           this.sqlName_[col].equalsIgnoreCase (columnName)) {
0:         // Found it, add it to the cache
0:         columnNameToIndexCache_.put (columnName, new Integer (col+1));
0:         return col+1;
0:       }
0:     }
0:     throw new SqlException (logWriter_, "Invalid argument: unknown column name " + columnName);
0:   }
1: 
0:   // assign ordinal position as the column name if null.
0:   void assignColumnName (int column)
0:   {
0:     if (columnNameToIndexCache_ == null)
0:       columnNameToIndexCache_ = new java.util.Hashtable ();
0:     String columnName = (new Integer(column)).toString();
0:     columnNameToIndexCache_.put (columnName, new Integer (column));
0:     sqlName_[column-1] = columnName;
0:   }
1: 
0:   public boolean columnIsNotInUnicode (int index)
0:   {
0:     return (sqlCcsid_[index] != 1208);
0:   }
1: 
0: }
============================================================================