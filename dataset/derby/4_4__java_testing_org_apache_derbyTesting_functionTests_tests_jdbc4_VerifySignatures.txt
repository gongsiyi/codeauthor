1:92caf5e: /*
1:92caf5e:  * Derby - org.apache.derbyTesting.functionTests.tests.jdbc4.VerifySignatures
6:92caf5e:  *
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:6e3dbab: 
1:6e3dbab:       http://www.apache.org/licenses/LICENSE-2.0
1:6e3dbab: 
1:6e3dbab:    Unless required by applicable law or agreed to in writing, software
1:6e3dbab:    distributed under the License is distributed on an "AS IS" BASIS,
1:6e3dbab:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6e3dbab:    See the License for the specific language governing permissions and
1:6e3dbab:    limitations under the License.
1:92caf5e:  *
5:92caf5e:  */
3:92caf5e: 
1:92caf5e: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:92caf5e: 
1:92caf5e: import java.lang.reflect.Method;
1:92caf5e: import java.lang.reflect.Modifier;
1:1ae02c9: import java.sql.Blob;
1:1ae02c9: import java.sql.CallableStatement;
1:1ae02c9: import java.sql.Clob;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.DatabaseMetaData;
1:1ae02c9: import java.sql.DriverManager;
1:1ae02c9: import java.sql.ParameterMetaData;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.ResultSetMetaData;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Savepoint;
1:1ae02c9: import java.sql.Statement;
1:92caf5e: import java.util.Arrays;
1:92caf5e: import java.util.HashSet;
1:92caf5e: import java.util.Set;
1:1ae02c9: import javax.sql.ConnectionPoolDataSource;
1:1ae02c9: import javax.sql.DataSource;
1:1ae02c9: import javax.sql.PooledConnection;
1:1ae02c9: import javax.sql.XAConnection;
1:1ae02c9: import javax.sql.XADataSource;
1:92caf5e: import junit.framework.Test;
1:92caf5e: import org.apache.derbyTesting.functionTests.util.TestUtil;
1:9f5c33f: import org.apache.derbyTesting.junit.BaseTestCase;
1:8ed08b2: import org.apache.derbyTesting.junit.J2EEDataSource;
1:8ed08b2: import org.apache.derbyTesting.junit.JDBCDataSource;
1:e0104e8: import org.apache.derbyTesting.junit.TestConfiguration;
1:92caf5e: 
5:92caf5e: /**
1:92caf5e:  * JUnit test which checks that all methods specified by the
1:92caf5e:  * interfaces in JDBC 4.0 are implemented. The test requires JVM 1.6
1:92caf5e:  * to run.
1:9f5c33f:  * Even though this class uses JDBC it extends BaseTestCase as
1:9f5c33f:  * it handles getting connections itself and thus does not
1:9f5c33f:  * need the utility methods or connecion handlng provided by
1:9f5c33f:  * BaseJDBCTestCase.
1:92caf5e:  */
1:9f5c33f: public class VerifySignatures extends BaseTestCase {
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * All the java.sql and javax.sql interfaces specified by JDBC 4.0.
1:92caf5e:      */
1:92caf5e:     private final static Class[] JDBC_INTERFACES = {
1:92caf5e:         java.sql.Array.class,
1:92caf5e:         java.sql.Blob.class,
1:92caf5e:         java.sql.CallableStatement.class,
1:92caf5e:         java.sql.Clob.class,
1:92caf5e:         java.sql.Connection.class,
1:92caf5e:         java.sql.DatabaseMetaData.class,
1:92caf5e:         java.sql.Driver.class,
1:92caf5e:         java.sql.NClob.class,
1:92caf5e:         java.sql.ParameterMetaData.class,
1:92caf5e:         java.sql.PreparedStatement.class,
1:92caf5e:         java.sql.Ref.class,
1:92caf5e:         java.sql.ResultSet.class,
1:92caf5e:         java.sql.ResultSetMetaData.class,
1:92caf5e:         java.sql.RowId.class,
1:92caf5e:         java.sql.Savepoint.class,
1:92caf5e:         java.sql.SQLData.class,
1:92caf5e:         java.sql.SQLInput.class,
1:92caf5e:         java.sql.SQLOutput.class,
1:92caf5e:         java.sql.SQLXML.class,
1:92caf5e:         java.sql.Statement.class,
1:92caf5e:         java.sql.Struct.class,
1:92caf5e:         java.sql.Wrapper.class,
1:92caf5e:         javax.sql.CommonDataSource.class,
1:92caf5e:         javax.sql.ConnectionEventListener.class,
1:92caf5e:         javax.sql.ConnectionPoolDataSource.class,
1:92caf5e:         javax.sql.DataSource.class,
1:92caf5e:         javax.sql.PooledConnection.class,
1:92caf5e:         javax.sql.RowSet.class,
1:92caf5e:         javax.sql.RowSetInternal.class,
1:92caf5e:         javax.sql.RowSetListener.class,
1:92caf5e:         javax.sql.RowSetMetaData.class,
1:92caf5e:         javax.sql.RowSetReader.class,
1:92caf5e:         javax.sql.RowSetWriter.class,
1:92caf5e:         javax.sql.StatementEventListener.class,
1:92caf5e:         javax.sql.XAConnection.class,
1:92caf5e:         javax.sql.XADataSource.class,
1:92caf5e:     };
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Creates a new instance.
1:92caf5e:      */
1:9f5c33f:     public VerifySignatures(String name) {
1:9f5c33f:         super(name);
5:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Build a suite of tests to be run.
1:92caf5e:      *
1:92caf5e:      * @return a test suite
1:92caf5e:      */
1:9f5c33f:     public static Test suite()  {
1:9f5c33f:         return TestConfiguration.defaultSuite(VerifySignatures.class);
1:dd7903b:     }
1:92caf5e:     
1:9f5c33f:     public void testAllJDBCObjects()
1:9f5c33f:       throws NoSuchMethodException, SQLException
1:9f5c33f:     {
1:92caf5e:         // set of all implementation/interface pairs found
1:92caf5e:         Set<ClassInfo> classes = new HashSet<ClassInfo>();
1:92caf5e: 
1:92caf5e:         collectClassesFromDataSource(classes);
1:92caf5e:         collectClassesFromConnectionPoolDataSource(classes);
1:92caf5e:         collectClassesFromXADataSource(classes);
1:92caf5e:         addClass(classes,
1:e0104e8:                  DriverManager.getDriver(TestConfiguration.getCurrent().getJDBCUrl()).getClass(),
1:92caf5e:                  java.sql.Driver.class);
1:92caf5e: 
1:92caf5e:         // all interfaces for which tests have been generated
1:92caf5e:         Set<Class> interfaces = new HashSet<Class>();
1:92caf5e: 
1:92caf5e:         for (ClassInfo pair : classes) {
1:92caf5e:             // some methods are defined in many interfaces, so collect
1:92caf5e:             // them in a set first to avoid duplicates
1:92caf5e:             Set<Method> methods = new HashSet<Method>();
1:92caf5e:             for (Class iface : getAllInterfaces(pair.jdbcInterface)) {
1:92caf5e:                 interfaces.add(iface);
1:92caf5e:                 for (Method method : iface.getMethods()) {
1:92caf5e:                     methods.add(method);
1:92caf5e:                 }
1:92caf5e:             }
1:92caf5e:             for (Method method : methods) {
1:9f5c33f:                 checkImplementationMethod(pair.derbyImplementation,
1:9f5c33f:                         method);
1:92caf5e:             }
1:92caf5e:         }
1:92caf5e:         
1:9f5c33f:         // Now ensure all interfaces were covered.
1:9f5c33f:         // get the declared set of interfaces Derby is
1:9f5c33f:         // expected to implement.
1:9f5c33f:         Set<Class> jdbcInterfaces = getInterfacesToCheck();
1:92caf5e:         
1:9f5c33f:         // remove from it all that were tested.
1:9f5c33f:         jdbcInterfaces.removeAll(interfaces);
1:92caf5e:         
1:9f5c33f:         // and the resultin set should be empty if we tested all!
1:92caf5e:         assertTrue("Unchecked interfaces: " + jdbcInterfaces,
1:92caf5e:                    jdbcInterfaces.isEmpty());
1:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Obtain a connection from a <code>DataSource</code> object and
1:92caf5e:      * perform JDBC operations on it. Collect the classes of all JDBC
1:92caf5e:      * objects that are found.
1:92caf5e:      *
1:92caf5e:      * @param classes set into which classes are collected
2:92caf5e:      * @exception SQLException if a database error occurs
1:92caf5e:      */
1:92caf5e:     private static void collectClassesFromDataSource(Set<ClassInfo> classes)
1:92caf5e:         throws SQLException
1:92caf5e:     {
1:8ed08b2:         DataSource ds = JDBCDataSource.getDataSource();
1:dfdbf62:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:dfdbf62:                                        "create=true");
1:92caf5e:         addClass(classes, ds.getClass(), javax.sql.DataSource.class);
1:92caf5e:         collectClassesFromConnection(ds.getConnection
1:e0104e8:                                      (TestConfiguration.getCurrent().getUserName(),
1:e0104e8:                                              TestConfiguration.getCurrent().getUserPassword()),
1:92caf5e:                                      classes);
1:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Obtain a connection from a <code>ConnectionPoolDataSource</code>
1:92caf5e:      * object and perform JDBC operations on it. Collect the classes
1:92caf5e:      * of all JDBC objects that are found.
1:92caf5e:      *
1:92caf5e:      * @param classes set into which classes are collected
1:92caf5e:      * @exception SQLException if a database error occurs
1:92caf5e:      */
1:92caf5e:     private static void
1:92caf5e:         collectClassesFromConnectionPoolDataSource(Set<ClassInfo> classes)
1:92caf5e:         throws SQLException
1:92caf5e:     {
1:8ed08b2:         ConnectionPoolDataSource cpds = J2EEDataSource.getConnectionPoolDataSource();
1:92caf5e:         addClass(classes,
1:92caf5e:                  cpds.getClass(), javax.sql.ConnectionPoolDataSource.class);
1:92caf5e: 
1:92caf5e:         PooledConnection pc =
1:e0104e8:             cpds.getPooledConnection(TestConfiguration.getCurrent().getUserName(),
1:e0104e8:                     TestConfiguration.getCurrent().getUserPassword());
1:92caf5e:         addClass(classes, pc.getClass(), javax.sql.PooledConnection.class);
1:92caf5e: 
1:92caf5e:         collectClassesFromConnection(pc.getConnection(), classes);
1:92caf5e: 
1:92caf5e:         pc.close();
1:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Obtain a connection from an <code>XADataSource</code> object
1:92caf5e:      * and perform JDBC operations on it. Collect the classes of all
1:92caf5e:      * JDBC objects that are found.
1:92caf5e:      *
1:92caf5e:      * @param classes set into which classes are collected
1:92caf5e:      * @exception SQLException if a database error occurs
1:92caf5e:      */
1:92caf5e:     private static void collectClassesFromXADataSource(Set<ClassInfo> classes)
1:92caf5e:         throws SQLException
1:92caf5e:     {
1:8ed08b2:         XADataSource xads = J2EEDataSource.getXADataSource();
1:92caf5e:         addClass(classes, xads.getClass(), javax.sql.XADataSource.class);
1:92caf5e: 
1:e0104e8:         XAConnection xaconn = xads.getXAConnection(TestConfiguration.getCurrent().getUserName(),
1:e0104e8:                 TestConfiguration.getCurrent().getUserPassword());
1:92caf5e:         addClass(classes, xaconn.getClass(), javax.sql.XAConnection.class);
1:92caf5e: 
1:92caf5e:         collectClassesFromConnection(xaconn.getConnection(), classes);
1:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Perform JDBC operations on a <code>Connection</code>. Collect
1:92caf5e:      * the classes of all JDBC objects that are found.
1:92caf5e:      *
1:92caf5e:      * @param conn connection to a database
1:92caf5e:      * @param classes set into which classes are collected
1:92caf5e:      * @exception SQLException if a database error occurs
1:92caf5e:      */
1:92caf5e:     private static void collectClassesFromConnection(Connection conn,
1:92caf5e:                                                      Set<ClassInfo> classes)
1:92caf5e:         throws SQLException
1:92caf5e:     {
1:92caf5e:         conn.setAutoCommit(false);
1:92caf5e:         addClass(classes, conn.getClass(), java.sql.Connection.class);
1:92caf5e: 
1:92caf5e:         Savepoint sp = conn.setSavepoint();
1:92caf5e:         addClass(classes, sp.getClass(), java.sql.Savepoint.class);
1:92caf5e:         conn.releaseSavepoint(sp);
1:92caf5e: 
1:92caf5e:         DatabaseMetaData dmd = conn.getMetaData();
1:92caf5e:         addClass(classes, dmd.getClass(), java.sql.DatabaseMetaData.class);
1:92caf5e: 
1:92caf5e:         collectClassesFromStatement(conn, classes);
1:92caf5e:         collectClassesFromPreparedStatement(conn, classes);
1:92caf5e:         collectClassesFromCallableStatement(conn, classes);
1:92caf5e:         conn.rollback();
1:92caf5e:         conn.close();
1:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Perform JDBC operations on a <code>Statement</code>. Collect
1:92caf5e:      * the classes of all JDBC objects that are found.
1:92caf5e:      *
1:92caf5e:      * @param conn connection to a database
1:92caf5e:      * @param classes set into which classes are collected
1:92caf5e:      * @exception SQLException if a database error occurs
1:92caf5e:      */
1:92caf5e:     private static void
1:92caf5e:         collectClassesFromStatement(Connection conn, Set<ClassInfo> classes)
1:92caf5e:         throws SQLException
1:92caf5e:     {
1:92caf5e:         Statement stmt = conn.createStatement();
1:92caf5e:         addClass(classes, stmt.getClass(), java.sql.Statement.class);
1:92caf5e: 
1:92caf5e:         stmt.execute("CREATE TABLE t (id INT PRIMARY KEY, " +
1:92caf5e:                      "b BLOB(10), c CLOB(10))");
1:92caf5e:         stmt.execute("INSERT INTO t (id, b, c) VALUES (1, "+
1:92caf5e:                      "CAST (" + TestUtil.stringToHexLiteral("101010001101") +
1:92caf5e:                      "AS BLOB(10)), CAST ('hello' AS CLOB(10)))");
1:92caf5e: 
1:92caf5e:         ResultSet rs = stmt.executeQuery("SELECT id, b, c FROM t");
1:92caf5e:         addClass(classes, rs.getClass(), java.sql.ResultSet.class);
1:92caf5e:         rs.next();
1:92caf5e:         Blob b = rs.getBlob(2);
1:92caf5e:         addClass(classes, b.getClass(), java.sql.Blob.class);
1:92caf5e:         Clob c = rs.getClob(3);
1:92caf5e:         addClass(classes, c.getClass(), java.sql.Clob.class);
1:92caf5e:         ResultSetMetaData rsmd = rs.getMetaData();
1:92caf5e:         addClass(classes, rsmd.getClass(), java.sql.ResultSetMetaData.class);
1:92caf5e:         rs.close();
1:92caf5e: 
1:92caf5e:         stmt.close();
1:92caf5e:         conn.rollback();
1:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Perform JDBC operations on a <code>PreparedStatement</code>.
1:92caf5e:      * Collect the classes of all JDBC objects that are found.
1:92caf5e:      *
1:92caf5e:      * @param conn connection to a database
1:92caf5e:      * @param classes set into which classes are collected
1:92caf5e:      * @exception SQLException if a database error occurs
1:92caf5e:      */
1:92caf5e:     private static void
1:92caf5e:         collectClassesFromPreparedStatement(Connection conn,
1:92caf5e:                                             Set<ClassInfo> classes)
1:92caf5e:         throws SQLException
1:92caf5e:     {
1:92caf5e:         PreparedStatement ps = conn.prepareStatement("VALUES(1)");
1:92caf5e:         addClass(classes, ps.getClass(), java.sql.PreparedStatement.class);
1:92caf5e:         ResultSet rs = ps.executeQuery();
1:92caf5e:         addClass(classes, rs.getClass(), java.sql.ResultSet.class);
1:92caf5e:         rs.close();
1:92caf5e: 
1:92caf5e:         ParameterMetaData pmd = ps.getParameterMetaData();
1:92caf5e:         addClass(classes, pmd.getClass(), java.sql.ParameterMetaData.class);
1:92caf5e: 
1:92caf5e:         ps.close();
1:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Perform JDBC operations on a <code>CallableStatement</code>.
1:92caf5e:      * Collect the classes of all JDBC objects that are found.
1:92caf5e:      *
1:92caf5e:      * @param conn connection to a database
1:92caf5e:      * @param classes set into which classes are collected
1:92caf5e:      * @exception SQLException if a database error occurs
1:92caf5e:      */
1:92caf5e:     private static void
1:92caf5e:         collectClassesFromCallableStatement(Connection conn,
1:92caf5e:                                             Set<ClassInfo> classes)
1:92caf5e:         throws SQLException
1:92caf5e:     {
1:92caf5e:         CallableStatement cs =
1:92caf5e:             conn.prepareCall("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");
1:92caf5e:         addClass(classes, cs.getClass(), java.sql.CallableStatement.class);
1:92caf5e: 
1:92caf5e:         ParameterMetaData pmd = cs.getParameterMetaData();
1:92caf5e:         addClass(classes, pmd.getClass(), java.sql.ParameterMetaData.class);
1:92caf5e: 
1:92caf5e:         cs.close();
1:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Adds a <code>ClassInfo</code> object to a set.
1:92caf5e:      *
1:92caf5e:      * @param classes set to which the class should be added
1:92caf5e:      * @param implementation Derby implementation class
1:92caf5e:      * @param iface JDBC interface supposed to be implemented
1:92caf5e:      */
1:92caf5e:     private static void addClass(Set<ClassInfo> classes,
1:92caf5e:                                  Class implementation, Class iface) {
1:92caf5e:         classes.add(new ClassInfo(implementation, iface));
1:92caf5e:     }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Get the set consisting of an interface and all its
1:92caf5e:      * super-interfaces.
1:92caf5e:      *
1:92caf5e:      * @param iface an interface
1:92caf5e:      * @return the set consisting of <code>iface</code> and all its
1:92caf5e:      * super-interfaces
1:92caf5e:      */
1:92caf5e:     private static Set<Class> getAllInterfaces(Class iface) {
1:92caf5e:         Set<Class> set = new HashSet<Class>();
1:92caf5e:         set.add(iface);
1:92caf5e:         for (Class superIface : iface.getInterfaces()) {
1:92caf5e:             set.add(superIface);
1:92caf5e:             set.addAll(getAllInterfaces(superIface));
1:92caf5e:         }
1:92caf5e:         return set;
1:92caf5e:     }
1:92caf5e:    
1:92caf5e:     /**
1:c7641f3:      * checks that a class implements a specific method.
1:c7641f3:      * @param derbyImplementation The Derby implementation class which is tested
1:c7641f3:      * @param ifaceMethod The method that should be implemented.
1:92caf5e:      */
1:c7641f3:     private static void checkImplementationMethod(
1:0f26c83:             Class<?> derbyImplementation, Method ifaceMethod)
1:c7641f3:         throws NoSuchMethodException
1:c7641f3:     {
1:92caf5e:         
1:92caf5e:             assertFalse("Implementation class is interface",
1:92caf5e:                         derbyImplementation.isInterface());
1:92caf5e: 
1:92caf5e:             Method impMethod =
1:92caf5e:                 derbyImplementation.getMethod(ifaceMethod.getName(),
1:92caf5e:                                               ifaceMethod.getParameterTypes());
1:69e3d06:             StringBuilder sb = new StringBuilder();
1:69e3d06:             Class[] pts = ifaceMethod.getParameterTypes();
1:69e3d06:             sb.append("(");
1:69e3d06:             for (int i=0; i < pts.length; i++) {
1:69e3d06:                 sb.append(pts[i].getName());
1:69e3d06:                 if (i < pts.length -1) {
1:69e3d06:                     sb.append(", ");
1:69e3d06:                 }
1:69e3d06:             }
1:69e3d06:             sb.append(")");
1:69e3d06:             assertEquals(
1:69e3d06:                     "Incorrect return type for " + ifaceMethod.getName() +
1:69e3d06:                     sb.toString(),
1:69e3d06:                     ifaceMethod.getReturnType(),
1:69e3d06:                     impMethod.getReturnType());
1:92caf5e: 
1:92caf5e:             int modifiers = impMethod.getModifiers();
1:92caf5e:             assertTrue("Non-public method", Modifier.isPublic(modifiers));
1:92caf5e:             assertFalse("Abstract method", Modifier.isAbstract(modifiers));
1:92caf5e:             assertFalse("Static method", Modifier.isStatic(modifiers));
1:92caf5e: 
1:92caf5e:             Class[] declaredExceptions = ifaceMethod.getExceptionTypes();
1:92caf5e:             for (Class exception : impMethod.getExceptionTypes()) {
1:92caf5e:                 if (RuntimeException.class.isAssignableFrom(exception)) {
1:92caf5e:                     continue;
1:92caf5e:                 }
1:92caf5e:                 assertNotNull("Incompatible throws clause",
1:92caf5e:                               findCompatibleClass(exception,
1:92caf5e:                                                   declaredExceptions));
1:92caf5e:             }
1:92caf5e:         }
1:92caf5e: 
1:92caf5e:         /**
1:92caf5e:          * Search an array of classes for a class that is identical to
1:92caf5e:          * or a super-class of the specified exception class.
1:92caf5e:          *
1:92caf5e:          * @param exception an exception class
1:92caf5e:          * @param declared an array of exception classes declared to
1:92caf5e:          * be thrown by a method
1:92caf5e:          * @return a class that is compatible with the specified
1:92caf5e:          * exception class, or <code>null</code> if no compatible
1:92caf5e:          * class is found
1:92caf5e:          */
1:c7641f3:         private static Class findCompatibleClass(Class exception, Class[] declared)
1:92caf5e:         {
1:92caf5e:             for (Class<?> dec : declared) {
1:92caf5e:                 if (dec.isAssignableFrom(exception)) {
1:92caf5e:                     return dec;
1:92caf5e:                 }
1:92caf5e:             }
1:92caf5e:             return null;
1:92caf5e:         }
1:92caf5e: 
1:92caf5e:         /**
1:9f5c33f:          * Returns the declared set of JDBC interfaces that
1:9f5c33f:          * Derby implements.
1:92caf5e:          *
1:92caf5e:          */
1:9f5c33f:         private static Set<Class> getInterfacesToCheck() {
1:92caf5e: 
1:9f5c33f:             Set<Class> jdbcInterfaces = new HashSet<Class>(Arrays.asList(JDBC_INTERFACES));
1:92caf5e: 
1:92caf5e:             // Remove the interfaces that we know we haven't checked.
1:92caf5e: 
1:92caf5e:             // Interfaces that Derby doesn't implement:
1:92caf5e:             jdbcInterfaces.remove(java.sql.Array.class);
1:92caf5e:             jdbcInterfaces.remove(java.sql.NClob.class);
1:92caf5e:             jdbcInterfaces.remove(java.sql.Ref.class);
1:92caf5e:             jdbcInterfaces.remove(java.sql.SQLData.class);
1:92caf5e:             jdbcInterfaces.remove(java.sql.SQLInput.class);
1:92caf5e:             jdbcInterfaces.remove(java.sql.SQLOutput.class);
1:92caf5e:             jdbcInterfaces.remove(java.sql.SQLXML.class);
1:92caf5e:             jdbcInterfaces.remove(java.sql.Struct.class);
1:92caf5e:             jdbcInterfaces.remove(javax.sql.RowSet.class);
1:92caf5e:             jdbcInterfaces.remove(javax.sql.RowSetInternal.class);
1:92caf5e:             jdbcInterfaces.remove(javax.sql.RowSetListener.class);
1:92caf5e:             jdbcInterfaces.remove(javax.sql.RowSetMetaData.class);
1:92caf5e:             jdbcInterfaces.remove(javax.sql.RowSetReader.class);
1:92caf5e:             jdbcInterfaces.remove(javax.sql.RowSetWriter.class);
1:92caf5e:             jdbcInterfaces.remove(java.sql.RowId.class);
1:92caf5e: 
1:92caf5e:             // The event listener interfaces are implemented in
1:92caf5e:             // application code, not in Derby code.
1:92caf5e:             jdbcInterfaces.remove(javax.sql.ConnectionEventListener.class);
1:92caf5e:             jdbcInterfaces.remove(javax.sql.StatementEventListener.class);
1:92caf5e:             
1:9f5c33f:             return jdbcInterfaces;
1:92caf5e:         }
1:92caf5e: 
1:92caf5e:     /**
1:92caf5e:      * Data structure holding a Derby implementation class and the
1:92caf5e:      * JDBC interface it is supposed to implement.
1:92caf5e:      */
1:92caf5e:     private static class ClassInfo {
1:92caf5e:         /** Derby implementation class. */
1:92caf5e:         Class derbyImplementation;
1:92caf5e:         /** JDBC interface which should be implemented. */
1:92caf5e:         Class jdbcInterface;
1:92caf5e: 
1:92caf5e:         /**
1:92caf5e:          * Creates a new <code>ClassInfo</code> instance.
1:92caf5e:          *
1:92caf5e:          * @param imp the Derby implementation class
1:92caf5e:          * @param iface the JDBC interface
1:92caf5e:          */
1:92caf5e:         ClassInfo(Class imp, Class iface) {
2:92caf5e:             derbyImplementation = imp;
1:92caf5e:             jdbcInterface = iface;
1:92caf5e:         }
1:92caf5e: 
1:92caf5e:         /**
1:92caf5e:          * Checks whether this object is equal to another object.
1:92caf5e:          *
1:92caf5e:          * @param x another object
1:92caf5e:          * @return <code>true</code> if the objects are equal,
1:92caf5e:          * <code>false</code> otherwise
1:92caf5e:          */
1:92caf5e:         public boolean equals(Object x) {
1:92caf5e:             if (x instanceof ClassInfo) {
1:92caf5e:                 ClassInfo ci = (ClassInfo) x;
1:92caf5e:                 return
1:92caf5e:                     derbyImplementation.equals(ci.derbyImplementation) &&
1:92caf5e:                     jdbcInterface.equals(ci.jdbcInterface);
1:92caf5e:             }
1:92caf5e:             return false;
1:92caf5e:         }
1:92caf5e: 
1:92caf5e:         /**
1:92caf5e:          * Calculate hash code.
1:92caf5e:          *
1:92caf5e:          * @return hash code
1:92caf5e:          */
1:92caf5e:         public int hashCode() {
1:92caf5e:             return derbyImplementation.hashCode() ^ jdbcInterface.hashCode();
1:92caf5e:         }
1:92caf5e:     }
1:92caf5e: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Blob;
1: import java.sql.CallableStatement;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.DriverManager;
1: import java.sql.ParameterMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Savepoint;
1: import java.sql.Statement;
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.DataSource;
1: import javax.sql.PooledConnection;
1: import javax.sql.XAConnection;
1: import javax.sql.XADataSource;
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1:             StringBuilder sb = new StringBuilder();
1:             Class[] pts = ifaceMethod.getParameterTypes();
1:             sb.append("(");
1:             for (int i=0; i < pts.length; i++) {
1:                 sb.append(pts[i].getName());
1:                 if (i < pts.length -1) {
1:                     sb.append(", ");
1:                 }
1:             }
1:             sb.append(")");
1:             assertEquals(
1:                     "Incorrect return type for " + ifaceMethod.getName() +
1:                     sb.toString(),
1:                     ifaceMethod.getReturnType(),
1:                     impMethod.getReturnType());
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9c8b717
/////////////////////////////////////////////////////////////////////////
commit:d6e7d39
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:dd7903b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
0:         if (JDBC.vmSupportsJDBC41()) {
0:             // DERBY-4869: The runtime environment supports JDBC 4.1, but
0:             // our database drivers don't yet. Disable this test until the
0:             // drivers have been updated.
0:             return new TestSuite("VerifySignatures - Disabled");
1:         }
commit:0f26c83
/////////////////////////////////////////////////////////////////////////
1:             Class<?> derbyImplementation, Method ifaceMethod)
commit:dfdbf62
/////////////////////////////////////////////////////////////////////////
1:         JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                                        "create=true");
commit:4782316
/////////////////////////////////////////////////////////////////////////
commit:57efc3c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.TestDataSourceFactory;
/////////////////////////////////////////////////////////////////////////
0:         DataSource ds = TestDataSourceFactory.getDataSource();
/////////////////////////////////////////////////////////////////////////
0:         ConnectionPoolDataSource cpds = TestDataSourceFactory.getConnectionPoolDataSource();
/////////////////////////////////////////////////////////////////////////
0:         XADataSource xads = TestDataSourceFactory.getXADataSource();
commit:92caf5e
/////////////////////////////////////////////////////////////////////////
1: /*
1:  * Derby - org.apache.derbyTesting.functionTests.tests.jdbc4.VerifySignatures
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its licensors, as
0:  * applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you
0:  * may not use this file except in compliance with the License. You
0:  * may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
0:  * implied. See the License for the specific language governing
0:  * permissions and limitations under the License.
1:  *
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
0: import java.sql.*;
0: import javax.sql.*;
1: 
1: import java.lang.reflect.Method;
1: import java.lang.reflect.Modifier;
1: import java.util.Arrays;
1: import java.util.HashSet;
1: import java.util.Set;
1: import junit.framework.Test;
0: import junit.framework.TestCase;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
1: import org.apache.derbyTesting.functionTests.util.TestUtil;
1: 
1: /**
1:  * JUnit test which checks that all methods specified by the
1:  * interfaces in JDBC 4.0 are implemented. The test requires JVM 1.6
1:  * to run.
1:  */
0: public class VerifySignatures extends BaseJDBCTestCase {
1: 
1:     /**
1:      * All the java.sql and javax.sql interfaces specified by JDBC 4.0.
1:      */
1:     private final static Class[] JDBC_INTERFACES = {
1:         java.sql.Array.class,
0:         java.sql.BaseQuery.class,
1:         java.sql.Blob.class,
1:         java.sql.CallableStatement.class,
1:         java.sql.Clob.class,
0:         java.sql.ConflictingRow.class,
1:         java.sql.Connection.class,
1:         java.sql.DatabaseMetaData.class,
0:         java.sql.DataSet.class,
0:         java.sql.DataSetResolver.class,
1:         java.sql.Driver.class,
1:         java.sql.NClob.class,
1:         java.sql.ParameterMetaData.class,
1:         java.sql.PreparedStatement.class,
0:         java.sql.QueryObjectGenerator.class,
1:         java.sql.Ref.class,
1:         java.sql.ResultSet.class,
1:         java.sql.ResultSetMetaData.class,
1:         java.sql.RowId.class,
1:         java.sql.Savepoint.class,
1:         java.sql.SQLData.class,
1:         java.sql.SQLInput.class,
1:         java.sql.SQLOutput.class,
1:         java.sql.SQLXML.class,
1:         java.sql.Statement.class,
1:         java.sql.Struct.class,
1:         java.sql.Wrapper.class,
1:         javax.sql.CommonDataSource.class,
1:         javax.sql.ConnectionEventListener.class,
1:         javax.sql.ConnectionPoolDataSource.class,
1:         javax.sql.DataSource.class,
1:         javax.sql.PooledConnection.class,
1:         javax.sql.RowSet.class,
1:         javax.sql.RowSetInternal.class,
1:         javax.sql.RowSetListener.class,
1:         javax.sql.RowSetMetaData.class,
1:         javax.sql.RowSetReader.class,
1:         javax.sql.RowSetWriter.class,
1:         javax.sql.StatementEventListener.class,
1:         javax.sql.XAConnection.class,
1:         javax.sql.XADataSource.class,
1:     };
1: 
1:     /**
1:      * Creates a new instance.
1:      */
0:     public VerifySignatures() {
0:         super("VerifySignatures");
1:     }
1: 
1:     /**
1:      * Build a suite of tests to be run.
1:      *
1:      * @return a test suite
1:      * @exception SQLException if a database error occurs
1:      */
0:     public static Test suite() throws SQLException {
1:         // set of all implementation/interface pairs found
1:         Set<ClassInfo> classes = new HashSet<ClassInfo>();
1: 
1:         collectClassesFromDataSource(classes);
1:         collectClassesFromConnectionPoolDataSource(classes);
1:         collectClassesFromXADataSource(classes);
1:         addClass(classes,
0:                  DriverManager.getDriver(CONFIG.getJDBCUrl()).getClass(),
1:                  java.sql.Driver.class);
1: 
0:         TestSuite suite = new TestSuite();
1: 
1:         // all interfaces for which tests have been generated
1:         Set<Class> interfaces = new HashSet<Class>();
1: 
1:         for (ClassInfo pair : classes) {
1:             // some methods are defined in many interfaces, so collect
1:             // them in a set first to avoid duplicates
1:             Set<Method> methods = new HashSet<Method>();
1:             for (Class iface : getAllInterfaces(pair.jdbcInterface)) {
1:                 interfaces.add(iface);
1:                 for (Method method : iface.getMethods()) {
1:                     methods.add(method);
1:                 }
1:             }
1:             for (Method method : methods) {
0:                 suite.addTest(new MethodTestCase(pair.derbyImplementation,
0:                                                  method));
1:             }
1:         }
0:         suite.addTest(new InterfaceCoverageTestCase(interfaces));
0:         return suite;
1:     }
1: 
1:     /**
1:      * Obtain a connection from a <code>DataSource</code> object and
1:      * perform JDBC operations on it. Collect the classes of all JDBC
1:      * objects that are found.
1:      *
1:      * @param classes set into which classes are collected
1:      * @exception SQLException if a database error occurs
1:      */
1:     private static void collectClassesFromDataSource(Set<ClassInfo> classes)
1:         throws SQLException
1:     {
0:         DataSource ds = getDataSource();
1:         addClass(classes, ds.getClass(), javax.sql.DataSource.class);
1:         collectClassesFromConnection(ds.getConnection
0:                                      (CONFIG.getUserName(),
0:                                       CONFIG.getUserPassword()),
1:                                      classes);
1:     }
1: 
1:     /**
1:      * Obtain a connection from a <code>ConnectionPoolDataSource</code>
1:      * object and perform JDBC operations on it. Collect the classes
1:      * of all JDBC objects that are found.
1:      *
1:      * @param classes set into which classes are collected
1:      * @exception SQLException if a database error occurs
1:      */
1:     private static void
1:         collectClassesFromConnectionPoolDataSource(Set<ClassInfo> classes)
1:         throws SQLException
1:     {
0:         ConnectionPoolDataSource cpds = getConnectionPoolDataSource();
1:         addClass(classes,
1:                  cpds.getClass(), javax.sql.ConnectionPoolDataSource.class);
1: 
1:         PooledConnection pc =
0:             cpds.getPooledConnection(CONFIG.getUserName(),
0:                                      CONFIG.getUserPassword());
1:         addClass(classes, pc.getClass(), javax.sql.PooledConnection.class);
1: 
1:         collectClassesFromConnection(pc.getConnection(), classes);
1: 
1:         pc.close();
1:     }
1: 
1:     /**
1:      * Obtain a connection from an <code>XADataSource</code> object
1:      * and perform JDBC operations on it. Collect the classes of all
1:      * JDBC objects that are found.
1:      *
1:      * @param classes set into which classes are collected
1:      * @exception SQLException if a database error occurs
1:      */
1:     private static void collectClassesFromXADataSource(Set<ClassInfo> classes)
1:         throws SQLException
1:     {
0:         XADataSource xads = getXADataSource();
1:         addClass(classes, xads.getClass(), javax.sql.XADataSource.class);
1: 
0:         XAConnection xaconn = xads.getXAConnection(CONFIG.getUserName(),
0:                                                    CONFIG.getUserPassword());
1:         addClass(classes, xaconn.getClass(), javax.sql.XAConnection.class);
1: 
1:         collectClassesFromConnection(xaconn.getConnection(), classes);
1:     }
1: 
1:     /**
1:      * Perform JDBC operations on a <code>Connection</code>. Collect
1:      * the classes of all JDBC objects that are found.
1:      *
1:      * @param conn connection to a database
1:      * @param classes set into which classes are collected
1:      * @exception SQLException if a database error occurs
1:      */
1:     private static void collectClassesFromConnection(Connection conn,
1:                                                      Set<ClassInfo> classes)
1:         throws SQLException
1:     {
1:         conn.setAutoCommit(false);
1:         addClass(classes, conn.getClass(), java.sql.Connection.class);
1: 
1:         Savepoint sp = conn.setSavepoint();
1:         addClass(classes, sp.getClass(), java.sql.Savepoint.class);
1:         conn.releaseSavepoint(sp);
1: 
1:         DatabaseMetaData dmd = conn.getMetaData();
1:         addClass(classes, dmd.getClass(), java.sql.DatabaseMetaData.class);
1: 
1:         collectClassesFromStatement(conn, classes);
1:         collectClassesFromPreparedStatement(conn, classes);
1:         collectClassesFromCallableStatement(conn, classes);
1:         conn.rollback();
1:         conn.close();
1:     }
1: 
1:     /**
1:      * Perform JDBC operations on a <code>Statement</code>. Collect
1:      * the classes of all JDBC objects that are found.
1:      *
1:      * @param conn connection to a database
1:      * @param classes set into which classes are collected
1:      * @exception SQLException if a database error occurs
1:      */
1:     private static void
1:         collectClassesFromStatement(Connection conn, Set<ClassInfo> classes)
1:         throws SQLException
1:     {
1:         Statement stmt = conn.createStatement();
1:         addClass(classes, stmt.getClass(), java.sql.Statement.class);
1: 
1:         stmt.execute("CREATE TABLE t (id INT PRIMARY KEY, " +
1:                      "b BLOB(10), c CLOB(10))");
1:         stmt.execute("INSERT INTO t (id, b, c) VALUES (1, "+
1:                      "CAST (" + TestUtil.stringToHexLiteral("101010001101") +
1:                      "AS BLOB(10)), CAST ('hello' AS CLOB(10)))");
1: 
1:         ResultSet rs = stmt.executeQuery("SELECT id, b, c FROM t");
1:         addClass(classes, rs.getClass(), java.sql.ResultSet.class);
1:         rs.next();
1:         Blob b = rs.getBlob(2);
1:         addClass(classes, b.getClass(), java.sql.Blob.class);
1:         Clob c = rs.getClob(3);
1:         addClass(classes, c.getClass(), java.sql.Clob.class);
1:         ResultSetMetaData rsmd = rs.getMetaData();
1:         addClass(classes, rsmd.getClass(), java.sql.ResultSetMetaData.class);
1:         rs.close();
1: 
1:         stmt.close();
1:         conn.rollback();
1:     }
1: 
1:     /**
1:      * Perform JDBC operations on a <code>PreparedStatement</code>.
1:      * Collect the classes of all JDBC objects that are found.
1:      *
1:      * @param conn connection to a database
1:      * @param classes set into which classes are collected
1:      * @exception SQLException if a database error occurs
1:      */
1:     private static void
1:         collectClassesFromPreparedStatement(Connection conn,
1:                                             Set<ClassInfo> classes)
1:         throws SQLException
1:     {
1:         PreparedStatement ps = conn.prepareStatement("VALUES(1)");
1:         addClass(classes, ps.getClass(), java.sql.PreparedStatement.class);
1:         ResultSet rs = ps.executeQuery();
1:         addClass(classes, rs.getClass(), java.sql.ResultSet.class);
1:         rs.close();
1: 
1:         ParameterMetaData pmd = ps.getParameterMetaData();
1:         addClass(classes, pmd.getClass(), java.sql.ParameterMetaData.class);
1: 
1:         ps.close();
1:     }
1: 
1:     /**
1:      * Perform JDBC operations on a <code>CallableStatement</code>.
1:      * Collect the classes of all JDBC objects that are found.
1:      *
1:      * @param conn connection to a database
1:      * @param classes set into which classes are collected
1:      * @exception SQLException if a database error occurs
1:      */
1:     private static void
1:         collectClassesFromCallableStatement(Connection conn,
1:                                             Set<ClassInfo> classes)
1:         throws SQLException
1:     {
1:         CallableStatement cs =
1:             conn.prepareCall("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");
1:         addClass(classes, cs.getClass(), java.sql.CallableStatement.class);
1: 
1:         ParameterMetaData pmd = cs.getParameterMetaData();
1:         addClass(classes, pmd.getClass(), java.sql.ParameterMetaData.class);
1: 
1:         cs.close();
1:     }
1: 
1:     /**
1:      * Adds a <code>ClassInfo</code> object to a set.
1:      *
1:      * @param classes set to which the class should be added
1:      * @param implementation Derby implementation class
1:      * @param iface JDBC interface supposed to be implemented
1:      */
1:     private static void addClass(Set<ClassInfo> classes,
1:                                  Class implementation, Class iface) {
1:         classes.add(new ClassInfo(implementation, iface));
1:     }
1: 
1:     /**
1:      * Get the set consisting of an interface and all its
1:      * super-interfaces.
1:      *
1:      * @param iface an interface
1:      * @return the set consisting of <code>iface</code> and all its
1:      * super-interfaces
1:      */
1:     private static Set<Class> getAllInterfaces(Class iface) {
1:         Set<Class> set = new HashSet<Class>();
1:         set.add(iface);
1:         for (Class superIface : iface.getInterfaces()) {
1:             set.add(superIface);
1:             set.addAll(getAllInterfaces(superIface));
1:         }
1:         return set;
1:     }
1: 
1:     /**
0:      * Test case which checks that a class implements a specific
0:      * method.
1:      */
0:     private static class MethodTestCase extends TestCase {
0:         /** The Derby implementation class which is tested. */
0:         private final Class derbyImplementation;
0:         /** The method that should be implemented. */
0:         private final Method ifaceMethod;
1: 
1:         /**
0:          * Creates a new <code>MethodTestCase</code> instance.
1:          *
0:          * @param imp the class to test
0:          * @param method the method to look for
1:          */
0:         private MethodTestCase(Class imp, Method method) {
0:             super("MethodTestCase{Class=" + imp.getName() +
0:                   ",Method=" + method + "}");
1:             derbyImplementation = imp;
0:             ifaceMethod = method;
1:         }
1: 
1:         /**
0:          * Run the test. Check that the method is implemented and that
0:          * its signature is correct.
1:          *
0:          * @exception NoSuchMethodException if the method is not found
1:          */
0:         public void runTest() throws NoSuchMethodException {
1:             assertFalse("Implementation class is interface",
1:                         derbyImplementation.isInterface());
1: 
1:             Method impMethod =
1:                 derbyImplementation.getMethod(ifaceMethod.getName(),
1:                                               ifaceMethod.getParameterTypes());
1: 
0:             assertEquals("Incorrect return type",
0:                          ifaceMethod.getReturnType(),
0:                          impMethod.getReturnType());
1: 
1:             int modifiers = impMethod.getModifiers();
1:             assertTrue("Non-public method", Modifier.isPublic(modifiers));
1:             assertFalse("Abstract method", Modifier.isAbstract(modifiers));
1:             assertFalse("Static method", Modifier.isStatic(modifiers));
1: 
1:             Class[] declaredExceptions = ifaceMethod.getExceptionTypes();
1:             for (Class exception : impMethod.getExceptionTypes()) {
1:                 if (RuntimeException.class.isAssignableFrom(exception)) {
1:                     continue;
1:                 }
1:                 assertNotNull("Incompatible throws clause",
1:                               findCompatibleClass(exception,
1:                                                   declaredExceptions));
1:             }
1:         }
1: 
1:         /**
1:          * Search an array of classes for a class that is identical to
1:          * or a super-class of the specified exception class.
1:          *
1:          * @param exception an exception class
1:          * @param declared an array of exception classes declared to
1:          * be thrown by a method
1:          * @return a class that is compatible with the specified
1:          * exception class, or <code>null</code> if no compatible
1:          * class is found
1:          */
0:         private Class findCompatibleClass(Class exception, Class[] declared)
1:         {
1:             for (Class<?> dec : declared) {
1:                 if (dec.isAssignableFrom(exception)) {
1:                     return dec;
1:                 }
1:             }
1:             return null;
1:         }
1:     }
1: 
1:     /**
0:      * Test case which checks that all relevant JDBC interfaces are
0:      * covered by the test.
1:      */
0:     private static class InterfaceCoverageTestCase extends TestCase {
1: 
0:         /** The interfaces that have been tested by
0:          * <code>MethodTestCase</code>. */
0:         private final Set<Class> checkedInterfaces;
0:         /** All JDBC interfaces whose implementations are relevant to
0:          * test. */
0:         private final Set<Class> jdbcInterfaces;
1: 
1:         /**
0:          * Creates a new <code>InterfaceCoverageTestCase</code> instance.
1:          *
0:          * @param interfaces the interfaces that have been tested
1:          */
0:         private InterfaceCoverageTestCase(Set<Class> interfaces) {
0:             super("InterfaceCoverageTestCase");
0:             checkedInterfaces = interfaces;
0:             jdbcInterfaces = new HashSet<Class>(Arrays.asList(JDBC_INTERFACES));
1: 
1:             // Remove the interfaces that we know we haven't checked.
1: 
1:             // Interfaces that Derby doesn't implement:
1:             jdbcInterfaces.remove(java.sql.Array.class);
0:             jdbcInterfaces.remove(java.sql.BaseQuery.class);
0:             jdbcInterfaces.remove(java.sql.ConflictingRow.class);
0:             jdbcInterfaces.remove(java.sql.DataSet.class);
0:             jdbcInterfaces.remove(java.sql.DataSetResolver.class);
1:             jdbcInterfaces.remove(java.sql.NClob.class);
0:             jdbcInterfaces.remove(java.sql.QueryObjectGenerator.class);
1:             jdbcInterfaces.remove(java.sql.Ref.class);
1:             jdbcInterfaces.remove(java.sql.SQLData.class);
1:             jdbcInterfaces.remove(java.sql.SQLInput.class);
1:             jdbcInterfaces.remove(java.sql.SQLOutput.class);
1:             jdbcInterfaces.remove(java.sql.SQLXML.class);
1:             jdbcInterfaces.remove(java.sql.Struct.class);
1:             jdbcInterfaces.remove(javax.sql.RowSet.class);
1:             jdbcInterfaces.remove(javax.sql.RowSetInternal.class);
1:             jdbcInterfaces.remove(javax.sql.RowSetListener.class);
1:             jdbcInterfaces.remove(javax.sql.RowSetMetaData.class);
1:             jdbcInterfaces.remove(javax.sql.RowSetReader.class);
1:             jdbcInterfaces.remove(javax.sql.RowSetWriter.class);
1: 
0:             // Derby implements RowId classes, but has no way to
0:             // obtain an object of that type.
1:             jdbcInterfaces.remove(java.sql.RowId.class);
1: 
1:             // The event listener interfaces are implemented in
1:             // application code, not in Derby code.
1:             jdbcInterfaces.remove(javax.sql.ConnectionEventListener.class);
1:             jdbcInterfaces.remove(javax.sql.StatementEventListener.class);
1:         }
1: 
1:         /**
0:          * Run the test. Check that all relevant interfaces have been
0:          * tested.
1:          */
0:         public void runTest() {
0:             jdbcInterfaces.removeAll(checkedInterfaces);
1:             assertTrue("Unchecked interfaces: " + jdbcInterfaces,
1:                        jdbcInterfaces.isEmpty());
1:         }
1:     }
1: 
1:     /**
1:      * Data structure holding a Derby implementation class and the
1:      * JDBC interface it is supposed to implement.
1:      */
1:     private static class ClassInfo {
1:         /** Derby implementation class. */
1:         Class derbyImplementation;
1:         /** JDBC interface which should be implemented. */
1:         Class jdbcInterface;
1: 
1:         /**
1:          * Creates a new <code>ClassInfo</code> instance.
1:          *
1:          * @param imp the Derby implementation class
1:          * @param iface the JDBC interface
1:          */
1:         ClassInfo(Class imp, Class iface) {
1:             derbyImplementation = imp;
1:             jdbcInterface = iface;
1:         }
1: 
1:         /**
1:          * Checks whether this object is equal to another object.
1:          *
1:          * @param x another object
1:          * @return <code>true</code> if the objects are equal,
1:          * <code>false</code> otherwise
1:          */
1:         public boolean equals(Object x) {
1:             if (x instanceof ClassInfo) {
1:                 ClassInfo ci = (ClassInfo) x;
1:                 return
1:                     derbyImplementation.equals(ci.derbyImplementation) &&
1:                     jdbcInterface.equals(ci.jdbcInterface);
1:             }
1:             return false;
1:         }
1: 
1:         /**
1:          * Calculate hash code.
1:          *
1:          * @return hash code
1:          */
1:         public int hashCode() {
1:             return derbyImplementation.hashCode() ^ jdbcInterface.hashCode();
1:         }
1:     }
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9f5c33f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestCase;
/////////////////////////////////////////////////////////////////////////
1:  * Even though this class uses JDBC it extends BaseTestCase as
1:  * it handles getting connections itself and thus does not
1:  * need the utility methods or connecion handlng provided by
1:  * BaseJDBCTestCase.
1: public class VerifySignatures extends BaseTestCase {
/////////////////////////////////////////////////////////////////////////
1:     public VerifySignatures(String name) {
1:         super(name);
1:     public static Test suite()  {
0:         
1:         return TestConfiguration.defaultSuite(VerifySignatures.class);
0:     }
0:     
1:     public void testAllJDBCObjects()
1:       throws NoSuchMethodException, SQLException
1:     {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 checkImplementationMethod(pair.derbyImplementation,
1:                         method);
0:         
1:         // Now ensure all interfaces were covered.
1:         // get the declared set of interfaces Derby is
1:         // expected to implement.
1:         Set<Class> jdbcInterfaces = getInterfacesToCheck();
0:         
1:         // remove from it all that were tested.
1:         jdbcInterfaces.removeAll(interfaces);
0:         
1:         // and the resultin set should be empty if we tested all!
0:         assertTrue("Unchecked interfaces: " + jdbcInterfaces,
0:                    jdbcInterfaces.isEmpty());
/////////////////////////////////////////////////////////////////////////
0:    
/////////////////////////////////////////////////////////////////////////
1:          * Returns the declared set of JDBC interfaces that
1:          * Derby implements.
1:         private static Set<Class> getInterfacesToCheck() {
0: 
1:             Set<Class> jdbcInterfaces = new HashSet<Class>(Arrays.asList(JDBC_INTERFACES));
/////////////////////////////////////////////////////////////////////////
0:             
1:             return jdbcInterfaces;
commit:c7641f3
/////////////////////////////////////////////////////////////////////////
0:             checkImplementationMethod(derbyImplementation, ifaceMethod);
0:         }   
0:     }
0:     
0:     /**
1:      * checks that a class implements a specific method.
1:      * @param derbyImplementation The Derby implementation class which is tested
1:      * @param ifaceMethod The method that should be implemented.
0:      */
1:     private static void checkImplementationMethod(
0:             Class derbyImplementation, Method ifaceMethod)
1:         throws NoSuchMethodException
1:     {
0:         
/////////////////////////////////////////////////////////////////////////
1:         private static Class findCompatibleClass(Class exception, Class[] declared)
/////////////////////////////////////////////////////////////////////////
commit:8ed08b2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
/////////////////////////////////////////////////////////////////////////
1:         DataSource ds = JDBCDataSource.getDataSource();
/////////////////////////////////////////////////////////////////////////
1:         ConnectionPoolDataSource cpds = J2EEDataSource.getConnectionPoolDataSource();
/////////////////////////////////////////////////////////////////////////
1:         XADataSource xads = J2EEDataSource.getXADataSource();
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("VerifySignatures suite");
commit:e0104e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:                  DriverManager.getDriver(TestConfiguration.getCurrent().getJDBCUrl()).getClass(),
/////////////////////////////////////////////////////////////////////////
1:                                      (TestConfiguration.getCurrent().getUserName(),
1:                                              TestConfiguration.getCurrent().getUserPassword()),
/////////////////////////////////////////////////////////////////////////
1:             cpds.getPooledConnection(TestConfiguration.getCurrent().getUserName(),
1:                     TestConfiguration.getCurrent().getUserPassword());
/////////////////////////////////////////////////////////////////////////
1:         XAConnection xaconn = xads.getXAConnection(TestConfiguration.getCurrent().getUserName(),
1:                 TestConfiguration.getCurrent().getUserPassword());
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
============================================================================