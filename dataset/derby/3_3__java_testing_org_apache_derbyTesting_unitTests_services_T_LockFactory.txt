1:2bc809f: /*
22:2bc809f: 
1:2bc809f:    Derby - Class org.apache.derbyTesting.unitTests.services.T_LockFactory
1:2bc809f: 
1:c38b841:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c38b841:    contributor license agreements.  See the NOTICE file distributed with
1:c38b841:    this work for additional information regarding copyright ownership.
1:c38b841:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c38b841:    (the "License"); you may not use this file except in compliance with
1:c38b841:    the License.  You may obtain a copy of the License at
1:2bc809f: 
1:2bc809f:       http://www.apache.org/licenses/LICENSE-2.0
1:2bc809f: 
1:2bc809f:    Unless required by applicable law or agreed to in writing, software
1:2bc809f:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bc809f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bc809f:    See the License for the specific language governing permissions and
1:2bc809f:    limitations under the License.
1:2bc809f: 
2:2bc809f:  */
1:2bc809f: 
1:2bc809f: package org.apache.derbyTesting.unitTests.services;
1:2bc809f: 
1:56c1dc2: import java.security.AccessController;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:56c1dc2: 
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_MultiIterations;
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.locks.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.monitor.Monitor;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.reference.SQLState;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.error.StandardException;
1:2bc809f: 
2:2bc809f: /**
1:2bc809f: 	Protocol unit test for the LockManager.
1:2bc809f: 
1:2bc809f: 	@see LockFactory
1:df4020d: 	@see org.apache.derbyTesting.unitTests.harness.UnitTest
1:2bc809f: */
1:2bc809f: 
1:2bc809f: public class T_LockFactory extends T_MultiIterations
1:2bc809f: {
1:2bc809f: 	protected final static int ITERATIONS = 100;	// iterations of multi-user tests
1:2bc809f: 
1:2bc809f: 	protected LockFactory	lf;
1:2bc809f: 
1:2bc809f: 	public T_LockFactory() {
1:2bc809f: 		super();
8:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	** The tests
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	protected String getModuleToTestProtocolName() {
1:2bc809f: 
1:2bc809f: 		return org.apache.derby.iapi.reference.Module.LockFactory;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Run all the tests, each test that starts with 'S' is a single user
1:2bc809f: 		test, each test that starts with 'M' is a multi-user test.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail The test failed in some way.
1:2bc809f: 	*/
1:2bc809f: 	protected  void setupTest() throws T_Fail {
1:2bc809f: 
3:2bc809f: 		try {
1:56c1dc2: 			lf = (LockFactory) startSystemModule(getModuleToTestProtocolName());
1:2bc809f: 		} catch (StandardException mse) {
1:2bc809f: 			throw T_Fail.exceptionFail(mse);
1:2bc809f: 		}
1:2bc809f: 		if (lf == null) {
1:2bc809f: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " module not started.");
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Run once per-iteration to run the actual test.
1:2bc809f: 		@exception T_Fail the test failed in some way.
1:2bc809f: 	*/
1:2bc809f: 	protected void runTestSet() throws T_Fail {
1:2bc809f: 
1:2bc809f: 		// Set up the expected error handling
1:2bc809f: 		try {
1:2bc809f: 			
1:2bc809f: 			S001();
1:2bc809f: 			S002();
1:2bc809f: 			S003();
1:2bc809f: 			S004();
1:2bc809f: 			S005();
1:2bc809f: 			S007();
1:2bc809f: 
1:2bc809f: 			M001();
1:2bc809f: 			M002();
1:2bc809f: 			M003();
1:2bc809f: 			M004();
1:2bc809f: 			
1:2bc809f: 
1:2bc809f: 		} catch (StandardException se) {
1:2bc809f: 
1:2bc809f: 			throw T_Fail.exceptionFail(se);
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	** Test functions
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Single user API test 001.
1:2bc809f: 
1:2bc809f: 		Lock an single object in a single group with all lock methods and
1:2bc809f: 		then unlock the object with all unlock methods.
1:2bc809f: 
2:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
2:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 	*/
1:2bc809f: 	void S001() throws StandardException, T_Fail {
1:2bc809f: 
1:3c1f634: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
1:2bc809f: 		Object g0 = new Object();	// create an object for a lock group
1:2bc809f: 		Lockable l0 = new T_L1();		// simple lockable
1:2bc809f: 
2:2bc809f: 		int count;
1:2bc809f: 		
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		// lock and unlock specifically (no timeout)
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		checkLockCount(cs, 1);
1:2bc809f: 		count = lf.unlock(cs, g0, l0, null);
1:2bc809f: 		if (count != 1)
1:2bc809f: 			throw T_Fail.testFailMsg("invalid unlock count, expected 1, got " + count);
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		// lock twice and unlock all ...
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		checkLockCount(cs, 2);
1:2bc809f: 		lf.unlock(cs, g0, l0, null);
1:2bc809f: 		lf.unlock(cs, g0, l0, null);
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		// lock three times and unlock by group
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		checkLockCount(cs, 3);
1:2bc809f: 		lf.unlockGroup(cs, g0);
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		// lock three times and unlock explicitly
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		checkLockCount(cs, 3);
1:2bc809f: 
1:2bc809f: 		lf.unlock(cs, g0, l0, null);
1:2bc809f: 		checkLockCount(cs, 2);
1:2bc809f: 
1:2bc809f: 		lf.unlock(cs, g0, l0, null);
1:2bc809f: 		checkLockCount(cs, 1);
1:2bc809f: 
1:2bc809f: 		lf.unlock(cs, g0, l0, null);
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		// lock and unlock specifically with timeout
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, 1000 /*ms*/);
1:2bc809f: 		checkLockCount(cs, 1);
1:2bc809f: 		count = lf.unlock(cs, g0, l0, null);
1:2bc809f: 		if (count != 1)
1:2bc809f: 			throw T_Fail.testFailMsg("invalid unlock count, expected 1, got " + count);
1:2bc809f: 
1:2bc809f: 		PASS("S001");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Single user API test 002.
1:2bc809f: 
1:2bc809f: 		Lock an object in different groups and check unlocks
1:2bc809f: 		apply to a single group.
1:2bc809f: 
1:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
1:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	void S002() throws StandardException, T_Fail {
1:2bc809f: 
1:3c1f634: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
1:2bc809f: 		Object g0 = new Object();	// create an object for a lock group
2:2bc809f: 		Object g1 = new Object();
1:2bc809f: 		Lockable l0 = new T_L1();		// simple lockable
1:2bc809f: 
1:2bc809f: 		int count;
1:2bc809f: 		
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		// lock object in two groups and unlock specifically
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g1, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		checkLockGroupCount(cs, g0, 1);
1:2bc809f: 		checkLockGroupCount(cs, g1, 1);
1:2bc809f: 		checkLockCount(cs, 2);
1:2bc809f: 
1:2bc809f: 		count = lf.unlock(cs, g0, l0, null);
1:2bc809f: 		if (count != 1)
1:2bc809f: 			throw T_Fail.testFailMsg("invalid unlock count, expected 1, got " + count);
1:2bc809f: 		checkLockGroupCount(cs, g0, 0);
1:2bc809f: 		checkLockGroupCount(cs, g1, 1);
1:2bc809f: 		checkLockCount(cs, 1);
1:2bc809f: 
1:2bc809f: 		count = lf.unlock(cs, g1, l0, null);
1:2bc809f: 		if (count != 1)
1:2bc809f: 			throw T_Fail.testFailMsg("invalid unlock count, expected 1, got " + count);
1:2bc809f: 		checkLockGroupCount(cs, g0, 0);
1:2bc809f: 		checkLockGroupCount(cs, g1, 0);
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		// lock object in two groups and unlock by group
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g1, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		checkLockCount(cs, 2);
1:2bc809f: 
1:2bc809f: 		lf.unlockGroup(cs, g1);
1:2bc809f: 		checkLockGroupCount(cs, g0, 1);
1:2bc809f: 		checkLockGroupCount(cs, g1, 0);
1:2bc809f: 		checkLockCount(cs, 1);
1:2bc809f: 
1:2bc809f: 		lf.unlockGroup(cs, g0);
1:2bc809f: 		checkLockGroupCount(cs, g0, 0);
1:2bc809f: 		checkLockGroupCount(cs, g1, 0);
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		PASS("S002");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Single user API test 003.
1:2bc809f: 
1:2bc809f: 		Lock multiple objects in different groups and check unlocks
1:2bc809f: 		apply to a single group.
1:2bc809f: 
1:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
1:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	void S003() throws StandardException, T_Fail {
1:2bc809f: 
1:3c1f634: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
1:2bc809f: 		Object g0 = new Object();	// create an object for a lock group
1:2bc809f: 		Object g1 = new Object();
1:2bc809f: 		Lockable l0 = new T_L1();		// simple lockable
1:2bc809f: 		Lockable l1 = new T_L1();
1:2bc809f: 		Lockable l2 = new T_L1();
1:2bc809f: 
1:2bc809f: 		int count;
1:2bc809f: 		
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		// lock l0 object in two groups and l1,l2 in group l1
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g1, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g1, l1, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g1, l2, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 
1:2bc809f: 		checkLockGroupCount(cs, g0, 1);
1:2bc809f: 		checkLockGroupCount(cs, g1, 3);
1:2bc809f: 		checkLockCount(cs, 4);
1:2bc809f: 
1:2bc809f: 		// quick check to see that no one is blocked
1:2bc809f: 		if (lf.anyoneBlocked())
1:2bc809f: 			throw T_Fail.testFailMsg("anyoneBlocked() returned true on a set of private locks");
1:2bc809f: 
1:2bc809f: 		lf.unlock(cs, g1, l1, null);
1:2bc809f: 		checkLockGroupCount(cs, g0, 1);
1:2bc809f: 		checkLockGroupCount(cs, g1, 2);
1:2bc809f: 		checkLockCount(cs, 3);
1:2bc809f: 
1:2bc809f: 		lf.unlockGroup(cs, g1);
1:2bc809f: 		checkLockGroupCount(cs, g0, 1);
1:2bc809f: 		checkLockGroupCount(cs, g1, 0);
1:2bc809f: 		checkLockCount(cs, 1);
1:2bc809f: 
1:2bc809f: 		lf.unlockGroup(cs, g0);
1:2bc809f: 		checkLockGroupCount(cs, g0, 0);
1:2bc809f: 		checkLockGroupCount(cs, g1, 0);
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		PASS("S003");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Single user API test 004.
1:2bc809f: 
1:2bc809f: 		Lock multiple objects in different groups and transfer
1:2bc809f: 		locks between groups.
1:2bc809f: 
1:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
1:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	void S004() throws StandardException, T_Fail {
1:2bc809f: 
1:3c1f634: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
1:2bc809f: 		Object g0 = new Object();	// create an object for a lock group
1:2bc809f: 		Object g1 = new Object();
1:2bc809f: 		Object g2 = new Object();
1:2bc809f: 		Lockable l0 = new T_L1();		// simple lockable
1:2bc809f: 		Lockable l1 = new T_L1();
1:2bc809f: 		Lockable l2 = new T_L1();
1:2bc809f: 
1:2bc809f: 		int count = 0;
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		// lock l0 object in two groups and l1,l2 in group l1
1:2bc809f: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g1, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g1, l1, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs, g1, l2, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 
1:2bc809f: 		checkLockGroupCount(cs, g0, 1);
1:2bc809f: 		checkLockGroupCount(cs, g1, 3);
1:2bc809f: 		checkLockCount(cs, 4);
1:2bc809f: 
1:2bc809f: 		lf.transfer(cs, g0, g1);
1:2bc809f: 		checkLockGroupCount(cs, g0, 0);
1:2bc809f: 		checkLockGroupCount(cs, g1, 4);
1:2bc809f: 		checkLockCount(cs, 4);
1:2bc809f: 
1:2bc809f: 		// transfer an empty to a non-existent one
1:2bc809f: 		lf.transfer(cs, g0, g2);
1:2bc809f: 		checkLockGroupCount(cs, g0, 0);
1:2bc809f: 		checkLockGroupCount(cs, g1, 4);
1:2bc809f: 		checkLockGroupCount(cs, g2, 0);
1:2bc809f: 		checkLockCount(cs, 4);
1:2bc809f: 		
1:2bc809f: 		lf.lockObject(cs, g2, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		checkLockGroupCount(cs, g2, 1);
1:2bc809f: 		checkLockCount(cs, 5);
1:2bc809f: 
1:2bc809f: 		lf.transfer(cs, g1, g2);
1:2bc809f: 		checkLockGroupCount(cs, g1, 0);
1:2bc809f: 		checkLockGroupCount(cs, g2, 5);
1:2bc809f: 		checkLockCount(cs, 5);
1:2bc809f: 
1:2bc809f: 		lf.transfer(cs, g2, g1);
1:2bc809f: 		checkLockGroupCount(cs, g1, 5);
1:2bc809f: 		checkLockGroupCount(cs, g2, 0);
1:2bc809f: 		checkLockCount(cs, 5);
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		lf.unlockGroup(cs, g2);
1:2bc809f: 		checkLockGroupCount(cs, g1, 5);
1:2bc809f: 		checkLockGroupCount(cs, g2, 0);
1:2bc809f: 		checkLockCount(cs, 5);
1:2bc809f: 
1:2bc809f: 		lf.unlockGroup(cs, g1);
1:2bc809f: 		checkLockGroupCount(cs, g1, 0);
1:2bc809f: 		checkLockGroupCount(cs, g2, 0);
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 
1:2bc809f: 		PASS("S004");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Single user API test 005.
1:2bc809f: 
1:2bc809f: 		Create two compatability spaces and ensure that locks
2:2bc809f: 		block each other out.
1:00d19b5: 
1:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
1:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 	*/
1:2bc809f: 	void S005() throws StandardException, T_Fail {
1:2bc809f: 
1:3c1f634: 		CompatibilitySpace cs0 = lf.createCompatibilitySpace(null);
1:3c1f634: 		CompatibilitySpace cs1 = lf.createCompatibilitySpace(null);
1:2bc809f: 
1:2bc809f: 		Object g0 = new Object();	// create an object for a lock group
1:2bc809f: 		Object g1 = new Object();	// create an object for a lock group
1:2bc809f: 		Lockable l0 = new T_L1();
1:2bc809f: 		Lockable l1 = new T_L1();
1:2bc809f: 		Lockable l2 = new T_L1();
1:2bc809f: 
1:2bc809f: 		int count;
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs0, 0);
1:2bc809f: 		checkLockCount(cs1, 0);
1:2bc809f: 
1:2bc809f: 		lf.lockObject(cs0, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		lf.lockObject(cs1, g1, l1, null, C_LockFactory.WAIT_FOREVER);
3:2bc809f: 		checkLockCount(cs0, 1);
2:2bc809f: 		checkLockCount(cs1, 1);
1:2bc809f: 
1:2bc809f: 		lf.lockObject(cs0, g0, l2, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		checkLockCount(cs0, 2);
1:2bc809f: 		checkLockCount(cs1, 1);
1:2bc809f: 
1:2bc809f: 		// now attempt to lock l2 in cs1 with a timeout, should fail
1:2bc809f: 		try {
1:2bc809f: 			lf.lockObject(cs1, g1, l2, null, 200 /* ms */);
2:2bc809f: 			throw T_Fail.testFailMsg("lock succeeded on already locked object");
1:2bc809f: 		}
3:2bc809f: 		catch (StandardException lfe) {
1:2bc809f: 			// we are expecting the timout exception, anything else is an error
3:2bc809f: 			if (!lfe.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
3:2bc809f: 				throw lfe;
1:2bc809f: 			}
1:2bc809f: 			checkLockCount(cs0, 2);
1:2bc809f: 			checkLockCount(cs1, 1);
1:2bc809f: 
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// now unlock the object, and re-attempt the lock
1:2bc809f: 		lf.unlock(cs0, g0, l2, null);
1:2bc809f: 		checkLockCount(cs0, 1);
1:2bc809f: 		checkLockCount(cs1, 1);
1:2bc809f: 		lf.lockObject(cs1, g1, l2, null, C_LockFactory.WAIT_FOREVER);
1:2bc809f: 		checkLockCount(cs0, 1);
2:2bc809f: 		checkLockCount(cs1, 2);
1:2bc809f: 
1:2bc809f: 		lf.unlockGroup(cs0, g0);
1:2bc809f: 		lf.unlockGroup(cs1, g1);
1:2bc809f: 		checkLockCount(cs0, 0);
1:2bc809f: 		checkLockCount(cs1, 0);
1:2bc809f: 
1:2bc809f: 		PASS("S005");
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	}	
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Single user API test 007.
1:2bc809f: 
1:2bc809f: 		Tests on groups and compatibility spaces
1:2bc809f: 		never seen by the lock manager.
1:2bc809f: 		
1:2bc809f: 
1:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
1:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 	*/
1:2bc809f: 	void S007() throws StandardException, T_Fail {
1:2bc809f: 
1:3c1f634: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
1:2bc809f: 		Object g0 = new Object();	// create an object for a lock group
1:2bc809f: 		Object g1 = new Object();	// create an object for a lock group
1:2bc809f: 		Lockable l0 = new T_L1();
1:2bc809f: 
1:2bc809f: 		int count;
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 		checkLockGroupCount(cs, g0, 0);
1:2bc809f: 
1:2bc809f: 		lf.unlockGroup(cs, g0);
1:2bc809f: 		lf.unlockGroup(cs, cs);
1:2bc809f: 		lf.unlock(cs, g0, l0, null);
1:2bc809f: 
1:2bc809f: 		lf.transfer(cs, g0, g1);
1:2bc809f: 		lf.transfer(cs, g1, g0);
1:2bc809f: 
1:2bc809f: 		if (lf.anyoneBlocked())
1:2bc809f: 			throw T_Fail.testFailMsg("anyoneBlocked() returned true on an empty space");
1:2bc809f: 
1:2bc809f: 		// check we have no locks held
1:2bc809f: 		checkLockCount(cs, 0);
1:2bc809f: 		checkLockGroupCount(cs, g0, 0);
1:2bc809f: 		checkLockGroupCount(cs, g1, 0);
1:2bc809f: 
1:2bc809f: 		PASS("S007");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	** Multi-user tests.
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Multi-user test 001.
1:2bc809f: 
1:2bc809f: 		Create two lockable objects and pass them off to two threads.
1:2bc809f: 		Each thread will run lock the first object, set its value then lock
1:dbed020: 		the second object and set its value, yield and then release the lock
1:2bc809f: 		on one and then on two. Various checks are made to ensure the
1:2bc809f: 		values are as expected.
1:2bc809f: 
1:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
1:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	void M001() throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 		Lockable[] locks = new T_L1[2];
1:2bc809f: 		locks[0] = new T_L1();
1:2bc809f: 		locks[1] = new T_L1();
1:2bc809f: 
1:2bc809f: 		T_User u1 = new T_User(1, lf, locks, ITERATIONS, 10 * ITERATIONS);
1:2bc809f: 		T_User u2 = new T_User(1, lf, locks, ITERATIONS, 20 * ITERATIONS);
1:2bc809f: 		Thread t1 = new Thread(u1);
1:2bc809f: 		Thread t2 = new Thread(u2);
1:2bc809f: 
1:2bc809f: 		t1.start();
1:2bc809f: 		t2.start();
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 			t1.join();
1:2bc809f: 			t2.join();
1:2bc809f: 		} catch (InterruptedException ie) {
1:2bc809f: 			throw T_Fail.exceptionFail(ie);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		if (u1.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u1.error);
1:2bc809f: 		if (u2.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u2.error);
1:2bc809f: 
1:2bc809f: 		PASS("M001");
1:2bc809f: 	}
1:2bc809f: 	
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Multi-user test 002
1:2bc809f: 
1:2bc809f: 		Create a single lockable and have three threads lock it, yield and
1:2bc809f: 		then release it. The single lockable can only have one locker.
1:2bc809f: 
1:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
1:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 		
1:2bc809f: 	void M002() throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 		Lockable[] locks = new T_L1[1];
1:2bc809f: 		locks[0] = new T_L1();
1:2bc809f: 
1:2bc809f: 		T_User u1 = new T_User(2, lf, locks, ITERATIONS, 10 * ITERATIONS);
1:2bc809f: 		T_User u2 = new T_User(2, lf, locks, ITERATIONS, 20 * ITERATIONS);
1:2bc809f: 		T_User u3 = new T_User(2, lf, locks, ITERATIONS, 30 * ITERATIONS);
1:2bc809f: 		Thread t1 = new Thread(u1);
1:2bc809f: 		Thread t2 = new Thread(u2);
1:2bc809f: 		Thread t3 = new Thread(u3);
1:2bc809f: 
1:2bc809f: 		t1.start();
1:2bc809f: 		t2.start();
1:2bc809f: 		t3.start();
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 			t1.join();
1:2bc809f: 			t2.join();
1:2bc809f: 			t3.join();
1:2bc809f: 		} catch (InterruptedException ie) {
1:2bc809f: 			throw T_Fail.exceptionFail(ie);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		if (u1.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u1.error);
1:2bc809f: 		if (u2.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u2.error);
1:2bc809f: 		if (u3.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u3.error);
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		PASS("M002");
1:2bc809f: 	}
1:2bc809f: 	/**
1:2bc809f: 		Multi-user test 003
1:2bc809f: 
1:2bc809f: 		Create a single lockable and have three threads lock it, yield and
1:2bc809f: 		then release it. The single lockable is a semaphore that can have two lockers.
1:2bc809f: 
1:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
1:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 		
1:2bc809f: 	void M003() throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 		Lockable[] locks = new Lockable[1];
1:2bc809f: 		locks[0] = new T_L2(2);
1:2bc809f: 
1:2bc809f: 		T_User u1 = new T_User(3, lf, locks, ITERATIONS, 0);
1:2bc809f: 		T_User u2 = new T_User(3, lf, locks, ITERATIONS, 0);
1:2bc809f: 		T_User u3 = new T_User(3, lf, locks, ITERATIONS, 0);
1:2bc809f: 		Thread t1 = new Thread(u1);
1:2bc809f: 		Thread t2 = new Thread(u2);
1:2bc809f: 		Thread t3 = new Thread(u3);
1:2bc809f: 
1:2bc809f: 		t1.start();
1:2bc809f: 		t2.start();
1:2bc809f: 		t3.start();
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 			t1.join();
1:2bc809f: 			t2.join();
1:2bc809f: 			t3.join();
1:2bc809f: 		} catch (InterruptedException ie) {
1:2bc809f: 			throw T_Fail.exceptionFail(ie);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		if (u1.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u1.error);
1:2bc809f: 		if (u2.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u2.error);
1:2bc809f: 		if (u3.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u3.error);
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		PASS("M003");
1:2bc809f: 	}
1:2bc809f: 	/**
1:2bc809f: 		Multi-user test 004
1:2bc809f: 
1:2bc809f: 		As M003 but each thread will lock the object twice, to ensure that
1:2bc809f: 		lock manager grantes the lock when the compatability space and qualifier
1:2bc809f: 		match.
1:2bc809f: 
1:2bc809f: 		@exception StandardException	An exception thrown by a method of LockFactory
1:2bc809f: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 		
1:2bc809f: 	void M004() throws StandardException, T_Fail {
1:2bc809f: 
1:2bc809f: 		Lockable[] locks = new Lockable[1];
1:2bc809f: 		locks[0] = new T_L2(2);
1:2bc809f: 
1:2bc809f: 		T_User u1 = new T_User(4, lf, locks, ITERATIONS, 0);
1:2bc809f: 		T_User u2 = new T_User(4, lf, locks, ITERATIONS, 0);
1:2bc809f: 		T_User u3 = new T_User(4, lf, locks, ITERATIONS, 0);
1:2bc809f: 		Thread t1 = new Thread(u1);
1:2bc809f: 		Thread t2 = new Thread(u2);
1:2bc809f: 		Thread t3 = new Thread(u3);
1:2bc809f: 
1:2bc809f: 		t1.start();
1:2bc809f: 		t2.start();
1:2bc809f: 		t3.start();
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 			t1.join();
1:2bc809f: 			t2.join();
1:2bc809f: 			t3.join();
1:2bc809f: 		} catch (InterruptedException ie) {
1:2bc809f: 			throw  T_Fail.exceptionFail(ie);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		if (u1.error != null)
1:2bc809f: 			throw  T_Fail.exceptionFail(u1.error);
1:2bc809f: 		if (u2.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u2.error);
1:2bc809f: 		if (u3.error != null)
1:2bc809f: 			throw T_Fail.exceptionFail(u3.error);
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		PASS("M004");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	** Utility functions
1:2bc809f: 	*/
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 		Check to see if the total number of locks we have is as expected.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail	Number of locks is not as expected.
1:2bc809f: 	*/
1:3c1f634: 	void checkLockCount(CompatibilitySpace cs, int expected) throws T_Fail {
1:2bc809f: 		boolean expect = expected != 0;
1:2bc809f: 		boolean got = lf.areLocksHeld(cs);
1:2bc809f: 		if (got != expect)
1:2bc809f: 			throw T_Fail.testFailMsg("Expected lock count (" + expect + "), got (" + got + ")");
1:2bc809f: 	}
1:56c1dc2: 
1:56c1dc2: 	/**
1:2bc809f: 		Check to see if the number of locks in a group we have is as expected.
1:2bc809f: 
1:2bc809f: 		@exception T_Fail	Number of locks is not as expected.
1:2bc809f: 	*/
1:2bc809f: 
1:3c1f634: 	void checkLockGroupCount(CompatibilitySpace cs, Object group, int expected)
1:3c1f634: 			throws T_Fail {
1:2bc809f: 		boolean expect = expected != 0;
1:2bc809f: 		boolean got = lf.areLocksHeld(cs, group);
1:2bc809f: 		if (got != expect)
1:2bc809f: 			throw T_Fail.testFailMsg("Expected lock count (" + expect + "), got (" + got + ")");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f:     
1:2bc809f:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object  startSystemModule( final String factoryInterface )
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.startSystemModule( factoryInterface );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:2bc809f: }
1:2bc809f: 
1:2bc809f: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 		the second object and set its value, yield and then release the lock
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
1: 
/////////////////////////////////////////////////////////////////////////
1: 			lf = (LockFactory) startSystemModule(getModuleToTestProtocolName());
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object  startSystemModule( final String factoryInterface )
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.startSystemModule( factoryInterface );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3c1f634
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs0 = lf.createCompatibilitySpace(null);
1: 		CompatibilitySpace cs1 = lf.createCompatibilitySpace(null);
/////////////////////////////////////////////////////////////////////////
1: 		CompatibilitySpace cs = lf.createCompatibilitySpace(null);
/////////////////////////////////////////////////////////////////////////
1: 	void checkLockCount(CompatibilitySpace cs, int expected) throws T_Fail {
/////////////////////////////////////////////////////////////////////////
1: 	void checkLockGroupCount(CompatibilitySpace cs, Object group, int expected)
1: 			throws T_Fail {
commit:1d8153c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:00d19b5
/////////////////////////////////////////////////////////////////////////
0: 		This test case originally tested that latches were released when a row
0: 		lock couldn't be obtained immediately, but LockFactory doesn't have
0: 		that functionality any more after DERBY-2197.
1: 
/////////////////////////////////////////////////////////////////////////
0: 		lf.lockObject(cs0, g0, rA, null, C_LockFactory.WAIT_FOREVER);
0: 		lf.lockObject(cs1, g1, rB, null, C_LockFactory.WAIT_FOREVER);
0: 			lf.lockObject(cs1, g1, rA, null, 5000);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:df4020d
/////////////////////////////////////////////////////////////////////////
1: 	@see org.apache.derbyTesting.unitTests.harness.UnitTest
commit:c38b841
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2bc809f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.services.T_LockFactory
1: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.services;
1: 
1: import org.apache.derbyTesting.unitTests.harness.T_MultiIterations;
1: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1: 
1: import org.apache.derby.iapi.services.locks.*;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: /**
1: 	Protocol unit test for the LockManager.
1: 
1: 	@see LockFactory
0: 	@see org.apache.derbyTesting.unitTests.harness..UnitTest
1: */
1: 
1: public class T_LockFactory extends T_MultiIterations
1: {
1: 	protected final static int ITERATIONS = 100;	// iterations of multi-user tests
1: 
1: 	protected LockFactory	lf;
1: 
1: 	public T_LockFactory() {
1: 		super();
1: 	}
1: 
1: 	/*
1: 	** The tests
1: 	*/
1: 
1: 	protected String getModuleToTestProtocolName() {
1: 
1: 		return org.apache.derby.iapi.reference.Module.LockFactory;
1: 	}
1: 
1: 	/**
1: 		Run all the tests, each test that starts with 'S' is a single user
1: 		test, each test that starts with 'M' is a multi-user test.
1: 
1: 		@exception T_Fail The test failed in some way.
1: 	*/
1: 	protected  void setupTest() throws T_Fail {
1: 
1: 		try {
0: 			lf = (LockFactory) Monitor.startSystemModule(getModuleToTestProtocolName());
1: 		} catch (StandardException mse) {
1: 			throw T_Fail.exceptionFail(mse);
1: 		}
1: 		if (lf == null) {
1: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " module not started.");
1: 		}
1: 	}
1: 
1: 	/**
1: 		Run once per-iteration to run the actual test.
1: 		@exception T_Fail the test failed in some way.
1: 	*/
1: 	protected void runTestSet() throws T_Fail {
1: 
1: 		// Set up the expected error handling
1: 		try {
1: 			
1: 			S001();
1: 			S002();
1: 			S003();
1: 			S004();
1: 			S005();
1: 			S007();
0: 			S008();
1: 
1: 			M001();
1: 			M002();
1: 			M003();
1: 			M004();
1: 			
1: 
1: 		} catch (StandardException se) {
1: 
1: 			throw T_Fail.exceptionFail(se);
1: 
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Test functions
1: 	*/
1: 
1: 	/**
1: 		Single user API test 001.
1: 
1: 		Lock an single object in a single group with all lock methods and
1: 		then unlock the object with all unlock methods.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
1: 	void S001() throws StandardException, T_Fail {
1: 
0: 		Object cs = new Object();	// create an object for the compatability space
1: 		Object g0 = new Object();	// create an object for a lock group
1: 		Lockable l0 = new T_L1();		// simple lockable
1: 
1: 		int count;
1: 		
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		// lock and unlock specifically (no timeout)
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockCount(cs, 1);
1: 		count = lf.unlock(cs, g0, l0, null);
1: 		if (count != 1)
1: 			throw T_Fail.testFailMsg("invalid unlock count, expected 1, got " + count);
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		// lock twice and unlock all ...
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockCount(cs, 2);
1: 		lf.unlock(cs, g0, l0, null);
1: 		lf.unlock(cs, g0, l0, null);
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		// lock three times and unlock by group
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockCount(cs, 3);
1: 		lf.unlockGroup(cs, g0);
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 
1: 		// lock three times and unlock explicitly
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockCount(cs, 3);
1: 
1: 		lf.unlock(cs, g0, l0, null);
1: 		checkLockCount(cs, 2);
1: 
1: 		lf.unlock(cs, g0, l0, null);
1: 		checkLockCount(cs, 1);
1: 
1: 		lf.unlock(cs, g0, l0, null);
1: 		checkLockCount(cs, 0);
1: 
1: 		// lock and unlock specifically with timeout
1: 		lf.lockObject(cs, g0, l0, null, 1000 /*ms*/);
1: 		checkLockCount(cs, 1);
1: 		count = lf.unlock(cs, g0, l0, null);
1: 		if (count != 1)
1: 			throw T_Fail.testFailMsg("invalid unlock count, expected 1, got " + count);
1: 
1: 		PASS("S001");
1: 	}
1: 
1: 	/**
1: 		Single user API test 002.
1: 
1: 		Lock an object in different groups and check unlocks
1: 		apply to a single group.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
1: 
1: 	void S002() throws StandardException, T_Fail {
1: 
0: 		Object cs = new Object();	// create an object for the compatability space
1: 		Object g0 = new Object();	// create an object for a lock group
1: 		Object g1 = new Object();
1: 		Lockable l0 = new T_L1();		// simple lockable
1: 
1: 		int count;
1: 		
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		// lock object in two groups and unlock specifically
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g1, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockGroupCount(cs, g0, 1);
1: 		checkLockGroupCount(cs, g1, 1);
1: 		checkLockCount(cs, 2);
1: 
1: 		count = lf.unlock(cs, g0, l0, null);
1: 		if (count != 1)
1: 			throw T_Fail.testFailMsg("invalid unlock count, expected 1, got " + count);
1: 		checkLockGroupCount(cs, g0, 0);
1: 		checkLockGroupCount(cs, g1, 1);
1: 		checkLockCount(cs, 1);
1: 
1: 		count = lf.unlock(cs, g1, l0, null);
1: 		if (count != 1)
1: 			throw T_Fail.testFailMsg("invalid unlock count, expected 1, got " + count);
1: 		checkLockGroupCount(cs, g0, 0);
1: 		checkLockGroupCount(cs, g1, 0);
1: 
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		// lock object in two groups and unlock by group
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g1, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockCount(cs, 2);
1: 
1: 		lf.unlockGroup(cs, g1);
1: 		checkLockGroupCount(cs, g0, 1);
1: 		checkLockGroupCount(cs, g1, 0);
1: 		checkLockCount(cs, 1);
1: 
1: 		lf.unlockGroup(cs, g0);
1: 		checkLockGroupCount(cs, g0, 0);
1: 		checkLockGroupCount(cs, g1, 0);
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		PASS("S002");
1: 	}
1: 
1: 	/**
1: 		Single user API test 003.
1: 
1: 		Lock multiple objects in different groups and check unlocks
1: 		apply to a single group.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 
1: 	*/
1: 
1: 	void S003() throws StandardException, T_Fail {
1: 
0: 		Object cs = new Object();	// create an object for the compatability space
1: 		Object g0 = new Object();	// create an object for a lock group
1: 		Object g1 = new Object();
1: 		Lockable l0 = new T_L1();		// simple lockable
1: 		Lockable l1 = new T_L1();
1: 		Lockable l2 = new T_L1();
1: 
1: 		int count;
1: 		
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		// lock l0 object in two groups and l1,l2 in group l1
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g1, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g1, l1, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g1, l2, null, C_LockFactory.WAIT_FOREVER);
1: 
1: 		checkLockGroupCount(cs, g0, 1);
1: 		checkLockGroupCount(cs, g1, 3);
1: 		checkLockCount(cs, 4);
1: 
1: 		// quick check to see that no one is blocked
1: 		if (lf.anyoneBlocked())
1: 			throw T_Fail.testFailMsg("anyoneBlocked() returned true on a set of private locks");
1: 
1: 		lf.unlock(cs, g1, l1, null);
1: 		checkLockGroupCount(cs, g0, 1);
1: 		checkLockGroupCount(cs, g1, 2);
1: 		checkLockCount(cs, 3);
1: 
1: 		lf.unlockGroup(cs, g1);
1: 		checkLockGroupCount(cs, g0, 1);
1: 		checkLockGroupCount(cs, g1, 0);
1: 		checkLockCount(cs, 1);
1: 
1: 		lf.unlockGroup(cs, g0);
1: 		checkLockGroupCount(cs, g0, 0);
1: 		checkLockGroupCount(cs, g1, 0);
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		PASS("S003");
1: 	}
1: 
1: 	/**
1: 		Single user API test 004.
1: 
1: 		Lock multiple objects in different groups and transfer
1: 		locks between groups.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
1: 
1: 	void S004() throws StandardException, T_Fail {
1: 
0: 		Object cs = new Object();	// create an object for the compatability space
1: 		Object g0 = new Object();	// create an object for a lock group
1: 		Object g1 = new Object();
1: 		Object g2 = new Object();
1: 		Lockable l0 = new T_L1();		// simple lockable
1: 		Lockable l1 = new T_L1();
1: 		Lockable l2 = new T_L1();
1: 
1: 		int count = 0;
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		// lock l0 object in two groups and l1,l2 in group l1
1: 		lf.lockObject(cs, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g1, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g1, l1, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs, g1, l2, null, C_LockFactory.WAIT_FOREVER);
1: 
1: 		checkLockGroupCount(cs, g0, 1);
1: 		checkLockGroupCount(cs, g1, 3);
1: 		checkLockCount(cs, 4);
1: 
1: 		lf.transfer(cs, g0, g1);
1: 		checkLockGroupCount(cs, g0, 0);
1: 		checkLockGroupCount(cs, g1, 4);
1: 		checkLockCount(cs, 4);
1: 
1: 		// transfer an empty to a non-existent one
1: 		lf.transfer(cs, g0, g2);
1: 		checkLockGroupCount(cs, g0, 0);
1: 		checkLockGroupCount(cs, g1, 4);
1: 		checkLockGroupCount(cs, g2, 0);
1: 		checkLockCount(cs, 4);
1: 		
1: 		lf.lockObject(cs, g2, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockGroupCount(cs, g2, 1);
1: 		checkLockCount(cs, 5);
1: 
1: 		lf.transfer(cs, g1, g2);
1: 		checkLockGroupCount(cs, g1, 0);
1: 		checkLockGroupCount(cs, g2, 5);
1: 		checkLockCount(cs, 5);
1: 
1: 		lf.transfer(cs, g2, g1);
1: 		checkLockGroupCount(cs, g1, 5);
1: 		checkLockGroupCount(cs, g2, 0);
1: 		checkLockCount(cs, 5);
1: 
1: 
1: 		lf.unlockGroup(cs, g2);
1: 		checkLockGroupCount(cs, g1, 5);
1: 		checkLockGroupCount(cs, g2, 0);
1: 		checkLockCount(cs, 5);
1: 
1: 		lf.unlockGroup(cs, g1);
1: 		checkLockGroupCount(cs, g1, 0);
1: 		checkLockGroupCount(cs, g2, 0);
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 
1: 		PASS("S004");
1: 	}
1: 
1: 	/**
1: 		Single user API test 005.
1: 
1: 		Create two compatability spaces and ensure that locks
1: 		block each other out.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
1: 	void S005() throws StandardException, T_Fail {
1: 
0: 		Object cs0 = new Object();	// create an object for the compatability space
0: 		Object cs1 = new Object();	// create an object for the compatability space
1: 
1: 		Object g0 = new Object();	// create an object for a lock group
1: 		Object g1 = new Object();	// create an object for a lock group
1: 		Lockable l0 = new T_L1();
1: 		Lockable l1 = new T_L1();
1: 		Lockable l2 = new T_L1();
1: 
1: 		int count;
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs0, 0);
1: 		checkLockCount(cs1, 0);
1: 
1: 		lf.lockObject(cs0, g0, l0, null, C_LockFactory.WAIT_FOREVER);
1: 		lf.lockObject(cs1, g1, l1, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockCount(cs0, 1);
1: 		checkLockCount(cs1, 1);
1: 
1: 		lf.lockObject(cs0, g0, l2, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockCount(cs0, 2);
1: 		checkLockCount(cs1, 1);
1: 
1: 		// now attempt to lock l2 in cs1 with a timeout, should fail
1: 		try {
1: 			lf.lockObject(cs1, g1, l2, null, 200 /* ms */);
1: 			throw T_Fail.testFailMsg("lock succeeded on already locked object");
1: 		}
1: 		catch (StandardException lfe) {
1: 			// we are expecting the timout exception, anything else is an error
1: 			if (!lfe.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
1: 				throw lfe;
1: 			}
1: 			checkLockCount(cs0, 2);
1: 			checkLockCount(cs1, 1);
1: 
1: 		}
1: 
1: 		// now unlock the object, and re-attempt the lock
1: 		lf.unlock(cs0, g0, l2, null);
1: 		checkLockCount(cs0, 1);
1: 		checkLockCount(cs1, 1);
1: 		lf.lockObject(cs1, g1, l2, null, C_LockFactory.WAIT_FOREVER);
1: 		checkLockCount(cs0, 1);
1: 		checkLockCount(cs1, 2);
1: 
1: 		lf.unlockGroup(cs0, g0);
1: 		lf.unlockGroup(cs1, g1);
1: 		checkLockCount(cs0, 0);
1: 		checkLockCount(cs1, 0);
1: 
1: 		PASS("S005");
1: 
1: 
1: 
1: 	}	
1: 
1: 
1: 	/**
1: 		Single user API test 007.
1: 
1: 		Tests on groups and compatibility spaces
1: 		never seen by the lock manager.
1: 		
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
1: 	void S007() throws StandardException, T_Fail {
1: 
0: 		Object cs = new Object();	// create an object for the compatability space
1: 		Object g0 = new Object();	// create an object for a lock group
1: 		Object g1 = new Object();	// create an object for a lock group
1: 		Lockable l0 = new T_L1();
1: 
1: 		int count;
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 		checkLockGroupCount(cs, g0, 0);
1: 
1: 		lf.unlockGroup(cs, g0);
1: 		lf.unlockGroup(cs, cs);
1: 		lf.unlock(cs, g0, l0, null);
1: 
1: 		lf.transfer(cs, g0, g1);
1: 		lf.transfer(cs, g1, g0);
1: 
1: 		if (lf.anyoneBlocked())
1: 			throw T_Fail.testFailMsg("anyoneBlocked() returned true on an empty space");
1: 
1: 		// check we have no locks held
1: 		checkLockCount(cs, 0);
1: 		checkLockGroupCount(cs, g0, 0);
1: 		checkLockGroupCount(cs, g1, 0);
1: 
1: 		PASS("S007");
1: 	}
1: 
1: 	/**
0: 		Single user API test 008.
1: 
0: 		Create two compatability spaces and ensure that locks/latches
1: 		block each other out.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
0: 	void S008() throws StandardException, T_Fail {
1: 
0: 		Object cs0 = new Object();	// create an object for the compatability space
0: 		Object cs1 = new Object();	// create an object for the compatability space
1: 
0: 		Object g0 = new Object();
1: 		Object g1 = new Object();
1: 
0: 		T_L1 page = new T_L1();
0: 		Lockable rA = new T_L1();
0: 		Lockable rB = new T_L1();
1: 
1: 		int count;
1: 
0: 		// Simulate a page/row lock type access
0: 		lf.latchObject(cs0, page, null, C_LockFactory.WAIT_FOREVER);
0: 		lf.lockObject(g0, rA, null, C_LockFactory.WAIT_FOREVER, page.latch);		// would release the latch if it had to wait
0: 		lf.unlatch(page.latch);
1: 
0: 		lf.latchObject(cs1, page, null, C_LockFactory.WAIT_FOREVER);
0: 		lf.lockObject(g1, rB, null, C_LockFactory.WAIT_FOREVER, page.latch);		// would release the latch if it had to wait
1: 
1: 		checkLockCount(cs0, 1);
1: 		checkLockCount(cs1, 2);
1: 
0: 		// this wait should release the latch, while waiting
0:         // on lock, but then re-get the latch after the timeout.
1: 		try {
0: 			lf.lockObject(g1, rA, null, 5000, page.latch);
1: 			throw T_Fail.testFailMsg("lock succeeded on already locked object");
1: 		}
1: 		catch (StandardException lfe) {
0: 			// we are expecting the timoeut exception, anything else is an error
1: 			if (!lfe.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
1: 				throw lfe;
1: 			}
1: 			checkLockCount(cs0, 1);
1: 			checkLockCount(cs1, 1);
1: 		}
1: 
1:         try {
0:             // make sure latch is held
0:             lf.latchObject(cs0, page, null, 5000);
0: 			throw T_Fail.testFailMsg("latch succeeded on already latch object");
1:         }
1: 		catch (StandardException lfe) {
0: 			// we are expecting timoeut exception, anything else is an error
1: 			if (!lfe.getMessageId().equals(SQLState.LOCK_TIMEOUT)) {
1: 				throw lfe;
1: 			}
1: 		}
1: 
0: 		lf.unlatch(page.latch);
1: 
0: 		lf.unlock(cs0,  g0, rA, null);
0: 		lf.unlock(cs1,  g0, rB, null);
1: 
0: 		PASS("S008");
1: 
1: 
1: 	}	
1: 
1: 
1: 
1: 	/*
1: 	** Multi-user tests.
1: 	*/
1: 
1: 	/**
1: 		Multi-user test 001.
1: 
1: 		Create two lockable objects and pass them off to two threads.
1: 		Each thread will run lock the first object, set its value then lock
0: 		the second object & set its value, yield and then release the lock
1: 		on one and then on two. Various checks are made to ensure the
1: 		values are as expected.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
1: 
1: 	void M001() throws StandardException, T_Fail {
1: 
1: 		Lockable[] locks = new T_L1[2];
1: 		locks[0] = new T_L1();
1: 		locks[1] = new T_L1();
1: 
1: 		T_User u1 = new T_User(1, lf, locks, ITERATIONS, 10 * ITERATIONS);
1: 		T_User u2 = new T_User(1, lf, locks, ITERATIONS, 20 * ITERATIONS);
1: 		Thread t1 = new Thread(u1);
1: 		Thread t2 = new Thread(u2);
1: 
1: 		t1.start();
1: 		t2.start();
1: 
1: 		try {
1: 			t1.join();
1: 			t2.join();
1: 		} catch (InterruptedException ie) {
1: 			throw T_Fail.exceptionFail(ie);
1: 		}
1: 
1: 		if (u1.error != null)
1: 			throw T_Fail.exceptionFail(u1.error);
1: 		if (u2.error != null)
1: 			throw T_Fail.exceptionFail(u2.error);
1: 
1: 		PASS("M001");
1: 	}
1: 	
1: 
1: 	/**
1: 		Multi-user test 002
1: 
1: 		Create a single lockable and have three threads lock it, yield and
1: 		then release it. The single lockable can only have one locker.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
1: 
1: 		
1: 	void M002() throws StandardException, T_Fail {
1: 
1: 		Lockable[] locks = new T_L1[1];
1: 		locks[0] = new T_L1();
1: 
1: 		T_User u1 = new T_User(2, lf, locks, ITERATIONS, 10 * ITERATIONS);
1: 		T_User u2 = new T_User(2, lf, locks, ITERATIONS, 20 * ITERATIONS);
1: 		T_User u3 = new T_User(2, lf, locks, ITERATIONS, 30 * ITERATIONS);
1: 		Thread t1 = new Thread(u1);
1: 		Thread t2 = new Thread(u2);
1: 		Thread t3 = new Thread(u3);
1: 
1: 		t1.start();
1: 		t2.start();
1: 		t3.start();
1: 
1: 		try {
1: 			t1.join();
1: 			t2.join();
1: 			t3.join();
1: 		} catch (InterruptedException ie) {
1: 			throw T_Fail.exceptionFail(ie);
1: 		}
1: 
1: 		if (u1.error != null)
1: 			throw T_Fail.exceptionFail(u1.error);
1: 		if (u2.error != null)
1: 			throw T_Fail.exceptionFail(u2.error);
1: 		if (u3.error != null)
1: 			throw T_Fail.exceptionFail(u3.error);
1: 
1: 
1: 		PASS("M002");
1: 	}
1: 	/**
1: 		Multi-user test 003
1: 
1: 		Create a single lockable and have three threads lock it, yield and
1: 		then release it. The single lockable is a semaphore that can have two lockers.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
1: 
1: 		
1: 	void M003() throws StandardException, T_Fail {
1: 
1: 		Lockable[] locks = new Lockable[1];
1: 		locks[0] = new T_L2(2);
1: 
1: 		T_User u1 = new T_User(3, lf, locks, ITERATIONS, 0);
1: 		T_User u2 = new T_User(3, lf, locks, ITERATIONS, 0);
1: 		T_User u3 = new T_User(3, lf, locks, ITERATIONS, 0);
1: 		Thread t1 = new Thread(u1);
1: 		Thread t2 = new Thread(u2);
1: 		Thread t3 = new Thread(u3);
1: 
1: 		t1.start();
1: 		t2.start();
1: 		t3.start();
1: 
1: 		try {
1: 			t1.join();
1: 			t2.join();
1: 			t3.join();
1: 		} catch (InterruptedException ie) {
1: 			throw T_Fail.exceptionFail(ie);
1: 		}
1: 
1: 		if (u1.error != null)
1: 			throw T_Fail.exceptionFail(u1.error);
1: 		if (u2.error != null)
1: 			throw T_Fail.exceptionFail(u2.error);
1: 		if (u3.error != null)
1: 			throw T_Fail.exceptionFail(u3.error);
1: 
1: 
1: 		PASS("M003");
1: 	}
1: 	/**
1: 		Multi-user test 004
1: 
1: 		As M003 but each thread will lock the object twice, to ensure that
1: 		lock manager grantes the lock when the compatability space and qualifier
1: 		match.
1: 
1: 		@exception StandardException	An exception thrown by a method of LockFactory
1: 		@exception T_Fail	Some behaviour of the LockFactory is incorrect
1: 	*/
1: 
1: 		
1: 	void M004() throws StandardException, T_Fail {
1: 
1: 		Lockable[] locks = new Lockable[1];
1: 		locks[0] = new T_L2(2);
1: 
1: 		T_User u1 = new T_User(4, lf, locks, ITERATIONS, 0);
1: 		T_User u2 = new T_User(4, lf, locks, ITERATIONS, 0);
1: 		T_User u3 = new T_User(4, lf, locks, ITERATIONS, 0);
1: 		Thread t1 = new Thread(u1);
1: 		Thread t2 = new Thread(u2);
1: 		Thread t3 = new Thread(u3);
1: 
1: 		t1.start();
1: 		t2.start();
1: 		t3.start();
1: 
1: 		try {
1: 			t1.join();
1: 			t2.join();
1: 			t3.join();
1: 		} catch (InterruptedException ie) {
1: 			throw  T_Fail.exceptionFail(ie);
1: 		}
1: 
1: 		if (u1.error != null)
1: 			throw  T_Fail.exceptionFail(u1.error);
1: 		if (u2.error != null)
1: 			throw T_Fail.exceptionFail(u2.error);
1: 		if (u3.error != null)
1: 			throw T_Fail.exceptionFail(u3.error);
1: 
1: 
1: 		PASS("M004");
1: 	}
1: 
1: 
1: 
1: 	/*
1: 	** Utility functions
1: 	*/
1: 
1: 	/**
1: 		Check to see if the total number of locks we have is as expected.
1: 
1: 		@exception T_Fail	Number of locks is not as expected.
1: 	*/
0: 	void checkLockCount(Object cs, int expected) throws T_Fail {
1: 		boolean expect = expected != 0;
1: 		boolean got = lf.areLocksHeld(cs);
1: 		if (got != expect)
1: 			throw T_Fail.testFailMsg("Expected lock count (" + expect + "), got (" + got + ")");
1: 	}
1: 
1: 	/**
1: 		Check to see if the number of locks in a group we have is as expected.
1: 
1: 		@exception T_Fail	Number of locks is not as expected.
1: 	*/
1: 
0: 	void checkLockGroupCount(Object cs, Object group, int expected) throws T_Fail {
1: 		boolean expect = expected != 0;
1: 		boolean got = lf.areLocksHeld(cs, group);
1: 		if (got != expect)
1: 			throw T_Fail.testFailMsg("Expected lock count (" + expect + "), got (" + got + ")");
1: 	}
1: 
1: }
1: 
1: 
============================================================================