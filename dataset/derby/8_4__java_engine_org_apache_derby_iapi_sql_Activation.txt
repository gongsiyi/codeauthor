1:fe77ca5: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.Activation
1:7ecc1f2: 
1:4590cd8:    Licensed to the Apache Software Foundation (ASF) under one or more
1:4590cd8:    contributor license agreements.  See the NOTICE file distributed with
1:4590cd8:    this work for additional information regarding copyright ownership.
1:4590cd8:    The ASF licenses this file to you under the Apache License, Version 2.0
1:4590cd8:    (the "License"); you may not use this file except in compliance with
1:4590cd8:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
10:fe77ca5: 
4:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: package org.apache.derby.iapi.sql;
1:fe77ca5: 
1:801cf0d: import java.sql.SQLWarning;
1:801cf0d: import java.util.Enumeration;
1:801cf0d: import java.util.Vector;
1:fe77ca5: import org.apache.derby.iapi.error.StandardException;
1:fe77ca5: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:6950a39: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
1:e4caed2: import org.apache.derby.iapi.sql.depend.Dependent;
1:fe77ca5: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:801cf0d: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:801cf0d: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1:fe77ca5: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:fe77ca5: import org.apache.derby.iapi.sql.execute.ExecRow;
1:fe77ca5: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1:fe77ca5: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
1:fe77ca5: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1:fe77ca5: import org.apache.derby.iapi.store.access.ConglomerateController;
1:fe77ca5: import org.apache.derby.iapi.store.access.ScanController;
1:fe77ca5: import org.apache.derby.iapi.store.access.TransactionController;
1:fe77ca5: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:801cf0d: import org.apache.derby.iapi.types.DataValueFactory;
1:a180287: import org.apache.derby.iapi.types.NumberDataValue;
1:801cf0d: import org.apache.derby.iapi.types.RowLocation;
1:fe77ca5: 
1:fe77ca5: 
4:fe77ca5: /**
1:fe77ca5:  * An activation contains all the local state information necessary
1:fe77ca5:  * to execute a re-entrant PreparedStatement. The way it will actually work
1:fe77ca5:  * is that a PreparedStatement will have an executable plan, which will be
1:fe77ca5:  * a generated class. All of the local state will be variables in the class.
1:fe77ca5:  * Creating a new instance of the executable plan will create the local state
1:fe77ca5:  * variables. This means that an executable plan must implement this interface,
1:fe77ca5:  * and that the PreparedStatement.getActivation() method will do a
1:fe77ca5:  * "new" operation on the executable plan.
1:fe77ca5:  * <p>
1:fe77ca5:  * The fixed implementations of Activation in the Execution impl
1:fe77ca5:  * package are used as skeletons for the classes generated for statements
1:fe77ca5:  * when they are compiled.
1:fe77ca5:  * <p>
1:fe77ca5:  * There are no fixed implementations of Activation for statements;
1:fe77ca5:  * a statement has an activation generated for it when it is compiled.
19:fe77ca5:  *
1:fe77ca5:  */
1:fe77ca5: 
1:e4caed2: public interface Activation extends Dependent
1:fe77ca5: {
1:fe77ca5: 	/**
1:fe77ca5: 	 * Resets the activation to the "pre-execution" state -
1:fe77ca5: 	 * that is, the state where it can be used to begin a new execution.
1:fe77ca5: 	 * Frees local buffers, stops scans, resets counters to zero, sets
1:fe77ca5: 	 * current date and time to an unitialized state, etc.
1:99d7d8b: 	 *
1:fe77ca5: 	 * @exception StandardException thrown on failure
1:fe77ca5: 	 */
1:fe77ca5: 	void	reset() throws StandardException;
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * JDBC requires that all select statements be converted into cursors,
1:fe77ca5: 	 * and that the cursor name be settable for each execution of a select
1:fe77ca5: 	 * statement. The Language Module will support this, so that the JDBC
1:fe77ca5: 	 * driver will not have to parse JSQL text. This method will have no
1:fe77ca5: 	 * effect when called on non-select statements.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * There will be a JSQL statement to disable the "cursorization" of
1:fe77ca5: 	 * all select statements. For non-cursorized select statements, this
1:fe77ca5: 	 * method will have no effect.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * This has no effect if the activation has been closed.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * @param cursorName  The cursor name to use.
1:fe77ca5: 	 */
1:fe77ca5: 	void	setCursorName(String cursorName);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the table has a held curosr open at
1:fe77ca5: 	 * commit time, data should not be deleted from the table. This method, (gets called at commit time) checks if this
1:fe77ca5: 	 * activation held cursor and if so, does that cursor reference the passed temp table name.
1:99d7d8b: 	 *
1:fe77ca5: 	 * @return	true if this activation has held cursor and if it references the passed temp table name
1:fe77ca5: 	 */
1:fe77ca5: 	public boolean checkIfThisActivationHasHoldCursor(String tableName);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Gets the ParameterValueSet for this execution of the statement.
1:99d7d8b: 	 *
1:fe77ca5: 	 * @return	The ParameterValueSet for this execution of the
1:fe77ca5: 	 *		statement. Returns NULL if there are no parameters.
1:fe77ca5: 	 */
1:fe77ca5: 	ParameterValueSet	getParameterValueSet();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Sets the parameter values for this execution of the statement.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * Has no effect if the activation has been closed.
1:fe77ca5: 	 *
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * NOTE: The setParameters() method is currently unimplemented. 
1:fe77ca5: 	 * A statement with parameters will generate its own ParameterValueSet,
1:fe77ca5: 	 * which can be gotten with the getParameterValueSet() method (above).
1:fe77ca5: 	 * The idea behind setParameters() is to improve performance when
1:fe77ca5: 	 * operating across a network by allowing all the parameters to be set
1:fe77ca5: 	 * in one call, as opposed to one call per parameter.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param parameterValues	The values of the parameters.
1:fe77ca5: 	 */
1:fe77ca5: 	void	setParameters(ParameterValueSet parameterValues, DataTypeDescriptor[] parameterTypes) throws StandardException;
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * When the prepared statement is executed, it passes
1:fe77ca5: 	 * execution on to the activation execution was requested for.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return the ResultSet for further manipulation, if any.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on failure
1:fe77ca5: 	 */
1:fe77ca5: 	ResultSet execute() throws StandardException;
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Closing an activation statement marks it as unusable. Any other
1:fe77ca5: 		requests made on it will fail.  An activation should be
1:fe77ca5: 		marked closed when it is expected to not be used any longer,
1:fe77ca5: 		i.e. when the connection for it is closed, or it has suffered some
1:fe77ca5: 		sort of severe error. This will also close its result set and
1:fe77ca5: 		release any resources it holds e.g. for parameters.
1:fe77ca5: 		<P>
1:fe77ca5: 		Any class that implements this must be prepared to be executed
1:fe77ca5: 		from garbage collection, ie. there is no matching context stack.
1:fe77ca5: 
1:fe77ca5: 		@exception StandardException		Thrown on failure
1:fe77ca5: 	 */
1:fe77ca5: 	void close() throws StandardException;
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Find out if the activation is closed or not.
1:fe77ca5: 
1:fe77ca5: 		@return true if the Activation has been closed.
1:fe77ca5: 	 */
1:fe77ca5: 	boolean isClosed();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Set this Activation for a single execution.
1:fe77ca5: 		E.g. a java.sql.Statement execution.
1:fe77ca5: 	*/
1:fe77ca5: 	void setSingleExecution();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Returns true if this Activation is only going to be used for
1:fe77ca5: 		one execution.
1:fe77ca5: 	*/
1:fe77ca5: 	boolean isSingleExecution();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	  Returns the chained list of warnings. Returns null
1:fe77ca5: 	  if there are no warnings.
1:fe77ca5: 	  */
1:fe77ca5: 	SQLWarning getWarnings();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	  Add a warning to the activation
1:fe77ca5: 	  */
1:fe77ca5: 	void addWarning(SQLWarning w);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	  Clear the activation's warnings.
1:fe77ca5: 	  */
1:fe77ca5: 	void clearWarnings();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the language connection context associated with this activation
1:fe77ca5:      */
1:fe77ca5: 	public	LanguageConnectionContext	getLanguageConnectionContext();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the Execution TransactionController associated with this 
1:fe77ca5: 	 * activation/lcc.
1:fe77ca5: 	 */
1:fe77ca5: 	TransactionController getTransactionController();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Returns the current result set for this activation, i.e.
1:fe77ca5: 	 * the one returned by the last execute() call.  If there has
1:fe77ca5: 	 * been no execute call or the activation has been reset or closed,
1:fe77ca5: 	 * a null is returned.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return the current ResultSet of this activation.
1:fe77ca5: 	 */
1:fe77ca5: 	ResultSet getResultSet();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Generated plans have a current row field for ease in defining
1:fe77ca5: 	 * the methods and finding them dynamically. The interface is
1:fe77ca5: 	 * used to set the row before a dynamic method that uses it is
1:fe77ca5: 	 * invoked.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * When all processing on the currentRow has been completed,
1:fe77ca5: 	 * callers should call activation.clearCurrentRow(resultSetNumber)
1:fe77ca5: 	 * to ensure that no unnecessary references are retained to rows.
1:fe77ca5: 	 * This will allow the rows no longer in use to be collected by
1:fe77ca5: 	 * the garbage collecter.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param currentRow		The row to be operated upon.
1:fe77ca5: 	 * @param resultSetNumber	The resultSetNumber for the current ResultSet
1:fe77ca5: 	 */
1:fe77ca5: 	void setCurrentRow(ExecRow currentRow, int resultSetNumber);
1:fe77ca5: 
1:fe77ca5: 	/**
1:c533cd2: 	 * Get the current row at the given index.
1:c533cd2: 	 */
1:c533cd2: 	public Row getCurrentRow(int resultSetNumber);
1:c533cd2:     
1:c533cd2: 	/**
1:fe77ca5: 	 * Generated plans have a current row field for ease in defining
1:fe77ca5: 	 * the methods and finding them dynamically. The interface is
1:fe77ca5: 	 * used to set the row before a dynamic method that uses it is
1:fe77ca5: 	 * invoked.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * When all processing on the currentRow has been completed,
1:fe77ca5: 	 * callers should call activation.clearCurrentRow(resultSetNumber)
1:fe77ca5: 	 * to ensure that no unnecessary references are retained to rows.
1:fe77ca5: 	 * This will allow the rows no longer in use to be collected by
1:fe77ca5: 	 * the garbage collecter.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param resultSetNumber	The resultSetNumber for the current ResultSet
1:fe77ca5: 	 */
1:fe77ca5: 	/* RESOLVE - this method belongs on an internal, not external, interface */
1:fe77ca5: 	void clearCurrentRow(int resultSetNumber);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the prepared statement that this activation is for.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return the prepared statement this activation is for.
1:fe77ca5: 	 *
1:fe77ca5: 	 */
1:fe77ca5: 	ExecPreparedStatement getPreparedStatement();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Check the validity of the current executing statement. Needs to be
1:fe77ca5: 		called after a statement has obtained the relevant table locks on
1:fe77ca5: 		the 
1:fe77ca5: 	*/
1:fe77ca5: 	public void checkStatementValidity() throws StandardException;
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the result description for this activation, if it has one.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return result description for this activation, if it has one;
1:fe77ca5: 	 * otherwise, null.
1:fe77ca5: 	 */
1:fe77ca5: 	ResultDescription getResultDescription();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the DataValueFactory
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return DataValueFactory
1:fe77ca5: 	 */
1:fe77ca5: 	DataValueFactory getDataValueFactory();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the ExecutionFactory
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return ExecutionFactory
1:fe77ca5: 	 */
1:fe77ca5: 	ExecutionFactory getExecutionFactory();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Get the saved RowLocation.
1:fe77ca5: 
1:fe77ca5: 		@param itemNumber	The saved item number.
1:fe77ca5: 
1:fe77ca5: 		@return	A RowLocation template for the conglomerate
1:fe77ca5: 	 */
1:9495437: 	public RowLocation getRowLocationTemplate(int itemNumber);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Get the number of subqueries in the entire query.
1:fe77ca5: 		@return int	 The number of subqueries in the entire query.
1:fe77ca5: 	 */
1:fe77ca5: 	public int getNumSubqueries();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Return the cursor name of this activation. This will differ
1:fe77ca5: 	 * from its ResultSet's cursor name if it has been
1:fe77ca5: 	 * altered with setCursorName. Thus this always returns the cursor
1:fe77ca5: 	 * name of the next execution of this activation. The cursor name
1:fe77ca5: 	 * of the current execution must be obtained from the ResultSet.
1:fe77ca5: 	 * or this.getResultSet.getCursorName() [with null checking].
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * Statements that do not support cursors will return a null.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * @return The cursor name.
1:fe77ca5: 	 */
1:fe77ca5: 	public String	getCursorName();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Return the holdability of this activation.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * @return The holdability of this activation.
1:fe77ca5: 	 */
1:fe77ca5: 	public boolean	getResultSetHoldability();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set current resultset holdability.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param resultSetHoldability	The new resultset holdability.
1:fe77ca5: 	 */
1:fe77ca5: 	public void setResultSetHoldability(boolean resultSetHoldability);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set the auto-generated keys resultset mode to true for this activation.
1:fe77ca5: 	 *
1:fe77ca5: 	 * The specific columns for auto-generated keys resultset can be requested by
1:fe77ca5: 	 * passing column positions array
1:fe77ca5: 	 *
1:fe77ca5: 	 * The specific columns for auto-generated keys resultset can be requested by
1:fe77ca5: 	 * passing column names array
1:fe77ca5: 	 *
1:fe77ca5: 	 * Both the parameters would be null if user didn't request specific keys.
1:fe77ca5: 	 * Otherwise, the user could request specific columns by passing column positions
1:fe77ca5: 	 * or names array but not both.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param columnIndexes Request specific columns in auto-generated keys
1:fe77ca5: 	 * resultset by passing column positions. null means no specific columns
1:fe77ca5: 	 * requested by position
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param columnNames Request specific columns in auto-generated keys
1:fe77ca5: 	 * resultset by passing column names.  null means no specific columns
1:fe77ca5: 	 * requested by position
1:fe77ca5: 	 */
1:fe77ca5: 	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes, String[] columnNames);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Returns true if auto-generated keys resultset request was made for this
1:fe77ca5: 	 * avtivation.
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * @return auto-generated keys resultset mode for this activation.
1:fe77ca5: 	 */
1:fe77ca5: 	public boolean	getAutoGeneratedKeysResultsetMode();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Returns the column positions array of columns requested in auto-generated
1:fe77ca5: 	 * keys resultset for this avtivation. Returns null if no specific column
1:fe77ca5: 	 * requested by positions
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * @return column positions array of columns requested.
1:fe77ca5: 	 */
1:fe77ca5: 	public int[] getAutoGeneratedKeysColumnIndexes();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Returns the column names array of columns requested in auto-generated
1:fe77ca5: 	 * keys resultset for this avtivation. Returns null if no specific column
1:fe77ca5: 	 * requested by names
1:fe77ca5: 	 * <p>
1:fe77ca5: 	 * @return column names array of columns requested.
1:fe77ca5: 	 */
1:fe77ca5: 	public String[] getAutoGeneratedKeysColumnNames();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Mark the activation as unused.  
1:fe77ca5: 	 */
1:fe77ca5: 	public void markUnused();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Is the activation in use?
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return true/false
1:fe77ca5: 	 */
1:fe77ca5: 	public boolean isInUse();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Tell this activation that the given ResultSet was found to have
1:fe77ca5: 	 * the given number of rows.  This is used during execution to determine
1:fe77ca5: 	 * whether a table has grown or shrunk.  If a table's size changes
1:fe77ca5: 	 * significantly, the activation may invalidate its PreparedStatement
1:fe77ca5: 	 * to force recompilation.
1:fe77ca5: 	 *
1:fe77ca5: 	 * Note that the association of row counts with ResultSets is kept
1:fe77ca5: 	 * in the activation class, not in the activation itself.  This
1:fe77ca5: 	 * means that this method must be synchronized.
1:fe77ca5: 	 *
1:fe77ca5: 	 * This method is not required to check the number of rows on each
1:fe77ca5: 	 * call.  Because of synchronization, this check is likely to be
1:fe77ca5: 	 * expensive, so it may only check every hundred calls or so.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 	public void informOfRowCount(NoPutResultSet resultSet, long rowCount)
1:fe77ca5: 					throws StandardException;
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the ConglomerateController, if any, that has already
1:fe77ca5: 	 * been opened for the heap when scaning for an update or delete.
1:fe77ca5: 	 * (Saves opening the ConglomerateController twice.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return The ConglomerateController, if available, to use for the update.
1:fe77ca5: 	 */
1:fe77ca5: 	public ConglomerateController getHeapConglomerateController();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set the ConglomerateController to be used for an update or delete.
1:fe77ca5: 	 * (Saves opening the ConglomerateController twice.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param updateHeapCC	The ConglomerateController to reuse for the update or delete.
1:fe77ca5: 	 */
1:fe77ca5: 	public void setHeapConglomerateController(ConglomerateController updateHeapCC);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Clear the ConglomerateController to be used for an update or delete.
1:fe77ca5: 	 * (Saves opening the ConglomerateController twice.)
1:fe77ca5: 	 */
1:fe77ca5: 	public void clearHeapConglomerateController();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the ScanController, if any, that has already
1:fe77ca5: 	 * been opened for the index when scaning for an update or delete.
1:fe77ca5: 	 * (Saves opening the ScanController twice.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return The ScanController, if available, to use for the update.
1:fe77ca5: 	 */
1:fe77ca5: 	public ScanController getIndexScanController();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set the ScanController to be used for an update or delete,
1:fe77ca5: 	 * when scanning an index that will also be updated
1:fe77ca5: 	 * (Saves opening the ScanController twice.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param indexSC	The ScanController to reuse for the update or delete.
1:fe77ca5: 	 */
1:fe77ca5: 	public void setIndexScanController(ScanController indexSC);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the conglomerate number of the index, if any, that has already
1:fe77ca5: 	 * been opened for scaning for an update or delete.
1:fe77ca5: 	 * (Saves opening the ScanController twice.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return The conglomerate number, if available, to use for the update.
1:fe77ca5: 	 */
1:fe77ca5: 	public long getIndexConglomerateNumber();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set the conglomerate number of the index to be used for an update or delete,
1:fe77ca5: 	 * when scanning an index that will also be updated
1:fe77ca5: 	 * (Saves opening the ScanController twice.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param indexConglomerateNumber The conglomerate number of the index to reuse for the update or delete.
1:fe77ca5: 	 */
1:fe77ca5: 	public void setIndexConglomerateNumber(long indexConglomerateNumber);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Clear the info for the index to be re-used for update/delete.
1:fe77ca5: 	 * (ScanController and conglomerate number.)
1:fe77ca5: 	 */
1:fe77ca5: 	public void clearIndexScanInfo();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Mark the Activation as being for create table.
1:fe77ca5: 	 * (NOTE: We can do certain optimizations for
1:fe77ca5: 	 * create table that we can't do for other DDL.)
1:fe77ca5: 	 */
1:fe77ca5: 	public void setForCreateTable();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get whether or not this activation is for
1:fe77ca5: 	 * create table.
1:fe77ca5: 	 * (NOTE: We can do certain optimizations for
1:fe77ca5: 	 * create table that we can't do for other DDL.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return Whether or not this activation is for
1:fe77ca5: 	 *		   create table.
1:fe77ca5: 	 */
1:fe77ca5: 	public boolean getForCreateTable();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Save the TableDescriptor for the target of 
1:fe77ca5: 	 * DDL so that it can be passed between the
1:fe77ca5: 	 * various ConstantActions during execution.
1:fe77ca5: 	 */
1:fe77ca5: 	public void setDDLTableDescriptor(TableDescriptor td);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the TableDescriptor for the target of
1:fe77ca5: 	 * DDL.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return The TableDescriptor for the target of
1:fe77ca5: 	 * DDL.
1:fe77ca5: 	 */
1:fe77ca5: 	public TableDescriptor getDDLTableDescriptor();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Set the maximum # of rows.  (# of rows that can
1:fe77ca5: 	 * be returned by a ResultSet.  0 means no limit.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @param maxRows Maximum # of rows. (0 means no limit.)
1:fe77ca5: 	 */
1:47a8183: 	public void setMaxRows(long maxRows);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the maximum # of rows.  (# of rows that can
1:fe77ca5: 	 * be returned by a ResultSet.  0 means no limit.)
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return Maximum # of rows.  (0 means no limit.)
1:fe77ca5: 	 */
1:47a8183: 	public long getMaxRows();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Is this Activation for a cursor?
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return Whether or not this Activation is for a cursor.
1:fe77ca5: 	 */
1:fe77ca5: 	public boolean isCursorActivation();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Save the ResultSet for the target
1:fe77ca5: 	 * of an update/delete to a VTI.
1:fe77ca5: 	 */
1:fe77ca5: 	public void setTargetVTI(java.sql.ResultSet targetVTI);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Get the ResultSet for the target
1:fe77ca5: 	 * of an update/delete to a VTI.
1:fe77ca5: 	 *
1:fe77ca5: 	 * @return The ResultSet for the target
1:fe77ca5: 	 * of an update/delete to a VTI.
1:fe77ca5: 	 */
1:fe77ca5: 	public java.sql.ResultSet getTargetVTI();
1:fe77ca5: 
1:508a010:     /**
1:508a010:      * Push a ConstantAction to be returned by getConstantAction().
1:508a010:      * Returns the newConstantAction.
1:508a010:      */
1:508a010:     public  ConstantAction    pushConstantAction( ConstantAction newConstantAction );
1:508a010: 
1:508a010:     /**
1:508a010:      * Pop the ConstantAction stack, returning the element which was just popped
1:508a010:      * off the stack.
1:508a010:      */
1:508a010:     public  ConstantAction    popConstantAction();
1:508a010: 
1:508a010:     /** Get the top ConstantAction on the stack without changing the stack. */
1:fe77ca5: 	public ConstantAction	getConstantAction();
1:fe77ca5: 
1:fe77ca5: 	//store a reference to the parent table result sets
1:fe77ca5: 	public void setParentResultSet(TemporaryRowHolder rs, String resultSetId);
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * get the reference to parent table ResultSets, that will be needed by the 
1:fe77ca5: 	 * referential action dependent table scans.
1:fe77ca5: 	 */
1:801cf0d:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:801cf0d:     public Vector<TemporaryRowHolder> getParentResultSet(String resultSetId);
1:fe77ca5: 	
1:fe77ca5: 	//clear the parent resultset hash table;
1:fe77ca5: 	public void clearParentResultSets();
1:fe77ca5: 
1:801cf0d:     public Enumeration<String> getParentResultSetKeys();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * beetle 3865: updateable cursor using index.  A way of communication
1:fe77ca5: 	 * between cursor activation and update activation.
1:fe77ca5: 	 */
1:fe77ca5: 	public void setForUpdateIndexScan(CursorResultSet forUpdateResultSet);
1:fe77ca5: 
1:fe77ca5: 	public CursorResultSet getForUpdateIndexScan();
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 		Return the set of dynamical created result sets, for procedures.
1:fe77ca5: 		Base implementation returns null, a generated class for a procedure overwrites
1:fe77ca5: 		this with a real implementation.
1:fe77ca5: 		@return null if no dynamic results exists. Otherwise an array of ResultSet
1:fe77ca5: 		arrays, each of length one containing null or a reference to a ResultSet.
1:99d7d8b: 	*/
1:fe77ca5: 	public java.sql.ResultSet[][] getDynamicResults();
1:fe77ca5: 
1:99d7d8b: 	/**
1:fe77ca5: 		Return the maximum number of dynamical created result sets from the procedure definition.
1:fe77ca5: 		Base implementation returns 0, a generated class for a procedure overwrites
1:fe77ca5: 		this with a real implementation.
1:fe77ca5: 	*/
1:fe77ca5: 	public int getMaxDynamicResults();
1:99d7d8b: 
1:99d7d8b: 
1:99d7d8b: 	/**
1:e3883f5: 	 * Get the current SQL session context if in a nested connection of a
1:e3883f5: 	 * stored routine or in a substatement.
1:99d7d8b: 	 */
1:e3883f5: 	public SQLSessionContext getSQLSessionContextForChildren();
1:99d7d8b: 
1:99d7d8b: 	/**
1:e3883f5: 	 * Set up and return the current SQL session context for all immediately
1:e3883f5: 	 * nested connections stemming from the call or function invocation of the
1:e3883f5: 	 * statement corresponding to this activation (push=true) or for a
1:e3883f5: 	 * substatement, which shares the parents statement's session context
1:e3883f5: 	 * (push=false).
1:e3883f5: 	 * @param push true if used to push a new connection context
1:99d7d8b: 	 */
1:e3883f5: 	public SQLSessionContext setupSQLSessionContextForChildren(boolean push);
1:99d7d8b: 
1:99d7d8b: 	/**
1:e3883f5: 	 * This activation is created in a dynamic call context or a substatement
1:e3883f5: 	 * execution context, chain its parent statements activation..
1:e3883f5: 	 */
1:e3883f5: 	public void setParentActivation(Activation a);
1:e3883f5: 
1:e3883f5: 	/**
1:e3883f5: 	 * This activation is created in a dynamic call context, or substatement
1:e3883f5: 	 * execution context; get its caller's or superstatement's activation.
1:99d7d8b: 	 *
1:99d7d8b: 	 * @return The caller's activation
1:99d7d8b: 	 */
1:e3883f5: 	public Activation getParentActivation();
1:99d7d8b: 
1:a180287: 	/**
1:a180287: 	 * Called by generated code to get the next number in an ANSI/ISO sequence
1:a180287:      * and advance the sequence. Raises an exception if the sequence was declared
1:a180287:      * NO CYCLE and its range is exhausted.
1:a180287: 	 *
1:a180287:      * @param sequenceUUIDstring The string value of the sequence's UUID
1:a180287:      * @param typeFormatID The format id of the data type to be returned. E.g., StoredFormatIds.SQL_INTEGER_ID.
1:a180287:      *
1:a180287: 	 * @return The next number in the sequence
1:a180287: 	 */
1:a180287: 	public NumberDataValue getCurrentValueAndAdvance
1:a180287:         ( String sequenceUUIDstring, int typeFormatID )
1:a180287:         throws StandardException;
1:fe77ca5: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a180287
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.types.NumberDataValue;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Called by generated code to get the next number in an ANSI/ISO sequence
1:      * and advance the sequence. Raises an exception if the sequence was declared
1:      * NO CYCLE and its range is exhausted.
1: 	 *
1:      * @param sequenceUUIDstring The string value of the sequence's UUID
1:      * @param typeFormatID The format id of the data type to be returned. E.g., StoredFormatIds.SQL_INTEGER_ID.
1:      *
1: 	 * @return The next number in the sequence
1: 	 */
1: 	public NumberDataValue getCurrentValueAndAdvance
1:         ( String sequenceUUIDstring, int typeFormatID )
1:         throws StandardException;
commit:508a010
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Push a ConstantAction to be returned by getConstantAction().
1:      * Returns the newConstantAction.
1:      */
1:     public  ConstantAction    pushConstantAction( ConstantAction newConstantAction );
1: 
1:     /**
1:      * Pop the ConstantAction stack, returning the element which was just popped
1:      * off the stack.
1:      */
1:     public  ConstantAction    popConstantAction();
1: 
1:     /** Get the top ConstantAction on the stack without changing the stack. */
commit:706f2eb
/////////////////////////////////////////////////////////////////////////
0: 	public Enumeration getParentResultSetKeys();
commit:47a8183
/////////////////////////////////////////////////////////////////////////
1: 	public void setMaxRows(long maxRows);
/////////////////////////////////////////////////////////////////////////
1: 	public long getMaxRows();
commit:9495437
/////////////////////////////////////////////////////////////////////////
1: 	public RowLocation getRowLocationTemplate(int itemNumber);
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0: 	public RowLocation getRowLocationTemplate(int itemNumber) throws StandardException;
commit:c533cd2
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the current row at the given index.
1: 	 */
1: 	public Row getCurrentRow(int resultSetNumber);
1:     
1: 	/**
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:801cf0d
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
1: import java.util.Enumeration;
1: import java.util.Vector;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.types.DataValueFactory;
1: import org.apache.derby.iapi.types.RowLocation;
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("UseOfObsoleteCollectionType")
1:     public Vector<TemporaryRowHolder> getParentResultSet(String resultSetId);
1:     public Enumeration<String> getParentResultSetKeys();
commit:e3883f5
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the current SQL session context if in a nested connection of a
1: 	 * stored routine or in a substatement.
1: 	public SQLSessionContext getSQLSessionContextForChildren();
1: 	 * Set up and return the current SQL session context for all immediately
1: 	 * nested connections stemming from the call or function invocation of the
1: 	 * statement corresponding to this activation (push=true) or for a
1: 	 * substatement, which shares the parents statement's session context
1: 	 * (push=false).
1: 	 * @param push true if used to push a new connection context
1: 	public SQLSessionContext setupSQLSessionContextForChildren(boolean push);
1: 	 * This activation is created in a dynamic call context or a substatement
1: 	 * execution context, chain its parent statements activation..
1: 	 */
1: 	public void setParentActivation(Activation a);
1: 
1: 	/**
1: 	 * This activation is created in a dynamic call context, or substatement
1: 	 * execution context; get its caller's or superstatement's activation.
1: 	public Activation getParentActivation();
commit:e4caed2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.depend.Dependent;
/////////////////////////////////////////////////////////////////////////
1: public interface Activation extends Dependent
commit:6950a39
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.conn.SQLSessionContext;
/////////////////////////////////////////////////////////////////////////
0: 	 * Return the current SQL session context for all immediately
0: 	 * nested connections stemming from the call or function
0: 	 * invocation of the statement corresponding to this activation.
0: 	public SQLSessionContext getNestedSQLSessionContext();
commit:f04dc44
/////////////////////////////////////////////////////////////////////////
0: 	 * @param role The name of the current role
/////////////////////////////////////////////////////////////////////////
0: 	 * @param a The caller's activation
commit:99d7d8b
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * Set the current role name of the dynamic call context stemming
0: 	 * from this activation (which must be a stored
0: 	 * procedure/function) call.
1: 	 *
0: 	 * @arg role The name of the current role
1: 	 */
0: 	public void setNestedCurrentRole(String role);
1: 
1: 	/**
0: 	 * Get the current role name of the dynamic call context stemming
0: 	 * from this activation (which must be a stored
0: 	 * procedure/function) call.
1: 	 *
0: 	 * @return The name of the current role
1: 	 */
0:     public String getNestedCurrentRole();
1: 
1: 	/**
0: 	 * This activation is created in a dynamic call context, remember
0: 	 * its caller's activation.
1: 	 *
0: 	 * @arg a The caller's activation
1: 	 */
0: 	public void setCallActivation(Activation a);
1: 
1: 	/**
0: 	 * This activation is created in a dynamic call context, get its
0: 	 * caller's activation.
1: 	 *
1: 	 * @return The caller's activation
1: 	 */
0: 	public Activation getCallActivation();
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:fbf1381
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:4590cd8
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.Activation
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: 
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
1: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
1: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1: 
0: import java.sql.SQLWarning;
0: import java.util.Enumeration;
0: import java.util.Vector;
0: import java.util.Hashtable;
1: 
1: 
1: /**
1:  * An activation contains all the local state information necessary
1:  * to execute a re-entrant PreparedStatement. The way it will actually work
1:  * is that a PreparedStatement will have an executable plan, which will be
1:  * a generated class. All of the local state will be variables in the class.
1:  * Creating a new instance of the executable plan will create the local state
1:  * variables. This means that an executable plan must implement this interface,
1:  * and that the PreparedStatement.getActivation() method will do a
1:  * "new" operation on the executable plan.
1:  * <p>
1:  * The fixed implementations of Activation in the Execution impl
1:  * package are used as skeletons for the classes generated for statements
1:  * when they are compiled.
1:  * <p>
1:  * There are no fixed implementations of Activation for statements;
1:  * a statement has an activation generated for it when it is compiled.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
0: public interface Activation
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 	 * Resets the activation to the "pre-execution" state -
1: 	 * that is, the state where it can be used to begin a new execution.
1: 	 * Frees local buffers, stops scans, resets counters to zero, sets
1: 	 * current date and time to an unitialized state, etc.
1: 	 *
0: 	 * @return	Nothing
1: 	 * @exception StandardException thrown on failure
1: 	 */
1: 	void	reset() throws StandardException;
1: 
1: 	/**
1: 	 * JDBC requires that all select statements be converted into cursors,
1: 	 * and that the cursor name be settable for each execution of a select
1: 	 * statement. The Language Module will support this, so that the JDBC
1: 	 * driver will not have to parse JSQL text. This method will have no
1: 	 * effect when called on non-select statements.
1: 	 * <p>
1: 	 * There will be a JSQL statement to disable the "cursorization" of
1: 	 * all select statements. For non-cursorized select statements, this
1: 	 * method will have no effect.
1: 	 * <p>
1: 	 * This has no effect if the activation has been closed.
1: 	 * <p>
1: 	 * @param cursorName  The cursor name to use.
1: 	 */
1: 	void	setCursorName(String cursorName);
1: 
1: 	/**
1: 	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the table has a held curosr open at
1: 	 * commit time, data should not be deleted from the table. This method, (gets called at commit time) checks if this
1: 	 * activation held cursor and if so, does that cursor reference the passed temp table name.
1: 	 *
1: 	 * @return	true if this activation has held cursor and if it references the passed temp table name
1: 	 */
1: 	public boolean checkIfThisActivationHasHoldCursor(String tableName);
1: 
1: 	/**
1: 	 * Gets the ParameterValueSet for this execution of the statement.
1: 	 *
1: 	 * @return	The ParameterValueSet for this execution of the
1: 	 *		statement. Returns NULL if there are no parameters.
1: 	 */
1: 	ParameterValueSet	getParameterValueSet();
1: 
1: 	/**
1: 	 * Sets the parameter values for this execution of the statement.
1: 	 * <p>
1: 	 * Has no effect if the activation has been closed.
1: 	 *
1: 	 * <p>
1: 	 * NOTE: The setParameters() method is currently unimplemented. 
1: 	 * A statement with parameters will generate its own ParameterValueSet,
1: 	 * which can be gotten with the getParameterValueSet() method (above).
1: 	 * The idea behind setParameters() is to improve performance when
1: 	 * operating across a network by allowing all the parameters to be set
1: 	 * in one call, as opposed to one call per parameter.
1: 	 *
1: 	 * @param parameterValues	The values of the parameters.
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 	void	setParameters(ParameterValueSet parameterValues, DataTypeDescriptor[] parameterTypes) throws StandardException;
1: 
1: 	/**
1: 	 * When the prepared statement is executed, it passes
1: 	 * execution on to the activation execution was requested for.
1: 	 *
1: 	 * @return the ResultSet for further manipulation, if any.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
1: 	ResultSet execute() throws StandardException;
1: 
1: 	/**
1: 		Closing an activation statement marks it as unusable. Any other
1: 		requests made on it will fail.  An activation should be
1: 		marked closed when it is expected to not be used any longer,
1: 		i.e. when the connection for it is closed, or it has suffered some
1: 		sort of severe error. This will also close its result set and
1: 		release any resources it holds e.g. for parameters.
1: 		<P>
1: 		Any class that implements this must be prepared to be executed
1: 		from garbage collection, ie. there is no matching context stack.
1: 
1: 		@exception StandardException		Thrown on failure
1: 	 */
1: 	void close() throws StandardException;
1: 
1: 	/**
1: 		Find out if the activation is closed or not.
1: 
1: 		@return true if the Activation has been closed.
1: 	 */
1: 	boolean isClosed();
1: 
1: 	/**
1: 		Set this Activation for a single execution.
1: 		E.g. a java.sql.Statement execution.
1: 	*/
1: 	void setSingleExecution();
1: 
1: 	/**
1: 		Returns true if this Activation is only going to be used for
1: 		one execution.
1: 	*/
1: 	boolean isSingleExecution();
1: 
1: 	/**
1: 	  Returns the chained list of warnings. Returns null
1: 	  if there are no warnings.
1: 	  */
1: 	SQLWarning getWarnings();
1: 
1: 	/**
1: 	  Add a warning to the activation
1: 	  */
1: 	void addWarning(SQLWarning w);
1: 
1: 	/**
1: 	  Clear the activation's warnings.
1: 	  */
1: 	void clearWarnings();
1: 
1: 	/**
1: 	 * Get the language connection context associated with this activation
1:      */
1: 	public	LanguageConnectionContext	getLanguageConnectionContext();
1: 
1: 	/**
1: 	 * Get the Execution TransactionController associated with this 
1: 	 * activation/lcc.
1: 	 */
1: 	TransactionController getTransactionController();
1: 
1: 	/**
1: 	 * Returns the current result set for this activation, i.e.
1: 	 * the one returned by the last execute() call.  If there has
1: 	 * been no execute call or the activation has been reset or closed,
1: 	 * a null is returned.
1: 	 *
1: 	 * @return the current ResultSet of this activation.
1: 	 */
1: 	ResultSet getResultSet();
1: 
1: 	/**
0: 	 * Sets the ResultSet to be returned by getResultSet() to null.
1: 	 */
0: 	void clearResultSet();
1: 
1: 	/**
1: 	 * Generated plans have a current row field for ease in defining
1: 	 * the methods and finding them dynamically. The interface is
1: 	 * used to set the row before a dynamic method that uses it is
1: 	 * invoked.
1: 	 * <p>
1: 	 * When all processing on the currentRow has been completed,
1: 	 * callers should call activation.clearCurrentRow(resultSetNumber)
1: 	 * to ensure that no unnecessary references are retained to rows.
1: 	 * This will allow the rows no longer in use to be collected by
1: 	 * the garbage collecter.
1: 	 *
1: 	 * @param currentRow		The row to be operated upon.
1: 	 * @param resultSetNumber	The resultSetNumber for the current ResultSet
1: 	 *
0: 	 * @return Nothing
1: 	 *
1: 	 */
1: 	void setCurrentRow(ExecRow currentRow, int resultSetNumber);
1: 
1: 	/**
1: 	 * Generated plans have a current row field for ease in defining
1: 	 * the methods and finding them dynamically. The interface is
1: 	 * used to set the row before a dynamic method that uses it is
1: 	 * invoked.
1: 	 * <p>
1: 	 * When all processing on the currentRow has been completed,
1: 	 * callers should call activation.clearCurrentRow(resultSetNumber)
1: 	 * to ensure that no unnecessary references are retained to rows.
1: 	 * This will allow the rows no longer in use to be collected by
1: 	 * the garbage collecter.
1: 	 *
1: 	 * @param resultSetNumber	The resultSetNumber for the current ResultSet
1: 	 *
0: 	 * @return Nothing
1: 	 */
1: 	/* RESOLVE - this method belongs on an internal, not external, interface */
1: 	void clearCurrentRow(int resultSetNumber);
1: 
1: 	/**
1: 	 * Get the prepared statement that this activation is for.
1: 	 *
1: 	 * @return the prepared statement this activation is for.
1: 	 *
1: 	 */
1: 	ExecPreparedStatement getPreparedStatement();
1: 
1: 	/**
1: 		Check the validity of the current executing statement. Needs to be
1: 		called after a statement has obtained the relevant table locks on
1: 		the 
1: 	*/
1: 	public void checkStatementValidity() throws StandardException;
1: 
1: 	/**
1: 	 * Get the result description for this activation, if it has one.
1: 	 *
1: 	 * @return result description for this activation, if it has one;
1: 	 * otherwise, null.
1: 	 */
1: 	ResultDescription getResultDescription();
1: 
1: 	/**
1: 	 * Get the DataValueFactory
1: 	 *
1: 	 * @return DataValueFactory
1: 	 */
1: 	DataValueFactory getDataValueFactory();
1: 
1: 	/**
1: 	 * Get the ExecutionFactory
1: 	 *
1: 	 * @return ExecutionFactory
1: 	 */
1: 	ExecutionFactory getExecutionFactory();
1: 
1: 	/**
1: 		Get the saved RowLocation.
1: 
1: 		@param itemNumber	The saved item number.
1: 
1: 		@return	A RowLocation template for the conglomerate
1: 	 */
0: 	public RowLocation getRowLocationTemplate(int itemNumber);
1: 
1: 	/**
1: 		Get the number of subqueries in the entire query.
1: 		@return int	 The number of subqueries in the entire query.
1: 	 */
1: 	public int getNumSubqueries();
1: 
1: 	/**
1: 	 * Return the cursor name of this activation. This will differ
1: 	 * from its ResultSet's cursor name if it has been
1: 	 * altered with setCursorName. Thus this always returns the cursor
1: 	 * name of the next execution of this activation. The cursor name
1: 	 * of the current execution must be obtained from the ResultSet.
1: 	 * or this.getResultSet.getCursorName() [with null checking].
1: 	 * <p>
1: 	 * Statements that do not support cursors will return a null.
1: 	 * <p>
1: 	 * @return The cursor name.
1: 	 */
1: 	public String	getCursorName();
1: 
1: 	/**
1: 	 * Return the holdability of this activation.
1: 	 * <p>
1: 	 * @return The holdability of this activation.
1: 	 */
1: 	public boolean	getResultSetHoldability();
1: 
1: 	/**
1: 	 * Set current resultset holdability.
1: 	 *
1: 	 * @param resultSetHoldability	The new resultset holdability.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setResultSetHoldability(boolean resultSetHoldability);
1: 
1: 	/**
1: 	 * Set the auto-generated keys resultset mode to true for this activation.
1: 	 *
1: 	 * The specific columns for auto-generated keys resultset can be requested by
1: 	 * passing column positions array
1: 	 *
1: 	 * The specific columns for auto-generated keys resultset can be requested by
1: 	 * passing column names array
1: 	 *
1: 	 * Both the parameters would be null if user didn't request specific keys.
1: 	 * Otherwise, the user could request specific columns by passing column positions
1: 	 * or names array but not both.
1: 	 *
1: 	 * @param columnIndexes Request specific columns in auto-generated keys
1: 	 * resultset by passing column positions. null means no specific columns
1: 	 * requested by position
1: 	 *
1: 	 * @param columnNames Request specific columns in auto-generated keys
1: 	 * resultset by passing column names.  null means no specific columns
1: 	 * requested by position
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes, String[] columnNames);
1: 
1: 	/**
1: 	 * Returns true if auto-generated keys resultset request was made for this
1: 	 * avtivation.
1: 	 * <p>
1: 	 * @return auto-generated keys resultset mode for this activation.
1: 	 */
1: 	public boolean	getAutoGeneratedKeysResultsetMode();
1: 
1: 	/**
1: 	 * Returns the column positions array of columns requested in auto-generated
1: 	 * keys resultset for this avtivation. Returns null if no specific column
1: 	 * requested by positions
1: 	 * <p>
1: 	 * @return column positions array of columns requested.
1: 	 */
1: 	public int[] getAutoGeneratedKeysColumnIndexes();
1: 
1: 	/**
1: 	 * Returns the column names array of columns requested in auto-generated
1: 	 * keys resultset for this avtivation. Returns null if no specific column
1: 	 * requested by names
1: 	 * <p>
1: 	 * @return column names array of columns requested.
1: 	 */
1: 	public String[] getAutoGeneratedKeysColumnNames();
1: 
1: 	/**
1: 	 * Mark the activation as unused.  
1: 	 */
1: 	public void markUnused();
1: 
1: 	/**
1: 	 * Is the activation in use?
1: 	 *
1: 	 * @return true/false
1: 	 */
1: 	public boolean isInUse();
1: 
1: 	/**
1: 	 * Tell this activation that the given ResultSet was found to have
1: 	 * the given number of rows.  This is used during execution to determine
1: 	 * whether a table has grown or shrunk.  If a table's size changes
1: 	 * significantly, the activation may invalidate its PreparedStatement
1: 	 * to force recompilation.
1: 	 *
1: 	 * Note that the association of row counts with ResultSets is kept
1: 	 * in the activation class, not in the activation itself.  This
1: 	 * means that this method must be synchronized.
1: 	 *
1: 	 * This method is not required to check the number of rows on each
1: 	 * call.  Because of synchronization, this check is likely to be
1: 	 * expensive, so it may only check every hundred calls or so.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void informOfRowCount(NoPutResultSet resultSet, long rowCount)
1: 					throws StandardException;
1: 
1: 	/**
1: 	 * Get the ConglomerateController, if any, that has already
1: 	 * been opened for the heap when scaning for an update or delete.
1: 	 * (Saves opening the ConglomerateController twice.)
1: 	 *
1: 	 * @return The ConglomerateController, if available, to use for the update.
1: 	 */
1: 	public ConglomerateController getHeapConglomerateController();
1: 
1: 	/**
1: 	 * Set the ConglomerateController to be used for an update or delete.
1: 	 * (Saves opening the ConglomerateController twice.)
1: 	 *
1: 	 * @param updateHeapCC	The ConglomerateController to reuse for the update or delete.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setHeapConglomerateController(ConglomerateController updateHeapCC);
1: 
1: 	/**
1: 	 * Clear the ConglomerateController to be used for an update or delete.
1: 	 * (Saves opening the ConglomerateController twice.)
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void clearHeapConglomerateController();
1: 
1: 	/**
1: 	 * Get the ScanController, if any, that has already
1: 	 * been opened for the index when scaning for an update or delete.
1: 	 * (Saves opening the ScanController twice.)
1: 	 *
1: 	 * @return The ScanController, if available, to use for the update.
1: 	 */
1: 	public ScanController getIndexScanController();
1: 
1: 	/**
1: 	 * Set the ScanController to be used for an update or delete,
1: 	 * when scanning an index that will also be updated
1: 	 * (Saves opening the ScanController twice.)
1: 	 *
1: 	 * @param indexSC	The ScanController to reuse for the update or delete.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setIndexScanController(ScanController indexSC);
1: 
1: 	/**
1: 	 * Get the conglomerate number of the index, if any, that has already
1: 	 * been opened for scaning for an update or delete.
1: 	 * (Saves opening the ScanController twice.)
1: 	 *
1: 	 * @return The conglomerate number, if available, to use for the update.
1: 	 */
1: 	public long getIndexConglomerateNumber();
1: 
1: 	/**
1: 	 * Set the conglomerate number of the index to be used for an update or delete,
1: 	 * when scanning an index that will also be updated
1: 	 * (Saves opening the ScanController twice.)
1: 	 *
1: 	 * @param indexConglomerateNumber The conglomerate number of the index to reuse for the update or delete.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setIndexConglomerateNumber(long indexConglomerateNumber);
1: 
1: 	/**
1: 	 * Clear the info for the index to be re-used for update/delete.
1: 	 * (ScanController and conglomerate number.)
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void clearIndexScanInfo();
1: 
1: 	/**
1: 	 * Mark the Activation as being for create table.
1: 	 * (NOTE: We can do certain optimizations for
1: 	 * create table that we can't do for other DDL.)
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setForCreateTable();
1: 
1: 	/**
1: 	 * Get whether or not this activation is for
1: 	 * create table.
1: 	 * (NOTE: We can do certain optimizations for
1: 	 * create table that we can't do for other DDL.)
1: 	 *
1: 	 * @return Whether or not this activation is for
1: 	 *		   create table.
1: 	 */
1: 	public boolean getForCreateTable();
1: 
1: 	/**
1: 	 * Save the TableDescriptor for the target of 
1: 	 * DDL so that it can be passed between the
1: 	 * various ConstantActions during execution.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setDDLTableDescriptor(TableDescriptor td);
1: 
1: 	/**
1: 	 * Get the TableDescriptor for the target of
1: 	 * DDL.
1: 	 *
1: 	 * @return The TableDescriptor for the target of
1: 	 * DDL.
1: 	 */
1: 	public TableDescriptor getDDLTableDescriptor();
1: 
1: 	/**
1: 	 * Set the maximum # of rows.  (# of rows that can
1: 	 * be returned by a ResultSet.  0 means no limit.)
1: 	 *
1: 	 * @param maxRows Maximum # of rows. (0 means no limit.)
1: 	 *
0: 	 * @return Nothing.
1: 	 */
0: 	public void setMaxRows(int maxRows);
1: 
1: 	/**
1: 	 * Get the maximum # of rows.  (# of rows that can
1: 	 * be returned by a ResultSet.  0 means no limit.)
1: 	 *
1: 	 * @return Maximum # of rows.  (0 means no limit.)
1: 	 */
0: 	public int getMaxRows();
1: 
1: 	/**
1: 	 * Is this Activation for a cursor?
1: 	 *
1: 	 * @return Whether or not this Activation is for a cursor.
1: 	 */
1: 	public boolean isCursorActivation();
1: 
1: 	/**
1: 	 * Save the ResultSet for the target
1: 	 * of an update/delete to a VTI.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	public void setTargetVTI(java.sql.ResultSet targetVTI);
1: 
1: 	/**
1: 	 * Get the ResultSet for the target
1: 	 * of an update/delete to a VTI.
1: 	 *
1: 	 * @return The ResultSet for the target
1: 	 * of an update/delete to a VTI.
1: 	 */
1: 	public java.sql.ResultSet getTargetVTI();
1: 
1: 	public ConstantAction	getConstantAction();
1: 
1: 	//store a reference to the parent table result sets
1: 	public void setParentResultSet(TemporaryRowHolder rs, String resultSetId);
1: 
1: 	/**
1: 	 * get the reference to parent table ResultSets, that will be needed by the 
1: 	 * referential action dependent table scans.
1: 	 */
0: 	public Vector getParentResultSet(String resultSetId);
1: 	
1: 	//clear the parent resultset hash table;
1: 	public void clearParentResultSets();
1: 
0: 	public Hashtable getParentResultSets();
1: 
1: 	/**
1: 	 * beetle 3865: updateable cursor using index.  A way of communication
1: 	 * between cursor activation and update activation.
1: 	 */
1: 	public void setForUpdateIndexScan(CursorResultSet forUpdateResultSet);
1: 
1: 	public CursorResultSet getForUpdateIndexScan();
1: 
1: 	/**
1: 		Return the set of dynamical created result sets, for procedures.
1: 		Base implementation returns null, a generated class for a procedure overwrites
1: 		this with a real implementation.
1: 		@return null if no dynamic results exists. Otherwise an array of ResultSet
1: 		arrays, each of length one containing null or a reference to a ResultSet.
1: 	*/
1: 	public java.sql.ResultSet[][] getDynamicResults();
1: 
1: 	/**
1: 		Return the maximum number of dynamical created result sets from the procedure definition.
1: 		Base implementation returns 0, a generated class for a procedure overwrites
1: 		this with a real implementation.
1: 	*/
1: 	public int getMaxDynamicResults();
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.NoPutResultSet;
0: import org.apache.derby.iapi.sql.execute.ConstantAction;
0: import org.apache.derby.iapi.sql.execute.CursorResultSet;
0: import org.apache.derby.iapi.sql.execute.TemporaryRowHolder;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: 
0: import java.sql.SQLWarning;
0: import java.util.Enumeration;
0: import java.util.Vector;
0: import java.util.Hashtable;
0: 
0: 
0: /**
0:  * An activation contains all the local state information necessary
0:  * to execute a re-entrant PreparedStatement. The way it will actually work
0:  * is that a PreparedStatement will have an executable plan, which will be
0:  * a generated class. All of the local state will be variables in the class.
0:  * Creating a new instance of the executable plan will create the local state
0:  * variables. This means that an executable plan must implement this interface,
0:  * and that the PreparedStatement.getActivation() method will do a
0:  * "new" operation on the executable plan.
0:  * <p>
0:  * The fixed implementations of Activation in the Execution impl
0:  * package are used as skeletons for the classes generated for statements
0:  * when they are compiled.
0:  * <p>
0:  * There are no fixed implementations of Activation for statements;
0:  * a statement has an activation generated for it when it is compiled.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: public interface Activation
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 	 * Resets the activation to the "pre-execution" state -
0: 	 * that is, the state where it can be used to begin a new execution.
0: 	 * Frees local buffers, stops scans, resets counters to zero, sets
0: 	 * current date and time to an unitialized state, etc.
0: 	 *
0: 	 * @return	Nothing
0: 	 * @exception StandardException thrown on failure
0: 	 */
0: 	void	reset() throws StandardException;
0: 
0: 	/**
0: 	 * JDBC requires that all select statements be converted into cursors,
0: 	 * and that the cursor name be settable for each execution of a select
0: 	 * statement. The Language Module will support this, so that the JDBC
0: 	 * driver will not have to parse JSQL text. This method will have no
0: 	 * effect when called on non-select statements.
0: 	 * <p>
0: 	 * There will be a JSQL statement to disable the "cursorization" of
0: 	 * all select statements. For non-cursorized select statements, this
0: 	 * method will have no effect.
0: 	 * <p>
0: 	 * This has no effect if the activation has been closed.
0: 	 * <p>
0: 	 * @param cursorName  The cursor name to use.
0: 	 */
0: 	void	setCursorName(String cursorName);
0: 
0: 	/**
0: 	 * Temporary tables can be declared with ON COMMIT DELETE ROWS. But if the table has a held curosr open at
0: 	 * commit time, data should not be deleted from the table. This method, (gets called at commit time) checks if this
0: 	 * activation held cursor and if so, does that cursor reference the passed temp table name.
0: 	 *
0: 	 * @return	true if this activation has held cursor and if it references the passed temp table name
0: 	 */
0: 	public boolean checkIfThisActivationHasHoldCursor(String tableName);
0: 
0: 	/**
0: 	 * Gets the ParameterValueSet for this execution of the statement.
0: 	 *
0: 	 * @return	The ParameterValueSet for this execution of the
0: 	 *		statement. Returns NULL if there are no parameters.
0: 	 */
0: 	ParameterValueSet	getParameterValueSet();
0: 
0: 	/**
0: 	 * Sets the parameter values for this execution of the statement.
0: 	 * <p>
0: 	 * Has no effect if the activation has been closed.
0: 	 *
0: 	 * <p>
0: 	 * NOTE: The setParameters() method is currently unimplemented. 
0: 	 * A statement with parameters will generate its own ParameterValueSet,
0: 	 * which can be gotten with the getParameterValueSet() method (above).
0: 	 * The idea behind setParameters() is to improve performance when
0: 	 * operating across a network by allowing all the parameters to be set
0: 	 * in one call, as opposed to one call per parameter.
0: 	 *
0: 	 * @param parameterValues	The values of the parameters.
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 	void	setParameters(ParameterValueSet parameterValues, DataTypeDescriptor[] parameterTypes) throws StandardException;
0: 
0: 	/**
0: 	 * When the prepared statement is executed, it passes
0: 	 * execution on to the activation execution was requested for.
0: 	 *
0: 	 * @return the ResultSet for further manipulation, if any.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	ResultSet execute() throws StandardException;
0: 
0: 	/**
0: 		Closing an activation statement marks it as unusable. Any other
0: 		requests made on it will fail.  An activation should be
0: 		marked closed when it is expected to not be used any longer,
0: 		i.e. when the connection for it is closed, or it has suffered some
0: 		sort of severe error. This will also close its result set and
0: 		release any resources it holds e.g. for parameters.
0: 		<P>
0: 		Any class that implements this must be prepared to be executed
0: 		from garbage collection, ie. there is no matching context stack.
0: 
0: 		@exception StandardException		Thrown on failure
0: 	 */
0: 	void close() throws StandardException;
0: 
0: 	/**
0: 		Find out if the activation is closed or not.
0: 
0: 		@return true if the Activation has been closed.
0: 	 */
0: 	boolean isClosed();
0: 
0: 	/**
0: 		Set this Activation for a single execution.
0: 		E.g. a java.sql.Statement execution.
0: 	*/
0: 	void setSingleExecution();
0: 
0: 	/**
0: 		Returns true if this Activation is only going to be used for
0: 		one execution.
0: 	*/
0: 	boolean isSingleExecution();
0: 
0: 	/**
0: 	  Returns the chained list of warnings. Returns null
0: 	  if there are no warnings.
0: 	  */
0: 	SQLWarning getWarnings();
0: 
0: 	/**
0: 	  Add a warning to the activation
0: 	  */
0: 	void addWarning(SQLWarning w);
0: 
0: 	/**
0: 	  Clear the activation's warnings.
0: 	  */
0: 	void clearWarnings();
0: 
0: 	/**
0: 	 * Get the language connection context associated with this activation
0:      */
0: 	public	LanguageConnectionContext	getLanguageConnectionContext();
0: 
0: 	/**
0: 	 * Get the Execution TransactionController associated with this 
0: 	 * activation/lcc.
0: 	 */
0: 	TransactionController getTransactionController();
0: 
0: 	/**
0: 	 * Returns the current result set for this activation, i.e.
0: 	 * the one returned by the last execute() call.  If there has
0: 	 * been no execute call or the activation has been reset or closed,
0: 	 * a null is returned.
0: 	 *
0: 	 * @return the current ResultSet of this activation.
0: 	 */
0: 	ResultSet getResultSet();
0: 
0: 	/**
0: 	 * Sets the ResultSet to be returned by getResultSet() to null.
0: 	 */
0: 	void clearResultSet();
0: 
0: 	/**
0: 	 * Generated plans have a current row field for ease in defining
0: 	 * the methods and finding them dynamically. The interface is
0: 	 * used to set the row before a dynamic method that uses it is
0: 	 * invoked.
0: 	 * <p>
0: 	 * When all processing on the currentRow has been completed,
0: 	 * callers should call activation.clearCurrentRow(resultSetNumber)
0: 	 * to ensure that no unnecessary references are retained to rows.
0: 	 * This will allow the rows no longer in use to be collected by
0: 	 * the garbage collecter.
0: 	 *
0: 	 * @param currentRow		The row to be operated upon.
0: 	 * @param resultSetNumber	The resultSetNumber for the current ResultSet
0: 	 *
0: 	 * @return Nothing
0: 	 *
0: 	 */
0: 	void setCurrentRow(ExecRow currentRow, int resultSetNumber);
0: 
0: 	/**
0: 	 * Generated plans have a current row field for ease in defining
0: 	 * the methods and finding them dynamically. The interface is
0: 	 * used to set the row before a dynamic method that uses it is
0: 	 * invoked.
0: 	 * <p>
0: 	 * When all processing on the currentRow has been completed,
0: 	 * callers should call activation.clearCurrentRow(resultSetNumber)
0: 	 * to ensure that no unnecessary references are retained to rows.
0: 	 * This will allow the rows no longer in use to be collected by
0: 	 * the garbage collecter.
0: 	 *
0: 	 * @param resultSetNumber	The resultSetNumber for the current ResultSet
0: 	 *
0: 	 * @return Nothing
0: 	 */
0: 	/* RESOLVE - this method belongs on an internal, not external, interface */
0: 	void clearCurrentRow(int resultSetNumber);
0: 
0: 	/**
0: 	 * Get the prepared statement that this activation is for.
0: 	 *
0: 	 * @return the prepared statement this activation is for.
0: 	 *
0: 	 */
0: 	ExecPreparedStatement getPreparedStatement();
0: 
0: 	/**
0: 		Check the validity of the current executing statement. Needs to be
0: 		called after a statement has obtained the relevant table locks on
0: 		the 
0: 	*/
0: 	public void checkStatementValidity() throws StandardException;
0: 
0: 	/**
0: 	 * Get the result description for this activation, if it has one.
0: 	 *
0: 	 * @return result description for this activation, if it has one;
0: 	 * otherwise, null.
0: 	 */
0: 	ResultDescription getResultDescription();
0: 
0: 	/**
0: 	 * Get the DataValueFactory
0: 	 *
0: 	 * @return DataValueFactory
0: 	 */
0: 	DataValueFactory getDataValueFactory();
0: 
0: 	/**
0: 	 * Get the ExecutionFactory
0: 	 *
0: 	 * @return ExecutionFactory
0: 	 */
0: 	ExecutionFactory getExecutionFactory();
0: 
0: 	/**
0: 		Get the saved RowLocation.
0: 
0: 		@param itemNumber	The saved item number.
0: 
0: 		@return	A RowLocation template for the conglomerate
0: 	 */
0: 	public RowLocation getRowLocationTemplate(int itemNumber);
0: 
0: 	/**
0: 		Get the number of subqueries in the entire query.
0: 		@return int	 The number of subqueries in the entire query.
0: 	 */
0: 	public int getNumSubqueries();
0: 
0: 	/**
0: 	 * Return the cursor name of this activation. This will differ
0: 	 * from its ResultSet's cursor name if it has been
0: 	 * altered with setCursorName. Thus this always returns the cursor
0: 	 * name of the next execution of this activation. The cursor name
0: 	 * of the current execution must be obtained from the ResultSet.
0: 	 * or this.getResultSet.getCursorName() [with null checking].
0: 	 * <p>
0: 	 * Statements that do not support cursors will return a null.
0: 	 * <p>
0: 	 * @return The cursor name.
0: 	 */
0: 	public String	getCursorName();
0: 
0: 	/**
0: 	 * Return the holdability of this activation.
0: 	 * <p>
0: 	 * @return The holdability of this activation.
0: 	 */
0: 	public boolean	getResultSetHoldability();
0: 
0: 	/**
0: 	 * Set current resultset holdability.
0: 	 *
0: 	 * @param resultSetHoldability	The new resultset holdability.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setResultSetHoldability(boolean resultSetHoldability);
0: 
0: 	/**
0: 	 * Set the auto-generated keys resultset mode to true for this activation.
0: 	 *
0: 	 * The specific columns for auto-generated keys resultset can be requested by
0: 	 * passing column positions array
0: 	 *
0: 	 * The specific columns for auto-generated keys resultset can be requested by
0: 	 * passing column names array
0: 	 *
0: 	 * Both the parameters would be null if user didn't request specific keys.
0: 	 * Otherwise, the user could request specific columns by passing column positions
0: 	 * or names array but not both.
0: 	 *
0: 	 * @param columnIndexes Request specific columns in auto-generated keys
0: 	 * resultset by passing column positions. null means no specific columns
0: 	 * requested by position
0: 	 *
0: 	 * @param columnNames Request specific columns in auto-generated keys
0: 	 * resultset by passing column names.  null means no specific columns
0: 	 * requested by position
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setAutoGeneratedKeysResultsetInfo(int[] columnIndexes, String[] columnNames);
0: 
0: 	/**
0: 	 * Returns true if auto-generated keys resultset request was made for this
0: 	 * avtivation.
0: 	 * <p>
0: 	 * @return auto-generated keys resultset mode for this activation.
0: 	 */
0: 	public boolean	getAutoGeneratedKeysResultsetMode();
0: 
0: 	/**
0: 	 * Returns the column positions array of columns requested in auto-generated
0: 	 * keys resultset for this avtivation. Returns null if no specific column
0: 	 * requested by positions
0: 	 * <p>
0: 	 * @return column positions array of columns requested.
0: 	 */
0: 	public int[] getAutoGeneratedKeysColumnIndexes();
0: 
0: 	/**
0: 	 * Returns the column names array of columns requested in auto-generated
0: 	 * keys resultset for this avtivation. Returns null if no specific column
0: 	 * requested by names
0: 	 * <p>
0: 	 * @return column names array of columns requested.
0: 	 */
0: 	public String[] getAutoGeneratedKeysColumnNames();
0: 
0: 	/**
0: 	 * Mark the activation as unused.  
0: 	 */
0: 	public void markUnused();
0: 
0: 	/**
0: 	 * Is the activation in use?
0: 	 *
0: 	 * @return true/false
0: 	 */
0: 	public boolean isInUse();
0: 
0: 	/**
0: 	 * Tell this activation that the given ResultSet was found to have
0: 	 * the given number of rows.  This is used during execution to determine
0: 	 * whether a table has grown or shrunk.  If a table's size changes
0: 	 * significantly, the activation may invalidate its PreparedStatement
0: 	 * to force recompilation.
0: 	 *
0: 	 * Note that the association of row counts with ResultSets is kept
0: 	 * in the activation class, not in the activation itself.  This
0: 	 * means that this method must be synchronized.
0: 	 *
0: 	 * This method is not required to check the number of rows on each
0: 	 * call.  Because of synchronization, this check is likely to be
0: 	 * expensive, so it may only check every hundred calls or so.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void informOfRowCount(NoPutResultSet resultSet, long rowCount)
0: 					throws StandardException;
0: 
0: 	/**
0: 	 * Get the ConglomerateController, if any, that has already
0: 	 * been opened for the heap when scaning for an update or delete.
0: 	 * (Saves opening the ConglomerateController twice.)
0: 	 *
0: 	 * @return The ConglomerateController, if available, to use for the update.
0: 	 */
0: 	public ConglomerateController getHeapConglomerateController();
0: 
0: 	/**
0: 	 * Set the ConglomerateController to be used for an update or delete.
0: 	 * (Saves opening the ConglomerateController twice.)
0: 	 *
0: 	 * @param updateHeapCC	The ConglomerateController to reuse for the update or delete.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setHeapConglomerateController(ConglomerateController updateHeapCC);
0: 
0: 	/**
0: 	 * Clear the ConglomerateController to be used for an update or delete.
0: 	 * (Saves opening the ConglomerateController twice.)
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void clearHeapConglomerateController();
0: 
0: 	/**
0: 	 * Get the ScanController, if any, that has already
0: 	 * been opened for the index when scaning for an update or delete.
0: 	 * (Saves opening the ScanController twice.)
0: 	 *
0: 	 * @return The ScanController, if available, to use for the update.
0: 	 */
0: 	public ScanController getIndexScanController();
0: 
0: 	/**
0: 	 * Set the ScanController to be used for an update or delete,
0: 	 * when scanning an index that will also be updated
0: 	 * (Saves opening the ScanController twice.)
0: 	 *
0: 	 * @param indexSC	The ScanController to reuse for the update or delete.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setIndexScanController(ScanController indexSC);
0: 
0: 	/**
0: 	 * Get the conglomerate number of the index, if any, that has already
0: 	 * been opened for scaning for an update or delete.
0: 	 * (Saves opening the ScanController twice.)
0: 	 *
0: 	 * @return The conglomerate number, if available, to use for the update.
0: 	 */
0: 	public long getIndexConglomerateNumber();
0: 
0: 	/**
0: 	 * Set the conglomerate number of the index to be used for an update or delete,
0: 	 * when scanning an index that will also be updated
0: 	 * (Saves opening the ScanController twice.)
0: 	 *
0: 	 * @param indexConglomerateNumber The conglomerate number of the index to reuse for the update or delete.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setIndexConglomerateNumber(long indexConglomerateNumber);
0: 
0: 	/**
0: 	 * Clear the info for the index to be re-used for update/delete.
0: 	 * (ScanController and conglomerate number.)
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void clearIndexScanInfo();
0: 
0: 	/**
0: 	 * Mark the Activation as being for create table.
0: 	 * (NOTE: We can do certain optimizations for
0: 	 * create table that we can't do for other DDL.)
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setForCreateTable();
0: 
0: 	/**
0: 	 * Get whether or not this activation is for
0: 	 * create table.
0: 	 * (NOTE: We can do certain optimizations for
0: 	 * create table that we can't do for other DDL.)
0: 	 *
0: 	 * @return Whether or not this activation is for
0: 	 *		   create table.
0: 	 */
0: 	public boolean getForCreateTable();
0: 
0: 	/**
0: 	 * Save the TableDescriptor for the target of 
0: 	 * DDL so that it can be passed between the
0: 	 * various ConstantActions during execution.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setDDLTableDescriptor(TableDescriptor td);
0: 
0: 	/**
0: 	 * Get the TableDescriptor for the target of
0: 	 * DDL.
0: 	 *
0: 	 * @return The TableDescriptor for the target of
0: 	 * DDL.
0: 	 */
0: 	public TableDescriptor getDDLTableDescriptor();
0: 
0: 	/**
0: 	 * Set the maximum # of rows.  (# of rows that can
0: 	 * be returned by a ResultSet.  0 means no limit.)
0: 	 *
0: 	 * @param maxRows Maximum # of rows. (0 means no limit.)
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setMaxRows(int maxRows);
0: 
0: 	/**
0: 	 * Get the maximum # of rows.  (# of rows that can
0: 	 * be returned by a ResultSet.  0 means no limit.)
0: 	 *
0: 	 * @return Maximum # of rows.  (0 means no limit.)
0: 	 */
0: 	public int getMaxRows();
0: 
0: 	/**
0: 	 * Is this Activation for a cursor?
0: 	 *
0: 	 * @return Whether or not this Activation is for a cursor.
0: 	 */
0: 	public boolean isCursorActivation();
0: 
0: 	/**
0: 	 * Save the ResultSet for the target
0: 	 * of an update/delete to a VTI.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	public void setTargetVTI(java.sql.ResultSet targetVTI);
0: 
0: 	/**
0: 	 * Get the ResultSet for the target
0: 	 * of an update/delete to a VTI.
0: 	 *
0: 	 * @return The ResultSet for the target
0: 	 * of an update/delete to a VTI.
0: 	 */
0: 	public java.sql.ResultSet getTargetVTI();
0: 
0: 	public ConstantAction	getConstantAction();
0: 
0: 	//store a reference to the parent table result sets
0: 	public void setParentResultSet(TemporaryRowHolder rs, String resultSetId);
0: 
0: 	/**
0: 	 * get the reference to parent table ResultSets, that will be needed by the 
0: 	 * referential action dependent table scans.
0: 	 */
0: 	public Vector getParentResultSet(String resultSetId);
0: 	
0: 	//clear the parent resultset hash table;
0: 	public void clearParentResultSets();
0: 
0: 	public Hashtable getParentResultSets();
0: 
0: 	/**
0: 	 * beetle 3865: updateable cursor using index.  A way of communication
0: 	 * between cursor activation and update activation.
0: 	 */
0: 	public void setForUpdateIndexScan(CursorResultSet forUpdateResultSet);
0: 
0: 	public CursorResultSet getForUpdateIndexScan();
0: 
0: 	/**
0: 		Return the set of dynamical created result sets, for procedures.
0: 		Base implementation returns null, a generated class for a procedure overwrites
0: 		this with a real implementation.
0: 		@return null if no dynamic results exists. Otherwise an array of ResultSet
0: 		arrays, each of length one containing null or a reference to a ResultSet.
0: 	*/
0: 	public java.sql.ResultSet[][] getDynamicResults();
0: 
0: 	/**
0: 		Return the maximum number of dynamical created result sets from the procedure definition.
0: 		Base implementation returns 0, a generated class for a procedure overwrites
0: 		this with a real implementation.
0: 	*/
0: 	public int getMaxDynamicResults();
0: }
============================================================================