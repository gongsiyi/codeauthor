1:7af6726: /*
1:7af6726: 
1:7af6726:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.StreamTruncationTest
1:7af6726: 
1:7af6726:    Licensed to the Apache Software Foundation (ASF) under one or more
1:7af6726:    contributor license agreements.  See the NOTICE file distributed with
1:7af6726:    this work for additional information regarding copyright ownership.
1:7af6726:    The ASF licenses this file to you under the Apache License, Version 2.0
1:7af6726:    (the "License"); you may not use this file except in compliance with
1:7af6726:    the License.  You may obtain a copy of the License at
1:7af6726: 
1:7af6726:       http://www.apache.org/licenses/LICENSE-2.0
1:7af6726: 
1:7af6726:    Unless required by applicable law or agreed to in writing, software
1:7af6726:    distributed under the License is distributed on an "AS IS" BASIS,
1:7af6726:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7af6726:    See the License for the specific language governing permissions and
1:7af6726:    limitations under the License.
1:7af6726: 
1:7af6726:  */
1:7af6726: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:7af6726: 
1:7af6726: import java.io.IOException;
1:7af6726: import java.io.Reader;
1:7af6726: import java.sql.PreparedStatement;
1:7af6726: import java.sql.ResultSet;
1:7af6726: import java.sql.SQLException;
1:7af6726: import java.sql.Statement;
1:7af6726: import java.sql.Types;
1:7af6726: import java.util.concurrent.atomic.AtomicInteger;
1:7af6726: import junit.framework.Test;
1:7af6726: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1:7af6726: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:7af6726: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:7af6726: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:7af6726: import org.apache.derbyTesting.junit.TestConfiguration;
1:7af6726: 
1:7af6726: /**
1:7af6726:  * Tests string data value truncation when the data is inserted with a stream.
1:7af6726:  * <p>
1:7af6726:  * Tests that truncation does indeed happen for CHAR, VARCHAR and CLOB.
1:7af6726:  * Truncation is not allowed for LONG VARCHAR columns.
1:7af6726:  * <p>
1:7af6726:  * There are two aspects to consider; specified length vs unspecified length
1:7af6726:  * (lengthless override), and small vs large. In this regard, small is when the
1:7af6726:  * stream content fits into the internal buffer of the conversion reader
1:7af6726:  * ({@code ReaderToUTF8Stream}). In this test, the buffer is assumed to be
1:7af6726:  * approximately 32KB.
1:7af6726:  */
1:7af6726: public class StreamTruncationTest
1:7af6726:     extends BaseJDBCTestCase {
1:7af6726: 
1:7af6726:     /**
1:7af6726:      * Assumed conversion buffer size.
1:7af6726:      * @see org.apache.derby.iapi.types.ReaderToUTF8Stream
1:7af6726:      */
1:7af6726:     public static final int CONV_BUFFER_SIZE = 32*1024;
1:7af6726: 
1:7af6726:     // Column index constants
1:7af6726:     public static final int CLOB = 2;
1:7af6726:     public static final int VARCHAR = 3;
1:7af6726:     public static final int LONGVARCHAR = 4;
1:7af6726:     public static final int CHAR = 5;
1:7af6726: 
1:7af6726:     /** Name of table with the "small" columns. */
1:7af6726:     public static final String TABLE_SMALL = "TRUNCATE_SMALL";
1:7af6726:     /** Name of table with the "large" columns. */
1:7af6726:     public static final String TABLE_LARGE = "TRUNCATE_LARGE";
1:7af6726:     /** Small size (smaller than the conversion buffer). */
1:7af6726:     public static final int SMALL_SIZE = CONV_BUFFER_SIZE / 2;
1:7af6726:     /** Large size (larger than the conversion buffer). */
1:7af6726:     public static final int LARGE_SIZE = CONV_BUFFER_SIZE * 2;
1:7af6726:     /* Size used for the large VARCHAR column. */
1:7af6726:     public static final int LARGE_VARCHAR_SIZE = 32672;
1:7af6726:     /* Size used for the CHAR column. */
1:7af6726:     public static final int CHAR_SIZE = 138;
1:7af6726: 
1:7af6726:     /** Id/counter to use for the inserted rows. */
1:7af6726:     private static AtomicInteger ID = new AtomicInteger(1);
1:7af6726: 
1:7af6726:     public StreamTruncationTest(String name) {
1:7af6726:         super(name);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void setUp()
1:7af6726:             throws SQLException {
1:7af6726:         setAutoCommit(false);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testCharWithLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         charSmall(false);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testCharWithoutLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         charSmall(true);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testSmallVarcharWithLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeSmall(VARCHAR, false);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testSmallVarcharWithoutLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeSmall(VARCHAR, true);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testLargeVarcharWithLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeLarge(VARCHAR, false);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testLargeVarcharWithoutLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeLarge(VARCHAR, true);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testLongVarcharWithLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeSmall(LONGVARCHAR, false);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testLongVarcharWithoutLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeSmall(LONGVARCHAR, true);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testSmallClobWithLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeSmall(CLOB, false);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testSmallClobWithoutLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeSmall(CLOB, true);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testLargeClobWithLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeLarge(CLOB, false);
1:7af6726:     }
1:7af6726: 
1:7af6726:     public void testLargeClobWithoutLength()
1:7af6726:             throws IOException, SQLException {
1:7af6726:         generalTypeLarge(CLOB, true);
1:7af6726:     }
1:7af6726: 
1:7af6726:     /**
1:7af6726:      * Executes a set of insertions into the larger of the columns.
1:7af6726:      *
1:7af6726:      * @param colIndex column index to insert into, which also determines the
1:7af6726:      *      type to test
1:7af6726:      * @param lengthless {@code true} if a lengthless override should be used,
1:7af6726:      *      {@code false} if the length of the stream shall be specified when
1:7af6726:      *      inserted
1:7af6726:      * @throws IOException if reading from the source stream fails
1:7af6726:      * @throws SQLException if something goes wrong
1:7af6726:      */
1:7af6726:     private void generalTypeLarge(int colIndex, boolean lengthless)
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertLarge(colIndex, lengthless, LARGE_SIZE, 0); // Fits
1:7af6726:         insertLarge(colIndex, lengthless, LARGE_SIZE -99, 15); // Fits
1:7af6726:         insertLarge(colIndex, lengthless, LARGE_SIZE + 189, 189); // Truncate
1:7af6726:         insertLarge(colIndex, lengthless, LARGE_SIZE, 250); // Fits
1:7af6726:         insertLarge(colIndex, lengthless, LARGE_SIZE + 180, 0); // Should fail
1:7af6726:         insertLarge(colIndex, lengthless, LARGE_SIZE + 180, 17); // Should fail
1:7af6726:     }
1:7af6726: 
1:7af6726:     /**
1:7af6726:      * Executes a set of insertions into the smaller of the columns.
1:7af6726:      *
1:7af6726:      * @param colIndex column index to insert into, which also determines the
1:7af6726:      *      type to test
1:7af6726:      * @param lengthless {@code true} if a lengthless override should be used,
1:7af6726:      *      {@code false} if the length of the stream shall be specified when
1:7af6726:      *      inserted
1:7af6726:      * @throws IOException if reading from the source stream fails
1:7af6726:      * @throws SQLException if something goes wrong
1:7af6726:      */
1:7af6726:     private void generalTypeSmall(int colIndex, boolean lengthless)
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertSmall(colIndex, lengthless, SMALL_SIZE, 0); // Fits
1:7af6726:         insertSmall(colIndex, lengthless, SMALL_SIZE -99, 15); // Fits
1:7af6726:         insertSmall(colIndex, lengthless, SMALL_SIZE + 189, 189); // Truncate
1:7af6726:         insertSmall(colIndex, lengthless, SMALL_SIZE, 250); // Fits
1:7af6726:         insertSmall(colIndex, lengthless, SMALL_SIZE + 180, 0); // Should fail
1:7af6726:         insertSmall(colIndex, lengthless, SMALL_SIZE + 180, 17); // Should fail
1:7af6726:     }
1:7af6726: 
1:7af6726:     /**
1:7af6726:      * Executes a set of insertions into the CHAR column.
1:7af6726:      *
1:7af6726:      * @param lengthless {@code true} if a lengthless override should be used,
1:7af6726:      *      {@code false} if the length of the stream shall be specified when
1:7af6726:      *      inserted
1:7af6726:      * @throws IOException if reading from the source stream fails
1:7af6726:      * @throws SQLException if something goes wrong
1:7af6726:      */
1:7af6726:     private void charSmall(boolean lengthless)
1:7af6726:             throws IOException, SQLException {
1:7af6726:         insertSmall(CHAR, lengthless, CHAR_SIZE, 0); // Fits
1:7af6726:         insertSmall(CHAR, lengthless, CHAR_SIZE -10, 4); // Fits
1:7af6726:         insertSmall(CHAR, lengthless, CHAR_SIZE + 189, 189); // Should truncate
1:7af6726:         insertSmall(CHAR, lengthless, CHAR_SIZE, 20); // Fits
1:7af6726:         insertSmall(CHAR, lengthless, CHAR_SIZE + 180, 0); // Should fail
1:7af6726:         insertSmall(CHAR, lengthless, CHAR_SIZE + 180, 17); // Should fail
1:7af6726:     }
1:7af6726: 
1:7af6726:     /**
1:7af6726:      * Inserts a small (smaller than internal conversion buffer) string value.
1:7af6726:      *
1:7af6726:      * @param colIndex column to insert into (see constants)
1:7af6726:      * @param lengthless whether the length of the stream should be specified
1:7af6726:      *      or not on insertion
1:7af6726:      * @param totalLength the total character length of the stream to insert
1:7af6726:      * @param blanks number of trailing blanks in the stream
1:7af6726:      * @return The id of the row inserted.
1:7af6726:      *
1:7af6726:      * @throws IOException if reading from the source stream fails
1:7af6726:      * @throws SQLException if something goes wrong, or the test fails
1:7af6726:      */
1:7af6726:     private int insertSmall(int colIndex, boolean lengthless,
1:7af6726:                             int totalLength, int blanks)
1:7af6726:             throws IOException, SQLException {
1:7af6726:         int id = ID.getAndAdd(1);
1:7af6726:         PreparedStatement ps = prepareStatement(
1:7af6726:                 "insert into " + TABLE_SMALL + " values (?,?,?,?,?)");
1:7af6726:         ps.setInt(1, id);
1:7af6726:         ps.setNull(2, Types.CLOB);
1:7af6726:         ps.setNull(3, Types.VARCHAR);
1:7af6726:         ps.setNull(4, Types.LONGVARCHAR);
1:7af6726:         ps.setNull(5, Types.CHAR);
1:7af6726: 
1:7af6726:         int colWidth = SMALL_SIZE;
1:7af6726:         if (colIndex == LONGVARCHAR) {
1:7af6726:             colWidth = 32700;
1:7af6726:         }
1:7af6726:         int expectedLength = Math.min(totalLength, colWidth);
1:7af6726:         // Length of CHAR is always the defined length due to padding.
1:7af6726:         if (colIndex == CHAR) {
1:7af6726:             colWidth = expectedLength = CHAR_SIZE;
1:7af6726:         }
1:7af6726:         println("totalLength=" + totalLength + ", blanks=" + blanks +
1:7af6726:                 ", colWidth=" + colWidth + ", expectedLength=" +
1:7af6726:                 expectedLength);
1:7af6726:         Reader source = new LoopingAlphabetReader(totalLength,
1:7af6726:                 CharAlphabet.modernLatinLowercase(), blanks);
1:7af6726:         // Now set what we are going to test.
1:7af6726:         if (lengthless) {
1:7af6726:             ps.setCharacterStream(colIndex, source);
1:7af6726:         } else {
1:7af6726:             ps.setCharacterStream(colIndex, source, totalLength);
1:7af6726:         }
1:7af6726:         try {
1:7af6726:             // Exceute the insert.
1:7af6726:             assertEquals(1, ps.executeUpdate());
1:7af6726:             if (totalLength > expectedLength) {
1:7af6726:                 assertTrue(totalLength - blanks <= expectedLength);
1:7af6726:             }
1:7af6726: 
1:7af6726:             // Fetch the value.
1:7af6726:             assertEquals(expectedLength,
1:7af6726:                     getStreamLength(TABLE_SMALL, colIndex, id));
1:7af6726:         } catch (SQLException sqle) {
1:7af6726:             // Sanity check of the length.
1:7af6726:             if (colIndex == LONGVARCHAR) {
1:7af6726:                 // Truncation is not allowed.
1:7af6726:                 assertTrue(totalLength > expectedLength);
1:7af6726:             } else {
1:7af6726:                 // Total length minus blanks must still be larger then the
1:7af6726:                 // expected length.
1:7af6726:                 assertTrue(totalLength - blanks > expectedLength);
1:7af6726:             }
1:7af6726:             // The error handling here is very fuzzy...
1:7af6726:             // This will hopefully be fixed, such that the exception thrown
1:7af6726:             // will always be 22001. Today this is currently wrapped by several
1:7af6726:             // other exceptions.
1:7af6726:             String expectedState = "XSDA4";
1:7af6726:             if (colIndex == CHAR || colIndex == VARCHAR) {
1:7af6726:                 if (lengthless) {
1:7af6726:                     expectedState = "XJ001";
1:7af6726:                 } else {
1:7af6726:                     if (!usingEmbedded()) {
1:7af6726:                         expectedState = "XJ001";
1:7af6726:                     } else {
1:7af6726:                         expectedState = "22001";
1:7af6726:                     }
1:7af6726:                 }
1:7af6726:             }
1:7af6726:             assertSQLState(expectedState, sqle);
1:7af6726:         }
1:7af6726:         return id;
1:7af6726:     }
1:7af6726: 
1:7af6726:     /**
1:7af6726:      * Inserts a large (largerer than internal conversion buffer) string value.
1:7af6726:      *
1:7af6726:      * @param colIndex column to insert into (see constants)
1:7af6726:      * @param lengthless whether the length of the stream should be specified
1:7af6726:      *      or not on insertion
1:7af6726:      * @param totalLength the total character length of the stream to insert
1:7af6726:      * @param blanks number of trailing blanks in the stream
1:7af6726:      * @return The id of the row inserted.
1:7af6726:      *
1:7af6726:      * @throws IOException if reading from the source stream fails
1:7af6726:      * @throws SQLException if something goes wrong, or the test fails
1:7af6726:      */
1:7af6726:     private int insertLarge(int colIndex, boolean lengthless,
1:7af6726:                             int totalLength, int blanks)
1:7af6726:             throws IOException, SQLException {
1:7af6726:         // Not used here, see insertSmall.
1:7af6726:         assertTrue(colIndex != CHAR && colIndex != LONGVARCHAR);
1:7af6726: 
1:7af6726:         int id = ID.getAndAdd(1);
1:7af6726:         PreparedStatement ps = prepareStatement(
1:7af6726:                 "insert into " + TABLE_LARGE + " values (?,?,?)");
1:7af6726:         ps.setInt(1, id);
1:7af6726:         ps.setNull(2, Types.CLOB);
1:7af6726:         ps.setNull(3, Types.VARCHAR);
1:7af6726: 
1:7af6726:         int colWidth = (colIndex == VARCHAR ? LARGE_VARCHAR_SIZE : LARGE_SIZE);
1:7af6726:         int expectedLength = Math.min(totalLength, colWidth);
1:7af6726:         println("totalLength=" + totalLength + ", blanks=" + blanks +
1:7af6726:                 ", colWidth=" + colWidth + ", expectedLength=" +
1:7af6726:                 expectedLength);
1:7af6726:         Reader source = new LoopingAlphabetReader(totalLength,
1:7af6726:                 CharAlphabet.modernLatinLowercase(), blanks);
1:7af6726:         // Now set what we are going to test.
1:7af6726:         if (lengthless) {
1:7af6726:             ps.setCharacterStream(colIndex, source);
1:7af6726:         } else {
1:7af6726:             ps.setCharacterStream(colIndex, source, totalLength);
1:7af6726:         }
1:7af6726:         try {
1:7af6726:             // Exceute the insert.
1:7af6726:             assertEquals(1, ps.executeUpdate());
1:7af6726:             if (totalLength > expectedLength) {
1:7af6726:                 assertTrue(totalLength - blanks <= expectedLength);
1:7af6726:             }
1:7af6726: 
1:7af6726:             // Fetch the value.
1:7af6726:             assertEquals(expectedLength,
1:7af6726:                     getStreamLength(TABLE_LARGE, colIndex, id));
1:7af6726:         } catch (SQLException sqle) {
1:7af6726:             // Sanity check of the length.
1:7af6726:             // Total length minus blanks must still be larger then the
1:7af6726:             // expected length.
1:7af6726:             assertTrue(totalLength - blanks > expectedLength);
1:7af6726:             // The error handling here is very fuzzy...
1:7af6726:             // This will hopefully be fixed, such that the exception thrown
1:7af6726:             // will always be 22001. Today this is currently wrapped by several
1:7af6726:             // other exceptions.
1:7af6726:             String expectedState = "XSDA4";
1:7af6726:             if (colIndex == VARCHAR) {
1:7af6726:                 if (lengthless) {
1:7af6726:                     expectedState = "XJ001";
1:7af6726:                 } else {
1:7af6726:                     if (!usingEmbedded()) {
1:7af6726:                         expectedState = "XJ001";
1:7af6726:                     } else {
1:7af6726:                         expectedState = "22001";
1:7af6726:                     }
1:7af6726:                 }
1:7af6726:             }
1:7af6726:             assertSQLState(expectedState, sqle);
1:7af6726:         }
1:7af6726:         return id;
1:7af6726:     }
1:7af6726: 
1:7af6726:     /**
1:7af6726:      * Obtains the length of the data value stored in the specified table,
1:7af6726:      * column index and id (primary key).
1:7af6726:      *
1:7af6726:      * @param table table name
1:7af6726:      * @param colIndex column index
1:7af6726:      * @param id id of the row to fetch
1:7af6726:      * @return The length in characters of the string data value fetched.
1:7af6726:      * @throws IOException if reading the stream fails
1:7af6726:      * @throws SQLException if something goes wrong
1:7af6726:      */
1:7af6726:     private int getStreamLength(String table, int colIndex, int id)
1:7af6726:             throws IOException, SQLException {
1:7af6726:         Statement sFetch =  createStatement();
1:7af6726:         ResultSet rs = sFetch.executeQuery("select * from " + table +
1:7af6726:                 " where id = " + id);
1:7af6726:         assertTrue(rs.next());
1:7af6726:         Reader dbSource = rs.getCharacterStream(colIndex);
1:7af6726:         int observedLen = 0;
1:7af6726:         char[] buf = new char[1024];
1:7af6726:         while (true) {
1:7af6726:             int read = dbSource.read(buf);
1:7af6726:             if (read == -1) {
1:7af6726:                 break;
1:7af6726:             }
1:7af6726:             observedLen += read;
1:7af6726:         }
1:7af6726:         rs.close();
1:7af6726:         return observedLen;
1:7af6726:     }
1:7af6726: 
1:7af6726:     /**
1:7af6726:      * Returns the suite of tests.
1:7af6726:      * <p>
1:7af6726:      * Two tables are created for the test.
1:7af6726:      *
1:7af6726:      * @return A suite of tests.
1:7af6726:      */
1:7af6726:     public static Test suite() {
1:7af6726:         return new CleanDatabaseTestSetup(TestConfiguration.defaultSuite(
1:7af6726:                 StreamTruncationTest.class, false)) {
1:7af6726:                     protected void decorateSQL(Statement stmt)
1:7af6726:                             throws SQLException {
1:7af6726:                         stmt.executeUpdate(
1:7af6726:                                 "create table " + TABLE_SMALL + " (" +
1:7af6726:                                 "ID int primary key, " +
1:7af6726:                                 "CLOBDATA clob(" + SMALL_SIZE + ")," +
1:7af6726:                                 "VCHARDATA varchar(" + SMALL_SIZE + ")," +
1:7af6726:                                 "LVCHARDATA long varchar," +
1:7af6726:                                 "CHARDATA char(" + CHAR_SIZE + "))");
1:7af6726:                         stmt.executeUpdate(
1:7af6726:                                 "create table " + TABLE_LARGE + " (" +
1:7af6726:                                 "ID int primary key, " +
1:7af6726:                                 "CLOBDATA clob(" + LARGE_SIZE + ")," +
1:7af6726:                                 "VCHARDATA varchar(" + LARGE_VARCHAR_SIZE +
1:7af6726:                                 "))");
1:7af6726:                         stmt.close();
1:7af6726:                     }
1:7af6726:             };
1:7af6726:     }
1:7af6726: }
============================================================================
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:7af6726
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.StreamTruncationTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
1: import java.io.IOException;
1: import java.io.Reader;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.Types;
1: import java.util.concurrent.atomic.AtomicInteger;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * Tests string data value truncation when the data is inserted with a stream.
1:  * <p>
1:  * Tests that truncation does indeed happen for CHAR, VARCHAR and CLOB.
1:  * Truncation is not allowed for LONG VARCHAR columns.
1:  * <p>
1:  * There are two aspects to consider; specified length vs unspecified length
1:  * (lengthless override), and small vs large. In this regard, small is when the
1:  * stream content fits into the internal buffer of the conversion reader
1:  * ({@code ReaderToUTF8Stream}). In this test, the buffer is assumed to be
1:  * approximately 32KB.
1:  */
1: public class StreamTruncationTest
1:     extends BaseJDBCTestCase {
1: 
1:     /**
1:      * Assumed conversion buffer size.
1:      * @see org.apache.derby.iapi.types.ReaderToUTF8Stream
1:      */
1:     public static final int CONV_BUFFER_SIZE = 32*1024;
1: 
1:     // Column index constants
1:     public static final int CLOB = 2;
1:     public static final int VARCHAR = 3;
1:     public static final int LONGVARCHAR = 4;
1:     public static final int CHAR = 5;
1: 
1:     /** Name of table with the "small" columns. */
1:     public static final String TABLE_SMALL = "TRUNCATE_SMALL";
1:     /** Name of table with the "large" columns. */
1:     public static final String TABLE_LARGE = "TRUNCATE_LARGE";
1:     /** Small size (smaller than the conversion buffer). */
1:     public static final int SMALL_SIZE = CONV_BUFFER_SIZE / 2;
1:     /** Large size (larger than the conversion buffer). */
1:     public static final int LARGE_SIZE = CONV_BUFFER_SIZE * 2;
1:     /* Size used for the large VARCHAR column. */
1:     public static final int LARGE_VARCHAR_SIZE = 32672;
1:     /* Size used for the CHAR column. */
1:     public static final int CHAR_SIZE = 138;
1: 
1:     /** Id/counter to use for the inserted rows. */
1:     private static AtomicInteger ID = new AtomicInteger(1);
1: 
1:     public StreamTruncationTest(String name) {
1:         super(name);
1:     }
1: 
1:     public void setUp()
1:             throws SQLException {
1:         setAutoCommit(false);
1:     }
1: 
1:     public void testCharWithLength()
1:             throws IOException, SQLException {
1:         charSmall(false);
1:     }
1: 
1:     public void testCharWithoutLength()
1:             throws IOException, SQLException {
1:         charSmall(true);
1:     }
1: 
1:     public void testSmallVarcharWithLength()
1:             throws IOException, SQLException {
1:         generalTypeSmall(VARCHAR, false);
1:     }
1: 
1:     public void testSmallVarcharWithoutLength()
1:             throws IOException, SQLException {
1:         generalTypeSmall(VARCHAR, true);
1:     }
1: 
1:     public void testLargeVarcharWithLength()
1:             throws IOException, SQLException {
1:         generalTypeLarge(VARCHAR, false);
1:     }
1: 
1:     public void testLargeVarcharWithoutLength()
1:             throws IOException, SQLException {
1:         generalTypeLarge(VARCHAR, true);
1:     }
1: 
1:     public void testLongVarcharWithLength()
1:             throws IOException, SQLException {
1:         generalTypeSmall(LONGVARCHAR, false);
1:     }
1: 
1:     public void testLongVarcharWithoutLength()
1:             throws IOException, SQLException {
1:         generalTypeSmall(LONGVARCHAR, true);
1:     }
1: 
1:     public void testSmallClobWithLength()
1:             throws IOException, SQLException {
1:         generalTypeSmall(CLOB, false);
1:     }
1: 
1:     public void testSmallClobWithoutLength()
1:             throws IOException, SQLException {
1:         generalTypeSmall(CLOB, true);
1:     }
1: 
1:     public void testLargeClobWithLength()
1:             throws IOException, SQLException {
1:         generalTypeLarge(CLOB, false);
1:     }
1: 
1:     public void testLargeClobWithoutLength()
1:             throws IOException, SQLException {
1:         generalTypeLarge(CLOB, true);
1:     }
1: 
1:     /**
1:      * Executes a set of insertions into the larger of the columns.
1:      *
1:      * @param colIndex column index to insert into, which also determines the
1:      *      type to test
1:      * @param lengthless {@code true} if a lengthless override should be used,
1:      *      {@code false} if the length of the stream shall be specified when
1:      *      inserted
1:      * @throws IOException if reading from the source stream fails
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void generalTypeLarge(int colIndex, boolean lengthless)
1:             throws IOException, SQLException {
1:         insertLarge(colIndex, lengthless, LARGE_SIZE, 0); // Fits
1:         insertLarge(colIndex, lengthless, LARGE_SIZE -99, 15); // Fits
1:         insertLarge(colIndex, lengthless, LARGE_SIZE + 189, 189); // Truncate
1:         insertLarge(colIndex, lengthless, LARGE_SIZE, 250); // Fits
1:         insertLarge(colIndex, lengthless, LARGE_SIZE + 180, 0); // Should fail
1:         insertLarge(colIndex, lengthless, LARGE_SIZE + 180, 17); // Should fail
1:     }
1: 
1:     /**
1:      * Executes a set of insertions into the smaller of the columns.
1:      *
1:      * @param colIndex column index to insert into, which also determines the
1:      *      type to test
1:      * @param lengthless {@code true} if a lengthless override should be used,
1:      *      {@code false} if the length of the stream shall be specified when
1:      *      inserted
1:      * @throws IOException if reading from the source stream fails
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void generalTypeSmall(int colIndex, boolean lengthless)
1:             throws IOException, SQLException {
1:         insertSmall(colIndex, lengthless, SMALL_SIZE, 0); // Fits
1:         insertSmall(colIndex, lengthless, SMALL_SIZE -99, 15); // Fits
1:         insertSmall(colIndex, lengthless, SMALL_SIZE + 189, 189); // Truncate
1:         insertSmall(colIndex, lengthless, SMALL_SIZE, 250); // Fits
1:         insertSmall(colIndex, lengthless, SMALL_SIZE + 180, 0); // Should fail
1:         insertSmall(colIndex, lengthless, SMALL_SIZE + 180, 17); // Should fail
1:     }
1: 
1:     /**
1:      * Executes a set of insertions into the CHAR column.
1:      *
1:      * @param lengthless {@code true} if a lengthless override should be used,
1:      *      {@code false} if the length of the stream shall be specified when
1:      *      inserted
1:      * @throws IOException if reading from the source stream fails
1:      * @throws SQLException if something goes wrong
1:      */
1:     private void charSmall(boolean lengthless)
1:             throws IOException, SQLException {
1:         insertSmall(CHAR, lengthless, CHAR_SIZE, 0); // Fits
1:         insertSmall(CHAR, lengthless, CHAR_SIZE -10, 4); // Fits
1:         insertSmall(CHAR, lengthless, CHAR_SIZE + 189, 189); // Should truncate
1:         insertSmall(CHAR, lengthless, CHAR_SIZE, 20); // Fits
1:         insertSmall(CHAR, lengthless, CHAR_SIZE + 180, 0); // Should fail
1:         insertSmall(CHAR, lengthless, CHAR_SIZE + 180, 17); // Should fail
1:     }
1: 
1:     /**
1:      * Inserts a small (smaller than internal conversion buffer) string value.
1:      *
1:      * @param colIndex column to insert into (see constants)
1:      * @param lengthless whether the length of the stream should be specified
1:      *      or not on insertion
1:      * @param totalLength the total character length of the stream to insert
1:      * @param blanks number of trailing blanks in the stream
1:      * @return The id of the row inserted.
1:      *
1:      * @throws IOException if reading from the source stream fails
1:      * @throws SQLException if something goes wrong, or the test fails
1:      */
1:     private int insertSmall(int colIndex, boolean lengthless,
1:                             int totalLength, int blanks)
1:             throws IOException, SQLException {
1:         int id = ID.getAndAdd(1);
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into " + TABLE_SMALL + " values (?,?,?,?,?)");
1:         ps.setInt(1, id);
1:         ps.setNull(2, Types.CLOB);
1:         ps.setNull(3, Types.VARCHAR);
1:         ps.setNull(4, Types.LONGVARCHAR);
1:         ps.setNull(5, Types.CHAR);
1: 
1:         int colWidth = SMALL_SIZE;
1:         if (colIndex == LONGVARCHAR) {
1:             colWidth = 32700;
1:         }
1:         int expectedLength = Math.min(totalLength, colWidth);
1:         // Length of CHAR is always the defined length due to padding.
1:         if (colIndex == CHAR) {
1:             colWidth = expectedLength = CHAR_SIZE;
1:         }
1:         println("totalLength=" + totalLength + ", blanks=" + blanks +
1:                 ", colWidth=" + colWidth + ", expectedLength=" +
1:                 expectedLength);
1:         Reader source = new LoopingAlphabetReader(totalLength,
1:                 CharAlphabet.modernLatinLowercase(), blanks);
1:         // Now set what we are going to test.
1:         if (lengthless) {
1:             ps.setCharacterStream(colIndex, source);
1:         } else {
1:             ps.setCharacterStream(colIndex, source, totalLength);
1:         }
1:         try {
1:             // Exceute the insert.
1:             assertEquals(1, ps.executeUpdate());
1:             if (totalLength > expectedLength) {
1:                 assertTrue(totalLength - blanks <= expectedLength);
1:             }
1: 
1:             // Fetch the value.
1:             assertEquals(expectedLength,
1:                     getStreamLength(TABLE_SMALL, colIndex, id));
1:         } catch (SQLException sqle) {
1:             // Sanity check of the length.
1:             if (colIndex == LONGVARCHAR) {
1:                 // Truncation is not allowed.
1:                 assertTrue(totalLength > expectedLength);
1:             } else {
1:                 // Total length minus blanks must still be larger then the
1:                 // expected length.
1:                 assertTrue(totalLength - blanks > expectedLength);
1:             }
1:             // The error handling here is very fuzzy...
1:             // This will hopefully be fixed, such that the exception thrown
1:             // will always be 22001. Today this is currently wrapped by several
1:             // other exceptions.
1:             String expectedState = "XSDA4";
1:             if (colIndex == CHAR || colIndex == VARCHAR) {
1:                 if (lengthless) {
1:                     expectedState = "XJ001";
1:                 } else {
1:                     if (!usingEmbedded()) {
1:                         expectedState = "XJ001";
1:                     } else {
1:                         expectedState = "22001";
1:                     }
1:                 }
1:             }
1:             assertSQLState(expectedState, sqle);
1:         }
1:         return id;
1:     }
1: 
1:     /**
1:      * Inserts a large (largerer than internal conversion buffer) string value.
1:      *
1:      * @param colIndex column to insert into (see constants)
1:      * @param lengthless whether the length of the stream should be specified
1:      *      or not on insertion
1:      * @param totalLength the total character length of the stream to insert
1:      * @param blanks number of trailing blanks in the stream
1:      * @return The id of the row inserted.
1:      *
1:      * @throws IOException if reading from the source stream fails
1:      * @throws SQLException if something goes wrong, or the test fails
1:      */
1:     private int insertLarge(int colIndex, boolean lengthless,
1:                             int totalLength, int blanks)
1:             throws IOException, SQLException {
1:         // Not used here, see insertSmall.
1:         assertTrue(colIndex != CHAR && colIndex != LONGVARCHAR);
1: 
1:         int id = ID.getAndAdd(1);
1:         PreparedStatement ps = prepareStatement(
1:                 "insert into " + TABLE_LARGE + " values (?,?,?)");
1:         ps.setInt(1, id);
1:         ps.setNull(2, Types.CLOB);
1:         ps.setNull(3, Types.VARCHAR);
1: 
1:         int colWidth = (colIndex == VARCHAR ? LARGE_VARCHAR_SIZE : LARGE_SIZE);
1:         int expectedLength = Math.min(totalLength, colWidth);
1:         println("totalLength=" + totalLength + ", blanks=" + blanks +
1:                 ", colWidth=" + colWidth + ", expectedLength=" +
1:                 expectedLength);
1:         Reader source = new LoopingAlphabetReader(totalLength,
1:                 CharAlphabet.modernLatinLowercase(), blanks);
1:         // Now set what we are going to test.
1:         if (lengthless) {
1:             ps.setCharacterStream(colIndex, source);
1:         } else {
1:             ps.setCharacterStream(colIndex, source, totalLength);
1:         }
1:         try {
1:             // Exceute the insert.
1:             assertEquals(1, ps.executeUpdate());
1:             if (totalLength > expectedLength) {
1:                 assertTrue(totalLength - blanks <= expectedLength);
1:             }
1: 
1:             // Fetch the value.
1:             assertEquals(expectedLength,
1:                     getStreamLength(TABLE_LARGE, colIndex, id));
1:         } catch (SQLException sqle) {
1:             // Sanity check of the length.
1:             // Total length minus blanks must still be larger then the
1:             // expected length.
1:             assertTrue(totalLength - blanks > expectedLength);
1:             // The error handling here is very fuzzy...
1:             // This will hopefully be fixed, such that the exception thrown
1:             // will always be 22001. Today this is currently wrapped by several
1:             // other exceptions.
1:             String expectedState = "XSDA4";
1:             if (colIndex == VARCHAR) {
1:                 if (lengthless) {
1:                     expectedState = "XJ001";
1:                 } else {
1:                     if (!usingEmbedded()) {
1:                         expectedState = "XJ001";
1:                     } else {
1:                         expectedState = "22001";
1:                     }
1:                 }
1:             }
1:             assertSQLState(expectedState, sqle);
1:         }
1:         return id;
1:     }
1: 
1:     /**
1:      * Obtains the length of the data value stored in the specified table,
1:      * column index and id (primary key).
1:      *
1:      * @param table table name
1:      * @param colIndex column index
1:      * @param id id of the row to fetch
1:      * @return The length in characters of the string data value fetched.
1:      * @throws IOException if reading the stream fails
1:      * @throws SQLException if something goes wrong
1:      */
1:     private int getStreamLength(String table, int colIndex, int id)
1:             throws IOException, SQLException {
1:         Statement sFetch =  createStatement();
1:         ResultSet rs = sFetch.executeQuery("select * from " + table +
1:                 " where id = " + id);
1:         assertTrue(rs.next());
1:         Reader dbSource = rs.getCharacterStream(colIndex);
1:         int observedLen = 0;
1:         char[] buf = new char[1024];
1:         while (true) {
1:             int read = dbSource.read(buf);
1:             if (read == -1) {
1:                 break;
1:             }
1:             observedLen += read;
1:         }
1:         rs.close();
1:         return observedLen;
1:     }
1: 
1:     /**
1:      * Returns the suite of tests.
1:      * <p>
1:      * Two tables are created for the test.
1:      *
1:      * @return A suite of tests.
1:      */
1:     public static Test suite() {
1:         return new CleanDatabaseTestSetup(TestConfiguration.defaultSuite(
1:                 StreamTruncationTest.class, false)) {
1:                     protected void decorateSQL(Statement stmt)
1:                             throws SQLException {
1:                         stmt.executeUpdate(
1:                                 "create table " + TABLE_SMALL + " (" +
1:                                 "ID int primary key, " +
1:                                 "CLOBDATA clob(" + SMALL_SIZE + ")," +
1:                                 "VCHARDATA varchar(" + SMALL_SIZE + ")," +
1:                                 "LVCHARDATA long varchar," +
1:                                 "CHARDATA char(" + CHAR_SIZE + "))");
1:                         stmt.executeUpdate(
1:                                 "create table " + TABLE_LARGE + " (" +
1:                                 "ID int primary key, " +
1:                                 "CLOBDATA clob(" + LARGE_SIZE + ")," +
1:                                 "VCHARDATA varchar(" + LARGE_VARCHAR_SIZE +
1:                                 "))");
1:                         stmt.close();
1:                     }
1:             };
1:     }
1: }
============================================================================