1:661c2e6: /*
5:508a010: 
1:661c2e6:    Derby - Class org.apache.derby.impl.sql.compile.MergeNode
1:b3f38f8: 
1:661c2e6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:661c2e6:    contributor license agreements.  See the NOTICE file distributed with
1:661c2e6:    this work for additional information regarding copyright ownership.
1:661c2e6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:661c2e6:    (the "License"); you may not use this file except in compliance with
1:661c2e6:    the License.  You may obtain a copy of the License at
1:508a010: 
1:661c2e6:       http://www.apache.org/licenses/LICENSE-2.0
1:508a010: 
1:661c2e6:    Unless required by applicable law or agreed to in writing, software
1:661c2e6:    distributed under the License is distributed on an "AS IS" BASIS,
1:661c2e6:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:661c2e6:    See the License for the specific language governing permissions and
1:661c2e6:    limitations under the License.
1:508a010: 
1:508a010:  */
1:508a010: 
1:661c2e6: package	org.apache.derby.impl.sql.compile;
1:508a010: 
1:508a010: import java.util.Arrays;
1:661c2e6: import java.util.ArrayList;
1:508a010: import java.util.HashMap;
1:77b6e85: import java.util.HashSet;
1:508a010: import java.util.List;
1:508a010: 
1:661c2e6: import org.apache.derby.iapi.error.StandardException;
1:508a010: import org.apache.derby.iapi.reference.ClassName;
1:661c2e6: import org.apache.derby.iapi.reference.SQLState;
1:508a010: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:508a010: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:661c2e6: import org.apache.derby.iapi.services.context.ContextManager;
1:508a010: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:daffaee: import org.apache.derby.iapi.sql.compile.IgnoreFilter;
1:508a010: import org.apache.derby.iapi.sql.compile.Visitor;
1:daffaee: import org.apache.derby.iapi.sql.conn.Authorizer;
1:508a010: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
1:661c2e6: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:661c2e6: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:508a010: import org.apache.derby.iapi.sql.execute.ConstantAction;
1:508a010: import org.apache.derby.iapi.util.IdUtil;
1:2f8e6fb: import org.apache.derby.shared.common.sanity.SanityManager;
1:508a010: 
1:3cc631b: /**
1:3511a12:  * <p>
1:508a010:  * A MergeNode represents a MERGE statement. The statement looks like
1:508a010:  * this...
1:1cd5dd1:  * </p>
1:661c2e6:  *
1:661c2e6:  * <pre>
1:508a010:  * MERGE INTO targetTable
1:508a010:  * USING sourceTable
1:508a010:  * ON searchCondition
1:508a010:  * matchingClause1 ... matchingClauseN
1:661c2e6:  * </pre>
1:508a010:  *
1:508a010:  * <p>
1:508a010:  * ...where each matching clause looks like this...
1:3511a12:  * </p>
1:508a010:  *
1:508a010:  * <pre>
1:508a010:  * WHEN MATCHED [ AND matchingRefinement ] THEN DELETE
1:508a010:  * </pre>
1:508a010:  *
1:508a010:  * <p>
1:508a010:  * ...or
1:508a010:  * </p>
1:508a010:  *
1:508a010:  * <pre>
1:508a010:  * WHEN MATCHED [ AND matchingRefinement ] THEN UPDATE SET col1 = expr1, ... colM = exprM
1:508a010:  * </pre>
1:508a010:  *
1:508a010:  * <p>
1:508a010:  * ...or
1:508a010:  * </p>
1:508a010:  *
1:508a010:  * <pre>
1:508a010:  * WHEN NOT MATCHED [ AND matchingRefinement ] THEN INSERT columnList VALUES valueList
1:508a010:  * </pre>
1:508a010:  *
1:508a010:  * <p>
1:508a010:  * The Derby compiler essentially rewrites this statement into a driving left join
1:508a010:  * followed by a series of DELETE/UPDATE/INSERT actions. The left join looks like
1:508a010:  * this:
1:508a010:  * </p>
1:508a010:  *
1:508a010:  * <pre>
1:508a010:  * SELECT selectList FROM sourceTable LEFT OUTER JOIN targetTable ON searchCondition
1:508a010:  * </pre>
1:508a010:  *
1:508a010:  * <p>
1:508a010:  * The selectList of the driving left join consists of the following:
1:508a010:  * </p>
1:508a010:  *
1:508a010:  * <ul>
1:508a010:  * <li>All of the columns mentioned in the searchCondition.</li>
1:508a010:  * <li>All of the columns mentioned in the matchingRefinement clauses.</li>
1:508a010:  * <li>All of the columns mentioned in the SET clauses and the INSERT columnLists and valueLists.</li>
1:508a010:  * <li>All additional columns needed for the triggers and foreign keys fired by the DeleteResultSets
1:508a010:  * and UpdateResultSets constructed for the WHEN MATCHED clauses.</li>
1:508a010:  * <li>All additional columns needed to build index rows and evaluate generated columns
1:508a010:  * needed by the UpdateResultSets constructed for the WHEN MATCHED...THEN UPDATE clauses.</li>
1:508a010:  * <li>A trailing targetTable.RowLocation column.</li>
1:508a010:  * </ul>
1:508a010:  *
1:508a010:  * <p>
1:4cf6633:  * The driving left join's selectList then looks like this...
1:4cf6633:  * </p>
1:4cf6633:  *
1:4cf6633:  * <pre>
1:4cf6633:  * sc1, ..., scN, tc1, ..., tcM, targetTable.RowLocation
1:4cf6633:  * </pre>
1:4cf6633:  *
1:4cf6633:  * <p>
1:4cf6633:  * Where sc1...scN are the columns we need from the source table (in alphabetical
1:4cf6633:  * order) and tc1...tcM are the columns we need from the target table (in alphabetical
1:4cf6633:  * order).
1:4cf6633:  * </p>
1:4cf6633:  *
1:4cf6633:  * <p>
1:508a010:  * The matchingRefinement expressions are bound and generated against the
1:508a010:  * FromList of the driving left join. Dummy DeleteNode, UpdateNode, and InsertNode
1:508a010:  * statements are independently constructed in order to bind and generate the DELETE/UPDATE/INSERT
1:508a010:  * actions.
1:508a010:  * </p>
1:508a010:  *
1:508a010:  * <p>
1:508a010:  * At execution time, the targetTable.RowLocation column is used to determine
1:508a010:  * whether a given driving row matches. The row matches iff targetTable.RowLocation is not null.
1:508a010:  * The driving row is then assigned to the
1:508a010:  * first DELETE/UPDATE/INSERT action to which it applies. The relevant columns from
1:757bc0e:  * the driving row are extracted and buffered in a temporary table (the "then" rows) specific to that
1:508a010:  * DELETE/UPDATE/INSERT action. After the driving left join has been processed,
1:508a010:  * the DELETE/UPDATE/INSERT actions are run in order, each taking its corresponding
1:508a010:  * temporary table as its source ResultSet.
1:508a010:  * </p>
1:4cf6633:  *
1:4cf6633:  * <p>
1:4cf6633:  * Name resolution was a particularly thorny problem. This is because name resolution
1:4cf6633:  * behaves differently for SELECTs and UPDATEs. In particular, while processing UPDATEs,
1:4cf6633:  * the compiler throws away name resolution information; this happens as a consequence
1:4cf6633:  * of work done on DERBY-1043. In the end, I had to invent more name resolution machinery
1:4cf6633:  * in order to compensate for the differences in the handling of SELECTs and UPDATEs.
1:4cf6633:  * If we are to allow subqueries in matching refinement clauses and in the values expressions
1:4cf6633:  * of INSERT and UPDATE actions, then we probably need to remove this special name
1:4cf6633:  * resolution machinery. And that, in turn, probably means revisiting DERBY-1043.
1:4cf6633:  * </p>
1:4cf6633:  *
1:4cf6633:  * <p>
1:4cf6633:  * The special name resolution machinery involves marking source and target column references
1:4cf6633:  * in order to make it clear which table they belong to. This is done in associateColumn(). The markers
1:4cf6633:  * are consulted at code-generation time in order to resolve column references when we
1:4cf6633:  * generate the expressions needed to populate the rows which go into the temporary tables.
1:4cf6633:  * That resolution happens in MatchingClauseNode.getSelectListOffset().
1:4cf6633:  * </p>
1:1cd5dd1:  */
1:508a010: 
1:661c2e6: public final class MergeNode extends DMLModStatementNode
1:2f8e6fb: {
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:daffaee:     //
1:661c2e6:     // CONSTANTS
1:4cf6633:     //
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:daffaee: 
1:1cd5dd1:     public  static  final   int SOURCE_TABLE_INDEX = 0;
1:1cd5dd1:     public  static  final   int TARGET_TABLE_INDEX = 1;
1:b3f38f8: 
1:1cd5dd1: 	private static  final   String  TARGET_ROW_LOCATION_NAME = "###TargetRowLocation";
1:3511a12: 
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:daffaee:     //
1:661c2e6:     // STATE
1:508a010:     //
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:3511a12: 
1:508a010:     //
1:4cf6633:     // Filled in by the constructor.
1:4cf6633:     //
1:508a010:     private FromBaseTable   _targetTable;
1:661c2e6:     private FromTable   _sourceTable;
1:661c2e6:     private ValueNode   _searchCondition;
1:d043e29:     private QueryTreeNodeVector<MatchingClauseNode> _matchingClauses;
1:508a010: 
1:4cf6633:     //
1:4cf6633:     // Filled in at bind() time.
1:4cf6633:     //
1:01632c2:     private ResultColumnList    _selectList;
1:508a010:     private FromList                _leftJoinFromList;
1:01632c2:     private HalfOuterJoinNode   _hojn;
1:508a010: 
1:4cf6633:     //
1:4cf6633:     // Filled in at generate() time.
1:4cf6633:     //
1:508a010:     private ConstantAction      _constantAction;
1:508a010:     private CursorNode          _leftJoinCursor;
1:508a010: 
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
9:661c2e6:     //
1:661c2e6:     // CONSTRUCTOR
1:661c2e6:     //
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:508a010: 
1:3511a12:     /**
1:3511a12:      * <p>
1:661c2e6:      * Constructor for a MergeNode.
1:508a010:      * </p>
1:3511a12:      */
1:661c2e6:     public  MergeNode
1:b3f38f8:         (
1:661c2e6:          FromTable          targetTable,
1:661c2e6:          FromTable          sourceTable,
1:661c2e6:          ValueNode          searchCondition,
1:d043e29:          QueryTreeNodeVector<MatchingClauseNode> matchingClauses,
1:661c2e6:          ContextManager     cm
1:1cd5dd1:          )
1:b3f38f8:         throws StandardException
1:3e77b5a:     {
1:508a010:         super( null, null, cm );
1:b3f38f8: 
1:508a010:         if ( !( targetTable instanceof FromBaseTable) ) { notBaseTable(); }
1:508a010:         else { _targetTable = (FromBaseTable) targetTable; }
1:1cd5dd1:         
1:661c2e6:         _sourceTable = sourceTable;
1:661c2e6:         _searchCondition = searchCondition;
1:661c2e6:         _matchingClauses = matchingClauses;
1:3e77b5a:     }
1:3e77b5a: 
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:1cd5dd1:     //
1:757bc0e:     // BIND-TIME ENTRY POINTS CALLED BY MatchingClauseNode
1:757bc0e:     //
1:757bc0e:     ///////////////////////////////////////////////////////////////////////////////////
1:757bc0e: 
1:757bc0e:     /** Get the target table for the MERGE statement */
1:757bc0e:     FromBaseTable   getTargetTable() { return _targetTable; }
1:757bc0e: 
1:4cf6633:     /**
1:4cf6633:      * <p>
1:4cf6633:      * Associate a column with the SOURCE or TARGET table. This is
1:4cf6633:      * part of the special name resolution machinery which smooths over
1:4cf6633:      * the differences between name resolution for SELECTs and UPDATEs.
1:4cf6633:      * </p>
1:4cf6633:      */
1:757bc0e:     void    associateColumn( FromList fromList, ColumnReference cr, int mergeTableID )
1:757bc0e:         throws StandardException
1:757bc0e:     {
1:757bc0e:         if ( mergeTableID != ColumnReference.MERGE_UNKNOWN )    { cr.setMergeTableID( mergeTableID ); }
1:757bc0e:         else
1:757bc0e:         {
1:757bc0e:             // we have to figure out which table the column is in
1:757bc0e:             String  columnsTableName = cr.getTableName();
1:757bc0e: 
1:757bc0e:             if ( ((FromTable) fromList.elementAt( SOURCE_TABLE_INDEX )).getMatchingColumn( cr ) != null )
1:757bc0e:             {
1:757bc0e:                 cr.setMergeTableID( ColumnReference.MERGE_SOURCE );
1:757bc0e:             }
1:757bc0e:             else if ( ((FromTable) fromList.elementAt( TARGET_TABLE_INDEX )).getMatchingColumn( cr ) != null )
1:757bc0e:             {
1:757bc0e:                 cr.setMergeTableID( ColumnReference.MERGE_TARGET );
1:757bc0e:             }
1:757bc0e:         }
1:757bc0e: 
1:757bc0e:         // Don't raise an error if a column in another table is referenced and we
1:757bc0e:         // don't know how to handle it here. If the column is not in the SOURCE or TARGET
1:757bc0e:         // table, then it will be caught by other bind-time logic. Columns which ought
1:757bc0e:         // to be associated, but aren't, will be caught later on by MatchingClauseNode.getMergeTableID().
1:757bc0e:     }
1:757bc0e: 
1:757bc0e:     /** Boilerplate for binding an expression against a FromList */
1:757bc0e:     void bindExpression( ValueNode value, FromList fromList )
1:757bc0e:         throws StandardException
1:757bc0e:     {
1:757bc0e:         CompilerContext cc = getCompilerContext();
1:757bc0e:         final int previousReliability = cc.getReliability();
1:757bc0e: 
1:757bc0e:         cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
1:757bc0e:         cc.pushCurrentPrivType( Authorizer.SELECT_PRIV );
1:757bc0e:             
1:757bc0e:         try {
1:757bc0e:             // this adds SELECT priv on referenced columns and EXECUTE privs on referenced routines
1:757bc0e:             value.bindExpression
1:757bc0e:                 (
1:757bc0e:                  fromList,
1:757bc0e:                  new SubqueryList( getContextManager() ),
1:757bc0e:                  new ArrayList<AggregateNode>()
1:757bc0e:                  );
1:757bc0e:         }
1:757bc0e:         finally
1:757bc0e:         {
1:757bc0e:             // Restore previous compiler state
1:757bc0e:             cc.popCurrentPrivType();
1:757bc0e:             cc.setReliability( previousReliability );
1:757bc0e:         }
1:757bc0e:     }
1:757bc0e: 
1:4cf6633:     /**
1:4cf6633:      * <p>
1:4cf6633:      * Add the columns in the matchingRefinement clause to the evolving map.
1:4cf6633:      * This is called when we're building the SELECT list for the driving left join.
1:4cf6633:      * </p>
1:4cf6633:      */
1:757bc0e:     void    getColumnsInExpression
1:757bc0e:         ( HashMap<String,ColumnReference> map, ValueNode expression, int mergeTableID )
1:757bc0e:         throws StandardException
1:757bc0e:     {
1:757bc0e:         if ( expression == null ) { return; }
1:757bc0e: 
1:757bc0e:         List<ColumnReference> colRefs = getColumnReferences( expression );
1:757bc0e: 
1:757bc0e:         getColumnsFromList( map, colRefs, mergeTableID );
1:757bc0e:     }
1:757bc0e: 
1:4cf6633:     /**
1:4cf6633:      * <p>
1:4cf6633:      * Add a list of columns to the the evolving map.
1:4cf6633:      * This is called when we're building the SELECT list for the driving left join.
1:4cf6633:      * </p>
1:4cf6633:      */
1:757bc0e:     void    getColumnsFromList
1:757bc0e:         ( HashMap<String,ColumnReference> map, ResultColumnList rcl, int mergeTableID )
1:757bc0e:         throws StandardException
1:757bc0e:     {
1:757bc0e:         List<ColumnReference> colRefs = getColumnReferences( rcl );
1:757bc0e: 
1:757bc0e:         getColumnsFromList( map, colRefs, mergeTableID );
1:757bc0e:     }
1:757bc0e:     
1:757bc0e:     ///////////////////////////////////////////////////////////////////////////////////
1:757bc0e:     //
1:661c2e6:     // bind() BEHAVIOR
1:daffaee:     //
1:661c2e6:     ///////////////////////////////////////////////////////////////////////////////////
1:daffaee: 
1:661c2e6:     @Override
1:661c2e6: 	public void bindStatement() throws StandardException
1:daffaee: 	{
1:661c2e6:         DataDictionary  dd = getDataDictionary();
1:daffaee: 
1:3511a12:         // source table must be a vti or base table
1:3511a12:         if (
1:3511a12:             !(_sourceTable instanceof FromVTI) &&
1:3511a12:             !(_sourceTable instanceof FromBaseTable)
1:3511a12:             )
1:daffaee:         {
1:57f53e3:             throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_OR_VTI );
1:daffaee:         }
1:daffaee: 
1:3511a12:         // source and target may not have the same correlation names
1:3511a12:         if ( getExposedName( _targetTable ).equals( getExposedName( _sourceTable ) ) )
1:b3f38f8:         {
1:3511a12:             throw StandardException.newException( SQLState.LANG_SAME_EXPOSED_NAME );
1:daffaee:         }
1:daffaee: 
1:3cc631b:         // don't allow derived column lists right now
1:3cc631b:         forbidDerivedColumnLists();
1:daffaee:         
1:b3f38f8:         // synonyms not allowed
1:eab88ec:         forbidSynonyms();
1:daffaee: 
1:daffaee:         //
1:daffaee:         // Don't add any privileges until we bind the matching clauses.
1:daffaee:         //
1:daffaee:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:daffaee:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:daffaee:             
1:3511a12:         FromList    dfl = new FromList( getContextManager() );
1:b3f38f8:         FromTable   dflSource = cloneFromTable( _sourceTable );
1:b3f38f8:         FromBaseTable   dflTarget = (FromBaseTable) cloneFromTable( _targetTable );
1:b3f38f8:         dfl.addFromTable( dflSource );
1:b3f38f8:         dfl.addFromTable( dflTarget );
1:3511a12:         dfl.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
1:daffaee: 
1:3511a12:         // target table must be a base table
1:b3f38f8:         if ( !targetIsBaseTable( dflTarget ) ) { notBaseTable(); }
1:bbd6aff: 
1:daffaee:         // ready to add permissions
1:daffaee:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:daffaee: 
1:1cd5dd1:         for ( MatchingClauseNode mcn : _matchingClauses )
1:2f8e6fb:         {
1:b3f38f8:             FromList    dummyFromList = cloneFromList( dd, dflTarget );
1:b3f38f8:             FromBaseTable   dummyTargetTable = (FromBaseTable) dummyFromList.elementAt( TARGET_TABLE_INDEX );
1:508a010:             mcn.bind( dd, this, dummyFromList, dummyTargetTable );
1:ed8967c: 
1:ed8967c:             // window function not allowed
1:ed8967c:             SelectNode.checkNoWindowFunctions(mcn, "matching clause");
1:843145a: 
1:843145a:             // aggregates not allowed
1:843145a:             checkNoAggregates(mcn);
1:3e77b5a:         }
1:3e77b5a:         
1:508a010:         bindLeftJoin( dd );
1:2f8e6fb: 	}
1:843145a: 
1:3cc631b: 
1:843145a:     static void checkNoAggregates(QueryTreeNode clause)
1:843145a:             throws StandardException {
1:843145a: 
1:843145a:         // Clause cannot contain window aggregates except inside subqueries
1:843145a:         HasNodeVisitor visitor = new HasNodeVisitor(AggregateNode.class,
1:843145a:                                                     SubqueryNode.class);
1:843145a:         clause.accept(visitor);
1:843145a: 
1:843145a:         if (visitor.hasNode()) {
1:843145a:             throw StandardException.newException(
1:843145a:                     SQLState.LANG_NO_AGGREGATES_IN_MERGE_MATCHING_CLAUSE);
1:843145a:         }
1:843145a:     }
1:843145a: 
1:843145a: 
1:757bc0e:     /////////////////////////////////////
1:757bc0e:     //
1:757bc0e:     // TABLE AND CORRELATION CHECKS
1:757bc0e:     //
1:757bc0e:     /////////////////////////////////////
1:b3f38f8: 
1:661c2e6:     /** Get the exposed name of a FromTable */
1:661c2e6:     private String  getExposedName( FromTable ft ) throws StandardException
1:2f8e6fb:     {
1:661c2e6:         return ft.getTableName().getTableName();
1:2f8e6fb:     }
1:2f8e6fb: 
1:d043e29:     @Override
1:d043e29:     public boolean referencesSessionSchema() throws StandardException {
1:d043e29:         return _sourceTable.referencesSessionSchema()
1:d043e29:                 || _targetTable.referencesSessionSchema()
1:d043e29:                 || _searchCondition.referencesSessionSchema()
1:d043e29:                 || _matchingClauses.referencesSessionSchema();
1:d043e29:     }
1:d043e29: 
1:ddfefeb:     /**
1:3cc631b:      *<p>
1:3cc631b:      * Because of name resolution complexities, we do not allow derived column lists
1:3cc631b:      * on source or target tables. These lists arise in queries like the following:
1:3cc631b:      * </p>
1:3cc631b:      *
1:3cc631b:      * <pre>
1:3cc631b:      * merge into t1 r( x )
1:3cc631b:      * using t2 on r.x = t2.a
1:3cc631b:      * when matched then delete;
1:3cc631b:      * 
1:3cc631b:      * merge into t1
1:3cc631b:      * using t2 r( x ) on t1.a = r.x
1:3cc631b:      * when matched then delete;
1:3cc631b:      * </pre>
1:3cc631b:      */
1:3cc631b:     private void    forbidDerivedColumnLists() throws StandardException
1:3cc631b:     {
1:11f7ee3:         if ( (_sourceTable.getResultColumns() != null) || (_targetTable.getResultColumns() != null) )
1:3cc631b:         {
1:3cc631b:             throw StandardException.newException( SQLState.LANG_NO_DCL_IN_MERGE );
1:3cc631b:         }
1:3cc631b:     }
1:3cc631b: 
1:b3f38f8:     /** Neither the source nor the target table may be a synonym */
1:eab88ec:     private void forbidSynonyms() throws StandardException
1:2f8e6fb:     {
1:eab88ec:         forbidSynonyms(_targetTable.getTableNameField().cloneMe());
1:b3f38f8:         if ( _sourceTable instanceof FromBaseTable )
1:2945dbb:         {
1:eab88ec:             forbidSynonyms(
1:eab88ec:                 ((FromBaseTable) _sourceTable).getTableNameField().cloneMe());
1:2f8e6fb:         }
1:2f8e6fb:     }
1:eab88ec: 
1:eab88ec:     private void forbidSynonyms(TableName tableName) throws StandardException
1:1cd5dd1:     {
1:eab88ec:         tableName.bind();
1:2f8e6fb: 
1:b3f38f8:         TableName   synonym = resolveTableToSynonym( tableName );
1:b3f38f8:         if ( synonym != null )
1:1cd5dd1:         {
1:b3f38f8:             throw StandardException.newException( SQLState.LANG_NO_SYNONYMS_IN_MERGE );
1:1cd5dd1:         }
1:1cd5dd1:     }
1:2f8e6fb: 
1:757bc0e:     /** Throw a "not base table" exception */
1:757bc0e:     private void    notBaseTable()  throws StandardException
1:757bc0e:     {
1:757bc0e:         throw StandardException.newException( SQLState.LANG_TARGET_NOT_BASE_TABLE );
1:757bc0e:     }
1:757bc0e: 
1:757bc0e:     /** Return true if the target table is a base table */
1:757bc0e:     private boolean targetIsBaseTable( FromBaseTable targetTable ) throws StandardException
1:757bc0e:     {
1:757bc0e:         FromBaseTable   fbt = targetTable;
1:757bc0e:         TableDescriptor desc = fbt.getTableDescriptor();
1:757bc0e:         if ( desc == null ) { return false; }
1:757bc0e: 
1:757bc0e:         switch( desc.getTableType() )
1:757bc0e:         {
1:757bc0e:         case TableDescriptor.BASE_TABLE_TYPE:
1:757bc0e:         case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:
1:757bc0e:             return true;
1:757bc0e: 
1:757bc0e:         default:
1:757bc0e:             return false;
1:757bc0e:         }
1:757bc0e:     }
1:757bc0e: 
1:757bc0e:     /** Return true if the source table is a base table, view, or table function */
1:57f53e3:     private boolean sourceIsBase_or_VTI() throws StandardException
1:757bc0e:     {
1:757bc0e:         if ( _sourceTable instanceof FromVTI ) { return true; }
1:757bc0e:         if ( !( _sourceTable instanceof FromBaseTable) ) { return false; }
1:757bc0e: 
1:757bc0e:         FromBaseTable   fbt = (FromBaseTable) _sourceTable;
1:757bc0e:         TableDescriptor desc = fbt.getTableDescriptor();
1:757bc0e:         if ( desc == null ) { return false; }
1:757bc0e: 
1:757bc0e:         switch( desc.getTableType() )
1:757bc0e:         {
1:757bc0e:         case TableDescriptor.BASE_TABLE_TYPE:
1:757bc0e:         case TableDescriptor.SYSTEM_TABLE_TYPE:
1:757bc0e:         case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:
1:757bc0e:             return true;
1:757bc0e: 
1:757bc0e:         default:
1:757bc0e:             return false;
1:757bc0e:         }
1:757bc0e:     }
1:757bc0e: 
1:757bc0e:     ///////////////////////////
1:757bc0e:     //
1:757bc0e:     // BINDING THE LEFT JOIN
1:757bc0e:     //
1:757bc0e:     ///////////////////////////
1:757bc0e: 
1:1cd5dd1:     /**
1:508a010:      * Bind the driving left join select.
1:508a010:      * Stuffs the left join SelectNode into the resultSet variable.
1:3511a12:      */
1:508a010:     private void    bindLeftJoin( DataDictionary dd )   throws StandardException
1:1cd5dd1:     {
1:508a010:         CompilerContext cc = getCompilerContext();
1:508a010:         final int previousReliability = cc.getReliability();
1:2f8e6fb:         
1:daffaee:         try {
1:daffaee:             cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
1:2945dbb: 
1:757bc0e:             //
1:daffaee:             // Don't add any privileges until we bind the matching refinement clauses.
1:daffaee:             //
1:daffaee:             IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:daffaee:             getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:1cd5dd1:             
1:01632c2:             _hojn = new HalfOuterJoinNode
1:2f8e6fb:                 (
1:508a010:                  _sourceTable,
1:508a010:                  _targetTable,
1:508a010:                  _searchCondition,
1:508a010:                  null,
1:508a010:                  false,
1:508a010:                  null,
1:508a010:                  getContextManager()
1:1cd5dd1:                  );
1:daffaee: 
1:01632c2:             _leftJoinFromList = _hojn.makeFromList( true, true );
1:508a010:             _leftJoinFromList.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
1:1cd5dd1: 
1:57f53e3:             if ( !sourceIsBase_or_VTI() )
1:3511a12:             {
1:57f53e3:                 throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_OR_VTI );
1:2945dbb:             }
1:1cd5dd1: 
1:508a010:             FromList    topFromList = new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() );
1:01632c2:             topFromList.addFromTable( _hojn );
1:daffaee: 
1:daffaee:             // ready to add permissions
1:daffaee:             getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:3511a12: 
1:508a010:             // preliminary binding of the matching clauses to resolve column
1:01632c2:             // references. this ensures that we can add all of the columns from
1:508a010:             // the matching refinements to the SELECT list of the left join.
1:508a010:             // we re-bind the matching clauses when we're done binding the left join
1:508a010:             // because, at that time, we have result set numbers needed for
1:508a010:             // code generation.
1:3511a12:             for ( MatchingClauseNode mcn : _matchingClauses )
1:3511a12:             {
1:508a010:                 mcn.bindRefinement( this, _leftJoinFromList );
1:3511a12:             }
1:3511a12: 
1:6ab1083:             ResultColumnList    selectList = buildSelectList();
1:77b6e85: 
1:01632c2:             // save a copy so that we can remap column references when generating the temporary rows
1:01632c2:             _selectList = selectList.copyListAndObjects();
1:3511a12: 
1:508a010:             resultSet = new SelectNode
1:1cd5dd1:                 (
2:2f8e6fb:                  selectList,
1:508a010:                  topFromList,
1:508a010:                  null,      // where clause
1:508a010:                  null,      // group by list
1:508a010:                  null,      // having clause
1:508a010:                  null,      // window list
1:508a010:                  null,      // optimizer plan override
1:508a010:                  getContextManager()
1:2f8e6fb:                  );
1:3511a12: 
1:508a010:             // Wrap the SELECT in a CursorNode in order to finish binding it.
1:508a010:             _leftJoinCursor = new CursorNode
1:1cd5dd1:                 (
1:508a010:                  "SELECT",
1:508a010:                  resultSet,
2:508a010:                  null,
1:508a010:                  null,
1:508a010:                  null,
1:508a010:                  null,
1:508a010:                  false,
1:508a010:                  CursorNode.READ_ONLY,
1:508a010:                  null,
1:d3347b5:                  true,
1:508a010:                  getContextManager()
1:2f8e6fb:                  );
1:3511a12:             
1:daffaee:             //
1:daffaee:             // We're only interested in privileges related to the ON clause.
1:daffaee:             // Otherwise, the driving left join should not contribute any
1:daffaee:             // privilege requirements.
1:daffaee:             //
1:daffaee:             getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:daffaee: 
1:508a010:             _leftJoinCursor.bindStatement();
1:daffaee:             
1:daffaee:             // ready to add permissions again
1:daffaee:             getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:757bc0e: 
1:daffaee:             // now figure out what privileges are needed for the ON clause
1:daffaee:             addOnClausePrivileges();
1:3511a12:         }
1:508a010:         finally
1:3511a12:         {
1:508a010:             // Restore previous compiler state
1:508a010:             cc.setReliability( previousReliability );
1:3511a12:         }
1:3511a12:     }
1:daffaee: 
1:757bc0e:     ////////////////////////////
1:757bc0e:     //
1:757bc0e:     // CLONING THE FROM LIST
1:757bc0e:     //
1:757bc0e:     ////////////////////////////
1:3511a12: 
1:757bc0e:     /** Create a FromList for binding a WHEN [ NOT ] MATCHED clause */
1:757bc0e:     private FromList    cloneFromList( DataDictionary dd, FromBaseTable targetTable )
1:daffaee:         throws StandardException
1:3511a12:     {
1:757bc0e:         FromList    dummyFromList = new FromList( getContextManager() );
1:757bc0e:         FromBaseTable   dummyTargetTable = new FromBaseTable
1:757bc0e:             (
1:757bc0e:              targetTable.getTableNameField(),
1:757bc0e:              targetTable.correlationName,
1:757bc0e:              null,
1:757bc0e:              null,
1:757bc0e:              getContextManager()
1:757bc0e:              );
1:757bc0e:         FromTable       dummySourceTable = cloneFromTable( _sourceTable );
1:3e77b5a: 
1:757bc0e:         dummyTargetTable.setMergeTableID( ColumnReference.MERGE_TARGET );
1:757bc0e:         dummySourceTable.setMergeTableID ( ColumnReference.MERGE_SOURCE );
1:757bc0e:         
1:757bc0e:         dummyFromList.addFromTable( dummySourceTable );
1:757bc0e:         dummyFromList.addFromTable( dummyTargetTable );
1:757bc0e:         
1:757bc0e:         //
1:757bc0e:         // Don't add any privileges while binding the tables.
1:757bc0e:         //
1:757bc0e:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:757bc0e:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:757bc0e:              
1:757bc0e:         dummyFromList.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
1:757bc0e: 
1:757bc0e:         // ready to add permissions
1:757bc0e:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:daffaee:         
1:757bc0e:         return dummyFromList;
1:b3f38f8:     }
1:daffaee: 
1:b3f38f8:     /** Clone a FromTable to avoid binding the original */
1:b3f38f8:     private FromTable   cloneFromTable( FromTable fromTable ) throws StandardException
1:b3f38f8:     {
1:b3f38f8:         if ( fromTable instanceof FromVTI )
1:b3f38f8:         {
1:b3f38f8:             FromVTI source = (FromVTI) fromTable;
1:3e77b5a: 
1:508a010:             return new FromVTI
1:1cd5dd1:                 (
1:508a010:                  source.methodCall,
1:508a010:                  source.correlationName,
1:11f7ee3:                  source.getResultColumns(),
1:b3f38f8:                  null,
1:508a010:                  source.exposedName,
1:b3f38f8:                  getContextManager()
1:b3f38f8:                  );
1:b3f38f8:         }
1:b3f38f8:         else if ( fromTable instanceof FromBaseTable )
1:b3f38f8:         {
1:b3f38f8:             FromBaseTable   source = (FromBaseTable) fromTable;
1:508a010:             return new FromBaseTable
1:3511a12:                 (
1:508a010:                  source.tableName,
1:508a010:                  source.correlationName,
1:b3f38f8:                  null,
1:508a010:                  null,
1:508a010:                  getContextManager()
1:1cd5dd1:                  );
1:b3f38f8:         }
1:2f8e6fb:         else
1:b3f38f8:         {
1:57f53e3:             throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_OR_VTI );
1:b3f38f8:         }
1:b3f38f8:     }
1:b3f38f8: 
1:757bc0e:     ///////////////////////////
1:1cd5dd1:     //
1:757bc0e:     // PRIVILEGE MANAGEMENT
1:757bc0e:     //
1:757bc0e:     ///////////////////////////
1:757bc0e: 
1:3511a12:     /**
1:1cd5dd1:      * <p>
1:daffaee:      * Add the privileges required by the ON clause.
1:daffaee:      * </p>
1:daffaee:      */
1:daffaee:     private void addOnClausePrivileges() throws StandardException
1:daffaee:     {
1:daffaee:         // add SELECT privilege on columns
1:daffaee:         for ( ColumnReference cr : getColumnReferences( _searchCondition ) )
1:daffaee:         {
1:daffaee:             addColumnPrivilege( cr );
1:daffaee:         }
1:daffaee:         
1:daffaee:         // add EXECUTE privilege on routines
1:daffaee:         for ( StaticMethodCallNode routine : getRoutineReferences( _searchCondition ) )
1:daffaee:         {
1:daffaee:             addRoutinePrivilege( routine );
1:daffaee:         }
1:18792e2: 
1:18792e2:         // add USAGE privilege on CASTs to user-defined types
1:18792e2:         for ( CastNode value : getCastNodes( _searchCondition ) )
1:18792e2:         {
1:18792e2:             addUDTUsagePriv( value );
1:18792e2:         }
1:daffaee:     }
1:daffaee: 
1:daffaee:     /**
1:daffaee:      * <p>
1:daffaee:      * Add SELECT privilege on the indicated column.
1:daffaee:      * </p>
1:daffaee:      */
1:daffaee:     private void    addColumnPrivilege( ColumnReference cr )
1:daffaee:         throws StandardException
1:daffaee:     {
1:daffaee:         CompilerContext cc = getCompilerContext();
1:daffaee:         ResultColumn    rc = cr.getSource();
1:daffaee:         
1:daffaee:         if ( rc != null )
1:daffaee:         {
1:daffaee:             ColumnDescriptor    colDesc = rc.getColumnDescriptor();
1:daffaee:             
1:daffaee:             if ( colDesc != null )
1:daffaee:             {
1:daffaee:                 cc.pushCurrentPrivType( Authorizer.SELECT_PRIV );
1:daffaee:                 cc.addRequiredColumnPriv( colDesc );
1:daffaee:                 cc.popCurrentPrivType();
1:daffaee:             }
1:daffaee:         }
1:daffaee:     }
1:daffaee: 
1:daffaee:     /**
1:daffaee:      * <p>
1:daffaee:      * Add EXECUTE privilege on the indicated routine.
1:daffaee:      * </p>
1:daffaee:      */
1:daffaee:     private void    addRoutinePrivilege( StaticMethodCallNode routine )
1:daffaee:         throws StandardException
1:daffaee:     {
1:daffaee:         CompilerContext cc = getCompilerContext();
1:daffaee:         
1:daffaee:         cc.pushCurrentPrivType( Authorizer.EXECUTE_PRIV );
1:daffaee:         cc.addRequiredRoutinePriv( routine.ad );
1:daffaee:         cc.popCurrentPrivType();
1:daffaee:     }
1:daffaee: 
1:757bc0e:     /** Get a list of CastNodes in an expression */
1:757bc0e:     private List<CastNode>   getCastNodes( QueryTreeNode expression )
1:757bc0e:         throws StandardException
1:757bc0e:     {
1:757bc0e:         CollectNodesVisitor<CastNode> getCNs =
1:757bc0e:             new CollectNodesVisitor<CastNode>(CastNode.class);
1:757bc0e: 
1:757bc0e:         expression.accept(getCNs);
1:757bc0e:         
1:757bc0e:         return getCNs.getList();
1:757bc0e:     }
1:757bc0e: 
1:757bc0e:     /** Get a list of routines in an expression */
1:757bc0e:     private List<StaticMethodCallNode>   getRoutineReferences( QueryTreeNode expression )
1:757bc0e:         throws StandardException
1:757bc0e:     {
1:757bc0e:         CollectNodesVisitor<StaticMethodCallNode> getSMCNs =
1:757bc0e:             new CollectNodesVisitor<StaticMethodCallNode>(StaticMethodCallNode.class);
1:757bc0e: 
1:757bc0e:         expression.accept(getSMCNs);
1:757bc0e:         
1:757bc0e:         return getSMCNs.getList();
1:757bc0e:     }
1:757bc0e: 
1:757bc0e:     ///////////////////////////////
1:757bc0e:     //
1:757bc0e:     // BUILD THE SELECT LIST
1:4cf6633:     // FOR THE DRIVING LEFT JOIN.
1:757bc0e:     //
1:757bc0e:     ///////////////////////////////
1:757bc0e: 
1:757bc0e:     /** Build the select list for the left join */
1:757bc0e:     private ResultColumnList    buildSelectList() throws StandardException
1:757bc0e:     {
1:757bc0e:         HashMap<String,ColumnReference> drivingColumnMap = new HashMap<String,ColumnReference>();
1:757bc0e:         getColumnsInExpression( drivingColumnMap, _searchCondition, ColumnReference.MERGE_UNKNOWN );
1:757bc0e:         
1:757bc0e:         for ( MatchingClauseNode mcn : _matchingClauses )
1:757bc0e:         {
1:757bc0e:             mcn.getColumnsInExpressions( this, drivingColumnMap );
1:757bc0e: 
1:757bc0e:             int mergeTableID = mcn.isDeleteClause() ? ColumnReference.MERGE_TARGET : ColumnReference.MERGE_UNKNOWN;
1:757bc0e:             getColumnsFromList( drivingColumnMap, mcn.getThenColumns(), mergeTableID );
1:757bc0e:         }
1:757bc0e: 
1:757bc0e:         ResultColumnList    selectList = new ResultColumnList( getContextManager() );
1:757bc0e: 
1:757bc0e:         // add all of the columns from the source table which are mentioned
1:757bc0e:         addColumns
1:757bc0e:             (
1:757bc0e:              (FromTable) _leftJoinFromList.elementAt( SOURCE_TABLE_INDEX ),
1:757bc0e:              drivingColumnMap,
1:757bc0e:              selectList,
1:757bc0e:              ColumnReference.MERGE_SOURCE
1:757bc0e:              );
1:757bc0e:         // add all of the columns from the target table which are mentioned
1:757bc0e:         addColumns
1:757bc0e:             (
1:757bc0e:              (FromTable) _leftJoinFromList.elementAt( TARGET_TABLE_INDEX ),
1:757bc0e:              drivingColumnMap,
1:757bc0e:              selectList,
1:757bc0e:              ColumnReference.MERGE_TARGET
1:757bc0e:              );
1:757bc0e: 
1:757bc0e:         addTargetRowLocation( selectList );
1:757bc0e: 
1:757bc0e:         return selectList;
1:757bc0e:     }
1:757bc0e: 
1:757bc0e:     /** Add the target table's row location to the left join's select list */
1:757bc0e:     private void    addTargetRowLocation( ResultColumnList selectList )
1:757bc0e:         throws StandardException
1:757bc0e:     {
1:757bc0e:         // tell the target table to generate a row location column
1:757bc0e:         _targetTable.setRowLocationColumnName( TARGET_ROW_LOCATION_NAME );
1:757bc0e: 
1:757bc0e:         TableName   fromTableName = _targetTable.getTableName();
1:757bc0e:         ColumnReference cr = new ColumnReference
1:757bc0e:                 ( TARGET_ROW_LOCATION_NAME, fromTableName, getContextManager() );
1:757bc0e:         cr.setMergeTableID( ColumnReference.MERGE_TARGET );
1:757bc0e:         ResultColumn    rowLocationColumn = new ResultColumn( (String) null, cr, getContextManager() );
1:757bc0e:         rowLocationColumn.markGenerated();
1:757bc0e: 
1:757bc0e:         selectList.addResultColumn( rowLocationColumn );
1:757bc0e:     }
1:757bc0e: 
1:daffaee:     /**
1:daffaee:      * <p>
1:508a010:      * Add to an evolving select list the columns from the indicated table.
1:3511a12:      * </p>
2:508a010:      */
1:508a010:     private void    addColumns
1:2f8e6fb:         (
1:508a010:          FromTable  fromTable,
1:508a010:          HashMap<String,ColumnReference> drivingColumnMap,
1:2f8e6fb:          ResultColumnList   selectList,
1:2f8e6fb:          int    mergeTableID
2:3511a12:          )
1:daffaee:         throws StandardException
1:3511a12:     {
1:3e77b5a:         String[]    columnNames = getColumns( mergeTableID, drivingColumnMap );
1:b3f38f8:         TableName   tableName = fromTable.getTableName();
1:daffaee: 
1:508a010:         for ( int i = 0; i < columnNames.length; i++ )
1:3511a12:         {
1:508a010:             ColumnReference cr = new ColumnReference
1:b3f38f8:                 ( columnNames[ i ], tableName, getContextManager() );
1:2f8e6fb:             cr.setMergeTableID( mergeTableID );
1:508a010:             ResultColumn    rc = new ResultColumn( (String) null, cr, getContextManager() );
1:508a010:             selectList.addResultColumn( rc );
1:daffaee:         }
1:3511a12:     }
1:daffaee: 
1:508a010:     /** Get the column names from the table with the given table number, in sorted order */
1:3e77b5a:     private String[]    getColumns( int mergeTableID, HashMap<String,ColumnReference> map )
1:3511a12:     {
1:77b6e85:         HashSet<String>     set = new HashSet<String>();
1:daffaee: 
1:508a010:         for ( ColumnReference cr : map.values() )
1:6ab1083:         {
1:77b6e85:             if ( cr.getMergeTableID() == mergeTableID ) { set.add( cr.getColumnName() ); }
1:3511a12:         }
1:b3f38f8: 
1:77b6e85:         String[]    retval = new String[ set.size() ];
1:77b6e85:         set.toArray( retval );
1:508a010:         Arrays.sort( retval );
1:b3f38f8: 
1:508a010:         return retval;
1:6ab1083:     }
1:b3f38f8:     
1:daffaee:     /** Get a list of column references in an expression */
1:daffaee:     private List<ColumnReference>   getColumnReferences( QueryTreeNode expression )
1:daffaee:         throws StandardException
1:daffaee:     {
1:3511a12:         CollectNodesVisitor<ColumnReference> getCRs =
1:3511a12:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1:2f8e6fb: 
1:3511a12:         expression.accept(getCRs);
1:daffaee:         
1:daffaee:         return getCRs.getList();
1:6ab1083:     }
1:3511a12: 
1:757bc0e:     /** Add a list of columns to the the evolving map */
2:508a010:     private void    getColumnsFromList
1:2f8e6fb:         ( HashMap<String,ColumnReference> map, List<ColumnReference> colRefs, int mergeTableID )
1:2f8e6fb:         throws StandardException
1:3511a12:     {
1:3511a12:         for ( ColumnReference cr : colRefs )
1:3511a12:         {
1:2f8e6fb:             addColumn( map, cr, mergeTableID );
1:3511a12:         }
1:3511a12:     }
1:3511a12: 
1:6ab1083:     /** Add a column to the evolving map of referenced columns */
1:6ab1083:     void    addColumn
1:3511a12:         (
1:6ab1083:          HashMap<String,ColumnReference> map,
1:30e18db:          ColumnReference    cr,
1:2f8e6fb:          int    mergeTableID
1:3511a12:          )
1:1cd5dd1:         throws StandardException
1:3511a12:     {
1:3e77b5a:         if ( cr.getTableName() == null )
1:6ab1083:         {
1:4fc5f9c:             cr = cr.bindExpression(
1:4fc5f9c:                     _leftJoinFromList,
1:4fc5f9c:                     new SubqueryList(getContextManager()),
1:4fc5f9c:                     new ArrayList<AggregateNode>());
1:daffaee:             TableName       tableName = cr.getQualifiedTableName();
1:3e77b5a:             cr = new ColumnReference( cr.getColumnName(), tableName, getContextManager() );
1:3511a12:         }
1:2f8e6fb: 
1:3e77b5a:         associateColumn( _leftJoinFromList, cr, mergeTableID );
1:2f8e6fb: 
1:6ab1083:         String  key = makeDCMKey( cr.getTableName(), cr.getColumnName() );
1:3e77b5a: 
1:3e77b5a:         ColumnReference mapCR = map.get( key );
1:3e77b5a:         if ( mapCR != null )
1:3e77b5a:         {
1:3e77b5a:             mapCR.setMergeTableID( cr.getMergeTableID() );
1:3e77b5a:         }
1:3e77b5a:         else
1:6ab1083:         {
1:6ab1083:             map.put( key, cr );
1:3511a12:         }
1:6ab1083:     }
1:3511a12: 
1:508a010:     /** Make a HashMap key for a column in the driving column map of the LEFT JOIN */
1:508a010:     private String  makeDCMKey( String tableName, String columnName )
1:01632c2:     {
1:508a010:         return IdUtil.mkQualifiedName( tableName, columnName );
1:01632c2:     }
1:3511a12: 
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:3511a12:     //
1:508a010:     // optimize() BEHAVIOR
1:3511a12:     //
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:6ab1083: 
1:508a010:     @Override
1:508a010: 	public void optimizeStatement() throws StandardException
1:508a010: 	{
1:daffaee:         //
1:daffaee:         // Don't add any privileges during optimization.
1:daffaee:         //
1:daffaee:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:daffaee:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:daffaee:             
1:508a010: 		/* First optimize the left join */
1:508a010: 		_leftJoinCursor.optimizeStatement();
1:6ab1083: 
1:a19ac61:         //
1:a19ac61:         // No need to set lockMode in the master MergeNode. The individual
1:a19ac61:         // actions and the driving left-join will set their own lock modes.
1:a19ac61:         //
1:6ab1083: 
1:508a010:         // now optimize the INSERT/UPDATE/DELETE actions
1:01632c2:         for ( MatchingClauseNode mcn : _matchingClauses )
1:508a010:         {
1:508a010:             mcn.optimize();
1:01632c2:         }
1:daffaee:         
1:daffaee:         // ready to add permissions again
1:daffaee:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:508a010: 	}
1:01632c2:     
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:508a010:     //
1:508a010:     // generate() BEHAVIOR
1:508a010:     //
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:01632c2: 
1:508a010:     @Override
1:508a010:     void generate( ActivationClassBuilder acb, MethodBuilder mb )
1:3511a12: 							throws StandardException
1:01632c2: 	{
1:508a010:         int     clauseCount = _matchingClauses.size();
1:508a010: 
1:508a010: 		/* generate the parameters */
1:508a010: 		generateParameterValueSet(acb);
1:508a010: 
1:508a010:         acb.pushGetResultSetFactoryExpression( mb );
1:508a010: 
1:508a010:         // arg 1: the driving left join 
1:508a010:         _leftJoinCursor.generate( acb, mb );
1:508a010: 
1:6ab1083:         // dig up the actual result set which was generated and which will drive the MergeResultSet
1:6ab1083:         ScrollInsensitiveResultSetNode  sirs = (ScrollInsensitiveResultSetNode) _leftJoinCursor.resultSet;
1:6ab1083:         ResultSetNode   generatedScan = sirs.getChildResult();
1:6ab1083: 
1:508a010:         ConstantAction[]    clauseActions = new ConstantAction[ clauseCount ];
1:508a010:         for ( int i = 0; i < clauseCount; i++ )
1:508a010:         {
1:d043e29:             MatchingClauseNode mcn = _matchingClauses.elementAt(i);
1:508a010: 
1:6ab1083:             mcn.generate( acb, _selectList, generatedScan, _hojn, i );
1:508a010:             clauseActions[ i ] = mcn.makeConstantAction( acb );
1:508a010:         }
1:508a010:         _constantAction = getGenericConstantActionFactory().getMergeConstantAction( clauseActions );
1:508a010:         
1:508a010:         mb.callMethod
1:508a010:             ( VMOpcode.INVOKEINTERFACE, (String) null, "getMergeResultSet", ClassName.ResultSet, 1 );
1:508a010: 	}
1:508a010:     
1:508a010:     @Override
1:508a010:     public ConstantAction makeConstantAction() throws StandardException
3:508a010: 	{
1:508a010: 		return _constantAction;
3:508a010: 	}
1:508a010: 
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:508a010:     //
1:508a010:     // Visitable BEHAVIOR
1:508a010:     //
1:508a010:     ///////////////////////////////////////////////////////////////////////////////////
1:508a010: 
1:508a010: 	/**
1:508a010: 	 * Accept the visitor for all visitable children of this node.
1:508a010: 	 * 
1:508a010: 	 * @param v the visitor
1:508a010: 	 *
1:508a010: 	 * @exception StandardException on error
1:508a010: 	 */
1:508a010:     @Override
1:508a010: 	void acceptChildren(Visitor v)
1:3511a12: 		throws StandardException
1:508a010: 	{
1:508a010:         if ( _leftJoinCursor != null )
1:508a010:         {
1:508a010:             _leftJoinCursor.acceptChildren( v );
1:508a010:         }
2:508a010:         else
1:508a010:         {
1:508a010:             super.acceptChildren( v );
1:508a010: 
1:508a010:             _targetTable.accept( v );
1:508a010:             _sourceTable.accept( v );
1:508a010:             _searchCondition.accept( v );
1:508a010:         }
1:508a010:         
2:508a010:         for ( MatchingClauseNode mcn : _matchingClauses )
1:508a010:         {
1:508a010:             mcn.accept( v );
1:508a010:         }
1:508a010: 	}
1:508a010: 
2:508a010: 	/**
1:ddfefeb: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:ddfefeb: 	 * how tree printing is supposed to work.
1:ddfefeb: 	 *
1:ddfefeb: 	 * @param depth		The depth of this node in the tree
1:ddfefeb: 	 */
1:ddfefeb:     @Override
1:ddfefeb:     void printSubNodes( int depth )
1:ddfefeb: 	{
1:ddfefeb: 		if (SanityManager.DEBUG)
1:ddfefeb: 		{
1:ddfefeb: 			super.printSubNodes( depth );
1:ddfefeb: 
1:ddfefeb:             printLabel( depth, "targetTable: " );
1:ddfefeb:             _targetTable.treePrint( depth + 1 );
1:ddfefeb: 
1:ddfefeb:             printLabel( depth, "sourceTable: " );
1:ddfefeb:             _sourceTable.treePrint( depth + 1 );
1:ddfefeb: 
1:ddfefeb:             if ( _searchCondition != null )
1:ddfefeb:             {
1:ddfefeb:                 printLabel( depth, "searchCondition: " );
1:ddfefeb:                 _searchCondition.treePrint( depth + 1 );
1:ddfefeb:             }
1:ddfefeb: 
1:ddfefeb:             for ( MatchingClauseNode mcn : _matchingClauses )
1:ddfefeb:             {
1:ddfefeb:                 printLabel( depth, mcn.toString() );
1:ddfefeb:                 mcn.treePrint( depth + 1 );
1:ddfefeb:             }
1:ddfefeb: 		}
1:ddfefeb: 	}
1:ddfefeb: 
1:508a010:     @Override
1:508a010:     String statementToString()
1:508a010: 	{
1:508a010: 		return "MERGE";
1:508a010: 	}
1:508a010: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:d043e29
/////////////////////////////////////////////////////////////////////////
1:     private QueryTreeNodeVector<MatchingClauseNode> _matchingClauses;
/////////////////////////////////////////////////////////////////////////
1:          QueryTreeNodeVector<MatchingClauseNode> matchingClauses,
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     public boolean referencesSessionSchema() throws StandardException {
1:         return _sourceTable.referencesSessionSchema()
1:                 || _targetTable.referencesSessionSchema()
1:                 || _searchCondition.referencesSessionSchema()
1:                 || _matchingClauses.referencesSessionSchema();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:             MatchingClauseNode mcn = _matchingClauses.elementAt(i);
commit:4fc5f9c
/////////////////////////////////////////////////////////////////////////
1:             cr = cr.bindExpression(
1:                     _leftJoinFromList,
1:                     new SubqueryList(getContextManager()),
1:                     new ArrayList<AggregateNode>());
commit:eab88ec
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         forbidSynonyms();
/////////////////////////////////////////////////////////////////////////
1:     private void forbidSynonyms() throws StandardException
1:         forbidSynonyms(_targetTable.getTableNameField().cloneMe());
1:             forbidSynonyms(
1:                 ((FromBaseTable) _sourceTable).getTableNameField().cloneMe());
1: 
1:     private void forbidSynonyms(TableName tableName) throws StandardException
1:         tableName.bind();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:843145a
/////////////////////////////////////////////////////////////////////////
1: 
1:             // aggregates not allowed
1:             checkNoAggregates(mcn);
1: 
1:     static void checkNoAggregates(QueryTreeNode clause)
1:             throws StandardException {
1: 
1:         // Clause cannot contain window aggregates except inside subqueries
1:         HasNodeVisitor visitor = new HasNodeVisitor(AggregateNode.class,
1:                                                     SubqueryNode.class);
1:         clause.accept(visitor);
1: 
1:         if (visitor.hasNode()) {
1:             throw StandardException.newException(
1:                     SQLState.LANG_NO_AGGREGATES_IN_MERGE_MATCHING_CLAUSE);
1:         }
1:     }
1: 
1: 
commit:ed8967c
/////////////////////////////////////////////////////////////////////////
1: 
1:             // window function not allowed
1:             SelectNode.checkNoWindowFunctions(mcn, "matching clause");
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:57f53e3
/////////////////////////////////////////////////////////////////////////
1:             throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_OR_VTI );
/////////////////////////////////////////////////////////////////////////
1:     private boolean sourceIsBase_or_VTI() throws StandardException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if ( !sourceIsBase_or_VTI() )
1:                 throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_OR_VTI );
/////////////////////////////////////////////////////////////////////////
1:             throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_OR_VTI );
commit:4cf6633
/////////////////////////////////////////////////////////////////////////
1:  * The driving left join's selectList then looks like this...
1:  * </p>
1:  *
1:  * <pre>
1:  * sc1, ..., scN, tc1, ..., tcM, targetTable.RowLocation
1:  * </pre>
1:  *
1:  * <p>
1:  * Where sc1...scN are the columns we need from the source table (in alphabetical
1:  * order) and tc1...tcM are the columns we need from the target table (in alphabetical
1:  * order).
1:  * </p>
1:  *
1:  * <p>
/////////////////////////////////////////////////////////////////////////
1:  *
1:  * <p>
1:  * Name resolution was a particularly thorny problem. This is because name resolution
1:  * behaves differently for SELECTs and UPDATEs. In particular, while processing UPDATEs,
1:  * the compiler throws away name resolution information; this happens as a consequence
1:  * of work done on DERBY-1043. In the end, I had to invent more name resolution machinery
1:  * in order to compensate for the differences in the handling of SELECTs and UPDATEs.
1:  * If we are to allow subqueries in matching refinement clauses and in the values expressions
1:  * of INSERT and UPDATE actions, then we probably need to remove this special name
1:  * resolution machinery. And that, in turn, probably means revisiting DERBY-1043.
1:  * </p>
1:  *
1:  * <p>
1:  * The special name resolution machinery involves marking source and target column references
1:  * in order to make it clear which table they belong to. This is done in associateColumn(). The markers
1:  * are consulted at code-generation time in order to resolve column references when we
1:  * generate the expressions needed to populate the rows which go into the temporary tables.
1:  * That resolution happens in MatchingClauseNode.getSelectListOffset().
1:  * </p>
/////////////////////////////////////////////////////////////////////////
1:     //
1:     // Filled in by the constructor.
1:     //
1:     //
1:     // Filled in at bind() time.
1:     //
1:     //
1:     // Filled in at generate() time.
1:     //
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Associate a column with the SOURCE or TARGET table. This is
1:      * part of the special name resolution machinery which smooths over
1:      * the differences between name resolution for SELECTs and UPDATEs.
1:      * </p>
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Add the columns in the matchingRefinement clause to the evolving map.
1:      * This is called when we're building the SELECT list for the driving left join.
1:      * </p>
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Add a list of columns to the the evolving map.
1:      * This is called when we're building the SELECT list for the driving left join.
1:      * </p>
1:      */
/////////////////////////////////////////////////////////////////////////
1:     // FOR THE DRIVING LEFT JOIN.
commit:0ae3b6d
/////////////////////////////////////////////////////////////////////////
commit:757bc0e
/////////////////////////////////////////////////////////////////////////
1:  * the driving row are extracted and buffered in a temporary table (the "then" rows) specific to that
/////////////////////////////////////////////////////////////////////////
1:     // BIND-TIME ENTRY POINTS CALLED BY MatchingClauseNode
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Get the target table for the MERGE statement */
1:     FromBaseTable   getTargetTable() { return _targetTable; }
1: 
0:     /** Associate a column with the SOURCE or TARGET table */
1:     void    associateColumn( FromList fromList, ColumnReference cr, int mergeTableID )
1:         throws StandardException
1:     {
1:         if ( mergeTableID != ColumnReference.MERGE_UNKNOWN )    { cr.setMergeTableID( mergeTableID ); }
1:         else
1:         {
1:             // we have to figure out which table the column is in
1:             String  columnsTableName = cr.getTableName();
1: 
1:             if ( ((FromTable) fromList.elementAt( SOURCE_TABLE_INDEX )).getMatchingColumn( cr ) != null )
1:             {
1:                 cr.setMergeTableID( ColumnReference.MERGE_SOURCE );
1:             }
1:             else if ( ((FromTable) fromList.elementAt( TARGET_TABLE_INDEX )).getMatchingColumn( cr ) != null )
1:             {
1:                 cr.setMergeTableID( ColumnReference.MERGE_TARGET );
1:             }
1:         }
1: 
1:         // Don't raise an error if a column in another table is referenced and we
1:         // don't know how to handle it here. If the column is not in the SOURCE or TARGET
1:         // table, then it will be caught by other bind-time logic. Columns which ought
1:         // to be associated, but aren't, will be caught later on by MatchingClauseNode.getMergeTableID().
1:     }
1: 
1:     /** Boilerplate for binding an expression against a FromList */
1:     void bindExpression( ValueNode value, FromList fromList )
1:         throws StandardException
1:     {
1:         CompilerContext cc = getCompilerContext();
1:         final int previousReliability = cc.getReliability();
1: 
1:         cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
1:         cc.pushCurrentPrivType( Authorizer.SELECT_PRIV );
1:             
1:         try {
1:             // this adds SELECT priv on referenced columns and EXECUTE privs on referenced routines
1:             value.bindExpression
1:                 (
1:                  fromList,
1:                  new SubqueryList( getContextManager() ),
1:                  new ArrayList<AggregateNode>()
1:                  );
1:         }
1:         finally
1:         {
1:             // Restore previous compiler state
1:             cc.popCurrentPrivType();
1:             cc.setReliability( previousReliability );
1:         }
1:     }
1: 
0:     /** Add the columns in the matchingRefinement clause to the evolving map */
1:     void    getColumnsInExpression
1:         ( HashMap<String,ColumnReference> map, ValueNode expression, int mergeTableID )
1:         throws StandardException
1:     {
1:         if ( expression == null ) { return; }
1: 
1:         List<ColumnReference> colRefs = getColumnReferences( expression );
1: 
1:         getColumnsFromList( map, colRefs, mergeTableID );
1:     }
1: 
1:     /** Add a list of columns to the the evolving map */
1:     void    getColumnsFromList
1:         ( HashMap<String,ColumnReference> map, ResultColumnList rcl, int mergeTableID )
1:         throws StandardException
1:     {
1:         List<ColumnReference> colRefs = getColumnReferences( rcl );
1: 
1:         getColumnsFromList( map, colRefs, mergeTableID );
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
/////////////////////////////////////////////////////////////////////////
1:     /////////////////////////////////////
1:     //
1:     // TABLE AND CORRELATION CHECKS
1:     //
1:     /////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /** Throw a "not base table" exception */
1:     private void    notBaseTable()  throws StandardException
1:     {
1:         throw StandardException.newException( SQLState.LANG_TARGET_NOT_BASE_TABLE );
1:     }
1: 
1:     /** Return true if the target table is a base table */
1:     private boolean targetIsBaseTable( FromBaseTable targetTable ) throws StandardException
1:     {
1:         FromBaseTable   fbt = targetTable;
1:         TableDescriptor desc = fbt.getTableDescriptor();
1:         if ( desc == null ) { return false; }
1: 
1:         switch( desc.getTableType() )
1:         {
1:         case TableDescriptor.BASE_TABLE_TYPE:
1:         case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:
1:             return true;
1: 
1:         default:
1:             return false;
1:         }
1:     }
1: 
1:     /** Return true if the source table is a base table, view, or table function */
0:     private boolean sourceIsBase_View_or_VTI() throws StandardException
1:     {
1:         if ( _sourceTable instanceof FromVTI ) { return true; }
1:         if ( !( _sourceTable instanceof FromBaseTable) ) { return false; }
1: 
1:         FromBaseTable   fbt = (FromBaseTable) _sourceTable;
1:         TableDescriptor desc = fbt.getTableDescriptor();
1:         if ( desc == null ) { return false; }
1: 
1:         switch( desc.getTableType() )
1:         {
1:         case TableDescriptor.BASE_TABLE_TYPE:
1:         case TableDescriptor.SYSTEM_TABLE_TYPE:
1:         case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:
0:         case TableDescriptor.VIEW_TYPE:
1:             return true;
1: 
1:         default:
1:             return false;
1:         }
1:     }
1: 
1:     ///////////////////////////
1:     //
1:     // BINDING THE LEFT JOIN
1:     //
1:     ///////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     ////////////////////////////
1:     //
1:     // CLONING THE FROM LIST
1:     //
1:     ////////////////////////////
1:     /** Create a FromList for binding a WHEN [ NOT ] MATCHED clause */
1:     private FromList    cloneFromList( DataDictionary dd, FromBaseTable targetTable )
1:         FromList    dummyFromList = new FromList( getContextManager() );
1:         FromBaseTable   dummyTargetTable = new FromBaseTable
1:             (
1:              targetTable.getTableNameField(),
1:              targetTable.correlationName,
1:              null,
1:              null,
1:              getContextManager()
1:              );
1:         FromTable       dummySourceTable = cloneFromTable( _sourceTable );
1:         dummyTargetTable.setMergeTableID( ColumnReference.MERGE_TARGET );
1:         dummySourceTable.setMergeTableID ( ColumnReference.MERGE_SOURCE );
1:         
1:         dummyFromList.addFromTable( dummySourceTable );
1:         dummyFromList.addFromTable( dummyTargetTable );
1:         
1:         //
1:         // Don't add any privileges while binding the tables.
1:         //
1:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:              
1:         dummyFromList.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
1:         // ready to add permissions
1:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:         
1:         return dummyFromList;
/////////////////////////////////////////////////////////////////////////
1:     ///////////////////////////
1:     //
1:     // PRIVILEGE MANAGEMENT
1:     //
1:     ///////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     /** Get a list of CastNodes in an expression */
1:     private List<CastNode>   getCastNodes( QueryTreeNode expression )
1:         throws StandardException
1:     {
1:         CollectNodesVisitor<CastNode> getCNs =
1:             new CollectNodesVisitor<CastNode>(CastNode.class);
1: 
1:         expression.accept(getCNs);
1:         
1:         return getCNs.getList();
1:     }
1: 
1:     /** Get a list of routines in an expression */
1:     private List<StaticMethodCallNode>   getRoutineReferences( QueryTreeNode expression )
1:         throws StandardException
1:     {
1:         CollectNodesVisitor<StaticMethodCallNode> getSMCNs =
1:             new CollectNodesVisitor<StaticMethodCallNode>(StaticMethodCallNode.class);
1: 
1:         expression.accept(getSMCNs);
1:         
1:         return getSMCNs.getList();
1:     }
1: 
1:     ///////////////////////////////
1:     //
1:     // BUILD THE SELECT LIST
0:     // FOR THE DRIVING LEFT JOIN
1:     //
1:     ///////////////////////////////
1: 
1:     /** Build the select list for the left join */
1:     private ResultColumnList    buildSelectList() throws StandardException
1:     {
1:         HashMap<String,ColumnReference> drivingColumnMap = new HashMap<String,ColumnReference>();
1:         getColumnsInExpression( drivingColumnMap, _searchCondition, ColumnReference.MERGE_UNKNOWN );
1:         
1:         for ( MatchingClauseNode mcn : _matchingClauses )
1:         {
1:             mcn.getColumnsInExpressions( this, drivingColumnMap );
1: 
1:             int mergeTableID = mcn.isDeleteClause() ? ColumnReference.MERGE_TARGET : ColumnReference.MERGE_UNKNOWN;
1:             getColumnsFromList( drivingColumnMap, mcn.getThenColumns(), mergeTableID );
1:         }
1: 
1:         ResultColumnList    selectList = new ResultColumnList( getContextManager() );
1: 
1:         // add all of the columns from the source table which are mentioned
1:         addColumns
1:             (
1:              (FromTable) _leftJoinFromList.elementAt( SOURCE_TABLE_INDEX ),
1:              drivingColumnMap,
1:              selectList,
1:              ColumnReference.MERGE_SOURCE
1:              );
1:         // add all of the columns from the target table which are mentioned
1:         addColumns
1:             (
1:              (FromTable) _leftJoinFromList.elementAt( TARGET_TABLE_INDEX ),
1:              drivingColumnMap,
1:              selectList,
1:              ColumnReference.MERGE_TARGET
1:              );
1: 
1:         addTargetRowLocation( selectList );
1: 
1:         return selectList;
1:     }
1: 
1:     /** Add the target table's row location to the left join's select list */
1:     private void    addTargetRowLocation( ResultColumnList selectList )
1:         throws StandardException
1:     {
1:         // tell the target table to generate a row location column
1:         _targetTable.setRowLocationColumnName( TARGET_ROW_LOCATION_NAME );
1: 
1:         TableName   fromTableName = _targetTable.getTableName();
1:         ColumnReference cr = new ColumnReference
1:                 ( TARGET_ROW_LOCATION_NAME, fromTableName, getContextManager() );
1:         cr.setMergeTableID( ColumnReference.MERGE_TARGET );
1:         ResultColumn    rowLocationColumn = new ResultColumn( (String) null, cr, getContextManager() );
1:         rowLocationColumn.markGenerated();
1: 
1:         selectList.addResultColumn( rowLocationColumn );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
commit:77b6e85
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashSet;
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         HashSet<String>     set = new HashSet<String>();
1:             if ( cr.getMergeTableID() == mergeTableID ) { set.add( cr.getColumnName() ); }
1:         String[]    retval = new String[ set.size() ];
1:         set.toArray( retval );
commit:d3347b5
/////////////////////////////////////////////////////////////////////////
1:                  true,
commit:ddfefeb
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 */
1:     @Override
1:     void printSubNodes( int depth )
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes( depth );
1: 
1:             printLabel( depth, "targetTable: " );
1:             _targetTable.treePrint( depth + 1 );
1: 
1:             printLabel( depth, "sourceTable: " );
1:             _sourceTable.treePrint( depth + 1 );
1: 
1:             if ( _searchCondition != null )
1:             {
1:                 printLabel( depth, "searchCondition: " );
1:                 _searchCondition.treePrint( depth + 1 );
1:             }
1: 
1:             for ( MatchingClauseNode mcn : _matchingClauses )
1:             {
1:                 printLabel( depth, mcn.toString() );
1:                 mcn.treePrint( depth + 1 );
1:             }
1: 		}
1: 	}
1: 
commit:a19ac61
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // No need to set lockMode in the master MergeNode. The individual
1:         // actions and the driving left-join will set their own lock modes.
1:         //
commit:18792e2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // add USAGE privilege on CASTs to user-defined types
1:         for ( CastNode value : getCastNodes( _searchCondition ) )
1:         {
1:             addUDTUsagePriv( value );
1:         }
/////////////////////////////////////////////////////////////////////////
0:     /** Get a list of CastNodes in an expression */
0:     private List<CastNode>   getCastNodes( QueryTreeNode expression )
0:         CollectNodesVisitor<CastNode> getCNs =
0:             new CollectNodesVisitor<CastNode>(CastNode.class);
0:         expression.accept(getCNs);
0:         return getCNs.getList();
/////////////////////////////////////////////////////////////////////////
commit:daffaee
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.IgnoreFilter;
1: import org.apache.derby.iapi.sql.conn.Authorizer;
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Don't add any privileges until we bind the matching clauses.
1:         //
1:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:             
/////////////////////////////////////////////////////////////////////////
1:         // ready to add permissions
1:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1: 
/////////////////////////////////////////////////////////////////////////
1:         //
0:         // Don't add any privileges while binding the tables.
1:         //
1:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:              
1:         // ready to add permissions
1:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
1:         
/////////////////////////////////////////////////////////////////////////
1: 
1:             //
1:             // Don't add any privileges until we bind the matching refinement clauses.
1:             //
1:             IgnoreFilter    ignorePermissions = new IgnoreFilter();
1:             getCompilerContext().addPrivilegeFilter( ignorePermissions );
/////////////////////////////////////////////////////////////////////////
0:             // ready to add permissions
1:             getCompilerContext().removePrivilegeFilter( ignorePermissions );
1: 
/////////////////////////////////////////////////////////////////////////
1:             
1:             //
1:             // We're only interested in privileges related to the ON clause.
1:             // Otherwise, the driving left join should not contribute any
1:             // privilege requirements.
1:             //
1:             getCompilerContext().addPrivilegeFilter( ignorePermissions );
1: 
1:             
1:             // ready to add permissions again
1:             getCompilerContext().removePrivilegeFilter( ignorePermissions );
1: 
1:             // now figure out what privileges are needed for the ON clause
1:             addOnClausePrivileges();
/////////////////////////////////////////////////////////////////////////
1:      * Add the privileges required by the ON clause.
1:      * </p>
1:      */
1:     private void addOnClausePrivileges() throws StandardException
1:     {
0:         // now add USAGE priv on referenced types
0:         addUDTUsagePriv( getValueNodes( _searchCondition ) );
1: 
1:         // add SELECT privilege on columns
1:         for ( ColumnReference cr : getColumnReferences( _searchCondition ) )
1:         {
1:             addColumnPrivilege( cr );
1:         }
1:         
1:         // add EXECUTE privilege on routines
1:         for ( StaticMethodCallNode routine : getRoutineReferences( _searchCondition ) )
1:         {
1:             addRoutinePrivilege( routine );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Add SELECT privilege on the indicated column.
1:      * </p>
1:      */
1:     private void    addColumnPrivilege( ColumnReference cr )
1:         throws StandardException
1:     {
1:         CompilerContext cc = getCompilerContext();
1:         ResultColumn    rc = cr.getSource();
1:         
1:         if ( rc != null )
1:         {
1:             ColumnDescriptor    colDesc = rc.getColumnDescriptor();
1:             
1:             if ( colDesc != null )
1:             {
1:                 cc.pushCurrentPrivType( Authorizer.SELECT_PRIV );
1:                 cc.addRequiredColumnPriv( colDesc );
1:                 cc.popCurrentPrivType();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Add EXECUTE privilege on the indicated routine.
1:      * </p>
1:      */
1:     private void    addRoutinePrivilege( StaticMethodCallNode routine )
1:         throws StandardException
1:     {
1:         CompilerContext cc = getCompilerContext();
1:         
1:         cc.pushCurrentPrivType( Authorizer.EXECUTE_PRIV );
1:         cc.addRequiredRoutinePriv( routine.ad );
1:         cc.popCurrentPrivType();
1:     }
1: 
1:     /**
1:      * <p>
/////////////////////////////////////////////////////////////////////////
0:         List<ColumnReference> colRefs = getColumnReferences( expression );
1: 
0:         getColumnsFromList( map, colRefs, mergeTableID );
1:     }
1: 
0:     /** Get a list of ValueNodes in an expression */
0:     private List<ValueNode>   getValueNodes( QueryTreeNode expression )
1:         throws StandardException
1:     {
0:         CollectNodesVisitor<ValueNode> getVNs =
0:             new CollectNodesVisitor<ValueNode>(ValueNode.class);
1: 
0:         expression.accept(getVNs);
1:         
0:         return getVNs.getList();
1:     }
1: 
0:     /** Get a list of routines in an expression */
0:     private List<StaticMethodCallNode>   getRoutineReferences( QueryTreeNode expression )
1:         throws StandardException
1:     {
0:         CollectNodesVisitor<StaticMethodCallNode> getSMCNs =
0:             new CollectNodesVisitor<StaticMethodCallNode>(StaticMethodCallNode.class);
1: 
0:         expression.accept(getSMCNs);
1:         
0:         return getSMCNs.getList();
1:     }
1: 
1:     /** Get a list of column references in an expression */
1:     private List<ColumnReference>   getColumnReferences( QueryTreeNode expression )
1:         throws StandardException
1:     {
1:         
1:         return getCRs.getList();
/////////////////////////////////////////////////////////////////////////
0:         List<ColumnReference> colRefs = getColumnReferences( rcl );
/////////////////////////////////////////////////////////////////////////
1:             TableName       tableName = cr.getQualifiedTableName();
0:             if ( tableName == null ) { tableName = new TableName( null, rc.getTableName(), getContextManager() ); }
/////////////////////////////////////////////////////////////////////////
1:         cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
0:         cc.pushCurrentPrivType( Authorizer.SELECT_PRIV );
1:         try {
0:             // this adds SELECT priv on referenced columns and EXECUTE privs on referenced routines
1: 
0:             // now add USAGE priv on referenced types
0:             addUDTUsagePriv( getValueNodes( value ) );
0:             cc.popCurrentPrivType();
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Don't add any privileges during optimization.
1:         //
0:         IgnoreFilter    ignorePermissions = new IgnoreFilter();
0:         getCompilerContext().addPrivilegeFilter( ignorePermissions );
1:             
/////////////////////////////////////////////////////////////////////////
1:         
1:         // ready to add permissions again
0:         getCompilerContext().removePrivilegeFilter( ignorePermissions );
commit:3e77b5a
/////////////////////////////////////////////////////////////////////////
1: 
0:         dummyTargetTable.setMergeTableID( ColumnReference.MERGE_TARGET );
0:         dummySourceTable.setMergeTableID ( ColumnReference.MERGE_SOURCE );
1:         
/////////////////////////////////////////////////////////////////////////
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:         String[]    columnNames = getColumns( mergeTableID, drivingColumnMap );
/////////////////////////////////////////////////////////////////////////
1:     private String[]    getColumns( int mergeTableID, HashMap<String,ColumnReference> map )
0:             if ( cr.getMergeTableID() == mergeTableID ) { list.add( cr.getColumnName() ); }
/////////////////////////////////////////////////////////////////////////
0:     void    getColumnsFromList
/////////////////////////////////////////////////////////////////////////
1:         if ( cr.getTableName() == null )
1:         {
0:             ResultColumn    rc = _leftJoinFromList.bindColumnReference( cr );
0:             TableName       tableName = new TableName( null, rc.getTableName(), getContextManager() );
1:             cr = new ColumnReference( cr.getColumnName(), tableName, getContextManager() );
1:         }
1: 
1:         associateColumn( _leftJoinFromList, cr, mergeTableID );
1: 
1:         ColumnReference mapCR = map.get( key );
1:         if ( mapCR != null )
1:         {
1:             mapCR.setMergeTableID( cr.getMergeTableID() );
1:         }
1:         else
0:     void    associateColumn( FromList fromList, ColumnReference cr, int mergeTableID )
/////////////////////////////////////////////////////////////////////////
0:             if ( ((FromTable) fromList.elementAt( SOURCE_TABLE_INDEX )).getMatchingColumn( cr ) != null )
0:             else if ( ((FromTable) fromList.elementAt( TARGET_TABLE_INDEX )).getMatchingColumn( cr ) != null )
commit:30e18db
/////////////////////////////////////////////////////////////////////////
1:          ColumnReference    cr,
commit:bbd6aff
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         if ( (_sourceTable.getResultColumns() != null) || (_targetTable.getResultColumns() != null) )
/////////////////////////////////////////////////////////////////////////
1:                  source.getResultColumns(),
commit:3cc631b
/////////////////////////////////////////////////////////////////////////
1:         // don't allow derived column lists right now
1:         forbidDerivedColumnLists();
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *<p>
1:      * Because of name resolution complexities, we do not allow derived column lists
1:      * on source or target tables. These lists arise in queries like the following:
1:      * </p>
1:      *
1:      * <pre>
1:      * merge into t1 r( x )
1:      * using t2 on r.x = t2.a
1:      * when matched then delete;
1:      * 
1:      * merge into t1
1:      * using t2 r( x ) on t1.a = r.x
1:      * when matched then delete;
1:      * </pre>
1:      */
1:     private void    forbidDerivedColumnLists() throws StandardException
1:     {
0:         if ( (_sourceTable.resultColumns != null) || (_targetTable.resultColumns != null) )
1:         {
1:             throw StandardException.newException( SQLState.LANG_NO_DCL_IN_MERGE );
1:         }
1:     }
1: 
commit:b3f38f8
/////////////////////////////////////////////////////////////////////////
1:         // synonyms not allowed
0:         forbidSynonyms( dd );
1: 
1:         FromTable   dflSource = cloneFromTable( _sourceTable );
1:         FromBaseTable   dflTarget = (FromBaseTable) cloneFromTable( _targetTable );
1:         dfl.addFromTable( dflSource );
1:         dfl.addFromTable( dflTarget );
1:         if ( !targetIsBaseTable( dflTarget ) ) { notBaseTable(); }
1:             FromList    dummyFromList = cloneFromList( dd, dflTarget );
1:             FromBaseTable   dummyTargetTable = (FromBaseTable) dummyFromList.elementAt( TARGET_TABLE_INDEX );
/////////////////////////////////////////////////////////////////////////
0:     /** Create a FromList for binding a WHEN [ NOT ] MATCHED clause */
0:     private FromList    cloneFromList( DataDictionary dd, FromBaseTable targetTable )
1:         throws StandardException
1:     {
0:         FromList    dummyFromList = new FromList( getContextManager() );
0:         FromBaseTable   dummyTargetTable = new FromBaseTable
1:             (
0:              targetTable.getTableNameField(),
0:              targetTable.correlationName,
1:              null,
1:              null,
1:              getContextManager()
1:              );
0:         FromTable       dummySourceTable = cloneFromTable( _sourceTable );
1:         
0:         dummyFromList.addFromTable( dummySourceTable );
0:         dummyFromList.addFromTable( dummyTargetTable );
0:         dummyFromList.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
1: 
0:         return dummyFromList;
1:     }
1: 
1:     /** Neither the source nor the target table may be a synonym */
0:     private void    forbidSynonyms( DataDictionary dd )    throws StandardException
1:     {
0:         forbidSynonyms( dd, _targetTable.getTableNameField().cloneMe() );
1:         if ( _sourceTable instanceof FromBaseTable )
1:         {
0:             forbidSynonyms( dd, ((FromBaseTable)_sourceTable).getTableNameField().cloneMe() );
1:         }
1:     }
0:     private void    forbidSynonyms( DataDictionary dd, TableName tableName ) throws StandardException
1:     {
0:         tableName.bind( dd );
1: 
1:         TableName   synonym = resolveTableToSynonym( tableName );
1:         if ( synonym != null )
1:         {
1:             throw StandardException.newException( SQLState.LANG_NO_SYNONYMS_IN_MERGE );
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     /** Clone a FromTable to avoid binding the original */
1:     private FromTable   cloneFromTable( FromTable fromTable ) throws StandardException
1:         if ( fromTable instanceof FromVTI )
1:             FromVTI source = (FromVTI) fromTable;
/////////////////////////////////////////////////////////////////////////
1:         else if ( fromTable instanceof FromBaseTable )
1:             FromBaseTable   source = (FromBaseTable) fromTable;
/////////////////////////////////////////////////////////////////////////
1:         TableName   tableName = fromTable.getTableName();
1: 
1:                 ( columnNames[ i ], tableName, getContextManager() );
commit:2f8e6fb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:              _targetTable.getTableNameField(),
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         getColumnsInExpression( drivingColumnMap, _searchCondition, ColumnReference.MERGE_UNKNOWN );
1: 
0:             int mergeTableID = mcn.isDeleteClause() ? ColumnReference.MERGE_TARGET : ColumnReference.MERGE_UNKNOWN;
0:             getColumnsFromList( drivingColumnMap, mcn.getBufferedColumns(), mergeTableID );
0:         addColumns
1:             (
0:              (FromTable) _leftJoinFromList.elementAt( SOURCE_TABLE_INDEX ),
0:              drivingColumnMap,
1:              selectList,
0:              ColumnReference.MERGE_SOURCE
1:              );
0:         addColumns
1:             (
0:              (FromTable) _leftJoinFromList.elementAt( TARGET_TABLE_INDEX ),
0:              drivingColumnMap,
1:              selectList,
0:              ColumnReference.MERGE_TARGET
1:              );
/////////////////////////////////////////////////////////////////////////
0:         cr.setMergeTableID( ColumnReference.MERGE_TARGET );
/////////////////////////////////////////////////////////////////////////
1:          ResultColumnList   selectList,
1:          int    mergeTableID
/////////////////////////////////////////////////////////////////////////
1:             cr.setMergeTableID( mergeTableID );
/////////////////////////////////////////////////////////////////////////
0:         ( HashMap<String,ColumnReference> map, ValueNode expression, int mergeTableID )
/////////////////////////////////////////////////////////////////////////
0:         getColumnsFromList( map, colRefs, mergeTableID );
0:         ( HashMap<String,ColumnReference> map, ResultColumnList rcl, int mergeTableID )
/////////////////////////////////////////////////////////////////////////
0:         getColumnsFromList( map, colRefs, mergeTableID );
1:         ( HashMap<String,ColumnReference> map, List<ColumnReference> colRefs, int mergeTableID )
1:             addColumn( map, cr, mergeTableID );
/////////////////////////////////////////////////////////////////////////
0:          ColumnReference    originalCR,
1:          int    mergeTableID
0:         ColumnReference cr = originalCR;
1:         
/////////////////////////////////////////////////////////////////////////
0:         associateColumn( cr, mergeTableID );
0:         originalCR.setMergeTableID( cr.getMergeTableID() );
1: 
/////////////////////////////////////////////////////////////////////////
0:     /** Associate a column with the SOURCE or TARGET table */
0:     private void    associateColumn( ColumnReference cr, int mergeTableID )
1:         throws StandardException
1:     {
0:         if ( mergeTableID != ColumnReference.MERGE_UNKNOWN )    { cr.setMergeTableID( mergeTableID ); }
1:         else
1:         {
0:             // we have to figure out which table the column is in
0:             String  columnsTableName = cr.getTableName();
1: 
0:             if ( ((FromTable)_leftJoinFromList.elementAt( SOURCE_TABLE_INDEX )).getMatchingColumn( cr ) != null )
1:             {
0:                 cr.setMergeTableID( ColumnReference.MERGE_SOURCE );
1:             }
0:             else if ( ((FromTable)_leftJoinFromList.elementAt( TARGET_TABLE_INDEX )).getMatchingColumn( cr ) != null )
1:             {
0:                 cr.setMergeTableID( ColumnReference.MERGE_TARGET );
1:             }
1:         }
1: 
0:         // Don't raise an error if a column in another table is referenced and we
0:         // don't know how to handle it here. If the column is not in the SOURCE or TARGET
0:         // table, then it will be caught by other bind-time logic. Columns which ought
0:         // to be associated, but aren't, will be caught later on by MatchingClauseNode.getMergeTableID().
1:     }
1: 
commit:b0456a0
/////////////////////////////////////////////////////////////////////////
0:             TableName   origTableName = cr.getQualifiedTableName();
/////////////////////////////////////////////////////////////////////////
0:                     cr.setQualifiedTableName( newTableName );
commit:2945dbb
/////////////////////////////////////////////////////////////////////////
0:         switch( desc.getTableType() )
1:         {
0:         case TableDescriptor.BASE_TABLE_TYPE:
0:         case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:
0:             return true;
1: 
0:         default:
0:             return false;
1:         }
/////////////////////////////////////////////////////////////////////////
0:         case TableDescriptor.SYSTEM_TABLE_TYPE:
0:         case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:
commit:1cd5dd1
/////////////////////////////////////////////////////////////////////////
1:     public  static  final   int SOURCE_TABLE_INDEX = 0;
1:     public  static  final   int TARGET_TABLE_INDEX = 1;
1: 	private static  final   String  TARGET_ROW_LOCATION_NAME = "###TargetRowLocation";
/////////////////////////////////////////////////////////////////////////
0:         // Replace all references to correlation names with the actual
1:         
0:         replaceCorrelationName( _targetTable.correlationName, _targetTable.tableName );
0:         _targetTable.correlationName = null;
0:         if ( _sourceTable instanceof FromBaseTable )
1:         {
0:             TableName   sourceTableName = ((FromBaseTable) _sourceTable).tableName;
0:             replaceCorrelationName( _sourceTable.correlationName, sourceTableName );
0:             _sourceTable.correlationName = null;
1:         //
0:         // Bind the WHEN [ NOT ] MATCHED clauses.
1:         //
/////////////////////////////////////////////////////////////////////////
0:      * in all ColumnReferences under all expressions. If the correlation name is null,
0:      * then replace all references to the unqualified table name with the fully
0:      * qualified table name. This replacement is
0:      * done before the ColumnReferences are bound.
1:      * </p>
1:      */
0:     private void    replaceCorrelationName
1:         (
0:          String correlationName,
0:          TableName  newTableName
1:          )
1:         throws StandardException
1:     {
0:         if ( correlationName == null ) { correlationName = newTableName.getTableName(); }
1: 
0:         replaceCorrelationName
1:             (
0:              correlationName,
0:              newTableName,
0:              _searchCondition
1:              );
1:             
1:         for ( MatchingClauseNode mcn : _matchingClauses )
1:         {
0:             mcn.replaceCorrelationName
1:                 (
0:                  this,
0:                  correlationName,
0:                  newTableName
1:                  );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
0:      * Replace references to the correlation name with the underlying table name
commit:3511a12
/////////////////////////////////////////////////////////////////////////
1:         // source table must be a vti or base table
1:         if (
1:             !(_sourceTable instanceof FromVTI) &&
1:             !(_sourceTable instanceof FromBaseTable)
1:             )
1:         {
0:             throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_VIEW_OR_VTI );
1:         }
1: 
1:         // source and target may not have the same correlation names
1:         if ( getExposedName( _targetTable ).equals( getExposedName( _sourceTable ) ) )
1:         {
1:             throw StandardException.newException( SQLState.LANG_SAME_EXPOSED_NAME );
1:         }
1: 
1:         //
0:         // Replace all references to a target correlation name with the actual
0:         // resolved table name.
1:         //
1:         FromList    dfl = new FromList( getContextManager() );
0:         dfl.addFromTable( _sourceTable );
0:         dfl.addFromTable( _targetTable );
1:         dfl.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
0:         if ( _targetTable.correlationName != null )
1:         {
0:             TableName   targetTableName = _targetTable.tableName;
0:             String  correlationName = _targetTable.correlationName;
1:             
0:             replaceCorrelationName
1:                 (
0:                 correlationName,
0:                  targetTableName,
0:                  _searchCondition
0:                  );
1:             
1:             for ( MatchingClauseNode mcn : _matchingClauses )
1:             {
0:                 mcn.replaceCorrelationName
1:                     (
0:                      this,
0:                      correlationName,
0:                      targetTableName
0:                      );
1:             }
1: 
0:             _targetTable.correlationName = null;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // target table must be a base table
0:         if ( !targetIsBaseTable( _targetTable ) ) { notBaseTable(); }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
0:      * Replace references to the correlation name with the underlying table name
0:      * in all ColumnReferences under the indicated list of ResultColumns. This replacement is
0:      * done before the ColumnReferences are bound.
1:      * </p>
1:      */
0:     public  void    replaceCorrelationName
0:         (
0:          String correlationName,
0:          TableName  newTableName,
0:          ResultColumnList   rcl
1:          )
1:         throws StandardException
1:     {
0:         if ( rcl == null ) { return; }
1:         
0:         for ( int i = 0; i < rcl.size(); i++ )
1:         {
0:             replaceCorrelationName( correlationName, newTableName, rcl.elementAt( i ) );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
0:      * Replace references to the correlation name with the underlying table name
0:      * in all ColumnReferences in the indicated expression. This replacement is
0:      * done before the ColumnReferences are bound.
1:      * </p>
1:      */
0:     public  void    replaceCorrelationName
0:         (
0:          String correlationName,
0:          TableName  newTableName,
0:          ValueNode  expression
1:          )
1:         throws StandardException
1:     {
0:         if ( expression == null ) { return; }
1:         
1:         CollectNodesVisitor<ColumnReference> getCRs =
1:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
1: 
1:         expression.accept(getCRs);
0:         List<ColumnReference> colRefs = getCRs.getList();
1: 
1:         for ( ColumnReference cr : colRefs )
1:         {
0:             TableName   origTableName = cr.tableName;
0:             if ( origTableName != null )
1:             {
0:                 if (
0:                     (origTableName.getSchemaName() == null) &&
0:                     correlationName.equals( origTableName.getTableName() )
1:                     )
1:                 {
0:                     cr.setTableNameNode( newTableName );
1:                 }
1:             }
1:         }
1:     }
1: 
commit:6ab1083
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             ResultColumnList    selectList = buildSelectList();
1:             
/////////////////////////////////////////////////////////////////////////
0:     /** Get the target table for the MERGE statement */
0:     FromBaseTable   getTargetTable() { return _targetTable; }
1: 
/////////////////////////////////////////////////////////////////////////
0:         CollectNodesVisitor<ColumnReference> getCRs =
0:             new CollectNodesVisitor<ColumnReference>( ColumnReference.class );
0:         rcl.accept( getCRs );
0:         List<ColumnReference> colRefs = getCRs.getList();
/////////////////////////////////////////////////////////////////////////
0:             addColumn( map, cr );
1:         }
1:     }
1:     /** Add a column to the evolving map of referenced columns */
1:     void    addColumn
0:         (
1:          HashMap<String,ColumnReference> map,
0:          ColumnReference    cr
0:          )
0:         throws StandardException
1:     {
0:         if ( cr.getTableName() == null )
1:         {
0:             ResultColumn    rc = _leftJoinFromList.bindColumnReference( cr );
0:             TableName       tableName = new TableName( null, rc.getTableName(), getContextManager() );
0:             cr = new ColumnReference( cr.getColumnName(), tableName, getContextManager() );
1:         }
1: 
1:         String  key = makeDCMKey( cr.getTableName(), cr.getColumnName() );
0:         if ( map.get( key ) == null )
1:         {
1:             map.put( key, cr );
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // dig up the actual result set which was generated and which will drive the MergeResultSet
1:         ScrollInsensitiveResultSetNode  sirs = (ScrollInsensitiveResultSetNode) _leftJoinCursor.resultSet;
1:         ResultSetNode   generatedScan = sirs.getChildResult();
1: 
1:             mcn.generate( acb, _selectList, generatedScan, _hojn, i );
commit:01632c2
/////////////////////////////////////////////////////////////////////////
1:     private ResultColumnList    _selectList;
1:     private HalfOuterJoinNode   _hojn;
/////////////////////////////////////////////////////////////////////////
0:             mcn.bindResultSetNumbers( this, _leftJoinFromList );
0:             if ( mcn.isUpdateClause() )
/////////////////////////////////////////////////////////////////////////
1:             _hojn = new HalfOuterJoinNode
/////////////////////////////////////////////////////////////////////////
1:             _leftJoinFromList = _hojn.makeFromList( true, true );
/////////////////////////////////////////////////////////////////////////
1:             topFromList.addFromTable( _hojn );
1:             // references. this ensures that we can add all of the columns from
/////////////////////////////////////////////////////////////////////////
1:             // save a copy so that we can remap column references when generating the temporary rows
1:             _selectList = selectList.copyListAndObjects();
1: 
0:                 mcn.bindThenColumns( _selectList );
/////////////////////////////////////////////////////////////////////////
1:         for ( MatchingClauseNode mcn : _matchingClauses )
1:         {
0:             if ( mcn.isUpdateClause() )
1:             {
0:                 throw StandardException.newException( SQLState.NOT_IMPLEMENTED, "MERGE" );
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:             mcn.generate( acb, _selectList, _hojn, i );
commit:508a010
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
1: import java.util.HashMap;
1: import java.util.List;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;
1: import org.apache.derby.iapi.sql.execute.ConstantAction;
1: import org.apache.derby.iapi.util.IdUtil;
1:  * A MergeNode represents a MERGE statement. The statement looks like
1:  * this...
1:  * MERGE INTO targetTable
1:  * USING sourceTable
1:  * ON searchCondition
1:  * matchingClause1 ... matchingClauseN
1:  *
1:  * <p>
1:  * ...where each matching clause looks like this...
1:  * </p>
1:  *
1:  * <pre>
1:  * WHEN MATCHED [ AND matchingRefinement ] THEN DELETE
1:  * </pre>
1:  *
1:  * <p>
1:  * ...or
1:  * </p>
1:  *
1:  * <pre>
1:  * WHEN MATCHED [ AND matchingRefinement ] THEN UPDATE SET col1 = expr1, ... colM = exprM
1:  * </pre>
1:  *
1:  * <p>
1:  * ...or
1:  * </p>
1:  *
1:  * <pre>
1:  * WHEN NOT MATCHED [ AND matchingRefinement ] THEN INSERT columnList VALUES valueList
1:  * </pre>
1:  *
1:  * <p>
1:  * The Derby compiler essentially rewrites this statement into a driving left join
1:  * followed by a series of DELETE/UPDATE/INSERT actions. The left join looks like
1:  * this:
1:  * </p>
1:  *
1:  * <pre>
1:  * SELECT selectList FROM sourceTable LEFT OUTER JOIN targetTable ON searchCondition
1:  * </pre>
1:  *
1:  * <p>
1:  * The selectList of the driving left join consists of the following:
1:  * </p>
1:  *
1:  * <ul>
1:  * <li>All of the columns mentioned in the searchCondition.</li>
1:  * <li>All of the columns mentioned in the matchingRefinement clauses.</li>
1:  * <li>All of the columns mentioned in the SET clauses and the INSERT columnLists and valueLists.</li>
1:  * <li>All additional columns needed for the triggers and foreign keys fired by the DeleteResultSets
1:  * and UpdateResultSets constructed for the WHEN MATCHED clauses.</li>
1:  * <li>All additional columns needed to build index rows and evaluate generated columns
1:  * needed by the UpdateResultSets constructed for the WHEN MATCHED...THEN UPDATE clauses.</li>
1:  * <li>A trailing targetTable.RowLocation column.</li>
1:  * </ul>
1:  *
1:  * <p>
1:  * The matchingRefinement expressions are bound and generated against the
1:  * FromList of the driving left join. Dummy DeleteNode, UpdateNode, and InsertNode
1:  * statements are independently constructed in order to bind and generate the DELETE/UPDATE/INSERT
1:  * actions.
1:  * </p>
1:  *
1:  * <p>
1:  * At execution time, the targetTable.RowLocation column is used to determine
1:  * whether a given driving row matches. The row matches iff targetTable.RowLocation is not null.
1:  * The driving row is then assigned to the
1:  * first DELETE/UPDATE/INSERT action to which it applies. The relevant columns from
0:  * the driving row are extracted and buffered in a temporary table specific to that
1:  * DELETE/UPDATE/INSERT action. After the driving left join has been processed,
1:  * the DELETE/UPDATE/INSERT actions are run in order, each taking its corresponding
1:  * temporary table as its source ResultSet.
1:  * </p>
/////////////////////////////////////////////////////////////////////////
0:     private static  final   int SOURCE_TABLE_INDEX = 0;
0:     private static  final   int TARGET_TABLE_INDEX = 1;
1: 
0: 	private static final String TARGET_ROW_LOCATION_NAME = "###TargetRowLocation";
1: 
0:     // constructor args
1:     private FromBaseTable   _targetTable;
0:     // filled in at bind() time
1:     private FromList                _leftJoinFromList;
1: 
0:     // filled in at generate() time
1:     private ConstantAction      _constantAction;
1:     private CursorNode          _leftJoinCursor;
1: 
/////////////////////////////////////////////////////////////////////////
1:         super( null, null, cm );
1:         if ( !( targetTable instanceof FromBaseTable) ) { notBaseTable(); }
1:         else { _targetTable = (FromBaseTable) targetTable; }
1:         
/////////////////////////////////////////////////////////////////////////
0:         FromList    dummyFromList = new FromList( getContextManager() );
0:         FromBaseTable   dummyTargetTable = new FromBaseTable
0:             (
0:              _targetTable.tableName,
0:              _targetTable.correlationName,
1:              null,
1:              null,
1:              getContextManager()
0:              );
0:         FromTable       dummySourceTable = cloneSourceTable();
1:         
0:         if ( getExposedName( dummyTargetTable ).equals( getExposedName( dummySourceTable ) ) )
0:         dummyFromList.addFromTable( dummySourceTable );
0:         dummyFromList.addFromTable( dummyTargetTable );
0:         dummyFromList.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
1:         
0:         if ( !targetIsBaseTable( dummyTargetTable ) ) { notBaseTable(); }
1: 
1:             mcn.bind( dd, this, dummyFromList, dummyTargetTable );
1:         
1:         bindLeftJoin( dd );
0:         // re-bind the matchingRefinement clauses now that we have result set numbers
0:         // from the driving left join.
1:         for ( MatchingClauseNode mcn : _matchingClauses )
1:         {
1:             mcn.bindRefinement( this, _leftJoinFromList );
1:         }
1:         
1:         for ( MatchingClauseNode mcn : _matchingClauses )
1:         {
0:             if ( mcn.isUpdateClause() || mcn.isInsertClause() )
1:             {
0:                 throw StandardException.newException( SQLState.NOT_IMPLEMENTED, "MERGE" );
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Bind the driving left join select.
1:      * Stuffs the left join SelectNode into the resultSet variable.
1:      */
1:     private void    bindLeftJoin( DataDictionary dd )   throws StandardException
1:         CompilerContext cc = getCompilerContext();
1:         final int previousReliability = cc.getReliability();
1:         
0:         try {
0:             cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
1:             
0:             HalfOuterJoinNode   hojn = new HalfOuterJoinNode
0:                 (
1:                  _sourceTable,
1:                  _targetTable,
1:                  _searchCondition,
1:                  null,
1:                  false,
1:                  null,
1:                  getContextManager()
0:                  );
0:             _leftJoinFromList = hojn.makeFromList( true, true );
1:             _leftJoinFromList.bindTables( dd, new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() ) );
1: 
0:             if ( !sourceIsBase_View_or_VTI() )
1:             {
0:                 throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_VIEW_OR_VTI );
1:             }
1: 
1:             FromList    topFromList = new FromList( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() );
0:             topFromList.addFromTable( hojn );
1: 
1:             // preliminary binding of the matching clauses to resolve column
0:             // referneces. this ensures that we can add all of the columns from
1:             // the matching refinements to the SELECT list of the left join.
1:             // we re-bind the matching clauses when we're done binding the left join
1:             // because, at that time, we have result set numbers needed for
1:             // code generation.
0:             for ( MatchingClauseNode mcn : _matchingClauses )
1:             {
0:                 mcn.bindRefinement( this, _leftJoinFromList );
1:             }
1:         
0:             ResultColumnList    selectList = buildSelectList();
1: 
0:             // calculate the offsets into the SELECT list which define the rows for
0:             // the WHEN [ NOT ] MATCHED  actions
0:             for ( MatchingClauseNode mcn : _matchingClauses )
1:             {
0:                 mcn.bindThenColumns( selectList );
1:             }            
1:             
1:             resultSet = new SelectNode
0:                 (
0:                  selectList,
1:                  topFromList,
1:                  null,      // where clause
1:                  null,      // group by list
1:                  null,      // having clause
1:                  null,      // window list
1:                  null,      // optimizer plan override
1:                  getContextManager()
0:                  );
1: 
1:             // Wrap the SELECT in a CursorNode in order to finish binding it.
1:             _leftJoinCursor = new CursorNode
0:                 (
1:                  "SELECT",
1:                  resultSet,
1:                  null,
1:                  null,
1:                  null,
1:                  null,
1:                  false,
1:                  CursorNode.READ_ONLY,
1:                  null,
1:                  getContextManager()
0:                  );
1:             _leftJoinCursor.bindStatement();
1:         }
1:         finally
1:         {
1:             // Restore previous compiler state
1:             cc.setReliability( previousReliability );
1:         }
1:     }
1: 
0:     /** Throw a "not base table" exception */
0:     private void    notBaseTable()  throws StandardException
1:     {
0:         throw StandardException.newException( SQLState.LANG_TARGET_NOT_BASE_TABLE );
1:     }
1: 
0:     /** Build the select list for the left join */
0:     private ResultColumnList    buildSelectList() throws StandardException
1:     {
0:         HashMap<String,ColumnReference> drivingColumnMap = new HashMap<String,ColumnReference>();
0:         getColumnsInExpression( drivingColumnMap, _searchCondition );
1:         
0:         for ( MatchingClauseNode mcn : _matchingClauses )
1:         {
0:             mcn.getColumnsInExpressions( this, drivingColumnMap );
0:             getColumnsFromList( drivingColumnMap, mcn.getBufferedColumns() );
1:         }
1: 
0:         ResultColumnList    selectList = new ResultColumnList( getContextManager() );
1: 
0:         // add all of the columns from the source table which are mentioned
0:         addColumns( (FromTable) _leftJoinFromList.elementAt( SOURCE_TABLE_INDEX ), drivingColumnMap, selectList );
0:         // add all of the columns from the target table which are mentioned
0:         addColumns( (FromTable) _leftJoinFromList.elementAt( TARGET_TABLE_INDEX ), drivingColumnMap, selectList );
1: 
0:         addTargetRowLocation( selectList );
1: 
0:         return selectList;
1:     }
1: 
0:     /** Add the target table's row location to the left join's select list */
0:     private void    addTargetRowLocation( ResultColumnList selectList )
0:         throws StandardException
1:     {
0:         // tell the target table to generate a row location column
0:         _targetTable.setRowLocationColumnName( TARGET_ROW_LOCATION_NAME );
1:         
0:         TableName   fromTableName = _targetTable.getTableName();
1:         ColumnReference cr = new ColumnReference
0:                 ( TARGET_ROW_LOCATION_NAME, fromTableName, getContextManager() );
0:         ResultColumn    rowLocationColumn = new ResultColumn( (String) null, cr, getContextManager() );
0:         rowLocationColumn.markGenerated();
1: 
0:         selectList.addResultColumn( rowLocationColumn );
0:     private boolean targetIsBaseTable( FromBaseTable targetTable ) throws StandardException
0:         FromBaseTable   fbt = targetTable;
/////////////////////////////////////////////////////////////////////////
0:     /** Clone the source table for binding the MATCHED clauses */
0:     private FromTable   cloneSourceTable() throws StandardException
0:     {
0:         if ( _sourceTable instanceof FromVTI )
0:         {
0:             FromVTI source = (FromVTI) _sourceTable;
0: 
1:             return new FromVTI
0:                 (
1:                  source.methodCall,
1:                  source.correlationName,
0:                  source.resultColumns,
0:                  null,
1:                  source.exposedName,
0:                  getContextManager()
0:                  );
0:         }
0:         else if ( _sourceTable instanceof FromBaseTable )
0:         {
0:             FromBaseTable   source = (FromBaseTable) _sourceTable;
1:             return new FromBaseTable
0:                 (
1:                  source.tableName,
1:                  source.correlationName,
0:                  null,
0:                  null,
0:                  getContextManager()
0:                  );
0:         }
1:         else
0:         {
0:             throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_VIEW_OR_VTI );
0:         }
0:     }
0: 
1:     /**
0:      * <p>
1:      * Add to an evolving select list the columns from the indicated table.
0:      * </p>
1:      */
1:     private void    addColumns
0:         (
1:          FromTable  fromTable,
1:          HashMap<String,ColumnReference> drivingColumnMap,
0:          ResultColumnList   selectList
0:          )
0:         throws StandardException
0:     {
0:         String[]    columnNames = getColumns( getExposedName( fromTable ), drivingColumnMap );
0:         
1:         for ( int i = 0; i < columnNames.length; i++ )
0:         {
0:             ColumnReference cr = new ColumnReference
0:                 ( columnNames[ i ], fromTable.getTableName(), getContextManager() );
1:             ResultColumn    rc = new ResultColumn( (String) null, cr, getContextManager() );
1:             selectList.addResultColumn( rc );
0:         }
0:     }
0: 
1:     /** Get the column names from the table with the given table number, in sorted order */
0:     private String[]    getColumns( String exposedName, HashMap<String,ColumnReference> map )
0:     {
0:         ArrayList<String>   list = new ArrayList<String>();
0: 
1:         for ( ColumnReference cr : map.values() )
0:         {
0:             if ( exposedName.equals( cr.getTableName() ) ) { list.add( cr.getColumnName() ); }
0:         }
0: 
0:         String[]    retval = new String[ list.size() ];
0:         list.toArray( retval );
1:         Arrays.sort( retval );
0: 
1:         return retval;
0:     }
0:     
0:     /** Add the columns in the matchingRefinement clause to the evolving map */
0:     void    getColumnsInExpression
0:         ( HashMap<String,ColumnReference> map, ValueNode expression )
0:         throws StandardException
0:     {
0:         if ( expression == null ) { return; }
0: 
0:         CollectNodesVisitor<ColumnReference> getCRs =
0:             new CollectNodesVisitor<ColumnReference>(ColumnReference.class);
0: 
0:         expression.accept(getCRs);
0:         List<ColumnReference> colRefs = getCRs.getList();
0: 
0:         getColumnsFromList( map, colRefs );
0:     }
0: 
0:     /** Add a list of columns to the the evolving map */
1:     private void    getColumnsFromList
0:         ( HashMap<String,ColumnReference> map, ResultColumnList rcl )
0:         throws StandardException
0:     {
0:         ArrayList<ColumnReference>  colRefs = new ArrayList<ColumnReference>();
0: 
0:         for ( int i = 0; i < rcl.size(); i++ )
0:         {
0:             ResultColumn    rc = rcl.elementAt( i );
0:             ColumnReference cr = rc.getReference();
0:             if ( cr != null ) { colRefs.add( cr ); }
0:         }
0: 
0:         getColumnsFromList( map, colRefs );
0:     }
0:     
0:     /** Add a list of columns to the the evolving map */
1:     private void    getColumnsFromList
0:         ( HashMap<String,ColumnReference> map, List<ColumnReference> colRefs )
0:         throws StandardException
0:     {
0:         for ( ColumnReference cr : colRefs )
0:         {
0:             if ( cr.getTableName() == null )
0:             {
0:                 ResultColumn    rc = _leftJoinFromList.bindColumnReference( cr );
0:                 TableName       tableName = new TableName( null, rc.getTableName(), getContextManager() );
0:                 cr = new ColumnReference( cr.getColumnName(), tableName, getContextManager() );
0:             }
0: 
0:             String  key = makeDCMKey( cr.getTableName(), cr.getColumnName() );
0:             if ( map.get( key ) == null )
0:             {
0:                 map.put( key, cr );
0:             }
0:         }
0:     }
0: 
1:     /** Make a HashMap key for a column in the driving column map of the LEFT JOIN */
1:     private String  makeDCMKey( String tableName, String columnName )
0:     {
1:         return IdUtil.mkQualifiedName( tableName, columnName );
0:     }
0: 
0:     /** Boilerplate for binding an expression against a FromList */
0:     void bindExpression( ValueNode value, FromList fromList )
0:         throws StandardException
0:     {
0:         CompilerContext cc = getCompilerContext();
0:         final int previousReliability = cc.getReliability();
0:         
0:         try {
0:             cc.setReliability( previousReliability | CompilerContext.SQL_IN_ROUTINES_ILLEGAL );
0:             
0:             value.bindExpression
0:                 (
0:                  fromList,
0:                  new SubqueryList( getContextManager() ),
0:                  new ArrayList<AggregateNode>()
0:                  );
0:         }
0:         finally
0:         {
0:             // Restore previous compiler state
0:             cc.setReliability( previousReliability );
0:         }
0:     }
0: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // optimize() BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
1:     @Override
1: 	public void optimizeStatement() throws StandardException
0: 	{
1: 		/* First optimize the left join */
1: 		_leftJoinCursor.optimizeStatement();
0: 
0: 		/* In language we always set it to row lock, it's up to store to
0: 		 * upgrade it to table lock.  This makes sense for the default read
0: 		 * committed isolation level and update lock.  For more detail, see
0: 		 * Beetle 4133.
1: 		 */
0: 		//lockMode = TransactionController.MODE_RECORD;
0: 
1:         // now optimize the INSERT/UPDATE/DELETE actions
0:         for ( MatchingClauseNode mcn : _matchingClauses )
0:         {
1:             mcn.optimize();
0:         }
0: 	}
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // generate() BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
1:     @Override
1:     void generate( ActivationClassBuilder acb, MethodBuilder mb )
0: 							throws StandardException
0: 	{
1:         int     clauseCount = _matchingClauses.size();
0: 
1: 		/* generate the parameters */
1: 		generateParameterValueSet(acb);
0: 
1:         acb.pushGetResultSetFactoryExpression( mb );
0: 
1:         // arg 1: the driving left join 
1:         _leftJoinCursor.generate( acb, mb );
0: 
1:         ConstantAction[]    clauseActions = new ConstantAction[ clauseCount ];
1:         for ( int i = 0; i < clauseCount; i++ )
0:         {
0:             MatchingClauseNode  mcn = _matchingClauses.get( i );
0: 
0:             mcn.generate( acb, i );
1:             clauseActions[ i ] = mcn.makeConstantAction( acb );
0:         }
1:         _constantAction = getGenericConstantActionFactory().getMergeConstantAction( clauseActions );
0:         
1:         mb.callMethod
1:             ( VMOpcode.INVOKEINTERFACE, (String) null, "getMergeResultSet", ClassName.ResultSet, 1 );
0: 	}
0:     
1:     @Override
1:     public ConstantAction makeConstantAction() throws StandardException
0: 	{
1: 		return _constantAction;
0: 	}
0: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // Visitable BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
1: 	/**
1: 	 * Accept the visitor for all visitable children of this node.
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
1:     @Override
1: 	void acceptChildren(Visitor v)
0: 		throws StandardException
0: 	{
1:         if ( _leftJoinCursor != null )
0:         {
1:             _leftJoinCursor.acceptChildren( v );
0:         }
1:         else
0:         {
1:             super.acceptChildren( v );
0: 
1:             _targetTable.accept( v );
1:             _sourceTable.accept( v );
1:             _searchCondition.accept( v );
0:         }
0:         
0:         for ( MatchingClauseNode mcn : _matchingClauses )
0:         {
1:             mcn.accept( v );
0:         }
0: 	}
0: 
1:     @Override
1:     String statementToString()
0: 	{
1: 		return "MERGE";
0: 	}
commit:661c2e6
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
1:    Derby - Class org.apache.derby.impl.sql.compile.MergeNode
0: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0:  */
0: 
1: package	org.apache.derby.impl.sql.compile;
0: 
1: import java.util.ArrayList;
0: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: 
0: /**
0:  * <p>
0:  * A MergeNode represents a MERGE statement.  It is the top node of the
0:  * query tree for that statement. The driving result set for a MERGE statement
0:  * is essentially the following:
0:  * </p>
1:  *
1:  * <pre>
0:  * sourceTable LEFT OUTER JOIN targetTable ON searchCondition
1:  * </pre>
0:  */
0: 
1: public final class MergeNode extends DMLModStatementNode
0: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
0:     private FromTable   _targetTable;
1:     private FromTable   _sourceTable;
1:     private ValueNode   _searchCondition;
0:     private ArrayList<MatchingClauseNode>   _matchingClauses;
0: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
0:     /**
0:      * <p>
1:      * Constructor for a MergeNode.
0:      * </p>
0:      */
1:     public  MergeNode
0:         (
1:          FromTable          targetTable,
1:          FromTable          sourceTable,
1:          ValueNode          searchCondition,
0:          ArrayList<MatchingClauseNode>  matchingClauses,
1:          ContextManager     cm
0:          )
0:         throws StandardException
0:     {
0:         super( null, cm );
0: 
0:         _targetTable = targetTable;
1:         _sourceTable = sourceTable;
1:         _searchCondition = searchCondition;
1:         _matchingClauses = matchingClauses;
0: 
0:         makeJoin();
0:     }
0: 
0:     /**
0:      * <p>
0:      * Construct the left outer join which will drive the execution.
0:      * </p>
0:      */
0:     private void    makeJoin() throws StandardException
0:     {
0:         resultSet = new HalfOuterJoinNode
0:             (
0:              _sourceTable,
0:              _targetTable,
0:              _searchCondition,
0:              null,
0:              false,
0:              null,
0:              getContextManager()
0:              );
0:     }
0: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // bind() BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
0: 
1:     @Override
1: 	public void bindStatement() throws StandardException
0: 	{
1:         DataDictionary  dd = getDataDictionary();
0: 
1:         //
0:         // Bind the left join. This binds _targetTable and _sourceTable.
1:         //
0:         bind( dd );
0: 
0:         bindSearchCondition();
0: 
0:         if ( !targetIsBaseTable() )
0:         {
0:             throw StandardException.newException( SQLState.LANG_TARGET_NOT_BASE_TABLE );
0:         }
0: 
0:         if ( !sourceIsBase_View_or_VTI() )
0:         {
0:             throw StandardException.newException( SQLState.LANG_SOURCE_NOT_BASE_VIEW_OR_VTI );
0:         }
0: 
0:         // source and target may not have the same correlation names
0:         if ( getExposedName( _targetTable ).equals( getExposedName( _sourceTable ) ) )
0:         {
0:             throw StandardException.newException( SQLState.LANG_SAME_EXPOSED_NAME );
0:         }
0: 
0:         for ( MatchingClauseNode mcn : _matchingClauses )
0:         {
0:             mcn.bind( (JoinNode) resultSet, _targetTable );
0:         }
0: 
0:         throw StandardException.newException( SQLState.NOT_IMPLEMENTED, "MERGE" );
0: 	}
0: 
1:     /** Get the exposed name of a FromTable */
1:     private String  getExposedName( FromTable ft ) throws StandardException
0:     {
1:         return ft.getTableName().getTableName();
0:     }
0: 
0:     /**  Bind the search condition, the ON clause of the left join */
0:     private void    bindSearchCondition()   throws StandardException
0:     {
0:         FromList    fromList = new FromList
0:             ( getOptimizerFactory().doJoinOrderOptimization(), getContextManager() );
0: 
0:         resultSet.bindResultColumns( fromList );
0:     }
0: 
0:     /** Return true if the target table is a base table */
0:     private boolean targetIsBaseTable() throws StandardException
0:     {
0:         if ( !( _targetTable instanceof FromBaseTable) ) { return false; }
0: 
0:         FromBaseTable   fbt = (FromBaseTable) _targetTable;
0:         TableDescriptor desc = fbt.getTableDescriptor();
0:         if ( desc == null ) { return false; }
0: 
0:         return ( desc.getTableType() == TableDescriptor.BASE_TABLE_TYPE );
0:     }
0: 
0:     /** Return true if the source table is a base table, view, or table function */
0:     private boolean sourceIsBase_View_or_VTI() throws StandardException
0:     {
0:         if ( _sourceTable instanceof FromVTI ) { return true; }
0:         if ( !( _sourceTable instanceof FromBaseTable) ) { return false; }
0: 
0:         FromBaseTable   fbt = (FromBaseTable) _sourceTable;
0:         TableDescriptor desc = fbt.getTableDescriptor();
0:         if ( desc == null ) { return false; }
0: 
0:         switch( desc.getTableType() )
0:         {
0:         case TableDescriptor.BASE_TABLE_TYPE:
0:         case TableDescriptor.VIEW_TYPE:
0:             return true;
0: 
0:         default:
0:             return false;
0:         }
0:     }
0: 
0: }
============================================================================