1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.CoalesceFunctionNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
21:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.lang.reflect.Modifier;
1:3bb140c: import java.util.List;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.ClassName;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:eac0369: import org.apache.derby.iapi.services.compiler.LocalField;
1:eac0369: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:01217c2: import org.apache.derby.iapi.sql.compile.Visitor;
1:3dd2399: import org.apache.derby.iapi.util.JBitSet;
1:3dd2399: 
1:3c78cae: /**
1:eac0369:  * This node represents coalesce/value function which returns the first argument that is not null.
1:eac0369:  * The arguments are evaluated in the order in which they are specified, and the result of the
1:eac0369:  * function is the first argument that is not null. The result can be null only if all the arguments
1:eac0369:  * can be null. The selected argument is converted, if necessary, to the attributes of the result.
2:eac0369:  *
1:eac0369:  *
1:eac0369:  * SQL Reference Guide for DB2 has section titled "Rules for result data types" at the following url
1:eac0369:  * http://publib.boulder.ibm.com/infocenter/db2help/index.jsp?topic=/com.ibm.db2.udb.doc/admin/r0008480.htm
1:eac0369: 
1:eac0369:  * I have constructed following table based on various tables and information under "Rules for result data types"
1:eac0369:  * This table has FOR BIT DATA TYPES broken out into separate columns for clarity
1:eac0369:  *
1:94f158a:  * Note that are few differences between Derby and DB2
1:3bb140c:  * 1)there are few differences between what data types are considered compatible
1:3bb140c:  * In DB2, CHAR FOR BIT DATA data types are compatible with CHAR data types
1:eac0369:  * ie in addition to following table, CHAR is compatible with CHAR FOR BIT DATA, VARCHAR FOR BIT DATA and LONG VARCHAR FOR BIT DATA
1:eac0369:  * ie in addition to following table, VARCHAR is compatible with CHAR FOR BIT DATA, VARCHAR FOR BIT DATA and LONG VARCHAR FOR BIT DATA
1:eac0369:  * ie in addition to following table, LONG VARCHAR is compatible with CHAR FOR BIT DATA, VARCHAR FOR BIT DATA and LONG VARCHAR FOR BIT DATA
1:eac0369:  * ie in addition to following table, CHAR FOR BIT DATA is compatible with DATE, TIME, TIMESTAMP
1:eac0369:  * ie in addition to following table, VARCHAR FOR BIT DATA is compatible with DATE, TIME, TIMESTAMP
1:eac0369:  *
1:3bb140c:  * 2)few data types do not have matching precision in Derby and DB2
1:94f158a:  * In DB2, precision of TIME is 8. In Derby, precision of TIME is 0.
1:94f158a:  * In DB2, precision,scale of TIMESTAMP is 26,6. In Derby, precision of TIMESTAMP is 0,0.
1:94f158a:  * In DB2, precision of DOUBLE is 15. In Derby, precision of DOUBLE is 52.
1:94f158a:  * In DB2, precision of REAL is 23. In Derby, precision of REAL is 7.
1:eac0369:  * In DB2, precision calculation equation is incorrect when we have int and decimal arguments.
1:94f158a:  * The equation should be p=x+max(w-x,10) since precision of integer is 10 in both DB2 and Derby. Instead, DB2 has p=x+max(w-x,11) 
1:eac0369:  *
1:eac0369:  * Types.             S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
1:eac0369:  *                    M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
1:eac0369:  *                    A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
1:eac0369:  *                    L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
1:eac0369:  *                    L  G  N  M     L     H  V  .  H  V           S
1:eac0369:  *                    I  E  T  A     E     A  A  B  A  A           T
1:eac0369:  *                    N  R     L           R  R  I  R  R           A
1:eac0369:  *                    T                       C  T  .  .           M
1:eac0369:  *                                            H     B  B           P
1:eac0369:  *                                            A     I  I
1:eac0369:  *                                            R     T   T
1:eac0369:  * SMALLINT         { "SMALLINT", "INTEGER", "BIGINT", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * INTEGER          { "INTEGER", "INTEGER", "BIGINT", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * BIGINT           { "BIGINT", "BIGINT", "BIGINT", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * DECIMAL          { "DECIMAL", "DECIMAL", "DECIMAL", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * REAL             { "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "REAL", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * DOUBLE           { "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * CHAR             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "CHAR", "VARCHAR", "LONG VARCHAR", "ERROR", "ERROR", "ERROR", "CLOB", "DATE", "TIME", "TIMESTAMP", "ERROR" },
1:eac0369:  * VARCHAR          { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "VARCHAR", "VARCHAR","LONG VARCHAR", "ERROR", "ERROR", "ERROR", "CLOB", "DATE", "TIME", "TIMESTAMP", "ERROR" },
1:eac0369:  * LONGVARCHAR      { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "LONG VARCHAR", "LONG VARCHAR", "LONG VARCHAR", "ERROR", "ERROR", "ERROR", "CLOB", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * CHAR FOR BIT     { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "BIT", "BIT VARYING", "LONG BIT VARYING", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * VARCH. BIT       { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "BIT VARYING", "BIT VARYING", "LONG BIT VARYING", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * LONGVAR. BIT     { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "LONG BIT VARYING", "LONG BIT VARYING", "LONG BIT VARYING", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * CLOB             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "CLOB", "CLOB", "CLOB", "ERROR", "ERROR", "ERROR", "CLOB", "ERROR", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * DATE             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "DATE", "DATE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "DATE", "ERROR", "ERROR", "ERROR" },
1:eac0369:  * TIME             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIME", "TIME", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIME", "ERROR", "ERROR" },
1:eac0369:  * TIMESTAMP        { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIMESTAMP", "TIMESTAMP", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIMESTAMP", "ERROR" },
1:eac0369:  * BLOB             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "BLOB" }
1:eac0369:  */
1:eac0369: 
1:3bb140c: class CoalesceFunctionNode extends ValueNode
9:eac0369: {
1:eac0369: 	String	functionName; //Are we here because of COALESCE function or VALUE function
1:eac0369: 	ValueNodeList	argumentsList; //this is the list of arguments to the function. We are interested in the first not-null argument
1:44937d7: 
1:44937d7: 	/**
1:44937d7: 	 * The generated method will generate code to call coalesce on
1:44937d7: 	 * this non-parameter argument.
1:44937d7: 	 */
1:44937d7: 	private int firstNonParameterNodeIdx = -1;
1:eac0369: 
3:eac0369: 	/**
1:3bb140c:      * Constructor for a CoalesceFunctionNode
1:eac0369: 	 *
1:eac0369: 	 * @param functionName	Tells if the function was called with name COALESCE or with name VALUE
1:eac0369: 	 * @param argumentsList	The list of arguments to the coalesce/value function
1:3bb140c:      * @param cm            The context manager
1:eac0369: 	 */
1:3bb140c:     CoalesceFunctionNode(
1:3bb140c:             String functionName,
1:3bb140c:             ValueNodeList argumentsList,
1:3bb140c:             ContextManager cm)
1:eac0369: 	{
1:3bb140c:         super(cm);
1:3bb140c:         this.functionName = functionName;
1:3bb140c:         this.argumentsList = argumentsList;
10:eac0369: 	}
1:01217c2: 
1:3dd2399: 	/**
1:eac0369: 	 * Binding this expression means setting the result DataTypeServices.
1:eac0369: 	 * In this case, the result type is based on the rules in the table listed earlier.
1:3c78cae: 	 *
1:eac0369: 	 * @param fromList			The FROM list for the statement.
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes.
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes.
1:3c78cae: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:71c8e86:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:eac0369: 					throws StandardException
1:3c78cae: 	{
1:eac0369: 		//bind all the arguments
1:09c2697:         argumentsList.bindExpression(fromList, subqueryList, aggregates);
1:01217c2: 
1:eac0369: 		//There should be more than one argument
1:eac0369: 		if (argumentsList.size() < 2)
1:eac0369: 			throw StandardException.newException(SQLState.LANG_DB2_NUMBER_OF_ARGS_INVALID, functionName);
1:01217c2: 
1:eac0369: 		//check if all the arguments are parameters. If yes, then throw an exception
1:eac0369: 		if (argumentsList.containsAllParameterNodes())
1:eac0369: 			throw StandardException.newException(SQLState.LANG_DB2_COALESCE_FUNCTION_ALL_PARAMS);
1:01217c2: 
2:3c78cae: 		int argumentsListSize = argumentsList.size();
1:eac0369: 		//find the first non-param argument. The generated method will generate code to call coalesce on this argument
3:eac0369: 		for (int index = 0; index < argumentsListSize; index++)
1:01217c2: 		{
1:e1f49ca:             if (!argumentsList.elementAt(index).requiresTypeFromContext())
1:01217c2: 			{
1:44937d7: 				firstNonParameterNodeIdx = index;
2:eac0369: 				break;
1:3c78cae: 			}
1:01217c2: 		}
1:01217c2: 
1:e1f49ca:         // Make sure these arguments are compatible to each other before
1:e1f49ca:         // coalesce can be allowed.
1:e1f49ca:         for (ValueNode vn : argumentsList) {
1:e1f49ca:             if (vn.requiresTypeFromContext()) {
1:e1f49ca:                 // Since we don't know the type of param, can't check for
1:e1f49ca:                 // compatibility.
1:eac0369: 				continue;
1:e1f49ca:             }
1:e1f49ca:             argumentsList.compatible(vn);
1:01217c2: 		}
1:eac0369: 
1:e1f49ca:         // Set the result type to the most dominant datatype in the arguments
1:e1f49ca:         // list and based on the table listed above.
1:eac0369: 		setType(argumentsList.getDominantTypeServices());
1:eac0369: 
1:e1f49ca:         // Set all the parameter types to the type of the result type.
1:e1f49ca:         for (ValueNode vn : argumentsList)
1:01217c2: 		{
1:e1f49ca:             if (vn.requiresTypeFromContext())
1:01217c2: 			{
1:e1f49ca:                 vn.setType(getTypeServices());
1:01217c2: 			}
1:01217c2: 		}
1:eac0369: 		return this;
1:01217c2: 	}
1:7017a35: 
1:7017a35: 	/**
1:e1f49ca:      * Do code generation for coalesce/value
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb	The method the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:3c78cae: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:3c78cae: 	{
1:eac0369: 		int			argumentsListSize = argumentsList.size();
1:eac0369: 		String		receiverType = ClassName.DataValueDescriptor;
1:eac0369: 		String		argumentsListInterfaceType = ClassName.DataValueDescriptor + "[]";
1:3c78cae: 
1:eac0369: 		// Generate the code to build the array
1:eac0369: 		LocalField arrayField =
1:eac0369: 			acb.newFieldDeclaration(Modifier.PRIVATE, argumentsListInterfaceType);
1:3c78cae: 
1:eac0369: 		/* The array gets created in the constructor.
1:eac0369: 		 * All constant elements in the array are initialized
1:eac0369: 		 * in the constructor.  
1:eac0369: 		 */
1:eac0369: 		/* Assign the initializer to the DataValueDescriptor[] field */
1:eac0369: 		MethodBuilder cb = acb.getConstructor();
1:eac0369: 		cb.pushNewArray(ClassName.DataValueDescriptor, argumentsListSize);
1:afa871e: 		cb.setField(arrayField);
1:3c78cae: 
1:eac0369: 		/* Set the array elements that are constant */
1:eac0369: 		int numConstants = 0;
1:eac0369: 		MethodBuilder nonConstantMethod = null;
1:eac0369: 		MethodBuilder currentConstMethod = cb;
1:eac0369: 		for (int index = 0; index < argumentsListSize; index++)
1:01217c2: 		{
1:eac0369: 			MethodBuilder setArrayMethod;
1:eac0369: 	
1:eac0369: 			if (argumentsList.elementAt(index) instanceof ConstantNode)
1:eac0369: 			{
1:eac0369: 				numConstants++;
1:eac0369: 		
1:eac0369: 				/*if too many statements are added  to a  method, 
1:eac0369: 				*size of method can hit  65k limit, which will
1:eac0369: 				*lead to the class format errors at load time.
1:eac0369: 				*To avoid this problem, when number of statements added 
1:eac0369: 				*to a method is > 2048, remaing statements are added to  a new function
1:eac0369: 				*and called from the function which created the function.
1:eac0369: 				*See Beetle 5135 or 4293 for further details on this type of problem.
1:eac0369: 				*/
1:eac0369: 				if(currentConstMethod.statementNumHitLimit(1))
1:eac0369: 				{
1:eac0369: 					MethodBuilder genConstantMethod = acb.newGeneratedFun("void", Modifier.PRIVATE);
1:eac0369: 					currentConstMethod.pushThis();
1:eac0369: 					currentConstMethod.callMethod(VMOpcode.INVOKEVIRTUAL,
1:eac0369: 												  (String) null, 
1:eac0369: 												  genConstantMethod.getName(),
1:eac0369: 												  "void", 0);
1:eac0369: 					//if it is a generate function, close the metod.
1:eac0369: 					if(currentConstMethod != cb){
1:eac0369: 						currentConstMethod.methodReturn();
1:eac0369: 						currentConstMethod.complete();
1:eac0369: 					}
1:eac0369: 					currentConstMethod = genConstantMethod;
1:eac0369: 				}
1:eac0369: 				setArrayMethod = currentConstMethod;
1:eac0369: 			} else {
1:eac0369: 				if (nonConstantMethod == null)
1:eac0369: 					nonConstantMethod = acb.newGeneratedFun("void", Modifier.PROTECTED);
1:eac0369: 				setArrayMethod = nonConstantMethod;
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			setArrayMethod.getField(arrayField); 
1:e1f49ca:             argumentsList.elementAt(index).generateExpression(acb, setArrayMethod);
1:eac0369: 			setArrayMethod.upCast(receiverType);
1:eac0369: 			setArrayMethod.setArrayElement(index);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//if a generated function was created to reduce the size of the methods close the functions.
1:eac0369: 		if(currentConstMethod != cb){
1:eac0369: 			currentConstMethod.methodReturn();
1:eac0369: 			currentConstMethod.complete();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (nonConstantMethod != null) {
1:eac0369: 			nonConstantMethod.methodReturn();
1:eac0369: 			nonConstantMethod.complete();
1:eac0369: 			mb.pushThis();
1:eac0369: 			mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, nonConstantMethod.getName(), "void", 0);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		**  Call the method for coalesce/value function.
1:eac0369: 		**	First generate following
1:eac0369: 		**	<first non-param argument in the list>.method(<all the arguments>, <resultType>)
1:eac0369: 		**	Next, if we are dealing with result type that is variable length, then generate a call to setWidth.
1:eac0369: 		*/
1:eac0369: 
1:44937d7: 		// coalesce will be called on this non-parameter argument
1:e1f49ca:         argumentsList.elementAt(firstNonParameterNodeIdx).
1:44937d7: 			generateExpression(acb, mb);
1:44937d7: 
1:eac0369: 		mb.upCast(ClassName.DataValueDescriptor);
1:eac0369: 
1:eac0369: 		mb.getField(arrayField); // first arg to the coalesce function
1:eac0369: 
1:eac0369: 		//Following is for the second arg. This arg will be used to pass the return value.
1:eac0369: 		//COALESCE method expects this to be initialized to NULL SQLxxx type object.
1:eac0369: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);
1:ba7683c: 		acb.generateNull(mb, getTypeCompiler(), getTypeServices().getCollationType());
1:eac0369: 		mb.upCast(ClassName.DataValueDescriptor);
1:eac0369: 		mb.putField(field);
1:eac0369: 
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, "coalesce", receiverType, 2);
1:eac0369: 		if (getTypeId().variableLength())//since result type is variable length, generate setWidth code.
1:eac0369: 		{
1:eac0369: 			boolean isNumber = getTypeId().isNumericTypeId();
1:806114c: 			// to leave the DataValueDescriptor value on the stack, since setWidth is void
1:806114c: 			mb.dup();
1:806114c: 
1:eac0369: 			mb.push(isNumber ? getTypeServices().getPrecision() : getTypeServices().getMaximumWidth());
1:eac0369: 			mb.push(getTypeServices().getScale());
1:eac0369: 			mb.push(true);
1:806114c: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", "void", 3);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 		print the non-node subfields
1:eac0369: 	 */
1:3bb140c:     @Override
1:01217c2: 	public String toString() 
1:01217c2: 	{
1:3c78cae: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:c9a1206: 			return
1:c9a1206: 				"functionName: " + functionName + "\n" +
1:c9a1206: 				"firstNonParameterNodeIdx: " + firstNonParameterNodeIdx + "\n" +
1:c9a1206: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:01217c2: 		}
1:01217c2: 	}
1:01217c2:         
1:01217c2: 	/**
1:c9a1206: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:c9a1206: 	 * how tree printing is supposed to work.
1:c9a1206: 	 *
1:c9a1206: 	 * @param depth		The depth of this node in the tree
1:c9a1206: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:c9a1206: 	{
1:c9a1206: 		if (SanityManager.DEBUG)
1:c9a1206: 		{
1:c9a1206: 			super.printSubNodes(depth);
1:c9a1206: 
1:c9a1206: 			printLabel(depth, "argumentsList: ");
1:c9a1206: 			argumentsList.treePrint(depth + 1);
1:c9a1206: 		}
1:c9a1206: 	}
1:c9a1206: 
1:c9a1206: 
1:c9a1206: 	/**
1:01217c2: 	 * {@inheritDoc}
1:01217c2: 	 */
1:2706d1f:     boolean isEquivalent(ValueNode o) throws StandardException
1:01217c2: 	{
1:2706d1f:         if (! isSameNodeKind(o)) {
2:01217c2: 			return false;
1:3c78cae: 		}
1:c9a1206: 		
1:01217c2: 		CoalesceFunctionNode other = (CoalesceFunctionNode)o;
1:fc5f3cc: 
1:fc5f3cc:         if (!argumentsList.isEquivalent(other.argumentsList))
1:01217c2: 		{
1:01217c2: 			return false;
1:3c78cae: 		}
1:fc5f3cc: 
1:01217c2: 		return true;
1:3c78cae: 	}
1:dd2f5a8: 
1:dd2f5a8: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:dd2f5a8: 	 *
1:dd2f5a8: 	 * @param v the visitor
1:dd2f5a8: 	 * @throws StandardException on error in the visitor
1:dd2f5a8: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v) throws StandardException
1:01217c2: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:dd2f5a8: 
1:fc5f3cc:         argumentsList = (ValueNodeList) argumentsList.accept(v);
1:01217c2: 	}
1:dd2f5a8: 
1:eac0369:     /**
1:3dd2399:      * Categorize this predicate.
1:3dd2399:      *
1:3dd2399:      * @see ValueNode#categorize(JBitSet, boolean)
1:3dd2399:      */
1:3bb140c:     @Override
1:3dd2399:     public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:3dd2399:         throws StandardException
1:3dd2399:     {
1:3dd2399:         return argumentsList.categorize(referencedTabs, simplePredsOnly);
1:3dd2399:     }
1:3dd2399: 
1:eac0369: 	/**
1:3c78cae: 	 * Preprocess an expression tree.  We do a number of transformations
1:3c78cae: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1:3c78cae: 	 * subquery flattening.
1:3c78cae: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1:eac0369: 	 *
1:3c78cae: 	 * @param	numTables			Number of tables in the DML Statement
1:3c78cae: 	 * @param	outerFromList		FromList from outer query block
1:3c78cae: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1:3c78cae: 	 * @param	outerPredicateList	PredicateList from outer query block
1:3c78cae: 	 *
1:3c78cae: 	 * @return						The modified expression
1:3c78cae: 	 *
1:3c78cae: 	 * @exception StandardException		Thrown on error
1:3c78cae: 	 */
1:3bb140c:     @Override
1:3bb140c:     ValueNode preprocess(int numTables,
1:3c78cae: 								FromList outerFromList,
1:3c78cae: 								SubqueryList outerSubqueryList,
1:3c78cae: 								PredicateList outerPredicateList) 
1:3c78cae: 					throws StandardException
1:3c78cae: 	{
1:fc5f3cc:         argumentsList.preprocess(
1:fc5f3cc:                 numTables,
1:fc5f3cc:                 outerFromList,
1:fc5f3cc:                 outerSubqueryList,
1:fc5f3cc:                 outerPredicateList);
1:fc5f3cc: 
1:3c78cae: 		return this;
1:3c78cae: 	}
1:3c78cae: 
1:3c78cae:     /**
1:7017a35:      * Remap all the {@code ColumnReference}s in this tree to be clones of
1:7017a35:      * the underlying expression.
1:7017a35:      *
1:7017a35:      * @return the remapped tree
1:7017a35:      * @throws StandardException if an error occurs
1:7017a35:      */
1:3bb140c:     @Override
1:7017a35:     public ValueNode remapColumnReferencesToExpressions()
1:7017a35:             throws StandardException
1:7017a35:     {
1:fc5f3cc:         argumentsList = argumentsList.remapColumnReferencesToExpressions();
1:7017a35:         return this;
1:7017a35:     }
1:7017a35: 
1:7017a35: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     boolean isEquivalent(ValueNode o) throws StandardException
1:         if (! isSameNodeKind(o)) {
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:             if (!argumentsList.elementAt(index).requiresTypeFromContext())
1:         // Make sure these arguments are compatible to each other before
1:         // coalesce can be allowed.
1:         for (ValueNode vn : argumentsList) {
1:             if (vn.requiresTypeFromContext()) {
1:                 // Since we don't know the type of param, can't check for
1:                 // compatibility.
1:             }
1:             argumentsList.compatible(vn);
1:         // Set the result type to the most dominant datatype in the arguments
1:         // list and based on the table listed above.
1:         // Set all the parameter types to the type of the result type.
1:         for (ValueNode vn : argumentsList)
1:             if (vn.requiresTypeFromContext())
1:                 vn.setType(getTypeServices());
1:      * Do code generation for coalesce/value
/////////////////////////////////////////////////////////////////////////
1:             argumentsList.elementAt(index).generateExpression(acb, setArrayMethod);
/////////////////////////////////////////////////////////////////////////
1:         argumentsList.elementAt(firstNonParameterNodeIdx).
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Modifier;
1: import java.util.List;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
/////////////////////////////////////////////////////////////////////////
1:  * 1)there are few differences between what data types are considered compatible
1:  * In DB2, CHAR FOR BIT DATA data types are compatible with CHAR data types
1:  * 2)few data types do not have matching precision in Derby and DB2
/////////////////////////////////////////////////////////////////////////
1: class CoalesceFunctionNode extends ValueNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a CoalesceFunctionNode
1:      * @param cm            The context manager
1:     CoalesceFunctionNode(
1:             String functionName,
1:             ValueNodeList argumentsList,
1:             ContextManager cm)
1:         super(cm);
1:         this.functionName = functionName;
1:         this.argumentsList = argumentsList;
0:         setNodeType(C_NodeTypes.COALESCE_FUNCTION_NODE);
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     ValueNode preprocess(int numTables,
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
1: 			return
1: 				"functionName: " + functionName + "\n" +
1: 				"firstNonParameterNodeIdx: " + firstNonParameterNodeIdx + "\n" +
1: 				super.toString();
/////////////////////////////////////////////////////////////////////////
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			printLabel(depth, "argumentsList: ");
1: 			argumentsList.treePrint(depth + 1);
1: 		}
1: 	}
1: 
1: 
1: 	/**
/////////////////////////////////////////////////////////////////////////
commit:44937d7
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * The generated method will generate code to call coalesce on
1: 	 * this non-parameter argument.
1: 	 */
1: 	private int firstNonParameterNodeIdx = -1;
/////////////////////////////////////////////////////////////////////////
1: 				firstNonParameterNodeIdx = index;
/////////////////////////////////////////////////////////////////////////
1: 		// coalesce will be called on this non-parameter argument
0: 		((ValueNode) argumentsList.elementAt(firstNonParameterNodeIdx)).
1: 			generateExpression(acb, mb);
1: 
/////////////////////////////////////////////////////////////////////////
0: 			printLabel(depth, "argumentsList: [firstNonParameterNodeIdx=" +
0: 					   firstNonParameterNodeIdx + "]" );
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:cd5717c
/////////////////////////////////////////////////////////////////////////
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes.
0:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List aggregates)
1:         argumentsList.bindExpression(fromList, subqueryList, aggregates);
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
/////////////////////////////////////////////////////////////////////////
0: 							List aggregateVector)
commit:fc5f3cc
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (!argumentsList.isEquivalent(other.argumentsList))
1: 
/////////////////////////////////////////////////////////////////////////
1:         argumentsList = (ValueNodeList) argumentsList.accept(v);
/////////////////////////////////////////////////////////////////////////
1:         argumentsList.preprocess(
1:                 numTables,
1:                 outerFromList,
1:                 outerSubqueryList,
1:                 outerPredicateList);
1: 
/////////////////////////////////////////////////////////////////////////
1:         argumentsList = argumentsList.remapColumnReferencesToExpressions();
commit:3dd2399
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.JBitSet;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Categorize this predicate.
1:      *
1:      * @see ValueNode#categorize(JBitSet, boolean)
1:      */
1:     public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
1:         throws StandardException
1:     {
1:         return argumentsList.categorize(referencedTabs, simplePredsOnly);
1:     }
1: 
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Accept the visitor for all visitable children of this node.
1: 	 *
1: 	 * @param v the visitor
1: 	 * @throws StandardException on error in the visitor
1: 	 */
1: 	void acceptChildren(Visitor v) throws StandardException
1: 		super.acceptChildren(v);
1: 
1: 
commit:7017a35
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Remap all the {@code ColumnReference}s in this tree to be clones of
1:      * the underlying expression.
1:      *
1:      * @return the remapped tree
1:      * @throws StandardException if an error occurs
1:      */
1:     public ValueNode remapColumnReferencesToExpressions()
1:             throws StandardException
1:     {
0:         for (int i = 0; i < argumentsList.size(); i++) {
0:             ValueNode vn = (ValueNode) argumentsList.elementAt(i);
0:             vn.remapColumnReferencesToExpressions();
1:         }
1:         return this;
1:     }
1: 
commit:3c78cae
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Preprocess an expression tree.  We do a number of transformations
1: 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
1: 	 * subquery flattening.
1: 	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
1: 	 *
1: 	 * @param	numTables			Number of tables in the DML Statement
1: 	 * @param	outerFromList		FromList from outer query block
1: 	 * @param	outerSubqueryList	SubqueryList from outer query block
1: 	 * @param	outerPredicateList	PredicateList from outer query block
1: 	 *
1: 	 * @return						The modified expression
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode preprocess(int numTables,
1: 								FromList outerFromList,
1: 								SubqueryList outerSubqueryList,
1: 								PredicateList outerPredicateList) 
1: 					throws StandardException
1: 	{
1: 		int argumentsListSize = argumentsList.size();
0: 		for (int i=0; i < argumentsListSize; i++) {
0: 			((ValueNode)argumentsList.elementAt(i)).preprocess
0: 				(numTables,
0: 				 outerFromList,
0: 				 outerSubqueryList,
0: 				 outerPredicateList);
1: 		}
1: 		return this;
1: 	}
1: 
1: 
1: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
1: 	 *
0: 	 * @param depth					The depth of this node in the tree
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			super.printSubNodes(depth);
0: 			printLabel(depth, "argumentsList: ");
1: 			int argumentsListSize = argumentsList.size();
0: 			for (int i=0; i < argumentsListSize; i++) {
0: 			    ((ValueNode)argumentsList.elementAt(i)).treePrint(depth+1);
1: 			}
1: 		}
1: 	}
1:         
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:     ValueNode bindExpression(FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:0a29524
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:f63b7da
/////////////////////////////////////////////////////////////////////////
0: 				//collation of ? operand should be same as the compilation schema
0: 				((ValueNode)argumentsList.elementAt(index)).setCollationUsingCompilationSchema(
commit:7c5fbc4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
0: 				//collation of ? operand should be same as the current schema
0: 				((ValueNode)argumentsList.elementAt(index)).getTypeServices()
0: 				.setCollationDerivation(
0: 						StringDataValue.COLLATION_DERIVATION_IMPLICIT);
0: 				((ValueNode)argumentsList.elementAt(index)).getTypeServices()
0: 				.setCollationType(
0: 						getLanguageConnectionContext().getDefaultSchema()
0: 								.getCollationType());
commit:ba7683c
/////////////////////////////////////////////////////////////////////////
1: 		acb.generateNull(mb, getTypeCompiler(), getTypeServices().getCollationType());
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1:  * Note that are few differences between Derby and DB2
/////////////////////////////////////////////////////////////////////////
0:  * 2)few datatypes donot have matching precision in Derby and DB2
1:  * In DB2, precision of TIME is 8. In Derby, precision of TIME is 0.
1:  * In DB2, precision,scale of TIMESTAMP is 26,6. In Derby, precision of TIMESTAMP is 0,0.
1:  * In DB2, precision of DOUBLE is 15. In Derby, precision of DOUBLE is 52.
1:  * In DB2, precision of REAL is 23. In Derby, precision of REAL is 7.
1:  * The equation should be p=x+max(w-x,10) since precision of integer is 10 in both DB2 and Derby. Instead, DB2 has p=x+max(w-x,11) 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:01217c2
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.Visitable;
1: import org.apache.derby.iapi.sql.compile.Visitor;
0: import java.util.Iterator;
/////////////////////////////////////////////////////////////////////////
1: 	public String toString() 
1: 	{
/////////////////////////////////////////////////////////////////////////
1:         
1: 	/**
1: 	 * {@inheritDoc}
1: 	 */
0: 	protected boolean isEquivalent(ValueNode o) throws StandardException
1: 	{
0: 		if (!isSameNodeType(o))
1: 		{
1: 			return false;
1: 		}
1: 		
1: 		CoalesceFunctionNode other = (CoalesceFunctionNode)o;
0: 		if (other.argumentsList.size() != argumentsList.size())
1: 		{
1: 			return false;
1: 			
1: 		}
1: 		
0: 		int size = argumentsList.size();
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			ValueNode v1 = (ValueNode)argumentsList.elementAt(index);
0: 			ValueNode v2 = (ValueNode)other.argumentsList.elementAt(index);
0: 			if (!v1.isEquivalent(v2)) 
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 		return true;
1: 	}
0: 	public Visitable accept(Visitor v) throws StandardException 
1: 	{
0: 		Visitable returnNode = v.visit(this);
1: 		
0: 		if (v.skipChildren(this) || v.stopTraversal())
1: 		{
0: 			return returnNode;
1: 		}
1: 		
0: 		int size = argumentsList.size();
0: 		for (int index = 0; index < size; index++)
1: 		{
0: 			argumentsList.setElementAt(
0: 					(QueryTreeNode)(argumentsList.elementAt(index)).accept(v), index);
1: 		}
0: 		return returnNode;
1: 	}
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 			// to leave the DataValueDescriptor value on the stack, since setWidth is void
1: 			mb.dup();
1: 
1: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", "void", 3);
commit:afa871e
/////////////////////////////////////////////////////////////////////////
1: 		cb.setField(arrayField);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.CoalesceFunctionNode
1: 
0:    Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
1: import org.apache.derby.iapi.services.compiler.LocalField;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import java.lang.reflect.Modifier;
1: 
0: import java.util.Vector;
1: 
1: /**
1:  * This node represents coalesce/value function which returns the first argument that is not null.
1:  * The arguments are evaluated in the order in which they are specified, and the result of the
1:  * function is the first argument that is not null. The result can be null only if all the arguments
1:  * can be null. The selected argument is converted, if necessary, to the attributes of the result.
1:  *
1:  *
1:  * SQL Reference Guide for DB2 has section titled "Rules for result data types" at the following url
1:  * http://publib.boulder.ibm.com/infocenter/db2help/index.jsp?topic=/com.ibm.db2.udb.doc/admin/r0008480.htm
1: 
1:  * I have constructed following table based on various tables and information under "Rules for result data types"
1:  * This table has FOR BIT DATA TYPES broken out into separate columns for clarity
1:  *
0:  * Note that are few differences between Cloudscape and DB2
0:  * 1)there are few differences between what datatypes are consdiered compatible
0:  * In DB2, CHAR FOR BIT DATA datatypes are compatible with CHAR datatypes
1:  * ie in addition to following table, CHAR is compatible with CHAR FOR BIT DATA, VARCHAR FOR BIT DATA and LONG VARCHAR FOR BIT DATA
1:  * ie in addition to following table, VARCHAR is compatible with CHAR FOR BIT DATA, VARCHAR FOR BIT DATA and LONG VARCHAR FOR BIT DATA
1:  * ie in addition to following table, LONG VARCHAR is compatible with CHAR FOR BIT DATA, VARCHAR FOR BIT DATA and LONG VARCHAR FOR BIT DATA
1:  * ie in addition to following table, CHAR FOR BIT DATA is compatible with DATE, TIME, TIMESTAMP
1:  * ie in addition to following table, VARCHAR FOR BIT DATA is compatible with DATE, TIME, TIMESTAMP
1:  *
0:  * 2)few datatypes donot have matching precision in Cloudscape and DB2
0:  * In DB2, precision of TIME is 8. In Cloudscape, precision of TIME is 0.
0:  * In DB2, precision,scale of TIMESTAMP is 26,6. In Cloudscape, precision of TIMESTAMP is 0,0.
0:  * In DB2, precision of DOUBLE is 15. In Cloudscape, precision of DOUBLE is 52.
0:  * In DB2, precision of REAL is 23. In Cloudscape, precision of REAL is 7.
1:  * In DB2, precision calculation equation is incorrect when we have int and decimal arguments.
0:  * The equation should be p=x+max(w-x,10) since precision of integer is 10 in both db2 and cloudscape. Instead, DB2 has p=x+max(w-x,11) 
1:  *
1:  * Types.             S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
1:  *                    M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
1:  *                    A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
1:  *                    L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
1:  *                    L  G  N  M     L     H  V  .  H  V           S
1:  *                    I  E  T  A     E     A  A  B  A  A           T
1:  *                    N  R     L           R  R  I  R  R           A
1:  *                    T                       C  T  .  .           M
1:  *                                            H     B  B           P
1:  *                                            A     I  I
1:  *                                            R     T   T
1:  * SMALLINT         { "SMALLINT", "INTEGER", "BIGINT", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * INTEGER          { "INTEGER", "INTEGER", "BIGINT", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * BIGINT           { "BIGINT", "BIGINT", "BIGINT", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * DECIMAL          { "DECIMAL", "DECIMAL", "DECIMAL", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * REAL             { "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "REAL", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * DOUBLE           { "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * CHAR             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "CHAR", "VARCHAR", "LONG VARCHAR", "ERROR", "ERROR", "ERROR", "CLOB", "DATE", "TIME", "TIMESTAMP", "ERROR" },
1:  * VARCHAR          { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "VARCHAR", "VARCHAR","LONG VARCHAR", "ERROR", "ERROR", "ERROR", "CLOB", "DATE", "TIME", "TIMESTAMP", "ERROR" },
1:  * LONGVARCHAR      { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "LONG VARCHAR", "LONG VARCHAR", "LONG VARCHAR", "ERROR", "ERROR", "ERROR", "CLOB", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * CHAR FOR BIT     { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "BIT", "BIT VARYING", "LONG BIT VARYING", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * VARCH. BIT       { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "BIT VARYING", "BIT VARYING", "LONG BIT VARYING", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * LONGVAR. BIT     { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "LONG BIT VARYING", "LONG BIT VARYING", "LONG BIT VARYING", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * CLOB             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "CLOB", "CLOB", "CLOB", "ERROR", "ERROR", "ERROR", "CLOB", "ERROR", "ERROR", "ERROR", "ERROR" },
1:  * DATE             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "DATE", "DATE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "DATE", "ERROR", "ERROR", "ERROR" },
1:  * TIME             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIME", "TIME", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIME", "ERROR", "ERROR" },
1:  * TIMESTAMP        { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIMESTAMP", "TIMESTAMP", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIMESTAMP", "ERROR" },
1:  * BLOB             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "BLOB" }
1:  */
1: 
0: public class CoalesceFunctionNode extends ValueNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
1: 	String	functionName; //Are we here because of COALESCE function or VALUE function
1: 	ValueNodeList	argumentsList; //this is the list of arguments to the function. We are interested in the first not-null argument
0: 	ValueNode firstNonParameterNode;//The generated method will generate code to call coalesce on this non-parameter argument
1: 
1: 	/**
0: 	 * Initializer for a CalesceFunctionNode
1: 	 *
1: 	 * @param functionName	Tells if the function was called with name COALESCE or with name VALUE
1: 	 * @param argumentsList	The list of arguments to the coalesce/value function
1: 	 */
0: 	public void init(Object functionName, Object argumentsList)
1: 	{
0: 		this.functionName = (String) functionName;
0: 		this.argumentsList = (ValueNodeList) argumentsList;
1: 	}
1: 
1: 	/**
1: 	 * Binding this expression means setting the result DataTypeServices.
1: 	 * In this case, the result type is based on the rules in the table listed earlier.
1: 	 *
1: 	 * @param fromList			The FROM list for the statement.
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes.
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes.
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 							Vector	aggregateVector)
1: 					throws StandardException
1: 	{
1: 		//bind all the arguments
0: 		argumentsList.bindExpression(fromList, subqueryList, aggregateVector);
1: 
1: 		//There should be more than one argument
1: 		if (argumentsList.size() < 2)
1: 			throw StandardException.newException(SQLState.LANG_DB2_NUMBER_OF_ARGS_INVALID, functionName);
1: 
1: 		//check if all the arguments are parameters. If yes, then throw an exception
1: 		if (argumentsList.containsAllParameterNodes())
1: 			throw StandardException.newException(SQLState.LANG_DB2_COALESCE_FUNCTION_ALL_PARAMS);
1: 
0: 		int argumentsListSize = argumentsList.size();
1: 		//find the first non-param argument. The generated method will generate code to call coalesce on this argument
1: 		for (int index = 0; index < argumentsListSize; index++)
1: 		{
0: 			if (!(((ValueNode) argumentsList.elementAt(index)).isParameterNode()))
1: 			{
0: 				firstNonParameterNode = (ValueNode) argumentsList.elementAt(index);
1: 				break;
1: 			}
1: 		}
1: 
0: 		//make sure these arguments are compatible to each other before coalesce can be allowed
1: 		for (int index = 0; index < argumentsListSize; index++)
1: 		{
0: 			if (((ValueNode) argumentsList.elementAt(index)).isParameterNode()) //since we don't know the type of param, can't check for compatibility
1: 				continue;
0: 				argumentsList.compatible((ValueNode) argumentsList.elementAt(index));
1: 		}
1: 
0: 		//set the result type to the most dominant datatype in the arguments list and based on the table listed above
1: 		setType(argumentsList.getDominantTypeServices());
1: 
0: 		//set all the parameter types to the type of the result type
1: 		for (int index = 0; index < argumentsListSize; index++)
1: 		{
0: 			if (((ValueNode) argumentsList.elementAt(index)).isParameterNode())
1: 			{
0: 				((ParameterNode) argumentsList.elementAt(index)).setDescriptor(getTypeServices());
1: 				break;
1: 			}
1: 		}
1: 		return this;
1: 	}
1: 
1: 	/**
0: 	 * Do code generation for coalese/value
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the expression will go into
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		int			argumentsListSize = argumentsList.size();
1: 		String		receiverType = ClassName.DataValueDescriptor;
1: 		String		argumentsListInterfaceType = ClassName.DataValueDescriptor + "[]";
1: 
1: 		// Generate the code to build the array
1: 		LocalField arrayField =
1: 			acb.newFieldDeclaration(Modifier.PRIVATE, argumentsListInterfaceType);
1: 
1: 		/* The array gets created in the constructor.
1: 		 * All constant elements in the array are initialized
1: 		 * in the constructor.  
1: 		 */
1: 		/* Assign the initializer to the DataValueDescriptor[] field */
1: 		MethodBuilder cb = acb.getConstructor();
1: 		cb.pushNewArray(ClassName.DataValueDescriptor, argumentsListSize);
0: 		cb.putField(arrayField);
0: 		cb.endStatement();
1: 
1: 		/* Set the array elements that are constant */
1: 		int numConstants = 0;
1: 		MethodBuilder nonConstantMethod = null;
1: 		MethodBuilder currentConstMethod = cb;
1: 		for (int index = 0; index < argumentsListSize; index++)
1: 		{
1: 			MethodBuilder setArrayMethod;
1: 	
1: 			if (argumentsList.elementAt(index) instanceof ConstantNode)
1: 			{
1: 				numConstants++;
1: 		
1: 				/*if too many statements are added  to a  method, 
1: 				*size of method can hit  65k limit, which will
1: 				*lead to the class format errors at load time.
1: 				*To avoid this problem, when number of statements added 
1: 				*to a method is > 2048, remaing statements are added to  a new function
1: 				*and called from the function which created the function.
1: 				*See Beetle 5135 or 4293 for further details on this type of problem.
1: 				*/
1: 				if(currentConstMethod.statementNumHitLimit(1))
1: 				{
1: 					MethodBuilder genConstantMethod = acb.newGeneratedFun("void", Modifier.PRIVATE);
1: 					currentConstMethod.pushThis();
1: 					currentConstMethod.callMethod(VMOpcode.INVOKEVIRTUAL,
1: 												  (String) null, 
1: 												  genConstantMethod.getName(),
1: 												  "void", 0);
1: 					//if it is a generate function, close the metod.
1: 					if(currentConstMethod != cb){
1: 						currentConstMethod.methodReturn();
1: 						currentConstMethod.complete();
1: 					}
1: 					currentConstMethod = genConstantMethod;
1: 				}
1: 				setArrayMethod = currentConstMethod;
1: 			} else {
1: 				if (nonConstantMethod == null)
1: 					nonConstantMethod = acb.newGeneratedFun("void", Modifier.PROTECTED);
1: 				setArrayMethod = nonConstantMethod;
1: 
1: 			}
1: 
1: 			setArrayMethod.getField(arrayField); 
0: 			((ValueNode) argumentsList.elementAt(index)).generateExpression(acb, setArrayMethod);
1: 			setArrayMethod.upCast(receiverType);
1: 			setArrayMethod.setArrayElement(index);
1: 		}
1: 
1: 		//if a generated function was created to reduce the size of the methods close the functions.
1: 		if(currentConstMethod != cb){
1: 			currentConstMethod.methodReturn();
1: 			currentConstMethod.complete();
1: 		}
1: 
1: 		if (nonConstantMethod != null) {
1: 			nonConstantMethod.methodReturn();
1: 			nonConstantMethod.complete();
1: 			mb.pushThis();
1: 			mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, nonConstantMethod.getName(), "void", 0);
1: 		}
1: 
1: 		/*
1: 		**  Call the method for coalesce/value function.
1: 		**	First generate following
1: 		**	<first non-param argument in the list>.method(<all the arguments>, <resultType>)
1: 		**	Next, if we are dealing with result type that is variable length, then generate a call to setWidth.
1: 		*/
1: 
0: 		firstNonParameterNode.generateExpression(acb, mb); //coalesce will be called on this non-parameter argument
1: 		mb.upCast(ClassName.DataValueDescriptor);
1: 
1: 		mb.getField(arrayField); // first arg to the coalesce function
1: 
1: 		//Following is for the second arg. This arg will be used to pass the return value.
1: 		//COALESCE method expects this to be initialized to NULL SQLxxx type object.
1: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);
0: 		acb.generateNull(mb, getTypeCompiler());
1: 		mb.upCast(ClassName.DataValueDescriptor);
1: 		mb.putField(field);
1: 
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, "coalesce", receiverType, 2);
1: 		if (getTypeId().variableLength())//since result type is variable length, generate setWidth code.
1: 		{
1: 			boolean isNumber = getTypeId().isNumericTypeId();
1: 			mb.push(isNumber ? getTypeServices().getPrecision() : getTypeServices().getMaximumWidth());
1: 			mb.push(getTypeServices().getScale());
1: 			mb.push(true);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
1: 		}
1: 	}
1: 
1: 	/*
1: 		print the non-node subfields
1: 	 */
0: 	public String toString() {
0: 		if (SanityManager.DEBUG)
1: 		{
0: 			return super.toString()+functionName+"("+argumentsList+")\n";
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:d5bc20f
/////////////////////////////////////////////////////////////////////////
0: 			if (!(((ValueNode) argumentsList.elementAt(index)).requiresTypeFromContext()))
/////////////////////////////////////////////////////////////////////////
0: 			if (((ValueNode) argumentsList.elementAt(index)).requiresTypeFromContext()) //since we don't know the type of param, can't check for compatibility
/////////////////////////////////////////////////////////////////////////
0: 			if (((ValueNode) argumentsList.elementAt(index)).requiresTypeFromContext())
0: 				((ValueNode)argumentsList.elementAt(index)).setType(getTypeServices());
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.iapi.services.compiler.LocalField;
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * This node represents coalesce/value function which returns the first argument that is not null.
0:  * The arguments are evaluated in the order in which they are specified, and the result of the
0:  * function is the first argument that is not null. The result can be null only if all the arguments
0:  * can be null. The selected argument is converted, if necessary, to the attributes of the result.
0:  *
0:  *
0:  * SQL Reference Guide for DB2 has section titled "Rules for result data types" at the following url
0:  * http://publib.boulder.ibm.com/infocenter/db2help/index.jsp?topic=/com.ibm.db2.udb.doc/admin/r0008480.htm
0: 
0:  * I have constructed following table based on various tables and information under "Rules for result data types"
0:  * This table has FOR BIT DATA TYPES broken out into separate columns for clarity
0:  *
0:  * Note that are few differences between Cloudscape and DB2
0:  * 1)there are few differences between what datatypes are consdiered compatible
0:  * In DB2, CHAR FOR BIT DATA datatypes are compatible with CHAR datatypes
0:  * ie in addition to following table, CHAR is compatible with CHAR FOR BIT DATA, VARCHAR FOR BIT DATA and LONG VARCHAR FOR BIT DATA
0:  * ie in addition to following table, VARCHAR is compatible with CHAR FOR BIT DATA, VARCHAR FOR BIT DATA and LONG VARCHAR FOR BIT DATA
0:  * ie in addition to following table, LONG VARCHAR is compatible with CHAR FOR BIT DATA, VARCHAR FOR BIT DATA and LONG VARCHAR FOR BIT DATA
0:  * ie in addition to following table, CHAR FOR BIT DATA is compatible with DATE, TIME, TIMESTAMP
0:  * ie in addition to following table, VARCHAR FOR BIT DATA is compatible with DATE, TIME, TIMESTAMP
0:  *
0:  * 2)few datatypes donot have matching precision in Cloudscape and DB2
0:  * In DB2, precision of TIME is 8. In Cloudscape, precision of TIME is 0.
0:  * In DB2, precision,scale of TIMESTAMP is 26,6. In Cloudscape, precision of TIMESTAMP is 0,0.
0:  * In DB2, precision of DOUBLE is 15. In Cloudscape, precision of DOUBLE is 52.
0:  * In DB2, precision of REAL is 23. In Cloudscape, precision of REAL is 7.
0:  * In DB2, precision calculation equation is incorrect when we have int and decimal arguments.
0:  * The equation should be p=x+max(w-x,10) since precision of integer is 10 in both db2 and cloudscape. Instead, DB2 has p=x+max(w-x,11) 
0:  *
0:  * Types.             S  I  B  D  R  D  C  V  L  C  V  L  C  D  T  T  B
0:  *                    M  N  I  E  E  O  H  A  O  H  A  O  L  A  I  I  L
0:  *                    A  T  G  C  A  U  A  R  N  A  R  N  O  T  M  M  O
0:  *                    L  E  I  I  L  B  R  C  G  R  C  G  B  E  E  E  B
0:  *                    L  G  N  M     L     H  V  .  H  V           S
0:  *                    I  E  T  A     E     A  A  B  A  A           T
0:  *                    N  R     L           R  R  I  R  R           A
0:  *                    T                       C  T  .  .           M
0:  *                                            H     B  B           P
0:  *                                            A     I  I
0:  *                                            R     T   T
0:  * SMALLINT         { "SMALLINT", "INTEGER", "BIGINT", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * INTEGER          { "INTEGER", "INTEGER", "BIGINT", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * BIGINT           { "BIGINT", "BIGINT", "BIGINT", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * DECIMAL          { "DECIMAL", "DECIMAL", "DECIMAL", "DECIMAL", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * REAL             { "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "REAL", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * DOUBLE           { "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "DOUBLE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * CHAR             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "CHAR", "VARCHAR", "LONG VARCHAR", "ERROR", "ERROR", "ERROR", "CLOB", "DATE", "TIME", "TIMESTAMP", "ERROR" },
0:  * VARCHAR          { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "VARCHAR", "VARCHAR","LONG VARCHAR", "ERROR", "ERROR", "ERROR", "CLOB", "DATE", "TIME", "TIMESTAMP", "ERROR" },
0:  * LONGVARCHAR      { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "LONG VARCHAR", "LONG VARCHAR", "LONG VARCHAR", "ERROR", "ERROR", "ERROR", "CLOB", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * CHAR FOR BIT     { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "BIT", "BIT VARYING", "LONG BIT VARYING", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * VARCH. BIT       { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "BIT VARYING", "BIT VARYING", "LONG BIT VARYING", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * LONGVAR. BIT     { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "LONG BIT VARYING", "LONG BIT VARYING", "LONG BIT VARYING", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * CLOB             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "CLOB", "CLOB", "CLOB", "ERROR", "ERROR", "ERROR", "CLOB", "ERROR", "ERROR", "ERROR", "ERROR" },
0:  * DATE             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "DATE", "DATE", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "DATE", "ERROR", "ERROR", "ERROR" },
0:  * TIME             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIME", "TIME", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIME", "ERROR", "ERROR" },
0:  * TIMESTAMP        { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIMESTAMP", "TIMESTAMP", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "TIMESTAMP", "ERROR" },
0:  * BLOB             { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "BLOB" }
0:  */
0: 
0: public class CoalesceFunctionNode extends ValueNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2004;
0: 	String	functionName; //Are we here because of COALESCE function or VALUE function
0: 	ValueNodeList	argumentsList; //this is the list of arguments to the function. We are interested in the first not-null argument
0: 	ValueNode firstNonParameterNode;//The generated method will generate code to call coalesce on this non-parameter argument
0: 
0: 	/**
0: 	 * Initializer for a CalesceFunctionNode
0: 	 *
0: 	 * @param functionName	Tells if the function was called with name COALESCE or with name VALUE
0: 	 * @param argumentsList	The list of arguments to the coalesce/value function
0: 	 */
0: 	public void init(Object functionName, Object argumentsList)
0: 	{
0: 		this.functionName = (String) functionName;
0: 		this.argumentsList = (ValueNodeList) argumentsList;
0: 	}
0: 
0: 	/**
0: 	 * Binding this expression means setting the result DataTypeServices.
0: 	 * In this case, the result type is based on the rules in the table listed earlier.
0: 	 *
0: 	 * @param fromList			The FROM list for the statement.
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes.
0: 	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes.
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
0: 							Vector	aggregateVector)
0: 					throws StandardException
0: 	{
0: 		//bind all the arguments
0: 		argumentsList.bindExpression(fromList, subqueryList, aggregateVector);
0: 
0: 		//There should be more than one argument
0: 		if (argumentsList.size() < 2)
0: 			throw StandardException.newException(SQLState.LANG_DB2_NUMBER_OF_ARGS_INVALID, functionName);
0: 
0: 		//check if all the arguments are parameters. If yes, then throw an exception
0: 		if (argumentsList.containsAllParameterNodes())
0: 			throw StandardException.newException(SQLState.LANG_DB2_COALESCE_FUNCTION_ALL_PARAMS);
0: 
0: 		int argumentsListSize = argumentsList.size();
0: 		//find the first non-param argument. The generated method will generate code to call coalesce on this argument
0: 		for (int index = 0; index < argumentsListSize; index++)
0: 		{
0: 			if (!(((ValueNode) argumentsList.elementAt(index)).isParameterNode()))
0: 			{
0: 				firstNonParameterNode = (ValueNode) argumentsList.elementAt(index);
0: 				break;
0: 			}
0: 		}
0: 
0: 		//make sure these arguments are compatible to each other before coalesce can be allowed
0: 		for (int index = 0; index < argumentsListSize; index++)
0: 		{
0: 			if (((ValueNode) argumentsList.elementAt(index)).isParameterNode()) //since we don't know the type of param, can't check for compatibility
0: 				continue;
0: 				argumentsList.compatible((ValueNode) argumentsList.elementAt(index));
0: 		}
0: 
0: 		//set the result type to the most dominant datatype in the arguments list and based on the table listed above
0: 		setType(argumentsList.getDominantTypeServices());
0: 
0: 		//set all the parameter types to the type of the result type
0: 		for (int index = 0; index < argumentsListSize; index++)
0: 		{
0: 			if (((ValueNode) argumentsList.elementAt(index)).isParameterNode())
0: 			{
0: 				((ParameterNode) argumentsList.elementAt(index)).setDescriptor(getTypeServices());
0: 				break;
0: 			}
0: 		}
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for coalese/value
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the expression will go into
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		int			argumentsListSize = argumentsList.size();
0: 		String		receiverType = ClassName.DataValueDescriptor;
0: 		String		argumentsListInterfaceType = ClassName.DataValueDescriptor + "[]";
0: 
0: 		// Generate the code to build the array
0: 		LocalField arrayField =
0: 			acb.newFieldDeclaration(Modifier.PRIVATE, argumentsListInterfaceType);
0: 
0: 		/* The array gets created in the constructor.
0: 		 * All constant elements in the array are initialized
0: 		 * in the constructor.  
0: 		 */
0: 		/* Assign the initializer to the DataValueDescriptor[] field */
0: 		MethodBuilder cb = acb.getConstructor();
0: 		cb.pushNewArray(ClassName.DataValueDescriptor, argumentsListSize);
0: 		cb.putField(arrayField);
0: 		cb.endStatement();
0: 
0: 		/* Set the array elements that are constant */
0: 		int numConstants = 0;
0: 		MethodBuilder nonConstantMethod = null;
0: 		MethodBuilder currentConstMethod = cb;
0: 		for (int index = 0; index < argumentsListSize; index++)
0: 		{
0: 			MethodBuilder setArrayMethod;
0: 	
0: 			if (argumentsList.elementAt(index) instanceof ConstantNode)
0: 			{
0: 				numConstants++;
0: 		
0: 				/*if too many statements are added  to a  method, 
0: 				*size of method can hit  65k limit, which will
0: 				*lead to the class format errors at load time.
0: 				*To avoid this problem, when number of statements added 
0: 				*to a method is > 2048, remaing statements are added to  a new function
0: 				*and called from the function which created the function.
0: 				*See Beetle 5135 or 4293 for further details on this type of problem.
0: 				*/
0: 				if(currentConstMethod.statementNumHitLimit(1))
0: 				{
0: 					MethodBuilder genConstantMethod = acb.newGeneratedFun("void", Modifier.PRIVATE);
0: 					currentConstMethod.pushThis();
0: 					currentConstMethod.callMethod(VMOpcode.INVOKEVIRTUAL,
0: 												  (String) null, 
0: 												  genConstantMethod.getName(),
0: 												  "void", 0);
0: 					//if it is a generate function, close the metod.
0: 					if(currentConstMethod != cb){
0: 						currentConstMethod.methodReturn();
0: 						currentConstMethod.complete();
0: 					}
0: 					currentConstMethod = genConstantMethod;
0: 				}
0: 				setArrayMethod = currentConstMethod;
0: 			} else {
0: 				if (nonConstantMethod == null)
0: 					nonConstantMethod = acb.newGeneratedFun("void", Modifier.PROTECTED);
0: 				setArrayMethod = nonConstantMethod;
0: 
0: 			}
0: 
0: 			setArrayMethod.getField(arrayField); 
0: 			((ValueNode) argumentsList.elementAt(index)).generateExpression(acb, setArrayMethod);
0: 			setArrayMethod.upCast(receiverType);
0: 			setArrayMethod.setArrayElement(index);
0: 		}
0: 
0: 		//if a generated function was created to reduce the size of the methods close the functions.
0: 		if(currentConstMethod != cb){
0: 			currentConstMethod.methodReturn();
0: 			currentConstMethod.complete();
0: 		}
0: 
0: 		if (nonConstantMethod != null) {
0: 			nonConstantMethod.methodReturn();
0: 			nonConstantMethod.complete();
0: 			mb.pushThis();
0: 			mb.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null, nonConstantMethod.getName(), "void", 0);
0: 		}
0: 
0: 		/*
0: 		**  Call the method for coalesce/value function.
0: 		**	First generate following
0: 		**	<first non-param argument in the list>.method(<all the arguments>, <resultType>)
0: 		**	Next, if we are dealing with result type that is variable length, then generate a call to setWidth.
0: 		*/
0: 
0: 		firstNonParameterNode.generateExpression(acb, mb); //coalesce will be called on this non-parameter argument
0: 		mb.upCast(ClassName.DataValueDescriptor);
0: 
0: 		mb.getField(arrayField); // first arg to the coalesce function
0: 
0: 		//Following is for the second arg. This arg will be used to pass the return value.
0: 		//COALESCE method expects this to be initialized to NULL SQLxxx type object.
0: 		LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, receiverType);
0: 		acb.generateNull(mb, getTypeCompiler());
0: 		mb.upCast(ClassName.DataValueDescriptor);
0: 		mb.putField(field);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, "coalesce", receiverType, 2);
0: 		if (getTypeId().variableLength())//since result type is variable length, generate setWidth code.
0: 		{
0: 			boolean isNumber = getTypeId().isNumericTypeId();
0: 			mb.push(isNumber ? getTypeServices().getPrecision() : getTypeServices().getMaximumWidth());
0: 			mb.push(getTypeServices().getScale());
0: 			mb.push(true);
0: 			mb.callMethod(VMOpcode.INVOKEINTERFACE, ClassName.VariableSizeDataValue, "setWidth", ClassName.DataValueDescriptor, 3);
0: 		}
0: 	}
0: 
0: 	/*
0: 		print the non-node subfields
0: 	 */
0: 	public String toString() {
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return super.toString()+functionName+"("+argumentsList+")\n";
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: }
============================================================================