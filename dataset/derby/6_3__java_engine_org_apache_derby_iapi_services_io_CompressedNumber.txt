1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.io.CompressedNumber
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
98:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.services.io;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import java.io.*;
1:eac0369: 
6:eac0369: /**
1:eac0369: 	Static methods to write and read compressed forms of numbers
1:eac0369: 	to DataOut and DataIn interfaces. Format written is platform
1:eac0369: 	independent like the Data* interfaces and must remain fixed
1:eac0369: 	once a product is shipped. If a different format is required
1:eac0369: 	then write a new set of methods, e.g. writeInt2. The formats
1:eac0369: 	defined by stored format identifiers are implicitly dependent
1:eac0369: 	on these formats not changing.
1:eac0369: */
1:eac0369: 
1:eac0369: public abstract class CompressedNumber {
1:eac0369: 
1:eac0369: 	// the maximum number of bytes written out for an int
1:eac0369: 	public static final int MAX_INT_STORED_SIZE = 4;
1:eac0369: 
1:eac0369: 	// the maximum number of bytes written out for a long
1:eac0369: 	public static final int MAX_LONG_STORED_SIZE = 8;
1:eac0369: 
1:eac0369:     // largest int stored compressed in 1 byte
1:eac0369: 	public static final int MAX_COMPRESSED_INT_ONE_BYTE  = 0x3f;
1:eac0369: 
1:eac0369:     // largest int stored compressed in 2 bytes
1:eac0369: 	public static final int MAX_COMPRESSED_INT_TWO_BYTES = 0x3fff;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Write a compressed integer only supporting signed values.
1:eac0369: 		Formats are (with x representing value bits):
1:eac0369: 		<PRE>
1:dbed020: 		1 Byte - 00xxxxxx                              Represents the value &lt;= 63 (0x3f)
1:dbed020: 		2 Byte - 01xxxxxx xxxxxxxx                     Represents the value &gt; 63 &amp;&amp; &lt;= 16383 (0x3fff)
1:dbed020: 		4 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value &gt; 16383 &amp;&amp; &lt;= MAX_INT
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 
1:eac0369: 		@exception IOException value is negative or an exception was thrown by a method on out.
1:eac0369: 	*/
1:eac0369: 	public static final int writeInt(DataOutput out, int value) throws IOException {
1:eac0369: 
1:eac0369: 		if (value < 0)
1:eac0369: 			throw new IOException();
1:eac0369: 
1:eac0369: 		if (value <= 0x3f) {
1:eac0369: 
1:eac0369: 			out.writeByte(value);
2:eac0369: 			return 1;
48:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (value <= 0x3fff) {
1:eac0369: 
1:eac0369: 			out.writeByte(0x40 | (value >>> 8));
1:eac0369: 			out.writeByte(value & 0xff);
3:eac0369: 			return 2;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		out.writeByte(((value >>> 24) | 0x80) & 0xff);
1:eac0369: 		out.writeByte((value >>> 16) & 0xff);
1:eac0369: 		out.writeByte((value >>> 8) & 0xff);
1:eac0369: 		out.writeByte((value) & 0xff);
3:eac0369: 		return 4;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Write a compressed integer directly to an OutputStream.
4:eac0369: 		@exception IOException an exception was thrown by a method on in.
1:eac0369: 	*/
1:eac0369: 	public static final int writeInt(OutputStream out, int value) throws IOException {
1:eac0369: 
1:eac0369: 		if (value < 0)
1:eac0369: 			throw new IOException();
1:eac0369: 
1:eac0369: 		if (value <= 0x3f) {
1:eac0369: 
1:eac0369: 			out.write(value);
1:eac0369: 			return 1;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (value <= 0x3fff) {
1:eac0369: 
1:eac0369: 			out.write(0x40 | (value >>> 8));
1:eac0369: 			out.write(value & 0xff);
1:eac0369: 			return 2;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		out.write(((value >>> 24) | 0x80) & 0xff);
1:eac0369: 		out.write((value >>> 16) & 0xff);
1:eac0369: 		out.write((value >>> 8) & 0xff);
1:eac0369: 		out.write((value) & 0xff);
1:eac0369: 		return 4;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Read an integer previously written by writeInt().
1:eac0369: 
1:eac0369: 		@exception IOException an exception was thrown by a method on in.
1:eac0369: 	*/
1:eac0369: 	public static final int readInt(DataInput in) throws IOException {
1:eac0369: 
2:eac0369: 		int value = in.readUnsignedByte();
1:eac0369: 
2:eac0369:         if ((value & ~0x3f) == 0)
11:eac0369:         {
2:eac0369:             // length is stored in this byte, we also know that the 0x80 bit
2:eac0369:             // was not set, so no need to mask off the sign extension from
2:eac0369:             // the byte to int conversion.
1:eac0369: 
2:eac0369:             // account for 1 byte stored length of field + 1 for all returns
1:eac0369:             return(value);
1:eac0369:         }
2:eac0369: 		else if ((value & 0x80) == 0)
1:eac0369: 		{
2:eac0369:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
3:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
2:eac0369:                 SanityManager.ASSERT((value & 0x40) == 0x40);
1:eac0369:             }
1:eac0369: 
2:eac0369:             // top 8 bits of 2 byte length is stored in this byte, we also 
2:eac0369:             // know that the 0x80 bit was not set, so no need to mask off the 
3:eac0369:             // sign extension from the 1st byte to int conversion.  Need to
2:eac0369:             // mask the byte in data[offset + 1] to account for possible sign
2:eac0369:             // extension.
1:eac0369: 
1:eac0369:             return(((value & 0x3f) << 8) | in.readUnsignedByte());
1:eac0369: 		}
3:eac0369:         else
1:eac0369:         {
2:eac0369:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
2:eac0369:                 SanityManager.ASSERT((value & 0x80) == 0x80);
1:eac0369:             }
1:eac0369: 
2:eac0369:             // top 8 bits of 4 byte length is stored in this byte, we also 
2:eac0369:             // know that the 0x80 bit was set, so need to mask off the 
1:eac0369:             // sign extension from the 1st byte to int conversion.  Need to
2:eac0369:             // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
2:eac0369:             // account for possible sign extension.
3:eac0369:             //
2:eac0369:             return(
1:eac0369:                  ((value & 0x7f)        << 24) |
1:eac0369:                  (in.readUnsignedByte() << 16) |
1:eac0369:                  (in.readUnsignedByte() <<  8) |
1:eac0369:                  (in.readUnsignedByte()      ));
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Read an integer previously written by writeInt().
1:eac0369: 
1:eac0369: 		@exception IOException an exception was thrown by a method on in.
1:eac0369: 	*/
1:eac0369: 	public static final int readInt(InputStream in) throws IOException {
1:eac0369: 
3:eac0369: 		int value = InputStreamUtil.readUnsignedByte(in);
1:eac0369: 
1:eac0369:         if ((value & ~0x3f) == 0)
1:eac0369:         {
1:eac0369:             return(value);
1:eac0369:         }
1:eac0369: 		else if ((value & 0x80) == 0)
1:eac0369: 		{
1:eac0369:             return(
1:eac0369:                 ((value & 0x3f) << 8) | InputStreamUtil.readUnsignedByte(in));
1:eac0369: 		}
1:eac0369:         else
1:eac0369: 		{
1:eac0369:             return(
1:eac0369:                 ((value          & 0x7f)              << 24) |
1:eac0369:                 (InputStreamUtil.readUnsignedByte(in) << 16) |
1:eac0369:                 (InputStreamUtil.readUnsignedByte(in) <<  8) |
1:eac0369:                 (InputStreamUtil.readUnsignedByte(in)      ));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final int readInt(
1:eac0369:     byte[]    data,
1:eac0369:     int       offset) 
1:eac0369:     {
1:eac0369: 		int value = data[offset++];
1:eac0369: 
1:eac0369:         if ((value & ~0x3f) == 0)
1:eac0369:         {
1:eac0369:             // length is stored in this byte, we also know that the 0x80 bit
1:eac0369:             // was not set, so no need to mask off the sign extension from
1:eac0369:             // the byte to int conversion.
1:eac0369: 
1:eac0369:             return(value);
1:eac0369:         }
1:eac0369: 		else if ((value & 0x80) == 0)
1:eac0369: 		{
1:eac0369:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT((value & 0x40) == 0x40);
1:eac0369:             }
1:eac0369: 
1:eac0369:             // top 8 bits of 2 byte length is stored in this byte, we also 
1:eac0369:             // know that the 0x80 bit was not set, so no need to mask off the 
1:eac0369:             // sign extension from the 1st byte to int conversion.  Need to
1:eac0369:             // mask the byte in data[offset + 1] to account for possible sign
1:eac0369:             // extension.
1:eac0369: 
1:eac0369:             return(((value & 0x3f) << 8) | (data[offset] & 0xff));
1:eac0369: 		}
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT((value & 0x80) == 0x80);
1:eac0369:             }
1:eac0369: 
1:eac0369:             // top 8 bits of 4 byte length is stored in this byte, we also 
1:eac0369:             // know that the 0x80 bit was set, so need to mask off the 
1:eac0369:             // sign extension from the 1st byte to int conversion.  Need to
1:eac0369:             // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
1:eac0369:             // account for possible sign extension.
1:eac0369:             //
1:eac0369:             return(
1:eac0369:                 ((value          & 0x7f) << 24) |
1:eac0369:                 ((data[offset++] & 0xff) << 16) |
1:eac0369:                 ((data[offset++] & 0xff) <<  8) |
1:eac0369:                 ((data[offset]   & 0xff)      ));
1:eac0369:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 		Skip an integer previously written by writeInt().
1:eac0369: 
1:eac0369: 		@exception IOException an exception was thrown by a method on in.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the number of bytes that would be written by a writeInt call
1:eac0369: 	*/
1:eac0369: 	public static final int sizeInt(int value) {
1:eac0369: 		if (value <= 0x3f) {
1:eac0369: 			return 1;
1:eac0369: 		}
1:eac0369: 		if (value <= 0x3fff) {
1:eac0369: 			return 2;
1:eac0369: 		}
1:eac0369: 		return 4;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Write a compressed long only supporting signed values.
1:eac0369: 
1:eac0369: 		Formats are (with x representing value bits):
1:eac0369: 		<PRE>
1:dbed020: 		2 byte - 00xxxxxx xxxxxxxx                     Represents the value &lt;= 16383 (0x3fff)
1:dbed020: 		4 byte - 01xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value &gt; 16383  &amp;&amp; &lt;= 0x3fffffff
1:dbed020: 		8 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value &gt; 0x3fffffff &amp;&amp; &lt;= MAX_LONG
1:eac0369: 		</PRE>
1:eac0369: 
1:eac0369: 
1:eac0369: 		@exception IOException value is negative or an exception was thrown by a method on out.
1:eac0369: 	*/
1:eac0369: 	public static final int writeLong(DataOutput out, long value) throws IOException {
1:eac0369: 
1:eac0369: 		if (value < 0)
1:eac0369: 			throw new IOException();
1:eac0369: 
1:eac0369: 		if (value <= 0x3fff) {
1:eac0369: 
1:eac0369: 			out.writeByte((int) ((value >>> 8) & 0xff));
1:eac0369: 			out.writeByte((int) ((value      ) & 0xff));
1:eac0369: 			return 2;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (value <= 0x3fffffff) {
1:eac0369: 
1:eac0369: 			out.writeByte((int) (((value >>> 24) | 0x40) & 0xff));
1:eac0369: 			out.writeByte((int) ( (value >>> 16) & 0xff));
1:eac0369: 			out.writeByte((int) ( (value >>>  8) & 0xff));
1:eac0369: 			out.writeByte((int) ( (value       ) & 0xff));
1:eac0369: 			return 4;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		out.writeByte((int) (((value >>> 56) | 0x80) & 0xff));
1:eac0369: 		out.writeByte((int) ( (value >>> 48) & 0xff));
1:eac0369: 		out.writeByte((int) ( (value >>> 40) & 0xff));
1:eac0369: 		out.writeByte((int) ( (value >>> 32) & 0xff));
1:eac0369: 		out.writeByte((int) ( (value >>> 24) & 0xff));
1:eac0369: 		out.writeByte((int) ( (value >>> 16) & 0xff));
1:eac0369: 		out.writeByte((int) ( (value >>>  8) & 0xff));
1:eac0369: 		out.writeByte((int) ( (value       ) & 0xff));
2:eac0369: 		return 8;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Write a compressed integer only supporting signed values.
1:eac0369: 
1:eac0369: 		@exception IOException value is negative or an exception was thrown by a method on out.
1:eac0369: 	*/
1:eac0369: 	public static final int writeLong(OutputStream out, long value) throws IOException {
1:eac0369: 
1:eac0369: 		if (value < 0)
1:eac0369: 			throw new IOException();
1:eac0369: 
1:eac0369: 		if (value <= 0x3fff) {
1:eac0369: 
1:eac0369: 			out.write((int) ((value >>> 8) & 0xff));
1:eac0369: 			out.write((int) ((value      ) & 0xff));
1:eac0369: 			return 2;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (value <= 0x3fffffff) {
1:eac0369: 
1:eac0369: 			out.write((int) (((value >>> 24) | 0x40) & 0xff));
1:eac0369: 			out.write((int) ( (value >>> 16) & 0xff));
1:eac0369: 			out.write((int) ( (value >>>  8) & 0xff));
1:eac0369: 			out.write((int) ( (value       ) & 0xff));
1:eac0369: 			return 4;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		out.write((int) (((value >>> 56) | 0x80) & 0xff));
1:eac0369: 		out.write((int) ( (value >>> 48) & 0xff));
1:eac0369: 		out.write((int) ( (value >>> 40) & 0xff));
1:eac0369: 		out.write((int) ( (value >>> 32) & 0xff));
1:eac0369: 		out.write((int) ( (value >>> 24) & 0xff));
1:eac0369: 		out.write((int) ( (value >>> 16) & 0xff));
1:eac0369: 		out.write((int) ( (value >>>  8) & 0xff));
1:eac0369: 		out.write((int) ( (value       ) & 0xff));
1:eac0369: 		return 8;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Read a long previously written by writeLong().
1:eac0369: 
1:eac0369: 		@exception IOException an exception was thrown by a method on in.
1:eac0369: 	*/
1:eac0369: 	public static final long readLong(DataInput in) throws IOException {
1:eac0369: 
1:eac0369: 		int int_value = in.readUnsignedByte();
1:eac0369: 
1:eac0369:         if ((int_value & ~0x3f) == 0)
1:eac0369:         {
1:eac0369:             // test for small case first - assuming this is usual case.
1:eac0369:             // this is stored in 2 bytes.
1:eac0369: 
1:eac0369:             return((int_value << 8) | in.readUnsignedByte());
1:eac0369: 		}
1:eac0369: 		else if ((int_value & 0x80) == 0)
1:eac0369: 		{
1:eac0369:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:             return(
1:eac0369:                 ((int_value & 0x3f)      << 24) |
1:eac0369:                 (in.readUnsignedByte()   << 16) |
1:eac0369:                 (in.readUnsignedByte()   <<  8) |
1:eac0369:                 (in.readUnsignedByte()));
1:eac0369: 		} 
1:eac0369:         else
1:eac0369: 		{
1:eac0369:             // value is stored in 8 bytes.  only use low 7 bits from 1st byte.
1:eac0369:             return(
1:eac0369:                 (((long) (int_value & 0x7f)   ) << 56) |
1:eac0369:                 (((long) in.readUnsignedByte()) << 48) |
1:eac0369:                 (((long) in.readUnsignedByte()) << 40) |
1:eac0369:                 (((long) in.readUnsignedByte()) << 32) |
1:eac0369:                 (((long) in.readUnsignedByte()) << 24) |
1:eac0369:                 (((long) in.readUnsignedByte()) << 16) |
1:eac0369:                 (((long) in.readUnsignedByte()) <<  8) |
1:eac0369:                 (((long) in.readUnsignedByte())      ));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Read a long previously written by writeLong().
1:eac0369: 
1:eac0369: 		@exception IOException an exception was thrown by a method on in.
1:eac0369: 	*/
1:eac0369: 	public static final long readLong(InputStream in) throws IOException {
1:eac0369: 
1:eac0369: 		int int_value = InputStreamUtil.readUnsignedByte(in);
1:eac0369: 
1:eac0369:         if ((int_value & ~0x3f) == 0)
1:eac0369:         {
1:eac0369:             // test for small case first - assuming this is usual case.
1:eac0369:             // this is stored in 2 bytes.
1:eac0369: 
1:eac0369:             return((int_value << 8) | InputStreamUtil.readUnsignedByte(in));
1:eac0369: 		}
1:eac0369: 		else if ((int_value & 0x80) == 0)
1:eac0369: 		{
1:eac0369:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:             return(
1:eac0369:                 ((int_value      & 0x3f)              << 24) |
1:eac0369:                 (InputStreamUtil.readUnsignedByte(in) << 16) |
1:eac0369:                 (InputStreamUtil.readUnsignedByte(in) <<  8) |
1:eac0369:                 (InputStreamUtil.readUnsignedByte(in)      ));
1:eac0369: 
1:eac0369: 		} 
1:eac0369:         else
1:eac0369: 		{
1:eac0369:             // value is stored in 8 bytes.  only use low 7 bits from 1st byte.
1:eac0369:             long value = int_value;
1:eac0369: 
1:eac0369:             return(
1:eac0369:                 (((long) (value & 0x7f)                      ) << 56) |
1:eac0369:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 48) |
1:eac0369:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 40) |
1:eac0369:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 32) |
1:eac0369:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 24) |
1:eac0369:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 16) |
1:eac0369:                 (((long) InputStreamUtil.readUnsignedByte(in)) <<  8) |
1:eac0369:                 (((long) InputStreamUtil.readUnsignedByte(in))      ));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final long readLong(
2:eac0369:     byte[]  data,
2:eac0369:     int     offset)
1:eac0369:     {
1:eac0369: 		int int_value = data[offset++];
1:eac0369: 
1:eac0369:         if ((int_value & ~0x3f) == 0)
1:eac0369:         {
1:eac0369:             // test for small case first - assuming this is usual case.
1:eac0369:             // this is stored in 2 bytes.
1:eac0369: 
1:eac0369:             return((int_value << 8) | (data[offset] & 0xff));
1:eac0369: 		}
1:eac0369: 		else if ((int_value & 0x80) == 0)
1:eac0369: 		{
1:eac0369:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
1:eac0369: 
1:eac0369:             return(
1:eac0369:                 ((int_value      & 0x3f) << 24) |
1:eac0369:                 ((data[offset++] & 0xff) << 16) |
1:eac0369:                 ((data[offset++] & 0xff) <<  8) |
1:eac0369:                 ((data[offset]   & 0xff)      ));
1:eac0369: 
1:eac0369: 		} 
1:eac0369:         else
1:eac0369: 		{
1:eac0369:             // value is stored in 8 bytes.  only use low 6 bits from 1st byte.
1:eac0369:             return(
1:eac0369:                 (((long) (int_value      & 0x7f)) << 56) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 48) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 40) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 32) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 24) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) << 16) |
1:eac0369:                 (((long) (data[offset++] & 0xff)) <<  8) |
1:eac0369:                 (((long) (data[offset]   & 0xff))      ));
1:eac0369: 
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public static final int sizeLong(long value) {
1:eac0369: 
1:eac0369: 		if (value <= 0x3fff) {
1:eac0369: 
1:eac0369: 			return 2;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (value <= 0x3fffffff) {
1:eac0369: 			return 4;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return 8;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 		1 Byte - 00xxxxxx                              Represents the value &lt;= 63 (0x3f)
1: 		2 Byte - 01xxxxxx xxxxxxxx                     Represents the value &gt; 63 &amp;&amp; &lt;= 16383 (0x3fff)
1: 		4 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value &gt; 16383 &amp;&amp; &lt;= MAX_INT
/////////////////////////////////////////////////////////////////////////
1: 		2 byte - 00xxxxxx xxxxxxxx                     Represents the value &lt;= 16383 (0x3fff)
1: 		4 byte - 01xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value &gt; 16383  &amp;&amp; &lt;= 0x3fffffff
1: 		8 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value &gt; 0x3fffffff &amp;&amp; &lt;= MAX_LONG
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:cd822eb
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:373cb84
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.io.CompressedNumber
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.io
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.io;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import java.io.*;
1: 
1: /**
1: 	Static methods to write and read compressed forms of numbers
1: 	to DataOut and DataIn interfaces. Format written is platform
1: 	independent like the Data* interfaces and must remain fixed
1: 	once a product is shipped. If a different format is required
1: 	then write a new set of methods, e.g. writeInt2. The formats
1: 	defined by stored format identifiers are implicitly dependent
1: 	on these formats not changing.
1: */
1: 
1: public abstract class CompressedNumber {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1: 	// the maximum number of bytes written out for an int
1: 	public static final int MAX_INT_STORED_SIZE = 4;
1: 
1: 	// the maximum number of bytes written out for a long
1: 	public static final int MAX_LONG_STORED_SIZE = 8;
1: 
1:     // largest int stored compressed in 1 byte
1: 	public static final int MAX_COMPRESSED_INT_ONE_BYTE  = 0x3f;
1: 
1:     // largest int stored compressed in 2 bytes
1: 	public static final int MAX_COMPRESSED_INT_TWO_BYTES = 0x3fff;
1: 
1: 
1: 	/**
1: 		Write a compressed integer only supporting signed values.
1: 		Formats are (with x representing value bits):
1: 		<PRE>
0: 		1 Byte - 00xxxxxx                              Represents the value <= 63 (0x3f)
0: 		2 Byte - 01xxxxxx xxxxxxxx                     Represents the value > 63 && <= 16383 (0x3fff)
0: 		4 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value > 16383 && <= MAX_INT
1: 		</PRE>
1: 
1: 
1: 		@exception IOException value is negative or an exception was thrown by a method on out.
1: 	*/
1: 	public static final int writeInt(DataOutput out, int value) throws IOException {
1: 
1: 		if (value < 0)
1: 			throw new IOException();
1: 
1: 		if (value <= 0x3f) {
1: 
1: 			out.writeByte(value);
1: 			return 1;
1: 		}
1: 
1: 		if (value <= 0x3fff) {
1: 
1: 			out.writeByte(0x40 | (value >>> 8));
1: 			out.writeByte(value & 0xff);
1: 			return 2;
1: 		}
1: 
1: 		out.writeByte(((value >>> 24) | 0x80) & 0xff);
1: 		out.writeByte((value >>> 16) & 0xff);
1: 		out.writeByte((value >>> 8) & 0xff);
1: 		out.writeByte((value) & 0xff);
1: 		return 4;
1: 	}
1: 
1: 	/**
1: 		Write a compressed integer directly to an OutputStream.
1: 		@exception IOException an exception was thrown by a method on in.
1: 	*/
1: 	public static final int writeInt(OutputStream out, int value) throws IOException {
1: 
1: 		if (value < 0)
1: 			throw new IOException();
1: 
1: 		if (value <= 0x3f) {
1: 
1: 			out.write(value);
1: 			return 1;
1: 		}
1: 
1: 		if (value <= 0x3fff) {
1: 
1: 			out.write(0x40 | (value >>> 8));
1: 			out.write(value & 0xff);
1: 			return 2;
1: 		}
1: 
1: 		out.write(((value >>> 24) | 0x80) & 0xff);
1: 		out.write((value >>> 16) & 0xff);
1: 		out.write((value >>> 8) & 0xff);
1: 		out.write((value) & 0xff);
1: 		return 4;
1: 	}
1: 
1: 
1: 	/**
1: 		Read an integer previously written by writeInt().
1: 
1: 		@exception IOException an exception was thrown by a method on in.
1: 	*/
1: 	public static final int readInt(DataInput in) throws IOException {
1: 
1: 		int value = in.readUnsignedByte();
1: 
1:         if ((value & ~0x3f) == 0)
1:         {
1:             // length is stored in this byte, we also know that the 0x80 bit
1:             // was not set, so no need to mask off the sign extension from
1:             // the byte to int conversion.
1: 
1:             // account for 1 byte stored length of field + 1 for all returns
1:             return(value);
1:         }
1: 		else if ((value & 0x80) == 0)
1: 		{
1:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT((value & 0x40) == 0x40);
1:             }
1: 
1:             // top 8 bits of 2 byte length is stored in this byte, we also 
1:             // know that the 0x80 bit was not set, so no need to mask off the 
1:             // sign extension from the 1st byte to int conversion.  Need to
1:             // mask the byte in data[offset + 1] to account for possible sign
1:             // extension.
1: 
1:             return(((value & 0x3f) << 8) | in.readUnsignedByte());
1: 		}
1:         else
1:         {
1:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT((value & 0x80) == 0x80);
1:             }
1: 
1:             // top 8 bits of 4 byte length is stored in this byte, we also 
1:             // know that the 0x80 bit was set, so need to mask off the 
1:             // sign extension from the 1st byte to int conversion.  Need to
1:             // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
1:             // account for possible sign extension.
1:             //
1:             return(
1:                  ((value & 0x7f)        << 24) |
1:                  (in.readUnsignedByte() << 16) |
1:                  (in.readUnsignedByte() <<  8) |
1:                  (in.readUnsignedByte()      ));
1:         }
1: 	}
1: 
1: 	/**
1: 		Read an integer previously written by writeInt().
1: 
1: 		@exception IOException an exception was thrown by a method on in.
1: 	*/
1: 	public static final int readInt(InputStream in) throws IOException {
1: 
1: 		int value = InputStreamUtil.readUnsignedByte(in);
1: 
1:         if ((value & ~0x3f) == 0)
1:         {
1:             return(value);
1:         }
1: 		else if ((value & 0x80) == 0)
1: 		{
1:             return(
1:                 ((value & 0x3f) << 8) | InputStreamUtil.readUnsignedByte(in));
1: 		}
1:         else
1: 		{
1:             return(
1:                 ((value          & 0x7f)              << 24) |
1:                 (InputStreamUtil.readUnsignedByte(in) << 16) |
1:                 (InputStreamUtil.readUnsignedByte(in) <<  8) |
1:                 (InputStreamUtil.readUnsignedByte(in)      ));
1: 		}
1: 	}
1: 
1: 	public static final int readInt(
1:     byte[]    data,
1:     int       offset) 
1:     {
1: 		int value = data[offset++];
1: 
1:         if ((value & ~0x3f) == 0)
1:         {
1:             // length is stored in this byte, we also know that the 0x80 bit
1:             // was not set, so no need to mask off the sign extension from
1:             // the byte to int conversion.
1: 
1:             return(value);
1:         }
1: 		else if ((value & 0x80) == 0)
1: 		{
1:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT((value & 0x40) == 0x40);
1:             }
1: 
1:             // top 8 bits of 2 byte length is stored in this byte, we also 
1:             // know that the 0x80 bit was not set, so no need to mask off the 
1:             // sign extension from the 1st byte to int conversion.  Need to
1:             // mask the byte in data[offset + 1] to account for possible sign
1:             // extension.
1: 
1:             return(((value & 0x3f) << 8) | (data[offset] & 0xff));
1: 		}
1:         else
1:         {
1:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT((value & 0x80) == 0x80);
1:             }
1: 
1:             // top 8 bits of 4 byte length is stored in this byte, we also 
1:             // know that the 0x80 bit was set, so need to mask off the 
1:             // sign extension from the 1st byte to int conversion.  Need to
1:             // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
1:             // account for possible sign extension.
1:             //
1:             return(
1:                 ((value          & 0x7f) << 24) |
1:                 ((data[offset++] & 0xff) << 16) |
1:                 ((data[offset++] & 0xff) <<  8) |
1:                 ((data[offset]   & 0xff)      ));
1:         }
1: 	}
1: 
1:     /**
0:      * Return the compressed Int value + stored size of the length + 1
0:      * <p>
0:      * Given offset in array to beginning of compressed int, return the 
0:      * value of the compressed int + the number of bytes used to store the
0:      * length.
0:      * <p>
0:      * So 1 byte lengths will return: length + 1 + 1
0:      * So 2 byte lengths will return: length + 2 + 1
0:      * So 4 byte lengths will return: length + 4 + 1
0:      * <p>
0:      * Note that this routine will not work for lengths MAX_INT - (MAX_INT - 5).
0:      * <p>
0:      * This routine is currently used by the StorePage code to skip fields
0:      * as efficiently as possible.  Since the page size is less than 
0:      * (MAX_INT - 5) it is all right to use this routine.
0:      *
0: 	 * @return compressed int value + length used to store the length.
0:      *
0:      * @param data   byte array containing the field.
0:      * @param offset offset to beginning of field, ie. data[offset] contains
0:      *               1st byte of the compressed int.
0:      **/
0: 	public static final int readIntAndReturnIntPlusOverhead(
1:     byte[]  data,
1:     int     offset)
1:     {
0:         int value = data[offset];
1: 
1:         if ((value & ~0x3f) == 0)
1:         {
1:             // length is stored in this byte, we also know that the 0x80 bit
1:             // was not set, so no need to mask off the sign extension from
1:             // the byte to int conversion.
1: 
1:             // account for 1 byte stored length of field + 1 for all returns
0:             return(value + 2);
1:         }
1: 		else if ((value & 0x80) == 0)
1: 		{
1:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT((value & 0x40) == 0x40);
1:             }
1: 
1:             // top 8 bits of 2 byte length is stored in this byte, we also 
1:             // know that the 0x80 bit was not set, so no need to mask off the 
1:             // sign extension from the 1st byte to int conversion.  Need to
1:             // mask the byte in data[offset + 1] to account for possible sign
1:             // extension.
1: 
0:             // add 3 to account for 2 byte length + 1 added to all returns
1: 
0:             return((((value & 0x3f) << 8) | (data[offset + 1] & 0xff)) + 3);
1: 		}
1:         else
1:         {
1:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT((value & 0x80) == 0x80);
1:             }
1: 
1:             // top 8 bits of 4 byte length is stored in this byte, we also 
1:             // know that the 0x80 bit was set, so need to mask off the 
1:             // sign extension from the 1st byte to int conversion.  Need to
1:             // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
1:             // account for possible sign extension.
1: 
1: 
0:             // add 5 to account for 4 byte length + 1 added to all returns
1:             return(
0:                 (((value            & 0x7f) << 24) |
0:                  ((data[offset + 1] & 0xff) << 16) |
0:                  ((data[offset + 2] & 0xff) <<  8) |
0:                   (data[offset + 3] & 0xff)) + 5);
1:         }
1: 	}
1: 
1: 
1: 	/**
1: 		Skip an integer previously written by writeInt().
1: 
1: 		@exception IOException an exception was thrown by a method on in.
1: 	*/
0: 	public static final int skipInt(DataInput in) throws IOException {
1: 
1: 		int value = in.readUnsignedByte();
1: 
0: 		if ((value & 0x80) == 0x80) {
0: 			in.skipBytes(3);
1: 			return 4;
1: 		}
1: 
0: 		if ((value & 0x40) == 0x40) {
0: 			in.skipBytes(1);
1: 			return 2;
1: 		}
1: 
1: 		return 1;
1: 	}
1: 
1: 	/**
1: 		Skip an integer previously written by writeInt().
1: 
1: 		@exception IOException an exception was thrown by a method on in.
1: 	*/
0: 	public static final int skipInt(InputStream in) throws IOException {
1: 
1: 		int value = InputStreamUtil.readUnsignedByte(in);
1: 
0: 		int skipBytes = 0;
1: 
0: 		if ((value & 0x80) == 0x80) {
0: 			skipBytes = 3;
1: 		}
0: 		else if ((value & 0x40) == 0x40) {
0: 			skipBytes = 1;
1: 		}
1: 
0: 		if (skipBytes != 0) {
0: 			if (in.skip(skipBytes) != skipBytes)
0: 				throw new EOFException();
1: 		}
1: 
1: 
0: 		return skipBytes + 1;
1: 	}
1: 
1: 	/**
1: 		Return the number of bytes that would be written by a writeInt call
1: 	*/
1: 	public static final int sizeInt(int value) {
1: 		if (value <= 0x3f) {
1: 			return 1;
1: 		}
1: 		if (value <= 0x3fff) {
1: 			return 2;
1: 		}
1: 		return 4;
1: 	}
1: 
1: 	/**
1: 		Write a compressed long only supporting signed values.
1: 
1: 		Formats are (with x representing value bits):
1: 		<PRE>
0: 		2 byte - 00xxxxxx xxxxxxxx                     Represents the value <= 16383 (0x3fff)
0: 		4 byte - 01xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value > 16383  && <= 0x3fffffff
0: 		8 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value > 0x3fffffff && <= MAX_LONG
1: 		</PRE>
1: 
1: 
1: 		@exception IOException value is negative or an exception was thrown by a method on out.
1: 	*/
1: 	public static final int writeLong(DataOutput out, long value) throws IOException {
1: 
1: 		if (value < 0)
1: 			throw new IOException();
1: 
1: 		if (value <= 0x3fff) {
1: 
1: 			out.writeByte((int) ((value >>> 8) & 0xff));
1: 			out.writeByte((int) ((value      ) & 0xff));
1: 			return 2;
1: 		}
1: 
1: 		if (value <= 0x3fffffff) {
1: 
1: 			out.writeByte((int) (((value >>> 24) | 0x40) & 0xff));
1: 			out.writeByte((int) ( (value >>> 16) & 0xff));
1: 			out.writeByte((int) ( (value >>>  8) & 0xff));
1: 			out.writeByte((int) ( (value       ) & 0xff));
1: 			return 4;
1: 		}
1: 
1: 		out.writeByte((int) (((value >>> 56) | 0x80) & 0xff));
1: 		out.writeByte((int) ( (value >>> 48) & 0xff));
1: 		out.writeByte((int) ( (value >>> 40) & 0xff));
1: 		out.writeByte((int) ( (value >>> 32) & 0xff));
1: 		out.writeByte((int) ( (value >>> 24) & 0xff));
1: 		out.writeByte((int) ( (value >>> 16) & 0xff));
1: 		out.writeByte((int) ( (value >>>  8) & 0xff));
1: 		out.writeByte((int) ( (value       ) & 0xff));
1: 		return 8;
1: 	}
1: 	/**
1: 		Write a compressed integer only supporting signed values.
1: 
1: 		@exception IOException value is negative or an exception was thrown by a method on out.
1: 	*/
1: 	public static final int writeLong(OutputStream out, long value) throws IOException {
1: 
1: 		if (value < 0)
1: 			throw new IOException();
1: 
1: 		if (value <= 0x3fff) {
1: 
1: 			out.write((int) ((value >>> 8) & 0xff));
1: 			out.write((int) ((value      ) & 0xff));
1: 			return 2;
1: 		}
1: 
1: 		if (value <= 0x3fffffff) {
1: 
1: 			out.write((int) (((value >>> 24) | 0x40) & 0xff));
1: 			out.write((int) ( (value >>> 16) & 0xff));
1: 			out.write((int) ( (value >>>  8) & 0xff));
1: 			out.write((int) ( (value       ) & 0xff));
1: 			return 4;
1: 		}
1: 
1: 		out.write((int) (((value >>> 56) | 0x80) & 0xff));
1: 		out.write((int) ( (value >>> 48) & 0xff));
1: 		out.write((int) ( (value >>> 40) & 0xff));
1: 		out.write((int) ( (value >>> 32) & 0xff));
1: 		out.write((int) ( (value >>> 24) & 0xff));
1: 		out.write((int) ( (value >>> 16) & 0xff));
1: 		out.write((int) ( (value >>>  8) & 0xff));
1: 		out.write((int) ( (value       ) & 0xff));
1: 		return 8;
1: 	}
1: 
1: 	/**
1: 		Read a long previously written by writeLong().
1: 
1: 		@exception IOException an exception was thrown by a method on in.
1: 	*/
1: 	public static final long readLong(DataInput in) throws IOException {
1: 
1: 		int int_value = in.readUnsignedByte();
1: 
1:         if ((int_value & ~0x3f) == 0)
1:         {
1:             // test for small case first - assuming this is usual case.
1:             // this is stored in 2 bytes.
1: 
1:             return((int_value << 8) | in.readUnsignedByte());
1: 		}
1: 		else if ((int_value & 0x80) == 0)
1: 		{
1:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
1: 
1:             return(
1:                 ((int_value & 0x3f)      << 24) |
1:                 (in.readUnsignedByte()   << 16) |
1:                 (in.readUnsignedByte()   <<  8) |
1:                 (in.readUnsignedByte()));
1: 		} 
1:         else
1: 		{
1:             // value is stored in 8 bytes.  only use low 7 bits from 1st byte.
1:             return(
1:                 (((long) (int_value & 0x7f)   ) << 56) |
1:                 (((long) in.readUnsignedByte()) << 48) |
1:                 (((long) in.readUnsignedByte()) << 40) |
1:                 (((long) in.readUnsignedByte()) << 32) |
1:                 (((long) in.readUnsignedByte()) << 24) |
1:                 (((long) in.readUnsignedByte()) << 16) |
1:                 (((long) in.readUnsignedByte()) <<  8) |
1:                 (((long) in.readUnsignedByte())      ));
1: 		}
1: 	}
1: 
1: 	/**
1: 		Read a long previously written by writeLong().
1: 
1: 		@exception IOException an exception was thrown by a method on in.
1: 	*/
1: 	public static final long readLong(InputStream in) throws IOException {
1: 
1: 		int int_value = InputStreamUtil.readUnsignedByte(in);
1: 
1:         if ((int_value & ~0x3f) == 0)
1:         {
1:             // test for small case first - assuming this is usual case.
1:             // this is stored in 2 bytes.
1: 
1:             return((int_value << 8) | InputStreamUtil.readUnsignedByte(in));
1: 		}
1: 		else if ((int_value & 0x80) == 0)
1: 		{
1:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
1: 
1:             return(
1:                 ((int_value      & 0x3f)              << 24) |
1:                 (InputStreamUtil.readUnsignedByte(in) << 16) |
1:                 (InputStreamUtil.readUnsignedByte(in) <<  8) |
1:                 (InputStreamUtil.readUnsignedByte(in)      ));
1: 
1: 		} 
1:         else
1: 		{
1:             // value is stored in 8 bytes.  only use low 7 bits from 1st byte.
1:             long value = int_value;
1: 
1:             return(
1:                 (((long) (value & 0x7f)                      ) << 56) |
1:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 48) |
1:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 40) |
1:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 32) |
1:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 24) |
1:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 16) |
1:                 (((long) InputStreamUtil.readUnsignedByte(in)) <<  8) |
1:                 (((long) InputStreamUtil.readUnsignedByte(in))      ));
1: 		}
1: 	}
1: 
1: 	public static final long readLong(
1:     byte[]  data,
1:     int     offset)
1:     {
1: 		int int_value = data[offset++];
1: 
1:         if ((int_value & ~0x3f) == 0)
1:         {
1:             // test for small case first - assuming this is usual case.
1:             // this is stored in 2 bytes.
1: 
1:             return((int_value << 8) | (data[offset] & 0xff));
1: 		}
1: 		else if ((int_value & 0x80) == 0)
1: 		{
1:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
1: 
1:             return(
1:                 ((int_value      & 0x3f) << 24) |
1:                 ((data[offset++] & 0xff) << 16) |
1:                 ((data[offset++] & 0xff) <<  8) |
1:                 ((data[offset]   & 0xff)      ));
1: 
1: 		} 
1:         else
1: 		{
1:             // value is stored in 8 bytes.  only use low 6 bits from 1st byte.
1:             return(
1:                 (((long) (int_value      & 0x7f)) << 56) |
1:                 (((long) (data[offset++] & 0xff)) << 48) |
1:                 (((long) (data[offset++] & 0xff)) << 40) |
1:                 (((long) (data[offset++] & 0xff)) << 32) |
1:                 (((long) (data[offset++] & 0xff)) << 24) |
1:                 (((long) (data[offset++] & 0xff)) << 16) |
1:                 (((long) (data[offset++] & 0xff)) <<  8) |
1:                 (((long) (data[offset]   & 0xff))      ));
1: 
1: 		}
1: 	}
1: 
1: 	/**
0: 		Skip a long previously written by writeLong().
1: 
1: 		@exception IOException an exception was thrown by a method on in.
1: 	*/
0: 	public static final int skipLong(DataInput in) throws IOException {
1: 
0: 		long value = in.readUnsignedByte();
1: 
0: 		if ((value & 0x80) == 0x80)
1: 		{
0: 			in.skipBytes(7);
1: 			return 8;
1: 		}
1: 		
1: 		
0: 		if ((value & 0x40) == 0x40)
1: 		{
0: 			in.skipBytes(3);
1: 			return 4;
1: 
1: 		}
1: 
0: 		in.skipBytes(1);
1: 		return 2;
1: 	}
1: 
1: 	/**
0: 		Skip a long previously written by writeLong().
1: 
1: 		@exception IOException an exception was thrown by a method on in.
1: 	*/
0: 	public static final int skipLong(InputStream in) throws IOException {
1: 
1: 		int value = InputStreamUtil.readUnsignedByte(in);
1: 
0: 		int skipBytes;
1: 
0: 		if ((value & 0x80) == 0x80) {
0: 			skipBytes = 7;
1: 		}
0: 		else if ((value & 0x40) == 0x40) {
0: 			skipBytes = 3;
1: 		}
1: 		else
0: 			skipBytes = 1;
1: 
0: 		if (in.skip(skipBytes) != skipBytes)
0: 			throw new EOFException();
1: 
0: 		return skipBytes + 1;
1: 	}
1: 
1: 	public static final int sizeLong(long value) {
1: 
1: 		if (value <= 0x3fff) {
1: 
1: 			return 2;
1: 		}
1: 
1: 		if (value <= 0x3fffffff) {
1: 			return 4;
1: 		}
1: 
1: 		return 8;
1: 	}
1: 
0: // /* FOR TESTING
0: // *****************************************************
1: 
0:   	private static byte[] holder = new byte[8];
0: 	private static  ArrayOutputStream aos = new ArrayOutputStream(holder);
0: 	private static  DataOutput out = new DataOutputStream(aos);
1: 
0: 	private static  ArrayInputStream ais = new ArrayInputStream(holder);
0: 	private static  DataInput in = new DataInputStream(ais);
0: 	private static  InputStream in_stream = ais;
1: 
1: 
0:     private static short checkInt(int i, short oldLength) throws IOException {
1: 
0: 		aos.setPosition(0);
0: 		int length = CompressedNumber.writeInt(out, i);
0: 		if (length != oldLength) {
0: 			System.out.println("changing length to " + length + " at value " + i + " 0x" + Integer.toHexString(i));
1: 
0: 			oldLength = (short) length;
1: 		}
1: 
0: 		int writtenBytes = aos.getPosition();
0: 		if (writtenBytes != length) {
0: 			System.out.println("MISMATCH written bytes  expected " + length + " got " + writtenBytes);
0: 			System.exit(1);
1: 		}
1: 
0: 		if (length != CompressedNumber.sizeInt(i)) {
0: 			System.out.println("MISMATCH sizeInt() bytes  expected " + length + " got " + CompressedNumber.sizeInt(i));
0: 			System.exit(1);
1: 		}
1: 
0: 		ais.setPosition(0);
0: 		int value = CompressedNumber.readInt(in);
0: 		if (value != i) {
0: 			System.out.println("MISMATCH value readInt(DataInput) expected " + i + " got " + value);
0: 			System.exit(1);
1: 		}
1: 
0: 		ais.setPosition(0);
0: 		value = ais.readCompressedInt();
0: 		if (value != i) {
0: 			System.out.println("MISMATCH value readInt(DataInput) expected " + i + " got " + value);
0: 			System.exit(1);
1: 		}
1: 
0: 		ais.setPosition(0);
0: 		value = CompressedNumber.readInt(in_stream);
0: 		if (value != i) {
0: 			System.out.println("MISMATCH value in readInt(InputStream) expected " + i + " got " + value);
0: 			System.exit(1);
1: 		}
1: 
1: 
0: 		value = CompressedNumber.readInt(holder, 0);
0: 		if (value != i) {
0: 			System.out.println(
0:                 "MISMATCH frome readInt(byte[], offset) value expected " + 
0:                 i + " got " + value);
0: 			System.exit(1);
1: 		}
1: 
0: 		ais.setPosition(0);
0: 		int skipLength = CompressedNumber.skipInt(in);
0: 		if (skipLength != length) {
0: 			System.out.println("MISMATCH skip length expected " + length + " got " + skipLength);
0: 			System.exit(1);
1: 		}
1: 
0:         int value_plus_int_length = readIntAndReturnIntPlusOverhead(holder, 0);
0:         if (value_plus_int_length != (length + i + 1)) { 
0: 			System.out.println("MISMATCH readIntAndReturnIntPlusOverhead() return expected " + (length + i) + " got " + value_plus_int_length);
0: 			System.exit(1);
1:         }
1: 
0: 		int skipPosition = ais.getPosition();
0: 		if (skipPosition != length) {
0: 			System.out.println("MISMATCH skip position expected " + length + " got " + skipPosition);
0: 			System.exit(1);
1: 		}
1: 
0: 		return oldLength;
1: 	}
1: 
0:     private static short checkLong(long i, short oldLength) throws IOException {
1: 
0: 		aos.setPosition(0);
0: 		int length = CompressedNumber.writeLong(out, i);
0: 		if (length != oldLength) {
0: 			System.out.println("changing length to " + length + " at value " + i + " 0x" + Long.toHexString(i));
0: 			oldLength = (short) length;
1: 		}
1: 
0: 		int writtenBytes = aos.getPosition();
0: 		if (writtenBytes != length) {
0: 			System.out.println("MISMATCH written bytes  expected " + length + " got " + writtenBytes);
0: 			System.exit(1);
1: 		}
1: 
0: 		if (length != CompressedNumber.sizeLong(i)) {
0: 			System.out.println("MISMATCH sizeLong() bytes  expected " + length + " got " + CompressedNumber.sizeLong(i));
0: 			System.exit(1);
1: 		}
1: 
0: 		long value = CompressedNumber.readLong(holder, 0);
0: 		if (value != i) {
0: 			for (int j = 0; j < 8; j++) {
1: 
0: 				System.out.println(Integer.toHexString((int) holder[j]));
1: 			}
1: 
0: 			System.out.println(
0:                 "MISMATCH in readLong(byte[], offset) value expected " + 
0:                 Long.toHexString(i) + " got " + value);
0: 			System.exit(1);
1: 		}
1: 
0: 		ais.setPosition(0);
0: 		value = CompressedNumber.readLong(in_stream);
0: 		if (value != i) {
0: 			for (int j = 0; j < 8; j++) {
1: 
0: 				System.out.println(Integer.toHexString((int) holder[j]));
1: 			}
0: 			System.out.println("MISMATCH value in readLong(InputStream) expected " + Long.toHexString(i) + " got " + value);
0: 			System.exit(1);
1: 		}
1: 
0: 		ais.setPosition(0);
0: 		value = ais.readCompressedLong();
0: 		if (value != i) {
0: 			for (int j = 0; j < 8; j++) {
1: 
0: 				System.out.println(Integer.toHexString((int) holder[j]));
1: 			}
0: 			System.out.println("MISMATCH value in readLong(InputStream) expected " + Long.toHexString(i) + " got " + value);
0: 			System.exit(1);
1: 		}
1: 
1: 
0: 		ais.setPosition(0);
0: 		value = CompressedNumber.readLong(in);
0: 		if (value != i) {
0: 			for (int j = 0; j < 8; j++) {
1: 
0: 				System.out.println(Integer.toHexString((int) holder[j]));
1: 			}
0: 			System.out.println("MISMATCH value in readLong(DataInput) expected " + Long.toHexString(i) + " got " + value);
0: 			System.exit(1);
1: 		}
1: 
0: 		ais.setPosition(0);
0: 		int skipLength = CompressedNumber.skipLong(in);
0: 		if (skipLength != length) {
0: 			System.out.println("MISMATCH skip length expected " + length + " got " + skipLength);
0: 			System.exit(1);
1: 		}
1: 
0: 		int skipPosition = ais.getPosition();
0: 		if (skipPosition != length) {
0: 			System.out.println("MISMATCH skip position expected " + length + " got " + skipPosition);
0: 			System.exit(1);
1: 		}
1: 
0: 		return oldLength;
1: 	}
1: 
0: 	public static void main(String[] args) throws IOException {
1: 
0: 		short oldLength = -1;
1: 
0: 		System.out.println("** Testing Int");
1: 
0: 		oldLength = checkInt(0, oldLength);
0: 		oldLength = checkInt(1, oldLength);
0: 		oldLength = checkInt(2, oldLength);
1: 
0: 		oldLength = checkInt(0x3f - 4, oldLength);
0: 		oldLength = checkInt(0x3f - 3, oldLength);
0: 		oldLength = checkInt(0x3f - 2, oldLength);
0: 		oldLength = checkInt(0x3f - 1, oldLength);
0: 		oldLength = checkInt(0x3f    , oldLength);
0: 		oldLength = checkInt(0x3f + 1, oldLength);
0: 		oldLength = checkInt(0x3f + 2, oldLength);
0: 		oldLength = checkInt(0x3f + 3, oldLength);
0: 		oldLength = checkInt(0x3f + 4, oldLength);
1: 
0: 		oldLength = checkInt(0x3f80 - 4, oldLength);
0: 		oldLength = checkInt(0x3f80 - 3, oldLength);
0: 		oldLength = checkInt(0x3f80 - 2, oldLength);
0: 		oldLength = checkInt(0x3f80 - 1, oldLength);
0: 		oldLength = checkInt(0x3f80    , oldLength);
0: 		oldLength = checkInt(0x3f80 + 1, oldLength);
0: 		oldLength = checkInt(0x3f80 + 2, oldLength);
0: 		oldLength = checkInt(0x3f80 + 3, oldLength);
0: 		oldLength = checkInt(0x3f80 + 4, oldLength);
1: 
0: 		oldLength = checkInt(0x3fff - 4, oldLength);
0: 		oldLength = checkInt(0x3fff - 3, oldLength);
0: 		oldLength = checkInt(0x3fff - 2, oldLength);
0: 		oldLength = checkInt(0x3fff - 1, oldLength);
0: 		oldLength = checkInt(0x3fff    , oldLength);
0: 		oldLength = checkInt(0x3fff + 1, oldLength);
0: 		oldLength = checkInt(0x3fff + 2, oldLength);
0: 		oldLength = checkInt(0x3fff + 3, oldLength);
0: 		oldLength = checkInt(0x3fff + 4, oldLength);
1: 
0: 		oldLength = checkInt(Integer.MAX_VALUE - 4, oldLength);
0: 		oldLength = checkInt(Integer.MAX_VALUE - 3, oldLength);
0: 		oldLength = checkInt(Integer.MAX_VALUE - 2, oldLength);
0: 		oldLength = checkInt(Integer.MAX_VALUE - 1, oldLength);
0: 		oldLength = checkInt(Integer.MAX_VALUE    , oldLength);
1: 
0:         oldLength = -1;
0:         for (int i = 0; i < 0xf0000; i++)
1:         {
0:             oldLength = checkInt(i, oldLength);
1:         }
1: 
0:         // takes 30 minutes to run.
1:         //
0:         // for (int i = 0; i < Integer.MAX_VALUE; i++)
0:         // {
0:         // if (i % 0x00800000 == 0)
0:         // System.out.println("checking: " + i);
1:         //
0:         // oldLength = checkInt(i, oldLength);
0:         // }
1: 
1: 
0: 		System.out.println("** Testing Long");
1: 
0:         oldLength = -1;
0:         for (int i = 0; i < 0xf0000; i++)
1:         {
0:             oldLength = checkLong(i, oldLength);
1:         }
1: 	
0: 		oldLength = -1;
1: 		
0: 		oldLength = checkLong(0, oldLength);
0: 		oldLength = checkLong(1, oldLength);
0: 		oldLength = checkLong(2, oldLength);
1: 
0: 		oldLength = checkLong(0x3fff - 2, oldLength);
0: 		oldLength = checkLong(0x3fff - 1, oldLength);
0: 		oldLength = checkLong(0x3fff    , oldLength);
0: 		oldLength = checkLong(0x3fff + 1, oldLength);
0: 		oldLength = checkLong(0x3fff + 2, oldLength);
1: 
0: 		oldLength = checkLong(0x3fffffff - 4, oldLength);
0: 		oldLength = checkLong(0x3fffffff - 3, oldLength);
0: 		oldLength = checkLong(0x3fffffff - 2, oldLength);
0: 		oldLength = checkLong(0x3fffffff - 1, oldLength);
0: 		oldLength = checkLong(0x3fffffff    , oldLength);
0: 		oldLength = checkLong(0x3fffffff + 1, oldLength);
0: 		oldLength = checkLong(0x3fffffff + 2, oldLength);
0: 		oldLength = checkLong(0x3fffffff + 3, oldLength);
0: 		oldLength = checkLong(0x3fffffff + 4, oldLength);
1: 
0: 		oldLength = checkLong(0x70000000 - 2, oldLength);
0: 		oldLength = checkLong(0x70000000 - 1, oldLength);
0: 		oldLength = checkLong(0x70000000    , oldLength);
0: 		oldLength = checkLong(0x70000000 + 1, oldLength);
0: 		oldLength = checkLong(0x70000000 + 2, oldLength);
1: 
1: 
0: 		oldLength = checkLong(Long.MAX_VALUE - 2, oldLength);
0: 		oldLength = checkLong(Long.MAX_VALUE - 1, oldLength);
0: 		oldLength = checkLong(Long.MAX_VALUE    , oldLength);
1: 
1: 
1: 	}
0: // ********************************************************/
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.io
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.io;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.io.*;
0: 
0: /**
0: 	Static methods to write and read compressed forms of numbers
0: 	to DataOut and DataIn interfaces. Format written is platform
0: 	independent like the Data* interfaces and must remain fixed
0: 	once a product is shipped. If a different format is required
0: 	then write a new set of methods, e.g. writeInt2. The formats
0: 	defined by stored format identifiers are implicitly dependent
0: 	on these formats not changing.
0: */
0: 
0: public abstract class CompressedNumber {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0: 	// the maximum number of bytes written out for an int
0: 	public static final int MAX_INT_STORED_SIZE = 4;
0: 
0: 	// the maximum number of bytes written out for a long
0: 	public static final int MAX_LONG_STORED_SIZE = 8;
0: 
0:     // largest int stored compressed in 1 byte
0: 	public static final int MAX_COMPRESSED_INT_ONE_BYTE  = 0x3f;
0: 
0:     // largest int stored compressed in 2 bytes
0: 	public static final int MAX_COMPRESSED_INT_TWO_BYTES = 0x3fff;
0: 
0: 
0: 	/**
0: 		Write a compressed integer only supporting signed values.
0: 		Formats are (with x representing value bits):
0: 		<PRE>
0: 		1 Byte - 00xxxxxx                              Represents the value <= 63 (0x3f)
0: 		2 Byte - 01xxxxxx xxxxxxxx                     Represents the value > 63 && <= 16383 (0x3fff)
0: 		4 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value > 16383 && <= MAX_INT
0: 		</PRE>
0: 
0: 
0: 		@exception IOException value is negative or an exception was thrown by a method on out.
0: 	*/
0: 	public static final int writeInt(DataOutput out, int value) throws IOException {
0: 
0: 		if (value < 0)
0: 			throw new IOException();
0: 
0: 		if (value <= 0x3f) {
0: 
0: 			out.writeByte(value);
0: 			return 1;
0: 		}
0: 
0: 		if (value <= 0x3fff) {
0: 
0: 			out.writeByte(0x40 | (value >>> 8));
0: 			out.writeByte(value & 0xff);
0: 			return 2;
0: 		}
0: 
0: 		out.writeByte(((value >>> 24) | 0x80) & 0xff);
0: 		out.writeByte((value >>> 16) & 0xff);
0: 		out.writeByte((value >>> 8) & 0xff);
0: 		out.writeByte((value) & 0xff);
0: 		return 4;
0: 	}
0: 
0: 	/**
0: 		Write a compressed integer directly to an OutputStream.
0: 		@exception IOException an exception was thrown by a method on in.
0: 	*/
0: 	public static final int writeInt(OutputStream out, int value) throws IOException {
0: 
0: 		if (value < 0)
0: 			throw new IOException();
0: 
0: 		if (value <= 0x3f) {
0: 
0: 			out.write(value);
0: 			return 1;
0: 		}
0: 
0: 		if (value <= 0x3fff) {
0: 
0: 			out.write(0x40 | (value >>> 8));
0: 			out.write(value & 0xff);
0: 			return 2;
0: 		}
0: 
0: 		out.write(((value >>> 24) | 0x80) & 0xff);
0: 		out.write((value >>> 16) & 0xff);
0: 		out.write((value >>> 8) & 0xff);
0: 		out.write((value) & 0xff);
0: 		return 4;
0: 	}
0: 
0: 
0: 	/**
0: 		Read an integer previously written by writeInt().
0: 
0: 		@exception IOException an exception was thrown by a method on in.
0: 	*/
0: 	public static final int readInt(DataInput in) throws IOException {
0: 
0: 		int value = in.readUnsignedByte();
0: 
0:         if ((value & ~0x3f) == 0)
0:         {
0:             // length is stored in this byte, we also know that the 0x80 bit
0:             // was not set, so no need to mask off the sign extension from
0:             // the byte to int conversion.
0: 
0:             // account for 1 byte stored length of field + 1 for all returns
0:             return(value);
0:         }
0: 		else if ((value & 0x80) == 0)
0: 		{
0:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT((value & 0x40) == 0x40);
0:             }
0: 
0:             // top 8 bits of 2 byte length is stored in this byte, we also 
0:             // know that the 0x80 bit was not set, so no need to mask off the 
0:             // sign extension from the 1st byte to int conversion.  Need to
0:             // mask the byte in data[offset + 1] to account for possible sign
0:             // extension.
0: 
0:             return(((value & 0x3f) << 8) | in.readUnsignedByte());
0: 		}
0:         else
0:         {
0:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT((value & 0x80) == 0x80);
0:             }
0: 
0:             // top 8 bits of 4 byte length is stored in this byte, we also 
0:             // know that the 0x80 bit was set, so need to mask off the 
0:             // sign extension from the 1st byte to int conversion.  Need to
0:             // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
0:             // account for possible sign extension.
0:             //
0:             return(
0:                  ((value & 0x7f)        << 24) |
0:                  (in.readUnsignedByte() << 16) |
0:                  (in.readUnsignedByte() <<  8) |
0:                  (in.readUnsignedByte()      ));
0:         }
0: 	}
0: 
0: 	/**
0: 		Read an integer previously written by writeInt().
0: 
0: 		@exception IOException an exception was thrown by a method on in.
0: 	*/
0: 	public static final int readInt(InputStream in) throws IOException {
0: 
0: 		int value = InputStreamUtil.readUnsignedByte(in);
0: 
0:         if ((value & ~0x3f) == 0)
0:         {
0:             return(value);
0:         }
0: 		else if ((value & 0x80) == 0)
0: 		{
0:             return(
0:                 ((value & 0x3f) << 8) | InputStreamUtil.readUnsignedByte(in));
0: 		}
0:         else
0: 		{
0:             return(
0:                 ((value          & 0x7f)              << 24) |
0:                 (InputStreamUtil.readUnsignedByte(in) << 16) |
0:                 (InputStreamUtil.readUnsignedByte(in) <<  8) |
0:                 (InputStreamUtil.readUnsignedByte(in)      ));
0: 		}
0: 	}
0: 
0: 	public static final int readInt(
0:     byte[]    data,
0:     int       offset) 
0:     {
0: 		int value = data[offset++];
0: 
0:         if ((value & ~0x3f) == 0)
0:         {
0:             // length is stored in this byte, we also know that the 0x80 bit
0:             // was not set, so no need to mask off the sign extension from
0:             // the byte to int conversion.
0: 
0:             return(value);
0:         }
0: 		else if ((value & 0x80) == 0)
0: 		{
0:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT((value & 0x40) == 0x40);
0:             }
0: 
0:             // top 8 bits of 2 byte length is stored in this byte, we also 
0:             // know that the 0x80 bit was not set, so no need to mask off the 
0:             // sign extension from the 1st byte to int conversion.  Need to
0:             // mask the byte in data[offset + 1] to account for possible sign
0:             // extension.
0: 
0:             return(((value & 0x3f) << 8) | (data[offset] & 0xff));
0: 		}
0:         else
0:         {
0:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT((value & 0x80) == 0x80);
0:             }
0: 
0:             // top 8 bits of 4 byte length is stored in this byte, we also 
0:             // know that the 0x80 bit was set, so need to mask off the 
0:             // sign extension from the 1st byte to int conversion.  Need to
0:             // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
0:             // account for possible sign extension.
0:             //
0:             return(
0:                 ((value          & 0x7f) << 24) |
0:                 ((data[offset++] & 0xff) << 16) |
0:                 ((data[offset++] & 0xff) <<  8) |
0:                 ((data[offset]   & 0xff)      ));
0:         }
0: 	}
0: 
0:     /**
0:      * Return the compressed Int value + stored size of the length + 1
0:      * <p>
0:      * Given offset in array to beginning of compressed int, return the 
0:      * value of the compressed int + the number of bytes used to store the
0:      * length.
0:      * <p>
0:      * So 1 byte lengths will return: length + 1 + 1
0:      * So 2 byte lengths will return: length + 2 + 1
0:      * So 4 byte lengths will return: length + 4 + 1
0:      * <p>
0:      * Note that this routine will not work for lengths MAX_INT - (MAX_INT - 5).
0:      * <p>
0:      * This routine is currently used by the StorePage code to skip fields
0:      * as efficiently as possible.  Since the page size is less than 
0:      * (MAX_INT - 5) it is all right to use this routine.
0:      *
0: 	 * @return compressed int value + length used to store the length.
0:      *
0:      * @param data   byte array containing the field.
0:      * @param offset offset to beginning of field, ie. data[offset] contains
0:      *               1st byte of the compressed int.
0:      **/
0: 	public static final int readIntAndReturnIntPlusOverhead(
0:     byte[]  data,
0:     int     offset)
0:     {
0:         int value = data[offset];
0: 
0:         if ((value & ~0x3f) == 0)
0:         {
0:             // length is stored in this byte, we also know that the 0x80 bit
0:             // was not set, so no need to mask off the sign extension from
0:             // the byte to int conversion.
0: 
0:             // account for 1 byte stored length of field + 1 for all returns
0:             return(value + 2);
0:         }
0: 		else if ((value & 0x80) == 0)
0: 		{
0:             // length is stored in 2 bytes.  only use low 6 bits from 1st byte.
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT((value & 0x40) == 0x40);
0:             }
0: 
0:             // top 8 bits of 2 byte length is stored in this byte, we also 
0:             // know that the 0x80 bit was not set, so no need to mask off the 
0:             // sign extension from the 1st byte to int conversion.  Need to
0:             // mask the byte in data[offset + 1] to account for possible sign
0:             // extension.
0: 
0:             // add 3 to account for 2 byte length + 1 added to all returns
0: 
0:             return((((value & 0x3f) << 8) | (data[offset + 1] & 0xff)) + 3);
0: 		}
0:         else
0:         {
0:             // length is stored in 4 bytes.  only use low 7 bits from 1st byte.
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT((value & 0x80) == 0x80);
0:             }
0: 
0:             // top 8 bits of 4 byte length is stored in this byte, we also 
0:             // know that the 0x80 bit was set, so need to mask off the 
0:             // sign extension from the 1st byte to int conversion.  Need to
0:             // mask the bytes from the next 3 bytes data[offset + 1,2,3] to 
0:             // account for possible sign extension.
0: 
0: 
0:             // add 5 to account for 4 byte length + 1 added to all returns
0:             return(
0:                 (((value            & 0x7f) << 24) |
0:                  ((data[offset + 1] & 0xff) << 16) |
0:                  ((data[offset + 2] & 0xff) <<  8) |
0:                   (data[offset + 3] & 0xff)) + 5);
0:         }
0: 	}
0: 
0: 
0: 	/**
0: 		Skip an integer previously written by writeInt().
0: 
0: 		@exception IOException an exception was thrown by a method on in.
0: 	*/
0: 	public static final int skipInt(DataInput in) throws IOException {
0: 
0: 		int value = in.readUnsignedByte();
0: 
0: 		if ((value & 0x80) == 0x80) {
0: 			in.skipBytes(3);
0: 			return 4;
0: 		}
0: 
0: 		if ((value & 0x40) == 0x40) {
0: 			in.skipBytes(1);
0: 			return 2;
0: 		}
0: 
0: 		return 1;
0: 	}
0: 
0: 	/**
0: 		Skip an integer previously written by writeInt().
0: 
0: 		@exception IOException an exception was thrown by a method on in.
0: 	*/
0: 	public static final int skipInt(InputStream in) throws IOException {
0: 
0: 		int value = InputStreamUtil.readUnsignedByte(in);
0: 
0: 		int skipBytes = 0;
0: 
0: 		if ((value & 0x80) == 0x80) {
0: 			skipBytes = 3;
0: 		}
0: 		else if ((value & 0x40) == 0x40) {
0: 			skipBytes = 1;
0: 		}
0: 
0: 		if (skipBytes != 0) {
0: 			if (in.skip(skipBytes) != skipBytes)
0: 				throw new EOFException();
0: 		}
0: 
0: 
0: 		return skipBytes + 1;
0: 	}
0: 
0: 	/**
0: 		Return the number of bytes that would be written by a writeInt call
0: 	*/
0: 	public static final int sizeInt(int value) {
0: 		if (value <= 0x3f) {
0: 			return 1;
0: 		}
0: 		if (value <= 0x3fff) {
0: 			return 2;
0: 		}
0: 		return 4;
0: 	}
0: 
0: 	/**
0: 		Write a compressed long only supporting signed values.
0: 
0: 		Formats are (with x representing value bits):
0: 		<PRE>
0: 		2 byte - 00xxxxxx xxxxxxxx                     Represents the value <= 16383 (0x3fff)
0: 		4 byte - 01xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value > 16383  && <= 0x3fffffff
0: 		8 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   Represents the value > 0x3fffffff && <= MAX_LONG
0: 		</PRE>
0: 
0: 
0: 		@exception IOException value is negative or an exception was thrown by a method on out.
0: 	*/
0: 	public static final int writeLong(DataOutput out, long value) throws IOException {
0: 
0: 		if (value < 0)
0: 			throw new IOException();
0: 
0: 		if (value <= 0x3fff) {
0: 
0: 			out.writeByte((int) ((value >>> 8) & 0xff));
0: 			out.writeByte((int) ((value      ) & 0xff));
0: 			return 2;
0: 		}
0: 
0: 		if (value <= 0x3fffffff) {
0: 
0: 			out.writeByte((int) (((value >>> 24) | 0x40) & 0xff));
0: 			out.writeByte((int) ( (value >>> 16) & 0xff));
0: 			out.writeByte((int) ( (value >>>  8) & 0xff));
0: 			out.writeByte((int) ( (value       ) & 0xff));
0: 			return 4;
0: 		}
0: 
0: 		out.writeByte((int) (((value >>> 56) | 0x80) & 0xff));
0: 		out.writeByte((int) ( (value >>> 48) & 0xff));
0: 		out.writeByte((int) ( (value >>> 40) & 0xff));
0: 		out.writeByte((int) ( (value >>> 32) & 0xff));
0: 		out.writeByte((int) ( (value >>> 24) & 0xff));
0: 		out.writeByte((int) ( (value >>> 16) & 0xff));
0: 		out.writeByte((int) ( (value >>>  8) & 0xff));
0: 		out.writeByte((int) ( (value       ) & 0xff));
0: 		return 8;
0: 	}
0: 	/**
0: 		Write a compressed integer only supporting signed values.
0: 
0: 		@exception IOException value is negative or an exception was thrown by a method on out.
0: 	*/
0: 	public static final int writeLong(OutputStream out, long value) throws IOException {
0: 
0: 		if (value < 0)
0: 			throw new IOException();
0: 
0: 		if (value <= 0x3fff) {
0: 
0: 			out.write((int) ((value >>> 8) & 0xff));
0: 			out.write((int) ((value      ) & 0xff));
0: 			return 2;
0: 		}
0: 
0: 		if (value <= 0x3fffffff) {
0: 
0: 			out.write((int) (((value >>> 24) | 0x40) & 0xff));
0: 			out.write((int) ( (value >>> 16) & 0xff));
0: 			out.write((int) ( (value >>>  8) & 0xff));
0: 			out.write((int) ( (value       ) & 0xff));
0: 			return 4;
0: 		}
0: 
0: 		out.write((int) (((value >>> 56) | 0x80) & 0xff));
0: 		out.write((int) ( (value >>> 48) & 0xff));
0: 		out.write((int) ( (value >>> 40) & 0xff));
0: 		out.write((int) ( (value >>> 32) & 0xff));
0: 		out.write((int) ( (value >>> 24) & 0xff));
0: 		out.write((int) ( (value >>> 16) & 0xff));
0: 		out.write((int) ( (value >>>  8) & 0xff));
0: 		out.write((int) ( (value       ) & 0xff));
0: 		return 8;
0: 	}
0: 
0: 	/**
0: 		Read a long previously written by writeLong().
0: 
0: 		@exception IOException an exception was thrown by a method on in.
0: 	*/
0: 	public static final long readLong(DataInput in) throws IOException {
0: 
0: 		int int_value = in.readUnsignedByte();
0: 
0:         if ((int_value & ~0x3f) == 0)
0:         {
0:             // test for small case first - assuming this is usual case.
0:             // this is stored in 2 bytes.
0: 
0:             return((int_value << 8) | in.readUnsignedByte());
0: 		}
0: 		else if ((int_value & 0x80) == 0)
0: 		{
0:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
0: 
0:             return(
0:                 ((int_value & 0x3f)      << 24) |
0:                 (in.readUnsignedByte()   << 16) |
0:                 (in.readUnsignedByte()   <<  8) |
0:                 (in.readUnsignedByte()));
0: 		} 
0:         else
0: 		{
0:             // value is stored in 8 bytes.  only use low 7 bits from 1st byte.
0:             return(
0:                 (((long) (int_value & 0x7f)   ) << 56) |
0:                 (((long) in.readUnsignedByte()) << 48) |
0:                 (((long) in.readUnsignedByte()) << 40) |
0:                 (((long) in.readUnsignedByte()) << 32) |
0:                 (((long) in.readUnsignedByte()) << 24) |
0:                 (((long) in.readUnsignedByte()) << 16) |
0:                 (((long) in.readUnsignedByte()) <<  8) |
0:                 (((long) in.readUnsignedByte())      ));
0: 		}
0: 	}
0: 
0: 	/**
0: 		Read a long previously written by writeLong().
0: 
0: 		@exception IOException an exception was thrown by a method on in.
0: 	*/
0: 	public static final long readLong(InputStream in) throws IOException {
0: 
0: 		int int_value = InputStreamUtil.readUnsignedByte(in);
0: 
0:         if ((int_value & ~0x3f) == 0)
0:         {
0:             // test for small case first - assuming this is usual case.
0:             // this is stored in 2 bytes.
0: 
0:             return((int_value << 8) | InputStreamUtil.readUnsignedByte(in));
0: 		}
0: 		else if ((int_value & 0x80) == 0)
0: 		{
0:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
0: 
0:             return(
0:                 ((int_value      & 0x3f)              << 24) |
0:                 (InputStreamUtil.readUnsignedByte(in) << 16) |
0:                 (InputStreamUtil.readUnsignedByte(in) <<  8) |
0:                 (InputStreamUtil.readUnsignedByte(in)      ));
0: 
0: 		} 
0:         else
0: 		{
0:             // value is stored in 8 bytes.  only use low 7 bits from 1st byte.
0:             long value = int_value;
0: 
0:             return(
0:                 (((long) (value & 0x7f)                      ) << 56) |
0:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 48) |
0:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 40) |
0:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 32) |
0:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 24) |
0:                 (((long) InputStreamUtil.readUnsignedByte(in)) << 16) |
0:                 (((long) InputStreamUtil.readUnsignedByte(in)) <<  8) |
0:                 (((long) InputStreamUtil.readUnsignedByte(in))      ));
0: 		}
0: 	}
0: 
0: 	public static final long readLong(
0:     byte[]  data,
0:     int     offset)
0:     {
0: 		int int_value = data[offset++];
0: 
0:         if ((int_value & ~0x3f) == 0)
0:         {
0:             // test for small case first - assuming this is usual case.
0:             // this is stored in 2 bytes.
0: 
0:             return((int_value << 8) | (data[offset] & 0xff));
0: 		}
0: 		else if ((int_value & 0x80) == 0)
0: 		{
0:             // value is stored in 4 bytes.  only use low 6 bits from 1st byte.
0: 
0:             return(
0:                 ((int_value      & 0x3f) << 24) |
0:                 ((data[offset++] & 0xff) << 16) |
0:                 ((data[offset++] & 0xff) <<  8) |
0:                 ((data[offset]   & 0xff)      ));
0: 
0: 		} 
0:         else
0: 		{
0:             // value is stored in 8 bytes.  only use low 6 bits from 1st byte.
0:             return(
0:                 (((long) (int_value      & 0x7f)) << 56) |
0:                 (((long) (data[offset++] & 0xff)) << 48) |
0:                 (((long) (data[offset++] & 0xff)) << 40) |
0:                 (((long) (data[offset++] & 0xff)) << 32) |
0:                 (((long) (data[offset++] & 0xff)) << 24) |
0:                 (((long) (data[offset++] & 0xff)) << 16) |
0:                 (((long) (data[offset++] & 0xff)) <<  8) |
0:                 (((long) (data[offset]   & 0xff))      ));
0: 
0: 		}
0: 	}
0: 
0: 	/**
0: 		Skip a long previously written by writeLong().
0: 
0: 		@exception IOException an exception was thrown by a method on in.
0: 	*/
0: 	public static final int skipLong(DataInput in) throws IOException {
0: 
0: 		long value = in.readUnsignedByte();
0: 
0: 		if ((value & 0x80) == 0x80)
0: 		{
0: 			in.skipBytes(7);
0: 			return 8;
0: 		}
0: 		
0: 		
0: 		if ((value & 0x40) == 0x40)
0: 		{
0: 			in.skipBytes(3);
0: 			return 4;
0: 
0: 		}
0: 
0: 		in.skipBytes(1);
0: 		return 2;
0: 	}
0: 
0: 	/**
0: 		Skip a long previously written by writeLong().
0: 
0: 		@exception IOException an exception was thrown by a method on in.
0: 	*/
0: 	public static final int skipLong(InputStream in) throws IOException {
0: 
0: 		int value = InputStreamUtil.readUnsignedByte(in);
0: 
0: 		int skipBytes;
0: 
0: 		if ((value & 0x80) == 0x80) {
0: 			skipBytes = 7;
0: 		}
0: 		else if ((value & 0x40) == 0x40) {
0: 			skipBytes = 3;
0: 		}
0: 		else
0: 			skipBytes = 1;
0: 
0: 		if (in.skip(skipBytes) != skipBytes)
0: 			throw new EOFException();
0: 
0: 		return skipBytes + 1;
0: 	}
0: 
0: 	public static final int sizeLong(long value) {
0: 
0: 		if (value <= 0x3fff) {
0: 
0: 			return 2;
0: 		}
0: 
0: 		if (value <= 0x3fffffff) {
0: 			return 4;
0: 		}
0: 
0: 		return 8;
0: 	}
0: 
0: // /* FOR TESTING
0: // *****************************************************
0: 
0:   	private static byte[] holder = new byte[8];
0: 	private static  ArrayOutputStream aos = new ArrayOutputStream(holder);
0: 	private static  DataOutput out = new DataOutputStream(aos);
0: 
0: 	private static  ArrayInputStream ais = new ArrayInputStream(holder);
0: 	private static  DataInput in = new DataInputStream(ais);
0: 	private static  InputStream in_stream = ais;
0: 
0: 
0:     private static short checkInt(int i, short oldLength) throws IOException {
0: 
0: 		aos.setPosition(0);
0: 		int length = CompressedNumber.writeInt(out, i);
0: 		if (length != oldLength) {
0: 			System.out.println("changing length to " + length + " at value " + i + " 0x" + Integer.toHexString(i));
0: 
0: 			oldLength = (short) length;
0: 		}
0: 
0: 		int writtenBytes = aos.getPosition();
0: 		if (writtenBytes != length) {
0: 			System.out.println("MISMATCH written bytes  expected " + length + " got " + writtenBytes);
0: 			System.exit(1);
0: 		}
0: 
0: 		if (length != CompressedNumber.sizeInt(i)) {
0: 			System.out.println("MISMATCH sizeInt() bytes  expected " + length + " got " + CompressedNumber.sizeInt(i));
0: 			System.exit(1);
0: 		}
0: 
0: 		ais.setPosition(0);
0: 		int value = CompressedNumber.readInt(in);
0: 		if (value != i) {
0: 			System.out.println("MISMATCH value readInt(DataInput) expected " + i + " got " + value);
0: 			System.exit(1);
0: 		}
0: 
0: 		ais.setPosition(0);
0: 		value = ais.readCompressedInt();
0: 		if (value != i) {
0: 			System.out.println("MISMATCH value readInt(DataInput) expected " + i + " got " + value);
0: 			System.exit(1);
0: 		}
0: 
0: 		ais.setPosition(0);
0: 		value = CompressedNumber.readInt(in_stream);
0: 		if (value != i) {
0: 			System.out.println("MISMATCH value in readInt(InputStream) expected " + i + " got " + value);
0: 			System.exit(1);
0: 		}
0: 
0: 
0: 		value = CompressedNumber.readInt(holder, 0);
0: 		if (value != i) {
0: 			System.out.println(
0:                 "MISMATCH frome readInt(byte[], offset) value expected " + 
0:                 i + " got " + value);
0: 			System.exit(1);
0: 		}
0: 
0: 		ais.setPosition(0);
0: 		int skipLength = CompressedNumber.skipInt(in);
0: 		if (skipLength != length) {
0: 			System.out.println("MISMATCH skip length expected " + length + " got " + skipLength);
0: 			System.exit(1);
0: 		}
0: 
0:         int value_plus_int_length = readIntAndReturnIntPlusOverhead(holder, 0);
0:         if (value_plus_int_length != (length + i + 1)) { 
0: 			System.out.println("MISMATCH readIntAndReturnIntPlusOverhead() return expected " + (length + i) + " got " + value_plus_int_length);
0: 			System.exit(1);
0:         }
0: 
0: 		int skipPosition = ais.getPosition();
0: 		if (skipPosition != length) {
0: 			System.out.println("MISMATCH skip position expected " + length + " got " + skipPosition);
0: 			System.exit(1);
0: 		}
0: 
0: 		return oldLength;
0: 	}
0: 
0:     private static short checkLong(long i, short oldLength) throws IOException {
0: 
0: 		aos.setPosition(0);
0: 		int length = CompressedNumber.writeLong(out, i);
0: 		if (length != oldLength) {
0: 			System.out.println("changing length to " + length + " at value " + i + " 0x" + Long.toHexString(i));
0: 			oldLength = (short) length;
0: 		}
0: 
0: 		int writtenBytes = aos.getPosition();
0: 		if (writtenBytes != length) {
0: 			System.out.println("MISMATCH written bytes  expected " + length + " got " + writtenBytes);
0: 			System.exit(1);
0: 		}
0: 
0: 		if (length != CompressedNumber.sizeLong(i)) {
0: 			System.out.println("MISMATCH sizeLong() bytes  expected " + length + " got " + CompressedNumber.sizeLong(i));
0: 			System.exit(1);
0: 		}
0: 
0: 		long value = CompressedNumber.readLong(holder, 0);
0: 		if (value != i) {
0: 			for (int j = 0; j < 8; j++) {
0: 
0: 				System.out.println(Integer.toHexString((int) holder[j]));
0: 			}
0: 
0: 			System.out.println(
0:                 "MISMATCH in readLong(byte[], offset) value expected " + 
0:                 Long.toHexString(i) + " got " + value);
0: 			System.exit(1);
0: 		}
0: 
0: 		ais.setPosition(0);
0: 		value = CompressedNumber.readLong(in_stream);
0: 		if (value != i) {
0: 			for (int j = 0; j < 8; j++) {
0: 
0: 				System.out.println(Integer.toHexString((int) holder[j]));
0: 			}
0: 			System.out.println("MISMATCH value in readLong(InputStream) expected " + Long.toHexString(i) + " got " + value);
0: 			System.exit(1);
0: 		}
0: 
0: 		ais.setPosition(0);
0: 		value = ais.readCompressedLong();
0: 		if (value != i) {
0: 			for (int j = 0; j < 8; j++) {
0: 
0: 				System.out.println(Integer.toHexString((int) holder[j]));
0: 			}
0: 			System.out.println("MISMATCH value in readLong(InputStream) expected " + Long.toHexString(i) + " got " + value);
0: 			System.exit(1);
0: 		}
0: 
0: 
0: 		ais.setPosition(0);
0: 		value = CompressedNumber.readLong(in);
0: 		if (value != i) {
0: 			for (int j = 0; j < 8; j++) {
0: 
0: 				System.out.println(Integer.toHexString((int) holder[j]));
0: 			}
0: 			System.out.println("MISMATCH value in readLong(DataInput) expected " + Long.toHexString(i) + " got " + value);
0: 			System.exit(1);
0: 		}
0: 
0: 		ais.setPosition(0);
0: 		int skipLength = CompressedNumber.skipLong(in);
0: 		if (skipLength != length) {
0: 			System.out.println("MISMATCH skip length expected " + length + " got " + skipLength);
0: 			System.exit(1);
0: 		}
0: 
0: 		int skipPosition = ais.getPosition();
0: 		if (skipPosition != length) {
0: 			System.out.println("MISMATCH skip position expected " + length + " got " + skipPosition);
0: 			System.exit(1);
0: 		}
0: 
0: 		return oldLength;
0: 	}
0: 
0: 	public static void main(String[] args) throws IOException {
0: 
0: 		short oldLength = -1;
0: 
0: 		System.out.println("** Testing Int");
0: 
0: 		oldLength = checkInt(0, oldLength);
0: 		oldLength = checkInt(1, oldLength);
0: 		oldLength = checkInt(2, oldLength);
0: 
0: 		oldLength = checkInt(0x3f - 4, oldLength);
0: 		oldLength = checkInt(0x3f - 3, oldLength);
0: 		oldLength = checkInt(0x3f - 2, oldLength);
0: 		oldLength = checkInt(0x3f - 1, oldLength);
0: 		oldLength = checkInt(0x3f    , oldLength);
0: 		oldLength = checkInt(0x3f + 1, oldLength);
0: 		oldLength = checkInt(0x3f + 2, oldLength);
0: 		oldLength = checkInt(0x3f + 3, oldLength);
0: 		oldLength = checkInt(0x3f + 4, oldLength);
0: 
0: 		oldLength = checkInt(0x3f80 - 4, oldLength);
0: 		oldLength = checkInt(0x3f80 - 3, oldLength);
0: 		oldLength = checkInt(0x3f80 - 2, oldLength);
0: 		oldLength = checkInt(0x3f80 - 1, oldLength);
0: 		oldLength = checkInt(0x3f80    , oldLength);
0: 		oldLength = checkInt(0x3f80 + 1, oldLength);
0: 		oldLength = checkInt(0x3f80 + 2, oldLength);
0: 		oldLength = checkInt(0x3f80 + 3, oldLength);
0: 		oldLength = checkInt(0x3f80 + 4, oldLength);
0: 
0: 		oldLength = checkInt(0x3fff - 4, oldLength);
0: 		oldLength = checkInt(0x3fff - 3, oldLength);
0: 		oldLength = checkInt(0x3fff - 2, oldLength);
0: 		oldLength = checkInt(0x3fff - 1, oldLength);
0: 		oldLength = checkInt(0x3fff    , oldLength);
0: 		oldLength = checkInt(0x3fff + 1, oldLength);
0: 		oldLength = checkInt(0x3fff + 2, oldLength);
0: 		oldLength = checkInt(0x3fff + 3, oldLength);
0: 		oldLength = checkInt(0x3fff + 4, oldLength);
0: 
0: 		oldLength = checkInt(Integer.MAX_VALUE - 4, oldLength);
0: 		oldLength = checkInt(Integer.MAX_VALUE - 3, oldLength);
0: 		oldLength = checkInt(Integer.MAX_VALUE - 2, oldLength);
0: 		oldLength = checkInt(Integer.MAX_VALUE - 1, oldLength);
0: 		oldLength = checkInt(Integer.MAX_VALUE    , oldLength);
0: 
0:         oldLength = -1;
0:         for (int i = 0; i < 0xf0000; i++)
0:         {
0:             oldLength = checkInt(i, oldLength);
0:         }
0: 
0:         // takes 30 minutes to run.
0:         //
0:         // for (int i = 0; i < Integer.MAX_VALUE; i++)
0:         // {
0:         // if (i % 0x00800000 == 0)
0:         // System.out.println("checking: " + i);
0:         //
0:         // oldLength = checkInt(i, oldLength);
0:         // }
0: 
0: 
0: 		System.out.println("** Testing Long");
0: 
0:         oldLength = -1;
0:         for (int i = 0; i < 0xf0000; i++)
0:         {
0:             oldLength = checkLong(i, oldLength);
0:         }
0: 	
0: 		oldLength = -1;
0: 		
0: 		oldLength = checkLong(0, oldLength);
0: 		oldLength = checkLong(1, oldLength);
0: 		oldLength = checkLong(2, oldLength);
0: 
0: 		oldLength = checkLong(0x3fff - 2, oldLength);
0: 		oldLength = checkLong(0x3fff - 1, oldLength);
0: 		oldLength = checkLong(0x3fff    , oldLength);
0: 		oldLength = checkLong(0x3fff + 1, oldLength);
0: 		oldLength = checkLong(0x3fff + 2, oldLength);
0: 
0: 		oldLength = checkLong(0x3fffffff - 4, oldLength);
0: 		oldLength = checkLong(0x3fffffff - 3, oldLength);
0: 		oldLength = checkLong(0x3fffffff - 2, oldLength);
0: 		oldLength = checkLong(0x3fffffff - 1, oldLength);
0: 		oldLength = checkLong(0x3fffffff    , oldLength);
0: 		oldLength = checkLong(0x3fffffff + 1, oldLength);
0: 		oldLength = checkLong(0x3fffffff + 2, oldLength);
0: 		oldLength = checkLong(0x3fffffff + 3, oldLength);
0: 		oldLength = checkLong(0x3fffffff + 4, oldLength);
0: 
0: 		oldLength = checkLong(0x70000000 - 2, oldLength);
0: 		oldLength = checkLong(0x70000000 - 1, oldLength);
0: 		oldLength = checkLong(0x70000000    , oldLength);
0: 		oldLength = checkLong(0x70000000 + 1, oldLength);
0: 		oldLength = checkLong(0x70000000 + 2, oldLength);
0: 
0: 
0: 		oldLength = checkLong(Long.MAX_VALUE - 2, oldLength);
0: 		oldLength = checkLong(Long.MAX_VALUE - 1, oldLength);
0: 		oldLength = checkLong(Long.MAX_VALUE    , oldLength);
0: 
0: 
0: 	}
0: // ********************************************************/
0: }
============================================================================