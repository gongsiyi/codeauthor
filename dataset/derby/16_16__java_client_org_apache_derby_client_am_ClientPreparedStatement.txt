1:486f51a: /*
214:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.PreparedStatement
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:76af6ed: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:1d87ff4: 
1:3896fdd: import java.io.InputStream;
1:3896fdd: import java.io.Reader;
1:69e3d06: import java.math.BigDecimal;
1:69e3d06: import java.math.BigInteger;
1:4469400: import java.math.RoundingMode;
1:69e3d06: import java.net.URL;
1:69e3d06: import java.sql.Array;
1:69e3d06: import java.sql.BatchUpdateException;
1:69e3d06: import java.sql.Blob;
1:69e3d06: import java.sql.Clob;
1:c1d0340: import java.sql.Date;
1:9a0cdf1: import java.sql.NClob;
1:69e3d06: import java.sql.ParameterMetaData;
1:69e3d06: import java.sql.PreparedStatement;
1:69e3d06: import java.sql.Ref;
1:69e3d06: import java.sql.ResultSet;
1:69e3d06: import java.sql.ResultSetMetaData;
1:9a0cdf1: import java.sql.RowId;
1:d506170: import java.sql.SQLException;
1:9a0cdf1: import java.sql.SQLXML;
1:c1d0340: import java.sql.Time;
1:c1d0340: import java.sql.Timestamp;
1:69e3d06: import java.sql.Types;
1:63d4142: import java.util.ArrayList;
1:486f51a: import java.util.Arrays;
1:c1d0340: import java.util.Calendar;
1:69e3d06: import java.util.Iterator;
1:407e52d: import org.apache.derby.client.ClientPooledConnection;
1:2e7a2af: import org.apache.derby.jdbc.ClientDriver;
1:5ef7a0d: import org.apache.derby.shared.common.reference.SQLState;
1:5ef7a0d: import org.apache.derby.shared.common.sanity.SanityManager;
1:70f7692: 
1:69e3d06: public class ClientPreparedStatement extends ClientStatement
1:69e3d06:     implements PreparedStatement, PreparedStatementCallbackInterface {
1:69e3d06: 
1:70f7692:     //---------------------navigational cheat-links-------------------------------
1:70f7692:     // Cheat-links are for convenience only, and are not part of the conceptual model.
1:70f7692:     // Warning:
1:70f7692:     //   Cheat-links should only be defined for invariant state data.
1:70f7692:     //   That is, the state data is set by the constructor and never changes.
1:70f7692: 
1:70f7692:     // Alias for downcast (MaterialPreparedStatementProxy) super.materialStatement.
1:70f7692:     public MaterialPreparedStatement materialPreparedStatement_ = null;
1:70f7692: 
1:70f7692:     //-----------------------------state------------------------------------------
1:70f7692: 
1:0326967:     String sql_;
1:70f7692: 
1:70f7692:     // This variable is only used by Batch.
1:70f7692:     // True if a call sql statement has an OUT or INOUT parameter registered.
1:0326967:     boolean outputRegistered_ = false;
1:70f7692: 
1:70f7692:     // Parameter inputs are cached as objects so they may be sent on execute()
1:0326967:     Object[] parameters_;
1:70f7692: 
1:0326967:     private boolean[] parameterSet_;
1:70f7692:     boolean[] parameterRegistered_;
1:3896fdd:     
1:70f7692:     void setInput(int parameterIndex, Object input) {
1:70f7692:         parameters_[parameterIndex - 1] = input;
1:70f7692:         parameterSet_[parameterIndex - 1] = true;
71:70f7692:     }
1:01c7f83: 
1:0326967:     ColumnMetaData parameterMetaData_; // type information for input sqlda
1:956354d:     
1:4772c7e:     private ArrayList<int[]> parameterTypeList;
1:407e52d: 
1:63d4142: 
1:70f7692:     // The problem with storing the scrollable ResultSet associated with cursorName in scrollableRS_ is
1:70f7692:     // that when the PreparedStatement is re-executed, it has a new ResultSet, however, we always do
1:70f7692:     // the reposition on the ResultSet that was stored in scrollableRS_, and we never update scrollableRS_
1:70f7692:     // when PreparedStatement is re-execute.  So the new ResultSet that needs to be repositioned never
1:70f7692:     // gets repositioned.
1:70f7692:     // So instead of caching the scrollableRS_, we will cache the cursorName.  And re-retrieve the scrollable
1:70f7692:     // result set from the map using this cursorName every time the PreparedStatement excutes.
1:0326967:     private String positionedUpdateCursorName_ = null;
1:407e52d:     
1:407e52d:     // the ClientPooledConnection object used to notify of the events that occur
1:407e52d:     // on this prepared statement object
1:0326967:     private final ClientPooledConnection pooledConnection_;
1:486f51a: 
1:486f51a: 
1:70f7692:     private void initPreparedStatement() {
1:70f7692:         materialPreparedStatement_ = null;
1:70f7692:         sql_ = null;
1:70f7692:         outputRegistered_ = false;
1:70f7692:         parameters_ = null;
1:70f7692:         parameterSet_ = null;
1:70f7692:         parameterRegistered_ = null;
1:70f7692:         parameterMetaData_ = null;
1:63d4142:         parameterTypeList = null;
1:70f7692:         isAutoCommittableStatement_ = true;
2:70f7692:         isPreparedStatement_ = true;
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected void initResetPreparedStatement() {
1:70f7692:         outputRegistered_ = false;
1:70f7692:         isPreparedStatement_ = true;
1:36adcbf:         resetParameters();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void reset(boolean fullReset) throws SqlException {
1:70f7692:         if (fullReset) {
1:70f7692:             connection_.resetPrepareStatement(this);
7:70f7692:         } else {
1:70f7692:             super.initResetPreparedStatement();
1:70f7692:             initResetPreparedStatement();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:01c7f83:     /**
1:76af6ed:      * Resets the prepared statement for reuse in a statement pool.
1:054fa3a:      *
1:76af6ed:      * @throws SqlException if the reset fails
1:475fc20:      * @see ClientStatement#resetForReuse
1:054fa3a:      */
1:76af6ed:     void resetForReuse()
1:7eed914:             throws SqlException {
1:76af6ed:         resetParameters();
1:76af6ed:         super.resetForReuse();
1:76af6ed:     }
1:054fa3a: 
1:70f7692:     private void resetParameters() {
1:bd644c6:         if (parameterMetaData_ != null) {
1:36adcbf:             Arrays.fill(parameters_, null);
1:36adcbf:             Arrays.fill(parameterSet_, false);
1:36adcbf:             Arrays.fill(parameterRegistered_, false);
1:70f7692:         }
1:70f7692:     }
1:76af6ed: 
1:506f4c8:     /**
1:407e52d:      *
1:407e52d:      * The PreparedStatement constructor used for JDBC 2 positioned update
1:407e52d:      * statements. Called by material statement constructors.
1:407e52d:      * It has the ClientPooledConnection as one of its parameters 
1:407e52d:      * this is used to raise the Statement Events when the prepared
1:407e52d:      * statement is closed
1:407e52d:      *
1:407e52d:      * @param agent The instance of NetAgent associated with this
1:407e52d:      *              CallableStatement object.
1:407e52d:      * @param connection The connection object associated with this
1:407e52d:      *                   PreparedStatement Object.
1:407e52d:      * @param sql        A String object that is the SQL statement to be sent
1:407e52d:      *                   to the database.
1:407e52d:      * @param section    Section
1:407e52d:      * @param cpc The ClientPooledConnection wraps the underlying physical
1:407e52d:      *            connection associated with this prepared statement.
1:407e52d:      *            It is used to pass the Statement closed and the Statement
1:407e52d:      *            error occurred events that occur back to the
1:407e52d:      *            ClientPooledConnection.
1:407e52d:      * @throws SqlException
1:407e52d:      *
1:407e52d:      */
1:407e52d: 
1:69e3d06:     public ClientPreparedStatement(Agent agent,
1:69e3d06:                              ClientConnection connection,
2:70f7692:                              String sql,
1:407e52d:                              Section section,ClientPooledConnection cpc)
1:407e52d:                              throws SqlException {
1:70f7692:         super(agent, connection);
1:7eed914:         // PreparedStatement is poolable by default
1:7eed914:         isPoolable = true;
1:70f7692:         initPreparedStatement(sql, section);
1:407e52d:         pooledConnection_ = cpc;
1:70f7692:     }
1:407e52d:     
1:0326967:     private void resetPreparedStatement(Agent agent,
1:69e3d06:                                        ClientConnection connection,
1:70f7692:                                        String sql,
3:70f7692:                                        Section section) throws SqlException {
1:70f7692:         super.resetStatement(agent, connection);
1:70f7692:         initPreparedStatement();
1:70f7692:         initPreparedStatement(sql, section);
1:70f7692:     }
1:486f51a: 
1:70f7692:     private void initPreparedStatement(String sql, Section section) throws SqlException {
1:70f7692:         sql_ = sql;
1:70f7692:         isPreparedStatement_ = true;
1:486f51a: 
1:70f7692:         parseSqlAndSetSqlModes(sql_);
1:74fb1b0:         setSection(section);
1:70f7692:     }
1:3896fdd: 
1:956354d:     /**
1:407e52d:      * The PreparedStatementConstructor used for jdbc 2 prepared statements 
1:407e52d:      * with scroll attributes. Called by material statement constructors.
1:407e52d:      * It has the ClientPooledConnection as one of its parameters 
1:407e52d:      * this is used to raise the Statement Events when the prepared
1:407e52d:      * statement is closed
1:407e52d:      *
1:407e52d:      * @param agent The instance of NetAgent associated with this
1:407e52d:      *              CallableStatement object.
1:407e52d:      * @param connection  The connection object associated with this
1:407e52d:      *                    PreparedStatement Object.
1:407e52d:      * @param sql         A String object that is the SQL statement
1:407e52d:      *                    to be sent to the database.
1:407e52d:      * @param type        One of the ResultSet type constants.
1:407e52d:      * @param concurrency One of the ResultSet concurrency constants.
1:407e52d:      * @param holdability One of the ResultSet holdability constants.
1:407e52d:      * @param autoGeneratedKeys a flag indicating whether auto-generated
1:407e52d:      *                          keys should be returned.
1:407e52d:      * @param columnNames an array of column names indicating the columns that
1:407e52d:      *                    should be returned from the inserted row or rows.
1:b52081a:      * @param columnIndexes an array of column names indicating the columns that
1:b52081a:      *                   should be returned from the inserted row.                   
1:407e52d:      * @param cpc The ClientPooledConnection wraps the underlying physical
1:407e52d:      *            connection associated with this prepared statement
1:407e52d:      *            it is used to pass the Statement closed and the Statement
1:407e52d:      *            error occurred events that occur back to the
1:407e52d:      *            ClientPooledConnection.
1:407e52d:      * @throws SqlException
1:407e52d:      */
1:69e3d06:     public ClientPreparedStatement(Agent agent,
1:69e3d06:                              ClientConnection connection,
1:70f7692:                              String sql,
1:7eed914:                              int type, int concurrency, int holdability, 
1:407e52d:                              int autoGeneratedKeys, String[] columnNames,
1:b52081a:                              int[] columnIndexes,
1:407e52d:                              ClientPooledConnection cpc) 
1:407e52d:                              throws SqlException {
1:7eed914:         super(agent, connection, type, concurrency, holdability, 
1:b52081a:               autoGeneratedKeys, columnNames, columnIndexes);
1:7eed914:         // PreparedStatement is poolable by default
1:7eed914:         isPoolable = true;
1:70f7692:         initPreparedStatement(sql);
1:407e52d:         pooledConnection_ = cpc;
1:70f7692:     }
1:407e52d: 
1:70f7692: 
3:70f7692:     public void resetPreparedStatement(Agent agent,
1:69e3d06:                                        ClientConnection connection,
1:70f7692:                                        String sql,
1:b52081a:                                        int type, int concurrency, int holdability, int autoGeneratedKeys, String[] columnNames,
1:b52081a:                                        int[] columnIndexes) throws SqlException {
1:b52081a:         super.resetStatement(agent, connection, type, concurrency, holdability, autoGeneratedKeys, 
1:b52081a:                 columnNames, columnIndexes);
1:70f7692:         initPreparedStatement();
1:70f7692:         initPreparedStatement(sql);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void initPreparedStatement(String sql) throws SqlException {
1:70f7692:         sql_ = super.escape(sql);
1:70f7692:         parseSqlAndSetSqlModes(sql_);
1:70f7692:         isPreparedStatement_ = true;
1:70f7692: 
1:70f7692:         // Check for positioned update statement and assign a section from the
1:70f7692:         // same package as the corresponding query section.
1:70f7692:         // Scan the sql for an "update...where current of <cursor-name>".
1:70f7692:         String cursorName = null;
1:70f7692:         if (sqlUpdateMode_ == isDeleteSql__ || sqlUpdateMode_ == isUpdateSql__) {
1:70f7692:             String[] sqlAndCursorName = extractCursorNameFromWhereCurrentOf(sql_);
1:70f7692:             if (sqlAndCursorName != null) {
1:70f7692:                 cursorName = sqlAndCursorName[0];
1:70f7692:                 sql_ = sqlAndCursorName[1];
1:70f7692:             }
1:70f7692:         }
1:70f7692:         if (cursorName != null) {
1:70f7692:             positionedUpdateCursorName_ = cursorName;
1:70f7692:             // Get a new section from the same package as the query section
1:74fb1b0:             setSection(agent_.sectionManager_.getPositionedUpdateSection(cursorName, false)); // false means get a regular section
1:70f7692: 
1:74fb1b0:             if (getSection() == null) {
1:6eb29f6:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                     new ClientMessageId(SQLState.CURSOR_INVALID_CURSOR_NAME), cursorName);
1:70f7692:             }
1:70f7692: 
1:70f7692:             //scrollableRS_ = agent_.sectionManager_.getPositionedUpdateResultSet (cursorName);
1:70f7692: 
1:70f7692:             // if client's cursor name is set, and the cursor name in the positioned update
1:70f7692:             // string is the same as the client's cursor name, replace client's cursor name
1:70f7692:             // with the server's cursor name.
1:70f7692:             // if the cursor name supplied in the sql string is different from the cursorName
1:70f7692:             // set by setCursorName(), then server will return "cursor name not defined" error,
1:70f7692:             // and no subsititution is made here.
1:74fb1b0:             if (getSection().getClientCursorName() != null && // cursor name is user defined
1:74fb1b0:                     cursorName.compareTo(getSection().getClientCursorName()) == 0)
1:70f7692:             // client's cursor name is substituted with section's server cursor name
1:d506170:             {
1:74fb1b0:                 sql_ = substituteClientCursorNameWithServerCursorName(sql_, getSection());
1:70f7692:             }
1:70f7692:         } else {
1:70f7692:             // We don't need to analyze the sql text to determine if it is a query or not.
1:70f7692:             // This is up to the server to decide, we just pass thru the sql on flowPrepare().
1:74fb1b0:             setSection(agent_.sectionManager_.getDynamicSection(resultSetHoldability_));
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // called immediately after the constructor by Connection prepare*() methods
1:70f7692:     void prepare() throws SqlException {
3:70f7692:         try {
1:70f7692:             // flow prepare, no static initialization is needed
1:eab1882:             flowPrepareDescribeInputOutput();
1:70f7692:         } catch (SqlException e) {
1:70f7692:             this.markClosed();
1:70f7692:             throw e;
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:486f51a: 
1:70f7692:     //------------------- Prohibited overrides from Statement --------------------
1:70f7692: 
1:6e97c84:     public void addBatch(String sql) throws SQLException {
1:6e97c84:         if (agent_.loggingEnabled()) {
1:6e97c84:             agent_.logWriter_.traceEntry(this, "addBatch", sql);
1:6e97c84:         }
1:6e97c84:         throw new SqlException(agent_.logWriter_,
1:6e97c84:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:6e97c84:             "addBatch(String)").getSQLException();
1:6e97c84:     }
1:6e97c84: 
1:d506170:     public boolean execute(String sql) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "execute", sql);
1:70f7692:         }
1:1d87ff4:         throw new SqlException(agent_.logWriter_,
1:e65b4db:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:1d87ff4:             "execute(String)").getSQLException();
1:70f7692:     }
1:a2006ae: 
1:69e3d06:     public ResultSet executeQuery(String sql) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "executeQuery", sql);
1:70f7692:         }
1:1d87ff4:         throw new SqlException(agent_.logWriter_,
1:e65b4db:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:1d87ff4:             "executeQuery(String)").getSQLException();
1:70f7692:     }
1:486f51a: 
1:d506170:     public int executeUpdate(String sql) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "executeUpdate", sql);
1:70f7692:         }
1:1d87ff4:         throw new SqlException(agent_.logWriter_,
1:e65b4db:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:1d87ff4:             "executeUpdate(String)").getSQLException();
1:70f7692:     }
1:70f7692:     // ---------------------------jdbc 1------------------------------------------
1:486f51a: 
1:69e3d06:     public ResultSet executeQuery() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "executeQuery");
1:20b2fd9:                 }
1:69e3d06:                 ClientResultSet resultSet = executeQueryX();
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "executeQuery", resultSet);
1:3896fdd:                 }
1:d506170:                 return resultSet;
1:3896fdd:             }
1:3896fdd:         }
1:407e52d:         catch ( SqlException se ) {
1:407e52d:             checkStatementValidity(se);
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:486f51a: 
1:70f7692:     // also called by some DBMD methods
1:69e3d06:     ClientResultSet executeQueryX() throws SqlException {
1:70f7692:         flowExecute(executeQueryMethod__);
1:70f7692:         return resultSet_;
1:d506170:     }
1:486f51a: 
1:486f51a: 
1:d506170:     public int executeUpdate() throws SQLException {
1:d506170:         try
1:d506170:         {
1:3896fdd:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "executeUpdate");
1:d506170:                 }
1:f26c60c:                 int updateValue = (int) executeUpdateX();
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "executeUpdate", updateValue);
1:d506170:                 }
1:d506170:                 return updateValue;
1:d506170:             }
1:d506170:         }
1:407e52d:         catch ( SqlException se ) {
1:407e52d:             checkStatementValidity(se);
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:486f51a: 
1:f26c60c:     private long executeUpdateX() throws SqlException {
1:70f7692:         flowExecute(executeUpdateMethod__);
1:70f7692:         return updateCount_;
1:70f7692:     }
1:486f51a: 
1:d506170:     public void setNull(int parameterIndex, int jdbcType) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setNull", parameterIndex, jdbcType);
1:d506170:                 }
1:a2006ae: 
1:a2006ae:                 checkForClosedStatement();
1:c1d0340: 
1:a2006ae:                 // JDBC 4.0 requires us to throw
1:a2006ae:                 // SQLFeatureNotSupportedException for certain target types if
1:a2006ae:                 // they are not supported. Check for these types before
1:a2006ae:                 // checking type compatibility.
1:9f0c37a:                 agent_.checkForSupportedDataType(jdbcType);
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a:                 
1:486f51a:                 if( ! PossibleTypes.getPossibleTypesForNull( paramType ).checkType( jdbcType )){
1:486f51a:                     
1:486f51a:                     //This exception mimic embedded behavior.
1:486f51a:                     //see http://issues.apache.org/jira/browse/DERBY-1610#action_12432568
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:486f51a:                                                       jdbcType,
1:486f51a:                                                       paramType );
1:486f51a:                 }
1:486f51a:                 
1:d506170:                 setNullX(parameterIndex, jdbcType);
1:486f51a:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:70f7692:     // also used by DBMD methods
1:70f7692:     void setNullX(int parameterIndex, int jdbcType) throws SqlException {
1:70f7692:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = jdbcType;
1:486f51a: 
1:70f7692:         if (!parameterMetaData_.nullable_[parameterIndex - 1]) {
1:1d87ff4:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.LANG_NULL_INTO_NON_NULL),
1:66527ec:                 parameterIndex);
1:70f7692:         }
1:70f7692:         setInput(parameterIndex, null);
1:70f7692:     }
1:486f51a: 
1:d506170:     public void setNull(int parameterIndex, int jdbcType, String typeName) throws SQLException {
1:a2006ae:         synchronized (connection_) {
1:a2006ae:             if (agent_.loggingEnabled()) {
1:a2006ae:                 agent_.logWriter_.traceEntry(this, "setNull", parameterIndex,
1:a2006ae:                                              jdbcType, typeName);
1:d506170:             }
1:a2006ae:             setNull(parameterIndex, jdbcType);
1:d506170:         }
1:70f7692:     }
1:486f51a: 
1:d506170:     public void setBoolean(int parameterIndex, boolean x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setBoolean", parameterIndex, x);
1:d506170:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a: 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ) {
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.BOOLEAN,
1:486f51a:                                                       paramType);
1:486f51a:                     
1:486f51a:                 }
1:486f51a:                 
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.BIT;
1:74f0097:                 setInput(parameterIndex, Boolean.valueOf(x));
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:d506170:     public void setByte(int parameterIndex, byte x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setByte", parameterIndex, x);
1:d506170:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a:                 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType( paramType ) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.TINYINT,
1:486f51a:                                                       paramType);
1:486f51a:                     
1:486f51a:                 }
1:486f51a:                 
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.TINYINT;
1:66527ec:                 setInput(parameterIndex, Short.valueOf(x));
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:d506170:     public void setShort(int parameterIndex, short x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setShort", parameterIndex, x);
1:d506170:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a: 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.SMALLINT,
1:486f51a:                                                       paramType);
1:486f51a:                                                   
1:486f51a: 
1:486f51a:                 }
1:486f51a:                 
1:d506170:                 setShortX(parameterIndex, x);
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:70f7692:     // also used by DBMD methods
1:70f7692:     void setShortX(int parameterIndex, short x) throws SqlException {
1:69e3d06:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:             Types.SMALLINT;
1:66527ec:         setInput(parameterIndex, x);
1:506f4c8: 
1:70f7692:     }
1:486f51a: 
1:d506170:     public void setInt(int parameterIndex, int x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setInt", parameterIndex, x);
1:486f51a:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a: 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.INTEGER,
1:486f51a:                                                       paramType);
1:d506170:                 }
1:486f51a:                 
1:d506170:                 setIntX(parameterIndex, x);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:70f7692:     // also used by DBMD methods
1:70f7692:     void setIntX(int parameterIndex, int x) throws SqlException {
1:69e3d06:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:             Types.INTEGER;
1:66527ec:         setInput(parameterIndex, x);
1:70f7692:     }
1:486f51a: 
1:486f51a: 
1:d506170:     public void setLong(int parameterIndex, long x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setLong", parameterIndex, x);
1:486f51a:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a:                 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.INTEGER,
1:486f51a:                                                       paramType);
1:d506170:                 }
1:6de69bd:                 setLongX(parameterIndex, x);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:6de69bd:     void setLongX(final int parameterIndex, final long x) 
1:6de69bd:     {
1:74eba43:         // Column numbers starts at 1, clientParamtertype_[0] refers to column 1
1:6de69bd:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] 
1:69e3d06:                 = Types.BIGINT;
1:66527ec:         setInput(parameterIndex, x);
1:6de69bd:     }
1:6de69bd: 
1:d506170:     public void setFloat(int parameterIndex, float x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setFloat", parameterIndex, x);
1:486f51a:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a: 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.FLOAT,
1:486f51a:                                                       paramType);
1:486f51a: 
1:d506170:                 }
1:486f51a:                 
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.REAL;
1:66527ec:                 setInput(parameterIndex, x);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setDouble(int parameterIndex, double x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setDouble", parameterIndex, x);
1:486f51a:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a:                 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.DOUBLE,
1:486f51a:                                                       paramType);
1:70f7692:                     
1:d506170:                 }
1:70f7692:                 
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.DOUBLE;
1:39b3237:                 Double d = x;
1:39b3237:                 setInput(parameterIndex, d);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setBigDecimal(int parameterIndex, BigDecimal x)
1:69e3d06:             throws SQLException {
1:3896fdd:         try
1:3896fdd:         {
1:d506170:             synchronized (connection_) {
1:3896fdd:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setBigDecimal", parameterIndex, x);
1:486f51a:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a: 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType( paramType ) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.BIGINT,
1:486f51a:                                                       paramType);
1:486f51a:                     
1:d506170:                 }
1:70f7692: 
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.DECIMAL;
1:69e3d06: 
1:d506170:                 if (x == null) {
1:69e3d06:                     setNull(parameterIndex, Types.DECIMAL);
1:d506170:                     return;
1:d506170:                 }
1:d506170:                 int registerOutScale = 0;
1:d506170:                 setInput(parameterIndex, x);
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:3896fdd:         {
1:3896fdd:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:dbbf9ff: 
1:c1d0340:     public void setDate(int parameterIndex, Date x, Calendar calendar)
1:c1d0340:             throws SQLException {
1:3896fdd:         try
1:3896fdd:         {
1:d506170:             synchronized (connection_) {
1:3896fdd:                 if (agent_.loggingEnabled()) {
1:c1d0340:                     agent_.logWriter_.traceEntry(
1:c1d0340:                             this, "setDate", parameterIndex, x, calendar);
1:d506170:                 }
1:1cb533f:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:70f7692:                 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_DATE.checkType(paramType) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_ ,
1:69e3d06:                                                       Types.DATE,
1:486f51a:                                                       paramType);
1:486f51a:                     
1:486f51a:                 }
1:486f51a:                 
1:320777f:                 checkForClosedStatement();
1:70f7692: 
1:c1d0340:                 if (calendar == null) {
1:c1d0340:                     throw new SqlException(agent_.logWriter_,
1:c1d0340:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
1:c1d0340:                         "null", "calendar", "setDate()");
1:c1d0340:                 }
1:c1d0340: 
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.DATE;
1:69e3d06: 
1:d506170:                 if (x == null) {
1:69e3d06:                     setNull(parameterIndex, Types.DATE);
1:d506170:                     return;
1:d506170:                 }
1:c1d0340:                 setInput(parameterIndex, new DateTimeValue(x, calendar));
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:3896fdd:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:c1d0340:     public void setDate(int parameterIndex, Date x) throws SQLException {
1:c1d0340:         setDate(parameterIndex, x, Calendar.getInstance());
1:70f7692:     }
1:70f7692: 
1:c1d0340:     public void setTime(int parameterIndex, Time x, Calendar calendar)
1:c1d0340:             throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setTime", parameterIndex, x);
1:d506170:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a: 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_TIME.checkType( paramType ) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception( agent_.logWriter_,
1:69e3d06:                                                        Types.TIME,
1:486f51a:                                                        paramType );
1:486f51a:                 }
1:486f51a:                 
1:c1d0340:                 if (calendar == null) {
1:c1d0340:                     throw new SqlException(agent_.logWriter_,
1:c1d0340:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
1:1d87ff4:                         "null", "calendar", "setTime()");
1:c1d0340:                 }
1:c1d0340: 
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.TIME;
1:c1d0340: 
1:c1d0340:                 if (x == null) {
1:69e3d06:                     setNull(parameterIndex, Types.TIME);
1:c1d0340:                     return;
1:d506170:                 }
1:c1d0340:                 setInput(parameterIndex, new DateTimeValue(x, calendar));
1:69e3d06: 
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:70f7692: 
1:c1d0340:     public void setTime(int parameterIndex, Time x) throws SQLException {
1:c1d0340:         setTime(parameterIndex, x, Calendar.getInstance());
1:c1d0340:     }
1:c1d0340: 
1:c1d0340:     public void setTimestamp(int parameterIndex, Timestamp x, Calendar calendar)
1:c1d0340:             throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setTimestamp", parameterIndex, x);
1:d506170:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a: 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_TIMESTAMP.checkType( paramType ) ) {
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.TIMESTAMP,
1:486f51a:                                                       paramType);
1:486f51a:                     
1:486f51a:                 }
1:486f51a:                 
3:d506170:                 if (calendar == null) {
1:1d87ff4:                     throw new SqlException(agent_.logWriter_,
1:e65b4db:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
1:c1d0340:                         "null", "calendar", "setTimestamp()");
1:c1d0340:                 }
1:c1d0340: 
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.TIMESTAMP;
1:70f7692: 
1:d506170:                 if (x == null) {
1:69e3d06:                     setNull(parameterIndex, Types.TIMESTAMP);
1:d506170:                     return;
1:d506170:                 }
1:c1d0340:                 setInput(parameterIndex, new DateTimeValue(x, calendar));
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:70f7692: 
1:c1d0340:     public void setTimestamp(int parameterIndex, Timestamp x)
1:c1d0340:             throws SQLException {
1:c1d0340:         setTimestamp(parameterIndex, x, Calendar.getInstance());
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setString(int parameterIndex, String x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setString", parameterIndex, x);
1:d506170:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a: 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_STRING.checkType( paramType ) ){
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_ ,
1:69e3d06:                                                       Types.VARCHAR,
1:486f51a:                                                       paramType);
1:486f51a:                 }
1:486f51a:                 
1:d506170:                 setStringX(parameterIndex, x);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // also used by DBMD methods
1:70f7692:     void setStringX(int parameterIndex, String x) throws SqlException {
1:69e3d06:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:             Types.LONGVARCHAR;
1:69e3d06: 
1:d506170:         if (x == null) {
1:69e3d06:             setNullX(parameterIndex, Types.LONGVARCHAR);
1:d506170:             return;
1:70f7692:         }
1:d506170:         setInput(parameterIndex, x);
1:70f7692:     }
1:70f7692: 
1:d506170:     public void setBytes(int parameterIndex, byte[] x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setBytes", parameterIndex, x);
1:d506170:                 }
1:486f51a:                 
1:bc52552:                 final int paramType = 
1:960054b:                     getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a:                 
1:486f51a:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_BYTES.checkType( paramType ) ){
1:486f51a:                     
1:486f51a:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                                       Types.VARBINARY,
1:486f51a:                                                       paramType );
1:486f51a:                 }
1:70f7692:                 
1:d506170:                 setBytesX(parameterIndex, x);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     // also used by CallableLocatorProcedures
1:0326967:     void setBytesX(int parameterIndex, byte[] x) throws SqlException {
1:69e3d06:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:             Types.LONGVARBINARY;
1:69e3d06: 
10:70f7692:         if (x == null) {
1:69e3d06:             setNullX(parameterIndex, Types.LONGVARBINARY);
12:70f7692:             return;
1:70f7692:         }
1:d506170:         setInput(parameterIndex, x);
1:70f7692: 
1:70f7692:     }
1:70f7692:     
1:054fa3a:     /**
1:c511410:      * sets the parameter to the  Binary Stream object
1:c511410:      *
1:c511410:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:c511410:      * @param x the java input stream which contains the binary parameter value
1:c511410:      * @param length the number of bytes in the stream
1:c511410:      * @exception SQLException thrown on failure.
1:c511410:      */
1:c511410: 
1:c511410:     public void setBinaryStream(int parameterIndex,
1:69e3d06:                                 InputStream x,
1:c511410:                                 long length) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:66527ec:                     agent_.logWriter_.traceEntry(this, "setBinaryStream",
1:66527ec:                         parameterIndex, "<input stream>", Long.valueOf(length));
1:c511410:                 }
1:c511410:                 
1:a2006ae:                 checkTypeForSetBinaryStream(parameterIndex);
1:70f7692: 
1:5e717f9:                 checkStreamLength(length);
1:c511410:                 setBinaryStreamX(parameterIndex, x, (int)length);
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d8383bd:     /**
1:c511410:      * sets the parameter to the  Binary Stream object
1:c511410:      *
1:c511410:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:c511410:      * @param x the java input stream which contains the binary parameter value
1:c511410:      * @param length the number of bytes in the stream
1:c511410:      * @exception SQLException thrown on failure.
1:c511410:      */
1:70f7692: 
1:70f7692:     public void setBinaryStream(int parameterIndex,
1:69e3d06:                                 InputStream x,
1:c511410:                                 int length) throws SQLException {
1:c511410:         setBinaryStream(parameterIndex,x,(long)length);
1:c511410:     }
1:c511410: 
1:b565f41:     private void setBinaryStreamX(int parameterIndex,
1:69e3d06:                                  InputStream x,
5:70f7692:                                  int length) throws SqlException {
1:69e3d06:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = Types.BLOB;
1:d506170:         if (x == null) {
1:69e3d06:             setNullX(parameterIndex, Types.BLOB);
1:d506170:             return;
1:486f51a:         }
1:69e3d06:         ClientBlob blob;
1:956354d:         if (length == -1) {
1:956354d:             // Create a blob of unknown length. This might cause an
1:956354d:             // OutOfMemoryError due to the temporary implementation in Blob.
1:956354d:             // The whole stream will be materialzied. See comments in Blob.
1:69e3d06:             blob = new ClientBlob(agent_, x);
1:956354d:         } else {
1:69e3d06:             blob = new ClientBlob(agent_, x, length);
1:956354d:         }
1:956354d:         setInput(parameterIndex, blob);
1:d506170:     }
1:486f51a: 
1:c511410:     /**
1:c511410:      * We do this inefficiently and read it all in here. The target type
1:c511410:      * is assumed to be a String.
1:c511410:      *
1:c511410:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:c511410:      * @param x the java input stream which contains the ASCII parameter value
1:c511410:      * @param length the number of bytes in the stream
1:c511410:      * @exception SQLException thrown on failure.
1:c511410:      */
1:c511410: 
1:c511410:     public void setAsciiStream(int parameterIndex,
1:69e3d06:                                InputStream x,
1:c511410:                                long length) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:5e717f9:                     agent_.logWriter_.traceEntry(this, "setAsciiStream",
1:66527ec:                         parameterIndex, "<input stream>", Long.valueOf(length));
1:d506170:                 }
1:486f51a:                 
1:a2006ae:                 checkTypeForSetAsciiStream(parameterIndex);
1:486f51a: 
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.CLOB;
1:69e3d06: 
1:d506170:                 if (x == null) {
1:69e3d06:                     setNull(parameterIndex, Types.LONGVARCHAR);
1:d506170:                     return;
1:d506170:                 }
1:5e717f9:                 checkStreamLength(length);
1:69e3d06:                 setInput(parameterIndex,
1:a0b8943:                     new ClientClob(agent_, x, Cursor.ISO_8859_1, (int) length));
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:69e3d06: 
1:c511410:     /**
1:c511410:      * We do this inefficiently and read it all in here. The target type
1:c511410:      * is assumed to be a String.
1:c511410:      *
1:c511410:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:c511410:      * @param x the java input stream which contains the ASCII parameter value
1:c511410:      * @param length the number of bytes in the stream
1:c511410:      * @exception SQLException thrown on failure.
1:c511410:      */
1:70f7692:     public void setAsciiStream(int parameterIndex,
1:69e3d06:                                InputStream x,
1:c511410:                                int length) throws SQLException {
1:c511410:         setAsciiStream(parameterIndex,x,(long)length);
1:c511410:     }
1:c511410:     
1:cb82751:     /**
1:5e717f9:      * Check the length passed in for the stream that is to be set. If length is
1:5e717f9:      * larger than Integer.MAX_VALUE or smaller that 0, we fail by throwing an 
1:5e717f9:      * SQLException.
1:5e717f9:      * @param length The length of the stream being set
1:5e717f9:      * @throws SQLException Thrown for a negative or too large length.
1:5e717f9:      */
1:5e717f9:     private void checkStreamLength(long length) throws SQLException {
1:c511410:         if(length > Integer.MAX_VALUE) {
1:5e717f9:             throw new SqlException(
1:5e717f9:                         agent_.logWriter_,
1:5e717f9:                         new ClientMessageId(
1:5e717f9:                             SQLState.CLIENT_LENGTH_OUTSIDE_RANGE_FOR_DATATYPE),
1:66527ec:                         length,
1:66527ec:                         Integer.MAX_VALUE
1:5e717f9:                     ).getSQLException();
1:5e717f9:         } else if (length < 0) {
1:5e717f9:             throw new SqlException(
1:5e717f9:                         agent_.logWriter_,
1:5e717f9:                         new ClientMessageId(SQLState.NEGATIVE_STREAM_LENGTH)
1:5e717f9:                     ).getSQLException();
1:c511410:         }
1:c511410:     }
1:5e717f9:     
1:a2006ae:     private void checkTypeForSetAsciiStream(int parameterIndex)
1:b54918e:             throws SqlException, SQLException {
1:960054b:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a:         if ( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_ASCIISTREAM.checkType( paramType ) ) {
1:486f51a:             
1:a2006ae:             PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                               Types.LONGVARCHAR,
1:486f51a:                                               paramType);
1:486f51a:             
1:486f51a:             
1:5e717f9:         }
1:5e717f9:     }
1:486f51a:     
1:a2006ae:     private void checkTypeForSetBinaryStream(int parameterIndex)
1:a2006ae:             throws SqlException, SQLException {
1:960054b:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
1:a2006ae:         if (!PossibleTypes.POSSIBLE_TYPES_IN_SET_BINARYSTREAM.
1:a2006ae:                 checkType(paramType)) {
1:a2006ae:             PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                               Types.VARBINARY,
1:a2006ae:                                               paramType);
1:a2006ae:         }
1:a2006ae:     }
1:486f51a:     
1:a2006ae:     private void checkTypeForSetCharacterStream(int parameterIndex)
1:a2006ae:             throws SqlException, SQLException {
1:960054b:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
1:a2006ae:         if (!PossibleTypes.POSSIBLE_TYPES_IN_SET_CHARACTERSTREAM.
1:a2006ae:                 checkType(paramType)) {
1:a2006ae:             PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                               Types.LONGVARCHAR,
1:a2006ae:                                               paramType);
1:a2006ae:         }
1:a2006ae:     }
1:a2006ae: 
1:a2006ae:     private void checkTypeForSetBlob(int parameterIndex)
1:a2006ae:             throws SqlException, SQLException {
1:960054b:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a:         if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_BLOB.checkType( paramType ) ){
1:486f51a:             
1:a2006ae:             PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                               Types.BLOB,
1:486f51a:                                               paramType);
1:486f51a:         }
1:486f51a:     }
1:486f51a:     
1:486f51a:     
1:a2006ae:     private void checkTypeForSetClob(int parameterIndex)
1:a2006ae:             throws SqlException, SQLException {
1:960054b:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
1:486f51a:         if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_CLOB.checkType( paramType ) ){
1:486f51a:                     
1:a2006ae:             PossibleTypes.throw22005Exception(agent_.logWriter_,
1:69e3d06:                                               Types.CLOB,
1:486f51a:                                               paramType);
1:486f51a:                     
1:486f51a:         }
1:486f51a:         
1:486f51a:     }
1:486f51a:     
1:486f51a:     
1:c511410:     /**
1:cb82751:      * Sets the specified parameter to the given input stream. Deprecated
1:cb82751:      * in JDBC 3.0 and this method will always just throw a feature not
1:cb82751:      * implemented exception.
1:cb82751:      *
1:cb82751:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:cb82751:      * @param x the java input stream which contains the UNICODE parameter
1:cb82751:      * value
1:cb82751:      * @param length the number of bytes in the stream
1:cb82751:      * @exception SQLException throws feature not implemented.
1:e24d8ef:      * @deprecated
1:cb82751:      */
1:70f7692:     public void setUnicodeStream(int parameterIndex,
1:69e3d06:                                  InputStream x,
1:d506170:                                  int length) throws SQLException {
1:cb82751:         if (agent_.loggingEnabled()) {
1:cb82751:             agent_.logWriter_.traceDeprecatedEntry(this, "setUnicodeStream",
1:cb82751:                                                    parameterIndex,
1:cb82751:                                                    "<input stream>", length);
1:486f51a:         }
1:cb82751: 
1:cb82751:         throw SQLExceptionFactory.notImplemented ("setUnicodeStream");
1:d506170:     }
1:70f7692: 
1:956354d:     /**
1:956354d:      * Sets the designated parameter to the given <code>Reader</code> object.
1:956354d:      * When a very large UNICODE value is input to a LONGVARCHAR parameter, it
1:956354d:      * may be more practical to send it via a <code>java.io.Reader</code>
1:956354d:      * object. The data will be read from the stream as needed until
1:956354d:      * end-of-file is reached. The JDBC driver will do any necessary conversion
1:956354d:      * from UNICODE to the database char format.
1:956354d:      *
1:956354d:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:956354d:      * @param x the <code>java.io.Reader</code> object that contains the
1:956354d:      *      Unicode data
1:956354d:      * @throws SQLException if a database access error occurs or this method is
1:956354d:      *      called on a closed <code>PreparedStatement</code>
1:956354d:      */
1:956354d:     public void setCharacterStream(int parameterIndex, Reader x)
1:956354d:             throws SQLException {
1:956354d:         synchronized (connection_) {
1:956354d:             if (agent_.loggingEnabled()) {
1:956354d:                 agent_.logWriter_.traceEntry(this, "setCharacterStream",
1:956354d:                         parameterIndex, x);
1:956354d:             }
1:956354d:             try {
1:a2006ae:                 checkTypeForSetCharacterStream(parameterIndex);
1:956354d:                 parameterMetaData_.clientParamtertype_[parameterIndex -1] =
1:69e3d06:                     Types.CLOB;
1:956354d:                 if (x == null) {
1:69e3d06:                     setNull(parameterIndex, Types.LONGVARCHAR);
1:956354d:                     return;
1:956354d:                 }
1:69e3d06:                 setInput(parameterIndex, new ClientClob(agent_, x));
1:956354d:             } catch (SqlException se) {
1:956354d:                 throw se.getSQLException();
1:956354d:             }
1:956354d:         }
1:956354d:     }
1:956354d: 
1:c511410:      /**
1:c511410:      * Sets the designated parameter to the given Reader, which will have
1:c511410:      * the specified number of bytes.
1:c511410:      *
1:c511410:      * @param parameterIndex the index of the parameter to which this set
1:c511410:      *                       method is applied
1:c511410:      * @param x the java Reader which contains the UNICODE value
1:c511410:      * @param length the number of bytes in the stream
1:c511410:      * @exception SQLException thrown on failure.
1:c511410:      *
1:c511410:      */
1:c511410: 
1:70f7692:     public void setCharacterStream(int parameterIndex,
1:69e3d06:                                    Reader x,
1:c511410:                                    long length) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:66527ec:                     agent_.logWriter_.traceEntry(this, "setCharacterStream",
1:66527ec:                             parameterIndex, x, Long.valueOf(length));
1:d506170:                 }
1:a2006ae:                 checkTypeForSetCharacterStream(parameterIndex);
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.CLOB;
1:69e3d06: 
1:d506170:                 if (x == null) {
1:69e3d06:                     setNull(parameterIndex, Types.LONGVARCHAR);
1:d506170:                     return;
1:d506170:                 }
1:5e717f9:                 checkStreamLength(length);
1:69e3d06:                 setInput(parameterIndex,
1:69e3d06:                          new ClientClob(agent_, x, (int)length));
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:d506170:     }
1:486f51a: 
1:c511410:      /**
1:c511410:      * Sets the designated parameter to the given Reader, which will have
1:c511410:      * the specified number of bytes.
1:c511410:      *
1:c511410:      * @param parameterIndex the index of the parameter to which this
1:c511410:      *                       set method is applied
1:c511410:      * @param x the java Reader which contains the UNICODE value
1:c511410:      * @param length the number of bytes in the stream
1:c511410:      * @exception SQLException thrown on failure.
1:c511410:      *
1:c511410:      */
1:c511410: 
1:c511410:     public void setCharacterStream(int parameterIndex,
1:69e3d06:                                    Reader x,
1:c511410:                                    int length) throws SQLException {
1:c511410:         setCharacterStream(parameterIndex,x,(long)length);
1:c511410:     }
1:c511410: 
1:69e3d06:     public void setBlob(int parameterIndex, Blob x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setBlob", parameterIndex, x);
1:486f51a:                 }
1:486f51a:                 
1:a2006ae:                 checkTypeForSetBlob(parameterIndex);
1:d506170:                 setBlobX(parameterIndex, x);
1:486f51a:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:0326967:     private void setBlobX(int parameterIndex, Blob x) throws SqlException {
1:69e3d06:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = Types.BLOB;
1:70f7692:         if (x == null) {
1:69e3d06:             setNullX(parameterIndex, Types.BLOB);
1:70f7692:             return;
1:70f7692:         }
1:d506170:         setInput(parameterIndex, x);
1:70f7692:     }
1:486f51a: 
1:69e3d06:     public void setClob(int parameterIndex, Clob x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setClob", parameterIndex, x);
1:d506170:                 }
1:a2006ae:                 checkTypeForSetClob(parameterIndex);
1:d506170:                 setClobX(parameterIndex, x);
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:0326967:     private void setClobX(int parameterIndex, Clob x) throws SqlException {
1:69e3d06:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = Types.CLOB;
1:70f7692:         if (x == null) {
1:69e3d06:             this.setNullX(parameterIndex, ClientTypes.CLOB);
1:70f7692:             return;
1:70f7692:         }
8:70f7692:         setInput(parameterIndex, x);
1:70f7692:     }
1:486f51a: 
1:486f51a: 
1:69e3d06:     public void setArray(int parameterIndex, Array x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setArray", parameterIndex, x);
1:d506170:                 }
1:c511410:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                     new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:486f51a: 
1:69e3d06:     public void setRef(int parameterIndex, Ref x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setRef", parameterIndex, x);
1:d506170:                 }
1:c511410:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                     new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
1:d506170:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }            
1:70f7692:     }
1:70f7692: 
1:70f7692:     // The Java compiler uses static binding, so we must use instanceof
1:70f7692:     // rather than to rely on separate setObject() methods for
1:70f7692:     // each of the Java Object instance types recognized below.
1:d506170:     public void setObject(int parameterIndex, Object x) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x);
1:506f4c8:                 }
1:506f4c8: 
1:506f4c8:                 int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
1:506f4c8: 
1:69e3d06:                 if ( paramType == Types.JAVA_OBJECT )
1:506f4c8:                 {
1:506f4c8:                     setUDTX( parameterIndex, x );
1:a92196c:                 } else if (x == null) {
1:a92196c:                     // DERBY-1938: Allow setting Java null also when the
1:a92196c:                     //      column type isn't specified explicitly by the
1:a92196c:                     //      user. Maps Java null to SQL NULL.
1:a92196c:                     setNull(parameterIndex, paramType);
1:a92196c:                 } else if (x instanceof String) {
1:d506170:                     setString(parameterIndex, (String) x);
1:d506170:                 } else if (x instanceof Integer) {
1:d506170:                     setInt(parameterIndex, ((Integer) x).intValue());
1:d506170:                 } else if (x instanceof Double) {
1:d506170:                     setDouble(parameterIndex, ((Double) x).doubleValue());
1:d506170:                 } else if (x instanceof Float) {
1:d506170:                     setFloat(parameterIndex, ((Float) x).floatValue());
1:d506170:                 } else if (x instanceof Boolean) {
1:d506170:                     setBoolean(parameterIndex, ((Boolean) x).booleanValue());
1:d506170:                 } else if (x instanceof Long) {
1:d506170:                     setLong(parameterIndex, ((Long) x).longValue());
1:d506170:                 } else if (x instanceof byte[]) {
1:d506170:                     setBytes(parameterIndex, (byte[]) x);
1:69e3d06:                 } else if (x instanceof BigDecimal) {
1:69e3d06:                     setBigDecimal(parameterIndex, (BigDecimal) x);
1:69e3d06:                 } else if (x instanceof Date) {
1:69e3d06:                     setDate(parameterIndex, (Date) x);
1:69e3d06:                 } else if (x instanceof Time) {
1:69e3d06:                     setTime(parameterIndex, (Time) x);
1:69e3d06:                 } else if (x instanceof Timestamp) {
1:69e3d06:                     setTimestamp(parameterIndex, (Timestamp) x);
1:69e3d06:                 } else if (x instanceof Blob) {
1:69e3d06:                     setBlob(parameterIndex, (Blob) x);
1:69e3d06:                 } else if (x instanceof Clob) {
1:69e3d06:                     setClob(parameterIndex, (Clob) x);
1:69e3d06:                 } else if (x instanceof Array) {
1:69e3d06:                     setArray(parameterIndex, (Array) x);
1:69e3d06:                 } else if (x instanceof Ref) {
1:69e3d06:                     setRef(parameterIndex, (Ref) x);
1:d506170:                 } else if (x instanceof Short) {
1:d506170:                     setShort(parameterIndex, ((Short) x).shortValue());
1:69e3d06:                 } else if (x instanceof BigInteger) {
1:69e3d06:                     setBigDecimal(parameterIndex,
1:69e3d06:                                   new BigDecimal((BigInteger)x));
1:59f54f8:                 } else if (x instanceof java.util.Date) {
1:69e3d06:                     setTimestamp(parameterIndex,
1:69e3d06:                                  new Timestamp(((java.util.Date)x).getTime()));
1:69e3d06:                 } else if (x instanceof Calendar) {
1:69e3d06:                     setTimestamp(
1:69e3d06:                         parameterIndex,
1:69e3d06:                         new Timestamp(((Calendar)x).getTime().getTime()));
1:d506170:                 } else if (x instanceof Byte) {
1:d506170:                     setByte(parameterIndex, ((Byte) x).byteValue());
1:d506170:                 } else {
1:a2006ae:                     checkForClosedStatement();
1:a2006ae:                     checkForValidParameterIndex(parameterIndex);
1:c511410:                     throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.UNSUPPORTED_TYPE));
1:d506170:                 }
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }            
1:70f7692:     }
1:70f7692: 
1:c511410:     /**
1:506f4c8:      * Set a UDT parameter to an object value.
1:506f4c8:      */
1:506f4c8:     private void setUDTX(int parameterIndex, Object x) throws SqlException, SQLException
1:506f4c8:     {
1:506f4c8:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
1:69e3d06:         int expectedType = Types.JAVA_OBJECT;
1:506f4c8:         
1:506f4c8:         if ( !( paramType == expectedType ) )
1:506f4c8:         {
1:506f4c8:             PossibleTypes.throw22005Exception
1:506f4c8:                 (agent_.logWriter_, expectedType, paramType );
1:506f4c8:         }
1:506f4c8:         
1:506f4c8:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = expectedType;
1:506f4c8:         if (x == null) {
1:506f4c8:             setNullX(parameterIndex, expectedType );
1:506f4c8:             return;
1:506f4c8:         }
1:506f4c8: 
1:506f4c8:         //
1:506f4c8:         // Make sure that we are setting the parameter to an instance of the UDT.
1:506f4c8:         //
1:506f4c8:         
1:506f4c8:         Throwable problem = null;
1:506f4c8:         String sourceClassName = x.getClass().getName();
1:506f4c8:         String targetClassName = getColumnMetaDataX().getColumnClassName(parameterIndex);
1:506f4c8: 
1:506f4c8:         try {
1:506f4c8:             Class targetClass = Class.forName( targetClassName );
1:506f4c8:             if ( targetClass.isInstance( x ) )
1:506f4c8:             {
1:506f4c8:                 setInput(parameterIndex, x);
1:506f4c8:                 return;
1:506f4c8:             }
1:506f4c8:         }
1:506f4c8:         catch (ClassNotFoundException e) { problem = e; }
1:506f4c8: 
1:506f4c8:         throw new SqlException
1:506f4c8:             (
1:506f4c8:              agent_.logWriter_,
1:506f4c8:              new ClientMessageId( SQLState.NET_UDT_COERCION_ERROR ),
1:506f4c8:              new Object[] { sourceClassName, targetClassName },
1:506f4c8:              problem
1:506f4c8:              );
1:506f4c8:     }
1:506f4c8: 
1:d506170:     public void setObject(int parameterIndex, Object x, int targetJdbcType) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x, targetJdbcType);
1:054fa3a:                 }
1:a2006ae:                 checkForClosedStatement();
1:d506170:                 setObjectX(parameterIndex, x, targetJdbcType, 0);
1:054fa3a:             }
1:d506170:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:d506170:         }
1:70f7692:     }
1:054fa3a: 
1:70f7692:     public void setObject(int parameterIndex,
1:70f7692:                           Object x,
1:70f7692:                           int targetJdbcType,
1:d506170:                           int scale) throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x, targetJdbcType, scale);
1:d506170:                 }
1:a2006ae:                 checkForClosedStatement();
1:d506170:                 setObjectX(parameterIndex, x, targetJdbcType, scale);
1:70f7692:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:054fa3a: 
1:70f7692:     private void setObjectX(int parameterIndex,
1:70f7692:                             Object x,
1:70f7692:                             int targetJdbcType,
2:70f7692:                             int scale) throws SqlException {
1:5e3c874:         checkForValidParameterIndex(parameterIndex);
1:70f7692:         checkForValidScale(scale);
1:70f7692: 
1:a2006ae:         // JDBC 4.0 requires us to throw SQLFeatureNotSupportedException for
1:a2006ae:         // certain target types if they are not supported.
1:9f0c37a:         agent_.checkForSupportedDataType(targetJdbcType);
1:a2006ae: 
1:70f7692:         if (x == null) {
1:d506170:             setNullX(parameterIndex, targetJdbcType);
1:70f7692:             return;
1:70f7692:         }
1:70f7692: 
1:1cb533f:         // JDBC Spec specifies that conversion should occur on the client if
1:1cb533f:         // the targetJdbcType is specified.
1:1cb533f: 
1:1cb533f:         int inputParameterType = CrossConverters.getInputJdbcType(targetJdbcType);
1:1cb533f:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = inputParameterType;
1:1cb533f:         x = agent_.crossConverters_.setObject(inputParameterType, x);
1:1cb533f: 
1:1cb533f:         // Set to round down on setScale like embedded does in SQLDecimal
1:1cb533f:         try {
1:69e3d06:             if (targetJdbcType == Types.DECIMAL ||
1:69e3d06:                 targetJdbcType == Types.NUMERIC) {
1:4469400:                 x = ((BigDecimal) x).setScale(scale, RoundingMode.DOWN);
1:1cb533f:             }
1:1cb533f:         } catch (ArithmeticException ae) {
1:1cb533f:             // Any problems with scale should have already been caught by
1:1cb533f:             // checkForvalidScale
1:1d87ff4:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.JAVA_EXCEPTION),
1:1d87ff4:                 new Object[] {ae.getClass().getName(), ae.getMessage()}, ae);
1:1cb533f:         }
1:d506170:         try { 
1:d506170:             setObject(parameterIndex, x);
1:d506170:         } catch ( SQLException se ) {
1:d506170:             throw new SqlException(se);
1:d506170:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Since parameters are cached as objects in parameters_[],
1:70f7692:     // java null may be used to represent SQL null.
1:d506170:     public void clearParameters() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "clearParameters");
1:d506170:                 }
1:320777f:                 checkForClosedStatement();
1:36adcbf:                 if (parameterMetaData_ != null) {
1:36adcbf:                     Arrays.fill(parameters_, null);
1:36adcbf:                     Arrays.fill(parameterSet_, false);
1:d506170:                 }
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean execute() throws SQLException {
1:d506170:         try
2:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "execute");
1:d506170:                 }
1:d506170:                 boolean b = executeX();
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "execute", b);
1:d506170:                 }
1:d506170:                 return b;
1:d506170:             }
1:70f7692:         }
1:407e52d:         catch ( SqlException se ) {
1:407e52d:             checkStatementValidity(se);
2:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d8383bd:     // also used by SQLCA
1:d8383bd:     boolean executeX() throws SqlException {
1:70f7692:         flowExecute(executeMethod__);
1:70f7692: 
1:70f7692:         return resultSet_ != null;
1:70f7692:     }
1:70f7692: 
1:70f7692:     //--------------------------JDBC 2.0-----------------------------
1:70f7692: 
1:d506170:     public void addBatch() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "addBatch");
1:d506170:                 }
1:320777f:                 checkForClosedStatement();
1:d506170:                 checkThatAllParametersAreSet();
1:63d4142:                 
1:63d4142:                 if (parameterTypeList == null) {
1:4772c7e:                     parameterTypeList = new ArrayList<int[]>();
1:63d4142:                 }
1:d506170: 
1:d506170:                 // ASSERT: since OUT/INOUT parameters are not allowed, there should
1:d506170:                 //         be no problem in sharing the JDBC Wrapper object instances
1:d506170:                 //         since they will not be modified by the driver.
1:d506170: 
1:d506170:                 // batch up the parameter values -- deep copy req'd
1:d506170: 
1:d506170:                 if (parameterMetaData_ != null) {
1:d506170:                     Object[] inputsClone = new Object[parameters_.length];
1:d506170:                     System.arraycopy(parameters_, 0, inputsClone, 0, parameters_.length);
1:d506170: 
1:d506170:                     batch_.add(inputsClone);
1:63d4142:                     
1:63d4142:                     // Get a copy of the parameter type data and save it in a list
1:63d4142:                     // which will be used later on at the time of batch execution.
1:63d4142:                     parameterTypeList.add(parameterMetaData_.clientParamtertype_.clone());
1:d506170:                 } else {
1:d506170:                     batch_.add(null);
1:63d4142:                     parameterTypeList.add(null);
1:d506170:                 }
1:d506170:             }
1:70f7692:         }
3:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Batch requires that input types are exact, we perform no input cross conversion for Batch.
1:70f7692:     // If so, this is an external semantic, and should go into the release notes
1:b54918e:     public int[] executeBatch() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "executeBatch");
1:d506170:                 }
1:f26c60c:                 long[] updateCounts = null;
1:d506170:                 updateCounts = executeBatchX(false);
1:70f7692: 
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "executeBatch", updateCounts);
1:d506170:                 }
1:f26c60c:                 return Utils.squashLongs( updateCounts );
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public ResultSetMetaData getMetaData() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getMetaData");
1:d506170:                 }
1:d506170:                 ColumnMetaData resultSetMetaData = getMetaDataX();
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getMetaData", resultSetMetaData);
1:d506170:                 }
1:d506170:                 return resultSetMetaData;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private ColumnMetaData getMetaDataX() throws SqlException {
1:d506170:         super.checkForClosedStatement();
1:70f7692:         return resultSetMetaData_;
1:d506170:     }
1:70f7692: 
1:33776ff:     //------------------------- JDBC 3.0 -----------------------------------
1:70f7692: 
1:d506170:     public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "execute", sql, autoGeneratedKeys);
1:d506170:         }
1:1d87ff4:         throw new SqlException(agent_.logWriter_,
1:e65b4db:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:1d87ff4:             "execute(String, int)").getSQLException();
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean execute(String sql, String[] columnNames) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "execute", sql, columnNames);
1:70f7692:         }
1:1d87ff4:         throw new SqlException(agent_.logWriter_,
1:e65b4db:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:1d87ff4:             "execute(String, String[])").getSQLException();
1:70f7692:     }
1:70f7692: 
1:d506170:     public boolean execute(String sql, int[] columnIndexes) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "execute", sql, columnIndexes);
1:70f7692:         }
1:1d87ff4:         throw new SqlException(agent_.logWriter_,
1:e65b4db:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:1d87ff4:             "execute(String, int[])").getSQLException();
1:70f7692:     }
1:70f7692: 
1:d506170:     public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "executeUpdate", autoGeneratedKeys);
1:70f7692:         }
1:1d87ff4:         throw new SqlException(agent_.logWriter_,
1:e65b4db:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:1d87ff4:             "executeUpdate(String, int)").getSQLException();
1:70f7692:     }
1:70f7692: 
1:d506170:     public int executeUpdate(String sql, String[] columnNames) throws SQLException {
1:d506170:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "executeUpdate", columnNames);
1:70f7692:         }
1:1d87ff4:         throw new SqlException(agent_.logWriter_,
1:e65b4db:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:1d87ff4:             "executeUpdate(String, String[])").getSQLException();
1:70f7692:     }
1:70f7692: 
1:d506170:     public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
54:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "executeUpdate", columnIndexes);
1:70f7692:         }
10:70f7692:         throw new SqlException(agent_.logWriter_,
1:e65b4db:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:1d87ff4:             "execute(String, int[])").getSQLException();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public void setURL(int parameterIndex, URL x) throws SQLException {
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceEntry(this, "setURL", parameterIndex, x);
1:70f7692:         }
1:0326967: 
1:0326967:         throw new SqlException(agent_.logWriter_,
1:0326967:                 new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED)).
1:0326967:                 getSQLException();
1:70f7692:     }
1:70f7692: 
1:69e3d06:     public ParameterMetaData getParameterMetaData() throws SQLException {
1:d506170:         try
1:d506170:         {
1:d506170:             synchronized (connection_) {
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceEntry(this, "getParameterMetaData");
1:d506170:                 }
1:d506170:                 Object parameterMetaData = getParameterMetaDataX();
1:d506170:                 if (agent_.loggingEnabled()) {
1:d506170:                     agent_.logWriter_.traceExit(this, "getParameterMetaData", parameterMetaData);
1:d506170:                 }
1:69e3d06:                 return (ParameterMetaData) parameterMetaData;
1:d506170:             }
1:70f7692:         }
1:d506170:         catch ( SqlException se )
1:d506170:         {
1:d506170:             throw se.getSQLException();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:69e3d06:     private ClientParameterMetaData getParameterMetaDataX()
1:69e3d06:             throws SqlException {
1:69e3d06:         ClientParameterMetaData pm =
1:69e3d06:             ClientDriver.getFactory().
1:69e3d06:             newParameterMetaData(getColumnMetaDataX());
1:70f7692:         return pm;
1:70f7692:     }
1:70f7692: 
1:a2006ae:     private ColumnMetaData getColumnMetaDataX() throws SqlException {
1:a2006ae:         checkForClosedStatement();
1:211c985:         return 
1:211c985:             parameterMetaData_ != null ?
1:211c985:             parameterMetaData_ : 
1:211c985:             ClientDriver.getFactory().newColumnMetaData(agent_.logWriter_, 0);
1:211c985:     }
1:211c985: 
1:70f7692:     // ------------------------ box car and callback methods --------------------------------
1:70f7692: 
1:0326967:     private void writeExecute(Section section,
2:70f7692:                              ColumnMetaData parameterMetaData,
1:70f7692:                              Object[] inputs,
1:70f7692:                              int numInputColumns,
1:70f7692:                              boolean outputExpected,
1:70f7692:                              // This is a hint to the material layer that more write commands will follow.
1:70f7692:                              // It is ignored by the driver in all cases except when blob data is written,
1:70f7692:                              // in which case this boolean is used to optimize the implementation.
1:70f7692:                              // Otherwise we wouldn't be able to chain after blob data is sent.
1:70f7692:                              // Current servers have a restriction that blobs can only be chained with blobs
1:70f7692:                              boolean chainedWritesFollowingSetLob) throws SqlException {
1:70f7692:         materialPreparedStatement_.writeExecute_(section,
1:70f7692:                 parameterMetaData,
1:70f7692:                 inputs,
1:70f7692:                 numInputColumns,
1:70f7692:                 outputExpected,
1:70f7692:                 chainedWritesFollowingSetLob);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:0326967:     private void readExecute() throws SqlException {
1:70f7692:         materialPreparedStatement_.readExecute_();
1:70f7692:     }
1:70f7692: 
1:d08d1a5:     private void writeOpenQuery(Section section,
1:70f7692:                                int fetchSize,
1:70f7692:                                int resultSetType,
1:70f7692:                                int numInputColumns,
1:70f7692:                                ColumnMetaData parameterMetaData,
1:70f7692:                                Object[] inputs) throws SqlException {
1:70f7692:         materialPreparedStatement_.writeOpenQuery_(section,
1:70f7692:                 fetchSize,
1:70f7692:                 resultSetType,
1:70f7692:                 numInputColumns,
1:70f7692:                 parameterMetaData,
1:70f7692:                 inputs);
1:70f7692:     }
1:70f7692: 
1:0326967:     private void writeDescribeInput(Section section) throws SqlException {
1:70f7692:         materialPreparedStatement_.writeDescribeInput_(section);
1:70f7692:     }
1:70f7692: 
1:0326967:     private void readDescribeInput() throws SqlException {
1:70f7692:         materialPreparedStatement_.readDescribeInput_();
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void completeDescribeInput(ColumnMetaData parameterMetaData, Sqlca sqlca) {
1:70f7692:         int sqlcode = super.completeSqlca(sqlca);
1:70f7692:         if (sqlcode < 0) {
1:70f7692:             return;
1:70f7692:         }
1:70f7692: 
1:70f7692: 
2:70f7692:         parameterMetaData_ = parameterMetaData;
1:70f7692: 
1:70f7692:         // The following code handles the case when
1:70f7692:         // sqlxParmmode is not supported, in which case server will return 0 (unknown), and
1:70f7692:         // this could clobber our guessed value for sqlxParmmode.  This is a problem.
1:70f7692:         // We can solve this problem for Non-CALL statements, since the parmmode is always IN (1).
1:70f7692:         // But what about CALL statements.  If CALLs are describable, then we have no
1:70f7692:         // problem, we assume server won't return unknown.
1:70f7692:         // If CALLs are not describable then nothing gets clobbered because we won't
1:70f7692:         // parse out extended describe, so again  no problem.
1:70f7692:         if (sqlMode_ != isCall__ && parameterMetaData_ != null) {
1:36adcbf:             // 1 means IN parameter
1:36adcbf:             Arrays.fill(parameterMetaData_.sqlxParmmode_, (short)1);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceParameterMetaData(this, parameterMetaData_);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void completeDescribeOutput(ColumnMetaData resultSetMetaData, Sqlca sqlca) {
1:70f7692:         int sqlcode = super.completeSqlca(sqlca);
1:70f7692:         if (sqlcode < 0) {
1:70f7692:             return;
1:70f7692:         }
2:70f7692:         resultSetMetaData_ = resultSetMetaData;
1:70f7692:         if (agent_.loggingEnabled()) {
1:70f7692:             agent_.logWriter_.traceResultSetMetaData(this, resultSetMetaData);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:0326967:     private void writePrepareDescribeInputOutput() throws SqlException {
2:70f7692:         // Notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
1:74fb1b0:         writePrepareDescribeOutput(sql_, getSection());
1:74fb1b0:         writeDescribeInput(getSection());
1:70f7692:     }
1:70f7692: 
1:0326967:     private void readPrepareDescribeInputOutput() throws SqlException {
1:70f7692:         readPrepareDescribeOutput();
1:70f7692:         readDescribeInput();
1:70f7692:         completePrepareDescribe();
1:70f7692:     }
1:70f7692: 
1:0326967:     private void writePrepareDescribeInput() throws SqlException {
1:70f7692:         // performance will be better if we flow prepare with output enable vs. prepare then describe input for callable
1:70f7692:         // Notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
1:74fb1b0:         writePrepare(sql_, getSection());
1:74fb1b0:         writeDescribeInput(getSection());
1:70f7692:     }
1:70f7692: 
1:b565f41:     private void readPrepareDescribeInput() throws SqlException {
1:70f7692:         readPrepare();
1:70f7692:         readDescribeInput();
1:70f7692:         completePrepareDescribe();
1:70f7692:     }
1:70f7692: 
1:0326967:     private void completePrepareDescribe() {
1:70f7692:         if (parameterMetaData_ == null) {
1:70f7692:             return;
1:70f7692:         }
1:70f7692:         parameters_ = expandObjectArray(parameters_, parameterMetaData_.columns_);
1:70f7692:         parameterSet_ = expandBooleanArray(parameterSet_, parameterMetaData_.columns_);
1:70f7692:         parameterRegistered_ = expandBooleanArray(parameterRegistered_, parameterMetaData_.columns_);
1:70f7692:     }
1:70f7692: 
1:70f7692:     private Object[] expandObjectArray(Object[] array, int newLength) {
1:70f7692:         if (array == null) {
1:70f7692:             Object[] newArray = new Object[newLength];
1:70f7692:             return newArray;
1:70f7692:         }
1:70f7692:         if (array.length < newLength) {
1:70f7692:             Object[] newArray = new Object[newLength];
1:70f7692:             System.arraycopy(array, 0, newArray, 0, array.length);
1:70f7692:             return newArray;
1:70f7692:         }
1:70f7692:         return array;
1:70f7692:     }
1:70f7692: 
1:70f7692:     private boolean[] expandBooleanArray(boolean[] array, int newLength) {
1:70f7692:         if (array == null) {
1:70f7692:             boolean[] newArray = new boolean[newLength];
1:70f7692:             return newArray;
1:70f7692:         }
1:70f7692:         if (array.length < newLength) {
1:70f7692:             boolean[] newArray = new boolean[newLength];
1:70f7692:             System.arraycopy(array, 0, newArray, 0, array.length);
1:70f7692:             return newArray;
1:70f7692:         }
1:70f7692:         return array;
1:70f7692:     }
1:70f7692: 
1:70f7692:     void flowPrepareDescribeInputOutput() throws SqlException {
2:70f7692:         agent_.beginWriteChain(this);
1:70f7692:         if (sqlMode_ == isCall__) {
1:70f7692:             writePrepareDescribeInput();
2:70f7692:             agent_.flow(this);
1:70f7692:             readPrepareDescribeInput();
2:70f7692:             agent_.endReadChain();
1:70f7692:         } else {
1:70f7692:             writePrepareDescribeInputOutput();
1:70f7692:             agent_.flow(this);
2:70f7692:             readPrepareDescribeInputOutput();
1:70f7692:             agent_.endReadChain();
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:d08d1a5:     private void flowExecute(int executeType) throws SqlException {
1:320777f:         checkForClosedStatement();
1:aadfc18:         checkAutoGeneratedKeysParameters();
1:d08d1a5:         clearWarningsX();
1:d08d1a5:         checkForAppropriateSqlMode(executeType, sqlMode_);
2:70f7692:         checkThatAllParametersAreSet();
1:70f7692: 
2:70f7692:         if (sqlMode_ == isUpdate__) {
1:70f7692:             updateCount_ = 0;
1:70f7692:         } else {
1:70f7692:             updateCount_ = -1;
1:70f7692:         }
1:70f7692: 
1:d51b773:         // DERBY-1036: Moved check till execute time to comply with embedded
1:d51b773:         // behavior. Since we check here and not in setCursorName, several
1:d51b773:         // statements can have the same cursor name as long as their result
1:d51b773:         // sets are not simultaneously open.
1:d51b773: 
1:d51b773:         if (sqlMode_ == isQuery__) {
1:d51b773:             checkForDuplicateCursorName();
1:d51b773:         }
1:d51b773: 
1:70f7692:             agent_.beginWriteChain(this);
1:70f7692: 
1:d08d1a5:             boolean piggybackedAutocommit = writeCloseResultSets(true);  // true means permit auto-commits
1:70f7692: 
1:d506170:             int numInputColumns;
1:d506170:             boolean outputExpected;
1:d506170:             try
1:d506170:             {
1:d506170:                 numInputColumns = (parameterMetaData_ != null) ? parameterMetaData_.getColumnCount() : 0;
1:d506170:                 outputExpected = (resultSetMetaData_ != null && resultSetMetaData_.getColumnCount() > 0);
1:d506170:             }
1:d506170:             catch ( SQLException se )
1:d506170:             {
1:d506170:                 // Generate a SqlException for this, we don't want to throw
1:d506170:                 // SQLException in this internal method
1:1d87ff4:                 throw new SqlException(se);
1:d506170:             }
1:70f7692:             boolean chainAutoCommit = false;
1:70f7692:             boolean commitSubstituted = false;
1:70f7692:             boolean repositionedCursor = false;
1:c8ceb5f:             boolean timeoutSent = false;
1:69e3d06:             ClientResultSet scrollableRS = null;
1:74fb1b0:             boolean prepareSentForAutoGeneratedKeys = false;
1:70f7692: 
1:c8ceb5f:             if (doWriteTimeout) {
1:c8ceb5f:                 timeoutArrayList.set(0, TIMEOUT_STATEMENT + timeout_);
1:c8ceb5f:                 writeSetSpecialRegister(timeoutArrayList);
1:c8ceb5f:                 doWriteTimeout = false;
1:c8ceb5f:                 timeoutSent = true;
1:c8ceb5f:             }
1:70f7692:             switch (sqlMode_) {
1:70f7692:             case isUpdate__:
1:70f7692:                 if (positionedUpdateCursorName_ != null) {
1:70f7692:                     scrollableRS = agent_.sectionManager_.getPositionedUpdateResultSet(positionedUpdateCursorName_);
1:70f7692:                 }
1:70f7692:                 if (scrollableRS != null && !scrollableRS.isRowsetCursor_) {
1:70f7692:                     repositionedCursor =
1:70f7692:                             scrollableRS.repositionScrollableResultSetBeforeJDBC1PositionedUpdateDelete();
1:70f7692:                     if (!repositionedCursor) {
1:70f7692:                         scrollableRS = null;
1:70f7692:                     }
1:70f7692:                 }
1:70f7692: 
1:70f7692:                 chainAutoCommit = connection_.willAutoCommitGenerateFlow() && isAutoCommittableStatement_;
1:70f7692: 
1:aa302c3:                 boolean chainOpenQueryForAutoGeneratedKeys = 
1:aa302c3:                 		((sqlUpdateMode_ == isInsertSql__ || sqlUpdateMode_ == isUpdateSql__) 
1:aa302c3:                 				&& autoGeneratedKeys_ == RETURN_GENERATED_KEYS);
1:74fb1b0:                 writeExecute(getSection(),
1:eab1882:                         parameterMetaData_,
1:eab1882:                         parameters_,
1:eab1882:                         numInputColumns,
1:eab1882:                         outputExpected,
1:eab1882:                         (chainAutoCommit || chainOpenQueryForAutoGeneratedKeys)// chain flag
1:eab1882:                 ); // chain flag
1:70f7692: 
1:eab1882:                 if (chainOpenQueryForAutoGeneratedKeys) {
1:74fb1b0:                     if (preparedStatementForAutoGeneratedKeys_ == null) {
1:74fb1b0:                         preparedStatementForAutoGeneratedKeys_ =
1:74fb1b0:                                 prepareAutoGeneratedKeysStatement(connection_);
1:74fb1b0:                         prepareSentForAutoGeneratedKeys = true;
1:74fb1b0:                     }
1:74fb1b0:                   
1:74fb1b0:                     writeOpenQuery(preparedStatementForAutoGeneratedKeys_.getSection(),
1:eab1882:                             preparedStatementForAutoGeneratedKeys_.fetchSize_,
1:eab1882:                             preparedStatementForAutoGeneratedKeys_.resultSetType_);
1:70f7692:                 }
1:eab1882:                 
1:70f7692: 
1:70f7692:                 if (chainAutoCommit) {
1:70f7692:                     // we have encountered an error in writing the execute, so do not
1:70f7692:                     // flow an autocommit
1:70f7692:                     if (agent_.accumulatedReadExceptions_ != null) {
1:70f7692:                         // currently, the only write exception we encounter is for
1:70f7692:                         // data truncation: SQLSTATE 01004, so we don't bother checking for this
1:70f7692:                         connection_.writeCommitSubstitute_();
1:70f7692:                         commitSubstituted = true;
1:70f7692:                     } else {
1:70f7692:                         // there is no write error, so flow the commit
1:70f7692:                         connection_.writeCommit();
1:70f7692:                     }
1:70f7692:                 }
1:70f7692:                 break;
1:70f7692: 
1:70f7692:             case isQuery__:
1:74fb1b0:                 writeOpenQuery(getSection(),
2:70f7692:                         fetchSize_,
2:70f7692:                         resultSetType_,
1:70f7692:                         numInputColumns,
2:70f7692:                         parameterMetaData_,
1:70f7692:                         parameters_);
1:70f7692:                 break;
1:70f7692: 
1:70f7692:             case isCall__:
1:70f7692:                 writeExecuteCall(outputRegistered_, // if no out/inout parameter, outputExpected = false
1:74fb1b0:                         null, getSection(),
1:70f7692:                         fetchSize_,
1:70f7692:                         false, // do not suppress ResultSets for regular CALLs
1:70f7692:                         resultSetType_,
1:70f7692:                         parameterMetaData_,
1:70f7692:                         parameters_); // cross conversion
1:70f7692:                 break;
1:70f7692:             }
1:70f7692: 
1:70f7692:             agent_.flow(this);
1:70f7692: 
1:70f7692:             super.readCloseResultSets(true);  // true means permit auto-commits
1:70f7692: 
1:70f7692:             // turn inUnitOfWork_ flag back on and add statement
1:70f7692:             // back on commitListeners_ list if they were off
1:70f7692:             // by an autocommit chained to a close cursor.
1:70f7692:             if (piggybackedAutocommit) {
1:70f7692:                 connection_.completeTransactionStart();
1:70f7692:             }
1:70f7692: 
1:d08d1a5:             markResultSetsClosed(true); // true means remove from list of commit and rollback listeners
1:70f7692: 
1:c8ceb5f:             if (timeoutSent) {
1:c8ceb5f:                 readSetSpecialRegister(); // Read response to the EXCSQLSET
1:c8ceb5f:             }
1:c8ceb5f: 
1:70f7692:             switch (sqlMode_) {
1:70f7692:             case isUpdate__:
1:70f7692:                 // do not need to reposition for a rowset cursor
1:70f7692:                 if (scrollableRS != null && !scrollableRS.isRowsetCursor_) {
1:70f7692:                     scrollableRS.readPositioningFetch_();
1:70f7692:                 }
1:70f7692: 
1:eab1882:                 else {
1:70f7692:                     readExecute();
1:3896fdd: 
1:aa302c3:             		if ((sqlUpdateMode_ == isInsertSql__ || sqlUpdateMode_ == isUpdateSql__) 
1:aa302c3:             				&& autoGeneratedKeys_ == RETURN_GENERATED_KEYS) {
1:74fb1b0:                         if (prepareSentForAutoGeneratedKeys) {
1:74fb1b0:                             preparedStatementForAutoGeneratedKeys_.materialPreparedStatement_.readPrepareDescribeOutput_();
1:74fb1b0:                         }
1:74fb1b0:           
1:70f7692:                         preparedStatementForAutoGeneratedKeys_.readOpenQuery();
1:70f7692:                         generatedKeysResultSet_ = preparedStatementForAutoGeneratedKeys_.resultSet_;
1:70f7692:                         preparedStatementForAutoGeneratedKeys_.resultSet_ = null;
1:3896fdd:                     }
1:3896fdd:                 }
1:3896fdd: 
1:70f7692:                 if (chainAutoCommit) {
1:70f7692:                     if (commitSubstituted) {
1:70f7692:                         connection_.readCommitSubstitute_();
1:70f7692:                     } else {
1:70f7692:                         connection_.readCommit();
1:3896fdd:                     }
1:3896fdd:                 }
1:70f7692:                 break;
1:3896fdd: 
1:70f7692:             case isQuery__:
1:70f7692:                 try {
2:70f7692:                     readOpenQuery();
1:70f7692:                 } catch (DisconnectException dise) {
1:70f7692:                     throw dise;
1:70f7692:                 } catch (SqlException e) {
1:70f7692:                     throw e;
1:3896fdd:                 }
1:70f7692:                 // resultSet_ is null if open query failed.
1:70f7692:                 // check for null resultSet_ before using it.
2:70f7692:                 if (resultSet_ != null) {
1:70f7692:                     resultSet_.parseScrollableRowset();
1:70f7692:                     //if (resultSet_.scrollable_) resultSet_.getRowCount();
1:d51b773: 
1:d51b773:                     // DERBY-1183: If we set it up earlier, the entry in
1:d51b773:                     // clientCursorNameCache_ gets wiped out by the closing of
1:d51b773:                     // result sets happening during readCloseResultSets above
1:d51b773:                     // because ResultSet#markClosed calls
1:d51b773:                     // Statement#removeClientCursorNameFromCache.
1:d51b773:                     setupCursorNameCacheAndMappings();
1:70f7692:                 }
1:70f7692:                 break;
1:3896fdd: 
1:70f7692:             case isCall__:
1:70f7692:                 readExecuteCall();
1:70f7692:                 break;
1:70f7692: 
1:70f7692:             }
1:70f7692: 
1:70f7692: 
1:70f7692:             try {
1:70f7692:                 agent_.endReadChain();
1:70f7692:             } catch (SqlException e) {
1:70f7692:                 throw e;
1:70f7692: 
1:70f7692:             }
1:70f7692: 
1:70f7692:             if (sqlMode_ == isCall__) {
1:70f7692:                 parseStorProcReturnedScrollableRowset();
1:d8383bd:                 checkForStoredProcResultSetCount(executeType);
1:70f7692:                 // When there are no result sets back, we will commit immediately when autocommit is true.
1:70f7692:                 // make sure a commit is not performed when making the call to the sqlca message procedure
1:70f7692:                 if (connection_.autoCommit_ && resultSet_ == null && resultSetList_ == null && isAutoCommittableStatement_) {
1:70f7692:                     connection_.flowAutoCommit();
1:70f7692:                 }
1:70f7692:             }
1:70f7692: 
1:73d678d:             // The JDBC spec says that executeUpdate() should return 0
1:73d678d:             // when no row count is returned.
1:73d678d:             if (executeType == executeUpdateMethod__ && updateCount_ < 0) {
1:73d678d:                 updateCount_ = 0;
1:73d678d:             }
1:73d678d: 
1:70f7692:             // Throw an exception if holdability returned by the server is different from requested.
1:70f7692:             if (resultSet_ != null && resultSet_.resultSetHoldability_ != resultSetHoldability_ && sqlMode_ != isCall__) {
1:1d87ff4:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                     new ClientMessageId(SQLState.UNABLE_TO_OPEN_RESULTSET_WITH_REQUESTED_HOLDABILTY),
1:66527ec:                         resultSetHoldability_);
1:70f7692:             }
1:70f7692:     }
1:70f7692: 
1:0326967:     private long[] executeBatchX(boolean supportsQueryBatchRequest)
1:a2006ae:         throws SqlException, SQLException {
1:3896fdd:         synchronized (connection_) {
1:70f7692:             checkForClosedStatement(); // Per jdbc spec (see Statement.close() javadoc)
1:70f7692:             clearWarningsX(); // Per jdbc spec 0.7, also see getWarnings() javadoc
1:70f7692:             return executeBatchRequestX(supportsQueryBatchRequest);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:f26c60c:     private long[] executeBatchRequestX(boolean supportsQueryBatchRequest)
1:69e3d06:             throws SqlException, BatchUpdateException {
1:70f7692:         SqlException chainBreaker = null;
1:70f7692:         int batchSize = batch_.size();
1:f26c60c:         long[] updateCounts = new long[batchSize];
1:d506170:         int numInputColumns;
1:d506170:         try {
1:d506170:             numInputColumns = parameterMetaData_ == null ? 0 : parameterMetaData_.getColumnCount();
1:d506170:         } catch ( SQLException se ) {
1:d506170:             throw new SqlException(se);
1:d506170:         }
1:70f7692:         Object[] savedInputs = null;  // used to save/restore existing parameters
1:c8ceb5f:         boolean timeoutSent = false;
1:70f7692: 
1:70f7692:         if (batchSize == 0) {
1:d506170:             return updateCounts;
1:70f7692:         }
1:6eb29f6:         // The network client has a hard limit of 65,534 commands in a single
1:6eb29f6:         // DRDA request. This is because DRDA uses a 2-byte correlation ID,
1:6eb29f6:         // and the values 0 and 0xffff are reserved as special values. So
1:6eb29f6:         // that imposes an upper limit on the batch size we can support:
1:6eb29f6:         if (batchSize > 65534)
1:b54918e:             throw ClientDriver.getFactory().newBatchUpdateException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.TOO_MANY_COMMANDS_FOR_BATCH), 
1:39b3237:                 new Object[] { 65534 }, updateCounts, null );
1:70f7692: 
1:70f7692:         // Initialize all the updateCounts to indicate failure
1:70f7692:         // This is done to account for "chain-breaking" errors where we cannot
1:70f7692:         // read any more replies
1:70f7692:         for (int i = 0; i < batchSize; i++) {
1:70f7692:             updateCounts[i] = -3;
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (!supportsQueryBatchRequest && sqlMode_ == isQuery__) {
1:b54918e:             throw ClientDriver.getFactory().newBatchUpdateException(agent_.logWriter_, 
1:b54918e:             new ClientMessageId(SQLState.CANNOT_BATCH_QUERIES), (Object [])null, updateCounts, null);
1:70f7692:         }
1:70f7692:         if (supportsQueryBatchRequest && sqlMode_ != isQuery__) {
1:b54918e:             throw ClientDriver.getFactory().newBatchUpdateException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.QUERY_BATCH_ON_NON_QUERY_STATEMENT), 
1:b54918e:                 (Object [])null, updateCounts, null);
1:70f7692:         }
1:70f7692: 
1:70f7692:         resultSetList_ = null;
1:70f7692: 
1:70f7692: 
1:70f7692:         if (sqlMode_ == isQuery__) {
1:9f1ddc5:             resetResultSetList();
1:69e3d06:             resultSetList_ = new ClientResultSet[batchSize];
1:70f7692:         }
1:70f7692: 
1:70f7692: 
1:70f7692:         //save the current input set so it can be restored
1:70f7692:         savedInputs = parameters_;
1:70f7692: 
1:70f7692:         agent_.beginBatchedWriteChain(this);
1:70f7692:         boolean chainAutoCommit = connection_.willAutoCommitGenerateFlow() && isAutoCommittableStatement_;
1:c8ceb5f: 
1:c8ceb5f:         if (doWriteTimeout) {
1:c8ceb5f:             timeoutArrayList.set(0, TIMEOUT_STATEMENT + timeout_);
1:c8ceb5f:             writeSetSpecialRegister(timeoutArrayList);
1:c8ceb5f:             doWriteTimeout = false;
1:c8ceb5f:             timeoutSent = true;
1:c8ceb5f:         }
1:70f7692: 
1:70f7692:         for (int i = 0; i < batchSize; i++) {
1:2c140d8:             if (parameterMetaData_ != null) {
1:4772c7e:                 parameterMetaData_.clientParamtertype_ = parameterTypeList.get(i);
1:2c140d8:                 parameters_ = (Object[]) batch_.get(i);
1:2c140d8:             }
1:2c140d8:             
1:70f7692:             if (sqlMode_ != isCall__) {
1:d506170:                 boolean outputExpected;
1:d506170:                 try {
1:d506170:                     outputExpected = (resultSetMetaData_ != null && resultSetMetaData_.getColumnCount() > 0);
1:d506170:                 } catch ( SQLException se ) {
1:d506170:                     throw new SqlException(se);
1:d506170:                 }
1:70f7692: 
1:74fb1b0:                 writeExecute(getSection(),
1:70f7692:                         parameterMetaData_,
1:70f7692:                         parameters_,
1:70f7692:                         numInputColumns,
3:33776ff:                         outputExpected,
1:33776ff:                         chainAutoCommit || (i != batchSize - 1));  // more statements to chain
1:70f7692:             } else if (outputRegistered_) // make sure no output parameters are registered
1:3896fdd:             {
1:b54918e:                 throw ClientDriver.getFactory().newBatchUpdateException(agent_.logWriter_, 
1:e65b4db:                     new ClientMessageId(SQLState.OUTPUT_PARAMS_NOT_ALLOWED),
1:b54918e:                     (Object [])null, updateCounts, null );
1:70f7692:             } else {
1:70f7692:                 writeExecuteCall(false, // no output expected for batched CALLs
1:74fb1b0:                         null, getSection(),
1:70f7692:                         fetchSize_,
1:70f7692:                         true, // suppress ResultSets for batch
1:70f7692:                         resultSetType_,
1:70f7692:                         parameterMetaData_,
1:70f7692:                         parameters_);
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         boolean commitSubstituted = false;
1:70f7692:         if (chainAutoCommit) {
1:70f7692:             // we have encountered an error in writing the execute, so do not
1:70f7692:             // flow an autocommit
1:70f7692:             if (agent_.accumulatedReadExceptions_ != null) {
1:70f7692:                 // currently, the only write exception we encounter is for
1:70f7692:                 // data truncation: SQLSTATE 01004, so we don't bother checking for this
1:70f7692:                 connection_.writeCommitSubstitute_();
1:70f7692:                 commitSubstituted = true;
1:70f7692:             } else {
1:70f7692:                 // there is no write error, so flow the commit
1:70f7692:                 connection_.writeCommit();
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:         agent_.flowBatch(this, batchSize);
1:c8ceb5f: 
1:c8ceb5f:         if (timeoutSent) {
1:c8ceb5f:             readSetSpecialRegister(); // Read response to the EXCSQLSET
1:c8ceb5f:         }
1:70f7692: 
1:70f7692:         try {
1:70f7692:             for (int i = 0; i < batchSize; i++) {
1:70f7692:                 agent_.setBatchedExceptionLabelIndex(i);
2:70f7692:                 parameters_ = (Object[]) batch_.get(i);
1:70f7692:                 if (sqlMode_ != isCall__) {
1:70f7692:                     readExecute();
1:70f7692:                 } else {
1:70f7692:                     readExecuteCall();
1:70f7692:                 }
1:70f7692:                 updateCounts[i] = updateCount_;
1:70f7692: 
1:70f7692:             }
1:70f7692: 
1:70f7692:             agent_.disableBatchedExceptionTracking(); // to prvent the following readCommit() from getting a batch label
1:70f7692:             if (chainAutoCommit) {
1:70f7692:                 if (!commitSubstituted) {
1:70f7692:                     connection_.readCommit();
1:70f7692:                 } else {
1:70f7692:                     connection_.readCommitSubstitute_();
1:70f7692:                 }
1:70f7692:             }
1:70f7692:         }
1:70f7692: 
1:70f7692:                 // for chain-breaking exception only, all read() methods do their own accumulation
1:70f7692:                 // this catches the entire accumulated chain, we need to be careful not to
1:70f7692:                 // reaccumulate it on the agent since the batch labels will be overwritten if
1:70f7692:                 // batch exception tracking is enabled.
1:70f7692:         catch (SqlException e) { // for chain-breaking exception only
1:70f7692:             chainBreaker = e;
1:70f7692:             chainBreaker.setNextException(new SqlException(agent_.logWriter_,
1:b2a1747:                 new ClientMessageId(SQLState.BATCH_CHAIN_BREAKING_EXCEPTION)));
1:70f7692:         }
1:70f7692:         // We need to clear the batch before any exception is thrown from agent_.endBatchedReadChain().
1:70f7692:         batch_.clear();
1:63d4142:         parameterTypeList = null;
1:70f7692: 
1:70f7692:         // restore the saved input set, setting it to "current"
1:70f7692:         parameters_ = savedInputs;
1:70f7692: 
1:70f7692:         agent_.endBatchedReadChain(updateCounts, chainBreaker);
1:70f7692: 
3:70f7692:         return updateCounts;
1:70f7692: 
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     //------------------material layer event callbacks follow-----------------------
1:70f7692: 
1:0326967:     private boolean listenToUnitOfWork_ = false;
1:70f7692: 
1:70f7692:     public void listenToUnitOfWork() {
1:70f7692:         if (!listenToUnitOfWork_) {
1:70f7692:             listenToUnitOfWork_ = true;
1:dd7d579:             connection_.CommitAndRollbackListeners_.put(this,null);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:74fb1b0:     @Override
1:69e3d06:     public void completeLocalCommit(Iterator listenerIterator) {
1:70f7692:         listenerIterator.remove();
1:70f7692:         listenToUnitOfWork_ = false;
1:70f7692:     }
1:70f7692: 
1:74fb1b0:     @Override
1:69e3d06:     public void completeLocalRollback(Iterator listenerIterator) {
1:70f7692:         listenerIterator.remove();
1:70f7692:         listenToUnitOfWork_ = false;
1:70f7692:     }
1:33776ff: 
1:70f7692:     //----------------------------internal use only helper methods----------------
1:70f7692: 
1:407e52d:     /**
1:d8383bd:      * Returns the name of the java.sql interface implemented by this class.
1:d8383bd:      * @return name of java.sql interface
1:d8383bd:      */
1:d8383bd:     protected String getJdbcStatementInterfaceName() {
1:d8383bd:         return "java.sql.PreparedStatement";
1:d8383bd:     }
1:d8383bd: 
1:70f7692:     void checkForValidParameterIndex(int parameterIndex) throws SqlException {
1:7bee3c6:         if (parameterMetaData_ == null) 
1:7bee3c6:             throw new SqlException(agent_.logWriter_,
1:7bee3c6:                     new ClientMessageId(SQLState.NO_INPUT_PARAMETERS));
1:7bee3c6: 
1:7bee3c6:         if (parameterIndex < 1 || parameterIndex > parameterMetaData_.columns_) {
1:1d87ff4:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.LANG_INVALID_PARAM_POSITION),
1:66527ec:                 parameterIndex, parameterMetaData_.columns_);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     private void checkThatAllParametersAreSet() throws SqlException {
1:d506170:         if (parameterMetaData_ != null) {
3:70f7692:             for (int i = 0; i < parameterMetaData_.columns_; i++) {
1:b98b60e:                 // Raise an exception if at least one of the parameters isn't
1:b98b60e:                 // set. It is OK that a parameter isn't set if it is registered
1:b98b60e:                 // as an output parameter. However, if it's an INOUT parameter,
1:b98b60e:                 // it must be set even if it has been registered (DERBY-2516).
1:b98b60e:                 if (!parameterSet_[i] &&
1:b98b60e:                         (!parameterRegistered_[i] ||
1:b98b60e:                          parameterMetaData_.sqlxParmmode_[i] ==
1:69e3d06:                             ClientParameterMetaData.parameterModeInOut)) {
1:1d87ff4:                     throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.LANG_MISSING_PARMS));
1:70f7692:                 }
1:70f7692:             }
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     void checkForValidScale(int scale) throws SqlException {
1:70f7692:         if (scale < 0 || scale > 31) {
1:1d87ff4:             throw new SqlException(agent_.logWriter_, 
1:66527ec:                 new ClientMessageId(SQLState.BAD_SCALE_VALUE), scale);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:bd644c6:     /* (non-Javadoc)
1:bd644c6:      * @see org.apache.derby.client.am.Statement#markClosed(boolean)
1:bd644c6:      */
1:bd644c6:     protected void markClosed(boolean removeListener){
1:407e52d:         if(pooledConnection_ != null)
1:407e52d:             pooledConnection_.onStatementClose(this);
1:6eb29f6:         super.markClosed(removeListener);
1:6eb29f6:         
1:6eb29f6:         if (parameterMetaData_ != null) {
1:70f7692:             parameterMetaData_.markClosed();
1:70f7692:             parameterMetaData_ = null;
1:70f7692:         }
1:70f7692:         sql_ = null;
1:bd644c6: 
1:70f7692:         // Apparently, the JVM is not smart enough to traverse parameters_[] and null
1:70f7692:         // out its members when the entire array is set to null (parameters_=null;).
1:70f7692:         if (parameters_ != null) {
1:36adcbf:             Arrays.fill(parameters_, null);
1:70f7692:         }
1:70f7692:         parameters_ = null;
1:70f7692: 
1:bd644c6:         if(removeListener)
1:6eb29f6:             connection_.CommitAndRollbackListeners_.remove(this);
1:3896fdd:     }
1:3896fdd:     
1:5ef7a0d:     // JDBC 4.0 methods
1:3896fdd: 
1:407e52d:     /**
1:956354d:      * Sets the designated parameter to the given input stream.
1:956354d:      * When a very large ASCII value is input to a <code>LONGVARCHAR</code>
1:956354d:      * parameter, it may be more practical to send it via a
1:956354d:      * <code>java.io.InputStream</code>. Data will be read from the stream as
1:956354d:      * needed until end-of-file is reached. The JDBC driver will do any
1:956354d:      * necessary conversion from ASCII to the database char format.
1:956354d:      *
1:956354d:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:956354d:      * @param x the Java input stream that contains the ASCII parameter value
1:956354d:      * @throws SQLException if a database access error occurs or this method is
1:956354d:      *      called on a closed <code>PreparedStatement</code>
1:956354d:      */
1:956354d:     public void setAsciiStream(int parameterIndex, InputStream x)
1:956354d:             throws SQLException {
1:956354d:         synchronized (connection_) {
1:956354d:             if (agent_.loggingEnabled()) {
1:956354d:                 agent_.logWriter_.traceEntry(this, "setAsciiStream",
1:956354d:                         parameterIndex, x);
1:956354d:             }
1:956354d:             try {
1:a2006ae:                 checkTypeForSetAsciiStream(parameterIndex);
1:69e3d06:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:69e3d06:                     Types.CLOB;
1:956354d: 
1:956354d:                 if (x == null) {
1:69e3d06:                     setNull(parameterIndex, Types.LONGVARCHAR);
1:956354d:                     return;
1:956354d:                 }
1:69e3d06:                 setInput(parameterIndex,
1:a0b8943:                          new ClientClob(agent_, x, Cursor.ISO_8859_1));
1:956354d:             } catch (SqlException se) {
1:956354d:                 throw se.getSQLException();
1:956354d:             }
1:956354d:         }
1:956354d:     }
1:3896fdd: 
1:956354d:     /**
1:956354d:      * Sets the designated parameter to the given input stream.
1:956354d:      * When a very large binary value is input to a <code>LONGVARBINARY</code>
1:956354d:      * parameter, it may be more practical to send it via a
1:956354d:      * <code>java.io.InputStream</code> object. The data will be read from the
1:956354d:      * stream as needed until end-of-file is reached.
1:956354d:      *
1:956354d:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:956354d:      * @param x the java input stream which contains the binary parameter value
1:956354d:      * @throws SQLException if a database access error occurs or this method is
1:956354d:      *      called on a closed <code>PreparedStatement</code>
1:956354d:      */
1:956354d:     public void setBinaryStream(int parameterIndex, InputStream x)
1:956354d:             throws SQLException {
1:956354d:         synchronized (connection_) {
1:956354d:             if (agent_.loggingEnabled()) {
1:956354d:                 agent_.logWriter_.traceEntry(this, "setBinaryStream",
1:956354d:                         parameterIndex, x);
1:956354d:             }
1:956354d:             try {
1:a2006ae:                 checkTypeForSetBinaryStream(parameterIndex);
1:956354d:                 setBinaryStreamX(parameterIndex, x, -1);
1:956354d:             } catch (SqlException se) {
1:956354d:                 throw se.getSQLException();
1:956354d:             }
1:956354d:         }
1:956354d:     }
1:956354d: 
1:956354d:     /**
1:956354d:      * Sets the designated parameter to a <code>Reader</code> object.
1:956354d:      *
1:956354d:      * @param parameterIndex index of the first parameter is 1, the second is 
1:956354d:      *      2, ...
1:956354d:      * @param reader an object that contains the data to set the parameter
1:956354d:      *      value to. 
1:956354d:      * @throws SQLException if parameterIndex does not correspond to a 
1:956354d:      *      parameter marker in the SQL statement; if a database access error
1:956354d:      *      occurs; this method is called on a closed PreparedStatementor if
1:956354d:      *      parameterIndex does not correspond to a parameter marker in the SQL
1:956354d:      *      statement
1:956354d:      */
1:956354d:     public void setClob(int parameterIndex, Reader reader)
1:956354d:             throws SQLException {
1:956354d:         synchronized (connection_) {
1:956354d:             if (agent_.loggingEnabled()) {
1:956354d:                 agent_.logWriter_.traceEntry(this, "setClob",
1:956354d:                         parameterIndex, reader);
1:956354d:             }
1:956354d:             
1:956354d:             try {
1:a2006ae:                 checkTypeForSetClob(parameterIndex);
1:956354d:                 checkForClosedStatement();
1:956354d:             } catch (SqlException se) {
1:956354d:                 throw se.getSQLException();
1:956354d:             }
1:69e3d06:             setInput(parameterIndex, new ClientClob(agent_, reader));
1:956354d:         }
1:956354d:     }
1:486f51a: 
1:5e717f9:    /**
1:3896fdd:      * Sets the designated parameter to a Reader object.
1:76af6ed:      *
1:3896fdd:      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
1:3896fdd:      * @param reader An object that contains the data to set the parameter value to.
1:3896fdd:      * @param length the number of characters in the parameter data.
1:3896fdd:      * @throws SQLException if parameterIndex does not correspond to a parameter
1:3896fdd:      * marker in the SQL statement, or if the length specified is less than zero.
4:3896fdd:      *
1:486f51a:      */
1:486f51a:     
1:3896fdd:     public void setClob(int parameterIndex, Reader reader, long length)
2:3896fdd:     throws SQLException{
1:3896fdd:         synchronized (connection_) {
1:3896fdd:             if (agent_.loggingEnabled()) {
1:3896fdd:                 agent_.logWriter_.traceEntry(this, "setClob",
1:66527ec:                         parameterIndex, reader, Long.valueOf(length));
1:320777f:             }
1:320777f:             try {
1:320777f:                 checkForClosedStatement();
1:320777f:             } catch (SqlException se) {
1:320777f:                 throw se.getSQLException();
1:3896fdd:             }
1:3896fdd:             if(length > Integer.MAX_VALUE)
1:1d87ff4:                 throw new SqlException(agent_.logWriter_,
1:e65b4db:                     new ClientMessageId(SQLState.BLOB_TOO_LARGE_FOR_CLIENT),
1:66527ec:                     length, Integer.MAX_VALUE).getSQLException();
1:3896fdd:             else
1:69e3d06:                 setInput(parameterIndex,
1:69e3d06:                          new ClientClob(agent_, reader, (int)length));
1:3896fdd:         }
1:3896fdd:     }
1:486f51a: 
1:76af6ed:     /**
1:956354d:      * Sets the designated parameter to a <code>InputStream</code> object.
1:956354d:      * This method differs from the <code>setBinaryStream(int, InputStream)
1:956354d:      * </code>  method because it informs the driver that the parameter value
1:956354d:      * should be sent to the server as a <code>BLOB</code>. When the
1:956354d:      * <code>setBinaryStream</code> method is used, the driver may have to do
1:956354d:      * extra work to determine whether the parameter data should be sent to the
1:956354d:      * server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>
1:956354d:      *
1:956354d:      * @param parameterIndex index of the first parameter is 1, the second is
1:956354d:      *      2, ...
1:956354d:      * @param inputStream an object that contains the data to set the parameter
1:956354d:      *      value to.
1:956354d:      * @throws SQLException if a database access error occurs, this method is
1:956354d:      *      called on a closed <code>PreparedStatement</code> or if
1:956354d:      *      <code>parameterIndex</code> does not correspond to a parameter
1:956354d:      *      marker in the SQL statement
1:956354d:      */
1:956354d:     public void setBlob(int parameterIndex, InputStream inputStream)
1:956354d:             throws SQLException {
1:956354d:         synchronized (connection_) {
1:956354d:             if (agent_.loggingEnabled()) {
1:956354d:                 agent_.logWriter_.traceEntry(this, "setBlob", parameterIndex,
1:956354d:                         inputStream);
1:956354d:             }
1:486f51a: 
1:956354d:             try {
1:a2006ae:                 checkTypeForSetBlob(parameterIndex);
1:956354d:                 setBinaryStreamX(parameterIndex, inputStream, -1);
1:956354d:             } catch (SqlException se) {
1:956354d:                 throw se.getSQLException();
1:956354d:             }
1:956354d:         }
1:956354d:     }
1:956354d: 
1:956354d:     /**
1:3896fdd:      * Sets the designated parameter to a InputStream object.
1:3896fdd:      *
1:3896fdd:      * @param parameterIndex index of the first parameter is 1,
1:3896fdd:      * the second is 2, ...
1:3896fdd:      * @param inputStream An object that contains the data to set the parameter
1:3896fdd:      * value to.
1:3896fdd:      * @param length the number of bytes in the parameter data.
1:3896fdd:      * @throws SQLException if parameterIndex does not correspond
1:3896fdd:      * to a parameter marker in the SQL statement,  if the length specified
1:3896fdd:      * is less than zero or if the number of bytes in the inputstream does not match
1:3896fdd:      * the specfied length.
1:3896fdd:      *
4:3896fdd:      */
1:3896fdd:     
1:3896fdd:     public void setBlob(int parameterIndex, InputStream inputStream, long length)
1:3896fdd:     throws SQLException{
1:3896fdd:         synchronized (connection_) {
1:3896fdd:             if (agent_.loggingEnabled()) {
1:3896fdd:                 agent_.logWriter_.traceEntry(this, "setBlob", parameterIndex,
1:66527ec:                         inputStream, Long.valueOf(length));
1:3896fdd:             }
1:3896fdd:             if(length > Integer.MAX_VALUE)
1:1d87ff4:                 throw new SqlException(agent_.logWriter_,
1:e65b4db:                     new ClientMessageId(SQLState.BLOB_TOO_LARGE_FOR_CLIENT),
1:66527ec:                     length, Integer.MAX_VALUE).getSQLException();
1:3896fdd:             else {
1:3896fdd:                 try {
1:a2006ae:                     checkTypeForSetBlob(parameterIndex);
1:3896fdd:                     setBinaryStreamX(parameterIndex, inputStream, (int)length);
1:3896fdd:                 } catch(SqlException se){
1:3896fdd:                     throw se.getSQLException();
1:3896fdd:                 }
1:3896fdd:             }
1:3896fdd:         }
1:3896fdd:     }    
1:3896fdd:  
1:5ef7a0d:     public void setNString(int index, String value) throws SQLException {
1:5ef7a0d:         throw SQLExceptionFactory.notImplemented("setNString(int, String)");
1:5ef7a0d:     }
1:5ef7a0d: 
1:5ef7a0d:     public void setNCharacterStream(int parameterIndex, Reader value)
1:5ef7a0d:             throws SQLException {
1:5ef7a0d:         throw SQLExceptionFactory.notImplemented(
1:5ef7a0d:                 "setNCharacterStream(int, Reader)");
1:5ef7a0d:     }
1:5ef7a0d: 
1:5ef7a0d:     public void setNCharacterStream(int index, Reader value, long length)
1:5ef7a0d:             throws SQLException {
1:5ef7a0d:         throw SQLExceptionFactory.notImplemented(
1:5ef7a0d:                 "setNCharacterStream(int, Reader, long)");
1:5ef7a0d:     }
1:5ef7a0d: 
1:5ef7a0d:     public void setNClob(int parameterIndex, Reader reader)
1:5ef7a0d:             throws SQLException {
1:5ef7a0d:         throw SQLExceptionFactory.notImplemented("setNClob(int, Reader)");
1:5ef7a0d:     }
1:5ef7a0d: 
1:5ef7a0d:     public void setNClob(int parameterIndex, Reader reader, long length)
1:5ef7a0d:             throws SQLException {
1:5ef7a0d:         throw SQLExceptionFactory.notImplemented("setNClob(int, Reader, long)");
1:5ef7a0d:     }
1:5ef7a0d: 
1:9a0cdf1:     public void setRowId(int parameterIndex, RowId x) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setRowId (int, RowId)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setNClob(int index, NClob value) throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setNClob (int, NClob)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:9a0cdf1:     public void setSQLXML(int parameterIndex, SQLXML xmlObject)
1:9a0cdf1:             throws SQLException {
1:9a0cdf1:         throw SQLExceptionFactory.notImplemented("setSQLXML (int, SQLXML)");
1:9a0cdf1:     }
1:9a0cdf1: 
1:5ef7a0d:     // End of JDBC 4.0 methods
1:5ef7a0d: 
1:20b2fd9:     // Beginning of JDBC 4.2 methods
1:20b2fd9: 
1:20b2fd9:     public long executeLargeUpdate() throws SQLException {
1:20b2fd9:         try
1:20b2fd9:         {
1:20b2fd9:             synchronized (connection_) {
1:20b2fd9:                 if (agent_.loggingEnabled()) {
1:20b2fd9:                     agent_.logWriter_.traceEntry(this, "executeLargeUpdate");
1:20b2fd9:                 }
1:20b2fd9:                 long updateValue = executeUpdateX();
1:20b2fd9:                 if (agent_.loggingEnabled()) {
1:20b2fd9:                     agent_.logWriter_.traceExit(this, "executeLargeUpdate", updateValue);
1:20b2fd9:                 }
1:20b2fd9:                 return updateValue;
1:20b2fd9:             }
1:20b2fd9:         }
1:20b2fd9:         catch ( SqlException se ) {
1:20b2fd9:             checkStatementValidity(se);
1:20b2fd9:             throw se.getSQLException();
1:20b2fd9:         }
1:3896fdd:     }
1:20b2fd9: 
1:20b2fd9:     // End of JDBC 4.2 methods
1:20b2fd9: 
1:407e52d:         /*
1:407e52d:          * Method calls onStatementError occurred on the 
1:407e52d:          * BrokeredConnectionControl class after checking the 
1:407e52d:          * SQLState of the SQLException thrown.
1:407e52d:          * @param sqle SqlException
1:407e52d:          * @throws java.sql.SQLException
1:407e52d:          */
1:407e52d:         
1:407e52d:         private void checkStatementValidity(SqlException sqle)  
1:407e52d:                                             throws SQLException {
1:407e52d:             //check if the statement is already closed 
1:407e52d:             //This might be caused because the connection associated
1:407e52d:             //with this prepared statement has been closed marking 
1:407e52d:             //its associated prepared statements also as
1:407e52d:             //closed
1:407e52d:             
1:407e52d:             if(pooledConnection_!=null && isClosed()){
1:407e52d:                 pooledConnection_.onStatementErrorOccurred(this,
1:407e52d:                     sqle.getSQLException());
1:407e52d:             }
1:407e52d:         }
1:407e52d:     
1:486f51a:     /**
1:486f51a:      * PossibleTypes is information which is set of types.
1:486f51a:      * A given type is evaluated as *possible* at checkType method if same type was found in the set.
1:486f51a:      */
1:486f51a:     private static class PossibleTypes{
1:486f51a:         
1:486f51a:         final private int[] possibleTypes;
1:486f51a:         
1:486f51a:         private PossibleTypes(int[] types){
1:486f51a:             possibleTypes = types;
1:486f51a:             Arrays.sort(possibleTypes);
1:486f51a:         }
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by set method for generic scalar.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.BIGINT,
1:69e3d06:                 Types.LONGVARCHAR ,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.DECIMAL,
1:69e3d06:                 Types.INTEGER,
1:69e3d06:                 Types.SMALLINT,
1:69e3d06:                 Types.REAL,
1:69e3d06:                 Types.DOUBLE,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.BOOLEAN } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setDate method.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_DATE = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.DATE,
1:69e3d06:                 Types.TIMESTAMP } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setTime method.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_TIME = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.TIME } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setTimestamp method.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_TIMESTAMP = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.DATE,
1:69e3d06:                 Types.TIME,
1:69e3d06:                 Types.TIMESTAMP } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setString method.
1:486f51a:          */
1:486f51a:         final private static PossibleTypes POSSIBLE_TYPES_IN_SET_STRING = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.BIGINT,
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.DECIMAL,
1:69e3d06:                 Types.INTEGER,
1:69e3d06:                 Types.SMALLINT,
1:69e3d06:                 Types.REAL,
1:69e3d06:                 Types.DOUBLE,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.BOOLEAN,
1:69e3d06:                 Types.DATE,
1:69e3d06:                 Types.TIME,
1:69e3d06:                 Types.TIMESTAMP,
1:69e3d06:                 Types.CLOB } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setBytes method.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_BYTES = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.LONGVARBINARY,
1:69e3d06:                 Types.VARBINARY,
1:69e3d06:                 Types.BINARY,
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.BLOB } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setBinaryStream method.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_BINARYSTREAM = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.LONGVARBINARY,
1:69e3d06:                 Types.VARBINARY,
1:69e3d06:                 Types.BINARY,
1:69e3d06:                 Types.BLOB } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setAsciiStream method.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_ASCIISTREAM = 
1:486f51a:             new PossibleTypes( new int[]{ 
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.CLOB } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setCharacterStream method.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_CHARACTERSTREAM = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.CLOB } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setBlob method.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_BLOB = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.BLOB } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of variable which can be set by setClob method.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_CLOB = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.CLOB } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to generic scalar typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.BIT,
1:69e3d06:                 Types.TINYINT,
1:69e3d06:                 Types.BIGINT,
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.NUMERIC,
1:69e3d06:                 Types.DECIMAL,
1:69e3d06:                 Types.INTEGER,
1:69e3d06:                 Types.SMALLINT,
1:69e3d06:                 Types.FLOAT,
1:69e3d06:                 Types.REAL,
1:69e3d06:                 Types.DOUBLE,
1:69e3d06:                 Types.VARCHAR } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to generic character typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_GENERIC_CHARACTERS_NULL = 
1:486f51a:             new PossibleTypes( new int[] {
1:69e3d06:                 Types.BIT,
1:69e3d06:                 Types.TINYINT,
1:69e3d06:                 Types.BIGINT,
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.NUMERIC,
1:69e3d06:                 Types.DECIMAL,
1:69e3d06:                 Types.INTEGER,
1:69e3d06:                 Types.SMALLINT,
1:69e3d06:                 Types.FLOAT,
1:69e3d06:                 Types.REAL,
1:69e3d06:                 Types.DOUBLE,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.DATE,
1:69e3d06:                 Types.TIME,
1:69e3d06:                 Types.TIMESTAMP } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to VARBINARY typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_VARBINARY_NULL = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.VARBINARY,
1:69e3d06:                 Types.BINARY,
1:69e3d06:                 Types.LONGVARBINARY } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to BINARY typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_BINARY_NULL = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.VARBINARY,
1:69e3d06:                 Types.BINARY,
1:69e3d06:                 Types.LONGVARBINARY } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to LONGVARBINARY typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_LONGVARBINARY_NULL = 
1:486f51a:             new PossibleTypes( new int[] {
1:69e3d06:                 Types.VARBINARY,
1:69e3d06:                 Types.BINARY,
1:69e3d06:                 Types.LONGVARBINARY } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to DATE typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_DATE_NULL = 
1:486f51a:             new PossibleTypes( new int[] {
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.DATE,
1:69e3d06:                 Types.TIMESTAMP } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to TIME typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_TIME_NULL = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.TIME,
1:69e3d06:                 Types.TIMESTAMP } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to TIMESTAMP typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_TIMESTAMP_NULL = 
1:486f51a:             new PossibleTypes( new int[] {
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.DATE,
1:69e3d06:                 Types.TIMESTAMP } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to CLOB typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_CLOB_NULL = 
1:486f51a:             new PossibleTypes( new int[] { 
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.CLOB } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to BLOB typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes POSSIBLE_TYPES_FOR_BLOB_NULL = 
1:486f51a:             new PossibleTypes( new int[] {
1:69e3d06:                 Types.BLOB } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This is possibleTypes of null value which can be assigned to other typed variable.
1:486f51a:          */
1:486f51a:         final public static PossibleTypes DEFAULT_POSSIBLE_TYPES_FOR_NULL = 
1:486f51a:             new PossibleTypes( new int[] {
1:69e3d06:                 Types.BIT,
1:69e3d06:                 Types.TINYINT,
1:69e3d06:                 Types.BIGINT,
1:69e3d06:                 Types.LONGVARBINARY,
1:69e3d06:                 Types.VARBINARY,
1:69e3d06:                 Types.BINARY,
1:69e3d06:                 Types.LONGVARCHAR,
1:69e3d06:                 Types.NULL,
1:69e3d06:                 Types.CHAR,
1:69e3d06:                 Types.NUMERIC,
1:69e3d06:                 Types.DECIMAL,
1:69e3d06:                 Types.INTEGER,
1:69e3d06:                 Types.SMALLINT,
1:69e3d06:                 Types.FLOAT,
1:69e3d06:                 Types.REAL,
1:69e3d06:                 Types.DOUBLE,
1:69e3d06:                 Types.VARCHAR,
1:69e3d06:                 Types.BOOLEAN,
1:69e3d06:                 Types.DATALINK,
1:69e3d06:                 Types.DATE,
1:69e3d06:                 Types.TIME,
1:69e3d06:                 Types.TIMESTAMP,
1:69e3d06:                 Types.OTHER,
1:69e3d06:                 Types.JAVA_OBJECT,
1:69e3d06:                 Types.DISTINCT,
1:69e3d06:                 Types.STRUCT,
1:69e3d06:                 Types.ARRAY,
1:69e3d06:                 Types.BLOB,
1:69e3d06:                 Types.CLOB,
1:69e3d06:                 Types.REF } );
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This method return true if the type is possible.
1:486f51a:          */
1:486f51a:         boolean checkType(int type){
1:486f51a:             
1:486f51a:             if(SanityManager.DEBUG){
1:486f51a:                 
1:486f51a:                 for(int i = 0;
1:486f51a:                     i < possibleTypes.length - 1;
1:486f51a:                     i ++){
1:486f51a:                     
1:486f51a:                     SanityManager.ASSERT(possibleTypes[i] < possibleTypes[i + 1]);
1:486f51a:                     
1:486f51a:                 }
1:486f51a:             }
1:486f51a:             
1:486f51a:             return Arrays.binarySearch( possibleTypes,
1:486f51a:                                         type ) >= 0;
1:486f51a:             
1:486f51a:         }
1:486f51a:         
1:486f51a:         static SqlException throw22005Exception( LogWriter logWriter, 
2:486f51a:                                                  int valType,
2:486f51a:                                                  int paramType)
1:486f51a:             
1:486f51a:             throws SqlException{
1:486f51a:             
2:486f51a:             throw new SqlException( logWriter,
1:486f51a:                                     new ClientMessageId(SQLState.LANG_DATA_TYPE_GET_MISMATCH) ,
2:486f51a:                                     new Object[]{ 
1:69e3d06:                                         ClientTypes.getTypeString(valType),
1:69e3d06:                                         ClientTypes.getTypeString(paramType)
2:486f51a:                                     },
2:486f51a:                                     (Throwable) null);
1:486f51a:         }
1:486f51a:         
1:486f51a:         
1:486f51a:         /**
1:486f51a:          * This method return possibleTypes of null value in variable typed as typeOfVariable.
1:486f51a:          */
1:486f51a:         static PossibleTypes getPossibleTypesForNull(int typeOfVariable){
1:486f51a:             
1:486f51a:             switch(typeOfVariable){
1:486f51a:                 
1:69e3d06:             case Types.SMALLINT:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:486f51a:                 
1:69e3d06:             case Types.INTEGER:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:486f51a:                 
1:69e3d06:             case Types.BIGINT:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:486f51a:                 
1:69e3d06:             case Types.REAL:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:486f51a:                 
1:69e3d06:             case Types.FLOAT:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:486f51a:                 
1:69e3d06:             case Types.DOUBLE:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:486f51a:                 
1:69e3d06:             case Types.DECIMAL:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:486f51a:                 
1:69e3d06:             case Types.CHAR:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_CHARACTERS_NULL;
1:486f51a:                 
1:69e3d06:             case Types.VARCHAR:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_CHARACTERS_NULL;
1:486f51a:                 
1:69e3d06:             case Types.LONGVARCHAR:
1:486f51a:                 return POSSIBLE_TYPES_FOR_GENERIC_CHARACTERS_NULL;
1:486f51a:                 
1:69e3d06:             case Types.VARBINARY:
1:486f51a:                 return POSSIBLE_TYPES_FOR_VARBINARY_NULL;
1:486f51a:                 
1:69e3d06:             case Types.BINARY:
1:486f51a:                 return POSSIBLE_TYPES_FOR_BINARY_NULL;
1:486f51a:                 
1:69e3d06:             case Types.LONGVARBINARY:
1:486f51a:                 return POSSIBLE_TYPES_FOR_LONGVARBINARY_NULL;
1:486f51a:                 
1:69e3d06:             case Types.DATE:
1:486f51a:                 return POSSIBLE_TYPES_FOR_DATE_NULL;
1:486f51a:                 
1:69e3d06:             case Types.TIME:
1:486f51a:                 return POSSIBLE_TYPES_FOR_TIME_NULL;
1:486f51a:                 
1:69e3d06:             case Types.TIMESTAMP:
1:486f51a:                 return POSSIBLE_TYPES_FOR_TIMESTAMP_NULL;
1:486f51a:                 
1:69e3d06:             case Types.CLOB:
1:486f51a:                 return POSSIBLE_TYPES_FOR_CLOB_NULL;
1:486f51a:                 
1:69e3d06:             case Types.BLOB:
1:486f51a:                 return POSSIBLE_TYPES_FOR_BLOB_NULL;
1:486f51a:                 
1:486f51a:             }
1:486f51a:         
1:486f51a:             // as default, accept all type...
1:486f51a:             return DEFAULT_POSSIBLE_TYPES_FOR_NULL;
1:486f51a:         }
1:486f51a:         
1:486f51a:     }
1:486f51a:     
4:3896fdd:     /**
1:01c7f83:      * <p>
1:01c7f83:      * Check for closed statement and extract the SQLException if it is raised.
1:01c7f83:      * </p>
1:01c7f83:      */
1:01c7f83:     protected void    checkStatus() throws SQLException
1:01c7f83:     {
1:01c7f83:         try {
1:01c7f83:             checkForClosedStatement();
1:01c7f83:         }
1:01c7f83:         catch (SqlException se) { throw se.getSQLException(); }
1:01c7f83:     }
1:01c7f83: 
1:486f51a: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1: import java.math.RoundingMode;
/////////////////////////////////////////////////////////////////////////
1:                 x = ((BigDecimal) x).setScale(scale, RoundingMode.DOWN);
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:                 Double d = x;
1:                 setInput(parameterIndex, d);
/////////////////////////////////////////////////////////////////////////
1:                 new Object[] { 65534 }, updateCounts, null );
commit:01c7f83
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * <p>
1:      * Check for closed statement and extract the SQLException if it is raised.
1:      * </p>
1:      */
1:     protected void    checkStatus() throws SQLException
1:     {
1:         try {
1:             checkForClosedStatement();
1:         }
1:         catch (SqlException se) { throw se.getSQLException(); }
1:     }
1: 
commit:9f0c37a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 agent_.checkForSupportedDataType(jdbcType);
/////////////////////////////////////////////////////////////////////////
1:         agent_.checkForSupportedDataType(targetJdbcType);
/////////////////////////////////////////////////////////////////////////
commit:7cfb7e6
/////////////////////////////////////////////////////////////////////////
0:         case JDBC40Translation.REF_CURSOR:
commit:b54918e
/////////////////////////////////////////////////////////////////////////
1:     public int[] executeBatch() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:         throws SqlException, SQLException {
/////////////////////////////////////////////////////////////////////////
0:             throws SqlException, java.sql.BatchUpdateException {
/////////////////////////////////////////////////////////////////////////
1:             throw ClientDriver.getFactory().newBatchUpdateException(agent_.logWriter_, 
0:                 new Object[] { new Integer( 65534 ) }, updateCounts, null );
/////////////////////////////////////////////////////////////////////////
1:             throw ClientDriver.getFactory().newBatchUpdateException(agent_.logWriter_, 
1:             new ClientMessageId(SQLState.CANNOT_BATCH_QUERIES), (Object [])null, updateCounts, null);
1:             throw ClientDriver.getFactory().newBatchUpdateException(agent_.logWriter_, 
1:                 (Object [])null, updateCounts, null);
/////////////////////////////////////////////////////////////////////////
1:                 throw ClientDriver.getFactory().newBatchUpdateException(agent_.logWriter_, 
1:                     (Object [])null, updateCounts, null );
commit:20b2fd9
/////////////////////////////////////////////////////////////////////////
1:     // Beginning of JDBC 4.2 methods
1: 
1:     public long executeLargeUpdate() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "executeLargeUpdate");
1:                 }
1:                 long updateValue = executeUpdateX();
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "executeLargeUpdate", updateValue);
1:                 }
1:                 return updateValue;
1:             }
1:         }
1:         catch ( SqlException se ) {
1:             checkStatementValidity(se);
1:             throw se.getSQLException();
1:         }
1:     }
1: 
1:     // End of JDBC 4.2 methods
1: 
commit:f26c60c
/////////////////////////////////////////////////////////////////////////
1:                 int updateValue = (int) executeUpdateX();
/////////////////////////////////////////////////////////////////////////
1:     private long executeUpdateX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                 long[] updateCounts = null;
1:                 return Utils.squashLongs( updateCounts );
/////////////////////////////////////////////////////////////////////////
0:     public long[] executeBatchX(boolean supportsQueryBatchRequest) 
/////////////////////////////////////////////////////////////////////////
1:     private long[] executeBatchRequestX(boolean supportsQueryBatchRequest)
1:         long[] updateCounts = new long[batchSize];
/////////////////////////////////////////////////////////////////////////
0:             throw BatchUpdateException.newBatchUpdateException(agent_.logWriter_, 
/////////////////////////////////////////////////////////////////////////
0:             throw BatchUpdateException.newBatchUpdateException(agent_.logWriter_, 
0:             throw BatchUpdateException.newBatchUpdateException(agent_.logWriter_, 
/////////////////////////////////////////////////////////////////////////
0:                 throw BatchUpdateException.newBatchUpdateException(agent_.logWriter_, 
commit:ff02576
/////////////////////////////////////////////////////////////////////////
0:                     setBigDecimal(parameterIndex, new java.math.BigDecimal( (java.math.BigInteger) x ) );
commit:59f54f8
/////////////////////////////////////////////////////////////////////////
0:                 } else if (x instanceof java.math.BigInteger) {
0:                     setLong(parameterIndex, ((java.math.BigInteger) x).longValue() );
1:                 } else if (x instanceof java.util.Date) {
0:                     setTimestamp(parameterIndex, new Timestamp(  ((java.util.Date) x).getTime() ) );
0:                 } else if (x instanceof java.util.Calendar) {
0:                     setTimestamp(parameterIndex, new Timestamp(  ((java.util.Calendar) x).getTime().getTime() ) );
commit:6e97c84
/////////////////////////////////////////////////////////////////////////
1:     public void addBatch(String sql) throws SQLException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "addBatch", sql);
1:         }
1:         throw new SqlException(agent_.logWriter_,
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "addBatch(String)").getSQLException();
1:     }
1: 
commit:e39aac2
/////////////////////////////////////////////////////////////////////////
0:                 java.sql.Types.BOOLEAN,
commit:9a62527
/////////////////////////////////////////////////////////////////////////
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.BOOLEAN } );
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1: 
1:                 int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
1: 
0:                 if ( paramType == java.sql.Types.JAVA_OBJECT )
1:                 {
1:                     setUDTX( parameterIndex, x );
1:                 }
0:                 else if (x instanceof String) {
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set a UDT parameter to an object value.
1:      */
1:     private void setUDTX(int parameterIndex, Object x) throws SqlException, SQLException
1:     {
1:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
0:         int expectedType = java.sql.Types.JAVA_OBJECT;
1:         
1:         if ( !( paramType == expectedType ) )
1:         {
1:             PossibleTypes.throw22005Exception
1:                 (agent_.logWriter_, expectedType, paramType );
1:         }
1:         
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = expectedType;
1:         if (x == null) {
1:             setNullX(parameterIndex, expectedType );
1:             return;
1:         }
1: 
1:         //
1:         // Make sure that we are setting the parameter to an instance of the UDT.
1:         //
1:         
1:         Throwable problem = null;
1:         String sourceClassName = x.getClass().getName();
1:         String targetClassName = getColumnMetaDataX().getColumnClassName(parameterIndex);
1: 
1:         try {
1:             Class targetClass = Class.forName( targetClassName );
1:             if ( targetClass.isInstance( x ) )
1:             {
1:                 setInput(parameterIndex, x);
1:                 return;
1:             }
1:         }
1:         catch (ClassNotFoundException e) { problem = e; }
1: 
1:         throw new SqlException
1:             (
1:              agent_.logWriter_,
1:              new ClientMessageId( SQLState.NET_UDT_COERCION_ERROR ),
1:              new Object[] { sourceClassName, targetClassName },
1:              problem
1:              );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:956354d
/////////////////////////////////////////////////////////////////////////
0:         Blob blob;
1:         if (length == -1) {
1:             // Create a blob of unknown length. This might cause an
1:             // OutOfMemoryError due to the temporary implementation in Blob.
1:             // The whole stream will be materialzied. See comments in Blob.
0:             blob = new Blob(agent_, x);
1:         } else {
0:             blob = new Blob(agent_, x, length);
1:         }
1:         setInput(parameterIndex, blob);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets the designated parameter to the given <code>Reader</code> object.
1:      * When a very large UNICODE value is input to a LONGVARCHAR parameter, it
1:      * may be more practical to send it via a <code>java.io.Reader</code>
1:      * object. The data will be read from the stream as needed until
1:      * end-of-file is reached. The JDBC driver will do any necessary conversion
1:      * from UNICODE to the database char format.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the <code>java.io.Reader</code> object that contains the
1:      *      Unicode data
1:      * @throws SQLException if a database access error occurs or this method is
1:      *      called on a closed <code>PreparedStatement</code>
1:      */
1:     public void setCharacterStream(int parameterIndex, Reader x)
1:             throws SQLException {
1:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setCharacterStream",
1:                         parameterIndex, x);
1:             }
1:             try {
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
1:                 parameterMetaData_.clientParamtertype_[parameterIndex -1] =
0:                     java.sql.Types.CLOB;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.CLOB);
1:                     return;
1:                 }
0:                 setInput(parameterIndex, new Clob(agent_, x));
1:             } catch (SqlException se) {
1:                 throw se.getSQLException();
1:             }
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Sets the designated parameter to the given input stream.
1:      * When a very large ASCII value is input to a <code>LONGVARCHAR</code>
1:      * parameter, it may be more practical to send it via a
1:      * <code>java.io.InputStream</code>. Data will be read from the stream as
1:      * needed until end-of-file is reached. The JDBC driver will do any
1:      * necessary conversion from ASCII to the database char format.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the Java input stream that contains the ASCII parameter value
1:      * @throws SQLException if a database access error occurs or this method is
1:      *      called on a closed <code>PreparedStatement</code>
1:      */
1:     public void setAsciiStream(int parameterIndex, InputStream x)
1:             throws SQLException {
1:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setAsciiStream",
1:                         parameterIndex, x);
1:             }
1:             try {
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.CLOB;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.CLOB);
1:                     return;
1:                 }
0:                 setInput(parameterIndex, new Clob(agent_, x, "US-ASCII"));
1:             } catch (SqlException se) {
1:                 throw se.getSQLException();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to the given input stream.
1:      * When a very large binary value is input to a <code>LONGVARBINARY</code>
1:      * parameter, it may be more practical to send it via a
1:      * <code>java.io.InputStream</code> object. The data will be read from the
1:      * stream as needed until end-of-file is reached.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the binary parameter value
1:      * @throws SQLException if a database access error occurs or this method is
1:      *      called on a closed <code>PreparedStatement</code>
1:      */
1:     public void setBinaryStream(int parameterIndex, InputStream x)
1:             throws SQLException {
1:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setBinaryStream",
1:                         parameterIndex, x);
1:             }
1:             try {
1:                 setBinaryStreamX(parameterIndex, x, -1);
1:             } catch (SqlException se) {
1:                 throw se.getSQLException();
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to a <code>Reader</code> object.
1:      *
1:      * @param parameterIndex index of the first parameter is 1, the second is 
1:      *      2, ...
1:      * @param reader an object that contains the data to set the parameter
1:      *      value to. 
1:      * @throws SQLException if parameterIndex does not correspond to a 
1:      *      parameter marker in the SQL statement; if a database access error
1:      *      occurs; this method is called on a closed PreparedStatementor if
1:      *      parameterIndex does not correspond to a parameter marker in the SQL
1:      *      statement
1:      */
1:     public void setClob(int parameterIndex, Reader reader)
1:             throws SQLException {
1:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setClob",
1:                         parameterIndex, reader);
1:             }
1:             try {
1:                 checkForClosedStatement();
1:             } catch (SqlException se) {
1:                 throw se.getSQLException();
1:             }
0:             setInput(parameterIndex, new Clob(agent_, reader));
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Sets the designated parameter to a <code>InputStream</code> object.
1:      * This method differs from the <code>setBinaryStream(int, InputStream)
1:      * </code>  method because it informs the driver that the parameter value
1:      * should be sent to the server as a <code>BLOB</code>. When the
1:      * <code>setBinaryStream</code> method is used, the driver may have to do
1:      * extra work to determine whether the parameter data should be sent to the
1:      * server as a <code>LONGVARBINARY</code> or a <code>BLOB</code>
1:      *
1:      * @param parameterIndex index of the first parameter is 1, the second is
1:      *      2, ...
1:      * @param inputStream an object that contains the data to set the parameter
1:      *      value to.
1:      * @throws SQLException if a database access error occurs, this method is
1:      *      called on a closed <code>PreparedStatement</code> or if
1:      *      <code>parameterIndex</code> does not correspond to a parameter
1:      *      marker in the SQL statement
1:      */
1:     public void setBlob(int parameterIndex, InputStream inputStream)
1:             throws SQLException {
1:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setBlob", parameterIndex,
1:                         inputStream);
1:             }
1:             try {
1:                 setBinaryStreamX(parameterIndex, inputStream, -1);
1:             } catch (SqlException se) {
1:                 throw se.getSQLException();
1:             }
1:         }
1:     }
1: 
1:     /**
commit:2e7a2af
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.jdbc.ClientDriver;
/////////////////////////////////////////////////////////////////////////
0:         ParameterMetaData pm = ClientDriver.getFactory().newParameterMetaData
0:                 (parameterMetaData_ != null
0:                 : ClientDriver.getFactory().newColumnMetaData(agent_.logWriter_, 0));
commit:cbd0ff1
/////////////////////////////////////////////////////////////////////////
0:     protected void setBinaryStreamX(int parameterIndex,
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:aa302c3
/////////////////////////////////////////////////////////////////////////
1:                 boolean chainOpenQueryForAutoGeneratedKeys = 
1:                 		((sqlUpdateMode_ == isInsertSql__ || sqlUpdateMode_ == isUpdateSql__) 
1:                 				&& autoGeneratedKeys_ == RETURN_GENERATED_KEYS);
/////////////////////////////////////////////////////////////////////////
1:             		if ((sqlUpdateMode_ == isInsertSql__ || sqlUpdateMode_ == isUpdateSql__) 
1:             				&& autoGeneratedKeys_ == RETURN_GENERATED_KEYS) {
commit:0ea561a
/////////////////////////////////////////////////////////////////////////
0:         // JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF,
0:         // ROWID, SQLXML or STRUCT data type and the JDBC driver does
0:         // not support this data type
/////////////////////////////////////////////////////////////////////////
0:         case JDBC40Translation.NCHAR:
0:         case JDBC40Translation.NCLOB:
0:         case JDBC40Translation.NVARCHAR:
commit:111785f
/////////////////////////////////////////////////////////////////////////
0:         // JAVA_OBJECT, LONGNVARCHAR, REF, ROWID, SQLXML or 
0:     	// STRUCT data type and the JDBC driver does not
0:         // support this data type
/////////////////////////////////////////////////////////////////////////
commit:7bee3c6
/////////////////////////////////////////////////////////////////////////
1:         if (parameterMetaData_ == null) 
1: 			throw new SqlException(agent_.logWriter_,
1: 					new ClientMessageId(SQLState.NO_INPUT_PARAMETERS));
1: 
1:         if (parameterIndex < 1 || parameterIndex > parameterMetaData_.columns_) {
0:                 new Integer(parameterMetaData_.columns_));
commit:53d6497
/////////////////////////////////////////////////////////////////////////
0:         	int totalParameters = 0;
0:             if (parameterMetaData_ != null)
0:             	//Load totalParmeters with correct number of parameters if 
0:             	//ParameterMetaData_ is not null. We will need that in the error
0:             	//message.
0:             	totalParameters = parameterMetaData_.columns_;
0:                 new Integer(totalParameters));
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:74fb1b0
/////////////////////////////////////////////////////////////////////////
1:         setSection(section);
/////////////////////////////////////////////////////////////////////////
1:             setSection(agent_.sectionManager_.getPositionedUpdateSection(cursorName, false)); // false means get a regular section
1:             if (getSection() == null) {
/////////////////////////////////////////////////////////////////////////
1:             if (getSection().getClientCursorName() != null && // cursor name is user defined
1:                     cursorName.compareTo(getSection().getClientCursorName()) == 0)
1:                 sql_ = substituteClientCursorNameWithServerCursorName(sql_, getSection());
1:             setSection(agent_.sectionManager_.getDynamicSection(resultSetHoldability_));
/////////////////////////////////////////////////////////////////////////
1:         writePrepareDescribeOutput(sql_, getSection());
1:         writeDescribeInput(getSection());
/////////////////////////////////////////////////////////////////////////
1:         writePrepare(sql_, getSection());
1:         writeDescribeInput(getSection());
/////////////////////////////////////////////////////////////////////////
1:             boolean prepareSentForAutoGeneratedKeys = false;
/////////////////////////////////////////////////////////////////////////
1:                 writeExecute(getSection(),
/////////////////////////////////////////////////////////////////////////
1:                     if (preparedStatementForAutoGeneratedKeys_ == null) {
1:                         preparedStatementForAutoGeneratedKeys_ =
1:                                 prepareAutoGeneratedKeysStatement(connection_);
1:                         prepareSentForAutoGeneratedKeys = true;
1:                     }
1:                   
1:                     writeOpenQuery(preparedStatementForAutoGeneratedKeys_.getSection(),
/////////////////////////////////////////////////////////////////////////
1:                 writeOpenQuery(getSection(),
/////////////////////////////////////////////////////////////////////////
1:                         null, getSection(),
/////////////////////////////////////////////////////////////////////////
1:                         if (prepareSentForAutoGeneratedKeys) {
1:                             preparedStatementForAutoGeneratedKeys_.materialPreparedStatement_.readPrepareDescribeOutput_();
1:                         }
1:           
/////////////////////////////////////////////////////////////////////////
1:                 writeExecute(getSection(),
/////////////////////////////////////////////////////////////////////////
1:                         null, getSection(),
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     @Override
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a0b8943
/////////////////////////////////////////////////////////////////////////
1:                     new ClientClob(agent_, x, Cursor.ISO_8859_1, (int) length));
/////////////////////////////////////////////////////////////////////////
1:                          new ClientClob(agent_, x, Cursor.ISO_8859_1));
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
1: import java.sql.NClob;
1: import java.sql.RowId;
1: import java.sql.SQLXML;
/////////////////////////////////////////////////////////////////////////
1:     public void setRowId(int parameterIndex, RowId x) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setRowId (int, RowId)");
1:     }
1: 
1:     public void setNClob(int index, NClob value) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNClob (int, NClob)");
1:     }
1: 
1:     public void setSQLXML(int parameterIndex, SQLXML xmlObject)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setSQLXML (int, SQLXML)");
1:     }
1: 
commit:b98b60e
/////////////////////////////////////////////////////////////////////////
1:                 // Raise an exception if at least one of the parameters isn't
1:                 // set. It is OK that a parameter isn't set if it is registered
1:                 // as an output parameter. However, if it's an INOUT parameter,
1:                 // it must be set even if it has been registered (DERBY-2516).
1:                 if (!parameterSet_[i] &&
1:                         (!parameterRegistered_[i] ||
1:                          parameterMetaData_.sqlxParmmode_[i] ==
0:                             java.sql.ParameterMetaData.parameterModeInOut)) {
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                 parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                 setInput(parameterIndex, Short.valueOf(x));
/////////////////////////////////////////////////////////////////////////
1:         setInput(parameterIndex, x);
/////////////////////////////////////////////////////////////////////////
1:         setInput(parameterIndex, x);
/////////////////////////////////////////////////////////////////////////
1:         setInput(parameterIndex, x);
/////////////////////////////////////////////////////////////////////////
1:                 setInput(parameterIndex, x);
/////////////////////////////////////////////////////////////////////////
1:                     agent_.logWriter_.traceEntry(this, "setBinaryStream",
1:                         parameterIndex, "<input stream>", Long.valueOf(length));
/////////////////////////////////////////////////////////////////////////
1:                         parameterIndex, "<input stream>", Long.valueOf(length));
/////////////////////////////////////////////////////////////////////////
1:                         length,
1:                         Integer.MAX_VALUE
/////////////////////////////////////////////////////////////////////////
1:                     agent_.logWriter_.traceEntry(this, "setCharacterStream",
1:                             parameterIndex, x, Long.valueOf(length));
/////////////////////////////////////////////////////////////////////////
1:                         resultSetHoldability_);
/////////////////////////////////////////////////////////////////////////
0:                 65534, updateCounts);
/////////////////////////////////////////////////////////////////////////
1:                 parameterIndex, parameterMetaData_.columns_);
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.BAD_SCALE_VALUE), scale);
/////////////////////////////////////////////////////////////////////////
1:                         parameterIndex, reader, Long.valueOf(length));
/////////////////////////////////////////////////////////////////////////
1:                     length, Integer.MAX_VALUE).getSQLException();
/////////////////////////////////////////////////////////////////////////
1:                         inputStream, Long.valueOf(length));
1:                     length, Integer.MAX_VALUE).getSQLException();
commit:5ef7a0d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.JDBC40Translation;
1: import org.apache.derby.shared.common.reference.SQLState;
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     // JDBC 4.0 methods
/////////////////////////////////////////////////////////////////////////
1:     public void setNString(int index, String value) throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNString(int, String)");
1:     }
1: 
1:     public void setNCharacterStream(int parameterIndex, Reader value)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented(
1:                 "setNCharacterStream(int, Reader)");
1:     }
1: 
1:     public void setNCharacterStream(int index, Reader value, long length)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented(
1:                 "setNCharacterStream(int, Reader, long)");
1:     }
1: 
1:     public void setNClob(int parameterIndex, Reader reader)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNClob(int, Reader)");
1:     }
1: 
1:     public void setNClob(int parameterIndex, Reader reader, long length)
1:             throws SQLException {
1:         throw SQLExceptionFactory.notImplemented("setNClob(int, Reader, long)");
1:     }
1: 
1:     // End of JDBC 4.0 methods
1: 
commit:4772c7e
/////////////////////////////////////////////////////////////////////////
1:     private ArrayList<int[]> parameterTypeList;
/////////////////////////////////////////////////////////////////////////
1:                     parameterTypeList = new ArrayList<int[]>();
/////////////////////////////////////////////////////////////////////////
1:                 parameterMetaData_.clientParamtertype_ = parameterTypeList.get(i);
commit:74f0097
/////////////////////////////////////////////////////////////////////////
1:                 setInput(parameterIndex, Boolean.valueOf(x));
commit:2349a90
/////////////////////////////////////////////////////////////////////////
0:                                        ColumnMetaData resultSetMetaData) {
commit:4458855
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
commit:c1d0340
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.util.Calendar;
/////////////////////////////////////////////////////////////////////////
1:     public void setDate(int parameterIndex, Date x, Calendar calendar)
1:             throws SQLException {
1:                     agent_.logWriter_.traceEntry(
1:                             this, "setDate", parameterIndex, x, calendar);
/////////////////////////////////////////////////////////////////////////
1: 
1:                 if (calendar == null) {
1:                     throw new SqlException(agent_.logWriter_,
1:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
1:                         "null", "calendar", "setDate()");
1:                 }
1: 
1:                 setInput(parameterIndex, new DateTimeValue(x, calendar));
/////////////////////////////////////////////////////////////////////////
1:     public void setDate(int parameterIndex, Date x) throws SQLException {
1:         setDate(parameterIndex, x, Calendar.getInstance());
1:     public void setTime(int parameterIndex, Time x, Calendar calendar)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1: 
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.TIME;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.TIME);
1:                     return;
1:                 }
1:                 setInput(parameterIndex, new DateTimeValue(x, calendar));
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void setTime(int parameterIndex, Time x) throws SQLException {
1:         setTime(parameterIndex, x, Calendar.getInstance());
1:     }
1: 
1:     public void setTimestamp(int parameterIndex, Timestamp x, Calendar calendar)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 if (calendar == null) {
1:                     throw new SqlException(agent_.logWriter_,
1:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
1:                         "null", "calendar", "setTimestamp()");
1:                 }
1: 
1:                 setInput(parameterIndex, new DateTimeValue(x, calendar));
/////////////////////////////////////////////////////////////////////////
1:     public void setTimestamp(int parameterIndex, Timestamp x)
1:             throws SQLException {
1:         setTimestamp(parameterIndex, x, Calendar.getInstance());
commit:e24d8ef
/////////////////////////////////////////////////////////////////////////
1:      * @deprecated
commit:960054b
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:         int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:a2006ae
/////////////////////////////////////////////////////////////////////////
1: 
1:                 checkForClosedStatement();
1: 
1:                 // JDBC 4.0 requires us to throw
1:                 // SQLFeatureNotSupportedException for certain target types if
1:                 // they are not supported. Check for these types before
1:                 // checking type compatibility.
0:                 checkForSupportedDataType(jdbcType);
/////////////////////////////////////////////////////////////////////////
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setNull", parameterIndex,
1:                                              jdbcType, typeName);
1:             setNull(parameterIndex, jdbcType);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetBinaryStream(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetAsciiStream(parameterIndex);
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:     private void checkTypeForSetAsciiStream(int parameterIndex)
1:             throws SqlException, SQLException {
0:         int paramType = getColumnMetaDataX().getColumnType(
0:             checkForEscapedCallWithResult(parameterIndex));
1:             PossibleTypes.throw22005Exception(agent_.logWriter_,
/////////////////////////////////////////////////////////////////////////
1:     private void checkTypeForSetBinaryStream(int parameterIndex)
1:             throws SqlException, SQLException {
0:         int paramType = getColumnMetaDataX().getColumnType(
0:             checkForEscapedCallWithResult(parameterIndex));
1:         if (!PossibleTypes.POSSIBLE_TYPES_IN_SET_BINARYSTREAM.
1:                 checkType(paramType)) {
1:             PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                               java.sql.Types.VARBINARY,
1:                                               paramType);
1:         }
1:     }
1:     private void checkTypeForSetCharacterStream(int parameterIndex)
1:             throws SqlException, SQLException {
0:         int paramType = getColumnMetaDataX().getColumnType(
0:             checkForEscapedCallWithResult(parameterIndex));
1:         if (!PossibleTypes.POSSIBLE_TYPES_IN_SET_CHARACTERSTREAM.
1:                 checkType(paramType)) {
1:             PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                               java.sql.Types.LONGVARCHAR,
1:                                               paramType);
1:         }
1:     }
1: 
1:     private void checkTypeForSetBlob(int parameterIndex)
1:             throws SqlException, SQLException {
0:         int paramType = getColumnMetaDataX().getColumnType(
0:             checkForEscapedCallWithResult(parameterIndex));
1:             PossibleTypes.throw22005Exception(agent_.logWriter_,
1:     private void checkTypeForSetClob(int parameterIndex)
1:             throws SqlException, SQLException {
0:         int paramType = getColumnMetaDataX().getColumnType(
0:             checkForEscapedCallWithResult(parameterIndex));
1:             PossibleTypes.throw22005Exception(agent_.logWriter_,
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetCharacterStream(parameterIndex);
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetCharacterStream(parameterIndex);
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetBlob(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetClob(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     checkForClosedStatement();
1:                     checkForValidParameterIndex(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                 checkForClosedStatement();
/////////////////////////////////////////////////////////////////////////
1:                 checkForClosedStatement();
/////////////////////////////////////////////////////////////////////////
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
1:         // JDBC 4.0 requires us to throw SQLFeatureNotSupportedException for
1:         // certain target types if they are not supported.
0:         checkForSupportedDataType(targetJdbcType);
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private ColumnMetaData getColumnMetaDataX() throws SqlException {
1:         checkForClosedStatement();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetAsciiStream(parameterIndex);
0:                 parameterIndex = checkForEscapedCallWithResult(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetBinaryStream(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetClob(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                 checkTypeForSetBlob(parameterIndex);
/////////////////////////////////////////////////////////////////////////
1:                     checkTypeForSetBlob(parameterIndex);
commit:cb82751
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets the specified parameter to the given input stream. Deprecated
1:      * in JDBC 3.0 and this method will always just throw a feature not
1:      * implemented exception.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the UNICODE parameter
1:      * value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException throws feature not implemented.
1:      */
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceDeprecatedEntry(this, "setUnicodeStream",
1:                                                    parameterIndex,
1:                                                    "<input stream>", length);
1: 
1:         throw SQLExceptionFactory.notImplemented ("setUnicodeStream");
commit:dbbf9ff
/////////////////////////////////////////////////////////////////////////
0:         checkForSupportedDataType(jdbcType);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         checkForSupportedDataType(targetJdbcType);
1: 
commit:054fa3a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0:         checkForSupportedDataType(targetJdbcType);
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Checks whether a data type is supported for
0:      * <code>setObject(int, Object, int)</code> and
0:      * <code>setObject(int, Object, int, int)</code>.
1:      *
0:      * @param dataType the data type to check
0:      * @exception SqlException if the type is not supported
1:      */
0:     private void checkForSupportedDataType(int dataType) throws SqlException {
1: 
0:         // JDBC 4.0 javadoc for setObject() says:
0:         //
0:         // Throws: (...) SQLFeatureNotSupportedException - if
0:         // targetSqlType is a ARRAY, BLOB, CLOB, DATALINK,
0:         // JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF,
0:         // ROWID, SQLXML or STRUCT data type and the JDBC driver does
0:         // not support this data type
0:         //
0:         // Of these types, we only support BLOB, CLOB and
0:         // (sort of) JAVA_OBJECT.
1: 
0:         switch (dataType) {
0:         case java.sql.Types.ARRAY:
0:         case java.sql.Types.DATALINK:
0:         case JDBC40Translation.NCHAR:
0:         case JDBC40Translation.NCLOB:
0:         case JDBC40Translation.NVARCHAR:
0:         case JDBC40Translation.LONGNVARCHAR:
0:         case java.sql.Types.REF:
0:         case JDBC40Translation.ROWID:
0:         case JDBC40Translation.SQLXML:
0:         case java.sql.Types.STRUCT:
0:             throw new SqlException
0:                 (agent_.logWriter_,
0:                  new ClientMessageId(SQLState.DATA_TYPE_NOT_SUPPORTED),
0:                  Types.getTypeString(dataType));
1:         }
1:     }
1: 
commit:d8383bd
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // also used by SQLCA
1:     boolean executeX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                 checkForStoredProcResultSetCount(executeType);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Returns the name of the java.sql interface implemented by this class.
1:      * @return name of java.sql interface
1:      */
1:     protected String getJdbcStatementInterfaceName() {
1:         return "java.sql.PreparedStatement";
1:     }
1: 
commit:c511410
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * sets the parameter to the  Binary Stream object
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the binary parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      */
1: 
1:                                 long length) throws SQLException {
0:                     agent_.logWriter_.traceEntry(this, "setBinaryStream", parameterIndex, "<input stream>", new Long(length));
1:                  if(length > Integer.MAX_VALUE) {
1:                     throw new SqlException(agent_.logWriter_,
0:                         new ClientMessageId(SQLState.CLIENT_LENGTH_OUTSIDE_RANGE_FOR_DATATYPE),
0:                         new Long(length), new Integer(Integer.MAX_VALUE)).getSQLException();
1:                 }
1:                 setBinaryStreamX(parameterIndex, x, (int)length);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * sets the parameter to the  Binary Stream object
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the binary parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      */
1: 
1:     public void setBinaryStream(int parameterIndex,
0:                                 java.io.InputStream x,
1:                                 int length) throws SQLException {
1:         setBinaryStream(parameterIndex,x,(long)length);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * We do this inefficiently and read it all in here. The target type
1:      * is assumed to be a String.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the ASCII parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      */
1: 
1:                                long length) throws SQLException {
0:                     agent_.logWriter_.traceEntry(this, "setAsciiStream", parameterIndex, "<input stream>", new Long(length));
/////////////////////////////////////////////////////////////////////////
0:                 if(length > Integer.MAX_VALUE) {
1:                     throw new SqlException(agent_.logWriter_,
0:                         new ClientMessageId(SQLState.CLIENT_LENGTH_OUTSIDE_RANGE_FOR_DATATYPE),
0:                         new Long(length), new Integer(Integer.MAX_VALUE)).getSQLException();
1:                 }
0:                 setInput(parameterIndex, new Clob(agent_, x, "US-ASCII", (int)length));
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * We do this inefficiently and read it all in here. The target type
1:      * is assumed to be a String.
1:      *
1:      * @param parameterIndex the first parameter is 1, the second is 2, ...
1:      * @param x the java input stream which contains the ASCII parameter value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      */
1:     public void setAsciiStream(int parameterIndex,
0:                                java.io.InputStream x,
1:                                int length) throws SQLException {
1:         setAsciiStream(parameterIndex,x,(long)length);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:      /**
1:      * Sets the designated parameter to the given Reader, which will have
1:      * the specified number of bytes.
1:      *
1:      * @param parameterIndex the index of the parameter to which this set
1:      *                       method is applied
1:      * @param x the java Reader which contains the UNICODE value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      *
1:      */
1: 
1:                                    long length) throws SQLException {
0:                     agent_.logWriter_.traceEntry(this, "setCharacterStream", parameterIndex, x, new Long(length));
/////////////////////////////////////////////////////////////////////////
0:                 if(length > Integer.MAX_VALUE) {
1:                     throw new SqlException(agent_.logWriter_,
0:                         new ClientMessageId(SQLState.CLIENT_LENGTH_OUTSIDE_RANGE_FOR_DATATYPE),
0:                         new Long(length), new Integer(Integer.MAX_VALUE)).getSQLException();
1:                 }
0:                 setInput(parameterIndex, new Clob(agent_, x, (int)length));
/////////////////////////////////////////////////////////////////////////
1:      /**
1:      * Sets the designated parameter to the given Reader, which will have
1:      * the specified number of bytes.
1:      *
1:      * @param parameterIndex the index of the parameter to which this
1:      *                       set method is applied
1:      * @param x the java Reader which contains the UNICODE value
1:      * @param length the number of bytes in the stream
1:      * @exception SQLException thrown on failure.
1:      *
1:      */
1: 
1:     public void setCharacterStream(int parameterIndex,
0:                                    java.io.Reader x,
1:                                    int length) throws SQLException {
1:         setCharacterStream(parameterIndex,x,(long)length);
1:     }
1: 
commit:73d678d
/////////////////////////////////////////////////////////////////////////
0:     private int executeUpdateX() throws SqlException {
0:         checkExecuteUpdatePostConditions("java.sql.PreparedStatement");
/////////////////////////////////////////////////////////////////////////
1:             // The JDBC spec says that executeUpdate() should return 0
1:             // when no row count is returned.
1:             if (executeType == executeUpdateMethod__ && updateCount_ < 0) {
1:                 updateCount_ = 0;
1:             }
1: 
commit:d51b773
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-1036: Moved check till execute time to comply with embedded
1:         // behavior. Since we check here and not in setCursorName, several
1:         // statements can have the same cursor name as long as their result
1:         // sets are not simultaneously open.
1: 
1:         if (sqlMode_ == isQuery__) {
1:             checkForDuplicateCursorName();
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:                     // DERBY-1183: If we set it up earlier, the entry in
1:                     // clientCursorNameCache_ gets wiped out by the closing of
1:                     // result sets happening during readCloseResultSets above
1:                     // because ResultSet#markClosed calls
1:                     // Statement#removeClientCursorNameFromCache.
1:                     setupCursorNameCacheAndMappings();
commit:320777f
/////////////////////////////////////////////////////////////////////////
1:                 checkForClosedStatement();
/////////////////////////////////////////////////////////////////////////
1:                 checkForClosedStatement();
/////////////////////////////////////////////////////////////////////////
1:                 checkForClosedStatement();
/////////////////////////////////////////////////////////////////////////
1:                 checkForClosedStatement();
/////////////////////////////////////////////////////////////////////////
1:             try {
1:                 checkForClosedStatement();
1:             } catch (SqlException se) {
1:                 throw se.getSQLException();
1:             }
commit:407e52d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.ClientPooledConnection;
/////////////////////////////////////////////////////////////////////////
1:     
1:     // the ClientPooledConnection object used to notify of the events that occur
1:     // on this prepared statement object
0:     protected final ClientPooledConnection pooledConnection_;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      *
1:      * The PreparedStatement constructor used for JDBC 2 positioned update
1:      * statements. Called by material statement constructors.
1:      * It has the ClientPooledConnection as one of its parameters 
1:      * this is used to raise the Statement Events when the prepared
1:      * statement is closed
1:      *
1:      * @param agent The instance of NetAgent associated with this
1:      *              CallableStatement object.
1:      * @param connection The connection object associated with this
1:      *                   PreparedStatement Object.
1:      * @param sql        A String object that is the SQL statement to be sent
1:      *                   to the database.
1:      * @param section    Section
1:      * @param cpc The ClientPooledConnection wraps the underlying physical
1:      *            connection associated with this prepared statement.
1:      *            It is used to pass the Statement closed and the Statement
1:      *            error occurred events that occur back to the
1:      *            ClientPooledConnection.
1:      * @throws SqlException
1:      *
1:      */
1: 
1:                              Section section,ClientPooledConnection cpc)
1:                              throws SqlException {
1:         pooledConnection_ = cpc;
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The PreparedStatementConstructor used for jdbc 2 prepared statements 
1:      * with scroll attributes. Called by material statement constructors.
1:      * It has the ClientPooledConnection as one of its parameters 
1:      * this is used to raise the Statement Events when the prepared
1:      * statement is closed
1:      *
1:      * @param agent The instance of NetAgent associated with this
1:      *              CallableStatement object.
1:      * @param connection  The connection object associated with this
1:      *                    PreparedStatement Object.
1:      * @param sql         A String object that is the SQL statement
1:      *                    to be sent to the database.
1:      * @param type        One of the ResultSet type constants.
1:      * @param concurrency One of the ResultSet concurrency constants.
1:      * @param holdability One of the ResultSet holdability constants.
1:      * @param autoGeneratedKeys a flag indicating whether auto-generated
1:      *                          keys should be returned.
1:      * @param columnNames an array of column names indicating the columns that
1:      *                    should be returned from the inserted row or rows.
1:      * @param cpc The ClientPooledConnection wraps the underlying physical
1:      *            connection associated with this prepared statement
1:      *            it is used to pass the Statement closed and the Statement
1:      *            error occurred events that occur back to the
1:      *            ClientPooledConnection.
1:      * @throws SqlException
1:      */
1:                              int autoGeneratedKeys, String[] columnNames,
1:                              ClientPooledConnection cpc) 
1:                              throws SqlException {
1:         pooledConnection_ = cpc;
1: 
/////////////////////////////////////////////////////////////////////////
1:         catch ( SqlException se ) {
1:             checkStatementValidity(se);
/////////////////////////////////////////////////////////////////////////
1:         catch ( SqlException se ) {
1:             checkStatementValidity(se);
/////////////////////////////////////////////////////////////////////////
1:         catch ( SqlException se ) {
1:             checkStatementValidity(se);
/////////////////////////////////////////////////////////////////////////
1:         if(pooledConnection_ != null)
1:             pooledConnection_.onStatementClose(this);
/////////////////////////////////////////////////////////////////////////
1:  
1:         /*
1:          * Method calls onStatementError occurred on the 
1:          * BrokeredConnectionControl class after checking the 
1:          * SQLState of the SQLException thrown.
1:          * @param sqle SqlException
1:          * @throws java.sql.SQLException
1:          */
1:         
1:         private void checkStatementValidity(SqlException sqle)  
1:                                             throws SQLException {
1:             //check if the statement is already closed 
1:             //This might be caused because the connection associated
1:             //with this prepared statement has been closed marking 
1:             //its associated prepared statements also as
1:             //closed
1:             
1:             if(pooledConnection_!=null && isClosed()){
1:                 pooledConnection_.onStatementErrorOccurred(this,
1:                     sqle.getSQLException());
1:             }
1:         }
1: 
commit:7eed914
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // PreparedStatement is poolable by default
1:         isPoolable = true;
/////////////////////////////////////////////////////////////////////////
1:                              int type, int concurrency, int holdability, 
0:                              int autoGeneratedKeys, String[] columnNames) 
1:         throws SqlException {
1:         super(agent, connection, type, concurrency, holdability, 
0:               autoGeneratedKeys, columnNames);
1:         // PreparedStatement is poolable by default
1:         isPoolable = true;
/////////////////////////////////////////////////////////////////////////
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     private void setBinaryStreamX(int parameterIndex,
/////////////////////////////////////////////////////////////////////////
1:     private void readPrepareDescribeInput() throws SqlException {
commit:9f1ddc5
/////////////////////////////////////////////////////////////////////////
1:             resetResultSetList();
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     String sql_;
1:     boolean outputRegistered_ = false;
1:     Object[] parameters_;
1:     private boolean[] parameterSet_;
/////////////////////////////////////////////////////////////////////////
1:     ColumnMetaData parameterMetaData_; // type information for input sqlda
/////////////////////////////////////////////////////////////////////////
1:     private String positionedUpdateCursorName_ = null;
1:     private final ClientPooledConnection pooledConnection_;
/////////////////////////////////////////////////////////////////////////
1:     private void resetPreparedStatement(Agent agent,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // also used by CallableLocatorProcedures
1:     void setBytesX(int parameterIndex, byte[] x) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private void setBlobX(int parameterIndex, Blob x) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private void setClobX(int parameterIndex, Clob x) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1: 
1:         throw new SqlException(agent_.logWriter_,
1:                 new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED)).
1:                 getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     private void writeExecute(Section section,
/////////////////////////////////////////////////////////////////////////
1:     private void readExecute() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private void writeDescribeInput(Section section) throws SqlException {
1:     private void readDescribeInput() throws SqlException {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private void writePrepareDescribeInputOutput() throws SqlException {
1:     private void readPrepareDescribeInputOutput() throws SqlException {
1:     private void writePrepareDescribeInput() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     private void completePrepareDescribe() {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private long[] executeBatchX(boolean supportsQueryBatchRequest)
/////////////////////////////////////////////////////////////////////////
1:     private boolean listenToUnitOfWork_ = false;
/////////////////////////////////////////////////////////////////////////
commit:475fc20
/////////////////////////////////////////////////////////////////////////
1:      * @see ClientStatement#resetForReuse
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
1: import java.math.BigInteger;
1: import java.net.URL;
1: import java.sql.Array;
1: import java.sql.BatchUpdateException;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.ParameterMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.Ref;
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.Types;
1: import java.util.Iterator;
1: public class ClientPreparedStatement extends ClientStatement
1:     implements PreparedStatement, PreparedStatementCallbackInterface {
1: 
/////////////////////////////////////////////////////////////////////////
1:     public ClientPreparedStatement(Agent agent,
1:                              ClientConnection connection,
/////////////////////////////////////////////////////////////////////////
1:                                        ClientConnection connection,
/////////////////////////////////////////////////////////////////////////
1:     public ClientPreparedStatement(Agent agent,
1:                              ClientConnection connection,
/////////////////////////////////////////////////////////////////////////
1:                                        ClientConnection connection,
/////////////////////////////////////////////////////////////////////////
0:                                        ClientConnection connection,
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet executeQuery(String sql) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public ResultSet executeQuery() throws SQLException {
1:                 ClientResultSet resultSet = executeQueryX();
/////////////////////////////////////////////////////////////////////////
1:     ClientResultSet executeQueryX() throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.BOOLEAN,
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.BIT;
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.TINYINT,
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.TINYINT;
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.SMALLINT,
/////////////////////////////////////////////////////////////////////////
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:             Types.SMALLINT;
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.INTEGER,
/////////////////////////////////////////////////////////////////////////
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:             Types.INTEGER;
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.INTEGER,
/////////////////////////////////////////////////////////////////////////
1:                 = Types.BIGINT;
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.FLOAT,
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.REAL;
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.DOUBLE,
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.DOUBLE;
/////////////////////////////////////////////////////////////////////////
1:     public void setBigDecimal(int parameterIndex, BigDecimal x)
1:             throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.BIGINT,
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.DECIMAL;
1: 
1:                     setNull(parameterIndex, Types.DECIMAL);
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.DATE,
/////////////////////////////////////////////////////////////////////////
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.DATE;
1: 
1:                     setNull(parameterIndex, Types.DATE);
/////////////////////////////////////////////////////////////////////////
1:                                                        Types.TIME,
/////////////////////////////////////////////////////////////////////////
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.TIME;
1: 
1:                     setNull(parameterIndex, Types.TIME);
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.TIMESTAMP,
/////////////////////////////////////////////////////////////////////////
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.TIMESTAMP;
1:                     setNull(parameterIndex, Types.TIMESTAMP);
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.VARCHAR,
/////////////////////////////////////////////////////////////////////////
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:             Types.LONGVARCHAR;
1: 
1:             setNullX(parameterIndex, Types.LONGVARCHAR);
/////////////////////////////////////////////////////////////////////////
1:                                                       Types.VARBINARY,
/////////////////////////////////////////////////////////////////////////
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:             Types.LONGVARBINARY;
1: 
1:             setNullX(parameterIndex, Types.LONGVARBINARY);
/////////////////////////////////////////////////////////////////////////
1:                                 InputStream x,
/////////////////////////////////////////////////////////////////////////
1:                                 InputStream x,
1:                                  InputStream x,
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = Types.BLOB;
1:             setNullX(parameterIndex, Types.BLOB);
1:         ClientBlob blob;
1:             blob = new ClientBlob(agent_, x);
1:             blob = new ClientBlob(agent_, x, length);
/////////////////////////////////////////////////////////////////////////
1:                                InputStream x,
/////////////////////////////////////////////////////////////////////////
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.CLOB;
1: 
1:                     setNull(parameterIndex, Types.LONGVARCHAR);
1:                 setInput(parameterIndex,
0:                          new ClientClob(agent_, x, "ISO-8859-1", (int)length));
/////////////////////////////////////////////////////////////////////////
1:                                InputStream x,
/////////////////////////////////////////////////////////////////////////
1:                                               Types.LONGVARCHAR,
/////////////////////////////////////////////////////////////////////////
1:                                               Types.VARBINARY,
/////////////////////////////////////////////////////////////////////////
1:                                               Types.LONGVARCHAR,
/////////////////////////////////////////////////////////////////////////
1:                                               Types.BLOB,
/////////////////////////////////////////////////////////////////////////
1:                                               Types.CLOB,
/////////////////////////////////////////////////////////////////////////
1:                                  InputStream x,
/////////////////////////////////////////////////////////////////////////
1:                     Types.CLOB;
1:                     setNull(parameterIndex, Types.LONGVARCHAR);
1:                 setInput(parameterIndex, new ClientClob(agent_, x));
/////////////////////////////////////////////////////////////////////////
1:                                    Reader x,
/////////////////////////////////////////////////////////////////////////
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.CLOB;
1: 
1:                     setNull(parameterIndex, Types.LONGVARCHAR);
1:                 setInput(parameterIndex,
1:                          new ClientClob(agent_, x, (int)length));
/////////////////////////////////////////////////////////////////////////
1:                                    Reader x,
1:     public void setBlob(int parameterIndex, Blob x) throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     public void setBlobX(int parameterIndex, Blob x) throws SqlException {
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = Types.BLOB;
1:             setNullX(parameterIndex, Types.BLOB);
1:     public void setClob(int parameterIndex, Clob x) throws SQLException {
/////////////////////////////////////////////////////////////////////////
0:     void setClobX(int parameterIndex, Clob x) throws SqlException {
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = Types.CLOB;
1:             this.setNullX(parameterIndex, ClientTypes.CLOB);
1:     public void setArray(int parameterIndex, Array x) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void setRef(int parameterIndex, Ref x) throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 if ( paramType == Types.JAVA_OBJECT )
/////////////////////////////////////////////////////////////////////////
1:                 } else if (x instanceof BigDecimal) {
1:                     setBigDecimal(parameterIndex, (BigDecimal) x);
1:                 } else if (x instanceof Date) {
1:                     setDate(parameterIndex, (Date) x);
1:                 } else if (x instanceof Time) {
1:                     setTime(parameterIndex, (Time) x);
1:                 } else if (x instanceof Timestamp) {
1:                     setTimestamp(parameterIndex, (Timestamp) x);
1:                 } else if (x instanceof Blob) {
1:                     setBlob(parameterIndex, (Blob) x);
1:                 } else if (x instanceof Clob) {
1:                     setClob(parameterIndex, (Clob) x);
1:                 } else if (x instanceof Array) {
1:                     setArray(parameterIndex, (Array) x);
1:                 } else if (x instanceof Ref) {
1:                     setRef(parameterIndex, (Ref) x);
1:                 } else if (x instanceof BigInteger) {
1:                     setBigDecimal(parameterIndex,
1:                                   new BigDecimal((BigInteger)x));
1:                     setTimestamp(parameterIndex,
1:                                  new Timestamp(((java.util.Date)x).getTime()));
1:                 } else if (x instanceof Calendar) {
1:                     setTimestamp(
1:                         parameterIndex,
1:                         new Timestamp(((Calendar)x).getTime().getTime()));
/////////////////////////////////////////////////////////////////////////
1:         int expectedType = Types.JAVA_OBJECT;
/////////////////////////////////////////////////////////////////////////
1:             if (targetJdbcType == Types.DECIMAL ||
1:                 targetJdbcType == Types.NUMERIC) {
0:                 x = ((BigDecimal) x).setScale(scale, BigDecimal.ROUND_DOWN);
/////////////////////////////////////////////////////////////////////////
1:     public ResultSetMetaData getMetaData() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void setURL(int parameterIndex, URL x) throws SQLException {
1:     public ParameterMetaData getParameterMetaData() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:                 return (ParameterMetaData) parameterMetaData;
/////////////////////////////////////////////////////////////////////////
1:     private ClientParameterMetaData getParameterMetaDataX()
1:             throws SqlException {
1:         ClientParameterMetaData pm =
1:             ClientDriver.getFactory().
1:             newParameterMetaData(getColumnMetaDataX());
/////////////////////////////////////////////////////////////////////////
1:             ClientResultSet scrollableRS = null;
/////////////////////////////////////////////////////////////////////////
1:             throws SqlException, BatchUpdateException {
/////////////////////////////////////////////////////////////////////////
1:             resultSetList_ = new ClientResultSet[batchSize];
/////////////////////////////////////////////////////////////////////////
1:     public void completeLocalCommit(Iterator listenerIterator) {
/////////////////////////////////////////////////////////////////////////
1:     public void completeLocalRollback(Iterator listenerIterator) {
/////////////////////////////////////////////////////////////////////////
1:                             ClientParameterMetaData.parameterModeInOut)) {
/////////////////////////////////////////////////////////////////////////
0:         BigDecimal decimalInput = (BigDecimal) parameters_[parameterIndex - 1];
/////////////////////////////////////////////////////////////////////////
1:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] =
1:                     Types.CLOB;
1: 
1:                     setNull(parameterIndex, Types.LONGVARCHAR);
1:                 setInput(parameterIndex,
0:                          new ClientClob(agent_, x, "ISO-8859-1"));
/////////////////////////////////////////////////////////////////////////
1:             setInput(parameterIndex, new ClientClob(agent_, reader));
/////////////////////////////////////////////////////////////////////////
1:                 setInput(parameterIndex,
1:                          new ClientClob(agent_, reader, (int)length));
/////////////////////////////////////////////////////////////////////////
1:                 Types.BIGINT,
1:                 Types.LONGVARCHAR ,
1:                 Types.CHAR,
1:                 Types.DECIMAL,
1:                 Types.INTEGER,
1:                 Types.SMALLINT,
1:                 Types.REAL,
1:                 Types.DOUBLE,
1:                 Types.VARCHAR,
1:                 Types.BOOLEAN } );
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.DATE,
1:                 Types.TIMESTAMP } );
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.TIME } );
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.DATE,
1:                 Types.TIME,
1:                 Types.TIMESTAMP } );
1:                 Types.BIGINT,
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.DECIMAL,
1:                 Types.INTEGER,
1:                 Types.SMALLINT,
1:                 Types.REAL,
1:                 Types.DOUBLE,
1:                 Types.VARCHAR,
1:                 Types.BOOLEAN,
1:                 Types.DATE,
1:                 Types.TIME,
1:                 Types.TIMESTAMP,
1:                 Types.CLOB } );
1:                 Types.LONGVARBINARY,
1:                 Types.VARBINARY,
1:                 Types.BINARY,
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.BLOB } );
1:                 Types.LONGVARBINARY,
1:                 Types.VARBINARY,
1:                 Types.BINARY,
1:                 Types.BLOB } );
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.CLOB } );
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.CLOB } );
1:                 Types.BLOB } );
1:                 Types.CLOB } );
1:                 Types.BIT,
1:                 Types.TINYINT,
1:                 Types.BIGINT,
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.NUMERIC,
1:                 Types.DECIMAL,
1:                 Types.INTEGER,
1:                 Types.SMALLINT,
1:                 Types.FLOAT,
1:                 Types.REAL,
1:                 Types.DOUBLE,
1:                 Types.VARCHAR } );
1:                 Types.BIT,
1:                 Types.TINYINT,
1:                 Types.BIGINT,
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.NUMERIC,
1:                 Types.DECIMAL,
1:                 Types.INTEGER,
1:                 Types.SMALLINT,
1:                 Types.FLOAT,
1:                 Types.REAL,
1:                 Types.DOUBLE,
1:                 Types.VARCHAR,
1:                 Types.DATE,
1:                 Types.TIME,
1:                 Types.TIMESTAMP } );
1:                 Types.VARBINARY,
1:                 Types.BINARY,
1:                 Types.LONGVARBINARY } );
1:                 Types.VARBINARY,
1:                 Types.BINARY,
1:                 Types.LONGVARBINARY } );
1:                 Types.VARBINARY,
1:                 Types.BINARY,
1:                 Types.LONGVARBINARY } );
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.DATE,
1:                 Types.TIMESTAMP } );
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.TIME,
1:                 Types.TIMESTAMP } );
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.DATE,
1:                 Types.TIMESTAMP } );
1:                 Types.LONGVARCHAR,
1:                 Types.CHAR,
1:                 Types.VARCHAR,
1:                 Types.CLOB } );
1:                 Types.BLOB } );
1:                 Types.BIT,
1:                 Types.TINYINT,
1:                 Types.BIGINT,
1:                 Types.LONGVARBINARY,
1:                 Types.VARBINARY,
1:                 Types.BINARY,
1:                 Types.LONGVARCHAR,
1:                 Types.NULL,
1:                 Types.CHAR,
1:                 Types.NUMERIC,
1:                 Types.DECIMAL,
1:                 Types.INTEGER,
1:                 Types.SMALLINT,
1:                 Types.FLOAT,
1:                 Types.REAL,
1:                 Types.DOUBLE,
1:                 Types.VARCHAR,
1:                 Types.BOOLEAN,
1:                 Types.DATALINK,
1:                 Types.DATE,
1:                 Types.TIME,
1:                 Types.TIMESTAMP,
1:                 Types.OTHER,
1:                 Types.JAVA_OBJECT,
1:                 Types.DISTINCT,
1:                 Types.STRUCT,
1:                 Types.ARRAY,
1:                 Types.BLOB,
1:                 Types.CLOB,
1:                 Types.REF } );
/////////////////////////////////////////////////////////////////////////
1:                                         ClientTypes.getTypeString(valType),
1:                                         ClientTypes.getTypeString(paramType)
/////////////////////////////////////////////////////////////////////////
1:             case Types.SMALLINT:
1:             case Types.INTEGER:
1:             case Types.BIGINT:
1:             case Types.REAL:
1:             case Types.FLOAT:
1:             case Types.DOUBLE:
1:             case Types.DECIMAL:
1:             case Types.CHAR:
1:             case Types.VARCHAR:
1:             case Types.LONGVARCHAR:
1:             case Types.VARBINARY:
1:             case Types.BINARY:
1:             case Types.LONGVARBINARY:
1:             case Types.DATE:
1:             case Types.TIME:
1:             case Types.TIMESTAMP:
1:             case Types.CLOB:
1:             case Types.BLOB:
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
1:         // The network client has a hard limit of 65,534 commands in a single
1:         // DRDA request. This is because DRDA uses a 2-byte correlation ID,
1:         // and the values 0 and 0xffff are reserved as special values. So
1:         // that imposes an upper limit on the batch size we can support:
1:         if (batchSize > 65534)
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_,
0:                     new ClientMessageId(SQLState.NO_INPUT_PARAMETERS));
/////////////////////////////////////////////////////////////////////////
1:         super.markClosed(removeListener);
1:         
1:         if (parameterMetaData_ != null) {
/////////////////////////////////////////////////////////////////////////
1:             connection_.CommitAndRollbackListeners_.remove(this);
commit:b52081a
/////////////////////////////////////////////////////////////////////////
1:      * @param columnIndexes an array of column names indicating the columns that
1:      *                   should be returned from the inserted row.                   
/////////////////////////////////////////////////////////////////////////
1:                              int[] columnIndexes,
1:               autoGeneratedKeys, columnNames, columnIndexes);
/////////////////////////////////////////////////////////////////////////
1:                                        int type, int concurrency, int holdability, int autoGeneratedKeys, String[] columnNames,
1:                                        int[] columnIndexes) throws SqlException {
1:         super.resetStatement(agent, connection, type, concurrency, holdability, autoGeneratedKeys, 
1:                 columnNames, columnIndexes);
commit:aadfc18
/////////////////////////////////////////////////////////////////////////
1:         checkAutoGeneratedKeysParameters();
commit:eab1882
/////////////////////////////////////////////////////////////////////////
1:             flowPrepareDescribeInputOutput();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 boolean chainOpenQueryForAutoGeneratedKeys = (sqlUpdateMode_ == isInsertSql__ && autoGeneratedKeys_ == RETURN_GENERATED_KEYS);
0:                 writeExecute(section_,
1:                         parameterMetaData_,
1:                         parameters_,
1:                         numInputColumns,
1:                         outputExpected,
1:                         (chainAutoCommit || chainOpenQueryForAutoGeneratedKeys)// chain flag
1:                 ); // chain flag
1:                 if (chainOpenQueryForAutoGeneratedKeys) {
0:                     prepareAutoGeneratedKeysStatement();
0:                     writeOpenQuery(preparedStatementForAutoGeneratedKeys_.section_,
1:                             preparedStatementForAutoGeneratedKeys_.fetchSize_,
1:                             preparedStatementForAutoGeneratedKeys_.resultSetType_);
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 else {
commit:dd7d579
/////////////////////////////////////////////////////////////////////////
1:             connection_.CommitAndRollbackListeners_.put(this,null);
commit:bd644c6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /* (non-Javadoc)
1:      * @see org.apache.derby.client.am.Statement#markClosed(boolean)
1:      */
1:     protected void markClosed(boolean removeListener){
0:     	super.markClosed(removeListener);
1:     	
1:     	if (parameterMetaData_ != null) {
/////////////////////////////////////////////////////////////////////////
1:         if(removeListener)
0:         	connection_.CommitAndRollbackListeners_.remove(this);
commit:64b55c2
/////////////////////////////////////////////////////////////////////////
0:             connection_.CommitAndRollbackListeners_.add(this);
commit:cff2860
/////////////////////////////////////////////////////////////////////////
0:             connection_.CommitAndRollbackListeners_.put(this,null);
commit:90f1614
/////////////////////////////////////////////////////////////////////////
0:             super.markResultSetsClosed(true); // true means remove from list of commit and rollback listeners
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:a92196c
/////////////////////////////////////////////////////////////////////////
1:                 } else if (x == null) {
1:                     // DERBY-1938: Allow setting Java null also when the
1:                     //      column type isn't specified explicitly by the
1:                     //      user. Maps Java null to SQL NULL.
1:                     setNull(parameterIndex, paramType);
1:                 } else if (x instanceof String) {
commit:5e717f9
/////////////////////////////////////////////////////////////////////////
1:                 checkStreamLength(length);
/////////////////////////////////////////////////////////////////////////
1:                     agent_.logWriter_.traceEntry(this, "setAsciiStream",
0:                             parameterIndex, "<input stream>", new Long(length));
/////////////////////////////////////////////////////////////////////////
1:                 checkStreamLength(length);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check the length passed in for the stream that is to be set. If length is
1:      * larger than Integer.MAX_VALUE or smaller that 0, we fail by throwing an 
1:      * SQLException.
1:      * @param length The length of the stream being set
1:      * @throws SQLException Thrown for a negative or too large length.
1:      */
1:     private void checkStreamLength(long length) throws SQLException {
0:         if(length > Integer.MAX_VALUE) {
1:             throw new SqlException(
1:                         agent_.logWriter_,
1:                         new ClientMessageId(
1:                             SQLState.CLIENT_LENGTH_OUTSIDE_RANGE_FOR_DATATYPE),
0:                         new Long(length),
0:                         new Integer(Integer.MAX_VALUE)
1:                     ).getSQLException();
1:         } else if (length < 0) {
1:             throw new SqlException(
1:                         agent_.logWriter_,
1:                         new ClientMessageId(SQLState.NEGATIVE_STREAM_LENGTH)
1:                     ).getSQLException();
1:         }
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:                 checkStreamLength(length);
commit:76af6ed
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Resets the prepared statement for reuse in a statement pool.
1:      *
1:      * @throws SqlException if the reset fails
0:      * @see Statement#resetForReuse
1:      */
1:     void resetForReuse()
0:             throws SqlException {
1:         resetParameters();
1:         super.resetForReuse();
1:     }
1: 
commit:36adcbf
/////////////////////////////////////////////////////////////////////////
1:         resetParameters();
/////////////////////////////////////////////////////////////////////////
1:         if (parameterMetaData_ != null) {
1:             Arrays.fill(parameters_, null);
1:             Arrays.fill(parameterSet_, false);
1:             Arrays.fill(parameterRegistered_, false);
/////////////////////////////////////////////////////////////////////////
1:                     Arrays.fill(parameters_, null);
1:                     Arrays.fill(parameterSet_, false);
/////////////////////////////////////////////////////////////////////////
1:             // 1 means IN parameter
1:             Arrays.fill(parameterMetaData_.sqlxParmmode_, (short)1);
/////////////////////////////////////////////////////////////////////////
1:             Arrays.fill(parameters_, null);
commit:faf6742
/////////////////////////////////////////////////////////////////////////
0:                 setInput(parameterIndex, new Clob(agent_, x, "ISO-8859-1", (int)length));
/////////////////////////////////////////////////////////////////////////
0:                 setInput(parameterIndex, new Clob(agent_, x, "ISO-8859-1"));
commit:74eba43
/////////////////////////////////////////////////////////////////////////
1:         // Column numbers starts at 1, clientParamtertype_[0] refers to column 1
commit:6de69bd
/////////////////////////////////////////////////////////////////////////
1:                 setLongX(parameterIndex, x);
/////////////////////////////////////////////////////////////////////////
1:     void setLongX(final int parameterIndex, final long x) 
1:     {
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] 
0:                 = java.sql.Types.BIGINT;
0:         setInput(parameterIndex, new Long(x));
1:     }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:d08d1a5
/////////////////////////////////////////////////////////////////////////
1:     private void writeOpenQuery(Section section,
/////////////////////////////////////////////////////////////////////////
1:     private void flowExecute(int executeType) throws SqlException {
0:         checkForClosedStatement();
1:         clearWarningsX();
1:         checkForAppropriateSqlMode(executeType, sqlMode_);
/////////////////////////////////////////////////////////////////////////
1:             boolean piggybackedAutocommit = writeCloseResultSets(true);  // true means permit auto-commits
/////////////////////////////////////////////////////////////////////////
1:             markResultSetsClosed(true); // true means remove from list of commit and rollback listeners
commit:63d4142
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     
0:     private ArrayList parameterTypeList;
/////////////////////////////////////////////////////////////////////////
1:         parameterTypeList = null;
/////////////////////////////////////////////////////////////////////////
1:                 
1:                 if (parameterTypeList == null) {
0:                     parameterTypeList = new ArrayList();
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                     
1:                     // Get a copy of the parameter type data and save it in a list
1:                     // which will be used later on at the time of batch execution.
1:                     parameterTypeList.add(parameterMetaData_.clientParamtertype_.clone());
1:                     parameterTypeList.add(null);
/////////////////////////////////////////////////////////////////////////
0:             parameterMetaData_.clientParamtertype_ = (int[]) parameterTypeList.get(i);
/////////////////////////////////////////////////////////////////////////
1:         parameterTypeList = null;
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:5e3c874
/////////////////////////////////////////////////////////////////////////
1:         checkForValidParameterIndex(parameterIndex);
commit:10e7778
/////////////////////////////////////////////////////////////////////////
0: 		// The network client has a hard limit of 65,534 commands in a single
0: 		// DRDA request. This is because DRDA uses a 2-byte correlation ID,
0: 		// and the values 0 and 0xffff are reserved as special values. So
0: 		// that imposes an upper limit on the batch size we can support:
0: 		if (batchSize > 65534)
0:             throw new BatchUpdateException(agent_.logWriter_, "No more than 65534 commands may be added to a single batch", updateCounts);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2c140d8
/////////////////////////////////////////////////////////////////////////
1:             if (parameterMetaData_ != null) {
0:                 parameterMetaData_.clientParamtertype_ = (int[]) parameterTypeList.get(i);
1:                 parameters_ = (Object[]) batch_.get(i);
1:             }
1:             
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:bc52552
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult(parameterIndex) ) ;
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
1:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = 
0:                     getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) );
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetAsciiStream(getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) ),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetCharacterStream(getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) ),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetCharacterStream(getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) ),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetBlob(getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) ),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetClob(getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) ),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetClob(getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) ),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetBlob(getColumnMetaDataX().getColumnType( checkForEscapedCallWithResult( parameterIndex ) ),
commit:211c985
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex) ;
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 final int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetAsciiStream(getColumnMetaDataX().getColumnType(parameterIndex),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetCharacterStream(getColumnMetaDataX().getColumnType(parameterIndex),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetCharacterStream(getColumnMetaDataX().getColumnType(parameterIndex),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetBlob(getColumnMetaDataX().getColumnType(parameterIndex),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetClob(getColumnMetaDataX().getColumnType(parameterIndex),
/////////////////////////////////////////////////////////////////////////
0:             ( getColumnMetaDataX() );
0:     private ColumnMetaData getColumnMetaDataX() {
1:         return 
1:             parameterMetaData_ != null ?
1:             parameterMetaData_ : 
1:             ClientDriver.getFactory().newColumnMetaData(agent_.logWriter_, 0);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetAsciiStream(getColumnMetaDataX().getColumnType( parameterIndex),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetClob(getColumnMetaDataX().getColumnType(parameterIndex),
/////////////////////////////////////////////////////////////////////////
0:                 checkTypeForSetBlob(getColumnMetaDataX().getColumnType(parameterIndex),
commit:486f51a
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex) ;
1:                 
1:                 if( ! PossibleTypes.getPossibleTypesForNull( paramType ).checkType( jdbcType )){
1:                     
1:                     //This exception mimic embedded behavior.
1:                     //see http://issues.apache.org/jira/browse/DERBY-1610#action_12432568
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
1:                                                       jdbcType,
1:                                                       paramType );
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1: 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ) {
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.BOOLEAN,
1:                                                       paramType);
1:                     
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1:                 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType( paramType ) ){
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.TINYINT,
1:                                                       paramType);
1:                     
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1: 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.SMALLINT,
1:                                                       paramType);
1:                                                   
1: 
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1: 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.INTEGER,
1:                                                       paramType);
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1:                 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.INTEGER,
1:                                                       paramType);
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1: 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.FLOAT,
1:                                                       paramType);
1: 
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1:                 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType(paramType) ){
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.DOUBLE,
1:                                                       paramType);
1:                     
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1: 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR.checkType( paramType ) ){
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.BIGINT,
1:                                                       paramType);
1:                     
1:                 }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1:                 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_DATE.checkType(paramType) ){
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_ ,
0:                                                       java.sql.Types.DATE,
1:                                                       paramType);
1:                     
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1: 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_TIME.checkType( paramType ) ){
1:                     
1:                     PossibleTypes.throw22005Exception( agent_.logWriter_,
0:                                                        java.sql.Types.TIME,
1:                                                        paramType );
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1: 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_TIMESTAMP.checkType( paramType ) ) {
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.TIMESTAMP,
1:                                                       paramType);
1:                     
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1: 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_STRING.checkType( paramType ) ){
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_ ,
0:                                                       java.sql.Types.VARCHAR,
1:                                                       paramType);
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1:                 
1:                 if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_BYTES.checkType( paramType ) ){
1:                     
1:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.VARBINARY,
1:                                                       paramType );
1:                 }
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 final int paramType = getParameterMetaData().getParameterType(parameterIndex);
1: 
0:                 if ( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_BINARYSTREAM.checkType( paramType ) ){
0:                     PossibleTypes.throw22005Exception(agent_.logWriter_,
0:                                                       java.sql.Types.VARBINARY,
0:                                                       paramType );
1:                 }                                         
1:                 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 checkTypeForSetAsciiStream(getParameterMetaData().getParameterType(parameterIndex),
0:                                            agent_.logWriter_);
1: 
0:                     setNull(parameterIndex, java.sql.Types.LONGVARCHAR);
/////////////////////////////////////////////////////////////////////////
1:     
0:     private static void checkTypeForSetAsciiStream( final int paramType,
0:                                                     LogWriter logWriter )
0:         throws SqlException {
1:         
1:         if ( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_ASCIISTREAM.checkType( paramType ) ) {
1:             
0:             PossibleTypes.throw22005Exception(logWriter,
0:                                               java.sql.Types.LONGVARCHAR,
1:                                               paramType);
1:             
1:             
1:         }
1:     }
1:     
1:     
0:     private static void checkTypeForSetBlob(final int paramType,
0:                                             LogWriter logWriter )
0:         throws SqlException {
1:         
1:         if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_BLOB.checkType( paramType ) ){
1:             
0:             PossibleTypes.throw22005Exception(logWriter,
0:                                               java.sql.Types.BLOB,
1:                                               paramType);
1:         }
1:     }
1:     
1:     
0:     private static void checkTypeForSetClob( int paramType,
0:                                              LogWriter logWriter )
0:         throws SqlException {
1:         
1:         if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_CLOB.checkType( paramType ) ){
1:                     
0:             PossibleTypes.throw22005Exception(logWriter,
0:                                               java.sql.Types.CLOB,
1:                                               paramType);
1:                     
1:         }
1:         
1:     }
1:     
1:     
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 checkTypeForSetCharacterStream(getParameterMetaData().getParameterType(parameterIndex),
0:                                                agent_.logWriter_);
1:                 
0:                     setNull(parameterIndex, java.sql.Types.LONGVARCHAR);
/////////////////////////////////////////////////////////////////////////
1: 
0:                 checkTypeForSetCharacterStream(getParameterMetaData().getParameterType(parameterIndex),
0:                                                agent_.logWriter_);
1:                 
0:                     setNull(parameterIndex, java.sql.Types.LONGVARCHAR);
/////////////////////////////////////////////////////////////////////////
1:     
1: 
0:     private static void checkTypeForSetCharacterStream(final int paramType,
0:                                                        LogWriter logWriter)
1:     throws SqlException{
1:         
0:         if( ! PossibleTypes.POSSIBLE_TYPES_IN_SET_CHARACTERSTREAM.checkType( paramType ) ){
1:             
0:             PossibleTypes.throw22005Exception(logWriter,
0:                                               java.sql.Types.LONGVARCHAR,
0:                                               paramType);
1:             
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 checkTypeForSetBlob(getParameterMetaData().getParameterType(parameterIndex),
0:                                     agent_.logWriter_);
1:                     
/////////////////////////////////////////////////////////////////////////
1:                 
0:                 checkTypeForSetClob(getParameterMetaData().getParameterType(parameterIndex),
0:                                     agent_.logWriter_);
1:                 
/////////////////////////////////////////////////////////////////////////
1: 
0:                 checkTypeForSetAsciiStream(getParameterMetaData().getParameterType( parameterIndex),
0:                                            agent_.logWriter_);
1: 
0:                     setNull(parameterIndex, java.sql.Types.LONGVARCHAR);
/////////////////////////////////////////////////////////////////////////
1:             
1:                 
0:                 checkTypeForSetClob(getParameterMetaData().getParameterType(parameterIndex),
0:                                 agent_.logWriter_);
1:                 
/////////////////////////////////////////////////////////////////////////
1: 
0:                 checkTypeForSetBlob(getParameterMetaData().getParameterType(parameterIndex),
0:                                     agent_.logWriter_);
1:                 
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * PossibleTypes is information which is set of types.
1:      * A given type is evaluated as *possible* at checkType method if same type was found in the set.
1:      */
1:     private static class PossibleTypes{
1:         
1:         final private int[] possibleTypes;
1:         
1:         private PossibleTypes(int[] types){
1:             possibleTypes = types;
1:             Arrays.sort(possibleTypes);
1:         }
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by set method for generic scalar.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_GENERIC_SCALAR = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.BIGINT,
0:                 java.sql.Types.LONGVARCHAR ,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.DECIMAL,
0:                 java.sql.Types.INTEGER,
0:                 java.sql.Types.SMALLINT,
0:                 java.sql.Types.REAL,
0:                 java.sql.Types.DOUBLE,
0:                 java.sql.Types.VARCHAR } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setDate method.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_DATE = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.DATE,
0:                 java.sql.Types.TIMESTAMP } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setTime method.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_TIME = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.TIME } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setTimestamp method.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_TIMESTAMP = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.DATE,
0:                 java.sql.Types.TIME,
0:                 java.sql.Types.TIMESTAMP } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setString method.
1:          */
1:         final private static PossibleTypes POSSIBLE_TYPES_IN_SET_STRING = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.BIGINT,
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.DECIMAL,
0:                 java.sql.Types.INTEGER,
0:                 java.sql.Types.SMALLINT,
0:                 java.sql.Types.REAL,
0:                 java.sql.Types.DOUBLE,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.DATE,
0:                 java.sql.Types.TIME,
0:                 java.sql.Types.TIMESTAMP,
0:                 java.sql.Types.CLOB } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setBytes method.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_BYTES = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.LONGVARBINARY,
0:                 java.sql.Types.VARBINARY,
0:                 java.sql.Types.BINARY,
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.BLOB } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setBinaryStream method.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_BINARYSTREAM = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.LONGVARBINARY,
0:                 java.sql.Types.VARBINARY,
0:                 java.sql.Types.BINARY,
0:                 java.sql.Types.BLOB } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setAsciiStream method.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_ASCIISTREAM = 
1:             new PossibleTypes( new int[]{ 
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.CLOB } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setCharacterStream method.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_CHARACTERSTREAM = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.CLOB } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setBlob method.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_BLOB = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.BLOB } );
1:         
1:         /**
1:          * This is possibleTypes of variable which can be set by setClob method.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_IN_SET_CLOB = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.CLOB } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to generic scalar typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.BIT,
0:                 java.sql.Types.TINYINT,
0:                 java.sql.Types.BIGINT,
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.NUMERIC,
0:                 java.sql.Types.DECIMAL,
0:                 java.sql.Types.INTEGER,
0:                 java.sql.Types.SMALLINT,
0:                 java.sql.Types.FLOAT,
0:                 java.sql.Types.REAL,
0:                 java.sql.Types.DOUBLE,
0:                 java.sql.Types.VARCHAR } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to generic character typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_GENERIC_CHARACTERS_NULL = 
1:             new PossibleTypes( new int[] {
0:                 java.sql.Types.BIT,
0:                 java.sql.Types.TINYINT,
0:                 java.sql.Types.BIGINT,
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.NUMERIC,
0:                 java.sql.Types.DECIMAL,
0:                 java.sql.Types.INTEGER,
0:                 java.sql.Types.SMALLINT,
0:                 java.sql.Types.FLOAT,
0:                 java.sql.Types.REAL,
0:                 java.sql.Types.DOUBLE,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.DATE,
0:                 java.sql.Types.TIME,
0:                 java.sql.Types.TIMESTAMP } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to VARBINARY typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_VARBINARY_NULL = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.VARBINARY,
0:                 java.sql.Types.BINARY,
0:                 java.sql.Types.LONGVARBINARY } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to BINARY typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_BINARY_NULL = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.VARBINARY,
0:                 java.sql.Types.BINARY,
0:                 java.sql.Types.LONGVARBINARY } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to LONGVARBINARY typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_LONGVARBINARY_NULL = 
1:             new PossibleTypes( new int[] {
0:                 java.sql.Types.VARBINARY,
0:                 java.sql.Types.BINARY,
0:                 java.sql.Types.LONGVARBINARY } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to DATE typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_DATE_NULL = 
1:             new PossibleTypes( new int[] {
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.DATE,
0:                 java.sql.Types.TIMESTAMP } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to TIME typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_TIME_NULL = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.TIME,
0:                 java.sql.Types.TIMESTAMP } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to TIMESTAMP typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_TIMESTAMP_NULL = 
1:             new PossibleTypes( new int[] {
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.DATE,
0:                 java.sql.Types.TIMESTAMP } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to CLOB typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_CLOB_NULL = 
1:             new PossibleTypes( new int[] { 
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.CLOB } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to BLOB typed variable.
1:          */
1:         final public static PossibleTypes POSSIBLE_TYPES_FOR_BLOB_NULL = 
1:             new PossibleTypes( new int[] {
0:                 java.sql.Types.BLOB } );
1:         
1:         /**
1:          * This is possibleTypes of null value which can be assigned to other typed variable.
1:          */
1:         final public static PossibleTypes DEFAULT_POSSIBLE_TYPES_FOR_NULL = 
1:             new PossibleTypes( new int[] {
0:                 java.sql.Types.BIT,
0:                 java.sql.Types.TINYINT,
0:                 java.sql.Types.BIGINT,
0:                 java.sql.Types.LONGVARBINARY,
0:                 java.sql.Types.VARBINARY,
0:                 java.sql.Types.BINARY,
0:                 java.sql.Types.LONGVARCHAR,
0:                 java.sql.Types.NULL,
0:                 java.sql.Types.CHAR,
0:                 java.sql.Types.NUMERIC,
0:                 java.sql.Types.DECIMAL,
0:                 java.sql.Types.INTEGER,
0:                 java.sql.Types.SMALLINT,
0:                 java.sql.Types.FLOAT,
0:                 java.sql.Types.REAL,
0:                 java.sql.Types.DOUBLE, 
0:                 java.sql.Types.VARCHAR,
0:                 java.sql.Types.BOOLEAN,
0:                 java.sql.Types.DATALINK,
0:                 java.sql.Types.DATE,
0:                 java.sql.Types.TIME,
0:                 java.sql.Types.TIMESTAMP,
0:                 java.sql.Types.OTHER,
0:                 java.sql.Types.JAVA_OBJECT,
0:                 java.sql.Types.DISTINCT,
0:                 java.sql.Types.STRUCT,
0:                 java.sql.Types.ARRAY,
0:                 java.sql.Types.BLOB,
0:                 java.sql.Types.CLOB,
0:                 java.sql.Types.REF } );
1:         
1:         /**
1:          * This method return true if the type is possible.
1:          */
1:         boolean checkType(int type){
1:             
1:             if(SanityManager.DEBUG){
1:                 
1:                 for(int i = 0;
1:                     i < possibleTypes.length - 1;
1:                     i ++){
1:                     
1:                     SanityManager.ASSERT(possibleTypes[i] < possibleTypes[i + 1]);
1:                     
1:                 }
1:             }
1:             
1:             return Arrays.binarySearch( possibleTypes,
1:                                         type ) >= 0;
1:             
1:         }
1:         
1:         /*
0:         static SqlException throwLangDataTypeSetException( LogWriter logWriter, 
1:                                                            int valType,
1:                                                            int paramType)
1:     
0:             throws SqlException{
1:             
1:             throw new SqlException( logWriter,
0:                                     new ClientMessageId(SQLState.LANG_DATA_TYPE_SET_MISMATCH) ,
1:                                     new Object[]{ 
0:                                         Types.getTypeString(valType),
0:                                         Types.getTypeString(paramType) 
1:                                     },
1:                                     (Throwable) null);
1:         }
1:         */
1:         
1:         static SqlException throw22005Exception( LogWriter logWriter, 
1:                                                  int valType,
1:                                                  int paramType)
1:             
0:             throws SqlException{
1:             
1:             throw new SqlException( logWriter,
1:                                     new ClientMessageId(SQLState.LANG_DATA_TYPE_GET_MISMATCH) ,
1:                                     new Object[]{ 
0:                                         Types.getTypeString(valType),
0:                                         Types.getTypeString(paramType) 
1:                                     },
1:                                     (Throwable) null);
1:         }
1:         
1:         
1:         /**
1:          * This method return possibleTypes of null value in variable typed as typeOfVariable.
1:          */
1:         static PossibleTypes getPossibleTypesForNull(int typeOfVariable){
1:             
1:             switch(typeOfVariable){
1:                 
0:             case java.sql.Types.SMALLINT:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:                 
0:             case java.sql.Types.INTEGER:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:                 
0:             case java.sql.Types.BIGINT:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:                 
0:             case java.sql.Types.REAL:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:                 
0:             case java.sql.Types.FLOAT:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:                 
0:             case java.sql.Types.DOUBLE:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:                 
0:             case java.sql.Types.DECIMAL:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_SCALAR_NULL;
1:                 
0:             case java.sql.Types.CHAR:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_CHARACTERS_NULL;
1:                 
0:             case java.sql.Types.VARCHAR:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_CHARACTERS_NULL;
1:                 
0:             case java.sql.Types.LONGVARCHAR:
1:                 return POSSIBLE_TYPES_FOR_GENERIC_CHARACTERS_NULL;
1:                 
0:             case java.sql.Types.VARBINARY:
1:                 return POSSIBLE_TYPES_FOR_VARBINARY_NULL;
1:                 
0:             case java.sql.Types.BINARY:
1:                 return POSSIBLE_TYPES_FOR_BINARY_NULL;
1:                 
0:             case java.sql.Types.LONGVARBINARY:
1:                 return POSSIBLE_TYPES_FOR_LONGVARBINARY_NULL;
1:                 
0:             case java.sql.Types.DATE:
1:                 return POSSIBLE_TYPES_FOR_DATE_NULL;
1:                 
0:             case java.sql.Types.TIME:
1:                 return POSSIBLE_TYPES_FOR_TIME_NULL;
1:                 
0:             case java.sql.Types.TIMESTAMP:
1:                 return POSSIBLE_TYPES_FOR_TIMESTAMP_NULL;
1:                 
0:             case java.sql.Types.CLOB:
1:                 return POSSIBLE_TYPES_FOR_CLOB_NULL;
1:                 
0:             case java.sql.Types.BLOB:
1:                 return POSSIBLE_TYPES_FOR_BLOB_NULL;
1:                 
1:             }
1:         
1:             // as default, accept all type...
1:             return DEFAULT_POSSIBLE_TYPES_FOR_NULL;
1:         }
1:         
1:     }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:b2a1747
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.BATCH_CHAIN_BREAKING_EXCEPTION)));
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.CURSOR_INVALID_CURSOR_NAME), cursorName);
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.LANG_NULL_INTO_NON_NULL),
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.INVALID_API_PARAMETER),
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.JAVA_EXCEPTION),
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
/////////////////////////////////////////////////////////////////////////
1:             new ClientMessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.UNABLE_TO_OPEN_RESULTSET_WITH_REQUESTED_HOLDABILTY),
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.TOO_MANY_COMMANDS_FOR_BATCH), 
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.CANNOT_BATCH_QUERIES), updateCounts);
1:                 new ClientMessageId(SQLState.QUERY_BATCH_ON_NON_QUERY_STATEMENT), 
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.OUTPUT_PARAMS_NOT_ALLOWED),
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.LANG_INVALID_PARAM_POSITION),
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.LANG_MISSING_PARMS));
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.LANG_RETURN_OUTPUT_PARAM_CANNOT_BE_SET));
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.BAD_SCALE_VALUE),
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.REGOUTPARAM_SCALE_DOESNT_MATCH_SETTER));
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.REGOUTPARAM_SCALE_DOESNT_MATCH_SETTER));
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.BLOB_TOO_LARGE_FOR_CLIENT),
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.BLOB_TOO_LARGE_FOR_CLIENT),
commit:1d87ff4
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.CURSOR_INVALID_CURSOR_NAME), cursorName);
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "execute(String)").getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "executeQuery(String)").getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "executeUpdate(String)").getSQLException();
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.LANG_NULL_INTO_NON_NULL),
0:                 new Integer(parameterIndex));
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_API_PARAMETER),
0:                         "null", "calendar", "setDate");
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(agent_.logWriter_,
0:                         new MessageId(SQLState.INVALID_API_PARAMETER),
1:                         "null", "calendar", "setTime()");
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.INVALID_API_PARAMETER),
0:                         "null", "calendar", "setTimestamp()");
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.JDBC_METHOD_NOT_IMPLEMENTED));
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.UNSUPPORTED_TYPE));
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.JAVA_EXCEPTION),
1:                 new Object[] {ae.getClass().getName(), ae.getMessage()}, ae);
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "execute(String, int)").getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "execute(String, String[])").getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "execute(String, int[])").getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "executeUpdate(String, int)").getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "executeUpdate(String, String[])").getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             new MessageId(SQLState.NOT_FOR_PREPARED_STATEMENT),
1:             "execute(String, int[])").getSQLException();
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(se);
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.UNABLE_TO_OPEN_RESULTSET_WITH_REQUESTED_HOLDABILTY),
0:                         new Integer(resultSetHoldability_));
/////////////////////////////////////////////////////////////////////////
0:             throw new BatchUpdateException(agent_.logWriter_, 
0:                 new MessageId(SQLState.TOO_MANY_COMMANDS_FOR_BATCH), 
0:                 new Integer(65534), updateCounts);
/////////////////////////////////////////////////////////////////////////
0:             throw new BatchUpdateException(agent_.logWriter_, 
0:                 new MessageId(SQLState.CANNOT_BATCH_QUERIES), updateCounts);
0:             throw new BatchUpdateException(agent_.logWriter_, 
0:                 new MessageId(SQLState.QUERY_BATCH_ON_NON_QUERY_STATEMENT), 
0:                 updateCounts);
/////////////////////////////////////////////////////////////////////////
0:                 throw new BatchUpdateException(agent_.logWriter_, 
0:                     new MessageId(SQLState.OUTPUT_PARAMS_NOT_ALLOWED),
0:                     updateCounts);
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.LANG_INVALID_PARAM_POSITION),
0:                 new Integer(parameterIndex), 
0:                 new Integer(parameterMetaData_.columns_));
/////////////////////////////////////////////////////////////////////////
1:                     throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.LANG_MISSING_PARMS));
/////////////////////////////////////////////////////////////////////////
0:                     new MessageId(SQLState.LANG_RETURN_OUTPUT_PARAM_CANNOT_BE_SET));
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.BAD_SCALE_VALUE),
0:                 new Integer(scale));
/////////////////////////////////////////////////////////////////////////
0:                 // TODO - FINISH THIS
1:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.REGOUTPARAM_SCALE_DOESNT_MATCH_SETTER));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.REGOUTPARAM_SCALE_DOESNT_MATCH_SETTER));
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_,
0:                     new MessageId(SQLState.BLOB_TOO_LARGE_FOR_CLIENT),
0:                     new Long(length), new Integer(Integer.MAX_VALUE)).getSQLException();
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_,
0:                     new MessageId(SQLState.BLOB_TOO_LARGE_FOR_CLIENT),
0:                     new Long(length), new Integer(Integer.MAX_VALUE)).getSQLException();
commit:3896fdd
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.Reader;
/////////////////////////////////////////////////////////////////////////
1:     
0:     // By default a PreparedStatement is poolable when it is created
0:     //required for jdbc4.0 methods
0:     private boolean isPoolable = true;    
/////////////////////////////////////////////////////////////////////////
1:     
0:     //jdbc 4.0 methods
1:    /**
1:      * Sets the designated parameter to a Reader object.
1:      *
1:      * @param parameterIndex index of the first parameter is 1, the second is 2, ...
1:      * @param reader An object that contains the data to set the parameter value to.
1:      * @param length the number of characters in the parameter data.
1:      * @throws SQLException if parameterIndex does not correspond to a parameter
1:      * marker in the SQL statement, or if the length specified is less than zero.
1:      *
1:      */
1:     
1:     public void setClob(int parameterIndex, Reader reader, long length)
1:     throws SQLException{
1:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setClob",
0:                         parameterIndex, reader, new Long(length));
1:             }
1:             if(length > Integer.MAX_VALUE)
0:                 throw new SQLException("CLOB length exceeds maximum " +
0:                         "possible limit");
1:             else
0:                 setInput(parameterIndex, new Clob(agent_, reader, (int)length));
1:         }
1:     }
1: 
1:     /**
1:      * Sets the designated parameter to a InputStream object.
1:      *
1:      * @param parameterIndex index of the first parameter is 1,
1:      * the second is 2, ...
1:      * @param inputStream An object that contains the data to set the parameter
1:      * value to.
1:      * @param length the number of bytes in the parameter data.
1:      * @throws SQLException if parameterIndex does not correspond
1:      * to a parameter marker in the SQL statement,  if the length specified
1:      * is less than zero or if the number of bytes in the inputstream does not match
1:      * the specfied length.
1:      *
1:      */
1:     
1:     public void setBlob(int parameterIndex, InputStream inputStream, long length)
1:     throws SQLException{
1:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
1:                 agent_.logWriter_.traceEntry(this, "setBlob", parameterIndex,
0:                         inputStream, new Long(length));
1:             }
1:             if(length > Integer.MAX_VALUE)
0:                 throw new SQLException("BLOB length exceeds maximum " +
0:                         "possible limit");
1:             else {
1:                 try {
1:                     setBinaryStreamX(parameterIndex, inputStream, (int)length);
1:                 } catch(SqlException se){
1:                     throw se.getSQLException();
1:                 }
1:             }
1:         }
1:     }    
1:     
1:     /**
0:      * Requests that a PreparedStatement be pooled or not.
1:      *
0:      * @param poolable requests that the statement be pooled if true and that the
0:      *                 statement not be pooled if false
0:      * @throws SQLException if the PreparedStatement has been closed.
1:      */
1:     
0:     public void setPoolable(boolean poolable)
0:     throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "setPoolable", poolable);
1:                 }
0:                 // Assert the statement has not been closed
0:                 checkForClosedStatement();
1:             
0:                 isPoolable = poolable;        
1:             }
1:         }
0:         catch (SqlException se)
1:         {
1:             throw se.getSQLException();
1:         }
1:     }
1:     
1:     /**
0:      * Returns the value of the statements poolable hint, indicating whether
0:      * pooling of the statement is requested.
1:      *
0:      * @return The value of the statement's poolable hint.
0:      * @throws SQLException if the PreparedStatement has been closed.
1:      */
1: 
0:     public boolean isPoolable()
1:     throws SQLException{
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "isPoolable");
1:                 }
0:                 // Assert the statement has not been closed
0:                 checkForClosedStatement();
1:             
0:                 return isPoolable;
1:             }
1:         }
0:         catch (SqlException se)
1:         {
1:             throw se.getSQLException();
1:         }
1:     }    
commit:d506170
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:     public boolean execute(String sql) throws SQLException {
0:                 " Use java.sql.PreparedStatement.execute () with no sql string argument.").getSQLException();
0:     public java.sql.ResultSet executeQuery(String sql) throws SQLException {
0:                 " Use java.sql.PreparedStatement.executeQuery () with no sql string argument.").getSQLException();
1:     public int executeUpdate(String sql) throws SQLException {
0:                 " Use java.sql.PreparedStatement.executeUpdate () with no sql string argument.").getSQLException();
0:     public java.sql.ResultSet executeQuery() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "executeQuery");
1:                 }
0:                 ResultSet resultSet = executeQueryX();
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "executeQuery", resultSet);
1:                 }
1:                 return resultSet;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public int executeUpdate() throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "executeUpdate");
1:                 }
0:                 int updateValue = executeUpdateX();
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "executeUpdate", updateValue);
1:                 }
1:                 return updateValue;
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public void setNull(int parameterIndex, int jdbcType) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setNull", parameterIndex, jdbcType);
1:                 }
1:                 setNullX(parameterIndex, jdbcType);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public void setNull(int parameterIndex, int jdbcType, String typeName) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "setNull", parameterIndex, jdbcType, typeName);
1:                 }
1:                 super.checkForClosedStatement();
0:                 setNull(parameterIndex, jdbcType);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public void setBoolean(int parameterIndex, boolean x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setBoolean", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.BIT;
0:                 setInput(parameterIndex, new Short((short) (x ? 1 : 0)));
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public void setByte(int parameterIndex, byte x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setByte", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.TINYINT;
0:                 setInput(parameterIndex, new Short(x));
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public void setShort(int parameterIndex, short x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setShort", parameterIndex, x);
1:                 }
1:                 setShortX(parameterIndex, x);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public void setInt(int parameterIndex, int x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setInt", parameterIndex, x);
1:                 }
1:                 setIntX(parameterIndex, x);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public void setLong(int parameterIndex, long x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setLong", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.BIGINT;
0:                 setInput(parameterIndex, new Long(x));
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public void setFloat(int parameterIndex, float x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setFloat", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.REAL;
0:                 setInput(parameterIndex, new Float(x));
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public void setDouble(int parameterIndex, double x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setDouble", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.DOUBLE;
0:                 setInput(parameterIndex, new Double(x));
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public void setBigDecimal(int parameterIndex, java.math.BigDecimal x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setBigDecimal", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.DECIMAL;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.DECIMAL);
1:                     return;
1:                 }
1:                 int registerOutScale = 0;
1:                 setInput(parameterIndex, x);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public void setDate(int parameterIndex, java.sql.Date x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "setDate", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.DATE;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.DATE);
1:                     return;
1:                 }
1:                 setInput(parameterIndex, x);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:                         java.util.Calendar calendar) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "setDate", parameterIndex, x, calendar);
1:                 }
1:                 if (calendar == null) {
0:                     throw new SqlException(agent_.logWriter_, "Invalid parameter: calendar is null");
1:                 }
0:                 java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
0:                 targetCalendar.clear();
0:                 targetCalendar.setTime(x);
0:                 java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:                 defaultCalendar.clear();
0:                 defaultCalendar.setTime(x);
0:                 long timeZoneOffset =
0:                         targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:                         targetCalendar.get(java.util.Calendar.DST_OFFSET) - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:                 java.sql.Date adjustedDate = ((timeZoneOffset == 0) || (x == null)) ? x : new java.sql.Date(x.getTime() + timeZoneOffset);
0:                 setDate(parameterIndex, adjustedDate);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public void setTime(int parameterIndex, java.sql.Time x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setTime", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.TIME;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.TIME);
1:                     return;
1:                 }
1:                 setInput(parameterIndex, x);
1:             }
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:                         java.util.Calendar calendar) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "setTime", parameterIndex, x, calendar);
1:                 }
1:                 if (calendar == null) {
0:                     throw new SqlException(agent_.logWriter_, "Invalid parameter: calendar is null");
1:                 }
0:                 java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
0:                 targetCalendar.clear();
0:                 targetCalendar.setTime(x);
0:                 java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:                 defaultCalendar.clear();
0:                 defaultCalendar.setTime(x);
0:                 long timeZoneOffset =
0:                         targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:                         targetCalendar.get(java.util.Calendar.DST_OFFSET) - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:                 java.sql.Time adjustedTime = ((timeZoneOffset == 0) || (x == null)) ? x : new java.sql.Time(x.getTime() + timeZoneOffset);
0:                 setTime(parameterIndex, adjustedTime);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public void setTimestamp(int parameterIndex, java.sql.Timestamp x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setTimestamp", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.TIMESTAMP;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.TIMESTAMP);
1:                     return;
1:                 }
1:                 setInput(parameterIndex, x);
0:                 // once the nanosecond field of timestamp is trim to microsecond for DERBY, should we throw a warning
0:                 //if (getParameterType (parameterIndex) == java.sql.Types.TIMESTAMP && x.getNanos() % 1000 != 0)
0:                 //  accumulateWarning (new SqlWarning (agent_.logWriter_, "DERBY timestamp can only store up to microsecond, conversion from nanosecond to microsecond causes rounding."));
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:                              java.util.Calendar calendar) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "setTimestamp", parameterIndex, x, calendar);
1:                 }
1:                 if (calendar == null) {
0:                     throw new SqlException(agent_.logWriter_, "Invalid parameter: calendar is null");
1:                 }
0:                 java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
0:                 targetCalendar.clear();
0:                 targetCalendar.setTime(x);
0:                 java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:                 defaultCalendar.clear();
0:                 defaultCalendar.setTime(x);
0:                 long timeZoneOffset =
0:                         targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:                         targetCalendar.get(java.util.Calendar.DST_OFFSET) - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:                 java.sql.Timestamp adjustedTimestamp = ((timeZoneOffset == 0) || (x == null)) ? x : new java.sql.Timestamp(x.getTime() + timeZoneOffset);
0:                 if (x != null) {
0:                     adjustedTimestamp.setNanos(x.getNanos());
1:                 }
0:                 setTimestamp(parameterIndex, adjustedTimestamp);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:     public void setString(int parameterIndex, String x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setString", parameterIndex, x);
1:                 }
1:                 setStringX(parameterIndex, x);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             setNullX(parameterIndex, java.sql.Types.LONGVARCHAR);
1:     public void setBytes(int parameterIndex, byte[] x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setBytes", parameterIndex, x);
1:                 }
1:                 setBytesX(parameterIndex, x);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             setNullX(parameterIndex, java.sql.Types.LONGVARBINARY);
/////////////////////////////////////////////////////////////////////////
1:                                 int length) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "setBinaryStream", parameterIndex, "<input stream>", length);
1:                 }
0:                 setBinaryStreamX(parameterIndex, x, length);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             setNullX(parameterIndex, java.sql.Types.BLOB);
/////////////////////////////////////////////////////////////////////////
0:                                int length) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "setAsciiStream", parameterIndex, "<input stream>", length);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.CLOB;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.CLOB);
1:                     return;
1:                 }
0:                 setInput(parameterIndex, new Clob(agent_, x, "US-ASCII", length));
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:                                  int length) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceDeprecatedEntry(this, "setUnicodeStream", parameterIndex, "<input stream>", length);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.CLOB;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.CLOB);
1:                     return;
1:                 }
0:                 setInput(parameterIndex, new Clob(agent_, x, "UnicodeBigUnmarked", length));
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:                                    int length) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "setCharacterStream", parameterIndex, x, length);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.CLOB;
1:                 if (x == null) {
0:                     setNull(parameterIndex, java.sql.Types.CLOB);
1:                     return;
1:                 }
0:                 setInput(parameterIndex, new Clob(agent_, x, length));
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public void setBlob(int parameterIndex, java.sql.Blob x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setBlob", parameterIndex, x);
1:                 }
1:                 setBlobX(parameterIndex, x);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:             setNullX(parameterIndex, java.sql.Types.BLOB);
0:     public void setClob(int parameterIndex, java.sql.Clob x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setClob", parameterIndex, x);
1:                 }
1:                 setClobX(parameterIndex, x);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
0:     public void setArray(int parameterIndex, java.sql.Array x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setArray", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 throw new SqlException(agent_.logWriter_, "jdbc 2 method not yet implemented");
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
0:     public void setRef(int parameterIndex, java.sql.Ref x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setRef", parameterIndex, x);
1:                 }
0:                 parameterIndex = checkSetterPreconditions(parameterIndex);
0:                 throw new SqlException(agent_.logWriter_, "jdbc 2 method not yet implemented").getSQLException();
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }            
1:     public void setObject(int parameterIndex, Object x) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x);
1:                 }
0:                 super.checkForClosedStatement();
0:                 if (x instanceof String) {
1:                     setString(parameterIndex, (String) x);
1:                 } else if (x instanceof Integer) {
1:                     setInt(parameterIndex, ((Integer) x).intValue());
1:                 } else if (x instanceof Double) {
1:                     setDouble(parameterIndex, ((Double) x).doubleValue());
1:                 } else if (x instanceof Float) {
1:                     setFloat(parameterIndex, ((Float) x).floatValue());
1:                 } else if (x instanceof Boolean) {
1:                     setBoolean(parameterIndex, ((Boolean) x).booleanValue());
1:                 } else if (x instanceof Long) {
1:                     setLong(parameterIndex, ((Long) x).longValue());
1:                 } else if (x instanceof byte[]) {
1:                     setBytes(parameterIndex, (byte[]) x);
0:                 } else if (x instanceof java.math.BigDecimal) {
0:                     setBigDecimal(parameterIndex, (java.math.BigDecimal) x);
0:                 } else if (x instanceof java.sql.Date) {
0:                     setDate(parameterIndex, (java.sql.Date) x);
0:                 } else if (x instanceof java.sql.Time) {
0:                     setTime(parameterIndex, (java.sql.Time) x);
0:                 } else if (x instanceof java.sql.Timestamp) {
0:                     setTimestamp(parameterIndex, (java.sql.Timestamp) x);
0:                 } else if (x instanceof java.sql.Blob) {
0:                     setBlob(parameterIndex, (java.sql.Blob) x);
0:                 } else if (x instanceof java.sql.Clob) {
0:                     setClob(parameterIndex, (java.sql.Clob) x);
0:                 } else if (x instanceof java.sql.Array) {
0:                     setArray(parameterIndex, (java.sql.Array) x);
0:                 } else if (x instanceof java.sql.Ref) {
0:                     setRef(parameterIndex, (java.sql.Ref) x);
1:                 } else if (x instanceof Short) {
1:                     setShort(parameterIndex, ((Short) x).shortValue());
1:                 } else if (x instanceof Byte) {
1:                     setByte(parameterIndex, ((Byte) x).byteValue());
1:                 } else {
0:                     checkSetterPreconditions(parameterIndex);
0:                     throw new SqlException(agent_.logWriter_, "Invalid data conversion:" +
0:                             " Parameter object type is invalid for requested conversion.");
1:                 }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:         }            
1:     public void setObject(int parameterIndex, Object x, int targetJdbcType) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x, targetJdbcType);
1:                 }
1:                 setObjectX(parameterIndex, x, targetJdbcType, 0);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
1:                           int scale) throws SQLException {
1:         try
1:         {
1:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x, targetJdbcType, scale);
1:                 }
1:                 setObjectX(parameterIndex, x, targetJdbcType, scale);
1:         }
1:         catch ( SqlException se )
1:         {
1:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:             setNullX(parameterIndex, targetJdbcType);
/////////////////////////////////////////////////////////////////////////
1:         try { 
1:             setObject(parameterIndex, x);
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
1:         }
1:     public void clearParameters() throws SQLException {
0:         try
0:         {
0:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "clearParameters");
0:                 checkForClosedStatement();
1:                 if (parameterMetaData_ != null) {
0:                     for (int i = 0; i < parameters_.length; i++) {
0:                         parameters_[i] = null;
1:                     }
0:                     for (int i = 0; i < parameterSet_.length; i++) {
0:                         parameterSet_[i] = false;
1:                     }
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
1:         }
1:     public boolean execute() throws SQLException {
0:         try
0:         {
0:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "execute");
1:                 }
1:                 boolean b = executeX();
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "execute", b);
1:                 }
1:                 return b;
1:         }
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public void addBatch() throws SQLException {
0:         try
0:         {
0:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "addBatch");
1:                 }
0:                 checkForClosedStatement();
1:                 checkThatAllParametersAreSet();
1: 
1:                 // ASSERT: since OUT/INOUT parameters are not allowed, there should
1:                 //         be no problem in sharing the JDBC Wrapper object instances
1:                 //         since they will not be modified by the driver.
1: 
1:                 // batch up the parameter values -- deep copy req'd
1: 
1:                 if (parameterMetaData_ != null) {
1:                     Object[] inputsClone = new Object[parameters_.length];
1:                     System.arraycopy(parameters_, 0, inputsClone, 0, parameters_.length);
1: 
1:                     batch_.add(inputsClone);
1:                 } else {
1:                     batch_.add(null);
1:                 }
1:         }
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
0:     public int[] executeBatch() throws SQLException, BatchUpdateException {
0:         try
0:         {
0:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "executeBatch");
1:                 }
0:                 int[] updateCounts = null;
1:                 updateCounts = executeBatchX(false);
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "executeBatch", updateCounts);
1:                 }
1:                 return updateCounts;
1:         }
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
0:     public java.sql.ResultSetMetaData getMetaData() throws SQLException {
0:         try
0:         {
0:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getMetaData");
1:                 }
1:                 ColumnMetaData resultSetMetaData = getMetaDataX();
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getMetaData", resultSetMetaData);
1:                 }
1:                 return resultSetMetaData;
1:         }
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:     public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
0:                 " Use java.sql.PreparedStatement.execute () with no arguments.").getSQLException();
1:     public boolean execute(String sql, String[] columnNames) throws SQLException {
0:                 " Use java.sql.PreparedStatement.execute () with no arguments.").getSQLException();
1:     public boolean execute(String sql, int[] columnIndexes) throws SQLException {
0:                 " Use java.sql.PreparedStatement.execute () with no arguments.").getSQLException();
1:     public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
0:                 " Use java.sql.PreparedStatement.executeUpdate () with no arguments.").getSQLException();
1:     public int executeUpdate(String sql, String[] columnNames) throws SQLException {
0:                 " Use java.sql.PreparedStatement.executeUpdate () with no arguments.").getSQLException();
1:     public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
0:                 " Use java.sql.PreparedStatement.executeUpdate () with no arguments.").getSQLException();
0:     public void setURL(int parameterIndex, java.net.URL x) throws SQLException {
0:         jdbc3FeatureNotSupported(false);
0:     public java.sql.ParameterMetaData getParameterMetaData() throws SQLException {
0:         try
0:         {
0:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceEntry(this, "getParameterMetaData");
1:                 }
1:                 Object parameterMetaData = getParameterMetaDataX();
1:                 if (agent_.loggingEnabled()) {
1:                     agent_.logWriter_.traceExit(this, "getParameterMetaData", parameterMetaData);
1:                 }
0:                 return (java.sql.ParameterMetaData) parameterMetaData;
1:         }
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
/////////////////////////////////////////////////////////////////////////
1:             int numInputColumns;
1:             boolean outputExpected;
0:             try
0:             {
1:                 numInputColumns = (parameterMetaData_ != null) ? parameterMetaData_.getColumnCount() : 0;
1:                 outputExpected = (resultSetMetaData_ != null && resultSetMetaData_.getColumnCount() > 0);
1:             }
1:             catch ( SQLException se )
0:             {
1:                 // Generate a SqlException for this, we don't want to throw
1:                 // SQLException in this internal method
0:                 throw new SqlException(agent_.logWriter_, se, se.getMessage(),
0:                     se.getSQLState(), se.getErrorCode());
1:             }
/////////////////////////////////////////////////////////////////////////
0:     public int[] executeBatchX(boolean supportsQueryBatchRequest) 
0:         throws SqlException, SQLException, BatchUpdateException {
/////////////////////////////////////////////////////////////////////////
1:         int numInputColumns;
1:         try {
1:             numInputColumns = parameterMetaData_ == null ? 0 : parameterMetaData_.getColumnCount();
1:         } catch ( SQLException se ) {
1:             throw new SqlException(se);
1:         }
/////////////////////////////////////////////////////////////////////////
1:                 boolean outputExpected;
1:                 try {
1:                     outputExpected = (resultSetMetaData_ != null && resultSetMetaData_.getColumnCount() > 0);
1:                 } catch ( SQLException se ) {
1:                     throw new SqlException(se);
1:                 }
/////////////////////////////////////////////////////////////////////////
0:     public void close() throws SQLException {
0:         try
0:         {
0:             synchronized (connection_) {
1:                 if (agent_.loggingEnabled()) {
0:                     agent_.logWriter_.traceEntry(this, "close");
1:                 }
0:                 closeX();
1:         }
0:         catch ( SqlException se )
0:         {
0:             throw se.getSQLException();
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:c8ceb5f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             boolean timeoutSent = false;
1:             if (doWriteTimeout) {
1:                 timeoutArrayList.set(0, TIMEOUT_STATEMENT + timeout_);
1:                 writeSetSpecialRegister(timeoutArrayList);
1:                 doWriteTimeout = false;
1:                 timeoutSent = true;
1:             }
/////////////////////////////////////////////////////////////////////////
1:             if (timeoutSent) {
1:                 readSetSpecialRegister(); // Read response to the EXCSQLSET
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         boolean timeoutSent = false;
/////////////////////////////////////////////////////////////////////////
1:         if (doWriteTimeout) {
1:             timeoutArrayList.set(0, TIMEOUT_STATEMENT + timeout_);
1:             writeSetSpecialRegister(timeoutArrayList);
1:             doWriteTimeout = false;
1:             timeoutSent = true;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (timeoutSent) {
1:             readSetSpecialRegister(); // Read response to the EXCSQLSET
1:         }
1: 
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:1cb533f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         // JDBC Spec specifies that conversion should occur on the client if
1:         // the targetJdbcType is specified.
1: 
1:         int inputParameterType = CrossConverters.getInputJdbcType(targetJdbcType);
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = inputParameterType;
1:         x = agent_.crossConverters_.setObject(inputParameterType, x);
1: 
1:         // Set to round down on setScale like embedded does in SQLDecimal
1:         try {
0:             if (targetJdbcType == java.sql.Types.DECIMAL || targetJdbcType == java.sql.Types.NUMERIC) {
0:                 x = ((java.math.BigDecimal) x).setScale(scale, java.math.BigDecimal.ROUND_DOWN);
1:             }
1:         } catch (ArithmeticException ae) {
1:             // Any problems with scale should have already been caught by
1:             // checkForvalidScale
0:             throw new SqlException(agent_.logWriter_, ae.getMessage());
1:         }
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: 
0:         implements java.sql.PreparedStatement,
0:         PreparedStatementCallbackInterface {
1:     //---------------------navigational cheat-links-------------------------------
1:     // Cheat-links are for convenience only, and are not part of the conceptual model.
1:     // Warning:
1:     //   Cheat-links should only be defined for invariant state data.
1:     //   That is, the state data is set by the constructor and never changes.
1:     // Alias for downcast (MaterialPreparedStatementProxy) super.materialStatement.
1:     public MaterialPreparedStatement materialPreparedStatement_ = null;
1:     //-----------------------------state------------------------------------------
0:     public String sql_;
1:     // This variable is only used by Batch.
1:     // True if a call sql statement has an OUT or INOUT parameter registered.
0:     public boolean outputRegistered_ = false;
1:     // Parameter inputs are cached as objects so they may be sent on execute()
0:     public Object[] parameters_;
0:     boolean[] parameterSet_;
1:     boolean[] parameterRegistered_;
1:     void setInput(int parameterIndex, Object input) {
1:         parameters_[parameterIndex - 1] = input;
1:         parameterSet_[parameterIndex - 1] = true;
0:     public ColumnMetaData parameterMetaData_; // type information for input sqlda
1:     // The problem with storing the scrollable ResultSet associated with cursorName in scrollableRS_ is
1:     // that when the PreparedStatement is re-executed, it has a new ResultSet, however, we always do
1:     // the reposition on the ResultSet that was stored in scrollableRS_, and we never update scrollableRS_
1:     // when PreparedStatement is re-execute.  So the new ResultSet that needs to be repositioned never
1:     // gets repositioned.
1:     // So instead of caching the scrollableRS_, we will cache the cursorName.  And re-retrieve the scrollable
1:     // result set from the map using this cursorName every time the PreparedStatement excutes.
0:     String positionedUpdateCursorName_ = null;
1:     private void initPreparedStatement() {
1:         materialPreparedStatement_ = null;
1:         sql_ = null;
1:         outputRegistered_ = false;
1:         parameters_ = null;
1:         parameterSet_ = null;
1:         parameterRegistered_ = null;
1:         parameterMetaData_ = null;
1:         isAutoCommittableStatement_ = true;
1:         isPreparedStatement_ = true;
1:     protected void initResetPreparedStatement() {
1:         outputRegistered_ = false;
1:         isPreparedStatement_ = true;
0:         if (parameterMetaData_ != null) {
0:             resetParameters();
1:         }
1:     }
1: 
1:     public void reset(boolean fullReset) throws SqlException {
1:         if (fullReset) {
1:             connection_.resetPrepareStatement(this);
1:         } else {
1:             super.initResetPreparedStatement();
1:             initResetPreparedStatement();
1:         }
1:     }
1: 
1:     private void resetParameters() {
1:         for (int i = 0; i < parameterMetaData_.columns_; i++) {
0:             parameters_[i] = null;
0:             parameterSet_[i] = false;
0:             parameterRegistered_[i] = false;
1:         }
1:     }
1: 
0:     // For for JDBC 2 positioned update statements.
0:     // Called by material statement constructors.
0:     public PreparedStatement(Agent agent,
0:                              Connection connection,
1:                              String sql,
1:                              Section section) throws SqlException {
1:         super(agent, connection);
1:         initPreparedStatement(sql, section);
1:     }
1: 
1:     public void resetPreparedStatement(Agent agent,
0:                                        Connection connection,
1:                                        String sql,
1:                                        Section section) throws SqlException {
1:         super.resetStatement(agent, connection);
1:         initPreparedStatement();
1:         initPreparedStatement(sql, section);
1:     }
1: 
1:     private void initPreparedStatement(String sql, Section section) throws SqlException {
1:         sql_ = sql;
1:         isPreparedStatement_ = true;
1: 
1:         parseSqlAndSetSqlModes(sql_);
0:         section_ = section;
1:     }
1: 
0:     // Constructor for jdbc 2 prepared statements with scroll attributes.
0:     // Called by material statement constructors.
0:     public PreparedStatement(Agent agent,
0:                              Connection connection,
1:                              String sql,
0:                              int type, int concurrency, int holdability, int autoGeneratedKeys, String[] columnNames) throws SqlException {
0:         super(agent, connection, type, concurrency, holdability, autoGeneratedKeys, columnNames);
1:         initPreparedStatement(sql);
1:     }
1: 
1:     public void resetPreparedStatement(Agent agent,
0:                                        Connection connection,
1:                                        String sql,
0:                                        int type, int concurrency, int holdability, int autoGeneratedKeys, String[] columnNames) throws SqlException {
0:         super.resetStatement(agent, connection, type, concurrency, holdability, autoGeneratedKeys, columnNames);
1:         initPreparedStatement();
1:         initPreparedStatement(sql);
1:     }
1: 
1:     private void initPreparedStatement(String sql) throws SqlException {
1:         sql_ = super.escape(sql);
1:         parseSqlAndSetSqlModes(sql_);
1:         isPreparedStatement_ = true;
1: 
1:         // Check for positioned update statement and assign a section from the
1:         // same package as the corresponding query section.
1:         // Scan the sql for an "update...where current of <cursor-name>".
1:         String cursorName = null;
1:         if (sqlUpdateMode_ == isDeleteSql__ || sqlUpdateMode_ == isUpdateSql__) {
1:             String[] sqlAndCursorName = extractCursorNameFromWhereCurrentOf(sql_);
1:             if (sqlAndCursorName != null) {
1:                 cursorName = sqlAndCursorName[0];
1:                 sql_ = sqlAndCursorName[1];
1:             }
1:         }
1:         if (cursorName != null) {
1:             positionedUpdateCursorName_ = cursorName;
1:             // Get a new section from the same package as the query section
0:             section_ = agent_.sectionManager_.getPositionedUpdateSection(cursorName, false); // false means get a regular section
1: 
0:             if (section_ == null) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid cursor name \"" + cursorName + "\" in the Update/Delete statement.");
1:             }
1: 
1:             //scrollableRS_ = agent_.sectionManager_.getPositionedUpdateResultSet (cursorName);
1: 
1:             // if client's cursor name is set, and the cursor name in the positioned update
1:             // string is the same as the client's cursor name, replace client's cursor name
1:             // with the server's cursor name.
1:             // if the cursor name supplied in the sql string is different from the cursorName
1:             // set by setCursorName(), then server will return "cursor name not defined" error,
1:             // and no subsititution is made here.
0:             if (section_.getClientCursorName() != null && // cursor name is user defined
0:                     cursorName.compareTo(section_.getClientCursorName()) == 0)
1:             // client's cursor name is substituted with section's server cursor name
0:             {
0:                 sql_ = substituteClientCursorNameWithServerCursorName(sql_, section_);
1:             }
1:         } else {
1:             // We don't need to analyze the sql text to determine if it is a query or not.
1:             // This is up to the server to decide, we just pass thru the sql on flowPrepare().
0:             section_ = agent_.sectionManager_.getDynamicSection(resultSetHoldability_);
1:         }
1:     }
1: 
1:     public void resetPreparedStatement(Agent agent,
0:                                        Connection connection,
1:                                        String sql,
0:                                        Section section,
1:                                        ColumnMetaData parameterMetaData,
0:                                        ColumnMetaData resultSetMetaData) throws SqlException {
0:         resetPreparedStatement(agent, connection, sql, section);
0:         initPreparedStatement(parameterMetaData, resultSetMetaData);
1:     }
1: 
0:     private void initPreparedStatement(ColumnMetaData parameterMetaData,
0:                                        ColumnMetaData resultSetMetaData) throws SqlException {
1:         isPreparedStatement_ = true;
1:         parameterMetaData_ = parameterMetaData;
1:         resultSetMetaData_ = resultSetMetaData;
0:         if (parameterMetaData_ != null) {
0:             parameters_ = new Object[parameterMetaData_.columns_];
0:             //parameterSetOrRegistered_ = new boolean[parameterMetaData_.columns_];
0:             parameterSet_ = new boolean[parameterMetaData_.columns_];
0:             parameterRegistered_ = new boolean[parameterMetaData_.columns_];
1:         }
1:     }
1: 
0:     protected void finalize() throws java.lang.Throwable {
1:         if (agent_.loggingEnabled()) {
0:             agent_.logWriter_.traceEntry(this, "finalize");
1:         }
0:         if (openOnClient_) {
0:             synchronized (connection_) {
0:                 closeX();
1:             }
1:         }
0:         super.finalize();
1:     }
1: 
1:     // called immediately after the constructor by Connection prepare*() methods
1:     void prepare() throws SqlException {
1:         try {
1:             // flow prepare, no static initialization is needed
0:             // already checked if columnNames is not null and server supports select from insert
0:             // in prepareStatementX()
0:             if (sqlUpdateMode_ == isInsertSql__ && generatedKeysColumnNames_ != null) {
0:                 flowPrepareForSelectFromInsert();
1:             } else {
0:                 flowPrepareDescribeInputOutput();
1:             }
1:         } catch (SqlException e) {
1:             this.markClosed();
1:             throw e;
1:         }
1:     //------------------- Prohibited overrides from Statement --------------------
0:     public boolean execute(String sql) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "execute", sql);
1:         }
1:         throw new SqlException(agent_.logWriter_,
0:                 "The method java.sql.Statement.execute (String sql) cannot be called on a " +
0:                 " prepared statement instance." +
0:                 " Use java.sql.PreparedStatement.execute () with no sql string argument.");
0:     public java.sql.ResultSet executeQuery(String sql) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "executeQuery", sql);
1:         }
1:         throw new SqlException(agent_.logWriter_,
0:                 "The method java.sql.Statement.executeQuery (String sql) cannot be called on a " +
0:                 " prepared statement instance." +
0:                 " Use java.sql.PreparedStatement.executeQuery () with no sql string argument.");
0:     public int executeUpdate(String sql) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "executeUpdate", sql);
1:         }
1:         throw new SqlException(agent_.logWriter_,
0:                 "The method java.sql.Statement.executeUpdate (String sql) cannot be called on a " +
0:                 " prepared statement instance." +
0:                 " Use java.sql.PreparedStatement.executeUpdate () with no sql string argument.");
1:     }
1:     // ---------------------------jdbc 1------------------------------------------
1: 
0:     public java.sql.ResultSet executeQuery() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "executeQuery");
1:             }
0:             ResultSet resultSet = executeQueryX();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "executeQuery", resultSet);
1:             }
0:             return resultSet;
1:         }
1:     }
1: 
1:     // also called by some DBMD methods
0:     ResultSet executeQueryX() throws SqlException {
1:         flowExecute(executeQueryMethod__);
1: 
0:         super.checkExecuteQueryPostConditions("java.sql.PreparedStatement");
1:         return resultSet_;
1:     }
1: 
1: 
0:     public int executeUpdate() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "executeUpdate");
1:             }
0:             int updateValue = executeUpdateX();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "executeUpdate", updateValue);
1:             }
0:             return updateValue;
1:         }
1:     }
1: 
0:     // also used by Blob
0:     int executeUpdateX() throws SqlException {
1:         flowExecute(executeUpdateMethod__);
1: 
1:         if (sqlMode_ == isUpdate__) {
0:             super.checkExecuteUpdatePostConditions("java.sql.PreparedStatement");
1:         }
1:         return updateCount_;
1:     }
1: 
0:     public void setNull(int parameterIndex, int jdbcType) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setNull", parameterIndex, jdbcType);
1:             }
0:             setNullX(parameterIndex, jdbcType);
1:         }
1:     }
1: 
1:     // also used by DBMD methods
1:     void setNullX(int parameterIndex, int jdbcType) throws SqlException {
0:         super.checkForClosedStatement();  // investigate what can be pushed up to setNull
0:         parameterIndex = checkSetterPreconditions(parameterIndex);
1:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = jdbcType;
1: 
1:         if (!parameterMetaData_.nullable_[parameterIndex - 1]) {
0:             throw new SqlException(agent_.logWriter_, "PreparedStatement: setNull method setting a non-nullable " +
0:                     "input parameter " + parameterIndex + " to null.");
1:         }
1:         setInput(parameterIndex, null);
1:     }
1: 
0:     public void setNull(int parameterIndex, int jdbcType, String typeName) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setNull", parameterIndex, jdbcType, typeName);
1:             }
0:             super.checkForClosedStatement();
0:             setNull(parameterIndex, jdbcType);
1:         }
1:     }
1: 
0:     public void setBoolean(int parameterIndex, boolean x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setBoolean", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.BIT;
0:             setInput(parameterIndex, new Short((short) (x ? 1 : 0)));
1:         }
1:     }
1: 
0:     public void setByte(int parameterIndex, byte x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setByte", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.TINYINT;
0:             setInput(parameterIndex, new Short(x));
1:         }
1:     }
1: 
0:     public void setShort(int parameterIndex, short x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setShort", parameterIndex, x);
1:             }
0:             setShortX(parameterIndex, x);
1:         }
1:     }
1: 
1:     // also used by DBMD methods
1:     void setShortX(int parameterIndex, short x) throws SqlException {
0:         parameterIndex = checkSetterPreconditions(parameterIndex);
0:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.SMALLINT;
0:         setInput(parameterIndex, new Short(x));
0:     public void setInt(int parameterIndex, int x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setInt", parameterIndex, x);
1:             }
0:             setIntX(parameterIndex, x);
1:         }
1:     // also used by DBMD methods
1:     void setIntX(int parameterIndex, int x) throws SqlException {
0:         parameterIndex = checkSetterPreconditions(parameterIndex);
0:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.INTEGER;
0:         setInput(parameterIndex, new Integer(x));
1: 
0:     public void setLong(int parameterIndex, long x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setLong", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.BIGINT;
0:             setInput(parameterIndex, new Long(x));
1:         }
1:     }
1: 
0:     public void setFloat(int parameterIndex, float x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setFloat", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.REAL;
0:             setInput(parameterIndex, new Float(x));
1:         }
1:     }
1: 
0:     public void setDouble(int parameterIndex, double x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setDouble", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.DOUBLE;
0:             setInput(parameterIndex, new Double(x));
1:         }
1:     }
1: 
0:     public void setBigDecimal(int parameterIndex, java.math.BigDecimal x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setBigDecimal", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.DECIMAL;
1:             if (x == null) {
0:                 setNull(parameterIndex, java.sql.Types.DECIMAL);
1:                 return;
1:             }
0:             int registerOutScale = 0;
1:             setInput(parameterIndex, x);
1:         }
1:     }
1: 
0:     public void setDate(int parameterIndex, java.sql.Date x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setDate", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.DATE;
1:             if (x == null) {
0:                 setNull(parameterIndex, java.sql.Types.DATE);
1:                 return;
1:             }
1:             setInput(parameterIndex, x);
1:         }
1:     }
1: 
0:     public void setDate(int parameterIndex,
0:                         java.sql.Date x,
0:                         java.util.Calendar calendar) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setDate", parameterIndex, x, calendar);
1:             }
0:             if (calendar == null) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid parameter: calendar is null");
1:             }
0:             java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
0:             targetCalendar.clear();
0:             targetCalendar.setTime(x);
0:             java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:             defaultCalendar.clear();
0:             defaultCalendar.setTime(x);
0:             long timeZoneOffset =
0:                     targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:                     targetCalendar.get(java.util.Calendar.DST_OFFSET) - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:             java.sql.Date adjustedDate = ((timeZoneOffset == 0) || (x == null)) ? x : new java.sql.Date(x.getTime() + timeZoneOffset);
0:             setDate(parameterIndex, adjustedDate);
1:         }
1:     }
1: 
0:     public void setTime(int parameterIndex, java.sql.Time x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setTime", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.TIME;
1:             if (x == null) {
0:                 setNull(parameterIndex, java.sql.Types.TIME);
1:                 return;
1:             }
1:             setInput(parameterIndex, x);
1: 
1:         }
1:     }
1: 
0:     public void setTime(int parameterIndex,
0:                         java.sql.Time x,
0:                         java.util.Calendar calendar) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setTime", parameterIndex, x, calendar);
1:             }
0:             if (calendar == null) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid parameter: calendar is null");
1:             }
0:             java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
0:             targetCalendar.clear();
0:             targetCalendar.setTime(x);
0:             java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:             defaultCalendar.clear();
0:             defaultCalendar.setTime(x);
0:             long timeZoneOffset =
0:                     targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:                     targetCalendar.get(java.util.Calendar.DST_OFFSET) - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:             java.sql.Time adjustedTime = ((timeZoneOffset == 0) || (x == null)) ? x : new java.sql.Time(x.getTime() + timeZoneOffset);
0:             setTime(parameterIndex, adjustedTime);
1:         }
1:     }
1: 
0:     public void setTimestamp(int parameterIndex, java.sql.Timestamp x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setTimestamp", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.TIMESTAMP;
1: 
1:             if (x == null) {
0:                 setNull(parameterIndex, java.sql.Types.TIMESTAMP);
1:                 return;
1:             }
1:             setInput(parameterIndex, x);
0:             // once the nanosecond field of timestamp is trim to microsecond for DERBY, should we throw a warning
0:             //if (getParameterType (parameterIndex) == java.sql.Types.TIMESTAMP && x.getNanos() % 1000 != 0)
0:             //  accumulateWarning (new SqlWarning (agent_.logWriter_, "DERBY timestamp can only store up to microsecond, conversion from nanosecond to microsecond causes rounding."));
1:         }
1:     }
1: 
0:     public void setTimestamp(int parameterIndex,
0:                              java.sql.Timestamp x,
0:                              java.util.Calendar calendar) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setTimestamp", parameterIndex, x, calendar);
1:             }
0:             if (calendar == null) {
0:                 throw new SqlException(agent_.logWriter_, "Invalid parameter: calendar is null");
1:             }
0:             java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
0:             targetCalendar.clear();
0:             targetCalendar.setTime(x);
0:             java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:             defaultCalendar.clear();
0:             defaultCalendar.setTime(x);
0:             long timeZoneOffset =
0:                     targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:                     targetCalendar.get(java.util.Calendar.DST_OFFSET) - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:             java.sql.Timestamp adjustedTimestamp = ((timeZoneOffset == 0) || (x == null)) ? x : new java.sql.Timestamp(x.getTime() + timeZoneOffset);
0:             if (x != null) {
0:                 adjustedTimestamp.setNanos(x.getNanos());
1:             }
0:             setTimestamp(parameterIndex, adjustedTimestamp);
1:         }
1:     }
1: 
0:     public void setString(int parameterIndex, String x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setString", parameterIndex, x);
1:             }
0:             setStringX(parameterIndex, x);
1:         }
1:     }
1: 
1:     // also used by DBMD methods
1:     void setStringX(int parameterIndex, String x) throws SqlException {
0:         parameterIndex = checkSetterPreconditions(parameterIndex);
0:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.LONGVARCHAR;
1:         if (x == null) {
0:             setNull(parameterIndex, java.sql.Types.LONGVARCHAR);
1:             return;
1:         }
1:         setInput(parameterIndex, x);
1:     }
1: 
0:     public void setBytes(int parameterIndex, byte[] x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setBytes", parameterIndex, x);
1:             }
0:             setBytesX(parameterIndex, x);
1:         }
1:     }
1: 
0:     // also used by BLOB
0:     public void setBytesX(int parameterIndex, byte[] x) throws SqlException {
0:         parameterIndex = checkSetterPreconditions(parameterIndex);
0:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.LONGVARBINARY;
1:         if (x == null) {
0:             setNull(parameterIndex, java.sql.Types.LONGVARBINARY);
1:             return;
1:         }
1:         setInput(parameterIndex, x);
1: 
1:     }
1: 
1:     public void setBinaryStream(int parameterIndex,
1:                                 int length) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setBinaryStream", parameterIndex, "<input stream>", length);
1:             }
0:             setBinaryStreamX(parameterIndex, x, length);
1:         }
0:     public void setBinaryStreamX(int parameterIndex,
0:                                  java.io.InputStream x,
1:                                  int length) throws SqlException {
0:         parameterIndex = checkSetterPreconditions(parameterIndex);
0:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.BLOB;
1:         if (x == null) {
0:             setNull(parameterIndex, java.sql.Types.BLOB);
1:             return;
1:         }
0:         setInput(parameterIndex, new Blob(agent_, x, length));
1:     public void setAsciiStream(int parameterIndex,
0:                                java.io.InputStream x,
1:                                int length) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setAsciiStream", parameterIndex, "<input stream>", length);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.CLOB;
1:             if (x == null) {
0:                 setNull(parameterIndex, java.sql.Types.CLOB);
1:                 return;
1:             }
0:             setInput(parameterIndex, new Clob(agent_, x, "US-ASCII", length));
1:         }
1:     public void setUnicodeStream(int parameterIndex,
0:                                  java.io.InputStream x,
1:                                  int length) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceDeprecatedEntry(this, "setUnicodeStream", parameterIndex, "<input stream>", length);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.CLOB;
1:             if (x == null) {
0:                 setNull(parameterIndex, java.sql.Types.CLOB);
1:                 return;
1:             }
0:             setInput(parameterIndex, new Clob(agent_, x, "UnicodeBigUnmarked", length));
1:         }
1:     public void setCharacterStream(int parameterIndex,
0:                                    java.io.Reader x,
1:                                    int length) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setCharacterStream", parameterIndex, x, length);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.CLOB;
1:             if (x == null) {
0:                 setNull(parameterIndex, java.sql.Types.CLOB);
1:                 return;
1:             }
0:             setInput(parameterIndex, new Clob(agent_, x, length));
1:         }
0:     public void setBlob(int parameterIndex, java.sql.Blob x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setBlob", parameterIndex, x);
1:             }
0:             setBlobX(parameterIndex, x);
1:         }
0:     // also used by Blob
0:     public void setBlobX(int parameterIndex, java.sql.Blob x) throws SqlException {
0:         parameterIndex = checkSetterPreconditions(parameterIndex);
0:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.BLOB;
1:         if (x == null) {
0:             setNull(parameterIndex, java.sql.Types.BLOB);
1:             return;
1:         }
1:         setInput(parameterIndex, x);
0:     public void setClob(int parameterIndex, java.sql.Clob x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setClob", parameterIndex, x);
1:             }
0:             setClobX(parameterIndex, x);
1:         }
0:     // also used by Clob
0:     void setClobX(int parameterIndex, java.sql.Clob x) throws SqlException {
0:         parameterIndex = checkSetterPreconditions(parameterIndex);
0:         parameterMetaData_.clientParamtertype_[parameterIndex - 1] = java.sql.Types.CLOB;
1:         if (x == null) {
0:             this.setNullX(parameterIndex, Types.CLOB);
1:             return;
1:         }
1:         setInput(parameterIndex, x);
0:     public void setArray(int parameterIndex, java.sql.Array x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setArray", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             throw new SqlException(agent_.logWriter_, "jdbc 2 method not yet implemented");
1:         }
1: 
0:     public void setRef(int parameterIndex, java.sql.Ref x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setRef", parameterIndex, x);
1:             }
0:             parameterIndex = checkSetterPreconditions(parameterIndex);
0:             throw new SqlException(agent_.logWriter_, "jdbc 2 method not yet implemented");
1:         }
1:     // The Java compiler uses static binding, so we must use instanceof
1:     // rather than to rely on separate setObject() methods for
1:     // each of the Java Object instance types recognized below.
0:     public void setObject(int parameterIndex, Object x) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x);
1:             }
0:             super.checkForClosedStatement();
0:             if (x instanceof String) {
0:                 setString(parameterIndex, (String) x);
0:             } else if (x instanceof Integer) {
0:                 setInt(parameterIndex, ((Integer) x).intValue());
0:             } else if (x instanceof Double) {
0:                 setDouble(parameterIndex, ((Double) x).doubleValue());
0:             } else if (x instanceof Float) {
0:                 setFloat(parameterIndex, ((Float) x).floatValue());
0:             } else if (x instanceof Boolean) {
0:                 setBoolean(parameterIndex, ((Boolean) x).booleanValue());
0:             } else if (x instanceof Long) {
0:                 setLong(parameterIndex, ((Long) x).longValue());
0:             } else if (x instanceof byte[]) {
0:                 setBytes(parameterIndex, (byte[]) x);
0:             } else if (x instanceof java.math.BigDecimal) {
0:                 setBigDecimal(parameterIndex, (java.math.BigDecimal) x);
0:             } else if (x instanceof java.sql.Date) {
0:                 setDate(parameterIndex, (java.sql.Date) x);
0:             } else if (x instanceof java.sql.Time) {
0:                 setTime(parameterIndex, (java.sql.Time) x);
0:             } else if (x instanceof java.sql.Timestamp) {
0:                 setTimestamp(parameterIndex, (java.sql.Timestamp) x);
0:             } else if (x instanceof java.sql.Blob) {
0:                 setBlob(parameterIndex, (java.sql.Blob) x);
0:             } else if (x instanceof java.sql.Clob) {
0:                 setClob(parameterIndex, (java.sql.Clob) x);
0:             } else if (x instanceof java.sql.Array) {
0:                 setArray(parameterIndex, (java.sql.Array) x);
0:             } else if (x instanceof java.sql.Ref) {
0:                 setRef(parameterIndex, (java.sql.Ref) x);
0:             } else if (x instanceof Short) {
0:                 setShort(parameterIndex, ((Short) x).shortValue());
0:             } else if (x instanceof Byte) {
0:                 setByte(parameterIndex, ((Byte) x).byteValue());
1:             } else {
0:                 checkSetterPreconditions(parameterIndex);
0:                 throw new SqlException(agent_.logWriter_, "Invalid data conversion:" +
0:                         " Parameter object type is invalid for requested conversion.");
1:             }
1:         }
0:     public void setObject(int parameterIndex, Object x, int targetJdbcType) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x, targetJdbcType);
1:             }
0:             setObjectX(parameterIndex, x, targetJdbcType, 0);
1:         }
1:     public void setObject(int parameterIndex,
1:                           Object x,
1:                           int targetJdbcType,
1:                           int scale) throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x, targetJdbcType, scale);
1:             }
0:             setObjectX(parameterIndex, x, targetJdbcType, scale);
1:         }
1:     }
1: 
1:     private void setObjectX(int parameterIndex,
1:                             Object x,
1:                             int targetJdbcType,
1:                             int scale) throws SqlException {
0:         parameterIndex = checkSetterPreconditions(parameterIndex);
1:         checkForValidScale(scale);
1: 
1:         if (x == null) {
0:             setNull(parameterIndex, targetJdbcType);
1:             return;
1:         }
0:         setObject(parameterIndex, x);
1:     }
1: 
1:     // Since parameters are cached as objects in parameters_[],
1:     // java null may be used to represent SQL null.
0:     public void clearParameters() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "clearParameters");
1:             }
0:             checkForClosedStatement();
0:             if (parameterMetaData_ != null) {
0:                 for (int i = 0; i < parameters_.length; i++) {
0:                     parameters_[i] = null;
1:                 }
1: 
0:                 for (int i = 0; i < parameterSet_.length; i++) {
0:                     parameterSet_[i] = false;
1:                 }
1:             }
1:         }
1:     }
1: 
0:     public boolean execute() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "execute");
1:             }
0:             boolean b = executeX();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "execute", b);
1:             }
0:             return b;
1:         }
1:     }
1: 
0:     private boolean executeX() throws SqlException {
1:         flowExecute(executeMethod__);
1: 
1:         return resultSet_ != null;
1:     }
1: 
1:     //--------------------------JDBC 2.0-----------------------------
1: 
0:     public void addBatch() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "addBatch");
1:             }
0:             checkForClosedStatement();
1:             checkThatAllParametersAreSet();
1: 
0:             // ASSERT: since OUT/INOUT parameters are not allowed, there should
0:             //         be no problem in sharing the JDBC Wrapper object instances
0:             //         since they will not be modified by the driver.
1: 
0:             // batch up the parameter values -- deep copy req'd
1: 
0:             if (parameterMetaData_ != null) {
0:                 Object[] inputsClone = new Object[parameters_.length];
0:                 System.arraycopy(parameters_, 0, inputsClone, 0, parameters_.length);
1: 
0:                 batch_.add(inputsClone);
1:             } else {
0:                 batch_.add(null);
1:             }
1:         }
1:     }
1: 
1:     // Batch requires that input types are exact, we perform no input cross conversion for Batch.
1:     // If so, this is an external semantic, and should go into the release notes
0:     public int[] executeBatch() throws SqlException, BatchUpdateException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "executeBatch");
1:             }
0:             int[] updateCounts = null;
0:             updateCounts = executeBatchX(false);
1: 
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "executeBatch", updateCounts);
1:             }
1:             return updateCounts;
1:         }
1:     }
1: 
0:     public java.sql.ResultSetMetaData getMetaData() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getMetaData");
1:             }
0:             ColumnMetaData resultSetMetaData = getMetaDataX();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getMetaData", resultSetMetaData);
1:             }
0:             return resultSetMetaData;
1:         }
1:     }
1: 
1:     private ColumnMetaData getMetaDataX() throws SqlException {
0:         super.checkForClosedStatement();
1:         return resultSetMetaData_;
1:     }
0:     public boolean execute(String sql, int autoGeneratedKeys) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "execute", sql, autoGeneratedKeys);
1:         }
1:         throw new SqlException(agent_.logWriter_,
0:                 "The method java.sql.Statement.execute (String sql, int autoGeneratedKeys) cannot be called on a " +
0:                 " prepared statement instance." +
0:                 " Use java.sql.PreparedStatement.execute () with no arguments.");
0:     public boolean execute(String sql, String[] columnNames) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "execute", sql, columnNames);
1:         }
1:         throw new SqlException(agent_.logWriter_,
0:                 "The method java.sql.Statement.execute (String sql, String[] columnNames) cannot be called on a " +
0:                 " prepared statement instance." +
0:                 " Use java.sql.PreparedStatement.execute () with no arguments.");
1:     }
0:     public boolean execute(String sql, int[] columnIndexes) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "execute", sql, columnIndexes);
1:         }
1:         throw new SqlException(agent_.logWriter_,
0:                 "The method java.sql.Statement.execute (String sql, int[] columnIndexes) cannot be called on a " +
0:                 " prepared statement instance." +
0:                 " Use java.sql.PreparedStatement.execute () with no arguments.");
1:     }
0:     public int executeUpdate(String sql, int autoGeneratedKeys) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "executeUpdate", autoGeneratedKeys);
1:         }
1:         throw new SqlException(agent_.logWriter_,
0:                 "The method java.sql.Statement.executeUpdate (String sql, int autoGeneratedKeys) cannot be called on a " +
0:                 " prepared statement instance." +
0:                 " Use java.sql.PreparedStatement.executeUpdate () with no arguments.");
1:     }
1: 
0:     public int executeUpdate(String sql, String[] columnNames) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "executeUpdate", columnNames);
1:         }
1:         throw new SqlException(agent_.logWriter_,
0:                 "The method java.sql.Statement.executeUpdate (String sql, String[] columnNames) cannot be called on a " +
0:                 " prepared statement instance." +
0:                 " Use java.sql.PreparedStatement.executeUpdate () with no arguments.");
1:     }
1: 
0:     public int executeUpdate(String sql, int[] columnIndexes) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "executeUpdate", columnIndexes);
1:         }
1:         throw new SqlException(agent_.logWriter_,
0:                 "The method java.sql.Statement.executeUpdate (String sql, int[] columnIndexes) cannot be called on a " +
0:                 " prepared statement instance." +
0:                 " Use java.sql.PreparedStatement.executeUpdate () with no arguments.");
1:     }
1: 
0:     public void setURL(int parameterIndex, java.net.URL x) throws SqlException {
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceEntry(this, "setURL", parameterIndex, x);
1:         }
0:         throw new SqlException(agent_.logWriter_, "JDBC 3 method called - not yet supported");
1:     }
1: 
0:     public java.sql.ParameterMetaData getParameterMetaData() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "getParameterMetaData");
1:             }
0:             Object parameterMetaData = getParameterMetaDataX();
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceExit(this, "getParameterMetaData", parameterMetaData);
1:             }
0:             return (java.sql.ParameterMetaData) parameterMetaData;
1:         }
1:     }
1: 
0:     private ParameterMetaData getParameterMetaDataX() throws SqlException {
0:         super.checkForClosedStatement();
0:         ParameterMetaData pm = new ParameterMetaData(parameterMetaData_ != null
0:                 ? parameterMetaData_
0:                 : new ColumnMetaData(agent_.logWriter_, 0));
0:         if (escapedProcedureCallWithResult_) {
0:             pm.escapedProcedureCallWithResult_ = true;
1:         }
1:         return pm;
1:     }
1: 
1:     // ------------------------ box car and callback methods --------------------------------
1: 
0:     public void writeExecute(Section section,
1:                              ColumnMetaData parameterMetaData,
1:                              Object[] inputs,
1:                              int numInputColumns,
1:                              boolean outputExpected,
1:                              // This is a hint to the material layer that more write commands will follow.
1:                              // It is ignored by the driver in all cases except when blob data is written,
1:                              // in which case this boolean is used to optimize the implementation.
1:                              // Otherwise we wouldn't be able to chain after blob data is sent.
1:                              // Current servers have a restriction that blobs can only be chained with blobs
1:                              boolean chainedWritesFollowingSetLob) throws SqlException {
1:         materialPreparedStatement_.writeExecute_(section,
1:                 parameterMetaData,
1:                 inputs,
1:                 numInputColumns,
1:                 outputExpected,
1:                 chainedWritesFollowingSetLob);
1:     }
1: 
1: 
0:     public void readExecute() throws SqlException {
1:         materialPreparedStatement_.readExecute_();
1:     }
1: 
0:     public void writeOpenQuery(Section section,
1:                                int fetchSize,
1:                                int resultSetType,
1:                                int numInputColumns,
1:                                ColumnMetaData parameterMetaData,
1:                                Object[] inputs) throws SqlException {
1:         materialPreparedStatement_.writeOpenQuery_(section,
1:                 fetchSize,
1:                 resultSetType,
1:                 numInputColumns,
1:                 parameterMetaData,
1:                 inputs);
1:     }
1: 
0:     public void writeDescribeInput(Section section) throws SqlException {
1:         materialPreparedStatement_.writeDescribeInput_(section);
1:     }
1: 
0:     public void readDescribeInput() throws SqlException {
1:         materialPreparedStatement_.readDescribeInput_();
1:     }
1: 
1:     public void completeDescribeInput(ColumnMetaData parameterMetaData, Sqlca sqlca) {
1:         int sqlcode = super.completeSqlca(sqlca);
1:         if (sqlcode < 0) {
1:             return;
1:         }
1: 
1: 
1:         parameterMetaData_ = parameterMetaData;
1: 
1:         // The following code handles the case when
1:         // sqlxParmmode is not supported, in which case server will return 0 (unknown), and
1:         // this could clobber our guessed value for sqlxParmmode.  This is a problem.
1:         // We can solve this problem for Non-CALL statements, since the parmmode is always IN (1).
1:         // But what about CALL statements.  If CALLs are describable, then we have no
1:         // problem, we assume server won't return unknown.
1:         // If CALLs are not describable then nothing gets clobbered because we won't
1:         // parse out extended describe, so again  no problem.
1:         if (sqlMode_ != isCall__ && parameterMetaData_ != null) {
1:             for (int i = 0; i < parameterMetaData_.columns_; i++) {
0:                 parameterMetaData_.sqlxParmmode_[i] = 1;  // 1 means IN parameter
1:             }
1:         }
1: 
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceParameterMetaData(this, parameterMetaData_);
1:         }
1:     }
1: 
0:     public void writeDescribeOutput(Section section) throws SqlException {
0:         materialPreparedStatement_.writeDescribeOutput_(section);
1:     }
1: 
0:     public void readDescribeOutput() throws SqlException {
0:         materialPreparedStatement_.readDescribeOutput_();
1:     }
1: 
1:     public void completeDescribeOutput(ColumnMetaData resultSetMetaData, Sqlca sqlca) {
1:         int sqlcode = super.completeSqlca(sqlca);
1:         if (sqlcode < 0) {
1:             return;
1:         }
1:         resultSetMetaData_ = resultSetMetaData;
1:         if (agent_.loggingEnabled()) {
1:             agent_.logWriter_.traceResultSetMetaData(this, resultSetMetaData);
1:         }
1:     }
1: 
0:     void writePrepareDescribeInputOutput() throws SqlException {
1:         // Notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
0:         writePrepareDescribeOutput(sql_, section_);
0:         writeDescribeInput(section_);
1:     }
1: 
0:     void readPrepareDescribeInputOutput() throws SqlException {
1:         readPrepareDescribeOutput();
1:         readDescribeInput();
1:         completePrepareDescribe();
1:     }
1: 
0:     void writePrepareDescribeInput() throws SqlException {
1:         // performance will be better if we flow prepare with output enable vs. prepare then describe input for callable
1:         // Notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
0:         writePrepare(sql_, section_);
0:         writeDescribeInput(section_);
1:     }
1: 
0:     void readPrepareDescribeInput() throws SqlException {
1:         readPrepare();
1:         readDescribeInput();
1:         completePrepareDescribe();
1:     }
1: 
0:     void completePrepareDescribe() {
1:         if (parameterMetaData_ == null) {
1:             return;
1:         }
1:         parameters_ = expandObjectArray(parameters_, parameterMetaData_.columns_);
1:         parameterSet_ = expandBooleanArray(parameterSet_, parameterMetaData_.columns_);
1:         parameterRegistered_ = expandBooleanArray(parameterRegistered_, parameterMetaData_.columns_);
1:     }
1: 
1:     private Object[] expandObjectArray(Object[] array, int newLength) {
1:         if (array == null) {
1:             Object[] newArray = new Object[newLength];
1:             return newArray;
1:         }
1:         if (array.length < newLength) {
1:             Object[] newArray = new Object[newLength];
1:             System.arraycopy(array, 0, newArray, 0, array.length);
1:             return newArray;
1:         }
1:         return array;
1:     }
1: 
1:     private boolean[] expandBooleanArray(boolean[] array, int newLength) {
1:         if (array == null) {
1:             boolean[] newArray = new boolean[newLength];
1:             return newArray;
1:         }
1:         if (array.length < newLength) {
1:             boolean[] newArray = new boolean[newLength];
1:             System.arraycopy(array, 0, newArray, 0, array.length);
1:             return newArray;
1:         }
1:         return array;
1:     }
1: 
0:     void flowPrepareForSelectFromInsert() throws SqlException {
1:         agent_.beginWriteChain(this);
0:         writePrepareDescribeInputOutput(constructSelectFromInsertSQL(sql_), section_);
1:         agent_.flow(this);
1:         readPrepareDescribeInputOutput();
1:         agent_.endReadChain();
1:     }
1: 
0:     void writePrepareDescribeInputOutput(String sql,
1:                                          Section section) throws SqlException {
1:         // Notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
0:         writePrepareDescribeOutput(sql, section);
0:         writeDescribeInput(section);
1:     }
1: 
1:     void flowPrepareDescribeInputOutput() throws SqlException {
1:         agent_.beginWriteChain(this);
1:         if (sqlMode_ == isCall__) {
1:             writePrepareDescribeInput();
1:             agent_.flow(this);
1:             readPrepareDescribeInput();
1:             agent_.endReadChain();
1:         } else {
1:             writePrepareDescribeInputOutput();
1:             agent_.flow(this);
1:             readPrepareDescribeInputOutput();
1:             agent_.endReadChain();
1:         }
1:     }
1: 
0:     void flowExecute(int executeType) throws SqlException {
0:         super.checkForClosedStatement();
0:         super.clearWarningsX();
0:         super.checkForAppropriateSqlMode(executeType, sqlMode_);
1:         checkThatAllParametersAreSet();
1: 
1:         if (sqlMode_ == isUpdate__) {
1:             updateCount_ = 0;
1:         } else {
1:             updateCount_ = -1;
1:         }
1: 
0:         java.util.Timer queryTimer = null;
0:         QueryTimerTask queryTimerTask = null;
0:         if (timeout_ != 0) {
0:             queryTimer = new java.util.Timer(); // A thread that ticks the seconds
0:             queryTimerTask = new QueryTimerTask(this, queryTimer);
0:             queryTimer.schedule(queryTimerTask, 1000 * timeout_);
1:         }
1: 
1:         try {
1:             agent_.beginWriteChain(this);
1: 
0:             boolean piggybackedAutocommit = super.writeCloseResultSets(true);  // true means permit auto-commits
1: 
1: 
0:             int numInputColumns = (parameterMetaData_ != null) ? parameterMetaData_.getColumnCount() : 0;
0:             boolean outputExpected = (resultSetMetaData_ != null && resultSetMetaData_.getColumnCount() > 0);
1:             boolean chainAutoCommit = false;
1:             boolean commitSubstituted = false;
1:             boolean repositionedCursor = false;
0:             ResultSet scrollableRS = null;
1: 
1:             switch (sqlMode_) {
1:             case isUpdate__:
1:                 if (positionedUpdateCursorName_ != null) {
1:                     scrollableRS = agent_.sectionManager_.getPositionedUpdateResultSet(positionedUpdateCursorName_);
1:                 }
1:                 if (scrollableRS != null && !scrollableRS.isRowsetCursor_) {
1:                     repositionedCursor =
1:                             scrollableRS.repositionScrollableResultSetBeforeJDBC1PositionedUpdateDelete();
1:                     if (!repositionedCursor) {
1:                         scrollableRS = null;
1:                     }
1:                 }
1: 
1:                 chainAutoCommit = connection_.willAutoCommitGenerateFlow() && isAutoCommittableStatement_;
1: 
0:                 if (sqlUpdateMode_ == isInsertSql__ && generatedKeysColumnNames_ != null) {
0:                     writeOpenQuery(section_,
1:                             fetchSize_,
1:                             resultSetType_,
1:                             numInputColumns,
1:                             parameterMetaData_,
1:                             parameters_);
1:                 } else {
0:                     boolean chainOpenQueryForAutoGeneratedKeys = (sqlUpdateMode_ == isInsertSql__ && autoGeneratedKeys_ == RETURN_GENERATED_KEYS);
0:                     writeExecute(section_,
1:                             parameterMetaData_,
1:                             parameters_,
0:                             (chainAutoCommit || chainOpenQueryForAutoGeneratedKeys)// chain flag
0:                     ); // chain flag
0:                     if (chainOpenQueryForAutoGeneratedKeys) {
0:                         prepareAutoGeneratedKeysStatement();
0:                         writeOpenQuery(preparedStatementForAutoGeneratedKeys_.section_,
0:                                 preparedStatementForAutoGeneratedKeys_.fetchSize_,
0:                                 preparedStatementForAutoGeneratedKeys_.resultSetType_);
1:                     }
1:                 }
1:                 if (chainAutoCommit) {
1:                     // we have encountered an error in writing the execute, so do not
1:                     // flow an autocommit
1:                     if (agent_.accumulatedReadExceptions_ != null) {
1:                         // currently, the only write exception we encounter is for
1:                         // data truncation: SQLSTATE 01004, so we don't bother checking for this
1:                         connection_.writeCommitSubstitute_();
1:                         commitSubstituted = true;
1:                     } else {
1:                         // there is no write error, so flow the commit
1:                         connection_.writeCommit();
1:                     }
1:                 }
1:                 break;
1:             case isQuery__:
0:                 writeOpenQuery(section_,
1:                         fetchSize_,
1:                         resultSetType_,
1:                         numInputColumns,
1:                         parameterMetaData_,
1:                 break;
1:             case isCall__:
1:                 writeExecuteCall(outputRegistered_, // if no out/inout parameter, outputExpected = false
0:                         null,
0:                         section_,
1:                         fetchSize_,
1:                         false, // do not suppress ResultSets for regular CALLs
1:                         resultSetType_,
1:                         parameterMetaData_,
1:                         parameters_); // cross conversion
1:                 break;
1:             }
1:             agent_.flow(this);
1:             super.readCloseResultSets(true);  // true means permit auto-commits
1:             // turn inUnitOfWork_ flag back on and add statement
1:             // back on commitListeners_ list if they were off
1:             // by an autocommit chained to a close cursor.
1:             if (piggybackedAutocommit) {
1:                 connection_.completeTransactionStart();
1:             }
0:             super.markResultSetsClosed();
1:             switch (sqlMode_) {
1:             case isUpdate__:
1:                 // do not need to reposition for a rowset cursor
1:                 if (scrollableRS != null && !scrollableRS.isRowsetCursor_) {
1:                     scrollableRS.readPositioningFetch_();
1:                 }
0:                 if (sqlUpdateMode_ == isInsertSql__ && generatedKeysColumnNames_ != null) {
1:                     readOpenQuery();
1:                     if (resultSet_ != null) {
0:                         generatedKeysResultSet_ = resultSet_;
0:                         resultSet_ = null;
0:                         updateCount_ = 1;
1:                     }
1:                 } else {
1:                     readExecute();
1: 
0:                     if (sqlUpdateMode_ == isInsertSql__ && autoGeneratedKeys_ == RETURN_GENERATED_KEYS) {
0:                         readPrepareAutoGeneratedKeysStatement();
1:                         preparedStatementForAutoGeneratedKeys_.readOpenQuery();
1:                         generatedKeysResultSet_ = preparedStatementForAutoGeneratedKeys_.resultSet_;
1:                         preparedStatementForAutoGeneratedKeys_.resultSet_ = null;
1:                     }
1:                 }
1: 
1:                 if (chainAutoCommit) {
1:                     if (commitSubstituted) {
1:                         connection_.readCommitSubstitute_();
1:                     } else {
1:                         connection_.readCommit();
1:                     }
1:                 }
1:                 break;
1: 
1:             case isQuery__:
1:                 try {
1:                     readOpenQuery();
1:                 } catch (DisconnectException dise) {
1:                     throw dise;
1:                 } catch (SqlException e) {
1:                     throw e;
1:                 }
1:                 // resultSet_ is null if open query failed.
1:                 // check for null resultSet_ before using it.
1:                 if (resultSet_ != null) {
1:                     resultSet_.parseScrollableRowset();
1:                     //if (resultSet_.scrollable_) resultSet_.getRowCount();
0:                     // If client's cursor name is set, map the client's cursor name to the ResultSet
0:                     // Else map the server's cursor name to the ResultSet
0:                     mapCursorNameToResultSet();
1:                 }
1:                 break;
1: 
1:             case isCall__:
1:                 readExecuteCall();
1:                 break;
1: 
1:             }
1: 
1: 
1:             try {
1:                 agent_.endReadChain();
1:             } catch (SqlException e) {
1:                 throw e;
1: 
1:             }
1: 
1:             if (sqlMode_ == isCall__) {
1:                 parseStorProcReturnedScrollableRowset();
1:                 // When there are no result sets back, we will commit immediately when autocommit is true.
1:                 // make sure a commit is not performed when making the call to the sqlca message procedure
1:                 if (connection_.autoCommit_ && resultSet_ == null && resultSetList_ == null && isAutoCommittableStatement_) {
1:                     connection_.flowAutoCommit();
1:                 }
1:             }
1: 
1:             // Throw an exception if holdability returned by the server is different from requested.
1:             if (resultSet_ != null && resultSet_.resultSetHoldability_ != resultSetHoldability_ && sqlMode_ != isCall__) {
0:                 throw new SqlException(agent_.logWriter_, "Unable to open resultSet with requested " +
0:                         "holdability " + resultSetHoldability_ + ".");
1:             }
1: 
0:         } finally {
0:             if (timeout_ != 0) { // query timers need to be cancelled.
0:                 queryTimer.cancel();
0:                 queryTimerTask.cancel();
1:             }
0:     public int[] executeBatchX(boolean supportsQueryBatchRequest) throws SqlException, BatchUpdateException {
0:         synchronized (connection_) {
1:             checkForClosedStatement(); // Per jdbc spec (see Statement.close() javadoc)
1:             clearWarningsX(); // Per jdbc spec 0.7, also see getWarnings() javadoc
1:             return executeBatchRequestX(supportsQueryBatchRequest);
1:         }
0:     private int[] executeBatchRequestX(boolean supportsQueryBatchRequest)
0:             throws SqlException, BatchUpdateException {
1:         SqlException chainBreaker = null;
1:         int batchSize = batch_.size();
0:         int[] updateCounts = new int[batchSize];
0:         int numInputColumns = parameterMetaData_ == null ? 0 : parameterMetaData_.getColumnCount();
1:         Object[] savedInputs = null;  // used to save/restore existing parameters
1:         if (batchSize == 0) {
1:             return updateCounts;
1:         }
1:         // Initialize all the updateCounts to indicate failure
1:         // This is done to account for "chain-breaking" errors where we cannot
1:         // read any more replies
1:         for (int i = 0; i < batchSize; i++) {
1:             updateCounts[i] = -3;
1:         }
1:         if (!supportsQueryBatchRequest && sqlMode_ == isQuery__) {
0:             throw new BatchUpdateException(agent_.logWriter_, "Batching of queries not allowed by J2EE compliance", updateCounts);
1:         }
1:         if (supportsQueryBatchRequest && sqlMode_ != isQuery__) {
0:             throw new BatchUpdateException(agent_.logWriter_, "Query batch requested on a non-query statement", updateCounts);
1:         }
1:         resultSetList_ = null;
1: 
1: 
1:         if (sqlMode_ == isQuery__) {
0:             indexOfCurrentResultSet_ = -1; //reset ResultSetList
0:             resultSetList_ = new ResultSet[batchSize];
1:         }
1: 
1: 
1:         //save the current input set so it can be restored
1:         savedInputs = parameters_;
1: 
1:         agent_.beginBatchedWriteChain(this);
1:         boolean chainAutoCommit = connection_.willAutoCommitGenerateFlow() && isAutoCommittableStatement_;
1: 
1:         for (int i = 0; i < batchSize; i++) {
1:             parameters_ = (Object[]) batch_.get(i);
1: 
1:             if (sqlMode_ != isCall__) {
0:                 boolean outputExpected = (resultSetMetaData_ != null && resultSetMetaData_.getColumnCount() > 0);
1: 
0:                 writeExecute(section_,
1:             } else if (outputRegistered_) // make sure no output parameters are registered
0:             {
0:                 throw new BatchUpdateException(agent_.logWriter_, "No output parameters are allowed in batch updates", updateCounts);
1:             } else {
1:                 writeExecuteCall(false, // no output expected for batched CALLs
0:                         null, // no procedure name supplied for prepared CALLs
0:                         section_,
1:                         fetchSize_,
1:                         true, // suppress ResultSets for batch
1:                         resultSetType_,
1:                         parameterMetaData_,
1:                         parameters_);
1:             }
1:         boolean commitSubstituted = false;
1:         if (chainAutoCommit) {
1:             // we have encountered an error in writing the execute, so do not
1:             // flow an autocommit
1:             if (agent_.accumulatedReadExceptions_ != null) {
1:                 // currently, the only write exception we encounter is for
1:                 // data truncation: SQLSTATE 01004, so we don't bother checking for this
1:                 connection_.writeCommitSubstitute_();
1:                 commitSubstituted = true;
1:             } else {
1:                 // there is no write error, so flow the commit
1:                 connection_.writeCommit();
1:             }
1: 
1:         agent_.flowBatch(this, batchSize);
1: 
1:         try {
1:             for (int i = 0; i < batchSize; i++) {
1:                 agent_.setBatchedExceptionLabelIndex(i);
1:                 parameters_ = (Object[]) batch_.get(i);
1:                 if (sqlMode_ != isCall__) {
1:                     readExecute();
1:                 } else {
1:                     readExecuteCall();
1:                 }
1:                 updateCounts[i] = updateCount_;
1: 
1:             }
1: 
1:             agent_.disableBatchedExceptionTracking(); // to prvent the following readCommit() from getting a batch label
1:             if (chainAutoCommit) {
1:                 if (!commitSubstituted) {
1:                     connection_.readCommit();
1:                 } else {
1:                     connection_.readCommitSubstitute_();
1:                 }
1:             }
1: 
1:                 // for chain-breaking exception only, all read() methods do their own accumulation
1:                 // this catches the entire accumulated chain, we need to be careful not to
1:                 // reaccumulate it on the agent since the batch labels will be overwritten if
1:                 // batch exception tracking is enabled.
1:         catch (SqlException e) { // for chain-breaking exception only
1:             chainBreaker = e;
1:             chainBreaker.setNextException(new SqlException(agent_.logWriter_,
0:                     "Non-recoverable chain-breaking exception occurred during batch processing.  " +
0:                     "The batch is terminated non-atomically."));
1:         }
1:         // We need to clear the batch before any exception is thrown from agent_.endBatchedReadChain().
1:         batch_.clear();
1: 
1:         // restore the saved input set, setting it to "current"
1:         parameters_ = savedInputs;
1: 
1:         agent_.endBatchedReadChain(updateCounts, chainBreaker);
1: 
1:         return updateCounts;
1: 
1: 
1:     //------------------material layer event callbacks follow-----------------------
1: 
0:     boolean listenToUnitOfWork_ = false;
1: 
1:     public void listenToUnitOfWork() {
1:         if (!listenToUnitOfWork_) {
1:             listenToUnitOfWork_ = true;
0:             connection_.CommitAndRollbackListeners_.add(this);
1:         }
0:     public void completeLocalCommit(java.util.Iterator listenerIterator) {
0:         if (section_ != null) {
0:             openOnServer_ = false;
1:         }
1:         listenerIterator.remove();
1:         listenToUnitOfWork_ = false;
0:     public void completeLocalRollback(java.util.Iterator listenerIterator) {
0:         if (section_ != null) {
0:             openOnServer_ = false;
1:         }
1:         listenerIterator.remove();
1:         listenToUnitOfWork_ = false;
1:     //----------------------------internal use only helper methods----------------
0:     private int checkSetterPreconditions(int parameterIndex) throws SqlException {
0:         super.checkForClosedStatement();
0:         parameterIndex = checkForEscapedCallWithResult(parameterIndex);
0:         checkForValidParameterIndex(parameterIndex);
0:         return parameterIndex;
1:     void checkForValidParameterIndex(int parameterIndex) throws SqlException {
0:         if (parameterMetaData_ == null || parameterIndex < 1 || parameterIndex > parameterMetaData_.columns_) {
0:             throw new SqlException(agent_.logWriter_, "Invalid argument: parameter index " +
0:                     parameterIndex + " is out of range.");
1:         }
1: 
1:     private void checkThatAllParametersAreSet() throws SqlException {
0:         if (parameterMetaData_ != null) {
1:             for (int i = 0; i < parameterMetaData_.columns_; i++) {
0:                 if (!parameterSet_[i] && !parameterRegistered_[i]) {
0:                     throw new SqlException(agent_.logWriter_, "At least one parameter to the current statement is uninitialized.", "07000");
1:                 }
1:             }
1:         }
1: 
0:     private int checkForEscapedCallWithResult(int parameterIndex) throws SqlException {
0:         if (escapedProcedureCallWithResult_) {
0:             if (parameterIndex == 1) {
1:                 throw new SqlException(agent_.logWriter_,
0:                         "Invalid attempt to set the return value parameter of a CALL statement." +
0:                         "Return value parameter of {?=CALL foo(?,?)} statement is parameter 1.");
1:             } else {
0:                 parameterIndex--;
1:             }
1:         }
0:         return parameterIndex;
1:     void checkForValidScale(int scale) throws SqlException {
1:         if (scale < 0 || scale > 31) {
0:             throw new SqlException(agent_.logWriter_, "Invalid argument: scale must be greater than or equal to 0 and less than 32.");
1:         }
0:     void checkScaleForINOUTDecimal(int parameterIndex, int registerOutScale) throws SqlException {
0:         java.math.BigDecimal decimalInput = (java.math.BigDecimal) parameters_[parameterIndex - 1];
0:         if (decimalInput == null) {
1:             return;
1:         }
0:         // if the register out scale is greater than input scale, input scale is stored in sqlScale_
0:         if (registerOutScale > parameterMetaData_.sqlScale_[parameterIndex - 1]) {
0:             int inputLength = decimalInput.toString().length();
0:             int scaleDifference = registerOutScale - decimalInput.scale();
0:             if (decimalInput.signum() == -1) {
0:                 inputLength--;
1:             }
0:             // if the new Decimal (with bigger scale) cannot fit into the DA
0:             if ((32 - scaleDifference) < inputLength) {
0:                 throw new SqlException(agent_.logWriter_, "The scale supplied by the registerOutParameter method does " +
0:                         "not match with the setter method. Possible loss of precision!");
1:             }
0:             // if the new Decimal (with bigger scale) can fit
0:             else {
0:                 parameters_[parameterIndex - 1] = decimalInput.setScale(registerOutScale);
0:                 parameterMetaData_.sqlScale_[parameterIndex - 1] = registerOutScale;
1:             }
1:         }
0:         // if the register out sacle is smaller than input scale
0:         else if (registerOutScale < parameterMetaData_.sqlScale_[parameterIndex - 1]) {
0:             // remove 0's at the end of input
1:             try {
0:                 // if the new Decimal (with smaller scale) can fit
0:                 parameters_[parameterIndex - 1] = decimalInput.setScale(registerOutScale);
0:                 parameterMetaData_.sqlScale_[parameterIndex - 1] = registerOutScale;
0:             } catch (ArithmeticException e) {
0:                 // if the new Decimal (with smaller scale) cannot fit into the DA
0:                 throw new SqlException(agent_.logWriter_, "The scale supplied by the registerOutParameter method does " +
0:                         "not match with the setter method. Possible loss of precision!");
1:             }
1:         }
1:     }
0:     public void close() throws SqlException {
0:         synchronized (connection_) {
1:             if (agent_.loggingEnabled()) {
0:                 agent_.logWriter_.traceEntry(this, "close");
1:             }
0:             closeX();
1:         }
1:     }
1: 
0:     // An untraced version of close()
0:     public void closeX() throws SqlException {
0:         if (!openOnClient_) {
1:             return;
1:         }
0:         super.closeX();
0:         if (parameterMetaData_ != null) {
1:             parameterMetaData_.markClosed();
1:             parameterMetaData_ = null;
1:         }
1:         sql_ = null;
1: 
1:         // Apparently, the JVM is not smart enough to traverse parameters_[] and null
1:         // out its members when the entire array is set to null (parameters_=null;).
1:         if (parameters_ != null) {
0:             for (int i = 0; i < parameters_.length; i++) {
0:                 parameters_[i] = null;
1:             }
1:         }
1:         parameters_ = null;
1: 
0:         connection_.CommitAndRollbackListeners_.remove(this);
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class org.apache.derby.client.am.PreparedStatement
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0: */
1: 
1: package org.apache.derby.client.am;
1: 
0: import org.apache.derby.client.am.Section;
1: 
0: public class PreparedStatement extends Statement
0:                                implements java.sql.PreparedStatement,
0:                                           PreparedStatementCallbackInterface
0: {
0:   //---------------------navigational cheat-links-------------------------------
0:   // Cheat-links are for convenience only, and are not part of the conceptual model.
0:   // Warning:
0:   //   Cheat-links should only be defined for invariant state data.
0:   //   That is, the state data is set by the constructor and never changes.
1: 
0:   // Alias for downcast (MaterialPreparedStatementProxy) super.materialStatement.
0:   public MaterialPreparedStatement materialPreparedStatement_ = null;
1: 
0:   //-----------------------------state------------------------------------------
1: 
0:   public String sql_;
1: 
0:   // This variable is only used by Batch.
0:   // True if a call sql statement has an OUT or INOUT parameter registered.
0:   public boolean outputRegistered_ = false;
1: 
0:   // Parameter inputs are cached as objects so they may be sent on execute()
0:   public Object[] parameters_;
1: 
0:   boolean[] parameterSet_;
0:   boolean[] parameterRegistered_;
1: 
0:   void setInput (int parameterIndex, Object input)
0:   { parameters_[parameterIndex-1] = input; parameterSet_[parameterIndex-1] = true; }
1: 
0:   public ColumnMetaData parameterMetaData_; // type information for input sqlda
1: 
1: 
0:   // The problem with storing the scrollable ResultSet associated with cursorName in scrollableRS_ is
0:   // that when the PreparedStatement is re-executed, it has a new ResultSet, however, we always do
0:   // the reposition on the ResultSet that was stored in scrollableRS_, and we never update scrollableRS_
0:   // when PreparedStatement is re-execute.  So the new ResultSet that needs to be repositioned never
0:   // gets repositioned.
0:   // So instead of caching the scrollableRS_, we will cache the cursorName.  And re-retrieve the scrollable
0:   // result set from the map using this cursorName every time the PreparedStatement excutes.
0:   String positionedUpdateCursorName_ = null;
1: 
1: 
0:   private void initPreparedStatement()
0:   {
0:     materialPreparedStatement_ = null;
0:     sql_ = null;
0:     outputRegistered_ = false;
0:     parameters_ = null;
0:     parameterSet_ = null;
0:     parameterRegistered_ = null;
0:     parameterMetaData_ = null;
0:     isAutoCommittableStatement_ = true;
0:     isPreparedStatement_ = true;
0:   }
1: 
0:   protected void initResetPreparedStatement()
0:   {
0:     outputRegistered_ = false;
0:     isPreparedStatement_ = true;
1: 
0:     if (parameterMetaData_ != null)
0:       resetParameters();
0:   }
1: 
0:   public void reset (boolean fullReset) throws SqlException
0:   {
0:     if (fullReset)
0:       connection_.resetPrepareStatement (this);
0:     else {
0:       super.initResetPreparedStatement();
0:       initResetPreparedStatement();
0:     }
0:   }
1: 
0:   private void resetParameters ()
0:   {
0:     for (int i = 0; i < parameterMetaData_.columns_; i++) {
0:       parameters_[i] = null;
0:       parameterSet_[i] = false;
0:       parameterRegistered_[i] = false;
0:     }
0:   }
1: 
0:   // For for JDBC 2 positioned update statements.
0:   // Called by material statement constructors.
0:   public PreparedStatement (Agent agent,
0:                             Connection connection,
0:                             String sql,
0:                             Section section) throws SqlException
0:   {
0:     super (agent, connection);
0:     initPreparedStatement (sql, section);
0:   }
1: 
0:   public void resetPreparedStatement (Agent agent,
0:                                       Connection connection,
0:                                       String sql,
0:                                       Section section) throws SqlException
0:   {
0:     super.resetStatement(agent, connection);
0:     initPreparedStatement();
0:     initPreparedStatement (sql, section);
0:   }
1: 
0:   private void initPreparedStatement (String sql, Section section) throws SqlException
0:   {
0:     sql_ = sql;
0:     isPreparedStatement_ = true;
1: 
0:     parseSqlAndSetSqlModes (sql_);
0:     section_ = section;
0:   }
1: 
0:   // Constructor for jdbc 2 prepared statements with scroll attributes.
0:   // Called by material statement constructors.
0:   public PreparedStatement (Agent agent,
0:                             Connection connection,
0:                             String sql,
0:                             int type, int concurrency, int holdability, int autoGeneratedKeys, String[] columnNames) throws SqlException
0:   {
0:     super (agent, connection, type, concurrency, holdability, autoGeneratedKeys, columnNames);
0:     initPreparedStatement (sql);
0:   }
1: 
0:   public void resetPreparedStatement (Agent agent,
0:                                       Connection connection,
0:                                       String sql,
0:                                       int type, int concurrency, int holdability, int autoGeneratedKeys, String[] columnNames) throws SqlException
0:   {
0:     super.resetStatement(agent, connection, type, concurrency, holdability, autoGeneratedKeys, columnNames);
0:     initPreparedStatement();
0:     initPreparedStatement (sql);
0:   }
1: 
0:   private void initPreparedStatement ( String sql) throws SqlException
0:   {
0:     sql_ = super.escape (sql);
0:     parseSqlAndSetSqlModes (sql_);
0:     isPreparedStatement_ = true;
1: 
0:     // Check for positioned update statement and assign a section from the
0:     // same package as the corresponding query section.
0:     // Scan the sql for an "update...where current of <cursor-name>".
0:     String cursorName = null;
0:     if(sqlUpdateMode_ == isDeleteSql__ || sqlUpdateMode_ == isUpdateSql__) {
0:       String[] sqlAndCursorName = extractCursorNameFromWhereCurrentOf (sql_);
0:       if(sqlAndCursorName != null) {
0:         cursorName = sqlAndCursorName[0];
0:         sql_ = sqlAndCursorName[1];
0:       }
0:     }
0:     if (cursorName != null) {
0:       positionedUpdateCursorName_ = cursorName;
0:       // Get a new section from the same package as the query section
0:       section_ = agent_.sectionManager_.getPositionedUpdateSection (cursorName, false); // false means get a regular section
1: 
0:       if (section_ == null)
0:         throw new SqlException (agent_.logWriter_, "Invalid cursor name \"" + cursorName + "\" in the Update/Delete statement.");
1: 
0:       //scrollableRS_ = agent_.sectionManager_.getPositionedUpdateResultSet (cursorName);
1: 
0:       // if client's cursor name is set, and the cursor name in the positioned update
0:       // string is the same as the client's cursor name, replace client's cursor name
0:       // with the server's cursor name.
0:       // if the cursor name supplied in the sql string is different from the cursorName
0:       // set by setCursorName(), then server will return "cursor name not defined" error,
0:       // and no subsititution is made here.
0:       if (section_.getClientCursorName() != null && // cursor name is user defined
0:           cursorName.compareTo (section_.getClientCursorName()) == 0)
0:         // client's cursor name is substituted with section's server cursor name
0:         sql_ = substituteClientCursorNameWithServerCursorName (sql_, section_);
0:     }
0:     else {
0:       // We don't need to analyze the sql text to determine if it is a query or not.
0:       // This is up to the server to decide, we just pass thru the sql on flowPrepare().
0:       section_ = agent_.sectionManager_.getDynamicSection (resultSetHoldability_);
0:     }
0:   }
1: 
0:   public void resetPreparedStatement (Agent agent,
0:                                       Connection connection,
0:                                       String sql,
0:                                       Section section,
0:                                       ColumnMetaData parameterMetaData,
0:                                       ColumnMetaData resultSetMetaData) throws SqlException
0:   {
0:     resetPreparedStatement (agent, connection, sql, section);
0:     initPreparedStatement (parameterMetaData, resultSetMetaData);
0:   }
1: 
0:   private void initPreparedStatement (
0:                                       ColumnMetaData parameterMetaData,
0:                                       ColumnMetaData resultSetMetaData) throws SqlException
0:   {
0:     isPreparedStatement_ = true;
0:     parameterMetaData_ = parameterMetaData;
0:     resultSetMetaData_ = resultSetMetaData;
0:     if(parameterMetaData_ != null) {
0:     parameters_ = new Object[parameterMetaData_.columns_];
0:     //parameterSetOrRegistered_ = new boolean[parameterMetaData_.columns_];
0:     parameterSet_ = new boolean[parameterMetaData_.columns_];
0:     parameterRegistered_ = new boolean[parameterMetaData_.columns_];
0:   }
0:   }
1: 
0:   protected void finalize () throws java.lang.Throwable
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "finalize");
0:     if (openOnClient_) { 
0:       synchronized (connection_) {
0:         closeX();
0:       }
0:     }
0:     super.finalize();
0:   }
1: 
0:   // called immediately after the constructor by Connection prepare*() methods
0:   void prepare () throws SqlException
0:   {
0:     try {
0: 		// flow prepare, no static initialization is needed
0:         // already checked if columnNames is not null and server supports select from insert
0:         // in prepareStatementX()
0:         if (sqlUpdateMode_ == isInsertSql__ && generatedKeysColumnNames_ != null)
0:           flowPrepareForSelectFromInsert ();
0:         else
0:           flowPrepareDescribeInputOutput();
0:     }
0:     catch (SqlException e) {
0:       this.markClosed();
0:       throw e;
0:     }
0:   }
1: 
1: 
0:   //------------------- Prohibited overrides from Statement --------------------
1: 
0:   public boolean execute (String sql) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "execute", sql);
0:     throw new SqlException (agent_.logWriter_,
0:       "The method java.sql.Statement.execute (String sql) cannot be called on a " +
0:       " prepared statement instance." +
0:       " Use java.sql.PreparedStatement.execute () with no sql string argument.");
0:   }
1: 
0:   public java.sql.ResultSet executeQuery (String sql) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeQuery", sql);
0:     throw new SqlException (agent_.logWriter_,
0:       "The method java.sql.Statement.executeQuery (String sql) cannot be called on a " +
0:       " prepared statement instance." +
0:       " Use java.sql.PreparedStatement.executeQuery () with no sql string argument.");
0:   }
1: 
0:   public int executeUpdate (String sql) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeUpdate", sql);
0:     throw new SqlException (agent_.logWriter_,
0:       "The method java.sql.Statement.executeUpdate (String sql) cannot be called on a " +
0:       " prepared statement instance." +
0:       " Use java.sql.PreparedStatement.executeUpdate () with no sql string argument.");
0:   }
0:   // ---------------------------jdbc 1------------------------------------------
1: 
0:   public java.sql.ResultSet executeQuery () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeQuery");
0:       ResultSet resultSet = executeQueryX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "executeQuery", resultSet);
0:       return resultSet;
0:     }
0:   }
1: 
0:   // also called by some DBMD methods
0:   ResultSet executeQueryX () throws SqlException
0:   {
0:     flowExecute (executeQueryMethod__);
1: 
0:     super.checkExecuteQueryPostConditions ("java.sql.PreparedStatement");
0:     return resultSet_;
0:   }
1: 
1: 
0:   public int executeUpdate () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeUpdate");
0:       int updateValue = executeUpdateX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "executeUpdate", updateValue);
0:       return updateValue;
0:     }
0:   }
1: 
0:   // also used by Blob
0:   int executeUpdateX () throws SqlException
0:   {
0:     flowExecute (executeUpdateMethod__);
1: 
0:     if (sqlMode_ == isUpdate__) super.checkExecuteUpdatePostConditions ("java.sql.PreparedStatement");
0:     return updateCount_;
0:   }
1: 
0:   public void setNull (int parameterIndex, int jdbcType) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setNull", parameterIndex, jdbcType);
0:       setNullX (parameterIndex, jdbcType);
0:     }
0:   }
1: 
0:   // also used by DBMD methods
0:   void setNullX (int parameterIndex, int jdbcType) throws SqlException
0:   {
0:     super.checkForClosedStatement();  // investigate what can be pushed up to setNull
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = jdbcType;
1: 
0:       if (!parameterMetaData_.nullable_[parameterIndex - 1])
0:         throw new SqlException (agent_.logWriter_, "PreparedStatement: setNull method setting a non-nullable " +
0:                                 "input parameter " + parameterIndex + " to null.");
0:       setInput (parameterIndex, null);
0:     }
1: 
0:   public void setNull (int parameterIndex, int jdbcType, String typeName) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setNull", parameterIndex, jdbcType, typeName);
0:       super.checkForClosedStatement();
0:       setNull (parameterIndex, jdbcType);
0:     }
0:   }
1: 
0:   public void setBoolean (int parameterIndex, boolean x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBoolean", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.BIT;
0: 	  setInput(parameterIndex, new Short ((short)(x ? 1 : 0)));
0: 	}
0:   }
1: 
0:   public void setByte (int parameterIndex, byte x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setByte", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.TINYINT;
0: 	  setInput(parameterIndex, new Short (x));
0:     }
0:   }
1: 
0:   public void setShort (int parameterIndex, short x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setShort", parameterIndex, x);
0:       setShortX (parameterIndex, x);
0:     }
0:   }
1: 
0:   // also used by DBMD methods
0:   void setShortX (int parameterIndex, short x) throws SqlException
0:   {
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.SMALLINT;
0: 	  setInput(parameterIndex, new Short (x));
1: 
0:     }
1: 
0:   public void setInt (int parameterIndex, int x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setInt", parameterIndex, x);
0:       setIntX (parameterIndex, x);
0:     }
0:   }
1: 
0:   // also used by DBMD methods
0:   void setIntX (int parameterIndex, int x) throws SqlException
0:   {
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.INTEGER;
0: 	  setInput(parameterIndex, new Integer (x));
0:     }
1: 
1: 
0:   public void setLong (int parameterIndex, long x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setLong", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.BIGINT;
0: 	  setInput(parameterIndex, new Long (x));
0: 	}
0:   }
1: 
0:   public void setFloat (int parameterIndex, float x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setFloat", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.REAL;
0:        setInput(parameterIndex, new Float(x));
0: 	}
0:   }
1: 
0:   public void setDouble (int parameterIndex, double x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setDouble", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.DOUBLE;
0: 	  setInput(parameterIndex, new Double(x));
0:     }
0:   }
1: 
0:   public void setBigDecimal (int parameterIndex, java.math.BigDecimal x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBigDecimal", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.DECIMAL;   
0: 	  if (x == null) { setNull (parameterIndex, java.sql.Types.DECIMAL); return; }
0:       int registerOutScale = 0;
0: 	  setInput(parameterIndex, x);
0:     }
0:   }
1: 
0:   public void setDate (int parameterIndex, java.sql.Date x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setDate", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.DATE;
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.DATE); return; }
0: 	  setInput(parameterIndex, x);
0:     }
0:   }
1: 
0:   public void setDate (int parameterIndex,
0:                        java.sql.Date x,
0:                        java.util.Calendar calendar) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setDate", parameterIndex, x, calendar);
0:       if (calendar == null) throw new SqlException (agent_.logWriter_, "Invalid parameter: calendar is null");
0:       java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
0:       targetCalendar.clear();
0:       targetCalendar.setTime(x);
0:       java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:       defaultCalendar.clear();
0:       defaultCalendar.setTime(x);
0:       long timeZoneOffset =
0:         targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:         targetCalendar.get(java.util.Calendar.DST_OFFSET)  - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:       java.sql.Date adjustedDate = ((timeZoneOffset == 0) || (x==null)) ? x : new java.sql.Date (x.getTime() + timeZoneOffset);
0:       setDate (parameterIndex, adjustedDate);
0:     }
0:   }
1: 
0:   public void setTime (int parameterIndex, java.sql.Time x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTime", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.TIME;
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.TIME); return; }
0: 	  setInput(parameterIndex, x);
1: 
0:     }
0:   }
1: 
0:   public void setTime (int parameterIndex,
0:                        java.sql.Time x,
0:                        java.util.Calendar calendar) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTime", parameterIndex, x, calendar);
0:       if (calendar == null) throw new SqlException (agent_.logWriter_, "Invalid parameter: calendar is null");
0:       java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
0:       targetCalendar.clear();
0:       targetCalendar.setTime(x);
0:       java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:       defaultCalendar.clear();
0:       defaultCalendar.setTime(x);
0:       long timeZoneOffset =
0:         targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:         targetCalendar.get(java.util.Calendar.DST_OFFSET)  - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:       java.sql.Time adjustedTime = ((timeZoneOffset == 0) || (x==null)) ? x : new java.sql.Time (x.getTime() + timeZoneOffset);
0:       setTime (parameterIndex, adjustedTime);
0:     }
0:   }
1: 
0:   public void setTimestamp (int parameterIndex, java.sql.Timestamp x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTimestamp", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1 ] = java.sql.Types.TIMESTAMP;
1: 
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.TIMESTAMP); return; }
0:       setInput (parameterIndex, x);
0:       // once the nanosecond field of timestamp is trim to microsecond for DERBY, should we throw a warning
0:       //if (getParameterType (parameterIndex) == java.sql.Types.TIMESTAMP && x.getNanos() % 1000 != 0)
0:       //  accumulateWarning (new SqlWarning (agent_.logWriter_, "DERBY timestamp can only store up to microsecond, conversion from nanosecond to microsecond causes rounding."));
0:     }
0:   }
1: 
0:   public void setTimestamp (int parameterIndex,
0:                             java.sql.Timestamp x,
0:                             java.util.Calendar calendar) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setTimestamp", parameterIndex, x, calendar);
0:       if (calendar == null) throw new SqlException (agent_.logWriter_, "Invalid parameter: calendar is null");
0:       java.util.Calendar targetCalendar = java.util.Calendar.getInstance(calendar.getTimeZone());
0:       targetCalendar.clear();
0:       targetCalendar.setTime(x);
0:       java.util.Calendar defaultCalendar = java.util.Calendar.getInstance();
0:       defaultCalendar.clear();
0:       defaultCalendar.setTime(x);
0:       long timeZoneOffset =
0:         targetCalendar.get(java.util.Calendar.ZONE_OFFSET) - defaultCalendar.get(java.util.Calendar.ZONE_OFFSET) +
0:         targetCalendar.get(java.util.Calendar.DST_OFFSET)  - defaultCalendar.get(java.util.Calendar.DST_OFFSET);
0:       java.sql.Timestamp adjustedTimestamp = ((timeZoneOffset == 0) || (x==null)) ? x : new java.sql.Timestamp (x.getTime() + timeZoneOffset);
0:       if (x != null) adjustedTimestamp.setNanos (x.getNanos());
0:       setTimestamp (parameterIndex, adjustedTimestamp);
0:     }
0:   }
1: 
0:   public void setString (int parameterIndex, String x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setString", parameterIndex, x);
0:       setStringX (parameterIndex, x);
0:     }
0:   }
1: 
0:   // also used by DBMD methods
0:   void setStringX (int parameterIndex, String x) throws SqlException
0:   {
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.LONGVARCHAR;
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.LONGVARCHAR); return; }
0: 	  setInput(parameterIndex, x);
0:     }
1: 
0:   public void setBytes (int parameterIndex, byte[] x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBytes", parameterIndex, x);
0:       setBytesX (parameterIndex, x);
0:     }
0:   }
1: 
0:   // also used by BLOB
0:   public void setBytesX (int parameterIndex, byte[] x) throws SqlException
0:   {
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.LONGVARBINARY;
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.LONGVARBINARY); return; }
0: 	  setInput(parameterIndex, x);
1: 
0:     }
1: 
0:   public void setBinaryStream (int parameterIndex,
0:                                java.io.InputStream x,
0:                                int length) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBinaryStream", parameterIndex, "<input stream>", length);
0:       setBinaryStreamX (parameterIndex, x, length);
0:     }
0:   }
1: 
0:   public void setBinaryStreamX (int parameterIndex,
0:                                java.io.InputStream x,
0:                                int length) throws SqlException
0:   {
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.BLOB;
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.BLOB); return; }
0: 	  setInput(parameterIndex, new Blob (agent_, x, length));
0:   }
1: 
0:   public void setAsciiStream (int parameterIndex,
0:                               java.io.InputStream x,
0:                               int length) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setAsciiStream", parameterIndex, "<input stream>", length);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.CLOB;
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.CLOB); return; }
0: 	  setInput(parameterIndex, new Clob (agent_, x, "US-ASCII", length));
0:     }
0:   }
1: 
0:   public void setUnicodeStream (int parameterIndex,
0:                                 java.io.InputStream x,
0:                                 int length) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceDeprecatedEntry (this, "setUnicodeStream", parameterIndex, "<input stream>", length);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.CLOB;
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.CLOB); return; }
0: 	  setInput(parameterIndex, new Clob (agent_, x, "UnicodeBigUnmarked", length));
0:     }
0:   }
1: 
0:   public void setCharacterStream (int parameterIndex,
0:                                   java.io.Reader x,
0:                                   int length) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setCharacterStream", parameterIndex, x, length);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.CLOB;
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.CLOB); return; }
0: 	  setInput(parameterIndex, new Clob (agent_, x, length));
0:     }
0:   }
1: 
0:   public void setBlob (int parameterIndex, java.sql.Blob x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setBlob", parameterIndex, x);
0:       setBlobX (parameterIndex, x);
0:     }
0:   }
1: 
0:   // also used by Blob
0:   public void setBlobX (int parameterIndex, java.sql.Blob x) throws SqlException
0:   {
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	  parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.BLOB;
0:       if (x == null) { setNull (parameterIndex, java.sql.Types.BLOB); return; }
0: 	  setInput(parameterIndex, x);
0:     }
1: 
0:   public void setClob (int parameterIndex, java.sql.Clob x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setClob", parameterIndex, x);
0:       setClobX (parameterIndex, x);
0:     }
0:   }
1: 
0:   // also used by Clob
0:   void setClobX (int parameterIndex, java.sql.Clob x) throws SqlException
0:   {
0: 	parameterIndex = checkSetterPreconditions (parameterIndex);
0: 	parameterMetaData_.clientParamtertype_[parameterIndex -1] = java.sql.Types.CLOB;
0:     if (x == null) { this.setNullX (parameterIndex, Types.CLOB); return; }
0: 	setInput(parameterIndex, x);
0:   }
1: 
1: 
0:   public void setArray (int parameterIndex, java.sql.Array x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setArray", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0:       throw new SqlException (agent_.logWriter_, "jdbc 2 method not yet implemented");
0:     }
0:   }
1: 
0:   public void setRef (int parameterIndex, java.sql.Ref x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setRef", parameterIndex, x);
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0:       throw new SqlException (agent_.logWriter_, "jdbc 2 method not yet implemented");
0:     }
0:   }
1: 
0:   // The Java compiler uses static binding, so we must use instanceof
0:   // rather than to rely on separate setObject() methods for
0:   // each of the Java Object instance types recognized below.
0:   public void setObject (int parameterIndex, Object x) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setObject", parameterIndex, x);
0:       super.checkForClosedStatement();
0:       if      (x instanceof String)               setString (parameterIndex, (String) x);
0:       else if (x instanceof Integer)              setInt (parameterIndex, ((Integer) x).intValue());
0:       else if (x instanceof Double)               setDouble (parameterIndex, ((Double) x).doubleValue());
0:       else if (x instanceof Float)                setFloat (parameterIndex, ((Float) x).floatValue());
0:       else if (x instanceof Boolean)              setBoolean (parameterIndex, ((Boolean) x).booleanValue());
0:       else if (x instanceof Long)                 setLong (parameterIndex, ((Long) x).longValue());
0:       else if (x instanceof byte[])               setBytes (parameterIndex, (byte[]) x);
0:       else if (x instanceof java.math.BigDecimal) setBigDecimal (parameterIndex, (java.math.BigDecimal) x);
0:       else if (x instanceof java.sql.Date)        setDate (parameterIndex, (java.sql.Date) x);
0:       else if (x instanceof java.sql.Time)        setTime (parameterIndex, (java.sql.Time) x);
0:       else if (x instanceof java.sql.Timestamp)   setTimestamp (parameterIndex, (java.sql.Timestamp) x);
0:       else if (x instanceof java.sql.Blob)        setBlob (parameterIndex, (java.sql.Blob) x);
0:       else if (x instanceof java.sql.Clob)        setClob (parameterIndex, (java.sql.Clob) x);
0:       else if (x instanceof java.sql.Array)       setArray (parameterIndex, (java.sql.Array) x);
0:       else if (x instanceof java.sql.Ref)         setRef (parameterIndex, (java.sql.Ref) x);
0:       else if (x instanceof Short)                setShort (parameterIndex, ((Short) x).shortValue());
0:       else if (x instanceof Byte)                 setByte (parameterIndex, ((Byte) x).byteValue());
0:       else {
0:         checkSetterPreconditions (parameterIndex);
0:         throw new SqlException (agent_.logWriter_, "Invalid data conversion:" +
0:                               " Parameter object type is invalid for requested conversion.");
0:       }
0:     }
0:   }
1: 
0:   public void setObject (int parameterIndex, Object x, int targetJdbcType) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setObject", parameterIndex, x, targetJdbcType);
0:       setObjectX (parameterIndex, x, targetJdbcType, 0);
0:     }
0:   }
1: 
0:   public void setObject (int parameterIndex,
0:                          Object x,
0:                          int targetJdbcType,
0:                          int scale) throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setObject", parameterIndex, x, targetJdbcType, scale);
0:       setObjectX (parameterIndex, x, targetJdbcType, scale);
0:     }
0:   }
1: 
0:   private void setObjectX (int parameterIndex,
0:                          Object x,
0:                          int targetJdbcType,
0:                          int scale) throws SqlException
0:   {
0:       parameterIndex = checkSetterPreconditions (parameterIndex);
0:       checkForValidScale (scale);
1: 
0:       if (x == null) { setNull (parameterIndex, targetJdbcType); return; }
0: 	  setObject(parameterIndex, x);
0:   }
1: 
0:   // Since parameters are cached as objects in parameters_[],
0:   // java null may be used to represent SQL null.
0:   public void clearParameters () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled ()) agent_.logWriter_.traceEntry (this, "clearParameters");
0:       checkForClosedStatement ();
0:       if (parameterMetaData_ != null) {
0:         for (int i = 0; i < parameters_.length; i++)
0:           parameters_[i] = null;
1: 
0:         for (int i = 0; i < parameterSet_.length; i++)
0:           parameterSet_[i] = false;
0:       }
0:     }
0:   }
1: 
0:   public boolean execute () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "execute");
0:       boolean b = executeX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "execute", b);
0:       return b;
0:     }
0:   }
1: 
0:   private boolean executeX () throws SqlException
0:   {
0:     flowExecute (executeMethod__);
1: 
0:     return resultSet_ != null;
0:   }
1: 
0:   //--------------------------JDBC 2.0-----------------------------
1: 
0:   public void addBatch () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "addBatch");
0:       checkForClosedStatement ();
0:       checkThatAllParametersAreSet();
1: 
0:       // ASSERT: since OUT/INOUT parameters are not allowed, there should
0:       //         be no problem in sharing the JDBC Wrapper object instances
0:       //         since they will not be modified by the driver.
1: 
0:       // batch up the parameter values -- deep copy req'd
1: 
0:       if(parameterMetaData_ != null) {
0:       Object[] inputsClone = new Object[parameters_.length];
0:       System.arraycopy (parameters_, 0, inputsClone, 0, parameters_.length);
1: 
0:       batch_.add (inputsClone);
0:     }
0:       else
0:         batch_.add(null);
0:     }
0:   }
1: 
0:   // Batch requires that input types are exact, we perform no input cross conversion for Batch.
0:   // If so, this is an external semantic, and should go into the release notes
0:   public int[] executeBatch() throws SqlException, BatchUpdateException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeBatch");
0:       int[] updateCounts = null;
0:       updateCounts = executeBatchX (false);
1: 
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "executeBatch", updateCounts);
0:       return updateCounts;
0:     }
0:   }
1: 
0:   public java.sql.ResultSetMetaData getMetaData () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getMetaData");
0:       ColumnMetaData resultSetMetaData = getMetaDataX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getMetaData", resultSetMetaData);
0:       return resultSetMetaData;
0:     }
0:   }
1: 
0:    private ColumnMetaData getMetaDataX () throws SqlException
0:   {
0:     super.checkForClosedStatement();
0:     return resultSetMetaData_;
0:   }
1: 
1:     //------------------------- JDBC 3.0 -----------------------------------
1: 
0:   public boolean execute (String sql, int autoGeneratedKeys) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "execute", sql, autoGeneratedKeys);
0:     throw new SqlException (agent_.logWriter_,
0:       "The method java.sql.Statement.execute (String sql, int autoGeneratedKeys) cannot be called on a " +
0:       " prepared statement instance." +
0:       " Use java.sql.PreparedStatement.execute () with no arguments.");
0:   }
1: 
0:   public boolean execute (String sql, String[] columnNames) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "execute", sql, columnNames);
0:     throw new SqlException (agent_.logWriter_,
0:       "The method java.sql.Statement.execute (String sql, String[] columnNames) cannot be called on a " +
0:       " prepared statement instance." +
0:       " Use java.sql.PreparedStatement.execute () with no arguments.");
0:   }
1: 
0:   public boolean execute (String sql, int[] columnIndexes) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "execute", sql, columnIndexes);
0:     throw new SqlException (agent_.logWriter_,
0:       "The method java.sql.Statement.execute (String sql, int[] columnIndexes) cannot be called on a " +
0:       " prepared statement instance." +
0:       " Use java.sql.PreparedStatement.execute () with no arguments.");
0:   }
1: 
0:   public int executeUpdate (String sql, int autoGeneratedKeys) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeUpdate", autoGeneratedKeys);
0:     throw new SqlException (agent_.logWriter_,
0:       "The method java.sql.Statement.executeUpdate (String sql, int autoGeneratedKeys) cannot be called on a " +
0:       " prepared statement instance." +
0:       " Use java.sql.PreparedStatement.executeUpdate () with no arguments.");
0:   }
1: 
0:   public int executeUpdate (String sql, String[] columnNames) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeUpdate", columnNames);
0:       throw new SqlException (agent_.logWriter_,
0:         "The method java.sql.Statement.executeUpdate (String sql, String[] columnNames) cannot be called on a " +
0:         " prepared statement instance." +
0:       " Use java.sql.PreparedStatement.executeUpdate () with no arguments.");
0:   }
1: 
0:   public int executeUpdate (String sql, int[] columnIndexes) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "executeUpdate", columnIndexes);
0:       throw new SqlException (agent_.logWriter_,
0:         "The method java.sql.Statement.executeUpdate (String sql, int[] columnIndexes) cannot be called on a " +
0:         " prepared statement instance." +
0:       " Use java.sql.PreparedStatement.executeUpdate () with no arguments.");
0:   }
1: 
0:   public void setURL (int parameterIndex, java.net.URL x) throws SqlException
0:   {
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "setURL", parameterIndex, x);
0:     throw new SqlException (agent_.logWriter_, "JDBC 3 method called - not yet supported");
0:   }
1: 
0:   public java.sql.ParameterMetaData getParameterMetaData() throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "getParameterMetaData");
0:       Object parameterMetaData = getParameterMetaDataX();
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceExit (this, "getParameterMetaData", parameterMetaData);
0:       return (java.sql.ParameterMetaData) parameterMetaData;
0:     }
0:   }
1: 
0:   private ParameterMetaData getParameterMetaDataX() throws SqlException
0:   {
0:     super.checkForClosedStatement();
0:     ParameterMetaData pm = new ParameterMetaData (parameterMetaData_ != null
0:                           ? parameterMetaData_
0:                           : new ColumnMetaData(agent_.logWriter_, 0));
0:     if (escapedProcedureCallWithResult_)
0:       pm.escapedProcedureCallWithResult_ = true;
0:     return pm;
0:   }
1: 
0:   // ------------------------ box car and callback methods --------------------------------
1: 
0:   public void writeExecute (Section section,
0:                             ColumnMetaData parameterMetaData,
0:                             Object[] inputs,
0:                             int numInputColumns,
0:                             boolean outputExpected,
0:                             // This is a hint to the material layer that more write commands will follow.
0:                             // It is ignored by the driver in all cases except when blob data is written,
0:                             // in which case this boolean is used to optimize the implementation.
0:                             // Otherwise we wouldn't be able to chain after blob data is sent.
0:                             // Current servers have a restriction that blobs can only be chained with blobs
0:                             boolean chainedWritesFollowingSetLob
0:                             ) throws SqlException
0:   { materialPreparedStatement_.writeExecute_ (section,
0:                              parameterMetaData,
0:                             inputs,
0:                             numInputColumns,
1:                             outputExpected,
0:                             chainedWritesFollowingSetLob);
0:                              }
1: 
1: 
0:   public void readExecute () throws SqlException
0:   { materialPreparedStatement_.readExecute_(); }
1: 
0:   public void writeOpenQuery (Section section,
0:                               int fetchSize,
0:                               int resultSetType,
0:                               int numInputColumns,
0:                               ColumnMetaData parameterMetaData,
0:                               Object[] inputs
0:                               ) throws SqlException
0:   { materialPreparedStatement_.writeOpenQuery_ (section,
0:                               fetchSize,
0:                               resultSetType,
0:                               numInputColumns,
0:                               parameterMetaData,
0:                               inputs);}
0:   public void writeDescribeInput (Section section) throws SqlException
0:   { materialPreparedStatement_.writeDescribeInput_ (section); }
0:   public void readDescribeInput () throws SqlException
0:   { materialPreparedStatement_.readDescribeInput_(); }
1: 
0:   public void completeDescribeInput (ColumnMetaData parameterMetaData, Sqlca sqlca)
0:   {
0:     int sqlcode = super.completeSqlca (sqlca);
0:     if (sqlcode < 0) return;
1: 
1: 
0:     parameterMetaData_ = parameterMetaData;
1: 
0:     // The following code handles the case when
0:     // sqlxParmmode is not supported, in which case server will return 0 (unknown), and
0:     // this could clobber our guessed value for sqlxParmmode.  This is a problem.
0:     // We can solve this problem for Non-CALL statements, since the parmmode is always IN (1).
0:     // But what about CALL statements.  If CALLs are describable, then we have no
0:     // problem, we assume server won't return unknown.
0:     // If CALLs are not describable then nothing gets clobbered because we won't
0:     // parse out extended describe, so again  no problem.
0:     if (sqlMode_ != isCall__ && parameterMetaData_ != null)
0:       for (int i = 0; i < parameterMetaData_.columns_; i++)
0:         parameterMetaData_.sqlxParmmode_[i] = 1;  // 1 means IN parameter
1: 
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceParameterMetaData (this, parameterMetaData_);
0:   }
1: 
0:   public void writeDescribeOutput (Section section) throws SqlException
0:   { materialPreparedStatement_.writeDescribeOutput_ (section); }
0:   public void readDescribeOutput () throws SqlException
0:   { materialPreparedStatement_.readDescribeOutput_(); }
0:   public void completeDescribeOutput (ColumnMetaData resultSetMetaData, Sqlca sqlca)
0:   {
0:     int sqlcode = super.completeSqlca (sqlca);
0:     if (sqlcode < 0) return;
0:     resultSetMetaData_ = resultSetMetaData;
0:     if (agent_.loggingEnabled()) agent_.logWriter_.traceResultSetMetaData (this, resultSetMetaData);
0:   }
1: 
0:   void writePrepareDescribeInputOutput () throws SqlException
0:   {
0:     // Notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
0:     writePrepareDescribeOutput (sql_, section_);
0:     writeDescribeInput (section_);
0:   }
1: 
0:   void readPrepareDescribeInputOutput () throws SqlException
0:   {
0:     readPrepareDescribeOutput ();
0:     readDescribeInput ();
0:     completePrepareDescribe();
0:   }
1: 
0:   void writePrepareDescribeInput () throws SqlException
0:   {
0:     // performance will be better if we flow prepare with output enable vs. prepare then describe input for callable
0:     // Notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
0:     writePrepare (sql_, section_);
0:     writeDescribeInput (section_);
0:   }
1: 
0:   void readPrepareDescribeInput () throws SqlException
0:   {
0:     readPrepare();
0:     readDescribeInput ();
0:     completePrepareDescribe();
0:   }
1: 
0:   void completePrepareDescribe ()
0:   {
0:     if (parameterMetaData_ == null) return;
0:     parameters_ = expandObjectArray (parameters_, parameterMetaData_.columns_);
0:     parameterSet_ = expandBooleanArray (parameterSet_, parameterMetaData_.columns_);
0:     parameterRegistered_ = expandBooleanArray (parameterRegistered_, parameterMetaData_.columns_);
0:   }
1: 
0:   private Object[] expandObjectArray (Object[] array, int newLength)
0:   {
0:     if (array == null) {
0:       Object[] newArray = new Object[newLength];
0:       return newArray;
0:     }
0:     if (array.length < newLength) {
0:       Object[] newArray = new Object[newLength];
0:       System.arraycopy (array, 0, newArray, 0, array.length);
0:       return newArray;
0:     }
0:     return array;
0:   }
1: 
0:   private boolean[] expandBooleanArray (boolean[] array, int newLength)
0:   {
0:     if (array == null) {
0:       boolean[] newArray = new boolean[newLength];
0:       return newArray;
0:     }
0:     if (array.length < newLength) {
0:       boolean[] newArray = new boolean[newLength];
0:       System.arraycopy (array, 0, newArray, 0, array.length);
0:       return newArray;
0:     }
0:     return array;
0:   }
1: 
0:   void flowPrepareForSelectFromInsert () throws SqlException
0:   {
0:     agent_.beginWriteChain (this);
0:     writePrepareDescribeInputOutput (constructSelectFromInsertSQL(sql_), section_);
0:     agent_.flow (this);
0:     readPrepareDescribeInputOutput();
0:     agent_.endReadChain();
0:   }
1: 
0:   void writePrepareDescribeInputOutput (String sql,
0:                                         Section section) throws SqlException
0:   {
0:     // Notice that sql_ is passed in since in general ad hoc sql must be passed in for unprepared statements
0:     writePrepareDescribeOutput (sql, section);
0:     writeDescribeInput (section);
0:   }
1: 
0:   void flowPrepareDescribeInputOutput () throws SqlException
0:   {
0:     agent_.beginWriteChain (this);
0:     if (sqlMode_ == isCall__) {
0:       writePrepareDescribeInput();
0:       agent_.flow (this);
0:       readPrepareDescribeInput();
0:       agent_.endReadChain();
0:     }
0:     else {
0:       writePrepareDescribeInputOutput();
0:       agent_.flow (this);
0:       readPrepareDescribeInputOutput();
0:       agent_.endReadChain();
0:     }
0:   }
1: 
0:   void flowExecute (int executeType) throws SqlException
0:   {
0:     super.checkForClosedStatement();
0:     super.clearWarningsX();
0:     super.checkForAppropriateSqlMode (executeType, sqlMode_);
0:     checkThatAllParametersAreSet();
1: 
0:     if (sqlMode_ == isUpdate__) updateCount_ = 0;
0:     else updateCount_ = -1;
1: 
0:     java.util.Timer queryTimer = null;
0:     QueryTimerTask queryTimerTask = null;
0:     if (timeout_ != 0) {
0:       queryTimer = new java.util.Timer (); // A thread that ticks the seconds
0:       queryTimerTask = new QueryTimerTask (this, queryTimer);
0:       queryTimer.schedule (queryTimerTask, 1000*timeout_);
0:     }
1: 
0:     try {
0:       agent_.beginWriteChain (this);
1: 
0:       boolean piggybackedAutocommit = super.writeCloseResultSets (true);  // true means permit auto-commits
1: 
1: 
0:       int numInputColumns = (parameterMetaData_ != null) ? parameterMetaData_.getColumnCount() : 0;
0:       boolean outputExpected = (resultSetMetaData_ != null && resultSetMetaData_.getColumnCount() > 0);
0:       boolean chainAutoCommit = false;
0:       boolean commitSubstituted = false;
0:       boolean repositionedCursor = false;
0:       ResultSet scrollableRS = null;
1: 
0:       switch (sqlMode_) {
0:       case isUpdate__:
0:         if (positionedUpdateCursorName_ != null)
0:           scrollableRS = agent_.sectionManager_.getPositionedUpdateResultSet (positionedUpdateCursorName_);
0:         if (scrollableRS != null && !scrollableRS.isRowsetCursor_) {
0:           repositionedCursor =
0:              scrollableRS.repositionScrollableResultSetBeforeJDBC1PositionedUpdateDelete();
0:           if (!repositionedCursor) scrollableRS = null;
0:         }
1: 
0:         chainAutoCommit = connection_.willAutoCommitGenerateFlow() && isAutoCommittableStatement_;
1: 
0:         if (sqlUpdateMode_ == isInsertSql__ && generatedKeysColumnNames_ != null) {
0:           writeOpenQuery (section_,
0:                           fetchSize_,
0:                           resultSetType_,
0:                           numInputColumns,
0:                           parameterMetaData_,
0:                           parameters_);
0:         }
0:         else {
0:           boolean chainOpenQueryForAutoGeneratedKeys = (sqlUpdateMode_ == isInsertSql__ && autoGeneratedKeys_ == RETURN_GENERATED_KEYS);
0:         writeExecute (section_,
0:                       parameterMetaData_,
0:                       parameters_,
0:                       numInputColumns,
1:                       outputExpected,
0:                         (chainAutoCommit || chainOpenQueryForAutoGeneratedKeys)// chain flag
0:                       ); // chain flag
1: 
0:           if (chainOpenQueryForAutoGeneratedKeys) {
0:             prepareAutoGeneratedKeysStatement ();
0:             writeOpenQuery (preparedStatementForAutoGeneratedKeys_.section_,
0:                             preparedStatementForAutoGeneratedKeys_.fetchSize_,
0:                             preparedStatementForAutoGeneratedKeys_.resultSetType_);
0:           }
0:         }
1: 
0:         if (chainAutoCommit) {
0:           // we have encountered an error in writing the execute, so do not
0:           // flow an autocommit
0:           if (agent_.accumulatedReadExceptions_ != null) {
0:             // currently, the only write exception we encounter is for
0:             // data truncation: SQLSTATE 01004, so we don't bother checking for this
0:             connection_.writeCommitSubstitute_ ();
0:             commitSubstituted = true;
0:           }
0:           else {
0:             // there is no write error, so flow the commit
0:             connection_.writeCommit ();
0:           }
0:         }
0:         break;
1: 
0:       case isQuery__:
0:         writeOpenQuery (section_,
0: 						fetchSize_,
0: 						resultSetType_,
0: 						numInputColumns,
0: 						parameterMetaData_,
0:                         parameters_);
0:         break;
1: 
0:       case isCall__:
0:           writeExecuteCall (outputRegistered_, // if no out/inout parameter, outputExpected = false
0: 							null,
0:                             section_,
0:                             fetchSize_,
0:                             false,  // do not suppress ResultSets for regular CALLs
0:                             resultSetType_,
0:                             parameterMetaData_,
0:                             parameters_); // cross conversion
0:         break;
0:       }
1: 
0:       agent_.flow (this);
1: 
0:       super.readCloseResultSets (true);  // true means permit auto-commits
1: 
0:       // turn inUnitOfWork_ flag back on and add statement
0:       // back on commitListeners_ list if they were off
0:       // by an autocommit chained to a close cursor.
0:       if (piggybackedAutocommit) {
0:         connection_.completeTransactionStart();
0:       }
1: 
0:       super.markResultSetsClosed();
1: 
0:       switch (sqlMode_) {
0:       case isUpdate__:
0:         // do not need to reposition for a rowset cursor
0:         if (scrollableRS != null && !scrollableRS.isRowsetCursor_)
0:           scrollableRS.readPositioningFetch_();
1: 
0:         if (sqlUpdateMode_ == isInsertSql__ && generatedKeysColumnNames_ != null) {
0:           readOpenQuery ();
0:           if (resultSet_ != null) {
0:             generatedKeysResultSet_ = resultSet_;
0:             resultSet_ = null;
0:             updateCount_ = 1;
0:           }
0:         }
0:         else {
0:         readExecute ();
1: 
0:           if (sqlUpdateMode_ == isInsertSql__ && autoGeneratedKeys_ == RETURN_GENERATED_KEYS) {
0:             readPrepareAutoGeneratedKeysStatement ();
0:             preparedStatementForAutoGeneratedKeys_.readOpenQuery ();
0:             generatedKeysResultSet_ = preparedStatementForAutoGeneratedKeys_.resultSet_;
0:             preparedStatementForAutoGeneratedKeys_.resultSet_ = null;
0:           }
0:         }
1: 
0:         if (chainAutoCommit) {
0:           if (commitSubstituted)
0:             connection_.readCommitSubstitute_ ();
0:           else
0:             connection_.readCommit ();
0:         }
0:         break;
1: 
0:       case isQuery__:
0:         try {
0:         readOpenQuery ();
0:         }
0:         catch (DisconnectException dise ) {
0:           throw dise;
0:         }
0:         catch (SqlException e) {
0: 			throw e;
0:         }
0:         // resultSet_ is null if open query failed.
0:         // check for null resultSet_ before using it.
0:         if (resultSet_ != null) {
0:           resultSet_.parseScrollableRowset ();
0:           //if (resultSet_.scrollable_) resultSet_.getRowCount();
0:           // If client's cursor name is set, map the client's cursor name to the ResultSet
0:           // Else map the server's cursor name to the ResultSet
0:           mapCursorNameToResultSet ();
0:         }
0:         break;
1: 
0:       case isCall__:
0:         readExecuteCall();
0:         break;
1: 
0:       }
1: 
1: 
0:       try {
0:         agent_.endReadChain();
0:       }
0:       catch (SqlException e) {
0: 		  throw e;
1: 
0:       }
1: 
0:       if (sqlMode_ == isCall__) {
0: 		parseStorProcReturnedScrollableRowset ();
0: 		 // When there are no result sets back, we will commit immediately when autocommit is true.
0:       // make sure a commit is not performed when making the call to the sqlca message procedure
0: 		if (connection_.autoCommit_ && resultSet_ == null && resultSetList_ == null && isAutoCommittableStatement_) {
0:         connection_.flowAutoCommit();
0:         }
0:       }
1: 
0:       // Throw an exception if holdability returned by the server is different from requested.
0:       if (resultSet_ != null && resultSet_.resultSetHoldability_ != resultSetHoldability_ && sqlMode_ != isCall__)
0:         throw new SqlException (agent_.logWriter_, "Unable to open resultSet with requested " +
0:                                 "holdability " + resultSetHoldability_ + ".");
1: 
0:     }
0:     finally {
0:       if (timeout_ != 0) { // query timers need to be cancelled.
0:         queryTimer.cancel();
0:         queryTimerTask.cancel();
0:       }
0:     }
1: 
0:   }
1: 
0:   public int[] executeBatchX (boolean supportsQueryBatchRequest) throws SqlException, BatchUpdateException
0:   {
0:     synchronized (connection_) {
0:       checkForClosedStatement (); // Per jdbc spec (see Statement.close() javadoc)
0:       clearWarningsX (); // Per jdbc spec 0.7, also see getWarnings() javadoc
0:       return executeBatchRequestX (supportsQueryBatchRequest);
0:     }
0:   }
1: 
1: 
0:   private int[] executeBatchRequestX (boolean supportsQueryBatchRequest)
0:                   throws SqlException, BatchUpdateException
0:   {
0:     SqlException chainBreaker = null;
0:     int batchSize = batch_.size();
0:     int[] updateCounts = new int[batchSize];
0:     int numInputColumns = parameterMetaData_== null ? 0  : parameterMetaData_.getColumnCount();
0:     Object[] savedInputs = null;  // used to save/restore existing parameters
1: 
0:     if (batchSize == 0) return updateCounts;
1: 
0:     // Initialize all the updateCounts to indicate failure
0:     // This is done to account for "chain-breaking" errors where we cannot
0:     // read any more replies
0:     for (int i = 0; i < batchSize; i++)
0:       updateCounts[i] = -3;
1: 
0:     if (!supportsQueryBatchRequest && sqlMode_ == isQuery__)
0:       throw new BatchUpdateException (agent_.logWriter_, "Batching of queries not allowed by J2EE compliance", updateCounts);
0:     if (supportsQueryBatchRequest && sqlMode_ != isQuery__)
0:       throw new BatchUpdateException (agent_.logWriter_, "Query batch requested on a non-query statement", updateCounts);
1: 
0:     resultSetList_ = null;
1: 
1: 
0:     if (sqlMode_ == isQuery__) {
0:       indexOfCurrentResultSet_ = -1; //reset ResultSetList
0:       resultSetList_ = new ResultSet[batchSize];
0:     }
1: 
1: 
0:     //save the current input set so it can be restored
0:     savedInputs = parameters_;
1: 
0:     agent_.beginBatchedWriteChain (this);
0:     boolean chainAutoCommit = connection_.willAutoCommitGenerateFlow() && isAutoCommittableStatement_;
1: 
0:     for (int i = 0; i < batchSize; i++) {
0:       parameters_ = (Object[]) batch_.get (i);
1: 
0:        if (sqlMode_ != isCall__) {
0:           boolean outputExpected = (resultSetMetaData_ != null && resultSetMetaData_.getColumnCount() > 0);
1: 
0:           writeExecute (section_,
0:                         parameterMetaData_,
0:                         parameters_,
0:                         numInputColumns,
1:                         outputExpected,
1:                         chainAutoCommit || (i != batchSize - 1));  // more statements to chain
0:       }
0:       else if (outputRegistered_) // make sure no output parameters are registered
0:         throw new BatchUpdateException (agent_.logWriter_, "No output parameters are allowed in batch updates", updateCounts);
0:       else {
0:             writeExecuteCall (false, // no output expected for batched CALLs
0:                               null,  // no procedure name supplied for prepared CALLs
0:                               section_,
0:                               fetchSize_,
0:                               true,  // suppress ResultSets for batch
0:                               resultSetType_,
0:                               parameterMetaData_,
0:                               parameters_);
0:       }
0:     }
1: 
0:     boolean commitSubstituted = false;
0:     if (chainAutoCommit) {
0:       // we have encountered an error in writing the execute, so do not
0:       // flow an autocommit
0:       if (agent_.accumulatedReadExceptions_ != null) {
0:         // currently, the only write exception we encounter is for
0:         // data truncation: SQLSTATE 01004, so we don't bother checking for this
0:         connection_.writeCommitSubstitute_ ();
0:         commitSubstituted = true;
0:       }
0:       else {
0:         // there is no write error, so flow the commit
0:         connection_.writeCommit ();
0:       }
0:     }
1: 
0:     agent_.flowBatch (this, batchSize);
1: 
0:     try {
0:       for (int i = 0; i < batchSize; i++) {
0:         agent_.setBatchedExceptionLabelIndex (i);
0:         parameters_ = (Object[]) batch_.get (i);
0:         if (sqlMode_ != isCall__)
0:             readExecute();
0:           else
0:             readExecuteCall();
0:           updateCounts[i] = updateCount_;
1: 
0:         }
1: 
0:       agent_.disableBatchedExceptionTracking(); // to prvent the following readCommit() from getting a batch label
0:       if (chainAutoCommit) {
0:         if (!commitSubstituted) {
0:           connection_.readCommit ();
0:         }
0:         else {
0:           connection_.readCommitSubstitute_ ();
0:         }
0:       }
0:     }
1: 
0:     // for chain-breaking exception only, all read() methods do their own accumulation
0:     // this catches the entire accumulated chain, we need to be careful not to
0:     // reaccumulate it on the agent since the batch labels will be overwritten if
0:     // batch exception tracking is enabled.
0:     catch (SqlException e) { // for chain-breaking exception only
0:       chainBreaker = e;
0:       chainBreaker.setNextException (new SqlException (agent_.logWriter_,
0:           "Non-recoverable chain-breaking exception occurred during batch processing.  " +
0:           "The batch is terminated non-atomically."));
0:     }
0:     // We need to clear the batch before any exception is thrown from agent_.endBatchedReadChain().
0:     batch_.clear ();
1: 
0:     // restore the saved input set, setting it to "current"
0:     parameters_ = savedInputs;
1: 
0:     agent_.endBatchedReadChain (updateCounts, chainBreaker);
1: 
0:     return updateCounts;
1: 
0:   }
1: 
1: 
0:   //------------------material layer event callbacks follow-----------------------
1: 
0:   boolean listenToUnitOfWork_ = false;
1: 
0:   public void listenToUnitOfWork()
0:   {
0:     if (!listenToUnitOfWork_) {
0:       listenToUnitOfWork_ = true;
0:       connection_.CommitAndRollbackListeners_.add(this);
0:     }
0:   }
1: 
0:   public void completeLocalCommit (java.util.Iterator listenerIterator)
0:   {
0:     if (section_ != null ) openOnServer_ = false;
0:     listenerIterator.remove();
0:     listenToUnitOfWork_ = false;
0:   }
1: 
0:   public void completeLocalRollback (java.util.Iterator listenerIterator)
0:   {
0:     if (section_ != null ) openOnServer_ = false;
0:     listenerIterator.remove();
0:     listenToUnitOfWork_ = false;
0:   }
1: 
0:   //----------------------------internal use only helper methods----------------
1: 
0:   private int checkSetterPreconditions (int parameterIndex) throws SqlException
0:   {
0:     super.checkForClosedStatement();
0:     parameterIndex = checkForEscapedCallWithResult (parameterIndex);
0:     checkForValidParameterIndex (parameterIndex);
0:     return parameterIndex;
0:   }
1: 
0:   void checkForValidParameterIndex (int parameterIndex) throws SqlException
0:   {
0:     if (parameterMetaData_ == null || parameterIndex < 1 || parameterIndex > parameterMetaData_.columns_)
0:       throw new SqlException (agent_.logWriter_, "Invalid argument: parameter index " +
0:                               parameterIndex + " is out of range.");
0:   }
1: 
0:   private void checkThatAllParametersAreSet () throws SqlException
0:   {
0:     if (parameterMetaData_ != null) {
0:       for (int i = 0; i < parameterMetaData_.columns_; i++)
0:         if (!parameterSet_[i] && !parameterRegistered_[i])
0:           throw new SqlException (agent_.logWriter_, "At least one parameter to the current statement is uninitialized.", "07000");
0:     }
0:   }
1: 
1: 
0:   private int checkForEscapedCallWithResult (int parameterIndex) throws SqlException
0:   {
0:     if (escapedProcedureCallWithResult_) {
0:       if (parameterIndex == 1)
0:         throw new SqlException (agent_.logWriter_,
0:           "Invalid attempt to set the return value parameter of a CALL statement." +
0:           "Return value parameter of {?=CALL foo(?,?)} statement is parameter 1.");
0:       else
0:         parameterIndex--;
0:     }
0:     return parameterIndex;
0:   }
1: 
0:   void checkForValidScale (int scale) throws SqlException
0:   {
0:     if (scale < 0 || scale > 31)
0:       throw new SqlException (agent_.logWriter_, "Invalid argument: scale must be greater than or equal to 0 and less than 32.");
0:   }
1: 
0:   void checkScaleForINOUTDecimal (int parameterIndex, int registerOutScale) throws SqlException
0:   {
0:     java.math.BigDecimal decimalInput = (java.math.BigDecimal) parameters_[parameterIndex - 1];
0:     if (decimalInput == null) return;
0:     // if the register out scale is greater than input scale, input scale is stored in sqlScale_
0:     if (registerOutScale > parameterMetaData_.sqlScale_[parameterIndex - 1]) {
0:       int inputLength = decimalInput.toString().length();
0:       int scaleDifference = registerOutScale - decimalInput.scale();
0:       if (decimalInput.signum() == -1) {
0:         inputLength--;
0:       }
0:       // if the new Decimal (with bigger scale) cannot fit into the DA
0:       if ((32 - scaleDifference) < inputLength) {
0:         throw new SqlException (agent_.logWriter_, "The scale supplied by the registerOutParameter method does " +
0:                                 "not match with the setter method. Possible loss of precision!");
0:       }
0:       // if the new Decimal (with bigger scale) can fit
0:       else {
0:         parameters_[parameterIndex - 1] = decimalInput.setScale (registerOutScale);
0:         parameterMetaData_.sqlScale_[parameterIndex - 1] = registerOutScale;
0:       }
0:     }
0:     // if the register out sacle is smaller than input scale
0:     else if (registerOutScale < parameterMetaData_.sqlScale_[parameterIndex - 1]) {
0:       // remove 0's at the end of input
0:       try {
0:         // if the new Decimal (with smaller scale) can fit
0:         parameters_[parameterIndex - 1] = decimalInput.setScale (registerOutScale);
0:         parameterMetaData_.sqlScale_[parameterIndex - 1] = registerOutScale;
0:       }
0:       catch (ArithmeticException e)
0:       {
0:         // if the new Decimal (with smaller scale) cannot fit into the DA
0:         throw new SqlException (agent_.logWriter_, "The scale supplied by the registerOutParameter method does " +
0:                                 "not match with the setter method. Possible loss of precision!");
0:       }
0:     }
0:   }
1: 
0:   public void close () throws SqlException
0:   {
0:     synchronized (connection_) {
0:       if (agent_.loggingEnabled()) agent_.logWriter_.traceEntry (this, "close");
0:       closeX();
0:     }
0:   }
1: 
0:   // An untraced version of close()
0:   public void closeX () throws SqlException
0:   {
0:     if (!openOnClient_) return;
0:     super.closeX();
0:     if (parameterMetaData_ != null) {
0:       parameterMetaData_.markClosed();
0:       parameterMetaData_ = null;
0:     }
0:     sql_ = null;
1: 
0:     // Apparently, the JVM is not smart enough to traverse parameters_[] and null
0:     // out its members when the entire array is set to null (parameters_=null;).
0:     if (parameters_ != null)
0:       for (int i = 0; i < parameters_.length; i++) { parameters_[i] = null; }
0:     parameters_ = null;
1: 
0:     connection_.CommitAndRollbackListeners_.remove(this);
0:   }
1: 
0: }
============================================================================