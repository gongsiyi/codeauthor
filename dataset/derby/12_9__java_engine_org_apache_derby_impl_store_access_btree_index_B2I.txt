1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.index.B2I
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
23:eac0369: 
5:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree.index;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: import java.util.Properties;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:b61f876: 
1:b61f876: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:b61f876: 
1:b61f876: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostController;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:b61f876: import org.apache.derby.iapi.types.RowLocation;
1:b61f876: import org.apache.derby.iapi.types.StringDataValue;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.access.btree.BTree;
1:eac0369: import org.apache.derby.impl.store.access.btree.BTreeLockingPolicy;
1:eac0369: import org.apache.derby.impl.store.access.btree.LeafControlRow;
1:eac0369: import org.apache.derby.impl.store.access.btree.OpenBTree;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: 
1:b61f876: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:b61f876: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:b61f876: 
1:b61f876: 
1:fa09146: // For JavaDoc references (i.e. @see)
1:fa09146: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1:fa09146: 
1:b61f876: 
1:6081510: /*
1:787ceb4:  * @derby.formatId ACCESS_B2I_V3_ID
2:eac0369:  *
1:787ceb4:  * @derby.purpose   The tag that describes the on disk representation of the B2I
1:b61f876:  *            conglomerate object.  Access contains no "directory" of 
1:b61f876:  *            conglomerate information.  In order to bootstrap opening a file
1:b61f876:  *            it encodes the factory that can open the conglomerate in the 
1:b61f876:  *            conglomerate id itself.  There exists a single B2IFactory which
1:b61f876:  *            must be able to read all btree format id's.  
1:28e234d:  *
1:b61f876:  *            This format was used for all Derby database B2I's in version
1:b61f876:  *            10.2 and previous versions.
1:b61f876:  *
1:787ceb4:  * @derby.upgrade   The format id of this object is currently always read from disk
1:b61f876:  *            as the first field of the conglomerate itself.  A bootstrap
1:b61f876:  *            problem exists as we don't know the format id of the B2I 
1:b61f876:  *            until we are in the "middle" of reading the B2I.  Thus the
1:b61f876:  *            base B2I implementation must be able to read and write 
1:b61f876:  *            all formats based on the reading the 
1:b61f876:  *            "format_of_this_conglomerate". 
1:b61f876:  *
1:b61f876:  *            soft upgrade to ACCESS_B2I_V4_ID:
1:b61f876:  *                read:
1:b61f876:  *                    old format is readable by current B2I implementation,
1:b61f876:  *                    with automatic in memory creation of default collation
1:b61f876:  *                    id needed by new format.  No code other than
1:b61f876:  *                    readExternal and writeExternal need know about old format.
1:b61f876:  *                write:
1:b61f876:  *                    will never write out new format id in soft upgrade mode.
1:b61f876:  *                    Code in readExternal and writeExternal handles writing
1:b61f876:  *                    correct version.  Code in the factory handles making
1:b61f876:  *                    sure new conglomerates use the B2I_v10_2 class to 
1:b61f876:  *                    that will write out old format info.
1:b61f876:  *
1:b61f876:  *            hard upgrade to ACCESS_B2I_V4_ID:
1:b61f876:  *                read:
1:b61f876:  *                    old format is readable by current B2I implementation,
1:b61f876:  *                    with automatic in memory creation of default collation
1:b61f876:  *                    id needed by new format.
1:b61f876:  *                write:
1:b61f876:  *                    Only "lazy" upgrade will happen.  New format will only
1:b61f876:  *                    get written for new conglomerate created after the 
1:b61f876:  *                    upgrade.  Old conglomerates continue to be handled the
1:b61f876:  *                    same as soft upgrade.
1:eac0369:  *
1:787ceb4:  * @derby.diskLayout 
1:b61f876:  *     format_of_this_conlgomerate(byte[])
1:eac0369:  *     containerid(long)
1:eac0369:  *     segmentid(int)
1:eac0369:  *     number_of_key_fields(int)
1:eac0369:  *     number_of_unique_columns(int)
1:eac0369:  *     allow_duplicates(boolean)
1:eac0369:  *     maintain_parent_links(boolean)
1:eac0369:  *     array_of_format_ids(byte[][])
1:eac0369:  *     baseConglomerateId(long)
1:eac0369:  *     rowLocationColumn(int)
1:b61f876:  *     ascend_column_info(FormatableBitSet)
1:b61f876:  *
1:6081510:  */
1:eac0369: 
1:6081510: /*
1:787ceb4:  * @derby.formatId ACCESS_B2I_V4_ID
1:eac0369:  *
1:787ceb4:  * @derby.purpose   The tag that describes the on disk representation of the B2I
1:b61f876:  *            conglomerate object.  Access contains no "directory" of 
1:b61f876:  *            conglomerate information.  In order to bootstrap opening a file
1:b61f876:  *            it encodes the factory that can open the conglomerate in the 
1:b61f876:  *            conglomerate id itself.  There exists a single B2IFactory which
1:b61f876:  *            must be able to read all btree format id's.  
1:eac0369:  *
1:28e234d:  *            This format was used for all Derby database B2I's in version 10.3.
1:28e234d:  *
1:787ceb4:  * @derby.upgrade   The format id of this object is currently always read from disk
1:28e234d:  *            as the first field of the conglomerate itself.  A bootstrap
1:28e234d:  *            problem exists as we don't know the format id of the B2I 
1:28e234d:  *            until we are in the "middle" of reading the B2I.  Thus the
1:28e234d:  *            base B2I implementation must be able to read and write 
1:28e234d:  *            all formats based on the reading the 
1:28e234d:  *            "format_of_this_conglomerate". 
1:eac0369:  *
1:28e234d:  *            soft upgrade to ACCESS_B2I_V5_ID:
1:28e234d:  *                read:
1:28e234d:  *                    old format is readable by current B2I implementation,
1:28e234d:  *                    with automatic in memory creation of default
1:28e234d:  *                    isUniqueWithDuplicateNulls value of false.
1:28e234d:  *                    No code other than readExternal and writeExternal need 
1:28e234d:  *                    know about old format.
1:28e234d:  *                write:
1:28e234d:  *                    will never write out new format id in soft upgrade mode.
1:28e234d:  *                    Code in readExternal and writeExternal handles writing
1:28e234d:  *                    correct version.  Code in the factory handles making
1:28e234d:  *                    sure new conglomerates use the B2I_v10_3 class
1:28e234d:  *                    that will write out old format info.
1:28e234d:  *
1:28e234d:  *            hard upgrade to ACCESS_B2I_V5_ID:
1:28e234d:  *                read:
1:28e234d:  *                    old format is readable by current B2I implementation,
1:28e234d:  *                    with automatic in memory creation of default
1:28e234d:  *                    isUniqueWithDuplicateNulls value of false.
1:28e234d:  *
1:28e234d:  *                write:
1:28e234d:  *                    Only "lazy" upgrade will happen.  New format will only
1:28e234d:  *                    get written for new conglomerate created after the 
1:28e234d:  *                    upgrade.  Old conglomerates continue to be handled the
1:28e234d:  *                    same as soft upgrade.
1:28e234d:  *
1:787ceb4:  * @derby.diskLayout 
1:28e234d:  *     format_of_this_conlgomerate(byte[])
1:28e234d:  *     containerid(long)
1:28e234d:  *     segmentid(int)
1:28e234d:  *     number_of_key_fields(int)
1:28e234d:  *     number_of_unique_columns(int)
1:28e234d:  *     allow_duplicates(boolean)
1:28e234d:  *     maintain_parent_links(boolean)
1:28e234d:  *     array_of_format_ids(byte[][])
1:28e234d:  *     baseConglomerateId(long)
1:28e234d:  *     rowLocationColumn(int)
1:28e234d:  *     ascend_column_info(FormatableBitSet)
1:28e234d:  *     collation_ids(compressed array of ints)
1:28e234d:  *
1:28e234d:  */
1:28e234d: 
1:28e234d: /*
1:787ceb4:  * @derby.formatId ACCESS_B2I_V5_ID
1:28e234d:  *
1:787ceb4:  * @derby.purpose   The tag that describes the on disk representation of the B2I
1:28e234d:  *            conglomerate object.  Access contains no "directory" of 
1:28e234d:  *            conglomerate information.  In order to bootstrap opening a file
1:28e234d:  *            it encodes the factory that can open the conglomerate in the 
1:28e234d:  *            conglomerate id itself.  There exists a single B2IFactory which
1:28e234d:  *            must be able to read all btree format id's.  
1:28e234d:  *
1:b61f876:  *            This format is the current version id of B2I and has been used 
1:28e234d:  *            in versions of Derby after the 10.3 release.
1:b61f876:  *
1:787ceb4:  * @derby.upgrade   This is the current version, no upgrade necessary.
1:eac0369:  *
1:787ceb4:  * @derby.diskLayout 
2:eac0369:  *     format_of_this_conlgomerate(byte[])
1:eac0369:  *     containerid(long)
1:eac0369:  *     segmentid(int)
1:eac0369:  *     number_of_key_fields(int)
1:eac0369:  *     number_of_unique_columns(int)
1:eac0369:  *     allow_duplicates(boolean)
1:eac0369:  *     maintain_parent_links(boolean)
1:eac0369:  *     array_of_format_ids(byte[][])
1:eac0369:  *     baseConglomerateId(long)
1:eac0369:  *     rowLocationColumn(int)
1:b61f876:  *     ascend_column_info(FormatableBitSet)
1:b61f876:  *     collation_ids(compressed array of ints)
1:28e234d:  *     isUniqueWithDuplicateNulls(boolean)
1:6081510:  */
1:eac0369: 
1:6081510: /**
1:6081510:  * Implements an instance of a B-Tree secondary index conglomerate.
1:6081510:  * A B2I object has two roles.
1:6081510:  * <ol>
1:6081510:  * <li>
1:6081510:  * The B2I object is stored on disk, and holds the store specific
1:6081510:  * information needed to access/describe the conglomerate. This
1:6081510:  * includes information such as the format ids of the columns, 
1:6081510:  * the conglomerate id of the base table, the location of 
1:6081510:  * row location column.
1:6081510:  * </li>
1:6081510:  * <li>
1:6081510:  * Access to all the interfaces start by making a call off the
1:6081510:  * Conglomerate interface. So for instance to get a scan on the
1:6081510:  * conglomerate method {@link #openScan openScan} should be called.
1:6081510:  * </li>
1:6081510:  * </ol>
1:6081510:  */
1:eac0369: public class B2I extends BTree
8:eac0369: {
1:18176ce:     private static final String PROPERTY_BASECONGLOMID = "baseConglomerateId";
1:18176ce:     private static final String PROPERTY_ROWLOCCOLUMN  = "rowLocationColumn";
1:eac0369: 
1:28e234d:     static final int FORMAT_NUMBER = StoredFormatIds.ACCESS_B2I_V5_ID;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Fields of B2I.
1:eac0369: 	*/
1:eac0369: 
9:eac0369: 	/**
1:eac0369: 	The id of the conglomerate which contains the base table.
1:eac0369: 	Row locations inserted into this secondary index are assumed
1:eac0369: 	to refer to that conglomerate.  Used to obtain table/row locks on the
1:eac0369:     base table rows which the index rows point at.
4:eac0369: 	**/
1:18176ce: 	long baseConglomerateId;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The column id (zero-based integer index) of the column which holds the row 
1:eac0369:     location to the base conglomerate.
1:eac0369: 	The default value of RowLocationColumn is the last key column.
1:eac0369:     Used to obtain table/row locks on the base table rows with the index rows
1:eac0369:     point at.
1:eac0369: 	Currently, RowLocationColumn must be the last key column.
1:eac0369: 	**/
1:18176ce: 	int rowLocationColumn;
1:eac0369: 
1:b61f876:     private static final int BASE_MEMORY_USAGE = 
1:b61f876:         ClassSize.estimateBaseFromCatalog( B2I.class);
1:eac0369: 
1:eac0369:     public int estimateMemoryUsage()
1:eac0369:     {
1:eac0369:         return BASE_MEMORY_USAGE;
10:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constructors for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Protected locking implmentations of abtract BTree routines:
1:eac0369:      *     getBtreeLockingPolicy
1:eac0369:      *     lockTable
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:b61f876:     /**
1:eac0369:      * Create a new btree locking policy from scratch.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     protected BTreeLockingPolicy getBtreeLockingPolicy(
1:eac0369:     Transaction             rawtran,
1:eac0369:     int                     lock_level,
1:eac0369:     int                     mode,
1:eac0369:     int                     isolation_level,
1:eac0369:     ConglomerateController  base_cc,
1:eac0369:     OpenBTree               open_btree)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         BTreeLockingPolicy ret_locking_policy = null;
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 (isolation_level == 
1:eac0369:                      TransactionController.ISOLATION_SERIALIZABLE)      ||
1:eac0369:                 (isolation_level == 
1:eac0369:                      TransactionController.ISOLATION_REPEATABLE_READ)   ||
1:eac0369:                 (isolation_level == 
1:eac0369:                      TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK) ||
1:eac0369:                 (isolation_level == 
1:eac0369:                      TransactionController.ISOLATION_READ_COMMITTED)    ||
1:eac0369:                 (isolation_level == 
1:eac0369:                      TransactionController.ISOLATION_READ_UNCOMMITTED),
1:eac0369:                 "bad isolation_level = " + isolation_level);
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (lock_level == TransactionController.MODE_TABLE)
1:eac0369:         {
1:eac0369:             ret_locking_policy = 
1:eac0369:                 new B2ITableLocking3(
1:eac0369:                     rawtran,
1:eac0369:                     lock_level,
1:eac0369:                     rawtran.newLockingPolicy(
1:eac0369:                         LockingPolicy.MODE_CONTAINER, 
1:eac0369:                         isolation_level,
1:eac0369:                         true), 
1:eac0369:                     base_cc,
1:eac0369:                     open_btree);
1:eac0369:         }
1:eac0369:         else if (lock_level == TransactionController.MODE_RECORD)
1:eac0369:         {
1:eac0369:             if (isolation_level == TransactionController.ISOLATION_SERIALIZABLE)
1:eac0369:             {
1:eac0369:                 ret_locking_policy = 
1:eac0369:                     new B2IRowLocking3(
1:eac0369:                         rawtran,
1:eac0369:                         lock_level,
1:eac0369:                         rawtran.newLockingPolicy(
1:eac0369:                             LockingPolicy.MODE_RECORD, 
1:eac0369:                             isolation_level,
1:eac0369:                             true), 
1:eac0369:                         base_cc,
1:eac0369:                         open_btree);
1:eac0369:             }
1:eac0369:             else if ((isolation_level == 
1:eac0369:                         TransactionController.ISOLATION_REPEATABLE_READ))
1:eac0369:             {
1:eac0369:                 ret_locking_policy = 
1:eac0369:                     new B2IRowLockingRR(
1:eac0369:                         rawtran,
1:eac0369:                         lock_level,
1:eac0369:                         rawtran.newLockingPolicy(
1:eac0369:                             LockingPolicy.MODE_RECORD, 
1:eac0369:                             isolation_level,
1:eac0369:                             true), 
1:eac0369:                         base_cc,
1:eac0369:                         open_btree);
1:eac0369:             }
1:eac0369:             else if ((isolation_level == 
1:eac0369:                         TransactionController.ISOLATION_READ_COMMITTED) ||
1:eac0369:                      (isolation_level == 
1:eac0369:                         TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK))
1:eac0369:             {
1:eac0369:                 ret_locking_policy = 
1:eac0369:                     new B2IRowLocking2(
1:eac0369:                         rawtran,
1:eac0369:                         lock_level,
1:eac0369:                         rawtran.newLockingPolicy(
1:eac0369:                             LockingPolicy.MODE_RECORD, 
1:eac0369:                             isolation_level,
1:eac0369:                             true), 
1:eac0369:                         base_cc,
1:eac0369:                         open_btree);
1:eac0369:             }
1:eac0369:             else if (isolation_level == 
1:eac0369:                         TransactionController.ISOLATION_READ_UNCOMMITTED)
1:eac0369:             {
1:eac0369:                 ret_locking_policy = 
1:eac0369:                     new B2IRowLocking1(
1:eac0369:                         rawtran,
1:eac0369:                         lock_level,
1:eac0369:                         rawtran.newLockingPolicy(
1:eac0369:                             LockingPolicy.MODE_RECORD, 
1:eac0369:                             isolation_level,
1:eac0369:                             true), 
1:eac0369:                         base_cc,
1:eac0369:                         open_btree);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 ret_locking_policy != null, "ret_locking_policy == null");
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_locking_policy);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Lock the base table.
1:eac0369:      * <p>
1:eac0369:      * Assumes that segment of the base container is the same as the segment
1:eac0369:      * of the btree segment.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE - we really want to get the lock without opening the container.
1:eac0369:      * raw store will be providing this.
1:eac0369:      *
1:eac0369:      * @param xact_manager Transaction to associate the lock with.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public final ConglomerateController lockTable(
1:eac0369:     TransactionManager  xact_manager,
1:eac0369:     int                 open_mode,
1:eac0369:     int                 lock_level,
1:eac0369:     int                 isolation_level)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         open_mode |= TransactionController.OPENMODE_FOR_LOCK_ONLY;
1:eac0369: 
1:eac0369:         // open the base conglomerate - just to get the table lock.
1:eac0369:         ConglomerateController cc = 
1:eac0369:             xact_manager.openConglomerate(
1:eac0369:                 this.baseConglomerateId, false, open_mode, lock_level, 
1:eac0369:                 isolation_level);
1:eac0369: 
1:eac0369:         return(cc);
1:eac0369:     }
1:28e234d:     
1:eac0369:     /**************************************************************************
1:eac0369: 	 *  Private methods of B2I, arranged alphabetically.
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 
1:eac0369:     private void traverseRight()
1:eac0369:     {
1:eac0369:         // RESOLVE - Do I have to do this???????????????
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.THROWASSERT("not implemented.");
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of B2I.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Create an empty secondary index b-tree, using the generic b-tree to do the
1:eac0369:     generic part of the creation process.
1:eac0369: 
1:eac0369:     This routine opens the newly created container, adds a single page, and
1:eac0369:     makes this page the root by inserting a LeafControlRow onto this page
1:eac0369:     at slot 0 and marking in that control row that the page is a root page.
1:eac0369: 
1:eac0369:     The following properties are specific to the b-tree secondary index:
1:eac0369:     <UL>
1:eac0369:     <LI> "baseConglomerateId" (integer).  The conglomerate id of the base
1:eac0369:     conglomerate is never actually accessed by the b-tree secondary
1:eac0369:     index implementation, it only serves as a namespace for row locks.
1:eac0369:     This property is required.
1:eac0369:     <LI> "rowLocationColumn" (integer).  The zero-based index into the row which
1:eac0369:     the b-tree secondary index will assume holds a @see RowLocation of
1:eac0369:     the base row in the base conglomerate.  This value will be used
1:eac0369:     for acquiring locks.  In this implementation RowLocationColumn must be 
1:eac0369:     the last key column.
1:eac0369:     This property is required.
1:eac0369:     </UL>
1:eac0369: 
1:eac0369:     A secondary index i (a, b) on table t (a, b, c) would have rows
1:eac0369:     which looked like (a, b, row_location).  baseConglomerateId is set to the
1:eac0369:     conglomerate id of t.  rowLocationColumns is set to 2.  allowsDuplicates
1:eac0369:     would be set to false, @see BTree#create.  To create a unique
1:eac0369:     secondary index set uniquenessColumns to 2, this means that the btree
1:eac0369:     code will compare the key values but not the row id when determing
1:eac0369:     uniqueness.  To create a nonunique secondary index set uniquenessColumns
1:eac0369:     to 3, this would mean that the uniqueness test would include the row
1:eac0369:     location and since all row locations will be unique  all rows inserted 
1:eac0369:     into the index will be differentiated (at least) by row location.  
1:eac0369: 
1:eac0369: 	@see BTree#create
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public void create(
1:eac0369:     TransactionManager      xact_manager,
1:eac0369:     int                     segmentId, 
1:eac0369:     long                    input_conglomid, 
1:eac0369:     DataValueDescriptor[]	template, 
1:eac0369: 	ColumnOrdering[]	    columnOrder,
1:b61f876:     int[]                   collationIds,
1:eac0369:     Properties              properties,
1:eac0369: 	int                     temporaryFlag)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         String      property_value = null;
1:eac0369:         Transaction rawtran        = xact_manager.getRawStoreXact();
1:eac0369: 
1:eac0369:         if (properties == null)
1:eac0369:         {
1:eac0369:             throw(StandardException.newException(
1:eac0369:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));
1:eac0369:         }
1:eac0369: 
1:eac0369:         // Get baseConglomerateId //
1:eac0369:         property_value = properties.getProperty(PROPERTY_BASECONGLOMID);
1:eac0369:         if (property_value == null)
1:eac0369:         {
1:eac0369:             throw(StandardException.newException(
1:eac0369:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 			if (property_value == null)
1:eac0369:             	SanityManager.THROWASSERT(
1:eac0369:                 	PROPERTY_BASECONGLOMID +
1:eac0369: 					"property not passed to B2I.create()");
1:eac0369:         }
1:eac0369: 
1:eac0369:         baseConglomerateId = Long.parseLong(property_value);
1:eac0369: 
1:eac0369:         // Get rowLocationColumn //
1:eac0369:         property_value = properties.getProperty(PROPERTY_ROWLOCCOLUMN);
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369: 			if (property_value == null)
1:eac0369:             	SanityManager.THROWASSERT(
1:eac0369:                 	PROPERTY_ROWLOCCOLUMN +
1:eac0369: 					"property not passed to B2I.create()");
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (property_value == null)
1:eac0369:         {
1:eac0369:             throw(StandardException.newException(
1:eac0369:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));
1:eac0369:         }
1:eac0369: 
1:eac0369:         rowLocationColumn = Integer.parseInt(property_value);
1:eac0369: 
1:eac0369:         // Currently the row location column must be the last column (makes)
1:eac0369:         // comparing the columns in the index easier.
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(rowLocationColumn == template.length - 1, 
1:eac0369:                 "rowLocationColumn is not the last column in the index");
1:eac0369:             SanityManager.ASSERT(
1:eac0369:                 template[rowLocationColumn] instanceof 
1:eac0369:                     RowLocation);
1:eac0369: 
1:eac0369:             // There must be at least one key column
1:eac0369: 			if (rowLocationColumn < 1)
1:eac0369:             	SanityManager.THROWASSERT(
1:eac0369: 					"rowLocationColumn (" + rowLocationColumn +
1:eac0369: 					") expected to be >= 1");
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:b61f876: 		/* convert the sorting order information into a boolean array map.
1:eac0369: 		 * If the sorting order for the columns is not provided, we
1:eac0369: 		 * assign the default as Ascending Order.
1:b61f876: 		 * array length is equal to template length, because column order
1:b61f876: 		 * length changes whether it is unique or is non unique. store assumes
1:b61f876: 		 * template length arrays. So, we make template length array and make
1:b61f876: 		 * the last column as ascending instead of having lot of execeptions 
1:b61f876:          * code.
1:eac0369: 		 */
1:eac0369: 		
1:eac0369: 		ascDescInfo = new boolean[template.length];
3:eac0369: 		for (int i=0 ; i < ascDescInfo.length; i++)
1:eac0369: 		{
1:eac0369: 			if (columnOrder != null && i < columnOrder.length)
1:eac0369: 				ascDescInfo[i] = columnOrder[i].getIsAscending();
2:eac0369: 			else
1:eac0369: 				ascDescInfo[i] = true;  // default values - ascending order
1:eac0369: 		}
1:eac0369: 
1:b61f876:         // get collation ids from input collation ids, store it in the 
1:b61f876:         // conglom state.
1:b61f876:         collation_ids = 
1:b61f876:             ConglomerateUtil.createCollationIds(template.length, collationIds);
1:9a3cbed:         hasCollatedTypes = hasCollatedColumns(collation_ids);
1:b61f876: 
1:eac0369: 		// Do the generic part of creating the b-tree.
1:b61f876: 		super.create(
1:b61f876:             rawtran, segmentId, input_conglomid, template, 
1:b61f876:             properties, getTypeFormatId(), temporaryFlag);
1:eac0369: 
1:eac0369:         // open the base conglomerate - to get the lock
1:eac0369:         ConglomerateController base_cc = 
1:eac0369:             xact_manager.openConglomerate(
1:eac0369:                 baseConglomerateId,
1:eac0369:                 false,
1:eac0369:                 TransactionController.OPENMODE_FOR_LOCK_ONLY, 
1:eac0369:                 TransactionController.MODE_TABLE,
1:eac0369:                 TransactionController.ISOLATION_SERIALIZABLE);
1:eac0369:         
1:eac0369:         OpenBTree open_btree = new OpenBTree();
1:eac0369: 
1:eac0369:         BTreeLockingPolicy b2i_locking_policy = 
1:eac0369:             new B2ITableLocking3(
1:eac0369:                 rawtran,
1:eac0369:                 TransactionController.MODE_TABLE,
1:eac0369:                 rawtran.newLockingPolicy(
1:eac0369:                     LockingPolicy.MODE_CONTAINER,
1:b61f876:                     TransactionController.ISOLATION_SERIALIZABLE, true), 
1:b61f876:                 base_cc, open_btree);
1:eac0369: 
1:eac0369: 
1:eac0369:         // The following call will "open" the new btree.  Create is
1:eac0369:         // an interesting case.  What we really want is read only table lock
1:eac0369:         // on the base conglomerate and update locks on the index.  For now
1:eac0369:         // just get the update lock on the base table, this is done by the
1:eac0369:         // lockTable() call made by base class.
1:eac0369: 
1:eac0369:         open_btree.init(
1:eac0369:             (TransactionManager) xact_manager,  // current user xact
1:eac0369:             (TransactionManager) xact_manager,  // current xact
1:eac0369:             (ContainerHandle) null,     // have init open the container.
1:eac0369:             rawtran, 
1:eac0369:             false,
1:eac0369:             (ContainerHandle.MODE_FORUPDATE),
1:eac0369:             TransactionController.MODE_TABLE,
1:eac0369:             b2i_locking_policy,         // get table level lock.
1:eac0369:             this,                       
1:eac0369:             (LogicalUndo) null,         // no logical undo necessary, as 
1:eac0369:                                         // initEmptyBtree()
1:eac0369:                                         // work will be done single user and
1:eac0369:                                         // rows will not move.
1:eac0369:             (DynamicCompiledOpenConglomInfo) null);
1:eac0369:                                         
1:eac0369: 		// Open the newly created container, and insert the first control row.
1:eac0369:         LeafControlRow.initEmptyBtree(open_btree);
1:eac0369: 
1:eac0369:         open_btree.close();
1:eac0369: 
1:eac0369:         base_cc.close();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of Conglomerate
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Retrieve the maximum value row in an ordered conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Returns true and fetches the rightmost row of an ordered conglomerate 
1:eac0369:      * into "fetchRow" if there is at least one row in the conglomerate.  If
1:eac0369:      * there are no rows in the conglomerate it returns false.
1:eac0369:      * <p>
1:eac0369:      * Non-ordered conglomerates will not implement this interface, calls
1:eac0369:      * will generate a StandardException.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE - this interface is temporary, long term equivalent (and more) 
1:eac0369:      * functionality will be provided by the openBackwardScan() interface.  
1:eac0369:      *
1:eac0369: 	 * @param xact_manager    The TransactionController under which this 
1:eac0369:      *                        operation takes place.
1:eac0369:      *
1:eac0369: 	 * @param conglomId       The identifier of the conglomerate
1:eac0369: 	 *                        to open the scan for.
1:eac0369:      *
1:eac0369: 	 * @param open_mode       Specifiy flags to control opening of table.  
1:eac0369:      *                        OPENMODE_FORUPDATE - if set open the table for
1:eac0369:      *                        update otherwise open table shared.
1:eac0369:      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
1:eac0369:      *
1:eac0369:      * @param isolation_level The isolation level to lock the conglomerate at.
1:b61f876:      *                        One of (ISOLATION_READ_COMMITTED or 
1:b61f876:      *                        ISOLATION_SERIALIZABLE).
1:eac0369:      *
1:eac0369: 	 * @param scanColumnList  A description of which columns to return from 
1:eac0369:      *                        every fetch in the scan.  template, 
1:eac0369:      *                        and scanColumnList work together
1:eac0369:      *                        to describe the row to be returned by the scan - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a "row".
1:eac0369:      *
1:eac0369:      * @param fetchRow        The row to retrieve the maximum value into.
1:eac0369:      *
1:eac0369: 	 * @return boolean indicating if a row was found and retrieved or not.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public boolean fetchMaxOnBTree(
1:eac0369:     TransactionManager      xact_manager,
1:eac0369:     Transaction             rawtran,
1:eac0369:     long                    conglomId,
1:eac0369:     int                     open_mode,
1:eac0369:     int                     lock_level,
1:eac0369:     LockingPolicy           locking_policy,
1:eac0369:     int                     isolation_level,
1:eac0369:     FormatableBitSet                 scanColumnList,
1:eac0369:     DataValueDescriptor[]   fetchRow)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         boolean row_exists;
1:eac0369: 
1:eac0369:         // row level locking implementation.
1:eac0369: 
1:eac0369:         // RESOLVE (revisit implementation after all the Xena rowlocking
1:eac0369:         // changes have been made).  Can probably come up with single
1:eac0369:         // path implementation.
1:eac0369:         
1:eac0369:         // Create a new b-tree secondary index scan.
1:eac0369:         B2IMaxScan b2is = new B2IMaxScan();
1:eac0369: 
1:eac0369:         // Initialize it.
1:eac0369:         b2is.init(
1:eac0369:             xact_manager, 
1:eac0369:             rawtran, 
1:eac0369:             open_mode,
1:eac0369:             lock_level,
1:eac0369:             locking_policy,
1:eac0369:             isolation_level,
1:eac0369:             true /* get locks on base table as part of open */,
1:eac0369:             scanColumnList,
1:eac0369:             this, 
1:eac0369:             new B2IUndo());
1:eac0369: 
1:eac0369:         row_exists = b2is.fetchMax(fetchRow);
1:eac0369: 
1:eac0369:         b2is.close();
1:eac0369: 
1:eac0369:         return(row_exists);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Bulk Load a B-tree secondary index.
1:eac0369: 
1:eac0369: 	@see Conglomerate#load
1:94f158a: 	@exception StandardException Standard Derby Error policy.
1:eac0369: 	raise SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION if a duplicate 
1:eac0369:     key is detected in the load.
1:eac0369: 	**/
1:eac0369: 
1:eac0369: 	public long load(
1:eac0369: 	TransactionManager      xact_manager,
1:eac0369: 	boolean                 createConglom,
1:eac0369: 	RowLocationRetRowSource rowSource)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369:         long num_rows_loaded = 0;
1:eac0369: 		B2IController b2ic = new B2IController();
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369:             int open_mode = TransactionController.OPENMODE_FORUPDATE;
1:eac0369: 
1:eac0369:             if (createConglom)
1:eac0369:             {
1:eac0369:                 open_mode |=
1:eac0369:                     (ContainerHandle.MODE_UNLOGGED |
1:eac0369:                      ContainerHandle.MODE_CREATE_UNLOGGED);
1:eac0369:             }
1:eac0369: 
1:eac0369:             // Do the actual open of the container in the super class.
1:eac0369:             b2ic.init(
1:eac0369:                 xact_manager,                    // current transaction   
1:eac0369:                 xact_manager.getRawStoreXact(),  // current raw store xact
1:44e4f27:                 false,                           // Not holdable
1:eac0369:                 open_mode,
1:eac0369:                 TransactionController.MODE_TABLE,
1:eac0369:                 xact_manager.getRawStoreXact().newLockingPolicy(
1:eac0369:                     LockingPolicy.MODE_CONTAINER,
1:eac0369:                     TransactionController.ISOLATION_SERIALIZABLE, true),
1:eac0369:                 true,
1:eac0369:                 this, 
1:eac0369:                 new B2IUndo(),
1:eac0369:                 (B2IStaticCompiledInfo) null,
1:eac0369:                 (DynamicCompiledOpenConglomInfo) null);
1:eac0369: 
1:eac0369:             num_rows_loaded = b2ic.load(xact_manager, createConglom, rowSource);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			b2ic.close();
1:eac0369: 		}
1:eac0369: 
1:eac0369:         return(num_rows_loaded);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Open a b-tree controller.
1:eac0369: 	@see Conglomerate#open
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public ConglomerateController open(
1:eac0369:     TransactionManager              xact_manager,
1:eac0369:     Transaction                     rawtran, 
1:eac0369:     boolean                         hold,
1:eac0369:     int                             open_mode,
1:eac0369:     int                             lock_level,
1:eac0369:     LockingPolicy                   locking_policy,
1:eac0369:     StaticCompiledOpenConglomInfo   static_info,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// Create a new b-tree secondary index controller.
1:eac0369: 		B2IController b2ic = new B2IController();
1:eac0369: 
1:eac0369: 		// Do the actual open of the container in the super class.
1:eac0369: 		b2ic.init(
1:eac0369:             xact_manager,               // current transaction   
1:eac0369:             rawtran,                    // current raw store transaction
1:44e4f27:             hold,                       // holdability
1:eac0369:             open_mode,
1:eac0369:             lock_level,
1:eac0369:             locking_policy,
1:eac0369:             true,
1:eac0369:             this, 
1:eac0369:             new B2IUndo(),
1:eac0369:             (B2IStaticCompiledInfo) static_info,
1:eac0369:             dynamic_info);
1:eac0369: 
1:eac0369: 		// Return it to the caller.
1:eac0369: 		return b2ic;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Open a b-tree secondary index scan controller.
1:eac0369: 	@see Conglomerate#openScan
1:eac0369: 	@see BTree#openScan
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public ScanManager openScan(
1:eac0369:     TransactionManager              xact_manager,
1:eac0369:     Transaction                     rawtran,
1:eac0369:     boolean                         hold,
1:eac0369:     int                             open_mode,
1:eac0369:     int                             lock_level,
1:eac0369:     LockingPolicy                   locking_policy,
1:eac0369:     int                             isolation_level,
1:eac0369: 	FormatableBitSet                         scanColumnList,
1:eac0369:     DataValueDescriptor[]			startKeyValue,
1:eac0369:     int                             startSearchOperator,
1:eac0369:     Qualifier                       qualifier[][],
1:eac0369:     DataValueDescriptor[]			stopKeyValue,
1:eac0369:     int                             stopSearchOperator,
1:eac0369:     StaticCompiledOpenConglomInfo   static_info,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		// Create a new b-tree secondary index scan.
1:eac0369: 		B2IForwardScan b2is = new B2IForwardScan();
1:eac0369: 
1:eac0369: 		// Initialize it.
1:eac0369: 		b2is.init(xact_manager, rawtran, 
1:eac0369:                   hold,
1:eac0369:                   open_mode,
1:eac0369:                   lock_level,
1:eac0369:                   locking_policy,
1:eac0369:                   isolation_level,
1:eac0369:                   true /* get locks on base table as part of open */,
1:eac0369:                   scanColumnList,
1:eac0369:                   startKeyValue, startSearchOperator,
1:eac0369:                   qualifier,
1:eac0369:                   stopKeyValue, stopSearchOperator, this, new B2IUndo(),
1:eac0369:                   (B2IStaticCompiledInfo) static_info,
1:eac0369:                   dynamic_info);
1:eac0369: 
1:eac0369: 		// Return it to the caller.
1:eac0369: 		return b2is;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:bbc927c:      * Open a b-tree compress scan.
1:bbc927c:      * <p>
1:bbc927c:      * B2I does not support a compress scan.
1:bbc927c:      * <p>
1:41a0826: 	 * @see Conglomerate#defragmentConglomerate
1:bbc927c:      *
1:bbc927c: 	 * @exception  StandardException  Standard exception policy.
1:bbc927c:      **/
1:bbc927c: 	public ScanManager defragmentConglomerate(
1:bbc927c:     TransactionManager              xact_manager,
1:bbc927c:     Transaction                     rawtran,
1:bbc927c:     boolean                         hold,
1:bbc927c:     int                             open_mode,
1:bbc927c:     int                             lock_level,
1:bbc927c:     LockingPolicy                   locking_policy,
1:bbc927c:     int                             isolation_level)
1:bbc927c: 			throws StandardException
1:bbc927c: 	{
1:bbc927c:         throw StandardException.newException(
1:bbc927c:             SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1:bbc927c: 	}
1:bbc927c: 
1:bbc927c: 	public void purgeConglomerate(
1:bbc927c:     TransactionManager              xact_manager,
1:bbc927c:     Transaction                     rawtran)
1:bbc927c:         throws StandardException
1:965be70:     {
1:bbc927c:         // currently on work to do in btree's for purge rows, purging
1:bbc927c:         // happens best when split is about to happen.
1:bbc927c:         return;
1:965be70:     }
1:965be70: 
1:bbc927c: 	public void compressConglomerate(
1:bbc927c:     TransactionManager              xact_manager,
1:bbc927c:     Transaction                     rawtran)
1:bbc927c:         throws StandardException
1:bbc927c:     {
1:965be70: 		B2IController b2ic = new B2IController();
1:965be70: 
1:965be70: 		try
1:bbc927c: 		{
1:965be70:             int open_mode = TransactionController.OPENMODE_FORUPDATE;
1:965be70: 
1:965be70:             // Do the actual open of the container in the super class.
1:965be70:             b2ic.init(
1:965be70:                 xact_manager,                    // current transaction   
1:965be70:                 xact_manager.getRawStoreXact(),  // current raw store xact
1:44e4f27:                 false,                           // Not holdable
1:965be70:                 open_mode,
1:965be70:                 TransactionController.MODE_TABLE,
1:965be70:                 xact_manager.getRawStoreXact().newLockingPolicy(
1:965be70:                     LockingPolicy.MODE_CONTAINER,
1:965be70:                     TransactionController.ISOLATION_SERIALIZABLE, true),
1:965be70:                 true,
1:965be70:                 this, 
1:965be70:                 new B2IUndo(),
1:965be70:                 (B2IStaticCompiledInfo) null,
1:965be70:                 (DynamicCompiledOpenConglomInfo) null);
1:bbc927c: 
1:965be70:             b2ic.getContainer().compressContainer();
1:965be70: 
1:965be70: 		}
1:965be70: 		finally
1:965be70: 		{
1:965be70: 			b2ic.close();
1:bbc927c: 		}
1:965be70: 
1:bbc927c:         return;
1:bbc927c:     }
1:bbc927c: 
1:bbc927c:     /**
1:eac0369:      * Return an open StoreCostController for the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Return an open StoreCostController which can be used to ask about 
1:eac0369:      * the estimated row counts and costs of ScanController and 
1:eac0369:      * ConglomerateController operations, on the given conglomerate.
1:eac0369:      * <p>
1:eac0369: 	 * @param xact_manager The TransactionController under which this 
1:eac0369:      *                     operation takes place.
1:eac0369: 	 * @param rawtran  raw transaction context in which scan is managed.
1:eac0369:      *
1:eac0369: 	 * @return The open StoreCostController.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369:      * @see StoreCostController
1:eac0369:      **/
1:eac0369:     public StoreCostController openStoreCost(
1:eac0369:     TransactionManager  xact_manager,
1:eac0369:     Transaction         rawtran)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         B2ICostController b2icost = new B2ICostController();
1:eac0369: 
1:eac0369:         b2icost.init(xact_manager, this, rawtran);
1:eac0369: 
1:eac0369:         return(b2icost);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Drop this b-tree secondary index.
1:eac0369: 	@see Conglomerate#drop
1:eac0369: 	@see BTree#drop
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369: 	**/
1:eac0369: 	public void drop(TransactionManager xact_manager)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         // HACK to get around problem where index is dropped after the base
1:eac0369:         // table.
1:eac0369:         ConglomerateController base_cc = null;
1:eac0369: 
1:eac0369: 
1:eac0369:         /* Get X table lock to make sure no thread is accessing index */
1:eac0369:         base_cc = 
1:eac0369:             lockTable(
1:eac0369:                 xact_manager, 
1:eac0369:                 TransactionController.OPENMODE_FORUPDATE, 
1:eac0369:                 TransactionController.MODE_TABLE,
1:eac0369:                 TransactionController.ISOLATION_REPEATABLE_READ);
1:eac0369: 
1:eac0369:         xact_manager.getRawStoreXact().dropContainer(id);
1:eac0369: 
1:eac0369:         if (base_cc != null)
1:eac0369:             base_cc.close();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return static information about the conglomerate to be included in a
1:eac0369:      * a compiled plan.
1:eac0369:      * <p>
1:eac0369:      * The static info would be valid until any ddl was executed on the 
1:eac0369:      * conglomid, and would be up to the caller to throw away when that 
1:eac0369:      * happened.  This ties in with what language already does for other 
1:eac0369:      * invalidation of static info.  The type of info in this would be 
1:eac0369:      * containerid and array of format id's from which templates can be created.
1:eac0369:      * The info in this object is read only and can be shared among as many 
1:eac0369:      * threads as necessary.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The static compiled information.
1:eac0369:      *
1:eac0369:      * @param conglomId The identifier of the conglomerate to open.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(
1:eac0369:     TransactionController   xact_manager,
1:eac0369:     long                    conglomId)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return(new B2IStaticCompiledInfo(xact_manager, this));
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of Storable (via Conglomerate via BTree).
1:eac0369: 	** This class is responsible for re/storing its
1:eac0369: 	** own state and calling its superclass to store its'.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() 
1:eac0369:     {
1:28e234d: 		return StoredFormatIds.ACCESS_B2I_V5_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:b61f876:      * Store the stored representation of the column value in the
1:b61f876:      * stream.
1:b61f876:      * <p>
1:b61f876:      * For more detailed description of the ACCESS_B2I_V3_ID format see 
1:b61f876:      * documentation at top of file.
1:b61f876:      *
1:b61f876:      * @see java.io.Externalizable#writeExternal
1:b61f876:      **/
1:b61f876: 	public void writeExternal_v10_2(ObjectOutput out) 
1:b61f876:         throws IOException 
1:b61f876:     {
2:eac0369: 		super.writeExternal(out);
2:eac0369: 		out.writeLong(baseConglomerateId);
2:eac0369: 		out.writeInt(rowLocationColumn);
1:eac0369: 
1:b61f876:         //write the columns ascend/descend information as bits
1:b61f876:         FormatableBitSet ascDescBits = 
1:b61f876:             new FormatableBitSet(ascDescInfo.length);
1:eac0369: 
1:b61f876:         for (int i = 0; i < ascDescInfo.length; i++)
1:b61f876:         {	
1:b61f876:             if (ascDescInfo[i])
1:b61f876:                 ascDescBits.set(i);
1:b61f876:         }
1:b61f876:         ascDescBits.writeExternal(out);
1:b61f876: 	}
1:eac0369: 
1:b61f876:     /**
1:b61f876:      * Store the stored representation of the column value in the
1:b61f876:      * stream.
1:b61f876:      * <p>
1:b61f876:      * For more detailed description of the ACCESS_B2I_V3_ID and 
1:b61f876:      * ACCESS_B2I_V4_ID formats see documentation at top of file.
1:b61f876:      *
1:b61f876:      * @see java.io.Externalizable#writeExternal
1:b61f876:      **/
1:28e234d: 	public void writeExternal_v10_3(ObjectOutput out) 
1:b61f876:         throws IOException 
1:b61f876:     {
1:b61f876:         // First part of ACCESS_B2I_V4_ID format is the ACCESS_B2I_V3_ID format.
1:b61f876:         writeExternal_v10_2(out);
1:28e234d: 		if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V4_ID
1:28e234d:                 || conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID)
1:b61f876:         {
1:b61f876:             // Now append sparse array of collation ids
1:b61f876:             ConglomerateUtil.writeCollationIdArray(collation_ids, out);
1:28e234d:         }
1:b61f876:     }
1:28e234d: 
1:28e234d: 
1:28e234d:     /**
1:28e234d:      * Store the stored representation of the column value in the
1:28e234d:      * stream.
1:28e234d:      * <p>
1:28e234d:      * For more detailed description of the ACCESS_B2I_V3_ID and 
1:28e234d:      * ACCESS_B2I_V5_ID formats see documentation at top of file.
1:28e234d:      *
1:28e234d:      * @see java.io.Externalizable#writeExternal
1:28e234d:      **/
1:28e234d:     public void writeExternal(ObjectOutput out) throws IOException {
1:28e234d:         writeExternal_v10_3 (out);
1:28e234d:         if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID)
1:28e234d:             out.writeBoolean (isUniqueWithDuplicateNulls());
1:28e234d:     }
1:eac0369: 
1:b61f876:     /**
1:b61f876:      * Restore the in-memory representation from the stream.
1:b61f876:      * <p>
1:b61f876:      *
1:b61f876:      * @exception ClassNotFoundException Thrown if the stored representation 
1:b61f876:      *                                   is serialized and a class named in 
1:b61f876:      *                                   the stream could not be found.
1:b61f876:      *
1:b61f876:      * @see java.io.Externalizable#readExternal
1:b61f876:      **/
1:4ecfb0e:     public void readExternal(ObjectInput in)
4:eac0369: 		throws IOException, ClassNotFoundException
1:eac0369: 	{
2:eac0369: 		super.readExternal(in);
2:eac0369: 		baseConglomerateId = in.readLong();
1:b61f876: 		rowLocationColumn  = in.readInt();
1:eac0369: 
1:b61f876:         // read the column sort order info
1:b61f876:         FormatableBitSet ascDescBits = new FormatableBitSet();
1:b61f876:         ascDescBits.readExternal(in);
1:b61f876:         ascDescInfo = new boolean[ascDescBits.getLength()];
1:b61f876:         for(int i =0 ; i < ascDescBits.getLength(); i++)
1:b61f876:             ascDescInfo[i] = ascDescBits.isSet(i);
1:28e234d:         
1:b61f876:         // In memory maintain a collation id per column in the template.
1:b61f876:         collation_ids = new int[format_ids.length];
1:9a3cbed:         if (SanityManager.DEBUG) {
1:9a3cbed:             SanityManager.ASSERT(!hasCollatedTypes);
1:9a3cbed:         }
1:b61f876: 
1:b61f876:         // initialize all the entries to COLLATION_TYPE_UCS_BASIC, 
1:b61f876:         // and then reset as necessary.  For version ACCESS_B2I_V3_ID,
1:b61f876:         // this is the default and no resetting is necessary.
1:b61f876:         for (int i = 0; i < format_ids.length; i++)
1:b61f876:             collation_ids[i] = StringDataValue.COLLATION_TYPE_UCS_BASIC;
1:b61f876: 
1:28e234d:         // initialize the unique with null setting to false, to be reset
1:28e234d:         // below when read from disk.  For version ACCESS_B2I_V3_ID and
1:28e234d:         // ACCESS_B2I_V4_ID, this is the default and no resetting is necessary.
1:28e234d:         setUniqueWithDuplicateNulls(false);
1:28e234d: 
1:28e234d: 		if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V4_ID
1:28e234d:                 || conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID)
1:b61f876:         {
1:b61f876:             // current format id, read collation info from disk
1:b61f876:             if (SanityManager.DEBUG)
1:b61f876:             {
1:b61f876:                 // length must include row location column and at least
1:b61f876:                 // one other field.
1:b61f876:                 SanityManager.ASSERT(
1:b61f876:                     collation_ids.length >= 2, 
1:b61f876:                     "length = " + collation_ids.length);
1:b61f876:             }
1:b61f876: 
1:9a3cbed:             hasCollatedTypes =
1:9a3cbed:                     ConglomerateUtil.readCollationIdArray(collation_ids, in);
1:b61f876:         }
1:b61f876:         else if (conglom_format_id != StoredFormatIds.ACCESS_B2I_V3_ID)
1:b61f876:         {
1:28e234d:             // Currently only V3, V4 and V5 should be possible in a Derby DB.
1:b61f876:             // Actual work for V3 is handled by default code above, so no
1:b61f876:             // special work is necessary.
1:b61f876: 
1:b61f876:             if (SanityManager.DEBUG)
1:b61f876:             {
1:b61f876:                 SanityManager.THROWASSERT(
1:b61f876:                     "Unexpected format id: " + conglom_format_id);
1:b61f876:             }
1:b61f876:         }
1:28e234d:         if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID) {
1:28e234d:             setUniqueWithDuplicateNulls(in.readBoolean());
1:28e234d:         }
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void readExternal(ObjectInput in)
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:9a3cbed
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         hasCollatedTypes = hasCollatedColumns(collation_ids);
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(!hasCollatedTypes);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             hasCollatedTypes =
1:                     ConglomerateUtil.readCollationIdArray(collation_ids, in);
commit:18176ce
/////////////////////////////////////////////////////////////////////////
1:     private static final String PROPERTY_BASECONGLOMID = "baseConglomerateId";
1:     private static final String PROPERTY_ROWLOCCOLUMN  = "rowLocationColumn";
0:     static final int FORMAT_NUMBER = StoredFormatIds.ACCESS_B2I_V3_ID;
/////////////////////////////////////////////////////////////////////////
1: 	long baseConglomerateId;
/////////////////////////////////////////////////////////////////////////
1: 	int rowLocationColumn;
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: // For JavaDoc references (i.e. @see)
1: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:787ceb4
/////////////////////////////////////////////////////////////////////////
1:  * @derby.formatId ACCESS_B2I_V3_ID
1:  * @derby.purpose   The tag that describes the on disk representation of the B2I
/////////////////////////////////////////////////////////////////////////
1:  * @derby.upgrade   The format id of this object is currently always read from disk
/////////////////////////////////////////////////////////////////////////
1:  * @derby.diskLayout 
/////////////////////////////////////////////////////////////////////////
1:  * @derby.formatId ACCESS_B2I_V4_ID
1:  * @derby.purpose   The tag that describes the on disk representation of the B2I
/////////////////////////////////////////////////////////////////////////
1:  * @derby.upgrade   The format id of this object is currently always read from disk
/////////////////////////////////////////////////////////////////////////
1:  * @derby.diskLayout 
/////////////////////////////////////////////////////////////////////////
1:  * @derby.formatId ACCESS_B2I_V5_ID
1:  * @derby.purpose   The tag that describes the on disk representation of the B2I
/////////////////////////////////////////////////////////////////////////
1:  * @derby.upgrade   This is the current version, no upgrade necessary.
1:  * @derby.diskLayout 
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:28e234d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.impl.store.access.btree.ControlRow;
/////////////////////////////////////////////////////////////////////////
1:  *            This format was used for all Derby database B2I's in version 10.3.
1:  *
0:  * @upgrade   The format id of this object is currently always read from disk
1:  *            as the first field of the conglomerate itself.  A bootstrap
1:  *            problem exists as we don't know the format id of the B2I 
1:  *            until we are in the "middle" of reading the B2I.  Thus the
1:  *            base B2I implementation must be able to read and write 
1:  *            all formats based on the reading the 
1:  *            "format_of_this_conglomerate". 
1:  *
1:  *            soft upgrade to ACCESS_B2I_V5_ID:
1:  *                read:
1:  *                    old format is readable by current B2I implementation,
1:  *                    with automatic in memory creation of default
1:  *                    isUniqueWithDuplicateNulls value of false.
1:  *                    No code other than readExternal and writeExternal need 
1:  *                    know about old format.
1:  *                write:
1:  *                    will never write out new format id in soft upgrade mode.
1:  *                    Code in readExternal and writeExternal handles writing
1:  *                    correct version.  Code in the factory handles making
1:  *                    sure new conglomerates use the B2I_v10_3 class
1:  *                    that will write out old format info.
1:  *
1:  *            hard upgrade to ACCESS_B2I_V5_ID:
1:  *                read:
1:  *                    old format is readable by current B2I implementation,
1:  *                    with automatic in memory creation of default
1:  *                    isUniqueWithDuplicateNulls value of false.
1:  *
1:  *                write:
1:  *                    Only "lazy" upgrade will happen.  New format will only
1:  *                    get written for new conglomerate created after the 
1:  *                    upgrade.  Old conglomerates continue to be handled the
1:  *                    same as soft upgrade.
1:  *
0:  * @disk_layout 
1:  *     format_of_this_conlgomerate(byte[])
1:  *     containerid(long)
1:  *     segmentid(int)
1:  *     number_of_key_fields(int)
1:  *     number_of_unique_columns(int)
1:  *     allow_duplicates(boolean)
1:  *     maintain_parent_links(boolean)
1:  *     array_of_format_ids(byte[][])
1:  *     baseConglomerateId(long)
1:  *     rowLocationColumn(int)
1:  *     ascend_column_info(FormatableBitSet)
1:  *     collation_ids(compressed array of ints)
1:  *
1:  */
1: 
1: /*
0:  * @format_id ACCESS_B2I_V5_ID
1:  *
0:  * @purpose   The tag that describes the on disk representation of the B2I
1:  *            conglomerate object.  Access contains no "directory" of 
1:  *            conglomerate information.  In order to bootstrap opening a file
1:  *            it encodes the factory that can open the conglomerate in the 
1:  *            conglomerate id itself.  There exists a single B2IFactory which
1:  *            must be able to read all btree format id's.  
1:  *
1:  *            in versions of Derby after the 10.3 release.
/////////////////////////////////////////////////////////////////////////
1:  *     isUniqueWithDuplicateNulls(boolean)
/////////////////////////////////////////////////////////////////////////
1:     static final int FORMAT_NUMBER = StoredFormatIds.ACCESS_B2I_V5_ID;
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1: 		return StoredFormatIds.ACCESS_B2I_V5_ID;
/////////////////////////////////////////////////////////////////////////
1: 	public void writeExternal_v10_3(ObjectOutput out) 
1: 		if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V4_ID
1:                 || conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID)
1:     }
1: 
1: 
1:     /**
1:      * Store the stored representation of the column value in the
1:      * stream.
1:      * <p>
1:      * For more detailed description of the ACCESS_B2I_V3_ID and 
1:      * ACCESS_B2I_V5_ID formats see documentation at top of file.
1:      *
1:      * @see java.io.Externalizable#writeExternal
1:      **/
1:     public void writeExternal(ObjectOutput out) throws IOException {
1:         writeExternal_v10_3 (out);
1:         if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID)
1:             out.writeBoolean (isUniqueWithDuplicateNulls());
1:     }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:         // initialize the unique with null setting to false, to be reset
1:         // below when read from disk.  For version ACCESS_B2I_V3_ID and
1:         // ACCESS_B2I_V4_ID, this is the default and no resetting is necessary.
1:         setUniqueWithDuplicateNulls(false);
1: 
1: 		if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V4_ID
1:                 || conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID)
/////////////////////////////////////////////////////////////////////////
1:             // Currently only V3, V4 and V5 should be possible in a Derby DB.
/////////////////////////////////////////////////////////////////////////
1:         if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V5_ID) {
1:             setUniqueWithDuplicateNulls(in.readBoolean());
1:         }
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1: 
1: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
1: 
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.services.io.CompressedNumber;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: 
1: 
0:  * @format_id ACCESS_B2I_V3_ID
1:  *            conglomerate object.  Access contains no "directory" of 
1:  *            conglomerate information.  In order to bootstrap opening a file
1:  *            it encodes the factory that can open the conglomerate in the 
1:  *            conglomerate id itself.  There exists a single B2IFactory which
1:  *            must be able to read all btree format id's.  
1:  *            This format was used for all Derby database B2I's in version
1:  *            10.2 and previous versions.
1:  *
0:  * @upgrade   The format id of this object is currently always read from disk
1:  *            as the first field of the conglomerate itself.  A bootstrap
1:  *            problem exists as we don't know the format id of the B2I 
1:  *            until we are in the "middle" of reading the B2I.  Thus the
1:  *            base B2I implementation must be able to read and write 
1:  *            all formats based on the reading the 
1:  *            "format_of_this_conglomerate". 
1:  *
1:  *            soft upgrade to ACCESS_B2I_V4_ID:
1:  *                read:
1:  *                    old format is readable by current B2I implementation,
1:  *                    with automatic in memory creation of default collation
1:  *                    id needed by new format.  No code other than
1:  *                    readExternal and writeExternal need know about old format.
1:  *                write:
1:  *                    will never write out new format id in soft upgrade mode.
1:  *                    Code in readExternal and writeExternal handles writing
1:  *                    correct version.  Code in the factory handles making
1:  *                    sure new conglomerates use the B2I_v10_2 class to 
1:  *                    that will write out old format info.
1:  *
1:  *            hard upgrade to ACCESS_B2I_V4_ID:
1:  *                read:
1:  *                    old format is readable by current B2I implementation,
1:  *                    with automatic in memory creation of default collation
1:  *                    id needed by new format.
1:  *                write:
1:  *                    Only "lazy" upgrade will happen.  New format will only
1:  *                    get written for new conglomerate created after the 
1:  *                    upgrade.  Old conglomerates continue to be handled the
1:  *                    same as soft upgrade.
1:  *     format_of_this_conlgomerate(byte[])
1:  *     ascend_column_info(FormatableBitSet)
1:  *
0:  * @format_id ACCESS_B2I_V4_ID
1:  *            conglomerate object.  Access contains no "directory" of 
1:  *            conglomerate information.  In order to bootstrap opening a file
1:  *            it encodes the factory that can open the conglomerate in the 
1:  *            conglomerate id itself.  There exists a single B2IFactory which
1:  *            must be able to read all btree format id's.  
1:  *            This format is the current version id of B2I and has been used 
0:  *            in versions of Derby after the 10.2 release.
0:  * @upgrade   This is the current version, no upgrade necessary.
/////////////////////////////////////////////////////////////////////////
1:  *     ascend_column_info(FormatableBitSet)
1:  *     collation_ids(compressed array of ints)
1:  *
/////////////////////////////////////////////////////////////////////////
0:     static final int FORMAT_NUMBER = StoredFormatIds.ACCESS_B2I_V4_ID;
/////////////////////////////////////////////////////////////////////////
1:     private static final int BASE_MEMORY_USAGE = 
1:         ClassSize.estimateBaseFromCatalog( B2I.class);
/////////////////////////////////////////////////////////////////////////
1:     int[]                   collationIds,
/////////////////////////////////////////////////////////////////////////
1: 		/* convert the sorting order information into a boolean array map.
1: 		 * array length is equal to template length, because column order
1: 		 * length changes whether it is unique or is non unique. store assumes
1: 		 * template length arrays. So, we make template length array and make
1: 		 * the last column as ascending instead of having lot of execeptions 
1:          * code.
/////////////////////////////////////////////////////////////////////////
1:         // get collation ids from input collation ids, store it in the 
1:         // conglom state.
1:         collation_ids = 
1:             ConglomerateUtil.createCollationIds(template.length, collationIds);
1: 
1: 		super.create(
1:             rawtran, segmentId, input_conglomid, template, 
1:             properties, getTypeFormatId(), temporaryFlag);
/////////////////////////////////////////////////////////////////////////
1:                     TransactionController.ISOLATION_SERIALIZABLE, true), 
1:                 base_cc, open_btree);
/////////////////////////////////////////////////////////////////////////
1:      *                        One of (ISOLATION_READ_COMMITTED or 
1:      *                        ISOLATION_SERIALIZABLE).
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Store the stored representation of the column value in the
1:      * stream.
1:      * <p>
1:      * For more detailed description of the ACCESS_B2I_V3_ID format see 
1:      * documentation at top of file.
1:      *
1:      * @see java.io.Externalizable#writeExternal
1:      **/
1: 	public void writeExternal_v10_2(ObjectOutput out) 
1:         throws IOException 
1:     {
1:         //write the columns ascend/descend information as bits
1:         FormatableBitSet ascDescBits = 
1:             new FormatableBitSet(ascDescInfo.length);
1:         for (int i = 0; i < ascDescInfo.length; i++)
1:         {	
1:             if (ascDescInfo[i])
1:                 ascDescBits.set(i);
1:         }
1:         ascDescBits.writeExternal(out);
1:     /**
1:      * Store the stored representation of the column value in the
1:      * stream.
1:      * <p>
1:      * For more detailed description of the ACCESS_B2I_V3_ID and 
1:      * ACCESS_B2I_V4_ID formats see documentation at top of file.
1:      *
1:      * @see java.io.Externalizable#writeExternal
1:      **/
0: 	public void writeExternal(ObjectOutput out) 
1:         throws IOException 
1:     {
1:         // First part of ACCESS_B2I_V4_ID format is the ACCESS_B2I_V3_ID format.
1:         writeExternal_v10_2(out);
0: 		if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V4_ID)
1:         {
1:             // Now append sparse array of collation ids
1:             ConglomerateUtil.writeCollationIdArray(collation_ids, out);
1:         }
1: 	}
1:     /**
1:      * Restore the in-memory representation from the stream.
1:      * <p>
1:      *
1:      * @exception ClassNotFoundException Thrown if the stored representation 
1:      *                                   is serialized and a class named in 
1:      *                                   the stream could not be found.
1:      *
1:      * @see java.io.Externalizable#readExternal
1:      **/
1: 		rowLocationColumn  = in.readInt();
1:         // read the column sort order info
1:         FormatableBitSet ascDescBits = new FormatableBitSet();
1:         ascDescBits.readExternal(in);
1:         ascDescInfo = new boolean[ascDescBits.getLength()];
1:         for(int i =0 ; i < ascDescBits.getLength(); i++)
1:             ascDescInfo[i] = ascDescBits.isSet(i);
1:         // In memory maintain a collation id per column in the template.
1:         collation_ids = new int[format_ids.length];
1:         // initialize all the entries to COLLATION_TYPE_UCS_BASIC, 
1:         // and then reset as necessary.  For version ACCESS_B2I_V3_ID,
1:         // this is the default and no resetting is necessary.
1:         for (int i = 0; i < format_ids.length; i++)
1:             collation_ids[i] = StringDataValue.COLLATION_TYPE_UCS_BASIC;
1: 
0: 		if (conglom_format_id == StoredFormatIds.ACCESS_B2I_V4_ID)
1:         {
1:             // current format id, read collation info from disk
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 // length must include row location column and at least
1:                 // one other field.
1:                 SanityManager.ASSERT(
1:                     collation_ids.length >= 2, 
1:                     "length = " + collation_ids.length);
1:             }
1: 
0:             ConglomerateUtil.readCollationIdArray(collation_ids, in);
1:         }
1:         else if (conglom_format_id != StoredFormatIds.ACCESS_B2I_V3_ID)
1:         {
0:             // Currently only V3 and V4 should be possible in a Derby DB.
1:             // Actual work for V3 is handled by default code above, so no
1:             // special work is necessary.
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "Unexpected format id: " + conglom_format_id);
1:             }
1:         }
commit:d7e478a
/////////////////////////////////////////////////////////////////////////
commit:6081510
/////////////////////////////////////////////////////////////////////////
1: /*
/////////////////////////////////////////////////////////////////////////
1:  */
1: /*
/////////////////////////////////////////////////////////////////////////
1:  */
1: /**
1:  * Implements an instance of a B-Tree secondary index conglomerate.
1:  * A B2I object has two roles.
1:  * <ol>
1:  * <li>
1:  * The B2I object is stored on disk, and holds the store specific
1:  * information needed to access/describe the conglomerate. This
1:  * includes information such as the format ids of the columns, 
1:  * the conglomerate id of the base table, the location of 
1:  * row location column.
1:  * </li>
1:  * <li>
1:  * Access to all the interfaces start by making a call off the
1:  * Conglomerate interface. So for instance to get a scan on the
1:  * conglomerate method {@link #openScan openScan} should be called.
1:  * </li>
1:  * </ol>
1:  */
commit:965be70
/////////////////////////////////////////////////////////////////////////
1: 		B2IController b2ic = new B2IController();
1: 
1: 		try
1: 		{
1:             int open_mode = TransactionController.OPENMODE_FORUPDATE;
1: 
1:             // Do the actual open of the container in the super class.
1:             b2ic.init(
1:                 xact_manager,                    // current transaction   
1:                 xact_manager.getRawStoreXact(),  // current raw store xact
1:                 open_mode,
1:                 TransactionController.MODE_TABLE,
1:                 xact_manager.getRawStoreXact().newLockingPolicy(
1:                     LockingPolicy.MODE_CONTAINER,
1:                     TransactionController.ISOLATION_SERIALIZABLE, true),
1:                 true,
1:                 this, 
1:                 new B2IUndo(),
1:                 (B2IStaticCompiledInfo) null,
1:                 (DynamicCompiledOpenConglomInfo) null);
1: 
1:             b2ic.getContainer().compressContainer();
1: 
1: 		}
1: 		finally
1: 		{
1: 			b2ic.close();
1: 		}
1: 
commit:06dbbcf
/////////////////////////////////////////////////////////////////////////
commit:41a0826
/////////////////////////////////////////////////////////////////////////
1: 	 * @see Conglomerate#defragmentConglomerate
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1:      * Open a b-tree compress scan.
1:      * <p>
1:      * B2I does not support a compress scan.
1:      * <p>
0: 	 * @see Conglomerate#openCompressScan
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public ScanManager defragmentConglomerate(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     int                             isolation_level)
1: 			throws StandardException
1: 	{
1:         throw StandardException.newException(
1:             SQLState.BTREE_UNIMPLEMENTED_FEATURE);
1: 	}
1: 
1: 	public void purgeConglomerate(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran)
1:         throws StandardException
1:     {
1:         // currently on work to do in btree's for purge rows, purging
1:         // happens best when split is about to happen.
1:         return;
1:     }
1: 
1: 	public void compressConglomerate(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran)
1:         throws StandardException
1:     {
0:         // TODO - need to implement for btree
1:         return;
1:     }
1: 
1:     /**
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:197b3d3
/////////////////////////////////////////////////////////////////////////
0: 		return StoredFormatIds.ACCESS_B2I_V4_ID;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 	@exception StandardException Standard Derby Error policy.
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:44e4f27
/////////////////////////////////////////////////////////////////////////
1:                 false,                           // Not holdable
/////////////////////////////////////////////////////////////////////////
1:             hold,                       // holdability
/////////////////////////////////////////////////////////////////////////
1:                 false,                           // Not holdable
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.index.B2I
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree.index
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree.index;
1: 
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: import java.util.Properties;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.types.RowLocation;
1: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
0: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.StoreCostController;
1: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.impl.store.access.btree.BTree;
1: import org.apache.derby.impl.store.access.btree.BTreeLockingPolicy;
1: import org.apache.derby.impl.store.access.btree.LeafControlRow;
0: import org.apache.derby.impl.store.access.btree.ControlRow;
1: import org.apache.derby.impl.store.access.btree.OpenBTree;
0: import org.apache.derby.impl.store.access.btree.WaitError;
1: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: 
1: /**
1: 
0:   A B2I object corresponds to an instance of a b-tree secondary index conglomerate.
1: 
1: **/
1: 
1: /**
0:  * @format_id ACCESS_B2I_V1_ID
1:  *
0:  * @purpose   The tag that describes the on disk representation of the B2I
0:  *            conglomerate object.  The B2I conglomerate object is stored in
0:  *            a field of a row in the Conglomerate directory.  
1:  *
0:  * @upgrade   This format was made obsolete in the kimono release.
1:  *
0:  * @disk_layout 
1:  *     containerid(long)
1:  *     segmentid(int)
1:  *     number_of_key_fields(int)
1:  *     number_of_unique_columns(int)
1:  *     allow_duplicates(boolean)
1:  *     maintain_parent_links(boolean)
1:  *     format_of_this_conlgomerate(byte[])
1:  *     array_of_format_ids(byte[][])
1:  *     baseConglomerateId(long)
1:  *     rowLocationColumn(int)
1:  **/
1: 
1: /**
0:  * @format_id ACCESS_B2I_V2_ID
1:  *
0:  * @purpose   The tag that describes the on disk representation of the B2I
0:  *            conglomerate object.  The B2I conglomerate object is stored in
0:  *            a field of a row in the Conglomerate directory.  
1:  *
0:  * @upgrade   The format id of this object is currently always read from disk
0:  *            as a separate column in the conglomerate directory.  To read
0:  *            A conglomerate object from disk and upgrade it to the current
0:  *            version do the following:
1:  *
0:  *                format_id = get format id from a separate column
0:  *                Upgradable conglom_obj = instantiate empty obj(format_id)
0:  *                read in conglom_obj from disk
0:  *                conglom = conglom_obj.upgradeToCurrent();
1:  *
0:  * @disk_layout 
1:  *     format_of_this_conlgomerate(byte[])
1:  *     containerid(long)
1:  *     segmentid(int)
1:  *     number_of_key_fields(int)
1:  *     number_of_unique_columns(int)
1:  *     allow_duplicates(boolean)
1:  *     maintain_parent_links(boolean)
1:  *     array_of_format_ids(byte[][])
1:  *     baseConglomerateId(long)
1:  *     rowLocationColumn(int)
1:  **/
1: 
1: public class B2I extends BTree
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     public    static final String PROPERTY_BASECONGLOMID = "baseConglomerateId";
0:     public    static final String PROPERTY_ROWLOCCOLUMN  = "rowLocationColumn";
1: 
0: 	public static final int FORMAT_NUMBER = StoredFormatIds.ACCESS_B2I_V3_ID;
1: 
1: 	/*
1: 	** Fields of B2I.
1: 	*/
1: 
1: 	/**
1: 	The id of the conglomerate which contains the base table.
1: 	Row locations inserted into this secondary index are assumed
1: 	to refer to that conglomerate.  Used to obtain table/row locks on the
1:     base table rows which the index rows point at.
1: 	**/
0: 	protected long baseConglomerateId;
1: 
1: 	/**
1: 	The column id (zero-based integer index) of the column which holds the row 
1:     location to the base conglomerate.
1: 	The default value of RowLocationColumn is the last key column.
1:     Used to obtain table/row locks on the base table rows with the index rows
1:     point at.
1: 	Currently, RowLocationColumn must be the last key column.
1: 	**/
0: 	protected int rowLocationColumn;
1: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( B2I.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
1:         return BASE_MEMORY_USAGE;
1:     }
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Protected locking implmentations of abtract BTree routines:
1:      *     getBtreeLockingPolicy
1:      *     lockTable
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Create a new btree locking policy from scratch.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     protected BTreeLockingPolicy getBtreeLockingPolicy(
1:     Transaction             rawtran,
1:     int                     lock_level,
1:     int                     mode,
1:     int                     isolation_level,
1:     ConglomerateController  base_cc,
1:     OpenBTree               open_btree)
1: 		throws StandardException
1:     {
1:         BTreeLockingPolicy ret_locking_policy = null;
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 (isolation_level == 
1:                      TransactionController.ISOLATION_SERIALIZABLE)      ||
1:                 (isolation_level == 
1:                      TransactionController.ISOLATION_REPEATABLE_READ)   ||
1:                 (isolation_level == 
1:                      TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK) ||
1:                 (isolation_level == 
1:                      TransactionController.ISOLATION_READ_COMMITTED)    ||
1:                 (isolation_level == 
1:                      TransactionController.ISOLATION_READ_UNCOMMITTED),
1:                 "bad isolation_level = " + isolation_level);
1:         }
1: 
1:         if (lock_level == TransactionController.MODE_TABLE)
1:         {
1:             ret_locking_policy = 
1:                 new B2ITableLocking3(
1:                     rawtran,
1:                     lock_level,
1:                     rawtran.newLockingPolicy(
1:                         LockingPolicy.MODE_CONTAINER, 
1:                         isolation_level,
1:                         true), 
1:                     base_cc,
1:                     open_btree);
1:         }
1:         else if (lock_level == TransactionController.MODE_RECORD)
1:         {
1:             if (isolation_level == TransactionController.ISOLATION_SERIALIZABLE)
1:             {
1:                 ret_locking_policy = 
1:                     new B2IRowLocking3(
1:                         rawtran,
1:                         lock_level,
1:                         rawtran.newLockingPolicy(
1:                             LockingPolicy.MODE_RECORD, 
1:                             isolation_level,
1:                             true), 
1:                         base_cc,
1:                         open_btree);
1:             }
1:             else if ((isolation_level == 
1:                         TransactionController.ISOLATION_REPEATABLE_READ))
1:             {
1:                 ret_locking_policy = 
1:                     new B2IRowLockingRR(
1:                         rawtran,
1:                         lock_level,
1:                         rawtran.newLockingPolicy(
1:                             LockingPolicy.MODE_RECORD, 
1:                             isolation_level,
1:                             true), 
1:                         base_cc,
1:                         open_btree);
1:             }
1:             else if ((isolation_level == 
1:                         TransactionController.ISOLATION_READ_COMMITTED) ||
1:                      (isolation_level == 
1:                         TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK))
1:             {
1:                 ret_locking_policy = 
1:                     new B2IRowLocking2(
1:                         rawtran,
1:                         lock_level,
1:                         rawtran.newLockingPolicy(
1:                             LockingPolicy.MODE_RECORD, 
1:                             isolation_level,
1:                             true), 
1:                         base_cc,
1:                         open_btree);
1:             }
1:             else if (isolation_level == 
1:                         TransactionController.ISOLATION_READ_UNCOMMITTED)
1:             {
1:                 ret_locking_policy = 
1:                     new B2IRowLocking1(
1:                         rawtran,
1:                         lock_level,
1:                         rawtran.newLockingPolicy(
1:                             LockingPolicy.MODE_RECORD, 
1:                             isolation_level,
1:                             true), 
1:                         base_cc,
1:                         open_btree);
1:             }
1:         }
1: 
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(
1:                 ret_locking_policy != null, "ret_locking_policy == null");
1:         }
1: 
1:         return(ret_locking_policy);
1:     }
1: 
1:     /**
1:      * Lock the base table.
1:      * <p>
1:      * Assumes that segment of the base container is the same as the segment
1:      * of the btree segment.
1:      * <p>
1:      * RESOLVE - we really want to get the lock without opening the container.
1:      * raw store will be providing this.
1:      *
1:      * @param xact_manager Transaction to associate the lock with.
0:      * @param forUpdate    Whether to lock exclusive or share.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public final ConglomerateController lockTable(
1:     TransactionManager  xact_manager,
1:     int                 open_mode,
1:     int                 lock_level,
1:     int                 isolation_level)
1: 		throws StandardException
1:     {
1:         open_mode |= TransactionController.OPENMODE_FOR_LOCK_ONLY;
1: 
1:         // open the base conglomerate - just to get the table lock.
1:         ConglomerateController cc = 
1:             xact_manager.openConglomerate(
1:                 this.baseConglomerateId, false, open_mode, lock_level, 
1:                 isolation_level);
1: 
1:         return(cc);
1:     }
1: 
1:     /**************************************************************************
1: 	 *  Private methods of B2I, arranged alphabetically.
1:      **************************************************************************
1:      */
1: 
1: 
1:     private void traverseRight()
1:     {
1:         // RESOLVE - Do I have to do this???????????????
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.THROWASSERT("not implemented.");
1:     }
1: 
1: 
1: 	/*
1: 	** Methods of B2I.
1: 	*/
1: 
1: 	/**
1: 	Create an empty secondary index b-tree, using the generic b-tree to do the
1:     generic part of the creation process.
1: 
1:     This routine opens the newly created container, adds a single page, and
1:     makes this page the root by inserting a LeafControlRow onto this page
1:     at slot 0 and marking in that control row that the page is a root page.
1: 
1:     The following properties are specific to the b-tree secondary index:
1:     <UL>
1:     <LI> "baseConglomerateId" (integer).  The conglomerate id of the base
1:     conglomerate is never actually accessed by the b-tree secondary
1:     index implementation, it only serves as a namespace for row locks.
1:     This property is required.
1:     <LI> "rowLocationColumn" (integer).  The zero-based index into the row which
1:     the b-tree secondary index will assume holds a @see RowLocation of
1:     the base row in the base conglomerate.  This value will be used
1:     for acquiring locks.  In this implementation RowLocationColumn must be 
1:     the last key column.
1:     This property is required.
1:     </UL>
1: 
1:     A secondary index i (a, b) on table t (a, b, c) would have rows
1:     which looked like (a, b, row_location).  baseConglomerateId is set to the
1:     conglomerate id of t.  rowLocationColumns is set to 2.  allowsDuplicates
1:     would be set to false, @see BTree#create.  To create a unique
1:     secondary index set uniquenessColumns to 2, this means that the btree
1:     code will compare the key values but not the row id when determing
1:     uniqueness.  To create a nonunique secondary index set uniquenessColumns
1:     to 3, this would mean that the uniqueness test would include the row
1:     location and since all row locations will be unique  all rows inserted 
1:     into the index will be differentiated (at least) by row location.  
1: 
1: 	@see BTree#create
1: 
1: 	@exception StandardException Standard exception policy.
1: 	**/
1: 	public void create(
1:     TransactionManager      xact_manager,
1:     int                     segmentId, 
1:     long                    input_conglomid, 
1:     DataValueDescriptor[]	template, 
1: 	ColumnOrdering[]	    columnOrder,
1:     Properties              properties,
1: 	int                     temporaryFlag)
1: 		throws StandardException
1: 	{
1:         String      property_value = null;
1:         Transaction rawtran        = xact_manager.getRawStoreXact();
1: 
1:         if (properties == null)
1:         {
1:             throw(StandardException.newException(
1:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));
1:         }
1: 
1:         // Get baseConglomerateId //
1:         property_value = properties.getProperty(PROPERTY_BASECONGLOMID);
1:         if (property_value == null)
1:         {
1:             throw(StandardException.newException(
1:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:         {
1: 			if (property_value == null)
1:             	SanityManager.THROWASSERT(
1:                 	PROPERTY_BASECONGLOMID +
1: 					"property not passed to B2I.create()");
1:         }
1: 
1:         baseConglomerateId = Long.parseLong(property_value);
1: 
1:         // Get rowLocationColumn //
1:         property_value = properties.getProperty(PROPERTY_ROWLOCCOLUMN);
1: 
1:         if (SanityManager.DEBUG)
1:         {
1: 			if (property_value == null)
1:             	SanityManager.THROWASSERT(
1:                 	PROPERTY_ROWLOCCOLUMN +
1: 					"property not passed to B2I.create()");
1:         }
1: 
1:         if (property_value == null)
1:         {
1:             throw(StandardException.newException(
1:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));
1:         }
1: 
1:         rowLocationColumn = Integer.parseInt(property_value);
1: 
1:         // Currently the row location column must be the last column (makes)
1:         // comparing the columns in the index easier.
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(rowLocationColumn == template.length - 1, 
1:                 "rowLocationColumn is not the last column in the index");
1:             SanityManager.ASSERT(
1:                 template[rowLocationColumn] instanceof 
1:                     RowLocation);
1: 
1:             // There must be at least one key column
1: 			if (rowLocationColumn < 1)
1:             	SanityManager.THROWASSERT(
1: 					"rowLocationColumn (" + rowLocationColumn +
1: 					") expected to be >= 1");
1:         }
1: 
1: 
0: 		/* covert the sorting order information into a boolean array map.
1: 		 * If the sorting order for the columns is not provided, we
1: 		 * assign the default as Ascending Order.
0: 		 * array length is equla to template length , because column order
0: 		 * length changes wther it is unique is non unique. store assumes
0: 		 * template length arrays. So , we make  template length array and make
0: 		 * the last column as ascending instead of having lot of execeptions code.
1: 		 */
1: 		
1: 		ascDescInfo = new boolean[template.length];
1: 		for (int i=0 ; i < ascDescInfo.length; i++)
1: 		{
1: 			if (columnOrder != null && i < columnOrder.length)
1: 				ascDescInfo[i] = columnOrder[i].getIsAscending();
1: 			else
1: 				ascDescInfo[i] = true;  // default values - ascending order
1: 		}
1: 
1: 		// Do the generic part of creating the b-tree.
0: 		super.create(rawtran, segmentId, input_conglomid, template, properties, getTypeFormatId(), temporaryFlag);
1: 
1:         // open the base conglomerate - to get the lock
1:         ConglomerateController base_cc = 
1:             xact_manager.openConglomerate(
1:                 baseConglomerateId,
1:                 false,
1:                 TransactionController.OPENMODE_FOR_LOCK_ONLY, 
1:                 TransactionController.MODE_TABLE,
1:                 TransactionController.ISOLATION_SERIALIZABLE);
1:         
1:         OpenBTree open_btree = new OpenBTree();
1: 
1:         BTreeLockingPolicy b2i_locking_policy = 
1:             new B2ITableLocking3(
1:                 rawtran,
1:                 TransactionController.MODE_TABLE,
1:                 rawtran.newLockingPolicy(
1:                     LockingPolicy.MODE_CONTAINER,
0:                     TransactionController.ISOLATION_SERIALIZABLE, true), base_cc, open_btree);
1: 
1: 
1:         // The following call will "open" the new btree.  Create is
1:         // an interesting case.  What we really want is read only table lock
1:         // on the base conglomerate and update locks on the index.  For now
1:         // just get the update lock on the base table, this is done by the
1:         // lockTable() call made by base class.
1: 
1:         open_btree.init(
1:             (TransactionManager) xact_manager,  // current user xact
1:             (TransactionManager) xact_manager,  // current xact
1:             (ContainerHandle) null,     // have init open the container.
1:             rawtran, 
1:             false,
1:             (ContainerHandle.MODE_FORUPDATE),
1:             TransactionController.MODE_TABLE,
1:             b2i_locking_policy,         // get table level lock.
1:             this,                       
1:             (LogicalUndo) null,         // no logical undo necessary, as 
1:                                         // initEmptyBtree()
1:                                         // work will be done single user and
1:                                         // rows will not move.
1:             (DynamicCompiledOpenConglomInfo) null);
1:                                         
1: 		// Open the newly created container, and insert the first control row.
1:         LeafControlRow.initEmptyBtree(open_btree);
1: 
1:         open_btree.close();
1: 
1:         base_cc.close();
1: 	}
1: 
1: 
1: 
1: 	/*
1: 	** Methods of Conglomerate
1: 	*/
1: 
1:     /**
1:      * Retrieve the maximum value row in an ordered conglomerate.
1:      * <p>
1:      * Returns true and fetches the rightmost row of an ordered conglomerate 
1:      * into "fetchRow" if there is at least one row in the conglomerate.  If
1:      * there are no rows in the conglomerate it returns false.
1:      * <p>
1:      * Non-ordered conglomerates will not implement this interface, calls
1:      * will generate a StandardException.
1:      * <p>
1:      * RESOLVE - this interface is temporary, long term equivalent (and more) 
1:      * functionality will be provided by the openBackwardScan() interface.  
1:      *
1: 	 * @param xact_manager    The TransactionController under which this 
1:      *                        operation takes place.
1:      *
1: 	 * @param conglomId       The identifier of the conglomerate
1: 	 *                        to open the scan for.
1:      *
1: 	 * @param open_mode       Specifiy flags to control opening of table.  
1:      *                        OPENMODE_FORUPDATE - if set open the table for
1:      *                        update otherwise open table shared.
1:      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
1:      *
1:      * @param isolation_level The isolation level to lock the conglomerate at.
0:      *                        One of (ISOLATION_READ_COMMITTED or ISOLATION_SERIALIZABLE).
1:      *
1: 	 * @param scanColumnList  A description of which columns to return from 
1:      *                        every fetch in the scan.  template, 
1:      *                        and scanColumnList work together
1:      *                        to describe the row to be returned by the scan - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a "row".
1:      *
1:      * @param fetchRow        The row to retrieve the maximum value into.
1:      *
1: 	 * @return boolean indicating if a row was found and retrieved or not.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public boolean fetchMaxOnBTree(
1:     TransactionManager      xact_manager,
1:     Transaction             rawtran,
1:     long                    conglomId,
1:     int                     open_mode,
1:     int                     lock_level,
1:     LockingPolicy           locking_policy,
1:     int                     isolation_level,
1:     FormatableBitSet                 scanColumnList,
1:     DataValueDescriptor[]   fetchRow)
1:         throws StandardException
1:     {
1:         boolean row_exists;
1: 
1:         // row level locking implementation.
1: 
1:         // RESOLVE (revisit implementation after all the Xena rowlocking
1:         // changes have been made).  Can probably come up with single
1:         // path implementation.
1:         
1:         // Create a new b-tree secondary index scan.
1:         B2IMaxScan b2is = new B2IMaxScan();
1: 
1:         // Initialize it.
1:         b2is.init(
1:             xact_manager, 
1:             rawtran, 
1:             open_mode,
1:             lock_level,
1:             locking_policy,
1:             isolation_level,
1:             true /* get locks on base table as part of open */,
1:             scanColumnList,
1:             this, 
1:             new B2IUndo());
1: 
1:         row_exists = b2is.fetchMax(fetchRow);
1: 
1:         b2is.close();
1: 
1:         return(row_exists);
1:     }
1: 
1: 
1: 	/**
1: 	Bulk Load a B-tree secondary index.
1: 
1: 	@see Conglomerate#load
0: 	@exception StandardException Standard Cloudscape Error policy.
1: 	raise SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION if a duplicate 
1:     key is detected in the load.
1: 	**/
1: 
1: 	public long load(
1: 	TransactionManager      xact_manager,
1: 	boolean                 createConglom,
1: 	RowLocationRetRowSource rowSource)
1: 		 throws StandardException
1: 	{
1:         long num_rows_loaded = 0;
1: 		B2IController b2ic = new B2IController();
1: 
1: 		try
1: 		{
1:             int open_mode = TransactionController.OPENMODE_FORUPDATE;
1: 
1:             if (createConglom)
1:             {
1:                 open_mode |=
1:                     (ContainerHandle.MODE_UNLOGGED |
1:                      ContainerHandle.MODE_CREATE_UNLOGGED);
1:             }
1: 
1:             // Do the actual open of the container in the super class.
1:             b2ic.init(
1:                 xact_manager,                    // current transaction   
1:                 xact_manager.getRawStoreXact(),  // current raw store xact
1:                 open_mode,
1:                 TransactionController.MODE_TABLE,
1:                 xact_manager.getRawStoreXact().newLockingPolicy(
1:                     LockingPolicy.MODE_CONTAINER,
1:                     TransactionController.ISOLATION_SERIALIZABLE, true),
1:                 true,
1:                 this, 
1:                 new B2IUndo(),
1:                 (B2IStaticCompiledInfo) null,
1:                 (DynamicCompiledOpenConglomInfo) null);
1: 
1:             num_rows_loaded = b2ic.load(xact_manager, createConglom, rowSource);
1: 
1: 		}
1: 		finally
1: 		{
1: 			b2ic.close();
1: 		}
1: 
1:         return(num_rows_loaded);
1: 	}
1: 
1: 	/**
1: 	Open a b-tree controller.
1: 	@see Conglomerate#open
1: 
1: 	@exception StandardException Standard exception policy.
1: 	**/
1: 	public ConglomerateController open(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran, 
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     StaticCompiledOpenConglomInfo   static_info,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1: 		throws StandardException
1: 	{
1: 		// Create a new b-tree secondary index controller.
1: 		B2IController b2ic = new B2IController();
1: 
1: 		// Do the actual open of the container in the super class.
1: 		b2ic.init(
1:             xact_manager,               // current transaction   
1:             rawtran,                    // current raw store transaction
1:             open_mode,
1:             lock_level,
1:             locking_policy,
1:             true,
1:             this, 
1:             new B2IUndo(),
1:             (B2IStaticCompiledInfo) static_info,
1:             dynamic_info);
1: 
1: 		// Return it to the caller.
1: 		return b2ic;
1: 	}
1: 
1: 	/**
1: 	Open a b-tree secondary index scan controller.
1: 	@see Conglomerate#openScan
1: 	@see BTree#openScan
1: 
1: 	@exception StandardException Standard exception policy.
1: 	**/
1: 	public ScanManager openScan(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     int                             isolation_level,
1: 	FormatableBitSet                         scanColumnList,
1:     DataValueDescriptor[]			startKeyValue,
1:     int                             startSearchOperator,
1:     Qualifier                       qualifier[][],
1:     DataValueDescriptor[]			stopKeyValue,
1:     int                             stopSearchOperator,
1:     StaticCompiledOpenConglomInfo   static_info,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1: 			throws StandardException
1: 	{
1: 		// Create a new b-tree secondary index scan.
1: 		B2IForwardScan b2is = new B2IForwardScan();
1: 
1: 		// Initialize it.
1: 		b2is.init(xact_manager, rawtran, 
1:                   hold,
1:                   open_mode,
1:                   lock_level,
1:                   locking_policy,
1:                   isolation_level,
1:                   true /* get locks on base table as part of open */,
1:                   scanColumnList,
1:                   startKeyValue, startSearchOperator,
1:                   qualifier,
1:                   stopKeyValue, stopSearchOperator, this, new B2IUndo(),
1:                   (B2IStaticCompiledInfo) static_info,
1:                   dynamic_info);
1: 
1: 		// Return it to the caller.
1: 		return b2is;
1: 	}
1: 
1:     /**
1:      * Return an open StoreCostController for the conglomerate.
1:      * <p>
1:      * Return an open StoreCostController which can be used to ask about 
1:      * the estimated row counts and costs of ScanController and 
1:      * ConglomerateController operations, on the given conglomerate.
1:      * <p>
1: 	 * @param xact_manager The TransactionController under which this 
1:      *                     operation takes place.
1: 	 * @param rawtran  raw transaction context in which scan is managed.
1:      *
1: 	 * @return The open StoreCostController.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1:      * @see StoreCostController
1:      **/
1:     public StoreCostController openStoreCost(
1:     TransactionManager  xact_manager,
1:     Transaction         rawtran)
1: 		throws StandardException
1:     {
1:         B2ICostController b2icost = new B2ICostController();
1: 
1:         b2icost.init(xact_manager, this, rawtran);
1: 
1:         return(b2icost);
1:     }
1: 
1: 	/**
1: 	Drop this b-tree secondary index.
1: 	@see Conglomerate#drop
1: 	@see BTree#drop
1: 
1: 	@exception StandardException Standard exception policy.
1: 	**/
1: 	public void drop(TransactionManager xact_manager)
1: 		throws StandardException
1: 	{
1:         // HACK to get around problem where index is dropped after the base
1:         // table.
1:         ConglomerateController base_cc = null;
1: 
1: 
1:         /* Get X table lock to make sure no thread is accessing index */
1:         base_cc = 
1:             lockTable(
1:                 xact_manager, 
1:                 TransactionController.OPENMODE_FORUPDATE, 
1:                 TransactionController.MODE_TABLE,
1:                 TransactionController.ISOLATION_REPEATABLE_READ);
1: 
1:         xact_manager.getRawStoreXact().dropContainer(id);
1: 
1:         if (base_cc != null)
1:             base_cc.close();
1: 	}
1: 
1:     /**
1:      * Return static information about the conglomerate to be included in a
1:      * a compiled plan.
1:      * <p>
1:      * The static info would be valid until any ddl was executed on the 
1:      * conglomid, and would be up to the caller to throw away when that 
1:      * happened.  This ties in with what language already does for other 
1:      * invalidation of static info.  The type of info in this would be 
1:      * containerid and array of format id's from which templates can be created.
1:      * The info in this object is read only and can be shared among as many 
1:      * threads as necessary.
1:      * <p>
1:      *
1: 	 * @return The static compiled information.
1:      *
1:      * @param conglomId The identifier of the conglomerate to open.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(
1:     TransactionController   xact_manager,
1:     long                    conglomId)
1: 		throws StandardException
1:     {
1:         return(new B2IStaticCompiledInfo(xact_manager, this));
1:     }
1: 
1: 	/*
1: 	** Methods of Storable (via Conglomerate via BTree).
1: 	** This class is responsible for re/storing its
1: 	** own state and calling its superclass to store its'.
1: 	*/
1: 
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() 
1:     {
0: 		return StoredFormatIds.ACCESS_B2I_V3_ID;
1: 	}
1: 
1: 	/**
0: 	Store the stored representation of the column value in the stream.
0: 	It might be easier to simply store the properties - which would certainly
0: 	make upgrading easier.*/
0: 	public void writeExternal_v36(ObjectOutput out) throws IOException {
1: 		super.writeExternal(out);
1: 		out.writeLong(baseConglomerateId);
1: 		out.writeInt(rowLocationColumn);
1: 	}
1: 
1: 	/**
0: 	Restore the in-memory representation from the stream.
1: 
0: 	@exception ClassNotFoundException Thrown if the stored representation is
0: 	serialized and a class named in the stream could not be found.
1: 
0: 	@see java.io.Externalizable#readExternal
1: 	*/
0: 	public void readExternal_v36(ObjectInput in)
1: 		throws IOException, ClassNotFoundException
1: 	{
1: 		super.readExternal(in);
1: 		
0: 		// XXX (nat) need to improve error handling
1: 		baseConglomerateId = in.readLong();
0: 		rowLocationColumn = in.readInt();
0: 		//set the default (Ascending) sort order
0: 		ascDescInfo = new boolean[nKeyFields];
1: 		for (int i=0 ; i < ascDescInfo.length; i++)
0: 			ascDescInfo[i] = true;
1: 	}
1: 
1: 
1: 	/**
0: 	Store the stored representation of the column value in the stream.
0: 	It might be easier to simply store the properties - which would certainly
0: 	make upgrading easier.
1: 
1:     */
0: 	public void writeExternal(ObjectOutput out) throws IOException {
1: 		super.writeExternal(out);
1: 		out.writeLong(baseConglomerateId);
1: 		out.writeInt(rowLocationColumn);
1: 
0: 		// if the conglomerate type is not not the version2
0: 		// sorting information is stored from version V3(release 3.7)
0: 		if (conglom_format_id != StoredFormatIds.ACCESS_B2I_V2_ID)
1: 		{
0: 			//write the coulmsn sort information as bits
0: 			FormatableBitSet ascDescBits = new FormatableBitSet(ascDescInfo.length);
0: 			for (int i = 0; i < ascDescInfo.length; i++)
1: 			{	
0: 				if (ascDescInfo[i])
0: 					ascDescBits.set(i);
1: 			}
0: 			ascDescBits.writeExternal(out);
1: 		}
1: 
1: 	}
1: 
1: 	/**
0: 	Restore the in-memory representation from the stream.
1: 
0: 	@exception ClassNotFoundException Thrown if the stored representation is
0: 	serialized and a class named in the stream could not be found.
1: 
0: 	@see java.io.Externalizable#readExternal
1: 	*/
0: 	private final void localReadExternal(ObjectInput in)
1: 		throws IOException, ClassNotFoundException
1: 	{
1: 		super.readExternal(in);
1: 		
0: 		// XXX (nat) need to improve error handling
1: 		baseConglomerateId = in.readLong();
0: 		rowLocationColumn = in.readInt();
1: 
0: 		// if the conglomerate type is  not the version2
0: 		// sorting info is avaialable  from version v3(release 3.7)
0: 		if (conglom_format_id != StoredFormatIds.ACCESS_B2I_V2_ID)
1: 		{
0: 			// read the column sort order info
0: 			FormatableBitSet ascDescBits = new FormatableBitSet();
0: 			ascDescBits.readExternal(in);
0: 			ascDescInfo = new boolean[ascDescBits.getLength()];
0: 			for(int i =0 ; i < ascDescBits.getLength(); i++)
0: 				ascDescInfo[i] = ascDescBits.isSet(i);
1: 		}
1: 		else
1: 		{
0: 			//set the default (Ascending) sort order
0: 			ascDescInfo = new boolean[nKeyFields];
1: 			for (int i=0 ; i < ascDescInfo.length; i++)
0: 				ascDescInfo[i] = true;
1: 
1: 		}
1: 
1: 	}
1: 
0: 	public void readExternal(ObjectInput in)
1: 		throws IOException, ClassNotFoundException
1: 	{
0:         localReadExternal(in);
1:     }
0: 	public void readExternalFromArray(ArrayInputStream in)
1: 		throws IOException, ClassNotFoundException
1: 	{
0:         localReadExternal(in);
1:     }
1: }
1: 
1: 
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree.index
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree.index;
0: 
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import java.util.Properties;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.impl.store.access.btree.BTree;
0: import org.apache.derby.impl.store.access.btree.BTreeLockingPolicy;
0: import org.apache.derby.impl.store.access.btree.LeafControlRow;
0: import org.apache.derby.impl.store.access.btree.ControlRow;
0: import org.apache.derby.impl.store.access.btree.OpenBTree;
0: import org.apache.derby.impl.store.access.btree.WaitError;
0: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: 
0: /**
0: 
0:   A B2I object corresponds to an instance of a b-tree secondary index conglomerate.
0: 
0: **/
0: 
0: /**
0:  * @format_id ACCESS_B2I_V1_ID
0:  *
0:  * @purpose   The tag that describes the on disk representation of the B2I
0:  *            conglomerate object.  The B2I conglomerate object is stored in
0:  *            a field of a row in the Conglomerate directory.  
0:  *
0:  * @upgrade   This format was made obsolete in the kimono release.
0:  *
0:  * @disk_layout 
0:  *     containerid(long)
0:  *     segmentid(int)
0:  *     number_of_key_fields(int)
0:  *     number_of_unique_columns(int)
0:  *     allow_duplicates(boolean)
0:  *     maintain_parent_links(boolean)
0:  *     format_of_this_conlgomerate(byte[])
0:  *     array_of_format_ids(byte[][])
0:  *     baseConglomerateId(long)
0:  *     rowLocationColumn(int)
0:  **/
0: 
0: /**
0:  * @format_id ACCESS_B2I_V2_ID
0:  *
0:  * @purpose   The tag that describes the on disk representation of the B2I
0:  *            conglomerate object.  The B2I conglomerate object is stored in
0:  *            a field of a row in the Conglomerate directory.  
0:  *
0:  * @upgrade   The format id of this object is currently always read from disk
0:  *            as a separate column in the conglomerate directory.  To read
0:  *            A conglomerate object from disk and upgrade it to the current
0:  *            version do the following:
0:  *
0:  *                format_id = get format id from a separate column
0:  *                Upgradable conglom_obj = instantiate empty obj(format_id)
0:  *                read in conglom_obj from disk
0:  *                conglom = conglom_obj.upgradeToCurrent();
0:  *
0:  * @disk_layout 
0:  *     format_of_this_conlgomerate(byte[])
0:  *     containerid(long)
0:  *     segmentid(int)
0:  *     number_of_key_fields(int)
0:  *     number_of_unique_columns(int)
0:  *     allow_duplicates(boolean)
0:  *     maintain_parent_links(boolean)
0:  *     array_of_format_ids(byte[][])
0:  *     baseConglomerateId(long)
0:  *     rowLocationColumn(int)
0:  **/
0: 
0: public class B2I extends BTree
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     public    static final String PROPERTY_BASECONGLOMID = "baseConglomerateId";
0:     public    static final String PROPERTY_ROWLOCCOLUMN  = "rowLocationColumn";
0: 
0: 	public static final int FORMAT_NUMBER = StoredFormatIds.ACCESS_B2I_V3_ID;
0: 
0: 	/*
0: 	** Fields of B2I.
0: 	*/
0: 
0: 	/**
0: 	The id of the conglomerate which contains the base table.
0: 	Row locations inserted into this secondary index are assumed
0: 	to refer to that conglomerate.  Used to obtain table/row locks on the
0:     base table rows which the index rows point at.
0: 	**/
0: 	protected long baseConglomerateId;
0: 
0: 	/**
0: 	The column id (zero-based integer index) of the column which holds the row 
0:     location to the base conglomerate.
0: 	The default value of RowLocationColumn is the last key column.
0:     Used to obtain table/row locks on the base table rows with the index rows
0:     point at.
0: 	Currently, RowLocationColumn must be the last key column.
0: 	**/
0: 	protected int rowLocationColumn;
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( B2I.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         return BASE_MEMORY_USAGE;
0:     }
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Protected locking implmentations of abtract BTree routines:
0:      *     getBtreeLockingPolicy
0:      *     lockTable
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Create a new btree locking policy from scratch.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected BTreeLockingPolicy getBtreeLockingPolicy(
0:     Transaction             rawtran,
0:     int                     lock_level,
0:     int                     mode,
0:     int                     isolation_level,
0:     ConglomerateController  base_cc,
0:     OpenBTree               open_btree)
0: 		throws StandardException
0:     {
0:         BTreeLockingPolicy ret_locking_policy = null;
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 (isolation_level == 
0:                      TransactionController.ISOLATION_SERIALIZABLE)      ||
0:                 (isolation_level == 
0:                      TransactionController.ISOLATION_REPEATABLE_READ)   ||
0:                 (isolation_level == 
0:                      TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK) ||
0:                 (isolation_level == 
0:                      TransactionController.ISOLATION_READ_COMMITTED)    ||
0:                 (isolation_level == 
0:                      TransactionController.ISOLATION_READ_UNCOMMITTED),
0:                 "bad isolation_level = " + isolation_level);
0:         }
0: 
0:         if (lock_level == TransactionController.MODE_TABLE)
0:         {
0:             ret_locking_policy = 
0:                 new B2ITableLocking3(
0:                     rawtran,
0:                     lock_level,
0:                     rawtran.newLockingPolicy(
0:                         LockingPolicy.MODE_CONTAINER, 
0:                         isolation_level,
0:                         true), 
0:                     base_cc,
0:                     open_btree);
0:         }
0:         else if (lock_level == TransactionController.MODE_RECORD)
0:         {
0:             if (isolation_level == TransactionController.ISOLATION_SERIALIZABLE)
0:             {
0:                 ret_locking_policy = 
0:                     new B2IRowLocking3(
0:                         rawtran,
0:                         lock_level,
0:                         rawtran.newLockingPolicy(
0:                             LockingPolicy.MODE_RECORD, 
0:                             isolation_level,
0:                             true), 
0:                         base_cc,
0:                         open_btree);
0:             }
0:             else if ((isolation_level == 
0:                         TransactionController.ISOLATION_REPEATABLE_READ))
0:             {
0:                 ret_locking_policy = 
0:                     new B2IRowLockingRR(
0:                         rawtran,
0:                         lock_level,
0:                         rawtran.newLockingPolicy(
0:                             LockingPolicy.MODE_RECORD, 
0:                             isolation_level,
0:                             true), 
0:                         base_cc,
0:                         open_btree);
0:             }
0:             else if ((isolation_level == 
0:                         TransactionController.ISOLATION_READ_COMMITTED) ||
0:                      (isolation_level == 
0:                         TransactionController.ISOLATION_READ_COMMITTED_NOHOLDLOCK))
0:             {
0:                 ret_locking_policy = 
0:                     new B2IRowLocking2(
0:                         rawtran,
0:                         lock_level,
0:                         rawtran.newLockingPolicy(
0:                             LockingPolicy.MODE_RECORD, 
0:                             isolation_level,
0:                             true), 
0:                         base_cc,
0:                         open_btree);
0:             }
0:             else if (isolation_level == 
0:                         TransactionController.ISOLATION_READ_UNCOMMITTED)
0:             {
0:                 ret_locking_policy = 
0:                     new B2IRowLocking1(
0:                         rawtran,
0:                         lock_level,
0:                         rawtran.newLockingPolicy(
0:                             LockingPolicy.MODE_RECORD, 
0:                             isolation_level,
0:                             true), 
0:                         base_cc,
0:                         open_btree);
0:             }
0:         }
0: 
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(
0:                 ret_locking_policy != null, "ret_locking_policy == null");
0:         }
0: 
0:         return(ret_locking_policy);
0:     }
0: 
0:     /**
0:      * Lock the base table.
0:      * <p>
0:      * Assumes that segment of the base container is the same as the segment
0:      * of the btree segment.
0:      * <p>
0:      * RESOLVE - we really want to get the lock without opening the container.
0:      * raw store will be providing this.
0:      *
0:      * @param xact_manager Transaction to associate the lock with.
0:      * @param forUpdate    Whether to lock exclusive or share.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public final ConglomerateController lockTable(
0:     TransactionManager  xact_manager,
0:     int                 open_mode,
0:     int                 lock_level,
0:     int                 isolation_level)
0: 		throws StandardException
0:     {
0:         open_mode |= TransactionController.OPENMODE_FOR_LOCK_ONLY;
0: 
0:         // open the base conglomerate - just to get the table lock.
0:         ConglomerateController cc = 
0:             xact_manager.openConglomerate(
0:                 this.baseConglomerateId, false, open_mode, lock_level, 
0:                 isolation_level);
0: 
0:         return(cc);
0:     }
0: 
0:     /**************************************************************************
0: 	 *  Private methods of B2I, arranged alphabetically.
0:      **************************************************************************
0:      */
0: 
0: 
0:     private void traverseRight()
0:     {
0:         // RESOLVE - Do I have to do this???????????????
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.THROWASSERT("not implemented.");
0:     }
0: 
0: 
0: 	/*
0: 	** Methods of B2I.
0: 	*/
0: 
0: 	/**
0: 	Create an empty secondary index b-tree, using the generic b-tree to do the
0:     generic part of the creation process.
0: 
0:     This routine opens the newly created container, adds a single page, and
0:     makes this page the root by inserting a LeafControlRow onto this page
0:     at slot 0 and marking in that control row that the page is a root page.
0: 
0:     The following properties are specific to the b-tree secondary index:
0:     <UL>
0:     <LI> "baseConglomerateId" (integer).  The conglomerate id of the base
0:     conglomerate is never actually accessed by the b-tree secondary
0:     index implementation, it only serves as a namespace for row locks.
0:     This property is required.
0:     <LI> "rowLocationColumn" (integer).  The zero-based index into the row which
0:     the b-tree secondary index will assume holds a @see RowLocation of
0:     the base row in the base conglomerate.  This value will be used
0:     for acquiring locks.  In this implementation RowLocationColumn must be 
0:     the last key column.
0:     This property is required.
0:     </UL>
0: 
0:     A secondary index i (a, b) on table t (a, b, c) would have rows
0:     which looked like (a, b, row_location).  baseConglomerateId is set to the
0:     conglomerate id of t.  rowLocationColumns is set to 2.  allowsDuplicates
0:     would be set to false, @see BTree#create.  To create a unique
0:     secondary index set uniquenessColumns to 2, this means that the btree
0:     code will compare the key values but not the row id when determing
0:     uniqueness.  To create a nonunique secondary index set uniquenessColumns
0:     to 3, this would mean that the uniqueness test would include the row
0:     location and since all row locations will be unique  all rows inserted 
0:     into the index will be differentiated (at least) by row location.  
0: 
0: 	@see BTree#create
0: 
0: 	@exception StandardException Standard exception policy.
0: 	**/
0: 	public void create(
0:     TransactionManager      xact_manager,
0:     int                     segmentId, 
0:     long                    input_conglomid, 
0:     DataValueDescriptor[]	template, 
0: 	ColumnOrdering[]	    columnOrder,
0:     Properties              properties,
0: 	int                     temporaryFlag)
0: 		throws StandardException
0: 	{
0:         String      property_value = null;
0:         Transaction rawtran        = xact_manager.getRawStoreXact();
0: 
0:         if (properties == null)
0:         {
0:             throw(StandardException.newException(
0:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));
0:         }
0: 
0:         // Get baseConglomerateId //
0:         property_value = properties.getProperty(PROPERTY_BASECONGLOMID);
0:         if (property_value == null)
0:         {
0:             throw(StandardException.newException(
0:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:         {
0: 			if (property_value == null)
0:             	SanityManager.THROWASSERT(
0:                 	PROPERTY_BASECONGLOMID +
0: 					"property not passed to B2I.create()");
0:         }
0: 
0:         baseConglomerateId = Long.parseLong(property_value);
0: 
0:         // Get rowLocationColumn //
0:         property_value = properties.getProperty(PROPERTY_ROWLOCCOLUMN);
0: 
0:         if (SanityManager.DEBUG)
0:         {
0: 			if (property_value == null)
0:             	SanityManager.THROWASSERT(
0:                 	PROPERTY_ROWLOCCOLUMN +
0: 					"property not passed to B2I.create()");
0:         }
0: 
0:         if (property_value == null)
0:         {
0:             throw(StandardException.newException(
0:                     SQLState.BTREE_PROPERTY_NOT_FOUND, PROPERTY_BASECONGLOMID));
0:         }
0: 
0:         rowLocationColumn = Integer.parseInt(property_value);
0: 
0:         // Currently the row location column must be the last column (makes)
0:         // comparing the columns in the index easier.
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(rowLocationColumn == template.length - 1, 
0:                 "rowLocationColumn is not the last column in the index");
0:             SanityManager.ASSERT(
0:                 template[rowLocationColumn] instanceof 
0:                     RowLocation);
0: 
0:             // There must be at least one key column
0: 			if (rowLocationColumn < 1)
0:             	SanityManager.THROWASSERT(
0: 					"rowLocationColumn (" + rowLocationColumn +
0: 					") expected to be >= 1");
0:         }
0: 
0: 
0: 		/* covert the sorting order information into a boolean array map.
0: 		 * If the sorting order for the columns is not provided, we
0: 		 * assign the default as Ascending Order.
0: 		 * array length is equla to template length , because column order
0: 		 * length changes wther it is unique is non unique. store assumes
0: 		 * template length arrays. So , we make  template length array and make
0: 		 * the last column as ascending instead of having lot of execeptions code.
0: 		 */
0: 		
0: 		ascDescInfo = new boolean[template.length];
0: 		for (int i=0 ; i < ascDescInfo.length; i++)
0: 		{
0: 			if (columnOrder != null && i < columnOrder.length)
0: 				ascDescInfo[i] = columnOrder[i].getIsAscending();
0: 			else
0: 				ascDescInfo[i] = true;  // default values - ascending order
0: 		}
0: 
0: 		// Do the generic part of creating the b-tree.
0: 		super.create(rawtran, segmentId, input_conglomid, template, properties, getTypeFormatId(), temporaryFlag);
0: 
0:         // open the base conglomerate - to get the lock
0:         ConglomerateController base_cc = 
0:             xact_manager.openConglomerate(
0:                 baseConglomerateId,
0:                 false,
0:                 TransactionController.OPENMODE_FOR_LOCK_ONLY, 
0:                 TransactionController.MODE_TABLE,
0:                 TransactionController.ISOLATION_SERIALIZABLE);
0:         
0:         OpenBTree open_btree = new OpenBTree();
0: 
0:         BTreeLockingPolicy b2i_locking_policy = 
0:             new B2ITableLocking3(
0:                 rawtran,
0:                 TransactionController.MODE_TABLE,
0:                 rawtran.newLockingPolicy(
0:                     LockingPolicy.MODE_CONTAINER,
0:                     TransactionController.ISOLATION_SERIALIZABLE, true), base_cc, open_btree);
0: 
0: 
0:         // The following call will "open" the new btree.  Create is
0:         // an interesting case.  What we really want is read only table lock
0:         // on the base conglomerate and update locks on the index.  For now
0:         // just get the update lock on the base table, this is done by the
0:         // lockTable() call made by base class.
0: 
0:         open_btree.init(
0:             (TransactionManager) xact_manager,  // current user xact
0:             (TransactionManager) xact_manager,  // current xact
0:             (ContainerHandle) null,     // have init open the container.
0:             rawtran, 
0:             false,
0:             (ContainerHandle.MODE_FORUPDATE),
0:             TransactionController.MODE_TABLE,
0:             b2i_locking_policy,         // get table level lock.
0:             this,                       
0:             (LogicalUndo) null,         // no logical undo necessary, as 
0:                                         // initEmptyBtree()
0:                                         // work will be done single user and
0:                                         // rows will not move.
0:             (DynamicCompiledOpenConglomInfo) null);
0:                                         
0: 		// Open the newly created container, and insert the first control row.
0:         LeafControlRow.initEmptyBtree(open_btree);
0: 
0:         open_btree.close();
0: 
0:         base_cc.close();
0: 	}
0: 
0: 
0: 
0: 	/*
0: 	** Methods of Conglomerate
0: 	*/
0: 
0:     /**
0:      * Retrieve the maximum value row in an ordered conglomerate.
0:      * <p>
0:      * Returns true and fetches the rightmost row of an ordered conglomerate 
0:      * into "fetchRow" if there is at least one row in the conglomerate.  If
0:      * there are no rows in the conglomerate it returns false.
0:      * <p>
0:      * Non-ordered conglomerates will not implement this interface, calls
0:      * will generate a StandardException.
0:      * <p>
0:      * RESOLVE - this interface is temporary, long term equivalent (and more) 
0:      * functionality will be provided by the openBackwardScan() interface.  
0:      *
0: 	 * @param xact_manager    The TransactionController under which this 
0:      *                        operation takes place.
0:      *
0: 	 * @param conglomId       The identifier of the conglomerate
0: 	 *                        to open the scan for.
0:      *
0: 	 * @param open_mode       Specifiy flags to control opening of table.  
0:      *                        OPENMODE_FORUPDATE - if set open the table for
0:      *                        update otherwise open table shared.
0:      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
0:      *
0:      * @param isolation_level The isolation level to lock the conglomerate at.
0:      *                        One of (ISOLATION_READ_COMMITTED or ISOLATION_SERIALIZABLE).
0:      *
0: 	 * @param scanColumnList  A description of which columns to return from 
0:      *                        every fetch in the scan.  template, 
0:      *                        and scanColumnList work together
0:      *                        to describe the row to be returned by the scan - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a "row".
0:      *
0:      * @param fetchRow        The row to retrieve the maximum value into.
0:      *
0: 	 * @return boolean indicating if a row was found and retrieved or not.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public boolean fetchMaxOnBTree(
0:     TransactionManager      xact_manager,
0:     Transaction             rawtran,
0:     long                    conglomId,
0:     int                     open_mode,
0:     int                     lock_level,
0:     LockingPolicy           locking_policy,
0:     int                     isolation_level,
0:     FormatableBitSet                 scanColumnList,
0:     DataValueDescriptor[]   fetchRow)
0:         throws StandardException
0:     {
0:         boolean row_exists;
0: 
0:         // row level locking implementation.
0: 
0:         // RESOLVE (revisit implementation after all the Xena rowlocking
0:         // changes have been made).  Can probably come up with single
0:         // path implementation.
0:         
0:         // Create a new b-tree secondary index scan.
0:         B2IMaxScan b2is = new B2IMaxScan();
0: 
0:         // Initialize it.
0:         b2is.init(
0:             xact_manager, 
0:             rawtran, 
0:             open_mode,
0:             lock_level,
0:             locking_policy,
0:             isolation_level,
0:             true /* get locks on base table as part of open */,
0:             scanColumnList,
0:             this, 
0:             new B2IUndo());
0: 
0:         row_exists = b2is.fetchMax(fetchRow);
0: 
0:         b2is.close();
0: 
0:         return(row_exists);
0:     }
0: 
0: 
0: 	/**
0: 	Bulk Load a B-tree secondary index.
0: 
0: 	@see Conglomerate#load
0: 	@exception StandardException Standard Cloudscape Error policy.
0: 	raise SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION if a duplicate 
0:     key is detected in the load.
0: 	**/
0: 
0: 	public long load(
0: 	TransactionManager      xact_manager,
0: 	boolean                 createConglom,
0: 	RowLocationRetRowSource rowSource)
0: 		 throws StandardException
0: 	{
0:         long num_rows_loaded = 0;
0: 		B2IController b2ic = new B2IController();
0: 
0: 		try
0: 		{
0:             int open_mode = TransactionController.OPENMODE_FORUPDATE;
0: 
0:             if (createConglom)
0:             {
0:                 open_mode |=
0:                     (ContainerHandle.MODE_UNLOGGED |
0:                      ContainerHandle.MODE_CREATE_UNLOGGED);
0:             }
0: 
0:             // Do the actual open of the container in the super class.
0:             b2ic.init(
0:                 xact_manager,                    // current transaction   
0:                 xact_manager.getRawStoreXact(),  // current raw store xact
0:                 open_mode,
0:                 TransactionController.MODE_TABLE,
0:                 xact_manager.getRawStoreXact().newLockingPolicy(
0:                     LockingPolicy.MODE_CONTAINER,
0:                     TransactionController.ISOLATION_SERIALIZABLE, true),
0:                 true,
0:                 this, 
0:                 new B2IUndo(),
0:                 (B2IStaticCompiledInfo) null,
0:                 (DynamicCompiledOpenConglomInfo) null);
0: 
0:             num_rows_loaded = b2ic.load(xact_manager, createConglom, rowSource);
0: 
0: 		}
0: 		finally
0: 		{
0: 			b2ic.close();
0: 		}
0: 
0:         return(num_rows_loaded);
0: 	}
0: 
0: 	/**
0: 	Open a b-tree controller.
0: 	@see Conglomerate#open
0: 
0: 	@exception StandardException Standard exception policy.
0: 	**/
0: 	public ConglomerateController open(
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran, 
0:     boolean                         hold,
0:     int                             open_mode,
0:     int                             lock_level,
0:     LockingPolicy                   locking_policy,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0: 		throws StandardException
0: 	{
0: 		// Create a new b-tree secondary index controller.
0: 		B2IController b2ic = new B2IController();
0: 
0: 		// Do the actual open of the container in the super class.
0: 		b2ic.init(
0:             xact_manager,               // current transaction   
0:             rawtran,                    // current raw store transaction
0:             open_mode,
0:             lock_level,
0:             locking_policy,
0:             true,
0:             this, 
0:             new B2IUndo(),
0:             (B2IStaticCompiledInfo) static_info,
0:             dynamic_info);
0: 
0: 		// Return it to the caller.
0: 		return b2ic;
0: 	}
0: 
0: 	/**
0: 	Open a b-tree secondary index scan controller.
0: 	@see Conglomerate#openScan
0: 	@see BTree#openScan
0: 
0: 	@exception StandardException Standard exception policy.
0: 	**/
0: 	public ScanManager openScan(
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran,
0:     boolean                         hold,
0:     int                             open_mode,
0:     int                             lock_level,
0:     LockingPolicy                   locking_policy,
0:     int                             isolation_level,
0: 	FormatableBitSet                         scanColumnList,
0:     DataValueDescriptor[]			startKeyValue,
0:     int                             startSearchOperator,
0:     Qualifier                       qualifier[][],
0:     DataValueDescriptor[]			stopKeyValue,
0:     int                             stopSearchOperator,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0: 			throws StandardException
0: 	{
0: 		// Create a new b-tree secondary index scan.
0: 		B2IForwardScan b2is = new B2IForwardScan();
0: 
0: 		// Initialize it.
0: 		b2is.init(xact_manager, rawtran, 
0:                   hold,
0:                   open_mode,
0:                   lock_level,
0:                   locking_policy,
0:                   isolation_level,
0:                   true /* get locks on base table as part of open */,
0:                   scanColumnList,
0:                   startKeyValue, startSearchOperator,
0:                   qualifier,
0:                   stopKeyValue, stopSearchOperator, this, new B2IUndo(),
0:                   (B2IStaticCompiledInfo) static_info,
0:                   dynamic_info);
0: 
0: 		// Return it to the caller.
0: 		return b2is;
0: 	}
0: 
0:     /**
0:      * Return an open StoreCostController for the conglomerate.
0:      * <p>
0:      * Return an open StoreCostController which can be used to ask about 
0:      * the estimated row counts and costs of ScanController and 
0:      * ConglomerateController operations, on the given conglomerate.
0:      * <p>
0: 	 * @param xact_manager The TransactionController under which this 
0:      *                     operation takes place.
0: 	 * @param rawtran  raw transaction context in which scan is managed.
0:      *
0: 	 * @return The open StoreCostController.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0:      * @see StoreCostController
0:      **/
0:     public StoreCostController openStoreCost(
0:     TransactionManager  xact_manager,
0:     Transaction         rawtran)
0: 		throws StandardException
0:     {
0:         B2ICostController b2icost = new B2ICostController();
0: 
0:         b2icost.init(xact_manager, this, rawtran);
0: 
0:         return(b2icost);
0:     }
0: 
0: 	/**
0: 	Drop this b-tree secondary index.
0: 	@see Conglomerate#drop
0: 	@see BTree#drop
0: 
0: 	@exception StandardException Standard exception policy.
0: 	**/
0: 	public void drop(TransactionManager xact_manager)
0: 		throws StandardException
0: 	{
0:         // HACK to get around problem where index is dropped after the base
0:         // table.
0:         ConglomerateController base_cc = null;
0: 
0: 
0:         /* Get X table lock to make sure no thread is accessing index */
0:         base_cc = 
0:             lockTable(
0:                 xact_manager, 
0:                 TransactionController.OPENMODE_FORUPDATE, 
0:                 TransactionController.MODE_TABLE,
0:                 TransactionController.ISOLATION_REPEATABLE_READ);
0: 
0:         xact_manager.getRawStoreXact().dropContainer(id);
0: 
0:         if (base_cc != null)
0:             base_cc.close();
0: 	}
0: 
0:     /**
0:      * Return static information about the conglomerate to be included in a
0:      * a compiled plan.
0:      * <p>
0:      * The static info would be valid until any ddl was executed on the 
0:      * conglomid, and would be up to the caller to throw away when that 
0:      * happened.  This ties in with what language already does for other 
0:      * invalidation of static info.  The type of info in this would be 
0:      * containerid and array of format id's from which templates can be created.
0:      * The info in this object is read only and can be shared among as many 
0:      * threads as necessary.
0:      * <p>
0:      *
0: 	 * @return The static compiled information.
0:      *
0:      * @param conglomId The identifier of the conglomerate to open.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(
0:     TransactionController   xact_manager,
0:     long                    conglomId)
0: 		throws StandardException
0:     {
0:         return(new B2IStaticCompiledInfo(xact_manager, this));
0:     }
0: 
0: 	/*
0: 	** Methods of Storable (via Conglomerate via BTree).
0: 	** This class is responsible for re/storing its
0: 	** own state and calling its superclass to store its'.
0: 	*/
0: 
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() 
0:     {
0: 		return StoredFormatIds.ACCESS_B2I_V3_ID;
0: 	}
0: 
0: 	/**
0: 	Store the stored representation of the column value in the stream.
0: 	It might be easier to simply store the properties - which would certainly
0: 	make upgrading easier.*/
0: 	public void writeExternal_v36(ObjectOutput out) throws IOException {
0: 		super.writeExternal(out);
0: 		out.writeLong(baseConglomerateId);
0: 		out.writeInt(rowLocationColumn);
0: 	}
0: 
0: 	/**
0: 	Restore the in-memory representation from the stream.
0: 
0: 	@exception ClassNotFoundException Thrown if the stored representation is
0: 	serialized and a class named in the stream could not be found.
0: 
0: 	@see java.io.Externalizable#readExternal
0: 	*/
0: 	public void readExternal_v36(ObjectInput in)
0: 		throws IOException, ClassNotFoundException
0: 	{
0: 		super.readExternal(in);
0: 		
0: 		// XXX (nat) need to improve error handling
0: 		baseConglomerateId = in.readLong();
0: 		rowLocationColumn = in.readInt();
0: 		//set the default (Ascending) sort order
0: 		ascDescInfo = new boolean[nKeyFields];
0: 		for (int i=0 ; i < ascDescInfo.length; i++)
0: 			ascDescInfo[i] = true;
0: 	}
0: 
0: 
0: 	/**
0: 	Store the stored representation of the column value in the stream.
0: 	It might be easier to simply store the properties - which would certainly
0: 	make upgrading easier.
0: 
0:     */
0: 	public void writeExternal(ObjectOutput out) throws IOException {
0: 		super.writeExternal(out);
0: 		out.writeLong(baseConglomerateId);
0: 		out.writeInt(rowLocationColumn);
0: 
0: 		// if the conglomerate type is not not the version2
0: 		// sorting information is stored from version V3(release 3.7)
0: 		if (conglom_format_id != StoredFormatIds.ACCESS_B2I_V2_ID)
0: 		{
0: 			//write the coulmsn sort information as bits
0: 			FormatableBitSet ascDescBits = new FormatableBitSet(ascDescInfo.length);
0: 			for (int i = 0; i < ascDescInfo.length; i++)
0: 			{	
0: 				if (ascDescInfo[i])
0: 					ascDescBits.set(i);
0: 			}
0: 			ascDescBits.writeExternal(out);
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	Restore the in-memory representation from the stream.
0: 
0: 	@exception ClassNotFoundException Thrown if the stored representation is
0: 	serialized and a class named in the stream could not be found.
0: 
0: 	@see java.io.Externalizable#readExternal
0: 	*/
0: 	private final void localReadExternal(ObjectInput in)
0: 		throws IOException, ClassNotFoundException
0: 	{
0: 		super.readExternal(in);
0: 		
0: 		// XXX (nat) need to improve error handling
0: 		baseConglomerateId = in.readLong();
0: 		rowLocationColumn = in.readInt();
0: 
0: 		// if the conglomerate type is  not the version2
0: 		// sorting info is avaialable  from version v3(release 3.7)
0: 		if (conglom_format_id != StoredFormatIds.ACCESS_B2I_V2_ID)
0: 		{
0: 			// read the column sort order info
0: 			FormatableBitSet ascDescBits = new FormatableBitSet();
0: 			ascDescBits.readExternal(in);
0: 			ascDescInfo = new boolean[ascDescBits.getLength()];
0: 			for(int i =0 ; i < ascDescBits.getLength(); i++)
0: 				ascDescInfo[i] = ascDescBits.isSet(i);
0: 		}
0: 		else
0: 		{
0: 			//set the default (Ascending) sort order
0: 			ascDescInfo = new boolean[nKeyFields];
0: 			for (int i=0 ; i < ascDescInfo.length; i++)
0: 				ascDescInfo[i] = true;
0: 
0: 		}
0: 
0: 	}
0: 
0: 	public void readExternal(ObjectInput in)
0: 		throws IOException, ClassNotFoundException
0: 	{
0:         localReadExternal(in);
0:     }
0: 	public void readExternalFromArray(ArrayInputStream in)
0: 		throws IOException, ClassNotFoundException
0: 	{
0:         localReadExternal(in);
0:     }
0: }
0: 
0: 
0: 
============================================================================