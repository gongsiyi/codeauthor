1:394a70e: /*
1:125c328: 
1:345de35:    Derby - Class org.apache.derby.impl.jdbc.EmbedClob
1:47510ba: 
1:88a3cb9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:88a3cb9:    contributor license agreements.  See the NOTICE file distributed with
1:88a3cb9:    this work for additional information regarding copyright ownership.
1:88a3cb9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:88a3cb9:    (the "License"); you may not use this file except in compliance with
1:88a3cb9:    the License.  You may obtain a copy of the License at
1:47510ba: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:47510ba: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:47510ba: 
1:456b8a1:  */
1:345de35: 
1:345de35: 
1:eac0369: package org.apache.derby.impl.jdbc;
1:345de35: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:1d6c1a5: import org.apache.derby.iapi.jdbc.EngineLOB;
1:7672693: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.types.Resetable;
1:7672693: import org.apache.derby.iapi.types.StringDataValue;
1:345de35: 
1:eac0369: import java.io.Reader;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.EOFException;
1:eac0369: import java.sql.SQLException;
1:eac0369: import java.sql.Clob;
128:eac0369: 
1:394a70e: /**
1:eac0369:     Implements java.sql.Clob (see the JDBC 2.0 spec).
1:eac0369:     A clob sits on top of a CHAR, VARCHAR or LONG VARCHAR column.
1:eac0369:     If its data is small (less than 1 page) it is a byte array taken from
1:eac0369:     the SQLChar class. If it is large (more than 1 page) it is a long column
1:eac0369:     in the database. The long column is accessed as a stream, and is implemented
1:e5b15ce:     in store as an OverflowInputStream. The Resetable interface allows sending
1:eac0369:     messages to that stream to initialize itself (reopen its container and
1:eac0369:     lock the corresponding row) and to reset itself to the beginning.
1:e5b15ce:     <p>
1:eac0369:     NOTE: In the case that the data is large, it is represented as a stream.
1:eac0369:     This stream can be returned to the user in the getAsciiStream() method.
1:eac0369:     This means that we have limited control over the state of the stream,
1:eac0369:     since the user can read bytes from it at any time.  Thus all methods
1:eac0369:     here reset the stream to the beginning before doing any work.
1:eac0369:     CAVEAT: The methods may not behave correctly if a user sets up
1:eac0369:     multiple threads and sucks data from the stream (returned from
1:eac0369:     getAsciiStream()) at the same time as calling the Clob methods.
1:eac0369: 
1:4153b27:   <P><B>Supports</B>
1:4153b27:    <UL>
1:4153b27:    <LI> JSR169 - no subsetting for java.sql.Clob
1:4153b27:    <LI> JDBC 2.0
1:4153b27:    <LI> JDBC 3.0 - no new dependencies on new JDBC 3.0 or JDK 1.4 classes,
1:4153b27:         new update methods can safely be added into implementation.
1:4153b27:    </UL>
1:80424bf:  */
1:1d6c1a5: final class EmbedClob extends ConnectionChild implements Clob, EngineLOB
43:eac0369: {
1:ce0c6c4: 
1:a78e683:     /**
1:a78e683:      * The underlying Clob object, which may change depending on what the user
1:a78e683:      * does with the Clob.
1:a78e683:      */
1:a78e683:     private InternalClob clob;
1:a78e683: 
1:a78e683:     /** Tells whether the Clob has been freed or not. */
1:125c328:     private boolean isValid = true;
1:456b8a1: 
1:d96e398:     private int locator;
1:ce0c6c4:     
1:8846963:     /**
1:a78e683:      * Creates an empty Clob object.
1:8846963:      *
1:8846963:      * @param con The Connection object associated with this EmbedClob object.
1:80424bf:      * @throws SQLException
1:8846963:      *
1:8846963:      */
1:a78e683:     EmbedClob(EmbedConnection con) throws SQLException {
1:8846963:         super(con);
1:10e4538:         this.clob = new TemporaryClob (this);
1:d96e398:         con.addLOBReference (this);
1:8846963:     }
1:8846963: 
1:80424bf:     /**
1:a78e683:      * Creates a Clob on top of a data value descriptor.
1:a78e683:      * <p>
1:e5b15ce:      * This constructor should only be called by {@link EmbedResultSet#getClob}.
1:a78e683:      * The data value descriptor may provide a <code>String</code> or a stream
1:a78e683:      * as the source of the Clob.
1:8846963:      *
1:7672693:      * @param dvd string data value descriptor providing the Clob source
1:a78e683:      * @param con associated connection for the Clob
1:e1fc783:      * @throws StandardException
1:125c328:      */
1:7672693:     protected EmbedClob(EmbedConnection con, StringDataValue dvd)
1:d349a1f:         throws StandardException, SQLException
1:394a70e:     {
1:eac0369:         super(con);
1:eac0369:         // if the underlying column is null, ResultSet.getClob will return null,
1:eac0369:         // never should get this far
2:eac0369:         if (SanityManager.DEBUG)
1:0ed8291:             SanityManager.ASSERT(!dvd.isNull(),
1:0ed8291:                                  "clob is created on top of a null column");
1:8846963: 
1:a78e683:         // See if a String or a stream will be the source of the Clob.
1:541361f:         if (dvd.hasStream()) {
1:541361f:             CharacterStreamDescriptor csd = dvd.getStreamWithDescriptor();
1:125c328:             /*
1:eac0369:              We are expecting this stream to be a FormatIdInputStream with an
1:eac0369:              OverflowInputStream inside. FormatIdInputStream implements
1:eac0369:              Resetable, as does OverflowInputStream. This should be the case
1:eac0369:              when retrieving data from a long column. However, SQLChar, which is
1:eac0369:              the class implementing the getStream() method for dvd.getStream(),
1:eac0369:              does not guarantee this for us. In particular, the logging system
1:eac0369:              (see StoredPage.logColumn) calls setStream with an argument that
1:eac0369:              is sometimes a RememberBytesInputStream on a SQLChar object
1:eac0369:              (e.g. see test repStreaming.sql). However, such a SQLChar
1:eac0369:              object is going to the log buffer, NOT back to the user, so it
1:eac0369:              should not break the ASSERT below.
1:394a70e:              */
1:eac0369:             if (SanityManager.DEBUG)
1:7672693:                 SanityManager.ASSERT(csd.getStream() instanceof Resetable);
1:125c328: 
1:a78e683:             try {
1:7672693:                 this.clob = new StoreStreamClob(csd, this);
1:2333262:             } catch (StandardException se) {
1:b44abbf:                 if (se.getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED)) {
1:b44abbf:                     throw StandardException
1:b44abbf:                             .newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
1:394a70e:                 }
1:a78e683:                 throw se;
1:394a70e:             }
1:541361f:         } else {
1:541361f:             try {
1:541361f:                 clob = new TemporaryClob(dvd.getString(),
1:541361f:                         this);
1:541361f:             }
1:541361f:             catch (IOException e) {
1:d349a1f:                 throw Util.setStreamFailure(e);
1:2333262:             }
1:541361f:         }
1:d96e398:         con.addLOBReference (this);
1:541361f:     }
1:0ed8291: 
1:ba50299:     /**
1:a78e683:      * Returns the number of characters in the <code>CLOB</code> value
1:394a70e:      * designated by this <code>Clob</code> object.
1:125c328:      *
1:a78e683:      * @return The length of the <code>CLOB</code> in number of characters.
1:a78e683:      * @exception SQLException if obtaining the length fails
1:394a70e:      */
1:eac0369:     public long length() throws SQLException
1:394a70e:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:394a70e:         try {
1:a78e683:             return this.clob.getCharLength();
1:a78e683:         } catch (IOException e) {
1:a78e683:             throw Util.setStreamFailure(e);
1:2333262:         }
1:394a70e:     }
1:ba50299: 
1:394a70e:     /**
1:a78e683:      * Returns a copy of the specified substring in the <code>CLOB</code> value
1:394a70e:      * designated by this <code>Clob</code> object.
1:a78e683:      * <p>
1:a78e683:      * The substring begins at position <code>pos</code> and has up to
1:0ed8291:      * * <code>length</code> consecutive characters. The starting position must
1:0ed8291:      * be between 1 and the length of the CLOB plus 1. This allows for 
1:0ed8291:      * zero-length CLOB values, from which only zero-length substrings can be
1:0ed8291:      * returned.
1:0ed8291:      * <p>
1:394a70e:      * If a larger length is requested than there are characters available,
1:394a70e:      * characters from the start position to the end of the CLOB are returned.
1:a78e683:      * <p>
1:a78e683:      * <em>NOTE</em>: If the starting position is the length of the CLOB plus 1,
1:a78e683:      * zero characters are returned regardless of the length requested.
1:0aceaa9:      *
1:394a70e:      * @param pos the first character of the substring to be extracted.
1:a78e683:      *    The first character is at position 1.
1:394a70e:      * @param length the number of consecutive characters to be copied
1:0ed8291:      * @return A <code>String</code> that is the specified substring in the
1:0ed8291:      *    <code>CLOB</code> value designated by this <code>Clob</code> object
1:0ed8291:      * @exception SQLException if there is an error accessing the
1:a78e683:      *    <code>CLOB</code>
1:394a70e:      */
1:eac0369:     public String getSubString(long pos, int length) throws SQLException
1:394a70e:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:125c328: 
1:a78e683:         if (pos < 1)
1:ba50299:             throw Util.generateCsSQLException(
1:ce40a31:                 SQLState.BLOB_BAD_POSITION, pos);
1:f433a64:         if (length < 0)
1:a78e683:             throw Util.generateCsSQLException(
1:ce40a31:                 SQLState.BLOB_NONPOSITIVE_LENGTH, length);
1:47510ba: 
1:a78e683:         String result;
1:a78e683:         // An exception will be thrown if the position is larger than the Clob.
1:ab2037f:         Reader reader;
1:ab2037f:         try {
1:ba50299:             try {
1:ab2037f:                 reader = this.clob.getInternalReader(pos);
1:ab2037f:             } catch (EOFException eofe) {
1:ab2037f:                 throw Util.generateCsSQLException(
1:1f18dc3:                         SQLState.BLOB_POSITION_TOO_LARGE, eofe, pos);
1:ab2037f:             }
1:a78e683:             char[] chars = new char[length];
1:a78e683:             int charsRead = 0;
1:a78e683:             // Read all the characters requested, or until EOF is reached.
1:a78e683:             while (charsRead < length) {
1:a78e683:                 int read = reader.read(chars, charsRead, length - charsRead);
1:a78e683:                 if (read == -1) {
1:a78e683:                     break;
1:394a70e:                 }
1:a78e683:                 charsRead += read;
1:394a70e:             }
1:a78e683:             reader.close();
1:a78e683:             // If we have an empty Clob or requested length is zero, return "".
1:a78e683:             if (charsRead == 0) {
1:a78e683:                 result = "";
1:a78e683:             } else {
1:a78e683:                 result = String.copyValueOf(chars, 0, charsRead);
1:394a70e:             }
1:a78e683:         } catch (IOException ioe) {
1:a78e683:             throw Util.setStreamFailure(ioe);
1:394a70e:         }
1:a78e683:         return result;
1:394a70e:     }
1:47510ba: 
1:394a70e:     /**
1:a78e683:      * Gets the <code>Clob</code> contents as a stream of characters.
1:a78e683:      * @return A character stream containing the <code>CLOB</code> data.
1:a78e683:      * @exception SQLException if there is an error accessing the
1:a78e683:      *    <code>CLOB</code>
1:394a70e:      */
1:eac0369:     public java.io.Reader getCharacterStream() throws SQLException
1:394a70e:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:a78e683:         try {
1:fcdce55:             return new ClobUpdatableReader (this);
1:a78e683:         } catch (IOException ioe) {
1:a78e683:             throw Util.setStreamFailure(ioe);
1:394a70e:         }
1:394a70e:     }
1:47510ba: 
1:394a70e:     /**
1:394a70e:      * Gets the <code>CLOB</code> value designated by this <code>Clob</code>
1:394a70e:      * object as a stream of Ascii bytes.
1:0ed8291:      * @return An Ascii stream containing the <code>CLOB</code> data. Valid
1:0ed8291:      *      values in the stream are 0 - 255.
1:394a70e:      * @exception SQLException if there is an error accessing the
1:a78e683:      *    <code>CLOB</code> value
1:394a70e:      */
1:eac0369:     public java.io.InputStream getAsciiStream() throws SQLException
1:eac0369:     {
1:a78e683:         // Validity is checked in getCharacterStream().
1:394a70e:         return new ReaderToAscii(getCharacterStream());
1:394a70e:     }
1:47510ba: 
1:394a70e:     /**
1:394a70e:      * Determines the character position at which the specified substring
1:0ed8291:      * <code>searchStr</code> appears in the <code>CLOB</code> value.
1:0ed8291:      * <p>
1:0ed8291:      * The search begins at position <code>start</code>. The method uses the
1:0ed8291:      * following algorithm for the search:
1:394a70e:      * <p>
1:394a70e:      * If the <code>CLOB</code> value is materialized as a string, use
1:394a70e:      * <code>String.indexOf</code>.
1:394a70e:      * <p>
1:0ed8291:      * If the <code>CLOB</code> value is represented as a stream, read a block
1:0ed8291:      * of chars from the start position and compare the chars with
1:394a70e:      * <code>searchStr</code>. Then:
1:394a70e:      * <ul> <li>If a matching char is found, increment <code>matchCount</code>.
1:394a70e:      *      <li>If <code>matchCount</code> is equal to the length of
1:394a70e:      *          <code>searchStr</code>, return with the current start position.
1:394a70e:      *      <li>If no match is found, and there is more data, restart search
1:394a70e:      *          (see below).
1:0ed8291:      *      <li>If no match is found, return <code>-1</code>.
1:394a70e:      * </ul>
1:394a70e:      * <p>
1:394a70e:      * The position where the stream has a char equal to the first char of
1:394a70e:      * <code>searchStr</code> will be remembered and used as the starting
1:394a70e:      * position for the next search-iteration if the current match fails.
1:394a70e:      * If a non-matching char is found, start a fresh search from the position
1:394a70e:      * remembered. If there is no such position, next search will start at the
1:394a70e:      * current position <code>+1</code>.
1:0aceaa9:      *
1:394a70e:      * @param searchStr the substring for which to search
1:394a70e:      * @param start the position at which to begin searching; the first position
1:394a70e:      *    is <code>1</code>
1:394a70e:      * @return The position at which the substring appears, <code>-1</code> if
1:394a70e:      *    it does not appear in the <code>CLOB</code> value. The first position
1:394a70e:      *    is <code>1</code>.
1:394a70e:      * @exception SQLException if there is an error accessing the
1:394a70e:      *    <code>CLOB</code> value
1:394a70e:      */
1:eac0369:     public long position(String searchStr, long start)
6:eac0369:         throws SQLException
1:eac0369:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:a78e683:         if (start < 1)
1:ab2037f:             throw Util.generateCsSQLException(
1:ce40a31:                             SQLState.BLOB_BAD_POSITION, start);
1:a78e683:         if (searchStr == null)
1:a78e683:             throw Util.generateCsSQLException(
1:a78e683:                             SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
1:10d991a:         if ("".equals(searchStr))
1:a78e683:             return start; // match DB2's SQL LOCATE function
1:125c328: 
1:eac0369:         boolean pushStack = false;
1:3a6f4cf:         EmbedConnection ec = getEmbedConnection();
1:eac0369:         try
1:eac0369:         {
1:47510ba: 
1:394a70e:             Object synchronization = getConnectionSynchronization();
1:e1fc783:             synchronized (synchronization)
1:394a70e:             {
1:3a6f4cf:                 pushStack = !ec.isClosed();
1:e1fc783:                 if (pushStack)
1:e1fc783:                     setupContextStack();
1:e1fc783:                 int matchCount = 0;
1:a78e683:                 long pos = start;
1:e1fc783:                 long newStart = -1;
1:ab2037f:                 Reader reader = this.clob.getInternalReader(start);
1:e1fc783:                 char [] tmpClob = new char [4096];
1:e1fc783:                 boolean reset;
1:e1fc783:                 for (;;) {
1:e1fc783:                     reset = false;
1:e1fc783:                     int readCount = reader.read (tmpClob);
1:3a6f4cf:                     if (readCount == -1) {
1:3a6f4cf:                         restoreIntrFlagIfSeen(pushStack, ec);
1:e1fc783:                         return -1;
1:3a6f4cf:                     }
1:47510ba:                     for (int clobOffset = 0;
1:e1fc783:                                 clobOffset < readCount; clobOffset++) {
1:a78e683:                         if (tmpClob[clobOffset]
1:a78e683:                                         == searchStr.charAt(matchCount)) {
1:47510ba:                             //find the new starting position in
1:e1fc783:                             // case this match is unsuccessful
1:47510ba:                             if (matchCount != 0 && newStart == -1
1:a78e683:                                     && tmpClob[clobOffset]
1:a78e683:                                     == searchStr.charAt(0)) {
1:e1fc783:                                 newStart = pos + clobOffset + 1;
1:394a70e:                             }
1:e1fc783:                             matchCount ++;
1:e1fc783:                             if (matchCount == searchStr.length()) {
1:3a6f4cf:                                 restoreIntrFlagIfSeen(pushStack, ec);
1:47510ba:                                 return pos + clobOffset
1:a78e683:                                         - searchStr.length() + 1;
1:394a70e:                             }
1:394a70e:                         }
1:e1fc783:                         else {
1:e1fc783:                             if (matchCount > 0) {
1:e1fc783:                                 if (newStart == -1) {
1:e1fc783:                                     if (matchCount > 1) {
1:e1fc783:                                         //compensate for increment in the "for"
1:e1fc783:                                         clobOffset--;
1:394a70e:                                     }
1:47510ba:                                     matchCount = 0;
1:47510ba:                                     continue;
1:394a70e:                                 }
2:e1fc783:                                 matchCount = 0;
1:e1fc783:                                 if (newStart < pos) {
1:e1fc783:                                     pos = newStart;
1:e1fc783:                                     reader.close();
1:ab2037f:                                     reader = this.clob.getInternalReader(
1:ab2037f:                                                                     newStart);
1:e1fc783:                                     newStart = -1;
1:e1fc783:                                     reset = true;
1:394a70e:                                     break;
1:47510ba:                                 }
1:e1fc783:                                 clobOffset = (int) (newStart - pos) - 1;
1:e1fc783:                                 newStart = -1;
2:e1fc783:                                 continue;
1:e1fc783:                             }
1:e1fc783:                         }
1:e1fc783:                     }
1:e1fc783:                     if (!reset) {
1:e1fc783:                         pos += readCount;
1:e1fc783:                     }
1:e1fc783:                 }
1:47510ba: 
1:e1fc783:             }
1:ab2037f:         } catch (EOFException eofe) {
1:3a6f4cf:             restoreIntrFlagIfSeen(pushStack, ec);
1:a78e683:             throw Util.generateCsSQLException(
1:1f18dc3:                     SQLState.BLOB_POSITION_TOO_LARGE, eofe, start);
1:a78e683:         } catch (IOException ioe) {
1:3a6f4cf:             restoreIntrFlagIfSeen(pushStack, ec);
1:a78e683:             throw Util.setStreamFailure(ioe);
1:a78e683:         } finally {
1:a78e683:             if (pushStack) {
1:394a70e:                 restoreContextStack();
1:a78e683:             }
1:394a70e:         }
1:394a70e:     }
1:47510ba: 
1:394a70e:     /**
1:394a70e:      * Determines the character position at which the specified
1:394a70e:      * <code>Clob</code> object <code>searchstr</code> appears in this
1:394a70e:      * <code>Clob</code> object.  The search begins at position
1:394a70e:      * <code>start</code>.
1:394a70e:      * @param searchClob the <code>Clob</code> object for which to search
1:394a70e:      * @param start the position at which to begin searching; the first
1:394a70e:      *              position is 1
1:394a70e:      * @return the position at which the <code>Clob</code> object appears,
1:394a70e:      * else -1; the first position is 1
1:394a70e:      * @exception SQLException if there is an error accessing the
1:394a70e:      * <code>CLOB</code> value
1:394a70e:      */
1:eac0369:     public long position(Clob searchClob, long start)
1:eac0369:         throws SQLException
1:394a70e:     {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:125c328:         checkValidity();
1:a78e683:         if (start < 1)
1:a78e683:             throw Util.generateCsSQLException(
1:ce40a31:                                 SQLState.BLOB_BAD_POSITION, start);
1:a78e683:         if (searchClob == null)
1:a78e683:             throw Util.generateCsSQLException(
1:a78e683:                                 SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
1:125c328: 
1:eac0369:         boolean pushStack = false;
1:3a6f4cf:         EmbedConnection ec = getEmbedConnection();
1:eac0369:         try
1:eac0369:         {
1:eac0369:             synchronized (getConnectionSynchronization())
1:eac0369:             {
1:394a70e:                 char[] subPatternChar = new char[1024];
1:47510ba: 
1:394a70e:                 boolean seenOneCharacter = false;
1:47510ba: 
1:eac0369: restartScan:
1:394a70e:                 for (;;) {
1:394a70e:                     long firstPosition = -1;
1:394a70e:                     Reader patternReader = searchClob.getCharacterStream();
1:394a70e:                         for (;;) {
1:47510ba: 
1:0ed8291:                             int read = patternReader.read(subPatternChar, 0,
1:0ed8291:                                                         subPatternChar.length);
1:394a70e:                             if (read == -1) {
1:394a70e:                                 //empty pattern
1:3a6f4cf:                                 if (!seenOneCharacter) {
1:0ed8291:                                     // matches DB2 SQL LOCATE function
1:3a6f4cf:                                     restoreIntrFlagIfSeen(pushStack, ec);
1:0ed8291:                                     return start;
1:3a6f4cf:                                 }
1:3a6f4cf: 
1:3a6f4cf:                                 restoreIntrFlagIfSeen(pushStack, ec);
1:394a70e:                                 return firstPosition;
1:394a70e:                             }
1:394a70e:                             if (read == 0) {
1:394a70e:                                 continue;
1:394a70e:                             }
1:394a70e:                             seenOneCharacter = true;
1:e1fc783: 
1:0ed8291:                             String subPattern =
1:0ed8291:                                 new String(subPatternChar, 0, read);
1:394a70e:                             long position = position(subPattern, start);
1:394a70e:                             if (position == -1) {
1:394a70e:                                 // never seen any match
1:3a6f4cf:                                 if (firstPosition == -1) {
1:3a6f4cf:                                     restoreIntrFlagIfSeen(pushStack, ec);
1:394a70e:                                     return -1;
1:3a6f4cf:                                 }
1:e1fc783: 
1:394a70e:                                 start = firstPosition + 1;
1:394a70e:                                 continue restartScan;
1:394a70e:                             }
1:e1fc783: 
2:394a70e:                             if (firstPosition == -1)
1:394a70e:                                 firstPosition = position;
1:394a70e:                             else if (position != start) {
1:0ed8291:                                 // must match at the first character of segment
1:394a70e:                                 start = firstPosition + 1;
1:394a70e:                                 continue restartScan;
1:394a70e:                             }
1:e1fc783: 
1:394a70e:                             // read is the length of the subPattern string
1:394a70e:                             start = position + read;
1:a78e683:                     } // End inner for loop
1:3a6f4cf:                 } // End outer for loop
1:3a6f4cf:             } // End synchronized block
1:a78e683:         } catch (IOException ioe) {
1:3a6f4cf:             restoreIntrFlagIfSeen(pushStack, ec);
1:a78e683:             throw Util.setStreamFailure(ioe);
1:a78e683:         } finally {
1:a78e683:             if (pushStack) {
1:a78e683:                 restoreContextStack();
1:394a70e:             }
1:394a70e:         }
1:394a70e:     }
1:e1fc783: 
1:394a70e:     /**
1:eac0369:     Following methods are for the new JDBC 3.0 methods in java.sql.Clob
1:eac0369:     (see the JDBC 3.0 spec). We have the JDBC 3.0 methods in Local20
1:eac0369:     package, so we don't have to have a new class in Local30.
1:eac0369:     The new JDBC 3.0 methods don't make use of any new JDBC3.0 classes and
1:eac0369:     so this will work fine in jdbc2.0 configuration.
1:394a70e:     */
1:e1fc783: 
1:fcf7ef3:     /////////////////////////////////////////////////////////////////////////
1:fcf7ef3:     //
1:394a70e:     //    JDBC 3.0    -    New public methods
1:fcf7ef3:     //
1:fcf7ef3:     /////////////////////////////////////////////////////////////////////////
1:fcf7ef3: 
1:125c328:     /**
1:394a70e:      * JDBC 3.0
1:0aceaa9:      *
1:0ed8291:      * Writes the given Java String to the CLOB value that this Clob object
1:0ed8291:      * designates at the position pos.
1:0aceaa9:      *
1:0ed8291:      * @param pos the position at which to start writing to the CLOB value that
1:0ed8291:      *      this Clob object represents
1:394a70e:      * @return the number of characters written
1:0ed8291:      * @throws SQLException if writing the string fails
1:394a70e:      */
1:394a70e:     public int setString(long pos, String str) throws SQLException {
1:e1fc783:             return setString (pos, str, 0, str.length());
1:394a70e:     }
1:1e5b2aa: 
1:394a70e:     /**
1:394a70e:      * JDBC 3.0
1:0aceaa9:      *
1:0ed8291:      * Writes len characters of str, starting at character offset, to the CLOB
1:0ed8291:      * value that this Clob represents.
1:0aceaa9:      *
1:0ed8291:      * @param pos the position at which to start writing to this Clob object
1:0ed8291:      * @param str the string to be written to the CLOB value that this Clob
1:0ed8291:      *      designates
1:0ed8291:      * @param offset the offset into str to start reading the characters to be
1:0ed8291:      *      written
1:0ed8291:      * @param len the number of characters to be written
1:394a70e:      * @return the number of characters written
1:0ed8291:      * @exception SQLException if writing the string fails
1:394a70e:      */
1:394a70e:     public int setString(long pos, String str, int offset, int len)
1:a78e683:             throws SQLException {
1:125c328:         checkValidity();
1:1e5b2aa:         if (pos < 1) {
1:a78e683:             throw Util.generateCsSQLException(
1:ce40a31:                 SQLState.BLOB_BAD_POSITION, pos);
1:394a70e:         }
1:fcf7ef3:         
1:1e5b2aa:         if (pos > length() + 1) {
1:394a70e:             throw Util.generateCsSQLException(
1:1e5b2aa:         	    SQLState.BLOB_POSITION_TOO_LARGE);
1:394a70e:         }
1:1e5b2aa:         
1:1e5b2aa:         if (str == null) {
1:e1fc783:             throw Util.generateCsSQLException(
1:1e5b2aa:         	    SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
1:47510ba:         }
1:1e5b2aa:         
1:1e5b2aa:         if (str.length() == 0) {
1:1e5b2aa:             return 0;
1:e1fc783:         }
1:1e5b2aa:         
1:1e5b2aa:         if (offset < 0 || offset >= str.length()) {
1:1e5b2aa:             throw Util.generateCsSQLException(SQLState.BLOB_INVALID_OFFSET);
1:e1fc783:         }
1:1e5b2aa:         
1:1e5b2aa:         if (len < 0) {
1:e1fc783:             throw Util.generateCsSQLException(
1:1e5b2aa:         	    SQLState.BLOB_NONPOSITIVE_LENGTH);
1:e1fc783:         }
1:1e5b2aa:         
1:1e5b2aa:         if (len + offset > str.length()) {
1:1e5b2aa:             throw Util.generateCsSQLException(
1:1e5b2aa:                     SQLState.LANG_SUBSTR_START_ADDING_LEN_OUT_OF_RANGE,
1:ce40a31:                     offset, len, str);
1:e1fc783:         }
1:1e5b2aa:         
1:394a70e:         try {
1:a78e683:             if (!this.clob.isWritable()) {
1:a78e683:                 makeWritableClobClone();
1:e1fc783:             }
1:a78e683:             // Note that Clob.length() +1 is a valid position for setString.
1:a78e683:             // If the position is larger than this, an EOFException will be
1:a78e683:             // thrown. This is cheaper then getting the length up front.
1:a78e683:             this.clob.insertString(str.substring(offset, (offset + len)),
1:a78e683:                                    pos);
1:a78e683:         } catch (EOFException eofe) {
1:a78e683:             throw Util.generateCsSQLException(
1:ba50299:                         SQLState.BLOB_POSITION_TOO_LARGE,
1:ce40a31:                         pos);
1:394a70e:         } catch (IOException e) {
1:394a70e:             throw Util.setStreamFailure(e);
1:e1fc783:         }
1:a78e683:         return str.length();
1:e1fc783:     }
1:456b8a1: 
1:394a70e:     /**
1:394a70e:      * JDBC 3.0
1:0aceaa9:      *
1:394a70e:      * Retrieves a stream to be used to write Ascii characters to the CLOB
1:394a70e:      * value that this Clob object represents, starting at position pos.
1:0aceaa9:      *
1:0ed8291:      * @param pos the position at which to start writing to this Clob object
1:394a70e:      * @return the stream to which ASCII encoded characters can be written
1:0ed8291:      * @exception SQLException if obtaining the stream fails
1:394a70e:      */
1:e1fc783:     public java.io.OutputStream setAsciiStream(long pos) throws SQLException {
1:a78e683:         checkValidity();
1:394a70e:         try {
1:a78e683:             return new ClobAsciiStream (this.clob.getWriter(pos));
1:e1fc783:         } catch (IOException e) {
1:e1fc783:             throw Util.setStreamFailure(e);
1:e1fc783:         }
1:e1fc783:     }
1:ce0c6c4: 
1:394a70e:     /**
1:394a70e:      * JDBC 3.0
1:0aceaa9:      *
1:0ed8291:      * Retrieves a stream to be used to write a stream of characters to the CLOB
1:0ed8291:      * value that this Clob object represents, starting at position pos.
1:0aceaa9:      *
1:0ed8291:      * @param pos the position at which to start writing to this Clob object
1:394a70e:      * @return the stream to which Unicode encoded characters can be written
1:0ed8291:      * @exception SQLException if obtaining the stream fails
1:394a70e:      */
1:e1fc783:     public java.io.Writer setCharacterStream(long pos) throws SQLException {
1:a78e683:         checkValidity();
1:394a70e:         try {
1:a78e683:             if (!this.clob.isWritable()) {
1:a78e683:                 makeWritableClobClone();
1:e1fc783:             }
1:a78e683:             return this.clob.getWriter(pos);
1:a78e683:         } catch (IOException ioe) {
1:a78e683:             throw Util.setStreamFailure(ioe);
1:e1fc783:         }
1:e1fc783:     }
1:eac0369: 
1:394a70e:     /**
1:394a70e:      * JDBC 3.0
1:0aceaa9:      *
1:0ed8291:      * Truncates the CLOB value that this Clob designates to have a length of
1:0ed8291:      * len characters
1:0aceaa9:      *
1:0ed8291:      * @param len the length, in characters, to which the CLOB value should be
1:979d9e8:      *      truncated, 0 is accepted
1:0ed8291:      * @exception SQLException if truncating the CLOB value fails
1:394a70e:      */
1:394a70e:     public void truncate(long len) throws SQLException
1:394a70e:     {
1:ba50299:         checkValidity();
1:979d9e8:         if (len < 0)
1:1e5b2aa:             throw Util.generateCsSQLException(
1:ce40a31:                 SQLState.BLOB_NONPOSITIVE_LENGTH, len);
1:394a70e:         try {
1:ba50299:             if (!clob.isWritable()) {
1:ba50299:                 makeWritableClobClone(len);
1:ba50299:             }
1:ba50299:             else {
1:ba50299:                 clob.truncate (len);
1:ba50299:             }
1:ba50299:         }
1:ba50299:         catch (EOFException eofe) {
1:ba50299:             throw Util.generateCsSQLException(
1:4d20e64:                         SQLState.BLOB_LENGTH_TOO_LONG,
1:1f18dc3:                         eofe, len);
1:ba50299:         } catch (IOException e) {
1:ba50299:             throw Util.setStreamFailure(e);
1:ba50299:         }
1:394a70e:     }
1:eac0369: 
1:394a70e:     /////////////////////////////////////////////////////////////////////////
1:394a70e:     //
1:394a70e:     //    JDBC 4.0    -    New public methods
1:394a70e:     //
1:394a70e:     /////////////////////////////////////////////////////////////////////////
1:394a70e:     /**
1:a78e683:      * Frees the <code>Clob</code> and releases the resources that it holds.
1:a78e683:      * <p>
1:a78e683:      * The object is invalid once the <code>free</code> method
1:125c328:      * is called. If <code>free</code> is called multiple times, the
1:125c328:      * subsequent calls to <code>free</code> are treated as a no-op.
1:125c328:      *
1:a78e683:      * @throws SQLException if an error occurs releasing the Clobs resources
1:125c328:      */
1:fcf7ef3:     public void free()
1:fcf7ef3:         throws SQLException {
1:a78e683:         if (this.isValid) {
1:a78e683:             this.isValid = false;
1:a78e683:             // Release and nullify the internal Clob.
1:394a70e:             try {
1:a78e683:                 this.clob.release();
1:a78e683:             } catch (IOException e) {
1:e1fc783:                 throw Util.setStreamFailure(e);
1:a78e683:             } finally {
1:d96e398:                 localConn.removeLOBMapping(locator);
1:a78e683:                 this.clob = null;
1:fcf7ef3:             }
1:e1fc783:         }
1:e1fc783:     }
1:125c328: 
1:e1fc783:     /**
1:cd727e7:      * Returns a <code>Reader</code> object that contains a partial
1:cd727e7:      * <code>Clob</code> value, starting with the character specified by pos,
1:cd727e7:      * which is length characters in length.
1:0aceaa9:      *
1:cd727e7:      * @param pos the offset to the first character of the partial value to
1:cd727e7:      * be retrieved.  The first character in the Clob is at position 1.
1:cd727e7:      * @param length the length in characters of the partial value to be
1:cd727e7:      * retrieved.
1:cd727e7:      * @return <code>Reader</code> through which the partial <code>Clob</code>
1:cd727e7:      * value can be read.
1:cd727e7:      * @throws SQLException if pos is less than 1 or if pos is greater than the
1:cd727e7:      * number of
1:418a799:      * characters in the {@code Clob} or if {@code pos + length} is greater than
1:418a799:      * {@code Clob.length() +1}
1:394a70e:      */
1:fcf7ef3:     public java.io.Reader getCharacterStream(long pos, long length)
1:fcf7ef3:         throws SQLException {
1:125c328:         //call checkValidity to exit by throwing a SQLException if
1:125c328:         //the Clob object has been freed by calling free() on it
1:a78e683:         checkValidity();
1:125c328:         
1:cd727e7:         if (pos <= 0) {
1:1e5b2aa:             throw Util.generateCsSQLException(
1:cd727e7:                     SQLState.BLOB_BAD_POSITION,
1:ce40a31:                     pos);
1:fcf7ef3:         }
1:cd727e7:         if (length < 0) {
1:1e5b2aa:             throw Util.generateCsSQLException(
1:cd727e7:                     SQLState.BLOB_NONPOSITIVE_LENGTH,
1:ce40a31:                     length);
1:e1fc783:         }
1:aeb4325:         if (length > (this.length() - (pos -1))) {
3:cd727e7:             throw Util.generateCsSQLException(
1:cd727e7:                     SQLState.POS_AND_LENGTH_GREATER_THAN_LOB,
1:ce40a31:                     pos, length);
1:e1fc783:         }
1:cd727e7:         
1:e1fc783:         try {
1:910b77f:             return new ClobUpdatableReader(this, pos, length);
1:394a70e:         } catch (IOException ioe) {
1:cd727e7:             throw Util.setStreamFailure(ioe);
2:e1fc783:         } 
1:e1fc783:     }
1:cd727e7: 
1:394a70e:     /*
1:a78e683:      * Checks if the Clob is valid.
1:a78e683:      * <p>
1:a78e683:      * A Clob is invalidated when {@link #free} is called or if the parent
1:a78e683:      * connection is closed.
1:0aceaa9:      *
1:a78e683:      * @throws SQLException if the Clob is not valid
1:e1fc783:      */
1:125c328:     private void checkValidity() throws SQLException{
1:394a70e:         localConn.checkIfClosed();        
1:125c328:         if(!isValid)
1:125c328:             throw newSQLException(SQLState.LOB_OBJECT_INVALID);
1:125c328:     }
1:a78e683: 
1:a78e683:     /**
1:a78e683:      * Makes a writable clone of the current Clob.
1:a78e683:      * <p>
1:a78e683:      * This is called when we have a {@link StoreStreamClob} and the user calls
1:a78e683:      * a method updating the content of the Clob. A temporary Clob will then be
1:a78e683:      * created to hold the updated content.
1:0aceaa9:      *
1:a78e683:      * @throws IOException if accessing underlying I/O resources fail
1:a78e683:      * @throws SQLException if accessing underlying resources fail
1:ba50299:      */
1:a78e683:     private void makeWritableClobClone()
1:a78e683:             throws IOException, SQLException {
1:a78e683:         InternalClob toBeAbandoned = this.clob;
1:b0c495f:         this.clob = TemporaryClob.cloneClobContent(
1:a78e683:                         getEmbedConnection().getDBName(),
1:a78e683:                         this, toBeAbandoned);
1:a78e683:         toBeAbandoned.release();
1:a78e683:     }
1:80424bf: 
1:80424bf:     /**
1:ba50299:      * Makes a writable clone of the current Clob.
1:ba50299:      * <p>
1:ba50299:      * This is called when we have a {@link StoreStreamClob} and the user calls
1:ba50299:      * a method updating the content of the Clob. A temporary Clob will then be
1:ba50299:      * created to hold the updated content.
1:0ed8291:      *
1:0ed8291:      * @param len number of characters to be cloned (should be smaller
1:0ed8291:      *      than clob length)
1:ba50299:      * @throws IOException if accessing underlying I/O resources fail
1:ba50299:      * @throws SQLException if accessing underlying resources fail
1:80424bf:      */
1:ba50299:     private void makeWritableClobClone(long len)
1:ba50299:             throws IOException, SQLException {
1:ba50299:         InternalClob toBeAbandoned = this.clob;
1:b0c495f:         this.clob = TemporaryClob.cloneClobContent(
1:ba50299:                         getEmbedConnection().getDBName(),
1:ba50299:                         this, toBeAbandoned, len);
1:ba50299:         toBeAbandoned.release();
1:80424bf:     }
1:80424bf: 
1:80424bf:     /**
1:6b5cc24:      * Returns the current internal Clob representation.
1:6b5cc24:      * <p>
1:6b5cc24:      * Care should be taken, as the representation can change when the user
1:6b5cc24:      * performs operations on the Clob. An example is if the Clob content is
1:6b5cc24:      * served from a store stream and the user updates the content. The
1:6b5cc24:      * internal representation will then be changed to a temporary Clob copy
1:6b5cc24:      * that allows updates.
1:6b5cc24:      *
1:6b5cc24:      * @return The current internal Clob representation.
1:80424bf:      */
1:6b5cc24:     InternalClob getInternalClob() {
1:6b5cc24:         return this.clob;
1:80424bf:     }
1:80424bf: 
1:e1fc783:     /**     
1:456b8a1:      * @return locator value for this Clob.
1:a78e683:      */
1:456b8a1:     public int getLocator() {
1:d96e398:         if (locator == 0) {
1:d96e398:             locator = localConn.addLOBMapping(this);
1:80424bf:         }
1:456b8a1:         return locator;
1:0ed8291:     }
1:ba50299: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.BLOB_BAD_POSITION, pos);
1:                 SQLState.BLOB_NONPOSITIVE_LENGTH, length);
/////////////////////////////////////////////////////////////////////////
1:                             SQLState.BLOB_BAD_POSITION, start);
/////////////////////////////////////////////////////////////////////////
1:                                 SQLState.BLOB_BAD_POSITION, start);
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.BLOB_BAD_POSITION, pos);
/////////////////////////////////////////////////////////////////////////
1:                     offset, len, str);
/////////////////////////////////////////////////////////////////////////
1:                         pos);
/////////////////////////////////////////////////////////////////////////
1:                 SQLState.BLOB_NONPOSITIVE_LENGTH, len);
/////////////////////////////////////////////////////////////////////////
1:                     pos);
1:                     length);
1:                     pos, length);
commit:88a3cb9
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:8846963
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * This constructor is used to create a empty Clob object. It is used by the
0:      * Connection interface method createClob().
1:      * 
0:      * @param clobString A String object containing the data to be stores in the 
0:      *        Clob.
1:      *
1:      * @param con The Connection object associated with this EmbedClob object.
1:      *
1:      */
1:     
0:     EmbedClob(String clobString,EmbedConnection con) {
1:         super(con);
0:         myString = clobString;
0:         isString = true;
1:     }
1:     
commit:125c328
/////////////////////////////////////////////////////////////////////////
1:     
0:     //This boolean variable indicates whether the Clob object has
0:     //been invalidated by calling free() on it
1:     private boolean isValid = true;
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
/////////////////////////////////////////////////////////////////////////
1:                 //call checkValidity to exit by throwing a SQLException if
1:                 //the Clob object has been freed by calling free() on it
1:                 checkValidity();
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
1:         //call checkValidity to exit by throwing a SQLException if
1:         //the Clob object has been freed by calling free() on it
1:         checkValidity();
1:         
/////////////////////////////////////////////////////////////////////////
0:                 throw Util.notImplemented();
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * This method frees the <code>Clob</code> object and releases the resources the resources
0:      * that it holds.  The object is invalid once the <code>free</code> method
1:      * is called. If <code>free</code> is called multiple times, the
1:      * subsequent calls to <code>free</code> are treated as a no-op.
1:      *
0:      * @throws SQLException if an error occurs releasing
0:      * the Clob's resources
1:      */
0:         //calling free() on a already freed object is treated as a no-op
0:         if (!isValid) return;
1:         
0:         //now that free has been called the Clob object is no longer
0:         //valid
0:         isValid = false;
1:         
0:         if (!isString)
0:             ((Resetable)myStream).closeStream();
0:         else
0:             myString = null;
/////////////////////////////////////////////////////////////////////////
1:         
1:         /*
0:          * Checks is isValid is true. If it is not true throws 
0:          * a SQLException stating that a method has been called on
0:          * an invalid LOB object
1:          *
0:          * throws SQLException if isValid is not true.
1:          */
1:         private void checkValidity() throws SQLException{
1:             if(!isValid)
1:                 throw newSQLException(SQLState.LOB_OBJECT_INVALID);
1:         }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:0aceaa9
/////////////////////////////////////////////////////////////////////////
0: 	* begins at position <code>start</code>. The method uses the following
0: 	* algorithm for the search
1: 	*
1: 	*
0: 	* 1)Is the length of the current pattern string to be matched greater than 256 ?
1: 	*
0: 	*	1.1)If "YES"
0: 	*		Extract the first 256 bytes as the current pattern to be matched
1: 	*
0: 	*		If "NO"
0: 	*		Make the pattern string itself as the current pattern to be matched
1: 	*
0: 	*	1.2)Initialize a variable that will indicate the character in the pattern
0: 	*		String being matched to zero. (say currPatternPos)
1: 	*
0: 	* 2)Read the 256 bytes of the Clob from the database
1: 	*
0: 	*	2.1)Initialize a variable that will indicate the current index in this array
0: 	*		to zero. (say currClobPos)
0: 	*	2.2)Exit if there are no more characters to be read in the Clob
1: 	*
0: 	* 3)Initialize a bestMatchPosition that will keep storing the next occurence of the 
0: 	*	first character in the pattern.This will be useful when we want to go back and 
0: 	*	start searching in the Clob array when a mismatch occurs.
1: 	*
0: 	* 4)Do the characters in currPatternPos and currClobPos match ?
0: 	*	4.1)If "YES" 
1: 	*
0: 	*		Increment currPatternPos and currClobPos. 
1: 	*
0: 	*		If currPatternPos is not 0 and the character in the 
0: 	*		currentClobPos is the same as the first character in the
0: 	*		pattern set bestMatchPosition = currentClobPos
1: 	*
0: 	*	4.2)If "No" 
1: 	*
0: 	*		set currClobPos = bestMatchPosition
0: 	*		set currPatternPos = 0
1: 	*
0: 	*	4.3)If currPatternPos > 256 
0: 	*		4.3.1)If "YES" 
0: 	*			  Return the current position in the Clob if all characters 
0: 	*			  have been matched otherwise perform step 1 to fetch the
0: 	*			  next 256 characters and increment matchCount
0: 	*		4.3.2)If "NO" repeat Step 4
1: 	*
0: 	*	4.4)If currClobPos > 256
0: 	*		4.4.1)If "YES"
0: 	*			  Repeat step 2 to fetch next 256 characters
0: 	*		4.4.2)If "NO"
0: 	*			  Repeat step 4
/////////////////////////////////////////////////////////////////////////
0: 								//Keep extracting substrings of length 256 from the pattern string
0: 								//and use these substrings for comparison with the data from the Clob
0: 								//if the subString remaining has a length > 256 then extract 256 bytes
0: 								//and return it
0: 								//otherwise return the remaining string 
0: 									tmpPatternS = searchStr.substring(patternIndex , patternIndex + 256);
0: 									tmpPatternS = searchStr.substring(patternIndex , patternLength);
/////////////////////////////////////////////////////////////////////////
0: 										//We need to increment clobOffset
0: 										//to start comparison from the 
0: 										//next character since the current
0: 										//character has already been compared
0: 										clobOffset++;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:1f18dc3
/////////////////////////////////////////////////////////////////////////
1:                         SQLState.BLOB_POSITION_TOO_LARGE, eofe, pos);
/////////////////////////////////////////////////////////////////////////
1:                     SQLState.BLOB_POSITION_TOO_LARGE, eofe, start);
/////////////////////////////////////////////////////////////////////////
1:                         eofe, len);
commit:d349a1f
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException, SQLException
/////////////////////////////////////////////////////////////////////////
1:                 throw Util.setStreamFailure(e);
commit:d2b4fdb
/////////////////////////////////////////////////////////////////////////
0:                 clob = new ClobStreamControl(con.getDBName(),
0:                         dvd.getString(), this);
commit:2333262
/////////////////////////////////////////////////////////////////////////
0:         catch (StandardException se) {
0:             throw Util.generateCsSQLException (se);
1:         }
/////////////////////////////////////////////////////////////////////////
0:             catch (StandardException se) {
0:                 throw Util.generateCsSQLException (se);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         } catch (StandardException se) {
0:             throw Util.generateCsSQLException (se);
commit:fcf7ef3
/////////////////////////////////////////////////////////////////////////
1:     /////////////////////////////////////////////////////////////////////////
1:     //
0:     //	JDBC 4.0	-	New public methods
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 	
1:     public void free()
1:         throws SQLException {
0:         throw Util.notImplemented();
1:     }
1: 
1:     public java.io.Reader getCharacterStream(long pos, long length)
1:         throws SQLException {
0:         throw Util.notImplemented();
1:     }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3a6f4cf
/////////////////////////////////////////////////////////////////////////
1:         EmbedConnection ec = getEmbedConnection();
1:                 pushStack = !ec.isClosed();
/////////////////////////////////////////////////////////////////////////
1:                     if (readCount == -1) {
1:                         restoreIntrFlagIfSeen(pushStack, ec);
1:                     }
/////////////////////////////////////////////////////////////////////////
1:                                 restoreIntrFlagIfSeen(pushStack, ec);
/////////////////////////////////////////////////////////////////////////
1:             restoreIntrFlagIfSeen(pushStack, ec);
1:             restoreIntrFlagIfSeen(pushStack, ec);
/////////////////////////////////////////////////////////////////////////
1:         EmbedConnection ec = getEmbedConnection();
/////////////////////////////////////////////////////////////////////////
1:                                 if (!seenOneCharacter) {
1:                                     restoreIntrFlagIfSeen(pushStack, ec);
1:                                 }
1: 
1:                                 restoreIntrFlagIfSeen(pushStack, ec);
/////////////////////////////////////////////////////////////////////////
1:                                 if (firstPosition == -1) {
1:                                     restoreIntrFlagIfSeen(pushStack, ec);
1:                                 }
/////////////////////////////////////////////////////////////////////////
1:                 } // End outer for loop
1:             } // End synchronized block
1:             restoreIntrFlagIfSeen(pushStack, ec);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:541361f
/////////////////////////////////////////////////////////////////////////
1:         if (dvd.hasStream()) {
1:             CharacterStreamDescriptor csd = dvd.getStreamWithDescriptor();
/////////////////////////////////////////////////////////////////////////
1:         } else {
1:             try {
1:                 clob = new TemporaryClob(dvd.getString(),
1:                         this);
1:             }
0:             catch (SQLException sqle) {
0:                 throw StandardException.newException (sqle.getSQLState(), sqle);
1:             }
1:             catch (IOException e) {
0:                 throw StandardException.newException (
0:                                         SQLState.SET_STREAM_FAILURE, e);
1:             }
commit:10d991a
/////////////////////////////////////////////////////////////////////////
1:         if ("".equals(searchStr))
commit:979d9e8
/////////////////////////////////////////////////////////////////////////
1:      *      truncated, 0 is accepted
1:         if (len < 0)
0:                 SQLState.BLOB_NONPOSITIVE_LENGTH, new Long(len));
commit:418a799
/////////////////////////////////////////////////////////////////////////
1:      * characters in the {@code Clob} or if {@code pos + length} is greater than
1:      * {@code Clob.length() +1}
commit:aeb4325
/////////////////////////////////////////////////////////////////////////
1:         if (length > (this.length() - (pos -1))) {
commit:7672693
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.CharacterStreamDescriptor;
1: import org.apache.derby.iapi.types.StringDataValue;
/////////////////////////////////////////////////////////////////////////
1:      * @param dvd string data value descriptor providing the Clob source
1:     protected EmbedClob(EmbedConnection con, StringDataValue dvd)
/////////////////////////////////////////////////////////////////////////
0:         CharacterStreamDescriptor csd = dvd.getStreamWithDescriptor();
0:         if (csd == null) {
/////////////////////////////////////////////////////////////////////////
1:                 SanityManager.ASSERT(csd.getStream() instanceof Resetable);
1:                 this.clob = new StoreStreamClob(csd, this);
commit:4d20e64
/////////////////////////////////////////////////////////////////////////
1:                         SQLState.BLOB_LENGTH_TOO_LONG,
0:                         new Long(len), eofe);
commit:910b77f
/////////////////////////////////////////////////////////////////////////
1:             return new ClobUpdatableReader(this, pos, length);
commit:ab2037f
/////////////////////////////////////////////////////////////////////////
1:         Reader reader;
1:             try {
1:                 reader = this.clob.getInternalReader(pos);
1:             } catch (EOFException eofe) {
1:                 throw Util.generateCsSQLException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos), eofe);
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 Reader reader = this.clob.getInternalReader(start);
/////////////////////////////////////////////////////////////////////////
1:                                     reader = this.clob.getInternalReader(
1:                                                                     newStart);
/////////////////////////////////////////////////////////////////////////
1:         } catch (EOFException eofe) {
1:             throw Util.generateCsSQLException(
0:                                         SQLState.BLOB_POSITION_TOO_LARGE, eofe);
commit:1d6c1a5
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.jdbc.EngineLOB;
/////////////////////////////////////////////////////////////////////////
1: final class EmbedClob extends ConnectionChild implements Clob, EngineLOB
commit:b0c495f
/////////////////////////////////////////////////////////////////////////
0:         this.clob = new TemporaryClob (con.getDBName(), this);
/////////////////////////////////////////////////////////////////////////
0:                 clob = new TemporaryClob(con.getDBName(),
/////////////////////////////////////////////////////////////////////////
1:         this.clob = TemporaryClob.cloneClobContent(
/////////////////////////////////////////////////////////////////////////
1:         this.clob = TemporaryClob.cloneClobContent(
commit:fcdce55
/////////////////////////////////////////////////////////////////////////
1:             return new ClobUpdatableReader (this);
/////////////////////////////////////////////////////////////////////////
0:             return new ClobUpdatableReader(this,
commit:6b5cc24
/////////////////////////////////////////////////////////////////////////
1:      * Returns the current internal Clob representation.
1:      * <p>
1:      * Care should be taken, as the representation can change when the user
1:      * performs operations on the Clob. An example is if the Clob content is
1:      * served from a store stream and the user updates the content. The
1:      * internal representation will then be changed to a temporary Clob copy
1:      * that allows updates.
1:      *
1:      * @return The current internal Clob representation.
1:     InternalClob getInternalClob() {
1:         return this.clob;
commit:80424bf
/////////////////////////////////////////////////////////////////////////
0:             return new ClobUpdateableReader (this);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
0:      * Returns if the internal clob is a writable clob.
0:      * @return true if internal clob is writable
1:      */
0:     boolean isWritable() {
0:         return clob.isWritable();
1:     }
1: 
1:     /**
0:      * Returns the internal InputStream associated with this clob.
0:      * @return internal InputStream
0:      * @throws IOException
1:      */
0:     InputStream getInternalStream () 
0:                     throws IOException, SQLException  {
0:         return clob.getRawByteStream();
1:     }
1: 
1:     /**
0:      * Returns byte length of the clob
0:      * @return byte length of the clob
0:      * @throws IOException
1:      * @throws SQLException
1:      */
0:     long getByteLength() throws IOException, SQLException {
0:         return clob.getByteLength();
1:     }
commit:0ed8291
/////////////////////////////////////////////////////////////////////////
1:             SanityManager.ASSERT(!dvd.isNull(),
1:                                  "clob is created on top of a null column");
/////////////////////////////////////////////////////////////////////////
1:      * * <code>length</code> consecutive characters. The starting position must
1:      * be between 1 and the length of the CLOB plus 1. This allows for 
1:      * zero-length CLOB values, from which only zero-length substrings can be
1:      * returned.
1:      * <p>
/////////////////////////////////////////////////////////////////////////
1:      * @return A <code>String</code> that is the specified substring in the
1:      *    <code>CLOB</code> value designated by this <code>Clob</code> object
1:      * @exception SQLException if there is an error accessing the
/////////////////////////////////////////////////////////////////////////
1:      * @return An Ascii stream containing the <code>CLOB</code> data. Valid
1:      *      values in the stream are 0 - 255.
/////////////////////////////////////////////////////////////////////////
1:      * <code>searchStr</code> appears in the <code>CLOB</code> value.
1:      * <p>
1:      * The search begins at position <code>start</code>. The method uses the
1:      * following algorithm for the search:
1:      * If the <code>CLOB</code> value is represented as a stream, read a block
1:      * of chars from the start position and compare the chars with
1:      *      <li>If no match is found, return <code>-1</code>.
/////////////////////////////////////////////////////////////////////////
1:                             int read = patternReader.read(subPatternChar, 0,
1:                                                         subPatternChar.length);
1:                                     // matches DB2 SQL LOCATE function
1:                                     return start;
/////////////////////////////////////////////////////////////////////////
1:                             String subPattern =
1:                                 new String(subPatternChar, 0, read);
/////////////////////////////////////////////////////////////////////////
1:                                 // must match at the first character of segment
/////////////////////////////////////////////////////////////////////////
1:      * Writes the given Java String to the CLOB value that this Clob object
1:      * designates at the position pos.
1:      * @param pos the position at which to start writing to the CLOB value that
1:      *      this Clob object represents
1:      * @throws SQLException if writing the string fails
/////////////////////////////////////////////////////////////////////////
1:      * Writes len characters of str, starting at character offset, to the CLOB
1:      * value that this Clob represents.
1:      * @param pos the position at which to start writing to this Clob object
1:      * @param str the string to be written to the CLOB value that this Clob
1:      *      designates
1:      * @param offset the offset into str to start reading the characters to be
1:      *      written
1:      * @param len the number of characters to be written
1:      * @exception SQLException if writing the string fails
/////////////////////////////////////////////////////////////////////////
1:      * @param pos the position at which to start writing to this Clob object
1:      * @exception SQLException if obtaining the stream fails
/////////////////////////////////////////////////////////////////////////
1:      * Retrieves a stream to be used to write a stream of characters to the CLOB
1:      * value that this Clob object represents, starting at position pos.
1:      * @param pos the position at which to start writing to this Clob object
1:      * @exception SQLException if obtaining the stream fails
/////////////////////////////////////////////////////////////////////////
1:      * Truncates the CLOB value that this Clob designates to have a length of
1:      * len characters
1:      * @param len the length, in characters, to which the CLOB value should be
0:      *      truncated
1:      * @exception SQLException if truncating the CLOB value fails
/////////////////////////////////////////////////////////////////////////
1: 
1:      *
1:      * @param len number of characters to be cloned (should be smaller
1:      *      than clob length)
/////////////////////////////////////////////////////////////////////////
1:     }
commit:ba50299
/////////////////////////////////////////////////////////////////////////
1:         checkValidity();
0:         if (len < 1)
1:             throw Util.generateCsSQLException(
0:                 SQLState.BLOB_BAD_POSITION, new Long(len));
1:         try {
1:             if (!clob.isWritable()) {
1:                 makeWritableClobClone(len);
1:             }
1:             else {
1:                 clob.truncate (len);
1:             }
1:         }
1:         catch (EOFException eofe) {
1:             throw Util.generateCsSQLException(
1:                         SQLState.BLOB_POSITION_TOO_LARGE,
0:                         new Long(len));
1:         } catch (IOException e) {
1:             throw Util.setStreamFailure(e);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Makes a writable clone of the current Clob.
1:      * <p>
1:      * This is called when we have a {@link StoreStreamClob} and the user calls
1:      * a method updating the content of the Clob. A temporary Clob will then be
1:      * created to hold the updated content.
0:      * @param len number of chars to be cloned (should be smaller 
0:      *      than clob lenght)
1:      * @throws IOException if accessing underlying I/O resources fail
1:      * @throws SQLException if accessing underlying resources fail
1:      */
1:     private void makeWritableClobClone(long len)
1:             throws IOException, SQLException {
1:         InternalClob toBeAbandoned = this.clob;
0:         this.clob = ClobStreamControl.cloneClobContent(
1:                         getEmbedConnection().getDBName(),
1:                         this, toBeAbandoned, len);
1:         toBeAbandoned.release();
1:     }    
commit:a78e683
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The underlying Clob object, which may change depending on what the user
1:      * does with the Clob.
1:      */
1:     private InternalClob clob;
1: 
1:     /** Tells whether the Clob has been freed or not. */
1:      * Creates an empty Clob object.
1:     EmbedClob(EmbedConnection con) throws SQLException {
0:         this.clob = new ClobStreamControl (con.getDBName(), this);
1:      * Creates a Clob on top of a data value descriptor.
1:      * <p>
1:      * The data value descriptor may provide a <code>String</code> or a stream
1:      * as the source of the Clob.
0:      * @param dvd data value descriptor providing the Clob source
1:      * @param con associated connection for the Clob
0:     protected EmbedClob(EmbedConnection con, DataValueDescriptor dvd)
/////////////////////////////////////////////////////////////////////////
0:         InputStream storeStream = dvd.getStream();
1:         // See if a String or a stream will be the source of the Clob.
0:         if (storeStream == null) {
0:             this.clob = new ClobStreamControl(con.getDBName(), this);
0:                 this.clob.insertString (dvd.getString(), 1L);
/////////////////////////////////////////////////////////////////////////
1:         } else {
/////////////////////////////////////////////////////////////////////////
0:                 SanityManager.ASSERT(storeStream instanceof Resetable);
0:                 ((Resetable) storeStream).initStream();
1:                 throw se;
0:             this.clob = new StoreStreamClob(storeStream, this);
1:      * Returns the number of characters in the <code>CLOB</code> value
0:      *
1:      * @return The length of the <code>CLOB</code> in number of characters.
1:      * @exception SQLException if obtaining the length fails
1:             return this.clob.getCharLength();
1:         } catch (IOException e) {
1:             throw Util.setStreamFailure(e);
1:      * Returns a copy of the specified substring in the <code>CLOB</code> value
1:      * <p>
1:      * The substring begins at position <code>pos</code> and has up to
0:      * * <code>length</code> consecutive characters. The starting position must be
0:      * between 1 and the length of the CLOB plus 1. This allows for zero-length
0:      * CLOB values, from which only zero-length substrings can be returned.
1:      * <p>
1:      * <em>NOTE</em>: If the starting position is the length of the CLOB plus 1,
1:      * zero characters are returned regardless of the length requested.
0:      *
1:      *    The first character is at position 1.
0:      *    the <code>CLOB</code> value designated by this <code>Clob</code> object
1:      * @exception SQLException if there is an error accessing the 
1:      *    <code>CLOB</code>
/////////////////////////////////////////////////////////////////////////
1:         String result;
1:         // An exception will be thrown if the position is larger than the Clob.
1:         try {
0:             Reader reader = this.clob.getReader(pos);
1:             char[] chars = new char[length];
1:             int charsRead = 0;
1:             // Read all the characters requested, or until EOF is reached.
1:             while (charsRead < length) {
1:                 int read = reader.read(chars, charsRead, length - charsRead);
1:                 if (read == -1) {
1:                     break;
1:                 charsRead += read;
1:             reader.close();
1:             // If we have an empty Clob or requested length is zero, return "".
1:             if (charsRead == 0) {
1:                 result = "";
0:             } else {
1:                 result = String.copyValueOf(chars, 0, charsRead);
1:         } catch (EOFException eofe) {
1:             throw Util.generateCsSQLException(
0:                                         SQLState.BLOB_POSITION_TOO_LARGE, eofe);
1:         } catch (IOException ioe) {
1:             throw Util.setStreamFailure(ioe);
1:         return result;
1:      * Gets the <code>Clob</code> contents as a stream of characters.
1:      * @return A character stream containing the <code>CLOB</code> data.
1:      *    <code>CLOB</code>
1:         try {
0:             return this.clob.getReader(1L);
1:         } catch (IOException ioe) {
1:             throw Util.setStreamFailure(ioe);
0:      * @return An Ascii stream containing the <code>CLOB</code> data. Valid values
0:      *    in the stream are 0 - 255.
1:      *    <code>CLOB</code> value
1:         // Validity is checked in getCharacterStream().
/////////////////////////////////////////////////////////////////////////
1:         if (start < 1)
1:             throw Util.generateCsSQLException(
0:                             SQLState.BLOB_BAD_POSITION, new Long(start));
1:         if (searchStr == null)
1:             throw Util.generateCsSQLException(
1:                             SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
0:         if (searchStr == "")
1:             return start; // match DB2's SQL LOCATE function
/////////////////////////////////////////////////////////////////////////
1:                 long pos = start;
0:                 Reader reader = this.clob.getReader(start);
/////////////////////////////////////////////////////////////////////////
1:                         if (tmpClob[clobOffset]
1:                                         == searchStr.charAt(matchCount)) {
1:                                     && tmpClob[clobOffset]
1:                                     == searchStr.charAt(0)) {
1:                                         - searchStr.length() + 1;
/////////////////////////////////////////////////////////////////////////
0:                                     reader = this.clob.getReader(newStart);
/////////////////////////////////////////////////////////////////////////
1:         } catch (IOException ioe) {
1:             throw Util.setStreamFailure(ioe);
1:         } finally {
1:             if (pushStack) {
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (start < 1)
1:             throw Util.generateCsSQLException(
0:                                 SQLState.BLOB_BAD_POSITION, new Long(start));
1:         if (searchClob == null)
1:             throw Util.generateCsSQLException(
1:                                 SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                     } // End inner for loop
0:             } // End outer for loop
0:         } // End synchronized block
1:         } catch (IOException ioe) {
1:             throw Util.setStreamFailure(ioe);
1:         } finally {
1:             if (pushStack) {
1:                 restoreContextStack();
/////////////////////////////////////////////////////////////////////////
1:             throws SQLException {
1:         checkValidity();
1:         if (pos < 1)
1:             throw Util.generateCsSQLException(
0:                 SQLState.BLOB_BAD_POSITION, new Long(pos));
1:             if (!this.clob.isWritable()) {
1:                 makeWritableClobClone();
1:             // Note that Clob.length() +1 is a valid position for setString.
1:             // If the position is larger than this, an EOFException will be
1:             // thrown. This is cheaper then getting the length up front.
1:             this.clob.insertString(str.substring(offset, (offset + len)),
1:                                    pos);
0:         } catch (EOFException eofe) {
1:             throw Util.generateCsSQLException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE,
0:                         new Long(pos));
1:         return str.length();
/////////////////////////////////////////////////////////////////////////
1:         checkValidity();
1:             return new ClobAsciiStream (this.clob.getWriter(pos));
/////////////////////////////////////////////////////////////////////////
1:         checkValidity();
1:             if (!this.clob.isWritable()) {
1:                 makeWritableClobClone();
1:             return this.clob.getWriter(pos);
1:         } catch (IOException ioe) {
1:             throw Util.setStreamFailure(ioe);
/////////////////////////////////////////////////////////////////////////
1:      * Frees the <code>Clob</code> and releases the resources that it holds.
1:      * <p>
1:      * The object is invalid once the <code>free</code> method
1:      * @throws SQLException if an error occurs releasing the Clobs resources
1:         if (this.isValid) {
1:             this.isValid = false;
1:             // Release and nullify the internal Clob.
1:                 this.clob.release();
1:             } catch (IOException e) {
1:             } finally {
1:                 this.clob = null;
/////////////////////////////////////////////////////////////////////////
1:      * Checks if the Clob is valid.
1:      * <p>
1:      * A Clob is invalidated when {@link #free} is called or if the parent
1:      * connection is closed.
1:      * @throws SQLException if the Clob is not valid
1: 
1:     /**
1:      * Makes a writable clone of the current Clob.
1:      * <p>
1:      * This is called when we have a {@link StoreStreamClob} and the user calls
1:      * a method updating the content of the Clob. A temporary Clob will then be
1:      * created to hold the updated content.
0:      *
1:      * @throws IOException if accessing underlying I/O resources fail
1:      * @throws SQLException if accessing underlying resources fail
1:      */
1:     private void makeWritableClobClone()
1:             throws IOException, SQLException {
1:         InternalClob toBeAbandoned = this.clob;
0:         this.clob = ClobStreamControl.cloneClobContent(
1:                         getEmbedConnection().getDBName(),
1:                         this, toBeAbandoned);
1:         toBeAbandoned.release();
1:     }
commit:394a70e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * Returns the number of characters
0:      * in the <code>CLOB</code> value
1:      * designated by this <code>Clob</code> object.
0:      * @return length of the <code>CLOB</code> in characters
1:      * @exception SQLException if there is an error accessing the
0:      * length of the <code>CLOB</code>
1:      */
/////////////////////////////////////////////////////////////////////////
1:         Object synchronization = getConnectionSynchronization();
0:             Reader clobReader = null;
1:             try {
0:                 clobReader = getCharacterStream();
/////////////////////////////////////////////////////////////////////////
0:                 clobReader.close();
0:                 clobReader = null;
0:                 return clobLength;
1:             }
0:             catch (Throwable t)
1:             {
0:                 throw noStateChangeLOB(t);
1:             }
0:             finally
1:             {
0:                 if (clobReader != null) {
1:                     try {
0:                         clobReader.close();
1:                     } catch (IOException ioe) {
1:                     }
1:                 }
1:                 restoreContextStack();
1:             }
1:         }
1:     }
1:     /**
0:      * Returns a copy of the specified substring
0:      * in the <code>CLOB</code> value
1:      * designated by this <code>Clob</code> object.
0:      * The substring begins at position
0:      * <code>pos</code> and has up to <code>length</code> consecutive
0:      * characters. The starting position must be between 1 and the length
0:      * of the CLOB plus 1. This allows for zero-length CLOB values, from
0:      * which only zero-length substrings can be returned.
1:      * If a larger length is requested than there are characters available,
1:      * characters from the start position to the end of the CLOB are returned.
1:      * @param pos the first character of the substring to be extracted.
0:      *            The first character is at position 1.
1:      * @param length the number of consecutive characters to be copied
0:      * @return a <code>String</code> that is the specified substring in
0:      *         the <code>CLOB</code> value designated by this <code>Clob</code> object
1:      * @exception SQLException if there is an error accessing the
0:      * <code>CLOB</code>
0:      * NOTE: If the starting position is the length of the CLOB plus 1,
0:      * zero characters are returned regardless of the length requested.
1:      */
/////////////////////////////////////////////////////////////////////////
0:         Object synchronization = getConnectionSynchronization();
0:             UTF8Reader clobReader = null;
1:             try {
0:                 clobReader = getCharacterStreamAtPos(pos, synchronization);
0:                 if (clobReader == null)
0:                     throw StandardException.newException(SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
0:                 StringBuffer sb = new StringBuffer(length);
0:                 int remainToRead = length;
0:                 while (remainToRead > 0) {
0:                     int read = clobReader.readInto(sb, remainToRead);
0:                     if (read == -1)
1:                         break;
0:                     remainToRead -= read;
1:                 }
0:                 clobReader.close();
0:                 clobReader = null;
0:                 return sb.toString();
1:             }
0:             catch (Throwable t)
1:             {
0:                 throw noStateChangeLOB(t);
1:             }
0:             finally
1:             {
0:                 if (clobReader != null)
0:                     clobReader.close();
0:                 restoreContextStack();
1:             }
1:         }
1:     /**
0:      * Gets the <code>Clob</code> contents as a Unicode stream.
0:      * @return a Unicode stream containing the <code>CLOB</code> data
1:      * @exception SQLException if there is an error accessing the
0:      * <code>CLOB</code>
1:      */
/////////////////////////////////////////////////////////////////////////
1:             try {
1:             }
0:             catch (Throwable t)
1:             {
0:                 throw noStateChangeLOB(t);
1:             }
0:             finally
1:             {
0:                 restoreContextStack();
1:             }
1:         }
1:     /**
1:      * Gets the <code>CLOB</code> value designated by this <code>Clob</code>
1:      * object as a stream of Ascii bytes.
0:      * @return an ascii stream containing the <code>CLOB</code> data
0:      * @exception SQLException if there is an error accessing the
1:      * <code>CLOB</code> value
1:      */
1:         return new ReaderToAscii(getCharacterStream());
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Determines the character position at which the specified substring
0:      * <code>searchStr</code> appears in the <code>CLOB</code> value.  The search
0:      * begins at position <code>start</code>. The method uses the following
0:      * algorithm for the search:
1:      * <p>
1:      * If the <code>CLOB</code> value is materialized as a string, use
1:      * <code>String.indexOf</code>.
1:      * <p>
0:      * If the <code>CLOB</code> value is represented as a stream, read a block of
0:      * chars from the start position and compare the chars with
1:      * <code>searchStr</code>. Then:
1:      * <ul> <li>If a matching char is found, increment <code>matchCount</code>.
1:      *      <li>If <code>matchCount</code> is equal to the length of
1:      *          <code>searchStr</code>, return with the current start position.
1:      *      <li>If no match is found, and there is more data, restart search
1:      *          (see below).
0:      *      <li>If all data is processed without a match, return <code>-1</code>.
1:      * </ul>
1:      * <p>
1:      * The position where the stream has a char equal to the first char of
1:      * <code>searchStr</code> will be remembered and used as the starting
1:      * position for the next search-iteration if the current match fails.
1:      * If a non-matching char is found, start a fresh search from the position
1:      * remembered. If there is no such position, next search will start at the
1:      * current position <code>+1</code>.
0:      *
1:      * @param searchStr the substring for which to search
1:      * @param start the position at which to begin searching; the first position
1:      *    is <code>1</code>
1:      * @return The position at which the substring appears, <code>-1</code> if
1:      *    it does not appear in the <code>CLOB</code> value. The first position
1:      *    is <code>1</code>.
0:      * @exception SQLException if there is an error accessing the
1:      *    <code>CLOB</code> value
1:      */
/////////////////////////////////////////////////////////////////////////
0:             throw noStateChangeLOB(t);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Determines the character position at which the specified
1:      * <code>Clob</code> object <code>searchstr</code> appears in this
1:      * <code>Clob</code> object.  The search begins at position
1:      * <code>start</code>.
1:      * @param searchClob the <code>Clob</code> object for which to search
1:      * @param start the position at which to begin searching; the first
1:      *              position is 1
1:      * @return the position at which the <code>Clob</code> object appears,
1:      * else -1; the first position is 1
0:      * @exception SQLException if there is an error accessing the
0:      * <code>CLOB</code> value
1:      */
/////////////////////////////////////////////////////////////////////////
1:                 char[] subPatternChar = new char[1024];
1:                 boolean seenOneCharacter = false;
0:                 //System.out.println("BEGIN CLOB SEARCH @ " + start);
1:                 for (;;) {
1:                     long firstPosition = -1;
1:                     Reader patternReader = searchClob.getCharacterStream();
0:                     //System.out.println("RESTART CLOB SEARCH @ " + start);
1:                     try {
1:                         for (;;) {
0:                             int read = patternReader.read(subPatternChar, 0, subPatternChar.length);
1:                             if (read == -1) {
1:                                 //empty pattern
0:                                 if (!seenOneCharacter)
0:                                     return start; // matches DB2 SQL LOCATE function
1:                                 return firstPosition;
1:                             }
1:                             if (read == 0) {
0:                                 //System.out.println("STUCK IN READ 0 HELL");
1:                                 continue;
1:                             }
1:                             seenOneCharacter = true;
0:                             String subPattern = new String(subPatternChar, 0, read);
0:                     //System.out.println("START CLOB SEARCH @ " + start + " -- " + subPattern);
1:                             long position = position(subPattern, start);
0:                     //System.out.println("DONE SUB CLOB SEARCH @ " + start + " -- " + position);
1:                             if (position == -1) {
1:                                 // never seen any match
1:                                 if (firstPosition == -1)
1:                                     return -1;
1:                                 start = firstPosition + 1;
1:                                 continue restartScan;
1:                             }
1:                             if (firstPosition == -1)
1:                                 firstPosition = position;
1:                             else if (position != start) {
0:                                 // must match at the first character of the segment
1:                                 start = firstPosition + 1;
1:                                 continue restartScan;
1:                             }
1:                             // read is the length of the subPattern string
1:                             start = position + read;
1:                     }
0:                     } finally {
0:                         patternReader.close();
1:                     }
1:                 }
0:             throw noStateChangeLOB(t);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:     */
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //    JDBC 3.0    -    New public methods
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1:     /**
1:      * JDBC 3.0
0:      *
0:      * Writes the given Java String to the CLOB value that this Clob object designates
0:      * at the position pos.
0:      *
0:      * @param pos - the position at which to start writing to the CLOB value that
0:      * this Clob object represents
1:      * @return the number of characters written
0:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public int setString(long pos, String str) throws SQLException {
1:     }
1:     /**
1:      * JDBC 3.0
0:      *
0:      * Writes len characters of str, starting at character offset, to the CLOB value
0:      * that this Clob represents.
0:      *
0:      * @param pos - the position at which to start writing to this Clob object
0:      * @param str - the string to be written to the CLOB value that this Clob designates
0:      * @param offset - the offset into str to start reading the characters to be written
0:      * @param len - the number of characters to be written
1:      * @return the number of characters written
0:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public int setString(long pos, String str, int offset, int len)
0:     throws SQLException {
1:         try {
0:             if (!materialized) {
0:                 control.copyData(myStream, length());
0:                 materialized = true;
0:             long charPos = control.getStreamPosition(0, pos - 1);
0:             if (charPos == -1)
1:                 throw Util.generateCsSQLException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, "" + pos);
0:             return (int) control.insertString(str.substring (offset,
0:                     (offset + len)), charPos);
1:         } catch (IOException e) {
1:             throw Util.setStreamFailure(e);
0:         catch (StandardException se) {
0:             throw Util.generateCsSQLException (se);
1:         }
1:     }
1:     /**
1:      * JDBC 3.0
0:      *
1:      * Retrieves a stream to be used to write Ascii characters to the CLOB
1:      * value that this Clob object represents, starting at position pos.
0:      *
0:      * @param pos - the position at which to start writing to this Clob object
1:      * @return the stream to which ASCII encoded characters can be written
0:      * @exception SQLException Feature not implemented for now.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * JDBC 3.0
0:      *
0:      * Retrieves a stream to be used to write a stream of Unicode characters to the
0:      * CLOB value that this Clob object represents, starting at position pos.
0:      *
0:      * @param pos - the position at which to start writing to this Clob object
1:      * @return the stream to which Unicode encoded characters can be written
0:      * @exception SQLException Feature not implemented for now.
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * JDBC 3.0
0:      *
0:      * Truncates the CLOB value that this Clob designates to have a length of len characters
0:      *
0:      * @param len - the length, in bytes, to which the CLOB value that this Blob
0:      * value should be truncated
0:      * @exception SQLException Feature not implemented for now.
1:      */
1:     public void truncate(long len) throws SQLException
1:     {
0:         throw Util.notImplemented();
1:     }
1:     //    JDBC 4.0    -    New public methods
/////////////////////////////////////////////////////////////////////////
1:     /*
0:     **
1:     */
0:     static SQLException noStateChangeLOB(Throwable t) {
/////////////////////////////////////////////////////////////////////////
0:         return org.apache.derby.impl.jdbc.EmbedResultSet.noStateChangeException(t);
1:     }
1:     /*
0:      * Checks is isValid is true. If it is not true throws
0:      * a SQLException stating that a method has been called on
0:      * an invalid LOB object
0:      *
0:      * throws SQLException if isValid is not true.
1:      */
0:     private void checkValidity() throws SQLException{
0:         if(!isValid)
0:             throw newSQLException(SQLState.LOB_OBJECT_INVALID);
1:         localConn.checkIfClosed();
1:     }
commit:fe1130b
/////////////////////////////////////////////////////////////////////////
0:                     if (size == 0L)
/////////////////////////////////////////////////////////////////////////
0:             if (skipBy == 0L)
commit:47510ba
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:      *
0:      * @param clobString A String object containing the data to be stores in the
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:    * which only zero-length substrings can be returned.
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:             clobReader = new UTF8Reader (control.getInputStream (0), 0,
0:                                             control.getByteLength(),
1: 
1: 
1: 
/////////////////////////////////////////////////////////////////////////
0:    * <code>searchStr</code> will be remembered and used as the starting
0:    *
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                         continue;
1:                     for (int clobOffset = 0;
0:                         if (tmpClob [clobOffset]
1:                             //find the new starting position in
1:                             if (matchCount != 0 && newStart == -1
0:                                     && tmpClob [clobOffset]
0:                                 //return after converting the position
1:                                 return pos + clobOffset
/////////////////////////////////////////////////////////////////////////
1:                                     matchCount = 0;
0:                                     reader = getCharacterStreamAtPos
1:                                 }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
0:     * @return the number of characters written
/////////////////////////////////////////////////////////////////////////
0:     * @param len - the number of characters to be written
/////////////////////////////////////////////////////////////////////////
0:     * @return the stream to which ASCII encoded characters can be written
/////////////////////////////////////////////////////////////////////////
0:     * @return the stream to which Unicode encoded characters can be written
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1:             }
/////////////////////////////////////////////////////////////////////////
1: 
0:          * Checks is isValid is true. If it is not true throws
commit:e5b15ce
/////////////////////////////////////////////////////////////////////////
1:     in store as an OverflowInputStream. The Resetable interface allows sending
1:     <p>
/////////////////////////////////////////////////////////////////////////
1:      * This constructor should only be called by {@link EmbedResultSet#getClob}.
0:      *
commit:e1fc783
/////////////////////////////////////////////////////////////////////////
0:     private boolean         materialized;
0:     private ClobStreamControl control;
/////////////////////////////////////////////////////////////////////////
0:      * @throws SQLException
0:     EmbedClob(String clobString,EmbedConnection con) throws SQLException {
0:         materialized = true;
0:         control = new ClobStreamControl (con.getDBName(), this);
1:         try {
0:             control.insertString (clobString, 0);
1:         }
1:        
0:         catch (IOException e) {
0:             throw Util.setStreamFailure (e);
1:         }
1:     /**
0:      * This constructor should only be called by EmbedResultSet.getClob
0:      * @param dvd 
0:      * @param con 
1:      * @throws StandardException
1:      */
/////////////////////////////////////////////////////////////////////////
0:             control = new ClobStreamControl (con.getDBName(), this);
0:             materialized = true;
0:             try {
0:                 String str = dvd.getString();
0:                 control.insertString (dvd.getString(), 0);
1:             }
0:             catch (SQLException sqle) {
0:                 throw StandardException.newException (sqle.getSQLState(), sqle);
1:             }
0:             catch (IOException e) {
0:                 throw StandardException.newException (
0:                                         SQLState.SET_STREAM_FAILURE, e);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         try {
0:             if (materialized)
0:                 return control.getCharLength ();
1:         }
0:         catch (IOException e) {
0:             throw Util.setStreamFailure (e);
1:         }
/////////////////////////////////////////////////////////////////////////
0:         if (materialized)
0:             try {
0:                 long sLength = control.getCharLength ();
0:                 if (sLength + 1 < pos)
1:                     throw Util.generateCsSQLException(
0:                         SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
0:                 int endIndex = ((int) pos) + length - 1;
0:                 // cannot go over length of string
0:                     return control.getSubstring (pos - 1,
0:                             (sLength > endIndex ? endIndex : sLength));
1:             }
0:             catch (IOException e) {
0:                 throw Util.setStreamFailure (e);
1:             }
/////////////////////////////////////////////////////////////////////////
0:         Object synchronization = getConnectionSynchronization();
0:                             if (materialized) {
0:                                 return control.getReader (0);
1:                             }
1:                             
0:                             return getCharacterStreamAtPos(1, synchronization);
/////////////////////////////////////////////////////////////////////////
0:     private UTF8Reader getCharacterStreamAtPos(long position, Object synchronization)
0:     throws IOException, StandardException {
0:         UTF8Reader clobReader = null;
0:         if (materialized)
0:             clobReader = new UTF8Reader (control.getInputStream (0), 0, 
0:                                             control.getByteLength(), 
0:                                     this, control);
1:         else {
0:             ((Resetable)myStream).resetStream();
0:             clobReader = new UTF8Reader(myStream, 0, this, synchronization);
1:         }
1:         
0:         // skip to the correct position (pos is one based)
0:         long remainToSkip = position - 1;
0:         while (remainToSkip > 0) {
0:             long skipBy = clobReader.skip(remainToSkip);
0:             if (skipBy == -1)
0:                 return null;
1:             
0:             remainToSkip -= skipBy;
1:         }
1:         
0:         return clobReader;
1:     }
/////////////////////////////////////////////////////////////////////////
0:             Object synchronization = getConnectionSynchronization();
1:             synchronized (synchronization)
0:                 pushStack = !getEmbedConnection().isClosed();
1:                 if (pushStack)
1:                     setupContextStack();
1:                 int matchCount = 0;
0:                 long pos = start - 1;
1:                 long newStart = -1;
0:                 Reader reader = getCharacterStreamAtPos (start, this);
1:                 char [] tmpClob = new char [4096];
1:                 boolean reset;
1:                 for (;;) {
1:                     reset = false;
1:                     int readCount = reader.read (tmpClob);
0:                     if (readCount == -1)
1:                         return -1;
0:                     if (readCount == 0)
1:                         continue;            
0:                     for (int clobOffset = 0; 
1:                                 clobOffset < readCount; clobOffset++) {
0:                         if (tmpClob [clobOffset] 
0:                                         == searchStr.charAt (matchCount)) {
0:                             //find the new starting position in 
1:                             // case this match is unsuccessful
0:                             if (matchCount != 0 && newStart == -1 
0:                                     && tmpClob [clobOffset] 
0:                                     == searchStr.charAt (0)) {
1:                                 newStart = pos + clobOffset + 1;
1:                             matchCount ++;
1:                             if (matchCount == searchStr.length()) {
0:                                 //return after converting the position 
0:                                 //to 1 based index
0:                                 return pos + clobOffset 
0:                                         - searchStr.length() + 1 + 1;
1:                             }
1:                         }
0:                         else {
1:                             if (matchCount > 0) {
1:                                 if (newStart == -1) {
1:                                     if (matchCount > 1) {
1:                                         //compensate for increment in the "for"
1:                                         clobOffset--;
1:                                     matchCount = 0;                                    
1:                                 matchCount = 0;
1:                                 if (newStart < pos) {
1:                                     pos = newStart;
1:                                     reader.close();
0:                                     reader = getCharacterStreamAtPos 
0:                                                 (newStart + 1, this);
1:                                     newStart = -1;
1:                                     reset = true;
0:                                     break;
1:                                 }                        
1:                                 clobOffset = (int) (newStart - pos) - 1;
1:                                 newStart = -1;
1:                                 continue;
1:                     if (!reset) {
1:                         pos += readCount;
1:                     }
1: 
/////////////////////////////////////////////////////////////////////////
0: 				char[] subPatternChar = new char[1024];
/////////////////////////////////////////////////////////////////////////
0:         if (!materialized)
/////////////////////////////////////////////////////////////////////////
0: 	public int setString(long pos, String str) throws SQLException {
1:             return setString (pos, str, 0, str.length());
1:    /**
/////////////////////////////////////////////////////////////////////////
0:         public int setString(long pos, String str, int offset, int len)
0:         throws SQLException {
0:             try {
0:                 if (!materialized) {
0:                     control.copyData(myStream, length());
0:                     materialized = true;
1:                 }
0:                 long charPos = control.getStreamPosition(0, pos - 1);
0:                 if (charPos == -1)
1:                     throw Util.generateCsSQLException(
0:                             SQLState.BLOB_POSITION_TOO_LARGE, "" + pos);
0:                 return (int) control.insertString(str.substring (offset,
0:                         (offset + len)), charPos);
1:             } catch (IOException e) {
1:                 throw Util.setStreamFailure(e);
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:     public java.io.OutputStream setAsciiStream(long pos) throws SQLException {
0:         try {
0:             return new ClobAsciiStream (control.getWriter(pos - 1));
0:         } catch (IOException e) {
1:             throw Util.setStreamFailure(e);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     public java.io.Writer setCharacterStream(long pos) throws SQLException {
0:         try {
0:             if (!materialized) {
0:                 control.copyData(myStream, length());
0:                 materialized = true;
1:             }
0:             return control.getWriter(pos - 1);
0:         } catch (IOException e) {
0:             throw Util.setStreamFailure(e);
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
0: 	public void truncate(long len) throws SQLException
/////////////////////////////////////////////////////////////////////////
0:         if (!materialized) {
0:         }
0:         else {
0:             try {
0:                 control.free();
0:             }    
0:             catch (IOException e) {
0:                 throw Util.setStreamFailure(e);
0:             }
0:         }
/////////////////////////////////////////////////////////////////////////
0:             localConn.checkIfClosed();
commit:dbcd4c1
/////////////////////////////////////////////////////////////////////////
0:    * <code>searchStr</code> appears in the <code>CLOB</code> value.  The search
0:    * algorithm for the search:
0:    * <p>
0:    * If the <code>CLOB</code> value is materialized as a string, use
0:    * <code>String.indexOf</code>.
0:    * <p>
0:    * If the <code>CLOB</code> value is represented as a stream, read a block of
0:    * chars from the start position and compare the chars with
0:    * <code>searchStr</code>. Then:
0:    * <ul> <li>If a matching char is found, increment <code>matchCount</code>.
0:    *      <li>If <code>matchCount</code> is equal to the length of
0:    *          <code>searchStr</code>, return with the current start position.
0:    *      <li>If no match is found, and there is more data, restart search
0:    *          (see below).
0:    *      <li>If all data is processed without a match, return <code>-1</code>.
0:    * </ul>
0:    * <p>
0:    * The position where the stream has a char equal to the first char of
0:    * <code>searchStr</code> will be remembered and used as the starting 
0:    * position for the next search-iteration if the current match fails.
0:    * If a non-matching char is found, start a fresh search from the position
0:    * remembered. If there is no such position, next search will start at the
0:    * current position <code>+1</code>.
0:    *    is <code>1</code>
0:    * @return The position at which the substring appears, <code>-1</code> if
0:    *    it does not appear in the <code>CLOB</code> value. The first position
0:    *    is <code>1</code>.
0:    *    <code>CLOB</code> value
commit:edf1a95
/////////////////////////////////////////////////////////////////////////
0:    * begins at position <code>start</code>. The method uses the following
0:    * algorithm for the search
0:    * If the clob is materialized in string use String.indexOf
0:    * else
0:    * Read a block of 256 chars from start position
0:    * compare the chars with the searchString
0:    * If a match is found
0:    * increment the matchCount
0:    * if the matchCount is equal to lenght of searchString return 
0:    * Remember the position where the stream has a char equal to the first char
0:    * of the searchString. This position we will use to start next try for match
0:    * if the current match fails.
0:    * if a mismatch is found 
0:    * start fresh match from the position remembered if there is no postion 
0:    * found for next match start with current position + 1
0:    * 
/////////////////////////////////////////////////////////////////////////
0:                 Object synchronization = getConnectionSynchronization();
0:                     int matchCount = 0;
0:                     long pos = start - 1;
0:                     long newStart = -1;
0:                     Reader reader = getCharacterStreamAtPos (start, this);
0:                     char [] tmpClob = new char [256];
0:                     boolean reset;
0:                     for (;;) {
0:                         reset = false;
0:                         int readCount = reader.read (tmpClob);
0:                         if (readCount == -1)
0:                             return -1;
0:                         if (readCount == 0)
0:                             continue;            
0:                         for (int clobOffset = 0; 
0:                                     clobOffset < readCount; clobOffset++) {
0:                             if (tmpClob [clobOffset] 
0:                                             == searchStr.charAt (matchCount)) {
0:                                 //find the new starting position in 
0:                                 // case this match is unsuccessful
0:                                 if (matchCount != 0 && newStart == -1 
0:                                         && tmpClob [clobOffset] 
0:                                         == searchStr.charAt (0)) {
0:                                     newStart = pos + clobOffset + 1;
0:                                 }
0:                                 matchCount ++;
0:                                 if (matchCount == searchStr.length()) {
0:                                     //return after converting the position 
0:                                     //to 1 based index
0:                                     return pos + clobOffset 
0:                                             - searchStr.length() + 1 + 1;
0:                                 }
0:                             }
0:                             else {
0:                                 if (matchCount > 0) {
0:                                     matchCount = 0;
0:                                     if (newStart == -1) {
0:                                         continue;
0:                                     }
0:                                     if (newStart < pos) {
0:                                         pos = newStart;
0:                                         reader.close();
0:                                         reader = getCharacterStreamAtPos 
0:                                                     (newStart + 1, this);
0:                                         newStart = -1;
0:                                         reset = true;
0:                                         break;
0:                                     }                        
0:                                     clobOffset = (int) (newStart - pos) - 1;
0:                                     newStart = -1;
0:                                     continue;
0:                                 }
0:                             }
0:                         }
0:                         if (!reset) {
0:                             pos += readCount;
0:                         }
0:                     }
0:                 }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1e5b2aa
/////////////////////////////////////////////////////////////////////////
1:         if (pos < 1) {
0:         }
1:         
1:         if (pos > length() + 1) {
1:             throw Util.generateCsSQLException(
1:         	    SQLState.BLOB_POSITION_TOO_LARGE);
0:         }
1:         
1:         if (str == null) {
1:             throw Util.generateCsSQLException(
1:         	    SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
0:         }
1:         
1:         if (str.length() == 0) {
1:             return 0;
0:         }
1:         
1:         if (offset < 0 || offset >= str.length()) {
1:             throw Util.generateCsSQLException(SQLState.BLOB_INVALID_OFFSET);
0:         }
1:         
1:         if (len < 0) {
1:             throw Util.generateCsSQLException(
1:         	    SQLState.BLOB_NONPOSITIVE_LENGTH);
0:         }
1:         
1:         if (len + offset > str.length()) {
1:             throw Util.generateCsSQLException(
1:                     SQLState.LANG_SUBSTR_START_ADDING_LEN_OUT_OF_RANGE,
0:                     new Integer(offset), new Integer(len), str);
0:         }
1:         
commit:10e4538
/////////////////////////////////////////////////////////////////////////
1:         this.clob = new TemporaryClob (this);
/////////////////////////////////////////////////////////////////////////
0:                 clob = new TemporaryClob(dvd.getString(),
0:                         this);
commit:456b8a1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.jdbc.EngineClob;
/////////////////////////////////////////////////////////////////////////
0: final class EmbedClob extends ConnectionChild implements Clob, EngineClob
/////////////////////////////////////////////////////////////////////////
0:     private final int locator;
1:     
/////////////////////////////////////////////////////////////////////////
0:         this.locator = con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
0:         this.locator = con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
1: 
0:     /**     
1:      * @return locator value for this Clob.
1:      */
1:     public int getLocator() {
1:         return locator;
0:     }
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:d96e398
/////////////////////////////////////////////////////////////////////////
1:     private int locator;
/////////////////////////////////////////////////////////////////////////
1:         con.addLOBReference (this);
/////////////////////////////////////////////////////////////////////////
1:         con.addLOBReference (this);
/////////////////////////////////////////////////////////////////////////
1:                 localConn.removeLOBMapping(locator);
/////////////////////////////////////////////////////////////////////////
1:         if (locator == 0) {
1:             locator = localConn.addLOBMapping(this);
0:         }
commit:f697326
/////////////////////////////////////////////////////////////////////////
0:                 this.clob = new StoreStreamClob(storeStream, this);
/////////////////////////////////////////////////////////////////////////
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:cd727e7
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Returns a <code>Reader</code> object that contains a partial
1:      * <code>Clob</code> value, starting with the character specified by pos,
1:      * which is length characters in length.
0:      *
1:      * @param pos the offset to the first character of the partial value to
1:      * be retrieved.  The first character in the Clob is at position 1.
1:      * @param length the length in characters of the partial value to be
1:      * retrieved.
1:      * @return <code>Reader</code> through which the partial <code>Clob</code>
1:      * value can be read.
1:      * @throws SQLException if pos is less than 1 or if pos is greater than the
1:      * number of
0:      * characters in the <code>Clob</code> or if pos + length is greater than
0:      * the number of
0:      * characters in the <code>Clob</code>
0:      *
0:      * @throws SQLException.
0:      */
0:         //call checkValidity to exit by throwing a SQLException if
0:         //the Clob object has been freed by calling free() on it
0:         checkValidity();
1:         
1:         if (pos <= 0) {
1:             throw Util.generateCsSQLException(
1:                     SQLState.BLOB_BAD_POSITION,
0:                     new Long(pos));
0:         }
1:         if (length < 0) {
1:             throw Util.generateCsSQLException(
1:                     SQLState.BLOB_NONPOSITIVE_LENGTH,
0:                     new Long(length));
0:         }
0:         if (length > (this.length() - pos)) {
1:             throw Util.generateCsSQLException(
1:                     SQLState.POS_AND_LENGTH_GREATER_THAN_LOB,
0:                     new Long(pos), new Long(length));
0:         }
1:         
0:         try {
0:             return new ClobUpdateableReader(this,
0:                                             pos-1,
0:                                             length);
0:         } catch (IOException ioe) {
1:             throw Util.setStreamFailure(ioe);
0:         } 
commit:7696c74
/////////////////////////////////////////////////////////////////////////
0:         con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
0:         con.addLOBMapping (this);
/////////////////////////////////////////////////////////////////////////
0:         localConn.checkIfClosed();        
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f433a64
/////////////////////////////////////////////////////////////////////////
0:    * characters. The starting position must be between 1 and the length
0:    * of the CLOB plus 1. This allows for zero-length CLOB values, from
0:    * which only zero-length substrings can be returned. 
0:    * If a larger length is requested than there are characters available,
0:    * characters from the start position to the end of the CLOB are returned.
/////////////////////////////////////////////////////////////////////////
0:    * NOTE: If the starting position is the length of the CLOB plus 1,
0:    * zero characters are returned regardless of the length requested.
/////////////////////////////////////////////////////////////////////////
1:         if (length < 0)
/////////////////////////////////////////////////////////////////////////
0:             if (sLength + 1 < pos)
0:             // cannot go over length of string
commit:e6936ea
/////////////////////////////////////////////////////////////////////////
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
/////////////////////////////////////////////////////////////////////////
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN_OR_SEARCH_STR);
commit:6b50965
/////////////////////////////////////////////////////////////////////////
0:    * @param searchStr the substring for which to search
/////////////////////////////////////////////////////////////////////////
0:    * @param searchClob the <code>Clob</code> object for which to search
/////////////////////////////////////////////////////////////////////////
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:da10c02
/////////////////////////////////////////////////////////////////////////
0: 				if (clobReader != null)
0: 					clobReader.close();
commit:ce0c6c4
/////////////////////////////////////////////////////////////////////////
0: 			    if (clobReader != null){
1: 				
0: 				try{
0: 				    clobReader.close();
1: 				    
0: 				}catch(IOException e){
0: 				    e.printStackTrace();
0: 				    throw new SQLException(e.getMessage());
1: 				    
0: 				}
0: 			    }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:b44abbf
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 ((Resetable) myStream).initStream();
0:             } catch (StandardException se) {
1:                 if (se.getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED)) {
1:                     throw StandardException
1:                             .newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
0:                 }
0:             }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4153b27
/////////////////////////////////////////////////////////////////////////
0: /**
/////////////////////////////////////////////////////////////////////////
1:   <P><B>Supports</B>
1:    <UL>
1:    <LI> JSR169 - no subsetting for java.sql.Clob
1:    <LI> JDBC 2.0
1:    <LI> JDBC 3.0 - no new dependencies on new JDBC 3.0 or JDK 1.4 classes,
1:         new update methods can safely be added into implementation.
1:    </UL>
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.jdbc.EmbedClob
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
0:  */
1: 
1: 
1: package org.apache.derby.impl.jdbc;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.Resetable;
0: import org.apache.derby.impl.jdbc.ConnectionChild;
0: import org.apache.derby.impl.jdbc.EmbedConnection;
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.UTF8Reader;
0: import org.apache.derby.impl.jdbc.ReaderToAscii;
1: 
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
0: import java.io.StringReader;
1: import java.io.Reader;
1: import java.io.IOException;
1: import java.io.EOFException;
1: import java.sql.SQLException;
1: import java.sql.Clob;
1: 
0: /*
1:     Implements java.sql.Clob (see the JDBC 2.0 spec).
1:     A clob sits on top of a CHAR, VARCHAR or LONG VARCHAR column.
1:     If its data is small (less than 1 page) it is a byte array taken from
1:     the SQLChar class. If it is large (more than 1 page) it is a long column
1:     in the database. The long column is accessed as a stream, and is implemented
0:     in store as an OverflowInputStream.  The Resetable interface allows sending
1:     messages to that stream to initialize itself (reopen its container and
1:     lock the corresponding row) and to reset itself to the beginning.
1: 
1:     NOTE: In the case that the data is large, it is represented as a stream.
1:     This stream can be returned to the user in the getAsciiStream() method.
1:     This means that we have limited control over the state of the stream,
1:     since the user can read bytes from it at any time.  Thus all methods
1:     here reset the stream to the beginning before doing any work.
1:     CAVEAT: The methods may not behave correctly if a user sets up
1:     multiple threads and sucks data from the stream (returned from
1:     getAsciiStream()) at the same time as calling the Clob methods.
1: 
0:  */
0: final class EmbedClob extends ConnectionChild implements Clob
1: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0:     // clob is either a string or stream
0:     private boolean         isString;
0:     private InputStream     myStream;
0:     private String          myString;
1: 
0:     /*
0:     This constructor should only be called by EmbedResultSet.getClob
0:     */
0:     protected EmbedClob(DataValueDescriptor dvd, EmbedConnection con)
0:         throws StandardException
1:     {
1:         super(con);
1:         // if the underlying column is null, ResultSet.getClob will return null,
1:         // never should get this far
1:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(!dvd.isNull(), "clob is created on top of a null column");
1: 
0:         myStream = dvd.getStream();
0:         if (myStream == null)
1:         {
0:             isString = true;
0:            myString = dvd.getString();
1:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(myString != null,"clob has a null value underneath");
0:         }
0:         else
1:         {
0:             /*
1:              We are expecting this stream to be a FormatIdInputStream with an
1:              OverflowInputStream inside. FormatIdInputStream implements
1:              Resetable, as does OverflowInputStream. This should be the case
1:              when retrieving data from a long column. However, SQLChar, which is
1:              the class implementing the getStream() method for dvd.getStream(),
1:              does not guarantee this for us. In particular, the logging system
1:              (see StoredPage.logColumn) calls setStream with an argument that
1:              is sometimes a RememberBytesInputStream on a SQLChar object
1:              (e.g. see test repStreaming.sql). However, such a SQLChar
1:              object is going to the log buffer, NOT back to the user, so it
1:              should not break the ASSERT below.
0:              */
1:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(myStream instanceof Resetable);
1: 
0:             ((Resetable)myStream).initStream();
1: 
0:         }
0:     }
1: 
1: 
0:   /**
0:    * Returns the number of characters
0:    * in the <code>CLOB</code> value
0:    * designated by this <code>Clob</code> object.
0:    * @return length of the <code>CLOB</code> in characters
0:    * @exception SQLException if there is an error accessing the
0:    * length of the <code>CLOB</code>
0:    */
1: 
1:     public long length() throws SQLException
1:     {
0:         // if we have a string, not a stream
0:         if (isString)
0:             return myString.length();
1: 
1: 
0: 		Object synchronization = getConnectionSynchronization();
0:         synchronized (synchronization)
1:         {
0: 			Reader clobReader = null;
0:             setupContextStack();
0: 			try {
1: 
0: 				clobReader = getCharacterStream();
0:                 long clobLength = 0;
0:                 for (;;)
1:                 {
0:                     long size = clobReader.skip(32 * 1024);
0:                     if (size == -1)
0:                         break;
0:                     clobLength += size;
0:                 }
0: 				clobReader.close();
0: 				clobReader = null;
1: 
0: 				return clobLength;
0: 			}
0: 			catch (Throwable t)
1: 			{
0: 				throw noStateChangeLOB(t);
0: 			}
0: 			finally
1: 			{
0: 				if (clobReader != null) {
0: 					try {
0: 						clobReader.close();
0: 					} catch (IOException ioe) {
0: 					}
0: 				}
0: 				restoreContextStack();
0: 			}
0: 		}
0: 	}
1: 
0:   /**
0:    * Returns a copy of the specified substring
0:    * in the <code>CLOB</code> value
0:    * designated by this <code>Clob</code> object.
0:    * The substring begins at position
0:    * <code>pos</code> and has up to <code>length</code> consecutive
0:    * characters.
0:    * @param pos the first character of the substring to be extracted.
0:    *            The first character is at position 1.
0:    * @param length the number of consecutive characters to be copied
0:    * @return a <code>String</code> that is the specified substring in
0:    *         the <code>CLOB</code> value designated by this <code>Clob</code> object
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code>
1: 
0:    NOTE: return the empty string if pos is too large
0:    */
1: 
1:     public String getSubString(long pos, int length) throws SQLException
1:     {
0:         if (pos < 1)
0:             throw Util.generateCsSQLException(
0:                 SQLState.BLOB_BAD_POSITION, new Long(pos));
0:         if (length <= 0)
0:             throw Util.generateCsSQLException(
0:                 SQLState.BLOB_NONPOSITIVE_LENGTH, new Integer(length));
1: 
0:         // if we have a string, not a stream
0:         if (isString)
1:         {
0:             int sLength = myString.length();
0:             if (sLength < pos)
0:                 throw Util.generateCsSQLException(
0:                     SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
0:             int endIndex = ((int) pos) + length - 1;
0:             // cannot go over length of string, or we get an exception
0:             return myString.substring(((int) pos) - 1, (sLength > endIndex ? endIndex : sLength));
0:         }
1: 
0: 		Object synchronization = getConnectionSynchronization();
0:         synchronized (synchronization)
1:         {
0:             setupContextStack();
1: 
0: 			UTF8Reader clobReader = null;
0: 			try {
1: 
0: 				clobReader = getCharacterStreamAtPos(pos, synchronization);
0: 				if (clobReader == null)
0: 					throw StandardException.newException(SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
1: 
0: 				StringBuffer sb = new StringBuffer(length);
0: 				int remainToRead = length;
0: 				while (remainToRead > 0) {
1: 
0: 					int read = clobReader.readInto(sb, remainToRead);
0: 					if (read == -1)
0: 						break;
1: 
0: 					remainToRead -= read;
0: 				}
0: 				clobReader.close();
0: 				clobReader = null;
1: 
0: 				return sb.toString();
0: 			}
0: 			catch (Throwable t)
1: 			{
0: 				throw noStateChangeLOB(t);
0: 			}
0: 			finally
1: 			{
0: 				if (clobReader != null)
0: 					clobReader.close();
0: 				restoreContextStack();
0: 			}
0: 		}
0:     }
1: 
1: 
0:   /**
0:    * Gets the <code>Clob</code> contents as a Unicode stream.
0:    * @return a Unicode stream containing the <code>CLOB</code> data
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code>
0:    */
1: 
1:     public java.io.Reader getCharacterStream() throws SQLException
1:     {
1: 
0:         // if we have a string, not a stream
0:         if (isString)
1:         {
0:             return new StringReader(myString);
0:         }
1: 
1: 
0: 		Object synchronization = getConnectionSynchronization();
0:         synchronized (synchronization)
1:         {
0:             setupContextStack();
1: 
0: 			try {
0: 				return getCharacterStreamAtPos(1, synchronization);
0: 			}
0: 			catch (Throwable t)
1: 			{
0: 				throw noStateChangeLOB(t);
0: 			}
0: 			finally
1: 			{
0: 				restoreContextStack();
0: 			}
0: 		}
0:     }
1: 
1: 
0:   /**
0:    * Gets the <code>CLOB</code> value designated by this <code>Clob</code>
0:    * object as a stream of Ascii bytes.
0:    * @return an ascii stream containing the <code>CLOB</code> data
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code> value
0:    */
1: 
1:     public java.io.InputStream getAsciiStream() throws SQLException
1:     {
0: 		return new ReaderToAscii(getCharacterStream());
0:     }
1: 
0: 	private UTF8Reader getCharacterStreamAtPos(long position, Object synchronization)
0: 		throws IOException, StandardException
1: 	{
0:         ((Resetable)myStream).resetStream();
0: 		UTF8Reader clobReader = new UTF8Reader(myStream, 0, this, synchronization);
1: 
0: 		// skip to the correct position (pos is one based)
0: 		long remainToSkip = position - 1;
0: 		while (remainToSkip > 0) {
0: 			long skipBy = clobReader.skip(remainToSkip);
0: 			if (skipBy == -1)
0: 				return null;
1: 
0: 			remainToSkip -= skipBy;
0: 		}
1: 
0: 		return clobReader;
0: 	}
1: 
1: 
0:   /**
0:    * Determines the character position at which the specified substring
0:    * <code>searchstr</code> appears in the <code>CLOB</code>.  The search
0:    * begins at position <code>start</code>.
0:    * @param searchstr the substring for which to search
0:    * @param start the position at which to begin searching; the first position
0:    *              is 1
0:    * @return the position at which the substring appears, else -1; the first
0:    *         position is 1
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code> value
0:    */
1:     public long position(String searchStr, long start)
1:         throws SQLException
1:     {
1:         boolean pushStack = false;
1:         try
1:         {
0:             if (start < 1)
0:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(start));
0:             if (searchStr == null)
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN);
0:             if (searchStr == "")
0:                 return start; // match DB2's SQL LOCATE function
1: 
0:             // if we have a string, not a stream
0:             if (isString)
1:             {
0: 				// avoid truncation errors in the cast of start to an int.
0: 				if (start > myString.length())
0: 					return -1;
1: 
0:                 int result = myString.indexOf(searchStr, (int) start-1);
0:                 return result < 0 ? -1 : result + 1;
0:             }
0:             else // we have a stream
1:             {
0: 				Object synchronization = getConnectionSynchronization();
0:                 synchronized (synchronization)
1:                 {
0:                     pushStack = !getEmbedConnection().isClosed();
0:                     if (pushStack)
0:                         setupContextStack();
1: 
0: 					char[] tmpClob = new char[256];
0: 					int patternLength = searchStr.length();
1: 
0: restartPattern:
0: 					for (;;) {
1: 
0: 					//System.out.println("RESET " + start);
0: 						UTF8Reader clobReader = getCharacterStreamAtPos(start, synchronization);
0: 						if (clobReader == null)
0: 							return -1;
1: 
1: 
1: 
0: 						// start of any match of the complete pattern.
1: 
0: 						int patternIndex = 0;
0: 						char[] tmpPattern = null;
0: 						boolean needPattern = true;
1: 
0: 						// how many characters of the patter segment we have matched
0: 						int matchCount = 0;
1: 
0: 						long currentPosition = start;
0: 						int clobOffset = -1;
0: 						int read = -1;
1: 
0: 						// absolute position of a possible match
0: 						long matchPosition = -1;
1: 
1: 
0: 						// absolute position of the next possible match
0: 						long nextBestMatchPosition = -1;
0: 						//System.out.println("restartPattern: " + start);
1: 
1: 
0: search:
0: 						for (;;)
1: 						{
0: 							//System.out.println("search: " + needPattern + " -- " + clobOffset);
0: 							if (needPattern) {
1: 
0: 								String tmpPatternS;
0: 								if ((patternLength - patternIndex) > 256)
0: 									tmpPatternS = searchStr.substring(patternIndex, 256);
0: 								else
0: 									tmpPatternS = searchStr;
1: 
0: 								tmpPattern = tmpPatternS.toCharArray();
0: 								needPattern = false;
0: 								matchCount = 0;
1: 
0: 							}
1: 
0: 							if (clobOffset == -1) {
1: 								
0: 								read = clobReader.read(tmpClob, 0, tmpClob.length);
0: 							//System.out.println("MORE DATA " + read);
0: 								if (read == -1)
0: 									return -1;
1: 
0: 								if (read == 0)
0: 									continue search;
1: 
0: 								clobOffset = 0;
0: 							}
1: 
1: 
0: 							// find matches within our two temp arrays.
0: compareArrays:
0: 							for (; clobOffset < read; clobOffset++) {
1: 
0: 								//System.out.println("compareArrays " + clobOffset);
1: 
0: 								char clobC = tmpClob[clobOffset];
1: 
1: 
0: 								if (clobC == tmpPattern[matchCount])
1: 								{
0: 									if (matchPosition == -1) {
0: 										matchPosition = currentPosition + clobOffset;
0: 									}
1: 
0: 									matchCount++;
1: 
0: 									// have we matched the entire pattern segment
0: 									if (matchCount == tmpPattern.length)
1: 									{
0: 										// move onto the next segment.
0: 										patternIndex += tmpPattern.length;
0: 										if (patternIndex == patternLength) {
0: 											// complete match !!
0: 											clobReader.close();
0: 											//System.out.println("COMPLETE@" + matchPosition);
0: 											return matchPosition;
0: 										}
1: 
0: 										needPattern = true;
0: 										continue search;
1: 
0: 									}
1: 
0: 									if (clobC == tmpPattern[0]) {
1: 
0: 										// save the next best start position.
1: 
0: 										// must be the first character of the actual pattern
0: 										if (patternIndex == 0) {
1: 
0: 											// must not be just a repeat of the match of the first character
0: 											if (matchCount != 1) {
1: 
0: 												// must not have a previous next best.
1: 
0: 												if (nextBestMatchPosition == -1) {
0: 													nextBestMatchPosition = currentPosition + clobOffset;
0: 												}
1: 
0: 											}
1: 
0: 										}
0: 									}
1: 
0: 									continue compareArrays;
0: 								}
0: 								else
1: 								{
0: 									// not a match
0: 									//
0: 									// 
0: 									if (matchPosition != -1) {
0: 										// failed after we matched some amount of the pattern
0: 										matchPosition = -1;
1: 
0: 										// See if we found a next best match
0: 										if (nextBestMatchPosition == -1)
1: 										{
0: 											// NO - just continue on, re-starting at this character
1: 
0: 											if (patternIndex != 0) {
0: 												needPattern = true;
0: 												continue search;
0: 											}
0: 										}
0: 										else if (nextBestMatchPosition >= currentPosition)
1: 										{
0: 											// restart in the current array
0: 											clobOffset = (int) (nextBestMatchPosition - currentPosition);
0: 											nextBestMatchPosition = -1;
1: 									
0: 											if (patternIndex != 0) {
0: 												needPattern = true;
0: 												continue search;
0: 											}
0: 										}
0: 										else
1: 										{
0: 											clobReader.close();
0: 											start = nextBestMatchPosition;
0: 											continue restartPattern;
0: 										}
1: 
0: 										clobOffset--; // since the continue will increment it
0: 										matchCount = 0;
0: 										continue compareArrays;
0: 									}
1: 									
0: 									// no current match, just continue
0: 								}
0: 							}
1: 
0: 							currentPosition += read;
1: 
0: 							// indicates we need to read more data
0: 							clobOffset = -1;
0: 						}
0: 					}
0: 				}
0:             }
0:         }
0:         catch (Throwable t)
1:         {
0: 			throw noStateChangeLOB(t);
0:         }
0:         finally
1:         {
0:             if (pushStack)
0:                 restoreContextStack();
0:         }
1: 
0:     }
1: 
1: 
0:   /**
0:    * Determines the character position at which the specified
0:    * <code>Clob</code> object <code>searchstr</code> appears in this
0:    * <code>Clob</code> object.  The search begins at position
0:    * <code>start</code>.
0:    * @param searchstr the <code>Clob</code> object for which to search
0:    * @param start the position at which to begin searching; the first
0:    *              position is 1
0:    * @return the position at which the <code>Clob</code> object appears,
0:    * else -1; the first position is 1
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code> value
0:    */
1: 
1:     public long position(Clob searchClob, long start)
1:         throws SQLException
1:     {
1:         boolean pushStack = false;
1:         try
1:         {
0:             if (start < 1)
0:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(start));
0:             if (searchClob == null)
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN);
1: 
1:             synchronized (getConnectionSynchronization())
1:             {
0: 				char[] subPatternChar = new char[256];
1: 
0: 				boolean seenOneCharacter = false;
1: 
0: 				//System.out.println("BEGIN CLOB SEARCH @ " + start);
1: 
1: restartScan:
0: 				for (;;) {
1: 
0: 					long firstPosition = -1;
1: 
0: 					Reader patternReader = searchClob.getCharacterStream();
1: 
0: 					//System.out.println("RESTART CLOB SEARCH @ " + start);
1: 
0: 					try {
1: 
0: 						for (;;) {
1: 
0: 							int read = patternReader.read(subPatternChar, 0, subPatternChar.length);
0: 							if (read == -1) {
0: 								//empty pattern
0: 								if (!seenOneCharacter)
0: 									return start; // matches DB2 SQL LOCATE function
1: 
0: 								return firstPosition;
0: 							}
0: 							if (read == 0) {
0: 								//System.out.println("STUCK IN READ 0 HELL");
0: 								continue;
0: 							}
1: 
0: 							seenOneCharacter = true;
1: 
0: 							String subPattern = new String(subPatternChar, 0, read);
0: 					//System.out.println("START CLOB SEARCH @ " + start + " -- " + subPattern);
0: 							long position = position(subPattern, start);
0: 					//System.out.println("DONE SUB CLOB SEARCH @ " + start + " -- " + position);
0: 							if (position == -1) {
0: 								// never seen any match
0: 								if (firstPosition == -1)
0: 									return -1;
1: 
0: 								start = firstPosition + 1;
0: 								continue restartScan;
0: 							}
1: 
0: 							if (firstPosition == -1)
0: 								firstPosition = position;
0: 							else if (position != start) {
0: 								// must match at the first character of the segment
0: 								start = firstPosition + 1;
0: 								continue restartScan;
0: 							}
1: 
0: 							// read is the length of the subPattern string
0: 							start = position + read;
0: 					}
0: 					} finally {
0: 						patternReader.close();
0: 					}
0: 				}
0:             }
0:         }
0:         catch (Throwable t)
1:         {
0: 			throw noStateChangeLOB(t);
0:         }
0:         finally
1:         {
0:             if (pushStack)
0:                 restoreContextStack();
0:         }
1: 
0:     }
1: 
1: 
0:     /*
0:      If we have a stream, release the resources associated with it.
0:      */
0:     protected void finalize()
1:     {
0:         // System.out.println("finalizer called");
0:         if (!isString)
0:             ((Resetable)myStream).closeStream();
0:     }
1: 
1: 
0: 	/**
1:     Following methods are for the new JDBC 3.0 methods in java.sql.Clob
1:     (see the JDBC 3.0 spec). We have the JDBC 3.0 methods in Local20
1:     package, so we don't have to have a new class in Local30.
1:     The new JDBC 3.0 methods don't make use of any new JDBC3.0 classes and
1:     so this will work fine in jdbc2.0 configuration.
0: 	*/
1: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	JDBC 3.0	-	New public methods
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
1: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Writes the given Java String to the CLOB value that this Clob object designates
0:     * at the position pos.
0:     *
0:     * @param pos - the position at which to start writing to the CLOB value that
0:     * this Clob object represents
0:     * @param str - the string to be written to the CLOB value that this Clob designates
0:     * @return the number of characters written 
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public int setString(long pos, String parameterName)
1:     throws SQLException
1: 	{
0: 		throw Util.notImplemented();
0: 	}
1: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Writes len characters of str, starting at character offset, to the CLOB value
0:     * that this Clob represents.
0:     *
0:     * @param pos - the position at which to start writing to this Clob object
0:     * @param str - the string to be written to the CLOB value that this Clob designates
0:     * @param offset - the offset into str to start reading the characters to be written
0:     * @param len - the number of characters to be written 
0:     * @return the number of characters written
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public int setString(long pos, String str, int offset, int len)
1:     throws SQLException
1: 	{
0: 		throw Util.notImplemented();
0: 	}
1: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Retrieves a stream to be used to write Ascii characters to the CLOB
0:     * value that this Clob object represents, starting at position pos.
0:     *
0:     * @param pos - the position at which to start writing to this Clob object
0:     * @return the stream to which ASCII encoded characters can be written 
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public java.io.OutputStream setAsciiStream(long pos)
1:     throws SQLException
1: 	{
0: 		throw Util.notImplemented();
0: 	}
1: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Retrieves a stream to be used to write a stream of Unicode characters to the
0:     * CLOB value that this Clob object represents, starting at position pos.
0:     *
0:     * @param pos - the position at which to start writing to this Clob object
0:     * @return the stream to which Unicode encoded characters can be written 
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public java.io.Writer setCharacterStream(long pos)
1:     throws SQLException
1: 	{
0: 		throw Util.notImplemented();
0: 	}
1: 
0:   	/**
0:     * JDBC 3.0
0:     *
0:     * Truncates the CLOB value that this Clob designates to have a length of len characters
0:     *
0:     * @param len - the length, in bytes, to which the CLOB value that this Blob
0:     * value should be truncated
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public void truncate(long len)
1:     throws SQLException
1: 	{
0: 		throw Util.notImplemented();
0: 	}
1: 
1: 
0: 	/*
0: 	**
0: 	*/
1: 
0: 	static SQLException noStateChangeLOB(Throwable t) {
0:         if (t instanceof StandardException)
1:         {
0:             // container closed means the blob or clob was accessed after commit
0:             if (((StandardException) t).getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED))
1:             {
0:                 t = StandardException.newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
0:             }
0:         }
0: 		return org.apache.derby.impl.jdbc.EmbedResultSet.noStateChangeException(t);
0: 	}
1: 
0: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.jdbc
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: 
0: package org.apache.derby.impl.jdbc;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.Resetable;
0: import org.apache.derby.impl.jdbc.ConnectionChild;
0: import org.apache.derby.impl.jdbc.EmbedConnection;
0: import org.apache.derby.impl.jdbc.Util;
0: import org.apache.derby.impl.jdbc.UTF8Reader;
0: import org.apache.derby.impl.jdbc.ReaderToAscii;
0: 
0: import java.io.InputStream;
0: import java.io.InputStreamReader;
0: import java.io.StringReader;
0: import java.io.Reader;
0: import java.io.IOException;
0: import java.io.EOFException;
0: import java.sql.SQLException;
0: import java.sql.Clob;
0: 
0: /*
0:     Implements java.sql.Clob (see the JDBC 2.0 spec).
0:     A clob sits on top of a CHAR, VARCHAR or LONG VARCHAR column.
0:     If its data is small (less than 1 page) it is a byte array taken from
0:     the SQLChar class. If it is large (more than 1 page) it is a long column
0:     in the database. The long column is accessed as a stream, and is implemented
0:     in store as an OverflowInputStream.  The Resetable interface allows sending
0:     messages to that stream to initialize itself (reopen its container and
0:     lock the corresponding row) and to reset itself to the beginning.
0: 
0:     NOTE: In the case that the data is large, it is represented as a stream.
0:     This stream can be returned to the user in the getAsciiStream() method.
0:     This means that we have limited control over the state of the stream,
0:     since the user can read bytes from it at any time.  Thus all methods
0:     here reset the stream to the beginning before doing any work.
0:     CAVEAT: The methods may not behave correctly if a user sets up
0:     multiple threads and sucks data from the stream (returned from
0:     getAsciiStream()) at the same time as calling the Clob methods.
0: 
0:  */
0: final class EmbedClob extends ConnectionChild implements Clob
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0:     // clob is either a string or stream
0:     private boolean         isString;
0:     private InputStream     myStream;
0:     private String          myString;
0: 
0:     /*
0:     This constructor should only be called by EmbedResultSet.getClob
0:     */
0:     protected EmbedClob(DataValueDescriptor dvd, EmbedConnection con)
0:         throws StandardException
0:     {
0:         super(con);
0:         // if the underlying column is null, ResultSet.getClob will return null,
0:         // never should get this far
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(!dvd.isNull(), "clob is created on top of a null column");
0: 
0:         myStream = dvd.getStream();
0:         if (myStream == null)
0:         {
0:             isString = true;
0:            myString = dvd.getString();
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(myString != null,"clob has a null value underneath");
0:         }
0:         else
0:         {
0:             /*
0:              We are expecting this stream to be a FormatIdInputStream with an
0:              OverflowInputStream inside. FormatIdInputStream implements
0:              Resetable, as does OverflowInputStream. This should be the case
0:              when retrieving data from a long column. However, SQLChar, which is
0:              the class implementing the getStream() method for dvd.getStream(),
0:              does not guarantee this for us. In particular, the logging system
0:              (see StoredPage.logColumn) calls setStream with an argument that
0:              is sometimes a RememberBytesInputStream on a SQLChar object
0:              (e.g. see test repStreaming.sql). However, such a SQLChar
0:              object is going to the log buffer, NOT back to the user, so it
0:              should not break the ASSERT below.
0:              */
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(myStream instanceof Resetable);
0: 
0:             ((Resetable)myStream).initStream();
0: 
0:         }
0:     }
0: 
0: 
0:   /**
0:    * Returns the number of characters
0:    * in the <code>CLOB</code> value
0:    * designated by this <code>Clob</code> object.
0:    * @return length of the <code>CLOB</code> in characters
0:    * @exception SQLException if there is an error accessing the
0:    * length of the <code>CLOB</code>
0:    */
0: 
0:     public long length() throws SQLException
0:     {
0:         // if we have a string, not a stream
0:         if (isString)
0:             return myString.length();
0: 
0: 
0: 		Object synchronization = getConnectionSynchronization();
0:         synchronized (synchronization)
0:         {
0: 			Reader clobReader = null;
0:             setupContextStack();
0: 			try {
0: 
0: 				clobReader = getCharacterStream();
0:                 long clobLength = 0;
0:                 for (;;)
0:                 {
0:                     long size = clobReader.skip(32 * 1024);
0:                     if (size == -1)
0:                         break;
0:                     clobLength += size;
0:                 }
0: 				clobReader.close();
0: 				clobReader = null;
0: 
0: 				return clobLength;
0: 			}
0: 			catch (Throwable t)
0: 			{
0: 				throw noStateChangeLOB(t);
0: 			}
0: 			finally
0: 			{
0: 				if (clobReader != null) {
0: 					try {
0: 						clobReader.close();
0: 					} catch (IOException ioe) {
0: 					}
0: 				}
0: 				restoreContextStack();
0: 			}
0: 		}
0: 	}
0: 
0:   /**
0:    * Returns a copy of the specified substring
0:    * in the <code>CLOB</code> value
0:    * designated by this <code>Clob</code> object.
0:    * The substring begins at position
0:    * <code>pos</code> and has up to <code>length</code> consecutive
0:    * characters.
0:    * @param pos the first character of the substring to be extracted.
0:    *            The first character is at position 1.
0:    * @param length the number of consecutive characters to be copied
0:    * @return a <code>String</code> that is the specified substring in
0:    *         the <code>CLOB</code> value designated by this <code>Clob</code> object
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code>
0: 
0:    NOTE: return the empty string if pos is too large
0:    */
0: 
0:     public String getSubString(long pos, int length) throws SQLException
0:     {
0:         if (pos < 1)
0:             throw Util.generateCsSQLException(
0:                 SQLState.BLOB_BAD_POSITION, new Long(pos));
0:         if (length <= 0)
0:             throw Util.generateCsSQLException(
0:                 SQLState.BLOB_NONPOSITIVE_LENGTH, new Integer(length));
0: 
0:         // if we have a string, not a stream
0:         if (isString)
0:         {
0:             int sLength = myString.length();
0:             if (sLength < pos)
0:                 throw Util.generateCsSQLException(
0:                     SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
0:             int endIndex = ((int) pos) + length - 1;
0:             // cannot go over length of string, or we get an exception
0:             return myString.substring(((int) pos) - 1, (sLength > endIndex ? endIndex : sLength));
0:         }
0: 
0: 		Object synchronization = getConnectionSynchronization();
0:         synchronized (synchronization)
0:         {
0:             setupContextStack();
0: 
0: 			UTF8Reader clobReader = null;
0: 			try {
0: 
0: 				clobReader = getCharacterStreamAtPos(pos, synchronization);
0: 				if (clobReader == null)
0: 					throw StandardException.newException(SQLState.BLOB_POSITION_TOO_LARGE, new Long(pos));
0: 
0: 				StringBuffer sb = new StringBuffer(length);
0: 				int remainToRead = length;
0: 				while (remainToRead > 0) {
0: 
0: 					int read = clobReader.readInto(sb, remainToRead);
0: 					if (read == -1)
0: 						break;
0: 
0: 					remainToRead -= read;
0: 				}
0: 				clobReader.close();
0: 				clobReader = null;
0: 
0: 				return sb.toString();
0: 			}
0: 			catch (Throwable t)
0: 			{
0: 				throw noStateChangeLOB(t);
0: 			}
0: 			finally
0: 			{
0: 				if (clobReader != null)
0: 					clobReader.close();
0: 				restoreContextStack();
0: 			}
0: 		}
0:     }
0: 
0: 
0:   /**
0:    * Gets the <code>Clob</code> contents as a Unicode stream.
0:    * @return a Unicode stream containing the <code>CLOB</code> data
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code>
0:    */
0: 
0:     public java.io.Reader getCharacterStream() throws SQLException
0:     {
0: 
0:         // if we have a string, not a stream
0:         if (isString)
0:         {
0:             return new StringReader(myString);
0:         }
0: 
0: 
0: 		Object synchronization = getConnectionSynchronization();
0:         synchronized (synchronization)
0:         {
0:             setupContextStack();
0: 
0: 			try {
0: 				return getCharacterStreamAtPos(1, synchronization);
0: 			}
0: 			catch (Throwable t)
0: 			{
0: 				throw noStateChangeLOB(t);
0: 			}
0: 			finally
0: 			{
0: 				restoreContextStack();
0: 			}
0: 		}
0:     }
0: 
0: 
0:   /**
0:    * Gets the <code>CLOB</code> value designated by this <code>Clob</code>
0:    * object as a stream of Ascii bytes.
0:    * @return an ascii stream containing the <code>CLOB</code> data
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code> value
0:    */
0: 
0:     public java.io.InputStream getAsciiStream() throws SQLException
0:     {
0: 		return new ReaderToAscii(getCharacterStream());
0:     }
0: 
0: 	private UTF8Reader getCharacterStreamAtPos(long position, Object synchronization)
0: 		throws IOException, StandardException
0: 	{
0:         ((Resetable)myStream).resetStream();
0: 		UTF8Reader clobReader = new UTF8Reader(myStream, 0, this, synchronization);
0: 
0: 		// skip to the correct position (pos is one based)
0: 		long remainToSkip = position - 1;
0: 		while (remainToSkip > 0) {
0: 			long skipBy = clobReader.skip(remainToSkip);
0: 			if (skipBy == -1)
0: 				return null;
0: 
0: 			remainToSkip -= skipBy;
0: 		}
0: 
0: 		return clobReader;
0: 	}
0: 
0: 
0:   /**
0:    * Determines the character position at which the specified substring
0:    * <code>searchstr</code> appears in the <code>CLOB</code>.  The search
0:    * begins at position <code>start</code>.
0:    * @param searchstr the substring for which to search
0:    * @param start the position at which to begin searching; the first position
0:    *              is 1
0:    * @return the position at which the substring appears, else -1; the first
0:    *         position is 1
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code> value
0:    */
0:     public long position(String searchStr, long start)
0:         throws SQLException
0:     {
0:         boolean pushStack = false;
0:         try
0:         {
0:             if (start < 1)
0:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(start));
0:             if (searchStr == null)
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN);
0:             if (searchStr == "")
0:                 return start; // match DB2's SQL LOCATE function
0: 
0:             // if we have a string, not a stream
0:             if (isString)
0:             {
0: 				// avoid truncation errors in the cast of start to an int.
0: 				if (start > myString.length())
0: 					return -1;
0: 
0:                 int result = myString.indexOf(searchStr, (int) start-1);
0:                 return result < 0 ? -1 : result + 1;
0:             }
0:             else // we have a stream
0:             {
0: 				Object synchronization = getConnectionSynchronization();
0:                 synchronized (synchronization)
0:                 {
0:                     pushStack = !getEmbedConnection().isClosed();
0:                     if (pushStack)
0:                         setupContextStack();
0: 
0: 					char[] tmpClob = new char[256];
0: 					int patternLength = searchStr.length();
0: 
0: restartPattern:
0: 					for (;;) {
0: 
0: 					//System.out.println("RESET " + start);
0: 						UTF8Reader clobReader = getCharacterStreamAtPos(start, synchronization);
0: 						if (clobReader == null)
0: 							return -1;
0: 
0: 
0: 
0: 						// start of any match of the complete pattern.
0: 
0: 						int patternIndex = 0;
0: 						char[] tmpPattern = null;
0: 						boolean needPattern = true;
0: 
0: 						// how many characters of the patter segment we have matched
0: 						int matchCount = 0;
0: 
0: 						long currentPosition = start;
0: 						int clobOffset = -1;
0: 						int read = -1;
0: 
0: 						// absolute position of a possible match
0: 						long matchPosition = -1;
0: 
0: 
0: 						// absolute position of the next possible match
0: 						long nextBestMatchPosition = -1;
0: 						//System.out.println("restartPattern: " + start);
0: 
0: 
0: search:
0: 						for (;;)
0: 						{
0: 							//System.out.println("search: " + needPattern + " -- " + clobOffset);
0: 							if (needPattern) {
0: 
0: 								String tmpPatternS;
0: 								if ((patternLength - patternIndex) > 256)
0: 									tmpPatternS = searchStr.substring(patternIndex, 256);
0: 								else
0: 									tmpPatternS = searchStr;
0: 
0: 								tmpPattern = tmpPatternS.toCharArray();
0: 								needPattern = false;
0: 								matchCount = 0;
0: 
0: 							}
0: 
0: 							if (clobOffset == -1) {
0: 								
0: 								read = clobReader.read(tmpClob, 0, tmpClob.length);
0: 							//System.out.println("MORE DATA " + read);
0: 								if (read == -1)
0: 									return -1;
0: 
0: 								if (read == 0)
0: 									continue search;
0: 
0: 								clobOffset = 0;
0: 							}
0: 
0: 
0: 							// find matches within our two temp arrays.
0: compareArrays:
0: 							for (; clobOffset < read; clobOffset++) {
0: 
0: 								//System.out.println("compareArrays " + clobOffset);
0: 
0: 								char clobC = tmpClob[clobOffset];
0: 
0: 
0: 								if (clobC == tmpPattern[matchCount])
0: 								{
0: 									if (matchPosition == -1) {
0: 										matchPosition = currentPosition + clobOffset;
0: 									}
0: 
0: 									matchCount++;
0: 
0: 									// have we matched the entire pattern segment
0: 									if (matchCount == tmpPattern.length)
0: 									{
0: 										// move onto the next segment.
0: 										patternIndex += tmpPattern.length;
0: 										if (patternIndex == patternLength) {
0: 											// complete match !!
0: 											clobReader.close();
0: 											//System.out.println("COMPLETE@" + matchPosition);
0: 											return matchPosition;
0: 										}
0: 
0: 										needPattern = true;
0: 										continue search;
0: 
0: 									}
0: 
0: 									if (clobC == tmpPattern[0]) {
0: 
0: 										// save the next best start position.
0: 
0: 										// must be the first character of the actual pattern
0: 										if (patternIndex == 0) {
0: 
0: 											// must not be just a repeat of the match of the first character
0: 											if (matchCount != 1) {
0: 
0: 												// must not have a previous next best.
0: 
0: 												if (nextBestMatchPosition == -1) {
0: 													nextBestMatchPosition = currentPosition + clobOffset;
0: 												}
0: 
0: 											}
0: 
0: 										}
0: 									}
0: 
0: 									continue compareArrays;
0: 								}
0: 								else
0: 								{
0: 									// not a match
0: 									//
0: 									// 
0: 									if (matchPosition != -1) {
0: 										// failed after we matched some amount of the pattern
0: 										matchPosition = -1;
0: 
0: 										// See if we found a next best match
0: 										if (nextBestMatchPosition == -1)
0: 										{
0: 											// NO - just continue on, re-starting at this character
0: 
0: 											if (patternIndex != 0) {
0: 												needPattern = true;
0: 												continue search;
0: 											}
0: 										}
0: 										else if (nextBestMatchPosition >= currentPosition)
0: 										{
0: 											// restart in the current array
0: 											clobOffset = (int) (nextBestMatchPosition - currentPosition);
0: 											nextBestMatchPosition = -1;
0: 									
0: 											if (patternIndex != 0) {
0: 												needPattern = true;
0: 												continue search;
0: 											}
0: 										}
0: 										else
0: 										{
0: 											clobReader.close();
0: 											start = nextBestMatchPosition;
0: 											continue restartPattern;
0: 										}
0: 
0: 										clobOffset--; // since the continue will increment it
0: 										matchCount = 0;
0: 										continue compareArrays;
0: 									}
0: 									
0: 									// no current match, just continue
0: 								}
0: 							}
0: 
0: 							currentPosition += read;
0: 
0: 							// indicates we need to read more data
0: 							clobOffset = -1;
0: 						}
0: 					}
0: 				}
0:             }
0:         }
0:         catch (Throwable t)
0:         {
0: 			throw noStateChangeLOB(t);
0:         }
0:         finally
0:         {
0:             if (pushStack)
0:                 restoreContextStack();
0:         }
0: 
0:     }
0: 
0: 
0:   /**
0:    * Determines the character position at which the specified
0:    * <code>Clob</code> object <code>searchstr</code> appears in this
0:    * <code>Clob</code> object.  The search begins at position
0:    * <code>start</code>.
0:    * @param searchstr the <code>Clob</code> object for which to search
0:    * @param start the position at which to begin searching; the first
0:    *              position is 1
0:    * @return the position at which the <code>Clob</code> object appears,
0:    * else -1; the first position is 1
0:    * @exception SQLException if there is an error accessing the
0:    * <code>CLOB</code> value
0:    */
0: 
0:     public long position(Clob searchClob, long start)
0:         throws SQLException
0:     {
0:         boolean pushStack = false;
0:         try
0:         {
0:             if (start < 1)
0:                 throw StandardException.newException(
0:                     SQLState.BLOB_BAD_POSITION, new Long(start));
0:             if (searchClob == null)
0:                 throw StandardException.newException(SQLState.BLOB_NULL_PATTERN);
0: 
0:             synchronized (getConnectionSynchronization())
0:             {
0: 				char[] subPatternChar = new char[256];
0: 
0: 				boolean seenOneCharacter = false;
0: 
0: 				//System.out.println("BEGIN CLOB SEARCH @ " + start);
0: 
0: restartScan:
0: 				for (;;) {
0: 
0: 					long firstPosition = -1;
0: 
0: 					Reader patternReader = searchClob.getCharacterStream();
0: 
0: 					//System.out.println("RESTART CLOB SEARCH @ " + start);
0: 
0: 					try {
0: 
0: 						for (;;) {
0: 
0: 							int read = patternReader.read(subPatternChar, 0, subPatternChar.length);
0: 							if (read == -1) {
0: 								//empty pattern
0: 								if (!seenOneCharacter)
0: 									return start; // matches DB2 SQL LOCATE function
0: 
0: 								return firstPosition;
0: 							}
0: 							if (read == 0) {
0: 								//System.out.println("STUCK IN READ 0 HELL");
0: 								continue;
0: 							}
0: 
0: 							seenOneCharacter = true;
0: 
0: 							String subPattern = new String(subPatternChar, 0, read);
0: 					//System.out.println("START CLOB SEARCH @ " + start + " -- " + subPattern);
0: 							long position = position(subPattern, start);
0: 					//System.out.println("DONE SUB CLOB SEARCH @ " + start + " -- " + position);
0: 							if (position == -1) {
0: 								// never seen any match
0: 								if (firstPosition == -1)
0: 									return -1;
0: 
0: 								start = firstPosition + 1;
0: 								continue restartScan;
0: 							}
0: 
0: 							if (firstPosition == -1)
0: 								firstPosition = position;
0: 							else if (position != start) {
0: 								// must match at the first character of the segment
0: 								start = firstPosition + 1;
0: 								continue restartScan;
0: 							}
0: 
0: 							// read is the length of the subPattern string
0: 							start = position + read;
0: 					}
0: 					} finally {
0: 						patternReader.close();
0: 					}
0: 				}
0:             }
0:         }
0:         catch (Throwable t)
0:         {
0: 			throw noStateChangeLOB(t);
0:         }
0:         finally
0:         {
0:             if (pushStack)
0:                 restoreContextStack();
0:         }
0: 
0:     }
0: 
0: 
0:     /*
0:      If we have a stream, release the resources associated with it.
0:      */
0:     protected void finalize()
0:     {
0:         // System.out.println("finalizer called");
0:         if (!isString)
0:             ((Resetable)myStream).closeStream();
0:     }
0: 
0: 
0: 	/**
0:     Following methods are for the new JDBC 3.0 methods in java.sql.Clob
0:     (see the JDBC 3.0 spec). We have the JDBC 3.0 methods in Local20
0:     package, so we don't have to have a new class in Local30.
0:     The new JDBC 3.0 methods don't make use of any new JDBC3.0 classes and
0:     so this will work fine in jdbc2.0 configuration.
0: 	*/
0: 
0: 	/////////////////////////////////////////////////////////////////////////
0: 	//
0: 	//	JDBC 3.0	-	New public methods
0: 	//
0: 	/////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Writes the given Java String to the CLOB value that this Clob object designates
0:     * at the position pos.
0:     *
0:     * @param pos - the position at which to start writing to the CLOB value that
0:     * this Clob object represents
0:     * @param str - the string to be written to the CLOB value that this Clob designates
0:     * @return the number of characters written 
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public int setString(long pos, String parameterName)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Writes len characters of str, starting at character offset, to the CLOB value
0:     * that this Clob represents.
0:     *
0:     * @param pos - the position at which to start writing to this Clob object
0:     * @param str - the string to be written to the CLOB value that this Clob designates
0:     * @param offset - the offset into str to start reading the characters to be written
0:     * @param len - the number of characters to be written 
0:     * @return the number of characters written
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public int setString(long pos, String str, int offset, int len)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Retrieves a stream to be used to write Ascii characters to the CLOB
0:     * value that this Clob object represents, starting at position pos.
0:     *
0:     * @param pos - the position at which to start writing to this Clob object
0:     * @return the stream to which ASCII encoded characters can be written 
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public java.io.OutputStream setAsciiStream(long pos)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0: 	/**
0:     * JDBC 3.0
0:     *
0:     * Retrieves a stream to be used to write a stream of Unicode characters to the
0:     * CLOB value that this Clob object represents, starting at position pos.
0:     *
0:     * @param pos - the position at which to start writing to this Clob object
0:     * @return the stream to which Unicode encoded characters can be written 
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public java.io.Writer setCharacterStream(long pos)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0:   	/**
0:     * JDBC 3.0
0:     *
0:     * Truncates the CLOB value that this Clob designates to have a length of len characters
0:     *
0:     * @param len - the length, in bytes, to which the CLOB value that this Blob
0:     * value should be truncated
0:     * @exception SQLException Feature not implemented for now.
0: 	*/
0: 	public void truncate(long len)
0:     throws SQLException
0: 	{
0: 		throw Util.notImplemented();
0: 	}
0: 
0: 
0: 	/*
0: 	**
0: 	*/
0: 
0: 	static SQLException noStateChangeLOB(Throwable t) {
0:         if (t instanceof StandardException)
0:         {
0:             // container closed means the blob or clob was accessed after commit
0:             if (((StandardException) t).getMessageId().equals(SQLState.DATA_CONTAINER_CLOSED))
0:             {
0:                 t = StandardException.newException(SQLState.BLOB_ACCESSED_AFTER_COMMIT);
0:             }
0:         }
0: 		return org.apache.derby.impl.jdbc.EmbedResultSet.noStateChangeException(t);
0: 	}
0: 
0: }
============================================================================