1:67614ad: /*
1:67614ad: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.harness.FileCompare
1:67614ad: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
1:67614ad: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
46:f68f62f: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:f68f62f: 
2:67614ad:  */
1:f68f62f: 
1:67614ad: package org.apache.derbyTesting.functionTests.harness;
1:67614ad: 
1:67614ad: /***
1:67614ad:  * FileCompare.java
1:67614ad:  *
1:67614ad:  * Compare two files using SimpleDiff
1:67614ad:  * Purpose: simulate diff
1:67614ad:  * Note: if usesysdiff=true, we execute the system's diff
1:67614ad:  ***/
1:67614ad: 
1:67614ad: import java.io.*;
1:67614ad: import java.util.StringTokenizer;
1:67614ad: import java.util.Properties;
1:67614ad: 
1:67614ad: public class FileCompare
1:67614ad: {
1:67614ad: 
1:67614ad:     private String testBase;
1:67614ad:     private String framework;
1:67614ad:     private String jvmName;
1:67614ad:     private String jvmString;
1:67614ad:     private String serverJvm;
1:67614ad:     private int iminor;
1:67614ad:     private boolean searchJdk12 = false;
1:67614ad:     private boolean searchJdk13 = false;
1:67614ad:     private boolean searchJdk14 = false;
1:0bbfdac:     private int driverVersionMajor = 0;
1:0bbfdac:     private int driverVersionMinor = 0;
1:67614ad:     private boolean searchFrame;
1:0bbfdac:     private boolean searchDriverVersion;
1:67614ad:     private InputStream master = null;
1:67614ad:     private boolean verbose;
1:67614ad:     
1:67614ad:     public FileCompare()
1:67614ad:     {
1:67614ad:       verbose = Boolean.getBoolean("verbose");
2:67614ad:     }
1:67614ad: 
1:67614ad:     // The arguments should be the names of the input and output files
1:67614ad:     public boolean exec(String outfile, File outDir, PrintWriter pwDiff,
1:67614ad:         String testBaseOrig, String framework, String jvmName,
1:67614ad:         int iminor, boolean useprocess, boolean usesysdiff, 
1:67614ad:         String canondir, String canonpath, String serverJvm)
1:67614ad:         throws IOException, ClassNotFoundException
1:67614ad:     {
1:67614ad:         testBase = testBaseOrig;
1:67614ad:         this.framework = framework;
1:67614ad:         this.jvmName = jvmName;
1:67614ad:         this.iminor = iminor;
1:67614ad:         this.jvmString = jvmName;
1:67614ad:         this.serverJvm = serverJvm;
1:67614ad: 
1:67614ad:         BufferedReader outFile;
1:67614ad:         BufferedReader masterFile;
1:67614ad:         StringBuffer sb = new StringBuffer();
1:67614ad:  
1:67614ad:         // If framework is DerbyNet, we may need to check subdirs of the master canon dir
1:0bbfdac:         // for specific masters by client  we're running against. So, get version
1:67614ad:         // for later use if that is the case.
1:0bbfdac:         if (framework.startsWith("DerbyNet"))
1:67614ad:         {
1:67614ad: 	  try	
1:67614ad: 	  {
1:3f5c48a:         Class<?> c = Class.forName(NetServer.getDriverName(framework));
1:4469400:         Object o = c.getConstructor().newInstance();
1:3f5c48a:         driverVersionMajor = (Integer) c.getMethod("getMajorVersion").invoke(o);
1:3f5c48a:         driverVersionMinor = (Integer) c.getMethod("getMinorVersion").invoke(o);
1:0bbfdac:             if (framework.startsWith("DerbyNet")) searchDriverVersion = true;
1:67614ad: 	  } catch ( Exception e )
1:67614ad: 	  {
1:0bbfdac: 	    //if anything goes wrong, make sure the driver version values are set to zero
1:67614ad: 	    //forget about it.
1:67614ad: 		  
1:0bbfdac: 		  System.out.println("Cannot determine driver version:" + e);
1:0bbfdac: 		  driverVersionMinor = 0;
1:0bbfdac: 		  driverVersionMajor = 0;
1:0bbfdac: 		  searchDriverVersion = false;
1:67614ad:  	  }
1:67614ad:         }
1:67614ad:         
1:0bbfdac: 
1:67614ad:         // The outfile name is known -- outfile
1:67614ad:         // But the master canon needs to be located
1:67614ad:         // The user can set canondir (or it defaults to "master")
1:67614ad:         String topdir = "";
1:67614ad:         if ( (canondir != null) && (canondir.length()>0) )
1:67614ad:             topdir = canondir;
1:67614ad:         else {
1:67614ad: 			// if this is using product jars, use product_master first
1:67614ad: 			Class c = FileCompare.class; // get our class loader
1:67614ad: 			InputStream is = c.getResourceAsStream("/org/apache/derby/info/DBMS.properties");
1:67614ad: 			Properties dbprop = new Properties();
1:67614ad: 			dbprop.load(is);
1:67614ad: 			is.close();
1:67614ad: 
1:67614ad: 			String filename=dbprop.getProperty("derby.product.file");
1:67614ad: 			if (filename != null) {
1:67614ad: 				//looks like it might be one of our jars?
1:67614ad: 				if (filename.startsWith("derby") && filename.endsWith(".jar")) {
1:67614ad: 					canondir = "product_master"; // remember redirection
1:67614ad:                     topdir = "product_master";
1:67614ad: 				}
1:67614ad: 				else
1:67614ad:                     topdir = "master";
1:67614ad: 			}
1:67614ad: 			else
1:67614ad:                 topdir = "master";
1:67614ad: 		}
1:67614ad: 
1:67614ad:         // There can be subdirs under the master for framework, jvm
1:67614ad:         String subdir = "";
1:67614ad:         boolean searchDefault = true; // if no framework or special jvm
1:67614ad:         boolean searchBoth = false;
1:67614ad:         boolean searchJvm = false;
1:67614ad:         if ( (framework != null) && (framework.length()>0) )
1:67614ad:         {
1:67614ad:             searchFrame = true;
1:67614ad:             subdir = framework;
1:67614ad:         }
1:67614ad:         if ( (jvmName != null) && (jvmName.length()>0)
1:67614ad:                 & (!jvmName.equals("currentjvm")) )
1:67614ad:         {
1:67614ad:             searchJvm = true;
1:67614ad:             if (searchFrame)
1:67614ad:                 searchBoth = true;
1:67614ad:             if ( iminor >= 2 ) // jdk12 or higher may use jdk12 masters
1:67614ad:                 jvmString = "jdk12";
1:67614ad: 	    if ( iminor >= 2 ) searchJdk12 = true;
1:67614ad:             if ( iminor >= 3 ) searchJdk13 = true;
1:67614ad:             if ( iminor >= 4 ) searchJdk14 = true;
1:67614ad:             subdir += jvmName;
1:67614ad:         }
1:67614ad: 
1:67614ad:         if ( searchFrame || searchJvm || searchBoth )
1:67614ad:             searchDefault = false;
1:67614ad:        
1:67614ad:         sb.append(topdir);
1:67614ad:         if (subdir.length()>0)
1:67614ad:             sb.append(subdir + '/');
1:67614ad:         sb.append(testBase + ".out");
1:67614ad:         String masterfilename = sb.toString();
1:67614ad: 	
1:67614ad: 	InputStream is = null;
1:67614ad:         
1:67614ad:         // Now try to locate the master file
1:67614ad: 	
1:67614ad:         if (is == null)
1:67614ad: 	{
1:67614ad: 	  searchCanondir(topdir);
1:67614ad: 	  is = master;
1:67614ad: 	}
1:67614ad:                 
1:4087714:         // If the master is still not found, create an empty master
1:67614ad:         if ( is == null )
1:67614ad:         {
1:4087714: 			is = new ByteArrayInputStream( new byte[] {} );
1:67614ad:         }
1:67614ad: 		// compress blanks in output columns to make up for column width differences
1:67614ad: 		// for JCC output
1:0bbfdac: 		if (NetServer.isClientConnection(framework))
1:67614ad: 		{
1:67614ad:             try
1:67614ad:             {
1:67614ad: 		        Sed sed = new Sed();
1:67614ad: 				File JCCOutFile = new File(outDir, testBase + ".tmpmstr");
1:67614ad: 		        sed.execJCC(is, JCCOutFile);
1:67614ad: 				is = new FileInputStream(JCCOutFile);
1:67614ad: 		    }
1:67614ad: 		    catch (ClassFormatError cfe)
1:67614ad: 		    {
1:67614ad: 		        System.out.println("SED Error: " + cfe.getMessage());
1:1edcdb3: 		    }
1:67614ad: 		}	
1:1edcdb3:         else 
1:1edcdb3:         {
1:1edcdb3:             // read in in fixed format, but write out relying on default encoding
1:1edcdb3:             File EncodedOutFile = new File(outDir, testBase + ".tmpmstr");
1:1edcdb3:             BufferedReader inFile = new BufferedReader(new InputStreamReader(is, "UTF-8"));
1:1edcdb3:             
1:1edcdb3:             PrintWriter pw = new PrintWriter
1:1edcdb3:             ( new BufferedWriter(new FileWriter(EncodedOutFile), 10000), true );
1:1edcdb3:             int c;
1:1edcdb3:             while ((c = inFile.read()) != -1)
1:1edcdb3:                 pw.write(c);
1:1edcdb3:             pw.flush();
1:1edcdb3:             pw.close();
1:1edcdb3:             is = new FileInputStream(EncodedOutFile);
1:1edcdb3:         }	
1:67614ad:         
1:67614ad:         // Define the input and output files
1:67614ad:         outFile = new BufferedReader(new FileReader(outfile));
1:67614ad:         masterFile = new BufferedReader(new InputStreamReader(is));
1:67614ad:         
1:67614ad:         // Do the comparison (diff)
1:67614ad:         if (usesysdiff == true)
1:67614ad:             return doSysDiff(is, testBase, outfile, outDir, pwDiff);
1:67614ad:         else
1:67614ad:         {
1:67614ad:             return doDiff2(outFile,masterFile, pwDiff);
1:67614ad:         }
1:67614ad:     }
1:67614ad: 
1:67614ad:     public boolean doDiff2(BufferedReader outFile, BufferedReader masterFile, PrintWriter pwDiff) throws IOException {
1:67614ad: 		return ((new SimpleDiff()).doWork(masterFile,outFile,pwDiff));
1:67614ad:     }
1:67614ad: 
1:67614ad:     public boolean doSysDiff(InputStream masterIS, String testBase, String outfile,
1:67614ad:         File outDir, PrintWriter pwDiff)
1:67614ad:         throws IOException
1:67614ad:     {
1:67614ad:         // Create a temp file to copy the master (located as an InputStream)
1:67614ad:         BufferedReader in =
1:67614ad:             new BufferedReader(new InputStreamReader(masterIS));
1:67614ad:         File tempMaster =
1:67614ad:             new File((new File(outDir,testBase + ".master")).getCanonicalPath());
1:67614ad: 
1:67614ad:         // Create a PrintWriter for copying the master temporarily for the diff
1:67614ad:         PrintWriter pwMaster = new PrintWriter( new BufferedWriter
1:67614ad:             (new FileWriter(tempMaster.getPath()), 10000), true );
1:67614ad:         String str = "";
1:67614ad:         while ( (str = in.readLine()) != null )
1:67614ad:         {
1:67614ad:             pwMaster.println(str);
1:67614ad:         }
1:67614ad:         pwMaster.close();
1:67614ad:         pwMaster = null;
1:67614ad:         in = null;
1:67614ad: 
1:67614ad:         String diffs = "0";
1:67614ad:         // Now create a process and do the system diff, capture to .out
1:67614ad:         Process pr = null;
1:67614ad:         try
1:67614ad:         {
1:67614ad:             StringBuffer sb = new StringBuffer();
1:67614ad:             sb.append("diff ");
1:67614ad:             sb.append(tempMaster.getCanonicalPath());
1:67614ad:             sb.append(" ");
1:67614ad:             sb.append(outfile);
1:67614ad:             String diffCmd = sb.toString();
1:67614ad: 
1:67614ad:             //System.out.println("diffCmd = " + diffCmd);
1:67614ad: 
1:67614ad:             pr = Runtime.getRuntime().exec(diffCmd);
1:67614ad: 
1:67614ad:             // We need the process inputstream to capture into the diff file
1:67614ad:             //System.out.println("Capture the process InputStream...");
1:67614ad:             BackgroundStreamDrainer stdout =
1:67614ad:                 new BackgroundStreamDrainer(pr.getInputStream(), null);
1:67614ad:             BackgroundStreamDrainer stderr =
1:67614ad:                 new BackgroundStreamDrainer(pr.getErrorStream(), null);
1:67614ad: 
1:67614ad:             pr.waitFor();
1:67614ad:             String result = HandleResult.handleResult(pr.exitValue(),
1:67614ad:                 stdout.getData(), stderr.getData(), pwDiff);
1:67614ad:             diffs = result.substring( result.lastIndexOf(',')+1 );
1:67614ad:             //System.out.println("diffs: " + diffs);
1:67614ad:             pr.destroy();
1:67614ad:             pr = null;
1:67614ad:         }
1:67614ad:         catch(Throwable t)
1:67614ad:         {
1:67614ad:             System.out.println("Process exception: " + t);
1:67614ad:             if (pr != null)
1:67614ad:             {
1:67614ad:                 pr.destroy();
1:67614ad:                 pr = null;
1:67614ad:             }
1:67614ad:         }
1:67614ad:         tempMaster.delete();
1:67614ad:         if ( diffs.equals("0") )
1:67614ad:             return false;
1:67614ad:         else
2:67614ad:             return true;
1:67614ad:     }
1:67614ad: 
1:67614ad:     public boolean doDiff(BufferedReader outFile, BufferedReader masterFile, PrintWriter pwDiff) throws IOException {
1:67614ad:         String str1;
1:67614ad:         String str2;
1:67614ad:         boolean diff = false;
1:67614ad: 
1:67614ad:         int line = 0;
1:67614ad:         int diffnum = 0;
1:67614ad:         int diffline = 0;
1:67614ad:         while ( (str1 = outFile.readLine()) != null )
1:67614ad:         {
1:67614ad:             line++;
1:67614ad:             str1 = str1.trim();
1:67614ad:             //System.out.println("Reading line: " + line);
1:67614ad:             // Read the line from the master file and compare
1:67614ad:             if ( (str2 = masterFile.readLine()) != null )
1:67614ad:             {
1:67614ad:                 str2 = str2.trim();
1:67614ad:                 if (!str1.equals(str2))
1:67614ad:                 {
1:67614ad:                     // Some lines diff because of too many spaces
1:67614ad:                     StringBuffer sb1 = new StringBuffer();
1:67614ad:                     StringBuffer sb2 = new StringBuffer();
1:67614ad:                     StringTokenizer st1 = new StringTokenizer(str1);
1:67614ad:                     while (st1.hasMoreTokens())
1:67614ad:                     {
1:67614ad:                         sb1.append(st1.nextToken());
1:67614ad:                     }
1:67614ad:                     //System.out.println("Out line: " + sb1.toString());
1:67614ad: 
1:67614ad:                     StringTokenizer st2 = new StringTokenizer(str2);
1:67614ad:                     while (st2.hasMoreTokens())
1:67614ad:                     {
1:67614ad:                         sb2.append(st2.nextToken());
1:67614ad:                     }
1:67614ad:                     //System.out.println("Master line: " + sb2.toString());
1:67614ad: 
1:67614ad:                     if ( sb1.toString().equals(sb2.toString()) )
1:67614ad:                         diff = false;
1:67614ad:                     // If the two lines are dashes, but wrong #, just ignore
1:67614ad:                     else if ( (str1.startsWith("-----")) && (str1.endsWith("-----")) )
1:67614ad:                     {
1:67614ad:                         if ( (str2.startsWith("-----")) && (str2.endsWith("-----")) )
1:67614ad:                             diff = false;
1:67614ad:                     }
1:67614ad:                     else
1:67614ad:                     {
1:67614ad:                         diff = true;
1:67614ad:                         diffnum++;
1:67614ad:                         System.out.println("Diff occurred at line: " + line);
1:67614ad:                         pwDiff.println("Diff occurred  at line: " + line);
2:67614ad:                         pwDiff.flush();
1:67614ad:                         break;
1:67614ad:                     }
1:67614ad:                 }
1:67614ad:                 else
1:67614ad:                 {
1:67614ad:                     diff = false;
1:67614ad:                 }
1:67614ad:             }
1:67614ad:         } // end while
1:67614ad:         outFile.close();
1:67614ad:         masterFile.close();
1:67614ad:         return diff;
1:67614ad:     }// end exec
1:67614ad: 
1:67614ad:     private void searchCanondir(String canondir)
1:67614ad:     {
1:67614ad: 	String prefix = canondir + '/';
1:67614ad: 	if (master == null && searchFrame) searchFramework(prefix);
1:67614ad:         if (master == null) searchJvm(prefix);
1:0bbfdac: 	if (master == null && searchDriverVersion) searchDriverVersion(prefix);
1:67614ad: 	if (master == null) getmaster(prefix);
1:67614ad: 	if (master == null && canondir != "master") searchCanondir("master");
1:67614ad:     }
1:67614ad: 
1:67614ad:     private void searchJvm(String prefix)
1:67614ad:     {
1:67614ad: 	// The JVM search follows the following pattern, with one exception:
1:67614ad: 	// first search jvmName (to support unnamed/non-IBM or Sun JVMs)
1:67614ad: 	// if vendor == IBM, search ibm+rev then jdk+rev, decrementing rev by one until rev=13,
1:0bbfdac: 	// in each dir, search framework and driver version if applicable.
1:31cc815: 	// BUT, if it's j9, unless j9dee, first j9_foundation, then search j9_22 for 22, otherwise, j9_13 then
1:41dfb84: 	// the normal ibm13 search pattern: ibm13 then jdk13.
1:67614ad: 
1:67614ad: 	String newprefix;
1:31cc815: 	if ((jvmName.startsWith("j9") || (serverJvm != null && serverJvm.startsWith("j9")))
1:31cc815:             && (!jvmName.startsWith("j9dee")))
1:67614ad: 	{
1:67614ad: 	    if (jvmName.startsWith("j9_foundation"))
1:67614ad:             {
1:67614ad:                 newprefix = prefix + "j9_foundation" + '/';
1:0bbfdac: 		if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
1:67614ad: 		if (master == null) getmaster(newprefix);
1:67614ad:             }
1:41dfb84: 	    else
1:41dfb84:             {
1:41dfb84:                 newprefix = prefix + jvmName + '/';
1:41dfb84:                 if ((!jvmName.equals("j9_13")) && (iminor  > 1))
1:41dfb84:                 {
1:41dfb84:                     for (int i = iminor; i > 1; i--)
1:41dfb84:                     {
1:41dfb84:                         if (master == null) 
1:41dfb84:                         {
1:41dfb84:                             newprefix = prefix + "j9_2" + i + '/'; 
1:41dfb84:                             getmaster(newprefix);
1:41dfb84:                         }
1:41dfb84:                     }
1:41dfb84:                 }
1:41dfb84:                 if (master == null) newprefix = prefix + "j9_13" + '/';
1:41dfb84:             }
1:0bbfdac: 	    if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
1:67614ad: 	    if (master == null) getmaster(newprefix);
1:67614ad: 	    
1:67614ad: 	}
1:67614ad: 	for (int i = iminor; i >= 2; i--)
1:67614ad: 	{
1:67614ad: 	    if (jvmName.startsWith("ibm"))
1:67614ad:             {
1:67614ad: 		newprefix = prefix + "ibm1" + i + '/';
1:0bbfdac: 		if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
1:67614ad: 		if (master == null) getmaster(newprefix);
1:67614ad: 	    }
1:67614ad: 	    newprefix = prefix + "jdk1" + i + '/';
1:0bbfdac: 	    if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
1:67614ad: 	    if (master == null) getmaster(newprefix);
1:67614ad:         } 
1:67614ad:     }
1:67614ad: 
1:67614ad:     private void searchFramework(String prefix)
1:67614ad:     {
1:67614ad:         String newprefix;
1:67614ad: 	newprefix = prefix + framework + '/';
1:67614ad: 	if (master == null) searchJvm(newprefix);
1:0bbfdac: 	if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
1:67614ad: 	if (master == null) getmaster(newprefix);
1:67614ad:     }
1:67614ad: 
1:0bbfdac:     private void searchDriverVersion(String prefix)
1:67614ad:     {
1:0bbfdac: 	// It is not sufficient to simply search the current driver version. 
1:0bbfdac: 	// We must search down through the versions to find the newest applicable master. 
1:67614ad:         
1:67614ad: 	String newprefix;
1:67614ad: 	
1:0bbfdac: 	for (int j = ((driverVersionMajor * 10) + driverVersionMinor); j >= 10; j--)
1:67614ad: 	{
1:0bbfdac:             newprefix = prefix + "ver" + j / 10 + "." + j % 10 + '/';
1:67614ad: 	    if (master == null) getmaster(newprefix); 
1:67614ad:         }
1:67614ad:     }
1:67614ad: 
1:67614ad:     private void getmaster(String prefix)
1:67614ad:     {
1:67614ad:         String fullname = prefix + testBase + ".out";
1:67614ad:         master = RunTest.loadTestResource(fullname);
1:67614ad:         if (master != null)
1:67614ad:             if (verbose) System.out.println("MasterFileName = "+fullname);
1:67614ad:     }
1:67614ad: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:         Object o = c.getConstructor().newInstance();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Class<?> c = Class.forName(NetServer.getDriverName(framework));
0:         Object o = c.newInstance();
1:         driverVersionMajor = (Integer) c.getMethod("getMajorVersion").invoke(o);
1:         driverVersionMinor = (Integer) c.getMethod("getMinorVersion").invoke(o);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:31cc815
/////////////////////////////////////////////////////////////////////////
1: 	// BUT, if it's j9, unless j9dee, first j9_foundation, then search j9_22 for 22, otherwise, j9_13 then
1: 	if ((jvmName.startsWith("j9") || (serverJvm != null && serverJvm.startsWith("j9")))
1:             && (!jvmName.startsWith("j9dee")))
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:1edcdb3
/////////////////////////////////////////////////////////////////////////
1: 		}	
1:         else 
1:         {
1:             // read in in fixed format, but write out relying on default encoding
1:             File EncodedOutFile = new File(outDir, testBase + ".tmpmstr");
1:             BufferedReader inFile = new BufferedReader(new InputStreamReader(is, "UTF-8"));
1:             
1:             PrintWriter pw = new PrintWriter
1:             ( new BufferedWriter(new FileWriter(EncodedOutFile), 10000), true );
1:             int c;
1:             while ((c = inFile.read()) != -1)
1:                 pw.write(c);
1:             pw.flush();
1:             pw.close();
1:             is = new FileInputStream(EncodedOutFile);
1:         }	
commit:41dfb84
/////////////////////////////////////////////////////////////////////////
0: 	// BUT, if it's j9, first j9_foundation, then search j9_22 for 22, otherwise, j9_13 then
1: 	// the normal ibm13 search pattern: ibm13 then jdk13.
/////////////////////////////////////////////////////////////////////////
1: 	    else
1:             {
1:                 newprefix = prefix + jvmName + '/';
1:                 if ((!jvmName.equals("j9_13")) && (iminor  > 1))
1:                 {
1:                     for (int i = iminor; i > 1; i--)
1:                     {
1:                         if (master == null) 
1:                         {
1:                             newprefix = prefix + "j9_2" + i + '/'; 
1:                             getmaster(newprefix);
1:                         }
1:                     }
1:                 }
1:                 if (master == null) newprefix = prefix + "j9_13" + '/';
1:             }
commit:67614ad
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.harness
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.harness;
1: 
1: /***
1:  * FileCompare.java
1:  *
1:  * Compare two files using SimpleDiff
1:  * Purpose: simulate diff
1:  * Note: if usesysdiff=true, we execute the system's diff
1:  ***/
1: 
1: import java.io.*;
0: import java.lang.reflect.*;
1: import java.util.StringTokenizer;
1: import java.util.Properties;
1: 
1: public class FileCompare
1: { 
0: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
1:     private String testBase;
1:     private String framework;
1:     private String jvmName;
1:     private String jvmString;
1:     private String serverJvm;
1:     private int iminor;
1:     private boolean searchJdk12 = false;
1:     private boolean searchJdk13 = false;
1:     private boolean searchJdk14 = false;
0:     private int jccMajor = 0;
0:     private int jccMinor = 0;
1:     private boolean searchFrame;
0:     private boolean searchJCC;
1:     private InputStream master = null;
1:     private boolean verbose;
1:     
1:     public FileCompare()
1:     {
1:       verbose = Boolean.getBoolean("verbose");
1:     }
1: 
1:     // The arguments should be the names of the input and output files
1:     public boolean exec(String outfile, File outDir, PrintWriter pwDiff,
1:         String testBaseOrig, String framework, String jvmName,
1:         int iminor, boolean useprocess, boolean usesysdiff, 
1:         String canondir, String canonpath, String serverJvm)
1:         throws IOException, ClassNotFoundException
1:     {
1:         testBase = testBaseOrig;
1:         this.framework = framework;
1:         this.jvmName = jvmName;
1:         this.iminor = iminor;
1:         this.jvmString = jvmName;
1:         this.serverJvm = serverJvm;
1: 
1:         BufferedReader outFile;
1:         BufferedReader masterFile;
1:         StringBuffer sb = new StringBuffer();
1:  
1:         // If framework is DerbyNet, we may need to check subdirs of the master canon dir
0:         // for specific masters by version of JCC we're running against. So, get JCC version
1:         // for later use if that is the case.
0:         if (framework.equals("DerbyNet"))
1:         {
0: 	  Class c = null;
0: 	  Method m = null;
0: 	  Object o = null;
0: 	  Integer i = null;
1: 	  try	
1: 	  {
0: 	    c = Class.forName("com.ibm.db2.jcc.DB2Driver");
0: 	    o = c.newInstance();
0: 	    m = c.getMethod("getMajorVersion", null);
0: 	    i = (Integer)m.invoke(o, null);
0: 	    jccMajor = i.intValue();
0: 	    m = c.getMethod("getMinorVersion", null);
0: 	    i = (Integer)m.invoke(o, null);
0: 	    jccMinor = i.intValue();
0:             if (framework.equals("DerbyNet")) searchJCC = true;
1: 	  } catch ( Exception e )
1: 	  {
0: 	    //if anything goes wrong, make sure the JCC version values are set to zero
1: 	    //forget about it.
0: 	   jccMinor = 0;
0: 	   jccMajor = 0;
0:            searchJCC = false;
1:  	  }
1:         }
1:         
1: 
1:         // The outfile name is known -- outfile
1:         // But the master canon needs to be located
1:         // The user can set canondir (or it defaults to "master")
1:         String topdir = "";
1:         if ( (canondir != null) && (canondir.length()>0) )
1:             topdir = canondir;
1:         else {
1: 			// if this is using product jars, use product_master first
1: 			Class c = FileCompare.class; // get our class loader
1: 			InputStream is = c.getResourceAsStream("/org/apache/derby/info/DBMS.properties");
1: 			Properties dbprop = new Properties();
1: 			dbprop.load(is);
1: 			is.close();
1: 
1: 			String filename=dbprop.getProperty("derby.product.file");
1: 			if (filename != null) {
1: 				//looks like it might be one of our jars?
1: 				if (filename.startsWith("derby") && filename.endsWith(".jar")) {
1: 					canondir = "product_master"; // remember redirection
1:                     topdir = "product_master";
1: 				}
1: 				else
1:                     topdir = "master";
1: 			}
1: 			else
1:                 topdir = "master";
1: 		}
1: 
1:         // There can be subdirs under the master for framework, jvm
1:         String subdir = "";
1:         boolean searchDefault = true; // if no framework or special jvm
1:         boolean searchBoth = false;
1:         boolean searchJvm = false;
1:         if ( (framework != null) && (framework.length()>0) )
1:         {
1:             searchFrame = true;
1:             subdir = framework;
1:         }
1:         if ( (jvmName != null) && (jvmName.length()>0)
1:                 & (!jvmName.equals("currentjvm")) )
1:         {
1:             searchJvm = true;
1:             if (searchFrame)
1:                 searchBoth = true;
1:             if ( iminor >= 2 ) // jdk12 or higher may use jdk12 masters
1:                 jvmString = "jdk12";
1: 	    if ( iminor >= 2 ) searchJdk12 = true;
1:             if ( iminor >= 3 ) searchJdk13 = true;
1:             if ( iminor >= 4 ) searchJdk14 = true;
1:             subdir += jvmName;
1:         }
1: 
1:         if ( searchFrame || searchJvm || searchBoth )
1:             searchDefault = false;
1:        
1:         sb.append(topdir);
1:         if (subdir.length()>0)
1:             sb.append(subdir + '/');
1:         sb.append(testBase + ".out");
1:         String masterfilename = sb.toString();
1: 	
1: 	InputStream is = null;
1:         
1:         // Now try to locate the master file
1: 	
1:         if (is == null)
1: 	{
1: 	  searchCanondir(topdir);
1: 	  is = master;
1: 	}
1:                 
0:         // If the master is still not found, print an error and return
1:         if ( is == null )
1:         {
0:             System.out.println("No master file was found.");
0:             pwDiff.println("No master file was found.");
1:             pwDiff.flush();
1:             return true;
1:         }
1: 		// compress blanks in output columns to make up for column width differences
1: 		// for JCC output
0: 		if (NetServer.isJCCConnection(framework))
1: 		{
1:             try
1:             {
1: 		        Sed sed = new Sed();
1: 				File JCCOutFile = new File(outDir, testBase + ".tmpmstr");
1: 		        sed.execJCC(is, JCCOutFile);
1: 				is = new FileInputStream(JCCOutFile);
1: 		    }
1: 		    catch (ClassFormatError cfe)
1: 		    {
1: 		        System.out.println("SED Error: " + cfe.getMessage());
1: 		    }
1: 		}
1:         
1:         // Define the input and output files
1:         outFile = new BufferedReader(new FileReader(outfile));
1:         masterFile = new BufferedReader(new InputStreamReader(is));
1:         
1:         // Do the comparison (diff)
1:         if (usesysdiff == true)
1:             return doSysDiff(is, testBase, outfile, outDir, pwDiff);
1:         else
1:         {
1:             return doDiff2(outFile,masterFile, pwDiff);
1:         }
1:     }
1: 
1:     public boolean doDiff2(BufferedReader outFile, BufferedReader masterFile, PrintWriter pwDiff) throws IOException {
1: 		return ((new SimpleDiff()).doWork(masterFile,outFile,pwDiff));
1:     }
1: 
1:     public boolean doSysDiff(InputStream masterIS, String testBase, String outfile,
1:         File outDir, PrintWriter pwDiff)
1:         throws IOException
1:     {
1:         // Create a temp file to copy the master (located as an InputStream)
1:         BufferedReader in =
1:             new BufferedReader(new InputStreamReader(masterIS));
1:         File tempMaster =
1:             new File((new File(outDir,testBase + ".master")).getCanonicalPath());
1: 
1:         // Create a PrintWriter for copying the master temporarily for the diff
1:         PrintWriter pwMaster = new PrintWriter( new BufferedWriter
1:             (new FileWriter(tempMaster.getPath()), 10000), true );
1:         String str = "";
1:         while ( (str = in.readLine()) != null )
1:         {
1:             pwMaster.println(str);
1:         }
1:         pwMaster.close();
1:         pwMaster = null;
1:         in = null;
1: 
1:         String diffs = "0";
1:         // Now create a process and do the system diff, capture to .out
1:         Process pr = null;
1:         try
1:         {
1:             StringBuffer sb = new StringBuffer();
1:             sb.append("diff ");
1:             sb.append(tempMaster.getCanonicalPath());
1:             sb.append(" ");
1:             sb.append(outfile);
1:             String diffCmd = sb.toString();
1: 
1:             //System.out.println("diffCmd = " + diffCmd);
1: 
1:             pr = Runtime.getRuntime().exec(diffCmd);
1: 
1:             // We need the process inputstream to capture into the diff file
1:             //System.out.println("Capture the process InputStream...");
1:             BackgroundStreamDrainer stdout =
1:                 new BackgroundStreamDrainer(pr.getInputStream(), null);
1:             BackgroundStreamDrainer stderr =
1:                 new BackgroundStreamDrainer(pr.getErrorStream(), null);
1: 
1:             pr.waitFor();
1:             String result = HandleResult.handleResult(pr.exitValue(),
1:                 stdout.getData(), stderr.getData(), pwDiff);
1:             diffs = result.substring( result.lastIndexOf(',')+1 );
1:             //System.out.println("diffs: " + diffs);
1:             pr.destroy();
1:             pr = null;
1:         }
1:         catch(Throwable t)
1:         {
1:             System.out.println("Process exception: " + t);
1:             if (pr != null)
1:             {
1:                 pr.destroy();
1:                 pr = null;
1:             }
1:         }
1:         tempMaster.delete();
1:         if ( diffs.equals("0") )
1:             return false;
1:         else
1:             return true;
1:     }
1: 
1:     public boolean doDiff(BufferedReader outFile, BufferedReader masterFile, PrintWriter pwDiff) throws IOException {
1:         String str1;
1:         String str2;
1:         boolean diff = false;
1: 
1:         int line = 0;
1:         int diffnum = 0;
1:         int diffline = 0;
1:         while ( (str1 = outFile.readLine()) != null )
1:         {
1:             line++;
1:             str1 = str1.trim();
1:             //System.out.println("Reading line: " + line);
1:             // Read the line from the master file and compare
1:             if ( (str2 = masterFile.readLine()) != null )
1:             {
1:                 str2 = str2.trim();
1:                 if (!str1.equals(str2))
1:                 {
1:                     // Some lines diff because of too many spaces
1:                     StringBuffer sb1 = new StringBuffer();
1:                     StringBuffer sb2 = new StringBuffer();
1:                     StringTokenizer st1 = new StringTokenizer(str1);
1:                     while (st1.hasMoreTokens())
1:                     {
1:                         sb1.append(st1.nextToken());
1:                     }
1:                     //System.out.println("Out line: " + sb1.toString());
1: 
1:                     StringTokenizer st2 = new StringTokenizer(str2);
1:                     while (st2.hasMoreTokens())
1:                     {
1:                         sb2.append(st2.nextToken());
1:                     }
1:                     //System.out.println("Master line: " + sb2.toString());
1: 
1:                     if ( sb1.toString().equals(sb2.toString()) )
1:                         diff = false;
1:                     // If the two lines are dashes, but wrong #, just ignore
1:                     else if ( (str1.startsWith("-----")) && (str1.endsWith("-----")) )
1:                     {
1:                         if ( (str2.startsWith("-----")) && (str2.endsWith("-----")) )
1:                             diff = false;
1:                     }
1:                     else
1:                     {
1:                         diff = true;
1:                         diffnum++;
1:                         System.out.println("Diff occurred at line: " + line);
1:                         pwDiff.println("Diff occurred  at line: " + line);
1:                         pwDiff.flush();
1:                         break;
1:                     }
1:                 }
1:                 else
1:                 {
1:                     diff = false;
1:                 }
1:             }
1:         } // end while
1:         outFile.close();
1:         masterFile.close();
1:         return diff;
1:     }// end exec
1: 
1:     private void searchCanondir(String canondir)
1:     {
1: 	String prefix = canondir + '/';
1: 	if (master == null && searchFrame) searchFramework(prefix);
1:         if (master == null) searchJvm(prefix);
0: 	if (master == null && searchJCC) searchJCCVersion(prefix);
1: 	if (master == null) getmaster(prefix);
1: 	if (master == null && canondir != "master") searchCanondir("master");
1:     }
1: 
1:     private void searchJvm(String prefix)
1:     {
1: 	// The JVM search follows the following pattern, with one exception:
1: 	// first search jvmName (to support unnamed/non-IBM or Sun JVMs)
1: 	// if vendor == IBM, search ibm+rev then jdk+rev, decrementing rev by one until rev=13,
0: 	// in each dir, search framework and jcc version if applicable.
0: 	// BUT, if it's j9, search j9_foundation then j9_13 if j9_foundation, or j9_13 for j9_13, then 	       // the normal ibm13 search pattern: ibm13 then jdk13.
1: 
1: 	String newprefix;
0: 	if (jvmName.startsWith("j9") || (serverJvm != null && serverJvm.startsWith("j9")))
1: 	{
1: 	    if (jvmName.startsWith("j9_foundation"))
1:             {
1:                 newprefix = prefix + "j9_foundation" + '/';
0: 		if (master == null && searchJCC) searchJCCVersion(newprefix);
1: 		if (master == null) getmaster(newprefix);
1:             }
0:             newprefix = prefix + "j9_13" + '/';
0: 	    if (master == null && searchJCC) searchJCCVersion(newprefix);
1: 	    if (master == null) getmaster(newprefix);
1: 	    
1: 	}
1: 	for (int i = iminor; i >= 2; i--)
1: 	{
1: 	    if (jvmName.startsWith("ibm"))
1:             {
1: 		newprefix = prefix + "ibm1" + i + '/';
0: 		if (master == null && searchJCC) searchJCCVersion(newprefix);
1: 		if (master == null) getmaster(newprefix);
1: 	    }
1: 	    newprefix = prefix + "jdk1" + i + '/';
0: 	    if (master == null && searchJCC) searchJCCVersion(newprefix);
1: 	    if (master == null) getmaster(newprefix);
1:         } 
1:     }
1: 
1:     private void searchFramework(String prefix)
1:     {
1:         String newprefix;
1: 	newprefix = prefix + framework + '/';
1: 	if (master == null) searchJvm(newprefix);
0: 	if (master == null && searchJCC) searchJCCVersion(newprefix);
1: 	if (master == null) getmaster(newprefix);
1:     }
1: 
0:     private void searchJCCVersion(String prefix)
1:     {
0: 	// It is not sufficient to simply search the current JCC version. 
0: 	// We must search down through the JCC versions to find the newest applicable master. 
1:         
1: 	String newprefix;
1: 	
0: 	for (int j = ((jccMajor * 10) + jccMinor); j >= 10; j--)
1: 	{
0:             newprefix = prefix + "jcc" + j / 10 + "." + j % 10 + '/';
1: 	    if (master == null) getmaster(newprefix); 
1:         }
1:     }
1: 
1:     private void getmaster(String prefix)
1:     {
1:         String fullname = prefix + testBase + ".out";
1:         master = RunTest.loadTestResource(fullname);
1:         if (master != null)
1:             if (verbose) System.out.println("MasterFileName = "+fullname);
1:     }
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:4087714
/////////////////////////////////////////////////////////////////////////
1:         // If the master is still not found, create an empty master
1: 			is = new ByteArrayInputStream( new byte[] {} );
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:0bbfdac
/////////////////////////////////////////////////////////////////////////
1:     private int driverVersionMajor = 0;
1:     private int driverVersionMinor = 0;
1:     private boolean searchDriverVersion;
/////////////////////////////////////////////////////////////////////////
1:         // for specific masters by client  we're running against. So, get version
1:         if (framework.startsWith("DerbyNet"))
/////////////////////////////////////////////////////////////////////////
0: 	    c = Class.forName(NetServer.getDriverName(framework));
0: 	    driverVersionMajor = i.intValue();
0: 	    driverVersionMinor = i.intValue();
1:             if (framework.startsWith("DerbyNet")) searchDriverVersion = true;
1: 	    //if anything goes wrong, make sure the driver version values are set to zero
1: 		  
1: 		  System.out.println("Cannot determine driver version:" + e);
1: 		  driverVersionMinor = 0;
1: 		  driverVersionMajor = 0;
1: 		  searchDriverVersion = false;
/////////////////////////////////////////////////////////////////////////
1: 		if (NetServer.isClientConnection(framework))
/////////////////////////////////////////////////////////////////////////
1: 	if (master == null && searchDriverVersion) searchDriverVersion(prefix);
/////////////////////////////////////////////////////////////////////////
1: 	// in each dir, search framework and driver version if applicable.
/////////////////////////////////////////////////////////////////////////
1: 		if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
1: 	    if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
/////////////////////////////////////////////////////////////////////////
1: 		if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
1: 	    if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
/////////////////////////////////////////////////////////////////////////
1: 	if (master == null && searchDriverVersion) searchDriverVersion(newprefix);
1:     private void searchDriverVersion(String prefix)
1: 	// It is not sufficient to simply search the current driver version. 
1: 	// We must search down through the versions to find the newest applicable master. 
1: 	for (int j = ((driverVersionMajor * 10) + driverVersionMinor); j >= 10; j--)
1:             newprefix = prefix + "ver" + j / 10 + "." + j % 10 + '/';
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
0: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.harness.FileCompare
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0:  */
1: 
0: package org.apache.derbyTesting.functionTests.harness;
1: 
0: /***
0:  * FileCompare.java
0:  *
0:  * Compare two files using SimpleDiff
0:  * Purpose: simulate diff
0:  * Note: if usesysdiff=true, we execute the system's diff
0:  ***/
1: 
0: import java.io.*;
0: import java.lang.reflect.*;
0: import java.util.StringTokenizer;
0: import java.util.Properties;
1: 
0: public class FileCompare
0: {
1: 
0:     private String testBase;
0:     private String framework;
0:     private String jvmName;
0:     private String jvmString;
0:     private String serverJvm;
0:     private int iminor;
0:     private boolean searchJdk12 = false;
0:     private boolean searchJdk13 = false;
0:     private boolean searchJdk14 = false;
0:     private int jccMajor = 0;
0:     private int jccMinor = 0;
0:     private boolean searchFrame;
0:     private boolean searchJCC;
0:     private InputStream master = null;
0:     private boolean verbose;
1:     
0:     public FileCompare()
0:     {
0:       verbose = Boolean.getBoolean("verbose");
0:     }
1: 
0:     // The arguments should be the names of the input and output files
0:     public boolean exec(String outfile, File outDir, PrintWriter pwDiff,
0:         String testBaseOrig, String framework, String jvmName,
0:         int iminor, boolean useprocess, boolean usesysdiff, 
0:         String canondir, String canonpath, String serverJvm)
0:         throws IOException, ClassNotFoundException
0:     {
0:         testBase = testBaseOrig;
0:         this.framework = framework;
0:         this.jvmName = jvmName;
0:         this.iminor = iminor;
0:         this.jvmString = jvmName;
0:         this.serverJvm = serverJvm;
1: 
0:         BufferedReader outFile;
0:         BufferedReader masterFile;
0:         StringBuffer sb = new StringBuffer();
1:  
0:         // If framework is DerbyNet, we may need to check subdirs of the master canon dir
0:         // for specific masters by version of JCC we're running against. So, get JCC version
0:         // for later use if that is the case.
0:         if (framework.equals("DerbyNet"))
0:         {
0: 	  Class c = null;
0: 	  Method m = null;
0: 	  Object o = null;
0: 	  Integer i = null;
0: 	  try	
0: 	  {
0: 	    c = Class.forName("com.ibm.db2.jcc.DB2Driver");
0: 	    o = c.newInstance();
0: 	    m = c.getMethod("getMajorVersion", null);
0: 	    i = (Integer)m.invoke(o, null);
0: 	    jccMajor = i.intValue();
0: 	    m = c.getMethod("getMinorVersion", null);
0: 	    i = (Integer)m.invoke(o, null);
0: 	    jccMinor = i.intValue();
0:             if (framework.equals("DerbyNet")) searchJCC = true;
0: 	  } catch ( Exception e )
0: 	  {
0: 	    //if anything goes wrong, make sure the JCC version values are set to zero
0: 	    //forget about it.
0: 	   jccMinor = 0;
0: 	   jccMajor = 0;
0:            searchJCC = false;
0:  	  }
0:         }
1:         
1: 
0:         // The outfile name is known -- outfile
0:         // But the master canon needs to be located
0:         // The user can set canondir (or it defaults to "master")
0:         String topdir = "";
0:         if ( (canondir != null) && (canondir.length()>0) )
0:             topdir = canondir;
0:         else {
0: 			// if this is using product jars, use product_master first
0: 			Class c = FileCompare.class; // get our class loader
0: 			InputStream is = c.getResourceAsStream("/org/apache/derby/info/DBMS.properties");
0: 			Properties dbprop = new Properties();
0: 			dbprop.load(is);
0: 			is.close();
1: 
0: 			String filename=dbprop.getProperty("derby.product.file");
0: 			if (filename != null) {
0: 				//looks like it might be one of our jars?
0: 				if (filename.startsWith("derby") && filename.endsWith(".jar")) {
0: 					canondir = "product_master"; // remember redirection
0:                     topdir = "product_master";
0: 				}
0: 				else
0:                     topdir = "master";
0: 			}
0: 			else
0:                 topdir = "master";
0: 		}
1: 
0:         // There can be subdirs under the master for framework, jvm
0:         String subdir = "";
0:         boolean searchDefault = true; // if no framework or special jvm
0:         boolean searchBoth = false;
0:         boolean searchJvm = false;
0:         if ( (framework != null) && (framework.length()>0) )
0:         {
0:             searchFrame = true;
0:             subdir = framework;
0:         }
0:         if ( (jvmName != null) && (jvmName.length()>0)
0:                 & (!jvmName.equals("currentjvm")) )
0:         {
0:             searchJvm = true;
0:             if (searchFrame)
0:                 searchBoth = true;
0:             if ( iminor >= 2 ) // jdk12 or higher may use jdk12 masters
0:                 jvmString = "jdk12";
0: 	    if ( iminor >= 2 ) searchJdk12 = true;
0:             if ( iminor >= 3 ) searchJdk13 = true;
0:             if ( iminor >= 4 ) searchJdk14 = true;
0:             subdir += jvmName;
0:         }
1: 
0:         if ( searchFrame || searchJvm || searchBoth )
0:             searchDefault = false;
1:        
0:         sb.append(topdir);
0:         if (subdir.length()>0)
0:             sb.append(subdir + '/');
0:         sb.append(testBase + ".out");
0:         String masterfilename = sb.toString();
1: 	
0: 	InputStream is = null;
1:         
0:         // Now try to locate the master file
1: 	
0:         if (is == null)
0: 	{
0: 	  searchCanondir(topdir);
0: 	  is = master;
0: 	}
1:                 
0:         // If the master is still not found, print an error and return
0:         if ( is == null )
0:         {
0:             System.out.println("No master file was found.");
0:             pwDiff.println("No master file was found.");
0:             pwDiff.flush();
0:             return true;
0:         }
0: 		// compress blanks in output columns to make up for column width differences
0: 		// for JCC output
0: 		if (NetServer.isJCCConnection(framework))
0: 		{
0:             try
0:             {
0: 		        Sed sed = new Sed();
0: 				File JCCOutFile = new File(outDir, testBase + ".tmpmstr");
0: 		        sed.execJCC(is, JCCOutFile);
0: 				is = new FileInputStream(JCCOutFile);
0: 		    }
0: 		    catch (ClassFormatError cfe)
0: 		    {
0: 		        System.out.println("SED Error: " + cfe.getMessage());
0: 		    }
0: 		}
1:         
0:         // Define the input and output files
0:         outFile = new BufferedReader(new FileReader(outfile));
0:         masterFile = new BufferedReader(new InputStreamReader(is));
1:         
0:         // Do the comparison (diff)
0:         if (usesysdiff == true)
0:             return doSysDiff(is, testBase, outfile, outDir, pwDiff);
0:         else
0:         {
0:             return doDiff2(outFile,masterFile, pwDiff);
0:         }
0:     }
1: 
0:     public boolean doDiff2(BufferedReader outFile, BufferedReader masterFile, PrintWriter pwDiff) throws IOException {
0: 		return ((new SimpleDiff()).doWork(masterFile,outFile,pwDiff));
0:     }
1: 
0:     public boolean doSysDiff(InputStream masterIS, String testBase, String outfile,
0:         File outDir, PrintWriter pwDiff)
0:         throws IOException
0:     {
0:         // Create a temp file to copy the master (located as an InputStream)
0:         BufferedReader in =
0:             new BufferedReader(new InputStreamReader(masterIS));
0:         File tempMaster =
0:             new File((new File(outDir,testBase + ".master")).getCanonicalPath());
1: 
0:         // Create a PrintWriter for copying the master temporarily for the diff
0:         PrintWriter pwMaster = new PrintWriter( new BufferedWriter
0:             (new FileWriter(tempMaster.getPath()), 10000), true );
0:         String str = "";
0:         while ( (str = in.readLine()) != null )
0:         {
0:             pwMaster.println(str);
0:         }
0:         pwMaster.close();
0:         pwMaster = null;
0:         in = null;
1: 
0:         String diffs = "0";
0:         // Now create a process and do the system diff, capture to .out
0:         Process pr = null;
0:         try
0:         {
0:             StringBuffer sb = new StringBuffer();
0:             sb.append("diff ");
0:             sb.append(tempMaster.getCanonicalPath());
0:             sb.append(" ");
0:             sb.append(outfile);
0:             String diffCmd = sb.toString();
1: 
0:             //System.out.println("diffCmd = " + diffCmd);
1: 
0:             pr = Runtime.getRuntime().exec(diffCmd);
1: 
0:             // We need the process inputstream to capture into the diff file
0:             //System.out.println("Capture the process InputStream...");
0:             BackgroundStreamDrainer stdout =
0:                 new BackgroundStreamDrainer(pr.getInputStream(), null);
0:             BackgroundStreamDrainer stderr =
0:                 new BackgroundStreamDrainer(pr.getErrorStream(), null);
1: 
0:             pr.waitFor();
0:             String result = HandleResult.handleResult(pr.exitValue(),
0:                 stdout.getData(), stderr.getData(), pwDiff);
0:             diffs = result.substring( result.lastIndexOf(',')+1 );
0:             //System.out.println("diffs: " + diffs);
0:             pr.destroy();
0:             pr = null;
0:         }
0:         catch(Throwable t)
0:         {
0:             System.out.println("Process exception: " + t);
0:             if (pr != null)
0:             {
0:                 pr.destroy();
0:                 pr = null;
0:             }
0:         }
0:         tempMaster.delete();
0:         if ( diffs.equals("0") )
0:             return false;
0:         else
0:             return true;
0:     }
1: 
0:     public boolean doDiff(BufferedReader outFile, BufferedReader masterFile, PrintWriter pwDiff) throws IOException {
0:         String str1;
0:         String str2;
0:         boolean diff = false;
1: 
0:         int line = 0;
0:         int diffnum = 0;
0:         int diffline = 0;
0:         while ( (str1 = outFile.readLine()) != null )
0:         {
0:             line++;
0:             str1 = str1.trim();
0:             //System.out.println("Reading line: " + line);
0:             // Read the line from the master file and compare
0:             if ( (str2 = masterFile.readLine()) != null )
0:             {
0:                 str2 = str2.trim();
0:                 if (!str1.equals(str2))
0:                 {
0:                     // Some lines diff because of too many spaces
0:                     StringBuffer sb1 = new StringBuffer();
0:                     StringBuffer sb2 = new StringBuffer();
0:                     StringTokenizer st1 = new StringTokenizer(str1);
0:                     while (st1.hasMoreTokens())
0:                     {
0:                         sb1.append(st1.nextToken());
0:                     }
0:                     //System.out.println("Out line: " + sb1.toString());
1: 
0:                     StringTokenizer st2 = new StringTokenizer(str2);
0:                     while (st2.hasMoreTokens())
0:                     {
0:                         sb2.append(st2.nextToken());
0:                     }
0:                     //System.out.println("Master line: " + sb2.toString());
1: 
0:                     if ( sb1.toString().equals(sb2.toString()) )
0:                         diff = false;
0:                     // If the two lines are dashes, but wrong #, just ignore
0:                     else if ( (str1.startsWith("-----")) && (str1.endsWith("-----")) )
0:                     {
0:                         if ( (str2.startsWith("-----")) && (str2.endsWith("-----")) )
0:                             diff = false;
0:                     }
0:                     else
0:                     {
0:                         diff = true;
0:                         diffnum++;
0:                         System.out.println("Diff occurred at line: " + line);
0:                         pwDiff.println("Diff occurred  at line: " + line);
0:                         pwDiff.flush();
0:                         break;
0:                     }
0:                 }
0:                 else
0:                 {
0:                     diff = false;
0:                 }
0:             }
0:         } // end while
0:         outFile.close();
0:         masterFile.close();
0:         return diff;
0:     }// end exec
1: 
0:     private void searchCanondir(String canondir)
0:     {
0: 	String prefix = canondir + '/';
0: 	if (master == null && searchFrame) searchFramework(prefix);
0:         if (master == null) searchJvm(prefix);
0: 	if (master == null && searchJCC) searchJCCVersion(prefix);
0: 	if (master == null) getmaster(prefix);
0: 	if (master == null && canondir != "master") searchCanondir("master");
0:     }
1: 
0:     private void searchJvm(String prefix)
0:     {
0: 	// The JVM search follows the following pattern, with one exception:
0: 	// first search jvmName (to support unnamed/non-IBM or Sun JVMs)
0: 	// if vendor == IBM, search ibm+rev then jdk+rev, decrementing rev by one until rev=13,
0: 	// in each dir, search framework and jcc version if applicable.
0: 	// BUT, if it's j9, search j9_foundation then j9_13 if j9_foundation, or j9_13 for j9_13, then 	       // the normal ibm13 search pattern: ibm13 then jdk13.
1: 
0: 	String newprefix;
0: 	if (jvmName.startsWith("j9") || (serverJvm != null && serverJvm.startsWith("j9")))
0: 	{
0: 	    if (jvmName.startsWith("j9_foundation"))
0:             {
0:                 newprefix = prefix + "j9_foundation" + '/';
0: 		if (master == null && searchJCC) searchJCCVersion(newprefix);
0: 		if (master == null) getmaster(newprefix);
0:             }
0:             newprefix = prefix + "j9_13" + '/';
0: 	    if (master == null && searchJCC) searchJCCVersion(newprefix);
0: 	    if (master == null) getmaster(newprefix);
1: 	    
0: 	}
0: 	for (int i = iminor; i >= 2; i--)
0: 	{
0: 	    if (jvmName.startsWith("ibm"))
0:             {
0: 		newprefix = prefix + "ibm1" + i + '/';
0: 		if (master == null && searchJCC) searchJCCVersion(newprefix);
0: 		if (master == null) getmaster(newprefix);
0: 	    }
0: 	    newprefix = prefix + "jdk1" + i + '/';
0: 	    if (master == null && searchJCC) searchJCCVersion(newprefix);
0: 	    if (master == null) getmaster(newprefix);
0:         } 
0:     }
1: 
0:     private void searchFramework(String prefix)
0:     {
0:         String newprefix;
0: 	newprefix = prefix + framework + '/';
0: 	if (master == null) searchJvm(newprefix);
0: 	if (master == null && searchJCC) searchJCCVersion(newprefix);
0: 	if (master == null) getmaster(newprefix);
0:     }
1: 
0:     private void searchJCCVersion(String prefix)
0:     {
0: 	// It is not sufficient to simply search the current JCC version. 
0: 	// We must search down through the JCC versions to find the newest applicable master. 
1:         
0: 	String newprefix;
1: 	
0: 	for (int j = ((jccMajor * 10) + jccMinor); j >= 10; j--)
0: 	{
0:             newprefix = prefix + "jcc" + j / 10 + "." + j % 10 + '/';
0: 	    if (master == null) getmaster(newprefix); 
0:         }
0:     }
1: 
0:     private void getmaster(String prefix)
0:     {
0:         String fullname = prefix + testBase + ".out";
0:         master = RunTest.loadTestResource(fullname);
0:         if (master != null)
0:             if (verbose) System.out.println("MasterFileName = "+fullname);
0:     }
0: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.harness.FileCompare
0: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
0: {
============================================================================