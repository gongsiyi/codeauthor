1:e081c85: /*
1:e081c85: 
1:e081c85:    Derby - Class org.apache.derby.impl.tools.optional.ForeignDBViews
1:e081c85: 
1:e081c85:    Licensed to the Apache Software Foundation (ASF) under one or more
1:e081c85:    contributor license agreements.  See the NOTICE file distributed with
1:e081c85:    this work for additional information regarding copyright ownership.
1:e081c85:    The ASF licenses this file to You under the Apache License, Version 2.0
1:e081c85:    (the "License"); you may not use this file except in compliance with
1:e081c85:    the License.  You may obtain a copy of the License at
1:e081c85: 
1:e081c85:       http://www.apache.org/licenses/LICENSE-2.0
1:e081c85: 
1:e081c85:    Unless required by applicable law or agreed to in writing, software
1:e081c85:    distributed under the License is distributed on an "AS IS" BASIS,
1:e081c85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e081c85:    See the License for the specific language governing permissions and
1:e081c85:    limitations under the License.
1:e081c85: 
1:e081c85:  */
1:e081c85: 
1:e081c85: package org.apache.derby.impl.tools.optional;
1:e081c85: 
1:e081c85: import java.sql.Connection;
1:e081c85: import java.sql.DatabaseMetaData;
1:e081c85: import java.sql.DriverManager;
1:e081c85: import java.sql.PreparedStatement;
1:e081c85: import java.sql.ResultSet;
1:e081c85: import java.sql.SQLException;
1:e081c85: import java.sql.Types;
1:e081c85: import java.util.HashSet;
1:e081c85: 
1:e081c85: import org.apache.derby.iapi.sql.dictionary.OptionalTool;
1:e081c85: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1:e081c85: import org.apache.derby.iapi.util.IdUtil;
1:e081c85: import org.apache.derby.iapi.util.StringUtil;
1:b412f10: import org.apache.derby.vti.ForeignTableVTI;
1:e081c85: 
1:e081c85: /**
1:e081c85:  * <p>
1:e081c85:  * OptionalTool to create wrapper functions and views for all of the user tables
1:e081c85:  * in a foreign database.
1:e081c85:  * </p>
1:e081c85:  */
1:e081c85: public	class   ForeignDBViews  implements OptionalTool
1:e081c85: {
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85:     //
1:e081c85:     //	CONSTANTS
1:e081c85:     //
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85: 
1:e081c85:     private static  final   int XML_TYPE = 2009;    // needed if you aren't compiling against Java 6
1:e081c85: 
1:e081c85:     //
1:e081c85:     // It's ok to get these SQLStates when trying to drop an object on behalf
1:e081c85:     // of unloadTool(). The idea is to make unloadTool() idempotent.
1:e081c85:     //
1:e081c85:     private static  final   String[]    SAFE_DROP_SQLSTATES =
1:e081c85:     {
1:e081c85:         org.apache.derby.shared.common.reference.SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
1:e081c85:         org.apache.derby.shared.common.reference.SQLState.LANG_OBJECT_DOES_NOT_EXIST,
1:e081c85:         org.apache.derby.shared.common.reference.SQLState.LANG_SCHEMA_DOES_NOT_EXIST,
1:e081c85:     };
1:e081c85: 
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85:     //
1:e081c85:     //	STATE
1:e081c85:     //
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85: 
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85:     //
1:e081c85:     //	CONSTRUCTOR
1:e081c85:     //
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85: 
1:e081c85:     /** 0-arg constructor required by the OptionalTool contract */
1:e081c85:     public  ForeignDBViews() {}
1:e081c85: 
1:e081c85:     ///////////////////////////////////////////////////////////////////////////////////
1:e081c85:     //
1:e081c85:     // OptionalTool BEHAVIOR
1:e081c85:     //
1:e081c85:     ///////////////////////////////////////////////////////////////////////////////////
1:e081c85: 
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Creates a local Derby schema for every foreign schema which contains
1:e081c85:      * a user table. Then creates a table function and convenience view for every
1:e081c85:      * user table found in the foreign database. The parameters to this method are:
1:e081c85:      * </p>
1:e081c85:      *
1:e081c85:      * <ul>
1:e081c85:      * <li>foreignConnectionURL (required) - URL to connect to the foreign database</li>
1:e081c85:      * <li>schemaPrefix (optional) - If not specified, then the local Derby schema which is
1:e081c85:      * created has the same name as the foreign schema. Otherwise, this prefix is prepended
1:e081c85:      * to the names of the local Derby schemas which are created.</li>
1:e081c85:      * </ul>
1:e081c85:      */
1:e081c85:     public  void    loadTool( String... configurationParameters )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         if ( (configurationParameters == null) || (configurationParameters.length < 1) )
1:e081c85:         {
1:e081c85:             throw wrap( LocalizedResource.getMessage( "OT_BadLoadUnloadArgs" ) );
1:e081c85:         }
1:e081c85: 
1:e081c85:         String              foreignConnectionURL = configurationParameters[ 0 ];
1:e081c85:         String              schemaPrefix = (configurationParameters.length == 1) ? null : configurationParameters[ 1 ];
1:e081c85:         Connection          foreignConn = getForeignConnection( foreignConnectionURL );
1:e081c85:         Connection          derbyConn = getDerbyConnection();
1:e081c85:         DatabaseMetaData    foreignDBMD = foreignConn.getMetaData();
1:e081c85:         ResultSet           tableCursor = getForeignTables( foreignDBMD );
1:e081c85: 
1:e081c85:         while( tableCursor.next() )
1:e081c85:         {
1:e081c85:             registerForeignTable
1:e081c85:                 (
1:e081c85:                  foreignDBMD,
1:e081c85:                  tableCursor.getString( 2 ),
1:e081c85:                  tableCursor.getString( 3 ),
1:e081c85:                  foreignConnectionURL,
1:e081c85:                  schemaPrefix,
1:e081c85:                  derbyConn
1:e081c85:                  );
1:e081c85:         }
1:e081c85: 
1:e081c85:         tableCursor.close();
1:e081c85:         foreignConn.close();
1:e081c85:     }
1:e081c85: 
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Removes the schemas, table functions, and views created by loadTool().
1:e081c85:      * </p>
1:e081c85:      *
1:e081c85:      * <ul>
1:e081c85:      * <li>connectionURL (required) - URL to connect to the foreign database</li>
1:e081c85:      * <li>schemaPrefix (optional) - See loadTool() for more information on this argument.</li>
1:e081c85:      * </ul>
1:e081c85:      */
1:e081c85:     public  void    unloadTool( String... configurationParameters )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         if ( (configurationParameters == null) || (configurationParameters.length < 1) )
1:e081c85:         {
1:e081c85:             throw wrap( LocalizedResource.getMessage( "OT_BadLoadUnloadArgs" ) );
1:e081c85:         }
1:e081c85: 
1:e081c85:         String              foreignConnectionURL = configurationParameters[ 0 ];
1:e081c85:         String              schemaPrefix = (configurationParameters.length == 1) ? null : configurationParameters[ 1 ];
1:e081c85:         Connection          foreignConn = getForeignConnection( foreignConnectionURL );
1:e081c85:         Connection          derbyConn = getDerbyConnection();
1:e081c85:         DatabaseMetaData    foreignDBMD = foreignConn.getMetaData();
1:e081c85:         ResultSet           tableCursor = getForeignTables( foreignDBMD );
1:e081c85:         HashSet<String> schemas = new HashSet<String>();
1:e081c85: 
1:e081c85:         while( tableCursor.next() )
1:e081c85:         {
1:e081c85:             String          derbySchemaName = getDerbySchemaName( schemaPrefix, tableCursor.getString( 2 ) );
1:e081c85:             String          objectName = tableCursor.getString( 3 );
1:e081c85: 
1:e081c85:             if ( derbySchemaName != null ) { schemas.add( derbySchemaName ); }
1:e081c85:             
1:e081c85:             dropObject( derbyConn, derbySchemaName, objectName, "view", false );
1:e081c85:             dropObject( derbyConn, derbySchemaName, objectName, "function", false );
1:e081c85:         }
1:e081c85: 
1:e081c85:         tableCursor.close();
1:e081c85:         foreignConn.close();
1:e081c85: 
1:e081c85:         // now drop the schemas created by loadTool()
1:e081c85:         for ( String schemaName : schemas ) { dropDerbySchema( derbyConn, schemaName ); }
1:b412f10: 
1:b412f10:         // now drop the connection to the foreign database
1:b412f10:         ForeignTableVTI.dropConnection( foreignConnectionURL );
1:e081c85:     }
1:e081c85: 
1:e081c85:     ///////////////////////////////////////////////////////////////////////////////////
1:e081c85:     //
1:e081c85:     // REGISTRATION MINIONS
1:e081c85:     //
1:e081c85:     ///////////////////////////////////////////////////////////////////////////////////
1:e081c85: 
1:e081c85:     private void    registerForeignTable
1:e081c85:         (
1:e081c85:          DatabaseMetaData   foreignDBMD,
1:e081c85:          String             foreignSchemaName,
1:e081c85:          String             foreignTableName,
1:e081c85:          String             foreignConnectionURL,
1:e081c85:          String             schemaPrefix,
1:e081c85:          Connection     derbyConn
1:e081c85:         )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         //
1:e081c85:         // Create DDL string for registering the table function
1:e081c85:         //
1:e081c85:         StringBuilder       tfBuffer = new StringBuilder();
1:e081c85:         String              derbySchemaName = getDerbySchemaName( schemaPrefix, foreignSchemaName );
1:e081c85:         String              dotSchemaName = dotSeparatedSchemaName( derbySchemaName );
1:e081c85: 
1:e081c85:         createDerbySchema( derbyConn, derbySchemaName );
1:e081c85: 
1:e081c85:         tfBuffer.append( "create function " + dotSchemaName + delimitedID( foreignTableName ) );
1:e081c85:         tfBuffer.append( "\n(" );
1:e081c85:         tfBuffer.append( "\n\tforeignSchemaName varchar( 32672 )," );
1:e081c85:         tfBuffer.append( "\n\tforeignTableName varchar( 32672 )," );
1:e081c85:         tfBuffer.append( "\n\tconnectionURL varchar( 32672 )" );
1:e081c85:         tfBuffer.append( "\n)\nreturns table\n(" );
1:e081c85:         
1:e081c85:         ResultSet           columnCursor = foreignDBMD.getColumns( null, foreignSchemaName, foreignTableName, "%" );
1:e081c85:         int                 columnCount = 0;
1:e081c85:         while( columnCursor.next() )
1:e081c85:         {
1:e081c85:             tfBuffer.append( "\n\t" );
1:e081c85:             if ( columnCount > 0 ) { tfBuffer.append( ", " ); }
1:e081c85:             columnCount++;
1:e081c85: 
1:e081c85:             tfBuffer.append( delimitedID( columnCursor.getString( 4 ) ) );
1:e081c85:             tfBuffer.append( " " );
1:e081c85:             tfBuffer.append
1:e081c85:                 (
1:e081c85:                  mapType
1:e081c85:                  (
1:e081c85:                   columnCursor.getInt( 5 ),
1:e081c85:                   columnCursor.getInt( 7 ),
1:e081c85:                   columnCursor.getInt( 9 ),
1:e081c85:                   columnCursor.getString( 6 )
1:e081c85:                   )
1:e081c85:                  );
1:e081c85:         }
1:e081c85:         columnCursor.close();
1:e081c85: 
1:e081c85:         tfBuffer.append( "\n)" );
1:e081c85:         tfBuffer.append( "\nlanguage java parameter style derby_jdbc_result_set no sql" );
1:e081c85:         tfBuffer.append( "\nexternal name 'org.apache.derby.vti.ForeignTableVTI.readForeignTable'" );
1:e081c85: 
1:e081c85:         String          tfDDL = tfBuffer.toString();
1:e081c85:         
1:e081c85:         //
1:e081c85:         // Create DDL string for registering the view
1:e081c85:         //
1:e081c85:         StringBuilder   viewBuffer = new StringBuilder();
1:e081c85: 
1:e081c85:         viewBuffer.append( "create view " + dotSchemaName + delimitedID( foreignTableName ) );
1:e081c85:         viewBuffer.append( "\nas select *" );
1:e081c85:         viewBuffer.append( "\nfrom table" );
1:e081c85:         viewBuffer.append( "\n(\n" );
1:e081c85:         viewBuffer.append( "\t" + dotSchemaName + delimitedID( foreignTableName ) );
1:e081c85:         viewBuffer.append( "\n\t(" );
1:e081c85:         viewBuffer.append( "\n\t\t" + stringLiteral( foreignSchemaName ) + "," );
1:e081c85:         viewBuffer.append( "\n\t\t" + stringLiteral( foreignTableName ) + "," );
1:e081c85:         viewBuffer.append( "\n\t\t" + stringLiteral( foreignConnectionURL ) );
1:e081c85:         viewBuffer.append( "\n\t)" );
1:e081c85:         viewBuffer.append( "\n) s" );
1:e081c85: 
1:e081c85:         String          viewDDL = viewBuffer.toString();
1:e081c85: 
1:e081c85:         //
1:e081c85:         // Now create the table function and view.
1:e081c85:         //
1:e081c85:         executeDDL( derbyConn, tfDDL );
1:e081c85:         executeDDL( derbyConn, viewDDL );
1:e081c85:     }
1:e081c85: 
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Get a cursor through the user tables in the foreign database.
1:e081c85:      * </p>
1:e081c85:      */
1:e081c85:     private ResultSet   getForeignTables( DatabaseMetaData foreignDBMD )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         return foreignDBMD.getTables( null, null, "%", new String[] { "TABLE" } );
1:e081c85:     }
1:e081c85: 
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Create a Derby schema if it does not already exist.
1:e081c85:      * </p>
1:e081c85:      */
1:e081c85:     private void    createDerbySchema
1:e081c85:         (
1:e081c85:          Connection derbyConn,
1:e081c85:          String     derbySchemaName
1:e081c85:          )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         if ( derbySchemaName == null ) { return; }
1:e081c85:         
1:e081c85:         PreparedStatement   existsPS = prepareStatement
1:e081c85:             ( derbyConn, "select count(*) from sys.sysschemas where schemaname = ?" );
1:e081c85:         existsPS.setString( 1, derbySchemaName );
1:e081c85:         ResultSet   existsRS = existsPS.executeQuery();
1:e081c85:         existsRS.next();
1:e081c85:         boolean exists = existsRS.getInt( 1 ) > 0;
1:e081c85:         existsRS.close();
1:e081c85:         existsPS.close();
1:e081c85: 
1:e081c85:         if ( !exists )
1:e081c85:         {
1:e081c85:             executeDDL
1:e081c85:                 ( derbyConn, "create schema " + delimitedID( derbySchemaName ) );
1:e081c85:         }
1:e081c85:     }
1:e081c85: 
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Drop a Derby schema.
1:e081c85:      * </p>
1:e081c85:      */
1:e081c85:     private void    dropDerbySchema
1:e081c85:         (
1:e081c85:          Connection derbyConn,
1:e081c85:          String     derbySchemaName
1:e081c85:          )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         if ( derbySchemaName == null ) { return; }
1:e081c85: 
1:e081c85:         dropObject( derbyConn, null, derbySchemaName, "schema", true );
1:e081c85:     }
1:e081c85:         
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Get the name of the local Derby schema corresponding to a foreign schema name.
1:e081c85:      * Returns null if the default (current) schema is to be used.
1:e081c85:      * </p>
1:e081c85:      */
1:e081c85:     private String  getDerbySchemaName
1:e081c85:         (
1:e081c85:          String schemaPrefix,
1:e081c85:          String foreignSchemaName
1:e081c85:          )
1:e081c85:     {
1:e081c85:         if ( foreignSchemaName == null ) { return null; }
1:e081c85:         else if ( schemaPrefix == null ) { return foreignSchemaName; }
1:e081c85:         else { return schemaPrefix + foreignSchemaName; }
1:e081c85:     }
1:e081c85: 
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Turn a Derby schema name into a schema name suitable for use
1:e081c85:      * in a dot-separated object name.
1:e081c85:      * </p>
1:e081c85:      */
1:e081c85:     private String  dotSeparatedSchemaName( String rawName )
1:e081c85:     {
1:e081c85:         if ( rawName == null ) { return ""; }
1:e081c85:         else { return delimitedID( rawName ) + "."; }
1:e081c85:     }
1:e081c85:     
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Get the type of an external database's column as a Derby type name.
1:e081c85:      * </p>
1:e081c85:      *
1:e081c85:      */
1:e081c85:     private String    mapType( int jdbcType, int precision, int scale, String foreignTypeName )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         switch( jdbcType )
1:e081c85:         {
1:e081c85:         case    Types.BIGINT:           return "bigint";
1:e081c85:         case    Types.BINARY:           return "char " + precisionToLength( precision ) + "  for bit data";
1:e081c85:         case    Types.BIT:              return "boolean";
1:e081c85:         case    Types.BLOB:             return "blob";
1:e081c85:         case    Types.BOOLEAN:          return "boolean";
1:e081c85:         case    Types.CHAR:             return "char" + precisionToLength( precision );
1:e081c85:         case    Types.CLOB:             return "clob";
1:e081c85:         case    Types.DATE:             return "date";
1:e081c85:         case    Types.DECIMAL:          return "decimal" + precisionAndScale( precision, scale );
1:e081c85:         case    Types.DOUBLE:           return "double";
1:e081c85:         case    Types.FLOAT:            return "float";
1:e081c85:         case    Types.INTEGER:          return "integer";
1:e081c85:         case    Types.LONGVARBINARY:    return "long varchar for bit data";
1:e081c85:         case    Types.LONGVARCHAR:      return "long varchar";
1:e081c85:         case    Types.NUMERIC:          return "numeric" + precisionAndScale( precision, scale );
1:e081c85:         case    Types.REAL:             return "real";
1:e081c85:         case    Types.SMALLINT:         return "smallint";
1:e081c85:         case    Types.TIME:             return "time";
1:e081c85:         case    Types.TIMESTAMP:        return "timestamp";
1:e081c85:         case    Types.TINYINT:          return "smallint";
1:e081c85:         case    Types.VARBINARY:        return "varchar " + precisionToLength( precision ) + "  for bit data";
1:e081c85:         case    Types.VARCHAR:          return "varchar" + precisionToLength( precision );
1:e081c85:         case    XML_TYPE:               return "xml";
1:e081c85:  
1:e081c85:         default:
1:e081c85:             throw wrap
1:e081c85:                 (
1:e081c85:                  LocalizedResource.getMessage
1:e081c85:                  (
1:e081c85:                   "OT_UnknownForeignDataType",
1:e081c85:                   Integer.toString( jdbcType ),
1:e081c85:                   foreignTypeName
1:e081c85:                  )
1:e081c85:                 );
1:e081c85:         }
1:e081c85:     }
1:e081c85: 
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Turns precision into a length designator.
1:e081c85:      * </p>
1:e081c85:      *
1:e081c85:      */
1:e081c85:     private String  precisionToLength( int precision )
1:e081c85:     {
1:e081c85:         return "( " + precision + " )";
1:e081c85:     }
1:e081c85: 
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Build a precision and scale designator.
1:e081c85:      * </p>
1:e081c85:      *
1:e081c85:      */
1:e081c85:     private String  precisionAndScale( int precision, int scale )
1:e081c85:     {
1:e081c85:         return "( " + precision + ", " + scale + " )";
1:e081c85:     }
1:e081c85: 
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85:     //
1:e081c85:     //	UNREGISTRATION MINIONS
1:e081c85:     //
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85: 
1:e081c85:     /**
1:e081c85:      * <p>
1:e081c85:      * Drop a schema object. If the object does not exist, silently
1:e081c85:      * swallow the error.
1:e081c85:      * </p>
1:e081c85:      */
1:e081c85:     private void    dropObject
1:e081c85:         (
1:e081c85:          Connection         conn,
1:e081c85:          String             schemaName,
1:e081c85:          String             objectName,
1:e081c85:          String             objectType,
1:e081c85:          boolean        restrict
1:e081c85:         )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         String              dotSchemaName = dotSeparatedSchemaName( schemaName );
1:e081c85:         String              restrictString = restrict ? " restrict" : "";
1:e081c85: 
1:e081c85:         try {
1:e081c85:             executeDDL
1:e081c85:                 (
1:e081c85:                  conn,
1:e081c85:                  "drop " + objectType + " " + dotSchemaName + delimitedID( objectName ) + restrictString
1:e081c85:                  );
1:e081c85:         }
1:e081c85:         catch (SQLException se)
1:e081c85:         {
1:e081c85:             String  actualSQLState = se.getSQLState();
1:e081c85: 
1:e081c85:             for ( String safeSQLState : SAFE_DROP_SQLSTATES )
1:e081c85:             {
1:e081c85:                 if ( actualSQLState.startsWith( safeSQLState ) ) { return; }
1:e081c85:             }
1:e081c85: 
1:e081c85:             throw se;
1:e081c85:         }
1:e081c85:     }
1:e081c85: 
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85:     //
1:e081c85:     //	Connection MANAGEMENT
1:e081c85:     //
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85: 
1:e081c85:     private Connection  getForeignConnection( String connectionURL )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         return DriverManager.getConnection( connectionURL );
1:e081c85:     }
1:e081c85: 
1:e081c85:     private Connection  getDerbyConnection() throws SQLException
1:e081c85:     {
1:e081c85:         return DriverManager.getConnection( "jdbc:default:connection" );
1:e081c85:     }
1:e081c85: 
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85:     //
1:e081c85:     //	SQL MINIONS
1:e081c85:     //
1:e081c85:     ////////////////////////////////////////////////////////////////////////
1:e081c85: 
1:e081c85:     private String  delimitedID( String text )  { return IdUtil.normalToDelimited( text ); }
1:e081c85:     private String  stringLiteral( String text )  { return StringUtil.quoteStringLiteral( text ); }
1:e081c85: 
1:e081c85:     private void    executeDDL
1:e081c85:         ( Connection conn, String text )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         PreparedStatement   ddl = prepareStatement( conn, text );
1:e081c85:         ddl.execute();
1:e081c85:         ddl.close();
1:e081c85:     }
1:e081c85:     
1:e081c85:     private PreparedStatement   prepareStatement
1:e081c85:         ( Connection conn, String text )
1:e081c85:         throws SQLException
1:e081c85:     {
1:e081c85:         return conn.prepareStatement( text );
1:e081c85:     }
1:e081c85: 
1:e081c85:     private SQLException    wrap( String errorMessage )
1:e081c85:     {
1:e081c85:         String  sqlState = org.apache.derby.shared.common.reference.SQLState.JAVA_EXCEPTION.substring( 0, 5 );
1:e081c85: 
1:e081c85:         return new SQLException( errorMessage, sqlState );
1:e081c85:     }
1:e081c85: 
1:e081c85: }
1:e081c85: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:b412f10
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.vti.ForeignTableVTI;
/////////////////////////////////////////////////////////////////////////
1: 
1:         // now drop the connection to the foreign database
1:         ForeignTableVTI.dropConnection( foreignConnectionURL );
commit:e081c85
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.tools.optional.ForeignDBViews
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.tools.optional;
1: 
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Types;
1: import java.util.HashSet;
1: 
1: import org.apache.derby.iapi.sql.dictionary.OptionalTool;
1: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1: import org.apache.derby.iapi.util.IdUtil;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: /**
1:  * <p>
1:  * OptionalTool to create wrapper functions and views for all of the user tables
1:  * in a foreign database.
1:  * </p>
1:  */
1: public	class   ForeignDBViews  implements OptionalTool
1: {
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTANTS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   int XML_TYPE = 2009;    // needed if you aren't compiling against Java 6
1: 
1:     //
1:     // It's ok to get these SQLStates when trying to drop an object on behalf
1:     // of unloadTool(). The idea is to make unloadTool() idempotent.
1:     //
1:     private static  final   String[]    SAFE_DROP_SQLSTATES =
1:     {
1:         org.apache.derby.shared.common.reference.SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,
1:         org.apache.derby.shared.common.reference.SQLState.LANG_OBJECT_DOES_NOT_EXIST,
1:         org.apache.derby.shared.common.reference.SQLState.LANG_SCHEMA_DOES_NOT_EXIST,
1:     };
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	STATE
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	CONSTRUCTOR
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /** 0-arg constructor required by the OptionalTool contract */
1:     public  ForeignDBViews() {}
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // OptionalTool BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Creates a local Derby schema for every foreign schema which contains
1:      * a user table. Then creates a table function and convenience view for every
1:      * user table found in the foreign database. The parameters to this method are:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>foreignConnectionURL (required) - URL to connect to the foreign database</li>
1:      * <li>schemaPrefix (optional) - If not specified, then the local Derby schema which is
1:      * created has the same name as the foreign schema. Otherwise, this prefix is prepended
1:      * to the names of the local Derby schemas which are created.</li>
1:      * </ul>
1:      */
1:     public  void    loadTool( String... configurationParameters )
1:         throws SQLException
1:     {
1:         if ( (configurationParameters == null) || (configurationParameters.length < 1) )
1:         {
1:             throw wrap( LocalizedResource.getMessage( "OT_BadLoadUnloadArgs" ) );
1:         }
1: 
1:         String              foreignConnectionURL = configurationParameters[ 0 ];
1:         String              schemaPrefix = (configurationParameters.length == 1) ? null : configurationParameters[ 1 ];
1:         Connection          foreignConn = getForeignConnection( foreignConnectionURL );
1:         Connection          derbyConn = getDerbyConnection();
1:         DatabaseMetaData    foreignDBMD = foreignConn.getMetaData();
1:         ResultSet           tableCursor = getForeignTables( foreignDBMD );
1: 
1:         while( tableCursor.next() )
1:         {
1:             registerForeignTable
1:                 (
1:                  foreignDBMD,
1:                  tableCursor.getString( 2 ),
1:                  tableCursor.getString( 3 ),
1:                  foreignConnectionURL,
1:                  schemaPrefix,
1:                  derbyConn
1:                  );
1:         }
1: 
1:         tableCursor.close();
1:         foreignConn.close();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Removes the schemas, table functions, and views created by loadTool().
1:      * </p>
1:      *
1:      * <ul>
1:      * <li>connectionURL (required) - URL to connect to the foreign database</li>
1:      * <li>schemaPrefix (optional) - See loadTool() for more information on this argument.</li>
1:      * </ul>
1:      */
1:     public  void    unloadTool( String... configurationParameters )
1:         throws SQLException
1:     {
1:         if ( (configurationParameters == null) || (configurationParameters.length < 1) )
1:         {
1:             throw wrap( LocalizedResource.getMessage( "OT_BadLoadUnloadArgs" ) );
1:         }
1: 
1:         String              foreignConnectionURL = configurationParameters[ 0 ];
1:         String              schemaPrefix = (configurationParameters.length == 1) ? null : configurationParameters[ 1 ];
1:         Connection          foreignConn = getForeignConnection( foreignConnectionURL );
1:         Connection          derbyConn = getDerbyConnection();
1:         DatabaseMetaData    foreignDBMD = foreignConn.getMetaData();
1:         ResultSet           tableCursor = getForeignTables( foreignDBMD );
1:         HashSet<String> schemas = new HashSet<String>();
1: 
1:         while( tableCursor.next() )
1:         {
1:             String          derbySchemaName = getDerbySchemaName( schemaPrefix, tableCursor.getString( 2 ) );
1:             String          objectName = tableCursor.getString( 3 );
1: 
1:             if ( derbySchemaName != null ) { schemas.add( derbySchemaName ); }
1:             
1:             dropObject( derbyConn, derbySchemaName, objectName, "view", false );
1:             dropObject( derbyConn, derbySchemaName, objectName, "function", false );
1:         }
1: 
1:         tableCursor.close();
1:         foreignConn.close();
1: 
1:         // now drop the schemas created by loadTool()
1:         for ( String schemaName : schemas ) { dropDerbySchema( derbyConn, schemaName ); }
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // REGISTRATION MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private void    registerForeignTable
1:         (
1:          DatabaseMetaData   foreignDBMD,
1:          String             foreignSchemaName,
1:          String             foreignTableName,
1:          String             foreignConnectionURL,
1:          String             schemaPrefix,
1:          Connection     derbyConn
1:         )
1:         throws SQLException
1:     {
1:         //
1:         // Create DDL string for registering the table function
1:         //
1:         StringBuilder       tfBuffer = new StringBuilder();
1:         String              derbySchemaName = getDerbySchemaName( schemaPrefix, foreignSchemaName );
1:         String              dotSchemaName = dotSeparatedSchemaName( derbySchemaName );
1: 
1:         createDerbySchema( derbyConn, derbySchemaName );
1: 
1:         tfBuffer.append( "create function " + dotSchemaName + delimitedID( foreignTableName ) );
1:         tfBuffer.append( "\n(" );
1:         tfBuffer.append( "\n\tforeignSchemaName varchar( 32672 )," );
1:         tfBuffer.append( "\n\tforeignTableName varchar( 32672 )," );
1:         tfBuffer.append( "\n\tconnectionURL varchar( 32672 )" );
1:         tfBuffer.append( "\n)\nreturns table\n(" );
1:         
1:         ResultSet           columnCursor = foreignDBMD.getColumns( null, foreignSchemaName, foreignTableName, "%" );
1:         int                 columnCount = 0;
1:         while( columnCursor.next() )
1:         {
1:             tfBuffer.append( "\n\t" );
1:             if ( columnCount > 0 ) { tfBuffer.append( ", " ); }
1:             columnCount++;
1: 
1:             tfBuffer.append( delimitedID( columnCursor.getString( 4 ) ) );
1:             tfBuffer.append( " " );
1:             tfBuffer.append
1:                 (
1:                  mapType
1:                  (
1:                   columnCursor.getInt( 5 ),
1:                   columnCursor.getInt( 7 ),
1:                   columnCursor.getInt( 9 ),
1:                   columnCursor.getString( 6 )
1:                   )
1:                  );
1:         }
1:         columnCursor.close();
1: 
1:         tfBuffer.append( "\n)" );
1:         tfBuffer.append( "\nlanguage java parameter style derby_jdbc_result_set no sql" );
1:         tfBuffer.append( "\nexternal name 'org.apache.derby.vti.ForeignTableVTI.readForeignTable'" );
1: 
1:         String          tfDDL = tfBuffer.toString();
1:         
1:         //
1:         // Create DDL string for registering the view
1:         //
1:         StringBuilder   viewBuffer = new StringBuilder();
1: 
1:         viewBuffer.append( "create view " + dotSchemaName + delimitedID( foreignTableName ) );
1:         viewBuffer.append( "\nas select *" );
1:         viewBuffer.append( "\nfrom table" );
1:         viewBuffer.append( "\n(\n" );
1:         viewBuffer.append( "\t" + dotSchemaName + delimitedID( foreignTableName ) );
1:         viewBuffer.append( "\n\t(" );
1:         viewBuffer.append( "\n\t\t" + stringLiteral( foreignSchemaName ) + "," );
1:         viewBuffer.append( "\n\t\t" + stringLiteral( foreignTableName ) + "," );
1:         viewBuffer.append( "\n\t\t" + stringLiteral( foreignConnectionURL ) );
1:         viewBuffer.append( "\n\t)" );
1:         viewBuffer.append( "\n) s" );
1: 
1:         String          viewDDL = viewBuffer.toString();
1: 
1:         //
1:         // Now create the table function and view.
1:         //
1:         executeDDL( derbyConn, tfDDL );
1:         executeDDL( derbyConn, viewDDL );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Get a cursor through the user tables in the foreign database.
1:      * </p>
1:      */
1:     private ResultSet   getForeignTables( DatabaseMetaData foreignDBMD )
1:         throws SQLException
1:     {
1:         return foreignDBMD.getTables( null, null, "%", new String[] { "TABLE" } );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Create a Derby schema if it does not already exist.
1:      * </p>
1:      */
1:     private void    createDerbySchema
1:         (
1:          Connection derbyConn,
1:          String     derbySchemaName
1:          )
1:         throws SQLException
1:     {
1:         if ( derbySchemaName == null ) { return; }
1:         
1:         PreparedStatement   existsPS = prepareStatement
1:             ( derbyConn, "select count(*) from sys.sysschemas where schemaname = ?" );
1:         existsPS.setString( 1, derbySchemaName );
1:         ResultSet   existsRS = existsPS.executeQuery();
1:         existsRS.next();
1:         boolean exists = existsRS.getInt( 1 ) > 0;
1:         existsRS.close();
1:         existsPS.close();
1: 
1:         if ( !exists )
1:         {
1:             executeDDL
1:                 ( derbyConn, "create schema " + delimitedID( derbySchemaName ) );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Drop a Derby schema.
1:      * </p>
1:      */
1:     private void    dropDerbySchema
1:         (
1:          Connection derbyConn,
1:          String     derbySchemaName
1:          )
1:         throws SQLException
1:     {
1:         if ( derbySchemaName == null ) { return; }
1: 
1:         dropObject( derbyConn, null, derbySchemaName, "schema", true );
1:     }
1:         
1:     /**
1:      * <p>
1:      * Get the name of the local Derby schema corresponding to a foreign schema name.
1:      * Returns null if the default (current) schema is to be used.
1:      * </p>
1:      */
1:     private String  getDerbySchemaName
1:         (
1:          String schemaPrefix,
1:          String foreignSchemaName
1:          )
1:     {
1:         if ( foreignSchemaName == null ) { return null; }
1:         else if ( schemaPrefix == null ) { return foreignSchemaName; }
1:         else { return schemaPrefix + foreignSchemaName; }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Turn a Derby schema name into a schema name suitable for use
1:      * in a dot-separated object name.
1:      * </p>
1:      */
1:     private String  dotSeparatedSchemaName( String rawName )
1:     {
1:         if ( rawName == null ) { return ""; }
1:         else { return delimitedID( rawName ) + "."; }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Get the type of an external database's column as a Derby type name.
1:      * </p>
1:      *
1:      */
1:     private String    mapType( int jdbcType, int precision, int scale, String foreignTypeName )
1:         throws SQLException
1:     {
1:         switch( jdbcType )
1:         {
1:         case    Types.BIGINT:           return "bigint";
1:         case    Types.BINARY:           return "char " + precisionToLength( precision ) + "  for bit data";
1:         case    Types.BIT:              return "boolean";
1:         case    Types.BLOB:             return "blob";
1:         case    Types.BOOLEAN:          return "boolean";
1:         case    Types.CHAR:             return "char" + precisionToLength( precision );
1:         case    Types.CLOB:             return "clob";
1:         case    Types.DATE:             return "date";
1:         case    Types.DECIMAL:          return "decimal" + precisionAndScale( precision, scale );
1:         case    Types.DOUBLE:           return "double";
1:         case    Types.FLOAT:            return "float";
1:         case    Types.INTEGER:          return "integer";
1:         case    Types.LONGVARBINARY:    return "long varchar for bit data";
1:         case    Types.LONGVARCHAR:      return "long varchar";
1:         case    Types.NUMERIC:          return "numeric" + precisionAndScale( precision, scale );
1:         case    Types.REAL:             return "real";
1:         case    Types.SMALLINT:         return "smallint";
1:         case    Types.TIME:             return "time";
1:         case    Types.TIMESTAMP:        return "timestamp";
1:         case    Types.TINYINT:          return "smallint";
1:         case    Types.VARBINARY:        return "varchar " + precisionToLength( precision ) + "  for bit data";
1:         case    Types.VARCHAR:          return "varchar" + precisionToLength( precision );
1:         case    XML_TYPE:               return "xml";
1:  
1:         default:
1:             throw wrap
1:                 (
1:                  LocalizedResource.getMessage
1:                  (
1:                   "OT_UnknownForeignDataType",
1:                   Integer.toString( jdbcType ),
1:                   foreignTypeName
1:                  )
1:                 );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Turns precision into a length designator.
1:      * </p>
1:      *
1:      */
1:     private String  precisionToLength( int precision )
1:     {
1:         return "( " + precision + " )";
1:     }
1: 
1:     /**
1:      * <p>
1:      * Build a precision and scale designator.
1:      * </p>
1:      *
1:      */
1:     private String  precisionAndScale( int precision, int scale )
1:     {
1:         return "( " + precision + ", " + scale + " )";
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	UNREGISTRATION MINIONS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Drop a schema object. If the object does not exist, silently
1:      * swallow the error.
1:      * </p>
1:      */
1:     private void    dropObject
1:         (
1:          Connection         conn,
1:          String             schemaName,
1:          String             objectName,
1:          String             objectType,
1:          boolean        restrict
1:         )
1:         throws SQLException
1:     {
1:         String              dotSchemaName = dotSeparatedSchemaName( schemaName );
1:         String              restrictString = restrict ? " restrict" : "";
1: 
1:         try {
1:             executeDDL
1:                 (
1:                  conn,
1:                  "drop " + objectType + " " + dotSchemaName + delimitedID( objectName ) + restrictString
1:                  );
1:         }
1:         catch (SQLException se)
1:         {
1:             String  actualSQLState = se.getSQLState();
1: 
1:             for ( String safeSQLState : SAFE_DROP_SQLSTATES )
1:             {
1:                 if ( actualSQLState.startsWith( safeSQLState ) ) { return; }
1:             }
1: 
1:             throw se;
1:         }
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	Connection MANAGEMENT
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     private Connection  getForeignConnection( String connectionURL )
1:         throws SQLException
1:     {
1:         return DriverManager.getConnection( connectionURL );
1:     }
1: 
1:     private Connection  getDerbyConnection() throws SQLException
1:     {
1:         return DriverManager.getConnection( "jdbc:default:connection" );
1:     }
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     //	SQL MINIONS
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     private String  delimitedID( String text )  { return IdUtil.normalToDelimited( text ); }
1:     private String  stringLiteral( String text )  { return StringUtil.quoteStringLiteral( text ); }
1: 
1:     private void    executeDDL
1:         ( Connection conn, String text )
1:         throws SQLException
1:     {
1:         PreparedStatement   ddl = prepareStatement( conn, text );
1:         ddl.execute();
1:         ddl.close();
1:     }
1:     
1:     private PreparedStatement   prepareStatement
1:         ( Connection conn, String text )
1:         throws SQLException
1:     {
1:         return conn.prepareStatement( text );
1:     }
1: 
1:     private SQLException    wrap( String errorMessage )
1:     {
1:         String  sqlState = org.apache.derby.shared.common.reference.SQLState.JAVA_EXCEPTION.substring( 0, 5 );
1: 
1:         return new SQLException( errorMessage, sqlState );
1:     }
1: 
1: }
1: 
============================================================================