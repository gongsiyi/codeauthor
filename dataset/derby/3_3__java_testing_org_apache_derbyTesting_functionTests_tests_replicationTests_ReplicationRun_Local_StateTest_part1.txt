1:40a554b: /*
2:40a554b:  
1:9c2b1f3: Derby - Class org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationRun_Local_StateTest_part1
1:40a554b:  
1:40a554b: Licensed to the Apache Software Foundation (ASF) under one or more
1:40a554b: contributor license agreements.  See the NOTICE file distributed with
1:40a554b: this work for additional information regarding copyright ownership.
1:40a554b: The ASF licenses this file to You under the Apache License, Version 2.0
1:40a554b: (the "License"); you may not use this file except in compliance with
1:40a554b: the License.  You may obtain a copy of the License at
1:40a554b:  
1:40a554b:    http://www.apache.org/licenses/LICENSE-2.0
1:40a554b:  
1:40a554b: Unless required by applicable law or agreed to in writing, software
1:40a554b: distributed under the License is distributed on an "AS IS" BASIS,
1:40a554b: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:40a554b: See the License for the specific language governing permissions and
1:40a554b: limitations under the License.
1:40a554b:  
1:40a554b:  */
1:40a554b: package org.apache.derbyTesting.functionTests.tests.replicationTests;
1:40a554b: 
1:40a554b: import java.sql.Connection;
1:40a554b: import java.sql.DriverManager;
1:40a554b: import java.sql.SQLException;
1:40a554b: import junit.framework.Test;
1:8c9d41e: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:40a554b: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1:40a554b: 
1:40a554b: 
2:40a554b: /**
1:40a554b:  * Run a replication test on localhost
1:40a554b:  * by using default values for master and slave hosts,
1:40a554b:  * and master and slave ports.
1:40a554b:  * 
1:40a554b:  */
1:40a554b: 
1:40a554b: public class ReplicationRun_Local_StateTest_part1 extends ReplicationRun
1:40a554b: {
1:8c9d41e:     final static String CANNOT_CONNECT_TO_DB_IN_SLAVE_MODE = "08004";
1:8c9d41e:     final static String LOGIN_FAILED = "08004";
1:8c9d41e:     final static String REPLICATION_DB_NOT_BOOTED = "XRE11";
1:8c9d41e:     final static String REPLICATION_MASTER_ALREADY_BOOTED = "XRE22";
1:8c9d41e:     final static String REPLICATION_NOT_IN_MASTER_MODE = "XRE07";
1:8c9d41e:     final static String REPLICATION_SLAVE_STARTED_OK = "XRE08";
1:8c9d41e: 
1:8c9d41e: 
1:8c9d41e: 
1:8c9d41e: /**
1:40a554b:      * Creates a new instance of ReplicationRun_Local_StateTest_part1
1:40a554b:      * 
1:40a554b:      * @param testcaseName Identifying the test.
1:40a554b:      */
1:40a554b:     public ReplicationRun_Local_StateTest_part1(String testcaseName)
1:40a554b:     {
1:40a554b:         super(testcaseName);
1:40a554b:     }
1:40a554b:         
1:40a554b:     public static Test suite()
1:40a554b:     {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("ReplicationRun_Local_StateTest_part1 Suite");
1:40a554b:         
1:40a554b:         suite.addTestSuite( ReplicationRun_Local_StateTest_part1.class );
1:40a554b:         
1:40a554b:         return SecurityManagerSetup.noSecurityManager(suite);
1:40a554b:     }
1:40a554b:     
1:40a554b:     //////////////////////////////////////////////////////////////
1:40a554b:     ////
1:40a554b:     //// The replication test framework (testReplication()):
1:40a554b:     //// a) "clean" replication run starting master and slave servers,
1:40a554b:     ////     preparing master and slave databases,
1:40a554b:     ////     starting and stopping replication and doing
1:40a554b:     ////     failover for a "normal"/"failure free" replication
1:40a554b:     ////     test run.
1:40a554b:     ////
1:40a554b:     //////////////////////////////////////////////////////////////
1:40a554b:     
1:40a554b:     public void testReplication_Local_StateTest_part1()
1:40a554b:     throws Exception
1:40a554b:     {
1:40a554b:         cleanAllTestHosts();
1:40a554b:         
1:40a554b:         initEnvironment();
1:40a554b:         
1:40a554b:         // State test. Continuation OK.
1:40a554b:         _testPreStartedMasterServer(); 
1:40a554b:         
1:40a554b:         initMaster(masterServerHost,
1:40a554b:                 replicatedDb);
1:40a554b:         
1:136610d:         startServer(masterJvmVersion, derbyMasterVersion,
1:40a554b:                 masterServerHost,
1:40a554b:                 ALL_INTERFACES, // masterServerHost, // "0.0.0.0", // All. or use masterServerHost for interfacesToListenOn,
1:40a554b:                 masterServerPort,
1:dbe5dc3:                 masterDbSubPath); // Distinguishing master/slave
1:40a554b:         
1:40a554b:         // State test. 
1:40a554b:         _testPreStartedSlaveServer(); 
1:40a554b:         
1:136610d:         startServer(slaveJvmVersion, derbySlaveVersion,
1:40a554b:                 slaveServerHost,
1:40a554b:                 ALL_INTERFACES, // slaveServerHost, // "0.0.0.0", // All. or use slaveServerHost for interfacesToListenOn,
1:40a554b:                 slaveServerPort,
1:dbe5dc3:                 slaveDbSubPath); // Distinguishing master/slave
1:40a554b:         
1:40a554b:         startServerMonitor(slaveServerHost);
1:40a554b:         
1:40a554b:         bootMasterDatabase(jvmVersion,
1:40a554b:                 masterDatabasePath +FS+ masterDbSubPath,
1:40a554b:                 replicatedDb,
1:40a554b:                 masterServerHost, // Where the startreplication command must be given
1:40a554b:                 masterServerPort, // master server interface accepting client requests
1:40a554b:                 null // bootLoad, // The "test" to start when booting db.
1:40a554b:                 );
1:40a554b:         
1:40a554b:         // State test. 
1:40a554b:         _testPreInitSlave();
1:40a554b:         
1:40a554b:         initSlave(slaveServerHost,
1:40a554b:                 jvmVersion,
1:40a554b:                 replicatedDb); // Trunk and Prototype V2: copy master db to db_slave.
1:40a554b:         
1:40a554b:         // State test. 
1:40a554b:         _testPreStartedSlave(); // Currently NOOP
1:40a554b:         
1:40a554b:         startSlave(jvmVersion, replicatedDb,
1:40a554b:                 slaveServerHost, // slaveClientInterface // where the slave db runs
1:40a554b:                 slaveServerPort,
1:40a554b:                 slaveServerHost, // for slaveReplInterface
1:40a554b:                 slaveReplPort,
1:40a554b:                 testClientHost);
1:40a554b:         
1:40a554b:         // State test. 
1:40a554b:         _testPreStartedMaster();
1:40a554b:         
1:40a554b:         // With master started above, next will fail! 
1:40a554b:         // Also seems failover will fail w/XRE21! : DERBY-3358!
1:40a554b:         // Further testing: skipping next startMaster seems to 
1:40a554b:         // NOT remove failover failure!
1:40a554b:         /* TEMP: should be operational already - try skipping this. * /
1:40a554b:         startMaster(jvmVersion, replicatedDb,
1:40a554b:                 masterServerHost, // Where the startMaster command must be given
1:40a554b:                 masterServerPort, // master server interface accepting client requests
1:40a554b:                 masterServerHost, // An interface on the master: masterClientInterface (==masterServerHost),
1:40a554b:                 slaveServerPort, // Not used since slave don't allow clients.
1:40a554b:                 slaveServerHost, // for slaveReplInterface
1:40a554b:                 slaveReplPort);
1:40a554b:          / * */
1:40a554b:         
1:40a554b:         // Used to run positive tests.
1:40a554b:         // Handle negative testing in State.testPostStartedMasterAndSlave().
1:40a554b:         // Observe that it will not be meaningful to do runTest if State.XXXX()
1:40a554b:         // has led to incorrect replication state wrt. replicationTest.
1:40a554b:         
1:40a554b:         replicationTest = "org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationTestRun";
1:40a554b:         util.DEBUG("replicationTest: " + replicationTest);
1:40a554b:         replicationVerify = "org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationTestRun_Verify";
1:40a554b:         util.DEBUG("replicationVerify: " + replicationVerify);
1:40a554b: 
1:40a554b:         runTest(replicationTest, // Returns immediatly if replicationTest is null.
1:40a554b:                 jvmVersion,
1:40a554b:                 testClientHost,
1:40a554b:                 masterServerHost, masterServerPort,
1:40a554b:                 replicatedDb);
1:40a554b:         
1:40a554b:         failOver(jvmVersion,
1:40a554b:                 masterDatabasePath, masterDbSubPath, replicatedDb,
1:40a554b:                 masterServerHost,  // Where the master db is run.
1:40a554b:                 masterServerPort,
1:40a554b:                 testClientHost);
1:40a554b:         
1:40a554b:         connectPing(slaveDatabasePath+FS+slaveDbSubPath+FS+replicatedDb,
1:40a554b:                 slaveServerHost,slaveServerPort,
1:40a554b:                 testClientHost);
1:40a554b:         
1:40a554b:         verifySlave();
1:40a554b:         
1:40a554b:         // We should verify the master as well, at least to see that we still can connect.
1:40a554b:         verifyMaster();
1:40a554b:         
1:40a554b:         stopServer(jvmVersion, derbyVersion,
1:40a554b:                 slaveServerHost, slaveServerPort);
1:40a554b:         
1:40a554b:         stopServer(jvmVersion, derbyVersion,
1:40a554b:                 masterServerHost, masterServerPort);
1:40a554b:         
1:40a554b:     }
1:40a554b: 
1:40a554b:     private void _testPreStartedMasterServer()
1:40a554b:     {
1:40a554b:         Connection conn = null;
1:dbe5dc3:         String db = masterDatabasePath +FS+ReplicationRun.masterDbSubPath +FS+ replicatedDb;
1:40a554b:         String connectionURL = "jdbc:derby:"
1:40a554b:                 + "//" + masterServerHost + ":" + masterServerPort + "/"
1:40a554b:                 + db
1:40a554b:                 + ";startMaster=true"
1:40a554b:                 + ";slavehost=" + slaveServerHost
1:40a554b:                 + ";slaveport=" + slaveServerPort;
1:40a554b:         util.DEBUG("testPreStartedMasterServer: " + connectionURL);
1:40a554b:         try
1:40a554b:         {
1:40a554b:             conn = DriverManager.getConnection(connectionURL);
1:40a554b:         }
1:40a554b:         catch (SQLException se)
1:40a554b:         {
1:40a554b:             int ec = se.getErrorCode();
1:40a554b:             String ss = se.getSQLState();
1:40a554b:             String msg = ec + " " + ss + " " + se.getMessage();
1:40a554b:             util.DEBUG("testStartMasterConnect_Illegal: " + msg);
1:40a554b:             assertTrue("Unexpected SQLException: " + msg, "08001".equals(ss));
1:40a554b:             util.DEBUG("As expected.");
1:40a554b:             return;
1:40a554b:         }
1:40a554b:         assertTrue("Expected SQLException: '08001 " + db + "'",false);
1:40a554b:     }
1:40a554b: 
1:40a554b:     private void _testPreStartedSlaveServer()
1:40a554b:     {
1:40a554b:         Connection conn = null;
1:dbe5dc3:         String db = slaveDatabasePath +FS+ReplicationRun.slaveDbSubPath +FS+ replicatedDb;
1:40a554b:         String connectionURL = "jdbc:derby:"  
1:40a554b:                 + "//" + slaveServerHost + ":" + slaveServerPort + "/"
1:40a554b:                 + db
1:40a554b:                 + ";startSlave=true"
1:40a554b:                 + ";slavehost=" + slaveServerHost 
1:40a554b:                 + ";slaveport=" + slaveServerPort;
1:40a554b:         util.DEBUG("testPreStartedSlaveServer: " + connectionURL);
1:40a554b:         try
1:40a554b:         {
1:40a554b:             conn = DriverManager.getConnection(connectionURL);
1:40a554b:         }
1:40a554b:         catch (SQLException se)
1:40a554b:         {
1:40a554b:             int ec = se.getErrorCode();
1:40a554b:             String ss = se.getSQLState();
1:40a554b:             String msg = ec + " " + ss + " " + se.getMessage();
1:40a554b:             util.DEBUG("testStartSlaveConnect_Illegal: " + msg);
1:40a554b:             assertTrue("Unexpected SQLException: " + msg, "08001".equals(ss));
1:40a554b:             util.DEBUG("As expected.");
1:40a554b:             return;
1:40a554b:         }
1:40a554b:         assertTrue("Expected SQLException: '08001 " + db + "'",false);
1:40a554b:     }
1:40a554b: 
1:40a554b:     private void _testPreInitSlave()
1:40a554b:     {
1:40a554b:         String db = null;
1:40a554b:         String connectionURL = null;
1:40a554b:         Connection conn = null;
1:40a554b:         
1:40a554b:         // 1.  stopMaster on master: fail
1:dbe5dc3:         db = masterDatabasePath +FS+ReplicationRun.masterDbSubPath +FS+ replicatedDb;
1:40a554b:         connectionURL = "jdbc:derby:"
1:40a554b:                 + "//" + masterServerHost + ":" + masterServerPort + "/"
1:40a554b:                 + db
1:40a554b:                 + ";stopMaster=true";
1:40a554b:         util.DEBUG("1. testPreInitSlave:" + connectionURL);
1:40a554b:         try
1:40a554b:         {
1:40a554b:             conn = DriverManager.getConnection(connectionURL);
1:40a554b:             util.DEBUG("Unexpectedly connected: " + connectionURL);
1:40a554b:             assertTrue("Unexpectedly connected: " + connectionURL,false);
1:40a554b:         }
1:40a554b:         catch (SQLException se)
1:40a554b:         {
1:40a554b:             int ec = se.getErrorCode();
1:40a554b:             String ss = se.getSQLState();
1:40a554b:             String msg = ec + " " + ss + " " + se.getMessage();
1:40a554b:             // SQLState.REPLICATION_NOT_IN_MASTER_MODE
1:40a554b: 
1:8c9d41e:             BaseJDBCTestCase.assertSQLState(
1:8c9d41e:                 "stopMaster on master failed: " + msg,
1:8c9d41e:                 REPLICATION_NOT_IN_MASTER_MODE,
1:8c9d41e:                 se);
1:40a554b:             util.DEBUG("stopMaster on master failed as expected: " + connectionURL + " " + msg);
1:40a554b:         }
1:40a554b:         
1:40a554b:         // 2. stopSlave on slave: fail
1:dbe5dc3:         db = slaveDatabasePath +FS+ReplicationRun.slaveDbSubPath +FS+ replicatedDb;
1:40a554b:         connectionURL = "jdbc:derby:"
1:40a554b:                 + "//" + slaveServerHost + ":" + slaveServerPort + "/"
1:40a554b:                 + db
1:40a554b:                 + ";stopSlave=true";
1:40a554b:         util.DEBUG("2. testPreInitSlave: " + connectionURL);
1:40a554b:         try
1:40a554b:         {
1:40a554b:             conn = DriverManager.getConnection(connectionURL);
1:40a554b:             util.DEBUG("Unexpectedly connected: " + connectionURL);
1:40a554b:             assertTrue("Unexpectedly connected: " + connectionURL,false);
1:40a554b:         }
1:40a554b:         catch (SQLException se)
1:40a554b:         {
1:40a554b:             int ec = se.getErrorCode();
1:40a554b:             String ss = se.getSQLState();
1:40a554b:             String msg = ec + " " + ss + " " + se.getMessage();
1:8c9d41e:             BaseJDBCTestCase.assertSQLState(
1:8c9d41e:                 "stopSlave on slave failed: " + msg,
1:8c9d41e:                 REPLICATION_DB_NOT_BOOTED,
1:8c9d41e:                 se);
1:40a554b:             util.DEBUG("stopSlave on slave failed as expected: " + connectionURL + " " + msg);
1:40a554b:         }
1:40a554b:     }
1:40a554b: 
1:40a554b:     private void _testPreStartedSlave()
1:40a554b:     {
1:40a554b:         Connection conn = null;
1:dbe5dc3:         String db = slaveDatabasePath +FS+ReplicationRun.slaveDbSubPath +FS+ replicatedDb;
1:40a554b:         String connectionURL = "jdbc:derby:"  
1:40a554b:                 + "//" + slaveServerHost + ":" + slaveServerPort + "/"
1:40a554b:                 + db
1:40a554b:                 + ";startSlave=true"
1:40a554b:                 + ";slaveHost=" + slaveServerHost 
1:40a554b:                 + ";slavePort=" + slaveReplPort;
1:40a554b:         util.DEBUG("testPreStartedSlave: Test moved to TestPostStartedMasterAndSlave! " + connectionURL);
1:40a554b:         if (true)return;
1:40a554b:         
1:40a554b:         // First StartSlave connect ok:
1:40a554b:         try
1:40a554b:         {
1:40a554b:             conn = DriverManager.getConnection(connectionURL); 
1:40a554b:             // Will hang until startMaster!
1:40a554b:             util.DEBUG("1. Successfully connected as: " + connectionURL);
1:40a554b:         }
1:40a554b:         catch (SQLException se)
1:40a554b:         {
1:40a554b:             int ec = se.getErrorCode();
1:40a554b:             String ss = se.getSQLState();
1:40a554b:             String msg = ec + " " + ss + " " + se.getMessage();
1:40a554b:             util.DEBUG(msg);
1:8c9d41e:             BaseJDBCTestCase.assertSQLState(
1:8c9d41e:                 "2. Unexpected SQLException: " + msg,
1:8c9d41e:                 REPLICATION_SLAVE_STARTED_OK,
1:8c9d41e:                 se);
1:40a554b:         }
1:40a554b:         
1:40a554b:         // Next StartSlave connect should fail:
1:40a554b:         try
1:40a554b:         {
1:40a554b:             conn = DriverManager.getConnection(connectionURL);
1:40a554b:             util.DEBUG("2. Unexpectedly connected as: " + connectionURL);
1:40a554b:             assertTrue("2. Unexpectedly connected as: " + connectionURL, false);
1:40a554b:         }
1:40a554b:         catch (SQLException se)
1:40a554b:         {
1:40a554b:             int ec = se.getErrorCode();
1:40a554b:             String ss = se.getSQLState();
1:40a554b:             String msg = ec + " " + ss + " " + se.getMessage();
1:40a554b:             util.DEBUG(msg);
1:8c9d41e:             BaseJDBCTestCase.assertSQLState(
1:8c9d41e:                 "2. Unexpected SQLException: " + msg,
1:8c9d41e:                 LOGIN_FAILED,
1:8c9d41e:                 se);
1:40a554b:         }
1:40a554b:         
1:40a554b:     }
1:40a554b: 
1:40a554b:     private void _testPreStartedMaster()
1:40a554b:     throws Exception
1:40a554b:     {
1:40a554b:         Connection conn = null;
1:dbe5dc3:         String db = masterDatabasePath +FS+ReplicationRun.masterDbSubPath +FS+ replicatedDb;
1:40a554b:         String connectionURL = "jdbc:derby:"  
1:40a554b:                 + "//" + masterServerHost + ":" + masterServerPort + "/"
1:40a554b:                 + db
1:40a554b:                 + ";startMaster=true"
1:40a554b:                 + ";slaveHost=" + slaveServerHost 
1:40a554b:                 + ";slavePort=" + slaveReplPort;
1:40a554b:         util.DEBUG("_testPreStartedMaster: " + connectionURL);
1:40a554b:         // First StartMaster connect ok:
1:40a554b:         // Must use "full" startMaster - including wait-loop.
1:40a554b:         
1:40a554b:         // Better move this to testPostStartedMasterAndSlave!
1:40a554b:         startMaster(jvmVersion, replicatedDb,
1:40a554b:                 masterServerHost, // Where the startMaster command must be given
1:40a554b:                 masterServerPort, // master server interface accepting client requests
1:40a554b:                 masterServerHost, // An interface on the master: masterClientInterface (==masterServerHost),
1:40a554b:                 slaveServerPort, // Not used since slave don't allow clients.
1:40a554b:                 slaveServerHost, // for slaveReplInterface
1:40a554b:                 slaveReplPort);
1:40a554b:         /* REMOVE!
1:40a554b:         try
1:40a554b:         {
1:40a554b:             conn = DriverManager.getConnection(connectionURL);
1:40a554b:             assertTrue("1. Unexpected!: startMaster Successfully connected as: " 
1:40a554b:                     + connectionURL, false);
1:40a554b:         }
1:40a554b:         catch (SQLException se)
1:40a554b:         {
1:40a554b:             int ec = se.getErrorCode();
1:40a554b:             String ss = se.getSQLState();
1:40a554b:             String msg = ec + " " + ss + " " + se.getMessage();
1:40a554b:             util.DEBUG(msg);
1:40a554b:             util.DEBUG("1. startMaster: No connection as expected: " + msg);
1:8c9d41e:             BaseJDBCTestCase.assertSQLState(
1:8c9d41e:                 "1. Unexpected SQLException: " + msg,
1:8c9d41e:                 REPLICATION_CONNECTION_EXCEPTION,
1:8c9d41e:                 se);
1:40a554b:         }
1:40a554b:         */
1:40a554b:         
1:40a554b:         util.DEBUG("2. startMaster attempt should fail on: " + connectionURL);
1:40a554b:         // util.DEBUG("********************'' 2. CURRENTLY HANGS!!!! Skipping.");
1:40a554b:         // if (false) // FIXME! ENABLE WHEN DERBY-3358 COMMITTED!
1:40a554b:         {
1:40a554b:         // A 2. StartMaster connect should fail:
1:40a554b:         try
1:40a554b:         {
1:40a554b:             conn = DriverManager.getConnection(connectionURL);
1:40a554b:             util.DEBUG("2. Unexpectedly connected as: " + connectionURL);
1:40a554b:             assertTrue("2. Unexpectedly connected as: " + connectionURL, false);
1:40a554b:         }
1:40a554b:         catch (SQLException se)
1:40a554b:         {
1:40a554b:             int ec = se.getErrorCode();
1:40a554b:             String ss = se.getSQLState();
1:40a554b:             String msg = ec + " " + ss + " " + se.getMessage();
1:40a554b:             util.DEBUG("2. startMaster No connection as expected: " + msg);
1:8c9d41e:             BaseJDBCTestCase.assertSQLState(
1:8c9d41e:                 "2. Unexpected SQLException: " + msg,
1:8c9d41e:                 REPLICATION_MASTER_ALREADY_BOOTED,
1:8c9d41e:                 se);
1:40a554b:         }
1:40a554b:         }
1:40a554b:         
1:40a554b:         // A 2. StartSlave connect should fail:
1:40a554b:         util.DEBUG("startSlave attempt should fail on: " + connectionURL);
1:dbe5dc3:         db = slaveDatabasePath +FS+ReplicationRun.slaveDbSubPath +FS+ replicatedDb;
1:40a554b:         connectionURL = "jdbc:derby:"  
1:40a554b:                 + "//" + slaveServerHost + ":" + slaveServerPort + "/"
1:40a554b:                 + db
1:40a554b:                 + ";startSlave=true"
1:40a554b:                 + ";slaveHost=" + slaveServerHost 
1:40a554b:                 + ";slavePort=" + slaveReplPort;
1:40a554b:         util.DEBUG(connectionURL);
1:40a554b:         try
1:40a554b:         {
1:40a554b:             conn = DriverManager.getConnection(connectionURL);
1:40a554b:             util.DEBUG("3. startSlave Unexpectedly connected as: " + connectionURL);
1:40a554b:             assertTrue("3. startSlave Unexpectedly connected as: " + connectionURL, false);
1:40a554b:         }
1:40a554b:         catch (SQLException se)
1:40a554b:         {
1:40a554b:             int ec = se.getErrorCode();
1:40a554b:             String ss = se.getSQLState();
1:40a554b:             String msg = ec + " " + ss + " " + se.getMessage();
1:40a554b:             util.DEBUG("3. startSlave No connection as expected: " + msg);
1:8c9d41e:             BaseJDBCTestCase.assertSQLState(
1:8c9d41e:                 "3. Unexpected SQLException: " + msg,
1:8c9d41e:                 CANNOT_CONNECT_TO_DB_IN_SLAVE_MODE,
1:8c9d41e:                 se);
1:40a554b:         }
1:40a554b:     }
1:40a554b:     
1:40a554b: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("ReplicationRun_Local_StateTest_part1 Suite");
commit:8c9d41e
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
/////////////////////////////////////////////////////////////////////////
1:     final static String CANNOT_CONNECT_TO_DB_IN_SLAVE_MODE = "08004";
1:     final static String LOGIN_FAILED = "08004";
1:     final static String REPLICATION_DB_NOT_BOOTED = "XRE11";
1:     final static String REPLICATION_MASTER_ALREADY_BOOTED = "XRE22";
1:     final static String REPLICATION_NOT_IN_MASTER_MODE = "XRE07";
1:     final static String REPLICATION_SLAVE_STARTED_OK = "XRE08";
1: 
1: 
1: 
1: /**
/////////////////////////////////////////////////////////////////////////
1:             BaseJDBCTestCase.assertSQLState(
1:                 "stopMaster on master failed: " + msg,
1:                 REPLICATION_NOT_IN_MASTER_MODE,
1:                 se);
/////////////////////////////////////////////////////////////////////////
1:             BaseJDBCTestCase.assertSQLState(
1:                 "stopSlave on slave failed: " + msg,
1:                 REPLICATION_DB_NOT_BOOTED,
1:                 se);
/////////////////////////////////////////////////////////////////////////
1:             BaseJDBCTestCase.assertSQLState(
1:                 "2. Unexpected SQLException: " + msg,
1:                 REPLICATION_SLAVE_STARTED_OK,
1:                 se);
/////////////////////////////////////////////////////////////////////////
1:             BaseJDBCTestCase.assertSQLState(
1:                 "2. Unexpected SQLException: " + msg,
1:                 LOGIN_FAILED,
1:                 se);
/////////////////////////////////////////////////////////////////////////
1:             BaseJDBCTestCase.assertSQLState(
1:                 "1. Unexpected SQLException: " + msg,
1:                 REPLICATION_CONNECTION_EXCEPTION,
1:                 se);
/////////////////////////////////////////////////////////////////////////
1:             BaseJDBCTestCase.assertSQLState(
1:                 "2. Unexpected SQLException: " + msg,
1:                 REPLICATION_MASTER_ALREADY_BOOTED,
1:                 se);
/////////////////////////////////////////////////////////////////////////
1:             BaseJDBCTestCase.assertSQLState(
1:                 "3. Unexpected SQLException: " + msg,
1:                 CANNOT_CONNECT_TO_DB_IN_SLAVE_MODE,
1:                 se);
commit:9c2b1f3
/////////////////////////////////////////////////////////////////////////
1: Derby - Class org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationRun_Local_StateTest_part1
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:136610d
/////////////////////////////////////////////////////////////////////////
1:         startServer(masterJvmVersion, derbyMasterVersion,
/////////////////////////////////////////////////////////////////////////
1:         startServer(slaveJvmVersion, derbySlaveVersion,
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:7a6650c
/////////////////////////////////////////////////////////////////////////
0:                    SQLState.CANNOT_CONNECT_TO_DB_IN_SLAVE_MODE.startsWith(ss));
commit:dbe5dc3
/////////////////////////////////////////////////////////////////////////
1:                 masterDbSubPath); // Distinguishing master/slave
/////////////////////////////////////////////////////////////////////////
1:                 slaveDbSubPath); // Distinguishing master/slave
/////////////////////////////////////////////////////////////////////////
1:         String db = masterDatabasePath +FS+ReplicationRun.masterDbSubPath +FS+ replicatedDb;
/////////////////////////////////////////////////////////////////////////
1:         String db = slaveDatabasePath +FS+ReplicationRun.slaveDbSubPath +FS+ replicatedDb;
/////////////////////////////////////////////////////////////////////////
1:         db = masterDatabasePath +FS+ReplicationRun.masterDbSubPath +FS+ replicatedDb;
/////////////////////////////////////////////////////////////////////////
1:         db = slaveDatabasePath +FS+ReplicationRun.slaveDbSubPath +FS+ replicatedDb;
/////////////////////////////////////////////////////////////////////////
1:         String db = slaveDatabasePath +FS+ReplicationRun.slaveDbSubPath +FS+ replicatedDb;
/////////////////////////////////////////////////////////////////////////
1:         String db = masterDatabasePath +FS+ReplicationRun.masterDbSubPath +FS+ replicatedDb;
/////////////////////////////////////////////////////////////////////////
1:         db = slaveDatabasePath +FS+ReplicationRun.slaveDbSubPath +FS+ replicatedDb;
commit:40a554b
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
0: Derby - Class org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationRun
1:  
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1:  
1:    http://www.apache.org/licenses/LICENSE-2.0
1:  
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1:  
1:  */
1: package org.apache.derbyTesting.functionTests.tests.replicationTests;
1: 
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.SQLException;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derby.shared.common.reference.SQLState;
1: import org.apache.derbyTesting.junit.SecurityManagerSetup;
1: 
1: 
1: /**
1:  * Run a replication test on localhost
1:  * by using default values for master and slave hosts,
1:  * and master and slave ports.
1:  * 
1:  */
1: 
1: public class ReplicationRun_Local_StateTest_part1 extends ReplicationRun
1: {
1:     
1:     /**
1:      * Creates a new instance of ReplicationRun_Local_StateTest_part1
1:      * 
1:      * @param testcaseName Identifying the test.
1:      */
1:     public ReplicationRun_Local_StateTest_part1(String testcaseName)
1:     {
1:         super(testcaseName);
1:     }
1:         
1:     public static Test suite()
1:     {
0:         TestSuite suite = new TestSuite("ReplicationRun_Local_StateTest_part1 Suite");
1:         
1:         suite.addTestSuite( ReplicationRun_Local_StateTest_part1.class );
1:         
1:         return SecurityManagerSetup.noSecurityManager(suite);
1:     }
1:     
1:     //////////////////////////////////////////////////////////////
1:     ////
1:     //// The replication test framework (testReplication()):
1:     //// a) "clean" replication run starting master and slave servers,
1:     ////     preparing master and slave databases,
1:     ////     starting and stopping replication and doing
1:     ////     failover for a "normal"/"failure free" replication
1:     ////     test run.
1:     ////
1:     //////////////////////////////////////////////////////////////
1:     
1:     public void testReplication_Local_StateTest_part1()
1:     throws Exception
1:     {
1:         cleanAllTestHosts();
1:         
1:         initEnvironment();
1:         
1:         // State test. Continuation OK.
1:         _testPreStartedMasterServer(); 
1:         
1:         initMaster(masterServerHost,
1:                 replicatedDb);
1:         
0:         masterServer = startServer(masterJvmVersion, derbyMasterVersion,
1:                 masterServerHost,
1:                 ALL_INTERFACES, // masterServerHost, // "0.0.0.0", // All. or use masterServerHost for interfacesToListenOn,
1:                 masterServerPort,
0:                 masterDatabasePath +FS+ masterDbSubPath); // Distinguishing master/slave
1:         
1:         // State test. 
1:         _testPreStartedSlaveServer(); 
1:         
0:         slaveServer = startServer(slaveJvmVersion, derbySlaveVersion,
1:                 slaveServerHost,
1:                 ALL_INTERFACES, // slaveServerHost, // "0.0.0.0", // All. or use slaveServerHost for interfacesToListenOn,
1:                 slaveServerPort,
0:                 slaveDatabasePath +FS+ slaveDbSubPath); // Distinguishing master/slave
1:         
1:         startServerMonitor(slaveServerHost);
1:         
1:         bootMasterDatabase(jvmVersion,
1:                 masterDatabasePath +FS+ masterDbSubPath,
1:                 replicatedDb,
1:                 masterServerHost, // Where the startreplication command must be given
1:                 masterServerPort, // master server interface accepting client requests
1:                 null // bootLoad, // The "test" to start when booting db.
1:                 );
1:         
1:         // State test. 
1:         _testPreInitSlave();
1:         
1:         initSlave(slaveServerHost,
1:                 jvmVersion,
1:                 replicatedDb); // Trunk and Prototype V2: copy master db to db_slave.
1:         
1:         // State test. 
1:         _testPreStartedSlave(); // Currently NOOP
1:         
1:         startSlave(jvmVersion, replicatedDb,
1:                 slaveServerHost, // slaveClientInterface // where the slave db runs
1:                 slaveServerPort,
1:                 slaveServerHost, // for slaveReplInterface
1:                 slaveReplPort,
1:                 testClientHost);
1:         
1:         // State test. 
1:         _testPreStartedMaster();
1:         
1:         // With master started above, next will fail! 
1:         // Also seems failover will fail w/XRE21! : DERBY-3358!
1:         // Further testing: skipping next startMaster seems to 
1:         // NOT remove failover failure!
1:         /* TEMP: should be operational already - try skipping this. * /
1:         startMaster(jvmVersion, replicatedDb,
1:                 masterServerHost, // Where the startMaster command must be given
1:                 masterServerPort, // master server interface accepting client requests
1:                 masterServerHost, // An interface on the master: masterClientInterface (==masterServerHost),
1:                 slaveServerPort, // Not used since slave don't allow clients.
1:                 slaveServerHost, // for slaveReplInterface
1:                 slaveReplPort);
1:          / * */
1:         
1:         // Used to run positive tests.
1:         // Handle negative testing in State.testPostStartedMasterAndSlave().
1:         // Observe that it will not be meaningful to do runTest if State.XXXX()
1:         // has led to incorrect replication state wrt. replicationTest.
1:         
1:         replicationTest = "org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationTestRun";
1:         util.DEBUG("replicationTest: " + replicationTest);
1:         replicationVerify = "org.apache.derbyTesting.functionTests.tests.replicationTests.ReplicationTestRun_Verify";
1:         util.DEBUG("replicationVerify: " + replicationVerify);
1: 
1:         runTest(replicationTest, // Returns immediatly if replicationTest is null.
1:                 jvmVersion,
1:                 testClientHost,
1:                 masterServerHost, masterServerPort,
1:                 replicatedDb);
1:         
1:         failOver(jvmVersion,
1:                 masterDatabasePath, masterDbSubPath, replicatedDb,
1:                 masterServerHost,  // Where the master db is run.
1:                 masterServerPort,
1:                 testClientHost);
1:         
1:         connectPing(slaveDatabasePath+FS+slaveDbSubPath+FS+replicatedDb,
1:                 slaveServerHost,slaveServerPort,
1:                 testClientHost);
1:         
1:         verifySlave();
1:         
1:         // We should verify the master as well, at least to see that we still can connect.
1:         verifyMaster();
1:         
1:         stopServer(jvmVersion, derbyVersion,
1:                 slaveServerHost, slaveServerPort);
1:         
1:         stopServer(jvmVersion, derbyVersion,
1:                 masterServerHost, masterServerPort);
1:         
1:     }
1: 
1:     private void _testPreStartedMasterServer()
1:     {
1:         Connection conn = null;
0:         String db = masterDatabasePath +"/"+ReplicationRun.masterDbSubPath +"/"+ replicatedDb;
1:         String connectionURL = "jdbc:derby:"
1:                 + "//" + masterServerHost + ":" + masterServerPort + "/"
1:                 + db
1:                 + ";startMaster=true"
1:                 + ";slavehost=" + slaveServerHost
1:                 + ";slaveport=" + slaveServerPort;
1:         util.DEBUG("testPreStartedMasterServer: " + connectionURL);
1:         try
1:         {
1:             conn = DriverManager.getConnection(connectionURL);
1:         }
1:         catch (SQLException se)
1:         {
1:             int ec = se.getErrorCode();
1:             String ss = se.getSQLState();
1:             String msg = ec + " " + ss + " " + se.getMessage();
1:             util.DEBUG("testStartMasterConnect_Illegal: " + msg);
1:             assertTrue("Unexpected SQLException: " + msg, "08001".equals(ss));
1:             util.DEBUG("As expected.");
1:             return;
1:         }
1:         assertTrue("Expected SQLException: '08001 " + db + "'",false);
1:     }
1: 
1:     private void _testPreStartedSlaveServer()
1:     {
1:         Connection conn = null;
0:         String db = slaveDatabasePath +"/"+ReplicationRun.slaveDbSubPath +"/"+ replicatedDb;
1:         String connectionURL = "jdbc:derby:"  
1:                 + "//" + slaveServerHost + ":" + slaveServerPort + "/"
1:                 + db
1:                 + ";startSlave=true"
1:                 + ";slavehost=" + slaveServerHost 
1:                 + ";slaveport=" + slaveServerPort;
1:         util.DEBUG("testPreStartedSlaveServer: " + connectionURL);
1:         try
1:         {
1:             conn = DriverManager.getConnection(connectionURL);
1:         }
1:         catch (SQLException se)
1:         {
1:             int ec = se.getErrorCode();
1:             String ss = se.getSQLState();
1:             String msg = ec + " " + ss + " " + se.getMessage();
1:             util.DEBUG("testStartSlaveConnect_Illegal: " + msg);
1:             assertTrue("Unexpected SQLException: " + msg, "08001".equals(ss));
1:             util.DEBUG("As expected.");
1:             return;
1:         }
1:         assertTrue("Expected SQLException: '08001 " + db + "'",false);
1:     }
1: 
1:     private void _testPreInitSlave()
1:     {
1:         String db = null;
1:         String connectionURL = null;
1:         Connection conn = null;
1:         
1:         // 1.  stopMaster on master: fail
0:         db = masterDatabasePath +"/"+ReplicationRun.masterDbSubPath +"/"+ replicatedDb;
1:         connectionURL = "jdbc:derby:"
1:                 + "//" + masterServerHost + ":" + masterServerPort + "/"
1:                 + db
1:                 + ";stopMaster=true";
1:         util.DEBUG("1. testPreInitSlave:" + connectionURL);
1:         try
1:         {
1:             conn = DriverManager.getConnection(connectionURL);
1:             util.DEBUG("Unexpectedly connected: " + connectionURL);
1:             assertTrue("Unexpectedly connected: " + connectionURL,false);
1:         }
1:         catch (SQLException se)
1:         {
1:             int ec = se.getErrorCode();
1:             String ss = se.getSQLState();
1:             String msg = ec + " " + ss + " " + se.getMessage();
1:             // SQLState.REPLICATION_NOT_IN_MASTER_MODE
1: 
0:             assertTrue("stopMaster on master failed: " + msg, 
0:                     SQLState.REPLICATION_NOT_IN_MASTER_MODE.equals(ss));
1:             util.DEBUG("stopMaster on master failed as expected: " + connectionURL + " " + msg);
1:         }
1:         
1:         // 2. stopSlave on slave: fail
0:         db = slaveDatabasePath +"/"+ReplicationRun.slaveDbSubPath +"/"+ replicatedDb;
1:         connectionURL = "jdbc:derby:"
1:                 + "//" + slaveServerHost + ":" + slaveServerPort + "/"
1:                 + db
1:                 + ";stopSlave=true";
1:         util.DEBUG("2. testPreInitSlave: " + connectionURL);
1:         try
1:         {
1:             conn = DriverManager.getConnection(connectionURL);
1:             util.DEBUG("Unexpectedly connected: " + connectionURL);
1:             assertTrue("Unexpectedly connected: " + connectionURL,false);
1:         }
1:         catch (SQLException se)
1:         {
1:             int ec = se.getErrorCode();
1:             String ss = se.getSQLState();
1:             String msg = ec + " " + ss + " " + se.getMessage();
0:             assertTrue("stopSlave on slave failed: " + msg, 
0:                     SQLState.REPLICATION_DB_NOT_BOOTED.equals(ss));
1:             util.DEBUG("stopSlave on slave failed as expected: " + connectionURL + " " + msg);
1:         }
1:     }
1: 
1:     private void _testPreStartedSlave()
1:     {
1:         Connection conn = null;
0:         String db = slaveDatabasePath +"/"+ReplicationRun.slaveDbSubPath +"/"+ replicatedDb;
1:         String connectionURL = "jdbc:derby:"  
1:                 + "//" + slaveServerHost + ":" + slaveServerPort + "/"
1:                 + db
1:                 + ";startSlave=true"
1:                 + ";slaveHost=" + slaveServerHost 
1:                 + ";slavePort=" + slaveReplPort;
1:         util.DEBUG("testPreStartedSlave: Test moved to TestPostStartedMasterAndSlave! " + connectionURL);
1:         if (true)return;
1:         
1:         // First StartSlave connect ok:
1:         try
1:         {
1:             conn = DriverManager.getConnection(connectionURL); 
1:             // Will hang until startMaster!
1:             util.DEBUG("1. Successfully connected as: " + connectionURL);
1:         }
1:         catch (SQLException se)
1:         {
1:             int ec = se.getErrorCode();
1:             String ss = se.getSQLState();
1:             String msg = ec + " " + ss + " " + se.getMessage();
1:             util.DEBUG(msg);
0:             assertTrue("2. Unexpected SQLException: " + msg, 
0:                     SQLState.REPLICATION_SLAVE_STARTED_OK.equals(ss));
1:         }
1:         
1:         // Next StartSlave connect should fail:
1:         try
1:         {
1:             conn = DriverManager.getConnection(connectionURL);
1:             util.DEBUG("2. Unexpectedly connected as: " + connectionURL);
1:             assertTrue("2. Unexpectedly connected as: " + connectionURL, false);
1:         }
1:         catch (SQLException se)
1:         {
1:             int ec = se.getErrorCode();
1:             String ss = se.getSQLState();
1:             String msg = ec + " " + ss + " " + se.getMessage();
1:             util.DEBUG(msg);
0:             assertTrue("2. Unexpected SQLException: " + msg, 
0:                     SQLState.LOGIN_FAILED.equals(ss));
1:         }
1:         
1:     }
1: 
1:     private void _testPreStartedMaster()
1:     throws Exception
1:     {
1:         Connection conn = null;
0:         String db = masterDatabasePath +"/"+ReplicationRun.masterDbSubPath +"/"+ replicatedDb;
1:         String connectionURL = "jdbc:derby:"  
1:                 + "//" + masterServerHost + ":" + masterServerPort + "/"
1:                 + db
1:                 + ";startMaster=true"
1:                 + ";slaveHost=" + slaveServerHost 
1:                 + ";slavePort=" + slaveReplPort;
1:         util.DEBUG("_testPreStartedMaster: " + connectionURL);
1:         // First StartMaster connect ok:
1:         // Must use "full" startMaster - including wait-loop.
1:         
1:         // Better move this to testPostStartedMasterAndSlave!
1:         startMaster(jvmVersion, replicatedDb,
1:                 masterServerHost, // Where the startMaster command must be given
1:                 masterServerPort, // master server interface accepting client requests
1:                 masterServerHost, // An interface on the master: masterClientInterface (==masterServerHost),
1:                 slaveServerPort, // Not used since slave don't allow clients.
1:                 slaveServerHost, // for slaveReplInterface
1:                 slaveReplPort);
1:         /* REMOVE!
1:         try
1:         {
1:             conn = DriverManager.getConnection(connectionURL);
1:             assertTrue("1. Unexpected!: startMaster Successfully connected as: " 
1:                     + connectionURL, false);
1:         }
1:         catch (SQLException se)
1:         {
1:             int ec = se.getErrorCode();
1:             String ss = se.getSQLState();
1:             String msg = ec + " " + ss + " " + se.getMessage();
1:             util.DEBUG(msg);
1:             util.DEBUG("1. startMaster: No connection as expected: " + msg);
0:             assertTrue("1. Unexpected SQLException: " + msg, 
0:                     SQLState.REPLICATION_CONNECTION_EXCEPTION.equals(ss));
1:         }
1:         */
1:         
1:         util.DEBUG("2. startMaster attempt should fail on: " + connectionURL);
1:         // util.DEBUG("********************'' 2. CURRENTLY HANGS!!!! Skipping.");
1:         // if (false) // FIXME! ENABLE WHEN DERBY-3358 COMMITTED!
1:         {
1:         // A 2. StartMaster connect should fail:
1:         try
1:         {
1:             conn = DriverManager.getConnection(connectionURL);
1:             util.DEBUG("2. Unexpectedly connected as: " + connectionURL);
1:             assertTrue("2. Unexpectedly connected as: " + connectionURL, false);
1:         }
1:         catch (SQLException se)
1:         {
1:             int ec = se.getErrorCode();
1:             String ss = se.getSQLState();
1:             String msg = ec + " " + ss + " " + se.getMessage();
1:             util.DEBUG("2. startMaster No connection as expected: " + msg);
0:             assertTrue("2. Unexpected SQLException: " + msg, 
0:                     SQLState.REPLICATION_MASTER_ALREADY_BOOTED.equals(ss));
1:         }
1:         }
1:         
1:         // A 2. StartSlave connect should fail:
1:         util.DEBUG("startSlave attempt should fail on: " + connectionURL);
0:         db = slaveDatabasePath +"/"+ReplicationRun.slaveDbSubPath +"/"+ replicatedDb;
1:         connectionURL = "jdbc:derby:"  
1:                 + "//" + slaveServerHost + ":" + slaveServerPort + "/"
1:                 + db
1:                 + ";startSlave=true"
1:                 + ";slaveHost=" + slaveServerHost 
1:                 + ";slavePort=" + slaveReplPort;
1:         util.DEBUG(connectionURL);
1:         try
1:         {
1:             conn = DriverManager.getConnection(connectionURL);
1:             util.DEBUG("3. startSlave Unexpectedly connected as: " + connectionURL);
1:             assertTrue("3. startSlave Unexpectedly connected as: " + connectionURL, false);
1:         }
1:         catch (SQLException se)
1:         {
1:             int ec = se.getErrorCode();
1:             String ss = se.getSQLState();
1:             String msg = ec + " " + ss + " " + se.getMessage();
1:             util.DEBUG("3. startSlave No connection as expected: " + msg);
0:             assertTrue("3. Unexpected SQLException: " + msg, 
0:                     SQLState.CANNOT_START_SLAVE_ALREADY_BOOTED.equals(ss));
1:         }
1:     }
1:     
1: }
============================================================================