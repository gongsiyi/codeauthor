3:fe77ca5: /*
1:8a93440: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.StatementNode
1:0393775: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:cc770d8: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:38fe427: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:38fe427: 
5:fe77ca5:  */
1:345de35: 
1:fe77ca5: package	org.apache.derby.impl.sql.compile;
1:345de35: 
1:3bb140c: import java.lang.reflect.Modifier;
1:fe77ca5: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.loader.GeneratedClass;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:354d5e8: import org.apache.derby.iapi.sql.ResultDescription;
1:fe77ca5: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:fe77ca5: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:fe77ca5: import org.apache.derby.iapi.store.access.ConglomerateController;
1:fe77ca5: import org.apache.derby.iapi.store.access.TransactionController;
1:fe77ca5: import org.apache.derby.iapi.util.ByteArray;
1:345de35: 
2:fe77ca5: /**
1:fe77ca5:  * A StatementNode represents a single statement in the language.  It is
1:fe77ca5:  * the top node for any statement.
1:fe77ca5:  * <p>
1:fe77ca5:  * StatementNode controls the class generation for query tree nodes.
1:cc770d8:  *
1:fe77ca5:  */
1:345de35: 
1:95e850d: /*
1:fe77ca5: * History:
1:fe77ca5: *	5/8/97	Rick Hilleags	Moved node-name-string to child classes.
1:fe77ca5: */
33:fe77ca5: 
1:d830d17: public abstract class StatementNode extends QueryTreeNode
2:fe77ca5: {
1:47eac7d:     /** Cached empty list object. */
1:47eac7d:     static final TableDescriptor[] EMPTY_TD_LIST = new TableDescriptor[0];
1:47eac7d: 
1:3bb140c:     StatementNode(ContextManager cm) {
1:3bb140c:         super(cm);
1:3bb140c:     }
1:3bb140c: 
1:8a93440: 	/**
1:fe77ca5: 	 * By default, assume StatementNodes are atomic.
1:fe77ca5: 	 * The rare statements that aren't atomic (e.g.
1:fe77ca5: 	 * CALL method()) override this.
1:354d5e8: 	 *
1:fe77ca5: 	 * @return true if the statement is atomic
1:354d5e8: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */	
1:3bb140c:     @Override
1:fe77ca5: 	public boolean isAtomic() throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		return true;
3:fe77ca5: 	}
1:354d5e8: 	
1:354d5e8: 	/**
1:8a93440: 	 * Returns whether or not this Statement requires a set/clear savepoint
1:8a93440: 	 * around its execution.  The following statement "types" do not require them:
1:8a93440: 	 *		Cursor	- unnecessary and won't work in a read only environment
1:8a93440: 	 *		Xact	- savepoint will get blown away underneath us during commit/rollback
1:8a93440: 	 * <p>
1:8a93440: 	 * ONLY CALLABLE AFTER GENERATION
1:95e850d: 	 * <P>
1:8a93440: 	 * This implementation returns true, sub-classes can override the
1:8a93440: 	 * method to not require a savepoint.
1:95e850d: 	 *
1:8a93440: 	 * @return boolean	Whether or not this Statement requires a set/clear savepoint
1:95e850d: 	 */
1:8a93440: 	public boolean needsSavepoint()
1:8a93440: 	{
1:8a93440: 		return true;
1:8a93440: 	}
1:95e850d: 	
1:d725d43: 	/**
1:354d5e8: 	 * Get the name of the SPS that is used to execute this statement. Only
1:354d5e8: 	 * relevant for an ExecSPSNode -- otherwise, returns null.
1:95e850d: 	 * 
1:354d5e8: 	 * @return the name of the underlying sps
1:354d5e8: 	 */
1:354d5e8: 	public String getSPSName() {
1:354d5e8: 		return null;
1:354d5e8: 	}
1:8a93440: 
1:dda453e: 	/**
1:354d5e8: 	 * Returns the name of statement in EXECUTE STATEMENT command. Returns null
1:354d5e8: 	 * for all other commands.
1:95e850d: 	 * 
1:354d5e8: 	 * @return String null unless overridden for Execute Statement command
1:354d5e8: 	 */
1:354d5e8: 	public String executeStatementName() {
1:354d5e8: 		return null;
1:354d5e8: 	}
1:354d5e8: 
1:354d5e8: 	/**
1:354d5e8: 	 * Returns name of schema in EXECUTE STATEMENT command. Returns null for all
1:354d5e8: 	 * other commands.
1:95e850d: 	 * 
1:354d5e8: 	 * @return String schema for EXECUTE STATEMENT null for all others
1:354d5e8: 	 */
1:354d5e8: 	public String executeSchemaName() {
1:354d5e8: 		return null;
1:354d5e8: 	}
1:354d5e8: 	
1:354d5e8: 	/**
1:354d5e8: 	 * Only DML statements have result descriptions - for all others return
1:354d5e8: 	 * null. This method is overridden in DMLStatementNode.
1:354d5e8: 	 * 
1:354d5e8: 	 * @return null
1:354d5e8: 	 * 
1:354d5e8: 	 */
1:354d5e8: 	public ResultDescription makeResultDescription() {
1:354d5e8: 		return null;
1:354d5e8: 	}
1:354d5e8: 
1:354d5e8:     /**
1:dda453e:      * Get an object with information about the cursor if there is one.
1:dda453e:      */
1:dda453e:     public Object getCursorInfo() throws StandardException {
1:dda453e:         return null;
1:dda453e:     }
1:dda453e: 
1:cc770d8: 	/**
1:354d5e8: 	 * Convert this object to a String. See comments in QueryTreeNode.java for
1:354d5e8: 	 * how this should be done for tree printing.
1:354d5e8: 	 * 
1:354d5e8: 	 * @return This object as a String
1:8a93440: 	 */
1:3bb140c:     @Override
1:fe77ca5: 	public String toString()
1:fe77ca5: 	{
1:fe77ca5: 		if (SanityManager.DEBUG)
1:fe77ca5: 		{
1:fe77ca5: 			return "statementType: " + statementToString() + "\n" +
1:fe77ca5: 				super.toString();
1:fe77ca5: 		}
1:fe77ca5: 		else
1:fe77ca5: 		{
1:fe77ca5: 			return "";
1:fe77ca5: 		}
1:fe77ca5: 	}
1:be0b54f: 
1:3bb140c:     abstract String statementToString();
1:d725d43: 	
1:fe77ca5: 	/**
1:cc770d8: 	 * Perform the binding operation statement.  Binding consists of
1:cc770d8: 	 * permissions checking, view resolution, datatype resolution, and
1:cc770d8: 	 * creation of a dependency list (for determining whether a tree or
1:cc770d8: 	 * plan is still up to date).
1:354d5e8: 	 *
1:cc770d8: 	 * This bindStatement() method does nothing. 
1:cc770d8: 	 * Each StatementNode type that can appear
1:cc770d8: 	 * at the top of a tree can override this method with its
1:cc770d8: 	 * own bindStatement() method that does "something".
1:8a93440: 	 *
1:cc770d8: 	 * @exception StandardException		Thrown on error
1:cc770d8: 	 */
1:cc770d8: 
1:cc770d8: 	public void bindStatement() throws StandardException
1:cc770d8: 	{
1:cc770d8: 	}
1:cc770d8: 	
1:fe77ca5: 	/**
1:d725d43: 	 * Generates an optimized statement from a bound StatementNode.  Actually,
1:d725d43: 	 * it annotates the tree in place rather than generating a new tree.
1:d725d43: 	 *
1:d725d43: 	 * For non-optimizable statements (for example, CREATE TABLE),
1:d725d43: 	 * return the bound tree without doing anything.  For optimizable
1:d725d43: 	 * statements, this method will be over-ridden in the statement's
1:d725d43: 	 * root node (DMLStatementNode in all cases we know about so far).
1:d725d43: 	 *
1:d725d43: 	 * Throws an exception if the tree is not bound, or if the binding
1:d725d43: 	 * is out of date.
1:d725d43: 	 *
1:d725d43: 	 *
1:d725d43: 	 * @exception StandardException		Thrown on error
1:d725d43: 	 */
1:3bb140c:     public void optimizeStatement() throws StandardException
1:d725d43: 	{
1:d725d43: 		
1:d725d43: 	}
1:38fe427: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * create the outer shell class builder for the class we will
1:fe77ca5: 	 * be generating, generate the expression to stuff in it,
1:fe77ca5: 	 * and turn it into a class.
1:fe77ca5: 	 */
1:fe77ca5: 	static final int NEED_DDL_ACTIVATION = 5;
1:fe77ca5: 	static final int NEED_CURSOR_ACTIVATION = 4;
1:fe77ca5: 	static final int NEED_PARAM_ACTIVATION = 2;
1:fe77ca5: 	static final int NEED_ROW_ACTIVATION = 1;
1:fe77ca5: 	static final int NEED_NOTHING_ACTIVATION = 0;
1:fe77ca5: 
1:fe77ca5: 	abstract int activationKind();
1:fe77ca5: 
1:fe77ca5: 	/* We need to get some kind of table lock (IX here) at the beginning of
1:fe77ca5: 	 * compilation of DMLModStatementNode and DDLStatementNode, to prevent the
1:fe77ca5: 	 * interference of insert/update/delete/DDL compilation and DDL execution,
1:fe77ca5: 	 * see beetle 3976, 4343, and $WS/language/SolutionsToConcurrencyIssues.txt
1:fe77ca5: 	 */
1:fe77ca5: 	protected TableDescriptor lockTableForCompilation(TableDescriptor td)
1:fe77ca5: 		throws StandardException
1:d725d43: 	{
1:fe77ca5: 		DataDictionary dd = getDataDictionary();
1:fe77ca5: 
1:fe77ca5: 		/* we need to lock only if the data dictionary is in DDL cache mode
1:fe77ca5: 		 */
1:fe77ca5: 		if (dd.getCacheMode() == DataDictionary.DDL_MODE)
1:fe77ca5: 		{
1:fe77ca5: 			ConglomerateController  heapCC;
1:fe77ca5: 			TransactionController tc =
1:fe77ca5: 				getLanguageConnectionContext().getTransactionCompile();
1:fe77ca5: 
1:fe77ca5: 			heapCC = tc.openConglomerate(td.getHeapConglomerateId(),
1:fe77ca5:                                     false,
1:fe77ca5: 									TransactionController.OPENMODE_FORUPDATE |
1:fe77ca5: 									TransactionController.OPENMODE_FOR_LOCK_ONLY,
1:fe77ca5: 									TransactionController.MODE_RECORD,
1:fe77ca5: 									TransactionController.ISOLATION_SERIALIZABLE);
1:fe77ca5: 			heapCC.close();
1:fe77ca5: 			/*
1:fe77ca5: 			** Need to get TableDescriptor again after getting the lock, in
1:fe77ca5: 			** case for example, a concurrent add column thread commits
1:fe77ca5: 			** while we are binding.
1:fe77ca5: 			*/
1:fe77ca5: 			String tableName = td.getName();
1:fe77ca5: 			td = getTableDescriptor(td.getName(), getSchemaDescriptor(td.getSchemaName()));
1:fe77ca5: 			if (td == null)
1:fe77ca5: 			{
1:fe77ca5: 				throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND, tableName);
1:d725d43: 			}
1:cc770d8: 		}
1:fe77ca5: 		return td;
1:fe77ca5: 	}
1:fe77ca5: 
1:fe77ca5: 
1:fe77ca5: 	/**
1:fe77ca5: 	 * Do code generation for this statement.
1:cc770d8: 	 *
1:6b50965: 	 * @param byteCode	the generated byte code for this statement.
1:fe77ca5: 	 *			if non-null, then the byte code is saved
1:fe77ca5: 	 *			here.
6:fe77ca5: 	 *
1:fe77ca5: 	 * @return		A GeneratedClass for this statement
1:fe77ca5: 	 *
1:fe77ca5: 	 * @exception StandardException		Thrown on error
1:fe77ca5: 	 */
1:fe77ca5: 	public GeneratedClass generate(ByteArray byteCode) throws StandardException
1:fe77ca5: 	{
1:fe77ca5: 		// start the new activation class.
1:fe77ca5: 		// it starts with the Execute method
1:fe77ca5: 		// and the appropriate superclass (based on
1:fe77ca5: 		// statement type, from inspecting the queryTree).
1:fe77ca5: 
1:fe77ca5: 		int nodeChoice = activationKind();
1:fe77ca5: 
1:fe77ca5: 		/* RESOLVE: Activation hierarchy was way too complicated
1:fe77ca5: 		 * and added no value.  Simple thing to do was to simply
1:fe77ca5: 		 * leave calling code alone and to handle here and to
1:fe77ca5: 		 * eliminate unnecessary classes.
1:fe77ca5: 		 */
1:fe77ca5: 		String superClass;
1:fe77ca5: 		switch (nodeChoice)
1:fe77ca5: 		{
1:fe77ca5: 		case NEED_CURSOR_ACTIVATION:
1:fe77ca5: 			superClass = ClassName.CursorActivation;
1:fe77ca5: 			break;
1:fe77ca5: 		case NEED_DDL_ACTIVATION:
1:fe77ca5: 			return getClassFactory().loadGeneratedClass(
1:fe77ca5: 				"org.apache.derby.impl.sql.execute.ConstantActionActivation", null);
1:fe77ca5: 
1:fe77ca5: 		case NEED_NOTHING_ACTIVATION :
1:fe77ca5: 		case NEED_ROW_ACTIVATION :
1:fe77ca5: 		case NEED_PARAM_ACTIVATION :
1:fe77ca5: 			superClass = ClassName.BaseActivation;
1:fe77ca5: 			break;
1:fe77ca5: 		default :
1:fe77ca5: 			throw StandardException.newException(SQLState.LANG_UNAVAILABLE_ACTIVATION_NEED,
1:fe77ca5: 					String.valueOf(nodeChoice));
1:fe77ca5: 		}
1:fe77ca5: 
1:fe77ca5: 		ActivationClassBuilder generatingClass = new ActivationClassBuilder(
1:fe77ca5: 										superClass, 
1:fe77ca5: 										getCompilerContext());
1:95e850d: 
1:d11ed08:         // Create the method that generates the ResultSet tree used when
1:d11ed08:         // executing this statement. Implements the abstract method
1:d11ed08:         // BaseActivation.createResultSet().
1:95e850d:         MethodBuilder mbWorker = generatingClass.getClassBuilder().newMethodBuilder(
1:d11ed08:                 Modifier.PROTECTED,
1:95e850d:                 ClassName.ResultSet,
1:d11ed08:                 "createResultSet");
1:95e850d:         mbWorker.addThrownException(ClassName.StandardException);
1:95e850d:         
1:95e850d:         // Generate the complete ResultSet tree for this statement.
1:95e850d:         // This step may add statements into the execute method
1:95e850d:         // for per-execution actions.
1:95e850d:         generate(generatingClass, mbWorker);
1:95e850d:         mbWorker.methodReturn();
1:95e850d:         mbWorker.complete();
1:edb7fcc: 
1:fe77ca5:    		// wrap up the activation class definition
1:fe77ca5: 		// generate on the tree gave us back the newExpr
1:fe77ca5: 		// for getting a result set on the tree.
1:fe77ca5: 		// we put it in a return statement and stuff
1:fe77ca5: 		// it in the execute method of the activation.
1:fe77ca5: 		// The generated statement is the expression:
1:fe77ca5: 		// the activation class builder takes care of constructing it
1:fe77ca5: 		// for us, given the resultSetExpr to use.
1:fe77ca5: 		//   return (this.resultSet = #resultSetExpr);
1:d11ed08: 		generatingClass.finishExecuteMethod();
1:edb7fcc: 
1:fe77ca5: 		// wrap up the constructor by putting a return at the end of it
1:fe77ca5: 		generatingClass.finishConstructor();
1:edb7fcc: 
1:38fe427: 		try {
1:38fe427: 			// cook the completed class into a real class
1:38fe427: 			// and stuff it into activationClass
1:38fe427: 			GeneratedClass activationClass = generatingClass.getGeneratedClass(byteCode);
1:edb7fcc: 
1:38fe427: 			return activationClass;
1:38fe427: 		} catch (StandardException e) {
1:95e850d: 			
1:38fe427: 			String msgId = e.getMessageId();
1:95e850d: 
1:38fe427: 			if (SQLState.GENERATED_CLASS_LIMIT_EXCEEDED.equals(msgId)
1:38fe427: 					|| SQLState.GENERATED_CLASS_LINKAGE_ERROR.equals(msgId))
1:38fe427: 			{
1:38fe427: 				throw StandardException.newException(
1:38fe427: 						SQLState.LANG_QUERY_TOO_COMPLEX, e);
1:38fe427: 			}
1:95e850d: 	
1:38fe427: 			throw e;
1:38fe427: 		}
1:fe77ca5: 	 }
1:47eac7d: 
1:47eac7d:     /**
1:47eac7d:      * Returns a list of base tables for which the index statistics of the
1:47eac7d:      * associated indexes should be updated.
1:47eac7d:      * <p>
1:47eac7d:      * This default implementation always returns an empty list.
1:47eac7d:      *
1:47eac7d:      * @return A list of table descriptors (potentially empty).
1:47eac7d:      * @throws StandardException if accessing the index descriptors of a base
1:47eac7d:      *      table fails
1:47eac7d:      */
1:47eac7d:     public TableDescriptor[] updateIndexStatisticsFor()
1:47eac7d:             throws StandardException {
1:47eac7d:         // Do nothing, overridden by appropriate nodes.
1:47eac7d:         return EMPTY_TD_LIST;
1:47eac7d:     }
1:fe77ca5: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.lang.reflect.Modifier;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:     StatementNode(ContextManager cm) {
1:         super(cm);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     abstract String statementToString();
/////////////////////////////////////////////////////////////////////////
1:     public void optimizeStatement() throws StandardException
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:dda453e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get an object with information about the cursor if there is one.
1:      */
1:     public Object getCursorInfo() throws StandardException {
1:         return null;
1:     }
1: 
commit:f542632
/////////////////////////////////////////////////////////////////////////
commit:d11ed08
/////////////////////////////////////////////////////////////////////////
1:         // Create the method that generates the ResultSet tree used when
1:         // executing this statement. Implements the abstract method
1:         // BaseActivation.createResultSet().
1:                 Modifier.PROTECTED,
1:                 "createResultSet");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		generatingClass.finishExecuteMethod();
commit:edb7fcc
/////////////////////////////////////////////////////////////////////////
0:          * Two methods are generated here: doExecute() and
0:          * doExecute() is called for every execution of the
/////////////////////////////////////////////////////////////////////////
0:          * protected ResultSet doExecute() {
/////////////////////////////////////////////////////////////////////////
0:         // Get the value of the resultSet field.
1: 
0:         // Keep a copy of the field value on the stack so we don't need
0:         // to look it up again if it's non-null.
0:         executeMethod.dup();
1: 
0:             // The field was null, so we won't use the value that's on the
0:             // stack. Forget about it.
0:             executeMethod.pop();
1: 
1: 
0:             // Push this onto the stack twice, as both callMethod() and
0:             // putField() take the instance as first operand.
0:             executeMethod.dup();
commit:0393775
/////////////////////////////////////////////////////////////////////////
0:         // wrap up the static initializer by putting a return at the end of it
0:         generatingClass.finishStaticInitializer();
1: 
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:47eac7d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /** Cached empty list object. */
1:     static final TableDescriptor[] EMPTY_TD_LIST = new TableDescriptor[0];
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Returns a list of base tables for which the index statistics of the
1:      * associated indexes should be updated.
1:      * <p>
1:      * This default implementation always returns an empty list.
1:      *
1:      * @return A list of table descriptors (potentially empty).
1:      * @throws StandardException if accessing the index descriptors of a base
1:      *      table fails
1:      */
1:     public TableDescriptor[] updateIndexStatisticsFor()
1:             throws StandardException {
1:         // Do nothing, overridden by appropriate nodes.
1:         return EMPTY_TD_LIST;
1:     }
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:95e850d
/////////////////////////////////////////////////////////////////////////
1:         /*
0:          * Generate the code to execute this statement.
0:          * Two methods are generated here: execute() and
0:          * fillResultSet().
0:          * <BR>
0:          * execute is called for every execution of the
0:          * Activation. Nodes may add code to this using
0:          * ActivationClassBuilder.getExecuteMethod().
0:          * This code will be executed every execution.
0:          * <BR>
0:          * fillResultSet is called by execute if the BaseActivation's
0:          * resultSet field is null and the returned ResultSet is
0:          * set into the the resultSet field.
1:          * <P>
0:          * The generated code is equivalent to:
0:          * <code>
0:          * public ResultSet execute() {
1:          * 
0:          *    // these two added by ActivationClassBuilder
0:          *    throwIfClosed("execute");
0:          *    startExecution();
1:          *    
0:          *    [per-execution code added by nodes]
1:          *    
0:          *    if (resultSet == null)
0:          *        resultSet = fillResultSet();
1:          *    
0:          *    return resultSet;
0:          * }
0:          * </code>
1:          */
0:         MethodBuilder executeMethod = generatingClass.getExecuteMethod();
1: 
1:         MethodBuilder mbWorker = generatingClass.getClassBuilder().newMethodBuilder(
0:                 Modifier.PRIVATE,
1:                 ClassName.ResultSet,
0:                 "fillResultSet");
1:         mbWorker.addThrownException(ClassName.StandardException);
1:         
1:         // Generate the complete ResultSet tree for this statement.
1:         // This step may add statements into the execute method
1:         // for per-execution actions.
1:         generate(generatingClass, mbWorker);
1:         mbWorker.methodReturn();
1:         mbWorker.complete();
0: 		executeMethod.getField(ClassName.BaseActivation, "resultSet",
0:                 ClassName.ResultSet);
1:         
1:         
0:             // Generate the result set tree and store the
0:             // resulting top-level result set into the resultSet
0:             // field, as well as returning it from the execute method.
1: 			
0:             executeMethod.pushThis();
0:             executeMethod.swap();
0:             executeMethod.putField(ClassName.BaseActivation, "resultSet", ClassName.ResultSet);
1:             
commit:354d5e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.ResultDescription;
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Get the name of the SPS that is used to execute this statement. Only
1: 	 * relevant for an ExecSPSNode -- otherwise, returns null.
1: 	 * 
1: 	 * @return the name of the underlying sps
1: 	 */
1: 	public String getSPSName() {
1: 		return null;
1: 	}
1: 	 * Returns the name of statement in EXECUTE STATEMENT command. Returns null
1: 	 * for all other commands.
1: 	 * 
1: 	 * @return String null unless overridden for Execute Statement command
1: 	 */
1: 	public String executeStatementName() {
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Returns name of schema in EXECUTE STATEMENT command. Returns null for all
1: 	 * other commands.
1: 	 * 
1: 	 * @return String schema for EXECUTE STATEMENT null for all others
1: 	 */
1: 	public String executeSchemaName() {
1: 		return null;
1: 	}
1: 	
1: 	/**
1: 	 * Only DML statements have result descriptions - for all others return
1: 	 * null. This method is overridden in DMLStatementNode.
1: 	 * 
1: 	 * @return null
1: 	 * 
1: 	 */
1: 	public ResultDescription makeResultDescription() {
1: 		return null;
1: 	}
1: 
1: 	/**
1: 	 * Convert this object to a String. See comments in QueryTreeNode.java for
1: 	 * how this should be done for tree printing.
1: 	 * 
1: 	 * @return This object as a String
commit:8a93440
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Returns whether or not this Statement requires a set/clear savepoint
1: 	 * around its execution.  The following statement "types" do not require them:
1: 	 *		Cursor	- unnecessary and won't work in a read only environment
1: 	 *		Xact	- savepoint will get blown away underneath us during commit/rollback
1: 	 * <p>
1: 	 * ONLY CALLABLE AFTER GENERATION
0: 	 * <P>
1: 	 * This implementation returns true, sub-classes can override the
1: 	 * method to not require a savepoint.
1: 	 *
1: 	 * @return boolean	Whether or not this Statement requires a set/clear savepoint
1: 	 */
1: 	public boolean needsSavepoint()
1: 	{
1: 		return true;
1: 	}
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
commit:be0b54f
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.Parser;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
/////////////////////////////////////////////////////////////////////////
1: 	
commit:d725d43
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Generates an optimized statement from a bound StatementNode.  Actually,
1: 	 * it annotates the tree in place rather than generating a new tree.
1: 	 *
1: 	 * For non-optimizable statements (for example, CREATE TABLE),
1: 	 * return the bound tree without doing anything.  For optimizable
1: 	 * statements, this method will be over-ridden in the statement's
1: 	 * root node (DMLStatementNode in all cases we know about so far).
1: 	 *
1: 	 * Throws an exception if the tree is not bound, or if the binding
1: 	 * is out of date.
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void  optimizeStatement() throws StandardException
1: 	{
1: 		
1: 	}
0: 	// TEMP -RE_WORK for switching to StatementNode.
0: 	public final QueryTreeNode optimize() throws StandardException
1: 	{
0: 		optimizeStatement();
0: 		return this;
1: 	}
commit:cc770d8
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Perform the binding operation statement.  Binding consists of
1: 	 * permissions checking, view resolution, datatype resolution, and
1: 	 * creation of a dependency list (for determining whether a tree or
1: 	 * plan is still up to date).
1: 	 *
1: 	 * This bindStatement() method does nothing. 
1: 	 * Each StatementNode type that can appear
1: 	 * at the top of a tree can override this method with its
1: 	 * own bindStatement() method that does "something".
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public void bindStatement() throws StandardException
1: 	{
1: 	}
1: 	
0: 	// TEMP map QueryTreeNode.bind() onto bindStatement()
0: 	// for StatementNode. Part of incremental development
0: 	// in switching the api for a compiled statement to
0: 	// be StatementNode.
0: 	public final QueryTreeNode bind() throws StandardException {
0: 		bindStatement();
0: 		return this;
1: 	}
commit:d830d17
/////////////////////////////////////////////////////////////////////////
1: public abstract class StatementNode extends QueryTreeNode
commit:0061383
/////////////////////////////////////////////////////////////////////////
0: abstract class StatementNode extends QueryTreeNode
commit:38fe427
/////////////////////////////////////////////////////////////////////////
1: 		try {
1: 			// cook the completed class into a real class
1: 			// and stuff it into activationClass
1: 			GeneratedClass activationClass = generatingClass.getGeneratedClass(byteCode);
1: 			return activationClass;
1: 		} catch (StandardException e) {
1: 			
1: 			String msgId = e.getMessageId();
1: 
1: 			if (SQLState.GENERATED_CLASS_LIMIT_EXCEEDED.equals(msgId)
1: 					|| SQLState.GENERATED_CLASS_LINKAGE_ERROR.equals(msgId))
1: 			{
1: 				throw StandardException.newException(
1: 						SQLState.LANG_QUERY_TOO_COMPLEX, e);
1: 			}
1: 	
1: 			throw e;
1: 		}
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.StatementNode
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
1: 
1: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import java.lang.reflect.Modifier;
1: 
1: /**
1:  * A StatementNode represents a single statement in the language.  It is
1:  * the top node for any statement.
1:  * <p>
1:  * StatementNode controls the class generation for query tree nodes.
1:  *
0:  * @author Jeff Lichtman
1:  */
1: 
1: /*
1: * History:
1: *	5/8/97	Rick Hilleags	Moved node-name-string to child classes.
1: */
1: 
0: public abstract class StatementNode extends QueryTreeNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/**
1: 	 * By default, assume StatementNodes are atomic.
1: 	 * The rare statements that aren't atomic (e.g.
1: 	 * CALL method()) override this.
1: 	 *
1: 	 * @return true if the statement is atomic
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */	
1: 	public boolean isAtomic() throws StandardException
1: 	{
1: 		return true;
1: 	}
1: 
1: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
1: 	 *
0: 	 * @return	This object as a String
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			return "statementType: " + statementToString() + "\n" +
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: 
0: 	public abstract String statementToString();
1: 
1: 	/**
1: 	 * create the outer shell class builder for the class we will
1: 	 * be generating, generate the expression to stuff in it,
1: 	 * and turn it into a class.
1: 	 */
1: 	static final int NEED_DDL_ACTIVATION = 5;
1: 	static final int NEED_CURSOR_ACTIVATION = 4;
1: 	static final int NEED_PARAM_ACTIVATION = 2;
1: 	static final int NEED_ROW_ACTIVATION = 1;
1: 	static final int NEED_NOTHING_ACTIVATION = 0;
1: 
1: 	abstract int activationKind();
1: 
1: 	/* We need to get some kind of table lock (IX here) at the beginning of
1: 	 * compilation of DMLModStatementNode and DDLStatementNode, to prevent the
1: 	 * interference of insert/update/delete/DDL compilation and DDL execution,
1: 	 * see beetle 3976, 4343, and $WS/language/SolutionsToConcurrencyIssues.txt
1: 	 */
1: 	protected TableDescriptor lockTableForCompilation(TableDescriptor td)
1: 		throws StandardException
1: 	{
1: 		DataDictionary dd = getDataDictionary();
1: 
1: 		/* we need to lock only if the data dictionary is in DDL cache mode
1: 		 */
1: 		if (dd.getCacheMode() == DataDictionary.DDL_MODE)
1: 		{
1: 			ConglomerateController  heapCC;
1: 			TransactionController tc =
1: 				getLanguageConnectionContext().getTransactionCompile();
1: 
1: 			heapCC = tc.openConglomerate(td.getHeapConglomerateId(),
1:                                     false,
1: 									TransactionController.OPENMODE_FORUPDATE |
1: 									TransactionController.OPENMODE_FOR_LOCK_ONLY,
1: 									TransactionController.MODE_RECORD,
1: 									TransactionController.ISOLATION_SERIALIZABLE);
1: 			heapCC.close();
1: 			/*
1: 			** Need to get TableDescriptor again after getting the lock, in
1: 			** case for example, a concurrent add column thread commits
1: 			** while we are binding.
1: 			*/
1: 			String tableName = td.getName();
1: 			td = getTableDescriptor(td.getName(), getSchemaDescriptor(td.getSchemaName()));
1: 			if (td == null)
1: 			{
1: 				throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND, tableName);
1: 			}
1: 		}
1: 		return td;
1: 	}
1: 
1: 
1: 	/**
1: 	 * Do code generation for this statement.
1: 	 *
0: 	 * @param	the generated byte code for this statement.
1: 	 *			if non-null, then the byte code is saved
1: 	 *			here.
1: 	 *
1: 	 * @return		A GeneratedClass for this statement
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public GeneratedClass generate(ByteArray byteCode) throws StandardException
1: 	{
1: 		// start the new activation class.
1: 		// it starts with the Execute method
1: 		// and the appropriate superclass (based on
1: 		// statement type, from inspecting the queryTree).
1: 
1: 		int nodeChoice = activationKind();
1: 
1: 		/* RESOLVE: Activation hierarchy was way too complicated
1: 		 * and added no value.  Simple thing to do was to simply
1: 		 * leave calling code alone and to handle here and to
1: 		 * eliminate unnecessary classes.
1: 		 */
1: 		String superClass;
1: 		switch (nodeChoice)
1: 		{
1: 		case NEED_CURSOR_ACTIVATION:
1: 			superClass = ClassName.CursorActivation;
1: 			break;
1: 		case NEED_DDL_ACTIVATION:
1: 			return getClassFactory().loadGeneratedClass(
1: 				"org.apache.derby.impl.sql.execute.ConstantActionActivation", null);
1: 
1: 		case NEED_NOTHING_ACTIVATION :
1: 		case NEED_ROW_ACTIVATION :
1: 		case NEED_PARAM_ACTIVATION :
1: 			superClass = ClassName.BaseActivation;
1: 			break;
1: 		default :
1: 			throw StandardException.newException(SQLState.LANG_UNAVAILABLE_ACTIVATION_NEED,
1: 					String.valueOf(nodeChoice));
1: 		}
1: 
1: 		ActivationClassBuilder generatingClass = new ActivationClassBuilder(
1: 										superClass, 
1: 										getCompilerContext());
0: 		MethodBuilder executeMethod = generatingClass.getExecuteMethod();
1: 
1: 
1: 		/*
0: 		** the resultSet variable is cached.
0: 		**
0: 		** 	resultSet = (resultSet == null) ? ... : resultSet
1: 		*/
1: 
0: 		executeMethod.pushThis();
0: 		executeMethod.getField(ClassName.BaseActivation, "resultSet", ClassName.ResultSet);
0: 		executeMethod.conditionalIfNull();
1: 
0: 			/* We should generate the result set here.  However, the generated
0: 			 * code size may be too big to fit in a conditional statement for
0: 			 * Java compiler to handle (it has a jump/branch step limit).  For
0: 			 * example, a extremely huge insert is issued with many many rows
0: 			 * (beetle 4293).  We fork a worker method here to get the
0: 			 * generated result set, pass our parameter to it and call it.
1: 			 */
0: 			MethodBuilder mbWorker = generatingClass.getClassBuilder().newMethodBuilder(
0: 														Modifier.PROTECTED,
0: 														ClassName.ResultSet,
0: 														"fillResultSet");
0: 			mbWorker.addThrownException(ClassName.StandardException);
1: 
0: 			// we expect to get back an expression that will give a resultSet
0: 			// the nodes use the generatingClass: they add expression functions
0: 			// to it, and then use those functions in their expressions.
0: 			generate(generatingClass, mbWorker);
1: 
0: 			mbWorker.methodReturn();
0: 			mbWorker.complete();
0: 			executeMethod.pushThis();
0: 			executeMethod.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,
0: 									 "fillResultSet", ClassName.ResultSet, 0);
1: 
0: 		executeMethod.startElseCode(); // this is here as the compiler only supports ? :
0: 			executeMethod.pushThis();
0: 			executeMethod.getField(ClassName.BaseActivation, "resultSet", ClassName.ResultSet);
0: 		executeMethod.completeConditional();
1: 
0: 		executeMethod.pushThis();
0: 		executeMethod.swap();
0: 		executeMethod.putField(ClassName.BaseActivation, "resultSet", ClassName.ResultSet);
1: 
0: 		executeMethod.endStatement();
1: 
1:    		// wrap up the activation class definition
1: 		// generate on the tree gave us back the newExpr
1: 		// for getting a result set on the tree.
1: 		// we put it in a return statement and stuff
1: 		// it in the execute method of the activation.
1: 		// The generated statement is the expression:
1: 		// the activation class builder takes care of constructing it
1: 		// for us, given the resultSetExpr to use.
1: 		//   return (this.resultSet = #resultSetExpr);
0: 		generatingClass.finishExecuteMethod(this instanceof CursorNode);
1: 
1: 		// wrap up the constructor by putting a return at the end of it
1: 		generatingClass.finishConstructor();
1: 
0: 		// cook the completed class into a real class
0: 		// and stuff it into activationClass
0: 		GeneratedClass activationClass = generatingClass.getGeneratedClass(byteCode);
1: 
0: 		return activationClass;
1: 	 }
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param byteCode	the generated byte code for this statement.
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.services.loader.GeneratedClass;
0: 
0: import org.apache.derby.iapi.util.ByteArray;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import java.lang.reflect.Modifier;
0: 
0: /**
0:  * A StatementNode represents a single statement in the language.  It is
0:  * the top node for any statement.
0:  * <p>
0:  * StatementNode controls the class generation for query tree nodes.
0:  *
0:  * @author Jeff Lichtman
0:  */
0: 
0: /*
0: * History:
0: *	5/8/97	Rick Hilleags	Moved node-name-string to child classes.
0: */
0: 
0: public abstract class StatementNode extends QueryTreeNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/**
0: 	 * By default, assume StatementNodes are atomic.
0: 	 * The rare statements that aren't atomic (e.g.
0: 	 * CALL method()) override this.
0: 	 *
0: 	 * @return true if the statement is atomic
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */	
0: 	public boolean isAtomic() throws StandardException
0: 	{
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Convert this object to a String.  See comments in QueryTreeNode.java
0: 	 * for how this should be done for tree printing.
0: 	 *
0: 	 * @return	This object as a String
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "statementType: " + statementToString() + "\n" +
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: 
0: 	public abstract String statementToString();
0: 
0: 	/**
0: 	 * create the outer shell class builder for the class we will
0: 	 * be generating, generate the expression to stuff in it,
0: 	 * and turn it into a class.
0: 	 */
0: 	static final int NEED_DDL_ACTIVATION = 5;
0: 	static final int NEED_CURSOR_ACTIVATION = 4;
0: 	static final int NEED_PARAM_ACTIVATION = 2;
0: 	static final int NEED_ROW_ACTIVATION = 1;
0: 	static final int NEED_NOTHING_ACTIVATION = 0;
0: 
0: 	abstract int activationKind();
0: 
0: 	/* We need to get some kind of table lock (IX here) at the beginning of
0: 	 * compilation of DMLModStatementNode and DDLStatementNode, to prevent the
0: 	 * interference of insert/update/delete/DDL compilation and DDL execution,
0: 	 * see beetle 3976, 4343, and $WS/language/SolutionsToConcurrencyIssues.txt
0: 	 */
0: 	protected TableDescriptor lockTableForCompilation(TableDescriptor td)
0: 		throws StandardException
0: 	{
0: 		DataDictionary dd = getDataDictionary();
0: 
0: 		/* we need to lock only if the data dictionary is in DDL cache mode
0: 		 */
0: 		if (dd.getCacheMode() == DataDictionary.DDL_MODE)
0: 		{
0: 			ConglomerateController  heapCC;
0: 			TransactionController tc =
0: 				getLanguageConnectionContext().getTransactionCompile();
0: 
0: 			heapCC = tc.openConglomerate(td.getHeapConglomerateId(),
0:                                     false,
0: 									TransactionController.OPENMODE_FORUPDATE |
0: 									TransactionController.OPENMODE_FOR_LOCK_ONLY,
0: 									TransactionController.MODE_RECORD,
0: 									TransactionController.ISOLATION_SERIALIZABLE);
0: 			heapCC.close();
0: 			/*
0: 			** Need to get TableDescriptor again after getting the lock, in
0: 			** case for example, a concurrent add column thread commits
0: 			** while we are binding.
0: 			*/
0: 			String tableName = td.getName();
0: 			td = getTableDescriptor(td.getName(), getSchemaDescriptor(td.getSchemaName()));
0: 			if (td == null)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_TABLE_NOT_FOUND, tableName);
0: 			}
0: 		}
0: 		return td;
0: 	}
0: 
0: 
0: 	/**
0: 	 * Do code generation for this statement.
0: 	 *
0: 	 * @param	the generated byte code for this statement.
0: 	 *			if non-null, then the byte code is saved
0: 	 *			here.
0: 	 *
0: 	 * @return		A GeneratedClass for this statement
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public GeneratedClass generate(ByteArray byteCode) throws StandardException
0: 	{
0: 		// start the new activation class.
0: 		// it starts with the Execute method
0: 		// and the appropriate superclass (based on
0: 		// statement type, from inspecting the queryTree).
0: 
0: 		int nodeChoice = activationKind();
0: 
0: 		/* RESOLVE: Activation hierarchy was way too complicated
0: 		 * and added no value.  Simple thing to do was to simply
0: 		 * leave calling code alone and to handle here and to
0: 		 * eliminate unnecessary classes.
0: 		 */
0: 		String superClass;
0: 		switch (nodeChoice)
0: 		{
0: 		case NEED_CURSOR_ACTIVATION:
0: 			superClass = ClassName.CursorActivation;
0: 			break;
0: 		case NEED_DDL_ACTIVATION:
0: 			return getClassFactory().loadGeneratedClass(
0: 				"org.apache.derby.impl.sql.execute.ConstantActionActivation", null);
0: 
0: 		case NEED_NOTHING_ACTIVATION :
0: 		case NEED_ROW_ACTIVATION :
0: 		case NEED_PARAM_ACTIVATION :
0: 			superClass = ClassName.BaseActivation;
0: 			break;
0: 		default :
0: 			throw StandardException.newException(SQLState.LANG_UNAVAILABLE_ACTIVATION_NEED,
0: 					String.valueOf(nodeChoice));
0: 		}
0: 
0: 		ActivationClassBuilder generatingClass = new ActivationClassBuilder(
0: 										superClass, 
0: 										getCompilerContext());
0: 		MethodBuilder executeMethod = generatingClass.getExecuteMethod();
0: 
0: 
0: 		/*
0: 		** the resultSet variable is cached.
0: 		**
0: 		** 	resultSet = (resultSet == null) ? ... : resultSet
0: 		*/
0: 
0: 		executeMethod.pushThis();
0: 		executeMethod.getField(ClassName.BaseActivation, "resultSet", ClassName.ResultSet);
0: 		executeMethod.conditionalIfNull();
0: 
0: 			/* We should generate the result set here.  However, the generated
0: 			 * code size may be too big to fit in a conditional statement for
0: 			 * Java compiler to handle (it has a jump/branch step limit).  For
0: 			 * example, a extremely huge insert is issued with many many rows
0: 			 * (beetle 4293).  We fork a worker method here to get the
0: 			 * generated result set, pass our parameter to it and call it.
0: 			 */
0: 			MethodBuilder mbWorker = generatingClass.getClassBuilder().newMethodBuilder(
0: 														Modifier.PROTECTED,
0: 														ClassName.ResultSet,
0: 														"fillResultSet");
0: 			mbWorker.addThrownException(ClassName.StandardException);
0: 
0: 			// we expect to get back an expression that will give a resultSet
0: 			// the nodes use the generatingClass: they add expression functions
0: 			// to it, and then use those functions in their expressions.
0: 			generate(generatingClass, mbWorker);
0: 
0: 			mbWorker.methodReturn();
0: 			mbWorker.complete();
0: 			executeMethod.pushThis();
0: 			executeMethod.callMethod(VMOpcode.INVOKEVIRTUAL, (String) null,
0: 									 "fillResultSet", ClassName.ResultSet, 0);
0: 
0: 		executeMethod.startElseCode(); // this is here as the compiler only supports ? :
0: 			executeMethod.pushThis();
0: 			executeMethod.getField(ClassName.BaseActivation, "resultSet", ClassName.ResultSet);
0: 		executeMethod.completeConditional();
0: 
0: 		executeMethod.pushThis();
0: 		executeMethod.swap();
0: 		executeMethod.putField(ClassName.BaseActivation, "resultSet", ClassName.ResultSet);
0: 
0: 		executeMethod.endStatement();
0: 
0:    		// wrap up the activation class definition
0: 		// generate on the tree gave us back the newExpr
0: 		// for getting a result set on the tree.
0: 		// we put it in a return statement and stuff
0: 		// it in the execute method of the activation.
0: 		// The generated statement is the expression:
0: 		// the activation class builder takes care of constructing it
0: 		// for us, given the resultSetExpr to use.
0: 		//   return (this.resultSet = #resultSetExpr);
0: 		generatingClass.finishExecuteMethod(this instanceof CursorNode);
0: 
0: 		// wrap up the constructor by putting a return at the end of it
0: 		generatingClass.finishConstructor();
0: 
0: 		// cook the completed class into a real class
0: 		// and stuff it into activationClass
0: 		GeneratedClass activationClass = generatingClass.getGeneratedClass(byteCode);
0: 
0: 		return activationClass;
0: 	 }
0: }
============================================================================