1:0c9f73e: /*
3:7a46698:  *
1:7a46698:  * Derby - Class org.apache.derbyTesting.junit.NetworkServerTestSetup
1:7a46698:  *
1:7a46698:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:7a46698:  * contributor license agreements.  See the NOTICE file distributed with
1:7a46698:  * this work for additional information regarding copyright ownership.
1:7a46698:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:7a46698:  * (the "License"); you may not use this file except in compliance with
1:7a46698:  * the License.  You may obtain a copy of the License at
1:7a46698:  *
1:7a46698:  *    http://www.apache.org/licenses/LICENSE-2.0
1:7a46698:  *
1:7a46698:  * Unless required by applicable law or agreed to in writing, 
1:7a46698:  * software distributed under the License is distributed on an 
1:7a46698:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:7a46698:  * either express or implied. See the License for the specific 
1:7a46698:  * language governing permissions and limitations under the License.
2:7a46698:  */
1:7a46698: package org.apache.derbyTesting.junit;
1:a63ab5e: 
1:953604b: import java.io.FileNotFoundException;
1:7a46698: import java.net.InetAddress;
1:eba07fc: import java.io.File;
1:953604b: import java.io.FileOutputStream;
1:a63ab5e: import java.io.IOException;
1:7a46698: import java.io.PrintWriter;
1:210e034: import java.net.ServerSocket;
1:6524638: import java.net.UnknownHostException;
1:953604b: import java.security.AccessController;
1:953604b: import java.security.PrivilegedAction;
1:a63ab5e: import java.security.PrivilegedActionException;
1:a63ab5e: import java.security.PrivilegedExceptionAction;
1:5107349: import java.sql.SQLException;
1:f69e1a2: import java.util.ArrayList;
1:c724a49: import java.util.Arrays;
1:2510115: import junit.framework.AssertionFailedError;
1:7a46698: import junit.framework.Test;
1:7a46698: import org.apache.derby.drda.NetworkServerControl;
1:63a21e7: import org.apache.derby.iapi.error.ExceptionUtil;
1:63a21e7: import org.apache.derby.iapi.services.info.JVMInfo;
1:f69e1a2: 
1:e0f1ffe: /**
1:7a46698:  * Test decorator that starts the network server on startup
1:7a46698:  * and stops it on teardown.
1:0c8f7b8:  * 
1:0c9f73e:  */
1:23c0fed: final public class NetworkServerTestSetup extends BaseTestSetup {
1:e0f1ffe: 
1:7d6ee2f:     /**
1:7d6ee2f:      * <p>
1:7d6ee2f:      * Setting maximum wait time to 4 minutes by default. On some platforms
1:7d6ee2f:      * it may take this long to start the server. See for example
1:7d6ee2f:      * <a href="http://bugs.sun.com/view_bug.do?bug_id=6483406">this JVM
1:7d6ee2f:      * bug</a> that sometimes makes server startup take more than 3 minutes.
1:7d6ee2f:      * </p>
1:7d6ee2f:      *
1:7d6ee2f:      * <p>
1:7d6ee2f:      * Increasing the wait time should not adversely affect those
1:765b3e4:      *  systems with fast port turnaround as the actual code loops for 
1:765b3e4:      *  SLEEP_TIME intervals, so should never see WAIT_TIME.
1:86ce429:      *  For even slower systems (or for faster systems) the default value can
1:86ce429:      *  be overwritten using the property derby.tests.networkServerStartTimeout
1:86ce429:      *  (which is in seconds, rather than milliseconds)
1:7d6ee2f:      * </p>
1:7a46698:      */
1:7d6ee2f:     private static final long DEFAULT_WAIT_TIME = 240000;
1:86ce429:     private static final long WAIT_TIME = getWaitTime();
1:e0f1ffe:     
1:7d6ee2f:     /** Sleep for 100 ms before pinging the network server (again) */
1:a63ab5e:     private static final int SLEEP_TIME = 100;
1:e0f1ffe: 
1:f69e1a2:     public static final String HOST_OPTION = "-h";
1:f69e1a2: 
1:e0f1ffe:     private static  long    waitTime = WAIT_TIME;
1:e0f1ffe:     
1:953604b:     private FileOutputStream serverOutput;
1:0c9f73e:     private final boolean asCommand;
1:953604b: 
1:0c8f7b8:     private final boolean startServerAtSetup;
1:e0f1ffe:     private final boolean useSeparateProcess;
1:e0f1ffe:     private final boolean serverShouldComeUp;
1:e0f1ffe:     
1:0c8f7b8:     /**
1:433c058:      * System properties to set on the command line (using -D)
1:433c058:      * only when starting the server in a separate virtual machine.
1:433c058:      */
1:e0f1ffe:     private final String[]    systemProperties;
1:a63ab5e:     
1:433c058:     /**
1:433c058:      * Startup arguments for the command line
1:433c058:      * only when starting the server in a separate virtual machine.
1:433c058:      */
1:a63ab5e:     private String[]    startupArgs;
1:a63ab5e:     /**
1:a63ab5e:      * The server as a process if started in a different vm.
1:a63ab5e:      */
1:a63ab5e:     private SpawnedProcess spawnedServer;
1:433c058:     
1:433c058:     /**
1:d7b5f4a:      * Decorates a test with the NetworkServerTestSetup.
1:433c058:      * 
1:433c058:      * Runs the server using the current configuration (at the time
1:433c058:      * of setup).
1:433c058:      * 
1:433c058:      * @param asCommand True to start using NetworkServerControl.main()
1:d7b5f4a:      * within the same virtual machine, false to use NetworkServerControl.start
1:d7b5f4a:      * (also within the same JVM).
1:433c058:      * 
1:433c058:      * @see NetworkServerControl#main(String[])
1:433c058:      * @see NetworkServerControl#start(PrintWriter)
1:0c8f7b8:      */
1:0c9f73e:     public NetworkServerTestSetup(Test test, boolean asCommand) {
1:7a46698:         super(test);
1:0c9f73e:         this.asCommand = asCommand;
1:e0f1ffe: 
1:e0f1ffe:         this.systemProperties = null;
1:e0f1ffe:         this.startupArgs = null;
1:e0f1ffe:         this.useSeparateProcess = false;
1:e0f1ffe:         this.serverShouldComeUp = true;
1:0c8f7b8:         this.startServerAtSetup = true;
1:e0f042a: }
1:e0f042a: 
1:210e034:     /**
1:d7b5f4a:      * Decorates a test with the NetworkServerTestSetup.
1:e0f042a:      * 
1:d7b5f4a:      * Sets up the server using the current configuration. Whether or not the
1:d7b5f4a:      * server is actually started at setup time is determined by the value of 
1:d7b5f4a:      * the passed parameters.
1:0c8f7b8:      * 
1:0c8f7b8:      * @param test the Test for which this setup is used
1:0c8f7b8:      * @param asCommand True to start using NetworkServerControl.main()
1:d7b5f4a:      * within the same virtual machine, false to use NetworkServerControl.start()
1:d7b5f4a:      * (also within the same virtual machine).
1:d7b5f4a:      * @param startServerAtSetup True to start the Network Server at setup time,
1:d7b5f4a:      *        False otherwise.
1:0c8f7b8:      * 
1:0c8f7b8:      * @see NetworkServerControl#main(String[])
1:0c8f7b8:      * @see NetworkServerControl#start(PrintWriter)
1:e0f1ffe:      */
1:d7b5f4a:     public NetworkServerTestSetup(  Test test, 
1:d7b5f4a:                                     boolean asCommand, 
1:d7b5f4a:                                     boolean startServerAtSetup) {
1:0c8f7b8:         super(test);
1:0c8f7b8:         this.asCommand = asCommand;
1:e0f1ffe: 
1:0c8f7b8:         this.systemProperties = null;
1:0c8f7b8:         this.startupArgs = null;
1:0c8f7b8:         this.useSeparateProcess = false;
1:0c8f7b8:         this.serverShouldComeUp = true;
1:0c8f7b8: 
1:0c8f7b8:         this.startServerAtSetup = startServerAtSetup;
1:a40bc13:     }
1:0c8f7b8:     
1:e0f042a:      /**
1:433c058:      * Decorator for starting up with specific command args
1:433c058:      * and system properties. Server is always started up
1:433c058:      * in a separate process with a separate virtual machine.
1:a63ab5e:      * <P>
1:a63ab5e:      * If the classes are being loaded from the classes
1:a63ab5e:      * folder instead of jar files then this will start
1:a63ab5e:      * the server up with no security manager using -noSecurityManager,
1:a63ab5e:      * unless the systemProperties or startupArgs set up any security
1:a63ab5e:      * manager.
1:a63ab5e:      * This is because the default policy
1:a63ab5e:      * installed by the network server only works from jar files.
1:a63ab5e:      * If this not desired then the test should skip the
1:a63ab5e:      * fixtures when loading from classes or
1:a63ab5e:      * install its own security manager.
1:7a46698:      */
1:e0f1ffe:     public NetworkServerTestSetup
1:e0f1ffe:         (
1:e0f1ffe:          Test test,
1:e0f1ffe:          String[] systemProperties,
1:e0f1ffe:          String[] startupArgs,
1:a63ab5e:          boolean serverShouldComeUp
1:e0f1ffe:         )
1:e0f1ffe:     {
1:e0f1ffe:         super(test);
1:e0f1ffe:         
1:e0f1ffe:         this.asCommand = true;
1:e0f1ffe: 
1:e0f1ffe:         this.systemProperties = systemProperties;
1:e0f1ffe:         this.startupArgs = startupArgs;
1:e0f1ffe:         this.useSeparateProcess = true;
1:e0f1ffe:         this.serverShouldComeUp = serverShouldComeUp;
1:0c8f7b8:         this.startServerAtSetup = true;
1:e0f1ffe:     }
1:86ce429: 
1:e0f1ffe:     /**
1:7a46698:      * Start the network server.
1:7a46698:      */
1:7a46698:     protected void setUp() throws Exception {
1:0c9f73e:         BaseTestCase.println("Starting network server:");
1:953604b:         
1:0c9f73e:         networkServerController = getNetworkServerControl();
1:953604b: 
1:0c8f7b8:         if (startServerAtSetup)
1:0c8f7b8:         {
1:210e034:             // DERBY-4201: A network server instance used in an earlier test
1:210e034:             // case might not have completely shut down and released the server
1:210e034:             // port yet. Wait here until the port has been released.
1:210e034:             waitForAvailablePort();
1:210e034: 
1:e0f1ffe:             if (useSeparateProcess)
1:a63ab5e:             { spawnedServer = startSeparateProcess(); }
1:e0f1ffe:             else if (asCommand)
1:e0f1ffe:             { startWithCommand(); }
1:0c8f7b8:             else
1:e0f1ffe:             { startWithAPI(); }
1:0c8f7b8: 
1:a63ab5e:             if (serverShouldComeUp)
1:a63ab5e:             {
1:a63ab5e:                 if (!pingForServerStart(networkServerController)) {
1:cf2526e:                     String msg = getTimeoutErrorMsg("network server to start");
1:a63ab5e:                     // Dump the output from the spawned process
1:a63ab5e:                     // and destroy it.
1:a63ab5e:                     if (spawnedServer != null) {
1:04846d1:                         spawnedServer.complete(2000);
1:a63ab5e:                         msg = spawnedServer.getFailMessage(msg);
1:a63ab5e:                         spawnedServer = null;
1:0c8f7b8:                     }
1:63a21e7:                     //DERBY-6012 print thread dump and java core
1:63a21e7:                     JVMInfo.javaDump();
1:cf2526e:                     fail(msg + Utilities.NL + ExceptionUtil.dumpThreads());
1:0c8f7b8:                 }
1:a63ab5e:             }
1:a63ab5e:         }
1:a63ab5e:     }
1:dc9cd0f: 
1:0c9f73e:     /**
1:210e034:      * Wait until the server port has been released by server instances used
1:210e034:      * by earlier test cases, or until the timeout specified by
1:210e034:      * {@link #getWaitTime()} has elapsed.
1:210e034:      *
1:6524638:      * @throws AssertionFailedError if the port didn't become available before
1:6524638:      * the timeout
1:6524638:      * @throws InterruptedException if the thread was interrupted while waiting
1:6524638:      * for the port to become available
1:6524638:      * @throws UnknownHostException if the host name couldn't be resolved
1:210e034:      */
1:6524638:     public static void waitForAvailablePort()
1:6524638:             throws InterruptedException, UnknownHostException {
1:9611078:         waitForAvailablePort(TestConfiguration.getCurrent().getPort());
1:a40bc13:     }
1:a40bc13: 
1:a40bc13: 
1:a40bc13:     /**
1:a40bc13:      * Wait until the specified port has been released by
1:a40bc13:      * by earlier test cases, or until the timeout specified by
1:a40bc13:      * {@link #getWaitTime()} has elapsed.
1:a40bc13:      *
1:9611078:      * @param port value.
1:a40bc13:      * @throws AssertionFailedError if the port didn't become available before
1:a40bc13:      * the timeout
1:a40bc13:      * @throws InterruptedException if the thread was interrupted while waiting
1:a40bc13:      * for the port to become available
1:a40bc13:      * @throws UnknownHostException if the host name couldn't be resolved
1:a40bc13:      */
1:a40bc13:     public static void waitForAvailablePort(int port)
1:a40bc13:             throws InterruptedException, UnknownHostException {
1:a40bc13: 
1:9611078:         InetAddress serverAddress = InetAddress.getByName(
1:9611078:                 TestConfiguration.getCurrent().getHostName());
1:a40bc13: 
1:210e034:         long giveUp = System.currentTimeMillis() + getWaitTime();
1:a40bc13:         BaseTestCase.println(
1:a40bc13:                 "probing port for availability: " + serverAddress + ":" + port);
1:210e034: 
1:210e034:         while (true) {
1:210e034:             try {
1:210e034:                 probeServerPort(port, serverAddress);
1:210e034:                 break;
1:210e034:             } catch (IOException ioe) {
1:210e034:                 if (System.currentTimeMillis() < giveUp) {
1:210e034:                     Thread.sleep(SLEEP_TIME);
1:210e034:                 } else {
1:210e034:                     BaseTestCase.fail(
1:a40bc13:                         getTimeoutErrorMsg("server port to become available",
1:a40bc13:                             port),
1:210e034:                         ioe);
1:210e034:                 }
1:210e034:             }
1:210e034:         }
1:210e034:     }
1:210e034: 
1:210e034:     /**
1:210e034:      * Check if a server socket can be opened on the specified port.
1:210e034:      *
1:210e034:      * @param port the port to check
1:210e034:      * @param addr the address of the network interface
1:210e034:      * @throws IOException if a server socket couldn't be opened
1:210e034:      */
1:6524638:     private static void probeServerPort(final int port, final InetAddress addr)
1:210e034:             throws IOException {
1:210e034:         try {
1:2510115:             AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
1:2510115:                 public Void run() throws IOException {
1:210e034:                     new ServerSocket(port, 0, addr).close();
1:210e034:                     return null;
1:210e034:                 }
1:210e034:             });
1:210e034:         } catch (PrivilegedActionException pae) {
1:210e034:             throw (IOException) pae.getCause();
1:210e034:         }
1:210e034:     }
1:210e034: 
1:0c9f73e:     private void startWithAPI() throws Exception
1:a63ab5e:     {
1:a40bc13:             
1:2510115:             serverOutput = AccessController.doPrivileged(
1:2510115:                     new PrivilegedAction<FileOutputStream>() {
1:2510115:                 public FileOutputStream run() {
1:eba07fc:                     File logs = new File("logs");
1:eba07fc:                     logs.mkdir();
1:eba07fc:                     File console = new File(logs, "serverConsoleOutput.log");
1:953604b:                     FileOutputStream fos = null;
1:953604b:                     try {
1:eba07fc:                         fos = new FileOutputStream(console.getPath(), true);
1:953604b:                     } catch (FileNotFoundException ex) {
1:953604b:                         ex.printStackTrace();
1:953604b:                     }
1:953604b:                     return fos;
1:953604b:                 }
1:953604b:             });
1:953604b:             
1:953604b:             networkServerController.start(new PrintWriter(serverOutput));
1:a63ab5e:     }
1:0c8f7b8:     
1:0c9f73e:     private void startWithCommand() throws Exception
1:a63ab5e:     {
1:0c9f73e:         // start the server through the command line
1:0c9f73e:         // arguments using a new thread to do so.
1:0c9f73e:         new Thread(
1:0c9f73e:         new Runnable() {
1:0c9f73e:             public void run() {
1:e0f1ffe: 
1:f69e1a2:                 String[]    args = getDefaultStartupArgs( false );
1:e0f1ffe:                 
1:e0f1ffe:                 org.apache.derby.drda.NetworkServerControl.main( args );
1:a63ab5e:             }
1:e0f1ffe:             
1:0c9f73e:         }, "NetworkServerTestSetup command").start();
1:e0f1ffe:     }
1:e0f1ffe: 
1:a63ab5e:     private SpawnedProcess startSeparateProcess() throws Exception
1:e0f1ffe:     {
1:2510115:         ArrayList<String> al = new ArrayList<String>();
1:f69e1a2:         boolean         skipHostName = false;
1:e0f1ffe: 
1:dcfc481:         // Loading from classes need to work-around the limitation of the
1:dcfc481:         // default policy file doesn't work with classes.  Similarly, if we are
1:dcfc481:         // running with Emma we don't run with the security manager, as the
1:dcfc481:         // default server policy doesn't contain needed permissions and,
1:dcfc481:         // additionally, Emma sources do not use doPrivileged blocks anyway.
1:1e0c703:         if (!TestConfiguration.loadingFromJars() ||
1:1e0c703:                 BaseTestCase.runsWithEmma() || BaseTestCase.runsWithJaCoCo())
1:e0f1ffe:         {
1:a63ab5e:             boolean setNoSecurityManager = true;
1:a63ab5e:             for (int i = 0; i < systemProperties.length; i++)
1:e0f1ffe:             {
1:a63ab5e:                 if (systemProperties[i].startsWith("java.security."))
1:e0f1ffe:                 {
1:a63ab5e:                     setNoSecurityManager = false;
1:a63ab5e:                     break;
1:e0f1ffe:                 }
1:e0f1ffe:             }
1:a63ab5e:             for (int i = 0; i < startupArgs.length; i++)
1:e0f1ffe:             {
1:a63ab5e:                 if (startupArgs[i].equals("-noSecurityManager"))
1:a63ab5e:                 {
1:a63ab5e:                     setNoSecurityManager = false;
1:a63ab5e:                     break;
1:e0f1ffe:                 }
1:a63ab5e:             }
1:a63ab5e:             if (setNoSecurityManager)
1:a63ab5e:             {
1:a63ab5e:                 String[] newArgs = new String[startupArgs.length + 1];
1:a63ab5e:                 System.arraycopy(startupArgs, 0, newArgs, 0, startupArgs.length);
1:a63ab5e:                 newArgs[newArgs.length - 1] = "-noSecurityManager";
1:a63ab5e:                 startupArgs = newArgs;
1:a63ab5e:             }
1:a63ab5e:         }
1:e0f1ffe: 
1:e0f1ffe:         int         count = systemProperties.length;
1:f69e1a2:         for ( int i = 0; i < count; i++ )
1:f69e1a2:         {
1:e621aee:             al.add( "-D" + systemProperties[ i ] );
1:e0f1ffe:         }
1:e0f1ffe: 
1:e621aee:         al.add( "org.apache.derby.drda.NetworkServerControl" );
1:e0f1ffe: 
1:f69e1a2:         count = startupArgs.length;
3:e0f1ffe:         for ( int i = 0; i < count; i++ )
1:e0f1ffe:         {
1:f69e1a2:             // if the special startup args override the hostname, then don't
1:f69e1a2:             // specify it twice
1:f69e1a2:             if ( HOST_OPTION.equals( startupArgs[ i ] ) ) { skipHostName = true; }
1:f69e1a2:         }
1:f69e1a2: 
1:c724a49:         al.addAll(Arrays.asList(getDefaultStartupArgs(skipHostName)));
1:c724a49:         al.addAll(Arrays.asList(startupArgs));
1:e0f1ffe: 
1:e621aee:         final   String[]  command = new String[ al.size() ];
1:e621aee:         al.toArray(command);
1:e0f1ffe: 
1:c724a49:         Process serverProcess = BaseTestCase.execJavaCmd(command);
1:e0f1ffe: 
1:a63ab5e:         return new SpawnedProcess(serverProcess, "SpawnedNetworkServer");
1:e0f1ffe:     }
1:e0f1ffe: 
1:7a46698:     /**
1:77b824b:      * Returns the <code>Process</code> object for the server process or <code>null</code> if the
1:e0f042a:      * network server does not run in a separate process
1:e0f042a:      */
1:a63ab5e:     public SpawnedProcess getServerProcess() {
1:a63ab5e:         return spawnedServer;
1:e0f1ffe:     }
1:e0f1ffe: 
1:7a46698:     /**
1:0c9f73e:      * Stop the network server if it still
1:0c9f73e:      * appears to be running.
1:57efc9f:      */
1:7a46698:     protected void tearDown() throws Exception {
1:e0f1ffe: 
1:7a46698:         if (networkServerController != null) {
1:0c9f73e:             boolean running = false;
1:e0f1ffe:             try {
1:0c9f73e:                 networkServerController.ping();
1:0c9f73e:                 running = true;
1:0c9f73e:             } catch (Exception e) {
1:e621aee:             }
1:a535758:       
1:c5d7876:             Throwable failedShutdown = null;
1:0c9f73e:             if (running)
1:f69e1a2:             {
1:f69e1a2:                 try {
1:f69e1a2:                     networkServerController.shutdown();
1:f69e1a2:                 } catch (Throwable t)
1:f69e1a2:                 {
1:c5d7876:                     failedShutdown = t;
1:f69e1a2:                 }
1:f69e1a2:             }
1:044179c:  
1:e0f1ffe:             if ( serverOutput != null ) { serverOutput.close(); }
1:f3271c1:             networkServerController = null;
1:f3271c1:             serverOutput = null;
1:e0f042a: 
1:a63ab5e:             if (spawnedServer != null) {
1:c5d7876:                 // Destroy the process if a failed shutdown
1:c5d7876:                 // to avoid hangs running tests as the complete()
1:c5d7876:                 // waits for the process to complete.
1:04846d1:                 spawnedServer.complete(getWaitTime());
1:a63ab5e:                 spawnedServer = null;
1:a63ab5e:             }
1:e0f1ffe: 
1:c5d7876:             // Throw an error to record the fact that the
1:c5d7876:             // shutdown failed.
1:c5d7876:             if (failedShutdown != null)
1:c5d7876:             {
1:c5d7876:                 if (failedShutdown instanceof Exception)
1:5107349:                 {
1:5107349:                     // authentication failure is ok.
1:5107349:                     if (
1:dc9cd0f:                         !(failedShutdown instanceof SQLException)
1:5107349:                         )
1:5107349:                     {
1:5107349:                         throw (Exception) failedShutdown;
1:5107349:                     }
1:5107349:                 }
1:5107349:                 else
1:5107349:                 {
1:5107349:                     throw (Error) failedShutdown;
1:5107349:                 }
1:c5d7876:             }
1:c5d7876:                 
1:a63ab5e:         }
1:0c9f73e:     }
1:c5d7876:     
1:e0f1ffe:     /**
1:e0f1ffe:      * Get the default command arguments for booting the network server.
1:e0f1ffe:      */
1:f69e1a2:     public  static String[] getDefaultStartupArgs( boolean skipHostName )
1:e0f1ffe:     {
1:e0f1ffe:         TestConfiguration config = TestConfiguration.getCurrent();
1:2510115:         ArrayList<String> argsList = new ArrayList<String>();
1:f69e1a2: 
1:f69e1a2:         argsList.add( "start" );
1:f69e1a2: 
1:f69e1a2:         if ( !skipHostName )
1:f69e1a2:         {
1:f69e1a2:             argsList.add( HOST_OPTION );
1:f69e1a2:             argsList.add( config.getHostName() );
1:e0f1ffe:         }
1:f69e1a2:         argsList.add( "-p" );
1:f69e1a2:         argsList.add( Integer.toString(config.getPort() ) );
1:f69e1a2: 
1:f69e1a2:         if (config.getSsl() != null) {
1:f69e1a2:             argsList.add( "-ssl" );
1:f69e1a2:             argsList.add( config.getSsl( ) );
1:f69e1a2:         }
1:f69e1a2: 
1:f69e1a2:         String[]    retval = new String[ argsList.size() ];
1:f69e1a2: 
1:f69e1a2:         argsList.toArray( retval );
1:f69e1a2: 
1:f69e1a2:         return retval;
1:0c9f73e:     }
1:e0f1ffe:     
1:7a46698:     /* Network Server Control */
1:7a46698:     private NetworkServerControl networkServerController;
1:e0f1ffe:         
1:86ce429:     /*
1:0c9f73e:      * Utility methods related to controlling network server.
1:e621aee:      */
1:c5d7876:     
1:7a46698:     /**
1:0c8f7b8:      * Return a new NetworkServerControl for the current configuration.
1:0c9f73e:      */
1:0c9f73e:     public static NetworkServerControl getNetworkServerControl()
1:0c9f73e:         throws Exception
1:a63ab5e:     {
1:0c9f73e:         TestConfiguration config = TestConfiguration.getCurrent();
1:204c040:         final InetAddress host = InetAddress.getByName(config.getHostName());
1:204c040:         final int port = config.getPort();
1:204c040:         final String user = config.getUserName();
1:204c040:         final String password = config.getUserPassword();
1:5a9d596:         if (config.getSsl() == null) {
1:204c040:             return new NetworkServerControl(host, port, user, password);
1:5a9d596:         } else {
1:5a9d596:             // This is a hack. A NetworkServerControl constructor with
1:5a9d596:             // the needed interface to control sslMode (and possibly
1:5a9d596:             // more) would be better.
1:49c16da:             String oldValue = BaseTestCase.getSystemProperty("derby.drda.sslMode");
1:49c16da:             BaseTestCase.setSystemProperty("derby.drda.sslMode", config.getSsl());
1:204c040:             NetworkServerControl control
1:204c040:                 = new NetworkServerControl(host, port, user, password);
1:433c058:                
1:5a9d596:             if (oldValue == null) {
1:49c16da: 
1:49c16da:                 BaseTestCase.removeSystemProperty("derby.drda.sslMode");
2:5a9d596:             } else {
1:49c16da:                 BaseTestCase.setSystemProperty("derby.drda.sslMode", oldValue);
1:0c9f73e:             }
1:5a9d596:             return control;
1:0c9f73e:         }
9:7a46698:     }
1:49c16da:     
1:0c9f73e:     /**
1:0c9f73e:      * Return a new NetworkServerControl for the current configuration.
1:0c8f7b8:      * Use the port number specified.
1:0c8f7b8:      * This method is not for general use - in most cases, the port
1:0c8f7b8:      * should not be specified in the test, instead, the test framework
1:0c8f7b8:      * will decide what is the best port number to use.
1:0c8f7b8:      */
1:0c8f7b8:     public static NetworkServerControl getNetworkServerControl(int port)
1:0c8f7b8:         throws Exception
1:0c8f7b8:     {
1:0c8f7b8:         TestConfiguration config = TestConfiguration.getCurrent();
1:204c040:         final InetAddress host = InetAddress.getByName(config.getHostName());
1:204c040:         final String user = config.getUserName();
1:204c040:         final String password = config.getUserPassword();
1:204c040:         return new NetworkServerControl(host, port, user, password);
1:0c8f7b8:     }
1:0c8f7b8:     
1:0c8f7b8:     /**
1:0c8f7b8:      * Return a new NetworkServerControl for the current configuration.
1:0c8f7b8:      * Use default values, i.e. port number and host are dependent on 
1:0c8f7b8:      * whatever settings are set in the environment (properties)
1:0c8f7b8:      */
1:0c8f7b8:     public static NetworkServerControl getNetworkServerControlDefault()
1:0c8f7b8:         throws Exception
1:0c8f7b8:     {
1:0c8f7b8:         TestConfiguration config = TestConfiguration.getCurrent();
1:204c040:         final String user = config.getUserName();
1:204c040:         final String password = config.getUserPassword();
1:204c040:         return new NetworkServerControl(user, password);
1:0c8f7b8:     }
1:0c8f7b8:     
1:0c8f7b8:     /**
1:0c9f73e:      * Ping the server until it has started. Asserts a failure
1:0c9f73e:      * if the server has not started within sixty seconds.
1:0c9f73e:      */
1:0c9f73e:     public static void waitForServerStart(NetworkServerControl networkServerController)
1:76da2f3:        throws InterruptedException 
1:a63ab5e:     {
1:a63ab5e:         if (!pingForServerStart(networkServerController)) {
1:cf2526e:              fail(getTimeoutErrorMsg("network server to start"));
1:a63ab5e:         }
1:76da2f3:     }
1:76da2f3:     
1:76da2f3:      /**
1:e0f1ffe:      * Set the number of milliseconds to wait before declaring server startup
1:e0f1ffe:      * a failure.
1:e0f1ffe:      * 
1:e0f1ffe:      */
1:e0f1ffe:     public static void setWaitTime( long newWaitTime )
1:e0f1ffe:    {
1:e0f1ffe:         waitTime = newWaitTime;
1:e0f1ffe:     }
1:e0f1ffe:     
1:7a46698:     /**
1:0c8f7b8:      * Set the number of milliseconds to wait before declaring server startup
1:0c8f7b8:      * a failure back to the default value specified in this class.
1:0c8f7b8:      * 
1:0c8f7b8:      */
1:0c8f7b8:     public static void setDefaultWaitTime()
1:0c8f7b8:     {
1:0c8f7b8:         waitTime = WAIT_TIME;
1:0c8f7b8:     }
1:0c8f7b8:     
1:0c8f7b8:     /**
1:76da2f3:      * Ping server for upto sixty seconds. If the server responds
1:76da2f3:      * in that time then return true, otherwise return false.
1:76da2f3:      * 
1:e0f042a:      * @param networkServerController controller object for network server
1:e0f042a:      * @param serverProcess the external process in which the server runs
1:e0f042a:      * (could be <code>null</code>)
1:e0f042a:      * @return true if server responds in time, false otherwise
1:76da2f3:      */
1:0c8f7b8:     public static boolean pingForServerUp(
1:0c8f7b8:         NetworkServerControl networkServerController, Process serverProcess,
1:0c8f7b8:         boolean expectServerUp)
1:76da2f3:         throws InterruptedException
1:0c8f7b8:     {
1:47758e2:         //DERBY-6337(derbynet.ServerPropertiesTest.ttestSetPortPriority prints 
1:47758e2:         // exception java.lang.Exception: 
1:47758e2:         // DRDA_InvalidReplyTooShort.S:Invalidreply from network 
1:47758e2:         // server:Insufficent data. but test passes)
1:47758e2:         //Sometimes, when server is coming down and a ping is sent to it, ping
1:47758e2:         // may get DRDA_InvalidReplyTooShort.S:Invalidreply rather than server
1:47758e2:         // is down depending on the timing of the server shutdown. If we do run
1:47758e2:         // into DRDA_InvalidReplyTooShort.S:Invalidreply, we will now send 
1:47758e2:         // another ping after a little wait, and this time around we should 
1:47758e2:         // get expected server down exception.
1:47758e2:         //Following boolean will be set to true if we get reply too short
1:47758e2:         // during the ping and it will try to ping again. But if we get
1:47758e2:         // the reply too short on that ping attempt as well, we will just
1:47758e2:         // print the exception on the console and conclude that server is
1:47758e2:         // down.
1:47758e2:         boolean alreadyGotReplyTooShort=false;
1:0c8f7b8:         // If we expect the server to be or come up, then
1:0c8f7b8:         // it makes sense to sleep (if ping unsuccessful), then ping 
1:0c8f7b8:         // and repeat this for the duration of wait-time, but stop
1:0c8f7b8:         // when the ping is successful.
1:0c8f7b8:         // But if we are pinging to see if the server is - or
1:0c8f7b8:         // has come - down, we should do the opposite, stop if ping 
1:0c8f7b8:         // is unsuccessful, and repeat until wait-time if it is
1:0c9f73e:         final long startTime = System.currentTimeMillis();
1:0c9f73e:         while (true) {
1:a63ab5e:             try {
1:0c9f73e:                 networkServerController.ping();
1:7d6ee2f:                 long elapsed = System.currentTimeMillis() - startTime;
1:7d6ee2f:                 if (expectServerUp) {
1:7d6ee2f:                     if (elapsed > 60000L) {
1:7d6ee2f:                         BaseTestCase.alarm(
1:7d6ee2f:                             "Very slow server startup: " + elapsed + " ms");
1:0c8f7b8:                     }
1:7d6ee2f:                     return true;
1:7d6ee2f:                 } else if (elapsed > waitTime) {
1:7d6ee2f:                     return true;
1:0c8f7b8:                 }
1:f69e1a2:             } catch (Throwable e) {
1:f69e1a2:                 if ( !vetPing( e ) )
1:f69e1a2:                 {
1:47758e2:                     if ( !alreadyGotReplyTooShort && 
1:47758e2:                             (e.getMessage().startsWith( "DRDA_InvalidReplyTooShort.S:" ) ) ){
1:47758e2:                         alreadyGotReplyTooShort = true;
1:47758e2:                         Thread.sleep(SLEEP_TIME);
1:47758e2:                         continue;
1:47758e2:                     }
1:f69e1a2:                     e.printStackTrace( System.out );
1:f69e1a2:                     // at this point, we don't have the usual "server not up
1:f69e1a2:                     // yet" error. get out. at this point, you may have to
1:f69e1a2:                     // manually kill the server.
1:f69e1a2: 
1:f69e1a2:                     return false;
1:f69e1a2:                 }
1:0c8f7b8:                 if (expectServerUp){
1:0c8f7b8:                     if (System.currentTimeMillis() - startTime > waitTime) 
1:0c8f7b8:                         return false;
1:0c9f73e:                 }
1:0c8f7b8:                 // else, we got what we expected, done.
1:0c8f7b8:                 else
1:0c8f7b8:                     return false;
1:0c9f73e:             }
1:e0f042a:             if (serverProcess != null) {
1:e0f042a:                 // if the server runs in a separate process, check whether the
1:e0f042a:                 // process is still alive
1:e0f042a:                 try {
1:e0f042a:                     int exitVal = serverProcess.exitValue();
1:e0f042a:                     // When exitValue() returns successfully, the server
1:e0f042a:                     // process must have terminated. No point in pinging the
1:e0f042a:                     // server anymore.
1:e0f042a:                     return false;
1:e0f042a:                 } catch (IllegalThreadStateException e) {
1:e0f042a:                     // This exception is thrown by Process.exitValue() if the
1:e0f042a:                     // process has not terminated. Keep on pinging the server.
1:f69e1a2:                 } catch (Throwable t) {
1:f69e1a2:                     // something unfortunate happened
1:f69e1a2:                     t.printStackTrace( System.out );
1:f69e1a2:                     return false;
1:e0f042a:                 }
1:e0f042a:             }
1:0c8f7b8:             Thread.sleep(SLEEP_TIME);
1:e0f042a:         }
1:0c9f73e:     }
1:e0f042a: 
1:f69e1a2:     // return false if ping returns an error other than "server not up yet"
1:f69e1a2:     private static  boolean vetPing( Throwable t )
1:f69e1a2:     {
1:f69e1a2:         if ( !t.getClass().getName().equals( "java.lang.Exception" ) ) { return false; }
1:f69e1a2:         
1:ceee49e:         return ( t.getMessage().startsWith( "DRDA_NoIO.S:" ) );
1:f69e1a2:     }
1:f69e1a2:     
1:f69e1a2:     // return true if this is a drda error
1:f69e1a2:     private static  boolean isDRDAerror( Throwable t )
1:f69e1a2:     {
1:f69e1a2:         if ( !t.getClass().getName().equals( "java.lang.Exception" ) ) { return false; }
1:f69e1a2:         
1:f69e1a2:         return ( t.getMessage().startsWith( "DRDA" ) );
1:f69e1a2:     }
1:f69e1a2:     
1:e0f042a:     public static boolean pingForServerStart(NetworkServerControl control)
1:e0f042a:         throws InterruptedException
1:e0f042a:     {
1:0c8f7b8:         return pingForServerUp(control, null, true);
1:e0f042a:     }
1:f69e1a2:     
1:7d6ee2f:     /**
1:7d6ee2f:      * Set the period before network server times out on start up based on the
1:86ce429:      * value passed in with property derby.tests.networkServerStartTimeout
1:7d6ee2f:      * in seconds, or use the default.
1:7d6ee2f:      * For example: with DEFAULT_WAIT_TIME set to 240000, i.e. 4 minutes,
1:86ce429:      * setting the property like so: 
1:7d6ee2f:      * <pre>
1:7d6ee2f:      *          -Dderby.tests.networkServerStartTimeout=600
1:7d6ee2f:      * </pre>
1:7d6ee2f:      * would extend the timeout to 10 minutes.
1:86ce429:      * If an invalid value is passed in (eg. 'abc') the calling test will fail
1:86ce429:      */
1:86ce429:     public static long getWaitTime() {
1:86ce429:         long waitTime = DEFAULT_WAIT_TIME;
1:86ce429:         String waitString = BaseTestCase.getSystemProperty(
2:86ce429:                 "derby.tests.networkServerStartTimeout");
1:86ce429:         if (waitString != null && waitString.length() != 0)
1:86ce429:         {
1:86ce429:             try {
1:86ce429:                 waitTime = (Long.parseLong(waitString)*1000);
1:86ce429:             } catch (Exception e) {
1:7d6ee2f:                 BaseTestCase.fail(
1:7d6ee2f:                         "trouble setting WAIT_TIME from passed in property " +
1:7d6ee2f:                         "derby.tests.networkServerStartTimeout", e);
1:86ce429:             }
1:86ce429:         }
1:86ce429:         return waitTime;
1:86ce429:     }
1:86ce429: 
1:cf2526e:     /** Returns an error message for timeouts including the port and host. */
1:a40bc13:     private static String getTimeoutErrorMsg(String failedAction, int port) {
1:210e034:         TestConfiguration conf = TestConfiguration.getCurrent();
1:cf2526e:         String host = conf.getHostName();
1:cf2526e:         return "Timed out waiting for " +
1:cf2526e:                 failedAction + " (" + host + ":" + port + ")";
1:0c9f73e:     }
1:a40bc13: 
1:a40bc13:     private static String getTimeoutErrorMsg(String failedAction) {
1:a40bc13:         TestConfiguration conf = TestConfiguration.getCurrent();
1:210e034:         int port = conf.getPort();
1:a40bc13:         return getTimeoutErrorMsg(failedAction, port);
1:a40bc13:     }
1:cf2526e: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:47758e2
/////////////////////////////////////////////////////////////////////////
1:         //DERBY-6337(derbynet.ServerPropertiesTest.ttestSetPortPriority prints 
1:         // exception java.lang.Exception: 
1:         // DRDA_InvalidReplyTooShort.S:Invalidreply from network 
1:         // server:Insufficent data. but test passes)
1:         //Sometimes, when server is coming down and a ping is sent to it, ping
1:         // may get DRDA_InvalidReplyTooShort.S:Invalidreply rather than server
1:         // is down depending on the timing of the server shutdown. If we do run
1:         // into DRDA_InvalidReplyTooShort.S:Invalidreply, we will now send 
1:         // another ping after a little wait, and this time around we should 
1:         // get expected server down exception.
1:         //Following boolean will be set to true if we get reply too short
1:         // during the ping and it will try to ping again. But if we get
1:         // the reply too short on that ping attempt as well, we will just
1:         // print the exception on the console and conclude that server is
1:         // down.
1:         boolean alreadyGotReplyTooShort=false;
/////////////////////////////////////////////////////////////////////////
1:                     if ( !alreadyGotReplyTooShort && 
1:                             (e.getMessage().startsWith( "DRDA_InvalidReplyTooShort.S:" ) ) ){
1:                         alreadyGotReplyTooShort = true;
1:                         Thread.sleep(SLEEP_TIME);
1:                         continue;
1:                     }
commit:63a21e7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.ExceptionUtil;
1: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
1:                     //DERBY-6012 print thread dump and java core
0:                     fail(ExceptionUtil.dumpThreads());
1:                     JVMInfo.javaDump();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:2510115
/////////////////////////////////////////////////////////////////////////
1: import junit.framework.AssertionFailedError;
/////////////////////////////////////////////////////////////////////////
1:             AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
1:                 public Void run() throws IOException {
/////////////////////////////////////////////////////////////////////////
1:             serverOutput = AccessController.doPrivileged(
1:                     new PrivilegedAction<FileOutputStream>() {
1:                 public FileOutputStream run() {
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<String> al = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         ArrayList<String> argsList = new ArrayList<String>();
commit:c724a49
/////////////////////////////////////////////////////////////////////////
1: import java.util.Arrays;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         al.addAll(Arrays.asList(getDefaultStartupArgs(skipHostName)));
1:         al.addAll(Arrays.asList(startupArgs));
1:         Process serverProcess = BaseTestCase.execJavaCmd(command);
commit:7d6ee2f
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Setting maximum wait time to 4 minutes by default. On some platforms
1:      * it may take this long to start the server. See for example
1:      * <a href="http://bugs.sun.com/view_bug.do?bug_id=6483406">this JVM
1:      * bug</a> that sometimes makes server startup take more than 3 minutes.
1:      * </p>
1:      *
1:      * <p>
1:      * Increasing the wait time should not adversely affect those
1:      * </p>
1:     private static final long DEFAULT_WAIT_TIME = 240000;
1:     /** Sleep for 100 ms before pinging the network server (again) */
/////////////////////////////////////////////////////////////////////////
1:                 long elapsed = System.currentTimeMillis() - startTime;
1:                 if (expectServerUp) {
1:                     if (elapsed > 60000L) {
1:                         BaseTestCase.alarm(
1:                             "Very slow server startup: " + elapsed + " ms");
1:                     return true;
1:                 } else if (elapsed > waitTime) {
1:                     return true;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set the period before network server times out on start up based on the
1:      * in seconds, or use the default.
1:      * For example: with DEFAULT_WAIT_TIME set to 240000, i.e. 4 minutes,
1:      * <pre>
1:      *          -Dderby.tests.networkServerStartTimeout=600
1:      * </pre>
1:      * would extend the timeout to 10 minutes.
/////////////////////////////////////////////////////////////////////////
1:                 BaseTestCase.fail(
1:                         "trouble setting WAIT_TIME from passed in property " +
1:                         "derby.tests.networkServerStartTimeout", e);
commit:6524638
/////////////////////////////////////////////////////////////////////////
1: import java.net.UnknownHostException;
/////////////////////////////////////////////////////////////////////////
1:      * @throws AssertionFailedError if the port didn't become available before
1:      * the timeout
1:      * @throws InterruptedException if the thread was interrupted while waiting
1:      * for the port to become available
1:      * @throws UnknownHostException if the host name couldn't be resolved
1:     public static void waitForAvailablePort()
1:             throws InterruptedException, UnknownHostException {
/////////////////////////////////////////////////////////////////////////
1:     private static void probeServerPort(final int port, final InetAddress addr)
commit:210e034
/////////////////////////////////////////////////////////////////////////
1: import java.net.ServerSocket;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-4201: A network server instance used in an earlier test
1:             // case might not have completely shut down and released the server
1:             // port yet. Wait here until the port has been released.
1:             waitForAvailablePort();
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Wait until the server port has been released by server instances used
1:      * by earlier test cases, or until the timeout specified by
1:      * {@link #getWaitTime()} has elapsed.
1:      *
0:      * @throws Exception if the port didn't become available before the timeout
1:      */
0:     private void waitForAvailablePort() throws Exception {
1:         TestConfiguration conf = TestConfiguration.getCurrent();
0:         InetAddress serverAddress = InetAddress.getByName(conf.getHostName());
1:         int port = conf.getPort();
1:         long giveUp = System.currentTimeMillis() + getWaitTime();
1: 
1:         while (true) {
1:             try {
1:                 probeServerPort(port, serverAddress);
1:                 break;
1:             } catch (IOException ioe) {
1:                 if (System.currentTimeMillis() < giveUp) {
1:                     Thread.sleep(SLEEP_TIME);
1:                 } else {
1:                     BaseTestCase.fail(
0:                         "Timed out waiting for server port to become available",
1:                         ioe);
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Check if a server socket can be opened on the specified port.
1:      *
1:      * @param port the port to check
1:      * @param addr the address of the network interface
1:      * @throws IOException if a server socket couldn't be opened
1:      */
0:     private void probeServerPort(final int port, final InetAddress addr)
1:             throws IOException {
1:         try {
0:             AccessController.doPrivileged(new PrivilegedExceptionAction() {
0:                 public Object run() throws IOException {
1:                     new ServerSocket(port, 0, addr).close();
1:                     return null;
1:                 }
1:             });
1:         } catch (PrivilegedActionException pae) {
1:             throw (IOException) pae.getCause();
1:         }
1:     }
1: 
commit:e0f042a
/////////////////////////////////////////////////////////////////////////
0:     private Process serverProcess;
/////////////////////////////////////////////////////////////////////////
0:         { serverProcess = startSeparateProcess(); }
/////////////////////////////////////////////////////////////////////////
0:     private Process startSeparateProcess() throws Exception
/////////////////////////////////////////////////////////////////////////
0:         return serverProcess;
1:     }
1: 
1:     /**
0:      * Returns the <code>Process</code> object for the server process.
1:      *
0:      * @param a <code>Process</code> object, or <code>null</code> if the
1:      * network server does not run in a separate process
1:      */
0:     public Process getServerProcess() {
0:         return serverProcess;
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (serverProcess != null) {
0:                 serverProcess.waitFor();
0:                 serverProcess = null;
1:             }
/////////////////////////////////////////////////////////////////////////
1:      * @param networkServerController controller object for network server
1:      * @param serverProcess the external process in which the server runs
1:      * (could be <code>null</code>)
1:      * @return true if server responds in time, false otherwise
0:     public static boolean pingForServerStart(
0:         NetworkServerControl networkServerController, Process serverProcess)
/////////////////////////////////////////////////////////////////////////
0:             if (serverProcess != null) {
1:                 // if the server runs in a separate process, check whether the
1:                 // process is still alive
1:                 try {
1:                     int exitVal = serverProcess.exitValue();
1:                     // When exitValue() returns successfully, the server
1:                     // process must have terminated. No point in pinging the
1:                     // server anymore.
1:                     return false;
1:                 } catch (IllegalThreadStateException e) {
1:                     // This exception is thrown by Process.exitValue() if the
1:                     // process has not terminated. Keep on pinging the server.
1:                 }
1:             }
1: 
1:     public static boolean pingForServerStart(NetworkServerControl control)
1:         throws InterruptedException
1:     {
0:         return pingForServerStart(control, null);
1:     }
commit:953604b
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileNotFoundException;
1: import java.io.FileOutputStream;
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1:     private FileOutputStream serverOutput;
1:     
/////////////////////////////////////////////////////////////////////////
1: 
1:             
0:             serverOutput = (FileOutputStream)
0:             AccessController.doPrivileged(new PrivilegedAction() {
0:                 public Object run() {
0:                     String fileName = System.getProperty("derby.system.home") + 
0:                             "serverConsoleOutput.log";
1:                     FileOutputStream fos = null;
1:                     try {
0:                         fos = (new FileOutputStream(fileName));
1:                     } catch (FileNotFoundException ex) {
1:                         ex.printStackTrace();
1:                     }
1:                     return fos;
1:                 }
1:             });
1: 
1:             networkServerController.start(new PrintWriter(serverOutput));
/////////////////////////////////////////////////////////////////////////
0:             serverOutput.close();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:9611078
/////////////////////////////////////////////////////////////////////////
1:         waitForAvailablePort(TestConfiguration.getCurrent().getPort());
/////////////////////////////////////////////////////////////////////////
1:      * @param port value.
/////////////////////////////////////////////////////////////////////////
1:         InetAddress serverAddress = InetAddress.getByName(
1:                 TestConfiguration.getCurrent().getHostName());
commit:a40bc13
/////////////////////////////////////////////////////////////////////////
0:         waitForAvailablePort(-1);
1:     }
1: 
1: 
1:     /**
1:      * Wait until the specified port has been released by
1:      * by earlier test cases, or until the timeout specified by
1:      * {@link #getWaitTime()} has elapsed.
1:      *
0:      * @param port If -1, use default port for configuration, else use this
0:      *             value.
1:      * @throws AssertionFailedError if the port didn't become available before
1:      * the timeout
1:      * @throws InterruptedException if the thread was interrupted while waiting
1:      * for the port to become available
1:      * @throws UnknownHostException if the host name couldn't be resolved
1:      */
1:     public static void waitForAvailablePort(int port)
1:             throws InterruptedException, UnknownHostException {
1: 
1: 
0:         if (port == -1) {
0:             port = conf.getPort();
1:         }
1: 
1:         BaseTestCase.println(
1:                 "probing port for availability: " + serverAddress + ":" + port);
/////////////////////////////////////////////////////////////////////////
1:                         getTimeoutErrorMsg("server port to become available",
1:                             port),
/////////////////////////////////////////////////////////////////////////
1:     private static String getTimeoutErrorMsg(String failedAction, int port) {
1: 
1:     private static String getTimeoutErrorMsg(String failedAction) {
1:         TestConfiguration conf = TestConfiguration.getCurrent();
0:         int port = conf.getPort();
1:         return getTimeoutErrorMsg(failedAction, port);
1:     }
commit:dcfc481
/////////////////////////////////////////////////////////////////////////
0:         al.add( "-Demma.verbosity.level=silent" );
1:         // Loading from classes need to work-around the limitation of the
1:         // default policy file doesn't work with classes.  Similarly, if we are
1:         // running with Emma we don't run with the security manager, as the
1:         // default server policy doesn't contain needed permissions and,
1:         // additionally, Emma sources do not use doPrivileged blocks anyway.
0:         if (!TestConfiguration.loadingFromJars() || BaseTestCase.runsWithEmma())
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cf2526e
/////////////////////////////////////////////////////////////////////////
1:                     String msg = getTimeoutErrorMsg("network server to start");
/////////////////////////////////////////////////////////////////////////
1:                     fail(msg + Utilities.NL + ExceptionUtil.dumpThreads());
/////////////////////////////////////////////////////////////////////////
0:                         getTimeoutErrorMsg("server port to become available"),
/////////////////////////////////////////////////////////////////////////
1:              fail(getTimeoutErrorMsg("network server to start"));
/////////////////////////////////////////////////////////////////////////
1:     /** Returns an error message for timeouts including the port and host. */
0:     private static String getTimeoutErrorMsg(String failedAction) {
0:         TestConfiguration conf = TestConfiguration.getCurrent();
0:         int port = conf.getPort();
1:         String host = conf.getHostName();
1:         return "Timed out waiting for " +
1:                 failedAction + " (" + host + ":" + port + ")";
1:     }
commit:5bf45ca
/////////////////////////////////////////////////////////////////////////
0:                         "Timed out waiting for server port " + port +
0:                         " to become available on host " + conf.getHostName(),
commit:1e0c703
/////////////////////////////////////////////////////////////////////////
1:         if (!TestConfiguration.loadingFromJars() ||
1:                 BaseTestCase.runsWithEmma() || BaseTestCase.runsWithJaCoCo())
commit:04846d1
/////////////////////////////////////////////////////////////////////////
1:                         spawnedServer.complete(2000);
/////////////////////////////////////////////////////////////////////////
1:                 spawnedServer.complete(getWaitTime());
commit:9c86d82
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dc9cd0f
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:                         !(failedShutdown instanceof SQLException)
commit:5107349
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
/////////////////////////////////////////////////////////////////////////
1:                 {
1:                     // authentication failure is ok.
1:                     if (
0:                         !(failedShutdown instanceof SQLException) ||
0:                         !( "4251I".equals( ((SQLException) failedShutdown).getSQLState() ) )
1:                         )
1:                     {
1:                         throw (Exception) failedShutdown;
1:                     }
1:                 }
1:                 else
1:                 {
1:                     throw (Error) failedShutdown;
1:                 }
commit:f69e1a2
/////////////////////////////////////////////////////////////////////////
1: import java.util.ArrayList;
/////////////////////////////////////////////////////////////////////////
1:     public static final String HOST_OPTION = "-h";
1: 
/////////////////////////////////////////////////////////////////////////
1:                 String[]    args = getDefaultStartupArgs( false );
/////////////////////////////////////////////////////////////////////////
1:         boolean         skipHostName = false;
/////////////////////////////////////////////////////////////////////////
1:         count = startupArgs.length;
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             // if the special startup args override the hostname, then don't
1:             // specify it twice
1:             if ( HOST_OPTION.equals( startupArgs[ i ] ) ) { skipHostName = true; }
1:         }
1: 
0:         String[]    defaultArgs = getDefaultStartupArgs( skipHostName );
/////////////////////////////////////////////////////////////////////////
0:         //System.out.println( "XXX server startup command = " + command );
1: 
/////////////////////////////////////////////////////////////////////////
1:             {
1:                 try {
1:                     networkServerController.shutdown();
1:                 } catch (Throwable t)
1:                 {
1:                     t.printStackTrace( System.out );
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:     public  static String[] getDefaultStartupArgs( boolean skipHostName )
0:         ArrayList               argsList = new ArrayList();
1: 
1:         argsList.add( "start" );
1: 
1:         if ( !skipHostName )
1:         {
1:             argsList.add( HOST_OPTION );
1:             argsList.add( config.getHostName() );
1:         argsList.add( "-p" );
1:         argsList.add( Integer.toString(config.getPort() ) );
1: 
1:         if (config.getSsl() != null) {
1:             argsList.add( "-ssl" );
1:             argsList.add( config.getSsl( ) );
1:         }
1: 
1:         String[]    retval = new String[ argsList.size() ];
1: 
1:         argsList.toArray( retval );
1: 
1:         return retval;
/////////////////////////////////////////////////////////////////////////
1:             } catch (Throwable e) {
1:                 if ( !vetPing( e ) )
1:                 {
1:                     e.printStackTrace( System.out );
1: 
1:                     // at this point, we don't have the usual "server not up
1:                     // yet" error. get out. at this point, you may have to
1:                     // manually kill the server.
1: 
1:                     return false;
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 } catch (Throwable t) {
1:                     // something unfortunate happened
0:                     t.printStackTrace( System.out );
1:                     return false;
1:     // return false if ping returns an error other than "server not up yet"
1:     private static  boolean vetPing( Throwable t )
1:     {
1:         if ( !t.getClass().getName().equals( "java.lang.Exception" ) ) { return false; }
1:         
0:         return ( t.getMessage().startsWith( "DRDA_NoIO.S:Could not connect to Derby Network Server" ) );
1:     }
1:     
1:     // return true if this is a drda error
1:     private static  boolean isDRDAerror( Throwable t )
1:     {
1:         if ( !t.getClass().getName().equals( "java.lang.Exception" ) ) { return false; }
1:         
1:         return ( t.getMessage().startsWith( "DRDA" ) );
1:     }
1:     
commit:77b824b
/////////////////////////////////////////////////////////////////////////
1:      * Returns the <code>Process</code> object for the server process or <code>null</code> if the
commit:e0f1ffe
/////////////////////////////////////////////////////////////////////////
0: import java.io.InputStream;
/////////////////////////////////////////////////////////////////////////
0:     /** Wait maximum 1 minute for server to start */
0:     private static final long WAIT_TIME = 60000;
1:     
0:     /** Sleep for 50 ms before pinging the network server (again) */
0:     private static final int SLEEP_TIME = 50;
1: 
1:     private static  long    waitTime = WAIT_TIME;
1:     
1: 
1:     private final boolean useSeparateProcess;
1:     private final boolean serverShouldComeUp;
0:     private final InputStream[] inputStreamHolder;
1:     private final String[]    systemProperties;
0:     private final String[]    startupArgs;
/////////////////////////////////////////////////////////////////////////
1: 
1:         this.systemProperties = null;
1:         this.startupArgs = null;
1:         this.useSeparateProcess = false;
1:         this.serverShouldComeUp = true;
0:         this.inputStreamHolder = null;
1: }
1: 
1:      /**
0:      * Decorator for starting up with specific command args.
1:      */
1:     public NetworkServerTestSetup
1:         (
1:          Test test,
1:          String[] systemProperties,
1:          String[] startupArgs,
0:          boolean useSeparateProcess,
0:          boolean serverShouldComeUp,
0:          InputStream[] inputStreamHolder
1:         )
1:     {
1:         super(test);
1:         
1:         this.asCommand = true;
1: 
1:         this.systemProperties = systemProperties;
1:         this.startupArgs = startupArgs;
1:         this.useSeparateProcess = true;
1:         this.serverShouldComeUp = serverShouldComeUp;
0:         this.inputStreamHolder = inputStreamHolder;
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (useSeparateProcess)
0:         { startSeparateProcess(); }
1:         else if (asCommand)
1:         { startWithCommand(); }
1:         { startWithAPI(); }
0:         if ( serverShouldComeUp ) { waitForServerStart(networkServerController); }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
0:                 String[]    args = getDefaultStartupArgs();
1:                 
1:                 org.apache.derby.drda.NetworkServerControl.main( args );
0:     private void startSeparateProcess() throws Exception
1:     {
0:         StringBuffer    buffer = new StringBuffer();
0:         String              classpath = BaseTestCase.getSystemProperty( "java.class.path" );
1: 
0:         buffer.append( "java -classpath " );
0:         buffer.append( classpath );
0:         buffer.append( " " );
1: 
1:         int         count = systemProperties.length;
1:         for ( int i = 0; i < count; i++ )
1:         {
0:             buffer.append( " -D" );
0:             buffer.append( systemProperties[ i ] );
1:         }
1: 
0:         buffer.append( " org.apache.derby.drda.NetworkServerControl " );
1: 
0:         String[]    defaultArgs = getDefaultStartupArgs();
1: 
0:         count = defaultArgs.length;
1:         for ( int i = 0; i < count; i++ )
1:         {
0:             buffer.append( " " );
0:             buffer.append( defaultArgs[ i ] );
1:         }
1: 
0:         count = startupArgs.length;
1:         for ( int i = 0; i < count; i++ )
1:         {
0:             buffer.append( " " );
0:             buffer.append( startupArgs[ i ] );
1:         }
1: 
0:         final   String  command = buffer.toString();
1: 
0:         Process     serverProcess = (Process) AccessController.doPrivileged
0:             (
0:              new PrivilegedAction()
1:              {
0:                  public Object run()
1:                  {
0:                      Process    result = null;
1:                      try {
0:                         result = Runtime.getRuntime().exec( command );
0:                      } catch (Exception ex) {
0:                          ex.printStackTrace();
1:                      }
1:                      
0:                      return result;
1:                  }
1:              }
0:             );
1: 
0:         inputStreamHolder[ 0 ] = serverProcess.getInputStream();
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:             if ( serverOutput != null ) { serverOutput.close(); }
1:     /**
1:      * Get the default command arguments for booting the network server.
1:      */
0:     public  static String[] getDefaultStartupArgs()
1:     {
1:         TestConfiguration config = TestConfiguration.getCurrent();
1:         
0:         return new String[] {
0:             "start",
0:             "-h",
0:             config.getHostName(),
0:             "-p",
0:             Integer.toString(config.getPort())
0:         };
1:     }
1:     
1:         
/////////////////////////////////////////////////////////////////////////
1:      /**
1:      * Set the number of milliseconds to wait before declaring server startup
1:      * a failure.
1:      * 
1:      */
1:     public static void setWaitTime( long newWaitTime )
1:    {
1:         waitTime = newWaitTime;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
0:                 if (System.currentTimeMillis() - startTime > waitTime) {
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:a535758
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.BaseTestCase;
/////////////////////////////////////////////////////////////////////////
0:         String startcommand ="";
0:         	startcommand += command[i] + " ";
1: 
0:         BaseTestCase.println("XXX server startup command = " +
0: 	startcommand + "\n");
commit:17227cf
/////////////////////////////////////////////////////////////////////////
0:                 spawnedServer.complete(failedShutdown != null, getWaitTime());
commit:ceee49e
/////////////////////////////////////////////////////////////////////////
1:         return ( t.getMessage().startsWith( "DRDA_NoIO.S:" ) );
commit:f23a20f
/////////////////////////////////////////////////////////////////////////
0:         al.add( BaseTestCase.getJavaExecutableName() );
commit:2a899d8
/////////////////////////////////////////////////////////////////////////
0:     /** Setting maximum wait time to 40 seconds.   On some platforms
0:      * it may take this long to start the server.  Increasing the wait
0:      *  time should not adversely affect those
0:     private static final long WAIT_TIME = 40000;
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:86ce429
/////////////////////////////////////////////////////////////////////////
0:     /** Setting maximum wait time to 40 seconds by default.  On some platforms
1:      *  For even slower systems (or for faster systems) the default value can
1:      *  be overwritten using the property derby.tests.networkServerStartTimeout
1:      *  (which is in seconds, rather than milliseconds)
0:     private static final long DEFAULT_WAIT_TIME = 40000;
1:     private static final long WAIT_TIME = getWaitTime();
/////////////////////////////////////////////////////////////////////////
1:     
1:     /*
0:      * set the period before network server times out on start up based on the
1:      * value passed in with property derby.tests.networkServerStartTimeout
0:      * in seconds, or use the default
0:      * for example: with DEFAULT_WAIT_TIME set to 40000, i.e. 40 seconds,
1:      * setting the property like so: 
0:      *          -Dderby.tests.networkServerStartTimeout=60
0:      * would extend the timeout to 1 minute.
1:      * If an invalid value is passed in (eg. 'abc') the calling test will fail
1:      */
1:     public static long getWaitTime() {
1:         long waitTime = DEFAULT_WAIT_TIME;
1:         String waitString = BaseTestCase.getSystemProperty(
1:                 "derby.tests.networkServerStartTimeout");
1:         if (waitString != null && waitString.length() != 0)
1:         {
1:             try {
1:                 waitTime = (Long.parseLong(waitString)*1000);
1:             } catch (Exception e) {
0:                 e.printStackTrace();
0:                 fail("trouble setting WAIT_TIME from passed in property " +
1:                         "derby.tests.networkServerStartTimeout");
1:             }
1:         }
1:         return waitTime;
1:     }
1: 
commit:0c8f7b8
/////////////////////////////////////////////////////////////////////////
1:     private final boolean startServerAtSetup;
/////////////////////////////////////////////////////////////////////////
1:         this.startServerAtSetup = true;
1:     /**
0:      * Decorator this test with the NetworkServerTestSetup.
1:      * 
0:      * Sets up the server using the current configuration, but does not start.
1:      * 
1:      * @param test the Test for which this setup is used
1:      * @param asCommand True to start using NetworkServerControl.main()
0:      * within the same virtual machine, false to use NetworkServerControl.start.
0:      * @param startServerAtSetup False to start using NetworkServerControl.main()
1:      * 
1:      * @see NetworkServerControl#main(String[])
1:      * @see NetworkServerControl#start(PrintWriter)
1:      */
0:     public NetworkServerTestSetup(Test test, boolean asCommand, boolean startServerAtSetup) {
1:         super(test);
1:         this.asCommand = asCommand;
1: 
1:         this.systemProperties = null;
1:         this.startupArgs = null;
1:         this.useSeparateProcess = false;
1:         this.serverShouldComeUp = true;
0:         this.inputStreamHolder = null;
1: 
1:         this.startServerAtSetup = startServerAtSetup;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:         this.startServerAtSetup = true;
/////////////////////////////////////////////////////////////////////////
1:         if (startServerAtSetup)
1:         {
0:             if (useSeparateProcess)
0:             { serverProcess = startSeparateProcess(); }
0:             else if (asCommand)
0:             { startWithCommand(); }
1:             else
0:             { startWithAPI(); }
1: 
0:             if ( serverShouldComeUp ) { waitForServerStart(networkServerController); }
1:         }
/////////////////////////////////////////////////////////////////////////
1:      * Return a new NetworkServerControl for the current configuration.
1:      * Use the port number specified.
1:      * This method is not for general use - in most cases, the port
1:      * should not be specified in the test, instead, the test framework
1:      * will decide what is the best port number to use.
1:      */
1:     public static NetworkServerControl getNetworkServerControl(int port)
1:         throws Exception
1:     {
1:         TestConfiguration config = TestConfiguration.getCurrent();
0:             return new NetworkServerControl
0:             (InetAddress.getByName(config.getHostName()), 
0:              port);
1:     }
1:     
1:     /**
1:      * Return a new NetworkServerControl for the current configuration.
1:      * Use default values, i.e. port number and host are dependent on 
1:      * whatever settings are set in the environment (properties)
1:      */
1:     public static NetworkServerControl getNetworkServerControlDefault()
1:         throws Exception
1:     {
1:         TestConfiguration config = TestConfiguration.getCurrent();
0:             return new NetworkServerControl();
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:      * Set the number of milliseconds to wait before declaring server startup
1:      * a failure back to the default value specified in this class.
1:      * 
1:      */
1:     public static void setDefaultWaitTime()
1:     {
1:         waitTime = WAIT_TIME;
1:     }
1:     
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     public static boolean pingForServerUp(
1:         NetworkServerControl networkServerController, Process serverProcess,
1:         boolean expectServerUp)
1:         // If we expect the server to be or come up, then
1:         // it makes sense to sleep (if ping unsuccessful), then ping 
1:         // and repeat this for the duration of wait-time, but stop
1:         // when the ping is successful.
1:         // But if we are pinging to see if the server is - or
1:         // has come - down, we should do the opposite, stop if ping 
1:         // is unsuccessful, and repeat until wait-time if it is
0:                 if (expectServerUp)
0:                     return true;
1:                 else
1:                 {
0:                     if (System.currentTimeMillis() - startTime > waitTime) {
0:                         return true;
1:                     }
1:                 }
/////////////////////////////////////////////////////////////////////////
1:                 if (expectServerUp){
1:                     if (System.currentTimeMillis() - startTime > waitTime) 
1:                         return false;
1:                 // else, we got what we expected, done.
0:                 else
1:                     return false;
/////////////////////////////////////////////////////////////////////////
1:             Thread.sleep(SLEEP_TIME);
/////////////////////////////////////////////////////////////////////////
1:         return pingForServerUp(control, null, true);
commit:57efc9f
/////////////////////////////////////////////////////////////////////////
0:         /* System.out.println( "XXX server startup command = ");
1:         */
commit:044179c
/////////////////////////////////////////////////////////////////////////
0:          System.out.println( "XXX server startup command = ");
1:         
commit:e621aee
/////////////////////////////////////////////////////////////////////////
0:         ArrayList       al = new ArrayList();
0:         al.add( "java" );
0:         al.add( "-classpath" );
0:         al.add( classpath );
1:             al.add( "-D" + systemProperties[ i ] );
1:         al.add( "org.apache.derby.drda.NetworkServerControl" );
/////////////////////////////////////////////////////////////////////////
0:             al.add( defaultArgs[ i ] );
0:             al.add( startupArgs[ i ] );
1:         final   String[]  command = new String[ al.size() ];
1:         al.toArray(command);
0:         /* System.out.println( "XXX server startup command = ");
0:         for (int i = 0 ; i < command.length ; i++) {
0:             System.out.print( command[i] + " " );
1:         }
0:         System.out.println();
1:         */
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:c5d7876
/////////////////////////////////////////////////////////////////////////
1:             Throwable failedShutdown = null;
1:                     failedShutdown = t;
/////////////////////////////////////////////////////////////////////////
1:                 // Destroy the process if a failed shutdown
1:                 // to avoid hangs running tests as the complete()
1:                 // waits for the process to complete.
0:                 spawnedServer.complete(failedShutdown != null);
1:             
1:             // Throw an error to record the fact that the
1:             // shutdown failed.
1:             if (failedShutdown != null)
1:             {
1:                 if (failedShutdown instanceof Exception)
0:                     throw (Exception) failedShutdown;
1:                 
0:                 throw (Error) failedShutdown;
1:             }
1:                 
commit:d7b5f4a
/////////////////////////////////////////////////////////////////////////
1:      * Decorates a test with the NetworkServerTestSetup.
1:      * within the same virtual machine, false to use NetworkServerControl.start
1:      * (also within the same JVM).
/////////////////////////////////////////////////////////////////////////
1:      * Decorates a test with the NetworkServerTestSetup.
1:      * Sets up the server using the current configuration. Whether or not the
1:      * server is actually started at setup time is determined by the value of 
1:      * the passed parameters.
1:      * within the same virtual machine, false to use NetworkServerControl.start()
1:      * (also within the same virtual machine).
1:      * @param startServerAtSetup True to start the Network Server at setup time,
1:      *        False otherwise.
1:     public NetworkServerTestSetup(  Test test, 
1:                                     boolean asCommand, 
1:                                     boolean startServerAtSetup) {
commit:a63ab5e
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
0:     private static final long WAIT_TIME = 10000;
1:     private static final int SLEEP_TIME = 100;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private String[]    startupArgs;
1:     /**
1:      * The server as a process if started in a different vm.
1:      */
1:     private SpawnedProcess spawnedServer;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * <P>
1:      * If the classes are being loaded from the classes
1:      * folder instead of jar files then this will start
1:      * the server up with no security manager using -noSecurityManager,
1:      * unless the systemProperties or startupArgs set up any security
1:      * manager.
1:      * This is because the default policy
1:      * installed by the network server only works from jar files.
1:      * If this not desired then the test should skip the
1:      * fixtures when loading from classes or
1:      * install its own security manager.
1:          boolean serverShouldComeUp
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             { spawnedServer = startSeparateProcess(); }
1:             if (serverShouldComeUp)
1:             {
1:                 if (!pingForServerStart(networkServerController)) {
0:                     String msg = "Timed out waiting for network server to start";
1:                     // Dump the output from the spawned process
1:                     // and destroy it.
1:                     if (spawnedServer != null) {
0:                         spawnedServer.complete(true);
1:                         msg = spawnedServer.getFailMessage(msg);
1:                         spawnedServer = null;
1:                     }
0:                     fail(msg);
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:     private SpawnedProcess startSeparateProcess() throws Exception
/////////////////////////////////////////////////////////////////////////
1:         
0:         // Loading from classes need to work-around the limitation
0:         // of the default policy file doesn't work with classes.
0:         if (!TestConfiguration.loadingFromJars())
1:         {
1:             boolean setNoSecurityManager = true;
1:             for (int i = 0; i < systemProperties.length; i++)
1:             {
1:                 if (systemProperties[i].startsWith("java.security."))
1:                 {
1:                     setNoSecurityManager = false;
1:                     break;
1:                 }
1:             }
1:             for (int i = 0; i < startupArgs.length; i++)
1:             {
1:                 if (startupArgs[i].equals("-noSecurityManager"))
1:                 {
1:                     setNoSecurityManager = false;
1:                     break;
1:                 }
1:             }
1:             if (setNoSecurityManager)
1:             {
1:                 String[] newArgs = new String[startupArgs.length + 1];
1:                 System.arraycopy(startupArgs, 0, newArgs, 0, startupArgs.length);
1:                 newArgs[newArgs.length - 1] = "-noSecurityManager";
1:                 startupArgs = newArgs;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
0:         Process serverProcess;
1:         
1:         try {
0:             serverProcess = (Process)
0:                 AccessController.doPrivileged
0:                 (
0:                  new PrivilegedExceptionAction()
0:                      public Object run() throws IOException
0:                      {
0:                          return Runtime.getRuntime().exec(command);
0:                 );
0:         } catch (PrivilegedActionException e) {
0:             throw e.getException();
1:         }
1:         return new SpawnedProcess(serverProcess, "SpawnedNetworkServer");
1:     public SpawnedProcess getServerProcess() {
1:         return spawnedServer;
/////////////////////////////////////////////////////////////////////////
1:             if (spawnedServer != null) {
0:                 spawnedServer.complete(false);
1:                 spawnedServer = null;
/////////////////////////////////////////////////////////////////////////
1:         if (!pingForServerStart(networkServerController)) {
0:              fail("Timed out waiting for network server to start");
1:         }
commit:204c040
/////////////////////////////////////////////////////////////////////////
1:         final InetAddress host = InetAddress.getByName(config.getHostName());
1:         final int port = config.getPort();
1:         final String user = config.getUserName();
1:         final String password = config.getUserPassword();
1:             return new NetworkServerControl(host, port, user, password);
1:             NetworkServerControl control
1:                 = new NetworkServerControl(host, port, user, password);
/////////////////////////////////////////////////////////////////////////
1:         final InetAddress host = InetAddress.getByName(config.getHostName());
1:         final String user = config.getUserName();
1:         final String password = config.getUserPassword();
1:         return new NetworkServerControl(host, port, user, password);
/////////////////////////////////////////////////////////////////////////
1:         final String user = config.getUserName();
1:         final String password = config.getUserPassword();
1:         return new NetworkServerControl(user, password);
commit:433c058
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * System properties to set on the command line (using -D)
1:      * only when starting the server in a separate virtual machine.
1:      */
1:     
1:     /**
1:      * Startup arguments for the command line
1:      * only when starting the server in a separate virtual machine.
1:      */
0:      * Decorator this test with the NetworkServerTestSetup.
1:      * 
1:      * Runs the server using the current configuration (at the time
1:      * of setup).
1:      * 
1:      * @param asCommand True to start using NetworkServerControl.main()
0:      * within the same virtual machine, false to use NetworkServerControl.start.
1:      * 
1:      * @see NetworkServerControl#main(String[])
1:      * @see NetworkServerControl#start(PrintWriter)
/////////////////////////////////////////////////////////////////////////
1:      * Decorator for starting up with specific command args
1:      * and system properties. Server is always started up
1:      * in a separate process with a separate virtual machine.
commit:49c16da
/////////////////////////////////////////////////////////////////////////
1:             String oldValue = BaseTestCase.getSystemProperty("derby.drda.sslMode");
1:             BaseTestCase.setSystemProperty("derby.drda.sslMode", config.getSsl());
1:                
1: 
1:                 BaseTestCase.removeSystemProperty("derby.drda.sslMode");
1:                 BaseTestCase.setSystemProperty("derby.drda.sslMode", oldValue);
commit:23c0fed
/////////////////////////////////////////////////////////////////////////
1: final public class NetworkServerTestSetup extends BaseTestSetup {
commit:76da2f3
/////////////////////////////////////////////////////////////////////////
1:        throws InterruptedException 
0:     {
0:         if (!pingForServerStart(networkServerController))
0:             fail("Timed out waiting for network server to start");
1:     }
1:     
1:     /**
1:      * Ping server for upto sixty seconds. If the server responds
1:      * in that time then return true, otherwise return false.
1:      * 
1:      */
0:     public static boolean pingForServerStart(NetworkServerControl networkServerController)
1:         throws InterruptedException
0:     {
0:                 return true;
0:                     return false;
commit:f3271c1
/////////////////////////////////////////////////////////////////////////
1:             networkServerController = null;
1:             serverOutput = null;
commit:0c9f73e
/////////////////////////////////////////////////////////////////////////
0: import java.net.UnknownHostException;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final boolean asCommand;
1:     public NetworkServerTestSetup(Test test, boolean asCommand) {
1:         this.asCommand = asCommand;
1:         BaseTestCase.println("Starting network server:");
1:         networkServerController = getNetworkServerControl();
0:         if (asCommand)
0:             startWithCommand();
0:         else
0:             startWithAPI();
0:         
0:         waitForServerStart(networkServerController);
1:     }
1:     private void startWithAPI() throws Exception
0:     {
/////////////////////////////////////////////////////////////////////////
0:    
1:     }
0:     
1:     private void startWithCommand() throws Exception
0:     {
0:         final TestConfiguration config = TestConfiguration.getCurrent();
0:         
1:         // start the server through the command line
1:         // arguments using a new thread to do so.
1:         new Thread(
1:         new Runnable() {
1:             public void run() {
0:                 org.apache.derby.drda.NetworkServerControl.main(
0:                         new String[] {
0:                                 "start",
0:                                 "-h",
0:                                 config.getHostName(),
0:                                 "-p",
0:                                 Integer.toString(config.getPort())
0:                         });                
0:             
1:         }, "NetworkServerTestSetup command").start();
1:      * Stop the network server if it still
1:      * appears to be running.
1:             boolean running = false;
0:             try {
1:                 networkServerController.ping();
1:                 running = true;
1:             } catch (Exception e) {
1:             }
0:       
1:             if (running)
0:                 networkServerController.shutdown();
0:  
/////////////////////////////////////////////////////////////////////////
0:     
0:     
1:     /*
1:      * Utility methods related to controlling network server.
1:      */
0:     
1:     /**
1:      * Return a new NetworkServerControl for the current configuration.
1:      */
1:     public static NetworkServerControl getNetworkServerControl()
1:         throws Exception
0:     {
1:         TestConfiguration config = TestConfiguration.getCurrent();
0:         return new NetworkServerControl
0:         (InetAddress.getByName(config.getHostName()), config.getPort());
1:     }
0:     
1:     /**
1:      * Ping the server until it has started. Asserts a failure
1:      * if the server has not started within sixty seconds.
1:      */
1:     public static void waitForServerStart(NetworkServerControl networkServerController)
0:         throws InterruptedException {
1:         final long startTime = System.currentTimeMillis();
1:         while (true) {
0:             Thread.sleep(SLEEP_TIME);
0:             try {
1:                 networkServerController.ping();
0:                 break;
0:             } catch (Exception e) {
0:                 if (System.currentTimeMillis() - startTime > WAIT_TIME) {
0:                     e.printStackTrace();
0:                     fail("Timed out waiting for network server to start");
1:                 }
1:             }
1:         }
1:     }
commit:eba07fc
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1:                     File logs = new File("logs");
1:                     logs.mkdir();
1:                     File console = new File(logs, "serverConsoleOutput.log");
1:                         fos = new FileOutputStream(console.getPath(), true);
/////////////////////////////////////////////////////////////////////////
commit:e0104e8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         TestConfiguration config = TestConfiguration.getCurrent();
0:         
/////////////////////////////////////////////////////////////////////////
commit:7a46698
/////////////////////////////////////////////////////////////////////////
0: /*
1:  *
1:  * Derby - Class org.apache.derbyTesting.junit.NetworkServerTestSetup
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.junit;
0: 
1: import java.net.InetAddress;
1: import java.io.PrintWriter;
0: import junit.extensions.TestSetup;
1: import junit.framework.Test;
1: import org.apache.derby.drda.NetworkServerControl;
0: 
0: // This import can be removed once junit classes are moved to this 
0: // package:
0: import org.apache.derbyTesting.functionTests.util.*;
0: 
1: /**
1:  * Test decorator that starts the network server on startup
1:  * and stops it on teardown.
1:  * 
0:  * It does not start it if the test is configured to run in
0:  * embedded mode.
1:  *
0:  * Currently it will start the network server in the same VM
0:  * as, and it does not support starting it from a remote 
0:  * machine.
1:  */
0: final public class NetworkServerTestSetup extends TestSetup {
0: 
1:     /**
0:      * Decorator this test with the NetworkServerTestSetup
1:      */
0:     public NetworkServerTestSetup(Test test) {
1:         super(test);
0:         
0:         this.config = TestConfiguration.DERBY_TEST_CONFIG;
0:         this.networkServerController = null;
1:     }
0: 
1:     /**
1:      * Start the network server.
1:      */
1:     protected void setUp() throws Exception {
0:         
0:         if (config.getJDBCClient().isEmbedded()) {
0:             BaseTestCase.println("Starting network server:");
0:             networkServerController = new NetworkServerControl
0:                 (InetAddress.getByName(config.getHostName()), config.getPort());
0:             
0:             networkServerController.start(new PrintWriter(System.out));
0:             
0:             final long startTime = System.currentTimeMillis();
0:             while (true) {
0:                 Thread.sleep(SLEEP_TIME);
0:                 try {
0:                     networkServerController.ping();
0:                     break;
0:                 } catch (Exception e) {
0:                     if (System.currentTimeMillis() - startTime > WAIT_TIME) {
0:                         e.printStackTrace();
0:                         fail("Timed out waiting for network server to start");
1:                     }
1:                 }
1:             }
1:         }
1:     }
0: 
1:     /**
0:      * Stop the network server.
1:      */
1:     protected void tearDown() throws Exception {
1:         if (networkServerController != null) {
0:             networkServerController.shutdown();
1:         }
1:     }
0:     
1:     /* Network Server Control */
1:     private NetworkServerControl networkServerController;
0:     
0:     /* Configuration of test */
0:     private final TestConfiguration config;
0:     
0:     /** Wait maximum 1 minute for server to start */
0:     private static final int WAIT_TIME = 60000;
0:     
0:     /** Sleep for 50 ms before pinging the network server (again) */
0:     private static final int SLEEP_TIME = 50;
1: }
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:5a9d596
/////////////////////////////////////////////////////////////////////////
1:         if (config.getSsl() == null) {
0:             return new String[] {
0:                 "start",
0:                 "-h",
0:                 config.getHostName(),
0:                 "-p",
0:                 Integer.toString(config.getPort())
0:             };
1:         } else {
0:             return new String[] {
0:                 "start",
0:                 "-h",
0:                 config.getHostName(),
0:                 "-p",
0:                 Integer.toString(config.getPort()),
0:                 "-ssl",
0:                 config.getSsl()
0:             };
0:         }
/////////////////////////////////////////////////////////////////////////
0:         if (config.getSsl() == null) {
0:             return new NetworkServerControl
0:                 (InetAddress.getByName(config.getHostName()), 
0:                  config.getPort());
1:         } else {
1:             // This is a hack. A NetworkServerControl constructor with
1:             // the needed interface to control sslMode (and possibly
1:             // more) would be better.
0:             String oldValue = 
0:                 System.setProperty("derby.drda.sslMode", config.getSsl());
0:             NetworkServerControl control = new NetworkServerControl
0:                 (InetAddress.getByName(config.getHostName()), 
0:                  config.getPort());
1:             if (oldValue == null) {
0:                 // JDK 1.4 does not have clearProperty....
0:                 System.getProperties().remove("derby.drda.sslMode");
1:             } else {
0:                 System.setProperty("derby.drda.sslMode", oldValue);
0:             }
1:             return control;
0:         }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:765b3e4
/////////////////////////////////////////////////////////////////////////
0:     /** Setting maximum wait time to 300 seconds.   For some systems it looks
0:      *  like restarting a server to listen on the same port is blocked waiting
0:      *  for a system specific interval.  This number looks to be something
0:      *  like 240 seconds on XP.  Waiting shorter than this time causes
0:      *  intermittent failures on a laptop running XP with a software firewall
0:      *  and a VPN.  Increasing the wait time should not adversely affect those
1:      *  systems with fast port turnaround as the actual code loops for 
1:      *  SLEEP_TIME intervals, so should never see WAIT_TIME.
0:      */
0:     private static final long WAIT_TIME = 300000;
0:     /** Sleep for 500 ms before pinging the network server (again) */
0:     private static final int SLEEP_TIME = 500;
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:ed153bd
/////////////////////////////////////////////////////////////////////////
0:             networkServerController.start(null);
commit:18f963f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:  * and it does not support starting it from a remote 
/////////////////////////////////////////////////////////////////////////
0:         if (!config.getJDBCClient().isEmbedded()) {
============================================================================