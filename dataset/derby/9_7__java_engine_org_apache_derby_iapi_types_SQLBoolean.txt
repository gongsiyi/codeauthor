2:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.SQLBoolean
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
25:eac0369: 
13:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:1b3f93b: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:9548d38: import java.math.BigDecimal;
1:eac0369: 
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.SQLException;
1:af1c18c: import org.apache.derby.catalog.UUID;
1:af1c18c: import org.apache.derby.iapi.sql.Activation;
1:af1c18c: import org.apache.derby.iapi.sql.Row;
1:af1c18c: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:af1c18c: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1:af1c18c: import org.apache.derby.impl.sql.execute.DMLWriteResultSet;
1:eac0369: 
12:eac0369: /**
1:eac0369:  * SQLBoolean satisfies the DataValueDescriptor
1:eac0369:  * interfaces (i.e., DataType). It implements a boolean column, 
1:eac0369:  * e.g. for * storing a column value; it can be specified
1:eac0369:  * when constructed to not allow nulls. Nullability cannot be changed
1:eac0369:  * after construction, as it affects the storage size and mechanism.
1:eac0369:  * <p>
1:eac0369:  * Because DataType is a subtype of DataType,
1:eac0369:  * SQLBoolean can play a role in either a DataType/Row
1:eac0369:  * or a DataType/Row, interchangeably.
1:eac0369:  * <p>
1:eac0369:  * We assume the store has a flag for nullness of the value,
1:eac0369:  * and simply return a 0-length array for the stored form
1:eac0369:  * when the value is null.
1:eac0369:  * <p>
1:eac0369:  * PERFORMANCE: There are likely alot of performance improvements
1:eac0369:  * possible for this implementation -- it new's Integer
1:eac0369:  * more than it probably wants to.
1:eac0369:  */
1:eac0369: public final class SQLBoolean
1:eac0369: 	extends DataType implements BooleanDataValue
20:eac0369: {
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 * (mostly implemented in DataType)
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * see if the integer value is null.
1:eac0369: 	 */
1:eac0369: 	public boolean isNull()
1:eac0369: 	{
1:eac0369: 		return isnull;
22:eac0369: 	}
1:eac0369: 
1:eac0369: 	public boolean	getBoolean()
1:eac0369: 	{
1:eac0369: 		return value;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private static int makeInt(boolean b)
1:eac0369: 	{
1:eac0369: 		return (b?1:0);
1:eac0369: 	}
1:eac0369: 
1:2c6f0a2: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#getByte 
1:eac0369: 	 */
1:eac0369: 	public byte	getByte() 
1:eac0369: 	{
1:eac0369: 		return (byte) makeInt(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#getShort 
1:eac0369: 	 */
1:eac0369: 	public short	getShort()
1:eac0369: 	{
1:eac0369: 		return (short) makeInt(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#getInt 
1:eac0369: 	 */
1:eac0369: 	public int	getInt()
1:eac0369: 	{
1:eac0369: 		return makeInt(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#getLong 
1:eac0369: 	 */
1:eac0369: 	public long	getLong()
1:eac0369: 	{
1:eac0369: 		return (long) makeInt(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#getFloat 
1:eac0369: 	 */
1:eac0369: 	public float	getFloat()
1:eac0369: 	{
1:eac0369: 		return (float) makeInt(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#getDouble 
1:eac0369: 	 */
1:eac0369: 	public double	getDouble()
1:eac0369: 	{
1:eac0369: 		return (double) makeInt(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2c6f0a2: 	 * Implementation for BOOLEAN type. Convert to a BigDecimal using long
1:2c6f0a2: 	 */
1:2c6f0a2: 	public int typeToBigDecimal()
1:2c6f0a2: 	{
1:2c6f0a2: 		return java.sql.Types.BIGINT;
1:2c6f0a2: 	}
1:eac0369: 	public String	getString()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 			return null;
1:eac0369: 		else if (value == true)
1:eac0369: 			return "true";
4:eac0369: 		else
1:eac0369: 			return "false";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Object	getObject()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 			return null;
1:eac0369: 		else
1:ce40a31: 			return value;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int	getLength()
1:eac0369: 	{
1:eac0369: 		return BOOLEAN_LENGTH;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// this is for DataType's error generator
1:eac0369: 	public String getTypeName()
1:eac0369: 	{
1:eac0369: 		return TypeId.BOOLEAN_NAME;
1:eac0369: 	}
1:eac0369: 
1:109cb26:     /**
1:109cb26:      * Recycle this SQLBoolean object if possible. If the object is immutable,
1:109cb26:      * create and return a new object.
1:109cb26:      *
1:109cb26:      * @return a new SQLBoolean if this object is immutable; otherwise, this
1:109cb26:      * object with value set to null
1:109cb26:      */
1:109cb26:     public DataValueDescriptor recycle() {
1:109cb26:         if (immutable) {
1:109cb26:             return new SQLBoolean();
1:109cb26:         }
1:109cb26:         return super.recycle();
1:109cb26:     }
1:109cb26: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() {
1:eac0369: 		return StoredFormatIds.SQL_BOOLEAN_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException {
1:eac0369: 
1:eac0369: 		// never called when value is null
4:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(! isNull());
1:eac0369: 
1:eac0369: 		out.writeBoolean(value);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see java.io.Externalizable#readExternal */
1:eac0369: 	public void readExternal(ObjectInput in) throws IOException {
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
4:eac0369: 			SanityManager.ASSERT( ! immutable,
4:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 
2:eac0369: 		value = in.readBoolean();
5:eac0369: 		isnull = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Storable#restoreToNull
20:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void restoreToNull()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 
3:eac0369: 		value = false;
3:eac0369: 		isnull = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Orderable interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public int compare(DataValueDescriptor other) throws StandardException
1:eac0369: 	{
1:eac0369: 		/* Use compare method from dominant type, negating result
1:eac0369: 		 * to reflect flipping of sides.
1:eac0369: 		 */
1:eac0369: 		if (typePrecedence() < other.typePrecedence())
1:eac0369: 		{
1:eac0369: 			return - (other.compare(this));
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		boolean thisNull, otherNull;
1:eac0369: 		thisNull = this.isNull();
1:eac0369: 		otherNull = other.isNull();
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		 * thisNull otherNull thisValue thatValue return
1:eac0369: 		 *	T		T			X		X			0	(this == other)
1:31f120e: 		 *	F		T			X		X			-1 	(this > other)
1:31f120e: 		 *	T		F			X		X			1	(this < other)
1:eac0369: 		 *
1:eac0369: 		 *	F		F			T		T			0	(this == other)
1:eac0369: 		 *	F		F			T		F			1	(this > other)
1:eac0369: 		 *	F		F			F		T			-1	(this < other)
1:eac0369: 		 *	F		F			F		F			0	(this == other)
1:eac0369: 		 */
1:eac0369: 		if (thisNull || otherNull)
1:eac0369: 		{
1:eac0369: 			if (!thisNull)		// otherNull must be true
1:eac0369: 				return -1;
1:31f120e: 			if (!otherNull)		// thisNull must be true
1:31f120e: 				return 1;
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* neither are null, get the value */
1:eac0369: 		boolean thisValue;
1:eac0369: 		boolean otherValue = false;
1:eac0369: 		thisValue = this.getBoolean();
1:eac0369: 
1:eac0369: 		otherValue = other.getBoolean();
1:eac0369: 
1:eac0369: 		if (thisValue == otherValue)
1:eac0369: 			return 0;
1:eac0369: 		else if (thisValue && !otherValue)
2:eac0369: 			return 1;
1:eac0369: 		else
1:eac0369: 			return -1;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		@exception StandardException thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean compare(int op,
1:eac0369: 						   DataValueDescriptor other,
1:eac0369: 						   boolean orderedNulls,
1:eac0369: 						   boolean unknownRV)
2:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!orderedNulls)		// nulls are unordered
1:eac0369: 		{
1:eac0369: 			if (this.isNull() || other.isNull())
1:eac0369: 				return unknownRV;
1:eac0369: 		}
1:eac0369: 		/* Do the comparison */
1:eac0369: 		return super.compare(op, other, orderedNulls, unknownRV);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:854dd10: 	/** @see DataValueDescriptor#cloneValue */
1:854dd10: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
1:eac0369: 	{
1:eac0369: 		return new SQLBoolean(value, isnull);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#getNewNull
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getNewNull()
1:eac0369: 	{
1:eac0369: 		return new SQLBoolean();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#setValueFromResultSet 
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1:eac0369: 									  boolean isNullable)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:eac0369: 			value = resultSet.getBoolean(colNumber);
1:eac0369: 			isnull = (isNullable && resultSet.wasNull());
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Set the value into a PreparedStatement.
1:eac0369: 
1:eac0369: 		@exception SQLException Error setting value in PreparedStatement
1:eac0369: 	*/
1:eac0369: 	public final void setInto(PreparedStatement ps, int position) throws SQLException {
1:eac0369: 
1:eac0369: 		if (isNull()) {
1:eac0369: 			ps.setNull(position, java.sql.Types.BIT);
2:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		ps.setBoolean(position, value);
1:eac0369: 	}
1:eac0369: 	/*
1:eac0369: 	 * class interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * constructors
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/* NOTE - other data types have both (type value) and (boolean nulls), 
1:eac0369: 	 * (value, nulls)
1:eac0369: 	 * We can't do both (boolean value) and (boolean nulls) here,
1:eac0369: 	 * so we'll skip over (boolean value) and have (Boolean value) so
1:eac0369: 	 * that we can support (boolean nulls).
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public SQLBoolean()
1:eac0369: 	{
1:eac0369: 		isnull = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public SQLBoolean(boolean val)
1:eac0369: 	{
1:eac0369: 		value = val;
1:eac0369: 	}
1:eac0369: 	public SQLBoolean(Boolean obj) {
1:eac0369: 		if (isnull = (obj == null))
1:eac0369: 			;
1:eac0369: 		else
1:eac0369: 			value = obj.booleanValue();
1:eac0369: 	}
1:eac0369: 
1:854dd10:     /* This constructor gets used for the cloneValue method */
1:eac0369: 	private SQLBoolean(boolean val, boolean isnull)
1:eac0369: 	{
1:eac0369: 		value = val;
1:eac0369: 		this.isnull = isnull;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see BooleanDataValue#setValue */
1:eac0369: 	public void setValue(boolean theValue)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 		value = theValue;
1:eac0369: 		isnull = false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValue(Boolean theValue)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
3:eac0369: 		if (theValue == null)
1:eac0369: 		{
1:eac0369: 			value = false;
1:eac0369: 			isnull = true;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			value = theValue.booleanValue();
1:eac0369: 			isnull = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// REMIND: do we need this, or is long enough?
1:eac0369: 	public void setValue(byte theValue)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 		value = theValue != 0;
1:eac0369: 		isnull = false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	// REMIND: do we need this, or is long enough?
1:eac0369: 	public void setValue(short theValue)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 		value = theValue != 0;
1:eac0369: 		isnull = false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	// REMIND: do we need this, or is long enough?
1:eac0369: 	public void setValue(int theValue)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 		value = theValue != 0;
1:eac0369: 		isnull = false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValue(long theValue)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 		value = theValue != 0;
1:eac0369: 		isnull = false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// REMIND: do we need this, or is double enough?
1:eac0369: 	public void setValue(float theValue)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 		value = theValue != 0;
1:eac0369: 		isnull = false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void setValue(double theValue)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 		value = theValue != 0;
1:eac0369: 		isnull = false;
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:9548d38: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:d7f7457: 		if (bigDecimal == null)
1:eac0369: 		{
1:eac0369: 			value = false;
1:eac0369: 			isnull = true;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:5465561:             value = BigDecimal.ZERO.compareTo(bigDecimal) != 0;
1:eac0369: 			isnull = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the value of this BooleanDataValue to the given String.
1:eac0369: 	 * String is trimmed and upcased.  If resultant string is not
1:eac0369: 	 * TRUE or FALSE, then an error is thrown.
1:eac0369: 	 *
8:eac0369: 	 * @param theValue	The value to set this BooleanDataValue to
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(String theValue)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT( ! immutable,
1:eac0369: 						"Attempt to set the value of an immutable SQLBoolean");
1:eac0369: 		if (theValue == null)
1:eac0369: 		{
1:eac0369: 			value = false;
1:eac0369: 			isnull = true;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			** Note: cannot use getBoolean(String) here because
1:eac0369: 			** it doesn't trim, and doesn't throw exceptions.
1:eac0369: 			*/
1:eac0369: 			String cleanedValue = StringUtil.SQLToUpperCase(theValue.trim());
1:eac0369: 			if (cleanedValue.equals("TRUE"))
1:eac0369: 			{
2:eac0369: 				value = true;
1:31342ae:                 isnull = false;
1:eac0369: 			}
1:eac0369: 			else if (cleanedValue.equals("FALSE"))
1:eac0369: 			{
1:eac0369: 				value = false;
1:31342ae:                 isnull = false;
1:31342ae: 			}
1:31342ae: 			else if (cleanedValue.equals("UNKNOWN"))
1:31342ae: 			{
1:31342ae: 				value = false;
1:31342ae:                 isnull = true;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{ 
1:eac0369: 				throw invalidFormat();
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#setValue
1:eac0369: 	 */	
1:806114c: 	void setObject(Object theValue)
1:eac0369: 	{
1:806114c: 		setValue((Boolean) theValue);
1:eac0369: 	}
1:eac0369: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1:eac0369: 
1:1b3f93b:         if ( theValue instanceof SQLChar ) { setValue( theValue.getString() ); }
1:1b3f93b: 		else if ( theValue instanceof SQLBoolean ){ setValue(theValue.getBoolean()); }
1:1b3f93b:         else
1:1b3f93b:         {
1:1b3f93b:             throw StandardException.newException
1:1b3f93b:                 ( SQLState.LANG_DATA_TYPE_SET_MISMATCH, theValue.getTypeName(), getTypeName() );
1:1b3f93b: 
1:1b3f93b:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** SQL Operators
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The = operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:eac0369: 	 * @param left			The value on the left side of the =
1:eac0369: 	 * @param right			The value on the right side of the =
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the two parameters are equal
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue equals(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		return truthValue(left,
1:eac0369: 							right,
1:eac0369: 							left.getBoolean() == right.getBoolean());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &lt;&gt; operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the two parameters are
1:eac0369: 	 *			not equal
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue notEquals(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		return truthValue(left,
1:eac0369: 							right,
1:eac0369: 							left.getBoolean() != right.getBoolean());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &lt; operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the left operand is
1:eac0369: 	 *			less than the right operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue lessThan(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We must call getBoolean() on both sides in order
1:eac0369: 		 * to catch any invalid casts.
1:eac0369: 		 */
1:eac0369: 		boolean leftBoolean = left.getBoolean();
1:eac0369: 		boolean rightBoolean = right.getBoolean();
1:eac0369: 		/* By convention, false is less than true */
1:eac0369: 		return truthValue(left,
1:eac0369: 							right,
1:eac0369: 							leftBoolean == false && rightBoolean == true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &gt; operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the left operand is
1:eac0369: 	 *			greater than the right operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue greaterThan(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We must call getBoolean() on both sides in order
1:eac0369: 		 * to catch any invalid casts.
1:eac0369: 		 */
1:eac0369: 		boolean leftBoolean = left.getBoolean();
1:eac0369: 		boolean rightBoolean = right.getBoolean();
1:eac0369: 		/* By convention, true is greater than false */
1:eac0369: 		return truthValue(left,
1:eac0369: 							right,
1:eac0369: 							leftBoolean == true && rightBoolean == false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &lt;= operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the left operand is
1:eac0369: 	 *			less than or equal to the right operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue lessOrEquals(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We must call getBoolean() on both sides in order
1:eac0369: 		 * to catch any invalid casts.
1:eac0369: 		 */
1:eac0369: 		boolean leftBoolean = left.getBoolean();
1:eac0369: 		boolean rightBoolean = right.getBoolean();
1:eac0369: 		/* By convention, false is less than true */
1:eac0369: 		return truthValue(left,
1:eac0369: 							right,
1:eac0369: 							leftBoolean == false || rightBoolean == true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dbed020: 	 * The &gt;= operator as called from the language module, as opposed to
1:eac0369: 	 * the storage module.
1:eac0369: 	 *
1:dbed020: 	 * @param left			The value on the left side of the operator
1:dbed020: 	 * @param right			The value on the right side of the operator
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQL boolean value telling whether the left operand is
1:eac0369: 	 *			greater than or equal to the right operand
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue greaterOrEquals(DataValueDescriptor left,
1:eac0369: 							 DataValueDescriptor right)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		/* We must call getBoolean() on both sides in order
1:eac0369: 		 * to catch any invalid casts.
1:eac0369: 		 */
1:eac0369: 		boolean leftBoolean = left.getBoolean();
1:eac0369: 		boolean rightBoolean = right.getBoolean();
1:eac0369: 		/* By convention, true is greater than false */
1:eac0369: 		return truthValue(left,
1:eac0369: 							right,
1:eac0369: 							leftBoolean == true || rightBoolean == false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The AND operator.  This implements SQL semantics for AND with unknown
1:eac0369: 	 * truth values - consult any standard SQL reference for an explanation.
1:eac0369: 	 *
1:eac0369: 	 * @param otherValue	The other boolean to AND with this one
1:eac0369: 	 *
1:eac0369: 	 * @return	this AND otherValue
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue and(BooleanDataValue otherValue)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Catch those cases where standard SQL null semantics don't work.
1:eac0369: 		*/
1:eac0369: 		if (this.equals(false) || otherValue.equals(false))
1:eac0369: 		{
2:eac0369: 			return BOOLEAN_FALSE;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return truthValue(this,
1:eac0369: 							otherValue,
1:eac0369: 							this.getBoolean() && otherValue.getBoolean());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The OR operator.  This implements SQL semantics for OR with unknown
1:eac0369: 	 * truth values - consult any standard SQL reference for an explanation.
1:eac0369: 	 *
1:eac0369: 	 * @param otherValue	The other boolean to OR with this one
1:eac0369: 	 *
1:eac0369: 	 * @return	this OR otherValue
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public BooleanDataValue or(BooleanDataValue otherValue)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Catch those cases where standard SQL null semantics don't work.
1:eac0369: 		*/
1:eac0369: 		if (this.equals(true) || otherValue.equals(true))
1:eac0369: 		{
2:eac0369: 			return BOOLEAN_TRUE;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return truthValue(this,
1:eac0369: 							otherValue,
1:eac0369: 							this.getBoolean() || otherValue.getBoolean());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * The SQL IS operator - consult any standard SQL reference for an explanation.
1:eac0369: 	 *
1:eac0369: 	 *	Implements the following truth table:
1:eac0369: 	 *
1:eac0369: 	 *	         otherValue
1:eac0369: 	 *	        | TRUE    | FALSE   | UNKNOWN
1:eac0369: 	 *	this    |----------------------------
1:eac0369: 	 *	        |
1:eac0369: 	 *	TRUE    | TRUE    | FALSE   | FALSE
1:eac0369: 	 *	FALSE   | FALSE   | TRUE    | FALSE
1:eac0369: 	 *	UNKNOWN | FALSE   | FALSE   | TRUE
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param otherValue	BooleanDataValue to compare to. May be TRUE, FALSE, or UNKNOWN.
1:eac0369: 	 *
1:eac0369: 	 * @return	whether this IS otherValue
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue is(BooleanDataValue otherValue)
1:eac0369: 	{
1:eac0369: 		if ( this.equals(true) && otherValue.equals(true) )
1:eac0369: 		{ return BOOLEAN_TRUE; }
1:eac0369: 
1:eac0369: 		if ( this.equals(false) && otherValue.equals(false) )
1:eac0369: 		{ return BOOLEAN_TRUE; }
1:eac0369: 
1:eac0369: 		if ( this.isNull() && otherValue.isNull() )
1:eac0369: 		{ return BOOLEAN_TRUE; }
1:eac0369: 
1:eac0369: 		return BOOLEAN_FALSE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Implements NOT IS. This reverses the sense of the is() call.
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @param otherValue	BooleanDataValue to compare to. May be TRUE, FALSE, or UNKNOWN.
1:eac0369: 	 *
1:eac0369: 	 * @return	NOT( this IS otherValue )
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue isNot(BooleanDataValue otherValue)
1:eac0369: 	{
1:eac0369: 		BooleanDataValue	isValue = is( otherValue );
1:eac0369: 
1:eac0369: 		if ( isValue.equals(true) ) { return BOOLEAN_FALSE; }
1:eac0369: 		else { return BOOLEAN_TRUE; }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Throw an exception with the given SQLState if this BooleanDataValue
1:eac0369: 	 * is false. This method is useful for evaluating constraints.
1:eac0369: 	 *
1:6b50965: 	 * @param sqlState		The SQLState of the exception to throw if
1:eac0369: 	 *						this SQLBoolean is false.
1:eac0369: 	 * @param tableName		The name of the table to include in the exception
1:eac0369: 	 *						message.
1:eac0369: 	 * @param constraintName	The name of the failed constraint to include
1:eac0369: 	 *							in the exception message.
1:eac0369: 	 *
1:eac0369: 	 * @return	this
1:eac0369: 	 *
1:eac0369: 	 * @exception	StandardException	Thrown if this BooleanDataValue
1:eac0369: 	 *									is false.
1:eac0369: 	 */
1:eac0369: 	public BooleanDataValue throwExceptionIfFalse(
1:eac0369: 									String sqlState,
1:eac0369: 									String tableName,
1:eac0369: 									String constraintName)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		if ( ( ! isNull() ) && (value == false) )
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(sqlState,
1:eac0369: 												tableName,
1:eac0369: 												constraintName);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:af1c18c:     public BooleanDataValue throwExceptionIfImmediateAndFalse(
1:af1c18c:                                     String sqlState,
1:af1c18c:                                     String tableName,
1:af1c18c:                                     String constraintName,
1:af1c18c:                                     Activation a,
1:af1c18c:                                     int savedUUIDIdx)
1:af1c18c:                             throws StandardException
1:af1c18c:     {
1:af1c18c:         if ( !isNull() && (value == false) ) {
1:af1c18c:             final ExecPreparedStatement ps = a.getPreparedStatement();
1:af1c18c:             final UUID constrId = (UUID)ps.getSavedObject(savedUUIDIdx);
1:af1c18c:             final LanguageConnectionContext lcc =
1:af1c18c:                 a.getLanguageConnectionContext();
1:4cc0287:             final boolean isDeferred = lcc.isEffectivelyDeferred(
1:4cc0287:                    lcc.getCurrentSQLSessionContext(a), constrId);
1:af1c18c: 
1:af1c18c:             if (!isDeferred) {
1:af1c18c:                 throw StandardException.newException(
1:af1c18c:                         sqlState, tableName, constraintName);
1:af1c18c:             } else {
1:af1c18c:                 // Just return the false value and validate later,
1:af1c18c:                 // cf NoRowsResultSetImpl#evaluateCheckConstraints.
1:af1c18c:                 // and InsertResultSet#evaluateCheckConstraints
1:af1c18c:                 DMLWriteResultSet rs =  (DMLWriteResultSet)a.getResultSet();
1:af1c18c:                 rs.rememberConstraint(constrId);
1:af1c18c:             }
1:af1c18c:         }
1:af1c18c: 
1:af1c18c:         return this;
1:af1c18c:     }
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/** @see DataValueDescriptor#typePrecedence */
1:eac0369: 	public int typePrecedence()
1:eac0369: 	{
1:eac0369: 		return TypeId.BOOLEAN_PRECEDENCE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Support functions
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the SQL truth value for a comparison.
1:eac0369: 	 *
1:eac0369: 	 * This method first looks at the operands - if either is null, it
1:eac0369: 	 * returns the unknown truth value.  This implements "normal" SQL
1:eac0369: 	 * null semantics, where if any operand is null, the result is null.
1:eac0369: 	 * Note that there are cases where these semantics are incorrect -
1:eac0369: 	 * for example, NULL AND FALSE is supposed to be FALSE, not NULL
1:eac0369: 	 * (the NULL truth value is the same as the UNKNOWN truth value).
1:eac0369: 	 *
1:eac0369: 	 * If neither operand is null, it returns a static final variable
1:eac0369: 	 * containing the SQLBoolean truth value.  It returns different values
1:eac0369: 	 * depending on whether the truth value is supposed to be nullable.
1:eac0369: 	 *
1:eac0369: 	 * This method always returns a pre-allocated static final SQLBoolean.
1:eac0369: 	 * This is practical because there are so few possible return values.
1:eac0369: 	 * Using pre-allocated values allows us to avoid constructing new
1:eac0369: 	 * SQLBoolean values during execution.
1:eac0369: 	 *
1:eac0369: 	 * @param leftOperand	The left operand of the binary comparison
1:eac0369: 	 * @param rightOperand	The right operand of the binary comparison
1:eac0369: 	 * @param truth			The truth value of the comparison
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQLBoolean containing the desired truth value.
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public static SQLBoolean truthValue(
1:eac0369: 								DataValueDescriptor leftOperand,
1:eac0369: 								DataValueDescriptor rightOperand,
1:eac0369: 								boolean truth)
1:eac0369: 	{
1:eac0369: 		/* Return UNKNOWN if either operand is null */
1:eac0369: 		if (leftOperand.isNull() || rightOperand.isNull())
1:eac0369: 		{
1:eac0369: 			return unknownTruthValue();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Return the appropriate SQLBoolean for the given truth value */
1:eac0369: 		if (truth == true)
1:eac0369: 		{
1:eac0369: 			return BOOLEAN_TRUE;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return BOOLEAN_FALSE;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * same as above, but takes a Boolean, if it is null, unknownTruthValue is returned
1:eac0369:      */
1:eac0369: 	public static SQLBoolean truthValue(
1:eac0369: 								DataValueDescriptor leftOperand,
1:eac0369: 								DataValueDescriptor rightOperand,
1:eac0369: 								Boolean truth)
1:eac0369: 	{
1:eac0369: 		/* Return UNKNOWN if either operand is null */
1:eac0369: 		if (leftOperand.isNull() || rightOperand.isNull() || truth==null)
1:eac0369: 		{
1:eac0369: 			return unknownTruthValue();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Return the appropriate SQLBoolean for the given truth value */
1:eac0369: 		if (truth == Boolean.TRUE)
1:eac0369: 		{
1:eac0369: 			return BOOLEAN_TRUE;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return BOOLEAN_FALSE;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get a truth value.
1:eac0369: 	 *
1:eac0369: 	 * @param value	The value of the SQLBoolean
1:eac0369: 	 *
1:eac0369:  	 * @return	A SQLBoolean with the given truth value
1:eac0369: 	 */
1:eac0369: 	public static SQLBoolean truthValue(boolean value)
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** Return the non-nullable versions of TRUE and FALSE, since they
1:eac0369: 		** can never be null.
1:eac0369: 		*/
1:eac0369: 		if (value == true)
1:eac0369: 			return BOOLEAN_TRUE;
1:eac0369: 		else
1:eac0369: 			return BOOLEAN_FALSE;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return an unknown truth value.  Check to be sure the return value is
1:eac0369: 	 * nullable.
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQLBoolean representing the UNKNOWN truth value
1:eac0369: 	 */
1:eac0369: 	public static SQLBoolean unknownTruthValue()
1:eac0369: 	{
1:eac0369: 		return UNKNOWN;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Determine whether this SQLBoolean contains the given boolean value.
1:eac0369: 	 *
1:eac0369: 	 * This method is used by generated code to determine when to do
1:eac0369: 	 * short-circuiting for an AND or OR.
1:eac0369: 	 *
1:eac0369: 	 * @param val	The value to look for
1:eac0369: 	 *
1:eac0369: 	 * @return	true if the given value equals the value in this SQLBoolean,
1:eac0369: 	 *			false if not
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public boolean equals(boolean val)
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 			return false;
1:eac0369: 		else
1:eac0369: 			return value == val;
1:eac0369: 	}
1:4549ad4: 	
1:4549ad4: 	/**
1:4549ad4: 	 * Return an immutable BooleanDataValue with the same value as this.
1:4549ad4: 	 * @return An immutable BooleanDataValue with the same value as this.
1:4549ad4: 	 */
1:4549ad4: 	public BooleanDataValue getImmutable()
1:4549ad4: 	{
1:4549ad4: 		if (isNull())
1:4549ad4: 			return SQLBoolean.UNKNOWN;
1:4549ad4: 		
1:4549ad4: 		return value ? SQLBoolean.BOOLEAN_TRUE : SQLBoolean.BOOLEAN_FALSE;
1:4549ad4: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * String display of value
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 			return "NULL";
1:eac0369: 		else if (value == true)
1:eac0369: 			return "true";
1:eac0369: 		else
1:eac0369: 			return "false";
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Hash code
1:eac0369: 	 */
1:eac0369: 	public int hashCode()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 		{
1:eac0369: 			return -1;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return (value) ? 1 : 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * useful constants...
1:eac0369: 	 */
1:eac0369: 	static final int BOOLEAN_LENGTH		= 1;	// must match the number of bytes written by DataOutput.writeBoolean()
1:eac0369: 
1:eac0369: 	private static final SQLBoolean BOOLEAN_TRUE = new SQLBoolean(true);
1:eac0369: 	private static final SQLBoolean BOOLEAN_FALSE = new SQLBoolean(false);
1:eac0369: 	static final SQLBoolean UNKNOWN = new SQLBoolean();
1:eac0369: 
1:eac0369: 	/* Static initialization block */
1:eac0369: 	static
1:eac0369: 	{
1:eac0369: 		/* Mark all the static SQLBooleans as immutable */
1:eac0369: 		BOOLEAN_TRUE.immutable = true;
1:eac0369: 		BOOLEAN_FALSE.immutable = true;
1:eac0369: 		UNKNOWN.immutable = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLBoolean.class);
1:eac0369: 
1:eac0369:     public int estimateMemoryUsage()
1:eac0369:     {
1:eac0369:         return BASE_MEMORY_USAGE;
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * object state
1:eac0369: 	 */
1:4549ad4: 	private boolean value;
1:4549ad4: 	private boolean isnull;
1:4549ad4: 	private boolean immutable;
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * The &lt;&gt; operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
/////////////////////////////////////////////////////////////////////////
1: 	 * The &lt; operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
/////////////////////////////////////////////////////////////////////////
1: 	 * The &gt; operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
/////////////////////////////////////////////////////////////////////////
1: 	 * The &lt;= operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
/////////////////////////////////////////////////////////////////////////
1: 	 * The &gt;= operator as called from the language module, as opposed to
1: 	 * @param left			The value on the left side of the operator
1: 	 * @param right			The value on the right side of the operator
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 			return value;
commit:31f120e
/////////////////////////////////////////////////////////////////////////
1: 		 *	F		T			X		X			-1 	(this > other)
1: 		 *	T		F			X		X			1	(this < other)
/////////////////////////////////////////////////////////////////////////
1: 			if (!otherNull)		// thisNull must be true
1: 				return 1;
commit:31342ae
/////////////////////////////////////////////////////////////////////////
1:                 isnull = false;
1:                 isnull = false;
1: 			}
1: 			else if (cleanedValue.equals("UNKNOWN"))
1: 			{
1: 				value = false;
1:                 isnull = true;
commit:1b3f93b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:         if ( theValue instanceof SQLChar ) { setValue( theValue.getString() ); }
1: 		else if ( theValue instanceof SQLBoolean ){ setValue(theValue.getBoolean()); }
1:         else
1:         {
1:             throw StandardException.newException
1:                 ( SQLState.LANG_DATA_TYPE_SET_MISMATCH, theValue.getTypeName(), getTypeName() );
1: 
1:         }
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:4cc0287
/////////////////////////////////////////////////////////////////////////
1:             final boolean isDeferred = lcc.isEffectivelyDeferred(
1:                    lcc.getCurrentSQLSessionContext(a), constrId);
commit:af1c18c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.sql.Activation;
1: import org.apache.derby.iapi.sql.Row;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.execute.ExecPreparedStatement;
1: import org.apache.derby.impl.sql.execute.DMLWriteResultSet;
/////////////////////////////////////////////////////////////////////////
1:     public BooleanDataValue throwExceptionIfImmediateAndFalse(
1:                                     String sqlState,
1:                                     String tableName,
1:                                     String constraintName,
1:                                     Activation a,
1:                                     int savedUUIDIdx)
1:                             throws StandardException
1:     {
1:         if ( !isNull() && (value == false) ) {
1:             final ExecPreparedStatement ps = a.getPreparedStatement();
1:             final UUID constrId = (UUID)ps.getSavedObject(savedUUIDIdx);
1:             final LanguageConnectionContext lcc =
1:                 a.getLanguageConnectionContext();
0:             final boolean isDeferred = lcc.isEffectivelyDeferred(a, constrId);
1: 
1:             if (!isDeferred) {
1:                 throw StandardException.newException(
1:                         sqlState, tableName, constraintName);
1:             } else {
1:                 // Just return the false value and validate later,
1:                 // cf NoRowsResultSetImpl#evaluateCheckConstraints.
1:                 // and InsertResultSet#evaluateCheckConstraints
1:                 DMLWriteResultSet rs =  (DMLWriteResultSet)a.getResultSet();
1:                 rs.rememberConstraint(constrId);
1:             }
1:         }
1: 
1:         return this;
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:5465561
/////////////////////////////////////////////////////////////////////////
1:             value = BigDecimal.ZERO.compareTo(bigDecimal) != 0;
commit:9548d38
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigDecimal;
/////////////////////////////////////////////////////////////////////////
1: 	public void setBigDecimal(BigDecimal bigDecimal) throws StandardException
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:82bf2d5
/////////////////////////////////////////////////////////////////////////
commit:8e6e96f
/////////////////////////////////////////////////////////////////////////
commit:109cb26
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Recycle this SQLBoolean object if possible. If the object is immutable,
1:      * create and return a new object.
1:      *
1:      * @return a new SQLBoolean if this object is immutable; otherwise, this
1:      * object with value set to null
1:      */
1:     public DataValueDescriptor recycle() {
1:         if (immutable) {
1:             return new SQLBoolean();
1:         }
1:         return super.recycle();
1:     }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4cded85
/////////////////////////////////////////////////////////////////////////
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1: 	/** @see DataValueDescriptor#cloneValue */
1: 	public DataValueDescriptor cloneValue(boolean forceMaterialization)
/////////////////////////////////////////////////////////////////////////
1:     /* This constructor gets used for the cloneValue method */
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param sqlState		The SQLState of the exception to throw if
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 	void setObject(Object theValue)
1: 		setValue((Boolean) theValue);
commit:4549ad4
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Return an immutable BooleanDataValue with the same value as this.
1: 	 * @return An immutable BooleanDataValue with the same value as this.
1: 	 */
1: 	public BooleanDataValue getImmutable()
1: 	{
1: 		if (isNull())
1: 			return SQLBoolean.UNKNOWN;
1: 		
1: 		return value ? SQLBoolean.BOOLEAN_TRUE : SQLBoolean.BOOLEAN_FALSE;
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 	private boolean value;
1: 	private boolean isnull;
1: 	private boolean immutable;
commit:a1970a9
/////////////////////////////////////////////////////////////////////////
0: 	public void setBigDecimal(Number bigDecimal) throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 			DataValueDescriptor tempDecimal = NumberDataType.ZERO_DECIMAL.getNewNull();
0: 			tempDecimal.setBigDecimal(bigDecimal);
0: 			value = NumberDataType.ZERO_DECIMAL.compare(tempDecimal) != 0;
commit:2a58829
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:2c6f0a2
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Implementation for BOOLEAN type. Convert to a BigDecimal using long
1: 	 */
1: 	public int typeToBigDecimal()
1: 	{
1: 		return java.sql.Types.BIGINT;
1: 	}
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
0: 	public void setBigDecimal(Number bigDecimal)
1: 		if (bigDecimal == null)
0: 			value = org.apache.derby.iapi.types.SQLDecimal.ZERO.compareTo(bigDecimal) != 0;
/////////////////////////////////////////////////////////////////////////
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.SQLBoolean
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.Storable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.types.Orderable;
1: 
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
0: import java.math.BigDecimal;
1: 
1: import java.sql.ResultSet;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: 
1: /**
1:  * SQLBoolean satisfies the DataValueDescriptor
1:  * interfaces (i.e., DataType). It implements a boolean column, 
1:  * e.g. for * storing a column value; it can be specified
1:  * when constructed to not allow nulls. Nullability cannot be changed
1:  * after construction, as it affects the storage size and mechanism.
1:  * <p>
1:  * Because DataType is a subtype of DataType,
1:  * SQLBoolean can play a role in either a DataType/Row
1:  * or a DataType/Row, interchangeably.
1:  * <p>
1:  * We assume the store has a flag for nullness of the value,
1:  * and simply return a 0-length array for the stored form
1:  * when the value is null.
1:  * <p>
1:  * PERFORMANCE: There are likely alot of performance improvements
1:  * possible for this implementation -- it new's Integer
1:  * more than it probably wants to.
1:  */
1: public final class SQLBoolean
1: 	extends DataType implements BooleanDataValue
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 * (mostly implemented in DataType)
1: 	 */
1: 
1: 	/*
1: 	 * see if the integer value is null.
1: 	 */
1: 	public boolean isNull()
1: 	{
1: 		return isnull;
1: 	}
1: 
1: 	public boolean	getBoolean()
1: 	{
1: 		return value;
1: 	}
1: 
1: 	private static int makeInt(boolean b)
1: 	{
1: 		return (b?1:0);
1: 	}
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#getByte 
1: 	 */
1: 	public byte	getByte() 
1: 	{
1: 		return (byte) makeInt(value);
1: 	}
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#getShort 
1: 	 */
1: 	public short	getShort()
1: 	{
1: 		return (short) makeInt(value);
1: 	}
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#getInt 
1: 	 */
1: 	public int	getInt()
1: 	{
1: 		return makeInt(value);
1: 	}
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#getLong 
1: 	 */
1: 	public long	getLong()
1: 	{
1: 		return (long) makeInt(value);
1: 	}
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#getFloat 
1: 	 */
1: 	public float	getFloat()
1: 	{
1: 		return (float) makeInt(value);
1: 	}
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#getDouble 
1: 	 */
1: 	public double	getDouble()
1: 	{
1: 		return (double) makeInt(value);
1: 	}
1: 
1: 	/** 
0: 	 * @see DataValueDescriptor#getBigDecimal 
1: 	 */
0: 	public BigDecimal	getBigDecimal()
1: 	{
0: 		if (isNull()) return null;
0: 		return BigDecimal.valueOf(makeInt(value));
1: 	}
1: 
1: 	public String	getString()
1: 	{
1: 		if (isNull())
1: 			return null;
1: 		else if (value == true)
1: 			return "true";
1: 		else
1: 			return "false";
1: 	}
1: 
1: 	public Object	getObject()
1: 	{
1: 		if (isNull())
1: 			return null;
1: 		else
0: 			return new Boolean(value);
1: 	}
1: 
1: 	public int	getLength()
1: 	{
1: 		return BOOLEAN_LENGTH;
1: 	}
1: 
1: 	// this is for DataType's error generator
1: 	public String getTypeName()
1: 	{
1: 		return TypeId.BOOLEAN_NAME;
1: 	}
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() {
1: 		return StoredFormatIds.SQL_BOOLEAN_ID;
1: 	}
1: 
1: 	public void writeExternal(ObjectOutput out) throws IOException {
1: 
1: 		// never called when value is null
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(! isNull());
1: 
1: 		out.writeBoolean(value);
1: 	}
1: 
1: 	/** @see java.io.Externalizable#readExternal */
1: 	public void readExternal(ObjectInput in) throws IOException {
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 
1: 		value = in.readBoolean();
1: 		isnull = false;
1: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException {
1: 
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 
1: 		value = in.readBoolean();
1: 		isnull = false;
1: 	}
1: 
1: 	/**
1: 	 * @see Storable#restoreToNull
1: 	 *
1: 	 */
1: 	public void restoreToNull()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 
1: 		value = false;
1: 		isnull = true;
1: 	}
1: 
1: 	/*
1: 	 * Orderable interface
1: 	 */
1: 
1: 	/**
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public int compare(DataValueDescriptor other) throws StandardException
1: 	{
1: 		/* Use compare method from dominant type, negating result
1: 		 * to reflect flipping of sides.
1: 		 */
1: 		if (typePrecedence() < other.typePrecedence())
1: 		{
1: 			return - (other.compare(this));
1: 		}
1: 
1: 		boolean thisNull, otherNull;
1: 		thisNull = this.isNull();
1: 		otherNull = other.isNull();
1: 
1: 		/*
1: 		 * thisNull otherNull thisValue thatValue return
1: 		 *	T		T			X		X			0	(this == other)
0: 		 *	F		T			X		X			1 	(this > other)
0: 		 *	T		F			X		X			-1	(this < other)
1: 		 *
1: 		 *	F		F			T		T			0	(this == other)
1: 		 *	F		F			T		F			1	(this > other)
1: 		 *	F		F			F		T			-1	(this < other)
1: 		 *	F		F			F		F			0	(this == other)
1: 		 */
1: 		if (thisNull || otherNull)
1: 		{
1: 			if (!thisNull)		// otherNull must be true
1: 				return 1;
0: 			if (!otherNull)		// thisNull must be true
1: 				return -1;
1: 			return 0;
1: 		}
1: 
1: 		/* neither are null, get the value */
1: 		boolean thisValue;
1: 		boolean otherValue = false;
1: 		thisValue = this.getBoolean();
1: 
1: 		otherValue = other.getBoolean();
1: 
1: 		if (thisValue == otherValue)
1: 			return 0;
1: 		else if (thisValue && !otherValue)
1: 			return 1;
1: 		else
1: 			return -1;
1: 	}
1: 
1: 	/**
1: 		@exception StandardException thrown on error
1: 	 */
1: 	public boolean compare(int op,
1: 						   DataValueDescriptor other,
1: 						   boolean orderedNulls,
1: 						   boolean unknownRV)
1: 		throws StandardException
1: 	{
1: 		if (!orderedNulls)		// nulls are unordered
1: 		{
1: 			if (this.isNull() || other.isNull())
1: 				return unknownRV;
1: 		}
1: 		/* Do the comparison */
1: 		return super.compare(op, other, orderedNulls, unknownRV);
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
1: 	{
1: 		return new SQLBoolean(value, isnull);
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#getNewNull
1: 	 */
1: 	public DataValueDescriptor getNewNull()
1: 	{
1: 		return new SQLBoolean();
1: 	}
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#setValueFromResultSet 
1: 	 *
1: 	 * @exception SQLException		Thrown on error
1: 	 */
1: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1: 									  boolean isNullable)
1: 		throws SQLException
1: 	{
1: 			value = resultSet.getBoolean(colNumber);
1: 			isnull = (isNullable && resultSet.wasNull());
1: 	}
1: 	/**
1: 		Set the value into a PreparedStatement.
1: 
1: 		@exception SQLException Error setting value in PreparedStatement
1: 	*/
1: 	public final void setInto(PreparedStatement ps, int position) throws SQLException {
1: 
1: 		if (isNull()) {
1: 			ps.setNull(position, java.sql.Types.BIT);
1: 			return;
1: 		}
1: 
1: 		ps.setBoolean(position, value);
1: 	}
1: 	/*
1: 	 * class interface
1: 	 */
1: 
1: 	/*
1: 	 * constructors
1: 	 */
1: 
1: 	/* NOTE - other data types have both (type value) and (boolean nulls), 
1: 	 * (value, nulls)
1: 	 * We can't do both (boolean value) and (boolean nulls) here,
1: 	 * so we'll skip over (boolean value) and have (Boolean value) so
1: 	 * that we can support (boolean nulls).
1: 	 */
1: 
1: 	public SQLBoolean()
1: 	{
1: 		isnull = true;
1: 	}
1: 
1: 	public SQLBoolean(boolean val)
1: 	{
1: 		value = val;
1: 	}
1: 	public SQLBoolean(Boolean obj) {
1: 		if (isnull = (obj == null))
1: 			;
1: 		else
1: 			value = obj.booleanValue();
1: 	}
1: 
0: 	/* This constructor gets used for the getClone() method */
1: 	private SQLBoolean(boolean val, boolean isnull)
1: 	{
1: 		value = val;
1: 		this.isnull = isnull;
1: 	}
1: 
1: 	/** @see BooleanDataValue#setValue */
1: 	public void setValue(boolean theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		value = theValue;
1: 		isnull = false;
1: 
1: 	}
1: 
1: 	public void setValue(Boolean theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		if (theValue == null)
1: 		{
1: 			value = false;
1: 			isnull = true;
1: 		}
1: 		else
1: 		{
1: 			value = theValue.booleanValue();
1: 			isnull = false;
1: 		}
1: 
1: 	}
1: 
1: 	// REMIND: do we need this, or is long enough?
1: 	public void setValue(byte theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		value = theValue != 0;
1: 		isnull = false;
1: 
1: 	}
1: 
1: 
1: 	// REMIND: do we need this, or is long enough?
1: 	public void setValue(short theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		value = theValue != 0;
1: 		isnull = false;
1: 
1: 	}
1: 
1: 
1: 	// REMIND: do we need this, or is long enough?
1: 	public void setValue(int theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		value = theValue != 0;
1: 		isnull = false;
1: 
1: 	}
1: 
1: 	public void setValue(long theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		value = theValue != 0;
1: 		isnull = false;
1: 
1: 	}
1: 
1: 	// REMIND: do we need this, or is double enough?
1: 	public void setValue(float theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		value = theValue != 0;
1: 		isnull = false;
1: 
1: 	}
1: 
1: 	public void setValue(double theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		value = theValue != 0;
1: 		isnull = false;
1: 
1: 	}
1: 
0: 	public void setValue(BigDecimal theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		if (theValue == null)
1: 		{
1: 			value = false;
1: 			isnull = true;
1: 		}
1: 		else
1: 		{
0: 			value = theValue.compareTo(org.apache.derby.iapi.types.SQLDecimal.ZERO) != 0;
1: 			isnull = false;
1: 		}
1: 
1: 	}
1: 
1: 	/**
0: 	 * Set the value of this BooleanDataValue to the given byte array value
1: 	 *
1: 	 * @param theValue	The value to set this BooleanDataValue to
1: 	 *
0: 	 * @return	This BooleanDataValue
1: 	 */
0: 	public void setValue(byte[] theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 
0: 		if (theValue != null)
1: 		{
1: 			isnull = false;
0: 			int length = theValue.length;
1: 	
1: 			/*
0: 			** Step through all bytes.  As soon
0: 			** as we get one with something other
0: 			** than 0, then we know we have a 'true'
1: 			*/
0: 			for (int i = 0; i < length; i++)
1: 			{
0: 				if (theValue[i] != 0)
1: 				{
1: 					value = true;
1: 					return;
1: 				}
1: 			}
1: 		}
1: 		else
1: 		{
1: 			isnull = true;
1: 		}
1: 		value = false;
1: 
1: 	}
1: 
1: 
1: 	/**
1: 	 * Set the value of this BooleanDataValue to the given String.
1: 	 * String is trimmed and upcased.  If resultant string is not
1: 	 * TRUE or FALSE, then an error is thrown.
1: 	 *
1: 	 * @param theValue	The value to set this BooleanDataValue to
1: 	 *
0: 	 * @return	This BooleanDataValue
1: 	 *
1: 	 * @exception StandardException Thrown on error
1: 	 */
1: 	public void setValue(String theValue)
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 		if (theValue == null)
1: 		{
1: 			value = false;
1: 			isnull = true;
1: 		}
1: 		else
1: 		{
1: 			/*
1: 			** Note: cannot use getBoolean(String) here because
1: 			** it doesn't trim, and doesn't throw exceptions.
1: 			*/
1: 			String cleanedValue = StringUtil.SQLToUpperCase(theValue.trim());
1: 			if (cleanedValue.equals("TRUE"))
1: 			{
1: 				value = true;
1: 			}
1: 			else if (cleanedValue.equals("FALSE"))
1: 			{
1: 				value = false;
1: 			}
1: 			else
1: 			{ 
1: 				throw invalidFormat();
1: 			}
1: 			isnull = false;
1: 		}
1: 
1: 	}
1: 
1: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Byte value
1: 	 *
1: 	 * @param theValue	The value to set this BooleanDataValue to
1: 	 *
0: 	 * @return	This BooleanDataValue
1: 	 */
0: 	public void setValue(Byte theValue)
1: 	{
0: 		setValueCore(theValue);
1: 	}
1: 
1: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Short value
1: 	 *
1: 	 * @param theValue	The value to set this BooleanDataValue to
1: 	 *
0: 	 * @return	This BooleanDataValue
1: 	 */
0: 	public void setValue(Short theValue)
1: 	{
0: 		setValueCore(theValue);
1: 	}
1: 	
1: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Long value
1: 	 *
1: 	 * @param theValue	The value to set this BooleanDataValue to
1: 	 *
0: 	 * @return	This BooleanDataValue
1: 	 */
0: 	public void setValue(Long theValue)
1: 	{
0: 		setValueCore(theValue);
1: 	}
1: 
1: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Integer value
1: 	 *
1: 	 * @param theValue	The value to set this BooleanDataValue to
1: 	 *
0: 	 * @return	This BooleanDataValue
1: 	 */
0: 	public void setValue(Integer theValue)
1: 	{
0: 		setValueCore(theValue);
1: 	}
1: 
1: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Double value
1: 	 *
1: 	 * @param theValue	The value to set this BooleanDataValue to
1: 	 *
0: 	 * @return	This BooleanDataValue
1: 	 */
0: 	public void setValue(Double theValue)
1: 	{
0: 		setValueCore(theValue);
1: 	}
1: 
1: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Double value
1: 	 *
1: 	 * @param theValue	The value to set this BooleanDataValue to
1: 	 *
0: 	 * @return	This BooleanDataValue
1: 	 */
0: 	public void setValue(Float theValue)
1: 	{
0: 		setValueCore(theValue);
1: 	}
1: 
0: 	private void setValueCore(Number theValue)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT( ! immutable,
1: 						"Attempt to set the value of an immutable SQLBoolean");
1: 
1: 		if (theValue == null)
1: 		{
1: 			isnull = true;
1: 			value = false;
1: 		}
1: 		else
1: 		{
0: 			value = (theValue.intValue() != 0);
1: 			isnull = false;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#setValue
1: 	 */	
0: 	public void setValue(Object theValue)
1: 		throws StandardException
1: 	{
0: 		if ((theValue instanceof Boolean) ||
0: 			(theValue == null))
1: 		{
0: 			this.setValue((Boolean)theValue);
1: 		}
0: 		else if (theValue instanceof Number) {
0: 			setValueCore((Number) theValue);
1: 		}
1: 		else
1: 		{
0: 			genericSetObject(theValue);
1: 		}
1: 	}
1: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1: 
0: 		setValue(theValue.getBoolean());
1: 	}
1: 
1: 
1: 	/*
1: 	** SQL Operators
1: 	*/
1: 
1: 	/**
1: 	 * The = operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
1: 	 * @param left			The value on the left side of the =
1: 	 * @param right			The value on the right side of the =
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the two parameters are equal
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue equals(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 				throws StandardException
1: 	{
1: 		return truthValue(left,
1: 							right,
1: 							left.getBoolean() == right.getBoolean());
1: 	}
1: 
1: 	/**
0: 	 * The <> operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the <>
0: 	 * @param right			The value on the right side of the <>
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the two parameters are
1: 	 *			not equal
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue notEquals(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 				throws StandardException
1: 	{
1: 		return truthValue(left,
1: 							right,
1: 							left.getBoolean() != right.getBoolean());
1: 	}
1: 
1: 	/**
0: 	 * The < operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the <
0: 	 * @param right			The value on the right side of the <
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the left operand is
1: 	 *			less than the right operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue lessThan(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 				throws StandardException
1: 	{
1: 		/* We must call getBoolean() on both sides in order
1: 		 * to catch any invalid casts.
1: 		 */
1: 		boolean leftBoolean = left.getBoolean();
1: 		boolean rightBoolean = right.getBoolean();
1: 		/* By convention, false is less than true */
1: 		return truthValue(left,
1: 							right,
1: 							leftBoolean == false && rightBoolean == true);
1: 	}
1: 
1: 	/**
0: 	 * The > operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the >
0: 	 * @param right			The value on the right side of the >
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the left operand is
1: 	 *			greater than the right operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue greaterThan(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 				throws StandardException
1: 	{
1: 		/* We must call getBoolean() on both sides in order
1: 		 * to catch any invalid casts.
1: 		 */
1: 		boolean leftBoolean = left.getBoolean();
1: 		boolean rightBoolean = right.getBoolean();
1: 		/* By convention, true is greater than false */
1: 		return truthValue(left,
1: 							right,
1: 							leftBoolean == true && rightBoolean == false);
1: 	}
1: 
1: 	/**
0: 	 * The <= operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the <=
0: 	 * @param right			The value on the right side of the <=
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the left operand is
1: 	 *			less than or equal to the right operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue lessOrEquals(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 				throws StandardException
1: 	{
1: 		/* We must call getBoolean() on both sides in order
1: 		 * to catch any invalid casts.
1: 		 */
1: 		boolean leftBoolean = left.getBoolean();
1: 		boolean rightBoolean = right.getBoolean();
1: 		/* By convention, false is less than true */
1: 		return truthValue(left,
1: 							right,
1: 							leftBoolean == false || rightBoolean == true);
1: 	}
1: 
1: 	/**
0: 	 * The >= operator as called from the language module, as opposed to
1: 	 * the storage module.
1: 	 *
0: 	 * @param left			The value on the left side of the >=
0: 	 * @param right			The value on the right side of the >=
1: 	 *
1: 	 * @return	A SQL boolean value telling whether the left operand is
1: 	 *			greater than or equal to the right operand
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public BooleanDataValue greaterOrEquals(DataValueDescriptor left,
1: 							 DataValueDescriptor right)
1: 				throws StandardException
1: 	{
1: 		/* We must call getBoolean() on both sides in order
1: 		 * to catch any invalid casts.
1: 		 */
1: 		boolean leftBoolean = left.getBoolean();
1: 		boolean rightBoolean = right.getBoolean();
1: 		/* By convention, true is greater than false */
1: 		return truthValue(left,
1: 							right,
1: 							leftBoolean == true || rightBoolean == false);
1: 	}
1: 
1: 	/**
1: 	 * The AND operator.  This implements SQL semantics for AND with unknown
1: 	 * truth values - consult any standard SQL reference for an explanation.
1: 	 *
1: 	 * @param otherValue	The other boolean to AND with this one
1: 	 *
1: 	 * @return	this AND otherValue
1: 	 *
1: 	 */
1: 
1: 	public BooleanDataValue and(BooleanDataValue otherValue)
1: 	{
1: 		/*
1: 		** Catch those cases where standard SQL null semantics don't work.
1: 		*/
1: 		if (this.equals(false) || otherValue.equals(false))
1: 		{
1: 			return BOOLEAN_FALSE;
1: 		}
1: 		else
1: 		{
1: 			return truthValue(this,
1: 							otherValue,
1: 							this.getBoolean() && otherValue.getBoolean());
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * The OR operator.  This implements SQL semantics for OR with unknown
1: 	 * truth values - consult any standard SQL reference for an explanation.
1: 	 *
1: 	 * @param otherValue	The other boolean to OR with this one
1: 	 *
1: 	 * @return	this OR otherValue
1: 	 *
1: 	 */
1: 
1: 	public BooleanDataValue or(BooleanDataValue otherValue)
1: 	{
1: 		/*
1: 		** Catch those cases where standard SQL null semantics don't work.
1: 		*/
1: 		if (this.equals(true) || otherValue.equals(true))
1: 		{
1: 			return BOOLEAN_TRUE;
1: 		}
1: 		else
1: 		{
1: 			return truthValue(this,
1: 							otherValue,
1: 							this.getBoolean() || otherValue.getBoolean());
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * The SQL IS operator - consult any standard SQL reference for an explanation.
1: 	 *
1: 	 *	Implements the following truth table:
1: 	 *
1: 	 *	         otherValue
1: 	 *	        | TRUE    | FALSE   | UNKNOWN
1: 	 *	this    |----------------------------
1: 	 *	        |
1: 	 *	TRUE    | TRUE    | FALSE   | FALSE
1: 	 *	FALSE   | FALSE   | TRUE    | FALSE
1: 	 *	UNKNOWN | FALSE   | FALSE   | TRUE
1: 	 *
1: 	 *
1: 	 * @param otherValue	BooleanDataValue to compare to. May be TRUE, FALSE, or UNKNOWN.
1: 	 *
1: 	 * @return	whether this IS otherValue
1: 	 *
1: 	 */
1: 	public BooleanDataValue is(BooleanDataValue otherValue)
1: 	{
1: 		if ( this.equals(true) && otherValue.equals(true) )
1: 		{ return BOOLEAN_TRUE; }
1: 
1: 		if ( this.equals(false) && otherValue.equals(false) )
1: 		{ return BOOLEAN_TRUE; }
1: 
1: 		if ( this.isNull() && otherValue.isNull() )
1: 		{ return BOOLEAN_TRUE; }
1: 
1: 		return BOOLEAN_FALSE;
1: 	}
1: 
1: 	/**
1: 	 * Implements NOT IS. This reverses the sense of the is() call.
1: 	 *
1: 	 *
1: 	 * @param otherValue	BooleanDataValue to compare to. May be TRUE, FALSE, or UNKNOWN.
1: 	 *
1: 	 * @return	NOT( this IS otherValue )
1: 	 *
1: 	 */
1: 	public BooleanDataValue isNot(BooleanDataValue otherValue)
1: 	{
1: 		BooleanDataValue	isValue = is( otherValue );
1: 
1: 		if ( isValue.equals(true) ) { return BOOLEAN_FALSE; }
1: 		else { return BOOLEAN_TRUE; }
1: 	}
1: 
1: 	/**
1: 	 * Throw an exception with the given SQLState if this BooleanDataValue
1: 	 * is false. This method is useful for evaluating constraints.
1: 	 *
0: 	 * @param SQLState		The SQLState of the exception to throw if
1: 	 *						this SQLBoolean is false.
1: 	 * @param tableName		The name of the table to include in the exception
1: 	 *						message.
1: 	 * @param constraintName	The name of the failed constraint to include
1: 	 *							in the exception message.
1: 	 *
1: 	 * @return	this
1: 	 *
1: 	 * @exception	StandardException	Thrown if this BooleanDataValue
1: 	 *									is false.
1: 	 */
1: 	public BooleanDataValue throwExceptionIfFalse(
1: 									String sqlState,
1: 									String tableName,
1: 									String constraintName)
1: 							throws StandardException
1: 	{
1: 		if ( ( ! isNull() ) && (value == false) )
1: 		{
1: 			throw StandardException.newException(sqlState,
1: 												tableName,
1: 												constraintName);
1: 		}
1: 
1: 		return this;
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/** @see DataValueDescriptor#typePrecedence */
1: 	public int typePrecedence()
1: 	{
1: 		return TypeId.BOOLEAN_PRECEDENCE;
1: 	}
1: 
1: 	/*
1: 	** Support functions
1: 	*/
1: 
1: 	/**
1: 	 * Return the SQL truth value for a comparison.
1: 	 *
1: 	 * This method first looks at the operands - if either is null, it
1: 	 * returns the unknown truth value.  This implements "normal" SQL
1: 	 * null semantics, where if any operand is null, the result is null.
1: 	 * Note that there are cases where these semantics are incorrect -
1: 	 * for example, NULL AND FALSE is supposed to be FALSE, not NULL
1: 	 * (the NULL truth value is the same as the UNKNOWN truth value).
1: 	 *
1: 	 * If neither operand is null, it returns a static final variable
1: 	 * containing the SQLBoolean truth value.  It returns different values
1: 	 * depending on whether the truth value is supposed to be nullable.
1: 	 *
1: 	 * This method always returns a pre-allocated static final SQLBoolean.
1: 	 * This is practical because there are so few possible return values.
1: 	 * Using pre-allocated values allows us to avoid constructing new
1: 	 * SQLBoolean values during execution.
1: 	 *
1: 	 * @param leftOperand	The left operand of the binary comparison
1: 	 * @param rightOperand	The right operand of the binary comparison
1: 	 * @param truth			The truth value of the comparison
1: 	 *
1: 	 * @return	A SQLBoolean containing the desired truth value.
1: 	 */
1: 
1: 	public static SQLBoolean truthValue(
1: 								DataValueDescriptor leftOperand,
1: 								DataValueDescriptor rightOperand,
1: 								boolean truth)
1: 	{
1: 		/* Return UNKNOWN if either operand is null */
1: 		if (leftOperand.isNull() || rightOperand.isNull())
1: 		{
1: 			return unknownTruthValue();
1: 		}
1: 
1: 		/* Return the appropriate SQLBoolean for the given truth value */
1: 		if (truth == true)
1: 		{
1: 			return BOOLEAN_TRUE;
1: 		}
1: 		else
1: 		{
1: 			return BOOLEAN_FALSE;
1: 		}
1: 	}
1: 
1:     /**
1:      * same as above, but takes a Boolean, if it is null, unknownTruthValue is returned
1:      */
1: 	public static SQLBoolean truthValue(
1: 								DataValueDescriptor leftOperand,
1: 								DataValueDescriptor rightOperand,
1: 								Boolean truth)
1: 	{
1: 		/* Return UNKNOWN if either operand is null */
1: 		if (leftOperand.isNull() || rightOperand.isNull() || truth==null)
1: 		{
1: 			return unknownTruthValue();
1: 		}
1: 
1: 		/* Return the appropriate SQLBoolean for the given truth value */
1: 		if (truth == Boolean.TRUE)
1: 		{
1: 			return BOOLEAN_TRUE;
1: 		}
1: 		else
1: 		{
1: 			return BOOLEAN_FALSE;
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Get a truth value.
1: 	 *
1: 	 * @param value	The value of the SQLBoolean
1: 	 *
1:  	 * @return	A SQLBoolean with the given truth value
1: 	 */
1: 	public static SQLBoolean truthValue(boolean value)
1: 	{
1: 		/*
1: 		** Return the non-nullable versions of TRUE and FALSE, since they
1: 		** can never be null.
1: 		*/
1: 		if (value == true)
1: 			return BOOLEAN_TRUE;
1: 		else
1: 			return BOOLEAN_FALSE;
1: 	}
1: 
1: 	/**
1: 	 * Return an unknown truth value.  Check to be sure the return value is
1: 	 * nullable.
1: 	 *
1: 	 * @return	A SQLBoolean representing the UNKNOWN truth value
1: 	 */
1: 	public static SQLBoolean unknownTruthValue()
1: 	{
1: 		return UNKNOWN;
1: 	}
1: 
1: 	/**
0: 	 * Return a false truth value.
1: 	 *
1: 	 *
0: 	 * @return	A SQLBoolean representing the FALSE truth value
1: 	 */
0: 	public static SQLBoolean falseTruthValue()
1: 	{
1: 		return BOOLEAN_FALSE;
1: 	}
1: 
1: 	/**
0: 	 * Return a true truth value.
1: 	 *
1: 	 *
0: 	 * @return	A SQLBoolean representing the TRUE truth value
1: 	 */
0: 	public static SQLBoolean trueTruthValue()
1: 	{
1: 		return BOOLEAN_TRUE;
1: 	}
1: 	
1: 	/**
1: 	 * Determine whether this SQLBoolean contains the given boolean value.
1: 	 *
1: 	 * This method is used by generated code to determine when to do
1: 	 * short-circuiting for an AND or OR.
1: 	 *
1: 	 * @param val	The value to look for
1: 	 *
1: 	 * @return	true if the given value equals the value in this SQLBoolean,
1: 	 *			false if not
1: 	 */
1: 
1: 	public boolean equals(boolean val)
1: 	{
1: 		if (isNull())
1: 			return false;
1: 		else
1: 			return value == val;
1: 	}
1: 
1: 	/*
1: 	 * String display of value
1: 	 */
1: 
1: 	public String toString()
1: 	{
1: 		if (isNull())
1: 			return "NULL";
1: 		else if (value == true)
1: 			return "true";
1: 		else
1: 			return "false";
1: 	}
1: 
1: 	/*
1: 	 * Hash code
1: 	 */
1: 	public int hashCode()
1: 	{
1: 		if (isNull())
1: 		{
1: 			return -1;
1: 		}
1: 
1: 		return (value) ? 1 : 0;
1: 	}
1: 
1: 	/*
1: 	 * useful constants...
1: 	 */
1: 	static final int BOOLEAN_LENGTH		= 1;	// must match the number of bytes written by DataOutput.writeBoolean()
1: 
1: 	private static final SQLBoolean BOOLEAN_TRUE = new SQLBoolean(true);
1: 	private static final SQLBoolean BOOLEAN_FALSE = new SQLBoolean(false);
1: 	static final SQLBoolean UNKNOWN = new SQLBoolean();
1: 
1: 	/* Static initialization block */
1: 	static
1: 	{
1: 		/* Mark all the static SQLBooleans as immutable */
1: 		BOOLEAN_TRUE.immutable = true;
1: 		BOOLEAN_FALSE.immutable = true;
1: 		UNKNOWN.immutable = true;
1: 	}
1: 
1:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLBoolean.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
1:         return BASE_MEMORY_USAGE;
1:     }
1: 
1: 	/*
1: 	 * object state
1: 	 */
0: 	protected boolean value;
0: 	protected boolean isnull;
0: 	protected boolean immutable;
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.Orderable;
0: 
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: import java.math.BigDecimal;
0: 
0: import java.sql.ResultSet;
0: import java.sql.PreparedStatement;
0: import java.sql.SQLException;
0: 
0: /**
0:  * SQLBoolean satisfies the DataValueDescriptor
0:  * interfaces (i.e., DataType). It implements a boolean column, 
0:  * e.g. for * storing a column value; it can be specified
0:  * when constructed to not allow nulls. Nullability cannot be changed
0:  * after construction, as it affects the storage size and mechanism.
0:  * <p>
0:  * Because DataType is a subtype of DataType,
0:  * SQLBoolean can play a role in either a DataType/Row
0:  * or a DataType/Row, interchangeably.
0:  * <p>
0:  * We assume the store has a flag for nullness of the value,
0:  * and simply return a 0-length array for the stored form
0:  * when the value is null.
0:  * <p>
0:  * PERFORMANCE: There are likely alot of performance improvements
0:  * possible for this implementation -- it new's Integer
0:  * more than it probably wants to.
0:  */
0: public final class SQLBoolean
0: 	extends DataType implements BooleanDataValue
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 * (mostly implemented in DataType)
0: 	 */
0: 
0: 	/*
0: 	 * see if the integer value is null.
0: 	 */
0: 	public boolean isNull()
0: 	{
0: 		return isnull;
0: 	}
0: 
0: 	public boolean	getBoolean()
0: 	{
0: 		return value;
0: 	}
0: 
0: 	private static int makeInt(boolean b)
0: 	{
0: 		return (b?1:0);
0: 	}
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#getByte 
0: 	 */
0: 	public byte	getByte() 
0: 	{
0: 		return (byte) makeInt(value);
0: 	}
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#getShort 
0: 	 */
0: 	public short	getShort()
0: 	{
0: 		return (short) makeInt(value);
0: 	}
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#getInt 
0: 	 */
0: 	public int	getInt()
0: 	{
0: 		return makeInt(value);
0: 	}
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#getLong 
0: 	 */
0: 	public long	getLong()
0: 	{
0: 		return (long) makeInt(value);
0: 	}
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#getFloat 
0: 	 */
0: 	public float	getFloat()
0: 	{
0: 		return (float) makeInt(value);
0: 	}
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#getDouble 
0: 	 */
0: 	public double	getDouble()
0: 	{
0: 		return (double) makeInt(value);
0: 	}
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#getBigDecimal 
0: 	 */
0: 	public BigDecimal	getBigDecimal()
0: 	{
0: 		if (isNull()) return null;
0: 		return BigDecimal.valueOf(makeInt(value));
0: 	}
0: 
0: 	public String	getString()
0: 	{
0: 		if (isNull())
0: 			return null;
0: 		else if (value == true)
0: 			return "true";
0: 		else
0: 			return "false";
0: 	}
0: 
0: 	public Object	getObject()
0: 	{
0: 		if (isNull())
0: 			return null;
0: 		else
0: 			return new Boolean(value);
0: 	}
0: 
0: 	public int	getLength()
0: 	{
0: 		return BOOLEAN_LENGTH;
0: 	}
0: 
0: 	// this is for DataType's error generator
0: 	public String getTypeName()
0: 	{
0: 		return TypeId.BOOLEAN_NAME;
0: 	}
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() {
0: 		return StoredFormatIds.SQL_BOOLEAN_ID;
0: 	}
0: 
0: 	public void writeExternal(ObjectOutput out) throws IOException {
0: 
0: 		// never called when value is null
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(! isNull());
0: 
0: 		out.writeBoolean(value);
0: 	}
0: 
0: 	/** @see java.io.Externalizable#readExternal */
0: 	public void readExternal(ObjectInput in) throws IOException {
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 
0: 		value = in.readBoolean();
0: 		isnull = false;
0: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException {
0: 
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 
0: 		value = in.readBoolean();
0: 		isnull = false;
0: 	}
0: 
0: 	/**
0: 	 * @see Storable#restoreToNull
0: 	 *
0: 	 */
0: 	public void restoreToNull()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 
0: 		value = false;
0: 		isnull = true;
0: 	}
0: 
0: 	/*
0: 	 * Orderable interface
0: 	 */
0: 
0: 	/**
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public int compare(DataValueDescriptor other) throws StandardException
0: 	{
0: 		/* Use compare method from dominant type, negating result
0: 		 * to reflect flipping of sides.
0: 		 */
0: 		if (typePrecedence() < other.typePrecedence())
0: 		{
0: 			return - (other.compare(this));
0: 		}
0: 
0: 		boolean thisNull, otherNull;
0: 		thisNull = this.isNull();
0: 		otherNull = other.isNull();
0: 
0: 		/*
0: 		 * thisNull otherNull thisValue thatValue return
0: 		 *	T		T			X		X			0	(this == other)
0: 		 *	F		T			X		X			1 	(this > other)
0: 		 *	T		F			X		X			-1	(this < other)
0: 		 *
0: 		 *	F		F			T		T			0	(this == other)
0: 		 *	F		F			T		F			1	(this > other)
0: 		 *	F		F			F		T			-1	(this < other)
0: 		 *	F		F			F		F			0	(this == other)
0: 		 */
0: 		if (thisNull || otherNull)
0: 		{
0: 			if (!thisNull)		// otherNull must be true
0: 				return 1;
0: 			if (!otherNull)		// thisNull must be true
0: 				return -1;
0: 			return 0;
0: 		}
0: 
0: 		/* neither are null, get the value */
0: 		boolean thisValue;
0: 		boolean otherValue = false;
0: 		thisValue = this.getBoolean();
0: 
0: 		otherValue = other.getBoolean();
0: 
0: 		if (thisValue == otherValue)
0: 			return 0;
0: 		else if (thisValue && !otherValue)
0: 			return 1;
0: 		else
0: 			return -1;
0: 	}
0: 
0: 	/**
0: 		@exception StandardException thrown on error
0: 	 */
0: 	public boolean compare(int op,
0: 						   DataValueDescriptor other,
0: 						   boolean orderedNulls,
0: 						   boolean unknownRV)
0: 		throws StandardException
0: 	{
0: 		if (!orderedNulls)		// nulls are unordered
0: 		{
0: 			if (this.isNull() || other.isNull())
0: 				return unknownRV;
0: 		}
0: 		/* Do the comparison */
0: 		return super.compare(op, other, orderedNulls, unknownRV);
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** @see DataValueDescriptor#getClone */
0: 	public DataValueDescriptor getClone()
0: 	{
0: 		return new SQLBoolean(value, isnull);
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#getNewNull
0: 	 */
0: 	public DataValueDescriptor getNewNull()
0: 	{
0: 		return new SQLBoolean();
0: 	}
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#setValueFromResultSet 
0: 	 *
0: 	 * @exception SQLException		Thrown on error
0: 	 */
0: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
0: 									  boolean isNullable)
0: 		throws SQLException
0: 	{
0: 			value = resultSet.getBoolean(colNumber);
0: 			isnull = (isNullable && resultSet.wasNull());
0: 	}
0: 	/**
0: 		Set the value into a PreparedStatement.
0: 
0: 		@exception SQLException Error setting value in PreparedStatement
0: 	*/
0: 	public final void setInto(PreparedStatement ps, int position) throws SQLException {
0: 
0: 		if (isNull()) {
0: 			ps.setNull(position, java.sql.Types.BIT);
0: 			return;
0: 		}
0: 
0: 		ps.setBoolean(position, value);
0: 	}
0: 	/*
0: 	 * class interface
0: 	 */
0: 
0: 	/*
0: 	 * constructors
0: 	 */
0: 
0: 	/* NOTE - other data types have both (type value) and (boolean nulls), 
0: 	 * (value, nulls)
0: 	 * We can't do both (boolean value) and (boolean nulls) here,
0: 	 * so we'll skip over (boolean value) and have (Boolean value) so
0: 	 * that we can support (boolean nulls).
0: 	 */
0: 
0: 	public SQLBoolean()
0: 	{
0: 		isnull = true;
0: 	}
0: 
0: 	public SQLBoolean(boolean val)
0: 	{
0: 		value = val;
0: 	}
0: 	public SQLBoolean(Boolean obj) {
0: 		if (isnull = (obj == null))
0: 			;
0: 		else
0: 			value = obj.booleanValue();
0: 	}
0: 
0: 	/* This constructor gets used for the getClone() method */
0: 	private SQLBoolean(boolean val, boolean isnull)
0: 	{
0: 		value = val;
0: 		this.isnull = isnull;
0: 	}
0: 
0: 	/** @see BooleanDataValue#setValue */
0: 	public void setValue(boolean theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		value = theValue;
0: 		isnull = false;
0: 
0: 	}
0: 
0: 	public void setValue(Boolean theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		if (theValue == null)
0: 		{
0: 			value = false;
0: 			isnull = true;
0: 		}
0: 		else
0: 		{
0: 			value = theValue.booleanValue();
0: 			isnull = false;
0: 		}
0: 
0: 	}
0: 
0: 	// REMIND: do we need this, or is long enough?
0: 	public void setValue(byte theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		value = theValue != 0;
0: 		isnull = false;
0: 
0: 	}
0: 
0: 
0: 	// REMIND: do we need this, or is long enough?
0: 	public void setValue(short theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		value = theValue != 0;
0: 		isnull = false;
0: 
0: 	}
0: 
0: 
0: 	// REMIND: do we need this, or is long enough?
0: 	public void setValue(int theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		value = theValue != 0;
0: 		isnull = false;
0: 
0: 	}
0: 
0: 	public void setValue(long theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		value = theValue != 0;
0: 		isnull = false;
0: 
0: 	}
0: 
0: 	// REMIND: do we need this, or is double enough?
0: 	public void setValue(float theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		value = theValue != 0;
0: 		isnull = false;
0: 
0: 	}
0: 
0: 	public void setValue(double theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		value = theValue != 0;
0: 		isnull = false;
0: 
0: 	}
0: 
0: 	public void setValue(BigDecimal theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		if (theValue == null)
0: 		{
0: 			value = false;
0: 			isnull = true;
0: 		}
0: 		else
0: 		{
0: 			value = theValue.compareTo(org.apache.derby.iapi.types.SQLDecimal.ZERO) != 0;
0: 			isnull = false;
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this BooleanDataValue to the given byte array value
0: 	 *
0: 	 * @param theValue	The value to set this BooleanDataValue to
0: 	 *
0: 	 * @return	This BooleanDataValue
0: 	 */
0: 	public void setValue(byte[] theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 
0: 		if (theValue != null)
0: 		{
0: 			isnull = false;
0: 			int length = theValue.length;
0: 	
0: 			/*
0: 			** Step through all bytes.  As soon
0: 			** as we get one with something other
0: 			** than 0, then we know we have a 'true'
0: 			*/
0: 			for (int i = 0; i < length; i++)
0: 			{
0: 				if (theValue[i] != 0)
0: 				{
0: 					value = true;
0: 					return;
0: 				}
0: 			}
0: 		}
0: 		else
0: 		{
0: 			isnull = true;
0: 		}
0: 		value = false;
0: 
0: 	}
0: 
0: 
0: 	/**
0: 	 * Set the value of this BooleanDataValue to the given String.
0: 	 * String is trimmed and upcased.  If resultant string is not
0: 	 * TRUE or FALSE, then an error is thrown.
0: 	 *
0: 	 * @param theValue	The value to set this BooleanDataValue to
0: 	 *
0: 	 * @return	This BooleanDataValue
0: 	 *
0: 	 * @exception StandardException Thrown on error
0: 	 */
0: 	public void setValue(String theValue)
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 		if (theValue == null)
0: 		{
0: 			value = false;
0: 			isnull = true;
0: 		}
0: 		else
0: 		{
0: 			/*
0: 			** Note: cannot use getBoolean(String) here because
0: 			** it doesn't trim, and doesn't throw exceptions.
0: 			*/
0: 			String cleanedValue = StringUtil.SQLToUpperCase(theValue.trim());
0: 			if (cleanedValue.equals("TRUE"))
0: 			{
0: 				value = true;
0: 			}
0: 			else if (cleanedValue.equals("FALSE"))
0: 			{
0: 				value = false;
0: 			}
0: 			else
0: 			{ 
0: 				throw invalidFormat();
0: 			}
0: 			isnull = false;
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Byte value
0: 	 *
0: 	 * @param theValue	The value to set this BooleanDataValue to
0: 	 *
0: 	 * @return	This BooleanDataValue
0: 	 */
0: 	public void setValue(Byte theValue)
0: 	{
0: 		setValueCore(theValue);
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Short value
0: 	 *
0: 	 * @param theValue	The value to set this BooleanDataValue to
0: 	 *
0: 	 * @return	This BooleanDataValue
0: 	 */
0: 	public void setValue(Short theValue)
0: 	{
0: 		setValueCore(theValue);
0: 	}
0: 	
0: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Long value
0: 	 *
0: 	 * @param theValue	The value to set this BooleanDataValue to
0: 	 *
0: 	 * @return	This BooleanDataValue
0: 	 */
0: 	public void setValue(Long theValue)
0: 	{
0: 		setValueCore(theValue);
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Integer value
0: 	 *
0: 	 * @param theValue	The value to set this BooleanDataValue to
0: 	 *
0: 	 * @return	This BooleanDataValue
0: 	 */
0: 	public void setValue(Integer theValue)
0: 	{
0: 		setValueCore(theValue);
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Double value
0: 	 *
0: 	 * @param theValue	The value to set this BooleanDataValue to
0: 	 *
0: 	 * @return	This BooleanDataValue
0: 	 */
0: 	public void setValue(Double theValue)
0: 	{
0: 		setValueCore(theValue);
0: 	}
0: 
0: 	/**
0: 	 * Set the value of this BooleanDataValue to the given Double value
0: 	 *
0: 	 * @param theValue	The value to set this BooleanDataValue to
0: 	 *
0: 	 * @return	This BooleanDataValue
0: 	 */
0: 	public void setValue(Float theValue)
0: 	{
0: 		setValueCore(theValue);
0: 	}
0: 
0: 	private void setValueCore(Number theValue)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT( ! immutable,
0: 						"Attempt to set the value of an immutable SQLBoolean");
0: 
0: 		if (theValue == null)
0: 		{
0: 			isnull = true;
0: 			value = false;
0: 		}
0: 		else
0: 		{
0: 			value = (theValue.intValue() != 0);
0: 			isnull = false;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#setValue
0: 	 */	
0: 	public void setValue(Object theValue)
0: 		throws StandardException
0: 	{
0: 		if ((theValue instanceof Boolean) ||
0: 			(theValue == null))
0: 		{
0: 			this.setValue((Boolean)theValue);
0: 		}
0: 		else if (theValue instanceof Number) {
0: 			setValueCore((Number) theValue);
0: 		}
0: 		else
0: 		{
0: 			genericSetObject(theValue);
0: 		}
0: 	}
0: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
0: 
0: 		setValue(theValue.getBoolean());
0: 	}
0: 
0: 
0: 	/*
0: 	** SQL Operators
0: 	*/
0: 
0: 	/**
0: 	 * The = operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the =
0: 	 * @param right			The value on the right side of the =
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the two parameters are equal
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue equals(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 				throws StandardException
0: 	{
0: 		return truthValue(left,
0: 							right,
0: 							left.getBoolean() == right.getBoolean());
0: 	}
0: 
0: 	/**
0: 	 * The <> operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the <>
0: 	 * @param right			The value on the right side of the <>
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the two parameters are
0: 	 *			not equal
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue notEquals(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 				throws StandardException
0: 	{
0: 		return truthValue(left,
0: 							right,
0: 							left.getBoolean() != right.getBoolean());
0: 	}
0: 
0: 	/**
0: 	 * The < operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the <
0: 	 * @param right			The value on the right side of the <
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the left operand is
0: 	 *			less than the right operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue lessThan(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 				throws StandardException
0: 	{
0: 		/* We must call getBoolean() on both sides in order
0: 		 * to catch any invalid casts.
0: 		 */
0: 		boolean leftBoolean = left.getBoolean();
0: 		boolean rightBoolean = right.getBoolean();
0: 		/* By convention, false is less than true */
0: 		return truthValue(left,
0: 							right,
0: 							leftBoolean == false && rightBoolean == true);
0: 	}
0: 
0: 	/**
0: 	 * The > operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the >
0: 	 * @param right			The value on the right side of the >
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the left operand is
0: 	 *			greater than the right operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue greaterThan(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 				throws StandardException
0: 	{
0: 		/* We must call getBoolean() on both sides in order
0: 		 * to catch any invalid casts.
0: 		 */
0: 		boolean leftBoolean = left.getBoolean();
0: 		boolean rightBoolean = right.getBoolean();
0: 		/* By convention, true is greater than false */
0: 		return truthValue(left,
0: 							right,
0: 							leftBoolean == true && rightBoolean == false);
0: 	}
0: 
0: 	/**
0: 	 * The <= operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the <=
0: 	 * @param right			The value on the right side of the <=
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the left operand is
0: 	 *			less than or equal to the right operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue lessOrEquals(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 				throws StandardException
0: 	{
0: 		/* We must call getBoolean() on both sides in order
0: 		 * to catch any invalid casts.
0: 		 */
0: 		boolean leftBoolean = left.getBoolean();
0: 		boolean rightBoolean = right.getBoolean();
0: 		/* By convention, false is less than true */
0: 		return truthValue(left,
0: 							right,
0: 							leftBoolean == false || rightBoolean == true);
0: 	}
0: 
0: 	/**
0: 	 * The >= operator as called from the language module, as opposed to
0: 	 * the storage module.
0: 	 *
0: 	 * @param left			The value on the left side of the >=
0: 	 * @param right			The value on the right side of the >=
0: 	 *
0: 	 * @return	A SQL boolean value telling whether the left operand is
0: 	 *			greater than or equal to the right operand
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public BooleanDataValue greaterOrEquals(DataValueDescriptor left,
0: 							 DataValueDescriptor right)
0: 				throws StandardException
0: 	{
0: 		/* We must call getBoolean() on both sides in order
0: 		 * to catch any invalid casts.
0: 		 */
0: 		boolean leftBoolean = left.getBoolean();
0: 		boolean rightBoolean = right.getBoolean();
0: 		/* By convention, true is greater than false */
0: 		return truthValue(left,
0: 							right,
0: 							leftBoolean == true || rightBoolean == false);
0: 	}
0: 
0: 	/**
0: 	 * The AND operator.  This implements SQL semantics for AND with unknown
0: 	 * truth values - consult any standard SQL reference for an explanation.
0: 	 *
0: 	 * @param otherValue	The other boolean to AND with this one
0: 	 *
0: 	 * @return	this AND otherValue
0: 	 *
0: 	 */
0: 
0: 	public BooleanDataValue and(BooleanDataValue otherValue)
0: 	{
0: 		/*
0: 		** Catch those cases where standard SQL null semantics don't work.
0: 		*/
0: 		if (this.equals(false) || otherValue.equals(false))
0: 		{
0: 			return BOOLEAN_FALSE;
0: 		}
0: 		else
0: 		{
0: 			return truthValue(this,
0: 							otherValue,
0: 							this.getBoolean() && otherValue.getBoolean());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * The OR operator.  This implements SQL semantics for OR with unknown
0: 	 * truth values - consult any standard SQL reference for an explanation.
0: 	 *
0: 	 * @param otherValue	The other boolean to OR with this one
0: 	 *
0: 	 * @return	this OR otherValue
0: 	 *
0: 	 */
0: 
0: 	public BooleanDataValue or(BooleanDataValue otherValue)
0: 	{
0: 		/*
0: 		** Catch those cases where standard SQL null semantics don't work.
0: 		*/
0: 		if (this.equals(true) || otherValue.equals(true))
0: 		{
0: 			return BOOLEAN_TRUE;
0: 		}
0: 		else
0: 		{
0: 			return truthValue(this,
0: 							otherValue,
0: 							this.getBoolean() || otherValue.getBoolean());
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * The SQL IS operator - consult any standard SQL reference for an explanation.
0: 	 *
0: 	 *	Implements the following truth table:
0: 	 *
0: 	 *	         otherValue
0: 	 *	        | TRUE    | FALSE   | UNKNOWN
0: 	 *	this    |----------------------------
0: 	 *	        |
0: 	 *	TRUE    | TRUE    | FALSE   | FALSE
0: 	 *	FALSE   | FALSE   | TRUE    | FALSE
0: 	 *	UNKNOWN | FALSE   | FALSE   | TRUE
0: 	 *
0: 	 *
0: 	 * @param otherValue	BooleanDataValue to compare to. May be TRUE, FALSE, or UNKNOWN.
0: 	 *
0: 	 * @return	whether this IS otherValue
0: 	 *
0: 	 */
0: 	public BooleanDataValue is(BooleanDataValue otherValue)
0: 	{
0: 		if ( this.equals(true) && otherValue.equals(true) )
0: 		{ return BOOLEAN_TRUE; }
0: 
0: 		if ( this.equals(false) && otherValue.equals(false) )
0: 		{ return BOOLEAN_TRUE; }
0: 
0: 		if ( this.isNull() && otherValue.isNull() )
0: 		{ return BOOLEAN_TRUE; }
0: 
0: 		return BOOLEAN_FALSE;
0: 	}
0: 
0: 	/**
0: 	 * Implements NOT IS. This reverses the sense of the is() call.
0: 	 *
0: 	 *
0: 	 * @param otherValue	BooleanDataValue to compare to. May be TRUE, FALSE, or UNKNOWN.
0: 	 *
0: 	 * @return	NOT( this IS otherValue )
0: 	 *
0: 	 */
0: 	public BooleanDataValue isNot(BooleanDataValue otherValue)
0: 	{
0: 		BooleanDataValue	isValue = is( otherValue );
0: 
0: 		if ( isValue.equals(true) ) { return BOOLEAN_FALSE; }
0: 		else { return BOOLEAN_TRUE; }
0: 	}
0: 
0: 	/**
0: 	 * Throw an exception with the given SQLState if this BooleanDataValue
0: 	 * is false. This method is useful for evaluating constraints.
0: 	 *
0: 	 * @param SQLState		The SQLState of the exception to throw if
0: 	 *						this SQLBoolean is false.
0: 	 * @param tableName		The name of the table to include in the exception
0: 	 *						message.
0: 	 * @param constraintName	The name of the failed constraint to include
0: 	 *							in the exception message.
0: 	 *
0: 	 * @return	this
0: 	 *
0: 	 * @exception	StandardException	Thrown if this BooleanDataValue
0: 	 *									is false.
0: 	 */
0: 	public BooleanDataValue throwExceptionIfFalse(
0: 									String sqlState,
0: 									String tableName,
0: 									String constraintName)
0: 							throws StandardException
0: 	{
0: 		if ( ( ! isNull() ) && (value == false) )
0: 		{
0: 			throw StandardException.newException(sqlState,
0: 												tableName,
0: 												constraintName);
0: 		}
0: 
0: 		return this;
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** @see DataValueDescriptor#typePrecedence */
0: 	public int typePrecedence()
0: 	{
0: 		return TypeId.BOOLEAN_PRECEDENCE;
0: 	}
0: 
0: 	/*
0: 	** Support functions
0: 	*/
0: 
0: 	/**
0: 	 * Return the SQL truth value for a comparison.
0: 	 *
0: 	 * This method first looks at the operands - if either is null, it
0: 	 * returns the unknown truth value.  This implements "normal" SQL
0: 	 * null semantics, where if any operand is null, the result is null.
0: 	 * Note that there are cases where these semantics are incorrect -
0: 	 * for example, NULL AND FALSE is supposed to be FALSE, not NULL
0: 	 * (the NULL truth value is the same as the UNKNOWN truth value).
0: 	 *
0: 	 * If neither operand is null, it returns a static final variable
0: 	 * containing the SQLBoolean truth value.  It returns different values
0: 	 * depending on whether the truth value is supposed to be nullable.
0: 	 *
0: 	 * This method always returns a pre-allocated static final SQLBoolean.
0: 	 * This is practical because there are so few possible return values.
0: 	 * Using pre-allocated values allows us to avoid constructing new
0: 	 * SQLBoolean values during execution.
0: 	 *
0: 	 * @param leftOperand	The left operand of the binary comparison
0: 	 * @param rightOperand	The right operand of the binary comparison
0: 	 * @param truth			The truth value of the comparison
0: 	 *
0: 	 * @return	A SQLBoolean containing the desired truth value.
0: 	 */
0: 
0: 	public static SQLBoolean truthValue(
0: 								DataValueDescriptor leftOperand,
0: 								DataValueDescriptor rightOperand,
0: 								boolean truth)
0: 	{
0: 		/* Return UNKNOWN if either operand is null */
0: 		if (leftOperand.isNull() || rightOperand.isNull())
0: 		{
0: 			return unknownTruthValue();
0: 		}
0: 
0: 		/* Return the appropriate SQLBoolean for the given truth value */
0: 		if (truth == true)
0: 		{
0: 			return BOOLEAN_TRUE;
0: 		}
0: 		else
0: 		{
0: 			return BOOLEAN_FALSE;
0: 		}
0: 	}
0: 
0:     /**
0:      * same as above, but takes a Boolean, if it is null, unknownTruthValue is returned
0:      */
0: 	public static SQLBoolean truthValue(
0: 								DataValueDescriptor leftOperand,
0: 								DataValueDescriptor rightOperand,
0: 								Boolean truth)
0: 	{
0: 		/* Return UNKNOWN if either operand is null */
0: 		if (leftOperand.isNull() || rightOperand.isNull() || truth==null)
0: 		{
0: 			return unknownTruthValue();
0: 		}
0: 
0: 		/* Return the appropriate SQLBoolean for the given truth value */
0: 		if (truth == Boolean.TRUE)
0: 		{
0: 			return BOOLEAN_TRUE;
0: 		}
0: 		else
0: 		{
0: 			return BOOLEAN_FALSE;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get a truth value.
0: 	 *
0: 	 * @param value	The value of the SQLBoolean
0: 	 *
0:  	 * @return	A SQLBoolean with the given truth value
0: 	 */
0: 	public static SQLBoolean truthValue(boolean value)
0: 	{
0: 		/*
0: 		** Return the non-nullable versions of TRUE and FALSE, since they
0: 		** can never be null.
0: 		*/
0: 		if (value == true)
0: 			return BOOLEAN_TRUE;
0: 		else
0: 			return BOOLEAN_FALSE;
0: 	}
0: 
0: 	/**
0: 	 * Return an unknown truth value.  Check to be sure the return value is
0: 	 * nullable.
0: 	 *
0: 	 * @return	A SQLBoolean representing the UNKNOWN truth value
0: 	 */
0: 	public static SQLBoolean unknownTruthValue()
0: 	{
0: 		return UNKNOWN;
0: 	}
0: 
0: 	/**
0: 	 * Return a false truth value.
0: 	 *
0: 	 *
0: 	 * @return	A SQLBoolean representing the FALSE truth value
0: 	 */
0: 	public static SQLBoolean falseTruthValue()
0: 	{
0: 		return BOOLEAN_FALSE;
0: 	}
0: 
0: 	/**
0: 	 * Return a true truth value.
0: 	 *
0: 	 *
0: 	 * @return	A SQLBoolean representing the TRUE truth value
0: 	 */
0: 	public static SQLBoolean trueTruthValue()
0: 	{
0: 		return BOOLEAN_TRUE;
0: 	}
0: 	
0: 	/**
0: 	 * Determine whether this SQLBoolean contains the given boolean value.
0: 	 *
0: 	 * This method is used by generated code to determine when to do
0: 	 * short-circuiting for an AND or OR.
0: 	 *
0: 	 * @param val	The value to look for
0: 	 *
0: 	 * @return	true if the given value equals the value in this SQLBoolean,
0: 	 *			false if not
0: 	 */
0: 
0: 	public boolean equals(boolean val)
0: 	{
0: 		if (isNull())
0: 			return false;
0: 		else
0: 			return value == val;
0: 	}
0: 
0: 	/*
0: 	 * String display of value
0: 	 */
0: 
0: 	public String toString()
0: 	{
0: 		if (isNull())
0: 			return "NULL";
0: 		else if (value == true)
0: 			return "true";
0: 		else
0: 			return "false";
0: 	}
0: 
0: 	/*
0: 	 * Hash code
0: 	 */
0: 	public int hashCode()
0: 	{
0: 		if (isNull())
0: 		{
0: 			return -1;
0: 		}
0: 
0: 		return (value) ? 1 : 0;
0: 	}
0: 
0: 	/*
0: 	 * useful constants...
0: 	 */
0: 	static final int BOOLEAN_LENGTH		= 1;	// must match the number of bytes written by DataOutput.writeBoolean()
0: 
0: 	private static final SQLBoolean BOOLEAN_TRUE = new SQLBoolean(true);
0: 	private static final SQLBoolean BOOLEAN_FALSE = new SQLBoolean(false);
0: 	static final SQLBoolean UNKNOWN = new SQLBoolean();
0: 
0: 	/* Static initialization block */
0: 	static
0: 	{
0: 		/* Mark all the static SQLBooleans as immutable */
0: 		BOOLEAN_TRUE.immutable = true;
0: 		BOOLEAN_FALSE.immutable = true;
0: 		UNKNOWN.immutable = true;
0: 	}
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLBoolean.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         return BASE_MEMORY_USAGE;
0:     }
0: 
0: 	/*
0: 	 * object state
0: 	 */
0: 	protected boolean value;
0: 	protected boolean isnull;
0: 	protected boolean immutable;
0: }
============================================================================