1:eac0369: /*
29:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.catalog.TabInfoImpl
1:345de35: 
1:f739ad1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f739ad1:    contributor license agreements.  See the NOTICE file distributed with
1:f739ad1:    this work for additional information regarding copyright ownership.
1:f739ad1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f739ad1:    (the "License"); you may not use this file except in compliance with
1:f739ad1:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
29:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.catalog;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.io.StreamStorable;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.CatalogRowFactory;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.ExecRow;
1:eac0369: import org.apache.derby.iapi.sql.execute.RowChanger;
1:eac0369: import org.apache.derby.iapi.sql.execute.TupleFilter;
1:eac0369: import org.apache.derby.iapi.sql.Activation;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.ScanController;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: import java.util.Properties;
1:eac0369: 
29:eac0369: /**
1:eac0369: * A poor mans structure used in DataDictionaryImpl.java.
1:eac0369: * Used to save heapId, name pairs for non core tables.
17:eac0369: *
1:eac0369: */
1:8d26d28: class TabInfoImpl
16:eac0369: {
1:8d26d28:     /**
1:8d26d28:      * ROWNOTDUPLICATE is out of range for a row
1:8d26d28:      * number.  If a return code does not equal
1:8d26d28:      * this value, then it refers to the row
1:8d26d28:      * that is a duplicate.
1:8d26d28:      */
1:8d26d28:     static  final   int     ROWNOTDUPLICATE = -1;
1:8d26d28: 
1:eac0369: 	private IndexInfoImpl[]				indexes;
1:eac0369: 	private long						heapConglomerate;
1:eac0369: 	private int							numIndexesSet;
1:eac0369: 	private boolean						heapSet;
1:f7e090f: 	private final CatalogRowFactory			crf;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Constructor
1:eac0369: 	 *
1:eac0369: 	 * @param crf				the associated CatalogRowFactory
1:eac0369: 	 */
1:5e3e7ba: 	TabInfoImpl(CatalogRowFactory crf)
1:eac0369: 	{
1:eac0369: 		this.heapConglomerate = -1;
1:eac0369: 		this.crf = crf;
1:eac0369: 
1:eac0369: 		int numIndexes = crf.getNumIndexes();
1:eac0369: 
1:eac0369: 		if (numIndexes > 0)
1:eac0369: 		{
1:eac0369: 			indexes = new IndexInfoImpl[numIndexes];
1:eac0369: 
1:eac0369: 			/* Init indexes */
1:eac0369: 			for (int indexCtr = 0; indexCtr < numIndexes; indexCtr++)
1:eac0369: 			{
1:eac0369: 				indexes[indexCtr] = new IndexInfoImpl(
1:eac0369: 											indexCtr,
1:eac0369: 											crf);
16:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Get the conglomerate for the heap.
1:8d26d28:      *
1:8d26d28:      * @return long     The conglomerate for the heap.
1:8d26d28:      */
1:8d26d28: 	long getHeapConglomerate()
1:eac0369: 	{
1:eac0369: 		return heapConglomerate;
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Set the heap conglomerate for this.
1:8d26d28:      *
1:8d26d28:      * @param heapConglomerate  The new heap conglomerate.
1:8d26d28:      */
1:8d26d28: 	void setHeapConglomerate(long heapConglomerate)
1:eac0369: 	{
1:eac0369: 		this.heapConglomerate = heapConglomerate;
1:eac0369: 		heapSet = true;
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Get the conglomerate for the specified index.
1:8d26d28:      *
1:8d26d28:      * @return long     The conglomerate for the specified index.
1:8d26d28:      */
1:8d26d28: 	long getIndexConglomerate(int indexID)
1:eac0369: 	{
4:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
3:eac0369: 			SanityManager.ASSERT(indexes != null,
3:eac0369: 				"indexes is expected to be non-null");
2:eac0369:             if (indexID >= indexes.length)
1:eac0369:             {
2:eac0369:                 SanityManager.THROWASSERT(
2:eac0369:                     "indexID (" + indexID + ") is out of range(0-" +
3:eac0369:                     indexes.length + ")");
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return indexes[indexID].getConglomerateNumber();
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Set the index conglomerate for the table.
1:8d26d28:      *
1:8d26d28:      * @param index             Index number for index for table
1:8d26d28:      * @param indexConglomerate The conglomerate for that index
1:8d26d28:      */
1:8d26d28: 	void setIndexConglomerate(int index, long indexConglomerate)
1:eac0369: 	{
1:eac0369: 		/* Index names must be set before conglomerates.
1:eac0369: 		 * Also verify that we are not setting the same conglomerate
1:eac0369: 		 * twice.
1:eac0369: 		 */
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(indexes[index] != null,
1:eac0369: 				"indexes[index] expected to be non-null");
1:eac0369: 			SanityManager.ASSERT(indexes[index].getConglomerateNumber() == -1,
1:eac0369: 				"indexes[index] expected to be -1");
1:eac0369: 		}
1:eac0369: 		indexes[index].setConglomerateNumber(indexConglomerate);
1:eac0369: 
1:eac0369: 		/* We are completely initialized when all indexes have 
1:eac0369: 		 * their conglomerates initialized 
1:eac0369: 		 */
1:eac0369: 		numIndexesSet++;
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Set the index conglomerate for the table.
1:8d26d28:      *
1:8d26d28:      * @param cd    The ConglomerateDescriptor for one of the index
1:8d26d28:      *              for this table.
1:8d26d28:      */
1:8d26d28:     void setIndexConglomerate(ConglomerateDescriptor cd)
1:eac0369: 	{
1:eac0369: 		int		index;
1:eac0369: 		String	indexName = cd.getConglomerateName();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(indexes != null,
1:eac0369: 				"indexes is expected to be non-null");
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for (index = 0; index < indexes.length; index++)
1:eac0369: 		{
1:eac0369: 			/* All index names expected to be set before
1:eac0369: 			 * any conglomerate is set.
1:eac0369: 			 */
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(indexes[index] != null,
1:eac0369: 					"indexes[index] expected to be non-null");
1:eac0369: 				SanityManager.ASSERT(indexes[index].getIndexName() != null,
1:eac0369: 					"indexes[index].getIndexName() expected to be non-null");
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/* Do we have a match? */
1:eac0369: 			if (indexes[index].getIndexName().equals(indexName))
1:eac0369: 			{
1:eac0369: 				indexes[index].setConglomerateNumber(cd.getConglomerateNumber());
1:eac0369: 				break;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (index == indexes.length)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("match not found for " + indexName);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* We are completely initialized when all indexIds are initialized */
1:eac0369: 		numIndexesSet++;
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Get the table name.
1:8d26d28:      *
1:8d26d28:      * @return String   The table name.
1:8d26d28:      */
1:8d26d28: 	String getTableName()
1:eac0369: 	{
1:f7e090f: 		return crf.getCatalogName();
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Get the index name.
1:8d26d28:      *
1:e47d643:      * @param indexId   Index number for index for table
1:8d26d28:      *
1:8d26d28:      * @return String   The index name.
1:8d26d28:      */
1:8d26d28: 	String getIndexName(int indexId)
1:eac0369: 	{
1:eac0369: 		return indexes[indexId].getIndexName();
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /** 
1:8d26d28:      * Get the CatalogRowFactory for this.
1:8d26d28:      *
1:8d26d28:      * @return CatalogRowFactory    The CatalogRowFactory for this.
1:8d26d28:      */
1:8d26d28: 	CatalogRowFactory getCatalogRowFactory()
1:eac0369: 	{
1:eac0369: 		return crf;
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Is this fully initialized.  
1:8d26d28:      * (i.e., is all conglomerate info initialized)
1:8d26d28:      *
1:8d26d28:      * @return boolean  Whether or not this is fully initialized.
1:8d26d28:      */
1:8d26d28: 	boolean isComplete()
1:eac0369: 	{
1:eac0369: 		/* We are complete when heap conglomerate and all
1:eac0369: 		 * index conglomerates are set.
1:eac0369: 		 */
1:eac0369: 		if (! heapSet)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		return (indexes == null ||	indexes.length == numIndexesSet);
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Get the column count for the specified index number.
1:8d26d28:      *
1:8d26d28:      * @param indexNumber   The index number.
1:8d26d28:      *
1:8d26d28:      * @return int          The column count for the specified index.
1:8d26d28:      */
1:8d26d28: 	int getIndexColumnCount(int indexNumber)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(indexes != null,
1:eac0369: 				"indexes is expected to be non-null");
1:eac0369: 
1:eac0369: 			if (!(indexNumber < indexes.length))
1:eac0369: 			{
2:eac0369: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
1:eac0369: 				indexes.length + ")");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return indexes[indexNumber].getColumnCount();
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Get the IndexRowGenerator for the specified index number.
1:8d26d28:      *
1:8d26d28:      * @param indexNumber   The index number.
1:8d26d28:      *
1:8d26d28:      * @return IndexRowGenerator    The IRG for the specified index number.
1:8d26d28:      */
1:8d26d28: 	IndexRowGenerator getIndexRowGenerator(int indexNumber)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(indexes != null,
1:eac0369: 				"indexes is expected to be non-null");
2:eac0369:             if (indexNumber >= indexes.length)
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "indexNumber (" + indexNumber + ") is out of range(0-" +
1:eac0369:                     indexes.length + ")");
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 		return indexes[indexNumber].getIndexRowGenerator();
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Set the IndexRowGenerator for the specified index number.
1:8d26d28:      *
1:8d26d28:      * @param indexNumber   The index number.
1:8d26d28:      * @param irg           The IndexRowGenerator for the specified index number.
1:8d26d28:      */
1:8d26d28: 	void setIndexRowGenerator(int indexNumber, IndexRowGenerator irg)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(indexes != null,
1:eac0369: 				"indexes is expected to be non-null");
1:eac0369:             if (indexNumber >= indexes.length)
1:eac0369:             {
1:eac0369:                 SanityManager.THROWASSERT(
1:eac0369:                     "indexNumber (" + indexNumber + ") is out of range(0-" +
1:eac0369:                     indexes.length + ")");
1:eac0369:             }
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		indexes[indexNumber].setIndexRowGenerator(irg);
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /** 
1:8d26d28:      * Get the number of indexes on this catalog.
1:8d26d28:      *
1:8d26d28:      * @return int  The number of indexes on this catalog.
1:8d26d28:      */
1:8d26d28: 	int getNumberOfIndexes()
1:eac0369: 	{
1:eac0369: 		if (indexes == null)
1:eac0369: 		{
1:eac0369: 			return 0;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return indexes.length;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Get the base column position for a column within a catalog
1:8d26d28:      * given the (0-based) index number for this catalog and the
1:8d26d28:      * (0-based) column number for the column within the index.
1:8d26d28:      *
1:8d26d28:      * @param indexNumber   The index number
1:8d26d28:      * @param colNumber     The column number within the index
1:8d26d28:      *
1:8d26d28:      * @return int      The base column position for the column.
1:8d26d28:      */
1:8d26d28: 	int getBaseColumnPosition(int indexNumber, int colNumber)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(indexes != null,
1:eac0369: 				"indexes is expected to be non-null");
1:eac0369: 			if (indexNumber >= indexes.length)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
1:eac0369: 					indexes.length + ")");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return indexes[indexNumber].getBaseColumnPosition(colNumber);
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:      * Return whether or not this index is declared unique
1:8d26d28:      *
1:8d26d28:      * @param indexNumber   The index number
1:8d26d28:      *
1:8d26d28:      * @return boolean      Whether or not this index is declared unique
1:8d26d28:      */
1:8d26d28: 	boolean isIndexUnique(int indexNumber)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(indexes != null,
1:eac0369: 				"indexes is expected to be non-null");
1:eac0369: 
1:eac0369: 			if (indexNumber >= indexes.length)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
1:eac0369: 					indexes.length + ")");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return indexes[indexNumber].isIndexUnique();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	 * Inserts a base row into a catalog and inserts all the corresponding
4:eac0369: 	 * index rows.
1:eac0369: 	 *
2:eac0369: 	 *	@param	row			row to insert
1:eac0369: 	 *	@param	tc			transaction
1:dbed020: 	 *	@return	row number (&gt;= 0) if duplicate row inserted into an index
3:eac0369: 	 *			ROWNOTDUPLICATE otherwise
1:eac0369: 	 *
11:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:8106edc: 	int insertRow( ExecRow row, TransactionController tc)
8:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		RowLocation[] 			notUsed = new RowLocation[1]; 
1:eac0369: 
1:8106edc: 		return insertRowListImpl(new ExecRow[] {row},tc,notUsed);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	 * Inserts a list of base rows into a catalog and inserts all the corresponding
1:eac0369: 	 * index rows.
1:eac0369: 	 *
2:eac0369: 	 *	@param	rowList		List of rows to insert
3:eac0369: 	 *	@param	tc			transaction controller
1:eac0369: 	 *
1:eac0369: 	 *
1:dbed020: 	 *	@return	row  number (&gt;= 0) if duplicate row inserted into an index
1:eac0369: 	 *			ROWNOTDUPLICATE otherwise
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:8d26d28: 	int insertRowList(ExecRow[] rowList, TransactionController tc )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		RowLocation[] 			notUsed = new RowLocation[1]; 
1:eac0369: 
1:8106edc: 		return insertRowListImpl(rowList,tc,notUsed);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Insert logic to insert a list of rows into a table. This logic has two
1:8d26d28: 	  odd features.
1:eac0369: 
1:eac0369: 	  <OL>
1:eac0369: 	  <LI>Returns an indication if any returned row was a duplicate.
1:eac0369: 	  <LI>Returns the RowLocation of the last row inserted.
1:eac0369: 	  </OL>
1:eac0369: 	  @param rowList the list of rows to insert
1:eac0369: 	  @param tc	transaction controller
1:eac0369: 	  @param rowLocationOut on output rowLocationOut[0] is set to the
1:eac0369: 	         last RowLocation inserted.
1:dbed020: 	  @return row number (&gt;= 0) if duplicate row inserted into an index
1:eac0369: 	  			ROWNOTDUPLICATE otherwise
1:eac0369: 	 */
1:8106edc: 	private int insertRowListImpl(ExecRow[] rowList, TransactionController tc,
1:8106edc:                                   RowLocation[] rowLocationOut)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ConglomerateController		heapController;
1:eac0369: 		RowLocation					heapLocation;
1:eac0369: 		ExecIndexRow				indexableRow;
1:eac0369: 		int							insertRetCode;
1:eac0369: 		int							retCode = ROWNOTDUPLICATE;
1:eac0369: 		int							indexCount = crf.getNumIndexes();
1:eac0369: 		ConglomerateController[]	indexControllers = new ConglomerateController[ indexCount ];
1:eac0369: 
1:eac0369: 		// Open the conglomerates
1:eac0369: 		heapController = 
1:eac0369:             tc.openConglomerate(
2:eac0369:                 getHeapConglomerate(), 
2:eac0369:                 false,
1:a921552: 				TransactionController.OPENMODE_FORUPDATE,
1:eac0369:                 TransactionController.MODE_RECORD,
2:eac0369:                 TransactionController.ISOLATION_REPEATABLE_READ);
1:eac0369: 		
1:eac0369: 		/* NOTE: Due to the lovely problem of trying to add
1:eac0369: 		 * a new column to syscolumns and an index on that
1:eac0369: 		 * column during upgrade, we have to deal with the
1:eac0369: 		 * issue of the index not existing yet.  So, it's okay
1:eac0369: 		 * if the index doesn't exist yet.  (It will magically
1:eac0369: 		 * get created at a later point during upgrade.)
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		for ( int ictr = 0; ictr < indexCount; ictr++ )
1:eac0369: 		{
1:eac0369: 			long conglomNumber = getIndexConglomerate(ictr);
1:eac0369: 			if (conglomNumber > -1)
1:eac0369: 			{
1:eac0369: 				indexControllers[ ictr ] = 
1:eac0369: 		            tc.openConglomerate( 
1:eac0369: 			            conglomNumber, 
1:eac0369:                         false,
1:8106edc: 						TransactionController.OPENMODE_FORUPDATE,
1:eac0369: 					    TransactionController.MODE_RECORD,
1:eac0369: 						TransactionController.ISOLATION_REPEATABLE_READ);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		heapLocation = heapController.newRowLocationTemplate();
1:eac0369: 		rowLocationOut[0]=heapLocation;
1:eac0369: 
1:eac0369: 		// loop through rows on this list, inserting them into system table
1:867a530: 		for (int rowNumber = 0; rowNumber < rowList.length; rowNumber++)
1:eac0369: 		{
1:867a530: 			ExecRow row = rowList[rowNumber];
1:eac0369: 			// insert the base row and get its new location 
1:eac0369: 			heapController.insertAndFetchLocation(row.getRowArray(), heapLocation);
1:eac0369: 			
1:eac0369: 			for ( int ictr = 0; ictr < indexCount; ictr++ )
1:eac0369: 		    {
1:eac0369: 				if (indexControllers[ ictr ] == null)
1:eac0369: 				{
1:eac0369: 					continue;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				// Get an index row based on the base row
1:eac0369: 				indexableRow = getIndexRowFromHeapRow( getIndexRowGenerator(ictr),
1:eac0369: 													   heapLocation,
1:eac0369: 													   row );
1:eac0369: 
1:0c5bc3a:                 insertRetCode = indexControllers[ ictr ].insert(
1:0c5bc3a:                         indexableRow.getRowArray());
1:eac0369: 
1:eac0369: 				if ( insertRetCode == ConglomerateController.ROWISDUPLICATE )
1:eac0369: 				{
1:eac0369: 					retCode = rowNumber;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}	// end loop through rows on list
1:eac0369: 
1:eac0369: 		// Close the open conglomerates
1:eac0369: 		for ( int ictr = 0; ictr < indexCount; ictr++ )
1:eac0369: 		{
1:eac0369: 			if (indexControllers[ ictr ] == null)
1:eac0369: 			{
1:eac0369: 				continue;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			indexControllers[ ictr ].close();
1:eac0369: 		}
1:eac0369: 		heapController.close();
1:eac0369: 
1:eac0369: 		return	retCode;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:       * Given a key row, delete all matching heap rows and their index
1:8d26d28:       * rows.
1:8d26d28:       * <p>
1:8d26d28:       * LOCKING: row locking if there is a key; otherwise, 
1:8d26d28:       * table locking.
1:8d26d28:       *
1:8d26d28:       * @param  tc          transaction controller
1:8d26d28:       * @param  key         key to delete by.
1:8d26d28:       * @param  indexNumber Key is appropriate for this index.
1:8d26d28:       * @return the number of rows deleted. If key is not unique,
1:8d26d28:       *         this may be more than one.
1:8d26d28:       * @exception StandardException        Thrown on failure
1:8d26d28:       */
1:8d26d28: 	int deleteRow( TransactionController tc, ExecIndexRow key, int indexNumber )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		// Always row locking
1:eac0369: 		return  deleteRows(tc,
1:eac0369: 						   key,
1:eac0369: 						   ScanController.GE,
1:eac0369: 						   null,
1:eac0369: 						   null,
1:eac0369: 						   key,
1:eac0369: 						   ScanController.GT,
1:3d7a3d4: 						   indexNumber,
1:3d7a3d4: 						   true);
1:eac0369: 	}
1:eac0369: 
1:8d26d28: 	int deleteRow( TransactionController tc, ExecIndexRow key,
1:3d7a3d4: 							int indexNumber, boolean wait)
1:3d7a3d4: 		throws StandardException
1:3d7a3d4: 	{
1:3d7a3d4: 		//  Always row locking
1:3d7a3d4: 		return  deleteRows(tc,
1:3d7a3d4: 						   key,
1:3d7a3d4: 						   ScanController.GE,
1:3d7a3d4: 						   null,
1:3d7a3d4: 						   null,
1:3d7a3d4: 						   key,
1:3d7a3d4: 						   ScanController.GT,
1:3d7a3d4: 						   indexNumber,
1:3d7a3d4: 						   wait);
1:3d7a3d4: 	}
1:3d7a3d4: 	
1:8d26d28:     /**
1:8d26d28:       * Delete the set of rows defined by a scan on an index
1:8d26d28:       * from the table. Most of the parameters are simply passed
1:8d26d28:       * to TransactionController.openScan. Please refer to the
1:8d26d28:       * TransactionController documentation for details.
1:8d26d28:       * <p>
1:8d26d28:       * LOCKING: row locking if there is a start and a stop
1:8d26d28:       * key; otherwise, table locking
1:8d26d28:       *
1:8d26d28:       * @param  tc          transaction controller
1:8d26d28:       * @param  startKey    key to start the scan.
1:8d26d28:       * @param  startOp     operation to start the scan.
1:8d26d28:       * @param  stopKey     key to start the scan.
1:8d26d28:       * @param  qualifier   a qualifier for the scan.
1:8d26d28:       * @param  filter      filter on base rows
1:8d26d28:       * @param  stopOp      operation to start the scan.
1:8d26d28:       * @param  indexNumber Key is appropriate for this index.
1:8d26d28:       * @return the number of rows deleted.
1:8d26d28:       * @exception StandardException        Thrown on failure
1:8d26d28:       * @see TransactionController#openScan
1:8d26d28:       */
1:8d26d28: 	int deleteRows(TransactionController tc,
1:3d7a3d4: 							ExecIndexRow startKey,
1:3d7a3d4: 							int startOp,
1:3d7a3d4: 							Qualifier[][] qualifier,
1:3d7a3d4: 							TupleFilter filter,
1:3d7a3d4: 							ExecIndexRow stopKey,
1:3d7a3d4: 							int stopOp,
1:3d7a3d4: 							int indexNumber) throws StandardException
1:3d7a3d4:     {
1:3d7a3d4: 		return  deleteRows(tc,
1:3d7a3d4: 				   startKey,
1:3d7a3d4: 				   startOp,
1:3d7a3d4: 				   qualifier,
1:3d7a3d4: 				   filter,
1:3d7a3d4: 				   stopKey,
1:3d7a3d4: 				   stopOp,
1:3d7a3d4: 				   indexNumber,
1:3d7a3d4: 				   true);
1:3d7a3d4:     }
1:3d7a3d4: 
1:3d7a3d4: 	/**
1:3d7a3d4: 	 * @inheritDoc
1:3d7a3d4: 	 */
1:8d26d28: 	private int deleteRows(TransactionController tc,
1:eac0369: 						  ExecIndexRow startKey,
1:eac0369: 						  int startOp,
1:eac0369: 						  Qualifier[][] qualifier,
1:eac0369: 						  TupleFilter filter,
1:eac0369: 						  ExecIndexRow stopKey,
1:eac0369: 						  int stopOp,
1:3d7a3d4: 						  int indexNumber,
1:3d7a3d4: 						  boolean wait)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
2:eac0369: 		ConglomerateController		heapCC;
2:eac0369: 		ScanController				drivingScan;
1:eac0369: 		ExecIndexRow	 			drivingIndexRow;
2:eac0369: 		RowLocation					baseRowLocation;
2:eac0369: 		RowChanger 					rc;
2:eac0369: 		ExecRow						baseRow = crf.makeEmptyRow();
1:eac0369: 		int                         rowsDeleted = 0;
1:eac0369: 		boolean						passedFilter = true;
1:3d7a3d4: 		
2:eac0369: 		rc = getRowChanger( tc, (int[])null,baseRow );
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** If we have a start and a stop key, then we are going to 
1:eac0369: 		** get row locks, otherwise, we are getting table locks.
1:eac0369: 		** This may be excessive locking for the case where there
1:eac0369: 		** is a start key and no stop key or vice versa.
1:eac0369: 		*/
1:eac0369: 		int lockMode = ((startKey != null) && (stopKey != null)) ? 
1:8072e98:                 TransactionController.MODE_RECORD : 
1:8072e98:                 TransactionController.MODE_TABLE;
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Don't use level 3 if we have the same start/stop key.
1:eac0369: 		*/
1:eac0369: 		int isolation = 
1:eac0369:             ((startKey != null) && (stopKey != null) && (startKey == stopKey)) ?
1:eac0369: 				TransactionController.ISOLATION_REPEATABLE_READ :
1:eac0369: 				TransactionController.ISOLATION_SERIALIZABLE;
1:eac0369: 
1:eac0369: 		// Row level locking
1:3d7a3d4: 		rc.open(lockMode, wait);
1:eac0369: 
1:eac0369: 		DataValueDescriptor[] startKeyRow = 
1:eac0369:             startKey == null ? null : startKey.getRowArray();
1:eac0369: 
1:eac0369: 		DataValueDescriptor[] stopKeyRow = 
1:eac0369:             stopKey == null  ? null : stopKey.getRowArray();
1:eac0369: 
2:eac0369: 		/* Open the heap conglomerate */
2:eac0369: 		heapCC = tc.openConglomerate(
1:eac0369:                     getHeapConglomerate(),
1:eac0369:                     false,
1:3d7a3d4:                     (TransactionController.OPENMODE_FORUPDATE |
1:3d7a3d4:                             ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1:eac0369:                     lockMode,
1:eac0369:                     TransactionController.ISOLATION_REPEATABLE_READ);
1:eac0369: 
2:eac0369: 		drivingScan = tc.openScan(
1:eac0369: 			getIndexConglomerate(indexNumber),  // conglomerate to open
1:eac0369: 			false, // don't hold open across commit
1:3d7a3d4: 			(TransactionController.OPENMODE_FORUPDATE | 
1:3d7a3d4: 				((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1:eac0369:             lockMode,
1:eac0369: 			isolation,
2:eac0369: 			(FormatableBitSet) null, // all fields as objects
1:eac0369: 			startKeyRow,   // start position - first row
1:eac0369:             startOp,      // startSearchOperation
1:eac0369: 			qualifier, //scanQualifier
1:eac0369: 			stopKeyRow,   // stop position - through last row
1:eac0369:             stopOp);     // stopSearchOperation
1:eac0369: 
1:eac0369: 		// Get an index row based on the base row
1:eac0369: 		drivingIndexRow = getIndexRowFromHeapRow(
1:eac0369: 			getIndexRowGenerator( indexNumber ),
1:eac0369: 			heapCC.newRowLocationTemplate(),
1:eac0369: 			crf.makeEmptyRow());
1:eac0369: 
1:d3a4f64: 		while (drivingScan.fetchNext(drivingIndexRow.getRowArray()))
1:eac0369: 		{
1:eac0369: 			baseRowLocation = (RowLocation)
1:eac0369: 						drivingIndexRow.getColumn(drivingIndexRow.nColumns());
1:eac0369: 
2:eac0369: 			boolean base_row_exists = 
2:eac0369:                 heapCC.fetch(
2:eac0369:                     baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
2:eac0369:                 // it can not be possible for heap row to disappear while 
2:eac0369:                 // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
2:eac0369:                 SanityManager.ASSERT(base_row_exists, "base row not found");
1:eac0369:             }
1:eac0369: 
1:eac0369: 			// only delete rows which pass the base-row filter
1:eac0369: 			if ( filter != null ) { passedFilter = filter.execute( baseRow ).equals( true ); }
1:eac0369: 			if ( passedFilter )
1:eac0369: 			{
2:eac0369: 				rc.deleteRow( baseRow, baseRowLocation );
2:eac0369: 				rowsDeleted++;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
2:eac0369: 		heapCC.close();
2:eac0369: 		drivingScan.close();
2:eac0369: 		rc.close();
1:3d7a3d4: 		
2:eac0369: 		return rowsDeleted;
1:eac0369: 	}
1:eac0369: 
1:8d26d28:     /**
1:8d26d28:       * Given a key row, return the first matching heap row.
1:8d26d28:       * <p>
1:8d26d28:       * LOCKING: shared row locking.
1:8d26d28:       *
1:8d26d28:       * @param  tc          transaction controller
1:8d26d28:       * @param  key         key to read by.
1:8d26d28:       * @param  indexNumber Key is appropriate for this index.
1:8d26d28:       * @exception StandardException        Thrown on failure
1:8d26d28:       */
1:8d26d28: 	ExecRow getRow( TransactionController tc,
1:eac0369: 						ExecIndexRow key,
1:eac0369: 						int indexNumber )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ConglomerateController		heapCC;
1:eac0369: 
1:eac0369: 		/* Open the heap conglomerate */
1:eac0369: 		heapCC = tc.openConglomerate(
1:eac0369:                     getHeapConglomerate(),
1:eac0369:                     false,
1:eac0369:                     0, 						// for read only
1:eac0369:                     TransactionController.MODE_RECORD,
1:eac0369:                     TransactionController.ISOLATION_REPEATABLE_READ);
1:eac0369: 
1:eac0369: 		try { return getRow( tc, heapCC, key, indexNumber ); }
1:eac0369: 		finally { heapCC.close(); }
1:eac0369: 	}
1:eac0369: 
1:8d26d28: 	/**
1:eac0369: 	 * Given an index row and index number return the RowLocation
1:eac0369: 	 * in the heap of the first matching row.
1:eac0369: 	 * Used by the autoincrement code to get the RowLocation in
1:dbed020: 	 * syscolumns given a &lt;tablename, columname&gt; pair.
1:8d26d28: 	 * 
1:eac0369: 	 * @see DataDictionaryImpl#computeRowLocation(TransactionController, TableDescriptor, String)
1:eac0369: 	 *
1:eac0369: 	 * @param tc		  Transaction Controller to use.
1:eac0369: 	 * @param key		  Index Row to search in the index.
1:eac0369: 	 * @param indexNumber Identifies the index to use.
1:eac0369: 	 *
1:eac0369: 	 * @exception		  StandardException thrown on failure.
1:8d26d28: 	 */
1:8d26d28: 	RowLocation getRowLocation(TransactionController tc,
1:eac0369: 									  ExecIndexRow key,
2:eac0369: 									  int indexNumber)
1:eac0369: 			  throws StandardException
1:eac0369: 	{
1:eac0369: 		ConglomerateController		heapCC;
1:eac0369: 		heapCC = tc.openConglomerate(
1:eac0369:                     getHeapConglomerate(),
1:eac0369:                     false,
1:eac0369:                     0, 						// for read only
1:eac0369:                     TransactionController.MODE_RECORD,
1:eac0369:                     TransactionController.ISOLATION_REPEATABLE_READ);
1:eac0369: 
1:eac0369: 		try 
1:eac0369: 		{
1:eac0369: 			RowLocation rl[] = new RowLocation[1];
1:eac0369: 			ExecRow notUsed = getRowInternal(tc, heapCC, key, indexNumber, rl);
1:eac0369: 			return rl[0];
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			heapCC.close();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369:     /**
1:8d26d28:       * Given a key row, return the first matching heap row.
1:8d26d28:       * <p>
1:8d26d28:       * LOCKING: shared row locking.
1:eac0369:       *
1:8d26d28:       * @param  tc          transaction controller
1:e47d643:       * @param  heapCC      heap to look in
1:8d26d28:       * @param  key         key to read by.
1:8d26d28:       * @param  indexNumber Key is appropriate for this index.
1:8d26d28:       * @exception StandardException        Thrown on failure
1:eac0369:       */
1:8d26d28: 	ExecRow getRow( TransactionController tc,
1:eac0369: 						   ConglomerateController heapCC,
1:eac0369: 						   ExecIndexRow key,
1:eac0369: 						   int indexNumber)
1:eac0369: 							
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		RowLocation rl[] = new RowLocation[1];
1:eac0369: 		return getRowInternal(tc, heapCC, key, indexNumber, rl);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  * @exception StandardException		Thrown on failure
1:eac0369: 	  */
1:eac0369: 	private ExecRow getRowInternal( TransactionController tc,
1:eac0369: 									ConglomerateController heapCC,
1:eac0369: 									ExecIndexRow key,
1:eac0369: 									int indexNumber,
1:eac0369: 									RowLocation rl[])
1:eac0369: 
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		ScanController				drivingScan;
1:eac0369: 		ExecIndexRow	 			drivingIndexRow;
1:eac0369: 		RowLocation					baseRowLocation;
1:eac0369: 		ExecRow						baseRow = crf.makeEmptyRow();
1:eac0369: 
1:eac0369: 		drivingScan = tc.openScan(
1:eac0369: 			getIndexConglomerate(indexNumber),
1:eac0369: 			                     // conglomerate to open
1:eac0369: 			false,               // don't hold open across commit
1:eac0369: 			0,                   // open for read
1:eac0369:             TransactionController.MODE_RECORD,
2:eac0369:             TransactionController.ISOLATION_REPEATABLE_READ,
1:eac0369: 			(FormatableBitSet) null,      // all fields as objects
1:eac0369: 			key.getRowArray(),   // start position - first row
1:eac0369:             ScanController.GE,   // startSearchOperation
1:eac0369: 			null,                //scanQualifier
1:eac0369: 			key.getRowArray(),   // stop position - through last row
1:eac0369:             ScanController.GT);  // stopSearchOperation
1:eac0369: 
1:eac0369: 		// Get an index row based on the base row
1:eac0369: 		drivingIndexRow = getIndexRowFromHeapRow(
1:eac0369: 			getIndexRowGenerator( indexNumber ),
1:eac0369: 			heapCC.newRowLocationTemplate(),
1:eac0369: 			crf.makeEmptyRow());
1:eac0369: 
1:eac0369: 		try	{
1:d3a4f64: 			if (drivingScan.fetchNext(drivingIndexRow.getRowArray()))
1:eac0369: 			{
1:eac0369: 				rl[0] = baseRowLocation = (RowLocation)
1:eac0369: 					drivingIndexRow.getColumn(drivingIndexRow.nColumns());
1:eac0369: 				boolean base_row_exists = 
1:eac0369:                     heapCC.fetch(
1:eac0369:                         baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
1:eac0369: 
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     // it can not be possible for heap row to disappear while 
1:eac0369:                     // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
1:eac0369:                     SanityManager.ASSERT(base_row_exists, "base row not found");
1:eac0369:                 }
1:eac0369: 
1:eac0369: 				return baseRow;
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				return null;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		finally {
1:eac0369: 			drivingScan.close();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	 * Updates a base row in a catalog and updates all the corresponding
1:eac0369: 	 * index rows.
1:eac0369: 	 *
3:eac0369: 	 *	@param	key			key row
2:eac0369: 	 *	@param	newRow		new version of the row
3:eac0369: 	 *	@param	indexNumber	index that key operates
3:eac0369: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
3:eac0369: 	 *							if a boolean is true, that means we must update the
3:eac0369: 	 *							corresponding index because changes in the newRow
3:eac0369: 	 *							affect it.
3:eac0369: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
3:eac0369: 	 *							to update.  If null, do all.
1:eac0369: 	 *	@param	tc			transaction controller
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:8d26d28: 	void updateRow( ExecIndexRow				key, 
2:eac0369: 						   ExecRow					newRow, 
3:eac0369: 						   int						indexNumber,
3:eac0369: 						   boolean[]				indicesToUpdate,
3:eac0369: 						   int[]					colsToUpdate,
1:8106edc: 						   TransactionController	tc)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecRow[] newRows = new ExecRow[1];
1:eac0369: 		newRows[0] = newRow;
1:a921552: 		updateRow(key, newRows, indexNumber, indicesToUpdate, colsToUpdate, tc);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	 * Updates a set of base rows in a catalog with the same key on an index
1:eac0369: 	 * and updates all the corresponding index rows. 
1:eac0369: 	 *
1:eac0369: 	 *	@param	key			key row
2:eac0369: 	 *	@param	newRows		new version of the array of rows
1:eac0369: 	 *	@param	indexNumber	index that key operates
1:eac0369: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
1:eac0369: 	 *							if a boolean is true, that means we must update the
1:eac0369: 	 *							corresponding index because changes in the newRow
1:eac0369: 	 *							affect it.
1:eac0369: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
1:eac0369: 	 *							to update.  If null, do all.
1:eac0369: 	 *	@param	tc			transaction controller
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on failure
1:eac0369: 	 */
1:8d26d28: 	void updateRow( ExecIndexRow				key,
2:eac0369: 						   ExecRow[]				newRows,
1:eac0369: 						   int						indexNumber,
1:eac0369: 						   boolean[]				indicesToUpdate,
1:eac0369: 						   int[]					colsToUpdate,
2:eac0369: 						   TransactionController	tc )
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ConglomerateController		heapCC;
1:eac0369: 		ScanController				drivingScan;
1:eac0369: 		ExecIndexRow	 			drivingIndexRow;
1:eac0369: 		RowLocation					baseRowLocation;
1:eac0369: 		ExecRow						baseRow = crf.makeEmptyRow();
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT( indicesToUpdate.length == crf.getNumIndexes(),
1:eac0369: 								 "Wrong number of indices." );
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		RowChanger 					rc  = getRowChanger( tc, colsToUpdate,baseRow );
1:eac0369: 
1:eac0369: 		// Row level locking
1:a921552: 		rc.openForUpdate(indicesToUpdate, TransactionController.MODE_RECORD, true);
1:eac0369: 
1:eac0369: 		/* Open the heap conglomerate */
1:eac0369: 		heapCC = tc.openConglomerate(
1:eac0369:                     getHeapConglomerate(),
1:eac0369:                     false,
1:a921552:                     TransactionController.OPENMODE_FORUPDATE,
1:eac0369:                     TransactionController.MODE_RECORD,
1:eac0369:                     TransactionController.ISOLATION_REPEATABLE_READ);
1:eac0369: 
1:eac0369: 		drivingScan = tc.openScan(
1:eac0369: 			getIndexConglomerate(indexNumber),  // conglomerate to open
1:eac0369: 			false, // don't hold open across commit
1:8106edc: 			TransactionController.OPENMODE_FORUPDATE,
1:eac0369:             TransactionController.MODE_RECORD,
1:eac0369:             TransactionController.ISOLATION_REPEATABLE_READ,
1:eac0369: 			(FormatableBitSet) null,     // all fields as objects
1:eac0369: 			key.getRowArray(),   // start position - first row
1:eac0369:             ScanController.GE,      // startSearchOperation
1:eac0369: 			null, //scanQualifier
1:eac0369: 			key.getRowArray(),   // stop position - through last row
1:eac0369:             ScanController.GT);     // stopSearchOperation
1:eac0369: 
1:eac0369: 		// Get an index row based on the base row
1:eac0369: 		drivingIndexRow = getIndexRowFromHeapRow(
1:eac0369: 			getIndexRowGenerator( indexNumber ),
1:eac0369: 			heapCC.newRowLocationTemplate(),
1:eac0369: 			crf.makeEmptyRow());
1:eac0369: 
1:eac0369: 		int rowNum = 0;
1:d3a4f64: 		while (drivingScan.fetchNext(drivingIndexRow.getRowArray()))
1:eac0369: 		{
1:eac0369: 			baseRowLocation = (RowLocation)
1:eac0369: 						drivingIndexRow.getColumn(drivingIndexRow.nColumns());
1:eac0369: 			boolean base_row_exists = 
1:eac0369:                 heapCC.fetch(
1:eac0369:                     baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 // it can not be possible for heap row to disappear while 
1:eac0369:                 // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
1:eac0369:                 SanityManager.ASSERT(base_row_exists, "base row not found");
1:eac0369:             }
1:eac0369: 			
1:eac0369: 			rc.updateRow(baseRow, (rowNum == newRows.length - 1) ?
1:eac0369: 						newRows[rowNum] : newRows[rowNum++], baseRowLocation );
1:eac0369: 		}
1:eac0369: 		rc.finish();
1:eac0369: 		heapCC.close();
1:eac0369: 		drivingScan.close();
1:eac0369: 		rc.close();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Properties associated with creating the heap.
1:eac0369: 	 *
1:eac0369: 	 * @return The Properties associated with creating the heap.
1:eac0369: 	 */
1:8d26d28: 	Properties getCreateHeapProperties()
1:eac0369: 	{
1:eac0369: 		return crf.getCreateHeapProperties();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the Properties associated with creating the specified index.
1:eac0369: 	 *
1:eac0369: 	 * @param indexNumber	The specified index number.
1:eac0369: 	 *
1:eac0369: 	 * @return The Properties associated with creating the specified index.
1:eac0369: 	 */
1:8d26d28: 	Properties getCreateIndexProperties(int indexNumber)
1:eac0369: 	{
1:eac0369: 		return crf.getCreateIndexProperties(indexNumber);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  *	Gets a row changer for this catalog.
1:eac0369: 	  *
1:eac0369: 	  *	@param	tc	transaction controller
1:eac0369: 	  *	@param	changedCols	the columns to change (1 based), may be null
1:eac0369: 	  * @param  baseRow used to detemine column types at creation time
1:eac0369: 	  *         only. The row changer does ***Not*** keep a referance to
1:eac0369: 	  *         this row or change it in any way.
1:eac0369: 	  *
1:eac0369: 	  *	@return	a row changer for this catalog.
1:eac0369: 	  * @exception StandardException		Thrown on failure
1:eac0369: 	  */
1:eac0369: 	private	RowChanger	getRowChanger( TransactionController tc,
1:eac0369: 									   int[] changedCols,
1:eac0369: 									   ExecRow baseRow)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		RowChanger 					rc;
1:eac0369: 		int							indexCount = crf.getNumIndexes();
1:eac0369: 		IndexRowGenerator[]			irgs = new IndexRowGenerator[ indexCount ];
1:eac0369: 		long[]						cids = new long[ indexCount ];
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			if (changedCols != null)
1:eac0369: 			{
1:eac0369: 				for (int i = changedCols.length - 1; i >= 0; i--)
1:eac0369: 				{
1:eac0369: 					SanityManager.ASSERT(changedCols[i] != 0, 
1:eac0369: 						"Column id is 0, but should be 1 based");
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		for ( int ictr = 0; ictr < indexCount; ictr++ )
1:eac0369: 		{
1:eac0369: 			irgs[ictr] = getIndexRowGenerator(ictr);
1:eac0369: 			cids[ictr] = getIndexConglomerate(ictr);
1:eac0369: 		}
1:eac0369: 
1:f7e090f: 		rc = crf.getExecutionFactory().getRowChanger(getHeapConglomerate(),
1:eac0369: 											(StaticCompiledOpenConglomInfo) null,
1:eac0369: 											(DynamicCompiledOpenConglomInfo) null,
1:eac0369: 											irgs,
1:eac0369: 											cids,
1:eac0369: 											(StaticCompiledOpenConglomInfo[]) null,
1:eac0369: 											(DynamicCompiledOpenConglomInfo[]) null,
1:eac0369: 											crf.getHeapColumnCount(),
1:eac0369: 											tc,
1:eac0369: 											changedCols,
1:eac0369: 											getStreamStorableHeapColIds(baseRow),
1:eac0369: 											(Activation) null);
1:eac0369: 		return	rc;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private boolean computedStreamStorableHeapColIds = false;
1:eac0369: 	private int[] streamStorableHeapColIds;
1:eac0369: 	private int[] getStreamStorableHeapColIds(ExecRow baseRow) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (!computedStreamStorableHeapColIds)
1:eac0369: 		{
1:eac0369: 			int sshcidLen = 0;
1:eac0369: 			//
1:eac0369: 			//Compute the length of streamStorableHeapColIds
1:eac0369: 			//One entry for each column id.
1:eac0369: 			DataValueDescriptor[] ra = baseRow.getRowArray();
1:eac0369: 			for(int ix=0;ix<ra.length;ix++)
1:eac0369: 				if (ra[ix] instanceof StreamStorable) sshcidLen++;
1:eac0369: 
1:eac0369: 			//
1:eac0369: 			//If we have some streamStorableHeapColIds we
1:eac0369: 			//allocate an array to remember them and fill in
1:eac0369: 			//the array with the 0 based column ids. If we
1:eac0369: 			//have none leave streamStorableHeapColIds Null.
1:eac0369: 			if (sshcidLen > 0)
1:eac0369: 			{
1:eac0369: 				streamStorableHeapColIds = new int[sshcidLen];
1:eac0369: 				int sshcidOffset=0;
1:eac0369: 				for(int ix=0;ix<ra.length;ix++)
1:eac0369: 					if (ra[ix] instanceof StreamStorable)
1:eac0369:  						streamStorableHeapColIds[sshcidOffset++] = ix;
1:eac0369: 			}
1:eac0369: 			computedStreamStorableHeapColIds = true;
1:eac0369: 		}
1:eac0369: 		return streamStorableHeapColIds;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get an index row based on a row from the heap.
1:eac0369: 	 *
1:eac0369: 	 * @param irg		IndexRowGenerator to use
1:eac0369: 	 * @param rl		RowLocation for heap
1:eac0369: 	 * @param heapRow	Row from the heap
1:eac0369: 	 *
1:eac0369: 	 * @return ExecIndexRow	Index row.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	private ExecIndexRow getIndexRowFromHeapRow(IndexRowGenerator irg,
1:eac0369: 								   RowLocation rl,
1:eac0369: 								   ExecRow heapRow)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ExecIndexRow		indexRow;
1:eac0369: 
1:eac0369: 		indexRow = irg.getIndexRowTemplate();
1:eac0369: 		// Get an index row based on the base row
1:eac0369: 		irg.getIndexRow(heapRow, rl, indexRow, (FormatableBitSet) null);
1:eac0369: 
1:eac0369: 		return indexRow;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:f7e090f: 			return "name: " + this.getTableName() + 
1:eac0369: 				"\n\theapCongolomerate: "+heapConglomerate +
1:eac0369: 				"\n\tnumIndexes: " + ((indexes != null) ? indexes.length : 0) +
1:eac0369: 				"\n\tnumIndexesSet: " + numIndexesSet +
1:eac0369: 				"\n\theapSet: " + heapSet +
1:f7e090f: 				"\n"; 
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 *	@return	row number (&gt;= 0) if duplicate row inserted into an index
/////////////////////////////////////////////////////////////////////////
1: 	 *	@return	row  number (&gt;= 0) if duplicate row inserted into an index
/////////////////////////////////////////////////////////////////////////
1: 	  @return row number (&gt;= 0) if duplicate row inserted into an index
/////////////////////////////////////////////////////////////////////////
1: 	 * syscolumns given a &lt;tablename, columname&gt; pair.
commit:3d7a3d4
/////////////////////////////////////////////////////////////////////////
1: 						   indexNumber,
1: 						   true);
0: 	public int deleteRow( TransactionController tc, ExecIndexRow key,
1: 							int indexNumber, boolean wait)
1: 		throws StandardException
1: 	{
1: 		//  Always row locking
1: 		return  deleteRows(tc,
1: 						   key,
1: 						   ScanController.GE,
1: 						   null,
1: 						   null,
1: 						   key,
1: 						   ScanController.GT,
1: 						   indexNumber,
1: 						   wait);
1: 	}
1: 	
/////////////////////////////////////////////////////////////////////////
1: 							ExecIndexRow startKey,
1: 							int startOp,
1: 							Qualifier[][] qualifier,
1: 							TupleFilter filter,
1: 							ExecIndexRow stopKey,
1: 							int stopOp,
1: 							int indexNumber) throws StandardException
1:     {
1: 		return  deleteRows(tc,
1: 				   startKey,
1: 				   startOp,
1: 				   qualifier,
1: 				   filter,
1: 				   stopKey,
1: 				   stopOp,
1: 				   indexNumber,
1: 				   true);
1:     }
1: 
1: 	/**
1: 	 * @inheritDoc
1: 	 */
0: 	public int deleteRows(TransactionController tc,
1: 						  int indexNumber,
1: 						  boolean wait)
/////////////////////////////////////////////////////////////////////////
1: 		
/////////////////////////////////////////////////////////////////////////
1: 		rc.open(lockMode, wait);
/////////////////////////////////////////////////////////////////////////
1:                     (TransactionController.OPENMODE_FORUPDATE |
1:                             ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1: 			(TransactionController.OPENMODE_FORUPDATE | 
1: 				((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
/////////////////////////////////////////////////////////////////////////
1: 		
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1:                 insertRetCode = indexControllers[ ictr ].insert(
1:                         indexableRow.getRowArray());
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:8072e98
/////////////////////////////////////////////////////////////////////////
1:                 TransactionController.MODE_RECORD : 
1:                 TransactionController.MODE_TABLE;
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a921552
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		updateRow(key, newRows, indexNumber, indicesToUpdate, colsToUpdate, tc);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		rc.openForUpdate(indicesToUpdate, TransactionController.MODE_RECORD, true);
1:                     TransactionController.OPENMODE_FORUPDATE,
1: 			TransactionController.OPENMODE_FORUPDATE,
commit:8106edc
/////////////////////////////////////////////////////////////////////////
1: 	int insertRow( ExecRow row, TransactionController tc)
1: 		return insertRowListImpl(new ExecRow[] {row},tc,notUsed);
/////////////////////////////////////////////////////////////////////////
1: 		return insertRowListImpl(rowList,tc,notUsed);
/////////////////////////////////////////////////////////////////////////
1: 	private int insertRowListImpl(ExecRow[] rowList, TransactionController tc,
1:                                   RowLocation[] rowLocationOut)
/////////////////////////////////////////////////////////////////////////
1: 				TransactionController.OPENMODE_FORUPDATE,
/////////////////////////////////////////////////////////////////////////
1: 						TransactionController.OPENMODE_FORUPDATE,
/////////////////////////////////////////////////////////////////////////
1: 						   TransactionController	tc)
0: 		updateRow(key, newRows, indexNumber, indicesToUpdate, colsToUpdate, tc, true);
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:e47d643
/////////////////////////////////////////////////////////////////////////
1:      * @param indexId   Index number for index for table
/////////////////////////////////////////////////////////////////////////
1:       * @param  heapCC      heap to look in
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:8d26d28
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: class TabInfoImpl
1:     /**
1:      * ROWNOTDUPLICATE is out of range for a row
1:      * number.  If a return code does not equal
1:      * this value, then it refers to the row
1:      * that is a duplicate.
1:      */
1:     static  final   int     ROWNOTDUPLICATE = -1;
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the conglomerate for the heap.
1:      *
1:      * @return long     The conglomerate for the heap.
1:      */
1: 	long getHeapConglomerate()
1:     /**
1:      * Set the heap conglomerate for this.
1:      *
1:      * @param heapConglomerate  The new heap conglomerate.
1:      */
1: 	void setHeapConglomerate(long heapConglomerate)
1:     /**
1:      * Get the conglomerate for the specified index.
1:      *
1:      * @return long     The conglomerate for the specified index.
1:      */
1: 	long getIndexConglomerate(int indexID)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set the index conglomerate for the table.
1:      *
1:      * @param index             Index number for index for table
1:      * @param indexConglomerate The conglomerate for that index
1:      */
1: 	void setIndexConglomerate(int index, long indexConglomerate)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set the index conglomerate for the table.
1:      *
1:      * @param cd    The ConglomerateDescriptor for one of the index
1:      *              for this table.
1:      */
1:     void setIndexConglomerate(ConglomerateDescriptor cd)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the table name.
1:      *
1:      * @return String   The table name.
1:      */
1: 	String getTableName()
1:     /**
1:      * Get the index name.
1:      *
0:      * @param indexID   Index number for index for table
1:      *
1:      * @return String   The index name.
1:      */
1: 	String getIndexName(int indexId)
1:     /** 
1:      * Get the CatalogRowFactory for this.
1:      *
1:      * @return CatalogRowFactory    The CatalogRowFactory for this.
1:      */
1: 	CatalogRowFactory getCatalogRowFactory()
1:     /**
1:      * Is this fully initialized.  
1:      * (i.e., is all conglomerate info initialized)
1:      *
1:      * @return boolean  Whether or not this is fully initialized.
1:      */
1: 	boolean isComplete()
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the column count for the specified index number.
1:      *
1:      * @param indexNumber   The index number.
1:      *
1:      * @return int          The column count for the specified index.
1:      */
1: 	int getIndexColumnCount(int indexNumber)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the IndexRowGenerator for the specified index number.
1:      *
1:      * @param indexNumber   The index number.
1:      *
1:      * @return IndexRowGenerator    The IRG for the specified index number.
1:      */
1: 	IndexRowGenerator getIndexRowGenerator(int indexNumber)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Set the IndexRowGenerator for the specified index number.
1:      *
1:      * @param indexNumber   The index number.
1:      * @param irg           The IndexRowGenerator for the specified index number.
1:      */
1: 	void setIndexRowGenerator(int indexNumber, IndexRowGenerator irg)
/////////////////////////////////////////////////////////////////////////
1:     /** 
1:      * Get the number of indexes on this catalog.
1:      *
1:      * @return int  The number of indexes on this catalog.
1:      */
1: 	int getNumberOfIndexes()
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the base column position for a column within a catalog
1:      * given the (0-based) index number for this catalog and the
1:      * (0-based) column number for the column within the index.
1:      *
1:      * @param indexNumber   The index number
1:      * @param colNumber     The column number within the index
1:      *
1:      * @return int      The base column position for the column.
1:      */
1: 	int getBaseColumnPosition(int indexNumber, int colNumber)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Return whether or not this index is declared unique
1:      *
1:      * @param indexNumber   The index number
1:      *
1:      * @return boolean      Whether or not this index is declared unique
1:      */
1: 	boolean isIndexUnique(int indexNumber)
/////////////////////////////////////////////////////////////////////////
0: 	int insertRow( ExecRow row, TransactionController tc, boolean wait)
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	int insertRowList(ExecRow[] rowList, TransactionController tc )
/////////////////////////////////////////////////////////////////////////
1: 	  odd features.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:       * Given a key row, delete all matching heap rows and their index
1:       * rows.
1:       * <p>
1:       * LOCKING: row locking if there is a key; otherwise, 
1:       * table locking.
1:       *
1:       * @param  tc          transaction controller
1:       * @param  key         key to delete by.
1:       * @param  indexNumber Key is appropriate for this index.
1:       * @return the number of rows deleted. If key is not unique,
1:       *         this may be more than one.
1:       * @exception StandardException        Thrown on failure
1:       */
1: 	int deleteRow( TransactionController tc, ExecIndexRow key, int indexNumber )
/////////////////////////////////////////////////////////////////////////
1: 	int deleteRow( TransactionController tc, ExecIndexRow key,
/////////////////////////////////////////////////////////////////////////
1:     /**
1:       * Delete the set of rows defined by a scan on an index
1:       * from the table. Most of the parameters are simply passed
1:       * to TransactionController.openScan. Please refer to the
1:       * TransactionController documentation for details.
1:       * <p>
1:       * LOCKING: row locking if there is a start and a stop
1:       * key; otherwise, table locking
1:       *
1:       * @param  tc          transaction controller
1:       * @param  startKey    key to start the scan.
1:       * @param  startOp     operation to start the scan.
1:       * @param  stopKey     key to start the scan.
1:       * @param  qualifier   a qualifier for the scan.
1:       * @param  filter      filter on base rows
1:       * @param  stopOp      operation to start the scan.
1:       * @param  indexNumber Key is appropriate for this index.
1:       * @return the number of rows deleted.
1:       * @exception StandardException        Thrown on failure
1:       * @see TransactionController#openScan
1:       */
1: 	int deleteRows(TransactionController tc,
/////////////////////////////////////////////////////////////////////////
1: 	private int deleteRows(TransactionController tc,
/////////////////////////////////////////////////////////////////////////
1:     /**
1:       * Given a key row, return the first matching heap row.
1:       * <p>
1:       * LOCKING: shared row locking.
1:       *
1:       * @param  tc          transaction controller
1:       * @param  key         key to read by.
1:       * @param  indexNumber Key is appropriate for this index.
1:       * @exception StandardException        Thrown on failure
1:       */
1: 	ExecRow getRow( TransactionController tc,
/////////////////////////////////////////////////////////////////////////
1: 	RowLocation getRowLocation(TransactionController tc,
/////////////////////////////////////////////////////////////////////////
1:     /**
1:       * Given a key row, return the first matching heap row.
1:       * <p>
1:       * LOCKING: shared row locking.
1:       *
1:       * @param  tc          transaction controller
0:       * @param  heap        heap to look in
1:       * @param  key         key to read by.
1:       * @param  indexNumber Key is appropriate for this index.
1:       * @exception StandardException        Thrown on failure
1:       */
1: 	ExecRow getRow( TransactionController tc,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	void updateRow( ExecIndexRow				key, 
/////////////////////////////////////////////////////////////////////////
1: 	void updateRow( ExecIndexRow				key, 
/////////////////////////////////////////////////////////////////////////
0: 	void updateRow( ExecIndexRow				key,
/////////////////////////////////////////////////////////////////////////
0: 	private void updateRow( ExecIndexRow				key,
/////////////////////////////////////////////////////////////////////////
1: 	Properties getCreateHeapProperties()
/////////////////////////////////////////////////////////////////////////
1: 	Properties getCreateIndexProperties(int indexNumber)
commit:f7e090f
/////////////////////////////////////////////////////////////////////////
1: 	private final CatalogRowFactory			crf;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		return crf.getCatalogName();
/////////////////////////////////////////////////////////////////////////
1: 		rc = crf.getExecutionFactory().getRowChanger(getHeapConglomerate(),
/////////////////////////////////////////////////////////////////////////
1: 			return "name: " + this.getTableName() + 
1: 				"\n"; 
commit:a7d7f12
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:5e3e7ba
/////////////////////////////////////////////////////////////////////////
0: class TabInfoImpl implements TabInfo
/////////////////////////////////////////////////////////////////////////
1: 	TabInfoImpl(CatalogRowFactory crf)
commit:d3a4f64
/////////////////////////////////////////////////////////////////////////
1: 		while (drivingScan.fetchNext(drivingIndexRow.getRowArray()))
/////////////////////////////////////////////////////////////////////////
1: 			if (drivingScan.fetchNext(drivingIndexRow.getRowArray()))
/////////////////////////////////////////////////////////////////////////
1: 		while (drivingScan.fetchNext(drivingIndexRow.getRowArray()))
commit:867a530
/////////////////////////////////////////////////////////////////////////
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		return insertRowListImpl(new ExecRow[] {row},tc,notUsed, wait);
/////////////////////////////////////////////////////////////////////////
0: 		return	insertRowList(new ExecRow[] {row}, lcc.getTransactionExecute());
/////////////////////////////////////////////////////////////////////////
0: 		insertRowListImpl(new ExecRow[] {row},tc,rowLocationOut, true);
/////////////////////////////////////////////////////////////////////////
0: 	public int insertRowList(ExecRow[] rowList, TransactionController tc )
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private int insertRowListImpl(ExecRow[] rowList, TransactionController tc, RowLocation[] rowLocationOut,
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		for (int rowNumber = 0; rowNumber < rowList.length; rowNumber++)
1: 			ExecRow row = rowList[rowNumber];
commit:6d698f7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private int insertRowList( RowList rowList, LanguageConnectionContext lcc )
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.catalog.TabInfoImpl
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.catalog
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.catalog;
1: 
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.StreamStorable;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.dictionary.CatalogRowFactory;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.RowList;
0: import org.apache.derby.iapi.sql.dictionary.TabInfo;
1: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
1: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
1: import org.apache.derby.iapi.sql.execute.RowChanger;
1: import org.apache.derby.iapi.sql.execute.TupleFilter;
1: import org.apache.derby.iapi.sql.Activation;
1: 
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.catalog.UUID;
0: import java.util.Enumeration;
1: import java.util.Properties;
1: 
1: /**
1: * A poor mans structure used in DataDictionaryImpl.java.
1: * Used to save heapId, name pairs for non core tables.
1: *
0: * @author jamie
1: */
0: public class TabInfoImpl implements TabInfo
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	private IndexInfoImpl[]				indexes;
0: 	private String						name;
1: 	private long						heapConglomerate;
1: 	private int							numIndexesSet;
1: 	private boolean						heapSet;
0: 	private UUID						uuid;
0: 	private CatalogRowFactory			crf;
1: 
0: 	private	ExecutionFactory			executionFactory;
1: 
1: 	/**
1: 	 * Constructor
1: 	 *
1: 	 * @param crf				the associated CatalogRowFactory
0: 	 * @param executionFactory	execution factory of the database
1: 	 */
0: 	public TabInfoImpl(CatalogRowFactory crf)
1: 	{
0: 		this.name = crf.getCatalogName();
1: 		this.heapConglomerate = -1;
1: 		this.crf = crf;
0: 		this.executionFactory = crf.getExecutionFactory();
1: 
1: 		int numIndexes = crf.getNumIndexes();
1: 
1: 		if (numIndexes > 0)
1: 		{
1: 			indexes = new IndexInfoImpl[numIndexes];
1: 
1: 			/* Init indexes */
1: 			for (int indexCtr = 0; indexCtr < numIndexes; indexCtr++)
1: 			{
1: 				indexes[indexCtr] = new IndexInfoImpl(
0: 											-1, 
0: 											crf.getIndexName(indexCtr),
0: 											crf.getIndexColumnCount(indexCtr),
0: 											crf.isIndexUnique(indexCtr),
1: 											indexCtr,
1: 											crf);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#getHeapConglomerate
1: 	 */
0: 	public long getHeapConglomerate()
1: 	{
1: 		return heapConglomerate;
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#setHeapConglomerate
1: 	 */
0: 	public void setHeapConglomerate(long heapConglomerate)
1: 	{
1: 		this.heapConglomerate = heapConglomerate;
1: 		heapSet = true;
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#getIndexConglomerate
1: 	 */
0: 	public long getIndexConglomerate(int indexID)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes != null,
1: 				"indexes is expected to be non-null");
1:             if (indexID >= indexes.length)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "indexID (" + indexID + ") is out of range(0-" +
1:                     indexes.length + ")");
1:             }
1: 		}
1: 
1: 		return indexes[indexID].getConglomerateNumber();
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#setIndexConglomerate
1: 	 */
0: 	public void setIndexConglomerate(int index, long indexConglomerate)
1: 	{
1: 		/* Index names must be set before conglomerates.
1: 		 * Also verify that we are not setting the same conglomerate
1: 		 * twice.
1: 		 */
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes[index] != null,
1: 				"indexes[index] expected to be non-null");
1: 			SanityManager.ASSERT(indexes[index].getConglomerateNumber() == -1,
1: 				"indexes[index] expected to be -1");
1: 		}
1: 		indexes[index].setConglomerateNumber(indexConglomerate);
1: 
1: 		/* We are completely initialized when all indexes have 
1: 		 * their conglomerates initialized 
1: 		 */
1: 		numIndexesSet++;
1: 	}
1: 
0: 	public void setIndexConglomerate(ConglomerateDescriptor cd)
1: 	{
1: 		int		index;
1: 		String	indexName = cd.getConglomerateName();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes != null,
1: 				"indexes is expected to be non-null");
1: 		}
1: 
1: 		for (index = 0; index < indexes.length; index++)
1: 		{
1: 			/* All index names expected to be set before
1: 			 * any conglomerate is set.
1: 			 */
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(indexes[index] != null,
1: 					"indexes[index] expected to be non-null");
1: 				SanityManager.ASSERT(indexes[index].getIndexName() != null,
1: 					"indexes[index].getIndexName() expected to be non-null");
1: 			}
1: 
1: 			/* Do we have a match? */
1: 			if (indexes[index].getIndexName().equals(indexName))
1: 			{
1: 				indexes[index].setConglomerateNumber(cd.getConglomerateNumber());
1: 				break;
1: 			}
1: 		}
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (index == indexes.length)
1: 			{
1: 				SanityManager.THROWASSERT("match not found for " + indexName);
1: 			}
1: 		}
1: 
1: 		/* We are completely initialized when all indexIds are initialized */
1: 		numIndexesSet++;
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#getTableName
1: 	 */
0: 	public String getTableName()
1: 	{
0: 		return name;
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#getIndexName
1: 	 */
0: 	public String getIndexName(int indexId)
1: 	{
1: 		return indexes[indexId].getIndexName();
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#setIndexName
1: 	 */
0: 	public void setIndexName(int indexID, String indexName)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes != null,
1: 				"indexes is expected to be non-null");
1: 
1: 			if (indexID >= indexes.length)
1: 				SanityManager.THROWASSERT(
1: 				"indexID (" + indexID + ") is out of range(0-" +
1: 				indexes.length + ")");
1: 		}
0: 		indexes[indexID].setIndexName(indexName);
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#getCatalogRowFactory
1: 	 */
0: 	public CatalogRowFactory getCatalogRowFactory()
1: 	{
1: 		return crf;
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#isComplete
1: 	 */
0: 	public boolean isComplete()
1: 	{
1: 		/* We are complete when heap conglomerate and all
1: 		 * index conglomerates are set.
1: 		 */
1: 		if (! heapSet)
1: 		{
1: 			return false;
1: 		}
1: 		return (indexes == null ||	indexes.length == numIndexesSet);
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#getIndexColumnCount
1: 	 */
0: 	public int getIndexColumnCount(int indexNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes != null,
1: 				"indexes is expected to be non-null");
1: 
1: 			if (!(indexNumber < indexes.length))
1: 			{
1: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
1: 				indexes.length + ")");
1: 			}
1: 		}
1: 
1: 		return indexes[indexNumber].getColumnCount();
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#getIndexRowGenerator
1: 	 */
0: 	public IndexRowGenerator getIndexRowGenerator(int indexNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes != null,
1: 				"indexes is expected to be non-null");
1:             if (indexNumber >= indexes.length)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "indexNumber (" + indexNumber + ") is out of range(0-" +
1:                     indexes.length + ")");
1:             }
1: 		}
1: 		return indexes[indexNumber].getIndexRowGenerator();
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#setIndexRowGenerator
1: 	 */
0: 	public void setIndexRowGenerator(int indexNumber, IndexRowGenerator irg)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes != null,
1: 				"indexes is expected to be non-null");
1:             if (indexNumber >= indexes.length)
1:             {
1:                 SanityManager.THROWASSERT(
1:                     "indexNumber (" + indexNumber + ") is out of range(0-" +
1:                     indexes.length + ")");
1:             }
1: 		}
1: 
1: 		indexes[indexNumber].setIndexRowGenerator(irg);
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#getNumberOfIndexes
1: 	 */
0: 	public int getNumberOfIndexes()
1: 	{
1: 		if (indexes == null)
1: 		{
1: 			return 0;
1: 		}
1: 		else
1: 		{
1: 			return indexes.length;
1: 		}
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#getBaseColumnPosition
1: 	 */
0: 	public int getBaseColumnPosition(int indexNumber, int colNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes != null,
1: 				"indexes is expected to be non-null");
1: 			if (indexNumber >= indexes.length)
1: 			{
1: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
1: 					indexes.length + ")");
1: 			}
1: 		}
1: 
1: 		return indexes[indexNumber].getBaseColumnPosition(colNumber);
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#setBaseColumnPosition
1: 	 */
0: 	public void setBaseColumnPosition(int indexNumber, int colNumber,
0: 									 int baseColumnPosition)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes != null,
1: 				"indexes is expected to be non-null");
1: 			if (indexNumber >= indexes.length)
1: 			{
1: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
1: 					indexes.length + ")");
1: 			}
1: 		}
1: 
0: 		indexes[indexNumber].setBaseColumnPosition(colNumber, baseColumnPosition);
1: 	}
1: 
1: 	/**
0: 	 * @see TabInfo#isIndexUnique
1: 	 */
0: 	public boolean isIndexUnique(int indexNumber)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(indexes != null,
1: 				"indexes is expected to be non-null");
1: 
1: 			if (indexNumber >= indexes.length)
1: 			{
1: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
1: 					indexes.length + ")");
1: 			}
1: 		}
1: 
1: 		return indexes[indexNumber].isIndexUnique();
1: 	}
1: 
1: 	/**
1: 	 * Inserts a base row into a catalog and inserts all the corresponding
1: 	 * index rows.
1: 	 *
1: 	 *	@param	row			row to insert
1: 	 *	@param	tc			transaction
0: 	 *	@param	wait		to wait on lock or quickly TIMEOUT
0: 	 *	@return	row number (>= 0) if duplicate row inserted into an index
1: 	 *			ROWNOTDUPLICATE otherwise
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public int insertRow( ExecRow row, TransactionController tc, boolean wait)
1: 		throws StandardException
1: 	{
0: 		RowList					rowList = new RowList( this );
1: 
0: 		rowList.add(row);
1: 
1: 		RowLocation[] 			notUsed = new RowLocation[1]; 
1: 
0: 		return insertRowListImpl(rowList,tc,notUsed, wait);
1: 	}
1: 
1: 
1: 	/**
1: 	 * Inserts a base row into a catalog and inserts all the corresponding
1: 	 * index rows.
1: 	 *
1: 	 *	@param	row			row to insert
0: 	 *	@param	lcc			language state variable
0: 	 *	@return	row number (>= 0) if duplicate row inserted into an index
1: 	 *			ROWNOTDUPLICATE otherwise
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public int insertRow( ExecRow row, LanguageConnectionContext lcc )
1: 		throws StandardException
1: 	{
0: 		RowList					rowList = new RowList( this );
1: 
0: 		rowList.add(row);
1: 
0: 		return	insertRowList( rowList, lcc );
1: 	}
1: 
1: 	/**
0: 	 @see TabInfo#insertRowAndFetchRowLocation
0: 	 @exception StandardException Thrown on failure
1: 	 */
0: 	public RowLocation insertRowAndFetchRowLocation(ExecRow row, TransactionController tc)
1: 		throws StandardException
1: 	{
0: 		RowList	rowList = new RowList( this );
0: 		rowList.add(row);
0: 		RowLocation[] rowLocationOut = new RowLocation[1]; 
0: 		insertRowListImpl(rowList,tc,rowLocationOut, true);
0: 		return rowLocationOut[0];
1: 	}
1: 
1: 	/**
0: 	 * Deletes a list of keyed rows from a catalog and all the corresponding
0: 	 * index rows. Deletes through the first index--all tuples are assumed to
0: 	 * be keys into the first index.
1: 	 *
0: 	 *	@param	rowList		List of keyed rows to delete
0: 	 *	@param	lcc			language state variable
1: 	 *
0: 	 * @return the number of rows deleted.
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public int deleteRowList( RowList rowList, LanguageConnectionContext lcc )
1: 		throws StandardException
1: 	{
0: 		int						totalRows = 0;
0: 		int						indexNumber;
0: 		ExecIndexRow			key;
0: 		Enumeration	       		iterator;
0: 		TransactionController	tc = lcc.getTransactionExecute();
1: 
0: 		// loop through rows on this list, deleting them through the first index.
0: 		for (iterator =  rowList.elements(); iterator.hasMoreElements(); )
1: 		{
0: 			indexNumber = crf.getPrimaryKeyIndexNumber();
1: 
0: 			key = (ExecIndexRow) iterator.nextElement();
0: 			totalRows += deleteRow( tc, key, indexNumber );
1: 		}
1: 
0: 		return	totalRows;
1: 	}
1: 
1: 	/**
1: 	 * Inserts a list of base rows into a catalog and inserts all the corresponding
1: 	 * index rows.
1: 	 *
1: 	 *	@param	rowList		List of rows to insert
1: 	 *	@param	tc			transaction controller
1: 	 *
1: 	 *
0: 	 *	@return	row  number (>= 0) if duplicate row inserted into an index
1: 	 *			ROWNOTDUPLICATE otherwise
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public int insertRowList( RowList rowList, TransactionController tc )
1: 		throws StandardException
1: 	{
1: 		RowLocation[] 			notUsed = new RowLocation[1]; 
1: 
0: 		return insertRowListImpl(rowList,tc,notUsed, true);
1: 	}
1: 
1: 	/**
1: 	 * Inserts a list of base rows into a catalog and inserts all the corresponding
1: 	 * index rows.
1: 	 *
1: 	 *	@param	rowList		List of rows to insert
0: 	 *	@param	lcc			language state variable
1: 	 *
1: 	 *
0: 	 *	@return	row  number (>= 0) if duplicate row inserted into an index
1: 	 *			ROWNOTDUPLICATE otherwise
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public int insertRowList( RowList rowList, LanguageConnectionContext lcc )
1: 		throws StandardException
1: 	{
0: 		TransactionController	tc = lcc.getTransactionExecute();
1: 
0: 		return insertRowList(rowList,tc);
1: 	}
1: 
1: 	/**
1: 	  Insert logic to insert a list of rows into a table. This logic has two
0: 	  odd features to support the TabInfo interface.
1: 
1: 	  <OL>
1: 	  <LI>Returns an indication if any returned row was a duplicate.
1: 	  <LI>Returns the RowLocation of the last row inserted.
1: 	  </OL>
1: 	  @param rowList the list of rows to insert
1: 	  @param tc	transaction controller
1: 	  @param rowLocationOut on output rowLocationOut[0] is set to the
1: 	         last RowLocation inserted.
0: 	  @param wait   to wait on lock or quickly TIMEOUT
0: 	  @return row number (>= 0) if duplicate row inserted into an index
1: 	  			ROWNOTDUPLICATE otherwise
1: 	 */
0: 	private int insertRowListImpl( RowList rowList, TransactionController tc, RowLocation[] rowLocationOut,
0: 								   boolean wait)
1: 		throws StandardException
1: 	{
1: 		ConglomerateController		heapController;
1: 		RowLocation					heapLocation;
1: 		ExecIndexRow				indexableRow;
1: 		int							insertRetCode;
1: 		int							retCode = ROWNOTDUPLICATE;
1: 		int							indexCount = crf.getNumIndexes();
1: 		ConglomerateController[]	indexControllers = new ConglomerateController[ indexCount ];
0: 		Enumeration	       			iterator;
0: 		ExecRow						row;
1: 
1: 		// Open the conglomerates
1: 		heapController = 
1:             tc.openConglomerate(
1:                 getHeapConglomerate(), 
1:                 false,
0: 				(TransactionController.OPENMODE_FORUPDATE |
0:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1:                 TransactionController.MODE_RECORD,
1:                 TransactionController.ISOLATION_REPEATABLE_READ);
1: 		
1: 		/* NOTE: Due to the lovely problem of trying to add
1: 		 * a new column to syscolumns and an index on that
1: 		 * column during upgrade, we have to deal with the
1: 		 * issue of the index not existing yet.  So, it's okay
1: 		 * if the index doesn't exist yet.  (It will magically
1: 		 * get created at a later point during upgrade.)
1: 		 */
1: 
1: 		for ( int ictr = 0; ictr < indexCount; ictr++ )
1: 		{
1: 			long conglomNumber = getIndexConglomerate(ictr);
1: 			if (conglomNumber > -1)
1: 			{
1: 				indexControllers[ ictr ] = 
1: 		            tc.openConglomerate( 
1: 			            conglomNumber, 
1:                         false,
0: 						(TransactionController.OPENMODE_FORUPDATE |
0:                     		((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1: 					    TransactionController.MODE_RECORD,
1: 						TransactionController.ISOLATION_REPEATABLE_READ);
1: 			}
1: 		}
1: 
1: 		heapLocation = heapController.newRowLocationTemplate();
1: 		rowLocationOut[0]=heapLocation;
1: 
1: 		// loop through rows on this list, inserting them into system table
0: 		int rowNumber = 0;
0: 		for (iterator =  rowList.elements(); iterator.hasMoreElements(); rowNumber++)
1: 		{
0: 			row = (ExecRow) iterator.nextElement();
1: 			// insert the base row and get its new location 
1: 			heapController.insertAndFetchLocation(row.getRowArray(), heapLocation);
1: 			
1: 			for ( int ictr = 0; ictr < indexCount; ictr++ )
1: 		    {
1: 				if (indexControllers[ ictr ] == null)
1: 				{
1: 					continue;
1: 				}
1: 
1: 				// Get an index row based on the base row
1: 				indexableRow = getIndexRowFromHeapRow( getIndexRowGenerator(ictr),
1: 													   heapLocation,
1: 													   row );
1: 
0: 				insertRetCode = 
0:                     indexControllers[ ictr ].insert(indexableRow.getRowArray());
1: 
1: 				if ( insertRetCode == ConglomerateController.ROWISDUPLICATE )
1: 				{
1: 					retCode = rowNumber;
1: 				}
1: 			}
1: 
1: 		}	// end loop through rows on list
1: 
1: 		// Close the open conglomerates
1: 		for ( int ictr = 0; ictr < indexCount; ictr++ )
1: 		{
1: 			if (indexControllers[ ictr ] == null)
1: 			{
1: 				continue;
1: 			}
1: 
1: 			indexControllers[ ictr ].close();
1: 		}
1: 		heapController.close();
1: 
1: 		return	retCode;
1: 	}
1: 
1: 	/**
1: 	  * @exception StandardException		Thrown on failure
0: 	  * @see TabInfo#truncate
1: 	  */
0: 	public int truncate( TransactionController tc )
1: 		 throws StandardException
1: 	{
1: 		ConglomerateController		heapCC;
1: 		ScanController				drivingScan;
1: 		RowLocation					baseRowLocation;
1: 		RowChanger 					rc;
1: 		ExecRow						baseRow = crf.makeEmptyRow();
1: 
1: 		rc = getRowChanger( tc, (int[])null,baseRow );
0: 		// Table level locking
0: 		rc.open(TransactionController.MODE_TABLE);
0: 		int rowsDeleted = 0;
1: 		
1: 		drivingScan = tc.openScan(
0: 			getHeapConglomerate(),  // conglomerate to open
0: 			false,        // don't hold open across commit
0:             TransactionController.OPENMODE_FORUPDATE, // for update
0:             TransactionController.MODE_TABLE,
1:             TransactionController.ISOLATION_REPEATABLE_READ,
1: 			(FormatableBitSet) null, // all fields as objects
0: 			null,         // start position - first row
0:             ScanController.NA,
0: 			null,         //scanQualifier
0: 			null,         // stop position - through last row
0:             ScanController.NA
0:                            // startSearchOperation
0: 			);     
1: 
1: 		/* Open the heap conglomerate */
1: 		heapCC = tc.openConglomerate(
1:                     getHeapConglomerate(),
1:                     false,
0:                     TransactionController.OPENMODE_FORUPDATE,
0:                     TransactionController.MODE_TABLE,
1:                     TransactionController.ISOLATION_REPEATABLE_READ);
1: 
0: 		baseRowLocation = heapCC.newRowLocationTemplate();
0: 		while (drivingScan.next())
1: 		{
1: 			rowsDeleted++;
0: 			drivingScan.fetchLocation(baseRowLocation);
1: 			boolean base_row_exists = 
1:                 heapCC.fetch(
1:                     baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 // it can not be possible for heap row to disappear while 
1:                 // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
1:                 SanityManager.ASSERT(base_row_exists, "base row not found");
1:             }
1: 			rc.deleteRow( baseRow, baseRowLocation );
1: 		}
1: 
1: 		heapCC.close();
1: 		drivingScan.close();
1: 		rc.close();
1: 		return rowsDeleted;
1: 	}
1: 
1: 	/**
0: 	 * LOCKING: row locking if there there is a key
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
0: 	 * @see TabInfo#deleteRow
1: 	 */
0: 	public int deleteRow( TransactionController tc, ExecIndexRow key, int indexNumber )
1: 		throws StandardException
1: 	{
1: 		// Always row locking
1: 		return  deleteRows(tc,
1: 						   key,
1: 						   ScanController.GE,
1: 						   null,
1: 						   null,
1: 						   key,
1: 						   ScanController.GT,
0: 						   indexNumber);
1: 	}
1: 
1: 	/**
0: 	 * LOCKING: row locking if there is both a start and
0: 	 * stop key; otherwise table locking
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
0: 	 * @see TabInfo#deleteRows
1: 	 */
0: 	public int deleteRows(TransactionController tc,
1: 						  ExecIndexRow startKey,
1: 						  int startOp,
1: 						  Qualifier[][] qualifier,
1: 						  TupleFilter filter,
1: 						  ExecIndexRow stopKey,
1: 						  int stopOp,
1: 						  int indexNumber)
1: 		 throws StandardException
1: 	{
1: 		ConglomerateController		heapCC;
1: 		ScanController				drivingScan;
1: 		ExecIndexRow	 			drivingIndexRow;
1: 		RowLocation					baseRowLocation;
1: 		RowChanger 					rc;
1: 		ExecRow						baseRow = crf.makeEmptyRow();
1: 		int                         rowsDeleted = 0;
1: 		boolean						passedFilter = true;
1: 
1: 		rc = getRowChanger( tc, (int[])null,baseRow );
1: 
1: 		/*
1: 		** If we have a start and a stop key, then we are going to 
1: 		** get row locks, otherwise, we are getting table locks.
1: 		** This may be excessive locking for the case where there
1: 		** is a start key and no stop key or vice versa.
1: 		*/
1: 		int lockMode = ((startKey != null) && (stopKey != null)) ? 
0: 				tc.MODE_RECORD : 
0: 				tc.MODE_TABLE;
1: 
1: 		/*
1: 		** Don't use level 3 if we have the same start/stop key.
1: 		*/
1: 		int isolation = 
1:             ((startKey != null) && (stopKey != null) && (startKey == stopKey)) ?
1: 				TransactionController.ISOLATION_REPEATABLE_READ :
1: 				TransactionController.ISOLATION_SERIALIZABLE;
1: 
1: 		// Row level locking
0: 		rc.open(lockMode);
1: 
1: 		DataValueDescriptor[] startKeyRow = 
1:             startKey == null ? null : startKey.getRowArray();
1: 
1: 		DataValueDescriptor[] stopKeyRow = 
1:             stopKey == null  ? null : stopKey.getRowArray();
1: 
1: 		/* Open the heap conglomerate */
1: 		heapCC = tc.openConglomerate(
1:                     getHeapConglomerate(),
1:                     false,
0:                     TransactionController.OPENMODE_FORUPDATE,
1:                     lockMode,
1:                     TransactionController.ISOLATION_REPEATABLE_READ);
1: 
1: 		drivingScan = tc.openScan(
1: 			getIndexConglomerate(indexNumber),  // conglomerate to open
1: 			false, // don't hold open across commit
0:             TransactionController.OPENMODE_FORUPDATE, // for update
1:             lockMode,
1: 			isolation,
1: 			(FormatableBitSet) null, // all fields as objects
1: 			startKeyRow,   // start position - first row
1:             startOp,      // startSearchOperation
1: 			qualifier, //scanQualifier
1: 			stopKeyRow,   // stop position - through last row
1:             stopOp);     // stopSearchOperation
1: 
1: 		// Get an index row based on the base row
1: 		drivingIndexRow = getIndexRowFromHeapRow(
1: 			getIndexRowGenerator( indexNumber ),
1: 			heapCC.newRowLocationTemplate(),
1: 			crf.makeEmptyRow());
1: 
0: 		while (drivingScan.next())
1: 		{
0: 			drivingScan.fetch(drivingIndexRow.getRowArray());
1: 			baseRowLocation = (RowLocation)
1: 						drivingIndexRow.getColumn(drivingIndexRow.nColumns());
1: 
1: 			boolean base_row_exists = 
1:                 heapCC.fetch(
1:                     baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 // it can not be possible for heap row to disappear while 
1:                 // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
1:                 SanityManager.ASSERT(base_row_exists, "base row not found");
1:             }
1: 
1: 			// only delete rows which pass the base-row filter
1: 			if ( filter != null ) { passedFilter = filter.execute( baseRow ).equals( true ); }
1: 			if ( passedFilter )
1: 			{
1: 				rc.deleteRow( baseRow, baseRowLocation );
1: 				rowsDeleted++;
1: 			}
1: 		}
1: 
1: 		heapCC.close();
1: 		drivingScan.close();
1: 		rc.close();
1: 		return rowsDeleted;
1: 	}
1: 
1: 	/**
1: 	  * @exception StandardException		Thrown on failure
0: 	  * @see TabInfo#getRow
1: 	  */
0: 	public ExecRow getRow( TransactionController tc,
1: 						ExecIndexRow key,
1: 						int indexNumber )
1: 		throws StandardException
1: 	{
1: 		ConglomerateController		heapCC;
1: 
1: 		/* Open the heap conglomerate */
1: 		heapCC = tc.openConglomerate(
1:                     getHeapConglomerate(),
1:                     false,
1:                     0, 						// for read only
1:                     TransactionController.MODE_RECORD,
1:                     TransactionController.ISOLATION_REPEATABLE_READ);
1: 
1: 		try { return getRow( tc, heapCC, key, indexNumber ); }
1: 		finally { heapCC.close(); }
1: 	}
1: 
1: 	/**
1: 	 * Given an index row and index number return the RowLocation
1: 	 * in the heap of the first matching row.
1: 	 * Used by the autoincrement code to get the RowLocation in
0: 	 * syscolumns given a <tablename, columname> pair.
1: 	 * 
1: 	 * @see DataDictionaryImpl#computeRowLocation(TransactionController, TableDescriptor, String)
1: 	 *
1: 	 * @param tc		  Transaction Controller to use.
1: 	 * @param key		  Index Row to search in the index.
1: 	 * @param indexNumber Identifies the index to use.
1: 	 *
1: 	 * @exception		  StandardException thrown on failure.
1: 	 */
0: 	public RowLocation getRowLocation(TransactionController tc,
1: 									  ExecIndexRow key,
1: 									  int indexNumber)
1: 			  throws StandardException
1: 	{
1: 		ConglomerateController		heapCC;
1: 		heapCC = tc.openConglomerate(
1:                     getHeapConglomerate(),
1:                     false,
1:                     0, 						// for read only
1:                     TransactionController.MODE_RECORD,
1:                     TransactionController.ISOLATION_REPEATABLE_READ);
1: 
1: 		try 
1: 		{
1: 			RowLocation rl[] = new RowLocation[1];
1: 			ExecRow notUsed = getRowInternal(tc, heapCC, key, indexNumber, rl);
1: 			return rl[0];
1: 		}
1: 		finally
1: 		{
1: 			heapCC.close();
1: 		}
1: 	}
1: 	/**
1: 	  * @exception StandardException		Thrown on failure
0: 	  * @see TabInfo#getRow
1: 	  */
0: 	public ExecRow getRow( TransactionController tc,
1: 						   ConglomerateController heapCC,
1: 						   ExecIndexRow key,
1: 						   int indexNumber)
1: 							
1: 		 throws StandardException
1: 	{
1: 		RowLocation rl[] = new RowLocation[1];
1: 		return getRowInternal(tc, heapCC, key, indexNumber, rl);
1: 	}
1: 
1: 	/**
1: 	  * @exception StandardException		Thrown on failure
0: 	  * @see TabInfo#getRow
1: 	  */
1: 	private ExecRow getRowInternal( TransactionController tc,
1: 									ConglomerateController heapCC,
1: 									ExecIndexRow key,
1: 									int indexNumber,
1: 									RowLocation rl[])
1: 
1: 		 throws StandardException
1: 	{
1: 		ScanController				drivingScan;
1: 		ExecIndexRow	 			drivingIndexRow;
1: 		RowLocation					baseRowLocation;
1: 		ExecRow						baseRow = crf.makeEmptyRow();
1: 
1: 		drivingScan = tc.openScan(
1: 			getIndexConglomerate(indexNumber),
1: 			                     // conglomerate to open
1: 			false,               // don't hold open across commit
1: 			0,                   // open for read
1:             TransactionController.MODE_RECORD,
1:             TransactionController.ISOLATION_REPEATABLE_READ,
1: 			(FormatableBitSet) null,      // all fields as objects
1: 			key.getRowArray(),   // start position - first row
1:             ScanController.GE,   // startSearchOperation
1: 			null,                //scanQualifier
1: 			key.getRowArray(),   // stop position - through last row
1:             ScanController.GT);  // stopSearchOperation
1: 
1: 		// Get an index row based on the base row
1: 		drivingIndexRow = getIndexRowFromHeapRow(
1: 			getIndexRowGenerator( indexNumber ),
1: 			heapCC.newRowLocationTemplate(),
1: 			crf.makeEmptyRow());
1: 
1: 		try	{
0: 			if (drivingScan.next())
1: 			{
0: 				drivingScan.fetch(drivingIndexRow.getRowArray());
1: 				rl[0] = baseRowLocation = (RowLocation)
1: 					drivingIndexRow.getColumn(drivingIndexRow.nColumns());
1: 				boolean base_row_exists = 
1:                     heapCC.fetch(
1:                         baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
1: 
1:                 if (SanityManager.DEBUG)
1:                 {
1:                     // it can not be possible for heap row to disappear while 
1:                     // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
1:                     SanityManager.ASSERT(base_row_exists, "base row not found");
1:                 }
1: 
1: 				return baseRow;
1: 			}
1: 			else
1: 			{
1: 				return null;
1: 			}
1: 		}
1: 
1: 		finally {
1: 			drivingScan.close();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Updates a base row in a catalog and updates all the corresponding
1: 	 * index rows.
1: 	 *
1: 	 *	@param	key			key row
1: 	 *	@param	newRow		new version of the row
1: 	 *	@param	indexNumber	index that key operates
1: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
1: 	 *							if a boolean is true, that means we must update the
1: 	 *							corresponding index because changes in the newRow
1: 	 *							affect it.
1: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
1: 	 *							to update.  If null, do all.
1: 	 *	@param	tc			transaction controller
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public void updateRow( ExecIndexRow				key, 
1: 						   ExecRow					newRow, 
1: 						   int						indexNumber,
1: 						   boolean[]				indicesToUpdate,
1: 						   int[]					colsToUpdate,
1: 						   TransactionController	tc )
1: 		throws StandardException
1: 	{
0: 		updateRow(key, newRow, indexNumber, indicesToUpdate, colsToUpdate, tc, true);
1: 	}
1: 
1: 	/**
1: 	 * Updates a base row in a catalog and updates all the corresponding
1: 	 * index rows.
1: 	 *
1: 	 *	@param	key			key row
1: 	 *	@param	newRow		new version of the row
1: 	 *	@param	indexNumber	index that key operates
1: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
1: 	 *							if a boolean is true, that means we must update the
1: 	 *							corresponding index because changes in the newRow
1: 	 *							affect it.
1: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
1: 	 *							to update.  If null, do all.
1: 	 *	@param	tc			transaction controller
0: 	 *	@param wait		If true, then the caller wants to wait for locks. False will be
0: 	 *	when we using a nested user xaction - we want to timeout right away if the parent
0: 	 *	holds the lock.  (bug 4821)
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public void updateRow( ExecIndexRow				key, 
1: 						   ExecRow					newRow, 
1: 						   int						indexNumber,
1: 						   boolean[]				indicesToUpdate,
1: 						   int[]					colsToUpdate,
0: 						   TransactionController	tc,
0: 						   boolean	wait )
1: 		throws StandardException
1: 	{
1: 		ExecRow[] newRows = new ExecRow[1];
1: 		newRows[0] = newRow;
0: 		updateRow(key, newRows, indexNumber, indicesToUpdate, colsToUpdate, tc, wait);
1: 	}
1: 
1: 	/**
1: 	 * Updates a set of base rows in a catalog with the same key on an index
1: 	 * and updates all the corresponding index rows. 
1: 	 *
1: 	 *	@param	key			key row
1: 	 *	@param	newRows		new version of the array of rows
1: 	 *	@param	indexNumber	index that key operates
1: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
1: 	 *							if a boolean is true, that means we must update the
1: 	 *							corresponding index because changes in the newRow
1: 	 *							affect it.
1: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
1: 	 *							to update.  If null, do all.
1: 	 *	@param	tc			transaction controller
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public void updateRow( ExecIndexRow				key,
1: 						   ExecRow[]				newRows,
1: 						   int						indexNumber,
1: 						   boolean[]				indicesToUpdate,
1: 						   int[]					colsToUpdate,
1: 						   TransactionController	tc )
1: 		throws StandardException
1: 	{
0: 		updateRow(key, newRows, indexNumber, indicesToUpdate, colsToUpdate, tc, true);
1: 	}
1: 
1: 	/**
1: 	 * Updates a set of base rows in a catalog with the same key on an index
0: 	 * and updates all the corresponding index rows. If parameter wait is true,
0: 	 * then the caller wants to wait for locks. When using a nested user xaction
0: 	 * we want to timeout right away if the parent holds the lock.
1: 	 *
1: 	 *	@param	key			key row
1: 	 *	@param	newRows		new version of the array of rows
1: 	 *	@param	indexNumber	index that key operates
1: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
1: 	 *							if a boolean is true, that means we must update the
1: 	 *							corresponding index because changes in the newRow
1: 	 *							affect it.
1: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
1: 	 *							to update.  If null, do all.
1: 	 *	@param	tc			transaction controller
0: 	 *	@param wait		If true, then the caller wants to wait for locks. When
0: 	 *							using a nested user xaction we want to timeout right away
0: 	 *							if the parent holds the lock. (bug 4821)
1: 	 *
1: 	 * @exception StandardException		Thrown on failure
1: 	 */
0: 	public void updateRow( ExecIndexRow				key,
1: 						   ExecRow[]				newRows,
1: 						   int						indexNumber,
1: 						   boolean[]				indicesToUpdate,
1: 						   int[]					colsToUpdate,
0: 						   TransactionController	tc,
0: 						   boolean wait)
1: 		throws StandardException
1: 	{
1: 		ConglomerateController		heapCC;
1: 		ScanController				drivingScan;
1: 		ExecIndexRow	 			drivingIndexRow;
1: 		RowLocation					baseRowLocation;
0: 		ExecIndexRow				templateRow;
1: 		ExecRow						baseRow = crf.makeEmptyRow();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT( indicesToUpdate.length == crf.getNumIndexes(),
1: 								 "Wrong number of indices." );
1: 		}
1: 
1: 		RowChanger 					rc  = getRowChanger( tc, colsToUpdate,baseRow );
1: 
1: 		// Row level locking
0: 		rc.openForUpdate(indicesToUpdate, TransactionController.MODE_RECORD, wait); 
1: 
1: 		/* Open the heap conglomerate */
1: 		heapCC = tc.openConglomerate(
1:                     getHeapConglomerate(),
1:                     false,
0:                     (TransactionController.OPENMODE_FORUPDATE |
0:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
1:                     TransactionController.MODE_RECORD,
1:                     TransactionController.ISOLATION_REPEATABLE_READ);
1: 
1: 		drivingScan = tc.openScan(
1: 			getIndexConglomerate(indexNumber),  // conglomerate to open
1: 			false, // don't hold open across commit
0: 			(TransactionController.OPENMODE_FORUPDATE |
0:             ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)), 
1:             TransactionController.MODE_RECORD,
1:             TransactionController.ISOLATION_REPEATABLE_READ,
1: 			(FormatableBitSet) null,     // all fields as objects
1: 			key.getRowArray(),   // start position - first row
1:             ScanController.GE,      // startSearchOperation
1: 			null, //scanQualifier
1: 			key.getRowArray(),   // stop position - through last row
1:             ScanController.GT);     // stopSearchOperation
1: 
1: 		// Get an index row based on the base row
1: 		drivingIndexRow = getIndexRowFromHeapRow(
1: 			getIndexRowGenerator( indexNumber ),
1: 			heapCC.newRowLocationTemplate(),
1: 			crf.makeEmptyRow());
1: 
1: 		int rowNum = 0;
0: 		while (drivingScan.next())
1: 		{
0: 			drivingScan.fetch(drivingIndexRow.getRowArray());
1: 
1: 			baseRowLocation = (RowLocation)
1: 						drivingIndexRow.getColumn(drivingIndexRow.nColumns());
1: 			boolean base_row_exists = 
1:                 heapCC.fetch(
1:                     baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 // it can not be possible for heap row to disappear while 
1:                 // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
1:                 SanityManager.ASSERT(base_row_exists, "base row not found");
1:             }
1: 			
1: 			rc.updateRow(baseRow, (rowNum == newRows.length - 1) ?
1: 						newRows[rowNum] : newRows[rowNum++], baseRowLocation );
1: 		}
1: 		rc.finish();
1: 		heapCC.close();
1: 		drivingScan.close();
1: 		rc.close();
1: 	}
1: 
1: 	/**
1: 	 * Get the Properties associated with creating the heap.
1: 	 *
1: 	 * @return The Properties associated with creating the heap.
1: 	 */
0: 	public Properties getCreateHeapProperties()
1: 	{
1: 		return crf.getCreateHeapProperties();
1: 	}
1: 
1: 	/**
1: 	 * Get the Properties associated with creating the specified index.
1: 	 *
1: 	 * @param indexNumber	The specified index number.
1: 	 *
1: 	 * @return The Properties associated with creating the specified index.
1: 	 */
0: 	public Properties getCreateIndexProperties(int indexNumber)
1: 	{
1: 		return crf.getCreateIndexProperties(indexNumber);
1: 	}
1: 
1: 	/**
1: 	  *	Gets a row changer for this catalog.
1: 	  *
1: 	  *	@param	tc	transaction controller
1: 	  *	@param	changedCols	the columns to change (1 based), may be null
1: 	  * @param  baseRow used to detemine column types at creation time
1: 	  *         only. The row changer does ***Not*** keep a referance to
1: 	  *         this row or change it in any way.
1: 	  *
1: 	  *	@return	a row changer for this catalog.
1: 	  * @exception StandardException		Thrown on failure
1: 	  */
1: 	private	RowChanger	getRowChanger( TransactionController tc,
1: 									   int[] changedCols,
1: 									   ExecRow baseRow)
1: 		throws StandardException
1: 	{
1: 		RowChanger 					rc;
1: 		int							indexCount = crf.getNumIndexes();
1: 		IndexRowGenerator[]			irgs = new IndexRowGenerator[ indexCount ];
1: 		long[]						cids = new long[ indexCount ];
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (changedCols != null)
1: 			{
1: 				for (int i = changedCols.length - 1; i >= 0; i--)
1: 				{
1: 					SanityManager.ASSERT(changedCols[i] != 0, 
1: 						"Column id is 0, but should be 1 based");
1: 				}
1: 			}
1: 		}
1: 
1: 		for ( int ictr = 0; ictr < indexCount; ictr++ )
1: 		{
1: 			irgs[ictr] = getIndexRowGenerator(ictr);
1: 			cids[ictr] = getIndexConglomerate(ictr);
1: 		}
1: 
0: 		rc = executionFactory.getRowChanger(getHeapConglomerate(),
1: 											(StaticCompiledOpenConglomInfo) null,
1: 											(DynamicCompiledOpenConglomInfo) null,
1: 											irgs,
1: 											cids,
1: 											(StaticCompiledOpenConglomInfo[]) null,
1: 											(DynamicCompiledOpenConglomInfo[]) null,
1: 											crf.getHeapColumnCount(),
1: 											tc,
1: 											changedCols,
1: 											getStreamStorableHeapColIds(baseRow),
1: 											(Activation) null);
1: 		return	rc;
1: 	}
1: 
1: 	private boolean computedStreamStorableHeapColIds = false;
1: 	private int[] streamStorableHeapColIds;
1: 	private int[] getStreamStorableHeapColIds(ExecRow baseRow) throws StandardException
1: 	{
1: 		if (!computedStreamStorableHeapColIds)
1: 		{
1: 			int sshcidLen = 0;
1: 			//
1: 			//Compute the length of streamStorableHeapColIds
1: 			//One entry for each column id.
1: 			DataValueDescriptor[] ra = baseRow.getRowArray();
1: 			for(int ix=0;ix<ra.length;ix++)
1: 				if (ra[ix] instanceof StreamStorable) sshcidLen++;
1: 
1: 			//
1: 			//If we have some streamStorableHeapColIds we
1: 			//allocate an array to remember them and fill in
1: 			//the array with the 0 based column ids. If we
1: 			//have none leave streamStorableHeapColIds Null.
1: 			if (sshcidLen > 0)
1: 			{
1: 				streamStorableHeapColIds = new int[sshcidLen];
1: 				int sshcidOffset=0;
1: 				for(int ix=0;ix<ra.length;ix++)
1: 					if (ra[ix] instanceof StreamStorable)
1:  						streamStorableHeapColIds[sshcidOffset++] = ix;
1: 			}
1: 			computedStreamStorableHeapColIds = true;
1: 		}
1: 		return streamStorableHeapColIds;
1: 	}
1: 
1: 	/**
1: 	 * Get an index row based on a row from the heap.
1: 	 *
1: 	 * @param irg		IndexRowGenerator to use
1: 	 * @param rl		RowLocation for heap
1: 	 * @param heapRow	Row from the heap
1: 	 *
1: 	 * @return ExecIndexRow	Index row.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	private ExecIndexRow getIndexRowFromHeapRow(IndexRowGenerator irg,
1: 								   RowLocation rl,
1: 								   ExecRow heapRow)
1: 		throws StandardException
1: 	{
1: 		ExecIndexRow		indexRow;
1: 
1: 		indexRow = irg.getIndexRowTemplate();
1: 		// Get an index row based on the base row
1: 		irg.getIndexRow(heapRow, rl, indexRow, (FormatableBitSet) null);
1: 
1: 		return indexRow;
1: 	}
1: 
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return "name: " + name + 
1: 				"\n\theapCongolomerate: "+heapConglomerate +
1: 				"\n\tnumIndexes: " + ((indexes != null) ? indexes.length : 0) +
1: 				"\n\tnumIndexesSet: " + numIndexesSet +
1: 				"\n\theapSet: " + heapSet +
0: 				"\n\tuuid: " + uuid; 
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f739ad1
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.catalog
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.catalog;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.StreamStorable;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.CatalogRowFactory;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.IndexRowGenerator;
0: import org.apache.derby.iapi.sql.dictionary.RowList;
0: import org.apache.derby.iapi.sql.dictionary.TabInfo;
0: import org.apache.derby.iapi.sql.execute.ExecIndexRow;
0: import org.apache.derby.iapi.sql.execute.ExecRow;
0: import org.apache.derby.iapi.sql.execute.ExecutionContext;
0: import org.apache.derby.iapi.sql.execute.ExecutionFactory;
0: import org.apache.derby.iapi.sql.execute.RowChanger;
0: import org.apache.derby.iapi.sql.execute.TupleFilter;
0: import org.apache.derby.iapi.sql.Activation;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.DataValueFactory;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: import org.apache.derby.catalog.UUID;
0: import java.util.Enumeration;
0: import java.util.Properties;
0: 
0: /**
0: * A poor mans structure used in DataDictionaryImpl.java.
0: * Used to save heapId, name pairs for non core tables.
0: *
0: * @author jamie
0: */
0: public class TabInfoImpl implements TabInfo
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	private IndexInfoImpl[]				indexes;
0: 	private String						name;
0: 	private long						heapConglomerate;
0: 	private int							numIndexesSet;
0: 	private boolean						heapSet;
0: 	private UUID						uuid;
0: 	private CatalogRowFactory			crf;
0: 
0: 	private	ExecutionFactory			executionFactory;
0: 
0: 	/**
0: 	 * Constructor
0: 	 *
0: 	 * @param crf				the associated CatalogRowFactory
0: 	 * @param executionFactory	execution factory of the database
0: 	 */
0: 	public TabInfoImpl(CatalogRowFactory crf)
0: 	{
0: 		this.name = crf.getCatalogName();
0: 		this.heapConglomerate = -1;
0: 		this.crf = crf;
0: 		this.executionFactory = crf.getExecutionFactory();
0: 
0: 		int numIndexes = crf.getNumIndexes();
0: 
0: 		if (numIndexes > 0)
0: 		{
0: 			indexes = new IndexInfoImpl[numIndexes];
0: 
0: 			/* Init indexes */
0: 			for (int indexCtr = 0; indexCtr < numIndexes; indexCtr++)
0: 			{
0: 				indexes[indexCtr] = new IndexInfoImpl(
0: 											-1, 
0: 											crf.getIndexName(indexCtr),
0: 											crf.getIndexColumnCount(indexCtr),
0: 											crf.isIndexUnique(indexCtr),
0: 											indexCtr,
0: 											crf);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#getHeapConglomerate
0: 	 */
0: 	public long getHeapConglomerate()
0: 	{
0: 		return heapConglomerate;
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#setHeapConglomerate
0: 	 */
0: 	public void setHeapConglomerate(long heapConglomerate)
0: 	{
0: 		this.heapConglomerate = heapConglomerate;
0: 		heapSet = true;
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#getIndexConglomerate
0: 	 */
0: 	public long getIndexConglomerate(int indexID)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes != null,
0: 				"indexes is expected to be non-null");
0:             if (indexID >= indexes.length)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "indexID (" + indexID + ") is out of range(0-" +
0:                     indexes.length + ")");
0:             }
0: 		}
0: 
0: 		return indexes[indexID].getConglomerateNumber();
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#setIndexConglomerate
0: 	 */
0: 	public void setIndexConglomerate(int index, long indexConglomerate)
0: 	{
0: 		/* Index names must be set before conglomerates.
0: 		 * Also verify that we are not setting the same conglomerate
0: 		 * twice.
0: 		 */
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes[index] != null,
0: 				"indexes[index] expected to be non-null");
0: 			SanityManager.ASSERT(indexes[index].getConglomerateNumber() == -1,
0: 				"indexes[index] expected to be -1");
0: 		}
0: 		indexes[index].setConglomerateNumber(indexConglomerate);
0: 
0: 		/* We are completely initialized when all indexes have 
0: 		 * their conglomerates initialized 
0: 		 */
0: 		numIndexesSet++;
0: 	}
0: 
0: 	public void setIndexConglomerate(ConglomerateDescriptor cd)
0: 	{
0: 		int		index;
0: 		String	indexName = cd.getConglomerateName();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes != null,
0: 				"indexes is expected to be non-null");
0: 		}
0: 
0: 		for (index = 0; index < indexes.length; index++)
0: 		{
0: 			/* All index names expected to be set before
0: 			 * any conglomerate is set.
0: 			 */
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(indexes[index] != null,
0: 					"indexes[index] expected to be non-null");
0: 				SanityManager.ASSERT(indexes[index].getIndexName() != null,
0: 					"indexes[index].getIndexName() expected to be non-null");
0: 			}
0: 
0: 			/* Do we have a match? */
0: 			if (indexes[index].getIndexName().equals(indexName))
0: 			{
0: 				indexes[index].setConglomerateNumber(cd.getConglomerateNumber());
0: 				break;
0: 			}
0: 		}
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (index == indexes.length)
0: 			{
0: 				SanityManager.THROWASSERT("match not found for " + indexName);
0: 			}
0: 		}
0: 
0: 		/* We are completely initialized when all indexIds are initialized */
0: 		numIndexesSet++;
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#getTableName
0: 	 */
0: 	public String getTableName()
0: 	{
0: 		return name;
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#getIndexName
0: 	 */
0: 	public String getIndexName(int indexId)
0: 	{
0: 		return indexes[indexId].getIndexName();
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#setIndexName
0: 	 */
0: 	public void setIndexName(int indexID, String indexName)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes != null,
0: 				"indexes is expected to be non-null");
0: 
0: 			if (indexID >= indexes.length)
0: 				SanityManager.THROWASSERT(
0: 				"indexID (" + indexID + ") is out of range(0-" +
0: 				indexes.length + ")");
0: 		}
0: 		indexes[indexID].setIndexName(indexName);
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#getCatalogRowFactory
0: 	 */
0: 	public CatalogRowFactory getCatalogRowFactory()
0: 	{
0: 		return crf;
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#isComplete
0: 	 */
0: 	public boolean isComplete()
0: 	{
0: 		/* We are complete when heap conglomerate and all
0: 		 * index conglomerates are set.
0: 		 */
0: 		if (! heapSet)
0: 		{
0: 			return false;
0: 		}
0: 		return (indexes == null ||	indexes.length == numIndexesSet);
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#getIndexColumnCount
0: 	 */
0: 	public int getIndexColumnCount(int indexNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes != null,
0: 				"indexes is expected to be non-null");
0: 
0: 			if (!(indexNumber < indexes.length))
0: 			{
0: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
0: 				indexes.length + ")");
0: 			}
0: 		}
0: 
0: 		return indexes[indexNumber].getColumnCount();
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#getIndexRowGenerator
0: 	 */
0: 	public IndexRowGenerator getIndexRowGenerator(int indexNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes != null,
0: 				"indexes is expected to be non-null");
0:             if (indexNumber >= indexes.length)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "indexNumber (" + indexNumber + ") is out of range(0-" +
0:                     indexes.length + ")");
0:             }
0: 		}
0: 		return indexes[indexNumber].getIndexRowGenerator();
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#setIndexRowGenerator
0: 	 */
0: 	public void setIndexRowGenerator(int indexNumber, IndexRowGenerator irg)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes != null,
0: 				"indexes is expected to be non-null");
0:             if (indexNumber >= indexes.length)
0:             {
0:                 SanityManager.THROWASSERT(
0:                     "indexNumber (" + indexNumber + ") is out of range(0-" +
0:                     indexes.length + ")");
0:             }
0: 		}
0: 
0: 		indexes[indexNumber].setIndexRowGenerator(irg);
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#getNumberOfIndexes
0: 	 */
0: 	public int getNumberOfIndexes()
0: 	{
0: 		if (indexes == null)
0: 		{
0: 			return 0;
0: 		}
0: 		else
0: 		{
0: 			return indexes.length;
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#getBaseColumnPosition
0: 	 */
0: 	public int getBaseColumnPosition(int indexNumber, int colNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes != null,
0: 				"indexes is expected to be non-null");
0: 			if (indexNumber >= indexes.length)
0: 			{
0: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
0: 					indexes.length + ")");
0: 			}
0: 		}
0: 
0: 		return indexes[indexNumber].getBaseColumnPosition(colNumber);
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#setBaseColumnPosition
0: 	 */
0: 	public void setBaseColumnPosition(int indexNumber, int colNumber,
0: 									 int baseColumnPosition)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes != null,
0: 				"indexes is expected to be non-null");
0: 			if (indexNumber >= indexes.length)
0: 			{
0: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
0: 					indexes.length + ")");
0: 			}
0: 		}
0: 
0: 		indexes[indexNumber].setBaseColumnPosition(colNumber, baseColumnPosition);
0: 	}
0: 
0: 	/**
0: 	 * @see TabInfo#isIndexUnique
0: 	 */
0: 	public boolean isIndexUnique(int indexNumber)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(indexes != null,
0: 				"indexes is expected to be non-null");
0: 
0: 			if (indexNumber >= indexes.length)
0: 			{
0: 				SanityManager.THROWASSERT("indexNumber (" + indexNumber + ") is out of range(0-" +
0: 					indexes.length + ")");
0: 			}
0: 		}
0: 
0: 		return indexes[indexNumber].isIndexUnique();
0: 	}
0: 
0: 	/**
0: 	 * Inserts a base row into a catalog and inserts all the corresponding
0: 	 * index rows.
0: 	 *
0: 	 *	@param	row			row to insert
0: 	 *	@param	tc			transaction
0: 	 *	@param	wait		to wait on lock or quickly TIMEOUT
0: 	 *	@return	row number (>= 0) if duplicate row inserted into an index
0: 	 *			ROWNOTDUPLICATE otherwise
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public int insertRow( ExecRow row, TransactionController tc, boolean wait)
0: 		throws StandardException
0: 	{
0: 		RowList					rowList = new RowList( this );
0: 
0: 		rowList.add(row);
0: 
0: 		RowLocation[] 			notUsed = new RowLocation[1]; 
0: 
0: 		return insertRowListImpl(rowList,tc,notUsed, wait);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Inserts a base row into a catalog and inserts all the corresponding
0: 	 * index rows.
0: 	 *
0: 	 *	@param	row			row to insert
0: 	 *	@param	lcc			language state variable
0: 	 *	@return	row number (>= 0) if duplicate row inserted into an index
0: 	 *			ROWNOTDUPLICATE otherwise
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public int insertRow( ExecRow row, LanguageConnectionContext lcc )
0: 		throws StandardException
0: 	{
0: 		RowList					rowList = new RowList( this );
0: 
0: 		rowList.add(row);
0: 
0: 		return	insertRowList( rowList, lcc );
0: 	}
0: 
0: 	/**
0: 	 @see TabInfo#insertRowAndFetchRowLocation
0: 	 @exception StandardException Thrown on failure
0: 	 */
0: 	public RowLocation insertRowAndFetchRowLocation(ExecRow row, TransactionController tc)
0: 		throws StandardException
0: 	{
0: 		RowList	rowList = new RowList( this );
0: 		rowList.add(row);
0: 		RowLocation[] rowLocationOut = new RowLocation[1]; 
0: 		insertRowListImpl(rowList,tc,rowLocationOut, true);
0: 		return rowLocationOut[0];
0: 	}
0: 
0: 	/**
0: 	 * Deletes a list of keyed rows from a catalog and all the corresponding
0: 	 * index rows. Deletes through the first index--all tuples are assumed to
0: 	 * be keys into the first index.
0: 	 *
0: 	 *	@param	rowList		List of keyed rows to delete
0: 	 *	@param	lcc			language state variable
0: 	 *
0: 	 * @return the number of rows deleted.
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public int deleteRowList( RowList rowList, LanguageConnectionContext lcc )
0: 		throws StandardException
0: 	{
0: 		int						totalRows = 0;
0: 		int						indexNumber;
0: 		ExecIndexRow			key;
0: 		Enumeration	       		iterator;
0: 		TransactionController	tc = lcc.getTransactionExecute();
0: 
0: 		// loop through rows on this list, deleting them through the first index.
0: 		for (iterator =  rowList.elements(); iterator.hasMoreElements(); )
0: 		{
0: 			indexNumber = crf.getPrimaryKeyIndexNumber();
0: 
0: 			key = (ExecIndexRow) iterator.nextElement();
0: 			totalRows += deleteRow( tc, key, indexNumber );
0: 		}
0: 
0: 		return	totalRows;
0: 	}
0: 
0: 	/**
0: 	 * Inserts a list of base rows into a catalog and inserts all the corresponding
0: 	 * index rows.
0: 	 *
0: 	 *	@param	rowList		List of rows to insert
0: 	 *	@param	tc			transaction controller
0: 	 *
0: 	 *
0: 	 *	@return	row  number (>= 0) if duplicate row inserted into an index
0: 	 *			ROWNOTDUPLICATE otherwise
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public int insertRowList( RowList rowList, TransactionController tc )
0: 		throws StandardException
0: 	{
0: 		RowLocation[] 			notUsed = new RowLocation[1]; 
0: 
0: 		return insertRowListImpl(rowList,tc,notUsed, true);
0: 	}
0: 
0: 	/**
0: 	 * Inserts a list of base rows into a catalog and inserts all the corresponding
0: 	 * index rows.
0: 	 *
0: 	 *	@param	rowList		List of rows to insert
0: 	 *	@param	lcc			language state variable
0: 	 *
0: 	 *
0: 	 *	@return	row  number (>= 0) if duplicate row inserted into an index
0: 	 *			ROWNOTDUPLICATE otherwise
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public int insertRowList( RowList rowList, LanguageConnectionContext lcc )
0: 		throws StandardException
0: 	{
0: 		TransactionController	tc = lcc.getTransactionExecute();
0: 
0: 		return insertRowList(rowList,tc);
0: 	}
0: 
0: 	/**
0: 	  Insert logic to insert a list of rows into a table. This logic has two
0: 	  odd features to support the TabInfo interface.
0: 
0: 	  <OL>
0: 	  <LI>Returns an indication if any returned row was a duplicate.
0: 	  <LI>Returns the RowLocation of the last row inserted.
0: 	  </OL>
0: 	  @param rowList the list of rows to insert
0: 	  @param tc	transaction controller
0: 	  @param rowLocationOut on output rowLocationOut[0] is set to the
0: 	         last RowLocation inserted.
0: 	  @param wait   to wait on lock or quickly TIMEOUT
0: 	  @return row number (>= 0) if duplicate row inserted into an index
0: 	  			ROWNOTDUPLICATE otherwise
0: 	 */
0: 	private int insertRowListImpl( RowList rowList, TransactionController tc, RowLocation[] rowLocationOut,
0: 								   boolean wait)
0: 		throws StandardException
0: 	{
0: 		ConglomerateController		heapController;
0: 		RowLocation					heapLocation;
0: 		ExecIndexRow				indexableRow;
0: 		int							insertRetCode;
0: 		int							retCode = ROWNOTDUPLICATE;
0: 		int							indexCount = crf.getNumIndexes();
0: 		ConglomerateController[]	indexControllers = new ConglomerateController[ indexCount ];
0: 		Enumeration	       			iterator;
0: 		ExecRow						row;
0: 
0: 		// Open the conglomerates
0: 		heapController = 
0:             tc.openConglomerate(
0:                 getHeapConglomerate(), 
0:                 false,
0: 				(TransactionController.OPENMODE_FORUPDATE |
0:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
0:                 TransactionController.MODE_RECORD,
0:                 TransactionController.ISOLATION_REPEATABLE_READ);
0: 		
0: 		/* NOTE: Due to the lovely problem of trying to add
0: 		 * a new column to syscolumns and an index on that
0: 		 * column during upgrade, we have to deal with the
0: 		 * issue of the index not existing yet.  So, it's okay
0: 		 * if the index doesn't exist yet.  (It will magically
0: 		 * get created at a later point during upgrade.)
0: 		 */
0: 
0: 		for ( int ictr = 0; ictr < indexCount; ictr++ )
0: 		{
0: 			long conglomNumber = getIndexConglomerate(ictr);
0: 			if (conglomNumber > -1)
0: 			{
0: 				indexControllers[ ictr ] = 
0: 		            tc.openConglomerate( 
0: 			            conglomNumber, 
0:                         false,
0: 						(TransactionController.OPENMODE_FORUPDATE |
0:                     		((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
0: 					    TransactionController.MODE_RECORD,
0: 						TransactionController.ISOLATION_REPEATABLE_READ);
0: 			}
0: 		}
0: 
0: 		heapLocation = heapController.newRowLocationTemplate();
0: 		rowLocationOut[0]=heapLocation;
0: 
0: 		// loop through rows on this list, inserting them into system table
0: 		int rowNumber = 0;
0: 		for (iterator =  rowList.elements(); iterator.hasMoreElements(); rowNumber++)
0: 		{
0: 			row = (ExecRow) iterator.nextElement();
0: 			// insert the base row and get its new location 
0: 			heapController.insertAndFetchLocation(row.getRowArray(), heapLocation);
0: 			
0: 			for ( int ictr = 0; ictr < indexCount; ictr++ )
0: 		    {
0: 				if (indexControllers[ ictr ] == null)
0: 				{
0: 					continue;
0: 				}
0: 
0: 				// Get an index row based on the base row
0: 				indexableRow = getIndexRowFromHeapRow( getIndexRowGenerator(ictr),
0: 													   heapLocation,
0: 													   row );
0: 
0: 				insertRetCode = 
0:                     indexControllers[ ictr ].insert(indexableRow.getRowArray());
0: 
0: 				if ( insertRetCode == ConglomerateController.ROWISDUPLICATE )
0: 				{
0: 					retCode = rowNumber;
0: 				}
0: 			}
0: 
0: 		}	// end loop through rows on list
0: 
0: 		// Close the open conglomerates
0: 		for ( int ictr = 0; ictr < indexCount; ictr++ )
0: 		{
0: 			if (indexControllers[ ictr ] == null)
0: 			{
0: 				continue;
0: 			}
0: 
0: 			indexControllers[ ictr ].close();
0: 		}
0: 		heapController.close();
0: 
0: 		return	retCode;
0: 	}
0: 
0: 	/**
0: 	  * @exception StandardException		Thrown on failure
0: 	  * @see TabInfo#truncate
0: 	  */
0: 	public int truncate( TransactionController tc )
0: 		 throws StandardException
0: 	{
0: 		ConglomerateController		heapCC;
0: 		ScanController				drivingScan;
0: 		RowLocation					baseRowLocation;
0: 		RowChanger 					rc;
0: 		ExecRow						baseRow = crf.makeEmptyRow();
0: 
0: 		rc = getRowChanger( tc, (int[])null,baseRow );
0: 		// Table level locking
0: 		rc.open(TransactionController.MODE_TABLE);
0: 		int rowsDeleted = 0;
0: 		
0: 		drivingScan = tc.openScan(
0: 			getHeapConglomerate(),  // conglomerate to open
0: 			false,        // don't hold open across commit
0:             TransactionController.OPENMODE_FORUPDATE, // for update
0:             TransactionController.MODE_TABLE,
0:             TransactionController.ISOLATION_REPEATABLE_READ,
0: 			(FormatableBitSet) null, // all fields as objects
0: 			null,         // start position - first row
0:             ScanController.NA,
0: 			null,         //scanQualifier
0: 			null,         // stop position - through last row
0:             ScanController.NA
0:                            // startSearchOperation
0: 			);     
0: 
0: 		/* Open the heap conglomerate */
0: 		heapCC = tc.openConglomerate(
0:                     getHeapConglomerate(),
0:                     false,
0:                     TransactionController.OPENMODE_FORUPDATE,
0:                     TransactionController.MODE_TABLE,
0:                     TransactionController.ISOLATION_REPEATABLE_READ);
0: 
0: 		baseRowLocation = heapCC.newRowLocationTemplate();
0: 		while (drivingScan.next())
0: 		{
0: 			rowsDeleted++;
0: 			drivingScan.fetchLocation(baseRowLocation);
0: 			boolean base_row_exists = 
0:                 heapCC.fetch(
0:                     baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 // it can not be possible for heap row to disappear while 
0:                 // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
0:                 SanityManager.ASSERT(base_row_exists, "base row not found");
0:             }
0: 			rc.deleteRow( baseRow, baseRowLocation );
0: 		}
0: 
0: 		heapCC.close();
0: 		drivingScan.close();
0: 		rc.close();
0: 		return rowsDeleted;
0: 	}
0: 
0: 	/**
0: 	 * LOCKING: row locking if there there is a key
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see TabInfo#deleteRow
0: 	 */
0: 	public int deleteRow( TransactionController tc, ExecIndexRow key, int indexNumber )
0: 		throws StandardException
0: 	{
0: 		// Always row locking
0: 		return  deleteRows(tc,
0: 						   key,
0: 						   ScanController.GE,
0: 						   null,
0: 						   null,
0: 						   key,
0: 						   ScanController.GT,
0: 						   indexNumber);
0: 	}
0: 
0: 	/**
0: 	 * LOCKING: row locking if there is both a start and
0: 	 * stop key; otherwise table locking
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 * @see TabInfo#deleteRows
0: 	 */
0: 	public int deleteRows(TransactionController tc,
0: 						  ExecIndexRow startKey,
0: 						  int startOp,
0: 						  Qualifier[][] qualifier,
0: 						  TupleFilter filter,
0: 						  ExecIndexRow stopKey,
0: 						  int stopOp,
0: 						  int indexNumber)
0: 		 throws StandardException
0: 	{
0: 		ConglomerateController		heapCC;
0: 		ScanController				drivingScan;
0: 		ExecIndexRow	 			drivingIndexRow;
0: 		RowLocation					baseRowLocation;
0: 		RowChanger 					rc;
0: 		ExecRow						baseRow = crf.makeEmptyRow();
0: 		int                         rowsDeleted = 0;
0: 		boolean						passedFilter = true;
0: 
0: 		rc = getRowChanger( tc, (int[])null,baseRow );
0: 
0: 		/*
0: 		** If we have a start and a stop key, then we are going to 
0: 		** get row locks, otherwise, we are getting table locks.
0: 		** This may be excessive locking for the case where there
0: 		** is a start key and no stop key or vice versa.
0: 		*/
0: 		int lockMode = ((startKey != null) && (stopKey != null)) ? 
0: 				tc.MODE_RECORD : 
0: 				tc.MODE_TABLE;
0: 
0: 		/*
0: 		** Don't use level 3 if we have the same start/stop key.
0: 		*/
0: 		int isolation = 
0:             ((startKey != null) && (stopKey != null) && (startKey == stopKey)) ?
0: 				TransactionController.ISOLATION_REPEATABLE_READ :
0: 				TransactionController.ISOLATION_SERIALIZABLE;
0: 
0: 		// Row level locking
0: 		rc.open(lockMode);
0: 
0: 		DataValueDescriptor[] startKeyRow = 
0:             startKey == null ? null : startKey.getRowArray();
0: 
0: 		DataValueDescriptor[] stopKeyRow = 
0:             stopKey == null  ? null : stopKey.getRowArray();
0: 
0: 		/* Open the heap conglomerate */
0: 		heapCC = tc.openConglomerate(
0:                     getHeapConglomerate(),
0:                     false,
0:                     TransactionController.OPENMODE_FORUPDATE,
0:                     lockMode,
0:                     TransactionController.ISOLATION_REPEATABLE_READ);
0: 
0: 		drivingScan = tc.openScan(
0: 			getIndexConglomerate(indexNumber),  // conglomerate to open
0: 			false, // don't hold open across commit
0:             TransactionController.OPENMODE_FORUPDATE, // for update
0:             lockMode,
0: 			isolation,
0: 			(FormatableBitSet) null, // all fields as objects
0: 			startKeyRow,   // start position - first row
0:             startOp,      // startSearchOperation
0: 			qualifier, //scanQualifier
0: 			stopKeyRow,   // stop position - through last row
0:             stopOp);     // stopSearchOperation
0: 
0: 		// Get an index row based on the base row
0: 		drivingIndexRow = getIndexRowFromHeapRow(
0: 			getIndexRowGenerator( indexNumber ),
0: 			heapCC.newRowLocationTemplate(),
0: 			crf.makeEmptyRow());
0: 
0: 		while (drivingScan.next())
0: 		{
0: 			drivingScan.fetch(drivingIndexRow.getRowArray());
0: 			baseRowLocation = (RowLocation)
0: 						drivingIndexRow.getColumn(drivingIndexRow.nColumns());
0: 
0: 			boolean base_row_exists = 
0:                 heapCC.fetch(
0:                     baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 // it can not be possible for heap row to disappear while 
0:                 // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
0:                 SanityManager.ASSERT(base_row_exists, "base row not found");
0:             }
0: 
0: 			// only delete rows which pass the base-row filter
0: 			if ( filter != null ) { passedFilter = filter.execute( baseRow ).equals( true ); }
0: 			if ( passedFilter )
0: 			{
0: 				rc.deleteRow( baseRow, baseRowLocation );
0: 				rowsDeleted++;
0: 			}
0: 		}
0: 
0: 		heapCC.close();
0: 		drivingScan.close();
0: 		rc.close();
0: 		return rowsDeleted;
0: 	}
0: 
0: 	/**
0: 	  * @exception StandardException		Thrown on failure
0: 	  * @see TabInfo#getRow
0: 	  */
0: 	public ExecRow getRow( TransactionController tc,
0: 						ExecIndexRow key,
0: 						int indexNumber )
0: 		throws StandardException
0: 	{
0: 		ConglomerateController		heapCC;
0: 
0: 		/* Open the heap conglomerate */
0: 		heapCC = tc.openConglomerate(
0:                     getHeapConglomerate(),
0:                     false,
0:                     0, 						// for read only
0:                     TransactionController.MODE_RECORD,
0:                     TransactionController.ISOLATION_REPEATABLE_READ);
0: 
0: 		try { return getRow( tc, heapCC, key, indexNumber ); }
0: 		finally { heapCC.close(); }
0: 	}
0: 
0: 	/**
0: 	 * Given an index row and index number return the RowLocation
0: 	 * in the heap of the first matching row.
0: 	 * Used by the autoincrement code to get the RowLocation in
0: 	 * syscolumns given a <tablename, columname> pair.
0: 	 * 
0: 	 * @see DataDictionaryImpl#computeRowLocation(TransactionController, TableDescriptor, String)
0: 	 *
0: 	 * @param tc		  Transaction Controller to use.
0: 	 * @param key		  Index Row to search in the index.
0: 	 * @param indexNumber Identifies the index to use.
0: 	 *
0: 	 * @exception		  StandardException thrown on failure.
0: 	 */
0: 	public RowLocation getRowLocation(TransactionController tc,
0: 									  ExecIndexRow key,
0: 									  int indexNumber)
0: 			  throws StandardException
0: 	{
0: 		ConglomerateController		heapCC;
0: 		heapCC = tc.openConglomerate(
0:                     getHeapConglomerate(),
0:                     false,
0:                     0, 						// for read only
0:                     TransactionController.MODE_RECORD,
0:                     TransactionController.ISOLATION_REPEATABLE_READ);
0: 
0: 		try 
0: 		{
0: 			RowLocation rl[] = new RowLocation[1];
0: 			ExecRow notUsed = getRowInternal(tc, heapCC, key, indexNumber, rl);
0: 			return rl[0];
0: 		}
0: 		finally
0: 		{
0: 			heapCC.close();
0: 		}
0: 	}
0: 	/**
0: 	  * @exception StandardException		Thrown on failure
0: 	  * @see TabInfo#getRow
0: 	  */
0: 	public ExecRow getRow( TransactionController tc,
0: 						   ConglomerateController heapCC,
0: 						   ExecIndexRow key,
0: 						   int indexNumber)
0: 							
0: 		 throws StandardException
0: 	{
0: 		RowLocation rl[] = new RowLocation[1];
0: 		return getRowInternal(tc, heapCC, key, indexNumber, rl);
0: 	}
0: 
0: 	/**
0: 	  * @exception StandardException		Thrown on failure
0: 	  * @see TabInfo#getRow
0: 	  */
0: 	private ExecRow getRowInternal( TransactionController tc,
0: 									ConglomerateController heapCC,
0: 									ExecIndexRow key,
0: 									int indexNumber,
0: 									RowLocation rl[])
0: 
0: 		 throws StandardException
0: 	{
0: 		ScanController				drivingScan;
0: 		ExecIndexRow	 			drivingIndexRow;
0: 		RowLocation					baseRowLocation;
0: 		ExecRow						baseRow = crf.makeEmptyRow();
0: 
0: 		drivingScan = tc.openScan(
0: 			getIndexConglomerate(indexNumber),
0: 			                     // conglomerate to open
0: 			false,               // don't hold open across commit
0: 			0,                   // open for read
0:             TransactionController.MODE_RECORD,
0:             TransactionController.ISOLATION_REPEATABLE_READ,
0: 			(FormatableBitSet) null,      // all fields as objects
0: 			key.getRowArray(),   // start position - first row
0:             ScanController.GE,   // startSearchOperation
0: 			null,                //scanQualifier
0: 			key.getRowArray(),   // stop position - through last row
0:             ScanController.GT);  // stopSearchOperation
0: 
0: 		// Get an index row based on the base row
0: 		drivingIndexRow = getIndexRowFromHeapRow(
0: 			getIndexRowGenerator( indexNumber ),
0: 			heapCC.newRowLocationTemplate(),
0: 			crf.makeEmptyRow());
0: 
0: 		try	{
0: 			if (drivingScan.next())
0: 			{
0: 				drivingScan.fetch(drivingIndexRow.getRowArray());
0: 				rl[0] = baseRowLocation = (RowLocation)
0: 					drivingIndexRow.getColumn(drivingIndexRow.nColumns());
0: 				boolean base_row_exists = 
0:                     heapCC.fetch(
0:                         baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
0: 
0:                 if (SanityManager.DEBUG)
0:                 {
0:                     // it can not be possible for heap row to disappear while 
0:                     // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
0:                     SanityManager.ASSERT(base_row_exists, "base row not found");
0:                 }
0: 
0: 				return baseRow;
0: 			}
0: 			else
0: 			{
0: 				return null;
0: 			}
0: 		}
0: 
0: 		finally {
0: 			drivingScan.close();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Updates a base row in a catalog and updates all the corresponding
0: 	 * index rows.
0: 	 *
0: 	 *	@param	key			key row
0: 	 *	@param	newRow		new version of the row
0: 	 *	@param	indexNumber	index that key operates
0: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
0: 	 *							if a boolean is true, that means we must update the
0: 	 *							corresponding index because changes in the newRow
0: 	 *							affect it.
0: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
0: 	 *							to update.  If null, do all.
0: 	 *	@param	tc			transaction controller
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public void updateRow( ExecIndexRow				key, 
0: 						   ExecRow					newRow, 
0: 						   int						indexNumber,
0: 						   boolean[]				indicesToUpdate,
0: 						   int[]					colsToUpdate,
0: 						   TransactionController	tc )
0: 		throws StandardException
0: 	{
0: 		updateRow(key, newRow, indexNumber, indicesToUpdate, colsToUpdate, tc, true);
0: 	}
0: 
0: 	/**
0: 	 * Updates a base row in a catalog and updates all the corresponding
0: 	 * index rows.
0: 	 *
0: 	 *	@param	key			key row
0: 	 *	@param	newRow		new version of the row
0: 	 *	@param	indexNumber	index that key operates
0: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
0: 	 *							if a boolean is true, that means we must update the
0: 	 *							corresponding index because changes in the newRow
0: 	 *							affect it.
0: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
0: 	 *							to update.  If null, do all.
0: 	 *	@param	tc			transaction controller
0: 	 *	@param wait		If true, then the caller wants to wait for locks. False will be
0: 	 *	when we using a nested user xaction - we want to timeout right away if the parent
0: 	 *	holds the lock.  (bug 4821)
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public void updateRow( ExecIndexRow				key, 
0: 						   ExecRow					newRow, 
0: 						   int						indexNumber,
0: 						   boolean[]				indicesToUpdate,
0: 						   int[]					colsToUpdate,
0: 						   TransactionController	tc,
0: 						   boolean	wait )
0: 		throws StandardException
0: 	{
0: 		ExecRow[] newRows = new ExecRow[1];
0: 		newRows[0] = newRow;
0: 		updateRow(key, newRows, indexNumber, indicesToUpdate, colsToUpdate, tc, wait);
0: 	}
0: 
0: 	/**
0: 	 * Updates a set of base rows in a catalog with the same key on an index
0: 	 * and updates all the corresponding index rows. 
0: 	 *
0: 	 *	@param	key			key row
0: 	 *	@param	newRows		new version of the array of rows
0: 	 *	@param	indexNumber	index that key operates
0: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
0: 	 *							if a boolean is true, that means we must update the
0: 	 *							corresponding index because changes in the newRow
0: 	 *							affect it.
0: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
0: 	 *							to update.  If null, do all.
0: 	 *	@param	tc			transaction controller
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public void updateRow( ExecIndexRow				key,
0: 						   ExecRow[]				newRows,
0: 						   int						indexNumber,
0: 						   boolean[]				indicesToUpdate,
0: 						   int[]					colsToUpdate,
0: 						   TransactionController	tc )
0: 		throws StandardException
0: 	{
0: 		updateRow(key, newRows, indexNumber, indicesToUpdate, colsToUpdate, tc, true);
0: 	}
0: 
0: 	/**
0: 	 * Updates a set of base rows in a catalog with the same key on an index
0: 	 * and updates all the corresponding index rows. If parameter wait is true,
0: 	 * then the caller wants to wait for locks. When using a nested user xaction
0: 	 * we want to timeout right away if the parent holds the lock.
0: 	 *
0: 	 *	@param	key			key row
0: 	 *	@param	newRows		new version of the array of rows
0: 	 *	@param	indexNumber	index that key operates
0: 	 *	@param	indicesToUpdate	array of booleans, one for each index on the catalog.
0: 	 *							if a boolean is true, that means we must update the
0: 	 *							corresponding index because changes in the newRow
0: 	 *							affect it.
0: 	 *	@param  colsToUpdate	array of ints indicating which columns (1 based)
0: 	 *							to update.  If null, do all.
0: 	 *	@param	tc			transaction controller
0: 	 *	@param wait		If true, then the caller wants to wait for locks. When
0: 	 *							using a nested user xaction we want to timeout right away
0: 	 *							if the parent holds the lock. (bug 4821)
0: 	 *
0: 	 * @exception StandardException		Thrown on failure
0: 	 */
0: 	public void updateRow( ExecIndexRow				key,
0: 						   ExecRow[]				newRows,
0: 						   int						indexNumber,
0: 						   boolean[]				indicesToUpdate,
0: 						   int[]					colsToUpdate,
0: 						   TransactionController	tc,
0: 						   boolean wait)
0: 		throws StandardException
0: 	{
0: 		ConglomerateController		heapCC;
0: 		ScanController				drivingScan;
0: 		ExecIndexRow	 			drivingIndexRow;
0: 		RowLocation					baseRowLocation;
0: 		ExecIndexRow				templateRow;
0: 		ExecRow						baseRow = crf.makeEmptyRow();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT( indicesToUpdate.length == crf.getNumIndexes(),
0: 								 "Wrong number of indices." );
0: 		}
0: 
0: 		RowChanger 					rc  = getRowChanger( tc, colsToUpdate,baseRow );
0: 
0: 		// Row level locking
0: 		rc.openForUpdate(indicesToUpdate, TransactionController.MODE_RECORD, wait); 
0: 
0: 		/* Open the heap conglomerate */
0: 		heapCC = tc.openConglomerate(
0:                     getHeapConglomerate(),
0:                     false,
0:                     (TransactionController.OPENMODE_FORUPDATE |
0:                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
0:                     TransactionController.MODE_RECORD,
0:                     TransactionController.ISOLATION_REPEATABLE_READ);
0: 
0: 		drivingScan = tc.openScan(
0: 			getIndexConglomerate(indexNumber),  // conglomerate to open
0: 			false, // don't hold open across commit
0: 			(TransactionController.OPENMODE_FORUPDATE |
0:             ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)), 
0:             TransactionController.MODE_RECORD,
0:             TransactionController.ISOLATION_REPEATABLE_READ,
0: 			(FormatableBitSet) null,     // all fields as objects
0: 			key.getRowArray(),   // start position - first row
0:             ScanController.GE,      // startSearchOperation
0: 			null, //scanQualifier
0: 			key.getRowArray(),   // stop position - through last row
0:             ScanController.GT);     // stopSearchOperation
0: 
0: 		// Get an index row based on the base row
0: 		drivingIndexRow = getIndexRowFromHeapRow(
0: 			getIndexRowGenerator( indexNumber ),
0: 			heapCC.newRowLocationTemplate(),
0: 			crf.makeEmptyRow());
0: 
0: 		int rowNum = 0;
0: 		while (drivingScan.next())
0: 		{
0: 			drivingScan.fetch(drivingIndexRow.getRowArray());
0: 
0: 			baseRowLocation = (RowLocation)
0: 						drivingIndexRow.getColumn(drivingIndexRow.nColumns());
0: 			boolean base_row_exists = 
0:                 heapCC.fetch(
0:                     baseRowLocation, baseRow.getRowArray(), (FormatableBitSet) null);
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 // it can not be possible for heap row to disappear while 
0:                 // holding scan cursor on index at ISOLATION_REPEATABLE_READ.
0:                 SanityManager.ASSERT(base_row_exists, "base row not found");
0:             }
0: 			
0: 			rc.updateRow(baseRow, (rowNum == newRows.length - 1) ?
0: 						newRows[rowNum] : newRows[rowNum++], baseRowLocation );
0: 		}
0: 		rc.finish();
0: 		heapCC.close();
0: 		drivingScan.close();
0: 		rc.close();
0: 	}
0: 
0: 	/**
0: 	 * Get the Properties associated with creating the heap.
0: 	 *
0: 	 * @return The Properties associated with creating the heap.
0: 	 */
0: 	public Properties getCreateHeapProperties()
0: 	{
0: 		return crf.getCreateHeapProperties();
0: 	}
0: 
0: 	/**
0: 	 * Get the Properties associated with creating the specified index.
0: 	 *
0: 	 * @param indexNumber	The specified index number.
0: 	 *
0: 	 * @return The Properties associated with creating the specified index.
0: 	 */
0: 	public Properties getCreateIndexProperties(int indexNumber)
0: 	{
0: 		return crf.getCreateIndexProperties(indexNumber);
0: 	}
0: 
0: 	/**
0: 	  *	Gets a row changer for this catalog.
0: 	  *
0: 	  *	@param	tc	transaction controller
0: 	  *	@param	changedCols	the columns to change (1 based), may be null
0: 	  * @param  baseRow used to detemine column types at creation time
0: 	  *         only. The row changer does ***Not*** keep a referance to
0: 	  *         this row or change it in any way.
0: 	  *
0: 	  *	@return	a row changer for this catalog.
0: 	  * @exception StandardException		Thrown on failure
0: 	  */
0: 	private	RowChanger	getRowChanger( TransactionController tc,
0: 									   int[] changedCols,
0: 									   ExecRow baseRow)
0: 		throws StandardException
0: 	{
0: 		RowChanger 					rc;
0: 		int							indexCount = crf.getNumIndexes();
0: 		IndexRowGenerator[]			irgs = new IndexRowGenerator[ indexCount ];
0: 		long[]						cids = new long[ indexCount ];
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (changedCols != null)
0: 			{
0: 				for (int i = changedCols.length - 1; i >= 0; i--)
0: 				{
0: 					SanityManager.ASSERT(changedCols[i] != 0, 
0: 						"Column id is 0, but should be 1 based");
0: 				}
0: 			}
0: 		}
0: 
0: 		for ( int ictr = 0; ictr < indexCount; ictr++ )
0: 		{
0: 			irgs[ictr] = getIndexRowGenerator(ictr);
0: 			cids[ictr] = getIndexConglomerate(ictr);
0: 		}
0: 
0: 		rc = executionFactory.getRowChanger(getHeapConglomerate(),
0: 											(StaticCompiledOpenConglomInfo) null,
0: 											(DynamicCompiledOpenConglomInfo) null,
0: 											irgs,
0: 											cids,
0: 											(StaticCompiledOpenConglomInfo[]) null,
0: 											(DynamicCompiledOpenConglomInfo[]) null,
0: 											crf.getHeapColumnCount(),
0: 											tc,
0: 											changedCols,
0: 											getStreamStorableHeapColIds(baseRow),
0: 											(Activation) null);
0: 		return	rc;
0: 	}
0: 
0: 	private boolean computedStreamStorableHeapColIds = false;
0: 	private int[] streamStorableHeapColIds;
0: 	private int[] getStreamStorableHeapColIds(ExecRow baseRow) throws StandardException
0: 	{
0: 		if (!computedStreamStorableHeapColIds)
0: 		{
0: 			int sshcidLen = 0;
0: 			//
0: 			//Compute the length of streamStorableHeapColIds
0: 			//One entry for each column id.
0: 			DataValueDescriptor[] ra = baseRow.getRowArray();
0: 			for(int ix=0;ix<ra.length;ix++)
0: 				if (ra[ix] instanceof StreamStorable) sshcidLen++;
0: 
0: 			//
0: 			//If we have some streamStorableHeapColIds we
0: 			//allocate an array to remember them and fill in
0: 			//the array with the 0 based column ids. If we
0: 			//have none leave streamStorableHeapColIds Null.
0: 			if (sshcidLen > 0)
0: 			{
0: 				streamStorableHeapColIds = new int[sshcidLen];
0: 				int sshcidOffset=0;
0: 				for(int ix=0;ix<ra.length;ix++)
0: 					if (ra[ix] instanceof StreamStorable)
0:  						streamStorableHeapColIds[sshcidOffset++] = ix;
0: 			}
0: 			computedStreamStorableHeapColIds = true;
0: 		}
0: 		return streamStorableHeapColIds;
0: 	}
0: 
0: 	/**
0: 	 * Get an index row based on a row from the heap.
0: 	 *
0: 	 * @param irg		IndexRowGenerator to use
0: 	 * @param rl		RowLocation for heap
0: 	 * @param heapRow	Row from the heap
0: 	 *
0: 	 * @return ExecIndexRow	Index row.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	private ExecIndexRow getIndexRowFromHeapRow(IndexRowGenerator irg,
0: 								   RowLocation rl,
0: 								   ExecRow heapRow)
0: 		throws StandardException
0: 	{
0: 		ExecIndexRow		indexRow;
0: 
0: 		indexRow = irg.getIndexRowTemplate();
0: 		// Get an index row based on the base row
0: 		irg.getIndexRow(heapRow, rl, indexRow, (FormatableBitSet) null);
0: 
0: 		return indexRow;
0: 	}
0: 
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "name: " + name + 
0: 				"\n\theapCongolomerate: "+heapConglomerate +
0: 				"\n\tnumIndexes: " + ((indexes != null) ? indexes.length : 0) +
0: 				"\n\tnumIndexesSet: " + numIndexesSet +
0: 				"\n\theapSet: " + heapSet +
0: 				"\n\tuuid: " + uuid; 
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: }
============================================================================