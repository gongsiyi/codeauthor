4:e4e2bfd: /*
78:e4e2bfd: 
1:e4e2bfd: Derby - Class org.apache.derbyTesting.functionTests.tests.largedata.LobLimitsTest
1:7e79794: 
1:e4e2bfd: Licensed to the Apache Software Foundation (ASF) under one or more
1:e4e2bfd: contributor license agreements.  See the NOTICE file distributed with
1:e4e2bfd: this work for additional information regarding copyright ownership.
1:e4e2bfd: The ASF licenses this file to You under the Apache License, Version 2.0
1:e4e2bfd: (the "License"); you may not use this file except in compliance with
1:e4e2bfd: the License.  You may obtain a copy of the License at
1:e4e2bfd: 
1:e4e2bfd: http://www.apache.org/licenses/LICENSE-2.0
1:e4e2bfd: 
1:e4e2bfd: Unless required by applicable law or agreed to in writing, software
1:e4e2bfd: distributed under the License is distributed on an "AS IS" BASIS,
1:e4e2bfd: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e4e2bfd: See the License for the specific language governing permissions and
1:e4e2bfd: limitations under the License.
1:e4e2bfd: 
1:7e79794:  */
1:e4e2bfd: 
1:e4e2bfd: package org.apache.derbyTesting.functionTests.tests.largedata;
1:e4e2bfd: 
1:e4e2bfd: import java.io.File;
1:e4e2bfd: import java.io.FileInputStream;
1:1ae02c9: import java.io.FileOutputStream;
1:1ae02c9: import java.io.FileReader;
1:e4e2bfd: import java.io.FileWriter;
1:1ae02c9: import java.io.IOException;
1:e4e2bfd: import java.io.InputStream;
1:e4e2bfd: import java.io.OutputStream;
1:e4e2bfd: import java.io.Reader;
1:e4e2bfd: import java.sql.Blob;
1:e4e2bfd: import java.sql.Clob;
1:e4e2bfd: import java.sql.PreparedStatement;
1:e4e2bfd: import java.sql.ResultSet;
1:e4e2bfd: import java.sql.SQLException;
1:e4e2bfd: import java.sql.Statement;
1:6a072f8: import java.util.Properties;
1:e4e2bfd: import junit.framework.Test;
1:e4e2bfd: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:d52bac6: import org.apache.derbyTesting.junit.JDBC;
1:1ae02c9: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:6a072f8: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.TestConfiguration;
1:e4e2bfd: 
17:e4e2bfd: /**
1:7e79794:  * This test is part of the "largedata" suite because this test tests data for
1:7e79794:  * lobs to the limits ( ie blob and clob can be 2G-1 maximum) and so this test
1:7e79794:  * may take considerable disk space as well as time to run. Hence it is not part
1:7e79794:  * of the derbyall suite but should ideally be run at some intervals to test if
1:7e79794:  * no regression has occurred.
1:7e79794:  */
1:e4e2bfd: 
1:e4e2bfd: public class LobLimitsTest extends BaseJDBCTestCase {
1:e4e2bfd: 
1:7e79794:     public LobLimitsTest(String name) {
1:e4e2bfd:         super(name);
82:e4e2bfd:     }
1:d52bac6: 
1:7e79794:     static boolean trace = false;
1:e4e2bfd: 
1:7e79794:     static final int _2GB = 2 * 1024 * 1024 * 1024 - 1;
1:7e79794:     static final int _100MB = 100 * 1024 * 1024;
1:7e79794:     static final long _4GB = 4 * 1024 * 1024 * (1024L);
1:7e79794:     static final int NUM_TRAILING_SPACES = 33 * 1024;
1:e4e2bfd: 
1:7e79794:     static int BIGGEST_LOB_SZ = _2GB;
1:e4e2bfd: 
1:7e79794:     public static void setBIGGEST_LOB_SZ(int bIGGESTLOBSZ) {
1:7e79794:         BIGGEST_LOB_SZ = bIGGESTLOBSZ;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     static int BIG_LOB_SZ = _100MB;
1:e4e2bfd: 
1:7e79794:     public static void setBIG_LOB_SZ(int bIGLOBSZ) {
1:7e79794:         BIG_LOB_SZ = bIGLOBSZ;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     static int MORE_DATA_THAN_COL_WIDTH = (_100MB) + 1;
1:e4e2bfd: 
1:7e79794:     public static void setMORE_DATA_THAN_COL_WIDTH(int mOREDATATHANCOLWIDTH) {
1:7e79794:         MORE_DATA_THAN_COL_WIDTH = mOREDATATHANCOLWIDTH;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     static final String DATAFILE = "extinout/byteLobLimits.dat";
1:7e79794: 
1:7e79794:     static final String CHARDATAFILE = "extinout/charLobLimits.txt";
1:7e79794: 
1:7e79794:     /**
1:e4e2bfd:      * Setup the schema and the blob sizes for the test.
1:7e79794:      * 
1:e4e2bfd:      * @param s
1:7e79794:      * @param biggestlobsz
1:e4e2bfd:      * @param biglobsz
1:e4e2bfd:      * @throws SQLException
22:e4e2bfd:      */
1:7e79794:     static void setupTables(Statement s, int biggestlobsz, int biglobsz)
1:7e79794:             throws SQLException {
1:7e79794:         setBIGGEST_LOB_SZ(biggestlobsz);
1:7e79794:         setBIG_LOB_SZ(biglobsz);
1:7e79794:         setMORE_DATA_THAN_COL_WIDTH(biglobsz + 1);
1:7e79794:         println("BIGGEST_LOB_SZ=" + BIGGEST_LOB_SZ + " BIG_LOB_SZ="
1:7e79794:                 + BIG_LOB_SZ);
1:7e79794:         s.execute("CREATE TABLE BLOBTBL (ID INT NOT NULL PRIMARY KEY, "
1:7e79794:                 + "POS BIGINT, DLEN BIGINT, CONTENT BLOB(2G))");
1:7e79794:         s.execute("CREATE TABLE CLOBTBL (ID INT NOT NULL PRIMARY KEY,"
1:7e79794:                 + "POS BIGINT, DLEN BIGINT, CONTENT CLOB(2G))");
1:7e79794:         s.execute("CREATE TABLE BLOBTBL2 (ID INT NOT NULL PRIMARY KEY, "
1:7e79794:                 + "POS BIGINT, CONTENT BLOB(" + BIG_LOB_SZ + "),DLEN BIGINT)");
1:e4e2bfd: 
1:7e79794:         // Please dont change the clob column width,since tests use this width
1:7e79794:         // to
1:7e79794:         // test for truncation of trailing spaces.
1:7e79794:         s.execute("CREATE TABLE CLOBTBL2 (ID INT NOT NULL PRIMARY KEY,"
1:7e79794:                 + "POS BIGINT, CONTENT CLOB(" + BIG_LOB_SZ + "), DLEN BIGINT)");
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public static Test suite() {
1:7e79794:         // Right now run just with embeddded.
1:543e809:         return baseSuite(_2GB, _100MB);
1:543e809:     }
1:543e809: 
1:543e809:     /**
1:543e809:      * Create an instance of the {@code LobLimitsTest} suite.
1:543e809:      *
1:543e809:      * @param biggestSize the size of the biggest LOB to test
1:543e809:      * @param bigSize the size of a typical big LOB to test
1:543e809:      * @return a test suite
1:543e809:      */
1:543e809:     static Test baseSuite(final int biggestSize, final int bigSize) {
1:6a072f8:     	//Run the suite with following properties in case we run into lock
1:6a072f8:     	// time out issues. It will help debug the problem if timeouts occur.
1:6a072f8:         Properties sysprops = new Properties();
1:6a072f8:         sysprops.setProperty("derby.locks.deadlockTrace", "true");
1:6a072f8:         sysprops.setProperty("derby.locks.monitor", "true");
1:543e809:         // Some of the test cases depend on certain other test cases to run
1:543e809:         // first, so force the test cases to run in lexicographical order.
1:1ae02c9:         Test suite =
1:1ae02c9:                 new CleanDatabaseTestSetup(
1:1ae02c9:                         new BaseTestSuite(LobLimitsTest.class)) {
1:1ae02c9:             @Override
1:7e79794:             protected void decorateSQL(Statement s)
3:e4e2bfd:                            throws SQLException {
1:543e809:                 setupTables(s, biggestSize, bigSize);
1:7e79794:             }
1:7e79794:         };
1:6a072f8:         suite = new SystemPropertyTestSetup(suite,sysprops);
1:e4e2bfd: 
1:7e79794:         return new SupportFilesSetup(suite);
1:7e79794:     }
1:7e79794: 
1:7e79794:     /**
1:7e79794:      * tests specific for blobs
1:7e79794:      * @throws Exception
1:7e79794:      */
1:543e809:     public void test_01_Blob() throws Exception {
1:d52bac6:         setAutoCommit(false);
1:e4e2bfd:         PreparedStatement insertBlob =
1:e4e2bfd:                 prepareStatement("INSERT INTO BLOBTBL values (?,?,?,?)");
1:e4e2bfd:         PreparedStatement selectBlob =
1:e4e2bfd:                 prepareStatement("SELECT CONTENT,DLEN FROM BLOBTBL WHERE ID = ?");
1:e4e2bfd:         PreparedStatement insertBlob2 =
1:e4e2bfd:                 prepareStatement("INSERT INTO BLOBTBL2 values (?,?,?,?)");
1:e4e2bfd:         PreparedStatement selectBlob2 =
1:e4e2bfd:                 prepareStatement("SELECT CONTENT,DLEN FROM BLOBTBL2 WHERE ID = ?");
1:7e79794:         // Test - 2Gb blob ( actually it is 2gb -1)
1:7e79794:         // Note with setBinaryStream interface the maximum size for the
1:7e79794:         // stream, can be max value for an int.
1:7e79794:         // Also note, that lobs in derby currently supports
1:7e79794:         // maximum size of 2gb -1
1:e4e2bfd: 
1:7e79794:         // first do insert blob of 2g, 2 rows
1:d52bac6:         insertBlob_SetBinaryStream("BlobTest #1", insertBlob,
1:7e79794:                 BIGGEST_LOB_SZ,
1:e4e2bfd:                    0, 2, BIGGEST_LOB_SZ);
1:7e79794:         // do a select to see if the inserts in test above went ok
1:d52bac6:         selectBlob("BlobTest #2", selectBlob, BIGGEST_LOB_SZ, 0, 1);
1:d52bac6:         selectBlob("BlobTest #3", selectBlob, BIGGEST_LOB_SZ, 1, 1);
1:e4e2bfd: 
1:7e79794:         // now do a select of one of the 2gb rows and update another 2g row
1:7e79794:         // using the setBlob api, updated blob is of length 2gb
1:7e79794:         // Fix for Bug entry -DERBY-599[setBlob should not materialize blob
1:7e79794:         // into memory]
1:d52bac6:         selectUpdateBlob("BlobTest #4", selectBlob, BIGGEST_LOB_SZ, 0, 1);
1:7e79794:         // select row from blobtbl and then do insert into the blobtbl
1:7e79794:         // using setBlob
1:d52bac6:         selectInsertBlob("BlobTest #4.1", selectBlob, insertBlob,
1:d52bac6:                 BIGGEST_LOB_SZ, 0, 3);
1:7e79794: 
1:7e79794:         // Test - generate random data, write to a file, use it to insert
1:7e79794:         // data into blob and then read back and compare if all is ok
1:7e79794:         // currently in fvt ( derbyall), tests check for substrings etc and
1:7e79794:         // for small amounts of data. This test will test for 100mb of blob data
1:7e79794: 
1:7e79794:         FileOutputStream fos =
1:7e79794:                 PrivilegedFileOpsForTests
1:7e79794:                         .getFileOutputStream(new File(DATAFILE));
1:7e79794:         RandomByteStreamT r = new RandomByteStreamT(new java.util.Random(),
1:e4e2bfd:                    BIG_LOB_SZ);
1:7e79794:         // write in chunks of 32k buffer
1:7e79794:         byte[] buffer = new byte[32 * 1024];
1:7e79794:         int count = 0;
1:e4e2bfd: 
1:7e79794:         while ((count = r.read(buffer)) >= 0)
1:7e79794:             fos.write(buffer, 0, count);
1:7e79794: 
1:7e79794:         fos.flush();
1:7e79794:         fos.close();
1:d52bac6:         insertBlob2("BlobTest #5.1 ", insertBlob2, BIG_LOB_SZ, 0, 1,
1:e4e2bfd:                    BIG_LOB_SZ, DATAFILE);
1:d52bac6:         selectBlob2("BlobTest #5.2 ", selectBlob2, BIG_LOB_SZ, 0, 1,
1:e4e2bfd:                    DATAFILE);
1:e4e2bfd: 
1:7e79794:         // update the 2gb row in blobtbl with the 100mb data and compare if the
1:7e79794:         // update
1:7e79794:         // went ok.
1:d52bac6:         selectUpdateBlob2("BlobTest #6", selectBlob2, selectBlob,
1:d52bac6:                 BIG_LOB_SZ, 0, 1, DATAFILE);
1:7e79794: 
1:3ce7ebd:         deleteAndTruncateTable("BLOBTBL2", 1);
1:7e79794: 
1:d52bac6:         commit();
1:e4e2bfd: 
1:3ce7ebd:         deleteAndTruncateTable("BLOBTBL", 3);
1:7e79794:     }
1:e4e2bfd: 
1:543e809:     public void test_02_BlobNegative() throws SQLException {
1:7e79794:         // Negative Test, use setBlob api to insert a 4GB blob.
1:d52bac6:         setAutoCommit(false);
1:7e79794:         PreparedStatement insertBlob =
1:7e79794:                 prepareStatement("INSERT INTO BLOBTBL values (?,?,?,?)");
1:7e79794: 
1:7e79794:         BlobImplT _4GbBlob =
1:7e79794:                 new BlobImplT(new RandomByteStreamT(new java.util.Random(),
1:7e79794:                         _4GB), _4GB);
1:7e79794: 
1:7e79794:         try {
1:d52bac6:             insertBlob_SetBlob("BlobTest #7 (setBlob with 4Gb blob",
1:7e79794:                     insertBlob, _4GbBlob,
1:7e79794:                     _4GB, 0, 1, 0);
1:f30426b:             fail("Inserting 4BG blob should have thrown exception");
1:7e79794:         } catch (SQLException sqle) {
1:7e79794:             // DERBY DOES NOT SUPPORT INSERT OF 4GB BLOB
1:f30426b:             if (usingDerbyNetClient()) {
1:f30426b:                 // DERBY-5338 client gives wrong SQLState and protocol error
1:f30426b:                 // inserting a 4GB clob. Should be 22003
1:f30426b:                 assertSQLState("XN015",sqle);
1:f30426b:             } else {
1:f30426b:                 assertSQLState("22003", sqle);
1:f30426b:             }
1:d52bac6:             commit();
1:7e79794:         }
1:7e79794:         // ADD NEW TESTS HERE
1:7e79794:     }
1:7e79794: 
1:7e79794:     /**
1:7e79794:      * tests using clobs
1:7e79794:      * 
1:7e79794:      * @throws Exception
1:7e79794:      */
1:543e809:     public void test_03_Clob1() throws Exception {
1:7e79794:         setAutoCommit(false);
1:e4e2bfd:         PreparedStatement insertClob =
1:e4e2bfd:                 prepareStatement("INSERT INTO CLOBTBL values (?,?,?,?)");
1:7e79794:         PreparedStatement selectClob =
1:7e79794:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL WHERE ID = ?");
1:e4e2bfd: 
1:7e79794:         // Test - 2Gb blob
1:7e79794:         // Note with setCharacterStream interface the maximum size for the
1:7e79794:         // stream has to be max value for a int which is (2GB -1 )
1:7e79794:         // first do insert clob of 2g, 2 rows
1:d52bac6:         insertClob_SetCharacterStream("ClobTest #1", insertClob,
1:7e79794:                 BIGGEST_LOB_SZ, 0, 2, BIGGEST_LOB_SZ);
1:7e79794:         // do a select to see if the inserts in test above went ok
1:d52bac6:         selectClob("ClobTest #2", selectClob, BIGGEST_LOB_SZ, 0, 1);
1:d52bac6:         selectClob("ClobTest #3", selectClob, BIGGEST_LOB_SZ, 0, 1);
1:7e79794:         // do a select and then update a row of 2gb size: uses getClob
1:d52bac6:         selectUpdateClob("ClobTest #4", selectClob, BIGGEST_LOB_SZ, 0, 1);
1:7e79794: 
1:7e79794:     }
1:7e79794: 
1:7e79794:     /**
1:7e79794:      * @throws Exception
1:7e79794:      */
1:543e809:     public void test_04_Clob2() throws Exception {
1:d52bac6:         setAutoCommit(false);
2:e4e2bfd:         PreparedStatement selectClob =
2:e4e2bfd:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL WHERE ID = ?");
1:e4e2bfd:         PreparedStatement insertClob2 =
1:e4e2bfd:                 prepareStatement("INSERT INTO CLOBTBL2 values (?,?,?,?)");
1:e4e2bfd:         PreparedStatement selectClob2 =
1:e4e2bfd:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 WHERE ID = ?");
1:e4e2bfd: 
1:7e79794:         // Test - generate random data, write to a file, use it to insert
1:7e79794:         // data into clob and then read back and compare if all is ok
1:7e79794:         // currently in fvt ( derbyall), tests check for substrings etc and
1:7e79794:         // for small amounts of data. This test will test for 100mb of clob data
1:7e79794:         writeToFile(CHARDATAFILE, new RandomCharReaderT(new java.util.Random(),
1:7e79794:                 BIG_LOB_SZ));
1:d52bac6:         insertClob2("ClobTest #5.1 ", insertClob2, BIG_LOB_SZ, 0, 1,
1:e4e2bfd:                    BIG_LOB_SZ, CHARDATAFILE);
1:d52bac6:         selectClob2("ClobTest #5.2 ", selectClob2, BIG_LOB_SZ, 0, 1,
1:e4e2bfd:                    CHARDATAFILE);
1:8c86e54:         // DERBY-5344 updateClob2 test in LobLimitsTest gets OutOfMemoryError 
1:8c86e54:         // on updateRow with embedded
1:8c86e54:         // Disabled for embedded for the big test for now, this will materialize.
1:8c86e54:         // As part of DERBY-1903 / DERBY-5344, the test was enabled for 
1:8c86e54:         // client. That issue will have reference to the materialization bug when 
1:8c86e54:         // it is found or filed.
1:8c86e54:         if (!(usingEmbedded()  && BIGGEST_LOB_SZ  == _2GB)) {
1:8c86e54:             updateClob2("ClobTest #8.1",selectClob,BIG_LOB_SZ,0,0,10,CHARDATAFILE);
1:8c86e54:         }
1:7e79794:         // update the 2gb row in clobtbl with the 100mb data and compare if the
1:7e79794:         // update
1:7e79794:         // went ok.
1:d52bac6:         selectUpdateClob2("ClobTest #8.2", selectClob2, selectClob,
1:d52bac6:                 BIG_LOB_SZ, 0, 1, CHARDATAFILE);
1:7e79794: 
1:7e79794:         // test for trailing space truncation
1:7e79794:         // insert 100mb+33k of data which has 33k of trailing space,
1:7e79794:         // into a column of 100mb
1:7e79794:         // insert should be successful, select should retrieve 100mb of data
1:7e79794: 
1:7e79794:         // Generate random data and write to a file, this file will be used
1:7e79794:         // in the verification process after inserts and updates.
1:7e79794:         writeToFile(CHARDATAFILE, new RandomCharReaderT(new java.util.Random(),
1:7e79794:                    (NUM_TRAILING_SPACES + BIG_LOB_SZ), NUM_TRAILING_SPACES));
1:d52bac6:         insertClob2("ClobTest #6.1 ", insertClob2, BIG_LOB_SZ, 3, 1,
1:7e79794:                    (NUM_TRAILING_SPACES + BIG_LOB_SZ), CHARDATAFILE);
1:7e79794:         // select will retrieve data and verify the data inserted.
1:d52bac6:         selectClob2("ClobTest #6.2 ", selectClob2, BIG_LOB_SZ, 3, 1,
1:e4e2bfd:                    CHARDATAFILE);
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:543e809:     public void test_05_ClobNegative() throws Exception {
1:d52bac6:         setAutoCommit(false);
1:e4e2bfd:         PreparedStatement insertClob =
1:e4e2bfd:                 prepareStatement("INSERT INTO CLOBTBL values (?,?,?,?)");
1:e4e2bfd:         PreparedStatement selectClob =
1:e4e2bfd:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL WHERE ID = ?");
1:e4e2bfd:         PreparedStatement insertClob2 =
1:e4e2bfd:                 prepareStatement("INSERT INTO CLOBTBL2 values (?,?,?,?)");
1:e4e2bfd:         PreparedStatement selectClob2 =
1:e4e2bfd:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 WHERE ID = ?");
1:e4e2bfd: 
1:d52bac6:         negativeSpaceTruncationTest("ClobTest #7");
1:e4e2bfd: 
1:7e79794:         // Test - for stream contains a trailing non-space character
1:7e79794:         // insert should throw an error
1:7e79794:         writeToFile(CHARDATAFILE, new RandomCharReaderT(new java.util.Random(),
1:7e79794:                 MORE_DATA_THAN_COL_WIDTH));
1:f30426b:         // DERBY-5341 : Client allows clob larger than
1:f30426b:         // column width to be inserted.
1:f30426b:         if (!usingDerbyNetClient()) {
1:f30426b:             try {
1:d52bac6:                 insertClob2("ClobTest #9.1 ", insertClob2,
1:f30426b:                         MORE_DATA_THAN_COL_WIDTH, 4, 1,
1:f30426b:                         MORE_DATA_THAN_COL_WIDTH, CHARDATAFILE);
1:f30426b:                 fail("ClobTest #9.1 " + "should have thrown XSDA4");
1:f30426b:             } catch (SQLException sqle) {
1:f30426b:                 assertSQLState("XSDA4", sqle);
1:f30426b:             }
1:7e79794:         }
1:7e79794:         // no row must be retrieved.
1:d52bac6:         selectClob2("ClobTest #9.2 ", selectClob2, BIG_LOB_SZ, 4, 0,
1:e4e2bfd:                    CHARDATAFILE);
2:7e79794:         try {
1:d52bac6:             insertClob2("ClobTest #10 ", insertClob2,
2:7e79794:                     MORE_DATA_THAN_COL_WIDTH, 4, 1,
1:7e79794:                        MORE_DATA_THAN_COL_WIDTH + 1, CHARDATAFILE);
1:f30426b:             fail("ClobTest #10. Should have thrown XSDA4");
2:7e79794:         } catch (SQLException sqle) {
1:7e79794:             // NEGATIVE TEST - Expected Exception: truncation of non-blanks not
1:7e79794:             // allowed and
1:7e79794:             // stream length is one greater than actual length of the stream
2:7e79794:             assertSQLState("XSDA4", sqle);
1:7e79794:         }
1:e4e2bfd: 
1:7e79794:         try {
1:d52bac6:             insertClob2("ClobTest #11 ", insertClob2,
1:7e79794:                     MORE_DATA_THAN_COL_WIDTH, 4, 1,
1:7e79794:                        MORE_DATA_THAN_COL_WIDTH - 1, CHARDATAFILE);
1:f30426b:             fail("ClobTest #11. Should have thrown XSDA4");
1:7e79794:         } catch (SQLException sqle) {
1:7e79794:             // NEGATIVE TEST - Expected Exception: truncation of non-blanks not
1:7e79794:             // allowed and
1:7e79794:             // stream length is one less than actual length of the stream
1:7e79794:             assertSQLState("XSDA4", sqle);
1:7e79794:         }
1:3ce7ebd:         deleteAndTruncateTable("CLOBTBL2", 2);
1:e4e2bfd: 
1:7e79794:         try {
1:7e79794:             // give -ve streamlength
1:d52bac6:             insertClob_SetCharacterStream("ClobTest #12.1", insertClob,
1:7e79794:                     BIG_LOB_SZ, 4, 1, -1);
1:f30426b:             fail("ClobTest #12. Should have thrown XJ025");
1:7e79794:         } catch (SQLException sqle) {
1:7e79794:             assertSQLState("XJ025", sqle);
1:7e79794:         }
1:e4e2bfd: 
1:d52bac6:         selectClob("ClobTest #12.2", selectClob, BIG_LOB_SZ, 4, 0);
1:e4e2bfd: 
1:3ce7ebd:         deleteAndTruncateTable("CLOBTBL", 2);
1:e4e2bfd: 
1:7e79794:         // Negative tests use the setClob API to insert a 4GB clob
1:e4e2bfd: 
1:7e79794:         // long _4GB = 4*1024*1024*(1024L);
1:e4e2bfd: 
1:7e79794:         ClobImplT _4GBClob =
1:7e79794:                 new ClobImplT(new RandomCharReaderT(new java.util.Random(),
1:7e79794:                         _4GB), _4GB);
1:e4e2bfd: 
1:7e79794:         try {
1:d52bac6:             insertClob_SetClob("ClobTest #13 (setClob with 4Gb clob",
1:7e79794:                     insertClob, _4GBClob,
1:7e79794:                     _4GB, 0, 1, 0);
1:f30426b:             fail("ClobTest #13. Should have thrown 22033");
1:7e79794:         } catch (SQLException sqle) {
1:f30426b:          // DERBY DOES NOT SUPPORT INSERT OF 4GB CLOB
1:f30426b:             if (usingDerbyNetClient()) {
1:f30426b:                 // DERBY-5338 client gives wrong SQLState and protocol error
1:f30426b:                 // inserting a 4GB clob. Should be 22003
1:f30426b:                 assertSQLState("XN015",sqle);
1:f30426b:             } else {
1:f30426b:                 assertSQLState("22003", sqle);
1:f30426b:             }
1:7e79794:         }
1:b24d2b4:         rollback();
1:e4e2bfd: 
1:7e79794:         // ADD NEW TESTS HERE
1:7e79794:     }
1:e4e2bfd: 
1:3ce7ebd:     //DERBY-5638
1:3ce7ebd:     // Following shutdown will ensure that all the logs are applied to the
1:3ce7ebd:     // database and hence there are no unapplied log files left at the end 
1:3ce7ebd:     // of the suite. 
1:3ce7ebd:     //This test deals will large data objects which can cause us to have 
1:3ce7ebd:     // large log files and if the database is not shutdown at the end of the 
1:3ce7ebd:     // suite, the suite will finish successfully but will leave a database 
1:3ce7ebd:     // directory with large number of big log files. Nightly machines which
1:3ce7ebd:     // run this suite on a regular basis can eventually run out of disk space
1:3ce7ebd:     // if those machines do not delete the database directories from multiple 
1:3ce7ebd:     // runs.
1:3ce7ebd:     public void test_06_shutdownDB() throws Exception {
1:3ce7ebd:         TestConfiguration.getCurrent().shutdownDatabase();
1:3ce7ebd:     }
1:3ce7ebd: 
1:d52bac6:     private void negativeSpaceTruncationTest(String msg)
1:7e79794:             throws Exception {
1:d52bac6:         PreparedStatement insertClob2 =
1:d52bac6:                 prepareStatement("INSERT INTO CLOBTBL2 values (?,?,?,?)");
1:e4e2bfd: 
1:7e79794:         // Negative test, stream has trailing spaces but the stream length is
1:7e79794:         // one
1:7e79794:         // more than the actual length of the stream
1:7e79794:         try {
1:d52bac6:             insertClob2(msg, insertClob2, BIG_LOB_SZ, 4, 1,
1:7e79794:                     (NUM_TRAILING_SPACES + BIG_LOB_SZ - 1), CHARDATAFILE);
1:f30426b:             fail(msg +". Should have thrown XSDA4");
1:7e79794:         } catch (SQLException sqle) {
1:7e79794:             // EXPECTED EXCEPTION - stream has trailing spaces,but stream
1:7e79794:             // length is 1 less than actual length of stream
1:7e79794:             assertSQLState("XSDA4", sqle);
1:7e79794:         }
1:e4e2bfd: 
1:7e79794:         try {
1:d52bac6:             insertClob2(msg, insertClob2, BIG_LOB_SZ, 5, 1,
1:7e79794:                     (NUM_TRAILING_SPACES + BIG_LOB_SZ + 1), CHARDATAFILE);
1:f30426b:             fail(msg + ". Should have thrown XSDA4");
1:7e79794:         } catch (SQLException sqle) {
1:7e79794:             // EXPECTED EXCEPTION - stream has trailing spaces,but stream
1:7e79794:             // length is 1 greater than actual length of stream
1:7e79794:             assertSQLState("XSDA4", sqle);
1:7e79794:         }
1:7e79794:     }
1:7e79794: 
1:7e79794:     /**
1:7e79794:      * insert blob
1:7e79794:      * 
1:7e79794:      * @param bloblen length of blob to insert
1:7e79794:      * @param start start id value for insert
1:7e79794:      * @param rows insert rows number of rows
1:7e79794:      * @param streamLength stream length passed to setBinaryStream(,,length)
1:7e79794:      */
1:d52bac6:     private void insertBlob_SetBinaryStream(String testId, PreparedStatement ps, int bloblen, int start,
1:7e79794:             int rows, int streamLength) throws SQLException {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + "insertBlob of size = "
1:7e79794:                 + bloblen);
1:d52bac6:         long ST = System.currentTimeMillis();
1:7e79794: 
1:7e79794:         int count = 0;
1:7e79794:         java.util.Random random = new java.util.Random();
1:7e79794:         for (int i = start; i < start + rows; i++) {
1:7e79794:             ps.setInt(1, i);
1:7e79794:             ps.setInt(2, 0);
1:7e79794:             ps.setLong(3, bloblen);
1:7e79794:             ps.setBinaryStream(4, new RandomByteStreamT(random, bloblen),
1:7e79794:                     streamLength);
1:7e79794:             count += ps.executeUpdate();
1:7e79794:         }
1:d52bac6:         commit();
1:7e79794:         println("Insert Blob (" + bloblen + ")" + " rows= "
1:e4e2bfd:                    + count + " = " + (long) (System.currentTimeMillis() - ST));
1:7e79794:         verifyTest(count, rows, " Rows inserted with blob of size (" + bloblen
1:7e79794:                 + ") =");
1:7e79794:         println("========================================");
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * insert blob, using a setBlob api.
1:7e79794:      * 
1:7e79794:      * @param bloblen length of blob to insert
1:7e79794:      * @param blob blob to insert
1:7e79794:      * @param start start id value for insert
1:7e79794:      * @param rows insert rows number of rows
1:7e79794:      * @param expectedRows rows expected to be inserted
1:7e79794:      */
1:d52bac6:     private void insertBlob_SetBlob(String testId,
1:e4e2bfd:             PreparedStatement ps, java.sql.Blob blob, long bloblen, int start,
1:e4e2bfd:             int rows, int expectedRows) throws SQLException {
27:e4e2bfd:         println("========================================");
2:e4e2bfd:         println("START " + testId + "insertBlob of size = "
5:e4e2bfd:                 + bloblen);
1:e4e2bfd:         long ST = System.currentTimeMillis();
11:e4e2bfd:         int count = 0;
1:7e79794:         for (int i = start; i < start + rows; i++) {
1:7e79794:             ps.setInt(1, i);
1:7e79794:             ps.setInt(2, 0);
1:7e79794:             ps.setLong(3, bloblen);
1:7e79794:             ps.setBlob(4, blob);
1:7e79794:             count += ps.executeUpdate();
1:7e79794:         }
1:d52bac6:         commit();
1:7e79794:         println("Insert Blob (" + bloblen + ")" + " rows= "
1:e4e2bfd:                         + count + " = "
2:e4e2bfd:                         + (long) (System.currentTimeMillis() - ST));
1:e4e2bfd: 
5:e4e2bfd:         verifyTest(count, expectedRows,
1:e4e2bfd:                 " Rows inserted with blob of size (" + bloblen + ") =");
1:e4e2bfd:         println("========================================");
1:e4e2bfd: 
1:e4e2bfd:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * select from blob table (BLOBTBL)
1:7e79794:      * 
1:7e79794:      * @param bloblen select expects to retrieve a blob of this length
1:7e79794:      * @param id id of the row to retrieve
1:7e79794:      * @param expectedRows number of rows expected to match id
1:7e79794:      */
1:d52bac6:     private void selectBlob(String testId,
1:7e79794:             PreparedStatement ps, int bloblen, int id, int expectedRows)
1:7e79794:             throws SQLException {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + " - SELECT BLOB of size = "
1:7e79794:                 + bloblen);
1:e4e2bfd: 
1:d52bac6:         long ST = System.currentTimeMillis();
1:e4e2bfd: 
1:7e79794:         int count = 0;
1:7e79794:         ps.setInt(1, id);
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:e4e2bfd: 
1:7e79794:         while (rs.next()) {
1:7e79794:             count++;
1:7e79794:             Blob value = rs.getBlob(1);
1:7e79794:             long l = value.length();
1:7e79794:             long dlen = rs.getLong(2);
1:7e79794:             assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:e4e2bfd:                        + " expected " + dlen + " for row in BLOBTBL with ID="
1:e4e2bfd:                        + id, dlen, l);
1:7e79794:         }
1:d52bac6: 
1:d52bac6:         rs.close();
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         verifyTest(count, expectedRows,
1:7e79794:                 "Matched rows selected with blob of size(" + bloblen + ") =");
1:7e79794:         println("Select Blob (" + bloblen + ")" + " rows= "
2:e4e2bfd:                    + expectedRows + " = "
1:e4e2bfd:                    + (long) (System.currentTimeMillis() - ST));
1:7e79794:         println("========================================");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * insert blob into BLOBTBL2
1:7e79794:      * 
1:7e79794:      * @param bloblen length of blob to insert
1:7e79794:      * @param start id value for insert
1:7e79794:      * @param rows insert rows number of rows
1:7e79794:      * @param streamLength stream length passed to setBinaryStream(,,length)
1:7e79794:      * @param file filename to match retrieved data against
1:7e79794:      */
1:e4e2bfd: 
1:d52bac6:     private void insertBlob2(String testId,
1:7e79794:             PreparedStatement ps, int bloblen, int start, int rows,
1:7e79794:             int streamLength, String file) throws Exception {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + "insert Blob of size = "
1:7e79794:                 + bloblen);
1:7e79794:         int count = 0;
1:d52bac6:         long ST = System.currentTimeMillis();
1:7e79794: 
1:7e79794:         for (int i = start; i < start + rows; i++) {
1:d52bac6:             FileInputStream fis =
1:d52bac6:                 PrivilegedFileOpsForTests.getFileInputStream(new File(file));
1:7e79794:             ps.setInt(1, i);
1:7e79794:             ps.setInt(2, 0);
1:7e79794:             ps.setLong(4, bloblen);
1:7e79794:             ps.setBinaryStream(3, fis, streamLength);
1:7e79794:             count += ps.executeUpdate();
1:7e79794:             fis.close();
1:7e79794:         }
1:d52bac6:         commit();
1:7e79794:         println("Insert Blob (" + bloblen + ")" + " rows= "
1:e4e2bfd:                    + count + " = " + (long) (System.currentTimeMillis() - ST));
1:7e79794:         verifyTest(count, rows, " Rows inserted with blob of size (" + bloblen
1:7e79794:                 + ") =");
1:7e79794:         println("========================================");
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * select from blob table (BLOBTBL2)
1:7e79794:      * 
1:7e79794:      * @param bloblen select expects to retrieve a blob of this length
1:7e79794:      * @param id id of the row to retrieve
1:7e79794:      * @param expectedRows number of rows expected to match id
1:7e79794:      * @param file name of the file,against which the retrieved data is compared
1:7e79794:      */
1:d52bac6:     private void selectBlob2(String testId,
1:7e79794:             PreparedStatement ps, int bloblen, int id, int expectedRows,
1:7e79794:             String file) throws Exception {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + " - SELECT BLOB of size = "
1:7e79794:                 + bloblen);
1:e4e2bfd: 
1:d52bac6:         long ST = System.currentTimeMillis();
1:e4e2bfd: 
1:7e79794:         int count = 0;
1:7e79794:         ps.setInt(1, id);
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:e4e2bfd: 
1:7e79794:         while (rs.next()) {
1:7e79794:             count++;
1:7e79794:             Blob value = rs.getBlob(1);
1:7e79794:             long l = value.length();
1:7e79794:             long dlen = rs.getLong(2);
1:7e79794:             assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:e4e2bfd:                        + " expected " + dlen + " for row in BLOBTBL with ID="
1:e4e2bfd:                        + id, dlen, l);
1:e4e2bfd: 
1:7e79794:             compareBlobToFile(value.getBinaryStream(), file);
1:7e79794:         }
1:d52bac6: 
1:d52bac6:         rs.close();
1:d52bac6:         commit();
1:7e79794: 
1:7e79794:         verifyTest(count, expectedRows,
1:7e79794:                 "Matched rows selected with blob of size(" + bloblen + ") =");
1:e4e2bfd: 
1:7e79794:         println("Select Blob (" + bloblen + ")" + " rows= "
1:e4e2bfd:                    + expectedRows + " = "
1:e4e2bfd:                    + (long) (System.currentTimeMillis() - ST));
1:7e79794:         println("========================================");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * Basically this test will do an update using setBlob api - select row from
1:7e79794:      * blobtbl and then update a row in blobtbl and verify updated data in
1:7e79794:      * blobtbl
1:7e79794:      * 
1:7e79794:      * @param ps select statement from which blob is retrieved
1:7e79794:      * @param bloblen updating value is of length bloblen
1:7e79794:      * @param id id of the row retrieved, for the update
1:7e79794:      * @param updateId id of the row that is updated
1:7e79794:      */
1:d52bac6:     private void selectUpdateBlob(String testId,
1:d52bac6:             PreparedStatement ps, int bloblen, int id, int updateId)
1:d52bac6:             throws Exception {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + " - select and then update blob of size= "
1:7e79794:                 + bloblen + " - Uses getBlob api");
1:e4e2bfd: 
1:7e79794:         ps.setInt(1, id);
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:7e79794:         rs.next();
1:7e79794:         Blob value = rs.getBlob(1);
1:7e79794:         long l = value.length();
1:7e79794:         long dlen = rs.getLong(2);
1:7e79794:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:e4e2bfd:                            + dlen + " for row in BLOBTBL with ID=" + id,
1:e4e2bfd:                            dlen, l);
1:e4e2bfd: 
1:7e79794:         PreparedStatement psUpd =
1:d52bac6:                 prepareStatement("update BLOBTBL set content=?,dlen =?" +
1:7e79794:                         "where id = ?");
1:7e79794:         psUpd.setBlob(1, value);
1:7e79794:         psUpd.setLong(2, l);
1:7e79794:         psUpd.setInt(3, updateId);
1:e4e2bfd: 
1:7e79794:         println("Rows Updated = " + psUpd.executeUpdate());
1:d52bac6:         commit();
1:7e79794: 
1:7e79794:         // now select and verify that update went through ok.
1:7e79794:         ps.setInt(1, updateId);
1:7e79794:         ResultSet rs2 = ps.executeQuery();
1:7e79794:         rs2.next();
1:7e79794:         Blob updatedValue = rs2.getBlob(1);
1:7e79794:         assertEquals(
1:7e79794:                 "FAIL - Retrieving the updated blob length does not match " +
1:7e79794:                         "expected length = " + l + " found = "
1:7e79794:                         + updatedValue.length(),
1:e4e2bfd:                    l, updatedValue.length());
1:d52bac6: 
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         // close resultsets
1:7e79794:         rs.close();
1:7e79794:         rs2.close();
1:7e79794:         println("========================================");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * Basically this test will do an insert using setBlob api - select row from
1:7e79794:      * blobtbl and then insert a row in blobtbl and verify updated data in
1:7e79794:      * blobtbl
1:7e79794:      * 
1:7e79794:      * @param ps select statement from which blob is retrieved
1:7e79794:      * @param bloblen updating value is of length bloblen
1:7e79794:      * @param id id of the row retrieved, for the update
1:7e79794:      * @param insertId id of the row that is inserted
1:7e79794:      */
1:d52bac6:     private void selectInsertBlob(String testId,
1:7e79794:             PreparedStatement ps, PreparedStatement ins, int bloblen, int id,
1:d52bac6:             int insertId) throws Exception {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + " - select and then insert blob of size= "
1:7e79794:                 + bloblen
1:7e79794:                 + " - Uses getBlob api to do select and setBlob for insert");
1:7e79794: 
1:7e79794:         ps.setInt(1, id);
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:7e79794:         rs.next();
1:7e79794:         Blob value = rs.getBlob(1);
1:7e79794:         long l = value.length();
1:7e79794:         long dlen = rs.getLong(2);
1:7e79794:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:e4e2bfd:                            + dlen + " for row in BLOBTBL with ID=" + id,
1:7e79794:                            dlen, l);
1:7e79794:         ins.setInt(1, insertId);
1:7e79794:         ins.setInt(2, 0);
1:7e79794:         ins.setLong(3, l);
1:7e79794:         ins.setBlob(4, value);
1:e4e2bfd: 
1:7e79794:         // assert one row updated
1:d52bac6:         assertUpdateCount(ins, 1);
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         // now select and verify that update went through ok.
1:7e79794:         ps.setInt(1, insertId);
1:7e79794:         ResultSet rs2 = ps.executeQuery();
1:7e79794:         rs2.next();
1:7e79794:         Blob insertedValue = rs2.getBlob(1);
1:7e79794:         assertEquals(
1:7e79794:                 "FAIL - Retrieving the updated blob length does not match " +
1:7e79794:                         "expected length = " + l + " found = "
1:7e79794:                         + insertedValue.length(),
1:7e79794:                 l, insertedValue.length());
1:d52bac6: 
1:d52bac6:         commit();
1:d52bac6: 
1:7e79794:         // close resultsets
1:7e79794:         rs.close();
1:7e79794:         rs2.close();
1:7e79794:         println("========================================");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * Basically this test will do an update using setBinaryStream api and
1:7e79794:      * verifies the updated data. select row from blobtbl2 and then update a row
1:7e79794:      * in blobtbl and verify updated data in blobtbl
1:7e79794:      * 
1:7e79794:      * @param bloblen updating value is of length bloblen
1:7e79794:      * @param id id of the row retrieved, for the update
1:7e79794:      * @param updateId id of the row that is updated
1:7e79794:      * @param file name of the file,against which the updated data is compared
1:7e79794:      */
1:d52bac6:     private void selectUpdateBlob2(String testId,
1:7e79794:             PreparedStatement ps, PreparedStatement sel, int bloblen, int id,
1:d52bac6:             int updateId, String file) throws Exception {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + " - select and then update blob of size= "
1:7e79794:                 + bloblen + " - Uses getBlob and setBlob  api");
1:e4e2bfd: 
1:7e79794:         // retrieve row from blobtbl2
1:7e79794:         ps.setInt(1, id);
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:7e79794:         rs.next();
1:7e79794:         Blob value = rs.getBlob(1);
1:7e79794:         long l = value.length();
1:7e79794:         long dlen = rs.getLong(2);
1:7e79794:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:7e79794:                 + dlen + " for row in BLOBTBL2 with ID=" + id, dlen, l);
1:e4e2bfd: 
1:7e79794:         PreparedStatement psUpd =
1:d52bac6:                 prepareStatement("update BLOBTBL set content=?,dlen =?" +
1:7e79794:                         " where id = ?");
1:7e79794:         psUpd.setBlob(1, value);
1:7e79794:         psUpd.setLong(2, l);
1:7e79794:         psUpd.setInt(3, updateId);
1:7e79794:         // assert 1 row updated
1:d52bac6:         assertUpdateCount(psUpd, 1);
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         // now select and verify that update went through ok.
1:7e79794:         sel.setInt(1, updateId);
1:7e79794:         ResultSet rs2 = sel.executeQuery();
1:7e79794:         rs2.next();
1:7e79794:         Blob updatedValue = rs2.getBlob(1);
1:7e79794:         assertEquals("FAIL - MISMATCH length of updated blob value : expected="
1:7e79794:                 +
1:7e79794:                 l + " found =" + updatedValue.length(), l, updatedValue
1:7e79794:                 .length());
1:7e79794:         compareBlobToFile(updatedValue.getBinaryStream(), file);
1:d52bac6: 
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         // close resultsets
1:7e79794:         rs.close();
1:7e79794:         rs2.close();
1:7e79794:         println("========================================");
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     private static void compareBlobToFile(InputStream lobstream, String filename)
1:7e79794:             throws Exception {
1:7e79794:         FileInputStream file =
1:7e79794:                 PrivilegedFileOpsForTests
1:7e79794:                         .getFileInputStream(new File(filename));
1:0f3e1f6:         assertEquals(file, lobstream);
1:7e79794:     }
1:e4e2bfd: 
1:3ce7ebd:     private void deleteAndTruncateTable(String table,
1:7e79794:             int expectedRows) throws SQLException {
1:3ce7ebd:     	Statement s = createStatement();
1:3ce7ebd:         //Keep the delete call to exercise delete of long blobs and clobs.
1:3ce7ebd:     	// This is a separate code path through Derby compared to truncate
1:3ce7ebd:     	// table code path.
1:3ce7ebd:         int count = s.executeUpdate(
1:d52bac6:                 "DELETE FROM " + JDBC.escape(table));
1:3ce7ebd:         //DERBY-5638
1:3ce7ebd:         //Adding truncate call which will give back the disk space being 
1:3ce7ebd:         // used by the table at commit time rather than wait for test 
1:3ce7ebd:         // infrastructure to drop the table.
1:3ce7ebd:         s.executeUpdate("TRUNCATE TABLE " + JDBC.escape(table));
1:d52bac6:         commit();
1:7e79794:         verifyTest(count, expectedRows, "Rows deleted =");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * insert clob
1:7e79794:      * 
1:7e79794:      * @param cloblen length of clob to insert
1:7e79794:      * @param start id value for insert
1:7e79794:      * @param rows insert rows number of rows
1:7e79794:      * @param streamLength stream length passed to
1:7e79794:      *            setCharacterStream(...,length)
1:7e79794:      */
1:d52bac6:     private void insertClob_SetCharacterStream(String testId, PreparedStatement ps, int cloblen, int start,
1:7e79794:             int rows, int streamLength) throws SQLException {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + "  -insertClob of size = "
1:7e79794:                 + cloblen);
1:7e79794: 
2:7e79794:         java.util.Random random = new java.util.Random();
1:7e79794:         int count = 0;
1:d52bac6:         long ST = System.currentTimeMillis();
1:7e79794: 
1:7e79794:         for (int i = start; i < start + rows; i++) {
1:7e79794:             ps.setInt(1, i);
1:7e79794:             ps.setInt(2, 0);
1:7e79794:             ps.setLong(3, cloblen);
1:7e79794:             ps.setCharacterStream(4, new RandomCharReaderT(random, cloblen),
1:7e79794:                     streamLength);
1:7e79794:             count += ps.executeUpdate();
1:7e79794:         }
1:d52bac6:         commit();
1:7e79794:         println("Insert Clob (" + cloblen + ")" + " rows= "
1:e4e2bfd:                    + count + " = " + (long) (System.currentTimeMillis() - ST));
1:7e79794:         verifyTest(count, rows, "Rows inserted with clob of size (" + cloblen
1:7e79794:                 + ") = ");
1:7e79794:         println("========================================");
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * insert clob, using a setClob api.
1:7e79794:      * 
1:7e79794:      * @param cloblen length of clob to insert
1:7e79794:      * @param clob clob to insert
1:7e79794:      * @param start start id value for insert
1:7e79794:      * @param rows insert rows number of rows
1:7e79794:      * @param expectedRows rows expected to be inserted
1:7e79794:      */
1:d52bac6:     private void insertClob_SetClob(String testId,
1:e4e2bfd:             PreparedStatement ps, java.sql.Clob clob, long cloblen, int start,
1:e4e2bfd:             int rows, int expectedRows) throws SQLException {
1:e4e2bfd:         println("========================================");
1:e4e2bfd:         println("START " + testId + "insertClob of size = " + cloblen);
1:d52bac6:         long ST = System.currentTimeMillis();
1:e4e2bfd:         int count = 0;
1:e4e2bfd: 
6:e4e2bfd:         for (int i = start; i < start + rows; i++) {
5:e4e2bfd:             ps.setInt(1, i);
5:e4e2bfd:             ps.setInt(2, 0);
2:e4e2bfd:             ps.setLong(3, cloblen);
1:e4e2bfd:             ps.setClob(4, clob);
5:e4e2bfd:             count += ps.executeUpdate();
1:e4e2bfd:         }
1:d52bac6:         commit();
1:e4e2bfd:         println("Insert Clob (" + cloblen + ")" + " rows= " + count + " = "
1:e4e2bfd:                 + (long) (System.currentTimeMillis() - ST));
1:e4e2bfd: 
1:e4e2bfd:         verifyTest(count, expectedRows, " Rows inserted with clob of size ("
1:e4e2bfd:                 + cloblen + ") =");
1:e4e2bfd:         println("========================================");
1:e4e2bfd: 
1:e4e2bfd:     }
1:e4e2bfd: 
1:e4e2bfd:     /**
1:7e79794:      * select from clob table
1:7e79794:      * 
1:7e79794:      * @param cloblen select expects to retrieve a clob of this length
1:7e79794:      * @param id id of the row to retrieve
1:7e79794:      * @param expectedRows number of rows expected to match id
1:7e79794:      */
1:d52bac6:     private void selectClob(String testId,
1:7e79794:             PreparedStatement ps, int cloblen, int id, int expectedRows)
1:7e79794:             throws SQLException {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + " - SELECT CLOB of size = "
1:7e79794:                 + cloblen);
1:e4e2bfd: 
1:7e79794:         int count = 0;
1:d52bac6:         long ST = System.currentTimeMillis();
1:e4e2bfd: 
1:7e79794:         ps.setInt(1, id);
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:7e79794:         while (rs.next()) {
1:7e79794:             count++;
1:7e79794:             Clob value = rs.getClob(1);
1:7e79794:             long l = value.length();
1:7e79794:             long dlen = rs.getLong(2);
1:7e79794:             assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:7e79794:                     + " expected " + dlen + " for row in CLOBTBL with ID="
1:7e79794:                     + id, l, dlen);
1:7e79794:         }
1:d52bac6:         rs.close();
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         println("Select Clob (" + cloblen + ")" + " rows= "
1:7e79794:                 + expectedRows + " = "
1:7e79794:                 + (long) (System.currentTimeMillis() - ST));
1:e4e2bfd: 
1:7e79794:         verifyTest(count, expectedRows,
1:7e79794:                 "Matched rows selected with clob of size(" + cloblen + ") =");
1:7e79794:         println("========================================");
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * insert clob into CLOBTBL2
1:7e79794:      * 
1:7e79794:      * @param cloblen length of clob to insert
1:7e79794:      * @param start id value for insert
1:7e79794:      * @param rows insert rows number of rows
1:7e79794:      * @param streamLength stream length passed to
1:7e79794:      *            setCharacterStream(pos,reader,streamLength)
1:7e79794:      * @param file name of the file that has data to be inserted
1:7e79794:      */
1:d52bac6:     private void insertClob2(String testId,
1:7e79794:             PreparedStatement ps, int cloblen, int start, int rows,
1:7e79794:             int streamLength, String file) throws Exception {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + "insert Clob of size = "
1:7e79794:                 + cloblen);
1:7e79794:         int count = 0;
1:d52bac6:         long ST = System.currentTimeMillis();
1:d52bac6:         for (int i = start; i < start + rows; i++) {
1:d52bac6:             FileReader reader = PrivilegedFileOpsForTests
1:e4e2bfd:                         .getFileReader(new File(file));
1:d52bac6:             try {
1:e4e2bfd:                 println("Got reader for file " + file + " " + reader);
1:e4e2bfd:                 ps.setInt(1, i);
1:e4e2bfd:                 ps.setInt(2, 0);
1:e4e2bfd:                 ps.setLong(4, cloblen);
1:e4e2bfd:                 ps.setCharacterStream(3, reader, streamLength);
1:e4e2bfd:                 count += ps.executeUpdate();
1:d52bac6:             } finally {
1:d52bac6:                 reader.close();
1:d52bac6:                 println("Closed reader for file " + file + " " + reader);
1:e4e2bfd:             }
1:e4e2bfd:         }
1:d52bac6:         commit();
1:7e79794: 
1:7e79794:         println("Insert Clob (" + cloblen + ")" + " rows= "
1:e4e2bfd:                    + count + " = " + (long) (System.currentTimeMillis() - ST));
1:7e79794:         verifyTest(count, rows, " Rows inserted with clob of size (" + cloblen
1:7e79794:                 + ") =");
1:7e79794:         println("========================================");
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /**
1:7e79794:      * select from clob table (CLOBTBL2)
1:7e79794:      * 
1:7e79794:      * @param cloblen select expects to retrieve a clob of this length
1:7e79794:      * @param id id of the row to retrieve
1:7e79794:      * @param expectedRows number of rows expected to match id
1:7e79794:      * @param file filename to compare the retrieved data against
1:7e79794:      */
1:d52bac6:     private void selectClob2(String testId,
1:7e79794:             PreparedStatement ps, int cloblen, int id, int expectedRows,
1:d52bac6:             String file) throws Exception {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + " - SELECT CLOB of size = "
1:7e79794:                 + cloblen);
1:e4e2bfd: 
1:d52bac6:         long ST = System.currentTimeMillis();
1:e4e2bfd: 
1:7e79794:         int count = 0;
1:7e79794:         ps.setInt(1, id);
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:e4e2bfd: 
1:7e79794:         while (rs.next()) {
1:7e79794:             count++;
1:7e79794:             Clob value = rs.getClob(1);
1:7e79794:             long l = value.length();
1:7e79794:             long dlen = rs.getLong(2);
1:7e79794:             assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:7e79794:                     + " expected " + dlen + " for row in CLOBTBL2 with ID="
1:7e79794:                     + id, l, cloblen);
1:7e79794:             compareClobToFile(value.getCharacterStream(), file, cloblen);
1:7e79794:         }
1:d52bac6: 
1:d52bac6:         rs.close();
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         verifyTest(count, expectedRows,
1:7e79794:                 "Matched rows selected with clob of size(" + cloblen + ") =");
1:e4e2bfd: 
1:7e79794:         println("Select Clob (" + cloblen + ")" + " rows= "
1:e4e2bfd:                    + expectedRows + " = "
1:e4e2bfd:                    + (long) (System.currentTimeMillis() - ST));
1:7e79794:         println("========================================");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /*
1:7e79794:      * Basically this test will do an update using setClob api - select row from
1:7e79794:      * clobtbl and then update a row in clobtbl and verify updated data in
1:7e79794:      * clobtbl
1:7e79794:      */
1:d52bac6:     private void selectUpdateClob(String testId,
1:d52bac6:             PreparedStatement ps, int cloblen, int id, int updateId) throws Exception {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + " - select and then update clob of size= "
1:7e79794:                 + cloblen + " - Uses setClob api");
1:e4e2bfd: 
1:7e79794:         ps.setInt(1, id);
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:7e79794:         rs.next();
1:7e79794:         Clob value = rs.getClob(1);
1:7e79794:         long l = value.length();
1:7e79794:         long dlen = rs.getLong(2);
1:7e79794:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:7e79794:                 + dlen + " for row in CLOBTBL with ID=" + id, dlen, l);
1:b862050:                 
1:b862050:         PreparedStatement psUpd =
1:b862050:                 prepareStatement("update CLOBTBL set content=?, "
1:b862050:                 + "dlen =? where id = ?");
1:b862050:         psUpd.setCharacterStream(1, value.getCharacterStream(), (int) l);
1:b862050:         psUpd.setLong(2, l);
1:b862050:         psUpd.setInt(3, updateId);
1:b862050:         if (usingDerbyNetClient()) {
1:b862050:             // DERBY-5317 cannot use setCharacterStream with value from
1:b862050:             // Clob.getCharacterStream because server will try to stream
1:b862050:             // lob to and from server at the same time. setClob can be
1:b862050:             // used as a work around.
1:b862050:             // Verify that new error is thrown 
1:b862050:             assertPreparedStatementError("XN023", psUpd);
1:b862050:             return;
1:b862050:         } else {
1:d52bac6:             assertUpdateCount(psUpd, 1);
1:f30426b:         }
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         // now select and verify that update went through ok.
1:7e79794:         ps.setInt(1, updateId);
1:7e79794:         ResultSet rs2 = ps.executeQuery();
1:7e79794:         rs2.next();
1:7e79794:         Clob updatedValue = rs2.getClob(1);
1:7e79794:         assertEquals(
1:7e79794:                 "FAIL - Retrieving the updated clob length does not match " +
1:7e79794:                         "expected length = " + l + " found = "
1:7e79794:                         + updatedValue.length(), l,
1:7e79794:                 updatedValue.length());
1:d52bac6: 
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         // close resultsets
1:7e79794:         rs.close();
1:7e79794:         rs2.close();
1:7e79794:         println("========================================");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /*
1:7e79794:      * Basically this test will do an update using setBlob api and verifies the
1:7e79794:      * updated data. select row from clobtbl2 and then update a row in clobtbl
1:7e79794:      * and verify updated data in clobtbl against the data in the original file
1:7e79794:      */
1:d52bac6:     private void selectUpdateClob2(String testId,
1:7e79794:             PreparedStatement ps, PreparedStatement sel, int cloblen, int id,
1:d52bac6:             int updateId, String file) throws Exception {
1:7e79794:         println("========================================");
1:7e79794:         println("START " + testId + " - select and then update clob of size= "
1:7e79794:                 + cloblen + " - Uses setClob api");
1:e4e2bfd: 
1:7e79794:         // retrieve row from clobtbl2
1:7e79794:         ps.setInt(1, id);
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:7e79794:         rs.next();
1:7e79794:         Clob value = rs.getClob(1);
1:7e79794:         long l = value.length();
1:7e79794:         long dlen = rs.getLong(2);
1:7e79794:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:7e79794:                 + dlen + " for row in CLOBTBL2 with ID=" + id, dlen, l);
1:e4e2bfd: 
1:f30426b:         PreparedStatement psUpd =
1:d52bac6:                prepareStatement("update CLOBTBL set content=?,dlen =? " +
1:7e79794:                                 "where id = ?");
1:7e79794:         psUpd.setClob(1, value);
1:f30426b:         psUpd.setLong(2, l);
1:f30426b:         psUpd.setInt(3, updateId);
1:e4e2bfd: 
1:d52bac6:         assertUpdateCount(psUpd, 1);
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         // now select and verify that update went through ok.
1:7e79794:         sel.setInt(1, updateId);
1:7e79794:         ResultSet rs2 = sel.executeQuery();
1:7e79794:         rs2.next();
1:7e79794:         Clob updatedValue = rs2.getClob(1);
1:7e79794:         assertEquals("FAIL - MISMATCH length of updated clob value , found=" +
1:7e79794:                    updatedValue.length() + ",expected = " + l, l, updatedValue
1:7e79794:                 .length());
1:7e79794:         compareClobToFile(updatedValue.getCharacterStream(), file, (int) l);
1:d52bac6:         commit();
1:7e79794: 
1:7e79794:         // close resultsets
1:7e79794:         rs.close();
1:7e79794:         rs2.close();
1:7e79794:         println("========================================");
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     /*
1:7e79794:      * Basically this test will do an update using updateClob api and verifies
1:7e79794:      * the updated data. select row from clobtbl2 and then update a row in
1:7e79794:      * clobtbl and verify updated data in clobtbl against the data in the
1:7e79794:      * original file
2:7e79794:      * 
1:7e79794:      * @param updateRowId id of the row that needs to be updated
1:7e79794:      */
1:d52bac6:     private void updateClob2(String testId,
1:7e79794:             PreparedStatement sel,
1:d52bac6:             int cloblen, int id, int updateRowId, int updateIdVal, String file)
1:d52bac6:             throws Exception {
1:d52bac6:         println("========================================");
1:d52bac6:         println("START " + testId
1:7e79794:                 + " - select and then update clob of size= "
1:7e79794:                 + cloblen + " - Uses updateClob api");
1:7e79794: 
1:7e79794:         PreparedStatement ps1 =
1:d52bac6:                         prepareStatement("SELECT * FROM CLOBTBL FOR UPDATE",
1:7e79794:                                 ResultSet.TYPE_FORWARD_ONLY,
1:7e79794:                                 ResultSet.CONCUR_UPDATABLE);
1:7e79794:         PreparedStatement ps =
1:d52bac6:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 " +
1:7e79794:                         "where ID =?");
1:7e79794: 
1:7e79794:         ps.setInt(1, id);
1:7e79794:         // retrieve row from clobtbl2
1:d52bac6:         ResultSet rs = ps.executeQuery();
1:7e79794:         rs.next();
1:7e79794:         Clob value = rs.getClob(1);
1:7e79794:         long l = value.length();
1:7e79794:         long dlen = rs.getLong(2);
1:7e79794:         if (dlen != l) {
1:d52bac6:             println("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:7e79794:                             + dlen + " for row in CLOBTBL2 with ID=" + id);
1:7e79794:         }
1:7e79794: 
1:7e79794:         ResultSet rs1 = ps1.executeQuery();
1:7e79794:         while (rs1.next()) {
1:7e79794:             if (rs1.getInt(1) == updateRowId) {
1:e4e2bfd:                 rs1.updateClob(4, value);
1:e4e2bfd:                 rs1.updateInt(1, updateIdVal);
1:e4e2bfd:                 rs1.updateInt(2, 0);
1:e4e2bfd:                 rs1.updateLong(3, dlen);
1:e4e2bfd:                 rs1.updateRow();
21:e4e2bfd:                 break;
1:e4e2bfd:             }
1:e4e2bfd:         }
1:d52bac6: 
1:d52bac6:         commit();
1:e4e2bfd: 
1:7e79794:         // close resultsets
1:7e79794:         rs.close();
1:7e79794:         rs1.close();
1:e4e2bfd: 
1:7e79794:         // verify
1:7e79794:         // now select and verify that update went through ok.
1:7e79794:         sel.setInt(1, updateIdVal);
1:7e79794:         ResultSet rs2 = sel.executeQuery();
1:7e79794:         rs2.next();
1:7e79794:         Clob updatedValue = rs2.getClob(1);
1:8c86e54:         assertEquals("FAIL - MISMATCH length of updated clob value ," +
1:8c86e54:                 "found=" + 
1:8c86e54:                 updatedValue.length() + ",expected = " + l,
1:8c86e54:                 l, updatedValue.length());
1:8c86e54:         compareClobToFile(updatedValue.getCharacterStream(), file, (int) l);
1:e4e2bfd: 
1:7e79794:         if (updatedValue.length() != l) {
1:d52bac6:             println("FAIL - MISMATCH length of updated clob value ," +
1:7e79794:                             "found="
1:7e79794:                             +
1:7e79794:                             updatedValue.length() + ",expected = " + l);
1:7e79794:         } else
1:7e79794:             compareClobToFile(updatedValue.getCharacterStream(), file, (int) l);
1:e4e2bfd: 
1:d52bac6:         println("========================================");
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     private static void compareClobToFile(Reader lobstream, String filename,
1:7e79794:             int length)
1:7e79794:             throws Exception {
1:7e79794:         FileReader file = PrivilegedFileOpsForTests.getFileReader(
1:7e79794:                    new File(filename));
1:7e79794:         int c1 = 0;
1:7e79794:         int c2 = 0;
1:7e79794:         long count = 0;
1:7e79794:         do {
1:7e79794:             c1 = lobstream.read();
1:7e79794:             c2 = file.read();
1:7e79794:             assertEquals(
1:7e79794:                     "FAIL -- MISMATCH in data stored versus data retrieved at "
2:7e79794:                             +
1:7e79794:                             count + " " + c1 + " does not match " + c2,
1:7e79794:                     c2, c1);
1:7e79794:             count++;
1:7e79794:             length--;
1:7e79794:         } while (c1 != -1 && c2 != -1 && length > 0);
1:7e79794:         file.close();
1:7e79794:     }
1:7e79794: 
1:7e79794:     private static void verifyTest(int affectedRows, int expectedRows,
1:7e79794:             String test) {
1:7e79794:         assertEquals("FAIL --" + test + affectedRows
1:7e79794:                 + " , but expected rows =" + expectedRows, expectedRows,
1:7e79794:                 affectedRows);
1:7e79794:         println(test + affectedRows);
1:7e79794:     }
1:7e79794: 
1:7e79794:     private static void writeToFile(String file, Reader r)
1:7e79794:             throws IOException {
1:7e79794:         // does file exist, if so delete and write to a fresh file
1:7e79794:         File f = new File(file);
1:7e79794:         if (PrivilegedFileOpsForTests.exists(f)) {
1:7e79794:             assertTrue(PrivilegedFileOpsForTests.delete(f));
1:7e79794:         }
1:7e79794:         FileWriter writer = PrivilegedFileOpsForTests.getFileWriter(f);
1:7e79794:         println("Got FileWriter for " + file + " " + writer);
1:7e79794:         // write in chunks of 32k buffer
1:7e79794:         char[] buffer = new char[32 * 1024];
1:7e79794:         int count = 0;
1:7e79794: 
1:7e79794:         while ((count = r.read(buffer)) >= 0)
1:7e79794:             writer.write(buffer, 0, count);
1:7e79794:         writer.flush();
1:7e79794:         writer.close();
1:7e79794:         println("writer " + writer + " for file " + file + " closed");
1:7e79794:     }
1:e4e2bfd: }
1:e4e2bfd: 
1:e4e2bfd: /**
1:e4e2bfd:  * Class to generate random byte data
1:e4e2bfd:  */
1:e4e2bfd: class RandomByteStreamT extends java.io.InputStream {
1:7e79794:     private long length;
1:e4e2bfd: 
1:7e79794:     private java.util.Random dpr;
1:e4e2bfd: 
1:7e79794:     RandomByteStreamT(java.util.Random dpr, long length) {
1:7e79794:         this.length = length;
1:7e79794:         this.dpr = dpr;
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public int read() {
1:7e79794:         if (length <= 0)
1:7e79794:             return -1;
1:e4e2bfd: 
1:7e79794:         length--;
1:7e79794:         return (byte) (dpr.nextInt() >>> 25);
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public int read(byte[] data, int off, int len) {
1:e4e2bfd: 
1:7e79794:         if (length <= 0)
1:7e79794:             return -1;
1:e4e2bfd: 
1:7e79794:         if (len > length)
1:7e79794:             len = (int) length;
1:e4e2bfd: 
1:7e79794:         for (int i = 0; i < len; i++) {
1:7e79794:             // chop off bits and return a +ve byte value.
1:7e79794:             data[off + i] = (byte) (dpr.nextInt() >>> 25);
1:7e79794:         }
1:e4e2bfd: 
1:7e79794:         length -= len;
1:7e79794:         return len;
1:7e79794:     }
1:e4e2bfd: }
1:e4e2bfd: 
1:e4e2bfd: /*
1:e4e2bfd:  * Class to generate random char data, generates 1,2,3bytes character.
1:e4e2bfd:  */
1:e4e2bfd: class RandomCharReaderT extends java.io.Reader {
1:7e79794:     private long length;
1:7e79794:     private long numTrailingSpaces;
1:e4e2bfd: 
1:7e79794:     private java.util.Random dpr;
1:e4e2bfd: 
1:7e79794:     RandomCharReaderT(java.util.Random dpr, long length) {
1:7e79794:         this.length = length;
1:7e79794:         this.dpr = dpr;
1:7e79794:         this.numTrailingSpaces = 0;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     RandomCharReaderT(java.util.Random dpr, long length, long numTrailingSpaces) {
1:7e79794:         this.length = length;
1:7e79794:         this.dpr = dpr;
1:7e79794:         this.numTrailingSpaces = numTrailingSpaces;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     private int randomInt(int min, int max) {
1:7e79794:         return dpr.nextInt(max - min) + min;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     private char getChar() {
1:7e79794:         // return space for trailing spaces.
1:7e79794:         if (length <= numTrailingSpaces) {
1:7e79794:             return ' ';
1:7e79794:         }
1:e4e2bfd: 
1:7e79794:         double drand = dpr.nextDouble();
1:7e79794:         char c = 'a';
1:7e79794:         if (drand < 0.25)
1:7e79794:             c = (char) randomInt((int) 'A', (int) 'Z');
1:7e79794:         else if (drand < 0.5)
1:7e79794:             switch (randomInt(1, 10)) {
1:7e79794:             case 1:
1:7e79794:                 c = '\u00c0';
1:7e79794:                 break;
1:7e79794:             case 2:
1:7e79794:                 c = '\u00c1';
1:7e79794:                 break;
1:7e79794:             case 3:
1:7e79794:                 c = '\u00c2';
1:7e79794:                 break;
1:7e79794:             case 4:
1:7e79794:                 c = '\u00ca';
1:7e79794:                 break;
1:7e79794:             case 5:
1:7e79794:                 c = '\u00cb';
1:7e79794:                 break;
1:7e79794:             case 6:
1:7e79794:                 c = '\u00d4';
1:7e79794:                 break;
1:7e79794:             case 7:
1:7e79794:                 c = '\u00d8';
1:7e79794:                 break;
1:7e79794:             case 8:
1:7e79794:                 c = '\u00d1';
1:7e79794:                 break;
1:7e79794:             case 9:
1:7e79794:                 c = '\u00cd';
1:7e79794:                 break;
1:7e79794:             default:
1:7e79794:                 c = '\u00dc';
1:7e79794:                 break;
1:7e79794:             }
1:7e79794:         else if (drand < 0.75)
1:7e79794:             c = (char) randomInt((int) 'a', (int) 'z');
1:7e79794:         else if (drand < 1.0)
1:7e79794:             switch (randomInt(1, 10)) {
1:7e79794:             case 1:
1:7e79794:                 c = '\u00e2';
1:7e79794:                 break;
1:7e79794:             case 2:
1:7e79794:                 c = '\u00e4';
1:7e79794:                 break;
1:7e79794:             case 3:
1:7e79794:                 c = '\u00e7';
1:7e79794:                 break;
1:7e79794:             case 4:
1:7e79794:                 c = '\u00e8';
1:7e79794:                 break;
1:7e79794:             case 5:
1:7e79794:                 c = '\u00ec';
1:7e79794:                 break;
1:7e79794:             case 6:
1:7e79794:                 c = '\u00ef';
1:7e79794:                 break;
1:7e79794:             case 7:
1:7e79794:                 c = '\u00f6';
1:7e79794:                 break;
1:7e79794:             case 8:
1:7e79794:                 c = '\u00f9';
1:7e79794:                 break;
1:7e79794:             case 9:
1:7e79794:                 c = '\u00fc';
1:7e79794:                 break;
1:7e79794:             default:
1:7e79794:                 c = '\u00e5';
1:7e79794:                 break;
1:7e79794:             }
1:e4e2bfd: 
1:7e79794:         return c;
1:e4e2bfd: 
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public int read() {
1:7e79794:         if (length <= 0)
1:7e79794:             return -1;
1:e4e2bfd: 
1:7e79794:         length--;
1:7e79794:         return getChar();
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public int read(char[] data, int off, int len) {
1:e4e2bfd: 
1:7e79794:         if (length <= 0)
1:7e79794:             return -1;
1:e4e2bfd: 
1:7e79794:         if (len > length)
1:7e79794:             len = (int) length;
1:e4e2bfd: 
1:7e79794:         for (int i = 0; i < len; i++) {
1:7e79794:             data[off + i] = getChar();
1:7e79794:             length -= 1;
1:7e79794:         }
1:e4e2bfd: 
1:7e79794:         return len;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public void close() {
1:7e79794: 
1:7e79794:     }
1:e4e2bfd: }
1:e4e2bfd: 
1:e4e2bfd: /**
1:7e79794:  * Class used to simulate a 4GB Clob implementation to check whether derby
1:7e79794:  * implements such large Clobs correctly. Derby throws an error if the clob size
1:7e79794:  * exceeds 2GB
1:e4e2bfd:  **/
1:e4e2bfd: 
1:e4e2bfd: class ClobImplT implements java.sql.Clob {
1:7e79794:     long length;
1:7e79794:     Reader myReader;
1:e4e2bfd: 
1:7e79794:     public ClobImplT(Reader myReader, long length) {
1:7e79794:         this.length = length;
1:7e79794:         this.myReader = myReader;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public long length() throws SQLException {
1:7e79794:         return length;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public String getSubString(long pos, int length) throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public java.io.Reader getCharacterStream() throws SQLException {
1:7e79794:         return myReader;
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public java.io.InputStream getAsciiStream() throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public long position(String searchstr, long start) throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public long position(Clob searchstr, long start) throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public int setString(long pos, String str) throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public int setString(long pos, String str, int offset, int len)
1:7e79794:             throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public java.io.OutputStream setAsciiStream(long pos) throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public java.io.Writer setCharacterStream(long pos) throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794:     public void truncate(long len) throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:7e79794: 
1:890e5d2:     public void free() throws SQLException {
1:890e5d2:         throw new SQLException("Not implemented");
1:890e5d2:     }
1:890e5d2: 
1:7e79794:     public Reader getCharacterStream(long pos, long length) throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:7e79794:     }
1:e4e2bfd: 
1:7e79794: }
1:e4e2bfd: 
1:e4e2bfd: /***
1:7e79794:  * Class to simulate a 4Gb blob impl in order to test if Derby handles such
1:7e79794:  * large blobs correctly. The main methods here are only the length() and the
1:7e79794:  * getBinaryStream(). Rest are just placeholders/dummy methods in order to
1:7e79794:  * implement the java.sql.Blob interface ---- Derby throws an error if the blob
1:7e79794:  * length exceeds the max range of int.
1:e4e2bfd:  */
1:7e79794: class BlobImplT implements java.sql.Blob {
2:e4e2bfd:     long length;
1:e4e2bfd:     InputStream myStream;
1:7e79794: 
1:7e79794:     public BlobImplT(InputStream is, long length) {
1:e4e2bfd:         this.myStream = is;
5:e4e2bfd:         this.length = length;
1:e4e2bfd:     }
1:7e79794: 
1:e4e2bfd:     public InputStream getBinaryStream()
1:7e79794:             throws SQLException {
1:e4e2bfd:         return myStream;
1:e4e2bfd:     }
1:7e79794: 
1:e4e2bfd:     public byte[] getBytes()
1:7e79794:             throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:e4e2bfd:     }
1:7e79794: 
1:e4e2bfd:     public long length()
1:7e79794:             throws SQLException {
2:e4e2bfd:         return length;
1:e4e2bfd:     }
1:7e79794: 
1:7e79794:     public long position(Blob pattern, long start)
1:7e79794:             throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:e4e2bfd:     }
1:7e79794: 
1:7e79794:     public long position(byte[] pattern, long start)
1:7e79794:             throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:e4e2bfd:     }
1:7e79794: 
1:e4e2bfd:     public OutputStream setBinaryStream(long pos)
1:7e79794:             throws SQLException
1:7e79794: 
30:e4e2bfd:     {
1:7e79794:         throw new SQLException("Not implemented");
1:e4e2bfd:     }
1:7e79794: 
1:7e79794:     public int setBytes(long pos, byte[] bytes)
1:7e79794:             throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:e4e2bfd:     }
1:7e79794: 
1:7e79794:     public int setBytes(long pos, byte[] bytes, int offset, int len)
1:7e79794:             throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:e4e2bfd:     }
1:7e79794: 
1:e4e2bfd:     public void truncate(long len)
1:7e79794:             throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:e4e2bfd:     }
1:7e79794: 
1:e4e2bfd:     public byte[] getBytes(long pos, int length)
1:7e79794:             throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:e4e2bfd:     }
1:7e79794: 
1:7e79794:     public void free() throws SQLException {
1:7e79794:         throw new SQLException("Not implemented");
1:e4e2bfd:     }
1:e4e2bfd: 
1:890e5d2:     public InputStream getBinaryStream(long pos, long length) throws SQLException {
1:890e5d2:         throw new SQLException("Not implemented");
1:890e5d2:     }
1:890e5d2: 
1:e4e2bfd: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileOutputStream;
1: import java.io.FileReader;
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         Test suite =
1:                 new CleanDatabaseTestSetup(
1:                         new BaseTestSuite(LobLimitsTest.class)) {
1:             @Override
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:b862050
/////////////////////////////////////////////////////////////////////////
1:                 
1:         PreparedStatement psUpd =
1:                 prepareStatement("update CLOBTBL set content=?, "
1:                 + "dlen =? where id = ?");
1:         psUpd.setCharacterStream(1, value.getCharacterStream(), (int) l);
1:         psUpd.setLong(2, l);
1:         psUpd.setInt(3, updateId);
1:         if (usingDerbyNetClient()) {
1:             // DERBY-5317 cannot use setCharacterStream with value from
1:             // Clob.getCharacterStream because server will try to stream
1:             // lob to and from server at the same time. setClob can be
1:             // used as a work around.
1:             // Verify that new error is thrown 
1:             assertPreparedStatementError("XN023", psUpd);
1:             return;
1:         } else {
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:890e5d2
/////////////////////////////////////////////////////////////////////////
1:     public void free() throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1: 
1:     public InputStream getBinaryStream(long pos, long length) throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1: 
commit:0f3e1f6
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(file, lobstream);
commit:d52bac6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         insertBlob_SetBinaryStream("BlobTest #1", insertBlob,
1:         selectBlob("BlobTest #2", selectBlob, BIGGEST_LOB_SZ, 0, 1);
1:         selectBlob("BlobTest #3", selectBlob, BIGGEST_LOB_SZ, 1, 1);
1:         selectUpdateBlob("BlobTest #4", selectBlob, BIGGEST_LOB_SZ, 0, 1);
1:         selectInsertBlob("BlobTest #4.1", selectBlob, insertBlob,
1:                 BIGGEST_LOB_SZ, 0, 3);
/////////////////////////////////////////////////////////////////////////
1:         insertBlob2("BlobTest #5.1 ", insertBlob2, BIG_LOB_SZ, 0, 1,
1:         selectBlob2("BlobTest #5.2 ", selectBlob2, BIG_LOB_SZ, 0, 1,
1:         selectUpdateBlob2("BlobTest #6", selectBlob2, selectBlob,
1:                 BIG_LOB_SZ, 0, 1, DATAFILE);
0:         deleteTable("BLOBTBL2", 1);
1:         commit();
0:         deleteTable("BLOBTBL", 3);
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:             insertBlob_SetBlob("BlobTest #7 (setBlob with 4Gb blob",
/////////////////////////////////////////////////////////////////////////
1:             commit();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         insertClob_SetCharacterStream("ClobTest #1", insertClob,
1:         selectClob("ClobTest #2", selectClob, BIGGEST_LOB_SZ, 0, 1);
1:         selectClob("ClobTest #3", selectClob, BIGGEST_LOB_SZ, 0, 1);
1:         selectUpdateClob("ClobTest #4", selectClob, BIGGEST_LOB_SZ, 0, 1);
/////////////////////////////////////////////////////////////////////////
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         insertClob2("ClobTest #5.1 ", insertClob2, BIG_LOB_SZ, 0, 1,
1:         selectClob2("ClobTest #5.2 ", selectClob2, BIG_LOB_SZ, 0, 1,
0:         // updateClob2("ClobTest #8.1",selectClob,BIG_LOB_SZ,0,0,10,CHARDATAFILE);
1:         selectUpdateClob2("ClobTest #8.2", selectClob2, selectClob,
1:                 BIG_LOB_SZ, 0, 1, CHARDATAFILE);
/////////////////////////////////////////////////////////////////////////
1:         insertClob2("ClobTest #6.1 ", insertClob2, BIG_LOB_SZ, 3, 1,
1:         selectClob2("ClobTest #6.2 ", selectClob2, BIG_LOB_SZ, 3, 1,
1:         setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         negativeSpaceTruncationTest("ClobTest #7");
/////////////////////////////////////////////////////////////////////////
1:                 insertClob2("ClobTest #9.1 ", insertClob2,
/////////////////////////////////////////////////////////////////////////
1:         selectClob2("ClobTest #9.2 ", selectClob2, BIG_LOB_SZ, 4, 0,
1:             insertClob2("ClobTest #10 ", insertClob2,
/////////////////////////////////////////////////////////////////////////
1:             insertClob2("ClobTest #11 ", insertClob2,
/////////////////////////////////////////////////////////////////////////
0:         deleteTable("CLOBTBL2", 2);
1:             insertClob_SetCharacterStream("ClobTest #12.1", insertClob,
1:         selectClob("ClobTest #12.2", selectClob, BIG_LOB_SZ, 4, 0);
0:         deleteTable("CLOBTBL", 2);
/////////////////////////////////////////////////////////////////////////
1:             insertClob_SetClob("ClobTest #13 (setClob with 4Gb clob",
/////////////////////////////////////////////////////////////////////////
1:     private void negativeSpaceTruncationTest(String msg)
1:         PreparedStatement insertClob2 =
1:                 prepareStatement("INSERT INTO CLOBTBL2 values (?,?,?,?)");
1:             insertClob2(msg, insertClob2, BIG_LOB_SZ, 4, 1,
/////////////////////////////////////////////////////////////////////////
1:             insertClob2(msg, insertClob2, BIG_LOB_SZ, 5, 1,
/////////////////////////////////////////////////////////////////////////
1:     private void insertBlob_SetBinaryStream(String testId, PreparedStatement ps, int bloblen, int start,
1:         long ST = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void insertBlob_SetBlob(String testId,
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void selectBlob(String testId,
1:         long ST = System.currentTimeMillis();
1:         ResultSet rs = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
1: 
1:         rs.close();
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void insertBlob2(String testId,
1:         long ST = System.currentTimeMillis();
1:             FileInputStream fis =
1:                 PrivilegedFileOpsForTests.getFileInputStream(new File(file));
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void selectBlob2(String testId,
1:         long ST = System.currentTimeMillis();
1:         ResultSet rs = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
1: 
1:         rs.close();
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void selectUpdateBlob(String testId,
1:             PreparedStatement ps, int bloblen, int id, int updateId)
1:             throws Exception {
1:         ResultSet rs = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:                 prepareStatement("update BLOBTBL set content=?,dlen =?" +
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void selectInsertBlob(String testId,
1:             int insertId) throws Exception {
1:         ResultSet rs = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:         assertUpdateCount(ins, 1);
1:         commit();
/////////////////////////////////////////////////////////////////////////
1: 
1:         commit();
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void selectUpdateBlob2(String testId,
1:             int updateId, String file) throws Exception {
1:         ResultSet rs = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:                 prepareStatement("update BLOBTBL set content=?,dlen =?" +
1:         assertUpdateCount(psUpd, 1);
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1: 
/////////////////////////////////////////////////////////////////////////
0:     private void deleteTable(String table,
0:         int count = createStatement().executeUpdate(
1:                 "DELETE FROM " + JDBC.escape(table));
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void insertClob_SetCharacterStream(String testId, PreparedStatement ps, int cloblen, int start,
1:         long ST = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void insertClob_SetClob(String testId,
1:         long ST = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void selectClob(String testId,
1:         long ST = System.currentTimeMillis();
1:         ResultSet rs = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:         rs.close();
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void insertClob2(String testId,
1:         long ST = System.currentTimeMillis();
1:         for (int i = start; i < start + rows; i++) {
1:             FileReader reader = PrivilegedFileOpsForTests
1:             try {
1:             } finally {
1:                 reader.close();
1:                 println("Closed reader for file " + file + " " + reader);
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void selectClob2(String testId,
1:             String file) throws Exception {
1:         long ST = System.currentTimeMillis();
1:         ResultSet rs = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
1: 
1:         rs.close();
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void selectUpdateClob(String testId,
1:             PreparedStatement ps, int cloblen, int id, int updateId) throws Exception {
1:         ResultSet rs = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
0:                     prepareStatement("update CLOBTBL set content=?, " +
1:             assertUpdateCount(psUpd, 1);
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         commit();
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void selectUpdateClob2(String testId,
1:             int updateId, String file) throws Exception {
1:         ResultSet rs = ps.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:                prepareStatement("update CLOBTBL set content=?,dlen =? " +
1:         assertUpdateCount(psUpd, 1);
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:         commit();
/////////////////////////////////////////////////////////////////////////
1:     private void updateClob2(String testId,
1:             int cloblen, int id, int updateRowId, int updateIdVal, String file)
1:             throws Exception {
1:         println("========================================");
1:         println("START " + testId
1:                         prepareStatement("SELECT * FROM CLOBTBL FOR UPDATE",
1:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 " +
1:         ResultSet rs = ps.executeQuery();
1:             println("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
/////////////////////////////////////////////////////////////////////////
1: 
1:         commit();
1: 
/////////////////////////////////////////////////////////////////////////
1:             println("FAIL - MISMATCH length of updated clob value ," +
1:         println("========================================");
commit:543e809
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return baseSuite(_2GB, _100MB);
1:     }
1: 
1:     /**
1:      * Create an instance of the {@code LobLimitsTest} suite.
1:      *
1:      * @param biggestSize the size of the biggest LOB to test
1:      * @param bigSize the size of a typical big LOB to test
1:      * @return a test suite
1:      */
1:     static Test baseSuite(final int biggestSize, final int bigSize) {
1:         // Some of the test cases depend on certain other test cases to run
1:         // first, so force the test cases to run in lexicographical order.
0:                 TestConfiguration.orderedSuite(LobLimitsTest.class)) {
1:                 setupTables(s, biggestSize, bigSize);
/////////////////////////////////////////////////////////////////////////
1:     public void test_01_Blob() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void test_02_BlobNegative() throws SQLException {
/////////////////////////////////////////////////////////////////////////
1:     public void test_03_Clob1() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void test_04_Clob2() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:     public void test_05_ClobNegative() throws Exception {
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:6a072f8
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:     	//Run the suite with following properties in case we run into lock
1:     	// time out issues. It will help debug the problem if timeouts occur.
1:         Properties sysprops = new Properties();
1:         sysprops.setProperty("derby.locks.deadlockTrace", "true");
1:         sysprops.setProperty("derby.locks.monitor", "true");
/////////////////////////////////////////////////////////////////////////
1:         suite = new SystemPropertyTestSetup(suite,sysprops);
commit:3ce7ebd
/////////////////////////////////////////////////////////////////////////
1:         deleteAndTruncateTable("BLOBTBL2", 1);
1:         deleteAndTruncateTable("BLOBTBL", 3);
/////////////////////////////////////////////////////////////////////////
1:         deleteAndTruncateTable("CLOBTBL2", 2);
/////////////////////////////////////////////////////////////////////////
1:         deleteAndTruncateTable("CLOBTBL", 2);
/////////////////////////////////////////////////////////////////////////
1:     //DERBY-5638
1:     // Following shutdown will ensure that all the logs are applied to the
1:     // database and hence there are no unapplied log files left at the end 
1:     // of the suite. 
1:     //This test deals will large data objects which can cause us to have 
1:     // large log files and if the database is not shutdown at the end of the 
1:     // suite, the suite will finish successfully but will leave a database 
1:     // directory with large number of big log files. Nightly machines which
1:     // run this suite on a regular basis can eventually run out of disk space
1:     // if those machines do not delete the database directories from multiple 
1:     // runs.
1:     public void test_06_shutdownDB() throws Exception {
1:         TestConfiguration.getCurrent().shutdownDatabase();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     private void deleteAndTruncateTable(String table,
1:     	Statement s = createStatement();
1:         //Keep the delete call to exercise delete of long blobs and clobs.
1:     	// This is a separate code path through Derby compared to truncate
1:     	// table code path.
1:         int count = s.executeUpdate(
1:         //DERBY-5638
1:         //Adding truncate call which will give back the disk space being 
1:         // used by the table at commit time rather than wait for test 
1:         // infrastructure to drop the table.
1:         s.executeUpdate("TRUNCATE TABLE " + JDBC.escape(table));
commit:b24d2b4
/////////////////////////////////////////////////////////////////////////
1:         rollback();
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:8c86e54
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-5344 updateClob2 test in LobLimitsTest gets OutOfMemoryError 
1:         // on updateRow with embedded
1:         // Disabled for embedded for the big test for now, this will materialize.
1:         // As part of DERBY-1903 / DERBY-5344, the test was enabled for 
1:         // client. That issue will have reference to the materialization bug when 
1:         // it is found or filed.
1:         if (!(usingEmbedded()  && BIGGEST_LOB_SZ  == _2GB)) {
1:             updateClob2("ClobTest #8.1",selectClob,BIG_LOB_SZ,0,0,10,CHARDATAFILE);
1:         }
/////////////////////////////////////////////////////////////////////////
1:         assertEquals("FAIL - MISMATCH length of updated clob value ," +
1:                 "found=" + 
1:                 updatedValue.length() + ",expected = " + l,
1:                 l, updatedValue.length());
1:         compareClobToFile(updatedValue.getCharacterStream(), file, (int) l);
commit:f30426b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             fail("Inserting 4BG blob should have thrown exception");
1:             if (usingDerbyNetClient()) {
1:                 // DERBY-5338 client gives wrong SQLState and protocol error
1:                 // inserting a 4GB clob. Should be 22003
1:                 assertSQLState("XN015",sqle);
1:             } else {
1:                 assertSQLState("22003", sqle);
1:             }
0:             conn.commit();
/////////////////////////////////////////////////////////////////////////
1:         // DERBY-5341 : Client allows clob larger than
1:         // column width to be inserted.
1:         if (!usingDerbyNetClient()) {
1:             try {
0:                 insertClob2("ClobTest #9.1 ", conn, insertClob2,
1:                         MORE_DATA_THAN_COL_WIDTH, 4, 1,
1:                         MORE_DATA_THAN_COL_WIDTH, CHARDATAFILE);
1:                 fail("ClobTest #9.1 " + "should have thrown XSDA4");
1:             } catch (SQLException sqle) {
1:                 assertSQLState("XSDA4", sqle);
1:             }
1:             fail("ClobTest #10. Should have thrown XSDA4");
/////////////////////////////////////////////////////////////////////////
1:             fail("ClobTest #11. Should have thrown XSDA4");
/////////////////////////////////////////////////////////////////////////
1:             fail("ClobTest #12. Should have thrown XJ025");
/////////////////////////////////////////////////////////////////////////
1:             fail("ClobTest #13. Should have thrown 22033");
1:          // DERBY DOES NOT SUPPORT INSERT OF 4GB CLOB
1:             if (usingDerbyNetClient()) {
1:                 // DERBY-5338 client gives wrong SQLState and protocol error
1:                 // inserting a 4GB clob. Should be 22003
1:                 assertSQLState("XN015",sqle);
1:             } else {
1:                 assertSQLState("22003", sqle);
1:             }
/////////////////////////////////////////////////////////////////////////
1:             fail(msg +". Should have thrown XSDA4");
/////////////////////////////////////////////////////////////////////////
1:             fail(msg + ". Should have thrown XSDA4");
/////////////////////////////////////////////////////////////////////////
0:         // DERBY-5317 cannot use setCharacterStream with value from
0:         // Clob.getCharacterStream because server will try to stream
0:         // lob to and from server at the same time. setClob can be
0:         // used as a work around.
0:         if (!usingDerbyNetClient()) {
1:             PreparedStatement psUpd =
0:                     conn.prepareStatement("update CLOBTBL set content=?, " +
0:                             "dlen =? where id = ?");
0:             psUpd.setCharacterStream(1, value.getCharacterStream(), (int) l);
1:             psUpd.setLong(2, l);
1:             psUpd.setInt(3, updateId);
0:             assertEquals(1, psUpd.executeUpdate());
0:             psUpd.close();
1:         }
/////////////////////////////////////////////////////////////////////////
commit:7e79794
/////////////////////////////////////////////////////////////////////////
1:  */
/////////////////////////////////////////////////////////////////////////
1:  * This test is part of the "largedata" suite because this test tests data for
1:  * lobs to the limits ( ie blob and clob can be 2G-1 maximum) and so this test
1:  * may take considerable disk space as well as time to run. Hence it is not part
1:  * of the derbyall suite but should ideally be run at some intervals to test if
1:  * no regression has occurred.
1:  */
1:     public LobLimitsTest(String name) {
1:     static boolean trace = false;
1:     static final int _2GB = 2 * 1024 * 1024 * 1024 - 1;
1:     static final int _100MB = 100 * 1024 * 1024;
1:     static final long _4GB = 4 * 1024 * 1024 * (1024L);
1:     static final int NUM_TRAILING_SPACES = 33 * 1024;
1:     static int BIGGEST_LOB_SZ = _2GB;
1:     public static void setBIGGEST_LOB_SZ(int bIGGESTLOBSZ) {
1:         BIGGEST_LOB_SZ = bIGGESTLOBSZ;
1:     }
1:     static int BIG_LOB_SZ = _100MB;
1:     public static void setBIG_LOB_SZ(int bIGLOBSZ) {
1:         BIG_LOB_SZ = bIGLOBSZ;
1:     }
1:     static int MORE_DATA_THAN_COL_WIDTH = (_100MB) + 1;
1:     public static void setMORE_DATA_THAN_COL_WIDTH(int mOREDATATHANCOLWIDTH) {
1:         MORE_DATA_THAN_COL_WIDTH = mOREDATATHANCOLWIDTH;
1:     }
1:     static final String DATAFILE = "extinout/byteLobLimits.dat";
1: 
1:     static final String CHARDATAFILE = "extinout/charLobLimits.txt";
1: 
1:      * 
1:      * @param biggestlobsz
1:     static void setupTables(Statement s, int biggestlobsz, int biglobsz)
1:             throws SQLException {
1:         setBIGGEST_LOB_SZ(biggestlobsz);
1:         setBIG_LOB_SZ(biglobsz);
1:         setMORE_DATA_THAN_COL_WIDTH(biglobsz + 1);
1:         println("BIGGEST_LOB_SZ=" + BIGGEST_LOB_SZ + " BIG_LOB_SZ="
1:                 + BIG_LOB_SZ);
0:         Connection conn = s.getConnection();
0:         conn.setAutoCommit(true);
1:         s.execute("CREATE TABLE BLOBTBL (ID INT NOT NULL PRIMARY KEY, "
1:                 + "POS BIGINT, DLEN BIGINT, CONTENT BLOB(2G))");
1:         s.execute("CREATE TABLE CLOBTBL (ID INT NOT NULL PRIMARY KEY,"
1:                 + "POS BIGINT, DLEN BIGINT, CONTENT CLOB(2G))");
1:         s.execute("CREATE TABLE BLOBTBL2 (ID INT NOT NULL PRIMARY KEY, "
1:                 + "POS BIGINT, CONTENT BLOB(" + BIG_LOB_SZ + "),DLEN BIGINT)");
1:         // Please dont change the clob column width,since tests use this width
1:         // to
1:         // test for truncation of trailing spaces.
1:         s.execute("CREATE TABLE CLOBTBL2 (ID INT NOT NULL PRIMARY KEY,"
1:                 + "POS BIGINT, CONTENT CLOB(" + BIG_LOB_SZ + "), DLEN BIGINT)");
1:     }
1:     public static Test suite() {
1:         // Right now run just with embeddded.
0:         Test suite = new CleanDatabaseTestSetup(
0:                 new TestSuite(LobLimitsTest.class)) {
1:             protected void decorateSQL(Statement s)
0:                 setupTables(s, _2GB, _100MB);
1:             }
1:         };
1:         return new SupportFilesSetup(suite);
1:     }
1: 
1:     /**
1:      * tests specific for blobs
1:      * 
0:      * @param conn
1:      * @throws Exception
1:      */
0:     public void testBlob() throws Exception {
0:         Connection conn = getConnection();
0:         conn.setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
1:         // Test - 2Gb blob ( actually it is 2gb -1)
1:         // Note with setBinaryStream interface the maximum size for the
1:         // stream, can be max value for an int.
1:         // Also note, that lobs in derby currently supports
1:         // maximum size of 2gb -1
1:         // first do insert blob of 2g, 2 rows
0:         insertBlob_SetBinaryStream("BlobTest #1", conn, insertBlob,
1:                 BIGGEST_LOB_SZ,
1:         // do a select to see if the inserts in test above went ok
0:         selectBlob("BlobTest #2", conn, selectBlob, BIGGEST_LOB_SZ, 0, 1);
0:         selectBlob("BlobTest #3", conn, selectBlob, BIGGEST_LOB_SZ, 1, 1);
1:         // now do a select of one of the 2gb rows and update another 2g row
1:         // using the setBlob api, updated blob is of length 2gb
1:         // Fix for Bug entry -DERBY-599[setBlob should not materialize blob
1:         // into memory]
0:         selectUpdateBlob("BlobTest #4", conn, selectBlob, BIGGEST_LOB_SZ, 0, 1,
0:                 1);
1:         // select row from blobtbl and then do insert into the blobtbl
1:         // using setBlob
0:         selectInsertBlob("BlobTest #4.1", conn, selectBlob, insertBlob,
0:                 BIGGEST_LOB_SZ, 0, 3, 1);
1: 
1:         // Test - generate random data, write to a file, use it to insert
1:         // data into blob and then read back and compare if all is ok
1:         // currently in fvt ( derbyall), tests check for substrings etc and
1:         // for small amounts of data. This test will test for 100mb of blob data
1: 
1:         FileOutputStream fos =
1:                 PrivilegedFileOpsForTests
1:                         .getFileOutputStream(new File(DATAFILE));
1:         RandomByteStreamT r = new RandomByteStreamT(new java.util.Random(),
1:         // write in chunks of 32k buffer
1:         byte[] buffer = new byte[32 * 1024];
1:         int count = 0;
1:         while ((count = r.read(buffer)) >= 0)
1:             fos.write(buffer, 0, count);
1: 
1:         fos.flush();
1:         fos.close();
0:         insertBlob2("BlobTest #5.1 ", conn, insertBlob2, BIG_LOB_SZ, 0, 1,
0:         selectBlob2("BlobTest #5.2 ", conn, selectBlob2, BIG_LOB_SZ, 0, 1,
1:         // update the 2gb row in blobtbl with the 100mb data and compare if the
1:         // update
1:         // went ok.
0:         selectUpdateBlob2("BlobTest #6", conn, selectBlob2, selectBlob,
0:                 BIG_LOB_SZ, 0, 1, 1, DATAFILE);
0:         deleteTable(conn, deleteBlob2, 1);
0:         conn.commit();
1: 
0:         deleteTable(conn, deleteBlob, 3);
1:     }
1: 
0:     public void testBlobNegative() throws SQLException {
1:         // Negative Test, use setBlob api to insert a 4GB blob.
0:         Connection conn = getConnection();
0:         conn.setAutoCommit(false);
1:         PreparedStatement insertBlob =
1:                 prepareStatement("INSERT INTO BLOBTBL values (?,?,?,?)");
1: 
1:         BlobImplT _4GbBlob =
1:                 new BlobImplT(new RandomByteStreamT(new java.util.Random(),
1:                         _4GB), _4GB);
1: 
1:         try {
0:             insertBlob_SetBlob("BlobTest #7 (setBlob with 4Gb blob", conn,
1:                     insertBlob, _4GbBlob,
1:                     _4GB, 0, 1, 0);
1:         } catch (SQLException sqle) {
1:             // DERBY DOES NOT SUPPORT INSERT OF 4GB BLOB
0:             assertSQLState("22003", sqle);
1:         }
1:         // ADD NEW TESTS HERE
1:     }
1: 
1:     /**
1:      * tests using clobs
1:      * 
1:      * @throws Exception
1:      */
0:     public void testClob1() throws Exception {
0:         Connection conn = getConnection();
1:         PreparedStatement selectClob =
1:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL WHERE ID = ?");
1:         // Test - 2Gb blob
1:         // Note with setCharacterStream interface the maximum size for the
1:         // stream has to be max value for a int which is (2GB -1 )
1:         // first do insert clob of 2g, 2 rows
0:         insertClob_SetCharacterStream("ClobTest #1", conn, insertClob,
1:                 BIGGEST_LOB_SZ, 0, 2, BIGGEST_LOB_SZ);
1:         // do a select to see if the inserts in test above went ok
0:         selectClob("ClobTest #2", conn, selectClob, BIGGEST_LOB_SZ, 0, 1);
0:         selectClob("ClobTest #3", conn, selectClob, BIGGEST_LOB_SZ, 0, 1);
1:         // do a select and then update a row of 2gb size: uses getClob
0:         selectUpdateClob("ClobTest #4", conn, selectClob, BIGGEST_LOB_SZ, 0, 1,
0:                 1);
1: 
1:     }
1: 
1:     /**
1:      * @throws Exception
1:      */
0:     public void testClob2() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         setAutoCommit(false);
1:         // Test - generate random data, write to a file, use it to insert
1:         // data into clob and then read back and compare if all is ok
1:         // currently in fvt ( derbyall), tests check for substrings etc and
1:         // for small amounts of data. This test will test for 100mb of clob data
1:         writeToFile(CHARDATAFILE, new RandomCharReaderT(new java.util.Random(),
1:                 BIG_LOB_SZ));
0:         insertClob2("ClobTest #5.1 ", conn, insertClob2, BIG_LOB_SZ, 0, 1,
0:         selectClob2("ClobTest #5.2 ", conn, selectClob2, BIG_LOB_SZ, 0, 1,
0:         // Disabled for now, this will materialize, will open
0:         // jira for it.
0:         // updateClob2("ClobTest #8.1",conn,selectClob,BIG_LOB_SZ,0,0,10,1,CHARDATAFILE);
1:         // update the 2gb row in clobtbl with the 100mb data and compare if the
1:         // update
1:         // went ok.
0:         selectUpdateClob2("ClobTest #8.2", conn, selectClob2, selectClob,
0:                 BIG_LOB_SZ, 0, 1, 1, CHARDATAFILE);
1:         // test for trailing space truncation
1:         // insert 100mb+33k of data which has 33k of trailing space,
1:         // into a column of 100mb
1:         // insert should be successful, select should retrieve 100mb of data
1: 
1:         // Generate random data and write to a file, this file will be used
1:         // in the verification process after inserts and updates.
1:         writeToFile(CHARDATAFILE, new RandomCharReaderT(new java.util.Random(),
1:                    (NUM_TRAILING_SPACES + BIG_LOB_SZ), NUM_TRAILING_SPACES));
0:         insertClob2("ClobTest #6.1 ", conn, insertClob2, BIG_LOB_SZ, 3, 1,
1:                    (NUM_TRAILING_SPACES + BIG_LOB_SZ), CHARDATAFILE);
1:         // select will retrieve data and verify the data inserted.
0:         selectClob2("ClobTest #6.2 ", conn, selectClob2, BIG_LOB_SZ, 3, 1,
1:     }
0:     public void testClobNegative() throws Exception {
0:         Connection conn = getConnection();
0:         conn.setAutoCommit(false);
/////////////////////////////////////////////////////////////////////////
0:         negativeSpaceTruncationTest("ClobTest #7", conn);
1: 
1:         // Test - for stream contains a trailing non-space character
1:         // insert should throw an error
1:         writeToFile(CHARDATAFILE, new RandomCharReaderT(new java.util.Random(),
1:                 MORE_DATA_THAN_COL_WIDTH));
1: 
1:         try {
0:             insertClob2("ClobTest #9.1 ", conn, insertClob2,
1:                     MORE_DATA_THAN_COL_WIDTH, 4, 1,
1:         } catch (SQLException sqle) {
1:             assertSQLState("XSDA4", sqle);
1:         }
1:         // no row must be retrieved.
0:         selectClob2("ClobTest #9.2 ", conn, selectClob2, BIG_LOB_SZ, 4, 0,
1:         try {
0:             insertClob2("ClobTest #10 ", conn, insertClob2,
1:                     MORE_DATA_THAN_COL_WIDTH, 4, 1,
1:                        MORE_DATA_THAN_COL_WIDTH + 1, CHARDATAFILE);
1:         } catch (SQLException sqle) {
1:             // NEGATIVE TEST - Expected Exception: truncation of non-blanks not
1:             // allowed and
1:             // stream length is one greater than actual length of the stream
1:             assertSQLState("XSDA4", sqle);
1:         }
1:         try {
0:             insertClob2("ClobTest #11 ", conn, insertClob2,
1:                     MORE_DATA_THAN_COL_WIDTH, 4, 1,
1:                        MORE_DATA_THAN_COL_WIDTH - 1, CHARDATAFILE);
1:         } catch (SQLException sqle) {
1:             // NEGATIVE TEST - Expected Exception: truncation of non-blanks not
1:             // allowed and
1:             // stream length is one less than actual length of the stream
1:             assertSQLState("XSDA4", sqle);
1:         }
0:         deleteTable(conn, deleteClob2, 2);
1:         try {
1:             // give -ve streamlength
0:             insertClob_SetCharacterStream("ClobTest #12.1", conn, insertClob,
1:                     BIG_LOB_SZ, 4, 1, -1);
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ025", sqle);
1:         }
0:         selectClob("ClobTest #12.2", conn, selectClob, BIG_LOB_SZ, 4, 0);
0:         deleteTable(conn, deleteClob, 2);
1:         // Negative tests use the setClob API to insert a 4GB clob
1:         // long _4GB = 4*1024*1024*(1024L);
1:         ClobImplT _4GBClob =
1:                 new ClobImplT(new RandomCharReaderT(new java.util.Random(),
1:                         _4GB), _4GB);
1:         try {
0:             insertClob_SetClob("ClobTest #13 (setClob with 4Gb clob", conn,
1:                     insertClob, _4GBClob,
1:                     _4GB, 0, 1, 0);
1:         } catch (SQLException sqle) {
0:             // DERBY DOES NOT SUPPORT INSERT OF 4GB CLOB
0:             assertSQLState("22003", sqle);
1:         }
1:         // ADD NEW TESTS HERE
1:     }
0:     private static void negativeSpaceTruncationTest(String msg, Connection conn)
1:             throws Exception {
0:         PreparedStatement insertClob2 = conn
0:                 .prepareStatement("INSERT INTO CLOBTBL2 values (?,?,?,?)");
1:         // Negative test, stream has trailing spaces but the stream length is
1:         // one
1:         // more than the actual length of the stream
1:         try {
0:             insertClob2(msg, conn, insertClob2, BIG_LOB_SZ, 4, 1,
1:                     (NUM_TRAILING_SPACES + BIG_LOB_SZ - 1), CHARDATAFILE);
1:         } catch (SQLException sqle) {
1:             // EXPECTED EXCEPTION - stream has trailing spaces,but stream
1:             // length is 1 less than actual length of stream
1:             assertSQLState("XSDA4", sqle);
1:         }
1:         try {
0:             insertClob2(msg, conn, insertClob2, BIG_LOB_SZ, 5, 1,
1:                     (NUM_TRAILING_SPACES + BIG_LOB_SZ + 1), CHARDATAFILE);
1:         } catch (SQLException sqle) {
1:             // EXPECTED EXCEPTION - stream has trailing spaces,but stream
1:             // length is 1 greater than actual length of stream
1:             assertSQLState("XSDA4", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * insert blob
1:      * 
1:      * @param bloblen length of blob to insert
1:      * @param start start id value for insert
1:      * @param rows insert rows number of rows
1:      * @param streamLength stream length passed to setBinaryStream(,,length)
1:      */
0:     private static void insertBlob_SetBinaryStream(String testId,
0:             Connection conn, PreparedStatement ps, int bloblen, int start,
1:             int rows, int streamLength) throws SQLException {
1:         println("========================================");
1:         println("START " + testId + "insertBlob of size = "
1:                 + bloblen);
0:         long ST = 0;
0:         ST = System.currentTimeMillis();
1: 
1:         int count = 0;
1:         java.util.Random random = new java.util.Random();
1:         for (int i = start; i < start + rows; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, 0);
1:             ps.setLong(3, bloblen);
1:             ps.setBinaryStream(4, new RandomByteStreamT(random, bloblen),
1:                     streamLength);
1:             count += ps.executeUpdate();
1:         }
0:         conn.commit();
1:         println("Insert Blob (" + bloblen + ")" + " rows= "
1:         verifyTest(count, rows, " Rows inserted with blob of size (" + bloblen
1:                 + ") =");
1:         println("========================================");
1:     }
1:     /**
1:      * insert blob, using a setBlob api.
1:      * 
1:      * @param bloblen length of blob to insert
1:      * @param blob blob to insert
1:      * @param start start id value for insert
1:      * @param rows insert rows number of rows
1:      * @param expectedRows rows expected to be inserted
1:      */
/////////////////////////////////////////////////////////////////////////
1:         for (int i = start; i < start + rows; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, 0);
1:             ps.setLong(3, bloblen);
1:             ps.setBlob(4, blob);
1:             count += ps.executeUpdate();
1:         }
0:         conn.commit();
1:         println("Insert Blob (" + bloblen + ")" + " rows= "
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * select from blob table (BLOBTBL)
1:      * 
1:      * @param bloblen select expects to retrieve a blob of this length
1:      * @param id id of the row to retrieve
1:      * @param expectedRows number of rows expected to match id
1:      */
0:     private static void selectBlob(String testId, Connection conn,
1:             PreparedStatement ps, int bloblen, int id, int expectedRows)
1:             throws SQLException {
1:         println("========================================");
1:         println("START " + testId + " - SELECT BLOB of size = "
1:                 + bloblen);
0:         long ST = 0;
0:         ResultSet rs = null;
0:         ST = System.currentTimeMillis();
1:         int count = 0;
1:         ps.setInt(1, id);
0:         rs = ps.executeQuery();
1:         while (rs.next()) {
1:             count++;
1:             Blob value = rs.getBlob(1);
1:             long l = value.length();
1:             long dlen = rs.getLong(2);
1:             assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:         }
0:         conn.commit();
1:         verifyTest(count, expectedRows,
1:                 "Matched rows selected with blob of size(" + bloblen + ") =");
1:         println("Select Blob (" + bloblen + ")" + " rows= "
1:         println("========================================");
1:     }
1:     /**
1:      * insert blob into BLOBTBL2
1:      * 
1:      * @param bloblen length of blob to insert
1:      * @param start id value for insert
1:      * @param rows insert rows number of rows
1:      * @param streamLength stream length passed to setBinaryStream(,,length)
1:      * @param file filename to match retrieved data against
1:      */
0:     private static void insertBlob2(String testId, Connection conn,
1:             PreparedStatement ps, int bloblen, int start, int rows,
1:             int streamLength, String file) throws Exception {
1:         println("========================================");
1:         println("START " + testId + "insert Blob of size = "
1:                 + bloblen);
1:         int count = 0;
1:         java.util.Random random = new java.util.Random();
0:         FileInputStream fis = null;
0:         long ST = 0;
0:         ST = System.currentTimeMillis();
1: 
1:         for (int i = start; i < start + rows; i++) {
0:             fis = PrivilegedFileOpsForTests.getFileInputStream(new File(file));
1:             ps.setInt(1, i);
1:             ps.setInt(2, 0);
1:             ps.setLong(4, bloblen);
1:             ps.setBinaryStream(3, fis, streamLength);
1:             count += ps.executeUpdate();
1:             fis.close();
1:         }
0:         conn.commit();
1:         println("Insert Blob (" + bloblen + ")" + " rows= "
1:         verifyTest(count, rows, " Rows inserted with blob of size (" + bloblen
1:                 + ") =");
1:         println("========================================");
1:     }
1:     /**
1:      * select from blob table (BLOBTBL2)
1:      * 
1:      * @param bloblen select expects to retrieve a blob of this length
1:      * @param id id of the row to retrieve
1:      * @param expectedRows number of rows expected to match id
1:      * @param file name of the file,against which the retrieved data is compared
1:      */
0:     private static void selectBlob2(String testId, Connection conn,
1:             PreparedStatement ps, int bloblen, int id, int expectedRows,
1:             String file) throws Exception {
1:         println("========================================");
1:         println("START " + testId + " - SELECT BLOB of size = "
1:                 + bloblen);
0:         long ST = 0;
0:         ResultSet rs = null;
0:         ST = System.currentTimeMillis();
1:         int count = 0;
1:         ps.setInt(1, id);
0:         rs = ps.executeQuery();
1:         while (rs.next()) {
1:             count++;
1:             Blob value = rs.getBlob(1);
1:             long l = value.length();
1:             long dlen = rs.getLong(2);
1:             assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:             compareBlobToFile(value.getBinaryStream(), file);
1:         }
0:         conn.commit();
1:         verifyTest(count, expectedRows,
1:                 "Matched rows selected with blob of size(" + bloblen + ") =");
1: 
1:         println("Select Blob (" + bloblen + ")" + " rows= "
1:         println("========================================");
1:     }
1:     /**
1:      * Basically this test will do an update using setBlob api - select row from
1:      * blobtbl and then update a row in blobtbl and verify updated data in
1:      * blobtbl
1:      * 
1:      * @param ps select statement from which blob is retrieved
1:      * @param bloblen updating value is of length bloblen
1:      * @param id id of the row retrieved, for the update
1:      * @param updateId id of the row that is updated
0:      * @param expectedRows to be updated
1:      */
0:     private static void selectUpdateBlob(String testId, Connection conn,
0:             PreparedStatement ps, int bloblen, int id, int updateId,
0:             int expectedRows) throws Exception {
1:         println("========================================");
1:         println("START " + testId + " - select and then update blob of size= "
1:                 + bloblen + " - Uses getBlob api");
0:         ResultSet rs = null;
1:         ps.setInt(1, id);
0:         rs = ps.executeQuery();
1:         rs.next();
1:         Blob value = rs.getBlob(1);
1:         long l = value.length();
1:         long dlen = rs.getLong(2);
1:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:         PreparedStatement psUpd =
0:                 conn.prepareStatement("update BLOBTBL set content=?,dlen =?" +
1:                         "where id = ?");
1:         psUpd.setBlob(1, value);
1:         psUpd.setLong(2, l);
1:         psUpd.setInt(3, updateId);
1:         println("Rows Updated = " + psUpd.executeUpdate());
0:         conn.commit();
1: 
1:         // now select and verify that update went through ok.
1:         ps.setInt(1, updateId);
1:         ResultSet rs2 = ps.executeQuery();
1:         rs2.next();
1:         Blob updatedValue = rs2.getBlob(1);
1:         assertEquals(
1:                 "FAIL - Retrieving the updated blob length does not match " +
1:                         "expected length = " + l + " found = "
1:                         + updatedValue.length(),
1:         // close resultsets
0:         conn.commit();
1:         rs.close();
1:         rs2.close();
0:         psUpd.close();
1:         println("========================================");
1:     }
1:     /**
1:      * Basically this test will do an insert using setBlob api - select row from
1:      * blobtbl and then insert a row in blobtbl and verify updated data in
1:      * blobtbl
1:      * 
1:      * @param ps select statement from which blob is retrieved
1:      * @param bloblen updating value is of length bloblen
1:      * @param id id of the row retrieved, for the update
1:      * @param insertId id of the row that is inserted
0:      * @param expectedRows to be updated
1:      */
0:     private static void selectInsertBlob(String testId, Connection conn,
1:             PreparedStatement ps, PreparedStatement ins, int bloblen, int id,
0:             int insertId,
0:             int expectedRows) throws Exception {
1:         println("========================================");
1:         println("START " + testId + " - select and then insert blob of size= "
1:                 + bloblen
1:                 + " - Uses getBlob api to do select and setBlob for insert");
0:         ResultSet rs = null;
1: 
1:         ps.setInt(1, id);
0:         rs = ps.executeQuery();
1:         rs.next();
1:         Blob value = rs.getBlob(1);
1:         long l = value.length();
1:         long dlen = rs.getLong(2);
1:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:                            dlen, l);
1:         ins.setInt(1, insertId);
1:         ins.setInt(2, 0);
1:         ins.setLong(3, l);
1:         ins.setBlob(4, value);
1:         // assert one row updated
0:         assertEquals(1, ins.executeUpdate());
0:         conn.commit();
1:         // now select and verify that update went through ok.
1:         ps.setInt(1, insertId);
1:         ResultSet rs2 = ps.executeQuery();
1:         rs2.next();
1:         Blob insertedValue = rs2.getBlob(1);
1:         assertEquals(
1:                 "FAIL - Retrieving the updated blob length does not match " +
1:                         "expected length = " + l + " found = "
1:                         + insertedValue.length(),
1:                 l, insertedValue.length());
1:         // close resultsets
0:         conn.commit();
1:         rs.close();
1:         rs2.close();
1:         println("========================================");
1:     }
1:     /**
1:      * Basically this test will do an update using setBinaryStream api and
1:      * verifies the updated data. select row from blobtbl2 and then update a row
1:      * in blobtbl and verify updated data in blobtbl
1:      * 
1:      * @param bloblen updating value is of length bloblen
1:      * @param id id of the row retrieved, for the update
1:      * @param updateId id of the row that is updated
0:      * @param expectedRows to be updated
1:      * @param file name of the file,against which the updated data is compared
1:      */
0:     private static void selectUpdateBlob2(String testId, Connection conn,
1:             PreparedStatement ps, PreparedStatement sel, int bloblen, int id,
0:             int updateId,
0:             int expectedRows, String file) throws Exception {
1:         println("========================================");
1:         println("START " + testId + " - select and then update blob of size= "
1:                 + bloblen + " - Uses getBlob and setBlob  api");
0:         ResultSet rs = null;
1:         // retrieve row from blobtbl2
1:         ps.setInt(1, id);
0:         rs = ps.executeQuery();
1:         rs.next();
1:         Blob value = rs.getBlob(1);
1:         long l = value.length();
1:         long dlen = rs.getLong(2);
1:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:                 + dlen + " for row in BLOBTBL2 with ID=" + id, dlen, l);
1:         PreparedStatement psUpd =
0:                 conn.prepareStatement("update BLOBTBL set content=?,dlen =?" +
1:                         " where id = ?");
1:         psUpd.setBlob(1, value);
1:         psUpd.setLong(2, l);
1:         psUpd.setInt(3, updateId);
1:         // assert 1 row updated
0:         assertEquals(1, psUpd.executeUpdate());
0:         conn.commit();
1:         // now select and verify that update went through ok.
1:         sel.setInt(1, updateId);
1:         ResultSet rs2 = sel.executeQuery();
1:         rs2.next();
1:         Blob updatedValue = rs2.getBlob(1);
1:         assertEquals("FAIL - MISMATCH length of updated blob value : expected="
1:                 +
1:                 l + " found =" + updatedValue.length(), l, updatedValue
1:                 .length());
1:         compareBlobToFile(updatedValue.getBinaryStream(), file);
1:         // close resultsets
0:         conn.commit();
1:         rs.close();
1:         rs2.close();
0:         psUpd.close();
1:         println("========================================");
1:     }
1:     private static void compareBlobToFile(InputStream lobstream, String filename)
1:             throws Exception {
1:         FileInputStream file =
1:                 PrivilegedFileOpsForTests
1:                         .getFileInputStream(new File(filename));
0:         int l = 0;
0:         int b = 0;
1:         do {
0:             l = lobstream.read();
0:             b = file.read();
0:             assertEquals("FAIL -- MISMATCH in data stored (" + l + ") versus" +
0:                     "data retrieved from file(" + b + "). ", b, l);
0:         } while (l != -1 && b != -1);
1:     }
0:     private static void deleteTable(Connection conn, PreparedStatement ps,
1:             int expectedRows) throws SQLException {
0:         int count = ps.executeUpdate();
0:         conn.commit();
1:         verifyTest(count, expectedRows, "Rows deleted =");
1:     }
1:     /**
1:      * insert clob
1:      * 
1:      * @param cloblen length of clob to insert
1:      * @param start id value for insert
1:      * @param rows insert rows number of rows
1:      * @param streamLength stream length passed to
1:      *            setCharacterStream(...,length)
1:      */
0:     private static void insertClob_SetCharacterStream(String testId,
0:             Connection conn, PreparedStatement ps, int cloblen, int start,
1:             int rows, int streamLength) throws SQLException {
1:         println("========================================");
1:         println("START " + testId + "  -insertClob of size = "
1:                 + cloblen);
1: 
0:         long ST = 0;
1:         java.util.Random random = new java.util.Random();
1:         int count = 0;
0:         ST = System.currentTimeMillis();
1: 
1:         for (int i = start; i < start + rows; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, 0);
1:             ps.setLong(3, cloblen);
1:             ps.setCharacterStream(4, new RandomCharReaderT(random, cloblen),
1:                     streamLength);
1:             count += ps.executeUpdate();
1:         }
0:         conn.commit();
1:         println("Insert Clob (" + cloblen + ")" + " rows= "
1:         verifyTest(count, rows, "Rows inserted with clob of size (" + cloblen
1:                 + ") = ");
1:         println("========================================");
1:     }
1:     /**
1:      * insert clob, using a setClob api.
1:      * 
1:      * @param cloblen length of clob to insert
1:      * @param clob clob to insert
1:      * @param start start id value for insert
1:      * @param rows insert rows number of rows
1:      * @param expectedRows rows expected to be inserted
1:      */
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * select from clob table
1:      * 
1:      * @param cloblen select expects to retrieve a clob of this length
1:      * @param id id of the row to retrieve
1:      * @param expectedRows number of rows expected to match id
1:      */
0:     private static void selectClob(String testId, Connection conn,
1:             PreparedStatement ps, int cloblen, int id, int expectedRows)
1:             throws SQLException {
1:         println("========================================");
1:         println("START " + testId + " - SELECT CLOB of size = "
1:                 + cloblen);
0:         long ST = 0;
1:         int count = 0;
0:         ResultSet rs = null;
0:         ST = System.currentTimeMillis();
1:         ps.setInt(1, id);
0:         rs = ps.executeQuery();
1:         while (rs.next()) {
1:             count++;
1:             Clob value = rs.getClob(1);
1:             long l = value.length();
1:             long dlen = rs.getLong(2);
1:             assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:                     + " expected " + dlen + " for row in CLOBTBL with ID="
1:                     + id, l, dlen);
1:         }
0:         conn.commit();
1:         println("Select Clob (" + cloblen + ")" + " rows= "
1:                 + expectedRows + " = "
1:                 + (long) (System.currentTimeMillis() - ST));
1:         verifyTest(count, expectedRows,
1:                 "Matched rows selected with clob of size(" + cloblen + ") =");
1:         println("========================================");
1:     }
1:     /**
1:      * insert clob into CLOBTBL2
1:      * 
1:      * @param cloblen length of clob to insert
1:      * @param start id value for insert
1:      * @param rows insert rows number of rows
1:      * @param streamLength stream length passed to
1:      *            setCharacterStream(pos,reader,streamLength)
1:      * @param file name of the file that has data to be inserted
1:      */
0:     private static void insertClob2(String testId, Connection conn,
1:             PreparedStatement ps, int cloblen, int start, int rows,
1:             int streamLength, String file) throws Exception {
1:         println("========================================");
1:         println("START " + testId + "insert Clob of size = "
1:                 + cloblen);
1:         int count = 0;
0:         FileReader reader = null;
0:         long ST = 0;
0:         ST = System.currentTimeMillis();
/////////////////////////////////////////////////////////////////////////
0:         conn.commit();
1: 
1:         println("Insert Clob (" + cloblen + ")" + " rows= "
1:         verifyTest(count, rows, " Rows inserted with clob of size (" + cloblen
1:                 + ") =");
1:         println("========================================");
1:     }
1:     /**
1:      * select from clob table (CLOBTBL2)
1:      * 
1:      * @param cloblen select expects to retrieve a clob of this length
1:      * @param id id of the row to retrieve
1:      * @param expectedRows number of rows expected to match id
1:      * @param file filename to compare the retrieved data against
1:      */
0:     private static void selectClob2(String testId, Connection conn,
1:             PreparedStatement ps, int cloblen, int id, int expectedRows,
0:             String file) throws SQLException, Exception {
1:         println("========================================");
1:         println("START " + testId + " - SELECT CLOB of size = "
1:                 + cloblen);
0:         long ST = 0;
0:         ResultSet rs = null;
0:         ST = System.currentTimeMillis();
1:         int count = 0;
1:         ps.setInt(1, id);
0:         rs = ps.executeQuery();
1:         while (rs.next()) {
1:             count++;
1:             Clob value = rs.getClob(1);
1:             long l = value.length();
1:             long dlen = rs.getLong(2);
1:             assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:                     + " expected " + dlen + " for row in CLOBTBL2 with ID="
1:                     + id, l, cloblen);
1:             compareClobToFile(value.getCharacterStream(), file, cloblen);
1:         }
0:         conn.commit();
1:         verifyTest(count, expectedRows,
1:                 "Matched rows selected with clob of size(" + cloblen + ") =");
1:         println("Select Clob (" + cloblen + ")" + " rows= "
1:         println("========================================");
1:     }
1:     /*
1:      * Basically this test will do an update using setClob api - select row from
1:      * clobtbl and then update a row in clobtbl and verify updated data in
1:      * clobtbl
1:      */
0:     private static void selectUpdateClob(String testId, Connection conn,
0:             PreparedStatement ps, int cloblen, int id, int updateId,
0:             int expectedRows) throws Exception {
1:         println("========================================");
1:         println("START " + testId + " - select and then update clob of size= "
1:                 + cloblen + " - Uses setClob api");
0:         ResultSet rs = null;
1:         ps.setInt(1, id);
0:         rs = ps.executeQuery();
1:         rs.next();
1:         Clob value = rs.getClob(1);
1:         long l = value.length();
1:         long dlen = rs.getLong(2);
1:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:                 + dlen + " for row in CLOBTBL with ID=" + id, dlen, l);
0:         PreparedStatement psUpd =
0:                 conn.prepareStatement("update CLOBTBL set content=?,dlen =? " +
0:                         " where id = ?");
0:         psUpd.setCharacterStream(1, value.getCharacterStream(), (int) l);
0:         psUpd.setLong(2, l);
0:         psUpd.setInt(3, updateId);
0:         assertEquals(1, psUpd.executeUpdate());
0:         conn.commit();
1:         // now select and verify that update went through ok.
1:         ps.setInt(1, updateId);
1:         ResultSet rs2 = ps.executeQuery();
1:         rs2.next();
1:         Clob updatedValue = rs2.getClob(1);
1:         assertEquals(
1:                 "FAIL - Retrieving the updated clob length does not match " +
1:                         "expected length = " + l + " found = "
1:                         + updatedValue.length(), l,
1:                 updatedValue.length());
1:         // close resultsets
0:         conn.commit();
1:         rs.close();
1:         rs2.close();
0:         psUpd.close();
1:         println("========================================");
1:     }
1:     /*
1:      * Basically this test will do an update using setBlob api and verifies the
1:      * updated data. select row from clobtbl2 and then update a row in clobtbl
1:      * and verify updated data in clobtbl against the data in the original file
1:      */
0:     private static void selectUpdateClob2(String testId, Connection conn,
1:             PreparedStatement ps, PreparedStatement sel, int cloblen, int id,
0:             int updateId,
0:             int expectedRows, String file) throws Exception {
1:         println("========================================");
1:         println("START " + testId + " - select and then update clob of size= "
1:                 + cloblen + " - Uses setClob api");
0:         ResultSet rs = null;
1:         // retrieve row from clobtbl2
1:         ps.setInt(1, id);
0:         rs = ps.executeQuery();
1:         rs.next();
1:         Clob value = rs.getClob(1);
1:         long l = value.length();
1:         long dlen = rs.getLong(2);
1:         assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:                 + dlen + " for row in CLOBTBL2 with ID=" + id, dlen, l);
0:         PreparedStatement psUpd =
0:                 conn
0:                         .prepareStatement("update CLOBTBL set content=?,dlen =? "
1:                                 +
1:                                 "where id = ?");
1:         psUpd.setClob(1, value);
0:         psUpd.setLong(2, l);
0:         psUpd.setInt(3, updateId);
0:         assertEquals(1, psUpd.executeUpdate());
0:         conn.commit();
1:         // now select and verify that update went through ok.
1:         sel.setInt(1, updateId);
1:         ResultSet rs2 = sel.executeQuery();
1:         rs2.next();
1:         Clob updatedValue = rs2.getClob(1);
1:         assertEquals("FAIL - MISMATCH length of updated clob value , found=" +
1:                    updatedValue.length() + ",expected = " + l, l, updatedValue
1:                 .length());
1:         compareClobToFile(updatedValue.getCharacterStream(), file, (int) l);
1:         // close resultsets
0:         conn.commit();
1:         rs.close();
1:         rs2.close();
0:         psUpd.close();
1:         println("========================================");
1:     }
1: 
1:     /*
1:      * Basically this test will do an update using updateClob api and verifies
1:      * the updated data. select row from clobtbl2 and then update a row in
1:      * clobtbl and verify updated data in clobtbl against the data in the
1:      * original file
1:      * 
1:      * @param updateRowId id of the row that needs to be updated
1:      */
0:     private static void updateClob2(String testId, Connection conn,
1:             PreparedStatement sel,
0:             int cloblen, int id, int updateRowId, int updateIdVal,
0:             int expectedRows, String file) throws Exception {
0:         System.out.println("========================================");
0:         System.out.println("START " + testId
1:                 + " - select and then update clob of size= "
1:                 + cloblen + " - Uses updateClob api");
1: 
1:         PreparedStatement ps1 =
0:                 conn
0:                         .prepareStatement("SELECT * FROM CLOBTBL FOR UPDATE",
1:                                 ResultSet.TYPE_FORWARD_ONLY,
1:                                 ResultSet.CONCUR_UPDATABLE);
1:         PreparedStatement ps =
0:                 conn.prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 " +
1:                         "where ID =?");
1: 
0:         ResultSet rs = null;
1:         ps.setInt(1, id);
1:         // retrieve row from clobtbl2
0:         rs = ps.executeQuery();
1:         rs.next();
1:         Clob value = rs.getClob(1);
1:         long l = value.length();
1:         long dlen = rs.getLong(2);
1:         if (dlen != l) {
0:             System.out
0:                     .println("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:                             + dlen + " for row in CLOBTBL2 with ID=" + id);
1:         }
1: 
1:         ResultSet rs1 = ps1.executeQuery();
1:         while (rs1.next()) {
1:             if (rs1.getInt(1) == updateRowId) {
/////////////////////////////////////////////////////////////////////////
1:         // close resultsets
0:         conn.commit();
1:         rs.close();
1:         rs1.close();
0:         ps1.close();
0:         ps.close();
1:         // verify
1:         // now select and verify that update went through ok.
1:         sel.setInt(1, updateIdVal);
1:         ResultSet rs2 = sel.executeQuery();
1:         rs2.next();
1:         Clob updatedValue = rs2.getClob(1);
1:         if (updatedValue.length() != l) {
0:             System.out
0:                     .println("FAIL - MISMATCH length of updated clob value ," +
1:                             "found="
1:                             +
1:                             updatedValue.length() + ",expected = " + l);
1:         } else
1:             compareClobToFile(updatedValue.getCharacterStream(), file, (int) l);
0:         System.out.println("========================================");
1:     }
1:     private static void compareClobToFile(Reader lobstream, String filename,
1:             int length)
1:             throws Exception {
1:         FileReader file = PrivilegedFileOpsForTests.getFileReader(
1:                    new File(filename));
1:         int c1 = 0;
1:         int c2 = 0;
1:         long count = 0;
0:         do {
1:             c1 = lobstream.read();
1:             c2 = file.read();
1:             assertEquals(
1:                     "FAIL -- MISMATCH in data stored versus data retrieved at "
1:                             +
1:                             count + " " + c1 + " does not match " + c2,
1:                     c2, c1);
1:             count++;
1:             length--;
1:         } while (c1 != -1 && c2 != -1 && length > 0);
1:         file.close();
1:     }
1: 
1:     private static void verifyTest(int affectedRows, int expectedRows,
1:             String test) {
1:         assertEquals("FAIL --" + test + affectedRows
1:                 + " , but expected rows =" + expectedRows, expectedRows,
1:                 affectedRows);
1:         println(test + affectedRows);
1:     }
1: 
1:     private static void writeToFile(String file, Reader r)
1:             throws IOException {
1:         // does file exist, if so delete and write to a fresh file
1:         File f = new File(file);
1:         if (PrivilegedFileOpsForTests.exists(f)) {
1:             assertTrue(PrivilegedFileOpsForTests.delete(f));
1:         }
1:         FileWriter writer = PrivilegedFileOpsForTests.getFileWriter(f);
1:         println("Got FileWriter for " + file + " " + writer);
1:         // write in chunks of 32k buffer
1:         char[] buffer = new char[32 * 1024];
1:         int count = 0;
1: 
1:         while ((count = r.read(buffer)) >= 0)
1:             writer.write(buffer, 0, count);
1:         writer.flush();
1:         writer.close();
1:         println("writer " + writer + " for file " + file + " closed");
1:     }
1:     private long length;
1:     private java.util.Random dpr;
1:     RandomByteStreamT(java.util.Random dpr, long length) {
1:         this.length = length;
1:         this.dpr = dpr;
1:     }
1:     public int read() {
1:         if (length <= 0)
1:             return -1;
1:         length--;
1:         return (byte) (dpr.nextInt() >>> 25);
1:     }
1:     public int read(byte[] data, int off, int len) {
1:         if (length <= 0)
1:             return -1;
1:         if (len > length)
1:             len = (int) length;
1:         for (int i = 0; i < len; i++) {
1:             // chop off bits and return a +ve byte value.
1:             data[off + i] = (byte) (dpr.nextInt() >>> 25);
1:         }
1:         length -= len;
1:         return len;
1:     }
1:     private long length;
1:     private long numTrailingSpaces;
1:     private java.util.Random dpr;
1:     RandomCharReaderT(java.util.Random dpr, long length) {
1:         this.length = length;
1:         this.dpr = dpr;
1:         this.numTrailingSpaces = 0;
1:     }
1:     RandomCharReaderT(java.util.Random dpr, long length, long numTrailingSpaces) {
1:         this.length = length;
1:         this.dpr = dpr;
1:         this.numTrailingSpaces = numTrailingSpaces;
1:     }
1:     private int randomInt(int min, int max) {
1:         return dpr.nextInt(max - min) + min;
1:     }
1:     private char getChar() {
1:         // return space for trailing spaces.
1:         if (length <= numTrailingSpaces) {
1:             return ' ';
1:         }
1:         double drand = dpr.nextDouble();
1:         char c = 'a';
1:         if (drand < 0.25)
1:             c = (char) randomInt((int) 'A', (int) 'Z');
1:         else if (drand < 0.5)
1:             switch (randomInt(1, 10)) {
1:             case 1:
1:                 c = '\u00c0';
1:                 break;
1:             case 2:
1:                 c = '\u00c1';
1:                 break;
1:             case 3:
1:                 c = '\u00c2';
1:                 break;
1:             case 4:
1:                 c = '\u00ca';
1:                 break;
1:             case 5:
1:                 c = '\u00cb';
1:                 break;
1:             case 6:
1:                 c = '\u00d4';
1:                 break;
1:             case 7:
1:                 c = '\u00d8';
1:                 break;
1:             case 8:
1:                 c = '\u00d1';
1:                 break;
1:             case 9:
1:                 c = '\u00cd';
1:                 break;
1:             default:
1:                 c = '\u00dc';
1:                 break;
1:             }
1:         else if (drand < 0.75)
1:             c = (char) randomInt((int) 'a', (int) 'z');
1:         else if (drand < 1.0)
1:             switch (randomInt(1, 10)) {
1:             case 1:
1:                 c = '\u00e2';
1:                 break;
1:             case 2:
1:                 c = '\u00e4';
1:                 break;
1:             case 3:
1:                 c = '\u00e7';
1:                 break;
1:             case 4:
1:                 c = '\u00e8';
1:                 break;
1:             case 5:
1:                 c = '\u00ec';
1:                 break;
1:             case 6:
1:                 c = '\u00ef';
1:                 break;
1:             case 7:
1:                 c = '\u00f6';
1:                 break;
1:             case 8:
1:                 c = '\u00f9';
1:                 break;
1:             case 9:
1:                 c = '\u00fc';
1:                 break;
1:             default:
1:                 c = '\u00e5';
1:                 break;
1:             }
1:         return c;
1:     }
1:     public int read() {
1:         if (length <= 0)
1:             return -1;
1:         length--;
1:         return getChar();
1:     }
1:     public int read(char[] data, int off, int len) {
1:         if (length <= 0)
1:             return -1;
1:         if (len > length)
1:             len = (int) length;
1:         for (int i = 0; i < len; i++) {
1:             data[off + i] = getChar();
1:             length -= 1;
1:         }
1:         return len;
1:     }
1:     public void close() {
1: 
1:     }
1:  * Class used to simulate a 4GB Clob implementation to check whether derby
1:  * implements such large Clobs correctly. Derby throws an error if the clob size
1:  * exceeds 2GB
1:     long length;
1:     Reader myReader;
1:     public ClobImplT(Reader myReader, long length) {
1:         this.length = length;
1:         this.myReader = myReader;
1:     }
1:     public long length() throws SQLException {
1:         return length;
1:     }
1:     public String getSubString(long pos, int length) throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:     public java.io.Reader getCharacterStream() throws SQLException {
1:         return myReader;
1:     }
1:     public java.io.InputStream getAsciiStream() throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:     public long position(String searchstr, long start) throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:     public long position(Clob searchstr, long start) throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:     public int setString(long pos, String str) throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:     public int setString(long pos, String str, int offset, int len)
1:             throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:     public java.io.OutputStream setAsciiStream(long pos) throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:     public java.io.Writer setCharacterStream(long pos) throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:     public void truncate(long len) throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:     public void free() throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1: 
1:     public Reader getCharacterStream(long pos, long length) throws SQLException {
1:         throw new SQLException("Not implemented");
1:     }
1:  * Class to simulate a 4Gb blob impl in order to test if Derby handles such
1:  * large blobs correctly. The main methods here are only the length() and the
1:  * getBinaryStream(). Rest are just placeholders/dummy methods in order to
1:  * implement the java.sql.Blob interface ---- Derby throws an error if the blob
1:  * length exceeds the max range of int.
1: class BlobImplT implements java.sql.Blob {
1: 
1:     public BlobImplT(InputStream is, long length) {
1: 
1:             throws SQLException {
1: 
1:             throws SQLException {
1:         throw new SQLException("Not implemented");
1: 
1:             throws SQLException {
1: 
1:     public long position(Blob pattern, long start)
1:             throws SQLException {
1:         throw new SQLException("Not implemented");
1: 
1:     public long position(byte[] pattern, long start)
1:             throws SQLException {
1:         throw new SQLException("Not implemented");
1: 
1:             throws SQLException
1: 
1:         throw new SQLException("Not implemented");
1: 
1:     public int setBytes(long pos, byte[] bytes)
1:             throws SQLException {
1:         throw new SQLException("Not implemented");
1: 
1:     public int setBytes(long pos, byte[] bytes, int offset, int len)
1:             throws SQLException {
1:         throw new SQLException("Not implemented");
1: 
1:             throws SQLException {
1:         throw new SQLException("Not implemented");
1: 
1:             throws SQLException {
1:         throw new SQLException("Not implemented");
1: 
commit:e4e2bfd
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.largedata.LobLimitsTest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.functionTests.tests.largedata;
1: 
1: 
1: 
1: import java.io.File;
0: import java.io.FileOutputStream;
1: import java.io.FileInputStream;
1: import java.io.FileWriter;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.io.Reader;
0: import java.io.FileReader;
0: import java.io.IOException;
1: import java.sql.Blob;
1: import java.sql.Clob;
0: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.SupportFilesSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1: 
1: 
1: /**
0: * This test is part of the "largedata" suite because this test tests data for
0: * lobs to the limits ( ie blob and clob can be 2G-1 maximum) and so this test
0: * may take considerable disk space as well as time to run. Hence it is not part
0: * of the derbyall suite but should ideally be run at some intervals to test if
0: * no regression has occurred.
1: */
1: 
1: public class LobLimitsTest extends BaseJDBCTestCase {
1: 
0:    public LobLimitsTest(String name) {
1:         super(name);
1:     }
1: 
0: static boolean trace = false;
1: 
0:    static final int _2GB = 2 * 1024 * 1024* 1024 - 1;
0:    static final int _100MB = 100 * 1024 * 1024;
0:    static final long _4GB =  4*1024*1024*(1024L);
0:    static final int NUM_TRAILING_SPACES = 33*1024;
1:    
1:    
0:    static int BIGGEST_LOB_SZ= _2GB;
1: 
0:    public static void setBIGGEST_LOB_SZ(int bIGGESTLOBSZ) {
0:     BIGGEST_LOB_SZ = bIGGESTLOBSZ;
1: }
1: 
0: static int BIG_LOB_SZ = _100MB;
1: 
0:    public static void setBIG_LOB_SZ(int bIGLOBSZ) {
0:     BIG_LOB_SZ = bIGLOBSZ;
1: }
0:    static int MORE_DATA_THAN_COL_WIDTH= (_100MB)+1;
1: 
0:    public static void setMORE_DATA_THAN_COL_WIDTH(int mOREDATATHANCOLWIDTH) {
0:     MORE_DATA_THAN_COL_WIDTH = mOREDATATHANCOLWIDTH;
1: }
1: 
0: static final String DATAFILE = "extinout/byteLobLimits.dat";
1: 
0:    static final String CHARDATAFILE = "extinout/charLobLimits.txt";
1: 
1:   
1:     /**
1:      * Setup the schema and the blob sizes for the test.
1:      * @param s
0:      * @param biggestlobsz 
1:      * @param biglobsz
1:      * @throws SQLException
1:      */
0:     static void setupTables(Statement s, int biggestlobsz, int biglobsz ) throws SQLException {
0:        setBIGGEST_LOB_SZ(biggestlobsz);
0:        setBIG_LOB_SZ(biglobsz);
0:        setMORE_DATA_THAN_COL_WIDTH(biglobsz +1);
0:        println("BIGGEST_LOB_SZ=" + BIGGEST_LOB_SZ + " BIG_LOB_SZ=" + BIG_LOB_SZ);
0:        Connection conn = s.getConnection();
0:        conn.setAutoCommit(true);
0:        s.execute("CREATE TABLE BLOBTBL (ID INT NOT NULL PRIMARY KEY, "
0:                + "POS BIGINT, DLEN BIGINT, CONTENT BLOB(2G))");
0:        s.execute("CREATE TABLE CLOBTBL (ID INT NOT NULL PRIMARY KEY,"
0:                + "POS BIGINT, DLEN BIGINT, CONTENT CLOB(2G))");
0:        s.execute("CREATE TABLE BLOBTBL2 (ID INT NOT NULL PRIMARY KEY, "
0:                + "POS BIGINT, CONTENT BLOB("+BIG_LOB_SZ+"),DLEN BIGINT)");
1: 
0:        // Please dont change the clob column width,since tests use this width to 
0:        // test for truncation of trailing spaces.
0:        s.execute("CREATE TABLE CLOBTBL2 (ID INT NOT NULL PRIMARY KEY,"
0:                + "POS BIGINT, CONTENT CLOB("+BIG_LOB_SZ+"), DLEN BIGINT)"); 
1: 
1:    }
1: 
0:    public static Test suite() {
0:        // Right now run just with embeddded.
0:        Test suite = new CleanDatabaseTestSetup(
0:                new TestSuite(LobLimitsTest.class)) {
0:                    protected void decorateSQL(Statement s)
1:                            throws SQLException {
0:                        setupTables(s,_2GB, _100MB);
1:                    }
0:                };
1:                
0:        return new SupportFilesSetup(suite);
1:    }
1: 
1:    /**
0:     * tests specific for blobs
0:     * @param conn
0:     * @throws Exception
1:     */
0:    public void testBlob() throws Exception {
0:        Connection conn = getConnection();
0:        conn.setAutoCommit(false);
1:         PreparedStatement insertBlob =
1:                 prepareStatement("INSERT INTO BLOBTBL values (?,?,?,?)");
1:         PreparedStatement selectBlob =
1:                 prepareStatement("SELECT CONTENT,DLEN FROM BLOBTBL WHERE ID = ?");
1:         PreparedStatement insertBlob2 =
1:                 prepareStatement("INSERT INTO BLOBTBL2 values (?,?,?,?)");
1:         PreparedStatement selectBlob2 =
1:                 prepareStatement("SELECT CONTENT,DLEN FROM BLOBTBL2 WHERE ID = ?");
0:         PreparedStatement deleteBlob2 =
0:                 prepareStatement("DELETE FROM BLOBTBL2");
0:         PreparedStatement deleteBlob =
0:                 conn.prepareStatement("DELETE FROM BLOBTBL");
0:            // Test - 2Gb blob ( actually it is 2gb -1)
0:            // Note with setBinaryStream interface the maximum size for the
0:            // stream, can be max value for an int.
0:            // Also note, that lobs in derby currently  supports
0:            // maximum size of 2gb -1
1: 
0:            // first do insert blob of 2g, 2 rows
0:            insertBlob_SetBinaryStream("BlobTest #1", conn, insertBlob, BIGGEST_LOB_SZ,
1:                    0, 2, BIGGEST_LOB_SZ);
0:            // do a select to see if the inserts in test above went ok
0:            selectBlob("BlobTest #2", conn, selectBlob, BIGGEST_LOB_SZ, 0, 1);
0:            selectBlob("BlobTest #3", conn, selectBlob, BIGGEST_LOB_SZ, 1, 1);
1:            
0:            // now do a select of one of the 2gb rows and update another 2g row 
0:            // using the setBlob api, updated blob is of length 2gb
0:            // Fix for Bug entry -DERBY-599[setBlob should not materialize blob
0:            // into memory]
0:            selectUpdateBlob("BlobTest #4",conn,selectBlob,BIGGEST_LOB_SZ,0,1,1);
0:            // select row from blobtbl and then do insert into the blobtbl
0:            // using setBlob
0:            selectInsertBlob("BlobTest #4.1",conn,selectBlob,insertBlob,BIGGEST_LOB_SZ,0,3,1);
1:                               
0:            // Test - generate random data, write to a file, use it to insert
0:            // data into blob and then read back and compare if all is ok
0:            // currently in fvt ( derbyall), tests check for substrings etc and 
0:            // for small amounts of data.  This test will test for 100mb of blob data
1: 
0:            FileOutputStream fos = PrivilegedFileOpsForTests.getFileOutputStream(new File(DATAFILE));
0:            RandomByteStreamT r = new RandomByteStreamT(new java.util.Random(),
1:                    BIG_LOB_SZ);
0:            // write in chunks of 32k buffer
0:            byte[] buffer = new byte[32 * 1024];
1:            int count = 0;
1:            
0:            while((count=r.read(buffer))>=0)
0:                fos.write(buffer,0,count);
1: 
0:            fos.flush();
0:            fos.close();
0:            insertBlob2("BlobTest #5.1 ", conn, insertBlob2, BIG_LOB_SZ, 0, 1,
1:                    BIG_LOB_SZ, DATAFILE);
0:            selectBlob2("BlobTest #5.2 ", conn, selectBlob2, BIG_LOB_SZ, 0, 1,
1:                    DATAFILE);
1:            
1:            
0:            // update the 2gb row in blobtbl with the 100mb data and compare if the update
0:            // went ok. 
0:            selectUpdateBlob2("BlobTest #6",conn,selectBlob2,selectBlob,BIG_LOB_SZ,0,1,1,DATAFILE);
1:                        
0:            deleteTable(conn, deleteBlob2, 1);
1: 
0:        conn.commit();
1:        
0:        deleteTable(conn, deleteBlob, 3);
1:    }
1:    
0:    public void testBlobNegative () throws SQLException {
0:        // Negative Test, use setBlob api to insert a 4GB blob.
0:        Connection conn = getConnection();
0:        conn.setAutoCommit(false);
0:        PreparedStatement insertBlob = prepareStatement("INSERT INTO BLOBTBL values (?,?,?,?)");
1:        
0:        BlobImplT _4GbBlob = new BlobImplT(new RandomByteStreamT(new java.util.Random(),_4GB),_4GB);
1: 
0:        try
1:        {
0:            insertBlob_SetBlob("BlobTest #7 (setBlob with 4Gb blob",conn,insertBlob,_4GbBlob,
0:                    _4GB,0,1,0);
1:        }
0:        catch(SQLException sqle)
1:        {
0:            //DERBY DOES NOT SUPPORT INSERT OF 4GB BLOB
0:            assertSQLState("22003", sqle);
1:        }
0:        // ADD  NEW TESTS HERE
1:    }
1: 
1:    /**
0:     * tests using clobs
0:     * @throws Exception
1:     */
0:    public void testClob1() throws Exception {
0:        Connection conn = getConnection();
0:         setAutoCommit(false);
1:         PreparedStatement insertClob =
1:                 prepareStatement("INSERT INTO CLOBTBL values (?,?,?,?)");
1:         PreparedStatement selectClob = 
1:             prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL WHERE ID = ?");
1: 
0:        // Test - 2Gb blob
0:        // Note with setCharacterStream interface the maximum size for the
0:        // stream has to be max value for a int which is (2GB -1 )
0:        // first do insert clob of 2g, 2 rows
0:        insertClob_SetCharacterStream("ClobTest #1", conn, insertClob,
0:                BIGGEST_LOB_SZ, 0, 2, BIGGEST_LOB_SZ);
0:        // do a select to see if the inserts in test above went ok
0:        selectClob("ClobTest #2", conn, selectClob, BIGGEST_LOB_SZ, 0, 1);
0:        selectClob("ClobTest #3", conn, selectClob, BIGGEST_LOB_SZ, 0, 1);
0:        // do a select and then update a row of 2gb size: uses getClob
0:        selectUpdateClob("ClobTest #4",conn,selectClob,BIGGEST_LOB_SZ,0,1,1);
1:            
1:    }
1:    
1:    /**
0:     * @throws Exception
1:     */
0:    public void testClob2() throws Exception {
0:         Connection conn = getConnection();
0:         conn.setAutoCommit(false);
1:         PreparedStatement selectClob =
1:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL WHERE ID = ?");
1:         PreparedStatement insertClob2 =
1:                 prepareStatement("INSERT INTO CLOBTBL2 values (?,?,?,?)");
1:         PreparedStatement selectClob2 =
1:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 WHERE ID = ?");
1: 
0:        setAutoCommit(false);
0:            // Test - generate random data, write to a file, use it to insert
0:            // data into clob and then read back and compare if all is ok
0:            // currently in fvt ( derbyall), tests check for substrings etc and 
0:            // for small amounts of data.  This test will test for 100mb of clob data
0:            writeToFile(CHARDATAFILE,new RandomCharReaderT(new java.util.Random(),BIG_LOB_SZ));
0:            insertClob2("ClobTest #5.1 ", conn, insertClob2, BIG_LOB_SZ, 0, 1,
1:                    BIG_LOB_SZ, CHARDATAFILE);
0:            selectClob2("ClobTest #5.2 ", conn, selectClob2, BIG_LOB_SZ, 0, 1,
1:                    CHARDATAFILE);
1: 
0:            // Disabled for now, this will materialize, will open 
0:            // jira for it.
0:            //updateClob2("ClobTest #8.1",conn,selectClob,BIG_LOB_SZ,0,0,10,1,CHARDATAFILE);
1: 
0:            // update the 2gb row in clobtbl with the 100mb data and compare if the update
0:            // went ok.
0:            selectUpdateClob2("ClobTest #8.2",conn,selectClob2,selectClob,BIG_LOB_SZ,0,1,1,CHARDATAFILE);
1: 
0:            // test for trailing space truncation
0:            // insert 100mb+33k of data which has 33k of trailing space,
0:            // into a column of 100mb
0:            // insert should be successful, select should retrieve 100mb of data
1:            
0:            // Generate random data and write to a file, this file will be used
0:            // in the verification process after inserts and updates.
0:            writeToFile(CHARDATAFILE,new RandomCharReaderT(new java.util.Random(),
0:                    (NUM_TRAILING_SPACES +BIG_LOB_SZ),NUM_TRAILING_SPACES));
0:            insertClob2("ClobTest #6.1 ", conn, insertClob2,BIG_LOB_SZ, 3, 1,
0:                    (NUM_TRAILING_SPACES +BIG_LOB_SZ), CHARDATAFILE);
0:            // select will retrieve data and verify the data inserted. 
0:            selectClob2("ClobTest #6.2 ", conn, selectClob2, BIG_LOB_SZ, 3, 1,
1:                    CHARDATAFILE);
1: 
1: 
1:        }
1:    
0:    public void testClobNegative() throws Exception {
0:        Connection conn = getConnection();
0:        conn.setAutoCommit(false);
1:         PreparedStatement insertClob =
1:                 prepareStatement("INSERT INTO CLOBTBL values (?,?,?,?)");
1:         PreparedStatement selectClob =
1:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL WHERE ID = ?");
1:         PreparedStatement insertClob2 =
1:                 prepareStatement("INSERT INTO CLOBTBL2 values (?,?,?,?)");
1:         PreparedStatement selectClob2 =
1:                 prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 WHERE ID = ?");
0:         PreparedStatement deleteClob2 =
0:                 prepareStatement("DELETE  from CLOBTBL2");
0:         PreparedStatement deleteClob = prepareStatement("DELETE  from CLOBTBL");
1: 
0:        negativeSpaceTruncationTest("ClobTest #7",conn);
1:        
0:        // Test - for stream contains a trailing non-space character
0:        // insert should throw an error
0:        writeToFile(CHARDATAFILE,new RandomCharReaderT(new java.util.Random(),MORE_DATA_THAN_COL_WIDTH));
1:               
0:            try {
0:                insertClob2("ClobTest #9.1 ", conn, insertClob2,MORE_DATA_THAN_COL_WIDTH, 4, 1,
0:                        MORE_DATA_THAN_COL_WIDTH, CHARDATAFILE);
0:            }catch(SQLException sqle)
1:            {
0:                assertSQLState("XSDA4",sqle);               
1:            }
0:            // no row must be retrieved.
0:            selectClob2("ClobTest #9.2 ", conn, selectClob2, BIG_LOB_SZ, 4, 0,
1:                    CHARDATAFILE);
1: 
0:            try
1:            {
0:                insertClob2("ClobTest #10 ", conn, insertClob2,MORE_DATA_THAN_COL_WIDTH, 4, 1,
0:                        MORE_DATA_THAN_COL_WIDTH +1 , CHARDATAFILE);
0:            }catch(SQLException sqle)
1:            {
0:                //NEGATIVE TEST - Expected Exception: truncation of non-blanks not allowed and
0:                //stream length is one greater than actual length of the stream 
0:                assertSQLState("XSDA4",sqle);
1:            }
1: 
0:            try
1:            {
0:                insertClob2("ClobTest #11 ", conn, insertClob2,MORE_DATA_THAN_COL_WIDTH, 4, 1,
0:                        MORE_DATA_THAN_COL_WIDTH -1 , CHARDATAFILE);
0:            }catch(SQLException sqle)
1:            {
0:                //NEGATIVE TEST - Expected Exception: truncation of non-blanks not allowed and
0:                //stream length is one less than actual length of the stream
0:                assertSQLState("XSDA4", sqle);
1:            }
0:            deleteTable(conn, deleteClob2, 2);
1: 
0:        try {
0:            // give -ve streamlength
0:            insertClob_SetCharacterStream("ClobTest #12.1", conn, insertClob,
0:                    BIG_LOB_SZ, 4, 1, -1);
0:        } catch (SQLException sqle) {
0:            assertSQLState("XJ025", sqle);
1:        }
1: 
0:        selectClob("ClobTest #12.2", conn, selectClob,BIG_LOB_SZ, 4, 0);
1: 
0:        deleteTable(conn, deleteClob, 2);
1:        
0:        // Negative tests use the setClob API to insert a 4GB clob
1: 
0:        //long _4GB =  4*1024*1024*(1024L);
1: 
0:        ClobImplT _4GBClob = new ClobImplT(new RandomCharReaderT(new java.util.Random(),_4GB),_4GB);		
1: 
0:        try
1:        {
0:            insertClob_SetClob("ClobTest #13 (setClob with 4Gb clob",conn,insertClob,_4GBClob,
0:                    _4GB,0,1,0);
1:        }
0:        catch(SQLException sqle)
1:        {
0:            //DERBY DOES NOT SUPPORT INSERT OF 4GB CLOB 
0:            assertSQLState("22003",sqle);
1:        }
1: 
0:        // ADD NEW TESTS HERE
1:    }
1: 
0:    private static void negativeSpaceTruncationTest(String msg,Connection conn)
0:        throws Exception
1:    {
0:        PreparedStatement insertClob2 = conn
0:        .prepareStatement("INSERT INTO CLOBTBL2 values (?,?,?,?)");
1: 
0:        // Negative test, stream has trailing spaces but the stream length is one 
0:        // more than the actual length of the stream
0:        try
1:        {
0:            insertClob2(msg, conn, insertClob2,BIG_LOB_SZ, 4, 1,
0:                (NUM_TRAILING_SPACES +BIG_LOB_SZ - 1), CHARDATAFILE);
0:        }catch(SQLException sqle)
1:        {
0:            //EXPECTED EXCEPTION - stream has trailing spaces,but stream 
0:            //length is 1 less than actual length of stream
0:            assertSQLState("XSDA4",sqle);
1:        }
1: 
0:        try
1:        {
0:            insertClob2(msg, conn, insertClob2,BIG_LOB_SZ, 5, 1,
0:                (NUM_TRAILING_SPACES +BIG_LOB_SZ + 1), CHARDATAFILE);
0:        }catch(SQLException sqle)
1:        {
0:            //EXPECTED EXCEPTION - stream has trailing spaces,but stream 
0:            // length is 1 greater than actual length of stream
0:            assertSQLState("XSDA4", sqle);
1:        }
1:    }
1:    
1:  
1:    /**
0:     * insert blob
0:     * @param bloblen   length of blob to insert
0:     * @param start     start id value for insert
0:     * @param rows      insert rows number of rows
0:     * @param streamLength  stream length passed to setBinaryStream(,,length)
1:     */
0:    private static void insertBlob_SetBinaryStream(String testId,
0:            Connection conn, PreparedStatement ps, int bloblen, int start,
0:            int rows, int streamLength) throws SQLException {
1:        println("========================================");
1:        println("START " + testId + "insertBlob of size = "
1:                + bloblen);
0:        long ST = 0;
0:        ST = System.currentTimeMillis();
1: 
1:        int count = 0;
0:        java.util.Random random = new java.util.Random();
1:        for (int i = start; i < start + rows; i++) {
1:            ps.setInt(1, i);
1:            ps.setInt(2, 0);
0:            ps.setLong(3, bloblen);
0:            ps.setBinaryStream(4, new RandomByteStreamT(random, bloblen),
0:                    streamLength);
1:            count += ps.executeUpdate();
1:        }
0:        conn.commit();
0:        println("Insert Blob (" + bloblen + ")" + " rows= "
1:                    + count + " = " + (long) (System.currentTimeMillis() - ST));
0:        verifyTest(count, rows, " Rows inserted with blob of size (" + bloblen
0:                + ") =");
1:        println("========================================");
1: 
1:    }
1: 
1:    /**
0:     * insert blob, using a setBlob api.
0:     * @param bloblen
0:     *            length of blob to insert
0:     * @param blob
0:     *            blob to insert
0:     * @param start
0:     *            start id value for insert
0:     * @param rows
0:     *            insert rows number of rows
0:     * @param expectedRows
0:     *            rows expected to be inserted
1:     */
0:     private static void insertBlob_SetBlob(String testId, Connection conn,
1:             PreparedStatement ps, java.sql.Blob blob, long bloblen, int start,
1:             int rows, int expectedRows) throws SQLException {
1:         println("========================================");
1:         println("START " + testId + "insertBlob of size = "
1:                 + bloblen);
1:         long ST = System.currentTimeMillis();
1:         int count = 0;
1:             for (int i = start; i < start + rows; i++) {
1:                 ps.setInt(1, i);
1:                 ps.setInt(2, 0);
0:                 ps.setLong(3, bloblen);
0:                 ps.setBlob(4, blob);
1:                 count += ps.executeUpdate();
1:             }
0:             conn.commit();
0:             println("Insert Blob (" + bloblen + ")" + " rows= "
1:                         + count + " = "
1:                         + (long) (System.currentTimeMillis() - ST));
1: 
1:         verifyTest(count, expectedRows,
1:                 " Rows inserted with blob of size (" + bloblen + ") =");
1:         println("========================================");
1: 
1:     }
1: 
1: 
1:    /**
0:     * select from blob table (BLOBTBL)
0:     * @param bloblen  select expects to retrieve a blob of this length
0:     * @param id       id of the row to retrieve
0:     * @param expectedRows  number of rows expected to match id
1:     */
0:    private static void selectBlob(String testId, Connection conn,
0:            PreparedStatement ps, int bloblen, int id, int expectedRows)
1:            throws SQLException {
1:        println("========================================");
0:        println("START " + testId + " - SELECT BLOB of size = "
1:                + bloblen);
1: 
0:        long ST = 0;
0:        ResultSet rs = null;
0:        ST = System.currentTimeMillis();
1: 
1:        int count = 0;
0:        ps.setInt(1, id);
0:        rs = ps.executeQuery();
1: 
0:        while (rs.next()) {
0:            count++;
0:            Blob value = rs.getBlob(1);
0:            long l = value.length();
0:            long dlen = rs.getLong(2);
0:            assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:                        + " expected " + dlen + " for row in BLOBTBL with ID="
1:                        + id, dlen, l);
1:        }
0:        conn.commit();
1: 
1:        verifyTest(count, expectedRows,
0:                "Matched rows selected with blob of size(" + bloblen + ") =");
0:        println("Select Blob (" + bloblen + ")" + " rows= "
1:                    + expectedRows + " = "
1:                    + (long) (System.currentTimeMillis() - ST));
1:        println("========================================");
1:    }
1: 
1:    /**
0:     * insert blob into BLOBTBL2
0:     * @param bloblen   length of blob to insert
0:     * @param start     id value for insert
0:     * @param rows      insert rows number of rows
0:     * @param streamLength  stream length passed to setBinaryStream(,,length)
0:     * @param file      filename to match retrieved data against
1:     */
1: 
0:    private static void insertBlob2(String testId, Connection conn,
0:            PreparedStatement ps, int bloblen, int start, int rows,
0:            int streamLength, String file) throws Exception {
1:        println("========================================");
0:        println("START " + testId + "insert Blob of size = "
1:                + bloblen);
1:        int count = 0;
0:        java.util.Random random = new java.util.Random();
0:        FileInputStream fis = null;
1: 
0:        long ST = 0;
1:        
0:        ST = System.currentTimeMillis();
1: 
1:        for (int i = start; i < start + rows; i++) {
0:            fis = PrivilegedFileOpsForTests.getFileInputStream(new File(file));
1:            ps.setInt(1, i);
1:            ps.setInt(2, 0);
0:            ps.setLong(4, bloblen);
0:            ps.setBinaryStream(3, fis, streamLength);
1:            count += ps.executeUpdate();
0:            fis.close();
1:        }
0:        conn.commit();
0:        println("Insert Blob (" + bloblen + ")" + " rows= "
1:                    + count + " = " + (long) (System.currentTimeMillis() - ST));
0:        verifyTest(count, rows, " Rows inserted with blob of size (" + bloblen
0:                + ") =");
1:        println("========================================");
1: 
1:    }
1: 
1:    /**
0:     * select from blob table (BLOBTBL2)
0:     * @param bloblen  select expects to retrieve a blob of this length
0:     * @param id       id of the row to retrieve
0:     * @param expectedRows  number of rows expected to match id
0:     * @param file  name of the file,against which the retrieved data is
0:     *              compared
1:     */
0:    private static void selectBlob2(String testId, Connection conn,
0:            PreparedStatement ps, int bloblen, int id, int expectedRows,
0:            String file) throws Exception {
1:        println("========================================");
0:        println("START " + testId + " - SELECT BLOB of size = "
1:                + bloblen);
1: 
0:        long ST = 0;
0:        ResultSet rs = null;
0:        ST = System.currentTimeMillis();
1: 
1:        int count = 0;
0:        ps.setInt(1, id);
0:        rs = ps.executeQuery();
1: 
0:        while (rs.next()) {
0:            count++;
0:            Blob value = rs.getBlob(1);
0:            long l = value.length();
0:            long dlen = rs.getLong(2);
0:            assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
1:                        + " expected " + dlen + " for row in BLOBTBL with ID="
1:                        + id, dlen, l);
1:            
0:            compareBlobToFile(value.getBinaryStream(), file);
1:        }
0:        conn.commit();
1: 
1:        verifyTest(count, expectedRows,
0:                "Matched rows selected with blob of size(" + bloblen + ") =");
1: 
1:    
0:            println("Select Blob (" + bloblen + ")" + " rows= "
1:                    + expectedRows + " = "
1:                    + (long) (System.currentTimeMillis() - ST));
1:            println("========================================");
1:    }
1: 
1:    /**
0:     * Basically this test will do an update using setBlob api -
0:     * select row from blobtbl and then update a row in blobtbl 
0:     * and verify updated data in blobtbl
0:     * @param    ps  select statement from which blob is retrieved
0:     * @param    bloblen updating value is of length bloblen
0:     * @param    id  id of the row retrieved, for the update
0:     * @param    updateId  id of the row that is updated
0:     * @param    expectedRows    to be updated
1:     */
0:    private static void selectUpdateBlob(String testId, Connection conn,
0:            PreparedStatement ps, int bloblen, int id, int updateId,
0:            int expectedRows) throws Exception {
1:        println("========================================");
0:        println("START " + testId + " - select and then update blob of size= "
0:                + bloblen + " - Uses getBlob api");
1: 
0:        ResultSet rs = null;
1: 
0:        ps.setInt(1, id);
0:        rs = ps.executeQuery();
0:        rs.next();
0:        Blob value = rs.getBlob(1);
0:        long l = value.length();
0:        long dlen = rs.getLong(2);
0:        assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:                            + dlen + " for row in BLOBTBL with ID=" + id,
1:                            dlen, l);
1:        
0:        PreparedStatement psUpd = conn
0:                .prepareStatement("update BLOBTBL set content=?,dlen =? where id = ?");
0:        psUpd.setBlob(1,value);
0:        psUpd.setLong(2, l);
0:        psUpd.setInt(3, updateId);
1: 
0:        println("Rows Updated = " + psUpd.executeUpdate());
0:        conn.commit();
1: 
0:        // now select and verify that update went through ok.
0:        ps.setInt(1, updateId);
0:        ResultSet rs2 = ps.executeQuery();
0:        rs2.next();
0:        Blob updatedValue = rs2.getBlob(1);
0:        assertEquals("FAIL - Retrieving the updated blob length does not match "+
0:                    "expected length = "+l +" found = "+ updatedValue.length(),
1:                    l, updatedValue.length());
1:        
0:        // close resultsets
0:        conn.commit();
0:        rs.close();
0:        rs2.close();
0:        psUpd.close();
1:        println("========================================");
1:    }
1: 
1:    /**
0:     * Basically this test will do an insert using setBlob api -
0:     * select row from blobtbl and then insert a row in blobtbl 
0:     * and verify updated data in blobtbl
0:     * @param    ps  select statement from which blob is retrieved
0:     * @param    bloblen updating value is of length bloblen
0:     * @param    id  id of the row retrieved, for the update
0:     * @param    insertId  id of the row that is inserted
0:     * @param    expectedRows    to be updated
1:     */
0:    private static void selectInsertBlob(String testId, Connection conn,
0:            PreparedStatement ps,PreparedStatement ins, int bloblen, int id, int insertId,
0:            int expectedRows) throws Exception {
1:        println("========================================");
0:        println("START " + testId + " - select and then insert blob of size= "
0:                + bloblen + " - Uses getBlob api to do select and setBlob for insert");
1: 
0:        ResultSet rs = null;
1: 
0:        ps.setInt(1, id);
0:        rs = ps.executeQuery();
0:        rs.next();
0:        Blob value = rs.getBlob(1);
0:        long l = value.length();
0:        long dlen = rs.getLong(2);
0:        assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
1:                            + dlen + " for row in BLOBTBL with ID=" + id,
0:                            dlen,l);
0:        ins.setInt(1,insertId);
0:        ins.setInt(2,0);
0:        ins.setLong(3,l);
0:        ins.setBlob(4,value);
1:        
0:        // assert one row updated
0:        assertEquals(1,ins.executeUpdate());
0:        conn.commit();
1: 
0:        // now select and verify that update went through ok.
0:        ps.setInt(1, insertId);
0:        ResultSet rs2 = ps.executeQuery();
0:        rs2.next();
0:        Blob insertedValue = rs2.getBlob(1);
0:        assertEquals("FAIL - Retrieving the updated blob length does not match "+
0:                "expected length = "+l +" found = "+ insertedValue.length(),
0:                l, insertedValue.length());
0:        // close resultsets
0:        conn.commit();
0:        rs.close();
0:        rs2.close();
1:        println("========================================");
1:    }
1: 
1: 
1:    /**
0:     * Basically this test will do an update using setBinaryStream api and verifies the
0:     * updated data.  select row from blobtbl2 and then update a row in blobtbl 
0:     * and verify updated data in blobtbl
0:     * @param    bloblen updating value is of length bloblen
0:     * @param    id  id of the row retrieved, for the update
0:     * @param    updateId  id of the row that is updated
0:     * @param    expectedRows    to be updated  
0:     * @param file  name of the file,against which the updated data is
0:     *              compared
1:     */
0:    private static void selectUpdateBlob2(String testId, Connection conn,
0:            PreparedStatement ps,PreparedStatement sel,int bloblen, int id, int updateId,
0:            int expectedRows,String file) throws Exception {
1:        println("========================================");
0:        println("START " + testId + " - select and then update blob of size= "
0:                + bloblen + " - Uses getBlob and setBlob  api");
1: 
0:        ResultSet rs = null;
1:        
0:        // retrieve row from blobtbl2
0:        ps.setInt(1, id);
0:        rs = ps.executeQuery();
0:        rs.next();
0:        Blob value = rs.getBlob(1);
0:        long l = value.length();
0:        long dlen = rs.getLong(2);
0:        assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
0:                + dlen + " for row in BLOBTBL2 with ID=" + id, dlen, l);
1:        
0:        PreparedStatement psUpd = conn
0:                .prepareStatement("update BLOBTBL set content=?,dlen =? where id = ?");
0:        psUpd.setBlob(1,value);
0:        psUpd.setLong(2, l);
0:        psUpd.setInt(3, updateId);
0:        // assert 1 row updated
0:        assertEquals(1, psUpd.executeUpdate());
0:        conn.commit();
1: 
0:        // now select and verify that update went through ok.
0:        sel.setInt(1, updateId);
0:        ResultSet rs2 = sel.executeQuery();
0:        rs2.next();
0:        Blob updatedValue = rs2.getBlob(1);
0:        assertEquals("FAIL - MISMATCH length of updated blob value : expected="+
0:                l+" found ="+updatedValue.length(), l, updatedValue.length());
0:        compareBlobToFile(updatedValue.getBinaryStream(),file);
1: 
0:        // close resultsets
0:        conn.commit();
0:        rs.close();
0:        rs2.close();
0:        psUpd.close();
1:        println("========================================");
1: 
1:    }
1: 
0:    private static void compareBlobToFile(InputStream lobstream, String filename)
0:            throws Exception {
0:        FileInputStream file = PrivilegedFileOpsForTests.getFileInputStream(new File(filename));
0:        int l = 0;
0:        int b = 0;
0:        do {
0:            l = lobstream.read();
0:            b = file.read();
0:            assertEquals("FAIL -- MISMATCH in data stored (" + l + ") versus"+
0:                    "data retrieved from file(" + b +"). ", b,l);
0:        } while (l != -1 && b != -1);
1:    }
1: 
0:    private static void deleteTable(Connection conn, PreparedStatement ps,
0:            int expectedRows) throws SQLException {
0:        int count = ps.executeUpdate();
0:        conn.commit();
0:        verifyTest(count, expectedRows, "Rows deleted =");
1:    }
1: 
1:    
1:    /**
0:     * insert clob
0:     * @param cloblen   length of clob to insert
0:     * @param start     id value for insert
0:     * @param rows      insert rows number of rows
0:     * @param streamLength  stream length passed to setCharacterStream(...,length)
1:     */
0:    private static void insertClob_SetCharacterStream(String testId,
0:            Connection conn, PreparedStatement ps, int cloblen, int start,
0:            int rows, int streamLength) throws SQLException {
1:        println("========================================");
0:        println("START " + testId + "  -insertClob of size = "
0:                + cloblen);
1: 
0:        long ST = 0;
0:        java.util.Random random = new java.util.Random();
1:        int count = 0;
0:        ST = System.currentTimeMillis();
1: 
1:        for (int i = start; i < start + rows; i++) {
1:            ps.setInt(1, i);
1:            ps.setInt(2, 0);
1:            ps.setLong(3, cloblen);
0:            ps.setCharacterStream(4, new RandomCharReaderT(random, cloblen),
0:                    streamLength);
1:            count += ps.executeUpdate();
1:        }
0:        conn.commit();
0:        println("Insert Clob (" + cloblen + ")" + " rows= "
1:                    + count + " = " + (long) (System.currentTimeMillis() - ST));
0:        verifyTest(count, rows, "Rows inserted with clob of size (" + cloblen
0:                + ") = ");
1:        println("========================================");
1: 
1:    }
1: 
1:   /**
0:     * insert clob, using a setClob api.
0:     * @param cloblen
0:     *            length of clob to insert
0:     * @param clob
0:     *            clob to insert
0:     * @param start
0:     *            start id value for insert
0:     * @param rows
0:     *            insert rows number of rows
0:     * @param expectedRows
0:     *            rows expected to be inserted
1:    */
0:     private static void insertClob_SetClob(String testId, Connection conn,
1:             PreparedStatement ps, java.sql.Clob clob, long cloblen, int start,
1:             int rows, int expectedRows) throws SQLException {
1:         println("========================================");
1:         println("START " + testId + "insertClob of size = " + cloblen);
0:         long ST = 0;
0:         ST = System.currentTimeMillis();
1:         int count = 0;
1: 
1:         for (int i = start; i < start + rows; i++) {
1:             ps.setInt(1, i);
1:             ps.setInt(2, 0);
1:             ps.setLong(3, cloblen);
1:             ps.setClob(4, clob);
1:             count += ps.executeUpdate();
1:         }
0:         conn.commit();
1:         println("Insert Clob (" + cloblen + ")" + " rows= " + count + " = "
1:                 + (long) (System.currentTimeMillis() - ST));
1: 
1:         verifyTest(count, expectedRows, " Rows inserted with clob of size ("
1:                 + cloblen + ") =");
1:         println("========================================");
1: 
1:     }
1: 
1:    /**
0:     * select from clob table
0:     * @param cloblen  select expects to retrieve a clob of this length
0:     * @param id       id of the row to retrieve
0:     * @param expectedRows number of rows expected to match id
1:     */
0:    private static void selectClob(String testId, Connection conn,
0:            PreparedStatement ps, int cloblen, int id, int expectedRows)
1:            throws SQLException {
1:        println("========================================");
0:        println("START " + testId + " - SELECT CLOB of size = "
0:                + cloblen);
1: 
0:        long ST = 0;
1:        int count = 0;
0:        ResultSet rs = null;
0:        ST = System.currentTimeMillis();
1: 
0:        ps.setInt(1, id);
0:        rs = ps.executeQuery();
0:        while (rs.next()) {
0:            count++;
0:            Clob value = rs.getClob(1);
0:            long l = value.length();
0:            long dlen = rs.getLong(2);
0:            assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
0:                    + " expected " + dlen + " for row in CLOBTBL with ID="
0:                    + id, l, dlen);
1:            }
0:        conn.commit();
1:        
0:        println("Select Clob (" + cloblen + ")" + " rows= "
1:                + expectedRows + " = "
1:                + (long) (System.currentTimeMillis() - ST));
1: 
1: 
1:        verifyTest(count, expectedRows,
0:                "Matched rows selected with clob of size(" + cloblen + ") =");
1:        println("========================================");
1: 
1:    }
1: 
1:    /**
0:     * insert clob into CLOBTBL2
0:     * @param cloblen   length of clob to insert
0:     * @param start     id value for insert
0:     * @param rows      insert rows number of rows
0:     * @param streamLength  stream length passed to setCharacterStream(pos,reader,streamLength)
0:     * @param file       name of the file that has data to be inserted
1:     */
0:    private static void insertClob2(String testId, Connection conn,
0:            PreparedStatement ps, int cloblen, int start, int rows,
0:            int streamLength, String file) throws Exception {
1:        println("========================================");
0:        println("START " + testId + "insert Clob of size = "
0:                + cloblen);
1:        int count = 0;
0:        FileReader reader = null;
0:        long ST = 0;
0:        ST = System.currentTimeMillis();
0:         try {
1:             for (int i = start; i < start + rows; i++) {
0:                 reader = PrivilegedFileOpsForTests
1:                         .getFileReader(new File(file));
1:                 println("Got reader for file " + file + " " + reader);
1:                 ps.setInt(1, i);
1:                 ps.setInt(2, 0);
1:                 ps.setLong(4, cloblen);
1:                 ps.setCharacterStream(3, reader, streamLength);
1:                 count += ps.executeUpdate();
1:             }
0:         } finally {
0:             reader.close();
0:             println("Closed reader for file " + file + " " + reader);
1:         }
0:        conn.commit();
1:  
0:        println("Insert Clob (" + cloblen + ")" + " rows= "
1:                    + count + " = " + (long) (System.currentTimeMillis() - ST));
0:        verifyTest(count, rows, " Rows inserted with clob of size (" + cloblen
0:                + ") =");
1:        println("========================================");
1: 
1:    }
1: 
1:    /**
0:     * select from clob table (CLOBTBL2)
0:     * @param cloblen  select expects to retrieve a clob of this length
0:     * @param id       id of the row to retrieve
0:     * @param expectedRows number of rows expected to match id
0:     * @param file  filename to compare the retrieved data against
1:     */
0:    private static void selectClob2(String testId, Connection conn,
0:            PreparedStatement ps, int cloblen, int id, int expectedRows,
0:            String file) throws SQLException, Exception {
1:        println("========================================");
0:        println("START " + testId + " - SELECT CLOB of size = "
0:                + cloblen);
1: 
0:        long ST = 0;
0:        ResultSet rs = null;
1: 
0:        ST = System.currentTimeMillis();
1: 
1:        int count = 0;
0:        ps.setInt(1, id);
0:        rs = ps.executeQuery();
1: 
0:        while (rs.next()) {
0:            count++;
0:            Clob value = rs.getClob(1);
0:            long l = value.length();
0:            long dlen = rs.getLong(2);
0:            assertEquals("FAIL - MISMATCH LENGTHS GOT " + l
0:                    + " expected " + dlen + " for row in CLOBTBL2 with ID="
0:                    + id, l, cloblen);
0:            compareClobToFile(value.getCharacterStream(), file, cloblen);
1:        }
0:        conn.commit();
1: 
1:        verifyTest(count, expectedRows,
0:                "Matched rows selected with clob of size(" + cloblen + ") =");
1: 
1:        
0:        println("Select Clob (" + cloblen + ")" + " rows= "
1:                    + expectedRows + " = "
1:                    + (long) (System.currentTimeMillis() - ST));
1:        println("========================================");
1:    }
1: 
1:    /*
0:     * Basically this test will do an update using setClob api -
0:     *  select row from clobtbl and then update a row in clobtbl 
0:     * and verify updated data in clobtbl 
1:     */    
0:    private static void selectUpdateClob(String testId, Connection conn,
0:            PreparedStatement ps, int cloblen, int id, int updateId,
0:            int expectedRows) throws Exception {
1:        println("========================================");
0:        println("START " + testId + " - select and then update clob of size= "
0:                + cloblen + " - Uses setClob api");
1: 
0:        ResultSet rs = null;
1: 
0:        ps.setInt(1, id);
0:        rs = ps.executeQuery();
0:        rs.next();
0:        Clob value = rs.getClob(1);
0:        long l = value.length();
0:        long dlen = rs.getLong(2);
0:        assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
0:                + dlen + " for row in CLOBTBL with ID=" + id, dlen, l);
1: 
0:        PreparedStatement psUpd = conn
0:                .prepareStatement("update CLOBTBL set content=?,dlen =? where id = ?");
0:        psUpd.setCharacterStream(1, value.getCharacterStream(), (int) l);
0:        psUpd.setLong(2, l);
0:        psUpd.setInt(3, updateId);
1: 
0:        assertEquals(1,psUpd.executeUpdate());
1:        
0:        conn.commit();
1: 
0:        // now select and verify that update went through ok.
0:        ps.setInt(1, updateId);
0:        ResultSet rs2 = ps.executeQuery();
0:        rs2.next();
0:        Clob updatedValue = rs2.getClob(1);
0:        assertEquals("FAIL - Retrieving the updated clob length does not match "+
0:                "expected length = "+l +" found = "+ updatedValue.length(),l, 
0:                updatedValue.length());
1: 
0:        // close resultsets
0:        conn.commit();
0:        rs.close();
0:        rs2.close();
0:        psUpd.close();
1:        println("========================================");
1:    }
1: 
1:    
1:    /*
0:     * Basically this test will do an update using setBlob api and verifies the
0:     * updated data.  select row from clobtbl2 and then update a row in clobtbl 
0:     * and verify updated data in clobtbl against the data in the original file
1:     */
0:    private static void selectUpdateClob2(String testId, Connection conn,
0:            PreparedStatement ps, PreparedStatement sel,int cloblen, int id, int updateId,
0:            int expectedRows,String file) throws Exception {
1:        println("========================================");
0:        println("START " + testId + " - select and then update clob of size= "
0:                + cloblen + " - Uses setClob api");
1: 
0:        ResultSet rs = null;
1:        
0:        // retrieve row from clobtbl2
0:        ps.setInt(1, id);
0:        rs = ps.executeQuery();
0:        rs.next();
0:        Clob value = rs.getClob(1);
0:        long l = value.length();
0:        long dlen = rs.getLong(2);
0:        assertEquals("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
0:                + dlen + " for row in CLOBTBL2 with ID=" + id, dlen, l);
1: 
0:        PreparedStatement psUpd = conn
0:                .prepareStatement("update CLOBTBL set content=?,dlen =? where id = ?");
0:        psUpd.setClob(1,value);
0:        psUpd.setLong(2, l);
0:        psUpd.setInt(3, updateId);
1: 
0:        assertEquals(1, psUpd.executeUpdate());
0:        conn.commit();
1: 
0:        // now select and verify that update went through ok.
0:        sel.setInt(1, updateId);
0:        ResultSet rs2 = sel.executeQuery();
0:        rs2.next();
0:        Clob updatedValue = rs2.getClob(1);
0:        assertEquals("FAIL - MISMATCH length of updated clob value , found="+
0:                    updatedValue.length() +",expected = "+l, l, updatedValue.length());
0:        compareClobToFile(updatedValue.getCharacterStream(),file,(int)l);
1: 
0:        // close resultsets
0:        conn.commit();
0:        rs.close();
0:        rs2.close();
0:        psUpd.close();
1:        println("========================================");
1: 
1:    }
1: 
1:    /*
0:     * Basically this test will do an update using updateClob api and verifies the
0:     * updated data.  select row from clobtbl2 and then update a row in clobtbl 
0:     * and verify updated data in clobtbl against the data in the original file
0:     * @param updateRowId    id of the row that needs to be updated
1:     */
0:    private static void updateClob2(String testId, Connection conn,PreparedStatement sel,
0:            int cloblen, int id, int updateRowId,int updateIdVal,
0:            int expectedRows,String file) throws Exception {
0:        System.out.println("========================================");
0:        System.out.println("START " + testId + " - select and then update clob of size= "
0:                + cloblen + " - Uses updateClob api");
1: 
1:        
0:        PreparedStatement ps1 = conn.prepareStatement("SELECT * FROM CLOBTBL FOR UPDATE", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
0:        PreparedStatement ps = conn.prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 where ID =?");
1:         
0:        ResultSet rs = null;
0:        ps.setInt(1,id);
0:        // retrieve row from clobtbl2
0:        rs = ps.executeQuery();
0:        rs.next();
0:        Clob value = rs.getClob(1);
0:        long l = value.length();
0:        long dlen = rs.getLong(2);
0:        if (dlen != l) {
0:            System.out
0:                    .println("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
0:                            + dlen + " for row in CLOBTBL2 with ID=" + id);
1:        }
1:        
0:        ResultSet rs1 = ps1.executeQuery();
0:        while (rs1.next()) {
0:             if (rs1.getInt(1) == updateRowId)
1:             {
1:                 rs1.updateClob(4, value);
1:                 rs1.updateInt(1, updateIdVal);
1:                 rs1.updateInt(2, 0);
1:                 rs1.updateLong(3, dlen);
1:                 rs1.updateRow();
1:                 break;
1:             }
1:         }
0:        // close resultsets
0:        conn.commit();
0:        rs.close();
0:        rs1.close();
0:        ps1.close();
0:        ps.close();
1:        
0:        // verify
0:        // now select and verify that update went through ok.
0:        sel.setInt(1, updateIdVal);
0:        ResultSet rs2 = sel.executeQuery();
0:        rs2.next();
0:        Clob updatedValue = rs2.getClob(1);
1:        
0:        if (updatedValue.length() != l)
1:        {
0:            System.out.println("FAIL - MISMATCH length of updated clob value , found="+
0:                    updatedValue.length() +",expected = "+l);
1:        }
0:        else
0:            compareClobToFile(updatedValue.getCharacterStream(),file,(int)l);
1: 
1: 
0:        System.out.println("========================================");
1: 
1:    }
1: 
1:    
0:    private static void compareClobToFile(Reader lobstream, String filename,int length)
0:            throws Exception {
0:        FileReader file = PrivilegedFileOpsForTests.getFileReader(
0:                    new  File(filename));
0:        int c1 = 0;
0:        int c2 = 0;
0:        long count = 0;
0:        do {
0:            c1 = lobstream.read();
0:            c2 = file.read();
0:            assertEquals("FAIL -- MISMATCH in data stored versus data retrieved at " + 
0:                    count + " " + c1 + " does not match " + c2,
0:                    c2, c1);
0:            count++;
0:            length--;
0:        } while (c1 != -1 && c2 != -1 && length > 0);
0:        file.close();
1:    }
1: 
0:    private static void verifyTest(int affectedRows, int expectedRows,
0:            String test) {
0:        assertEquals("FAIL --" + test + affectedRows
0:                + " , but expected rows =" + expectedRows, expectedRows,
0:                affectedRows);
0:        println(test + affectedRows);
1:    }
1:    
0:    private static void writeToFile(String file,Reader r)
0:        throws IOException
1:    {
0:        // does file exist, if so delete and write to a fresh file
0:        File f =new File(file);
0:        if (PrivilegedFileOpsForTests.exists(f)) {
0:            assertTrue(PrivilegedFileOpsForTests.delete(f));
1:        }
0:        FileWriter writer = PrivilegedFileOpsForTests.getFileWriter(f);
0:        println("Got FileWriter for " + file + " " + writer);
0:        // write in chunks of 32k buffer
0:        char[] buffer = new char[32 * 1024];
1:        int count = 0;
1:        
0:        while((count = r.read(buffer)) >=0)
0:            writer.write(buffer,0,count);
0:        writer.flush();
0:        writer.close();
0:        println("writer " + writer + " for file " + file + " closed");
1:    }
1: }
1: 
1: /**
1:  * Class to generate random byte data
1:  */
1: class RandomByteStreamT extends java.io.InputStream {
0:    private long length;
1: 
0:    private java.util.Random dpr;
1: 
0:    RandomByteStreamT(java.util.Random dpr, long length) {
1:        this.length = length;
0:        this.dpr = dpr;
1: 
1:    }
1: 
0:    public int read() {
0:        if (length <= 0)
0:            return -1;
1: 
0:        length--;
0:        return (byte) (dpr.nextInt() >>> 25);
1:    }
1: 
0:    public int read(byte[] data, int off, int len) {
1: 
0:        if (length <= 0)
0:            return -1;
1: 
0:        if (len > length)
0:            len = (int)length;
1: 
0:        for (int i = 0; i < len; i++) {
0:            // chop off bits and return a +ve byte value.
0:            data[off + i] = (byte) (dpr.nextInt() >>> 25);
1:        }
1: 
0:        length -= len;
0:        return len;
1:    }
1: }
1: 
1: /*
1:  * Class to generate random char data, generates 1,2,3bytes character.
1:  */
1: class RandomCharReaderT extends java.io.Reader {
0:    private long length;
0:    private long numTrailingSpaces;
1: 
0:    private java.util.Random dpr;
1: 
0:    RandomCharReaderT(java.util.Random dpr, long length) {
1:        this.length = length;
0:        this.dpr = dpr;
0:        this.numTrailingSpaces = 0;
1:    }
1: 
0:    RandomCharReaderT(java.util.Random dpr, long length,long numTrailingSpaces) {
1:        this.length = length;
0:        this.dpr = dpr;
0:        this.numTrailingSpaces = numTrailingSpaces;
1:    }
1: 
0:    private int randomInt(int min, int max) {
0:        return dpr.nextInt(max - min) + min;
1:    }
1: 
0:    private char getChar() {
0:        // return space for trailing spaces.
0:        if (length <= numTrailingSpaces)
1:        {
0:           return ' ';
1:        }
1:           
0:        double drand = dpr.nextDouble();
0:        char c = 'a';
0:        if (drand < 0.25)
0:            c = (char) randomInt((int) 'A', (int) 'Z');
0:        else if (drand < 0.5)
0:            switch (randomInt(1, 10)) {
0:            case 1:
0:                c = '\u00c0';
1:                break;
0:            case 2:
0:                c = '\u00c1';
1:                break;
0:            case 3:
0:                c = '\u00c2';
1:                break;
0:            case 4:
0:                c = '\u00ca';
1:                break;
0:            case 5:
0:                c = '\u00cb';
1:                break;
0:            case 6:
0:                c = '\u00d4';
1:                break;
0:            case 7:
0:                c = '\u00d8';
1:                break;
0:            case 8:
0:                c = '\u00d1';
1:                break;
0:            case 9:
0:                c = '\u00cd';
1:                break;
0:            default:
0:                c = '\u00dc';
1:                break;
1:            }
0:        else if (drand < 0.75)
0:            c = (char) randomInt((int) 'a', (int) 'z');
0:        else if (drand < 1.0)
0:            switch (randomInt(1, 10)) {
0:            case 1:
0:                c = '\u00e2';
1:                break;
0:            case 2:
0:                c = '\u00e4';
1:                break;
0:            case 3:
0:                c = '\u00e7';
1:                break;
0:            case 4:
0:                c = '\u00e8';
1:                break;
0:            case 5:
0:                c = '\u00ec';
1:                break;
0:            case 6:
0:                c = '\u00ef';
1:                break;
0:            case 7:
0:                c = '\u00f6';
1:                break;
0:            case 8:
0:                c = '\u00f9';
1:                break;
0:            case 9:
0:                c = '\u00fc';
1:                break;
0:            default:
0:                c = '\u00e5';
1:                break;
1:            }
1: 
0:        return c;
1: 
1:    }
1: 
0:    public int read() {
0:        if (length <= 0)
0:            return -1;
1: 
0:        length--;
0:        return getChar();
1:    }
1: 
0:    public int read(char[] data, int off, int len) {
1: 
0:        if (length <= 0)
0:            return -1;
1: 
0:        if (len > length)
0:            len = (int)length;
1: 
0:        for (int i = 0; i < len; i++) {
0:            data[off + i] = getChar();
0:            length -= 1;
1:        }
1: 
0:        return len;
1:    }
1: 
0:    public void close() {
1: 
1:    }
1: }
1: 
1: /**
0:  * Class used to simulate a 4GB Clob implementation to 
0:  * check whether derby implements such large Clobs correctly.
0:  * Derby throws an error if the clob size exceeds 2GB
1:  **/
1: 
1: class ClobImplT implements java.sql.Clob {
1:   long length;
0:   Reader myReader;
1:  
0:   public ClobImplT(Reader myReader,long length) {
1:       this.length = length;
0:       this.myReader = myReader;
1:   }
1: 
0:   public long length() throws SQLException {
1:       return length;
1:   }
1: 
0:   public String getSubString(long pos, int length) throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public java.io.Reader getCharacterStream() throws SQLException {
0:       return myReader;
1:   }
1: 
0:   public java.io.InputStream getAsciiStream() throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public long position(String searchstr, long start) throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public long position(Clob searchstr, long start) throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public int setString(long pos, String str) throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public int setString(long pos, String str, int offset, int len) throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public java.io.OutputStream setAsciiStream(long pos) throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public java.io.Writer setCharacterStream(long pos) throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public void truncate(long len) throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public void free() throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
0:   public Reader getCharacterStream(long pos, long length) throws SQLException {
0:       throw new SQLException("Not implemented");
1:   }
1: 
1: }
1: 
1: /***
0:  * Class to simulate a 4Gb blob impl in order to test if Derby
0:  * handles such large blobs correctly. The main methods here are
0:  * only the length() and the getBinaryStream(). Rest are just
0:  * placeholders/dummy methods in order to implement the java.sql.Blob
0:  * interface
0:  * ----
0:  * Derby throws an error if the blob length exceeds the max range of
0:  * int. 
1:  */
0: class BlobImplT implements java.sql.Blob
1: {
1:     long length;
1:     InputStream myStream;
1:     
0:     public BlobImplT(InputStream is, long length)
1:     {
1:         this.myStream = is;
1:         this.length = length;
1:     }
1:     public InputStream getBinaryStream()
0:     throws SQLException
1:     {
1:         return myStream;
1:     }
1:     
1:     public byte[] getBytes()
0:     throws SQLException
1:     {
0:         throw new SQLException("Not implemented"); 
1:     }
1:     public long length()
0:     throws SQLException
1:     {
1:         return length;
1:     }
1:     
0:     public long position(Blob pattern,long start)
0:     throws SQLException
1:     {
0:         throw new SQLException("Not implemented"); 
1:     }
1:     
0:     public long position(byte[] pattern,long start)
0:     throws SQLException
1:     {
0:         throw new SQLException("Not implemented"); 
1:     }
1:     public OutputStream setBinaryStream(long pos)
0:     throws SQLException
1:     
1:     {
0:         throw new SQLException("Not implemented"); 
1:     }
1:     
0:     public int setBytes(long pos,byte[] bytes)
0:     throws SQLException
1:     {
0:         throw new SQLException("Not implemented"); 
1:     }
0:     public int setBytes(long pos,byte[] bytes,int offset,int len)
0:     throws SQLException
1:     {
0:         throw new SQLException("Not implemented"); 
1:     }
1:     
1:     public void truncate(long len)
0:     throws SQLException
1:     {
0:         throw new SQLException("Not implemented"); 
1:     }
1:     
1:     public byte[] getBytes(long pos, int length)
0:     throws SQLException
1:     {
0:         throw new SQLException("Not implemented"); 
1:     }
1:     
1: }
============================================================================