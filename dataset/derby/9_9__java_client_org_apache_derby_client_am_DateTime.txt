1:33776ff: /*
1:6eb9730: 
1:33776ff:    Derby - Class org.apache.derby.client.am.DateTime
1:6eb9730: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
41:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
2:70f7692: */
1:33776ff: package org.apache.derby.client.am;
1:491c5b6: 
1:5d2e2bd: import org.apache.derby.shared.common.reference.SQLState;
1:bead0ab: import org.apache.derby.iapi.reference.DRDAConstants;
1:5d2e2bd: 
1:a0b8943: import java.nio.charset.Charset;
1:69e3d06: import java.sql.Date;
1:69e3d06: import java.sql.Time;
1:69e3d06: import java.sql.Timestamp;
1:26b9e3c: import java.util.Calendar;
1:69e3d06: import java.util.GregorianCalendar;
1:6eb9730: import org.apache.derby.client.net.Typdef;
1:33776ff: 
1:33776ff: 
3:70f7692: /**
1:33776ff:  * High performance converters from date/time byte encodings to JDBC Date, Time and Timestamp objects.
1:70f7692:  * <p/>
1:70f7692:  * Using this class for direct date/time conversions from bytes offers superior performance over the alternative method
1:70f7692:  * of first constructing a Java String from the encoded bytes, and then using {@link java.sql.Date#valueOf
1:70f7692:  * java.sql.Date.valueOf()}, {@link java.sql.Time#valueOf java.sql.Time.valueOf()} or {@link java.sql.Timestamp#valueOf
1:70f7692:  * java.sql.Timestamp.valueOf()}.
1:70f7692:  * <p/>
1:70f7692:  */
1:70f7692: public class DateTime {
1:70f7692: 
1:70f7692:     // Hide the default constructor
1:70f7692:     private DateTime() {
4:70f7692:     }
1:491c5b6: 
1:70f7692:     private static final int dateRepresentationLength = 10;
1:70f7692:     private static final int timeRepresentationLength = 8;
1:bead0ab:     private static final int timestampRepresentationLength = DRDAConstants.DRDA_TIMESTAMP_LENGTH;
1:491c5b6: 
1:70f7692:     // *********************************************************
1:70f7692:     // ********** Output converters (byte[] -> class) **********
1:70f7692:     // *********************************************************
1:491c5b6: 
1:70f7692:     /**
1:491c5b6:      * Expected character representation is DERBY string representation of a date, 
1:491c5b6:      * which is in JIS format: <code> yyyy-mm-dd </code>
1:491c5b6:      * 
1:6eb9730:      * @param buffer    
1:491c5b6:      * @param offset    
1:26b9e3c:      * @param recyclableCal
1:491c5b6:      * @param encoding            encoding of buffer data
1:b69e1e8:      * @return  Date translated from  buffer with specified encoding
1:70f7692:      */
1:0326967:     static final Date dateBytesToDate(byte[] buffer,
1:0326967:             int offset,
1:0326967:             Calendar recyclableCal,
1:a0b8943:             Charset encoding) {
1:0326967: 
1:70f7692:         int year, month, day;
1:491c5b6: 
1:491c5b6:         String date = new String(buffer, offset, 
1:491c5b6:                 DateTime.dateRepresentationLength,encoding);
1:70f7692:         int yearIndx, monthIndx, dayIndx;
1:70f7692:         if (date.charAt(4) == '-') {
1:70f7692:             // JIS format: yyyy-mm-dd.
1:70f7692:             yearIndx = 0;
1:70f7692:             monthIndx = 5;
1:70f7692:             dayIndx = 8;
8:70f7692:         } else {
1:69e3d06:             throw new IllegalArgumentException(
1:f271471:                 SqlException.getMessageUtil().getTextMessage(
1:f271471:                     SQLState.LANG_FORMAT_EXCEPTION));
1:70f7692:         }
1:491c5b6: 
2:70f7692:         int zeroBase = ((int) '0');
1:70f7692:         // Character arithmetic is used rather than
1:70f7692:         // the less efficient Integer.parseInt (date.substring()).
2:70f7692:         year =
1:70f7692:                 1000 * (((int) date.charAt(yearIndx)) - zeroBase) +
1:70f7692:                 100 * (((int) date.charAt(yearIndx + 1)) - zeroBase) +
1:70f7692:                 10 * (((int) date.charAt(yearIndx + 2)) - zeroBase) +
1:26b9e3c:                 (((int) date.charAt(yearIndx + 3)) - zeroBase);
1:26b9e3c: 
2:70f7692:         month =
1:70f7692:                 10 * (((int) date.charAt(monthIndx)) - zeroBase) +
1:70f7692:                 (((int) date.charAt(monthIndx + 1)) - zeroBase) -
2:70f7692:                 1;
2:70f7692:         day =
1:70f7692:                 10 * (((int) date.charAt(dayIndx)) - zeroBase) +
1:70f7692:                 (((int) date.charAt(dayIndx + 1)) - zeroBase);
1:26b9e3c: 
1:33a2799:         Calendar cal = getCleanCalendar(recyclableCal);
1:26b9e3c:         cal.set(year, month, day);
1:69e3d06:         return new Date(cal.getTimeInMillis());
1:70f7692:     }
1:33a2799: 
1:70f7692:     
1:70f7692:     /**
1:491c5b6:      * Expected character representation is DERBY string representation of time,
1:491c5b6:      * which is in the format: <code> hh.mm.ss </code>
1:6eb9730:      * @param buffer
1:491c5b6:      * @param offset
1:26b9e3c:      * @param recyclableCal
1:491c5b6:      * @param encoding           encoding of buffer
1:b69e1e8:      * @return  Time translated from buffer with specified encoding
1:70f7692:      */
1:b565f41:     static final Time timeBytesToTime(byte[] buffer,
1:a0b8943:                                       int offset,
1:a0b8943:                                       Calendar recyclableCal,
1:a0b8943:                                       Charset encoding)
1:a0b8943:     {
2:70f7692:         int hour, minute, second;
1:70f7692: 
1:491c5b6:         String time = new String(buffer, offset, 
1:491c5b6:                 DateTime.timeRepresentationLength, encoding);
1:70f7692:         int zeroBase = ((int) '0');
1:70f7692: 
1:70f7692:         // compute hour.
3:70f7692:         hour =
1:70f7692:                 10 * (((int) time.charAt(0)) - zeroBase) +
1:70f7692:                 (((int) time.charAt(1)) - zeroBase);
1:70f7692:         // compute minute.
3:70f7692:         minute =
1:70f7692:                 10 * (((int) time.charAt(3)) - zeroBase) +
1:70f7692:                 (((int) time.charAt(4)) - zeroBase);
1:70f7692:         // compute second.
3:70f7692:         second =
1:70f7692:                 10 * (((int) time.charAt(6)) - zeroBase) +
1:70f7692:                 (((int) time.charAt(7)) - zeroBase);
1:33776ff: 
1:26b9e3c:         Calendar cal = getCleanCalendar(recyclableCal);
1:26b9e3c:         cal.set(1970, Calendar.JANUARY, 1, hour, minute, second);
1:69e3d06:         return new Time(cal.getTimeInMillis());
1:70f7692:     }
1:33776ff: 
1:70f7692:     /**
1:bead0ab:      * See getTimestampLength() for an explanation of how timestamps are formatted.
1:bead0ab:      * 
1:491c5b6:      * @param buffer
1:491c5b6:      * @param offset
1:26b9e3c:      * @param recyclableCal
1:491c5b6:      * @param encoding                encoding of buffer
1:bead0ab:      * @param supportsTimestampNanoseconds true if the server supports nanoseconds in timestamps
1:b69e1e8:      * @return TimeStamp translated from buffer with specified encoding
1:70f7692:      */
1:a0b8943:     static final Timestamp timestampBytesToTimestamp(
1:a0b8943:             byte[] buffer, int offset, Calendar recyclableCal,
1:a0b8943:             Charset encoding, boolean supportsTimestampNanoseconds)
1:33a2799:     {
1:70f7692:         int year, month, day, hour, minute, second, fraction;
1:bead0ab:         String timestamp = new String
1:bead0ab:             ( buffer, offset, getTimestampLength( supportsTimestampNanoseconds ), encoding );
1:491c5b6:        
1:26b9e3c:         Calendar cal = getCleanCalendar(recyclableCal);
1:33776ff: 
1:33a2799:         /* java.sql.Timestamp has nanosecond precision, so we have to keep
1:bead0ab:          * the parsed nanoseconds value and use that to set nanos.
1:33a2799:          */
1:bead0ab:         int nanos = parseTimestampString(timestamp, cal, supportsTimestampNanoseconds);
1:69e3d06:         Timestamp ts = new Timestamp(cal.getTimeInMillis());
1:bead0ab:         ts.setNanos( nanos );
1:33a2799:         return ts;
1:33a2799:     }
1:33a2799: 
1:33a2799:     /**
1:bead0ab:      * Parse a String of the form <code>yyyy-mm-dd-hh.mm.ss.ffffff[fff]</code>
1:33a2799:      * and store the various fields into the received Calendar object.
1:33a2799:      *
1:33a2799:      * @param timestamp Timestamp value to parse, as a String.
1:bead0ab:      * @param cal Calendar into which to store the parsed fields.  Should not be null.
1:bead0ab:      * @param supportsTimestampNanoseconds true if the server supports nanoseconds in timestamps
1:33a2799:      *
1:bead0ab:      * @return The nanoseconds field as parsed from the timestamp string.
1:33a2799:      *  This cannot be set in the Calendar object but we still want to
1:33a2799:      *  preserve the value, in case the caller needs it (for example, to
1:bead0ab:      *  create a java.sql.Timestamp with nanosecond precision).
1:33a2799:      */
1:33a2799:     private static int parseTimestampString(String timestamp,
1:bead0ab:         Calendar cal, boolean supportsTimestampNanoseconds )
1:33a2799:     {
1:70f7692:         int zeroBase = ((int) '0');
1:33776ff: 
1:33a2799:         cal.set(Calendar.YEAR,
1:70f7692:                 1000 * (((int) timestamp.charAt(0)) - zeroBase) +
1:70f7692:                 100 * (((int) timestamp.charAt(1)) - zeroBase) +
1:70f7692:                 10 * (((int) timestamp.charAt(2)) - zeroBase) +
1:33a2799:                 (((int) timestamp.charAt(3)) - zeroBase));
1:26b9e3c: 
1:33a2799:         cal.set(Calendar.MONTH,
1:70f7692:                 10 * (((int) timestamp.charAt(5)) - zeroBase) +
1:33a2799:                 (((int) timestamp.charAt(6)) - zeroBase) - 1);
1:33a2799: 
1:33a2799:         cal.set(Calendar.DAY_OF_MONTH,
1:70f7692:                 10 * (((int) timestamp.charAt(8)) - zeroBase) +
1:33a2799:                 (((int) timestamp.charAt(9)) - zeroBase));
1:33a2799: 
1:33a2799:         cal.set(Calendar.HOUR,
2:70f7692:                 10 * (((int) timestamp.charAt(11)) - zeroBase) +
1:33a2799:                 (((int) timestamp.charAt(12)) - zeroBase));
1:33a2799: 
1:33a2799:         cal.set(Calendar.MINUTE,
2:70f7692:                 10 * (((int) timestamp.charAt(14)) - zeroBase) +
1:33a2799:                 (((int) timestamp.charAt(15)) - zeroBase));
1:33a2799: 
1:33a2799:         cal.set(Calendar.SECOND,
2:70f7692:                 10 * (((int) timestamp.charAt(17)) - zeroBase) +
1:33a2799:                 (((int) timestamp.charAt(18)) - zeroBase));
1:26b9e3c: 
1:bead0ab:         int nanos = 
1:bead0ab:                 100000000 * (((int) timestamp.charAt(20)) - zeroBase) +
1:bead0ab:                 10000000 * (((int) timestamp.charAt(21)) - zeroBase) +
1:bead0ab:                 1000000 * (((int) timestamp.charAt(22)) - zeroBase) +
1:bead0ab:                 100000 * (((int) timestamp.charAt(23)) - zeroBase) +
1:bead0ab:                 10000 * (((int) timestamp.charAt(24)) - zeroBase) +
1:bead0ab:                 1000 * (((int) timestamp.charAt(25)) - zeroBase);
1:bead0ab:  
1:bead0ab:         if ( supportsTimestampNanoseconds )
1:bead0ab:         {
1:bead0ab:             nanos += 100 * (((int) timestamp.charAt(26)) - zeroBase);
1:bead0ab:             nanos += 10 * (((int) timestamp.charAt(27)) - zeroBase);
1:bead0ab:             nanos += (((int) timestamp.charAt(28)) - zeroBase);
1:bead0ab:         }
1:bead0ab:         
1:bead0ab:         /* The "ffffff[fff]" that we parsed is nanoseconds.  In order to
1:33a2799:          * capture that information inside of the MILLISECOND field
1:bead0ab:          * we have to divide by 1000000.
1:33a2799:          */
1:bead0ab:         cal.set(Calendar.MILLISECOND, nanos / 1000000);
1:bead0ab:         
1:bead0ab:         return nanos;
1:26b9e3c:     }
1:33776ff: 
1:70f7692:     // ********************************************************
1:70f7692:     // ********** Input converters (class -> byte[]) **********
1:70f7692:     // ********************************************************
1:33776ff: 
1:26b9e3c:     /**
1:6eb9730:      * Date is converted to a char representation in JDBC date format: <code>yyyy-mm-dd</code> date format
1:6eb9730:      * and then converted to bytes using UTF8 encoding
1:6eb9730:      * @param buffer  bytes in UTF8 encoding of the date
1:6eb9730:      * @param offset  write into the buffer from this offset 
1:6eb9730:      * @param date    date value
1:6eb9730:      * @return DateTime.dateRepresentationLength. This is the fixed length in 
1:6eb9730:      * bytes taken to represent the date value
1:6eb9730:      * @throws SqlException
1:70f7692:      */
1:70f7692:     public static final int dateToDateBytes(byte[] buffer,
11:70f7692:                                             int offset,
1:c1d0340:                                             DateTimeValue date)
1:a0b8943:     throws SqlException {
1:c1d0340:         int year = date.getYear();
3:70f7692:         if (year > 9999) {
1:5d2e2bd:             throw new SqlException(null,
1:e65b4db:                 new ClientMessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
1:66527ec:                 year, "9999");
1:70f7692:         }
2:70f7692:         int month = date.getMonth() + 1;
1:c1d0340:         int day = date.getDayOfMonth();
1:33776ff: 
2:70f7692:         char[] dateChars = new char[DateTime.dateRepresentationLength];
5:70f7692:         int zeroBase = (int) '0';
2:70f7692:         dateChars[0] = (char) (year / 1000 + zeroBase);
2:70f7692:         dateChars[1] = (char) ((year % 1000) / 100 + zeroBase);
2:70f7692:         dateChars[2] = (char) ((year % 100) / 10 + zeroBase);
2:70f7692:         dateChars[3] = (char) (year % 10 + +zeroBase);
2:70f7692:         dateChars[4] = '-';
2:70f7692:         dateChars[5] = (char) (month / 10 + zeroBase);
2:70f7692:         dateChars[6] = (char) (month % 10 + zeroBase);
2:70f7692:         dateChars[7] = '-';
2:70f7692:         dateChars[8] = (char) (day / 10 + zeroBase);
2:70f7692:         dateChars[9] = (char) (day % 10 + zeroBase);
1:6eb9730:         
1:6eb9730:         // Network server expects to read the date parameter value bytes with
1:6eb9730:         // UTF-8 encoding.  Reference - DERBY-1127
1:6eb9730:         // see DRDAConnThread.readAndSetParams
1:6eb9730:         byte[] dateBytes = (new String(dateChars)).getBytes(Typdef.UTF8ENCODING);
2:70f7692:         System.arraycopy(dateBytes, 0, buffer, offset, DateTime.dateRepresentationLength);
1:33776ff: 
2:70f7692:         return DateTime.dateRepresentationLength;
1:70f7692:     }
1:33776ff: 
1:70f7692:     /**
1:6eb9730:      * java.sql.Time is converted to character representation which is in JDBC time escape
1:6eb9730:      * format: <code>hh:mm:ss</code>, which is the same as JIS time format in DERBY string 
1:6eb9730:      * representation of a time.  The char representation is converted to bytes using UTF8 
1:6eb9730:      * encoding.
1:6eb9730:      * @param buffer  bytes in UTF8 encoding of the time
1:6eb9730:      * @param offset  write into the buffer from this offset 
1:6eb9730:      * @param time  java.sql.Time value
1:6eb9730:      * @return DateTime.timeRepresentationLength. This is the fixed length in 
1:6eb9730:      * bytes taken to represent the time value
1:70f7692:      */
1:70f7692:     public static final int timeToTimeBytes(byte[] buffer,
1:70f7692:                                             int offset,
1:c1d0340:                                             DateTimeValue time)
1:a0b8943:     {
2:70f7692:         int hour = time.getHours();
2:70f7692:         int minute = time.getMinutes();
2:70f7692:         int second = time.getSeconds();
1:70f7692: 
2:70f7692:         char[] timeChars = new char[DateTime.timeRepresentationLength];
1:70f7692:         int zeroBase = (int) '0';
2:70f7692:         timeChars[0] = (char) (hour / 10 + zeroBase);
2:70f7692:         timeChars[1] = (char) (hour % 10 + +zeroBase);
2:70f7692:         timeChars[2] = ':';
2:70f7692:         timeChars[3] = (char) (minute / 10 + zeroBase);
2:70f7692:         timeChars[4] = (char) (minute % 10 + zeroBase);
2:70f7692:         timeChars[5] = ':';
2:70f7692:         timeChars[6] = (char) (second / 10 + zeroBase);
2:70f7692:         timeChars[7] = (char) (second % 10 + zeroBase);
1:6eb9730:         
1:6eb9730:         // Network server expects to read the time parameter value bytes with
1:6eb9730:         // UTF-8 encoding.  Reference - DERBY-1127
1:6eb9730:         // see DRDAConnThread.readAndSetParams
1:6eb9730:         byte[] timeBytes = (new String(timeChars)).getBytes(Typdef.UTF8ENCODING);
2:70f7692:         System.arraycopy(timeBytes, 0, buffer, offset, DateTime.timeRepresentationLength);
1:70f7692: 
2:70f7692:         return DateTime.timeRepresentationLength;
1:70f7692:     }
1:33776ff: 
1:70f7692:     /**
1:bead0ab:      * See getTimestampLength() for an explanation of how timestamps are formatted.
1:491c5b6:      *
1:6eb9730:      * @param buffer  bytes in UTF8 encoding of the timestamp
1:6eb9730:      * @param offset  write into the buffer from this offset 
1:6eb9730:      * @param timestamp  timestamp value
1:bead0ab:      * @param supportsTimestampNanoseconds true if the server supports nanoseconds in timestamps
1:bead0ab:      * @return DateTime.timestampRepresentationLength. This is the fixed  length in bytes, taken to represent the timestamp value
1:6eb9730:      * @throws SqlException
1:70f7692:      */
1:70f7692:     public static final int timestampToTimestampBytes(byte[] buffer,
1:70f7692:                                                       int offset,
1:c1d0340:                                                       DateTimeValue timestamp,
1:bead0ab:                                                       boolean supportsTimestampNanoseconds) 
1:a0b8943:     throws SqlException {
1:c1d0340:         int year = timestamp.getYear();
1:70f7692:         if (year > 9999) {
1:5d2e2bd:             throw new SqlException(null,
1:e65b4db:                 new ClientMessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
1:66527ec:                 year, "9999");
1:70f7692:         }
2:70f7692:         int month = timestamp.getMonth() + 1;
1:c1d0340:         int day = timestamp.getDayOfMonth();
2:70f7692:         int hour = timestamp.getHours();
2:70f7692:         int minute = timestamp.getMinutes();
2:70f7692:         int second = timestamp.getSeconds();
1:70f7692:         int microsecond = timestamp.getNanos() / 1000;
1:70f7692: 
1:bead0ab:         int arrayLength = getTimestampLength( supportsTimestampNanoseconds );
1:bead0ab:         char[] timestampChars = new char[ arrayLength ];
1:70f7692:         int zeroBase = (int) '0';
1:bead0ab: 
2:70f7692:         timestampChars[0] = (char) (year / 1000 + zeroBase);
2:70f7692:         timestampChars[1] = (char) ((year % 1000) / 100 + zeroBase);
2:70f7692:         timestampChars[2] = (char) ((year % 100) / 10 + zeroBase);
2:70f7692:         timestampChars[3] = (char) (year % 10 + +zeroBase);
3:70f7692:         timestampChars[4] = '-';
2:70f7692:         timestampChars[5] = (char) (month / 10 + zeroBase);
2:70f7692:         timestampChars[6] = (char) (month % 10 + zeroBase);
3:70f7692:         timestampChars[7] = '-';
2:70f7692:         timestampChars[8] = (char) (day / 10 + zeroBase);
2:70f7692:         timestampChars[9] = (char) (day % 10 + zeroBase);
3:70f7692:         timestampChars[10] = '-';
2:70f7692:         timestampChars[11] = (char) (hour / 10 + zeroBase);
2:70f7692:         timestampChars[12] = (char) (hour % 10 + zeroBase);
3:70f7692:         timestampChars[13] = '.';
2:70f7692:         timestampChars[14] = (char) (minute / 10 + zeroBase);
2:70f7692:         timestampChars[15] = (char) (minute % 10 + zeroBase);
3:70f7692:         timestampChars[16] = '.';
2:70f7692:         timestampChars[17] = (char) (second / 10 + zeroBase);
2:70f7692:         timestampChars[18] = (char) (second % 10 + zeroBase);
3:70f7692:         timestampChars[19] = '.';
1:70f7692:         timestampChars[20] = (char) (microsecond / 100000 + zeroBase);
1:70f7692:         timestampChars[21] = (char) ((microsecond % 100000) / 10000 + zeroBase);
1:70f7692:         timestampChars[22] = (char) ((microsecond % 10000) / 1000 + zeroBase);
1:70f7692:         timestampChars[23] = (char) ((microsecond % 1000) / 100 + zeroBase);
1:70f7692:         timestampChars[24] = (char) ((microsecond % 100) / 10 + zeroBase);
1:70f7692:         timestampChars[25] = (char) (microsecond % 10 + zeroBase);
1:6eb9730:         
1:bead0ab:         if ( supportsTimestampNanoseconds )
1:bead0ab:         {
1:bead0ab:             int nanosecondsOnly = timestamp.getNanos() % 1000;
1:bead0ab:             
1:bead0ab:             timestampChars[ 26 ] = (char) (nanosecondsOnly / 100 + zeroBase);
1:bead0ab:             timestampChars[ 27 ] = (char) ((nanosecondsOnly % 100) / 10 + zeroBase);
1:bead0ab:             timestampChars[ 28 ] = (char) (nanosecondsOnly % 10 + zeroBase);
1:bead0ab:         }
1:bead0ab: 
1:6eb9730:         // Network server expects to read the timestamp parameter value bytes with
1:6eb9730:         // UTF-8 encoding.  Reference - DERBY-1127
1:6eb9730:         // see DRDAConnThread.readAndSetParams
1:bead0ab:         String newtimestampString = new String(timestampChars);
1:bead0ab:         byte[] timestampBytes = newtimestampString.getBytes(Typdef.UTF8ENCODING);
1:bead0ab:         System.arraycopy(timestampBytes, 0, buffer, offset, arrayLength);
1:33776ff: 
1:bead0ab:         return arrayLength;
1:70f7692:     }
1:33776ff: 
1:70f7692:     // *********************************************************
1:70f7692:     // ******* CROSS output converters (byte[] -> class) *******
1:70f7692:     // *********************************************************
1:491c5b6: 
1:33776ff:     
1:70f7692:     /**
1:491c5b6:      * Expected character representation is DERBY string representation of a date
1:491c5b6:      * which is in JIS format: <code> yyyy-mm-dd </code>
1:491c5b6:      * 
1:6eb9730:      * @param buffer
1:491c5b6:      * @param offset
1:26b9e3c:      * @param recyclableCal
1:491c5b6:      * @param encoding                encoding of buffer
1:b69e1e8:      * @return Timestamp translated from buffer with specified encoding
1:70f7692:      */
1:0326967:     static final Timestamp dateBytesToTimestamp(byte[] buffer,
1:70f7692:                                                                 int offset,
1:26b9e3c:                                                                 Calendar recyclableCal,
1:a0b8943:                                                                 Charset encoding)
1:a0b8943:     {
1:70f7692:         int year, month, day;
1:33776ff: 
1:491c5b6:         String date = new String(buffer, offset, DateTime.dateRepresentationLength,
1:491c5b6:                 encoding);
1:70f7692:         int yearIndx, monthIndx, dayIndx;
1:33776ff: 
1:70f7692:         yearIndx = 0;
1:70f7692:         monthIndx = 5;
1:70f7692:         dayIndx = 8;
1:33776ff: 
1:70f7692:         int zeroBase = ((int) '0');
1:70f7692:         // Character arithmetic is used rather than
1:70f7692:         // the less efficient Integer.parseInt (date.substring()).
1:70f7692:         year =
1:70f7692:                 1000 * (((int) date.charAt(yearIndx)) - zeroBase) +
1:70f7692:                 100 * (((int) date.charAt(yearIndx + 1)) - zeroBase) +
1:70f7692:                 10 * (((int) date.charAt(yearIndx + 2)) - zeroBase) +
1:26b9e3c:                 (((int) date.charAt(yearIndx + 3)) - zeroBase);
1:33776ff: 
1:70f7692:         month =
1:70f7692:                 10 * (((int) date.charAt(monthIndx)) - zeroBase) +
1:70f7692:                 (((int) date.charAt(monthIndx + 1)) - zeroBase) -
1:70f7692:                 1;
1:70f7692:         day =
1:70f7692:                 10 * (((int) date.charAt(dayIndx)) - zeroBase) +
1:70f7692:                 (((int) date.charAt(dayIndx + 1)) - zeroBase);
1:33776ff: 
1:26b9e3c:         Calendar cal = getCleanCalendar(recyclableCal);
1:26b9e3c:         cal.set(year, month, day, 0, 0, 0);
1:69e3d06:         Timestamp ts = new Timestamp(cal.getTimeInMillis());
1:26b9e3c:         ts.setNanos(0);
1:26b9e3c:         return ts;
1:70f7692:     }
1:33776ff: 
1:33776ff:     
1:70f7692:     /**
1:491c5b6:      *  Expected character representation is DERBY string representation of time
1:491c5b6:      * which is in the format: <code> hh.mm.ss </code>
1:491c5b6:      * 
1:6eb9730:      * @param buffer
1:491c5b6:      * @param offset
1:26b9e3c:      * @param recyclableCal
1:491c5b6:      * @param encoding                 encoding of buffer
1:b69e1e8:      * @return Timestamp translated from buffer with specified encoding 
1:491c5b6:      * 
1:70f7692:      */
1:0326967:     static final Timestamp timeBytesToTimestamp(byte[] buffer,
1:a0b8943:                                                 int offset,
1:a0b8943:                                                 Calendar recyclableCal,
1:a0b8943:                                                 Charset encoding)
1:a0b8943: {
1:70f7692:         int hour, minute, second;
1:33776ff: 
1:491c5b6:         String time = new String(buffer, offset, 
1:491c5b6:                 DateTime.timeRepresentationLength, encoding);
1:70f7692:         int zeroBase = ((int) '0');
1:33776ff: 
1:70f7692:         // compute hour.
1:70f7692:         hour =
1:70f7692:                 10 * (((int) time.charAt(0)) - zeroBase) +
1:70f7692:                 (((int) time.charAt(1)) - zeroBase);
1:70f7692:         // compute minute.
1:70f7692:         minute =
1:70f7692:                 10 * (((int) time.charAt(3)) - zeroBase) +
1:70f7692:                 (((int) time.charAt(4)) - zeroBase);
1:70f7692:         // compute second   JIS format: hh:mm:ss.
1:70f7692:         second =
1:70f7692:                 10 * (((int) time.charAt(6)) - zeroBase) +
1:70f7692:                 (((int) time.charAt(7)) - zeroBase);
1:70f7692: 
1:bde1220:         // The SQL standard specifies that the date portion of the returned
1:bde1220:         // timestamp should be set to the current date. See DERBY-889 for
1:bde1220:         // more details.
1:26b9e3c:         Calendar cal = getCleanCalendar(recyclableCal);
1:26b9e3c:         cal.setTime(new java.util.Date());
1:26b9e3c: 
1:26b9e3c:         // Now override the time fields with the values we parsed.
1:26b9e3c:         cal.set(Calendar.HOUR_OF_DAY, hour);
1:26b9e3c:         cal.set(Calendar.MINUTE, minute);
1:26b9e3c:         cal.set(Calendar.SECOND, second);
1:26b9e3c: 
1:26b9e3c:         // Derby's resolution for the TIME type is only seconds.
1:26b9e3c:         cal.set(Calendar.MILLISECOND, 0);
1:69e3d06:         return new Timestamp(cal.getTimeInMillis());
1:bde1220:     }
1:70f7692:     
1:70f7692:     
1:70f7692:     /**
1:bead0ab:      * See getTimestampLength() for an explanation of how timestamps are formatted.
1:491c5b6:      * 
1:491c5b6:      * @param buffer
1:491c5b6:      * @param offset
1:26b9e3c:      * @param recyclableCal
1:491c5b6:      * @param encoding             encoding of buffer
1:b69e1e8:      * @return Date translated from buffer with specified encoding
1:70f7692:      */
1:0326967:     static final Date timestampBytesToDate(byte[] buffer,
1:a0b8943:                                            int offset,
1:a0b8943:                                            Calendar recyclableCal,
1:a0b8943:                                            Charset encoding)
1:491c5b6:      {
1:70f7692:         int year, month, day;
1:70f7692: 
1:491c5b6:         String timestamp = new String(buffer, offset, 
1:491c5b6:                 DateTime.timestampRepresentationLength, encoding);
1:70f7692:         int zeroBase = ((int) '0');
1:33a2799: 
1:70f7692:         year =
1:70f7692:                 1000 * (((int) timestamp.charAt(0)) - zeroBase) +
1:70f7692:                 100 * (((int) timestamp.charAt(1)) - zeroBase) +
1:70f7692:                 10 * (((int) timestamp.charAt(2)) - zeroBase) +
1:26b9e3c:                 (((int) timestamp.charAt(3)) - zeroBase);
1:26b9e3c: 
1:70f7692:         month =
1:70f7692:                 10 * (((int) timestamp.charAt(5)) - zeroBase) +
2:70f7692:                 (((int) timestamp.charAt(6)) - zeroBase) -
1:70f7692:                 1;
1:70f7692:         day =
1:70f7692:                 10 * (((int) timestamp.charAt(8)) - zeroBase) +
2:70f7692:                 (((int) timestamp.charAt(9)) - zeroBase);
1:70f7692: 
1:26b9e3c:         Calendar cal = getCleanCalendar(recyclableCal);
1:26b9e3c:         cal.set(year, month, day);
1:69e3d06:         return new Date(cal.getTimeInMillis());
1:70f7692:     }
1:70f7692: 
1:70f7692:    
1:70f7692:     /**
1:bead0ab:      * See getTimestampLength() for an explanation of how timestamps are formatted.
1:491c5b6:      * 
1:491c5b6:      * @param buffer
1:491c5b6:      * @param offset
1:26b9e3c:      * @param recyclableCal
1:491c5b6:      * @param encoding            encoding of buffer
1:b69e1e8:      * @return  Time translated from buffer with specified Encoding
1:70f7692:      */
1:0326967:     static final Time timestampBytesToTime(byte[] buffer,
1:a0b8943:                                            int offset,
1:a0b8943:                                            Calendar recyclableCal,
1:a0b8943:                                            Charset encoding)
1:491c5b6:     {
1:33a2799:         /* When getting a java.sql.Time object from a TIMESTAMP value we
1:33a2799:          * need to preserve the milliseconds from the timestamp.
1:33a2799:          * 
1:33a2799:          * Note: a Derby SQL TIME value has by definition resolution of only
1:33a2799:          * a second so its millisecond value is always zero.  However,
1:33a2799:          * java.sql.Time is not a direct mapping to the SQL Type; rather, it's
1:33a2799:          * a JDBC type, and the JDBC java.sql.Time class has a precision of
1:33a2799:          * milliseconds.  So when converting from a SQL TIMESTAMP we should
1:33a2799:          * retain the millisecond precision.  DERBY-1816.
1:33a2799:          *
1:33a2799:          * In order to accomplish this we parse *all* fields of the timestamp
1:33a2799:          * into a Calendar object, then create the java.sql.Time object from
1:33a2799:          * that Calendar. This allows us to preserve the sub-second resolution
1:33a2799:          * that is parsed from the timestamp. 
1:33a2799:          */
1:33a2799:  
1:491c5b6:         String timestamp = new String(buffer, offset, 
1:491c5b6:                 DateTime.timestampRepresentationLength, encoding);
1:33a2799:        
1:26b9e3c:         Calendar cal = getCleanCalendar(recyclableCal);
1:33a2799: 
1:33a2799:         /* Note that "parseTimestampString()" returns microseconds but we
1:33a2799:          * ignore micros because java.sql.Time only has millisecond precision.
1:33a2799:          */
1:bead0ab:         parseTimestampString(timestamp, cal, false);
1:33a2799: 
1:33a2799:         /* Java API indicates that the date components of a Time value
1:33a2799:          * must be set to January 1, 1970. So override those values now.
1:33a2799:          */
1:33a2799:         cal.set(1970, Calendar.JANUARY, 1);
1:69e3d06:         return new Time(cal.getTimeInMillis());
1:70f7692:     }
1:70f7692: 
1:70f7692:     /**
1:26b9e3c:      * Return a clean (i.e. all values cleared out) Calendar object
1:26b9e3c:      * that can be used for creating Time, Timestamp, and Date objects.
1:26b9e3c:      * If the received Calendar object is non-null, then just clear
1:26b9e3c:      * that and return it.
1:26b9e3c:      *
1:26b9e3c:      * @param recyclableCal Calendar object to use if non-null.
1:26b9e3c:      */
1:26b9e3c:     private static Calendar getCleanCalendar(Calendar recyclableCal)
1:26b9e3c:     {
1:26b9e3c:         if (recyclableCal != null)
1:26b9e3c:         {
1:26b9e3c:             recyclableCal.clear();
1:26b9e3c:             return recyclableCal;
1:70f7692:         }
1:26b9e3c: 
1:26b9e3c:         /* Default GregorianCalendar initializes to current time.
1:26b9e3c:          * Make sure we clear that out before returning, per the
1:26b9e3c:          * contract of this method.
1:26b9e3c:          */
1:69e3d06:         Calendar result = new GregorianCalendar();
1:26b9e3c:         result.clear();
1:26b9e3c:         return result;
1:70f7692:     }
1:70f7692: 
1:70f7692:     // *********************************************************
1:70f7692:     // ******* CROSS input converters (class -> byte[]) ********
1:70f7692:     // *********************************************************
1:70f7692: 
1:70f7692:     /**
1:bead0ab:      * Return the length of a timestamp depending on whether timestamps
1:bead0ab:      * should have full nanosecond precision or be truncated to just microseconds.
1:bead0ab:      * java.sql.Timestamp is converted to a character representation which is a DERBY string 
1:bead0ab:      * representation of a timestamp converted to bytes using UTF8 encoding.
1:bead0ab:      * For Derby 10.6 and above, this is <code>yyyy-mm-dd-hh.mm.ss.fffffffff</code>.
1:bead0ab:      * For Derby 10.5 and below, this is <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>. See DERBY-2602.
1:bead0ab:      * and then converted to bytes using UTF8 encoding
1:bead0ab:      *
1:bead0ab:      * @param supportsTimestampNanoseconds true if the connection supports nanoseconds in timestamps
1:70f7692:      */
1:bead0ab:     public static int getTimestampLength( boolean supportsTimestampNanoseconds )
1:bead0ab:     {
1:bead0ab:         return supportsTimestampNanoseconds ?
1:60f5182:             DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_OLD_TIMESTAMP_LENGTH;
1:70f7692:     }
1:70f7692: 
1:70f7692: }
1:33776ff: 
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a0b8943
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
1:             Charset encoding) {
/////////////////////////////////////////////////////////////////////////
1:                                       int offset,
1:                                       Calendar recyclableCal,
1:                                       Charset encoding)
1:     {
/////////////////////////////////////////////////////////////////////////
1:     static final Timestamp timestampBytesToTimestamp(
1:             byte[] buffer, int offset, Calendar recyclableCal,
1:             Charset encoding, boolean supportsTimestampNanoseconds)
/////////////////////////////////////////////////////////////////////////
1:     throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     {
/////////////////////////////////////////////////////////////////////////
1:     throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:                                                                 Charset encoding)
1:     {
/////////////////////////////////////////////////////////////////////////
1:                                                 int offset,
1:                                                 Calendar recyclableCal,
1:                                                 Charset encoding)
1: {
/////////////////////////////////////////////////////////////////////////
1:                                            int offset,
1:                                            Calendar recyclableCal,
1:                                            Charset encoding)
/////////////////////////////////////////////////////////////////////////
1:                                            int offset,
1:                                            Calendar recyclableCal,
1:                                            Charset encoding)
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                 year, "9999");
/////////////////////////////////////////////////////////////////////////
1:                 year, "9999");
commit:4d04d50
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:c1d0340
/////////////////////////////////////////////////////////////////////////
1:                                             DateTimeValue date)
1:         int year = date.getYear();
1:         int day = date.getDayOfMonth();
/////////////////////////////////////////////////////////////////////////
1:                                             DateTimeValue time)
/////////////////////////////////////////////////////////////////////////
1:                                                       DateTimeValue timestamp,
1:         int year = timestamp.getYear();
1:         int day = timestamp.getDayOfMonth();
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
1:     static final Time timeBytesToTime(byte[] buffer,
commit:0326967
/////////////////////////////////////////////////////////////////////////
1:     static final Date dateBytesToDate(byte[] buffer,
1:             int offset,
1:             Calendar recyclableCal,
0:             String encoding) throws UnsupportedEncodingException {
1: 
/////////////////////////////////////////////////////////////////////////
0:     static final Timestamp timestampBytesToTimestamp(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:     static final Timestamp dateBytesToTimestamp(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:     static final Timestamp timeBytesToTimestamp(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:     static final Date timestampBytesToDate(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:     static final Time timestampBytesToTime(byte[] buffer,
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Date;
1: import java.sql.Time;
1: import java.sql.Timestamp;
1: import java.util.GregorianCalendar;
/////////////////////////////////////////////////////////////////////////
0:     public static final Date dateBytesToDate(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:             throw new IllegalArgumentException(
/////////////////////////////////////////////////////////////////////////
1:         return new Date(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
0:     public static final Time timeBytesToTime(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:         return new Time(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
0:     public static final Timestamp timestampBytesToTimestamp(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:         Timestamp ts = new Timestamp(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
0:     public static final Timestamp dateBytesToTimestamp(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:         Timestamp ts = new Timestamp(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
0:     public static final Timestamp timeBytesToTimestamp(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:         return new Timestamp(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
0:     public static final Date timestampBytesToDate(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:         return new Date(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
0:     public static final Time timestampBytesToTime(byte[] buffer,
/////////////////////////////////////////////////////////////////////////
1:         return new Time(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
1:         Calendar result = new GregorianCalendar();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:60f5182
/////////////////////////////////////////////////////////////////////////
1:             DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_OLD_TIMESTAMP_LENGTH;
commit:bead0ab
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.DRDAConstants;
/////////////////////////////////////////////////////////////////////////
1:     private static final int timestampRepresentationLength = DRDAConstants.DRDA_TIMESTAMP_LENGTH;
/////////////////////////////////////////////////////////////////////////
1:      * See getTimestampLength() for an explanation of how timestamps are formatted.
1:      * @param supportsTimestampNanoseconds true if the server supports nanoseconds in timestamps
0:                                                                      String encoding,
1:                                                                      boolean supportsTimestampNanoseconds) 
1:         String timestamp = new String
1:             ( buffer, offset, getTimestampLength( supportsTimestampNanoseconds ), encoding );
1:          * the parsed nanoseconds value and use that to set nanos.
1:         int nanos = parseTimestampString(timestamp, cal, supportsTimestampNanoseconds);
1:         ts.setNanos( nanos );
1:      * Parse a String of the form <code>yyyy-mm-dd-hh.mm.ss.ffffff[fff]</code>
1:      * @param cal Calendar into which to store the parsed fields.  Should not be null.
1:      * @param supportsTimestampNanoseconds true if the server supports nanoseconds in timestamps
1:      * @return The nanoseconds field as parsed from the timestamp string.
1:      *  create a java.sql.Timestamp with nanosecond precision).
1:         Calendar cal, boolean supportsTimestampNanoseconds )
/////////////////////////////////////////////////////////////////////////
1:         int nanos = 
1:                 100000000 * (((int) timestamp.charAt(20)) - zeroBase) +
1:                 10000000 * (((int) timestamp.charAt(21)) - zeroBase) +
1:                 1000000 * (((int) timestamp.charAt(22)) - zeroBase) +
1:                 100000 * (((int) timestamp.charAt(23)) - zeroBase) +
1:                 10000 * (((int) timestamp.charAt(24)) - zeroBase) +
1:                 1000 * (((int) timestamp.charAt(25)) - zeroBase);
1:  
1:         if ( supportsTimestampNanoseconds )
1:         {
1:             nanos += 100 * (((int) timestamp.charAt(26)) - zeroBase);
1:             nanos += 10 * (((int) timestamp.charAt(27)) - zeroBase);
1:             nanos += (((int) timestamp.charAt(28)) - zeroBase);
1:         }
1:         
1:         /* The "ffffff[fff]" that we parsed is nanoseconds.  In order to
1:          * we have to divide by 1000000.
1:         cal.set(Calendar.MILLISECOND, nanos / 1000000);
1:         
1:         return nanos;
/////////////////////////////////////////////////////////////////////////
1:      * See getTimestampLength() for an explanation of how timestamps are formatted.
1:      *
1:      * @param supportsTimestampNanoseconds true if the server supports nanoseconds in timestamps
1:      * @return DateTime.timestampRepresentationLength. This is the fixed  length in bytes, taken to represent the timestamp value
0:                                                       java.sql.Timestamp timestamp,
0:                                                       boolean supportsTimestampNanoseconds) 
/////////////////////////////////////////////////////////////////////////
1:         int arrayLength = getTimestampLength( supportsTimestampNanoseconds );
1:         char[] timestampChars = new char[ arrayLength ];
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ( supportsTimestampNanoseconds )
1:         {
1:             int nanosecondsOnly = timestamp.getNanos() % 1000;
1:             
1:             timestampChars[ 26 ] = (char) (nanosecondsOnly / 100 + zeroBase);
1:             timestampChars[ 27 ] = (char) ((nanosecondsOnly % 100) / 10 + zeroBase);
1:             timestampChars[ 28 ] = (char) (nanosecondsOnly % 10 + zeroBase);
1:         }
1: 
1:         String newtimestampString = new String(timestampChars);
1:         byte[] timestampBytes = newtimestampString.getBytes(Typdef.UTF8ENCODING);
1:         System.arraycopy(timestampBytes, 0, buffer, offset, arrayLength);
1:         return arrayLength;
/////////////////////////////////////////////////////////////////////////
1:      * See getTimestampLength() for an explanation of how timestamps are formatted.
/////////////////////////////////////////////////////////////////////////
1:      * See getTimestampLength() for an explanation of how timestamps are formatted.
/////////////////////////////////////////////////////////////////////////
1:         parseTimestampString(timestamp, cal, false);
/////////////////////////////////////////////////////////////////////////
1:      * Return the length of a timestamp depending on whether timestamps
1:      * should have full nanosecond precision or be truncated to just microseconds.
1:      * java.sql.Timestamp is converted to a character representation which is a DERBY string 
1:      * representation of a timestamp converted to bytes using UTF8 encoding.
1:      * For Derby 10.6 and above, this is <code>yyyy-mm-dd-hh.mm.ss.fffffffff</code>.
1:      * For Derby 10.5 and below, this is <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>. See DERBY-2602.
1:      * and then converted to bytes using UTF8 encoding
1:      *
1:      * @param supportsTimestampNanoseconds true if the connection supports nanoseconds in timestamps
1:     public static int getTimestampLength( boolean supportsTimestampNanoseconds )
1:     {
1:         return supportsTimestampNanoseconds ?
0:             DRDAConstants.JDBC_TIMESTAMP_LENGTH : DRDAConstants.DRDA_TIMESTAMP_LENGTH;
author:Army
-------------------------------------------------------------------------------
commit:33a2799
/////////////////////////////////////////////////////////////////////////
1:         Calendar cal = getCleanCalendar(recyclableCal);
1: 
1:         /* java.sql.Timestamp has nanosecond precision, so we have to keep
0:          * the parsed microseconds value and use that to set nanos.
1:          */
0:         int micros = parseTimestampString(timestamp, cal);
0:         java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
0:         ts.setNanos(micros * 1000);
1:         return ts;
1:     }
1: 
1:     /**
0:      * Parse a String of the form <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>
1:      * and store the various fields into the received Calendar object.
1:      *
1:      * @param timestamp Timestamp value to parse, as a String.
0:      * @param cal Calendar into which to store the parsed fields.  Should
0:      *  not be null.
1:      *
0:      * @return The microseconds field as parsed from the timestamp string.
1:      *  This cannot be set in the Calendar object but we still want to
1:      *  preserve the value, in case the caller needs it (for example, to
0:      *  create a java.sql.Timestamp with microsecond precision).
1:      */
1:     private static int parseTimestampString(String timestamp,
0:         Calendar cal)
1:     {
1:         cal.set(Calendar.YEAR,
1:                 (((int) timestamp.charAt(3)) - zeroBase));
1:         cal.set(Calendar.MONTH,
1:                 (((int) timestamp.charAt(6)) - zeroBase) - 1);
1: 
1:         cal.set(Calendar.DAY_OF_MONTH,
1:                 (((int) timestamp.charAt(9)) - zeroBase));
1: 
1:         cal.set(Calendar.HOUR,
1:                 (((int) timestamp.charAt(12)) - zeroBase));
1: 
1:         cal.set(Calendar.MINUTE,
1:                 (((int) timestamp.charAt(15)) - zeroBase));
1: 
1:         cal.set(Calendar.SECOND,
1:                 (((int) timestamp.charAt(18)) - zeroBase));
1: 
0:         int micros = 
/////////////////////////////////////////////////////////////////////////
0:         /* The "ffffff" that we parsed is microseconds.  In order to
1:          * capture that information inside of the MILLISECOND field
0:          * we have to divide by 1000.
1:          */
0:         cal.set(Calendar.MILLISECOND, micros / 1000);
0:         return micros;
/////////////////////////////////////////////////////////////////////////
0:     throws  UnsupportedEncodingException
1:     {
1:         /* When getting a java.sql.Time object from a TIMESTAMP value we
1:          * need to preserve the milliseconds from the timestamp.
1:          * 
1:          * Note: a Derby SQL TIME value has by definition resolution of only
1:          * a second so its millisecond value is always zero.  However,
1:          * java.sql.Time is not a direct mapping to the SQL Type; rather, it's
1:          * a JDBC type, and the JDBC java.sql.Time class has a precision of
1:          * milliseconds.  So when converting from a SQL TIMESTAMP we should
1:          * retain the millisecond precision.  DERBY-1816.
1:          *
1:          * In order to accomplish this we parse *all* fields of the timestamp
1:          * into a Calendar object, then create the java.sql.Time object from
1:          * that Calendar. This allows us to preserve the sub-second resolution
1:          * that is parsed from the timestamp. 
1:          */
1:  
1:        
1: 
1:         /* Note that "parseTimestampString()" returns microseconds but we
1:          * ignore micros because java.sql.Time only has millisecond precision.
1:          */
0:         parseTimestampString(timestamp, cal);
1: 
1:         /* Java API indicates that the date components of a Time value
1:          * must be set to January 1, 1970. So override those values now.
1:          */
1:         cal.set(1970, Calendar.JANUARY, 1);
commit:26b9e3c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Calendar;
/////////////////////////////////////////////////////////////////////////
1:      * @param recyclableCal
1:                                                       Calendar recyclableCal, 
/////////////////////////////////////////////////////////////////////////
1:                 (((int) date.charAt(yearIndx + 3)) - zeroBase);
1: 
/////////////////////////////////////////////////////////////////////////
1:         Calendar cal = getCleanCalendar(recyclableCal);
1:         cal.set(year, month, day);
0:         return new java.sql.Date(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
1:      * @param recyclableCal
0:                                                       Calendar recyclableCal,
/////////////////////////////////////////////////////////////////////////
1:         Calendar cal = getCleanCalendar(recyclableCal);
1:         cal.set(1970, Calendar.JANUARY, 1, hour, minute, second);
0:         return new java.sql.Time(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
1:      * @param recyclableCal
0:                                                                      Calendar recyclableCal, 
/////////////////////////////////////////////////////////////////////////
1:                 (((int) timestamp.charAt(3)) - zeroBase);
1: 
/////////////////////////////////////////////////////////////////////////
1:         Calendar cal = getCleanCalendar(recyclableCal);
0:         cal.set(year, month, day, hour, minute, second);
0:         java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
0:         ts.setNanos(fraction * 1000);
1:         return ts;
/////////////////////////////////////////////////////////////////////////
1:      * @param recyclableCal
0:                                                                 Calendar recyclableCal,
/////////////////////////////////////////////////////////////////////////
1:                 (((int) date.charAt(yearIndx + 3)) - zeroBase);
1: 
/////////////////////////////////////////////////////////////////////////
1:         Calendar cal = getCleanCalendar(recyclableCal);
1:         cal.set(year, month, day, 0, 0, 0);
0:         java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
1:         ts.setNanos(0);
0:         return ts;
/////////////////////////////////////////////////////////////////////////
1:      * @param recyclableCal
/////////////////////////////////////////////////////////////////////////
0:                                                                 Calendar recyclableCal, 
/////////////////////////////////////////////////////////////////////////
1:         Calendar cal = getCleanCalendar(recyclableCal);
1:         cal.setTime(new java.util.Date());
1: 
1:         // Now override the time fields with the values we parsed.
1:         cal.set(Calendar.HOUR_OF_DAY, hour);
1:         cal.set(Calendar.MINUTE, minute);
1:         cal.set(Calendar.SECOND, second);
1: 
1:         // Derby's resolution for the TIME type is only seconds.
1:         cal.set(Calendar.MILLISECOND, 0);
0:         return new java.sql.Timestamp(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
1:      * @param recyclableCal
0:                                                            Calendar recyclableCal, 
/////////////////////////////////////////////////////////////////////////
0:                 (((int) timestamp.charAt(3)) - zeroBase);
1: 
/////////////////////////////////////////////////////////////////////////
1:         Calendar cal = getCleanCalendar(recyclableCal);
1:         cal.set(year, month, day);
0:         return new java.sql.Date(cal.getTimeInMillis());
/////////////////////////////////////////////////////////////////////////
1:      * @param recyclableCal
0:                                                            Calendar recyclableCal, 
/////////////////////////////////////////////////////////////////////////
0:         Calendar cal = getCleanCalendar(recyclableCal);
0:         cal.set(1970, Calendar.JANUARY, 1, hour, minute, second);
0:         return new java.sql.Time(cal.getTimeInMillis());
1:     }
1: 
1:     /**
1:      * Return a clean (i.e. all values cleared out) Calendar object
1:      * that can be used for creating Time, Timestamp, and Date objects.
1:      * If the received Calendar object is non-null, then just clear
1:      * that and return it.
1:      *
1:      * @param recyclableCal Calendar object to use if non-null.
1:      */
1:     private static Calendar getCleanCalendar(Calendar recyclableCal)
1:     {
1:         if (recyclableCal != null)
1:         {
1:             recyclableCal.clear();
1:             return recyclableCal;
1: 
1:         /* Default GregorianCalendar initializes to current time.
1:          * Make sure we clear that out before returning, per the
1:          * contract of this method.
1:          */
0:         Calendar result = new java.util.GregorianCalendar();
1:         result.clear();
1:         return result;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:bde1220
/////////////////////////////////////////////////////////////////////////
1:         // The SQL standard specifies that the date portion of the returned
1:         // timestamp should be set to the current date. See DERBY-889 for
1:         // more details.
0:         java.util.Date today = new java.util.Date();
0:             recyclableTimestamp = new java.sql.Timestamp(today.getTime());
0:         else {
0:             recyclableTimestamp.setTime(today.getTime());
1:         }
0:         recyclableTimestamp.setHours(hour);
0:         recyclableTimestamp.setMinutes(minute);
0:         recyclableTimestamp.setSeconds(second);
0:         recyclableTimestamp.setNanos(0);
0:         return recyclableTimestamp;
commit:6eb9730
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.net.Typdef;
/////////////////////////////////////////////////////////////////////////
1:      * Date is converted to a char representation in JDBC date format: <code>yyyy-mm-dd</code> date format
1:      * and then converted to bytes using UTF8 encoding
1:      * @param buffer  bytes in UTF8 encoding of the date
1:      * @param offset  write into the buffer from this offset 
1:      * @param date    date value
1:      * @return DateTime.dateRepresentationLength. This is the fixed length in 
1:      * bytes taken to represent the date value
1:      * @throws SqlException
0:      * @throws UnsupportedEncodingException if UTF8 Encoding is not supported
0:                                             java.sql.Date date) 
0:     throws SqlException,UnsupportedEncodingException {
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Network server expects to read the date parameter value bytes with
1:         // UTF-8 encoding.  Reference - DERBY-1127
1:         // see DRDAConnThread.readAndSetParams
1:         byte[] dateBytes = (new String(dateChars)).getBytes(Typdef.UTF8ENCODING);
1:      * java.sql.Time is converted to character representation which is in JDBC time escape
1:      * format: <code>hh:mm:ss</code>, which is the same as JIS time format in DERBY string 
1:      * representation of a time.  The char representation is converted to bytes using UTF8 
1:      * encoding.
1:      * @param buffer  bytes in UTF8 encoding of the time
1:      * @param offset  write into the buffer from this offset 
1:      * @param time  java.sql.Time value
1:      * @return DateTime.timeRepresentationLength. This is the fixed length in 
1:      * bytes taken to represent the time value
0:      * @throws UnsupportedEncodingException
0:                                             java.sql.Time time)
0:     throws UnsupportedEncodingException {
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Network server expects to read the time parameter value bytes with
1:         // UTF-8 encoding.  Reference - DERBY-1127
1:         // see DRDAConnThread.readAndSetParams
1:         byte[] timeBytes = (new String(timeChars)).getBytes(Typdef.UTF8ENCODING);
0:      * java.sql.Timestamp is converted to a character representation which is in DERBY string 
0:      * representation of a timestamp: <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
0:      * and then converted to bytes using UTF8 encoding
1:      * @param buffer  bytes in UTF8 encoding of the timestamp
1:      * @param offset  write into the buffer from this offset 
1:      * @param timestamp  timestamp value
0:      * @return DateTime.timestampRepresentationLength. This is the fixed 
0:      * length in bytes, taken to represent the timestamp value
1:      * @throws SqlException
0:      * @throws UnsupportedEncodingException
0:                                                       java.sql.Timestamp timestamp) 
0:     throws SqlException,UnsupportedEncodingException {
/////////////////////////////////////////////////////////////////////////
1:         
1:         // Network server expects to read the timestamp parameter value bytes with
1:         // UTF-8 encoding.  Reference - DERBY-1127
1:         // see DRDAConnThread.readAndSetParams
0:         byte[] timestampBytes = (new String(timestampChars)).getBytes(Typdef.UTF8ENCODING);
/////////////////////////////////////////////////////////////////////////
0:      * java.sql.Timestamp is converted to character representation that is in JDBC date escape 
0:      * format: <code>yyyy-mm-dd</code>, which is the same as JIS date format in DERBY string representation of a date.
0:      * and then converted to bytes using UTF8 encoding.
1:      * @param buffer  
0:      * @param offset  write into the buffer from this offset 
0:      * @param timestamp  timestamp value
0:      * @return DateTime.dateRepresentationLength. This is the fixed length 
0:      * in bytes, that is taken to represent the timestamp value as a date.
0:      * @throws SqlException
0:      * @throws UnsupportedEncodingException
0:                                                  java.sql.Timestamp timestamp)
0:     throws SqlException,UnsupportedEncodingException {
/////////////////////////////////////////////////////////////////////////
0:         // Network server expects to read the date parameter value bytes with
0:         // UTF-8 encoding.  Reference - DERBY-1127
0:         // see DRDAConnThread.readAndSetParams
0:         byte[] dateBytes = (new String(dateChars)).getBytes(Typdef.UTF8ENCODING);
0:      * java.sql.Timestamp is converted to character representation in JDBC time escape format:
0:      *  <code>hh:mm:ss</code>, which is the same as
0:      * JIS time format in DERBY string representation of a time. The char representation is 
0:      * then converted to bytes using UTF8 encoding and written out into the buffer
1:      * @param buffer
0:      * @param offset  write into the buffer from this offset 
0:      * @param timestamp timestamp value
0:      * @return DateTime.timeRepresentationLength. This is the fixed length 
0:      * in bytes taken to represent the timestamp value as Time.
0:      * @throws UnsupportedEncodingException
0:                                                  java.sql.Timestamp timestamp)
0:         throws UnsupportedEncodingException {
/////////////////////////////////////////////////////////////////////////
1:         
0:         // Network server expects to read the time parameter value bytes with
0:         // UTF-8 encoding.  Reference - DERBY-1127
0:         // see DRDAConnThread.readAndSetParams 
0:         byte[] timeBytes = (new String(timeChars)).getBytes(Typdef.UTF8ENCODING);
0:      * java.sql.Date is converted to character representation that is in DERBY string 
0:      * representation of a timestamp:<code>yyyy-mm-dd-hh.mm.ss.ffffff</code> and then 
0:      * converted to bytes using UTF8 encoding and written out to the buffer
1:      * @param buffer
0:      * @param offset offset in buffer to start writing to
0:      * @param date date value
0:      * @return DateTime.timestampRepresentationLength. This is the fixed length
0:      * in bytes, taken to represent the timestamp value.
0:      * @throws SqlException
0:      * @throws UnsupportedEncodingException
0:                                                  java.sql.Date date)
0:     throws SqlException, UnsupportedEncodingException {
/////////////////////////////////////////////////////////////////////////
1:         
0:         // Network server expects to read the timestamp parameter value bytes with
0:         // UTF-8 encoding.  Reference - DERBY-1127
0:         // see DRDAConnThread.readAndSetParams 
0:         byte[] timestampBytes = (new String(timestampChars)).getBytes(Typdef.UTF8ENCODING);
0:      * java.sql.Time is converted to a character representation that is in DERBY string representation of a timestamp:
0:      * <code>yyyy-mm-dd-hh.mm.ss.ffffff</code> and converted to bytes using UTF8 encoding 
1:      * @param buffer
0:      * @param offset offset in buffer to start writing to
0:      * @param time time value
0:      * @return DateTime.timestampRepresentationLength which is the fixed length
0:      * taken up by the conversion of time to timestamp in bytes
0:      * @throws UnsupportedEncodingException
0:                                                  java.sql.Time time)
0:     throws UnsupportedEncodingException {
/////////////////////////////////////////////////////////////////////////
0:         // Network server expects to read the timestamp parameter value bytes with
0:         // UTF-8 encoding.  Reference - DERBY-1127
0:         // see DRDAConnThread.readAndSetParams for TIMESTAMP
0:         byte[] timestampBytes = (new String(timestampChars)).getBytes(Typdef.UTF8ENCODING);
commit:b69e1e8
/////////////////////////////////////////////////////////////////////////
1:      * @return  Date translated from  buffer with specified encoding
/////////////////////////////////////////////////////////////////////////
1:      * @return  Time translated from buffer with specified encoding
/////////////////////////////////////////////////////////////////////////
1:      * @return TimeStamp translated from buffer with specified encoding
/////////////////////////////////////////////////////////////////////////
1:      * @return Timestamp translated from buffer with specified encoding
/////////////////////////////////////////////////////////////////////////
1:      * @return Timestamp translated from buffer with specified encoding 
/////////////////////////////////////////////////////////////////////////
1:      * @return Date translated from buffer with specified encoding
/////////////////////////////////////////////////////////////////////////
1:      * @return  Time translated from buffer with specified Encoding
commit:491c5b6
/////////////////////////////////////////////////////////////////////////
0: import java.io.UnsupportedEncodingException;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Expected character representation is DERBY string representation of a date, 
1:      * which is in JIS format: <code> yyyy-mm-dd </code>
1:      * 
1:      * @param buffer    
1:      * @param offset    
0:      * @param recyclableDate
1:      * @param encoding            encoding of buffer data
0:      * @return
0:      * @throws UnsupportedEncodingException
0:                                                       java.sql.Date recyclableDate, 
0:                                                       String encoding) 
0:     throws UnsupportedEncodingException {
1:         String date = new String(buffer, offset, 
1:                 DateTime.dateRepresentationLength,encoding);
/////////////////////////////////////////////////////////////////////////
1:     
1:      * Expected character representation is DERBY string representation of time,
1:      * which is in the format: <code> hh.mm.ss </code>
1:      * @param buffer
1:      * @param offset
0:      * @param recyclableTime
1:      * @param encoding           encoding of buffer
0:      * @return
0:      * @throws UnsupportedEncodingException
0:                                                       java.sql.Time recyclableTime,
0:                                                       String encoding) 
0:     throws UnsupportedEncodingException {
1:         String time = new String(buffer, offset, 
1:                 DateTime.timeRepresentationLength, encoding);
/////////////////////////////////////////////////////////////////////////
1:      * 
1:      * @param buffer
1:      * @param offset
0:      * @param recyclableTimestamp
1:      * @param encoding                encoding of buffer
0:      * @return
0:      * @throws UnsupportedEncodingException
0:                                                                      java.sql.Timestamp recyclableTimestamp, 
0:                                                                      String encoding) 
0:     throws UnsupportedEncodingException
1:     {
1:         String timestamp = new String(buffer, offset, 
0:                 DateTime.timestampRepresentationLength,encoding);
1:        
/////////////////////////////////////////////////////////////////////////
1:     
1:      * Expected character representation is DERBY string representation of a date
1:      * which is in JIS format: <code> yyyy-mm-dd </code>
1:      * 
0:      * @param buffer
1:      * @param offset
0:      * @param recyclableTimestamp
1:      * @param encoding                encoding of buffer
0:      * @return
0:      * @throws UnsupportedEncodingException
0:                                                                 java.sql.Timestamp recyclableTimestamp,
0:                                                                 String encoding) 
0:     throws UnsupportedEncodingException {
1:         String date = new String(buffer, offset, DateTime.dateRepresentationLength,
1:                 encoding);
/////////////////////////////////////////////////////////////////////////
1:     
1:      *  Expected character representation is DERBY string representation of time
1:      * which is in the format: <code> hh.mm.ss </code>
1:      * 
0:      * @param buffer
1:      * @param offset
0:      * @param recyclableTimestamp
1:      * @param encoding                 encoding of buffer
0:      * @return  
0:      * @throws UnsupportedEncodingException
1:      * 
0:                                                                 java.sql.Timestamp recyclableTimestamp, 
0:                                                                 String encoding)
0:     throws UnsupportedEncodingException {
1:         String time = new String(buffer, offset, 
1:                 DateTime.timeRepresentationLength, encoding);
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:      * 
0:      * @param buffer
1:      * @param offset
0:      * @param recyclableDate
1:      * @param encoding             encoding of buffer
0:      * @return
0:      * @throws UnsupportedEncodingException
0:                                                            java.sql.Date recyclableDate, 
0:                                                            String encoding) 
0:     throws UnsupportedEncodingException 
1:      {
1:         String timestamp = new String(buffer, offset, 
1:                 DateTime.timestampRepresentationLength, encoding);
/////////////////////////////////////////////////////////////////////////
1:    
1:      * 
0:      * @param buffer
1:      * @param offset
0:      * @param recyclableTime
1:      * @param encoding            encoding of buffer
0:      * @return
0:      * @throws UnsupportedEncodingException
0:                                                            java.sql.Time recyclableTime, 
0:                                                            String encoding) 
0:     throws  UnsupportedEncodingException {
0:         String timestamp = new String(buffer, offset, 
1:                 DateTime.timestampRepresentationLength, encoding);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f271471
/////////////////////////////////////////////////////////////////////////
1:                 SqlException.getMessageUtil().getTextMessage(
1:                     SQLState.LANG_FORMAT_EXCEPTION));
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
/////////////////////////////////////////////////////////////////////////
0:                 new ClientMessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.i18n.MessageUtil;
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
0:             throw new java.lang.IllegalArgumentException(
0:                 MessageUtil.getCompleteMessage(SQLState.LANG_FORMAT_EXCEPTION,
0:                     SqlException.CLIENT_MESSAGE_RESOURCE_NAME,
0:                     (Object[])null));
/////////////////////////////////////////////////////////////////////////
0:                                             java.sql.Date date) throws SqlException {
1:             throw new SqlException(null,
0:                 new MessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
0:                 new Integer(year), "9999");
/////////////////////////////////////////////////////////////////////////
0:                                                       java.sql.Timestamp timestamp) throws SqlException {
1:             throw new SqlException(null,
0:                 new MessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
0:                 new Integer(year), "9999");
/////////////////////////////////////////////////////////////////////////
0:                                                  java.sql.Timestamp timestamp) throws SqlException {
0:             throw new SqlException(null,
0:                 new MessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
0:                 new Integer(year), "9999");
/////////////////////////////////////////////////////////////////////////
0:                                                  java.sql.Date date) throws SqlException {
0:             throw new SqlException(null,
0:                 new MessageId(SQLState.YEAR_EXCEEDS_MAXIMUM),
0:                 new Integer(year), "9999");
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1:  * <p/>
1:  * Using this class for direct date/time conversions from bytes offers superior performance over the alternative method
1:  * of first constructing a Java String from the encoded bytes, and then using {@link java.sql.Date#valueOf
1:  * java.sql.Date.valueOf()}, {@link java.sql.Time#valueOf java.sql.Time.valueOf()} or {@link java.sql.Timestamp#valueOf
1:  * java.sql.Timestamp.valueOf()}.
1:  * <p/>
1: public class DateTime {
1:     // Hide the default constructor
1:     private DateTime() {
1:     private static final int dateRepresentationLength = 10;
1:     private static final int timeRepresentationLength = 8;
0:     private static final int timestampRepresentationLength = 26;
1:     // *********************************************************
1:     // ********** Output converters (byte[] -> class) **********
1:     // *********************************************************
1: 
1:     /**
0:      * Expected character representation is DERBY string representation of a date, which is in one of the following
0:      * format.
1:      */
0:     public static final java.sql.Date dateBytesToDate(byte[] buffer,
1:                                                       int offset,
0:                                                       java.sql.Date recyclableDate) {
1:         int year, month, day;
1: 
0:         String date = new String(buffer, offset, DateTime.dateRepresentationLength);
1:         int yearIndx, monthIndx, dayIndx;
1:         if (date.charAt(4) == '-') {
1:             // JIS format: yyyy-mm-dd.
1:             yearIndx = 0;
1:             monthIndx = 5;
1:             dayIndx = 8;
1:         } else {
0:             throw new java.lang.IllegalArgumentException("Unsupported date format!");
1:         }
1: 
1:         int zeroBase = ((int) '0');
1:         // Character arithmetic is used rather than
1:         // the less efficient Integer.parseInt (date.substring()).
1:         year =
1:                 1000 * (((int) date.charAt(yearIndx)) - zeroBase) +
1:                 100 * (((int) date.charAt(yearIndx + 1)) - zeroBase) +
1:                 10 * (((int) date.charAt(yearIndx + 2)) - zeroBase) +
0:                 (((int) date.charAt(yearIndx + 3)) - zeroBase) -
0:                 1900;
1:         month =
1:                 10 * (((int) date.charAt(monthIndx)) - zeroBase) +
1:                 (((int) date.charAt(monthIndx + 1)) - zeroBase) -
1:                 1;
1:         day =
1:                 10 * (((int) date.charAt(dayIndx)) - zeroBase) +
1:                 (((int) date.charAt(dayIndx + 1)) - zeroBase);
1: 
0:         if (recyclableDate == null) {
0:             return new java.sql.Date(year, month, day);
1:         } else {
0:             recyclableDate.setYear(year);
0:             recyclableDate.setMonth(month);
0:             recyclableDate.setDate(day);
0:             return recyclableDate;
1:         }
1:     /**
0:      * Expected character representation is DERBY string representation of a time, which is in one of the following
0:      * format: hh.mm.ss.
1:      */
0:     public static final java.sql.Time timeBytesToTime(byte[] buffer,
1:                                                       int offset,
0:                                                       java.sql.Time recyclableTime) {
1:         int hour, minute, second;
0:         String time = new String(buffer, offset, DateTime.timeRepresentationLength);
1:         int zeroBase = ((int) '0');
1:         // compute hour.
1:         hour =
1:                 10 * (((int) time.charAt(0)) - zeroBase) +
1:                 (((int) time.charAt(1)) - zeroBase);
1:         // compute minute.
1:         minute =
1:                 10 * (((int) time.charAt(3)) - zeroBase) +
1:                 (((int) time.charAt(4)) - zeroBase);
1:         // compute second.
1:         second =
1:                 10 * (((int) time.charAt(6)) - zeroBase) +
1:                 (((int) time.charAt(7)) - zeroBase);
0:         if (recyclableTime == null) {
0:             return new java.sql.Time(hour, minute, second);
1:         } else {
0:             recyclableTime.setHours(hour);
0:             recyclableTime.setMinutes(minute);
0:             recyclableTime.setSeconds(second);
0:             return recyclableTime;
1:         }
1:     /**
0:      * Expected character representation is DERBY string representation of a timestamp:
0:      * <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
1:      */
0:     public static final java.sql.Timestamp timestampBytesToTimestamp(byte[] buffer,
1:                                                                      int offset,
0:                                                                      java.sql.Timestamp recyclableTimestamp) {
1:         int year, month, day, hour, minute, second, fraction;
0:         String timestamp = new String(buffer, offset, DateTime.timestampRepresentationLength);
1:         int zeroBase = ((int) '0');
1:         year =
1:                 1000 * (((int) timestamp.charAt(0)) - zeroBase) +
1:                 100 * (((int) timestamp.charAt(1)) - zeroBase) +
1:                 10 * (((int) timestamp.charAt(2)) - zeroBase) +
0:                 (((int) timestamp.charAt(3)) - zeroBase) -
0:                 1900;
1:         month =
1:                 10 * (((int) timestamp.charAt(5)) - zeroBase) +
1:                 (((int) timestamp.charAt(6)) - zeroBase) -
1:                 1;
1:         day =
1:                 10 * (((int) timestamp.charAt(8)) - zeroBase) +
1:                 (((int) timestamp.charAt(9)) - zeroBase);
1:         hour =
1:                 10 * (((int) timestamp.charAt(11)) - zeroBase) +
0:                 (((int) timestamp.charAt(12)) - zeroBase);
1:         minute =
1:                 10 * (((int) timestamp.charAt(14)) - zeroBase) +
0:                 (((int) timestamp.charAt(15)) - zeroBase);
1:         second =
1:                 10 * (((int) timestamp.charAt(17)) - zeroBase) +
0:                 (((int) timestamp.charAt(18)) - zeroBase);
0:         fraction =
0:                 100000 * (((int) timestamp.charAt(20)) - zeroBase) +
0:                 10000 * (((int) timestamp.charAt(21)) - zeroBase) +
0:                 1000 * (((int) timestamp.charAt(22)) - zeroBase) +
0:                 100 * (((int) timestamp.charAt(23)) - zeroBase) +
0:                 10 * (((int) timestamp.charAt(24)) - zeroBase) +
0:                 (((int) timestamp.charAt(25)) - zeroBase);
0:         if (recyclableTimestamp == null) {
0:             return new java.sql.Timestamp(year, month, day, hour, minute, second, fraction * 1000);
1:         } else {
0:             recyclableTimestamp.setYear(year);
0:             recyclableTimestamp.setMonth(month);
0:             recyclableTimestamp.setDate(day);
0:             recyclableTimestamp.setHours(hour);
0:             recyclableTimestamp.setMinutes(minute);
0:             recyclableTimestamp.setSeconds(second);
0:             recyclableTimestamp.setNanos(fraction * 1000);
0:             return recyclableTimestamp;
1:         }
1:     // ********************************************************
1:     // ********** Input converters (class -> byte[]) **********
1:     // ********************************************************
1:     /**
0:      * The returned character representation is in JDBC date format: <code>yyyy-mm-dd</code> date format in DERBY string
0:      * representation of a date.
1:      */
1:     public static final int dateToDateBytes(byte[] buffer,
1:                                             int offset,
0:                                             java.sql.Date date) throws ConversionException {
0:         int year = date.getYear() + 1900;
1:         if (year > 9999) {
0:             throw new ConversionException("Year exceeds the maximum \"9999\".");
1:         }
1:         int month = date.getMonth() + 1;
0:         int day = date.getDate();
1:         char[] dateChars = new char[DateTime.dateRepresentationLength];
1:         int zeroBase = (int) '0';
1:         dateChars[0] = (char) (year / 1000 + zeroBase);
1:         dateChars[1] = (char) ((year % 1000) / 100 + zeroBase);
1:         dateChars[2] = (char) ((year % 100) / 10 + zeroBase);
1:         dateChars[3] = (char) (year % 10 + +zeroBase);
1:         dateChars[4] = '-';
1:         dateChars[5] = (char) (month / 10 + zeroBase);
1:         dateChars[6] = (char) (month % 10 + zeroBase);
1:         dateChars[7] = '-';
1:         dateChars[8] = (char) (day / 10 + zeroBase);
1:         dateChars[9] = (char) (day % 10 + zeroBase);
0:         byte[] dateBytes = (new String(dateChars)).getBytes();
1:         System.arraycopy(dateBytes, 0, buffer, offset, DateTime.dateRepresentationLength);
1:         return DateTime.dateRepresentationLength;
1:     /**
0:      * The returned character representation is in JDBC time escape format: <code>hh:mm:ss</code>, which is the same as
0:      * JIS time format in DERBY string representation of a time.
1:      */
1:     public static final int timeToTimeBytes(byte[] buffer,
1:                                             int offset,
0:                                             java.sql.Time time) {
1:         int hour = time.getHours();
1:         int minute = time.getMinutes();
1:         int second = time.getSeconds();
1:         char[] timeChars = new char[DateTime.timeRepresentationLength];
1:         int zeroBase = (int) '0';
1:         timeChars[0] = (char) (hour / 10 + zeroBase);
1:         timeChars[1] = (char) (hour % 10 + +zeroBase);
1:         timeChars[2] = ':';
1:         timeChars[3] = (char) (minute / 10 + zeroBase);
1:         timeChars[4] = (char) (minute % 10 + zeroBase);
1:         timeChars[5] = ':';
1:         timeChars[6] = (char) (second / 10 + zeroBase);
1:         timeChars[7] = (char) (second % 10 + zeroBase);
0:         byte[] timeBytes = (new String(timeChars)).getBytes();
1:         System.arraycopy(timeBytes, 0, buffer, offset, DateTime.timeRepresentationLength);
1:         return DateTime.timeRepresentationLength;
1:     /**
0:      * The returned character representation is in DERBY string representation of a timestamp:
0:      * <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
1:      */
1:     public static final int timestampToTimestampBytes(byte[] buffer,
1:                                                       int offset,
0:                                                       java.sql.Timestamp timestamp) throws ConversionException {
0:         int year = timestamp.getYear() + 1900;
1:         if (year > 9999) {
0:             throw new ConversionException("Year exceeds the maximum \"9999\".");
1:         }
1:         int month = timestamp.getMonth() + 1;
0:         int day = timestamp.getDate();
1:         int hour = timestamp.getHours();
1:         int minute = timestamp.getMinutes();
1:         int second = timestamp.getSeconds();
1:         int microsecond = timestamp.getNanos() / 1000;
0:         char[] timestampChars = new char[DateTime.timestampRepresentationLength];
1:         int zeroBase = (int) '0';
1:         timestampChars[0] = (char) (year / 1000 + zeroBase);
1:         timestampChars[1] = (char) ((year % 1000) / 100 + zeroBase);
1:         timestampChars[2] = (char) ((year % 100) / 10 + zeroBase);
1:         timestampChars[3] = (char) (year % 10 + +zeroBase);
1:         timestampChars[4] = '-';
1:         timestampChars[5] = (char) (month / 10 + zeroBase);
1:         timestampChars[6] = (char) (month % 10 + zeroBase);
1:         timestampChars[7] = '-';
1:         timestampChars[8] = (char) (day / 10 + zeroBase);
1:         timestampChars[9] = (char) (day % 10 + zeroBase);
1:         timestampChars[10] = '-';
1:         timestampChars[11] = (char) (hour / 10 + zeroBase);
1:         timestampChars[12] = (char) (hour % 10 + zeroBase);
1:         timestampChars[13] = '.';
1:         timestampChars[14] = (char) (minute / 10 + zeroBase);
1:         timestampChars[15] = (char) (minute % 10 + zeroBase);
1:         timestampChars[16] = '.';
1:         timestampChars[17] = (char) (second / 10 + zeroBase);
1:         timestampChars[18] = (char) (second % 10 + zeroBase);
1:         timestampChars[19] = '.';
1:         timestampChars[20] = (char) (microsecond / 100000 + zeroBase);
1:         timestampChars[21] = (char) ((microsecond % 100000) / 10000 + zeroBase);
1:         timestampChars[22] = (char) ((microsecond % 10000) / 1000 + zeroBase);
1:         timestampChars[23] = (char) ((microsecond % 1000) / 100 + zeroBase);
1:         timestampChars[24] = (char) ((microsecond % 100) / 10 + zeroBase);
1:         timestampChars[25] = (char) (microsecond % 10 + zeroBase);
0:         byte[] timestampBytes = (new String(timestampChars)).getBytes();
0:         System.arraycopy(timestampBytes, 0, buffer, offset, DateTime.timestampRepresentationLength);
0:         return DateTime.timestampRepresentationLength;
1:     // *********************************************************
1:     // ******* CROSS output converters (byte[] -> class) *******
1:     // *********************************************************
1:     /**
0:      * Expected character representation is DERBY string representation of a date, which is in one of the following
0:      * format.
1:      */
0:     public static final java.sql.Timestamp dateBytesToTimestamp(byte[] buffer,
1:                                                                 int offset,
0:                                                                 java.sql.Timestamp recyclableTimestamp) {
1:         int year, month, day;
0:         String date = new String(buffer, offset, DateTime.dateRepresentationLength);
1:         int yearIndx, monthIndx, dayIndx;
1:         yearIndx = 0;
1:         monthIndx = 5;
1:         dayIndx = 8;
1: 
1:         int zeroBase = ((int) '0');
1:         // Character arithmetic is used rather than
1:         // the less efficient Integer.parseInt (date.substring()).
1:         year =
1:                 1000 * (((int) date.charAt(yearIndx)) - zeroBase) +
1:                 100 * (((int) date.charAt(yearIndx + 1)) - zeroBase) +
1:                 10 * (((int) date.charAt(yearIndx + 2)) - zeroBase) +
0:                 (((int) date.charAt(yearIndx + 3)) - zeroBase) -
0:                 1900;
1:         month =
1:                 10 * (((int) date.charAt(monthIndx)) - zeroBase) +
1:                 (((int) date.charAt(monthIndx + 1)) - zeroBase) -
1:                 1;
1:         day =
1:                 10 * (((int) date.charAt(dayIndx)) - zeroBase) +
1:                 (((int) date.charAt(dayIndx + 1)) - zeroBase);
1: 
0:         if (recyclableTimestamp == null) {
0:             return new java.sql.Timestamp(year, month, day, 0, 0, 0, 0);
1:         } else {
0:             recyclableTimestamp.setYear(year);
0:             recyclableTimestamp.setMonth(month);
0:             recyclableTimestamp.setDate(day);
0:             recyclableTimestamp.setHours(0);
0:             recyclableTimestamp.setMinutes(0);
0:             recyclableTimestamp.setSeconds(0);
0:             recyclableTimestamp.setNanos(0);
0:             return recyclableTimestamp;
1:         }
1:     /**
0:      * Expected character representation is DERBY string representation of a time, which is in one of the following
0:      * format.
1:      */
0:     public static final java.sql.Timestamp timeBytesToTimestamp(byte[] buffer,
1:                                                                 int offset,
0:                                                                 java.sql.Timestamp recyclableTimestamp) {
1:         int hour, minute, second;
0:         String time = new String(buffer, offset, DateTime.timeRepresentationLength);
1:         int zeroBase = ((int) '0');
1:         // compute hour.
1:         hour =
1:                 10 * (((int) time.charAt(0)) - zeroBase) +
1:                 (((int) time.charAt(1)) - zeroBase);
1:         // compute minute.
1:         minute =
1:                 10 * (((int) time.charAt(3)) - zeroBase) +
1:                 (((int) time.charAt(4)) - zeroBase);
1:         // compute second   JIS format: hh:mm:ss.
1:         second =
1:                 10 * (((int) time.charAt(6)) - zeroBase) +
1:                 (((int) time.charAt(7)) - zeroBase);
0:         if (recyclableTimestamp == null) {
0:             return new java.sql.Timestamp(0, 0, 1, hour, minute, second, 0);
1:         } else {
0:             recyclableTimestamp.setYear(0);
0:             recyclableTimestamp.setMonth(0);
0:             recyclableTimestamp.setDate(1);
0:             recyclableTimestamp.setHours(hour);
0:             recyclableTimestamp.setMinutes(minute);
0:             recyclableTimestamp.setSeconds(second);
0:             recyclableTimestamp.setNanos(0);
0:             return recyclableTimestamp;
1:         }
1:     }
1:     /**
0:      * Expected character representation is DERBY string representation of a timestamp:
0:      * <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
1:      */
0:     public static final java.sql.Date timestampBytesToDate(byte[] buffer,
1:                                                            int offset,
0:                                                            java.sql.Date recyclableDate) {
1:         int year, month, day;
0:         String timestamp = new String(buffer, offset, DateTime.timestampRepresentationLength);
1:         int zeroBase = ((int) '0');
1:         year =
1:                 1000 * (((int) timestamp.charAt(0)) - zeroBase) +
1:                 100 * (((int) timestamp.charAt(1)) - zeroBase) +
1:                 10 * (((int) timestamp.charAt(2)) - zeroBase) +
0:                 (((int) timestamp.charAt(3)) - zeroBase) -
0:                 1900;
1:         month =
1:                 10 * (((int) timestamp.charAt(5)) - zeroBase) +
1:                 (((int) timestamp.charAt(6)) - zeroBase) -
1:                 1;
1:         day =
1:                 10 * (((int) timestamp.charAt(8)) - zeroBase) +
1:                 (((int) timestamp.charAt(9)) - zeroBase);
0:         if (recyclableDate == null) {
0:             return new java.sql.Date(year, month, day);
1:         } else {
0:             recyclableDate.setYear(year);
0:             recyclableDate.setMonth(month);
0:             recyclableDate.setDate(day);
0:             return recyclableDate;
1:         }
1:     }
1:     /**
0:      * Expected character representation is DERBY string representation of a timestamp:
0:      * <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
1:      */
0:     public static final java.sql.Time timestampBytesToTime(byte[] buffer,
1:                                                            int offset,
0:                                                            java.sql.Time recyclableTime) {
1:         int hour, minute, second;
0:         String timestamp = new String(buffer, offset, DateTime.timestampRepresentationLength);
1:         int zeroBase = ((int) '0');
1:         hour =
1:                 10 * (((int) timestamp.charAt(11)) - zeroBase) +
0:                 (((int) timestamp.charAt(12)) - zeroBase);
1:         minute =
1:                 10 * (((int) timestamp.charAt(14)) - zeroBase) +
0:                 (((int) timestamp.charAt(15)) - zeroBase);
1:         second =
1:                 10 * (((int) timestamp.charAt(17)) - zeroBase) +
0:                 (((int) timestamp.charAt(18)) - zeroBase);
0:         if (recyclableTime == null) {
0:             return new java.sql.Time(hour, minute, second);
1:         } else {
0:             recyclableTime.setYear(hour);
0:             recyclableTime.setMonth(minute);
0:             recyclableTime.setDate(second);
0:             return recyclableTime;
1:         }
1:     }
1:     // *********************************************************
1:     // ******* CROSS input converters (class -> byte[]) ********
1:     // *********************************************************
1:     /**
0:      * The returned character representation is in JDBC date escape format: <code>yyyy-mm-dd</code>, which is the same
0:      * as JIS date format in DERBY string representation of a date.
1:      */
0:     public static final int timestampToDateBytes(byte[] buffer,
1:                                                  int offset,
0:                                                  java.sql.Timestamp timestamp) throws ConversionException {
0:         int year = timestamp.getYear() + 1900;
1:         if (year > 9999) {
0:             throw new ConversionException("Year exceeds the maximum \"9999\".");
1:         }
1:         int month = timestamp.getMonth() + 1;
0:         int day = timestamp.getDate();
1:         char[] dateChars = new char[DateTime.dateRepresentationLength];
1:         int zeroBase = (int) '0';
1:         dateChars[0] = (char) (year / 1000 + zeroBase);
1:         dateChars[1] = (char) ((year % 1000) / 100 + zeroBase);
1:         dateChars[2] = (char) ((year % 100) / 10 + zeroBase);
1:         dateChars[3] = (char) (year % 10 + +zeroBase);
1:         dateChars[4] = '-';
1:         dateChars[5] = (char) (month / 10 + zeroBase);
1:         dateChars[6] = (char) (month % 10 + zeroBase);
1:         dateChars[7] = '-';
1:         dateChars[8] = (char) (day / 10 + zeroBase);
1:         dateChars[9] = (char) (day % 10 + zeroBase);
0:         byte[] dateBytes = (new String(dateChars)).getBytes();
1:         System.arraycopy(dateBytes, 0, buffer, offset, DateTime.dateRepresentationLength);
1: 
1:         return DateTime.dateRepresentationLength;
1:     }
1: 
1:     /**
0:      * The returned character representation is in JDBC time escape format: <code>hh:mm:ss</code>, which is the same as
0:      * JIS time format in DERBY string representation of a time.
1:      */
0:     public static final int timestampToTimeBytes(byte[] buffer,
1:                                                  int offset,
0:                                                  java.sql.Timestamp timestamp) {
1:         int hour = timestamp.getHours();
1:         int minute = timestamp.getMinutes();
1:         int second = timestamp.getSeconds();
1: 
1:         char[] timeChars = new char[DateTime.timeRepresentationLength];
1:         int zeroBase = (int) '0';
1:         timeChars[0] = (char) (hour / 10 + zeroBase);
1:         timeChars[1] = (char) (hour % 10 + +zeroBase);
1:         timeChars[2] = ':';
1:         timeChars[3] = (char) (minute / 10 + zeroBase);
1:         timeChars[4] = (char) (minute % 10 + zeroBase);
1:         timeChars[5] = ':';
1:         timeChars[6] = (char) (second / 10 + zeroBase);
1:         timeChars[7] = (char) (second % 10 + zeroBase);
0:         byte[] timeBytes = (new String(timeChars)).getBytes();
1:         System.arraycopy(timeBytes, 0, buffer, offset, DateTime.timeRepresentationLength);
1: 
1:         return DateTime.timeRepresentationLength;
1:     }
1: 
1:     /**
0:      * The returned character representation is in DERBY string representation of a timestamp:
0:      * <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
1:      */
0:     public static final int dateToTimestampBytes(byte[] buffer,
1:                                                  int offset,
0:                                                  java.sql.Date date) throws ConversionException {
0:         int year = date.getYear() + 1900;
1:         if (year > 9999) {
0:             throw new ConversionException("Year exceeds the maximum \"9999\".");
1:         }
1:         int month = date.getMonth() + 1;
0:         int day = date.getDate();
1: 
0:         char[] timestampChars = new char[DateTime.timestampRepresentationLength];
1:         int zeroBase = (int) '0';
1:         timestampChars[0] = (char) (year / 1000 + zeroBase);
1:         timestampChars[1] = (char) ((year % 1000) / 100 + zeroBase);
1:         timestampChars[2] = (char) ((year % 100) / 10 + zeroBase);
1:         timestampChars[3] = (char) (year % 10 + +zeroBase);
1:         timestampChars[4] = '-';
1:         timestampChars[5] = (char) (month / 10 + zeroBase);
1:         timestampChars[6] = (char) (month % 10 + zeroBase);
1:         timestampChars[7] = '-';
1:         timestampChars[8] = (char) (day / 10 + zeroBase);
1:         timestampChars[9] = (char) (day % 10 + zeroBase);
1:         timestampChars[10] = '-';
0:         timestampChars[11] = '0';
0:         timestampChars[12] = '0';
1:         timestampChars[13] = '.';
0:         timestampChars[14] = '0';
0:         timestampChars[15] = '0';
1:         timestampChars[16] = '.';
0:         timestampChars[17] = '0';
0:         timestampChars[18] = '0';
1:         timestampChars[19] = '.';
0:         timestampChars[20] = '0';
0:         timestampChars[21] = '0';
0:         timestampChars[22] = '0';
0:         timestampChars[23] = '0';
0:         timestampChars[24] = '0';
0:         timestampChars[25] = '0';
1: 
0:         byte[] timestampBytes = (new String(timestampChars)).getBytes();
0:         System.arraycopy(timestampBytes, 0, buffer, offset, DateTime.timestampRepresentationLength);
1: 
0:         return DateTime.timestampRepresentationLength;
1:     }
1: 
1:     /**
0:      * The returned character representation is in DERBY string representation of a timestamp:
0:      * <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
1:      */
0:     public static final int timeToTimestampBytes(byte[] buffer,
1:                                                  int offset,
0:                                                  java.sql.Time time) {
1:         int hour = time.getHours();
1:         int minute = time.getMinutes();
1:         int second = time.getSeconds();
1: 
0:         char[] timestampChars = new char[DateTime.timestampRepresentationLength];
1:         int zeroBase = (int) '0';
0:         timestampChars[0] = '1';
0:         timestampChars[1] = '9';
0:         timestampChars[2] = '0';
0:         timestampChars[3] = '0';
1:         timestampChars[4] = '-';
0:         timestampChars[5] = '0';
0:         timestampChars[6] = '1';
1:         timestampChars[7] = '-';
0:         timestampChars[8] = '0';
0:         timestampChars[9] = '1';
1:         timestampChars[10] = '-';
1:         timestampChars[11] = (char) (hour / 10 + zeroBase);
1:         timestampChars[12] = (char) (hour % 10 + zeroBase);
1:         timestampChars[13] = '.';
1:         timestampChars[14] = (char) (minute / 10 + zeroBase);
1:         timestampChars[15] = (char) (minute % 10 + zeroBase);
1:         timestampChars[16] = '.';
1:         timestampChars[17] = (char) (second / 10 + zeroBase);
1:         timestampChars[18] = (char) (second % 10 + zeroBase);
1:         timestampChars[19] = '.';
0:         timestampChars[20] = '0';
0:         timestampChars[21] = '0';
0:         timestampChars[22] = '0';
0:         timestampChars[23] = '0';
0:         timestampChars[24] = '0';
0:         timestampChars[25] = '0';
1: 
0:         byte[] timestampBytes = (new String(timestampChars)).getBytes();
0:         System.arraycopy(timestampBytes, 0, buffer, offset, DateTime.timestampRepresentationLength);
1: 
0:         return DateTime.timestampRepresentationLength;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.DateTime
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0: */
1: package org.apache.derby.client.am;
1: 
1: 
0: /**
1:  * High performance converters from date/time byte encodings to JDBC Date, Time and Timestamp objects.
0:  * <p>
0:  * Using this class for direct date/time conversions from bytes offers
0:  * superior performance over the alternative method of first constructing
0:  * a Java String from the encoded bytes, and then using
0:  * {@link java.sql.Date#valueOf java.sql.Date.valueOf()},
0:  * {@link java.sql.Time#valueOf java.sql.Time.valueOf()} or
0:  * {@link java.sql.Timestamp#valueOf java.sql.Timestamp.valueOf()}.
0:  * <p>
0:  */
0: public class DateTime
0: {
1: 
0:   // Hide the default constructor
0:   private DateTime () {}
1: 
0:   private static final int dateRepresentationLength = 10;
0:   private static final int timeRepresentationLength = 8;
0:   private static final int timestampRepresentationLength = 26;
1: 
0:   // *********************************************************
0:   // ********** Output converters (byte[] -> class) **********
0:   // *********************************************************
1: 
0:   /**
0:    * Expected character representation is DERBY string representation
0:    * of a date, which is in one of the following format.
0:    */
0:   public static final java.sql.Date dateBytesToDate (byte[] buffer,
0:                                                int offset,
0:                                                java.sql.Date recyclableDate)
0:   {
0:     int year, month, day;
1: 
0:     String date = new String (buffer, offset, DateTime.dateRepresentationLength);
0:     int yearIndx, monthIndx, dayIndx;
0:     if (date.charAt (4) == '-') {
0:       // JIS format: yyyy-mm-dd.
0:       yearIndx = 0;
0:       monthIndx = 5;
0:       dayIndx = 8;
0:     }
0:     else throw new java.lang.IllegalArgumentException ("Unsupported date format!");
1: 
0:     int zeroBase = ((int) '0');
0:     // Character arithmetic is used rather than
0:     // the less efficient Integer.parseInt (date.substring()).
0:     year =
0:       1000*(((int) date.charAt (yearIndx)) - zeroBase) +
0:       100*(((int) date.charAt (yearIndx+1)) - zeroBase) +
0:       10*(((int) date.charAt (yearIndx+2)) - zeroBase) +
0:       (((int) date.charAt (yearIndx+3)) - zeroBase) -
0:       1900;
0:     month =
0:       10*(((int) date.charAt (monthIndx)) - zeroBase) +
0:       (((int) date.charAt (monthIndx+1)) - zeroBase) -
0:       1;
0:     day =
0:       10*(((int) date.charAt (dayIndx)) - zeroBase) +
0:       (((int) date.charAt (dayIndx+1)) - zeroBase);
1: 
0:     if (recyclableDate == null)
0:       return new java.sql.Date (year, month, day);
0:     else {
0:       recyclableDate.setYear (year);
0:       recyclableDate.setMonth (month);
0:       recyclableDate.setDate (day);
0:       return recyclableDate;
0:     }
0:   }
1: 
0:   /**
0:    * Expected character representation is DERBY string representation
0:    * of a time, which is in one of the following format: hh.mm.ss.
0:    */
0:   public static final java.sql.Time timeBytesToTime (byte[] buffer,
0:                                                int offset,
0:                                                java.sql.Time recyclableTime)
0:   {
0:     int hour, minute, second;
1: 
0:     String time = new String (buffer, offset, DateTime.timeRepresentationLength);
0:     int zeroBase = ((int) '0');
1: 
0:     // compute hour.
0:     hour =
0:       10*(((int) time.charAt (0)) - zeroBase) +
0:       (((int) time.charAt (1)) - zeroBase);
0:     // compute minute.
0:     minute =
0:       10*(((int) time.charAt (3)) - zeroBase) +
0:       (((int) time.charAt (4)) - zeroBase);
0:     // compute second.
0:     second =
0:         10*(((int) time.charAt (6)) - zeroBase) +
0:         (((int) time.charAt (7)) - zeroBase);
1: 
0:     if (recyclableTime == null)
0:       return new java.sql.Time (hour, minute, second);
0:     else {
0:       recyclableTime.setHours (hour);
0:       recyclableTime.setMinutes (minute);
0:       recyclableTime.setSeconds (second);
0:       return recyclableTime;
0:     }
0:   }
1: 
0:   /**
0:    * Expected character representation is DERBY string representation
0:    * of a timestamp: <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
0:    *
0:    */
0:   public static final java.sql.Timestamp timestampBytesToTimestamp (byte[] buffer,
0:                                                               int offset,
0:                                                               java.sql.Timestamp recyclableTimestamp)
0:   {
0:     int year, month, day, hour, minute, second, fraction;
1: 
0:     String timestamp = new String (buffer, offset, DateTime.timestampRepresentationLength);
0:     int zeroBase = ((int) '0');
1: 
0:     year =
0:       1000*(((int) timestamp.charAt (0)) - zeroBase) +
0:       100*(((int) timestamp.charAt (1)) - zeroBase) +
0:       10*(((int) timestamp.charAt (2)) - zeroBase) +
0:       (((int) timestamp.charAt (3)) - zeroBase) -
0:       1900;
0:     month =
0:       10*(((int) timestamp.charAt (5)) - zeroBase) +
0:       (((int) timestamp.charAt (6)) - zeroBase) -
0:       1;
0:     day =
0:       10*(((int) timestamp.charAt (8)) - zeroBase) +
0:       (((int) timestamp.charAt (9)) - zeroBase);
0:     hour =
0:       10*(((int) timestamp.charAt (11)) - zeroBase) +
0:       (((int) timestamp.charAt (12)) - zeroBase);
0:     minute =
0:       10*(((int) timestamp.charAt (14)) - zeroBase) +
0:       (((int) timestamp.charAt (15)) - zeroBase);
0:     second =
0:       10*(((int) timestamp.charAt (17)) - zeroBase) +
0:       (((int) timestamp.charAt (18)) - zeroBase);
0:     fraction =
0:       100000*(((int) timestamp.charAt (20)) - zeroBase) +
0:       10000*(((int) timestamp.charAt (21)) - zeroBase) +
0:       1000*(((int) timestamp.charAt (22)) - zeroBase) +
0:       100*(((int) timestamp.charAt (23)) - zeroBase) +
0:       10*(((int) timestamp.charAt (24)) - zeroBase) +
0:       (((int) timestamp.charAt (25)) - zeroBase);
1: 
0:     if (recyclableTimestamp == null)
0:       return new java.sql.Timestamp (year, month, day, hour, minute, second, fraction*1000);
0:     else {
0:       recyclableTimestamp.setYear (year);
0:       recyclableTimestamp.setMonth (month);
0:       recyclableTimestamp.setDate (day);
0:       recyclableTimestamp.setHours (hour);
0:       recyclableTimestamp.setMinutes (minute);
0:       recyclableTimestamp.setSeconds (second);
0:       recyclableTimestamp.setNanos (fraction*1000);
0:       return recyclableTimestamp;
0:     }
0:   }
1: 
0:   // ********************************************************
0:   // ********** Input converters (class -> byte[]) **********
0:   // ********************************************************
1: 
0:   /**
0:    * The returned character representation is in JDBC date format:
0:    * <code>yyyy-mm-dd</code> date format in
0:    * DERBY string representation of a date.
0:    *
0:    */
0:   public static final int dateToDateBytes (byte[] buffer,
0:                                      int offset,
0:                                      java.sql.Date date
0:                                      ) throws ConversionException
0:   {
0:     int year = date.getYear () + 1900;
0:     if (year > 9999) throw new ConversionException ("Year exceeds the maximum \"9999\".");
0:     int month = date.getMonth () + 1;
0:     int day = date.getDate ();
1: 
0:     char[] dateChars = new char[DateTime.dateRepresentationLength];
0:     int zeroBase = (int) '0';
0:     dateChars[0] = (char) (year/1000 + zeroBase);
0:     dateChars[1] = (char) ((year%1000)/100 + zeroBase);
0:     dateChars[2] = (char) ((year%100)/10 + zeroBase);
0:     dateChars[3] = (char) (year%10 + + zeroBase);
0:     dateChars[4] = '-';
0:     dateChars[5] = (char) (month/10 + zeroBase);
0:     dateChars[6] = (char) (month%10 + zeroBase);
0:     dateChars[7] = '-';
0:     dateChars[8] = (char) (day/10 + zeroBase);
0:     dateChars[9] = (char) (day%10 + zeroBase);
0:     byte[] dateBytes = (new String(dateChars)).getBytes ();
0:     System.arraycopy(dateBytes, 0, buffer, offset, DateTime.dateRepresentationLength);
1: 
0:     return DateTime.dateRepresentationLength;
0:   }
1: 
0:   /**
0:    * The returned character representation is in JDBC time escape format:
0:    * <code>hh:mm:ss</code>, which is the same as JIS time format in
0:    * DERBY string representation of a time.
0:    *
0:    */
0:   public static final int timeToTimeBytes (byte[] buffer,
0:                                      int offset,
0:                                      java.sql.Time time)
0:   {
0:     int hour = time.getHours();
0:     int minute = time.getMinutes();
0:     int second = time.getSeconds();
1: 
0:     char[] timeChars = new char[DateTime.timeRepresentationLength];
0:     int zeroBase = (int) '0';
0:     timeChars[0] = (char) (hour/10 + zeroBase);
0:     timeChars[1] = (char) (hour%10 + + zeroBase);
0:     timeChars[2] = ':';
0:     timeChars[3] = (char) (minute/10 + zeroBase);
0:     timeChars[4] = (char) (minute%10 + zeroBase);
0:     timeChars[5] = ':';
0:     timeChars[6] = (char) (second/10 + zeroBase);
0:     timeChars[7] = (char) (second%10 + zeroBase);
0:     byte[] timeBytes = (new String(timeChars)).getBytes ();
0:     System.arraycopy(timeBytes, 0, buffer, offset, DateTime.timeRepresentationLength);
1: 
0:     return DateTime.timeRepresentationLength;
0:   }
1: 
0:   /**
0:    * The returned character representation is in DERBY string representation of
0:    * a timestamp: <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
0:    */
0:   public static final int timestampToTimestampBytes (byte[] buffer,
0:                                                int offset,
0:                                                java.sql.Timestamp timestamp
0:                                                ) throws ConversionException
0:   {
0:     int year = timestamp.getYear () + 1900;
0:     if (year > 9999) throw new ConversionException ("Year exceeds the maximum \"9999\".");
0:     int month = timestamp.getMonth () + 1;
0:     int day = timestamp.getDate ();
0:     int hour = timestamp.getHours();
0:     int minute = timestamp.getMinutes();
0:     int second = timestamp.getSeconds();
0:     int microsecond = timestamp.getNanos()/1000;
1: 
0:     char[] timestampChars = new char[DateTime.timestampRepresentationLength];
0:     int zeroBase = (int) '0';
0:     timestampChars[0]  = (char) (year/1000 + zeroBase);
0:     timestampChars[1]  = (char) ((year%1000)/100 + zeroBase);
0:     timestampChars[2]  = (char) ((year%100)/10 + zeroBase);
0:     timestampChars[3]  = (char) (year%10 + + zeroBase);
0:     timestampChars[4]  = '-';
0:     timestampChars[5]  = (char) (month/10 + zeroBase);
0:     timestampChars[6]  = (char) (month%10 + zeroBase);
0:     timestampChars[7]  = '-';
0:     timestampChars[8]  = (char) (day/10 + zeroBase);
0:     timestampChars[9]  = (char) (day%10 + zeroBase);
0:     timestampChars[10] = '-';
0:     timestampChars[11] = (char) (hour/10 + zeroBase);
0:     timestampChars[12] = (char) (hour%10 + zeroBase);
0:     timestampChars[13] = '.';
0:     timestampChars[14] = (char) (minute/10 + zeroBase);
0:     timestampChars[15] = (char) (minute%10 + zeroBase);
0:     timestampChars[16] = '.';
0:     timestampChars[17] = (char) (second/10 + zeroBase);
0:     timestampChars[18] = (char) (second%10 + zeroBase);
0:     timestampChars[19] = '.';
0:     timestampChars[20] = (char) (microsecond/100000 + zeroBase);
0:     timestampChars[21] = (char) ((microsecond%100000)/10000 + zeroBase);
0:     timestampChars[22] = (char) ((microsecond%10000)/1000 + zeroBase);
0:     timestampChars[23] = (char) ((microsecond%1000)/100 + zeroBase);
0:     timestampChars[24] = (char) ((microsecond%100)/10 + zeroBase);
0:     timestampChars[25] = (char) (microsecond%10 + zeroBase);
1: 
0:     byte[] timestampBytes = (new String(timestampChars)).getBytes ();
0:     System.arraycopy(timestampBytes, 0, buffer, offset, DateTime.timestampRepresentationLength);
1: 
0:     return DateTime.timestampRepresentationLength;
0:   }
1: 
0:   // *********************************************************
0:   // ******* CROSS output converters (byte[] -> class) *******
0:   // *********************************************************
1: 
0:   /**
0:    * Expected character representation is DERBY string representation
0:    * of a date, which is in one of the following format.
0:    */
0:   public static final java.sql.Timestamp dateBytesToTimestamp (byte[] buffer,
0:                                                          int offset,
0:                                                          java.sql.Timestamp recyclableTimestamp)
0:   {
0:     int year, month, day;
1: 
0:     String date = new String (buffer, offset, DateTime.dateRepresentationLength);
0:     int yearIndx, monthIndx, dayIndx;
1: 
0:     yearIndx = 0;
0:     monthIndx = 5;
0:     dayIndx = 8;
1: 
0:     int zeroBase = ((int) '0');
0:     // Character arithmetic is used rather than
0:     // the less efficient Integer.parseInt (date.substring()).
0:     year =
0:       1000*(((int) date.charAt (yearIndx)) - zeroBase) +
0:       100*(((int) date.charAt (yearIndx+1)) - zeroBase) +
0:       10*(((int) date.charAt (yearIndx+2)) - zeroBase) +
0:       (((int) date.charAt (yearIndx+3)) - zeroBase) -
0:       1900;
0:     month =
0:       10*(((int) date.charAt (monthIndx)) - zeroBase) +
0:       (((int) date.charAt (monthIndx+1)) - zeroBase) -
0:       1;
0:     day =
0:       10*(((int) date.charAt (dayIndx)) - zeroBase) +
0:       (((int) date.charAt (dayIndx+1)) - zeroBase);
1: 
0:     if (recyclableTimestamp == null)
0:       return new java.sql.Timestamp (year, month, day, 0, 0, 0, 0);
0:     else {
0:       recyclableTimestamp.setYear (year);
0:       recyclableTimestamp.setMonth (month);
0:       recyclableTimestamp.setDate (day);
0:       recyclableTimestamp.setHours (0);
0:       recyclableTimestamp.setMinutes (0);
0:       recyclableTimestamp.setSeconds (0);
0:       recyclableTimestamp.setNanos (0);
0:       return recyclableTimestamp;
0:     }
0:   }
1: 
0:   /**
0:    * Expected character representation is DERBY string representation
0:    * of a time, which is in one of the following format.
0:    */
0:   public static final java.sql.Timestamp timeBytesToTimestamp (byte[] buffer,
0:                                                          int offset,
0:                                                          java.sql.Timestamp recyclableTimestamp)
0:   {
0:     int hour, minute, second;
1: 
0:     String time = new String (buffer, offset, DateTime.timeRepresentationLength);
0:     int zeroBase = ((int) '0');
1: 
0:     // compute hour.
0:     hour =
0:       10*(((int) time.charAt (0)) - zeroBase) +
0:       (((int) time.charAt (1)) - zeroBase);
0:     // compute minute.
0:     minute =
0:       10*(((int) time.charAt (3)) - zeroBase) +
0:       (((int) time.charAt (4)) - zeroBase);
0:     // compute second   JIS format: hh:mm:ss.
0:     second =
0:         10*(((int) time.charAt (6)) - zeroBase) +
0:         (((int) time.charAt (7)) - zeroBase);
1: 
0:     if (recyclableTimestamp == null)
0:       return new java.sql.Timestamp (0, 0, 1, hour, minute, second, 0);
0:     else {
0:       recyclableTimestamp.setYear (0);
0:       recyclableTimestamp.setMonth (0);
0:       recyclableTimestamp.setDate (1);
0:       recyclableTimestamp.setHours (hour);
0:       recyclableTimestamp.setMinutes (minute);
0:       recyclableTimestamp.setSeconds (second);
0:       recyclableTimestamp.setNanos (0);
0:       return recyclableTimestamp;
0:     }
0:   }
1: 
0:   /**
0:    * Expected character representation is DERBY string representation
0:    * of a timestamp: <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
0:    */
0:   public static final java.sql.Date timestampBytesToDate (byte[] buffer,
0:                                                     int offset,
0:                                                     java.sql.Date recyclableDate)
0:   {
0:     int year, month, day;
1: 
0:     String timestamp = new String (buffer, offset, DateTime.timestampRepresentationLength);
0:     int zeroBase = ((int) '0');
1: 
0:     year =
0:       1000*(((int) timestamp.charAt (0)) - zeroBase) +
0:       100*(((int) timestamp.charAt (1)) - zeroBase) +
0:       10*(((int) timestamp.charAt (2)) - zeroBase) +
0:       (((int) timestamp.charAt (3)) - zeroBase) -
0:       1900;
0:     month =
0:       10*(((int) timestamp.charAt (5)) - zeroBase) +
0:       (((int) timestamp.charAt (6)) - zeroBase) -
0:       1;
0:     day =
0:       10*(((int) timestamp.charAt (8)) - zeroBase) +
0:       (((int) timestamp.charAt (9)) - zeroBase);
1: 
0:     if (recyclableDate == null)
0:       return new java.sql.Date (year, month, day);
0:     else {
0:       recyclableDate.setYear (year);
0:       recyclableDate.setMonth (month);
0:       recyclableDate.setDate (day);
0:       return recyclableDate;
0:     }
0:   }
1: 
0:   /**
0:    * Expected character representation is DERBY string representation
0:    * of a timestamp: <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
0:    */
0:   public static final java.sql.Time timestampBytesToTime (byte[] buffer,
0:                                                     int offset,
0:                                                     java.sql.Time recyclableTime)
0:   {
0:     int hour, minute, second;
1: 
0:     String timestamp = new String (buffer, offset, DateTime.timestampRepresentationLength);
0:     int zeroBase = ((int) '0');
1: 
0:     hour =
0:       10*(((int) timestamp.charAt (11)) - zeroBase) +
0:       (((int) timestamp.charAt (12)) - zeroBase);
0:     minute =
0:       10*(((int) timestamp.charAt (14)) - zeroBase) +
0:       (((int) timestamp.charAt (15)) - zeroBase);
0:     second =
0:       10*(((int) timestamp.charAt (17)) - zeroBase) +
0:       (((int) timestamp.charAt (18)) - zeroBase);
1: 
0:     if (recyclableTime == null)
0:       return new java.sql.Time (hour, minute, second);
0:     else {
0:       recyclableTime.setYear (hour);
0:       recyclableTime.setMonth (minute);
0:       recyclableTime.setDate (second);
0:       return recyclableTime;
0:     }
0:   }
1: 
0:   // *********************************************************
0:   // ******* CROSS input converters (class -> byte[]) ********
0:   // *********************************************************
1: 
0:   /**
0:    * The returned character representation is in JDBC date escape format:
0:    * <code>yyyy-mm-dd</code>, which is the same as JIS date format in
0:    * DERBY string representation of a date.
0:    *
0:    */
0:   public static final int timestampToDateBytes (byte[] buffer,
0:                                           int offset,
0:                                           java.sql.Timestamp timestamp
0:                                           ) throws ConversionException
0:   {
0:     int year = timestamp.getYear () + 1900;
0:     if (year > 9999) throw new ConversionException ("Year exceeds the maximum \"9999\".");
0:     int month = timestamp.getMonth () + 1;
0:     int day = timestamp.getDate ();
1: 
0:     char[] dateChars = new char[DateTime.dateRepresentationLength];
0:     int zeroBase = (int) '0';
0:     dateChars[0] = (char) (year/1000 + zeroBase);
0:     dateChars[1] = (char) ((year%1000)/100 + zeroBase);
0:     dateChars[2] = (char) ((year%100)/10 + zeroBase);
0:     dateChars[3] = (char) (year%10 + + zeroBase);
0:     dateChars[4] = '-';
0:     dateChars[5] = (char) (month/10 + zeroBase);
0:     dateChars[6] = (char) (month%10 + zeroBase);
0:     dateChars[7] = '-';
0:     dateChars[8] = (char) (day/10 + zeroBase);
0:     dateChars[9] = (char) (day%10 + zeroBase);
0:     byte[] dateBytes = (new String(dateChars)).getBytes ();
0:     System.arraycopy(dateBytes, 0, buffer, offset, DateTime.dateRepresentationLength);
1: 
0:     return DateTime.dateRepresentationLength;
0:   }
1: 
0:   /**
0:    * The returned character representation is in JDBC time escape format:
0:    * <code>hh:mm:ss</code>, which is the same as JIS time format in
0:    * DERBY string representation of a time.
0:    *
0:    */
0:   public static final int timestampToTimeBytes (byte[] buffer,
0:                                           int offset,
0:                                           java.sql.Timestamp timestamp)
0:   {
0:     int hour = timestamp.getHours();
0:     int minute = timestamp.getMinutes();
0:     int second = timestamp.getSeconds();
1: 
0:     char[] timeChars = new char[DateTime.timeRepresentationLength];
0:     int zeroBase = (int) '0';
0:     timeChars[0] = (char) (hour/10 + zeroBase);
0:     timeChars[1] = (char) (hour%10 + + zeroBase);
0:     timeChars[2] = ':';
0:     timeChars[3] = (char) (minute/10 + zeroBase);
0:     timeChars[4] = (char) (minute%10 + zeroBase);
0:     timeChars[5] = ':';
0:     timeChars[6] = (char) (second/10 + zeroBase);
0:     timeChars[7] = (char) (second%10 + zeroBase);
0:     byte[] timeBytes = (new String(timeChars)).getBytes ();
0:     System.arraycopy(timeBytes, 0, buffer, offset, DateTime.timeRepresentationLength);
1: 
0:     return DateTime.timeRepresentationLength;
0:   }
1: 
0:   /**
0:    * The returned character representation is in DERBY string representation of
0:    * a timestamp: <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
0:    *
0:    */
0:   public static final int dateToTimestampBytes (byte[] buffer,
0:                                           int offset,
0:                                           java.sql.Date date
0:                                           ) throws ConversionException
0:   {
0:     int year = date.getYear () + 1900;
0:     if (year > 9999) throw new ConversionException ("Year exceeds the maximum \"9999\".");
0:     int month = date.getMonth () + 1;
0:     int day = date.getDate ();
1: 
0:     char[] timestampChars = new char[DateTime.timestampRepresentationLength];
0:     int zeroBase = (int) '0';
0:     timestampChars[0]  = (char) (year/1000 + zeroBase);
0:     timestampChars[1]  = (char) ((year%1000)/100 + zeroBase);
0:     timestampChars[2]  = (char) ((year%100)/10 + zeroBase);
0:     timestampChars[3]  = (char) (year%10 + + zeroBase);
0:     timestampChars[4]  = '-';
0:     timestampChars[5]  = (char) (month/10 + zeroBase);
0:     timestampChars[6]  = (char) (month%10 + zeroBase);
0:     timestampChars[7]  = '-';
0:     timestampChars[8]  = (char) (day/10 + zeroBase);
0:     timestampChars[9]  = (char) (day%10 + zeroBase);
0:     timestampChars[10] = '-';
0:     timestampChars[11] = '0';
0:     timestampChars[12] = '0';
0:     timestampChars[13] = '.';
0:     timestampChars[14] = '0';
0:     timestampChars[15] = '0';
0:     timestampChars[16] = '.';
0:     timestampChars[17] = '0';
0:     timestampChars[18] = '0';
0:     timestampChars[19] = '.';
0:     timestampChars[20] = '0';
0:     timestampChars[21] = '0';
0:     timestampChars[22] = '0';
0:     timestampChars[23] = '0';
0:     timestampChars[24] = '0';
0:     timestampChars[25] = '0';
1: 
0:     byte[] timestampBytes = (new String(timestampChars)).getBytes ();
0:     System.arraycopy(timestampBytes, 0, buffer, offset, DateTime.timestampRepresentationLength);
1: 
0:     return DateTime.timestampRepresentationLength;
0:   }
1: 
0:   /**
0:    * The returned character representation is in DERBY string representation of
0:    * a timestamp: <code>yyyy-mm-dd-hh.mm.ss.ffffff</code>.
0:    *
0:    */
0:   public static final int timeToTimestampBytes (byte[] buffer,
0:                                           int offset,
0:                                           java.sql.Time time
0:                                           )
0:   {
0:     int hour = time.getHours();
0:     int minute = time.getMinutes();
0:     int second = time.getSeconds();
1: 
0:     char[] timestampChars = new char[DateTime.timestampRepresentationLength];
0:     int zeroBase = (int) '0';
0:     timestampChars[0]  = '1';
0:     timestampChars[1]  = '9';
0:     timestampChars[2]  = '0';
0:     timestampChars[3]  = '0';
0:     timestampChars[4]  = '-';
0:     timestampChars[5]  = '0';
0:     timestampChars[6]  = '1';
0:     timestampChars[7]  = '-';
0:     timestampChars[8]  = '0';
0:     timestampChars[9]  = '1';
0:     timestampChars[10] = '-';
0:     timestampChars[11] = (char) (hour/10 + zeroBase);
0:     timestampChars[12] = (char) (hour%10 + zeroBase);
0:     timestampChars[13] = '.';
0:     timestampChars[14] = (char) (minute/10 + zeroBase);
0:     timestampChars[15] = (char) (minute%10 + zeroBase);
0:     timestampChars[16] = '.';
0:     timestampChars[17] = (char) (second/10 + zeroBase);
0:     timestampChars[18] = (char) (second%10 + zeroBase);
0:     timestampChars[19] = '.';
0:     timestampChars[20] = '0';
0:     timestampChars[21] = '0';
0:     timestampChars[22] = '0';
0:     timestampChars[23] = '0';
0:     timestampChars[24] = '0';
0:     timestampChars[25] = '0';
1: 
0:     byte[] timestampBytes = (new String(timestampChars)).getBytes ();
0:     System.arraycopy(timestampBytes, 0, buffer, offset, DateTime.timestampRepresentationLength);
1: 
0:     return DateTime.timestampRepresentationLength;
0:   }
0: }
1: 
============================================================================