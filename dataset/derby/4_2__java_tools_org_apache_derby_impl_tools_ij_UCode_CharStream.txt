1:fe77ca5: /*
1:985fc85: 
1:985fc85:    Derby - Class org.apache.derby.impl.tools.ij.UCode_CharStream
1:985fc85: 
1:11bc2d0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:11bc2d0:    contributor license agreements.  See the NOTICE file distributed with
1:11bc2d0:    this work for additional information regarding copyright ownership.
1:11bc2d0:    The ASF licenses this file to You under the Apache License, Version 2.0
1:11bc2d0:    (the "License"); you may not use this file except in compliance with
1:11bc2d0:    the License.  You may obtain a copy of the License at
1:985fc85: 
1:985fc85:       http://www.apache.org/licenses/LICENSE-2.0
1:985fc85: 
1:985fc85:    Unless required by applicable law or agreed to in writing, software
1:985fc85:    distributed under the License is distributed on an "AS IS" BASIS,
1:985fc85:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:985fc85:    See the License for the specific language governing permissions and
1:985fc85:    limitations under the License.
2:fe77ca5: 
2:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: /* Generated By:JavaCC: Do not edit this line. UCode_CharStream.java Version 0.7pre6 */
1:fe77ca5: package org.apache.derby.impl.tools.ij;
1:fe77ca5: 
2:fe77ca5: /**
1:fe77ca5:  * An implementation of interface CharStream, where the stream is assumed to
1:fe77ca5:  * contain only Unicode characters.
1:fe77ca5:  */
1:fe77ca5: 
1:fe77ca5: public final class UCode_CharStream implements CharStream
1:fe77ca5: {
1:fe77ca5:   public static final boolean staticFlag = false;
1:fe77ca5:   public int bufpos = -1;
1:fe77ca5:   int bufsize;
1:fe77ca5:   int available;
1:fe77ca5:   int tokenBegin;
1:fe77ca5:   private int bufline[];
1:fe77ca5:   private int bufcolumn[];
1:fe77ca5: 
1:fe77ca5:   private int column = 0;
1:fe77ca5:   private int line = 1;
1:fe77ca5: 
1:fe77ca5:   private boolean prevCharIsCR = false;
1:fe77ca5:   private boolean prevCharIsLF = false;
1:fe77ca5: 
1:fe77ca5:   private java.io.Reader inputStream;
1:fe77ca5: 
1:fe77ca5:   private char[] nextCharBuf;
1:fe77ca5:   private char[] buffer;
1:fe77ca5:   private int maxNextCharInd = 0;
1:fe77ca5:   private int nextCharInd = -1;
1:fe77ca5: 
1:fe77ca5:   private final void ExpandBuff(boolean wrapAround)
1:fe77ca5:   {
1:fe77ca5:      char[] newbuffer = new char[bufsize + 2048];
1:fe77ca5:      int newbufline[] = new int[bufsize + 2048];
1:fe77ca5:      int newbufcolumn[] = new int[bufsize + 2048];
1:fe77ca5: 
1:fe77ca5:      try
1:fe77ca5:      {
1:fe77ca5:         if (wrapAround)
1:fe77ca5:         {
1:fe77ca5:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
1:fe77ca5:            System.arraycopy(buffer, 0, newbuffer,
1:fe77ca5:                                              bufsize - tokenBegin, bufpos);
1:fe77ca5:            buffer = newbuffer;
1:fe77ca5: 
1:fe77ca5:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
1:fe77ca5:            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
1:fe77ca5:            bufline = newbufline;
1:fe77ca5: 
1:fe77ca5:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
1:fe77ca5:            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
1:fe77ca5:            bufcolumn = newbufcolumn;
1:fe77ca5: 
1:fe77ca5:            bufpos += (bufsize - tokenBegin);
1:fe77ca5:         }
1:fe77ca5:         else
1:fe77ca5:         {
1:fe77ca5:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
1:fe77ca5:            buffer = newbuffer;
1:fe77ca5: 
1:fe77ca5:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
1:fe77ca5:            bufline = newbufline;
1:fe77ca5: 
1:fe77ca5:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
1:fe77ca5:            bufcolumn = newbufcolumn;
1:fe77ca5: 
1:fe77ca5:            bufpos -= tokenBegin;
1:fe77ca5:         }
1:fe77ca5:      }
1:fe77ca5:      catch (Throwable t)
1:fe77ca5:      {
1:fe77ca5:         throw new Error(t.getMessage());
1:fe77ca5:      }
1:fe77ca5: 
1:fe77ca5:      available = (bufsize += 2048);
1:fe77ca5:      tokenBegin = 0;
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   private final void FillBuff() throws java.io.IOException
1:fe77ca5:   {
1:fe77ca5:      if (maxNextCharInd == 4096)
1:fe77ca5:         maxNextCharInd = nextCharInd = 0;
1:fe77ca5: 
1:fe77ca5:      int i;
1:fe77ca5:      try {
1:fe77ca5:         if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
1:fe77ca5:                                             4096 - maxNextCharInd)) == -1)
1:fe77ca5:         {
1:fe77ca5:            inputStream.close();
1:fe77ca5:            throw new java.io.IOException();
1:fe77ca5:         }
1:fe77ca5:         else
1:fe77ca5:            maxNextCharInd += i;
1:fe77ca5:         return;
1:fe77ca5:      }
1:fe77ca5:      catch(java.io.IOException e) {
1:fe77ca5:         if (bufpos != 0)
1:fe77ca5:         {
1:fe77ca5:            --bufpos;
1:fe77ca5:            backup(0);
1:fe77ca5:         }
1:fe77ca5:         else
1:fe77ca5:         {
1:fe77ca5:            bufline[bufpos] = line;
1:fe77ca5:            bufcolumn[bufpos] = column;
1:fe77ca5:         }
1:fe77ca5:         if (tokenBegin == -1)
1:fe77ca5:            tokenBegin = bufpos;
1:fe77ca5:         throw e;
1:fe77ca5:      }
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   private final char ReadChar() throws java.io.IOException
1:fe77ca5:   {
1:fe77ca5:      if (++nextCharInd >= maxNextCharInd)
1:fe77ca5:         FillBuff();
1:fe77ca5: 
1:fe77ca5:      return nextCharBuf[nextCharInd];
1:fe77ca5:   }
1:fe77ca5:      
1:fe77ca5:   public char BeginToken() throws java.io.IOException
1:fe77ca5:   {     
1:fe77ca5:      tokenBegin = -1;
1:fe77ca5:      char c = readChar();
1:fe77ca5:      tokenBegin = bufpos;
1:fe77ca5: 
1:fe77ca5:      return c;
1:fe77ca5:   }     
1:fe77ca5: 
1:fe77ca5:   private final void UpdateLineColumn(char c)
1:fe77ca5:   {
1:fe77ca5:      column++;
1:fe77ca5: 
1:fe77ca5:      if (prevCharIsLF)
1:fe77ca5:      {
1:fe77ca5:         prevCharIsLF = false;
1:fe77ca5:         line += (column = 1);
1:fe77ca5:      }
1:fe77ca5:      else if (prevCharIsCR)
1:fe77ca5:      {
1:fe77ca5:         prevCharIsCR = false;
1:fe77ca5:         if (c == '\n')
1:fe77ca5:         {
1:fe77ca5:            prevCharIsLF = true;
1:fe77ca5:         }
1:fe77ca5:         else
1:fe77ca5:            line += (column = 1);
1:fe77ca5:      }
1:fe77ca5: 
1:fe77ca5:      switch (c)
1:fe77ca5:      {
1:fe77ca5:         case '\r' :
1:fe77ca5:            prevCharIsCR = true;
1:fe77ca5:            break;
1:fe77ca5:         case '\n' :
1:fe77ca5:            prevCharIsLF = true;
1:fe77ca5:            break;
1:fe77ca5:         case '\t' :
1:fe77ca5:            column--;
1:fe77ca5:            column += (8 - (column & 07));
1:fe77ca5:            break;
1:fe77ca5:         default :
1:fe77ca5:            break;
1:fe77ca5:      }
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   private int inBuf = 0;
1:fe77ca5:   public final char readChar() throws java.io.IOException
1:fe77ca5:   {
1:fe77ca5:      if (inBuf > 0)
1:fe77ca5:      {
1:fe77ca5:         --inBuf;
1:fe77ca5:         return (char)buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
1:fe77ca5:      }
1:fe77ca5: 
1:fe77ca5: 	 bufpos++;
1:fe77ca5:      char c = ReadChar();
1:fe77ca5:      UpdateLineColumn(c);
1:fe77ca5: 
1:fe77ca5:      if (bufpos == available)
1:fe77ca5:      {
1:fe77ca5:         if (available == bufsize)
1:fe77ca5:         {
1:fe77ca5:            if (tokenBegin > 2048)
1:fe77ca5:            {
1:fe77ca5:               bufpos = 0;
1:fe77ca5:               available = tokenBegin;
1:fe77ca5:            }
1:fe77ca5:            else if (tokenBegin < 0)
1:fe77ca5:               bufpos = 0;
1:fe77ca5:            else
1:fe77ca5:               ExpandBuff(false);
1:fe77ca5:         }
1:fe77ca5:         else if (available > tokenBegin)
1:fe77ca5:            available = bufsize;
1:fe77ca5:         else if ((tokenBegin - available) < 2048)
1:fe77ca5:            ExpandBuff(true);
1:fe77ca5:         else
1:fe77ca5:            available = tokenBegin;
1:fe77ca5:      }
1:fe77ca5: 
1:fe77ca5:      return (buffer[bufpos] = c);
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * @deprecated 
1:fe77ca5:    * @see #getEndColumn
1:fe77ca5:    */
1:fe77ca5: 
1:fe77ca5:   public final int getColumn() {
1:fe77ca5:      return bufcolumn[bufpos];
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * @deprecated 
1:fe77ca5:    * @see #getEndLine
1:fe77ca5:    */
1:fe77ca5: 
1:fe77ca5:   public final int getLine() {
1:fe77ca5:      return bufline[bufpos];
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public final int getEndColumn() {
1:fe77ca5:      return bufcolumn[bufpos];
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public final int getEndLine() {
1:fe77ca5:      return bufline[bufpos];
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public final int getBeginColumn() {
1:fe77ca5:      return bufcolumn[tokenBegin];
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public final int getBeginLine() {
1:fe77ca5:      return bufline[tokenBegin];
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public final void backup(int amount) {
1:fe77ca5: 
1:fe77ca5:     inBuf += amount;
1:fe77ca5:     if ((bufpos -= amount) < 0)
1:fe77ca5:        bufpos += bufsize;
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public UCode_CharStream(java.io.Reader dstream,
1:fe77ca5:                  int startline, int startcolumn, int buffersize)
1:fe77ca5:   {
1:fe77ca5:     inputStream = dstream;
1:fe77ca5:     line = startline;
1:fe77ca5:     column = startcolumn - 1;
1:fe77ca5: 
1:fe77ca5:     available = bufsize = buffersize;
1:fe77ca5:     buffer = new char[buffersize];
1:fe77ca5:     nextCharBuf = new char[buffersize];
1:fe77ca5:     bufline = new int[buffersize];
1:fe77ca5:     bufcolumn = new int[buffersize];
1:fe77ca5:   }
1:fe77ca5: 		
1:fe77ca5: 
1:fe77ca5:   public UCode_CharStream(java.io.Reader dstream,
1:fe77ca5:                                         int startline, int startcolumn)
1:fe77ca5:   {
1:fe77ca5:      this(dstream, startline, startcolumn, 4096);
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public void ReInit(java.io.Reader dstream,
1:fe77ca5:                  int startline, int startcolumn, int buffersize)
1:fe77ca5:   {
1:fe77ca5:     inputStream = dstream;
1:fe77ca5:     line = startline;
1:fe77ca5:     column = startcolumn - 1;
1:fe77ca5: 
1:fe77ca5:     if (buffer == null || buffersize != buffer.length)
1:fe77ca5:     {
1:fe77ca5:       available = bufsize = buffersize;
1:fe77ca5:       buffer = new char[buffersize];
1:fe77ca5:       nextCharBuf = new char[buffersize];
1:fe77ca5:       bufline = new int[buffersize];
1:fe77ca5:       bufcolumn = new int[buffersize];
1:fe77ca5:     }
1:fe77ca5:   	tokenBegin = inBuf = maxNextCharInd = 0; 
1:fe77ca5: 	nextCharInd = bufpos = -1; 
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public void ReInit(java.io.Reader dstream,
1:fe77ca5:                                         int startline, int startcolumn)
1:fe77ca5:   {
1:fe77ca5:      ReInit(dstream, startline, startcolumn, 4096);
1:fe77ca5:   }
1:fe77ca5:   public UCode_CharStream(java.io.InputStream dstream, int startline,
1:fe77ca5:   int startcolumn, int buffersize)
1:fe77ca5:   {
1:fe77ca5:      this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public UCode_CharStream(java.io.InputStream dstream, int startline,
1:fe77ca5:                                                            int startcolumn)
1:fe77ca5:   {
1:fe77ca5:      this(dstream, startline, startcolumn, 4096);
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public void ReInit(java.io.InputStream dstream, int startline,
1:fe77ca5:   int startcolumn, int buffersize)
1:fe77ca5:   {
1:fe77ca5:      ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
1:fe77ca5:   }
1:fe77ca5:   public void ReInit(java.io.InputStream dstream, int startline,
1:fe77ca5:                                                            int startcolumn)
1:fe77ca5:   {
1:fe77ca5:      ReInit(dstream, startline, startcolumn, 4096);
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public final String GetImage()
1:fe77ca5:   {
1:fe77ca5:      if (bufpos >= tokenBegin)
1:fe77ca5:         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
1:fe77ca5:      else
1:fe77ca5:         return new String(buffer, tokenBegin, bufsize - tokenBegin) +
1:fe77ca5:                               new String(buffer, 0, bufpos + 1);
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public final char[] GetSuffix(int len)
1:fe77ca5:   {
1:fe77ca5:      char[] ret = new char[len];
1:fe77ca5: 
1:fe77ca5:      if ((bufpos + 1) >= len)
1:fe77ca5:         System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
1:fe77ca5:      else
1:fe77ca5:      {
1:fe77ca5:         System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
1:fe77ca5:                                                           len - bufpos - 1);
1:fe77ca5:         System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
1:fe77ca5:      }
1:fe77ca5: 
1:fe77ca5:      return ret;
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   public void Done()
1:fe77ca5:   {
1:fe77ca5:      nextCharBuf = null;
1:fe77ca5:      buffer = null;
1:fe77ca5:      bufline = null;
1:fe77ca5:      bufcolumn = null;
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5:   /**
1:fe77ca5:    * Method to adjust line and column numbers for the start of a token.<BR>
1:fe77ca5:    */
1:fe77ca5:   public void adjustBeginLineColumn(int newLine, int newCol)
1:fe77ca5:   {
1:fe77ca5:      int start = tokenBegin;
1:fe77ca5:      int len;
1:fe77ca5: 
1:fe77ca5:      if (bufpos >= tokenBegin)
1:fe77ca5:      {
1:fe77ca5:         len = bufpos - tokenBegin + inBuf + 1;
1:fe77ca5:      }
1:fe77ca5:      else
1:fe77ca5:      {
1:fe77ca5:         len = bufsize - tokenBegin + bufpos + 1 + inBuf;
1:fe77ca5:      }
1:fe77ca5: 
1:fe77ca5:      int i = 0, j = 0, k = 0;
1:fe77ca5:      int nextColDiff = 0, columnDiff = 0;
1:fe77ca5: 
1:fe77ca5:      while (i < len &&
1:fe77ca5:             bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
1:fe77ca5:      {
1:fe77ca5:         bufline[j] = newLine;
1:fe77ca5:         nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
1:fe77ca5:         bufcolumn[j] = newCol + columnDiff;
1:fe77ca5:         columnDiff = nextColDiff;
1:fe77ca5:         i++;
1:fe77ca5:      } 
1:fe77ca5: 
1:fe77ca5:      if (i < len)
1:fe77ca5:      {
1:fe77ca5:         bufline[j] = newLine++;
1:fe77ca5:         bufcolumn[j] = newCol + columnDiff;
1:fe77ca5: 
1:fe77ca5:         while (i++ < len)
1:fe77ca5:         {
1:fe77ca5:            if (bufline[j = start % bufsize] != bufline[++start % bufsize])
1:fe77ca5:               bufline[j] = newLine++;
1:fe77ca5:            else
1:fe77ca5:               bufline[j] = newLine;
1:fe77ca5:         }
1:fe77ca5:      }
1:fe77ca5: 
1:fe77ca5:      line = bufline[j];
1:fe77ca5:      column = bufcolumn[j];
1:fe77ca5:   }
1:fe77ca5: 
1:fe77ca5: }
============================================================================
author:David Van Couvering
-------------------------------------------------------------------------------
commit:11bc2d0
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:985fc85
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.tools.ij.UCode_CharStream
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:a8ff4fd
/////////////////////////////////////////////////////////////////////////
commit:fe77ca5
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: /* Generated By:JavaCC: Do not edit this line. UCode_CharStream.java Version 0.7pre6 */
1: package org.apache.derby.impl.tools.ij;
1: 
1: /**
1:  * An implementation of interface CharStream, where the stream is assumed to
1:  * contain only Unicode characters.
1:  */
1: 
1: public final class UCode_CharStream implements CharStream
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1:   public static final boolean staticFlag = false;
1:   public int bufpos = -1;
1:   int bufsize;
1:   int available;
1:   int tokenBegin;
1:   private int bufline[];
1:   private int bufcolumn[];
1: 
1:   private int column = 0;
1:   private int line = 1;
1: 
1:   private boolean prevCharIsCR = false;
1:   private boolean prevCharIsLF = false;
1: 
1:   private java.io.Reader inputStream;
1: 
1:   private char[] nextCharBuf;
1:   private char[] buffer;
1:   private int maxNextCharInd = 0;
1:   private int nextCharInd = -1;
1: 
1:   private final void ExpandBuff(boolean wrapAround)
1:   {
1:      char[] newbuffer = new char[bufsize + 2048];
1:      int newbufline[] = new int[bufsize + 2048];
1:      int newbufcolumn[] = new int[bufsize + 2048];
1: 
1:      try
1:      {
1:         if (wrapAround)
1:         {
1:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
1:            System.arraycopy(buffer, 0, newbuffer,
1:                                              bufsize - tokenBegin, bufpos);
1:            buffer = newbuffer;
1: 
1:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
1:            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
1:            bufline = newbufline;
1: 
1:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
1:            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
1:            bufcolumn = newbufcolumn;
1: 
1:            bufpos += (bufsize - tokenBegin);
1:         }
1:         else
1:         {
1:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
1:            buffer = newbuffer;
1: 
1:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
1:            bufline = newbufline;
1: 
1:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
1:            bufcolumn = newbufcolumn;
1: 
1:            bufpos -= tokenBegin;
1:         }
1:      }
1:      catch (Throwable t)
1:      {
1:         throw new Error(t.getMessage());
1:      }
1: 
1:      available = (bufsize += 2048);
1:      tokenBegin = 0;
1:   }
1: 
1:   private final void FillBuff() throws java.io.IOException
1:   {
1:      if (maxNextCharInd == 4096)
1:         maxNextCharInd = nextCharInd = 0;
1: 
1:      int i;
1:      try {
1:         if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
1:                                             4096 - maxNextCharInd)) == -1)
1:         {
1:            inputStream.close();
1:            throw new java.io.IOException();
1:         }
1:         else
1:            maxNextCharInd += i;
1:         return;
1:      }
1:      catch(java.io.IOException e) {
1:         if (bufpos != 0)
1:         {
1:            --bufpos;
1:            backup(0);
1:         }
1:         else
1:         {
1:            bufline[bufpos] = line;
1:            bufcolumn[bufpos] = column;
1:         }
1:         if (tokenBegin == -1)
1:            tokenBegin = bufpos;
1:         throw e;
1:      }
1:   }
1: 
1:   private final char ReadChar() throws java.io.IOException
1:   {
1:      if (++nextCharInd >= maxNextCharInd)
1:         FillBuff();
1: 
1:      return nextCharBuf[nextCharInd];
1:   }
1:      
1:   public char BeginToken() throws java.io.IOException
1:   {     
1:      tokenBegin = -1;
1:      char c = readChar();
1:      tokenBegin = bufpos;
1: 
1:      return c;
1:   }     
1: 
1:   private final void UpdateLineColumn(char c)
1:   {
1:      column++;
1: 
1:      if (prevCharIsLF)
1:      {
1:         prevCharIsLF = false;
1:         line += (column = 1);
1:      }
1:      else if (prevCharIsCR)
1:      {
1:         prevCharIsCR = false;
1:         if (c == '\n')
1:         {
1:            prevCharIsLF = true;
1:         }
1:         else
1:            line += (column = 1);
1:      }
1: 
1:      switch (c)
1:      {
1:         case '\r' :
1:            prevCharIsCR = true;
1:            break;
1:         case '\n' :
1:            prevCharIsLF = true;
1:            break;
1:         case '\t' :
1:            column--;
1:            column += (8 - (column & 07));
1:            break;
1:         default :
1:            break;
1:      }
1:   }
1: 
1:   private int inBuf = 0;
1:   public final char readChar() throws java.io.IOException
1:   {
1:      if (inBuf > 0)
1:      {
1:         --inBuf;
1:         return (char)buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
1:      }
1: 
1: 	 bufpos++;
1:      char c = ReadChar();
1:      UpdateLineColumn(c);
1: 
1:      if (bufpos == available)
1:      {
1:         if (available == bufsize)
1:         {
1:            if (tokenBegin > 2048)
1:            {
1:               bufpos = 0;
1:               available = tokenBegin;
1:            }
1:            else if (tokenBegin < 0)
1:               bufpos = 0;
1:            else
1:               ExpandBuff(false);
1:         }
1:         else if (available > tokenBegin)
1:            available = bufsize;
1:         else if ((tokenBegin - available) < 2048)
1:            ExpandBuff(true);
1:         else
1:            available = tokenBegin;
1:      }
1: 
1:      return (buffer[bufpos] = c);
1:   }
1: 
1:   /**
1:    * @deprecated 
1:    * @see #getEndColumn
1:    */
1: 
1:   public final int getColumn() {
1:      return bufcolumn[bufpos];
1:   }
1: 
1:   /**
1:    * @deprecated 
1:    * @see #getEndLine
1:    */
1: 
1:   public final int getLine() {
1:      return bufline[bufpos];
1:   }
1: 
1:   public final int getEndColumn() {
1:      return bufcolumn[bufpos];
1:   }
1: 
1:   public final int getEndLine() {
1:      return bufline[bufpos];
1:   }
1: 
1:   public final int getBeginColumn() {
1:      return bufcolumn[tokenBegin];
1:   }
1: 
1:   public final int getBeginLine() {
1:      return bufline[tokenBegin];
1:   }
1: 
1:   public final void backup(int amount) {
1: 
1:     inBuf += amount;
1:     if ((bufpos -= amount) < 0)
1:        bufpos += bufsize;
1:   }
1: 
1:   public UCode_CharStream(java.io.Reader dstream,
1:                  int startline, int startcolumn, int buffersize)
1:   {
1:     inputStream = dstream;
1:     line = startline;
1:     column = startcolumn - 1;
1: 
1:     available = bufsize = buffersize;
1:     buffer = new char[buffersize];
1:     nextCharBuf = new char[buffersize];
1:     bufline = new int[buffersize];
1:     bufcolumn = new int[buffersize];
1:   }
1: 		
1: 
1:   public UCode_CharStream(java.io.Reader dstream,
1:                                         int startline, int startcolumn)
1:   {
1:      this(dstream, startline, startcolumn, 4096);
1:   }
1: 
1:   public void ReInit(java.io.Reader dstream,
1:                  int startline, int startcolumn, int buffersize)
1:   {
1:     inputStream = dstream;
1:     line = startline;
1:     column = startcolumn - 1;
1: 
1:     if (buffer == null || buffersize != buffer.length)
1:     {
1:       available = bufsize = buffersize;
1:       buffer = new char[buffersize];
1:       nextCharBuf = new char[buffersize];
1:       bufline = new int[buffersize];
1:       bufcolumn = new int[buffersize];
1:     }
1:   	tokenBegin = inBuf = maxNextCharInd = 0; 
1: 	nextCharInd = bufpos = -1; 
1:   }
1: 
1:   public void ReInit(java.io.Reader dstream,
1:                                         int startline, int startcolumn)
1:   {
1:      ReInit(dstream, startline, startcolumn, 4096);
1:   }
1:   public UCode_CharStream(java.io.InputStream dstream, int startline,
1:   int startcolumn, int buffersize)
1:   {
1:      this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
1:   }
1: 
1:   public UCode_CharStream(java.io.InputStream dstream, int startline,
1:                                                            int startcolumn)
1:   {
1:      this(dstream, startline, startcolumn, 4096);
1:   }
1: 
1:   public void ReInit(java.io.InputStream dstream, int startline,
1:   int startcolumn, int buffersize)
1:   {
1:      ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
1:   }
1:   public void ReInit(java.io.InputStream dstream, int startline,
1:                                                            int startcolumn)
1:   {
1:      ReInit(dstream, startline, startcolumn, 4096);
1:   }
1: 
1:   public final String GetImage()
1:   {
1:      if (bufpos >= tokenBegin)
1:         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
1:      else
1:         return new String(buffer, tokenBegin, bufsize - tokenBegin) +
1:                               new String(buffer, 0, bufpos + 1);
1:   }
1: 
1:   public final char[] GetSuffix(int len)
1:   {
1:      char[] ret = new char[len];
1: 
1:      if ((bufpos + 1) >= len)
1:         System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
1:      else
1:      {
1:         System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
1:                                                           len - bufpos - 1);
1:         System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
1:      }
1: 
1:      return ret;
1:   }
1: 
1:   public void Done()
1:   {
1:      nextCharBuf = null;
1:      buffer = null;
1:      bufline = null;
1:      bufcolumn = null;
1:   }
1: 
1:   /**
1:    * Method to adjust line and column numbers for the start of a token.<BR>
1:    */
1:   public void adjustBeginLineColumn(int newLine, int newCol)
1:   {
1:      int start = tokenBegin;
1:      int len;
1: 
1:      if (bufpos >= tokenBegin)
1:      {
1:         len = bufpos - tokenBegin + inBuf + 1;
1:      }
1:      else
1:      {
1:         len = bufsize - tokenBegin + bufpos + 1 + inBuf;
1:      }
1: 
1:      int i = 0, j = 0, k = 0;
1:      int nextColDiff = 0, columnDiff = 0;
1: 
1:      while (i < len &&
1:             bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
1:      {
1:         bufline[j] = newLine;
1:         nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
1:         bufcolumn[j] = newCol + columnDiff;
1:         columnDiff = nextColDiff;
1:         i++;
1:      } 
1: 
1:      if (i < len)
1:      {
1:         bufline[j] = newLine++;
1:         bufcolumn[j] = newCol + columnDiff;
1: 
1:         while (i++ < len)
1:         {
1:            if (bufline[j = start % bufsize] != bufline[++start % bufsize])
1:               bufline[j] = newLine++;
1:            else
1:               bufline[j] = newLine;
1:         }
1:      }
1: 
1:      line = bufline[j];
1:      column = bufcolumn[j];
1:   }
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.tools.ij
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: /* Generated By:JavaCC: Do not edit this line. UCode_CharStream.java Version 0.7pre6 */
0: package org.apache.derby.impl.tools.ij;
0: 
0: /**
0:  * An implementation of interface CharStream, where the stream is assumed to
0:  * contain only Unicode characters.
0:  */
0: 
0: public final class UCode_CharStream implements CharStream
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0:   public static final boolean staticFlag = false;
0:   public int bufpos = -1;
0:   int bufsize;
0:   int available;
0:   int tokenBegin;
0:   private int bufline[];
0:   private int bufcolumn[];
0: 
0:   private int column = 0;
0:   private int line = 1;
0: 
0:   private boolean prevCharIsCR = false;
0:   private boolean prevCharIsLF = false;
0: 
0:   private java.io.Reader inputStream;
0: 
0:   private char[] nextCharBuf;
0:   private char[] buffer;
0:   private int maxNextCharInd = 0;
0:   private int nextCharInd = -1;
0: 
0:   private final void ExpandBuff(boolean wrapAround)
0:   {
0:      char[] newbuffer = new char[bufsize + 2048];
0:      int newbufline[] = new int[bufsize + 2048];
0:      int newbufcolumn[] = new int[bufsize + 2048];
0: 
0:      try
0:      {
0:         if (wrapAround)
0:         {
0:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
0:            System.arraycopy(buffer, 0, newbuffer,
0:                                              bufsize - tokenBegin, bufpos);
0:            buffer = newbuffer;
0: 
0:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
0:            System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
0:            bufline = newbufline;
0: 
0:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
0:            System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
0:            bufcolumn = newbufcolumn;
0: 
0:            bufpos += (bufsize - tokenBegin);
0:         }
0:         else
0:         {
0:            System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
0:            buffer = newbuffer;
0: 
0:            System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
0:            bufline = newbufline;
0: 
0:            System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
0:            bufcolumn = newbufcolumn;
0: 
0:            bufpos -= tokenBegin;
0:         }
0:      }
0:      catch (Throwable t)
0:      {
0:         throw new Error(t.getMessage());
0:      }
0: 
0:      available = (bufsize += 2048);
0:      tokenBegin = 0;
0:   }
0: 
0:   private final void FillBuff() throws java.io.IOException
0:   {
0:      if (maxNextCharInd == 4096)
0:         maxNextCharInd = nextCharInd = 0;
0: 
0:      int i;
0:      try {
0:         if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
0:                                             4096 - maxNextCharInd)) == -1)
0:         {
0:            inputStream.close();
0:            throw new java.io.IOException();
0:         }
0:         else
0:            maxNextCharInd += i;
0:         return;
0:      }
0:      catch(java.io.IOException e) {
0:         if (bufpos != 0)
0:         {
0:            --bufpos;
0:            backup(0);
0:         }
0:         else
0:         {
0:            bufline[bufpos] = line;
0:            bufcolumn[bufpos] = column;
0:         }
0:         if (tokenBegin == -1)
0:            tokenBegin = bufpos;
0:         throw e;
0:      }
0:   }
0: 
0:   private final char ReadChar() throws java.io.IOException
0:   {
0:      if (++nextCharInd >= maxNextCharInd)
0:         FillBuff();
0: 
0:      return nextCharBuf[nextCharInd];
0:   }
0:      
0:   public char BeginToken() throws java.io.IOException
0:   {     
0:      tokenBegin = -1;
0:      char c = readChar();
0:      tokenBegin = bufpos;
0: 
0:      return c;
0:   }     
0: 
0:   private final void UpdateLineColumn(char c)
0:   {
0:      column++;
0: 
0:      if (prevCharIsLF)
0:      {
0:         prevCharIsLF = false;
0:         line += (column = 1);
0:      }
0:      else if (prevCharIsCR)
0:      {
0:         prevCharIsCR = false;
0:         if (c == '\n')
0:         {
0:            prevCharIsLF = true;
0:         }
0:         else
0:            line += (column = 1);
0:      }
0: 
0:      switch (c)
0:      {
0:         case '\r' :
0:            prevCharIsCR = true;
0:            break;
0:         case '\n' :
0:            prevCharIsLF = true;
0:            break;
0:         case '\t' :
0:            column--;
0:            column += (8 - (column & 07));
0:            break;
0:         default :
0:            break;
0:      }
0:   }
0: 
0:   private int inBuf = 0;
0:   public final char readChar() throws java.io.IOException
0:   {
0:      if (inBuf > 0)
0:      {
0:         --inBuf;
0:         return (char)buffer[(bufpos == bufsize - 1) ? (bufpos = 0) : ++bufpos];
0:      }
0: 
0: 	 bufpos++;
0:      char c = ReadChar();
0:      UpdateLineColumn(c);
0: 
0:      if (bufpos == available)
0:      {
0:         if (available == bufsize)
0:         {
0:            if (tokenBegin > 2048)
0:            {
0:               bufpos = 0;
0:               available = tokenBegin;
0:            }
0:            else if (tokenBegin < 0)
0:               bufpos = 0;
0:            else
0:               ExpandBuff(false);
0:         }
0:         else if (available > tokenBegin)
0:            available = bufsize;
0:         else if ((tokenBegin - available) < 2048)
0:            ExpandBuff(true);
0:         else
0:            available = tokenBegin;
0:      }
0: 
0:      return (buffer[bufpos] = c);
0:   }
0: 
0:   /**
0:    * @deprecated 
0:    * @see #getEndColumn
0:    */
0: 
0:   public final int getColumn() {
0:      return bufcolumn[bufpos];
0:   }
0: 
0:   /**
0:    * @deprecated 
0:    * @see #getEndLine
0:    */
0: 
0:   public final int getLine() {
0:      return bufline[bufpos];
0:   }
0: 
0:   public final int getEndColumn() {
0:      return bufcolumn[bufpos];
0:   }
0: 
0:   public final int getEndLine() {
0:      return bufline[bufpos];
0:   }
0: 
0:   public final int getBeginColumn() {
0:      return bufcolumn[tokenBegin];
0:   }
0: 
0:   public final int getBeginLine() {
0:      return bufline[tokenBegin];
0:   }
0: 
0:   public final void backup(int amount) {
0: 
0:     inBuf += amount;
0:     if ((bufpos -= amount) < 0)
0:        bufpos += bufsize;
0:   }
0: 
0:   public UCode_CharStream(java.io.Reader dstream,
0:                  int startline, int startcolumn, int buffersize)
0:   {
0:     inputStream = dstream;
0:     line = startline;
0:     column = startcolumn - 1;
0: 
0:     available = bufsize = buffersize;
0:     buffer = new char[buffersize];
0:     nextCharBuf = new char[buffersize];
0:     bufline = new int[buffersize];
0:     bufcolumn = new int[buffersize];
0:   }
0: 		
0: 
0:   public UCode_CharStream(java.io.Reader dstream,
0:                                         int startline, int startcolumn)
0:   {
0:      this(dstream, startline, startcolumn, 4096);
0:   }
0: 
0:   public void ReInit(java.io.Reader dstream,
0:                  int startline, int startcolumn, int buffersize)
0:   {
0:     inputStream = dstream;
0:     line = startline;
0:     column = startcolumn - 1;
0: 
0:     if (buffer == null || buffersize != buffer.length)
0:     {
0:       available = bufsize = buffersize;
0:       buffer = new char[buffersize];
0:       nextCharBuf = new char[buffersize];
0:       bufline = new int[buffersize];
0:       bufcolumn = new int[buffersize];
0:     }
0:   	tokenBegin = inBuf = maxNextCharInd = 0; 
0: 	nextCharInd = bufpos = -1; 
0:   }
0: 
0:   public void ReInit(java.io.Reader dstream,
0:                                         int startline, int startcolumn)
0:   {
0:      ReInit(dstream, startline, startcolumn, 4096);
0:   }
0:   public UCode_CharStream(java.io.InputStream dstream, int startline,
0:   int startcolumn, int buffersize)
0:   {
0:      this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
0:   }
0: 
0:   public UCode_CharStream(java.io.InputStream dstream, int startline,
0:                                                            int startcolumn)
0:   {
0:      this(dstream, startline, startcolumn, 4096);
0:   }
0: 
0:   public void ReInit(java.io.InputStream dstream, int startline,
0:   int startcolumn, int buffersize)
0:   {
0:      ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
0:   }
0:   public void ReInit(java.io.InputStream dstream, int startline,
0:                                                            int startcolumn)
0:   {
0:      ReInit(dstream, startline, startcolumn, 4096);
0:   }
0: 
0:   public final String GetImage()
0:   {
0:      if (bufpos >= tokenBegin)
0:         return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
0:      else
0:         return new String(buffer, tokenBegin, bufsize - tokenBegin) +
0:                               new String(buffer, 0, bufpos + 1);
0:   }
0: 
0:   public final char[] GetSuffix(int len)
0:   {
0:      char[] ret = new char[len];
0: 
0:      if ((bufpos + 1) >= len)
0:         System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
0:      else
0:      {
0:         System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
0:                                                           len - bufpos - 1);
0:         System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
0:      }
0: 
0:      return ret;
0:   }
0: 
0:   public void Done()
0:   {
0:      nextCharBuf = null;
0:      buffer = null;
0:      bufline = null;
0:      bufcolumn = null;
0:   }
0: 
0:   /**
0:    * Method to adjust line and column numbers for the start of a token.<BR>
0:    */
0:   public void adjustBeginLineColumn(int newLine, int newCol)
0:   {
0:      int start = tokenBegin;
0:      int len;
0: 
0:      if (bufpos >= tokenBegin)
0:      {
0:         len = bufpos - tokenBegin + inBuf + 1;
0:      }
0:      else
0:      {
0:         len = bufsize - tokenBegin + bufpos + 1 + inBuf;
0:      }
0: 
0:      int i = 0, j = 0, k = 0;
0:      int nextColDiff = 0, columnDiff = 0;
0: 
0:      while (i < len &&
0:             bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
0:      {
0:         bufline[j] = newLine;
0:         nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
0:         bufcolumn[j] = newCol + columnDiff;
0:         columnDiff = nextColDiff;
0:         i++;
0:      } 
0: 
0:      if (i < len)
0:      {
0:         bufline[j] = newLine++;
0:         bufcolumn[j] = newCol + columnDiff;
0: 
0:         while (i++ < len)
0:         {
0:            if (bufline[j = start % bufsize] != bufline[++start % bufsize])
0:               bufline[j] = newLine++;
0:            else
0:               bufline[j] = newLine;
0:         }
0:      }
0: 
0:      line = bufline[j];
0:      column = bufcolumn[j];
0:   }
0: 
0: }
============================================================================