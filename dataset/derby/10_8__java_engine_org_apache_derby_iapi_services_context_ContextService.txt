2:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.services.context.ContextService
1:7ecc1f2: 
1:6baf18b:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6baf18b:    contributor license agreements.  See the NOTICE file distributed with
1:6baf18b:    this work for additional information regarding copyright ownership.
1:6baf18b:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6baf18b:    (the "License"); you may not use this file except in compliance with
1:6baf18b:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
19:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.services.context;
1:eac0369: 
1:1a36302: import java.security.AccessController;
1:1a36302: import java.security.PrivilegedAction;
1:1a36302: import java.util.HashSet;
1:f9a152b: import java.util.Stack;
1:1a36302: 
1:4b58cc0: import org.apache.derby.shared.common.error.ShutdownException;
1:a0dbbd7: import org.apache.derby.iapi.security.SecurityUtil;
1:eac0369: import org.apache.derby.iapi.services.monitor.Monitor;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1:eac0369: 
1:8a059c4: /**
1:eac0369: 	A set of static methods to supply easier access to contexts.
1:eac0369: */
1:eac0369: public final class ContextService //OLD extends Hashtable
1:eac0369: {
1:eac0369: 
1:eac0369: 	private static ContextService factory;
1:eac0369: 	private HeaderPrintWriter errorStream;
1:eac0369: 
2:eac0369: 	/**
1:eac0369: 		Maintains a list of all the contexts that this thread has created
1:eac0369: 		and/or used. The object stored in the thread local varys according
1:eac0369: 		how this thread has been used and will be one of:
1:eac0369: 
1:eac0369: 		<UL>
1:eac0369: 		<LI> null - the thread no affiliation with a context manager.
1:eac0369: 
1:874ccee: 		<LI> ContextManager - the current thread has used or is using
1:874ccee:             this context manager. If ContextManager.activeThread equals
1:874ccee:             the current thread then the thread is currently active with
1:874ccee:             the ContextManager. In this case ContextManager.activeCount
1:874ccee:             will be greater than zero and represent the level of nested
1:874ccee:             setCurrentContextmanager calls.
1:874ccee:             If ContextManager.activeThread is null then no other thread
1:874ccee:             is using the Contextmanager, if ContextManager.activeThread
1:874ccee:             is not-null and not equal to the current thread then some
1:874ccee:             other thread is using the context. It is assumed that
1:874ccee:             only a single thread can be using a ContextManager at any time
1:874ccee:             and this is enforced by synchronization outside the ContextManager.
1:874ccee:             E.g for JDBC connections, synchronization at the JDBC level.
1:eac0369: 
1:f9a152b:         <LI> ContextManagerStack containing ContextManagers - the current
1:874ccee:         thread is actively using multiple different ContextManagers,
1:874ccee:         with nesting. All ContextManagers in the stack will have
1:874ccee:         activeThread set to the current thread, and their activeCount
1:f9a152b:         set to -1. This is because nesting is solely represented by
1:874ccee:         the stack, with the current context manager on top of the stack.
1:874ccee:         This supports multiple levels of nesting across two stacks, e.g.
1:dbed020:         C1-&gt;C2-&gt;C2-&gt;C1-&gt;C2.
1:eac0369: 		</UL>
1:eac0369: 
1:eac0369: 		This thread local is used to find the current context manager. Basically it provides
1:eac0369: 		fast access to a list of candidate contexts. If one of the contexts has its activeThread
1:eac0369: 		equal to the current thread then it is the current context manager.
1:eac0369: 
1:3fd26f3: 		If the thread has pushed multiple contexts (e.g. open a new non-nested Derby connection
1:874ccee: 		from a server side method) then threadContextList will contain a Stack. The value for each cm
1:eac0369: 		will be a push order, with higher numbers being more recently pushed.
1:eac0369: 
1:eac0369: 		To support the case where a single context manager is pushed twice (nested connection),
1:eac0369: 		the context manager keeps track of the number of times it has been pushed (set). Note that
1:eac0369: 		our synchronization requires that a single context can only be accessed by a single thread at a time.
1:eac0369: 		In the JDBC layer this is enforced by the synchronization on the connection object.
1:eac0369: 
1:eac0369: 		<P>
1:eac0369: 		There are two cases we are trying to optimise.
1:eac0369: 		<UL>
1:eac0369: 		<LI> Typical JDBC client program where there a Connection is always executed using a single thread.
1:eac0369: 			In this case this variable will contain the Connection's context manager 
1:eac0369: 		<LI> Typical application server pooled connection where a single thread may use a connection from a pool
1:874ccee: 		for the lifetime of the request. In this case this variable will contain a  WeakReference.
1:eac0369: 		</UL>
1:874ccee:         <BR>
1:f9a152b:         Single thread for Connection execution.
1:874ccee:         <pre>
1:874ccee:         threadContextList.get() == cm
1:874ccee:         // while in JDBC engine code
1:874ccee:         cm.activeThread == Thread.currentThread();
1:874ccee:         cm.activeCount = 1;
1:874ccee:         </pre>
1:874ccee:         
1:874ccee:         <BR>
1:874ccee:         J2EE single thread for lifetime of execution.
1:874ccee:         <pre>
1:874ccee:         // thread executing request
1:874ccee:          threadContextList.get() == cm
1:874ccee:         // while in JDBC engine code
1:874ccee:         cm.activeThread == Thread.currentThread();
1:874ccee:         cm.activeCount = 1;
1:874ccee:         
1:874ccee:         // other threads that have recently executed
1:874ccee:         // the same connection can have
1:874ccee:         threadContextList.get() == cm
1:874ccee:         cm.activeThread != Thread.currentThread();
1:874ccee:        </pre>
1:874ccee:         
1:874ccee:         <BR>
1:874ccee:         Nested routine calls within single connection
1:874ccee:         <pre>
1:874ccee:         threadContextList.get() == cm
1:874ccee:         // Within server-side JDBC code in a
1:874ccee:         // function called from another function/procedure
1:874ccee:         // called from an applications's statement
1:874ccee:         // (three levels of nesting)
1:874ccee:         cm.activeThread == Thread.currentThread();
1:874ccee:         cm.activeCount = 3;         
1:874ccee:         </pre>
1:874ccee:         
1:874ccee:         <BR>
1:874ccee:         Nested routine calls with the inner routine
1:874ccee:         using a different connection to access a Derby database.
1:874ccee:         Note nesting of orignal Contextmanager cm is changed
1:874ccee:         from an activeCount of 2 to nesting within the stack
1:874ccee:         once multiple ContextManagers are involved.
1:874ccee:         <pre>
1:874ccee:         threadContextList.get() == stack {cm2,cm,cm}
1:874ccee:         cm.activeThread == Thread.currentThread();
1:874ccee:         cm.activeCount = -1; // nesting in stack
1:874ccee:         cm2.activeThread == Thread.currentThread();
1:874ccee:         cm2.activeCount = -1; // nesting in stack
1:874ccee:         </pre> 
1:874ccee:         
1:874ccee:         <BR>
1:874ccee:         Nested multiple ContextManagers, the code supports
1:874ccee:         this, though it may not be possible currently
1:874ccee:         to have a stack like this from SQL/JDBC.
1:874ccee:         <pre>
1:874ccee:         threadContextList.get() == stack {cm3,cm2,cm,cm2,cm,cm}
1:874ccee:         cm.activeThread == Thread.currentThread();
1:874ccee:         cm.activeCount = -1; // nesting in stack
1:874ccee:         cm2.activeThread == Thread.currentThread();
1:874ccee:         cm2.activeCount = -1; // nesting in stack
1:874ccee:         cm3.activeThread == Thread.currentThread();
1:874ccee:         cm3.activeCount = -1; // nesting in stack
1:874ccee:         </pre>   
1:eac0369: 	*/
1:073b862: 	private ThreadLocal<Object> threadContextList = new ThreadLocal<Object>();
1:eac0369: 
1:eac0369:     /**
1:8a059c4:      * Collection of all ContextManagers that are open
1:8a059c4:      * in the complete Derby system. A ContextManager is
1:8a059c4:      * added when it is created with newContextManager and
1:8a059c4:      * removed when the session is closed.
1:8a059c4:      * 
1:8a059c4:      * @see #newContextManager()
1:8a059c4:      * @see SystemContext#cleanupOnError(Throwable)
1:8a059c4:      */
1:073b862: 	private HashSet<ContextManager> allContexts;
1:eac0369: 
1:8a059c4:     /**
1:8a059c4:      * Create a new ContextService for a Derby system.
1:8a059c4:      * Only a single system is active at any time.
1:8a059c4:      *
1:8a059c4:      */
1:eac0369: 	public ContextService() {
1:eac0369: 
1:eac0369: 		// find the error stream
1:eac0369: 		errorStream = Monitor.getStream();		
1:eac0369: 
1:eac0369: 		ContextService.factory = this;
1:eac0369: 
1:073b862: 		allContexts = new HashSet<ContextManager>();
1:eac0369: 
1:874ccee: 	}
1:eac0369: 
1:8a059c4: 	/**
1:eac0369: 		So it can be given to us and taken away...
1:eac0369: 	 */
1:a0dbbd7: 	public static void stop()
1:a0dbbd7:     {
1:a0dbbd7:         // Verify that we have permission to execute this method.
1:a0dbbd7:         SecurityUtil.checkDerbyInternalsPrivilege();
1:a0dbbd7:         
1:896f574: 		// For some unknown reason, the ContextManager and
1:896f574: 		// ContextService objects will not be garbage collected
1:896f574: 		// without the next two lines.
1:8a059c4:         ContextService fact = ContextService.factory;
1:8a059c4:         if (fact != null) {
1:8a059c4:             synchronized (fact) {
1:8a059c4:                 fact.allContexts = null;
1:8a059c4:                 fact.threadContextList = null;
1:8a059c4:                 ContextService.factory = null;
1:8a059c4:             }
1:8a059c4:         }
4:eac0369: 	}
1:eac0369: 
1:a0dbbd7: 	public static ContextService getFactory()
1:a0dbbd7:     {
1:a0dbbd7:         // Verify that we have permission to execute this method.
1:a0dbbd7:         SecurityUtil.checkDerbyInternalsPrivilege();
1:a0dbbd7:         
1:eac0369: 		ContextService csf = factory;
1:eac0369: 
1:eac0369: 		if (csf == null)
1:eac0369: 			throw new ShutdownException();
1:eac0369: 		return csf;
1:eac0369: 	}
1:874ccee: 	/**
1:eac0369: 		Find the context with the given name in the context service factory
1:eac0369: 		loaded for the system.
1:eac0369: 
1:eac0369: 		@return The requested context, null if it doesn't exist.
1:eac0369: 	*/
1:a0dbbd7: 	public static Context getContext(String contextId)
1:a0dbbd7:     {
1:a0dbbd7:         // Verify that we have permission to execute this method.
1:a0dbbd7:         SecurityUtil.checkDerbyInternalsPrivilege();
1:a0dbbd7:         
1:eac0369: 		ContextManager cm = getFactory().getCurrentContextManager();
1:eac0369: 
1:eac0369:         if( cm == null)
1:eac0369:             return null;
1:eac0369:         
1:eac0369: 		return cm.getContext(contextId);
1:eac0369: 	}
1:eac0369: 
1:d86eb82: 	/**
1:eac0369: 		Find the context with the given name in the context service factory
1:eac0369: 		loaded for the system.
1:eac0369: 
1:eac0369: 		This version will not do any debug checking, but return null
1:eac0369: 		quietly if it runs into any problems.
1:eac0369: 
1:eac0369: 		@return The requested context, null if it doesn't exist.
1:eac0369: 	*/
1:a0dbbd7: 	public static Context getContextOrNull(String contextId)
1:a0dbbd7:     {
1:a0dbbd7:         // Verify that we have permission to execute this method.
1:a0dbbd7:         SecurityUtil.checkDerbyInternalsPrivilege();
1:a0dbbd7:         
1:eac0369: 		ContextService csf = factory;
1:eac0369: 
1:eac0369: 		if (csf == null)
1:eac0369: 			return null;
1:eac0369: 		
1:eac0369: 		ContextManager cm = csf.getCurrentContextManager();
1:eac0369: 
2:eac0369: 		if (cm == null)
1:eac0369: 			return null;
1:eac0369: 
1:eac0369: 		return cm.getContext(contextId);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:d86eb82: 	 * Get current Context Manager linked to the current Thread.
1:d86eb82:      * See setCurrentContextManager for details.
1:d86eb82:      * Note that this call can be expensive and is only
1:d86eb82:      * intended to be used in "stateless" situations.
1:d86eb82:      * Ideally code has a reference to the correct
1:d86eb82:      * ContextManager from another Object, such as a pushed Context.
1:d86eb82:      * 
1:eac0369: 	 * @return ContextManager current Context Manager
1:eac0369: 	 */
1:eac0369: 	public ContextManager getCurrentContextManager() {
1:eac0369: 
1:073b862: 		ThreadLocal<Object> tcl = threadContextList;
1:fb57a7b: 		if (tcl == null) {
1:fb57a7b: 			// The context service is already stopped.
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:fb57a7b: 		Object list = tcl.get();
1:eac0369: 
1:eac0369: 		if (list instanceof ContextManager) {
1:874ccee:             
1:874ccee:             Thread me = Thread.currentThread();
1:eac0369: 			
1:eac0369: 			ContextManager cm = (ContextManager) list;
2:eac0369: 			if (cm.activeThread == me)
2:eac0369: 				return cm;
1:eac0369: 			return null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (list == null)
1:eac0369: 			return null;
1:eac0369: 
1:f9a152b:         return ((ContextManagerStack) list).peek();
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:d86eb82:      * Break the link between the current Thread and the passed
1:d86eb82:      * in ContextManager. Called in a pair with setCurrentContextManager,
1:d86eb82:      * see that method for details.
1:d86eb82:      */
1:eac0369: 	public void resetCurrentContextManager(ContextManager cm) {
1:073b862: 		ThreadLocal<Object> tcl = threadContextList;
1:eac0369: 
1:fb57a7b: 		if (tcl == null) {
1:fb57a7b: 			// The context service is already stopped.
1:fb57a7b: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 			if (Thread.currentThread() != cm.activeThread) {
1:eac0369: 				SanityManager.THROWASSERT("resetCurrentContextManager - mismatch threads - current" + Thread.currentThread() + " - cm's " + cm.activeThread);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (getCurrentContextManager() != cm) {
1:eac0369: 				SanityManager.THROWASSERT("resetCurrentContextManager - mismatch contexts - " + Thread.currentThread());
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (cm.activeCount < -1) {
1:eac0369: 				SanityManager.THROWASSERT("resetCurrentContextManager - invalid count - current" + Thread.currentThread() + " - count " + cm.activeCount);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (cm.activeCount == 0) {
1:eac0369: 				SanityManager.THROWASSERT("resetCurrentContextManager - invalid count - current" + Thread.currentThread() + " - count " + cm.activeCount);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (cm.activeCount > 0) {
1:fb57a7b: 				if (tcl.get() != cm)
1:fb57a7b: 					SanityManager.THROWASSERT("resetCurrentContextManager - invalid thread local " + Thread.currentThread() + " - object " + tcl.get());
1:eac0369: 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (cm.activeCount != -1) {
1:7a8d023: 			if (--cm.activeCount == 0) {
1:eac0369: 				cm.activeThread = null;
1:7a8d023:                 
1:7a8d023:                 // If the ContextManager is empty
1:7a8d023:                 // then don't keep a reference to it
1:7a8d023:                 // when it is not in use. The ContextManager
1:7a8d023:                 // has been closed (most likely) and this
1:7a8d023:                 // is now unwanted. Keeping the reference
1:7a8d023:                 // would hold onto memory and increase the
1:7a8d023:                 // chance of holding onto a another reference
1:7a8d023:                 // will could cause issues for future operations.
1:7a8d023:                 if (cm.isEmpty())
1:7a8d023:                     tcl.set(null);
1:7a8d023:                     
1:7a8d023:             }
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:f9a152b:         ContextManagerStack stack = (ContextManagerStack) tcl.get();
1:eac0369: 
1:f9a152b:         // Remove the context manager at the top of the stack.
1:f9a152b:         stack.pop();
1:eac0369: 
1:f9a152b:         ContextManager nextCM = stack.peek();
1:eac0369: 
1:eac0369: 		boolean seenMultipleCM = false;
1:eac0369: 		boolean seenCM = false;
1:f9a152b:         for (ContextManager stackCM : stack) {
1:eac0369: 
1:eac0369: 			if (stackCM != nextCM)
1:eac0369: 				seenMultipleCM = true;
1:eac0369: 
1:eac0369: 			if (stackCM == cm)
1:eac0369: 				seenCM = true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (!seenCM) {
1:eac0369: 			cm.activeThread = null;
1:eac0369: 			cm.activeCount = 0;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (!seenMultipleCM)
1:eac0369: 		{
1:eac0369: 			// all the context managers on the stack
1:eac0369: 			// are the same so reduce to a simple count.
1:eac0369: 			nextCM.activeCount = stack.size();
1:fb57a7b: 			tcl.set(nextCM);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:874ccee:      * The current thread (passed in a me) is setting associateCM
1:874ccee:      * to be its current context manager. Sets the thread local
1:874ccee:      * variable threadContextList to reflect associateCM being
1:874ccee:      * the current ContextManager.
1:874ccee:      * 
1:874ccee:      * @return True if the nesting level is to be represented in
1:874ccee:      * the ContextManager.activeCount field. False if not.
1:874ccee:      * 
1:874ccee:      * @see ContextManager#activeCount
1:874ccee:      * @see ContextManager#activeThread
1:874ccee:     */
1:eac0369: 	private boolean addToThreadList(Thread me, ContextManager associateCM) {
1:eac0369: 
1:073b862: 		ThreadLocal<Object> tcl = threadContextList;
1:eac0369: 
1:fb57a7b: 		if (tcl == null) {
1:fb57a7b: 			// The context service is already stopped.
1:fb57a7b: 			return false;
1:eac0369: 		}
1:eac0369: 
1:fb57a7b: 		Object list = tcl.get();
1:eac0369: 
1:874ccee:         // Already set up to reflect associateCM ContextManager
1:eac0369: 		if (associateCM == list)
1:eac0369: 			return true;
1:eac0369: 
1:874ccee:         // Not currently using any ContextManager
1:eac0369: 		if (list == null)
1:eac0369: 		{
1:fb57a7b: 			tcl.set(associateCM);
1:eac0369: 			return true;
1:eac0369: 		}
1:874ccee: 
1:f9a152b:         ContextManagerStack stack;
1:eac0369: 		if (list instanceof ContextManager) {
1:eac0369:             
1:874ccee:             // Could be two situations:
1:874ccee:             // 1. Single ContextManager not in use by this thread
1:874ccee:             // 2. Single ContextManager in use by this thread (nested call)
1:874ccee:             
1:eac0369: 			ContextManager threadsCM = (ContextManager) list;
1:eac0369: 			if (me == null)
1:eac0369: 				me = Thread.currentThread();
1:874ccee:             
1:eac0369: 			if (threadsCM.activeThread != me) {
1:874ccee:                 // Not nested, just a CM left over
1:874ccee:                 // from a previous execution.
1:fb57a7b: 				tcl.set(associateCM);
1:eac0369: 				return true;
1:eac0369: 			}
1:874ccee:             
1:874ccee:             // Nested, need to create a Stack of ContextManagers,
1:874ccee:             // the top of the stack will be the active one.
1:f9a152b:             stack = new ContextManagerStack();
1:fb57a7b: 			tcl.set(stack);
1:874ccee:             
1:874ccee:             // The stack represents the true nesting
1:874ccee:             // of ContextManagers, splitting out nesting
1:874ccee:             // of a single ContextManager into multiple
1:874ccee:             // entries in the stack.
1:eac0369: 			for (int i = 0; i < threadsCM.activeCount; i++)
1:eac0369: 			{
1:eac0369: 				stack.push(threadsCM);
1:eac0369: 			}
1:eac0369: 			threadsCM.activeCount = -1;
1:eac0369: 		}
2:eac0369: 		else
1:eac0369: 		{
1:874ccee:             // existing stack, nesting represented
1:874ccee:             // by stack entries, not activeCount.
1:f9a152b:             stack = (ContextManagerStack) list;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		stack.push(associateCM);
1:eac0369: 		associateCM.activeCount = -1;
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 			if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
1:eac0369: 
1:eac0369: 				if (stack.size() > 10)
1:eac0369: 					System.out.println("memoryLeakTrace:ContextService:threadLocal " + stack.size());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:d86eb82:      * Link the current thread to the passed in Contextmanager
1:d86eb82:      * so that a subsequent call to getCurrentContextManager by
1:d86eb82:      * the current Thread will return cm.
1:d86eb82:      * ContextManagers are tied to a Thread while the thread
1:d86eb82:      * is executing Derby code. For example on most JDBC method
1:d86eb82:      * calls the ContextManager backing the Connection object
1:d86eb82:      * is tied to the current Thread at the start of the method
1:d86eb82:      * and reset at the end of the method. Once the Thread
1:d86eb82:      * has completed its Derby work the method resetCurrentContextManager
1:d86eb82:      * must be called with the same ContextManager to break the link.
1:d86eb82:      * Note that a subsquent use of the ContextManager may be on
1:d86eb82:      * a separate Thread, the Thread is only linked to the ContextManager
1:d86eb82:      * between the setCurrentContextManager and resetCurrentContextManager calls.
1:d86eb82:      * <BR>
1:d86eb82:      * ContextService supports nesting of calls by a single Thread, either
1:d86eb82:      * with the same ContextManager or a different ContextManager.
1:d86eb82:      * <UL>
1:d86eb82:      * <LI>The same ContextManager would be pushed during a nested JDBC call in
1:d86eb82:      * a procedure or function.
1:d86eb82:      * <LI>A different ContextManager would be pushed during a call on
1:d86eb82:      * a different embedded JDBC Connection in a procedure or function.
1:d86eb82:      * </UL>
1:eac0369: 	 */
1:eac0369: 	public void setCurrentContextManager(ContextManager cm) {
1:eac0369: 
1:eac0369: 
1:eac0369: 		if (SanityManager.DEBUG) {
2:eac0369: 			Thread me = Thread.currentThread();
1:eac0369: 
1:eac0369: 			if (cm.activeThread != null && me != cm.activeThread) {
1:eac0369: 				SanityManager.THROWASSERT("setCurrentContextManager - mismatch threads - current " + me + " - cm's " + cm.activeThread);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		Thread me = null;
1:eac0369: 
1:eac0369: 		if (cm.activeThread == null) {
1:eac0369: 			cm.activeThread = (me = Thread.currentThread());
1:eac0369: 		}
1:eac0369: 		if (addToThreadList(me, cm))
1:eac0369: 			cm.activeCount++;
1:874ccee:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * It's up to the caller to track this context manager and set it
1:eac0369: 	 * in the context manager list using setCurrentContextManager.
1:eac0369: 	 * We don't keep track of it due to this call being made.
1:eac0369: 	 */
1:eac0369: 	public ContextManager newContextManager()
1:eac0369: 	{
1:eac0369: 		ContextManager cm = new ContextManager(this, errorStream);
1:eac0369: 
1:eac0369: 		// push a context that will shut down the system on
1:eac0369: 		// a severe error.
1:eac0369: 		new SystemContext(cm);
1:eac0369: 
3:eac0369: 		synchronized (this) {
1:eac0369: 			allContexts.add(cm);
1:8a059c4:             
1:eac0369: 			if (SanityManager.DEBUG) {
1:eac0369: 
1:eac0369: 				if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
1:eac0369: 
1:eac0369: 					if (allContexts.size() > 50)
1:eac0369: 						System.out.println("memoryLeakTrace:ContextService:allContexts " + allContexts.size());
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return cm;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public void notifyAllActiveThreads(Context c) {
1:eac0369: 		Thread me = Thread.currentThread();
1:eac0369: 
1:eac0369: 		synchronized (this) {
1:f9a152b:             for (ContextManager cm : allContexts) {
1:eac0369: 
1:eac0369: 				Thread active = cm.activeThread;
1:eac0369: 
1:eac0369: 				if (active == me)
2:eac0369: 					continue;
1:eac0369: 
1:eac0369: 				if (active == null)
1:eac0369: 					continue;
1:eac0369: 
1:6d8a24d:                 final Thread fActive = active;
1:eac0369: 				if (cm.setInterrupted(c))
1:eac0369:                 {
1:636f0a0:                     try {
1:636f0a0:                         AccessController.doPrivileged(
1:636f0a0:                                 new PrivilegedAction<Void>() {
1:636f0a0:                                     public Void run()  {
1:636f0a0:                                         fActive.interrupt();
1:636f0a0:                                         return null;
1:636f0a0:                                     }
1:636f0a0:                                 });
1:636f0a0:                     } catch (java.security.AccessControlException ace) {
1:770bedf:                         // DERBY-6352; if we see an exception here, just
1:770bedf:                         // swallow it, leaving the thread to finish
1:636f0a0:                     }
1:636f0a0:                 }
1:636f0a0: 			}
1:636f0a0: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:8a059c4:      * Remove a ContextManager from the list of all active
1:8a059c4:      * contexts managers.
1:8a059c4:      */
1:8a059c4:     synchronized void removeContext(ContextManager cm)
1:636f0a0:     {
1:8a059c4:         if (allContexts != null)
1:8a059c4:             allContexts.remove( cm);
1:eac0369:     }
1:f9a152b: 
1:f9a152b:     /** Specialized stack class that contains context managers. */
1:f9a152b:     private static class ContextManagerStack extends Stack<ContextManager> {
1:f9a152b:         // The class is empty. Its primary purpose is to allow type-safe casts
1:f9a152b:         // from Object, which are needed because the stacks live in a
1:f9a152b:         // ThreadLocal<Object> rather than ThreadLocal<Stack<ContextManager>>.
1:f9a152b:         // Casts from Object to Stack<ContextManager> will cause an unchecked
1:f9a152b:         // conversion warning, whereas casts from Object to ContextManagerStack
1:f9a152b:         // won't.
1:f9a152b:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:         C1-&gt;C2-&gt;C2-&gt;C1-&gt;C2.
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.security.SecurityUtil;
/////////////////////////////////////////////////////////////////////////
1: 	public static void stop()
1:     {
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1: 	public static ContextService getFactory()
1:     {
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1: 	public static Context getContext(String contextId)
1:     {
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
/////////////////////////////////////////////////////////////////////////
1: 	public static Context getContextOrNull(String contextId)
1:     {
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1:         
commit:073b862
/////////////////////////////////////////////////////////////////////////
1: 	private ThreadLocal<Object> threadContextList = new ThreadLocal<Object>();
/////////////////////////////////////////////////////////////////////////
1: 	private HashSet<ContextManager> allContexts;
/////////////////////////////////////////////////////////////////////////
1: 		allContexts = new HashSet<ContextManager>();
/////////////////////////////////////////////////////////////////////////
1: 		ThreadLocal<Object> tcl = threadContextList;
/////////////////////////////////////////////////////////////////////////
1: 		ThreadLocal<Object> tcl = threadContextList;
/////////////////////////////////////////////////////////////////////////
0:     @SuppressWarnings("unchecked")
1: 		ThreadLocal<Object> tcl = threadContextList;
/////////////////////////////////////////////////////////////////////////
0:  		java.util.Stack<ContextManager> stack;
/////////////////////////////////////////////////////////////////////////
0: 			stack = new java.util.Stack<ContextManager>();
/////////////////////////////////////////////////////////////////////////
0: 			stack = (java.util.Stack<ContextManager>) list;
/////////////////////////////////////////////////////////////////////////
0: 			for (Iterator<ContextManager> i = allContexts.iterator(); i.hasNext(); ) {
0: 				ContextManager cm = i.next();
/////////////////////////////////////////////////////////////////////////
0:                             new PrivilegedAction<Object>() {
commit:6baf18b
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:4b58cc0
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.error.ShutdownException;
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:770bedf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                         // DERBY-6352; if we see an exception here, just
1:                         // swallow it, leaving the thread to finish
commit:636f0a0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
/////////////////////////////////////////////////////////////////////////
0:                     // DERBY-6352; in some cases a SecurityException is seen
0:                     // demanding an explicit granting of modifyThread 
0:                     // permission, which should not be needed for Derby, as we
0:                     // should not have any system threads.
1:                     try {
1:                         AccessController.doPrivileged(
1:                                 new PrivilegedAction<Void>() {
1:                                     public Void run()  {
1:                                         fActive.interrupt();
1:                                         return null;
1:                                     }
1:                                 });
1:                     } catch (java.security.AccessControlException ace) {
0:                         // if sane, ASSERT and stop. The Assert will 
0:                         // cause info on all current threads to be printed to
0:                         // the console, and we're also adding details about 
0:                         // the thread causing the security exception.
0:                         // if insane, rethrow, and if an IBM JVM, do a jvmdump
0:                         if (SanityManager.DEBUG)
1:                         {
0:                             SanityManager.THROWASSERT("unexpectedly needing " +
0:                                     "an extra permission, for thread: " +
0:                                     fActive.getName() + " with state: "+ 
0:                                     fActive.getState());
0:                             ace.printStackTrace();
1:                         }
0:                         else {
0:                             if (JVMInfo.isIBMJVM()) {
0:                                 JVMInfo.javaDump();
1:                             }
0:                             throw ace;
1:                         }
1:                     }
commit:1a36302
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.util.HashSet;
0: import java.util.Iterator;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f9a152b
/////////////////////////////////////////////////////////////////////////
1: import java.util.Stack;
/////////////////////////////////////////////////////////////////////////
1:         <LI> ContextManagerStack containing ContextManagers - the current
1:         set to -1. This is because nesting is solely represented by
/////////////////////////////////////////////////////////////////////////
1:         Single thread for Connection execution.
/////////////////////////////////////////////////////////////////////////
1:         return ((ContextManagerStack) list).peek();
/////////////////////////////////////////////////////////////////////////
1:         ContextManagerStack stack = (ContextManagerStack) tcl.get();
1:         // Remove the context manager at the top of the stack.
1:         stack.pop();
1:         ContextManager nextCM = stack.peek();
1:         for (ContextManager stackCM : stack) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         ContextManagerStack stack;
/////////////////////////////////////////////////////////////////////////
1:             stack = new ContextManagerStack();
/////////////////////////////////////////////////////////////////////////
1:             stack = (ContextManagerStack) list;
/////////////////////////////////////////////////////////////////////////
1:             for (ContextManager cm : allContexts) {
/////////////////////////////////////////////////////////////////////////
0:                             new PrivilegedAction<Void>() {
0:                                 public Void run()  {
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Specialized stack class that contains context managers. */
1:     private static class ContextManagerStack extends Stack<ContextManager> {
1:         // The class is empty. Its primary purpose is to allow type-safe casts
1:         // from Object, which are needed because the stacks live in a
1:         // ThreadLocal<Object> rather than ThreadLocal<Stack<ContextManager>>.
1:         // Casts from Object to Stack<ContextManager> will cause an unchecked
1:         // conversion warning, whereas casts from Object to ContextManagerStack
1:         // won't.
1:     }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7132626
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.error.ShutdownException;
commit:7a8d023
/////////////////////////////////////////////////////////////////////////
1: 			if (--cm.activeCount == 0) {
1:                 
1:                 // If the ContextManager is empty
1:                 // then don't keep a reference to it
1:                 // when it is not in use. The ContextManager
1:                 // has been closed (most likely) and this
1:                 // is now unwanted. Keeping the reference
1:                 // would hold onto memory and increase the
1:                 // chance of holding onto a another reference
1:                 // will could cause issues for future operations.
1:                 if (cm.isEmpty())
1:                     tcl.set(null);
1:                     
1:             }
commit:8a059c4
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Collection of all ContextManagers that are open
1:      * in the complete Derby system. A ContextManager is
1:      * added when it is created with newContextManager and
1:      * removed when the session is closed.
1:      * 
1:      * @see #newContextManager()
1:      * @see SystemContext#cleanupOnError(Throwable)
1:      */
1:     /**
1:      * Create a new ContextService for a Derby system.
1:      * Only a single system is active at any time.
1:      *
1:      */
/////////////////////////////////////////////////////////////////////////
1:         ContextService fact = ContextService.factory;
1:         if (fact != null) {
1:             synchronized (fact) {
1:                 fact.allContexts = null;
1:                 fact.threadContextList = null;
1:                 ContextService.factory = null;
1:             }
1:         }
/////////////////////////////////////////////////////////////////////////
1:             
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Remove a ContextManager from the list of all active
1:      * contexts managers.
1:      */
1:     synchronized void removeContext(ContextManager cm)
1:         if (allContexts != null)
1:             allContexts.remove( cm);
commit:874ccee
/////////////////////////////////////////////////////////////////////////
1: 		<LI> ContextManager - the current thread has used or is using
1:             this context manager. If ContextManager.activeThread equals
1:             the current thread then the thread is currently active with
1:             the ContextManager. In this case ContextManager.activeCount
1:             will be greater than zero and represent the level of nested
1:             setCurrentContextmanager calls.
1:             If ContextManager.activeThread is null then no other thread
1:             is using the Contextmanager, if ContextManager.activeThread
1:             is not-null and not equal to the current thread then some
1:             other thread is using the context. It is assumed that
1:             only a single thread can be using a ContextManager at any time
1:             and this is enforced by synchronization outside the ContextManager.
1:             E.g for JDBC connections, synchronization at the JDBC level.
0: 		<LI> java.util.Stack containing ContextManagers - the current
1:         thread is actively using multiple different ContextManagers,
1:         with nesting. All ContextManagers in the stack will have
1:         activeThread set to the current thread, and their activeCount
0:         set to -1. This is beacause nesting is soley represented by
1:         the stack, with the current context manager on top of the stack.
1:         This supports multiple levels of nesting across two stacks, e.g.
0:         C1->C2->C2->C1->C2.
/////////////////////////////////////////////////////////////////////////
1: 		from a server side method) then threadContextList will contain a Stack. The value for each cm
/////////////////////////////////////////////////////////////////////////
1: 		for the lifetime of the request. In this case this variable will contain a  WeakReference.
1:         <BR>
0:         Single thread for Connection exection.
1:         <pre>
1:         threadContextList.get() == cm
1:         // while in JDBC engine code
1:         cm.activeThread == Thread.currentThread();
1:         cm.activeCount = 1;
1:         </pre>
1:         
1:         <BR>
1:         J2EE single thread for lifetime of execution.
1:         <pre>
1:         // thread executing request
1:          threadContextList.get() == cm
1:         // while in JDBC engine code
1:         cm.activeThread == Thread.currentThread();
1:         cm.activeCount = 1;
1:         
1:         // other threads that have recently executed
1:         // the same connection can have
1:         threadContextList.get() == cm
1:         cm.activeThread != Thread.currentThread();
1:        </pre>
1:         
1:         <BR>
1:         Nested routine calls within single connection
1:         <pre>
1:         threadContextList.get() == cm
1:         // Within server-side JDBC code in a
1:         // function called from another function/procedure
1:         // called from an applications's statement
1:         // (three levels of nesting)
1:         cm.activeThread == Thread.currentThread();
1:         cm.activeCount = 3;         
1:         </pre>
1:         
1:         <BR>
1:         Nested routine calls with the inner routine
1:         using a different connection to access a Derby database.
1:         Note nesting of orignal Contextmanager cm is changed
1:         from an activeCount of 2 to nesting within the stack
1:         once multiple ContextManagers are involved.
1:         <pre>
1:         threadContextList.get() == stack {cm2,cm,cm}
1:         cm.activeThread == Thread.currentThread();
1:         cm.activeCount = -1; // nesting in stack
1:         cm2.activeThread == Thread.currentThread();
1:         cm2.activeCount = -1; // nesting in stack
1:         </pre> 
1:         
1:         <BR>
1:         Nested multiple ContextManagers, the code supports
1:         this, though it may not be possible currently
1:         to have a stack like this from SQL/JDBC.
1:         <pre>
1:         threadContextList.get() == stack {cm3,cm2,cm,cm2,cm,cm}
1:         cm.activeThread == Thread.currentThread();
1:         cm.activeCount = -1; // nesting in stack
1:         cm2.activeThread == Thread.currentThread();
1:         cm2.activeCount = -1; // nesting in stack
1:         cm3.activeThread == Thread.currentThread();
1:         cm3.activeCount = -1; // nesting in stack
1:         </pre>   
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             
1:             Thread me = Thread.currentThread();
/////////////////////////////////////////////////////////////////////////
1: 	}
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * The current thread (passed in a me) is setting associateCM
1:      * to be its current context manager. Sets the thread local
1:      * variable threadContextList to reflect associateCM being
1:      * the current ContextManager.
1:      * 
1:      * @return True if the nesting level is to be represented in
1:      * the ContextManager.activeCount field. False if not.
1:      * 
1:      * @see ContextManager#activeCount
1:      * @see ContextManager#activeThread
1:     */
/////////////////////////////////////////////////////////////////////////
1:         // Already set up to reflect associateCM ContextManager
1:         // Not currently using any ContextManager
0:  		java.util.Stack stack;
1:             
1:             // Could be two situations:
1:             // 1. Single ContextManager not in use by this thread
1:             // 2. Single ContextManager in use by this thread (nested call)
1:             
1:             
1:                 // Not nested, just a CM left over
1:                 // from a previous execution.
1:             
1:             // Nested, need to create a Stack of ContextManagers,
1:             // the top of the stack will be the active one.
1:             
1:             // The stack represents the true nesting
1:             // of ContextManagers, splitting out nesting
1:             // of a single ContextManager into multiple
1:             // entries in the stack.
/////////////////////////////////////////////////////////////////////////
1:             // existing stack, nesting represented
1:             // by stack entries, not activeCount.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     }
/////////////////////////////////////////////////////////////////////////
commit:d86eb82
/////////////////////////////////////////////////////////////////////////
1: 	 * Get current Context Manager linked to the current Thread.
1:      * See setCurrentContextManager for details.
1:      * Note that this call can be expensive and is only
1:      * intended to be used in "stateless" situations.
1:      * Ideally code has a reference to the correct
1:      * ContextManager from another Object, such as a pushed Context.
1:      * 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Break the link between the current Thread and the passed
1:      * in ContextManager. Called in a pair with setCurrentContextManager,
1:      * see that method for details.
1:      */
/////////////////////////////////////////////////////////////////////////
1:      * Link the current thread to the passed in Contextmanager
1:      * so that a subsequent call to getCurrentContextManager by
1:      * the current Thread will return cm.
1:      * ContextManagers are tied to a Thread while the thread
1:      * is executing Derby code. For example on most JDBC method
1:      * calls the ContextManager backing the Connection object
1:      * is tied to the current Thread at the start of the method
1:      * and reset at the end of the method. Once the Thread
1:      * has completed its Derby work the method resetCurrentContextManager
1:      * must be called with the same ContextManager to break the link.
1:      * Note that a subsquent use of the ContextManager may be on
1:      * a separate Thread, the Thread is only linked to the ContextManager
1:      * between the setCurrentContextManager and resetCurrentContextManager calls.
1:      * <BR>
1:      * ContextService supports nesting of calls by a single Thread, either
1:      * with the same ContextManager or a different ContextManager.
1:      * <UL>
1:      * <LI>The same ContextManager would be pushed during a nested JDBC call in
1:      * a procedure or function.
1:      * <LI>A different ContextManager would be pushed during a call on
1:      * a different embedded JDBC Connection in a procedure or function.
1:      * </UL>
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.services.context.ContextService
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.context
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.services.context;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
1: 
0: import java.util.Hashtable;
0: import java.util.Enumeration;
1: 
0: import java.util.HashSet;
0: import java.util.Iterator;
1: 
1: /**
1: 	A set of static methods to supply easier access to contexts.
1: */
1: public final class ContextService //OLD extends Hashtable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private static ContextService factory;
1: 	private HeaderPrintWriter errorStream;
1: 
1: 	/**
1: 		Maintains a list of all the contexts that this thread has created
1: 		and/or used. The object stored in the thread local varys according
1: 		how this thread has been used and will be one of:
1: 
1: 		<UL>
1: 		<LI> null - the thread no affiliation with a context manager.
1: 
0: 		<LI> ContextManager - the thread created and possibly was used to execute this context manager.
0: 			This is a strong reference as it can be disassociated from the thread when the context is closed.
1: 
0: 		<LI> WeakReference containing a ContextManager - the thread was used to execute this context manager.
0: 			This is a weak reference to allow the context to be closed and garbage collected without having
0: 			to track every single thread that used it or having to modify this list when resetting the current
0: 			context manager.
1: 
0: 		<LI> WeakHashMap (key = ContextManager, value = Integer) - the thread has created and possibly executed any number of context managers.
1: 		</UL>
1: 
1: 		This thread local is used to find the current context manager. Basically it provides
1: 		fast access to a list of candidate contexts. If one of the contexts has its activeThread
1: 		equal to the current thread then it is the current context manager.
1: 
0: 		If the thread has pushed multiple contexts (e.g. open a new non-nested Cloudscape connection
0: 		from a server side method) then threadContextList will contain a WeakHashMap. The value for each cm
1: 		will be a push order, with higher numbers being more recently pushed.
1: 
1: 		To support the case where a single context manager is pushed twice (nested connection),
1: 		the context manager keeps track of the number of times it has been pushed (set). Note that
1: 		our synchronization requires that a single context can only be accessed by a single thread at a time.
1: 		In the JDBC layer this is enforced by the synchronization on the connection object.
1: 
1: 		<P>
1: 		There are two cases we are trying to optimise.
1: 		<UL>
1: 		<LI> Typical JDBC client program where there a Connection is always executed using a single thread.
1: 			In this case this variable will contain the Connection's context manager 
1: 		<LI> Typical application server pooled connection where a single thread may use a connection from a pool
0: 		for the lifetime of the request. In this case this varibale will contain a  WeakReference.
1: 		</UL>
1: 		
1: 
0: 		Need to support
0: 			CM1					OPTIMIZE
0: 			CM1,CM1				OPTIMIZE
0: 			CM1,CM1,CM1,CM1		OPTIMIZE
0: 			CM1,CM1,CM2
0: 			CM1,CM2,CM1,CM2
0: 			CM1,CM2,CM3,CM1
0: 			etc.
1: 
1: 
0: 			STACK for last 3
1: 	*/
1: 
0: 	final ThreadLocal	threadContextList = new ThreadLocal();
1: 
0: 	private final HashSet allContexts;
1: 
0: 	// don't want any instances
1: 	public ContextService() {
1: 
1: 		// find the error stream
1: 		errorStream = Monitor.getStream();		
1: 
1: 		ContextService.factory = this;
1: 
0: 		allContexts = new HashSet();
1: 
1: 	}
1: 
1: 	/**
1: 		So it can be given to us and taken away...
1: 	 */
0: 	public static void stop() {
0: 		ContextService.factory = null;
1: 	}
1: 
0: 	public static ContextService getFactory() {
1: 		ContextService csf = factory;
1: 
1: 		if (csf == null)
1: 			throw new ShutdownException();
1: 		return csf;
1: 	}
1: 	/**
1: 		Find the context with the given name in the context service factory
1: 		loaded for the system.
1: 
1: 		@return The requested context, null if it doesn't exist.
1: 	*/
0: 	public static Context getContext(String contextId) {
1: 
1: 		ContextManager cm = getFactory().getCurrentContextManager();
1: 
1:         if( cm == null)
1:             return null;
1:         
1: 		return cm.getContext(contextId);
1: 	}
1: 
1: 	/**
1: 		Find the context with the given name in the context service factory
1: 		loaded for the system.
1: 
1: 		This version will not do any debug checking, but return null
1: 		quietly if it runs into any problems.
1: 
1: 		@return The requested context, null if it doesn't exist.
1: 	*/
0: 	public static Context getContextOrNull(String contextId) {
1: 		ContextService csf = factory;
1: 
1: 		if (csf == null)
1: 			return null;
1: 		
1: 		ContextManager cm = csf.getCurrentContextManager();
1: 
1: 		if (cm == null)
1: 			return null;
1: 
1: 		return cm.getContext(contextId);
1: 	}
1: 
1: 
1: 	/**
0: 	 * Get current Context Manager
1: 	 * @return ContextManager current Context Manager
1: 	 */
1: 	public ContextManager getCurrentContextManager() {
1: 
1: 		Thread me = Thread.currentThread();
1: 
0: 		Object list = threadContextList.get();
1: 
1: 		if (list instanceof ContextManager) {
1: 			
1: 			ContextManager cm = (ContextManager) list;
1: 			if (cm.activeThread == me)
1: 				return cm;
1: 			return null;
1: 		}
1: 
1: 		if (list == null)
1: 			return null;
1: 
0: 		java.util.Stack stack = (java.util.Stack) list;
0: 		return (ContextManager) (stack.peek());
1: 
1: 
0: 	//	if (list == null)
0: 	//		return null;
1: 
0: 		/*		Thread me = Thread.currentThread();
1: 		
1: 		synchronized (this) {
0: 			for (Iterator i = allContexts.iterator(); i.hasNext(); ) {
1: 
0: 				ContextManager cm = (ContextManager) i.next();
1: 				if (cm.activeThread == me)
1: 					return cm;
1: 			}
1: 		}
0: 		//OLDreturn (ContextManager) get(me);
1: 		return null;
0: */	}
1: 
1: 	public void resetCurrentContextManager(ContextManager cm) {
1: 		if (SanityManager.DEBUG) {
1: 
1: 			if (Thread.currentThread() != cm.activeThread) {
1: 				SanityManager.THROWASSERT("resetCurrentContextManager - mismatch threads - current" + Thread.currentThread() + " - cm's " + cm.activeThread);
1: 			}
1: 
1: 			if (getCurrentContextManager() != cm) {
1: 				SanityManager.THROWASSERT("resetCurrentContextManager - mismatch contexts - " + Thread.currentThread());
1: 			}
1: 
1: 			if (cm.activeCount < -1) {
1: 				SanityManager.THROWASSERT("resetCurrentContextManager - invalid count - current" + Thread.currentThread() + " - count " + cm.activeCount);
1: 			}
1: 
1: 			if (cm.activeCount == 0) {
1: 				SanityManager.THROWASSERT("resetCurrentContextManager - invalid count - current" + Thread.currentThread() + " - count " + cm.activeCount);
1: 			}
1: 
1: 			if (cm.activeCount > 0) {
0: 				if (threadContextList.get() != cm)
0: 					SanityManager.THROWASSERT("resetCurrentContextManager - invalid thread local " + Thread.currentThread() + " - object " + threadContextList.get());
1: 
1: 			}
1: 		}
1: 
1: 		if (cm.activeCount != -1) {
0: 			if (--cm.activeCount == 0)
1: 				cm.activeThread = null;
1: 			return;
1: 		}
1: 
0: 		java.util.Stack stack = (java.util.Stack) threadContextList.get();
1: 
0: 		Object oldCM = stack.pop();
1: 
0: 		ContextManager nextCM = (ContextManager) stack.peek();
1: 
1: 		boolean seenMultipleCM = false;
1: 		boolean seenCM = false;
0: 		for (int i = 0; i < stack.size(); i++) {
1: 
0: 			Object stackCM = stack.elementAt(i);
1: 			if (stackCM != nextCM)
1: 				seenMultipleCM = true;
1: 
1: 			if (stackCM == cm)
1: 				seenCM = true;
1: 		}
1: 
1: 		if (!seenCM) {
1: 			cm.activeThread = null;
1: 			cm.activeCount = 0;
1: 		}
1: 
1: 		if (!seenMultipleCM)
1: 		{
1: 			// all the context managers on the stack
1: 			// are the same so reduce to a simple count.
1: 			nextCM.activeCount = stack.size();
0: 			threadContextList.set(nextCM);
1: 		}
1: 	}
1: 
1: 	private boolean addToThreadList(Thread me, ContextManager associateCM) {
1: 
0: 		Object list = threadContextList.get();
1: 
1: 		if (associateCM == list)
1: 			return true;
1: 
1: 		if (list == null)
1: 		{
0: 			threadContextList.set(associateCM);
1: 			return true;
1: 		}
1: 
0: 		java.util.Stack stack;
1: 		if (list instanceof ContextManager) {
1: 			ContextManager threadsCM = (ContextManager) list;
1: 			if (me == null)
1: 				me = Thread.currentThread();
1: 			if (threadsCM.activeThread != me) {
0: 				threadContextList.set(associateCM);
1: 				return true;
1: 			}
0: 			stack = new java.util.Stack();
0: 			threadContextList.set(stack);
1: 
1: 			for (int i = 0; i < threadsCM.activeCount; i++)
1: 			{
1: 				stack.push(threadsCM);
1: 			}
1: 			threadsCM.activeCount = -1;
1: 		}
1: 		else
1: 		{
0: 			stack = (java.util.Stack) list;
1: 		}
1: 
1: 		stack.push(associateCM);
1: 		associateCM.activeCount = -1;
1: 
1: 		if (SanityManager.DEBUG) {
1: 
1: 			if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
1: 
1: 				if (stack.size() > 10)
1: 					System.out.println("memoryLeakTrace:ContextService:threadLocal " + stack.size());
1: 			}
1: 		}
1: 
1: 		return false;
1: 	}
1: 
1: 	/**
1: 	 */
1: 	public void setCurrentContextManager(ContextManager cm) {
1: 
1: 
1: 		if (SanityManager.DEBUG) {
1: 			Thread me = Thread.currentThread();
1: 
1: 			if (cm.activeThread != null && me != cm.activeThread) {
1: 				SanityManager.THROWASSERT("setCurrentContextManager - mismatch threads - current " + me + " - cm's " + cm.activeThread);
1: 			}
1: 
0: /*			if ((cm.activeCount <0) || (cm.activeThread == null && cm.activeCount != 0) || (cm.activeThread != null && cm.activeCount == 0)) {
0: 				SanityManager.THROWASSERT("resetCurrentContextManager - invalid count - owner " + cm.activeThread + " - count " + cm.activeCount);
1: 			}
1: */
1: 		}
1: 
1: 		Thread me = null;
1: 
1: 		if (cm.activeThread == null) {
1: 			cm.activeThread = (me = Thread.currentThread());
1: 		}
1: 		if (addToThreadList(me, cm))
1: 			cm.activeCount++;
1: 
0: /*OLD
1: 		if (cm == null)
0: 			// don't bother storing it if it is null
0: 			remove(me);
1: 		else
0: 			put(me, cm);
0: */	}
1: 
1: 	/**
1: 	 * It's up to the caller to track this context manager and set it
1: 	 * in the context manager list using setCurrentContextManager.
1: 	 * We don't keep track of it due to this call being made.
1: 	 */
1: 	public ContextManager newContextManager()
1: 	{
1: 		ContextManager cm = new ContextManager(this, errorStream);
1: 
1: 		// push a context that will shut down the system on
1: 		// a severe error.
1: 		new SystemContext(cm);
1: 
1: 		synchronized (this) {
1: 			allContexts.add(cm);
1: 
1: 			if (SanityManager.DEBUG) {
1: 
1: 				if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
1: 
1: 					if (allContexts.size() > 50)
1: 						System.out.println("memoryLeakTrace:ContextService:allContexts " + allContexts.size());
1: 				}
1: 			}
1: 		}
1: 
1: 		return cm;
1: 	}
1: 
1: 	public void notifyAllActiveThreads(Context c) {
1: 		Thread me = Thread.currentThread();
1: 
1: 		synchronized (this) {
0: 			for (Iterator i = allContexts.iterator(); i.hasNext(); ) {
1: 
0: 				ContextManager cm = (ContextManager) i.next();
1: 
1: 				Thread active = cm.activeThread;
1: 
1: 				if (active == me)
1: 					continue;
1: 
1: 				if (active == null)
1: 					continue;
1: 
1: 				if (cm.setInterrupted(c))
0: 					active.interrupt();
1: 			}
1: 		}
1: 
1: /*
1: 		synchronized (this) {
0: 			for (Enumeration e = keys(); e.hasMoreElements(); ) {
0: 				Thread t = (Thread) e.nextElement();
0: 				if (t == me)
1: 					continue;
1: 
0: 				ContextManager him = (ContextManager) get(t);
1: 
0: 				if (him.setInterrupted(c))
0: 					t.interrupt();
1: 			}
0: 		} */
1: 	}
1: 
0:     synchronized void removeContext( ContextManager cm)
1:     {
0:         allContexts.remove( cm);
1:     }
1: }
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6d8a24d
/////////////////////////////////////////////////////////////////////////
0: import java.security.AccessController;
0: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1:                 final Thread fActive = active;
0:                 {
0:                     AccessController.doPrivileged(
0:                             new PrivilegedAction() {
0:                                 public Object run()  {
0:                                     fActive.interrupt();
0:                                     return null;
0:                                 }
0:                             });
0:                 }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 		If the thread has pushed multiple contexts (e.g. open a new non-nested Derby connection
author:Bernt Johnsen
-------------------------------------------------------------------------------
commit:fb57a7b
/////////////////////////////////////////////////////////////////////////
0: 		ThreadLocal tcl = threadContextList;
1: 		if (tcl == null) {
1: 			// The context service is already stopped.
0: 			return null;
0: 		}
0: 
1: 		Object list = tcl.get();
/////////////////////////////////////////////////////////////////////////
0: 		ThreadLocal tcl = threadContextList;
0: 
1: 		if (tcl == null) {
1: 			// The context service is already stopped.
1: 			return;
0: 		}
0: 
/////////////////////////////////////////////////////////////////////////
1: 				if (tcl.get() != cm)
1: 					SanityManager.THROWASSERT("resetCurrentContextManager - invalid thread local " + Thread.currentThread() + " - object " + tcl.get());
/////////////////////////////////////////////////////////////////////////
0: 		java.util.Stack stack = (java.util.Stack) tcl.get();
/////////////////////////////////////////////////////////////////////////
1: 			tcl.set(nextCM);
0: 		ThreadLocal tcl = threadContextList;
0: 
1: 		if (tcl == null) {
1: 			// The context service is already stopped.
1: 			return false;
0: 		}
0: 
1: 		Object list = tcl.get();
1: 			tcl.set(associateCM);
/////////////////////////////////////////////////////////////////////////
1: 				tcl.set(associateCM);
1: 			tcl.set(stack);
commit:896f574
/////////////////////////////////////////////////////////////////////////
0: 	private ThreadLocal threadContextList = new ThreadLocal();
0: 	private HashSet allContexts;
/////////////////////////////////////////////////////////////////////////
1: 		// For some unknown reason, the ContextManager and
1: 		// ContextService objects will not be garbage collected
1: 		// without the next two lines.
0: 		factory.allContexts = null;
0: 		factory.threadContextList = null;
0: 
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.services.context
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.services.context;
0: 
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
0: 
0: import java.util.Hashtable;
0: import java.util.Enumeration;
0: 
0: import java.util.HashSet;
0: import java.util.Iterator;
0: 
0: /**
0: 	A set of static methods to supply easier access to contexts.
0: */
0: public final class ContextService //OLD extends Hashtable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private static ContextService factory;
0: 	private HeaderPrintWriter errorStream;
0: 
0: 	/**
0: 		Maintains a list of all the contexts that this thread has created
0: 		and/or used. The object stored in the thread local varys according
0: 		how this thread has been used and will be one of:
0: 
0: 		<UL>
0: 		<LI> null - the thread no affiliation with a context manager.
0: 
0: 		<LI> ContextManager - the thread created and possibly was used to execute this context manager.
0: 			This is a strong reference as it can be disassociated from the thread when the context is closed.
0: 
0: 		<LI> WeakReference containing a ContextManager - the thread was used to execute this context manager.
0: 			This is a weak reference to allow the context to be closed and garbage collected without having
0: 			to track every single thread that used it or having to modify this list when resetting the current
0: 			context manager.
0: 
0: 		<LI> WeakHashMap (key = ContextManager, value = Integer) - the thread has created and possibly executed any number of context managers.
0: 		</UL>
0: 
0: 		This thread local is used to find the current context manager. Basically it provides
0: 		fast access to a list of candidate contexts. If one of the contexts has its activeThread
0: 		equal to the current thread then it is the current context manager.
0: 
0: 		If the thread has pushed multiple contexts (e.g. open a new non-nested Cloudscape connection
0: 		from a server side method) then threadContextList will contain a WeakHashMap. The value for each cm
0: 		will be a push order, with higher numbers being more recently pushed.
0: 
0: 		To support the case where a single context manager is pushed twice (nested connection),
0: 		the context manager keeps track of the number of times it has been pushed (set). Note that
0: 		our synchronization requires that a single context can only be accessed by a single thread at a time.
0: 		In the JDBC layer this is enforced by the synchronization on the connection object.
0: 
0: 		<P>
0: 		There are two cases we are trying to optimise.
0: 		<UL>
0: 		<LI> Typical JDBC client program where there a Connection is always executed using a single thread.
0: 			In this case this variable will contain the Connection's context manager 
0: 		<LI> Typical application server pooled connection where a single thread may use a connection from a pool
0: 		for the lifetime of the request. In this case this varibale will contain a  WeakReference.
0: 		</UL>
0: 		
0: 
0: 		Need to support
0: 			CM1					OPTIMIZE
0: 			CM1,CM1				OPTIMIZE
0: 			CM1,CM1,CM1,CM1		OPTIMIZE
0: 			CM1,CM1,CM2
0: 			CM1,CM2,CM1,CM2
0: 			CM1,CM2,CM3,CM1
0: 			etc.
0: 
0: 
0: 			STACK for last 3
0: 	*/
0: 
0: 	final ThreadLocal	threadContextList = new ThreadLocal();
0: 
0: 	private final HashSet allContexts;
0: 
0: 	// don't want any instances
0: 	public ContextService() {
0: 
0: 		// find the error stream
0: 		errorStream = Monitor.getStream();		
0: 
0: 		ContextService.factory = this;
0: 
0: 		allContexts = new HashSet();
0: 
0: 	}
0: 
0: 	/**
0: 		So it can be given to us and taken away...
0: 	 */
0: 	public static void stop() {
0: 		ContextService.factory = null;
0: 	}
0: 
0: 	public static ContextService getFactory() {
0: 		ContextService csf = factory;
0: 
0: 		if (csf == null)
0: 			throw new ShutdownException();
0: 		return csf;
0: 	}
0: 	/**
0: 		Find the context with the given name in the context service factory
0: 		loaded for the system.
0: 
0: 		@return The requested context, null if it doesn't exist.
0: 	*/
0: 	public static Context getContext(String contextId) {
0: 
0: 		ContextManager cm = getFactory().getCurrentContextManager();
0: 
0:         if( cm == null)
0:             return null;
0:         
0: 		return cm.getContext(contextId);
0: 	}
0: 
0: 	/**
0: 		Find the context with the given name in the context service factory
0: 		loaded for the system.
0: 
0: 		This version will not do any debug checking, but return null
0: 		quietly if it runs into any problems.
0: 
0: 		@return The requested context, null if it doesn't exist.
0: 	*/
0: 	public static Context getContextOrNull(String contextId) {
0: 		ContextService csf = factory;
0: 
0: 		if (csf == null)
0: 			return null;
0: 		
0: 		ContextManager cm = csf.getCurrentContextManager();
0: 
0: 		if (cm == null)
0: 			return null;
0: 
0: 		return cm.getContext(contextId);
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get current Context Manager
0: 	 * @return ContextManager current Context Manager
0: 	 */
0: 	public ContextManager getCurrentContextManager() {
0: 
0: 		Thread me = Thread.currentThread();
0: 
0: 		Object list = threadContextList.get();
0: 
0: 		if (list instanceof ContextManager) {
0: 			
0: 			ContextManager cm = (ContextManager) list;
0: 			if (cm.activeThread == me)
0: 				return cm;
0: 			return null;
0: 		}
0: 
0: 		if (list == null)
0: 			return null;
0: 
0: 		java.util.Stack stack = (java.util.Stack) list;
0: 		return (ContextManager) (stack.peek());
0: 
0: 
0: 	//	if (list == null)
0: 	//		return null;
0: 
0: 		/*		Thread me = Thread.currentThread();
0: 		
0: 		synchronized (this) {
0: 			for (Iterator i = allContexts.iterator(); i.hasNext(); ) {
0: 
0: 				ContextManager cm = (ContextManager) i.next();
0: 				if (cm.activeThread == me)
0: 					return cm;
0: 			}
0: 		}
0: 		//OLDreturn (ContextManager) get(me);
0: 		return null;
0: */	}
0: 
0: 	public void resetCurrentContextManager(ContextManager cm) {
0: 		if (SanityManager.DEBUG) {
0: 
0: 			if (Thread.currentThread() != cm.activeThread) {
0: 				SanityManager.THROWASSERT("resetCurrentContextManager - mismatch threads - current" + Thread.currentThread() + " - cm's " + cm.activeThread);
0: 			}
0: 
0: 			if (getCurrentContextManager() != cm) {
0: 				SanityManager.THROWASSERT("resetCurrentContextManager - mismatch contexts - " + Thread.currentThread());
0: 			}
0: 
0: 			if (cm.activeCount < -1) {
0: 				SanityManager.THROWASSERT("resetCurrentContextManager - invalid count - current" + Thread.currentThread() + " - count " + cm.activeCount);
0: 			}
0: 
0: 			if (cm.activeCount == 0) {
0: 				SanityManager.THROWASSERT("resetCurrentContextManager - invalid count - current" + Thread.currentThread() + " - count " + cm.activeCount);
0: 			}
0: 
0: 			if (cm.activeCount > 0) {
0: 				if (threadContextList.get() != cm)
0: 					SanityManager.THROWASSERT("resetCurrentContextManager - invalid thread local " + Thread.currentThread() + " - object " + threadContextList.get());
0: 
0: 			}
0: 		}
0: 
0: 		if (cm.activeCount != -1) {
0: 			if (--cm.activeCount == 0)
0: 				cm.activeThread = null;
0: 			return;
0: 		}
0: 
0: 		java.util.Stack stack = (java.util.Stack) threadContextList.get();
0: 
0: 		Object oldCM = stack.pop();
0: 
0: 		ContextManager nextCM = (ContextManager) stack.peek();
0: 
0: 		boolean seenMultipleCM = false;
0: 		boolean seenCM = false;
0: 		for (int i = 0; i < stack.size(); i++) {
0: 
0: 			Object stackCM = stack.elementAt(i);
0: 			if (stackCM != nextCM)
0: 				seenMultipleCM = true;
0: 
0: 			if (stackCM == cm)
0: 				seenCM = true;
0: 		}
0: 
0: 		if (!seenCM) {
0: 			cm.activeThread = null;
0: 			cm.activeCount = 0;
0: 		}
0: 
0: 		if (!seenMultipleCM)
0: 		{
0: 			// all the context managers on the stack
0: 			// are the same so reduce to a simple count.
0: 			nextCM.activeCount = stack.size();
0: 			threadContextList.set(nextCM);
0: 		}
0: 	}
0: 
0: 	private boolean addToThreadList(Thread me, ContextManager associateCM) {
0: 
0: 		Object list = threadContextList.get();
0: 
0: 		if (associateCM == list)
0: 			return true;
0: 
0: 		if (list == null)
0: 		{
0: 			threadContextList.set(associateCM);
0: 			return true;
0: 		}
0: 
0: 		java.util.Stack stack;
0: 		if (list instanceof ContextManager) {
0: 			ContextManager threadsCM = (ContextManager) list;
0: 			if (me == null)
0: 				me = Thread.currentThread();
0: 			if (threadsCM.activeThread != me) {
0: 				threadContextList.set(associateCM);
0: 				return true;
0: 			}
0: 			stack = new java.util.Stack();
0: 			threadContextList.set(stack);
0: 
0: 			for (int i = 0; i < threadsCM.activeCount; i++)
0: 			{
0: 				stack.push(threadsCM);
0: 			}
0: 			threadsCM.activeCount = -1;
0: 		}
0: 		else
0: 		{
0: 			stack = (java.util.Stack) list;
0: 		}
0: 
0: 		stack.push(associateCM);
0: 		associateCM.activeCount = -1;
0: 
0: 		if (SanityManager.DEBUG) {
0: 
0: 			if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
0: 
0: 				if (stack.size() > 10)
0: 					System.out.println("memoryLeakTrace:ContextService:threadLocal " + stack.size());
0: 			}
0: 		}
0: 
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	 */
0: 	public void setCurrentContextManager(ContextManager cm) {
0: 
0: 
0: 		if (SanityManager.DEBUG) {
0: 			Thread me = Thread.currentThread();
0: 
0: 			if (cm.activeThread != null && me != cm.activeThread) {
0: 				SanityManager.THROWASSERT("setCurrentContextManager - mismatch threads - current " + me + " - cm's " + cm.activeThread);
0: 			}
0: 
0: /*			if ((cm.activeCount <0) || (cm.activeThread == null && cm.activeCount != 0) || (cm.activeThread != null && cm.activeCount == 0)) {
0: 				SanityManager.THROWASSERT("resetCurrentContextManager - invalid count - owner " + cm.activeThread + " - count " + cm.activeCount);
0: 			}
0: */
0: 		}
0: 
0: 		Thread me = null;
0: 
0: 		if (cm.activeThread == null) {
0: 			cm.activeThread = (me = Thread.currentThread());
0: 		}
0: 		if (addToThreadList(me, cm))
0: 			cm.activeCount++;
0: 
0: /*OLD
0: 		if (cm == null)
0: 			// don't bother storing it if it is null
0: 			remove(me);
0: 		else
0: 			put(me, cm);
0: */	}
0: 
0: 	/**
0: 	 * It's up to the caller to track this context manager and set it
0: 	 * in the context manager list using setCurrentContextManager.
0: 	 * We don't keep track of it due to this call being made.
0: 	 */
0: 	public ContextManager newContextManager()
0: 	{
0: 		ContextManager cm = new ContextManager(this, errorStream);
0: 
0: 		// push a context that will shut down the system on
0: 		// a severe error.
0: 		new SystemContext(cm);
0: 
0: 		synchronized (this) {
0: 			allContexts.add(cm);
0: 
0: 			if (SanityManager.DEBUG) {
0: 
0: 				if (SanityManager.DEBUG_ON("memoryLeakTrace")) {
0: 
0: 					if (allContexts.size() > 50)
0: 						System.out.println("memoryLeakTrace:ContextService:allContexts " + allContexts.size());
0: 				}
0: 			}
0: 		}
0: 
0: 		return cm;
0: 	}
0: 
0: 	public void notifyAllActiveThreads(Context c) {
0: 		Thread me = Thread.currentThread();
0: 
0: 		synchronized (this) {
0: 			for (Iterator i = allContexts.iterator(); i.hasNext(); ) {
0: 
0: 				ContextManager cm = (ContextManager) i.next();
0: 
0: 				Thread active = cm.activeThread;
0: 
0: 				if (active == me)
0: 					continue;
0: 
0: 				if (active == null)
0: 					continue;
0: 
0: 				if (cm.setInterrupted(c))
0: 					active.interrupt();
0: 			}
0: 		}
0: 
0: /*
0: 		synchronized (this) {
0: 			for (Enumeration e = keys(); e.hasMoreElements(); ) {
0: 				Thread t = (Thread) e.nextElement();
0: 				if (t == me)
0: 					continue;
0: 
0: 				ContextManager him = (ContextManager) get(t);
0: 
0: 				if (him.setInterrupted(c))
0: 					t.interrupt();
0: 			}
0: 		} */
0: 	}
0: 
0:     synchronized void removeContext( ContextManager cm)
0:     {
0:         allContexts.remove( cm);
0:     }
0: }
============================================================================