1:2bc809f: /*
2:2bc809f: 
1:2bc809f:    Derby - Class org.apache.derbyTesting.unitTests.store.T_SortController
1:2bc809f: 
1:c38b841:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c38b841:    contributor license agreements.  See the NOTICE file distributed with
1:c38b841:    this work for additional information regarding copyright ownership.
1:c38b841:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c38b841:    (the "License"); you may not use this file except in compliance with
1:c38b841:    the License.  You may obtain a copy of the License at
1:2bc809f: 
1:2bc809f:       http://www.apache.org/licenses/LICENSE-2.0
1:2bc809f: 
1:2bc809f:    Unless required by applicable law or agreed to in writing, software
1:2bc809f:    distributed under the License is distributed on an "AS IS" BASIS,
1:2bc809f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:2bc809f:    See the License for the specific language governing permissions and
1:2bc809f:    limitations under the License.
1:2bc809f: 
1:2bc809f:  */
1:2bc809f: 
1:2bc809f: package org.apache.derbyTesting.unitTests.store;
1:2bc809f: 
1:2bc809f: // impl imports are the preferred way to create unit tests.
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1:2bc809f: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.store.access.*;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.context.ContextService;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.monitor.Monitor;
1:2bc809f: import org.apache.derby.iapi.services.io.Storable;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.error.StandardException;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.types.DataValueDescriptor;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.reference.Property;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.services.i18n.MessageService;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.reference.SQLState;
1:2bc809f: 
1:2bc809f: import org.apache.derby.iapi.types.SQLInteger;
1:2bc809f: 
1:9ce0e0f: import java.security.AccessController;
1:9ce0e0f: import java.security.PrivilegedAction;
1:56c1dc2: import java.security.PrivilegedActionException;
1:56c1dc2: import java.security.PrivilegedExceptionAction;
1:2bc809f: import java.util.Properties;
1:2bc809f: import java.util.Vector;
1:2bc809f: import java.util.StringTokenizer;
1:2bc809f: import java.io.File;
1:0c5bc3a: import org.apache.derby.shared.common.sanity.SanityManager;
1:2bc809f: 
1:2bc809f: /**
1:2bc809f: 
1:2bc809f:   Unit test for sorting.
1:2bc809f: 
1:2bc809f: **/
1:2bc809f: 
1:2bc809f: public class T_SortController extends T_Generic
1:2bc809f: {
1:2bc809f: 	private static final String testService = "sortTest";
1:2bc809f: 
1:2bc809f: 	/** Set this to print out the rows that are inserted into
1:2bc809f: 	 ** and returned from each sort. **/
1:2bc809f: 	protected boolean verbose = false;
1:2bc809f: 
1:2bc809f: 	public String getModuleToTestProtocolName() {
1:2bc809f: 		return AccessFactory.MODULE;
1:2bc809f: 	}
1:2bc809f: 
1:9ce0e0f: 	private void setSortBufferSize(final String buf_length) {
1:3f5c48a:     	AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:3f5c48a: 		    public Void run()  {
1:9ce0e0f: 		    	System.setProperty("derby.storage.sortBufferMax", buf_length);
1:9ce0e0f: 		    	return null;
1:2bc809f: 		    }
1:9ce0e0f: 	    });
1:9ce0e0f: 	}
1:0c5bc3a: 
1:2bc809f: 	/*
1:2bc809f: 	** Methods of T_SortController
1:2bc809f: 	*/
1:2bc809f: 
1:56c1dc2: 	/**
1:2bc809f: 		@exception T_Fail test has failed
1:2bc809f: 	*/
1:2bc809f: 	protected void runTests() throws T_Fail
1:2bc809f: 	{
1:2bc809f: 		int failcount = 0;
1:2bc809f: 
1:2bc809f: 		// Get the AccessFactory to test.
1:2bc809f: 
1:2bc809f: 		// don't automatic boot this service if it gets left around
1:2bc809f: 		if (startParams == null) {
1:2bc809f: 			startParams = new Properties();
1:2bc809f: 		}
1:2bc809f: 		startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1:2bc809f: 		// remove the service directory to ensure a clean run
1:2bc809f: 		startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1:2bc809f: 
1:2bc809f: 		// see if we are testing encryption
1:2bc809f: 		startParams = T_Util.setEncryptionParam(startParams);
1:2bc809f: 
1:2bc809f: 		try {
1:2bc809f: 			REPORT("(unitTestMain) Testing " + "sortTest with default sort buffer size 1024");
1:2bc809f: 			AccessFactory store1024 = null;
1:2bc809f: 			failcount = runEachTest(store1024, "1024");
1:2bc809f: 
1:2bc809f: 			setSortBufferSize("4");
1:2bc809f: 			REPORT("(unitTestMain) Testing " + "sortTest with minimum sort buffer size 4");
1:2bc809f: 			AccessFactory store4 = null;
1:2bc809f: 			failcount += runEachTest(store4, "4");
1:2bc809f: 		}
1:2bc809f: 		catch (StandardException e)
1:2bc809f: 		{
1:2bc809f: 			String  msg = e.getMessage();
1:2bc809f: 			if (msg == null)
1:2bc809f: 				msg = e.getClass().getName();
1:2bc809f: 			REPORT("(unitTestMain) unexpected exception: " + msg);
1:2bc809f: 			throw T_Fail.exceptionFail(e);
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		if (failcount != 0)
1:2bc809f: 			throw T_Fail.testFailMsg("(unitTestMain)" + failcount + " cases failed.");
1:2bc809f: 
1:2bc809f: 		REPORT("(unitTestMain) succeeded");
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	protected int runEachTest(AccessFactory store, String tail) throws T_Fail, StandardException {
1:2bc809f: 
1:2bc809f: 		TransactionController tc = null;
1:2bc809f: 		int failcount = 0;
1:2bc809f: 
1:2bc809f: 		try {
1:56c1dc2: 			store = (AccessFactory) createPersistentService(getModuleToTestProtocolName(), 
1:2bc809f: 				testService + tail, startParams);
1:2bc809f: 		} catch (StandardException mse) {
1:2bc809f: 			throw T_Fail.exceptionFail(mse);
1:2bc809f: 		}
1:2bc809f: 		if (store == null) {
1:2bc809f: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		tc = store.getTransaction(
1:a0dbbd7:                 getContextService().getCurrentContextManager());
1:2bc809f: 
1:2bc809f: 		if (!sortExample(tc))
1:2bc809f: 			failcount++;
1:2bc809f: 		if (!sortBufferCoverage(tc))
1:2bc809f: 			failcount++;
1:2bc809f: 		if (!sortBoundaries(tc))
1:2bc809f: 			failcount++;
1:2bc809f: 		if (!sortAllDuplicates(tc))
1:2bc809f: 			failcount++;
1:2bc809f: 		if (!sortDescending(tc))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		tc.commit();
1:2bc809f: 		tc.destroy();
1:2bc809f: 
1:2bc809f: 		return failcount;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	This test is more of an example, with lots of comments to
1:2bc809f: 	explain what's going on.
1:2bc809f: 	**/
1:2bc809f: 	boolean sortExample(TransactionController tc)
1:2bc809f: 		throws StandardException
1:2bc809f: 	{
1:2bc809f: 		REPORT("(sortExample)");
1:2bc809f: 
1:2bc809f: 		// Create the rows to be sorted.
1:2bc809f: 		T_AccessRow row[] = new T_AccessRow[4];
1:2bc809f: 		row[0] = new T_AccessRow(18,  1,  2);
1:2bc809f: 		row[1] = new T_AccessRow( 6,  1, 18);
1:2bc809f: 		row[2] = new T_AccessRow(18,  1,  2);
1:2bc809f: 		row[3] = new T_AccessRow( 8, 14,  3);
1:2bc809f: 
1:2bc809f: 		// Decide on what kind of sort we want.  The properties
1:2bc809f: 		// can select different sorting techniques and options.
1:2bc809f: 		// But all sorts will result in the rows being in order.
1:2bc809f: 		// We don't care which sort technique is used, so set
1:2bc809f: 		// the properties to null.
1:2bc809f: 		Properties implParameters = null;
1:2bc809f: 
1:2bc809f: 		// Define the type of rows to be sorted by constructing
1:2bc809f: 		// a template.  Any row with the correct column types
1:2bc809f: 		// will do (the values in the template are never used,
1:2bc809f: 		// just the types).  The first row to be inserted will
1:2bc809f: 		// make a good template.
1:2bc809f: 		T_AccessRow template = row[0];
1:2bc809f: 
1:2bc809f: 		// Define the column ordering: sort on column 1
1:2bc809f: 		// (the second column) ascending, then column 2
1:2bc809f: 		// (the third column) ascending.
1:2bc809f: 		ColumnOrdering order[] = new ColumnOrdering[2];
1:2bc809f: 		order[0] = new T_ColumnOrderingImpl(1, true); // ascending
1:2bc809f: 		order[1] = new T_ColumnOrderingImpl(2, true); // ascending
1:2bc809f: 
1:2bc809f: 		// Tell the sort that the rows are not already in order.
1:2bc809f: 		boolean alreadyInOrder = false;
1:2bc809f: 
1:2bc809f: 		// Tell the sort that we're estimating that about 10
1:2bc809f: 		// rows will be inserted into the sort.  This is just
1:2bc809f: 		// a hint, the sort will still work if more rows or
1:2bc809f: 		// fewer rows are inserted.  But if the guess is close
1:2bc809f: 		// the sort will probably run faster.
1:2bc809f: 		long estimatedRows = 10;
1:2bc809f: 
1:2bc809f: 		// Tell the sort that we're estimating that the rows 
1:2bc809f:         // are about 24 bytes long (3 int columns).
1:2bc809f: 		// This is just a hint, the sort will still work if rows of
1:2bc809f: 		// less or greater size are inserted.  But if the guess is close
1:2bc809f: 		// the sort will probably run faster.
1:2bc809f: 		int estimatedRowSize = 12;
1:2bc809f: 
1:2bc809f: 		// Create the sort.
1:2bc809f: 		long sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows, 
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		// For the above sort, on the above input rows, we expect
1:2bc809f: 		// the output rows to look like this:
1:2bc809f: 		T_AccessRow expectedRow[] = new T_AccessRow[3];
1:2bc809f: 		expectedRow[0] = new T_AccessRow(18,  1,  2);
1:2bc809f: 		expectedRow[1] = new T_AccessRow( 6,  1, 18);
1:2bc809f: 		expectedRow[2] = new T_AccessRow( 8, 14,  3);
1:2bc809f: 
1:2bc809f: 		return testSort(tc, row, expectedRow, sortid);
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	This test covers specific code paths in the external sort's
1:2bc809f: 	sort buffer.  It really should live closer to the sort buffer
1:2bc809f: 	since the effectiveness of this test is very very implementation
1:2bc809f: 	dependent.
1:2bc809f: 	**/
1:2bc809f: 	boolean sortBufferCoverage(TransactionController tc)
1:2bc809f: 		throws StandardException
1:2bc809f: 	{
1:2bc809f: 		REPORT("(sortBufferCoverage)");
1:2bc809f: 
1:2bc809f: 		// Create the rows to be sorted.  This sequence of values
1:2bc809f: 		// will provoke both single and double rotations on insert
1:2bc809f: 		// and both single and double rotations on removal.  Every
1:2bc809f: 		// row has a duplicate so that we can test duplicate handling
1:2bc809f: 		// in every tree position and through all manipulations.
1:2bc809f: 		T_AccessRow row[] = new T_AccessRow[16];
1:2bc809f: 		row[0] = new T_AccessRow(2, 0,  0); // first node
1:2bc809f: 		row[1] = new T_AccessRow(2, 0,  0);
1:2bc809f: 
1:2bc809f: 		row[2] = new T_AccessRow(4, 0,  0); // This makes the tree get higher [A7 case (i)]
1:2bc809f: 		row[3] = new T_AccessRow(4, 0,  0);
1:2bc809f: 
1:2bc809f: 		row[4] = new T_AccessRow(1, 0,  0); // This makes the tree more balanced [A7 case (ii)]
1:2bc809f: 		row[5] = new T_AccessRow(1, 0,  0);
1:2bc809f: 
1:2bc809f: 		row[6] = new T_AccessRow(7, 0,  0); // Tree getting higher again [A7 case (i)]
1:2bc809f: 		row[7] = new T_AccessRow(7, 0,  0);
1:2bc809f: 
1:2bc809f: 		row[8] = new T_AccessRow(8, 0,  0); // Tree getting out of balance [A7 case iii]
1:2bc809f: 									  // Single rotation will fix	[A8]
1:2bc809f: 		row[9] = new T_AccessRow(8, 0,  0);
1:2bc809f: 
1:2bc809f: 		row[10] = new T_AccessRow(3, 0,  0); // Tree getting out of balance [A7 case iii]
1:2bc809f: 									  // Double rotation will fix	[A9]
1:2bc809f: 		row[11] = new T_AccessRow(3, 0,  0);
1:2bc809f: 
1:2bc809f: 		row[12] = new T_AccessRow(5, 0,  0); // Tree more balanced [A7 case (ii)]
1:2bc809f: 		row[13] = new T_AccessRow(5, 0,  0);
1:2bc809f: 
1:2bc809f: 		row[14] = new T_AccessRow(6, 0,  0); // Tree getting higher again [A7 case (i)]
1:2bc809f: 		row[15] = new T_AccessRow(6, 0,  0);
1:2bc809f: 
1:2bc809f: 		// RESOLVE (nat) Should select the sort that being tested here.
1:2bc809f: 		Properties implParameters = null;
1:2bc809f: 
1:2bc809f: 		T_AccessRow template = row[0];
1:2bc809f: 
1:2bc809f: 		// Sort on column 0 (the first column) ascending
1:2bc809f: 		ColumnOrdering order[] = new ColumnOrdering[1];
1:2bc809f: 		order[0] = new T_ColumnOrderingImpl(0, true); // ascending
1:2bc809f: 
1:2bc809f: 		// The rows are not already in order.
1:2bc809f: 		boolean alreadyInOrder = false;
1:2bc809f: 
1:2bc809f: 		long estimatedRows = 20;
1:2bc809f: 		int estimatedRowSize = 12;
1:2bc809f: 
1:2bc809f: 		// Create the sort.
1:2bc809f: 		long sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows,
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		// Rows should come out in order
1:2bc809f: 		T_AccessRow expectedRow[] = new T_AccessRow[16];
1:2bc809f: 		expectedRow[0] = new T_AccessRow(1, 0,  0);
1:2bc809f: 		expectedRow[1] = new T_AccessRow(1, 0,  0);
1:2bc809f: 		expectedRow[2] = new T_AccessRow(2, 0,  0);
1:2bc809f: 		expectedRow[3] = new T_AccessRow(2, 0,  0);
1:2bc809f: 		expectedRow[4] = new T_AccessRow(3, 0,  0);
1:2bc809f: 		expectedRow[5] = new T_AccessRow(3, 0,  0);
1:2bc809f: 		expectedRow[6] = new T_AccessRow(4, 0,  0);
1:2bc809f: 		expectedRow[7] = new T_AccessRow(4, 0,  0);
1:2bc809f: 		expectedRow[8] = new T_AccessRow(5, 0,  0);
1:2bc809f: 		expectedRow[9] = new T_AccessRow(5, 0,  0);
1:2bc809f: 		expectedRow[10] = new T_AccessRow(6, 0,  0);
1:2bc809f: 		expectedRow[11] = new T_AccessRow(6, 0,  0);
1:2bc809f: 		expectedRow[12] = new T_AccessRow(7, 0,  0);
1:2bc809f: 		expectedRow[13] = new T_AccessRow(7, 0,  0);
1:2bc809f: 		expectedRow[14] = new T_AccessRow(8, 0,  0);
1:2bc809f: 		expectedRow[15] = new T_AccessRow(8, 0,  0);
1:2bc809f: 
1:2bc809f: 		return testSort(tc, row, expectedRow, sortid);
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	Test a sorts with one or zero rows.
1:2bc809f: 	**/
1:2bc809f: 	boolean sortBoundaries(TransactionController tc)
1:2bc809f: 		throws StandardException
1:2bc809f: 	{
1:2bc809f: 		int failcount = 0;
1:2bc809f: 		long sortid;
1:2bc809f: 		Properties implParameters;
1:2bc809f: 		T_AccessRow template;
1:2bc809f: 		ColumnOrdering order[];
1:2bc809f: 		boolean alreadyInOrder;
1:2bc809f: 		long estimatedRows;
1:2bc809f: 		int estimatedRowSize;
1:2bc809f: 		T_AccessRow input[];
1:2bc809f: 		T_AccessRow expected[];
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** The following sort parameters are the same for
1:2bc809f: 		** every sort tested in this method.
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		implParameters = null;
1:2bc809f: 		template = new T_AccessRow(1, 1, 1);
1:2bc809f: 		order = new ColumnOrdering[1];
1:2bc809f: 		order[0] = new T_ColumnOrderingImpl(0, true); // ascending
1:2bc809f: 		estimatedRows = 10;
1:2bc809f: 		estimatedRowSize = 12;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** A no-row sort.
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortBoundaries) Sorting no rows");
1:2bc809f: 
1:2bc809f: 		input = new T_AccessRow[0];  // no rows in..
1:2bc809f: 		expected = new T_AccessRow[0];  // .. ==> no rows out!
1:2bc809f: 		alreadyInOrder = false;
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows, 
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, input, expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** A no-row already in order sort.
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortBoundaries) Sorting no rows - \"already in order\"");
1:2bc809f: 
1:2bc809f: 		input = new T_AccessRow[0];  // no rows in..
1:2bc809f: 		expected = new T_AccessRow[0];  // .. ==> no rows out!
1:2bc809f: 		alreadyInOrder = true;
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows, 
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, input, expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** A single-row sort.
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortBoundaries) Sorting a single row");
1:2bc809f: 
1:2bc809f: 		input = new T_AccessRow[1];
1:2bc809f: 		input[0] = new T_AccessRow(99, 88, 77);
1:2bc809f: 		expected = new T_AccessRow[1];
1:2bc809f: 		expected[0] = new T_AccessRow(99, 88, 77);
1:2bc809f: 		alreadyInOrder = false;
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows,
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, input, expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** A single-row already-in-order sort.
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortBoundaries) Sorting a single row - \"already in order\"");
1:2bc809f: 
1:2bc809f: 		input = new T_AccessRow[1];
1:2bc809f: 		input[0] = new T_AccessRow(99, 88, 77);
1:2bc809f: 		expected = new T_AccessRow[1];
1:2bc809f: 		expected[0] = new T_AccessRow(99, 88, 77);
1:2bc809f: 		alreadyInOrder = true;
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows, 
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, input, expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** A single-row sort, eliminating duplicates
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortBoundaries) Sorting a single row - \"eliminate duplicates\"");
1:2bc809f: 
1:2bc809f: 		input = new T_AccessRow[1];
1:2bc809f: 		input[0] = new T_AccessRow(99, 88, 77);
1:2bc809f: 		expected = new T_AccessRow[1];
1:2bc809f: 		expected[0] = new T_AccessRow(99, 88, 77);
1:2bc809f: 		alreadyInOrder = false;
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows, 
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, input, expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		return failcount == 0;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	Test a sort where all the rows are duplicates
1:2bc809f: 	**/
1:2bc809f: 	boolean sortAllDuplicates(TransactionController tc)
1:2bc809f: 		throws StandardException
1:2bc809f: 	{
1:2bc809f: 		int failcount = 0;
1:2bc809f: 		long sortid;
1:2bc809f: 		Properties implParameters;
1:2bc809f: 		T_AccessRow template;
1:2bc809f: 		ColumnOrdering order[];
1:2bc809f: 		boolean alreadyInOrder;
1:2bc809f: 		long estimatedRows;
1:2bc809f: 		int estimatedRowSize;
1:2bc809f: 		T_AccessRow input[];
1:2bc809f: 		T_AccessRow expected[];
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** The following sort parameters will be used in every
1:2bc809f: 		** sort in this method.
1:2bc809f: 		*/
1:2bc809f: 		
1:2bc809f: 		implParameters = null;
1:2bc809f: 		template = new T_AccessRow(1, 1, 1);
1:2bc809f: 
1:2bc809f: 		// Ordering first two columns, ascending
1:2bc809f: 		order = new ColumnOrdering[2];
1:2bc809f: 		order[0] = new T_ColumnOrderingImpl(0, true); // ascending
1:2bc809f: 		order[1] = new T_ColumnOrderingImpl(1, true); // ascending
1:2bc809f: 
1:2bc809f: 		alreadyInOrder = false;
1:2bc809f: 		estimatedRows = 10;
1:2bc809f: 		estimatedRowSize = 12;
1:2bc809f: 
1:2bc809f: 		input = new T_AccessRow[5];
1:2bc809f: 		input[0] = new T_AccessRow(1, 1, 1);
1:2bc809f: 		input[1] = new T_AccessRow(1, 1, 1);
1:2bc809f: 		input[2] = new T_AccessRow(1, 1, 1);
1:2bc809f: 		input[3] = new T_AccessRow(1, 1, 1);
1:2bc809f: 		input[4] = new T_AccessRow(1, 1, 1);
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** When doing no aggregation, we expect every duplicate
1:2bc809f: 		** to come back out.
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortAllDuplicates) no aggregation");
1:2bc809f: 
1:2bc809f: 		expected = new T_AccessRow[5];
1:2bc809f: 		expected[0] = new T_AccessRow(1, 1, 1);
1:2bc809f: 		expected[1] = new T_AccessRow(1, 1, 1);
1:2bc809f: 		expected[2] = new T_AccessRow(1, 1, 1);
1:2bc809f: 		expected[3] = new T_AccessRow(1, 1, 1);
1:2bc809f: 		expected[4] = new T_AccessRow(1, 1, 1);
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows, 
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, input, expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** If we're doing duplicate elimination, we expect
1:2bc809f: 		** one row back (since they're all duplicates).
1:2bc809f: 		*/
1:2bc809f: 		
1:2bc809f: 		REPORT("(sortAllDuplicates) eliminate duplicates");
1:2bc809f: 
1:2bc809f: 		expected = new T_AccessRow[1];
1:2bc809f: 		expected[0] = new T_AccessRow(1, 1, 1);
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows, 
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, input, expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** Another aggregation, this time summing up the 
1:2bc809f: 		** third column.
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortAllDuplicates) sum aggregate");
1:2bc809f: 
1:2bc809f: 		expected = new T_AccessRow[1];
1:2bc809f: 		expected[0] = new T_AccessRow(1, 1, 5);
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_SumForIntCol(2), alreadyInOrder, estimatedRows, 
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, input, expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		return failcount == 0;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	Test a sort where we have some ascending and descending keys.
1:2bc809f: 	**/
1:2bc809f: 	boolean sortDescending(TransactionController tc)
1:2bc809f: 		throws StandardException
1:2bc809f: 	{
1:2bc809f: 		int failcount = 0;
1:2bc809f: 		long sortid;
1:2bc809f: 		Properties implParameters;
1:2bc809f: 		T_AccessRow template;
1:2bc809f: 		ColumnOrdering order[];
1:2bc809f: 		boolean alreadyInOrder;
1:2bc809f: 		long estimatedRows;
1:2bc809f: 		int estimatedRowSize;
1:2bc809f: 		T_AccessRow expected[];
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** The following sort parameters will be used in every
1:2bc809f: 		** sort in this method.
1:2bc809f: 		*/
1:2bc809f: 		
1:2bc809f: 		implParameters = null;
1:2bc809f: 		template = new T_AccessRow(1, 1, 1);
1:2bc809f: 
1:2bc809f: 		alreadyInOrder = false;
1:2bc809f: 		estimatedRows = 10;
1:2bc809f: 		estimatedRowSize = 12;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** Straight descending sort.
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortDescending) no aggregation");
1:2bc809f: 
1:2bc809f: 		order = new ColumnOrdering[2];
1:2bc809f: 		order[0] = new T_ColumnOrderingImpl(0, false); // descending
1:2bc809f: 		order[1] = new T_ColumnOrderingImpl(1, false); // descending
1:2bc809f: 
1:2bc809f: 		expected = new T_AccessRow[10];
1:2bc809f: 		expected[0] = new T_AccessRow(8, 1, 1);
1:2bc809f: 		expected[1] = new T_AccessRow(4, 8, 1);
1:2bc809f: 		expected[2] = new T_AccessRow(4, 2, 1);
1:2bc809f: 		expected[3] = new T_AccessRow(4, 1, 1);
1:2bc809f: 		expected[4] = new T_AccessRow(3, 8, 1);
1:2bc809f: 		expected[5] = new T_AccessRow(3, 5, 1);
1:2bc809f: 		expected[6] = new T_AccessRow(3, 3, 1);
1:2bc809f: 		expected[7] = new T_AccessRow(3, 3, 1);
1:2bc809f: 		expected[8] = new T_AccessRow(3, 3, 1);
1:2bc809f: 		expected[9] = new T_AccessRow(1, 1, 1);
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows,
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, getSortDescendingInput(), expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** Descending sort eliminating duplicates
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortDescending) eliminate duplicates");
1:2bc809f: 
1:2bc809f: 		order = new ColumnOrdering[2];
1:2bc809f: 		order[0] = new T_ColumnOrderingImpl(0, false); // descending
1:2bc809f: 		order[1] = new T_ColumnOrderingImpl(1, false); // descending
1:2bc809f: 
1:2bc809f: 		expected = new T_AccessRow[8];
1:2bc809f: 		expected[0] = new T_AccessRow(8, 1, 1);
1:2bc809f: 		expected[1] = new T_AccessRow(4, 8, 1);
1:2bc809f: 		expected[2] = new T_AccessRow(4, 2, 1);
1:2bc809f: 		expected[3] = new T_AccessRow(4, 1, 1);
1:2bc809f: 		expected[4] = new T_AccessRow(3, 8, 1);
1:2bc809f: 		expected[5] = new T_AccessRow(3, 5, 1);
1:2bc809f: 		expected[6] = new T_AccessRow(3, 3, 1);
1:2bc809f: 		expected[7] = new T_AccessRow(1, 1, 1);
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows,
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, getSortDescendingInput(), expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 		/*
1:2bc809f: 		** Eliminate duplicates, ascending on second column.
1:2bc809f: 		*/
1:2bc809f: 
1:2bc809f: 		REPORT("(sortDescending) descending/ascending - eliminate duplicates");
1:2bc809f: 
1:2bc809f: 		order = new ColumnOrdering[2];
1:2bc809f: 		order[0] = new T_ColumnOrderingImpl(0, false); // descending
1:2bc809f: 		order[1] = new T_ColumnOrderingImpl(1, true); // ascending
1:2bc809f: 
1:2bc809f: 		expected = new T_AccessRow[8];
1:2bc809f: 		expected[0] = new T_AccessRow(8, 1, 1);
1:2bc809f: 		expected[1] = new T_AccessRow(4, 1, 1);
1:2bc809f: 		expected[2] = new T_AccessRow(4, 2, 1);
1:2bc809f: 		expected[3] = new T_AccessRow(4, 8, 1);
1:2bc809f: 		expected[4] = new T_AccessRow(3, 3, 1);
1:2bc809f: 		expected[5] = new T_AccessRow(3, 5, 1);
1:2bc809f: 		expected[6] = new T_AccessRow(3, 8, 1);
1:2bc809f: 		expected[7] = new T_AccessRow(1, 1, 1);
1:2bc809f: 
1:2bc809f: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1:2bc809f: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows,
1:2bc809f:             estimatedRowSize);
1:2bc809f: 
1:2bc809f: 		if (!testSort(tc, getSortDescendingInput(), expected, sortid))
1:2bc809f: 			failcount++;
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 		return failcount == 0;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	private T_AccessRow[] getSortDescendingInput()
1:2bc809f: 	{
1:2bc809f: 		T_AccessRow[] input;
1:2bc809f: 
1:2bc809f: 		input = new T_AccessRow[10];
1:2bc809f: 		input[0] = new T_AccessRow(8, 1, 1);
1:2bc809f: 		input[1] = new T_AccessRow(1, 1, 1);
1:2bc809f: 		input[2] = new T_AccessRow(3, 5, 1);
1:2bc809f: 		input[3] = new T_AccessRow(4, 1, 1);
1:2bc809f: 		input[4] = new T_AccessRow(3, 3, 1);
1:2bc809f: 		input[5] = new T_AccessRow(3, 8, 1);
1:2bc809f: 		input[6] = new T_AccessRow(3, 3, 1);
1:2bc809f: 		input[7] = new T_AccessRow(3, 3, 1);
1:2bc809f: 		input[8] = new T_AccessRow(4, 2, 1);
1:2bc809f: 		input[9] = new T_AccessRow(4, 8, 1);
1:2bc809f: 
1:2bc809f: 		return input;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 
1:2bc809f: 	/**
1:2bc809f: 	Insert the given rows into the given sort, and check that the
1:2bc809f: 	rows retrieved from the sort match the output rows.
1:2bc809f: 	**/
1:2bc809f: 	boolean testSort(TransactionController tc, T_AccessRow in[], T_AccessRow outrow[], long sortid)
1:2bc809f: 		throws StandardException
1:2bc809f: 	{
1:2bc809f: 		// Open a sort controller for inserting the rows.
1:2bc809f: 		SortController sort = tc.openSort(sortid);
1:2bc809f: 
1:2bc809f: 		// Insert the rows to be sorted.
1:2bc809f: 		for (int i = 0; i < in.length; i++)
1:2bc809f: 		{
1:2bc809f: 			if (verbose)
1:2bc809f: 				REPORT("(testSort) in: " + in[i]);
1:2bc809f: 			sort.insert(in[i].getRowArray());
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// Close the sort controller.  This makes the rows
1:2bc809f: 		// available to be retrieved.
1:2bc809f:         // It also means we are getting final sort statistics.
1:d186278:         sort.completedInserts();
1:2bc809f: 
1:2bc809f:         // Test the SortInfo part of sort.
1:2bc809f:         SortInfo   sort_info = sort.getSortInfo();
1:2bc809f:         Properties sortprop      = sort_info.getAllSortInfo(null);
1:2bc809f: 
1:2bc809f:         String sortType = sortprop.getProperty(
1:2bc809f: 				MessageService.getTextMessage(SQLState.STORE_RTS_SORT_TYPE));
1:2bc809f:         int numRowsInput = Integer.parseInt(sortprop.getProperty(
1:2bc809f: 			MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_INPUT)));
1:2bc809f:         int numRowsOutput = Integer.parseInt(sortprop.getProperty(
1:2bc809f: 			MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_OUTPUT)));
1:2bc809f: 
1:2bc809f: 		String external =
1:2bc809f: 			  MessageService.getTextMessage(SQLState.STORE_RTS_EXTERNAL);
1:2bc809f: 		String internal =
1:2bc809f: 			 MessageService.getTextMessage(SQLState.STORE_RTS_INTERNAL);
1:2bc809f:         if (sortType.compareTo(internal) != 0 &&
1:2bc809f:             sortType.compareTo(external) != 0)
1:2bc809f:             FAIL("(testSort) unknown sortType.  Expected internal or external, got " + sortType);
1:2bc809f: 
1:2bc809f:         if (numRowsInput != in.length)
1:2bc809f:             FAIL("(testSort) SortInfo.numRowsInput (value: " + numRowsInput +
1:2bc809f:                 ") is not equal to in.length (value: " + in.length + ")");
1:2bc809f: 
1:2bc809f:         if (numRowsOutput != outrow.length)
1:2bc809f:             FAIL("(testSort) SortInfo.numRowsOutput (value: " +
1:2bc809f:                 numRowsOutput + ") is not equal to outrow.length (value: " + outrow.length + ")");
1:2bc809f: 
1:2bc809f: 		if (sortType.equals(external))
1:2bc809f:         {
1:2bc809f:             int numMergeRuns = Integer.parseInt(sortprop.getProperty(
1:2bc809f: 			 MessageService.getTextMessage(SQLState.STORE_RTS_NUM_MERGE_RUNS)));
1:3f5c48a:             Vector<Integer> mergeRuns = new Vector<Integer>();
1:2bc809f:             StringTokenizer st = new StringTokenizer(sortprop.getProperty(
1:2bc809f: 			 MessageService.getTextMessage(SQLState.STORE_RTS_MERGE_RUNS_SIZE)),
1:2bc809f: 			 "[],",false);
1:2bc809f:             while (st.hasMoreTokens())
1:2bc809f:                 mergeRuns.addElement(Integer.valueOf(st.nextToken().trim()));
1:2bc809f: 
1:2bc809f:             if (mergeRuns.size() != numMergeRuns)
1:2bc809f:                 FAIL("(testSort) the number of elements in vector SortInfo.mergeRunsSize (value: " +
1:2bc809f:                 mergeRuns.size() + " ) is not equal to SortInfo.numMergeRuns (value: " +
1:2bc809f:                 numMergeRuns + " )");
1:2bc809f: 
1:2bc809f:             int totRunSize = 0;
1:2bc809f:             for (int i = 0; i < mergeRuns.size(); i++)
1:3f5c48a:                 totRunSize += mergeRuns.elementAt(i);
1:2bc809f:             if (totRunSize != numRowsInput)
1:2bc809f:                FAIL("(testSort) the sum of the elements of the vector SortInfo.mergeRunsSize (value: " +
1:2bc809f:                 totRunSize + " ) is not equal to SortInfo.numRowsInput (value: " +
1:2bc809f:                 numRowsInput + " )");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 		sort = null;
1:2bc809f: 
1:2bc809f: 		// Open a sort scan for reading the rows back.
1:2bc809f: 		ScanController scan = tc.openSortScan(sortid, false);
1:2bc809f: 
1:2bc809f: 		// Things that could go wrong.
1:2bc809f: 		boolean mismatch = false;
1:2bc809f: 		boolean toofew = false;
1:2bc809f: 		boolean toomany = false;
1:2bc809f: 
1:2bc809f: 		// Fetch the sorted rows and compare them to the rows
1:2bc809f: 		// in the outrow array.
1:2bc809f: 		T_AccessRow result = new T_AccessRow(3);
1:2bc809f: 		for (int i = 0; i < outrow.length; i++)
1:2bc809f: 		{
1:2bc809f: 			if (scan.next() == false)
1:2bc809f: 			{
1:2bc809f: 				// We were expecting the i'th row from outrow, but
1:2bc809f: 				// it didn't show up!
1:2bc809f: 				toofew = true;
1:2bc809f: 				FAIL("(testSort) Too few rows in sort output");
1:2bc809f: 				break;
1:2bc809f: 			}
1:2bc809f: 
1:2bc809f: 			scan.fetch(result.getRowArray());
1:2bc809f: 			if (verbose)
1:2bc809f: 				REPORT("(testSort) out: " + result);
1:2bc809f: 
1:2bc809f: 			if (!result.equals(outrow[i]))
1:2bc809f: 			{
1:2bc809f: 				// The i'th row from the sort didn't match the
1:2bc809f: 				// i'th row from out.
1:2bc809f: 				mismatch = true;
1:2bc809f: 				FAIL("(testSort) row " + result + " != " + outrow[i]);
1:2bc809f: 			}
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f: 		// We should not see any more rows out of the sort,
1:2bc809f: 		// since we've exhausted the out array.
1:2bc809f: 		while (scan.next() == true)
1:2bc809f: 		{
1:2bc809f: 			scan.fetch(result.getRowArray());
1:2bc809f: 			if (verbose)
1:2bc809f: 				REPORT("(testSort) out: " + result);
1:2bc809f: 			toomany = true;
1:2bc809f: 			FAIL("(testSort) Extra row");
1:2bc809f: 		}
1:2bc809f: 
1:2bc809f:         // Test the ScanInfo part of sort.
1:2bc809f:         ScanInfo   scan_info = scan.getScanInfo();
1:2bc809f:         Properties prop      = scan_info.getAllScanInfo(null);
1:2bc809f: 
1:2bc809f:         if (prop.getProperty(
1:2bc809f: 				MessageService.getTextMessage(SQLState.STORE_RTS_SCAN_TYPE)
1:2bc809f: 							).compareTo(
1:2bc809f: 				MessageService.getTextMessage(SQLState.STORE_RTS_SORT)) != 0)
1:2bc809f:         {
1:2bc809f:             FAIL("(testSort) wrong scanType.  Expected sort, got " +
1:2bc809f:                 prop.getProperty(
1:2bc809f: 					MessageService.getTextMessage(
1:2bc809f: 												SQLState.STORE_RTS_SCAN_TYPE)));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         if (tc.countOpens(TransactionController.OPEN_CREATED_SORTS) != 1)
1:2bc809f:         {
1:2bc809f:             FAIL("(testSort) sort count before close is wrong: " +
1:2bc809f:                  tc.countOpens(TransactionController.OPEN_CREATED_SORTS));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 		// Close the scan controller (which implicitly destroys the sort).
1:2bc809f: 		scan.close();
1:2bc809f: 		scan = null;
1:2bc809f: 
1:2bc809f:         if (tc.countOpens(TransactionController.OPEN_CREATED_SORTS) != 1)
1:2bc809f:         {
1:2bc809f:             FAIL("(testSort) sort count after close is wrong: " +
1:2bc809f:                  tc.countOpens(TransactionController.OPEN_CREATED_SORTS));
1:2bc809f:         }
1:2bc809f: 
1:2bc809f:         tc.dropSort(sortid);
1:2bc809f: 
1:2bc809f:         if (tc.countOpens(TransactionController.OPEN_CREATED_SORTS) > 0)
1:2bc809f:         {
1:2bc809f:             FAIL("(testSort) a sort is still open.");
1:2bc809f:         }
1:2bc809f: 
1:2bc809f: 		return (!mismatch && !toofew && !toomany);
1:2bc809f: 	}
1:a0dbbd7:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of the ContextService. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  ContextService    getContextService()
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getFactory();
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<ContextService>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public ContextService run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getFactory();
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:2bc809f:     /**
1:56c1dc2:      * Privileged startup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:56c1dc2:         throws StandardException
1:56c1dc2:     {
1:56c1dc2:         try {
1:56c1dc2:             return AccessController.doPrivileged
1:56c1dc2:                 (
1:56c1dc2:                  new PrivilegedExceptionAction<Object>()
1:56c1dc2:                  {
1:56c1dc2:                      public Object run()
1:56c1dc2:                          throws StandardException
1:56c1dc2:                      {
1:56c1dc2:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:56c1dc2:                      }
1:56c1dc2:                  }
1:56c1dc2:                  );
1:56c1dc2:         } catch (PrivilegedActionException pae)
1:56c1dc2:         {
1:56c1dc2:             throw StandardException.plainWrapException( pae );
1:56c1dc2:         }
1:56c1dc2:     }
1:56c1dc2: 
1:2bc809f: }
1:2bc809f: 
1:2bc809f: 
1:2bc809f: class T_DummySortObserver implements SortObserver
1:2bc809f: {
1:2bc809f: 	T_AccessRow  template;
1:3f5c48a: 	Vector<DataValueDescriptor[]> vector;
1:2bc809f: 
1:2bc809f: 	T_DummySortObserver(T_AccessRow template)
1:2bc809f: 	{
1:2bc809f: 		this.template = template;
1:3f5c48a: 		vector = new Vector<DataValueDescriptor[]>();
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * Methods of SortObserver
1:2bc809f: 	 */
1:2bc809f: 	public DataValueDescriptor[] insertNonDuplicateKey(
1:2bc809f:     DataValueDescriptor[] insertRow)	
1:2bc809f: 	{
1:2bc809f: 		return insertRow;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public DataValueDescriptor[] insertDuplicateKey(
1:2bc809f:     DataValueDescriptor[]   insertRow, 
1:2bc809f:     DataValueDescriptor[]   existingRow)
1:2bc809f: 	{
1:2bc809f: 		return insertRow;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public void addToFreeList(
1:2bc809f:     DataValueDescriptor[]   objectArray, 
1:2bc809f:     int                     maxFreeListSize)
1:2bc809f: 	{
1:2bc809f: 		if (vector.size() < maxFreeListSize)
1:2bc809f: 		{
1:2bc809f: 			vector.addElement(objectArray);
1:2bc809f: 		}
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public DataValueDescriptor[] getArrayClone()
1:2bc809f: 		throws StandardException
1:2bc809f: 	{
1:2bc809f: 		int lastElement = vector.size();
1:2bc809f: 
1:2bc809f: 		if (lastElement > 0)
1:2bc809f: 		{
1:3f5c48a:             return vector.remove(lastElement - 1);
1:2bc809f: 		}
1:2bc809f: 		return template.getRowArrayClone();
1:2bc809f: 	}
1:0c5bc3a: 
1:0c5bc3a:     public boolean deferred() {
1:0c5bc3a:         return false;
1:0c5bc3a:     }
1:0c5bc3a: 
1:0c5bc3a:     public boolean deferrable() {
1:0c5bc3a:         return false;
1:0c5bc3a:     }
1:0c5bc3a: 
1:0c5bc3a:     public void rememberDuplicate(DataValueDescriptor[] row)
1:0c5bc3a:             throws StandardException {
1:0c5bc3a:         if (SanityManager.DEBUG) {
1:0c5bc3a:             SanityManager.NOTREACHED();
1:0c5bc3a:         }
1:0c5bc3a:     }
1:0c5bc3a: }
1:0c5bc3a: 
1:2bc809f: class T_DuplicateEliminator extends T_DummySortObserver
1:2bc809f: {
1:0c5bc3a: 
1:2bc809f: 	T_DuplicateEliminator(T_AccessRow template)
1:2bc809f: 	{
1:2bc809f: 		super(template);
1:0c5bc3a: 	}
1:2bc809f: 	/*
1:2bc809f: 	 * Methods of SortObserver
1:2bc809f: 	 */
1:2bc809f: 	public DataValueDescriptor[] insertNonDuplicateKey(
1:2bc809f:     DataValueDescriptor[] insertRow)	
1:2bc809f: 	{
1:2bc809f: 		return insertRow;
1:0c5bc3a: 	}
1:2bc809f: 
1:2bc809f: 	public DataValueDescriptor[] insertDuplicateKey(
1:2bc809f:     DataValueDescriptor[] insertRow, 
1:2bc809f:     DataValueDescriptor[] existingRow)
1:2bc809f: 	{
1:2bc809f: 		return null;
1:0c5bc3a: 	}
1:2bc809f: }
1:2bc809f: 
1:2bc809f: class T_SumForIntCol implements SortObserver
1:2bc809f: {
1:2bc809f: 	private int columnId;
1:2bc809f: 	
1:2bc809f: 	T_SumForIntCol(int columnId)
1:2bc809f: 	{
1:2bc809f: 		this.columnId = columnId;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	/*
1:2bc809f: 	 * Methods of SortObserver
1:2bc809f: 	 */
1:2bc809f: 
1:2bc809f: 	public DataValueDescriptor[] insertNonDuplicateKey(
1:2bc809f:     DataValueDescriptor[] insertRow)	
1:2bc809f: 	{
1:2bc809f: 		return insertRow;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public DataValueDescriptor[] insertDuplicateKey(
1:2bc809f:     DataValueDescriptor[] insertRow, 
1:2bc809f:     DataValueDescriptor[] existingRow)
1:2bc809f: 		throws StandardException
1:2bc809f: 	{
1:2bc809f: 
1:2bc809f: 		// We know, because this is a test program and it's only
1:2bc809f: 		// used this way, that we can safely cast the arguments
1:2bc809f: 		// to SQLInteger.
1:2bc809f: 		SQLInteger increment = (SQLInteger) insertRow[columnId];
1:2bc809f: 		SQLInteger sum = (SQLInteger) existingRow[columnId];
1:2bc809f: 
1:2bc809f: 		// Perform the aggregation.
1:2bc809f: 		sum.plus(sum, increment, sum);
1:2bc809f: 
1:2bc809f: 		return null;
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public void addToFreeList(
1:2bc809f:     DataValueDescriptor[]   objectArray, 
1:2bc809f:     int                     maxFreeListSize)
1:2bc809f: 	{
1:2bc809f: 	}
1:2bc809f: 
1:2bc809f: 	public DataValueDescriptor[] getArrayClone()
1:2bc809f: 		throws StandardException
1:2bc809f: 	{
1:2bc809f: 		return null;
1:2bc809f: 	}
1:2bc809f: 
1:0c5bc3a:     public boolean deferred() {
1:0c5bc3a:         return false;
1:2bc809f:     }
1:2bc809f: 
1:0c5bc3a:     public boolean deferrable() {
1:0c5bc3a:         return false;
1:2bc809f:     }
1:2bc809f: 
1:0c5bc3a:     public void rememberDuplicate(DataValueDescriptor[] row)
1:0c5bc3a:             throws StandardException {
1:0c5bc3a:         if (SanityManager.DEBUG) {
1:0c5bc3a:             SanityManager.NOTREACHED();
1:2bc809f:         }
1:2bc809f:     }
1:2bc809f: }
1:2bc809f: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedActionException;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
1: 			store = (AccessFactory) createPersistentService(getModuleToTestProtocolName(), 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged startup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Object createPersistentService( final String factoryInterface, final String serviceName, final Properties properties ) 
1:         throws StandardException
1:     {
1:         try {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedExceptionAction<Object>()
1:                  {
1:                      public Object run()
1:                          throws StandardException
1:                      {
1:                          return Monitor.createPersistentService( factoryInterface, serviceName, properties );
1:                      }
1:                  }
1:                  );
1:         } catch (PrivilegedActionException pae)
1:         {
1:             throw StandardException.plainWrapException( pae );
1:         }
1:     }
1: 
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1:                 getContextService().getCurrentContextManager());
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of the ContextService. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ContextService    getContextService()
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getFactory();
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<ContextService>()
1:                  {
1:                      public ContextService run()
1:                      {
1:                          return ContextService.getFactory();
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0c5bc3a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean deferred() {
1:         return false;
1:     }
1: 
1:     public boolean deferrable() {
1:         return false;
1:     }
1: 
1:     public void rememberDuplicate(DataValueDescriptor[] row)
1:             throws StandardException {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.NOTREACHED();
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1: 
1:     public boolean deferred() {
1:         return false;
1:     }
1: 
1:     public boolean deferrable() {
1:         return false;
1:     }
1: 
1:     public void rememberDuplicate(DataValueDescriptor[] row)
1:             throws StandardException {
1:         if (SanityManager.DEBUG) {
1:             SanityManager.NOTREACHED();
1:         }
1:     }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:     	AccessController.doPrivileged(new PrivilegedAction<Void>() {
1: 		    public Void run()  {
/////////////////////////////////////////////////////////////////////////
1:             Vector<Integer> mergeRuns = new Vector<Integer>();
/////////////////////////////////////////////////////////////////////////
1:                 totRunSize += mergeRuns.elementAt(i);
/////////////////////////////////////////////////////////////////////////
1: 	Vector<DataValueDescriptor[]> vector;
1: 		vector = new Vector<DataValueDescriptor[]>();
/////////////////////////////////////////////////////////////////////////
1:             return vector.remove(lastElement - 1);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:d186278
/////////////////////////////////////////////////////////////////////////
1:         sort.completedInserts();
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:c38b841
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:2bc809f
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.unitTests.store.T_SortController
1: 
0:    Copyright 1997, 2005 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.unitTests.store;
1: 
1: // impl imports are the preferred way to create unit tests.
1: import org.apache.derbyTesting.unitTests.harness.T_Generic;
1: import org.apache.derbyTesting.unitTests.harness.T_Fail;
1: 
1: import org.apache.derby.iapi.store.access.*;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: 
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.reference.Property;
1: 
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.types.SQLInteger;
1: 
1: import java.util.Properties;
1: import java.util.Vector;
1: import java.util.StringTokenizer;
1: import java.io.File;
1: 
1: /**
1: 
1:   Unit test for sorting.
1: 
1: **/
1: 
1: public class T_SortController extends T_Generic
1: {
1: 	private static final String testService = "sortTest";
1: 
1: 	/** Set this to print out the rows that are inserted into
1: 	 ** and returned from each sort. **/
1: 	protected boolean verbose = false;
1: 
1: 	public String getModuleToTestProtocolName() {
1: 		return AccessFactory.MODULE;
1: 	}
1: 
0: 	private void setSortBufferSize(String buf_length) {
0: 		Properties p = System.getProperties();
0: 		p.put("derby.storage.sortBufferMax", buf_length);
0: 		System.setProperties(p);
1: 	}
1: 
1: 	/*
1: 	** Methods of T_SortController
1: 	*/
1: 
1: 	/**
1: 		@exception T_Fail test has failed
1: 	*/
1: 	protected void runTests() throws T_Fail
1: 	{
1: 		int failcount = 0;
1: 
1: 		// Get the AccessFactory to test.
1: 
1: 		// don't automatic boot this service if it gets left around
1: 		if (startParams == null) {
1: 			startParams = new Properties();
1: 		}
1: 		startParams.put(Property.NO_AUTO_BOOT, Boolean.TRUE.toString());
1: 		// remove the service directory to ensure a clean run
1: 		startParams.put(Property.DELETE_ON_CREATE, Boolean.TRUE.toString());
1: 
1: 		// see if we are testing encryption
1: 		startParams = T_Util.setEncryptionParam(startParams);
1: 
1: 		try {
1: 			REPORT("(unitTestMain) Testing " + "sortTest with default sort buffer size 1024");
1: 			AccessFactory store1024 = null;
1: 			failcount = runEachTest(store1024, "1024");
1: 
1: 			setSortBufferSize("4");
1: 			REPORT("(unitTestMain) Testing " + "sortTest with minimum sort buffer size 4");
1: 			AccessFactory store4 = null;
1: 			failcount += runEachTest(store4, "4");
1: 		}
1: 		catch (StandardException e)
1: 		{
1: 			String  msg = e.getMessage();
1: 			if (msg == null)
1: 				msg = e.getClass().getName();
1: 			REPORT("(unitTestMain) unexpected exception: " + msg);
1: 			throw T_Fail.exceptionFail(e);
1: 		}
1: 
1: 		if (failcount != 0)
1: 			throw T_Fail.testFailMsg("(unitTestMain)" + failcount + " cases failed.");
1: 
1: 		REPORT("(unitTestMain) succeeded");
1: 	}
1: 
1: 	protected int runEachTest(AccessFactory store, String tail) throws T_Fail, StandardException {
1: 
1: 		TransactionController tc = null;
1: 		int failcount = 0;
1: 
1: 		try {
0: 			store = (AccessFactory) Monitor.createPersistentService(getModuleToTestProtocolName(), 
1: 				testService + tail, startParams);
1: 		} catch (StandardException mse) {
1: 			throw T_Fail.exceptionFail(mse);
1: 		}
1: 		if (store == null) {
1: 			throw T_Fail.testFailMsg(getModuleToTestProtocolName() + " service not started.");
1: 		}
1: 
1: 		tc = store.getTransaction(
0:                 ContextService.getFactory().getCurrentContextManager());
1: 
1: 		if (!sortExample(tc))
1: 			failcount++;
1: 		if (!sortBufferCoverage(tc))
1: 			failcount++;
1: 		if (!sortBoundaries(tc))
1: 			failcount++;
1: 		if (!sortAllDuplicates(tc))
1: 			failcount++;
1: 		if (!sortDescending(tc))
1: 			failcount++;
1: 
1: 		tc.commit();
1: 		tc.destroy();
1: 
1: 		return failcount;
1: 	}
1: 
1: 	/**
1: 	This test is more of an example, with lots of comments to
1: 	explain what's going on.
1: 	**/
1: 	boolean sortExample(TransactionController tc)
1: 		throws StandardException
1: 	{
1: 		REPORT("(sortExample)");
1: 
1: 		// Create the rows to be sorted.
1: 		T_AccessRow row[] = new T_AccessRow[4];
1: 		row[0] = new T_AccessRow(18,  1,  2);
1: 		row[1] = new T_AccessRow( 6,  1, 18);
1: 		row[2] = new T_AccessRow(18,  1,  2);
1: 		row[3] = new T_AccessRow( 8, 14,  3);
1: 
1: 		// Decide on what kind of sort we want.  The properties
1: 		// can select different sorting techniques and options.
1: 		// But all sorts will result in the rows being in order.
1: 		// We don't care which sort technique is used, so set
1: 		// the properties to null.
1: 		Properties implParameters = null;
1: 
1: 		// Define the type of rows to be sorted by constructing
1: 		// a template.  Any row with the correct column types
1: 		// will do (the values in the template are never used,
1: 		// just the types).  The first row to be inserted will
1: 		// make a good template.
1: 		T_AccessRow template = row[0];
1: 
1: 		// Define the column ordering: sort on column 1
1: 		// (the second column) ascending, then column 2
1: 		// (the third column) ascending.
1: 		ColumnOrdering order[] = new ColumnOrdering[2];
1: 		order[0] = new T_ColumnOrderingImpl(1, true); // ascending
1: 		order[1] = new T_ColumnOrderingImpl(2, true); // ascending
1: 
1: 		// Tell the sort that the rows are not already in order.
1: 		boolean alreadyInOrder = false;
1: 
1: 		// Tell the sort that we're estimating that about 10
1: 		// rows will be inserted into the sort.  This is just
1: 		// a hint, the sort will still work if more rows or
1: 		// fewer rows are inserted.  But if the guess is close
1: 		// the sort will probably run faster.
1: 		long estimatedRows = 10;
1: 
1: 		// Tell the sort that we're estimating that the rows 
1:         // are about 24 bytes long (3 int columns).
1: 		// This is just a hint, the sort will still work if rows of
1: 		// less or greater size are inserted.  But if the guess is close
1: 		// the sort will probably run faster.
1: 		int estimatedRowSize = 12;
1: 
1: 		// Create the sort.
1: 		long sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows, 
1:             estimatedRowSize);
1: 
1: 		// For the above sort, on the above input rows, we expect
1: 		// the output rows to look like this:
1: 		T_AccessRow expectedRow[] = new T_AccessRow[3];
1: 		expectedRow[0] = new T_AccessRow(18,  1,  2);
1: 		expectedRow[1] = new T_AccessRow( 6,  1, 18);
1: 		expectedRow[2] = new T_AccessRow( 8, 14,  3);
1: 
1: 		return testSort(tc, row, expectedRow, sortid);
1: 	}
1: 
1: 	/**
1: 	This test covers specific code paths in the external sort's
1: 	sort buffer.  It really should live closer to the sort buffer
1: 	since the effectiveness of this test is very very implementation
1: 	dependent.
1: 	**/
1: 	boolean sortBufferCoverage(TransactionController tc)
1: 		throws StandardException
1: 	{
1: 		REPORT("(sortBufferCoverage)");
1: 
1: 		// Create the rows to be sorted.  This sequence of values
1: 		// will provoke both single and double rotations on insert
1: 		// and both single and double rotations on removal.  Every
1: 		// row has a duplicate so that we can test duplicate handling
1: 		// in every tree position and through all manipulations.
1: 		T_AccessRow row[] = new T_AccessRow[16];
1: 		row[0] = new T_AccessRow(2, 0,  0); // first node
1: 		row[1] = new T_AccessRow(2, 0,  0);
1: 
1: 		row[2] = new T_AccessRow(4, 0,  0); // This makes the tree get higher [A7 case (i)]
1: 		row[3] = new T_AccessRow(4, 0,  0);
1: 
1: 		row[4] = new T_AccessRow(1, 0,  0); // This makes the tree more balanced [A7 case (ii)]
1: 		row[5] = new T_AccessRow(1, 0,  0);
1: 
1: 		row[6] = new T_AccessRow(7, 0,  0); // Tree getting higher again [A7 case (i)]
1: 		row[7] = new T_AccessRow(7, 0,  0);
1: 
1: 		row[8] = new T_AccessRow(8, 0,  0); // Tree getting out of balance [A7 case iii]
1: 									  // Single rotation will fix	[A8]
1: 		row[9] = new T_AccessRow(8, 0,  0);
1: 
1: 		row[10] = new T_AccessRow(3, 0,  0); // Tree getting out of balance [A7 case iii]
1: 									  // Double rotation will fix	[A9]
1: 		row[11] = new T_AccessRow(3, 0,  0);
1: 
1: 		row[12] = new T_AccessRow(5, 0,  0); // Tree more balanced [A7 case (ii)]
1: 		row[13] = new T_AccessRow(5, 0,  0);
1: 
1: 		row[14] = new T_AccessRow(6, 0,  0); // Tree getting higher again [A7 case (i)]
1: 		row[15] = new T_AccessRow(6, 0,  0);
1: 
1: 		// RESOLVE (nat) Should select the sort that being tested here.
1: 		Properties implParameters = null;
1: 
1: 		T_AccessRow template = row[0];
1: 
1: 		// Sort on column 0 (the first column) ascending
1: 		ColumnOrdering order[] = new ColumnOrdering[1];
1: 		order[0] = new T_ColumnOrderingImpl(0, true); // ascending
1: 
1: 		// The rows are not already in order.
1: 		boolean alreadyInOrder = false;
1: 
1: 		long estimatedRows = 20;
1: 		int estimatedRowSize = 12;
1: 
1: 		// Create the sort.
1: 		long sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows,
1:             estimatedRowSize);
1: 
1: 		// Rows should come out in order
1: 		T_AccessRow expectedRow[] = new T_AccessRow[16];
1: 		expectedRow[0] = new T_AccessRow(1, 0,  0);
1: 		expectedRow[1] = new T_AccessRow(1, 0,  0);
1: 		expectedRow[2] = new T_AccessRow(2, 0,  0);
1: 		expectedRow[3] = new T_AccessRow(2, 0,  0);
1: 		expectedRow[4] = new T_AccessRow(3, 0,  0);
1: 		expectedRow[5] = new T_AccessRow(3, 0,  0);
1: 		expectedRow[6] = new T_AccessRow(4, 0,  0);
1: 		expectedRow[7] = new T_AccessRow(4, 0,  0);
1: 		expectedRow[8] = new T_AccessRow(5, 0,  0);
1: 		expectedRow[9] = new T_AccessRow(5, 0,  0);
1: 		expectedRow[10] = new T_AccessRow(6, 0,  0);
1: 		expectedRow[11] = new T_AccessRow(6, 0,  0);
1: 		expectedRow[12] = new T_AccessRow(7, 0,  0);
1: 		expectedRow[13] = new T_AccessRow(7, 0,  0);
1: 		expectedRow[14] = new T_AccessRow(8, 0,  0);
1: 		expectedRow[15] = new T_AccessRow(8, 0,  0);
1: 
1: 		return testSort(tc, row, expectedRow, sortid);
1: 	}
1: 
1: 
1: 	/**
1: 	Test a sorts with one or zero rows.
1: 	**/
1: 	boolean sortBoundaries(TransactionController tc)
1: 		throws StandardException
1: 	{
1: 		int failcount = 0;
1: 		long sortid;
1: 		Properties implParameters;
1: 		T_AccessRow template;
1: 		ColumnOrdering order[];
1: 		boolean alreadyInOrder;
1: 		long estimatedRows;
1: 		int estimatedRowSize;
1: 		T_AccessRow input[];
1: 		T_AccessRow expected[];
1: 
1: 		/*
1: 		** The following sort parameters are the same for
1: 		** every sort tested in this method.
1: 		*/
1: 
1: 		implParameters = null;
1: 		template = new T_AccessRow(1, 1, 1);
1: 		order = new ColumnOrdering[1];
1: 		order[0] = new T_ColumnOrderingImpl(0, true); // ascending
1: 		estimatedRows = 10;
1: 		estimatedRowSize = 12;
1: 
1: 		/*
1: 		** A no-row sort.
1: 		*/
1: 
1: 		REPORT("(sortBoundaries) Sorting no rows");
1: 
1: 		input = new T_AccessRow[0];  // no rows in..
1: 		expected = new T_AccessRow[0];  // .. ==> no rows out!
1: 		alreadyInOrder = false;
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows, 
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, input, expected, sortid))
1: 			failcount++;
1: 
1: 		/*
1: 		** A no-row already in order sort.
1: 		*/
1: 
1: 		REPORT("(sortBoundaries) Sorting no rows - \"already in order\"");
1: 
1: 		input = new T_AccessRow[0];  // no rows in..
1: 		expected = new T_AccessRow[0];  // .. ==> no rows out!
1: 		alreadyInOrder = true;
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows, 
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, input, expected, sortid))
1: 			failcount++;
1: 
1: 		/*
1: 		** A single-row sort.
1: 		*/
1: 
1: 		REPORT("(sortBoundaries) Sorting a single row");
1: 
1: 		input = new T_AccessRow[1];
1: 		input[0] = new T_AccessRow(99, 88, 77);
1: 		expected = new T_AccessRow[1];
1: 		expected[0] = new T_AccessRow(99, 88, 77);
1: 		alreadyInOrder = false;
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows,
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, input, expected, sortid))
1: 			failcount++;
1: 
1: 		/*
1: 		** A single-row already-in-order sort.
1: 		*/
1: 
1: 		REPORT("(sortBoundaries) Sorting a single row - \"already in order\"");
1: 
1: 		input = new T_AccessRow[1];
1: 		input[0] = new T_AccessRow(99, 88, 77);
1: 		expected = new T_AccessRow[1];
1: 		expected[0] = new T_AccessRow(99, 88, 77);
1: 		alreadyInOrder = true;
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows, 
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, input, expected, sortid))
1: 			failcount++;
1: 
1: 		/*
1: 		** A single-row sort, eliminating duplicates
1: 		*/
1: 
1: 		REPORT("(sortBoundaries) Sorting a single row - \"eliminate duplicates\"");
1: 
1: 		input = new T_AccessRow[1];
1: 		input[0] = new T_AccessRow(99, 88, 77);
1: 		expected = new T_AccessRow[1];
1: 		expected[0] = new T_AccessRow(99, 88, 77);
1: 		alreadyInOrder = false;
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows, 
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, input, expected, sortid))
1: 			failcount++;
1: 
1: 		return failcount == 0;
1: 	}
1: 
1: 	/**
1: 	Test a sort where all the rows are duplicates
1: 	**/
1: 	boolean sortAllDuplicates(TransactionController tc)
1: 		throws StandardException
1: 	{
1: 		int failcount = 0;
1: 		long sortid;
1: 		Properties implParameters;
1: 		T_AccessRow template;
1: 		ColumnOrdering order[];
1: 		boolean alreadyInOrder;
1: 		long estimatedRows;
1: 		int estimatedRowSize;
1: 		T_AccessRow input[];
1: 		T_AccessRow expected[];
1: 
1: 		/*
1: 		** The following sort parameters will be used in every
1: 		** sort in this method.
1: 		*/
1: 		
1: 		implParameters = null;
1: 		template = new T_AccessRow(1, 1, 1);
1: 
1: 		// Ordering first two columns, ascending
1: 		order = new ColumnOrdering[2];
1: 		order[0] = new T_ColumnOrderingImpl(0, true); // ascending
1: 		order[1] = new T_ColumnOrderingImpl(1, true); // ascending
1: 
1: 		alreadyInOrder = false;
1: 		estimatedRows = 10;
1: 		estimatedRowSize = 12;
1: 
1: 		input = new T_AccessRow[5];
1: 		input[0] = new T_AccessRow(1, 1, 1);
1: 		input[1] = new T_AccessRow(1, 1, 1);
1: 		input[2] = new T_AccessRow(1, 1, 1);
1: 		input[3] = new T_AccessRow(1, 1, 1);
1: 		input[4] = new T_AccessRow(1, 1, 1);
1: 
1: 		/*
1: 		** When doing no aggregation, we expect every duplicate
1: 		** to come back out.
1: 		*/
1: 
1: 		REPORT("(sortAllDuplicates) no aggregation");
1: 
1: 		expected = new T_AccessRow[5];
1: 		expected[0] = new T_AccessRow(1, 1, 1);
1: 		expected[1] = new T_AccessRow(1, 1, 1);
1: 		expected[2] = new T_AccessRow(1, 1, 1);
1: 		expected[3] = new T_AccessRow(1, 1, 1);
1: 		expected[4] = new T_AccessRow(1, 1, 1);
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows, 
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, input, expected, sortid))
1: 			failcount++;
1: 
1: 		/*
1: 		** If we're doing duplicate elimination, we expect
1: 		** one row back (since they're all duplicates).
1: 		*/
1: 		
1: 		REPORT("(sortAllDuplicates) eliminate duplicates");
1: 
1: 		expected = new T_AccessRow[1];
1: 		expected[0] = new T_AccessRow(1, 1, 1);
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows, 
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, input, expected, sortid))
1: 			failcount++;
1: 
1: 		/*
1: 		** Another aggregation, this time summing up the 
1: 		** third column.
1: 		*/
1: 
1: 		REPORT("(sortAllDuplicates) sum aggregate");
1: 
1: 		expected = new T_AccessRow[1];
1: 		expected[0] = new T_AccessRow(1, 1, 5);
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_SumForIntCol(2), alreadyInOrder, estimatedRows, 
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, input, expected, sortid))
1: 			failcount++;
1: 
1: 		return failcount == 0;
1: 	}
1: 
1: 	/**
1: 	Test a sort where we have some ascending and descending keys.
1: 	**/
1: 	boolean sortDescending(TransactionController tc)
1: 		throws StandardException
1: 	{
1: 		int failcount = 0;
1: 		long sortid;
1: 		Properties implParameters;
1: 		T_AccessRow template;
1: 		ColumnOrdering order[];
1: 		boolean alreadyInOrder;
1: 		long estimatedRows;
1: 		int estimatedRowSize;
1: 		T_AccessRow expected[];
1: 
1: 		/*
1: 		** The following sort parameters will be used in every
1: 		** sort in this method.
1: 		*/
1: 		
1: 		implParameters = null;
1: 		template = new T_AccessRow(1, 1, 1);
1: 
1: 		alreadyInOrder = false;
1: 		estimatedRows = 10;
1: 		estimatedRowSize = 12;
1: 
1: 		/*
1: 		** Straight descending sort.
1: 		*/
1: 
1: 		REPORT("(sortDescending) no aggregation");
1: 
1: 		order = new ColumnOrdering[2];
1: 		order[0] = new T_ColumnOrderingImpl(0, false); // descending
1: 		order[1] = new T_ColumnOrderingImpl(1, false); // descending
1: 
1: 		expected = new T_AccessRow[10];
1: 		expected[0] = new T_AccessRow(8, 1, 1);
1: 		expected[1] = new T_AccessRow(4, 8, 1);
1: 		expected[2] = new T_AccessRow(4, 2, 1);
1: 		expected[3] = new T_AccessRow(4, 1, 1);
1: 		expected[4] = new T_AccessRow(3, 8, 1);
1: 		expected[5] = new T_AccessRow(3, 5, 1);
1: 		expected[6] = new T_AccessRow(3, 3, 1);
1: 		expected[7] = new T_AccessRow(3, 3, 1);
1: 		expected[8] = new T_AccessRow(3, 3, 1);
1: 		expected[9] = new T_AccessRow(1, 1, 1);
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DummySortObserver(template), alreadyInOrder, estimatedRows,
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, getSortDescendingInput(), expected, sortid))
1: 			failcount++;
1: 
1: 		/*
1: 		** Descending sort eliminating duplicates
1: 		*/
1: 
1: 		REPORT("(sortDescending) eliminate duplicates");
1: 
1: 		order = new ColumnOrdering[2];
1: 		order[0] = new T_ColumnOrderingImpl(0, false); // descending
1: 		order[1] = new T_ColumnOrderingImpl(1, false); // descending
1: 
1: 		expected = new T_AccessRow[8];
1: 		expected[0] = new T_AccessRow(8, 1, 1);
1: 		expected[1] = new T_AccessRow(4, 8, 1);
1: 		expected[2] = new T_AccessRow(4, 2, 1);
1: 		expected[3] = new T_AccessRow(4, 1, 1);
1: 		expected[4] = new T_AccessRow(3, 8, 1);
1: 		expected[5] = new T_AccessRow(3, 5, 1);
1: 		expected[6] = new T_AccessRow(3, 3, 1);
1: 		expected[7] = new T_AccessRow(1, 1, 1);
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows,
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, getSortDescendingInput(), expected, sortid))
1: 			failcount++;
1: 
1: 		/*
1: 		** Eliminate duplicates, ascending on second column.
1: 		*/
1: 
1: 		REPORT("(sortDescending) descending/ascending - eliminate duplicates");
1: 
1: 		order = new ColumnOrdering[2];
1: 		order[0] = new T_ColumnOrderingImpl(0, false); // descending
1: 		order[1] = new T_ColumnOrderingImpl(1, true); // ascending
1: 
1: 		expected = new T_AccessRow[8];
1: 		expected[0] = new T_AccessRow(8, 1, 1);
1: 		expected[1] = new T_AccessRow(4, 1, 1);
1: 		expected[2] = new T_AccessRow(4, 2, 1);
1: 		expected[3] = new T_AccessRow(4, 8, 1);
1: 		expected[4] = new T_AccessRow(3, 3, 1);
1: 		expected[5] = new T_AccessRow(3, 5, 1);
1: 		expected[6] = new T_AccessRow(3, 8, 1);
1: 		expected[7] = new T_AccessRow(1, 1, 1);
1: 
1: 		sortid = tc.createSort(implParameters, template.getRowArray(),
1: 			order, new T_DuplicateEliminator(template), alreadyInOrder, estimatedRows,
1:             estimatedRowSize);
1: 
1: 		if (!testSort(tc, getSortDescendingInput(), expected, sortid))
1: 			failcount++;
1: 
1: 
1: 		return failcount == 0;
1: 	}
1: 
1: 	private T_AccessRow[] getSortDescendingInput()
1: 	{
1: 		T_AccessRow[] input;
1: 
1: 		input = new T_AccessRow[10];
1: 		input[0] = new T_AccessRow(8, 1, 1);
1: 		input[1] = new T_AccessRow(1, 1, 1);
1: 		input[2] = new T_AccessRow(3, 5, 1);
1: 		input[3] = new T_AccessRow(4, 1, 1);
1: 		input[4] = new T_AccessRow(3, 3, 1);
1: 		input[5] = new T_AccessRow(3, 8, 1);
1: 		input[6] = new T_AccessRow(3, 3, 1);
1: 		input[7] = new T_AccessRow(3, 3, 1);
1: 		input[8] = new T_AccessRow(4, 2, 1);
1: 		input[9] = new T_AccessRow(4, 8, 1);
1: 
1: 		return input;
1: 	}
1: 
1: 
1: 	/**
1: 	Insert the given rows into the given sort, and check that the
1: 	rows retrieved from the sort match the output rows.
1: 	**/
1: 	boolean testSort(TransactionController tc, T_AccessRow in[], T_AccessRow outrow[], long sortid)
1: 		throws StandardException
1: 	{
1: 		// Open a sort controller for inserting the rows.
1: 		SortController sort = tc.openSort(sortid);
1: 
1: 		// Insert the rows to be sorted.
1: 		for (int i = 0; i < in.length; i++)
1: 		{
1: 			if (verbose)
1: 				REPORT("(testSort) in: " + in[i]);
1: 			sort.insert(in[i].getRowArray());
1: 		}
1: 
1: 		// Close the sort controller.  This makes the rows
1: 		// available to be retrieved.
1:         // It also means we are getting final sort statistics.
0:         sort.close();
1: 
1:         // Test the SortInfo part of sort.
1:         SortInfo   sort_info = sort.getSortInfo();
1:         Properties sortprop      = sort_info.getAllSortInfo(null);
1: 
1:         String sortType = sortprop.getProperty(
1: 				MessageService.getTextMessage(SQLState.STORE_RTS_SORT_TYPE));
1:         int numRowsInput = Integer.parseInt(sortprop.getProperty(
1: 			MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_INPUT)));
1:         int numRowsOutput = Integer.parseInt(sortprop.getProperty(
1: 			MessageService.getTextMessage(SQLState.STORE_RTS_NUM_ROWS_OUTPUT)));
1: 
1: 		String external =
1: 			  MessageService.getTextMessage(SQLState.STORE_RTS_EXTERNAL);
1: 		String internal =
1: 			 MessageService.getTextMessage(SQLState.STORE_RTS_INTERNAL);
1:         if (sortType.compareTo(internal) != 0 &&
1:             sortType.compareTo(external) != 0)
1:             FAIL("(testSort) unknown sortType.  Expected internal or external, got " + sortType);
1: 
1:         if (numRowsInput != in.length)
1:             FAIL("(testSort) SortInfo.numRowsInput (value: " + numRowsInput +
1:                 ") is not equal to in.length (value: " + in.length + ")");
1: 
1:         if (numRowsOutput != outrow.length)
1:             FAIL("(testSort) SortInfo.numRowsOutput (value: " +
1:                 numRowsOutput + ") is not equal to outrow.length (value: " + outrow.length + ")");
1: 
1: 		if (sortType.equals(external))
1:         {
1:             int numMergeRuns = Integer.parseInt(sortprop.getProperty(
1: 			 MessageService.getTextMessage(SQLState.STORE_RTS_NUM_MERGE_RUNS)));
0:             Vector mergeRuns = new Vector();
1:             StringTokenizer st = new StringTokenizer(sortprop.getProperty(
1: 			 MessageService.getTextMessage(SQLState.STORE_RTS_MERGE_RUNS_SIZE)),
1: 			 "[],",false);
1:             while (st.hasMoreTokens())
1:                 mergeRuns.addElement(Integer.valueOf(st.nextToken().trim()));
1: 
1:             if (mergeRuns.size() != numMergeRuns)
1:                 FAIL("(testSort) the number of elements in vector SortInfo.mergeRunsSize (value: " +
1:                 mergeRuns.size() + " ) is not equal to SortInfo.numMergeRuns (value: " +
1:                 numMergeRuns + " )");
1: 
1:             int totRunSize = 0;
1:             for (int i = 0; i < mergeRuns.size(); i++)
0:                 totRunSize += ((Integer) mergeRuns.elementAt(i)).intValue();
1:             if (totRunSize != numRowsInput)
1:                FAIL("(testSort) the sum of the elements of the vector SortInfo.mergeRunsSize (value: " +
1:                 totRunSize + " ) is not equal to SortInfo.numRowsInput (value: " +
1:                 numRowsInput + " )");
1:         }
1: 
1: 		sort = null;
1: 
1: 		// Open a sort scan for reading the rows back.
1: 		ScanController scan = tc.openSortScan(sortid, false);
1: 
1: 		// Things that could go wrong.
1: 		boolean mismatch = false;
1: 		boolean toofew = false;
1: 		boolean toomany = false;
1: 
1: 		// Fetch the sorted rows and compare them to the rows
1: 		// in the outrow array.
1: 		T_AccessRow result = new T_AccessRow(3);
1: 		for (int i = 0; i < outrow.length; i++)
1: 		{
1: 			if (scan.next() == false)
1: 			{
1: 				// We were expecting the i'th row from outrow, but
1: 				// it didn't show up!
1: 				toofew = true;
1: 				FAIL("(testSort) Too few rows in sort output");
1: 				break;
1: 			}
1: 
1: 			scan.fetch(result.getRowArray());
1: 			if (verbose)
1: 				REPORT("(testSort) out: " + result);
1: 
1: 			if (!result.equals(outrow[i]))
1: 			{
1: 				// The i'th row from the sort didn't match the
1: 				// i'th row from out.
1: 				mismatch = true;
1: 				FAIL("(testSort) row " + result + " != " + outrow[i]);
1: 			}
1: 		}
1: 
1: 		// We should not see any more rows out of the sort,
1: 		// since we've exhausted the out array.
1: 		while (scan.next() == true)
1: 		{
1: 			scan.fetch(result.getRowArray());
1: 			if (verbose)
1: 				REPORT("(testSort) out: " + result);
1: 			toomany = true;
1: 			FAIL("(testSort) Extra row");
1: 		}
1: 
1:         // Test the ScanInfo part of sort.
1:         ScanInfo   scan_info = scan.getScanInfo();
1:         Properties prop      = scan_info.getAllScanInfo(null);
1: 
1:         if (prop.getProperty(
1: 				MessageService.getTextMessage(SQLState.STORE_RTS_SCAN_TYPE)
1: 							).compareTo(
1: 				MessageService.getTextMessage(SQLState.STORE_RTS_SORT)) != 0)
1:         {
1:             FAIL("(testSort) wrong scanType.  Expected sort, got " +
1:                 prop.getProperty(
1: 					MessageService.getTextMessage(
1: 												SQLState.STORE_RTS_SCAN_TYPE)));
1:         }
1: 
1:         if (tc.countOpens(TransactionController.OPEN_CREATED_SORTS) != 1)
1:         {
1:             FAIL("(testSort) sort count before close is wrong: " +
1:                  tc.countOpens(TransactionController.OPEN_CREATED_SORTS));
1:         }
1: 
1: 		// Close the scan controller (which implicitly destroys the sort).
1: 		scan.close();
1: 		scan = null;
1: 
1:         if (tc.countOpens(TransactionController.OPEN_CREATED_SORTS) != 1)
1:         {
1:             FAIL("(testSort) sort count after close is wrong: " +
1:                  tc.countOpens(TransactionController.OPEN_CREATED_SORTS));
1:         }
1: 
1:         tc.dropSort(sortid);
1: 
1:         if (tc.countOpens(TransactionController.OPEN_CREATED_SORTS) > 0)
1:         {
1:             FAIL("(testSort) a sort is still open.");
1:         }
1: 
1: 		return (!mismatch && !toofew && !toomany);
1: 	}
1: }
1: 
1: 
1: class T_DummySortObserver implements SortObserver
1: {
1: 	T_AccessRow  template;
0: 	Vector vector;
1: 
1: 	T_DummySortObserver(T_AccessRow template)
1: 	{
1: 		this.template = template;
0: 		vector = new Vector();
1: 	}
1: 
1: 	/*
1: 	 * Methods of SortObserver
1: 	 */
1: 	public DataValueDescriptor[] insertNonDuplicateKey(
1:     DataValueDescriptor[] insertRow)	
1: 	{
1: 		return insertRow;
1: 	}
1: 
1: 	public DataValueDescriptor[] insertDuplicateKey(
1:     DataValueDescriptor[]   insertRow, 
1:     DataValueDescriptor[]   existingRow)
1: 	{
1: 		return insertRow;
1: 	}
1: 
1: 	public void addToFreeList(
1:     DataValueDescriptor[]   objectArray, 
1:     int                     maxFreeListSize)
1: 	{
1: 		if (vector.size() < maxFreeListSize)
1: 		{
1: 			vector.addElement(objectArray);
1: 		}
1: 	}
1: 
1: 	public DataValueDescriptor[] getArrayClone()
1: 		throws StandardException
1: 	{
1: 		int lastElement = vector.size();
1: 
1: 		if (lastElement > 0)
1: 		{
0: 			DataValueDescriptor[] retval = 
0:                 (DataValueDescriptor[]) vector.elementAt(lastElement - 1);
0: 			vector.removeElementAt(lastElement - 1);
0: 			return retval;
1: 		}
1: 		return template.getRowArrayClone();
1: 	}
1: }
1: 
1: class T_DuplicateEliminator extends T_DummySortObserver
1: {
1: 
1: 	T_DuplicateEliminator(T_AccessRow template)
1: 	{
1: 		super(template);
1: 	}
1: 	/*
1: 	 * Methods of SortObserver
1: 	 */
1: 	public DataValueDescriptor[] insertNonDuplicateKey(
1:     DataValueDescriptor[] insertRow)	
1: 	{
1: 		return insertRow;
1: 	}
1: 
1: 	public DataValueDescriptor[] insertDuplicateKey(
1:     DataValueDescriptor[] insertRow, 
1:     DataValueDescriptor[] existingRow)
1: 	{
1: 		return null;
1: 	}
1: }
1: 
1: class T_SumForIntCol implements SortObserver
1: {
1: 	private int columnId;
1: 	
1: 	T_SumForIntCol(int columnId)
1: 	{
1: 		this.columnId = columnId;
1: 	}
1: 
1: 	/*
1: 	 * Methods of SortObserver
1: 	 */
1: 
1: 	public DataValueDescriptor[] insertNonDuplicateKey(
1:     DataValueDescriptor[] insertRow)	
1: 	{
1: 		return insertRow;
1: 	}
1: 
1: 	public DataValueDescriptor[] insertDuplicateKey(
1:     DataValueDescriptor[] insertRow, 
1:     DataValueDescriptor[] existingRow)
1: 		throws StandardException
1: 	{
1: 
1: 		// We know, because this is a test program and it's only
1: 		// used this way, that we can safely cast the arguments
1: 		// to SQLInteger.
1: 		SQLInteger increment = (SQLInteger) insertRow[columnId];
1: 		SQLInteger sum = (SQLInteger) existingRow[columnId];
1: 
1: 		// Perform the aggregation.
1: 		sum.plus(sum, increment, sum);
1: 
1: 		return null;
1: 	}
1: 
1: 	public void addToFreeList(
1:     DataValueDescriptor[]   objectArray, 
1:     int                     maxFreeListSize)
1: 	{
1: 	}
1: 
1: 	public DataValueDescriptor[] getArrayClone()
1: 		throws StandardException
1: 	{
1: 		return null;
1: 	}
1: }
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9ce0e0f
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: 	private void setSortBufferSize(final String buf_length) {
0:     	AccessController.doPrivileged(new PrivilegedAction() {
0: 		    public Object run()  {
1: 		    	System.setProperty("derby.storage.sortBufferMax", buf_length);
1: 		    	return null;
1: 		    }
1: 	    });
commit:1093b6d
/////////////////////////////////////////////////////////////////////////
0: 		System.setProperty("derby.storage.sortBufferMax", buf_length);
============================================================================