1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.HashTableNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
20:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:3bb140c: import java.util.Properties;
1:eac0369: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1:3bb140c: import org.apache.derby.iapi.error.StandardException;
1:3bb140c: import org.apache.derby.iapi.reference.ClassName;
1:3bb140c: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableIntHolder;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizable;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizer;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Visitor;
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * A HashTableNode represents a result set where a hash table is built.
2:eac0369:  *
1:eac0369:  */
1:eac0369: 
1:3bb140c: class HashTableNode extends SingleChildResultSetNode
3:eac0369: {
1:eac0369: 	PredicateList	searchPredicateList;
1:eac0369: 	PredicateList	joinPredicateList;
1:eac0369: 
1:eac0369: 	SubqueryList	pSubqueryList;
1:eac0369: 	SubqueryList	rSubqueryList;
1:eac0369: 
1:eac0369: 	/**
1:3bb140c:      * Constructor for a HashTableNode.
1:eac0369: 	 *
1:eac0369: 	 * @param childResult			The child result set
1:eac0369: 	 * @param tableProperties	Properties list associated with the table
1:eac0369: 	 * @param resultColumns			The RCL.
1:eac0369: 	 * @param searchPredicateList	Single table clauses
1:eac0369: 	 * @param joinPredicateList		Multi table clauses
1:eac0369: 	 * @param accessPath			The access path
1:eac0369: 	 * @param costEstimate			The cost estimate
1:eac0369: 	 * @param pSubqueryList			List of subqueries in RCL
1:eac0369: 	 * @param rSubqueryList			List of subqueries in Predicate lists
1:eac0369: 	 * @param hashKeyColumns		Hash key columns
1:3bb140c:      * @param cm                    The context manager
1:eac0369: 	 */
1:3bb140c:     HashTableNode(ResultSetNode  childResult,
1:3bb140c:                   Properties     tableProperties,
1:3bb140c:                   ResultColumnList resultColumns,
1:3bb140c:                   PredicateList  searchPredicateList,
1:3bb140c:                   PredicateList  joinPredicateList,
1:3bb140c:                   AccessPathImpl accessPath,
1:3bb140c:                   CostEstimate   costEstimate,
1:3bb140c:                   SubqueryList   pSubqueryList,
1:3bb140c:                   SubqueryList   rSubqueryList,
1:3bb140c:                   int[]          hashKeyColumns,
1:3bb140c:                   ContextManager cm)
1:eac0369: 	{
1:3bb140c:         super(childResult, tableProperties, cm);
1:11f7ee3:         setResultColumns( resultColumns );
1:3bb140c:         this.searchPredicateList = searchPredicateList;
1:3bb140c:         this.joinPredicateList = joinPredicateList;
1:3bb140c:         this.trulyTheBestAccessPath = accessPath;
1:11f7ee3:         setCostEstimate( costEstimate );
1:3bb140c:         this.pSubqueryList = pSubqueryList;
1:3bb140c:         this.rSubqueryList = rSubqueryList;
1:3bb140c:         setHashKeyColumns(hashKeyColumns);
3:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 *  Optimizable interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Optimizable#modifyAccessPath
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public Optimizable modifyAccessPath(JBitSet outerTables, Optimizer optimizer) 
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1:eac0369: 	 * how tree printing is supposed to work.
1:eac0369: 	 *
1:eac0369: 	 * @param depth		The depth of this node in the tree
1:eac0369: 	 */
1:3bb140c:     @Override
1:3bb140c:     void printSubNodes(int depth)
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			super.printSubNodes(depth);
1:eac0369: 
1:eac0369: 			if (searchPredicateList != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "searchPredicateList: ");
1:eac0369: 				searchPredicateList.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			if (joinPredicateList != null)
1:eac0369: 			{
1:eac0369: 				printLabel(depth, "joinPredicateList: ");
1:eac0369: 				joinPredicateList.treePrint(depth + 1);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * For joins, the tree will be (nodes are left out if the clauses
1:eac0369:      * are empty):
1:eac0369:      *
1:eac0369:      *      ProjectRestrictResultSet -- for the having and the select list
1:eac0369:      *      SortResultSet -- for the group by list
1:eac0369:      *      ProjectRestrictResultSet -- for the where and the select list (if no group or having)
1:eac0369:      *      the result set for the fromList
1:eac0369:      *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369:      */
1:3bb140c:     @Override
1:8fe3166:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
1:eac0369: 							throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:11f7ee3:             SanityManager.ASSERT(getResultColumns() != null, "Tree structure bad");
1:eac0369: 
1:f6fa942:         //
1:f6fa942:         // If we are projecting and restricting the stream from a table
1:f6fa942:         // function, then give the table function all of the information that
1:f6fa942:         // it needs in order to push the projection and qualifiers into
1:f6fa942:         // the table function. See DERBY-4357.
1:f6fa942:         //
1:f6fa942:         if ( childResult instanceof FromVTI )
1:f6fa942:         {
1:f6fa942:             ((FromVTI) childResult).computeProjectionAndRestriction( searchPredicateList );
1:f6fa942:         }
1:f6fa942: 
1:eac0369: 		generateMinion( acb, mb, false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * General logic shared by Core compilation and by the Replication Filter
1:eac0369: 	 * compiler. A couple ResultSets (the ones used by PREPARE SELECT FILTER)
1:eac0369: 	 * implement this method.
1:eac0369: 	 *
1:6b50965: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb the method  the expression will go into
1:eac0369: 	 *
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateResultSet(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		generateMinion( acb, mb, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Logic shared by generate() and generateResultSet().
1:eac0369: 	 *
1:6b50965: 	 * @param acb	The ExpressionClassBuilder for the class being built
1:eac0369: 	 * @param mb the method  the expression will go into
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	private void generateMinion(ExpressionClassBuilder acb,
1:eac0369: 									 MethodBuilder mb, boolean genChildResultSet)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		MethodBuilder	userExprFun;
1:eac0369: 		ValueNode	searchClause = null;
1:eac0369: 		ValueNode	equijoinClause = null;
1:eac0369: 
1:eac0369: 
1:eac0369: 		/* The tableProperties, if non-null, must be correct to get this far.
1:eac0369: 		 * We simply call verifyProperties to set initialCapacity and
1:eac0369: 		 * loadFactor.
1:eac0369: 		 */
1:eac0369: 		verifyProperties(getDataDictionary());
1:eac0369: 
1:eac0369: 		// build up the tree.
1:eac0369: 
1:eac0369: 		/* Put the predicates back into the tree */
1:eac0369: 		if (searchPredicateList != null)
1:eac0369: 		{
1:eac0369: 			// Remove any redundant predicates before restoring
1:eac0369: 			searchPredicateList.removeRedundantPredicates();
1:eac0369: 			searchClause = searchPredicateList.restorePredicates();
1:eac0369: 			/* Allow the searchPredicateList to get garbage collected now
1:eac0369: 			 * that we're done with it.
1:eac0369: 			 */
1:eac0369: 			searchPredicateList = null;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// for the single table predicates, we generate an exprFun
1:eac0369: 		// that evaluates the expression of the clause
1:eac0369: 		// against the current row of the child's result.
1:eac0369: 		// if the restriction is empty, simply pass null
1:eac0369: 		// to optimize for run time performance.
1:eac0369: 
1:eac0369:    		// generate the function and initializer:
1:eac0369:    		// Note: Boolean lets us return nulls (boolean would not)
1:eac0369:    		// private Boolean exprN()
1:eac0369:    		// {
1:eac0369:    		//   return <<searchClause.generate(ps)>>;
1:eac0369:    		// }
1:eac0369:    		// static Method exprN = method pointer to exprN;
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 		// Map the result columns to the source columns
1:1d0c809:         ResultColumnList.ColumnMapping  mappingArrays =
1:11f7ee3:             getResultColumns().mapSourceColumns();
1:1d0c809: 
1:1d0c809:         int[] mapArray = mappingArrays.mapArray;
1:1d0c809: 
1:eac0369: 		int mapArrayItem = acb.addItem(new ReferencedColumnsDescriptorImpl(mapArray));
1:eac0369: 
1:eac0369: 		// Save the hash key columns 
1:eac0369: 
1:eac0369: 		FormatableIntHolder[] fihArray = 
1:eac0369: 				FormatableIntHolder.getFormatableIntHolders(hashKeyColumns()); 
1:eac0369: 		FormatableArrayHolder hashKeyHolder = new FormatableArrayHolder(fihArray);
1:eac0369: 		int hashKeyItem = acb.addItem(hashKeyHolder);
1:eac0369: 
1:eac0369: 		/* Generate the HashTableResultSet:
1:eac0369: 		 *	arg1: childExpress - Expression for childResultSet
1:93ff8cc: 		 *  arg2: searchExpress - Expression for single table predicates
1:93ff8cc: 		 *	arg3	: equijoinExpress - Qualifier[] for hash table look up
1:93ff8cc: 		 *  arg4: projectExpress - Expression for projection, if any
1:93ff8cc: 		 *  arg5: resultSetNumber
1:93ff8cc: 		 *  arg6: mapArrayItem - item # for mapping of source columns
1:93ff8cc: 		 *  arg7: reuseResult - whether or not the result row can be reused
1:eac0369: 		 *						(ie, will it always be the same)
1:93ff8cc: 		 *	arg8: hashKeyItem - item # for int[] of hash column #s
1:93ff8cc: 		 *	arg9: removeDuplicates - don't remove duplicates in hash table (for now)
1:93ff8cc: 		 *	arg10: maxInMemoryRowCount - max row size for in-memory hash table
1:93ff8cc: 		 *	arg11: initialCapacity - initialCapacity for java.util.Hashtable
1:93ff8cc: 		 *	arg12	: loadFactor - loadFactor for java.util.Hashtable
1:93ff8cc: 		 *  arg13: estimated row count
1:93ff8cc: 		 *  arg14: estimated cost
1:93ff8cc: 		 *  arg15: close method
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 
1:eac0369: 		if (genChildResultSet)
1:eac0369: 			childResult.generateResultSet(acb, mb);
1:eac0369: 		else
1:eac0369: 			childResult.generate((ActivationClassBuilder) acb, mb);
1:eac0369: 
1:eac0369: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1:eac0369: 		 * ResultColumnList and ResultSet.
1:eac0369: 		 */
1:eac0369: 		assignResultSetNumber();
1:eac0369: 
1:eac0369: 		/* Set the point of attachment in all subqueries attached
1:eac0369: 		 * to this node.
1:eac0369: 		 */
1:eac0369: 		if (pSubqueryList != null && pSubqueryList.size() > 0)
1:eac0369: 		{
1:11f7ee3: 			pSubqueryList.setPointOfAttachment(getResultSetNumber());
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(pSubqueryList.size() == 0,
1:eac0369: 					"pSubqueryList.size() expected to be 0");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (rSubqueryList != null && rSubqueryList.size() > 0)
1:eac0369: 		{
1:11f7ee3: 			rSubqueryList.setPointOfAttachment(getResultSetNumber());
1:eac0369: 			if (SanityManager.DEBUG)
1:eac0369: 			{
1:eac0369: 				SanityManager.ASSERT(rSubqueryList.size() == 0,
1:eac0369: 					"rSubqueryList.size() expected to be 0");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:ab10884: 		// Get the final cost estimate based on child's cost.
1:11f7ee3: 		setCostEstimate( childResult.getFinalCostEstimate() );
1:eac0369: 
1:eac0369: 		// if there is no searchClause, we just want to pass null.
1:eac0369: 		if (searchClause == null)
1:eac0369: 		{
1:eac0369: 		   	mb.pushNull(ClassName.GeneratedMethod);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			// this sets up the method and the static field.
1:eac0369: 			// generates:
1:eac0369: 			// 	DataValueDescriptor userExprFun { }
1:eac0369: 			userExprFun = acb.newUserExprFun();
1:eac0369: 
1:eac0369: 			// searchClause knows it is returning its value;
1:eac0369: 
1:eac0369: 			/* generates:
1:eac0369: 			 *    return <searchClause.generate(acb)>;
1:eac0369: 			 * and adds it to userExprFun
1:eac0369: 			 * NOTE: The explicit cast to DataValueDescriptor is required
1:eac0369: 			 * since the searchClause may simply be a boolean column or subquery
1:eac0369: 			 * which returns a boolean.  For example:
1:eac0369: 			 *		where booleanColumn
1:eac0369: 			 */
1:eac0369: 
1:eac0369: 			searchClause.generateExpression(acb, userExprFun);
1:eac0369: 			userExprFun.methodReturn();
1:eac0369: 
1:eac0369: 
1:eac0369: 			/* PUSHCOMPILER
1:eac0369: 			userSB.newReturnStatement(searchClause.generateExpression(acb, userSB));
1:eac0369: 			*/
1:eac0369: 
1:eac0369: 			// we are done modifying userExprFun, complete it.
1:eac0369: 			userExprFun.complete();
1:eac0369: 
1:eac0369: 	   		// searchClause is used in the final result set as an access of the new static
1:eac0369:    			// field holding a reference to this new method.
1:eac0369: 			// generates:
1:eac0369: 			//	ActivationClass.userExprFun
1:eac0369: 			// which is the static field that "points" to the userExprFun
1:eac0369: 			// that evaluates the where clause.
1:eac0369:    			acb.pushMethodReference(mb, userExprFun);
1:eac0369: 		}
1:eac0369: 		/* Generate the qualifiers for the look up into
1:eac0369: 		 * the hash table.
1:eac0369: 		 */
1:eac0369: 		joinPredicateList.generateQualifiers(acb, mb, (Optimizable) childResult,
1:eac0369: 														false);
1:eac0369: 
1:eac0369: 		/* Determine whether or not reflection is needed for the projection.
1:eac0369: 		 * Reflection is not needed if all of the columns map directly to source
1:eac0369: 		 * columns.
1:eac0369: 		 */
1:eac0369: 		if (reflectionNeededForProjection())
1:eac0369: 		{
1:eac0369: 			// for the resultColumns, we generate a userExprFun
1:eac0369: 			// that creates a new row from expressions against
1:eac0369: 			// the current row of the child's result.
1:eac0369: 			// (Generate optimization: see if we can simply
1:eac0369: 			// return the current row -- we could, but don't, optimize
1:eac0369: 			// the function call out and have execution understand
1:eac0369: 			// that a null function pointer means take the current row
1:eac0369: 			// as-is, with the performance trade-off as discussed above.)
1:eac0369: 
1:eac0369: 			/* Generate the Row function for the projection */
1:11f7ee3: 			getResultColumns().generateCore(acb, mb, false);
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 		   	mb.pushNull(ClassName.GeneratedMethod);
1:eac0369: 		}
1:eac0369: 
1:11f7ee3: 		mb.push(getResultSetNumber());
1:eac0369: 		mb.push(mapArrayItem);
1:11f7ee3: 		mb.push(getResultColumns().reusableResult());
1:eac0369: 		mb.push(hashKeyItem);
1:eac0369: 		mb.push(false);
1:eac0369: 		mb.push(-1L);
1:eac0369: 		mb.push(initialCapacity);
1:eac0369: 		mb.push(loadFactor);
1:11f7ee3: 		mb.push(getCostEstimate().singleScanRowCount());
1:11f7ee3: 		mb.push(getCostEstimate().getEstimatedCost());
1:eac0369: 
1:9e6e461: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getHashTableResultSet",
1:9e6e461:                 ClassName.NoPutResultSet, 14);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:dd2f5a8: 	 * Accept the visitor for all visitable children of this node.
1:eac0369: 	 * 
1:eac0369: 	 * @param v the visitor
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:dd2f5a8: 	void acceptChildren(Visitor v)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:dd2f5a8: 		super.acceptChildren(v);
1:eac0369: 
1:aebfb28: 		if (searchPredicateList != null)
1:eac0369: 		{
1:eac0369: 			searchPredicateList = (PredicateList)searchPredicateList.accept(v);
1:eac0369: 		}
1:eac0369: 
1:aebfb28: 		if (joinPredicateList != null)
1:eac0369: 		{
1:eac0369: 			joinPredicateList = (PredicateList)joinPredicateList.accept(v);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:11f7ee3
/////////////////////////////////////////////////////////////////////////
1:         setResultColumns( resultColumns );
1:         setCostEstimate( costEstimate );
/////////////////////////////////////////////////////////////////////////
1:             SanityManager.ASSERT(getResultColumns() != null, "Tree structure bad");
/////////////////////////////////////////////////////////////////////////
1:             getResultColumns().mapSourceColumns();
/////////////////////////////////////////////////////////////////////////
1: 			pSubqueryList.setPointOfAttachment(getResultSetNumber());
/////////////////////////////////////////////////////////////////////////
1: 			rSubqueryList.setPointOfAttachment(getResultSetNumber());
/////////////////////////////////////////////////////////////////////////
1: 		setCostEstimate( childResult.getFinalCostEstimate() );
/////////////////////////////////////////////////////////////////////////
1: 			getResultColumns().generateCore(acb, mb, false);
1: 		mb.push(getResultSetNumber());
1: 		mb.push(getResultColumns().reusableResult());
1: 		mb.push(getCostEstimate().singleScanRowCount());
1: 		mb.push(getCostEstimate().getEstimatedCost());
commit:f6fa942
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // If we are projecting and restricting the stream from a table
1:         // function, then give the table function all of the information that
1:         // it needs in order to push the projection and qualifiers into
1:         // the table function. See DERBY-4357.
1:         //
1:         if ( childResult instanceof FromVTI )
1:         {
1:             ((FromVTI) childResult).computeProjectionAndRestriction( searchPredicateList );
1:         }
1: 
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.util.Properties;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.ClassName;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.Optimizer;
1: import org.apache.derby.iapi.sql.compile.Visitor;
1: class HashTableNode extends SingleChildResultSetNode
/////////////////////////////////////////////////////////////////////////
1:      * Constructor for a HashTableNode.
/////////////////////////////////////////////////////////////////////////
1:      * @param cm                    The context manager
1:     HashTableNode(ResultSetNode  childResult,
1:                   Properties     tableProperties,
1:                   ResultColumnList resultColumns,
1:                   PredicateList  searchPredicateList,
1:                   PredicateList  joinPredicateList,
1:                   AccessPathImpl accessPath,
1:                   CostEstimate   costEstimate,
1:                   SubqueryList   pSubqueryList,
1:                   SubqueryList   rSubqueryList,
1:                   int[]          hashKeyColumns,
1:                   ContextManager cm)
1:         super(childResult, tableProperties, cm);
0:         setNodeType(C_NodeTypes.HASH_TABLE_NODE);
0:         this.resultColumns = resultColumns;
1:         this.searchPredicateList = searchPredicateList;
1:         this.joinPredicateList = joinPredicateList;
1:         this.trulyTheBestAccessPath = accessPath;
0:         this.costEstimate = costEstimate;
1:         this.pSubqueryList = pSubqueryList;
1:         this.rSubqueryList = rSubqueryList;
1:         setHashKeyColumns(hashKeyColumns);
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void printSubNodes(int depth)
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
commit:1d0c809
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList.ColumnMapping  mappingArrays =
0:             resultColumns.mapSourceColumns();
1: 
1:         int[] mapArray = mappingArrays.mapArray;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb, MethodBuilder mb)
/////////////////////////////////////////////////////////////////////////
1:     void generateResultSet(ExpressionClassBuilder acb, MethodBuilder mb)
commit:402f3c2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:aebfb28
/////////////////////////////////////////////////////////////////////////
1: 		if (searchPredicateList != null)
1: 		if (joinPredicateList != null)
commit:dd2f5a8
/////////////////////////////////////////////////////////////////////////
1: 	 * Accept the visitor for all visitable children of this node.
1: 	void acceptChildren(Visitor v)
1: 		super.acceptChildren(v);
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getHashTableResultSet",
1:                 ClassName.NoPutResultSet, 14);
commit:93ff8cc
/////////////////////////////////////////////////////////////////////////
1: 		 *  arg2: searchExpress - Expression for single table predicates
1: 		 *	arg3	: equijoinExpress - Qualifier[] for hash table look up
1: 		 *  arg4: projectExpress - Expression for projection, if any
1: 		 *  arg5: resultSetNumber
1: 		 *  arg6: mapArrayItem - item # for mapping of source columns
1: 		 *  arg7: reuseResult - whether or not the result row can be reused
1: 		 *	arg8: hashKeyItem - item # for int[] of hash column #s
1: 		 *	arg9: removeDuplicates - don't remove duplicates in hash table (for now)
1: 		 *	arg10: maxInMemoryRowCount - max row size for in-memory hash table
1: 		 *	arg11: initialCapacity - initialCapacity for java.util.Hashtable
1: 		 *	arg12	: loadFactor - loadFactor for java.util.Hashtable
1: 		 *  arg13: estimated row count
1: 		 *  arg14: estimated cost
1: 		 *  arg15: close method
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getHashTableResultSet", ClassName.NoPutResultSet, 15);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.HashTableNode
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
1: 
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.reference.ClassName;
1: 
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
1: 
1: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
1: import org.apache.derby.iapi.services.io.FormatableIntHolder;
1: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * A HashTableNode represents a result set where a hash table is built.
1:  *
0:  * @author Jerry Brenner
1:  */
1: 
0: public class HashTableNode extends SingleChildResultSetNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 	PredicateList	searchPredicateList;
1: 	PredicateList	joinPredicateList;
1: 
1: 	SubqueryList	pSubqueryList;
1: 	SubqueryList	rSubqueryList;
1: 
1: 	/**
0: 	 * Initializer for a HashTableNode.
1: 	 *
1: 	 * @param childResult			The child result set
1: 	 * @param tableProperties	Properties list associated with the table
1: 	 * @param resultColumns			The RCL.
1: 	 * @param searchPredicateList	Single table clauses
1: 	 * @param joinPredicateList		Multi table clauses
1: 	 * @param accessPath			The access path
1: 	 * @param costEstimate			The cost estimate
1: 	 * @param pSubqueryList			List of subqueries in RCL
1: 	 * @param rSubqueryList			List of subqueries in Predicate lists
1: 	 * @param hashKeyColumns		Hash key columns
1: 	 */
1: 
0: 	public void init(
0: 						 Object childResult,
0: 						 Object tableProperties,
0: 						 Object resultColumns,
0: 						 Object searchPredicateList,
0: 						 Object joinPredicateList,
0: 						 Object accessPath,
0: 						 Object   costEstimate,
0: 						 Object	pSubqueryList,
0: 						 Object   rSubqueryList,
0: 						 Object hashKeyColumns)
1: 	{
0: 		super.init(childResult, tableProperties);
0: 		this.resultColumns = (ResultColumnList) resultColumns;
0: 		this.searchPredicateList = (PredicateList) searchPredicateList;
0: 		this.joinPredicateList = (PredicateList) joinPredicateList;
0: 		this.trulyTheBestAccessPath = (AccessPathImpl) accessPath;
0: 		this.costEstimate = (CostEstimate) costEstimate;
0: 		this.pSubqueryList = (SubqueryList) pSubqueryList;
0: 		this.rSubqueryList = (SubqueryList) rSubqueryList;
0: 		setHashKeyColumns((int[]) hashKeyColumns);
1: 	}
1: 
1: 	/*
1: 	 *  Optimizable interface
1: 	 */
1: 
1: 	/**
1: 	 * @see Optimizable#modifyAccessPath
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public Optimizable modifyAccessPath(JBitSet outerTables, Optimizer optimizer) 
1: 		throws StandardException
1: 	{
1: 		return this;
1: 	}
1: 
1: 	/**
1: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
1: 	 * how tree printing is supposed to work.
1: 	 *
1: 	 * @param depth		The depth of this node in the tree
1: 	 *
0: 	 * @return	Nothing
1: 	 */
1: 
0: 	public void printSubNodes(int depth)
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			super.printSubNodes(depth);
1: 
1: 			if (searchPredicateList != null)
1: 			{
1: 				printLabel(depth, "searchPredicateList: ");
1: 				searchPredicateList.treePrint(depth + 1);
1: 			}
1: 
1: 			if (joinPredicateList != null)
1: 			{
1: 				printLabel(depth, "joinPredicateList: ");
1: 				joinPredicateList.treePrint(depth + 1);
1: 			}
1: 		}
1: 	}
1: 
1:     /**
1:      * For joins, the tree will be (nodes are left out if the clauses
1:      * are empty):
1:      *
1:      *      ProjectRestrictResultSet -- for the having and the select list
1:      *      SortResultSet -- for the group by list
1:      *      ProjectRestrictResultSet -- for the where and the select list (if no group or having)
1:      *      the result set for the fromList
1:      *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
1: 							throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
0:         SanityManager.ASSERT(resultColumns != null, "Tree structure bad");
1: 
1: 		generateMinion( acb, mb, false);
1: 	}
1: 
1: 	/**
1: 	 * General logic shared by Core compilation and by the Replication Filter
1: 	 * compiler. A couple ResultSets (the ones used by PREPARE SELECT FILTER)
1: 	 * implement this method.
1: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb the method  the expression will go into
1: 	 *
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
0: 	public void generateResultSet(ExpressionClassBuilder acb,
0: 										   MethodBuilder mb)
1: 									throws StandardException
1: 	{
1: 		generateMinion( acb, mb, true);
1: 	}
1: 
1: 	/**
1: 	 * Logic shared by generate() and generateResultSet().
1: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
1: 	 * @param mb the method  the expression will go into
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	private void generateMinion(ExpressionClassBuilder acb,
1: 									 MethodBuilder mb, boolean genChildResultSet)
1: 									throws StandardException
1: 	{
1: 		MethodBuilder	userExprFun;
1: 		ValueNode	searchClause = null;
1: 		ValueNode	equijoinClause = null;
1: 
1: 
1: 		/* The tableProperties, if non-null, must be correct to get this far.
1: 		 * We simply call verifyProperties to set initialCapacity and
1: 		 * loadFactor.
1: 		 */
1: 		verifyProperties(getDataDictionary());
1: 
1: 		// build up the tree.
1: 
1: 		/* Put the predicates back into the tree */
1: 		if (searchPredicateList != null)
1: 		{
1: 			// Remove any redundant predicates before restoring
1: 			searchPredicateList.removeRedundantPredicates();
1: 			searchClause = searchPredicateList.restorePredicates();
1: 			/* Allow the searchPredicateList to get garbage collected now
1: 			 * that we're done with it.
1: 			 */
1: 			searchPredicateList = null;
1: 		}
1: 
1: 		// for the single table predicates, we generate an exprFun
1: 		// that evaluates the expression of the clause
1: 		// against the current row of the child's result.
1: 		// if the restriction is empty, simply pass null
1: 		// to optimize for run time performance.
1: 
1:    		// generate the function and initializer:
1:    		// Note: Boolean lets us return nulls (boolean would not)
1:    		// private Boolean exprN()
1:    		// {
1:    		//   return <<searchClause.generate(ps)>>;
1:    		// }
1:    		// static Method exprN = method pointer to exprN;
1: 
1: 
1: 
1: 
1: 
1: 		// Map the result columns to the source columns
0: 		int[] mapArray = resultColumns.mapSourceColumns();
1: 		int mapArrayItem = acb.addItem(new ReferencedColumnsDescriptorImpl(mapArray));
1: 
1: 		// Save the hash key columns 
1: 
1: 		FormatableIntHolder[] fihArray = 
1: 				FormatableIntHolder.getFormatableIntHolders(hashKeyColumns()); 
1: 		FormatableArrayHolder hashKeyHolder = new FormatableArrayHolder(fihArray);
1: 		int hashKeyItem = acb.addItem(hashKeyHolder);
1: 
1: 		/* Generate the HashTableResultSet:
1: 		 *	arg1: childExpress - Expression for childResultSet
0: 		 *  arg2: Activation
0: 		 *  arg3: searchExpress - Expression for single table predicates
0: 		 *	arg4	: equijoinExpress - Qualifier[] for hash table look up
0: 		 *  arg5: projectExpress - Expression for projection, if any
0: 		 *  arg6: resultSetNumber
0: 		 *  arg7: mapArrayItem - item # for mapping of source columns
0: 		 *  arg8: reuseResult - whether or not the result row can be reused
1: 		 *						(ie, will it always be the same)
0: 		 *	arg9: hashKeyItem - item # for int[] of hash column #s
0: 		 *	arg10: removeDuplicates - don't remove duplicates in hash table (for now)
0: 		 *	arg11: maxInMemoryRowCount - max row size for in-memory hash table
0: 		 *	arg12: initialCapacity - initialCapacity for java.util.Hashtable
0: 		 *	arg13	: loadFactor - loadFactor for java.util.Hashtable
0: 		 *  arg14: estimated row count
0: 		 *  arg15: estimated cost
0: 		 *  arg16: close method
1: 		 */
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
1: 
1: 		if (genChildResultSet)
1: 			childResult.generateResultSet(acb, mb);
1: 		else
1: 			childResult.generate((ActivationClassBuilder) acb, mb);
1: 
1: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
1: 		 * ResultColumnList and ResultSet.
1: 		 */
1: 		assignResultSetNumber();
1: 
1: 		/* Set the point of attachment in all subqueries attached
1: 		 * to this node.
1: 		 */
1: 		if (pSubqueryList != null && pSubqueryList.size() > 0)
1: 		{
0: 			pSubqueryList.setPointOfAttachment(resultSetNumber);
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(pSubqueryList.size() == 0,
1: 					"pSubqueryList.size() expected to be 0");
1: 			}
1: 		}
1: 		if (rSubqueryList != null && rSubqueryList.size() > 0)
1: 		{
0: 			rSubqueryList.setPointOfAttachment(resultSetNumber);
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				SanityManager.ASSERT(rSubqueryList.size() == 0,
1: 					"rSubqueryList.size() expected to be 0");
1: 			}
1: 		}
1: 
0: 		// Get the cost estimate from the child if we don't have one yet
0: 		if (costEstimate == null)
1: 		{
0: 			costEstimate = childResult.getCostEstimate();
1: 		}
0: 		acb.pushThisAsActivation(mb);
1: 
1: 		// if there is no searchClause, we just want to pass null.
1: 		if (searchClause == null)
1: 		{
1: 		   	mb.pushNull(ClassName.GeneratedMethod);
1: 		}
1: 		else
1: 		{
1: 			// this sets up the method and the static field.
1: 			// generates:
1: 			// 	DataValueDescriptor userExprFun { }
1: 			userExprFun = acb.newUserExprFun();
1: 
1: 			// searchClause knows it is returning its value;
1: 
1: 			/* generates:
1: 			 *    return <searchClause.generate(acb)>;
1: 			 * and adds it to userExprFun
1: 			 * NOTE: The explicit cast to DataValueDescriptor is required
1: 			 * since the searchClause may simply be a boolean column or subquery
1: 			 * which returns a boolean.  For example:
1: 			 *		where booleanColumn
1: 			 */
1: 
1: 			searchClause.generateExpression(acb, userExprFun);
1: 			userExprFun.methodReturn();
1: 
1: 
1: 			/* PUSHCOMPILER
1: 			userSB.newReturnStatement(searchClause.generateExpression(acb, userSB));
1: 			*/
1: 
1: 			// we are done modifying userExprFun, complete it.
1: 			userExprFun.complete();
1: 
1: 	   		// searchClause is used in the final result set as an access of the new static
1:    			// field holding a reference to this new method.
1: 			// generates:
1: 			//	ActivationClass.userExprFun
1: 			// which is the static field that "points" to the userExprFun
1: 			// that evaluates the where clause.
1:    			acb.pushMethodReference(mb, userExprFun);
1: 		}
1: 		/* Generate the qualifiers for the look up into
1: 		 * the hash table.
1: 		 */
1: 		joinPredicateList.generateQualifiers(acb, mb, (Optimizable) childResult,
1: 														false);
1: 
1: 		/* Determine whether or not reflection is needed for the projection.
1: 		 * Reflection is not needed if all of the columns map directly to source
1: 		 * columns.
1: 		 */
1: 		if (reflectionNeededForProjection())
1: 		{
1: 			// for the resultColumns, we generate a userExprFun
1: 			// that creates a new row from expressions against
1: 			// the current row of the child's result.
1: 			// (Generate optimization: see if we can simply
1: 			// return the current row -- we could, but don't, optimize
1: 			// the function call out and have execution understand
1: 			// that a null function pointer means take the current row
1: 			// as-is, with the performance trade-off as discussed above.)
1: 
1: 			/* Generate the Row function for the projection */
0: 			resultColumns.generateCore(acb, mb, false);
1: 		}
1: 		else
1: 		{
1: 		   	mb.pushNull(ClassName.GeneratedMethod);
1: 		}
1: 
0: 		mb.push(resultSetNumber);
1: 		mb.push(mapArrayItem);
0: 		mb.push(resultColumns.reusableResult());
1: 		mb.push(hashKeyItem);
1: 		mb.push(false);
1: 		mb.push(-1L);
1: 		mb.push(initialCapacity);
1: 		mb.push(loadFactor);
0: 		mb.push(costEstimate.singleScanRowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
1: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getHashTableResultSet", ClassName.NoPutResultSet, 16);
1: 	}
1: 
1: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
1: 	 * 
1: 	 * @param v the visitor
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public Visitable accept(Visitor v) 
1: 		throws StandardException
1: 	{
0: 		if (v.skipChildren(this))
1: 		{
0: 			return v.visit(this);
1: 		}
1: 
0: 		Visitable returnNode = super.accept(v);
1: 
0: 		if (searchPredicateList != null && !v.stopTraversal())
1: 		{
1: 			searchPredicateList = (PredicateList)searchPredicateList.accept(v);
1: 		}
1: 
0: 		if (joinPredicateList != null && !v.stopTraversal())
1: 		{
1: 			joinPredicateList = (PredicateList)joinPredicateList.accept(v);
1: 		}
1: 
0: 		return returnNode;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
/////////////////////////////////////////////////////////////////////////
1: 	 * @param acb	The ExpressionClassBuilder for the class being built
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ab10884
/////////////////////////////////////////////////////////////////////////
1: 		// Get the final cost estimate based on child's cost.
0: 		costEstimate = childResult.getFinalCostEstimate();
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: 
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
0: import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
0: import org.apache.derby.iapi.sql.compile.Optimizer;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
0: import org.apache.derby.iapi.sql.compile.Visitable;
0: import org.apache.derby.iapi.sql.compile.Visitor;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.AccessPath;
0: import org.apache.derby.iapi.reference.ClassName;
0: 
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.catalog.types.ReferencedColumnsDescriptorImpl;
0: 
0: import org.apache.derby.iapi.services.io.FormatableArrayHolder;
0: import org.apache.derby.iapi.services.io.FormatableIntHolder;
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * A HashTableNode represents a result set where a hash table is built.
0:  *
0:  * @author Jerry Brenner
0:  */
0: 
0: public class HashTableNode extends SingleChildResultSetNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	PredicateList	searchPredicateList;
0: 	PredicateList	joinPredicateList;
0: 
0: 	SubqueryList	pSubqueryList;
0: 	SubqueryList	rSubqueryList;
0: 
0: 	/**
0: 	 * Initializer for a HashTableNode.
0: 	 *
0: 	 * @param childResult			The child result set
0: 	 * @param tableProperties	Properties list associated with the table
0: 	 * @param resultColumns			The RCL.
0: 	 * @param searchPredicateList	Single table clauses
0: 	 * @param joinPredicateList		Multi table clauses
0: 	 * @param accessPath			The access path
0: 	 * @param costEstimate			The cost estimate
0: 	 * @param pSubqueryList			List of subqueries in RCL
0: 	 * @param rSubqueryList			List of subqueries in Predicate lists
0: 	 * @param hashKeyColumns		Hash key columns
0: 	 */
0: 
0: 	public void init(
0: 						 Object childResult,
0: 						 Object tableProperties,
0: 						 Object resultColumns,
0: 						 Object searchPredicateList,
0: 						 Object joinPredicateList,
0: 						 Object accessPath,
0: 						 Object   costEstimate,
0: 						 Object	pSubqueryList,
0: 						 Object   rSubqueryList,
0: 						 Object hashKeyColumns)
0: 	{
0: 		super.init(childResult, tableProperties);
0: 		this.resultColumns = (ResultColumnList) resultColumns;
0: 		this.searchPredicateList = (PredicateList) searchPredicateList;
0: 		this.joinPredicateList = (PredicateList) joinPredicateList;
0: 		this.trulyTheBestAccessPath = (AccessPathImpl) accessPath;
0: 		this.costEstimate = (CostEstimate) costEstimate;
0: 		this.pSubqueryList = (SubqueryList) pSubqueryList;
0: 		this.rSubqueryList = (SubqueryList) rSubqueryList;
0: 		setHashKeyColumns((int[]) hashKeyColumns);
0: 	}
0: 
0: 	/*
0: 	 *  Optimizable interface
0: 	 */
0: 
0: 	/**
0: 	 * @see Optimizable#modifyAccessPath
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public Optimizable modifyAccessPath(JBitSet outerTables, Optimizer optimizer) 
0: 		throws StandardException
0: 	{
0: 		return this;
0: 	}
0: 
0: 	/**
0: 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
0: 	 * how tree printing is supposed to work.
0: 	 *
0: 	 * @param depth		The depth of this node in the tree
0: 	 *
0: 	 * @return	Nothing
0: 	 */
0: 
0: 	public void printSubNodes(int depth)
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			super.printSubNodes(depth);
0: 
0: 			if (searchPredicateList != null)
0: 			{
0: 				printLabel(depth, "searchPredicateList: ");
0: 				searchPredicateList.treePrint(depth + 1);
0: 			}
0: 
0: 			if (joinPredicateList != null)
0: 			{
0: 				printLabel(depth, "joinPredicateList: ");
0: 				joinPredicateList.treePrint(depth + 1);
0: 			}
0: 		}
0: 	}
0: 
0:     /**
0:      * For joins, the tree will be (nodes are left out if the clauses
0:      * are empty):
0:      *
0:      *      ProjectRestrictResultSet -- for the having and the select list
0:      *      SortResultSet -- for the group by list
0:      *      ProjectRestrictResultSet -- for the where and the select list (if no group or having)
0:      *      the result set for the fromList
0:      *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0:      */
0: 	public void generate(ActivationClassBuilder acb,
0: 								MethodBuilder mb)
0: 							throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0:         SanityManager.ASSERT(resultColumns != null, "Tree structure bad");
0: 
0: 		generateMinion( acb, mb, false);
0: 	}
0: 
0: 	/**
0: 	 * General logic shared by Core compilation and by the Replication Filter
0: 	 * compiler. A couple ResultSets (the ones used by PREPARE SELECT FILTER)
0: 	 * implement this method.
0: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb the method  the expression will go into
0: 	 *
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public void generateResultSet(ExpressionClassBuilder acb,
0: 										   MethodBuilder mb)
0: 									throws StandardException
0: 	{
0: 		generateMinion( acb, mb, true);
0: 	}
0: 
0: 	/**
0: 	 * Logic shared by generate() and generateResultSet().
0: 	 *
0: 	 * @param ecb	The ExpressionClassBuilder for the class being built
0: 	 * @param mb the method  the expression will go into
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	private void generateMinion(ExpressionClassBuilder acb,
0: 									 MethodBuilder mb, boolean genChildResultSet)
0: 									throws StandardException
0: 	{
0: 		MethodBuilder	userExprFun;
0: 		ValueNode	searchClause = null;
0: 		ValueNode	equijoinClause = null;
0: 
0: 
0: 		/* The tableProperties, if non-null, must be correct to get this far.
0: 		 * We simply call verifyProperties to set initialCapacity and
0: 		 * loadFactor.
0: 		 */
0: 		verifyProperties(getDataDictionary());
0: 
0: 		// build up the tree.
0: 
0: 		/* Put the predicates back into the tree */
0: 		if (searchPredicateList != null)
0: 		{
0: 			// Remove any redundant predicates before restoring
0: 			searchPredicateList.removeRedundantPredicates();
0: 			searchClause = searchPredicateList.restorePredicates();
0: 			/* Allow the searchPredicateList to get garbage collected now
0: 			 * that we're done with it.
0: 			 */
0: 			searchPredicateList = null;
0: 		}
0: 
0: 		// for the single table predicates, we generate an exprFun
0: 		// that evaluates the expression of the clause
0: 		// against the current row of the child's result.
0: 		// if the restriction is empty, simply pass null
0: 		// to optimize for run time performance.
0: 
0:    		// generate the function and initializer:
0:    		// Note: Boolean lets us return nulls (boolean would not)
0:    		// private Boolean exprN()
0:    		// {
0:    		//   return <<searchClause.generate(ps)>>;
0:    		// }
0:    		// static Method exprN = method pointer to exprN;
0: 
0: 
0: 
0: 
0: 
0: 		// Map the result columns to the source columns
0: 		int[] mapArray = resultColumns.mapSourceColumns();
0: 		int mapArrayItem = acb.addItem(new ReferencedColumnsDescriptorImpl(mapArray));
0: 
0: 		// Save the hash key columns 
0: 
0: 		FormatableIntHolder[] fihArray = 
0: 				FormatableIntHolder.getFormatableIntHolders(hashKeyColumns()); 
0: 		FormatableArrayHolder hashKeyHolder = new FormatableArrayHolder(fihArray);
0: 		int hashKeyItem = acb.addItem(hashKeyHolder);
0: 
0: 		/* Generate the HashTableResultSet:
0: 		 *	arg1: childExpress - Expression for childResultSet
0: 		 *  arg2: Activation
0: 		 *  arg3: searchExpress - Expression for single table predicates
0: 		 *	arg4	: equijoinExpress - Qualifier[] for hash table look up
0: 		 *  arg5: projectExpress - Expression for projection, if any
0: 		 *  arg6: resultSetNumber
0: 		 *  arg7: mapArrayItem - item # for mapping of source columns
0: 		 *  arg8: reuseResult - whether or not the result row can be reused
0: 		 *						(ie, will it always be the same)
0: 		 *	arg9: hashKeyItem - item # for int[] of hash column #s
0: 		 *	arg10: removeDuplicates - don't remove duplicates in hash table (for now)
0: 		 *	arg11: maxInMemoryRowCount - max row size for in-memory hash table
0: 		 *	arg12: initialCapacity - initialCapacity for java.util.Hashtable
0: 		 *	arg13	: loadFactor - loadFactor for java.util.Hashtable
0: 		 *  arg14: estimated row count
0: 		 *  arg15: estimated cost
0: 		 *  arg16: close method
0: 		 */
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 
0: 		if (genChildResultSet)
0: 			childResult.generateResultSet(acb, mb);
0: 		else
0: 			childResult.generate((ActivationClassBuilder) acb, mb);
0: 
0: 		/* Get the next ResultSet #, so that we can number this ResultSetNode, its
0: 		 * ResultColumnList and ResultSet.
0: 		 */
0: 		assignResultSetNumber();
0: 
0: 		/* Set the point of attachment in all subqueries attached
0: 		 * to this node.
0: 		 */
0: 		if (pSubqueryList != null && pSubqueryList.size() > 0)
0: 		{
0: 			pSubqueryList.setPointOfAttachment(resultSetNumber);
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(pSubqueryList.size() == 0,
0: 					"pSubqueryList.size() expected to be 0");
0: 			}
0: 		}
0: 		if (rSubqueryList != null && rSubqueryList.size() > 0)
0: 		{
0: 			rSubqueryList.setPointOfAttachment(resultSetNumber);
0: 			if (SanityManager.DEBUG)
0: 			{
0: 				SanityManager.ASSERT(rSubqueryList.size() == 0,
0: 					"rSubqueryList.size() expected to be 0");
0: 			}
0: 		}
0: 
0: 		// Get the cost estimate from the child if we don't have one yet
0: 		if (costEstimate == null)
0: 		{
0: 			costEstimate = childResult.getCostEstimate();
0: 		}
0: 		acb.pushThisAsActivation(mb);
0: 
0: 		// if there is no searchClause, we just want to pass null.
0: 		if (searchClause == null)
0: 		{
0: 		   	mb.pushNull(ClassName.GeneratedMethod);
0: 		}
0: 		else
0: 		{
0: 			// this sets up the method and the static field.
0: 			// generates:
0: 			// 	DataValueDescriptor userExprFun { }
0: 			userExprFun = acb.newUserExprFun();
0: 
0: 			// searchClause knows it is returning its value;
0: 
0: 			/* generates:
0: 			 *    return <searchClause.generate(acb)>;
0: 			 * and adds it to userExprFun
0: 			 * NOTE: The explicit cast to DataValueDescriptor is required
0: 			 * since the searchClause may simply be a boolean column or subquery
0: 			 * which returns a boolean.  For example:
0: 			 *		where booleanColumn
0: 			 */
0: 
0: 			searchClause.generateExpression(acb, userExprFun);
0: 			userExprFun.methodReturn();
0: 
0: 
0: 			/* PUSHCOMPILER
0: 			userSB.newReturnStatement(searchClause.generateExpression(acb, userSB));
0: 			*/
0: 
0: 			// we are done modifying userExprFun, complete it.
0: 			userExprFun.complete();
0: 
0: 	   		// searchClause is used in the final result set as an access of the new static
0:    			// field holding a reference to this new method.
0: 			// generates:
0: 			//	ActivationClass.userExprFun
0: 			// which is the static field that "points" to the userExprFun
0: 			// that evaluates the where clause.
0:    			acb.pushMethodReference(mb, userExprFun);
0: 		}
0: 		/* Generate the qualifiers for the look up into
0: 		 * the hash table.
0: 		 */
0: 		joinPredicateList.generateQualifiers(acb, mb, (Optimizable) childResult,
0: 														false);
0: 
0: 		/* Determine whether or not reflection is needed for the projection.
0: 		 * Reflection is not needed if all of the columns map directly to source
0: 		 * columns.
0: 		 */
0: 		if (reflectionNeededForProjection())
0: 		{
0: 			// for the resultColumns, we generate a userExprFun
0: 			// that creates a new row from expressions against
0: 			// the current row of the child's result.
0: 			// (Generate optimization: see if we can simply
0: 			// return the current row -- we could, but don't, optimize
0: 			// the function call out and have execution understand
0: 			// that a null function pointer means take the current row
0: 			// as-is, with the performance trade-off as discussed above.)
0: 
0: 			/* Generate the Row function for the projection */
0: 			resultColumns.generateCore(acb, mb, false);
0: 		}
0: 		else
0: 		{
0: 		   	mb.pushNull(ClassName.GeneratedMethod);
0: 		}
0: 
0: 		mb.push(resultSetNumber);
0: 		mb.push(mapArrayItem);
0: 		mb.push(resultColumns.reusableResult());
0: 		mb.push(hashKeyItem);
0: 		mb.push(false);
0: 		mb.push(-1L);
0: 		mb.push(initialCapacity);
0: 		mb.push(loadFactor);
0: 		mb.push(costEstimate.singleScanRowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 		closeMethodArgument(acb, mb);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getHashTableResultSet", ClassName.NoPutResultSet, 16);
0: 	}
0: 
0: 	/**
0: 	 * Accept a visitor, and call v.visit()
0: 	 * on child nodes as necessary.  
0: 	 * 
0: 	 * @param v the visitor
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public Visitable accept(Visitor v) 
0: 		throws StandardException
0: 	{
0: 		if (v.skipChildren(this))
0: 		{
0: 			return v.visit(this);
0: 		}
0: 
0: 		Visitable returnNode = super.accept(v);
0: 
0: 		if (searchPredicateList != null && !v.stopTraversal())
0: 		{
0: 			searchPredicateList = (PredicateList)searchPredicateList.accept(v);
0: 		}
0: 
0: 		if (joinPredicateList != null && !v.stopTraversal())
0: 		{
0: 			joinPredicateList = (PredicateList)joinPredicateList.accept(v);
0: 		}
0: 
0: 		return returnNode;
0: 	}
0: }
============================================================================