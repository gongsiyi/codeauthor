4:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.OrderByList
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
26:eac0369: 
10:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.reference.ClassName;
1:b1f84c1: import org.apache.derby.iapi.reference.Limits;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.services.classfile.VMOpcode;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CostEstimate;
1:3bb140c: import org.apache.derby.iapi.sql.compile.Optimizable;
1:3bb140c: import org.apache.derby.iapi.sql.compile.OptimizableList;
1:3bb140c: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1:3bb140c: import org.apache.derby.iapi.sql.compile.RowOrdering;
1:3bb140c: import org.apache.derby.iapi.store.access.ColumnOrdering;
1:3bb140c: import org.apache.derby.iapi.store.access.SortCostController;
1:3bb140c: import org.apache.derby.iapi.types.DataValueDescriptor;
1:3bb140c: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
7:eac0369: /**
1:eac0369:  * An OrderByList is an ordered list of columns in the ORDER BY clause.
1:eac0369:  * That is, the order of columns in this list is significant - the
1:eac0369:  * first column in the list is the most significant in the ordering,
1:eac0369:  * and the last column in the list is the least significant.
7:eac0369:  *
1:eac0369:  */
1:e1f49ca: class OrderByList extends OrderedColumnList<OrderByColumn>
1:eac0369: 						implements RequiredRowOrdering {
1:eac0369: 
1:eac0369: 	private boolean allAscending = true;
1:eac0369: 	private boolean alwaysSort;
1:eac0369: 	private ResultSetNode resultToSort;
1:eac0369: 	private SortCostController scc;
1:eac0369: 	private Object[] resultRow;
1:eac0369: 	private ColumnOrdering[] columnOrdering;
1:eac0369: 	private int estimatedRowSize;
1:eac0369: 	private boolean sortNeeded = true;
1:2060c4a: 	private int resultSetNumber = -1;
1:eac0369: 
1:49300a7:     /**
1:49300a7:      * {@code true} if this instance orders a
1:49300a7:      * {@literal <table value constructor>}.
1:49300a7:      * See {@link #isTableValueCtorOrdering}.
1:49300a7:      */
1:49300a7:     private boolean isTableValueCtorOrdering;
1:49300a7: 
1:49300a7:     /**
1:3bb140c:      * Constructor.
1:49300a7:      * Initialize with the type of the result set this {@code OrderByList} is
1:49300a7:      * attached to, e.g. {@code SELECT}, {@code VALUES} or a set operation.
1:3bb140c:      * @param rs The result set this {@code OrderByList} is ordering. May be
1:3bb140c:      *           null
1:3bb140c:      * @param cm The context manager
1:49300a7:     */
1:3bb140c:    OrderByList(ResultSetNode rs, ContextManager cm) {
1:e1f49ca:        super(OrderByColumn.class, cm);
1:3bb140c:        this.isTableValueCtorOrdering =
1:49300a7:                 (rs instanceof UnionNode &&
1:49300a7:                 ((UnionNode)rs).tableConstructor()) ||
1:49300a7:                 rs instanceof RowResultSetNode;
1:49300a7:     }
1:2bb13ac: 
1:2bb13ac: 	/**
1:eac0369: 		Add a column to the list
1:49300a7: 	
1:eac0369: 		@param column	The column to add to the list
1:eac0369: 	 */
1:3bb140c:     void addOrderByColumn(OrderByColumn column)
7:eac0369: 	{
1:eac0369: 		addElement(column);
1:2060c4a: 
1:eac0369: 		if (! column.isAscending())
1:eac0369: 			allAscending = false;
7:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Are all columns in the list ascending.
1:eac0369: 	 *
1:eac0369: 	 * @return	Whether or not all columns in the list ascending.
1:eac0369: 	 */
1:eac0369: 	boolean allAscending()
1:eac0369: 	{
1:eac0369: 		return allAscending;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a column from the list
1:eac0369: 	
1:eac0369: 		@param position	The column to get from the list
1:eac0369: 	 */
1:3bb140c:     OrderByColumn getOrderByColumn(int position) {
1:e1f49ca:         if (SanityManager.DEBUG) {
1:e1f49ca:             SanityManager.ASSERT(position >=0 && position < size());
1:e1f49ca:         }
1:e1f49ca: 
1:e1f49ca:         return elementAt(position);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2060c4a: 	 *	Bind the update columns by their names to the target resultset of the
1:74d0488:      * cursor specification.
1:2060c4a: 	 *
1:2060c4a: 	 * 	@param target	The underlying result set
1:2060c4a: 	 *	@exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     void bindOrderByColumns(ResultSetNode target)
1:eac0369: 					throws StandardException {
1:eac0369: 
1:eac0369: 		/* Remember the target for use in optimization */
1:eac0369: 		resultToSort = target;
1:eac0369: 
1:eac0369: 		/* Only 1012 columns allowed in ORDER BY clause */
1:e1f49ca:         if (size() > Limits.DB2_MAX_ELEMENTS_IN_ORDER_BY)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_ELEMENTS);
1:eac0369: 		}
1:eac0369: 
1:e1f49ca:         for (OrderByColumn obc : this)
1:eac0369: 		{
1:2bb13ac: 			obc.bindOrderByColumn(target, this);
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Always sort if we are ordering on an expression, and not
1:eac0369: 			** just a column.
1:eac0369: 			*/
1:eac0369: 			if ( !
1:eac0369: 			 (obc.getResultColumn().getExpression() instanceof ColumnReference))
1:eac0369: 			{
1:eac0369: 				alwaysSort = true;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:2bb13ac: 	 * Adjust addedColumnOffset values due to removal of a duplicate column
1:2bb13ac: 	 *
1:2bb13ac: 	 * This routine is called by bind processing when it identifies and
1:2bb13ac: 	 * removes a column from the result column list which was pulled up due
1:2bb13ac: 	 * to its presence in the ORDER BY clause, but which was later found to
1:2bb13ac: 	 * be a duplicate. The OrderByColumn instance for the removed column
1:2bb13ac: 	 * has been adjusted to point to the true column in the result column
1:2bb13ac: 	 * list and its addedColumnOffset has been reset to -1. This routine
1:2bb13ac: 	 * finds any other OrderByColumn instances which had an offset greater
1:2bb13ac: 	 * than that of the column that has been deleted, and decrements their
1:2bb13ac: 	 * addedColumOffset to account for the deleted column's removal.
1:2bb13ac: 	 *
1:2bb13ac: 	 * @param gap   column which has been removed from the result column list
1:2bb13ac: 	 */
1:2bb13ac: 	void closeGap(int gap)
1:2bb13ac: 	{
1:e1f49ca:         for (OrderByColumn obc : this)
1:2bb13ac: 		{
1:2bb13ac: 			obc.collapseAddedColumnGap(gap);
1:2bb13ac: 		}
1:2bb13ac: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Pull up Order By columns by their names to the target resultset
2:eac0369: 		of the cursor specification.
1:eac0369: 
2:eac0369: 		@param target	The underlying result set
1:eac0369: 	
1:eac0369: 	 */
1:3bb140c:     void pullUpOrderByColumns(ResultSetNode target)
1:eac0369: 					throws StandardException {
1:eac0369: 
1:eac0369: 		/* Remember the target for use in optimization */
1:eac0369: 		resultToSort = target;
1:eac0369: 
1:e1f49ca:         for (OrderByColumn obc : this)
1:eac0369: 		{
1:eac0369: 			obc.pullUpOrderByColumn(target);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Is this order by list an in order prefix of the specified RCL.
1:eac0369: 	 * This is useful when deciding if an order by list can be eliminated
1:eac0369: 	 * due to a sort from an underlying distinct or union.
1:eac0369: 	 *
1:eac0369: 	 * @param sourceRCL	The source RCL.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not this order by list an in order prefix of the specified RCL.
1:eac0369: 	 */
1:eac0369: 	boolean isInOrderPrefix(ResultColumnList sourceRCL)
1:eac0369: 	{
3:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:3bb140c:             int rclSize = sourceRCL.size();
1:3bb140c:             if (size() > rclSize)
1:eac0369: 			{
1:eac0369: 				SanityManager.THROWASSERT(
1:eac0369: 					"size() (" + size() + 
1:eac0369: 					") expected to be <= sourceRCL.size() (" +
1:eac0369: 					sourceRCL.size() + ")");
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
5:eac0369: 		int size = size();
5:eac0369: 		for (int index = 0; index < size; index++)
1:eac0369: 		{
1:e1f49ca:             if (elementAt(index).getResultColumn() !=
1:e1f49ca:                 sourceRCL.elementAt(index))
1:eac0369: 			{
1:eac0369: 				return false;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return true;
1:eac0369: 	}
1:c723732: 
1:c723732: 	/**
1:eac0369: 	 * Order by columns now point to the PRN above the node of interest.
1:eac0369: 	 * We need them to point to the RCL under that one.  This is useful
1:eac0369: 	 * when combining sorts where we need to reorder the sorting
1:eac0369: 	 * columns.
1:c723732: 	 */
1:eac0369: 	void resetToSourceRCs()
1:eac0369: 	{
1:e1f49ca:         for (OrderByColumn obc : this)
1:eac0369: 		{
1:eac0369: 			obc.resetToSourceRC();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Build a new RCL with the same RCs as the passed in RCL
1:eac0369: 	 * but in an order that matches the ordering columns.
1:c723732: 	 *
1:eac0369: 	 * @param resultColumns	The RCL to reorder.
1:eac0369: 	 *	
1:eac0369: 	 *	@exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	ResultColumnList reorderRCL(ResultColumnList resultColumns)
3:eac0369: 		throws StandardException
1:c723732: 	{
1:3bb140c:         ResultColumnList newRCL = new ResultColumnList(getContextManager());
1:eac0369: 
1:eac0369: 		/* The new RCL starts with the ordering columns */
1:e1f49ca:         for (OrderByColumn obc : this)
1:eac0369: 		{
1:eac0369: 			newRCL.addElement(obc.getResultColumn());
1:eac0369: 			resultColumns.removeElement(obc.getResultColumn());
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* And ends with the non-ordering columns */
1:eac0369: 		newRCL.destructiveAppend(resultColumns);
1:eac0369: 		newRCL.resetVirtualColumnIds();
1:d5ef906: 		newRCL.copyOrderBySelect(resultColumns);
1:eac0369: 		return newRCL;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Remove any constant columns from this order by list.
1:eac0369: 		Constant columns are ones where all of the column references
1:eac0369: 		are equal to constant expressions according to the given
1:eac0369: 		predicate list.
1:c723732: 	 */
1:eac0369: 	void removeConstantColumns(PredicateList whereClause)
1:eac0369: 	{
1:eac0369: 		/* Walk the list backwards so we can remove elements safely */
1:eac0369: 		for (int loc = size() - 1;
1:eac0369: 			 loc >= 0;
1:eac0369: 			 loc--)
1:eac0369: 		{
1:e1f49ca:             if (elementAt(loc).constantColumn(whereClause))
1:eac0369: 			{
1:eac0369: 				removeElementAt(loc);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Remove any duplicate columns from this order by list.
1:eac0369: 		For example, one may "ORDER BY 1, 1, 2" can be reduced
1:eac0369: 		to "ORDER BY 1, 2".
1:eac0369: 		Beetle 5401.
1:eac0369: 	 */
1:eac0369: 	void removeDupColumns()
1:eac0369: 	{
1:eac0369: 		/* Walk the list backwards so we can remove elements safely */
1:eac0369: 		for (int loc = size() - 1; loc > 0; loc--)
1:eac0369: 		{
1:e1f49ca:             OrderByColumn obc = elementAt(loc);
1:eac0369: 			int           colPosition = obc.getColumnPosition();
1:eac0369: 
1:eac0369: 			for (int inner = 0; inner < loc; inner++)
1:eac0369: 			{
1:e1f49ca:                 OrderByColumn prev_obc = elementAt(inner);
1:eac0369: 				if (colPosition == prev_obc.getColumnPosition())
1:eac0369: 				{
1:eac0369: 					removeElementAt(loc);
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369:     	generate the sort result set operating over the source
1:eac0369: 		expression.
1:eac0369: 
1:eac0369: 		@param acb the tool for building the class
1:eac0369: 		@param mb	the method the generated code is to go into
1:eac0369: 		@exception StandardException thrown on failure
1:eac0369: 	 */
1:9f2ed7d:     void generate(ActivationClassBuilder acb,
1:eac0369: 								MethodBuilder mb,
1:eac0369: 								ResultSetNode child)
1:eac0369: 							throws StandardException 
1:eac0369: 	{
1:c723732: 		/*
1:eac0369: 		** If sorting is not required, don't generate a sort result set -
1:eac0369: 		** just return the child result set.
1:eac0369: 		*/
1:eac0369: 		if ( ! sortNeeded) {
1:eac0369: 			child.generate(acb, mb);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/* Get the next ResultSet#, so we can number this ResultSetNode, its
1:eac0369: 		 * ResultColumnList and ResultSet.
1:eac0369: 		 *
1:eac0369: 		 * REMIND: to do this properly (if order bys can live throughout
1:eac0369: 		 * the tree) there ought to be an OrderByNode that holds its own
1:eac0369: 		 * ResultColumnList that is a lsit of virtual column nodes pointing
1:eac0369: 		 * to the source's result columns.  But since we know it is outermost,
1:eac0369: 		 * we just gloss over that and get ourselves a resultSetNumber
1:eac0369: 		 * directly.
1:eac0369: 		 */
1:eac0369: 		CompilerContext cc = getCompilerContext();
1:eac0369: 
1:eac0369: 
1:c723732: 		/*
1:eac0369: 			create the orderItem and stuff it in.
1:eac0369: 		 */
1:eac0369: 		int orderItem = acb.addItem(acb.getColumnOrdering(this));
1:eac0369: 
1:eac0369: 
1:eac0369: 		/* Generate the SortResultSet:
1:eac0369: 		 *	arg1: childExpress - Expression for childResultSet
1:eac0369: 		 *  arg2: distinct - always false, we have a separate node
1:eac0369: 		 *				for distincts
1:eac0369: 		 *  arg3: isInSortedOrder - is the source result set in sorted order
1:eac0369: 		 *  arg4: orderItem - entry in saved objects for the ordering
1:93ff8cc: 		 *  arg5: rowAllocator - method to construct rows for fetching
1:eac0369: 		 *			from the sort
1:93ff8cc: 		 *  arg6: row size
1:93ff8cc: 		 *  arg7: resultSetNumber
1:93ff8cc: 		 *  arg8: estimated row count
1:93ff8cc: 		 *  arg9: estimated cost
1:eac0369: 		 */
1:eac0369: 
1:eac0369: 		acb.pushGetResultSetFactoryExpression(mb);
1:eac0369: 
1:eac0369: 		child.generate(acb, mb);
1:eac0369: 
1:2060c4a: 		resultSetNumber = cc.getNextResultSetNumber();
1:eac0369: 
1:eac0369: 		// is a distinct query
1:eac0369: 		mb.push(false);
1:eac0369: 
1:eac0369: 		// not in sorted order
1:eac0369: 		mb.push(false);
1:eac0369: 
1:eac0369: 		mb.push(orderItem);
1:eac0369: 
1:eac0369: 		// row allocator
1:bda7291:         mb.push(acb.addItem(child.getResultColumns().buildRowTemplate()));
1:eac0369: 
1:eac0369: 		mb.push(child.getResultColumns().getTotalColumnSize());
1:eac0369: 
1:eac0369: 		mb.push(resultSetNumber);
1:eac0369: 
1:eac0369: 		// Get the cost estimate for the child
1:eac0369: 		// RESOLVE - we will eventually include the cost of the sort
1:ab10884: 		CostEstimate costEstimate = child.getFinalCostEstimate(); 
1:eac0369: 
1:eac0369: 		mb.push(costEstimate.rowCount());
1:eac0369: 		mb.push(costEstimate.getEstimatedCost());
1:eac0369: 
1:eac0369: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getSortResultSet",
1:9e6e461: 							ClassName.NoPutResultSet, 9);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/* RequiredRowOrdering interface */
1:eac0369: 
1:9f0dc0e:     /**
1:9f0dc0e:      * @see RequiredRowOrdering#sortRequired(RowOrdering, OptimizableList, int[])
1:9f0dc0e:      *
1:9f0dc0e:      * @exception StandardException     Thrown on error
1:9f0dc0e:      */
1:9f0dc0e:     public int sortRequired(
1:9f0dc0e:         RowOrdering rowOrdering,
1:9f0dc0e:         OptimizableList optimizableList,
1:9f0dc0e:         int[] proposedJoinOrder) throws StandardException
1:9f0dc0e:     {
1:9f0dc0e:         return sortRequired(rowOrdering,
1:9f0dc0e:                             (JBitSet)null,
1:9f0dc0e:                             optimizableList,
1:9f0dc0e:                             proposedJoinOrder);
1:9f0dc0e:     }
1:eac0369: 
1:9f0dc0e:     /**
1:9f0dc0e:      * @see RequiredRowOrdering#sortRequired(RowOrdering, JBitSet, OptimizableList, int[])
1:9f0dc0e:      *
1:9f0dc0e:      * @exception StandardException     Thrown on error
1:9f0dc0e:      */
1:9f0dc0e:     public int sortRequired(
1:9f0dc0e:         RowOrdering rowOrdering,
1:9f0dc0e:         JBitSet tableMap,
1:9f0dc0e:         OptimizableList optimizableList,
1:9f0dc0e:         int[] proposedJoinOrder) throws StandardException
1:9f0dc0e:     {
1:eac0369: 		/*
1:eac0369: 		** Currently, all indexes are ordered ascending, so a descending
1:eac0369: 		** ORDER BY always requires a sort.
1:eac0369: 		*/
1:eac0369: 		if (alwaysSort)
1:eac0369: 		{
1:eac0369: 			return RequiredRowOrdering.SORT_REQUIRED;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Step through the columns in this list, and ask the
1:eac0369: 		** row ordering whether it is ordered on each column.
1:eac0369: 		*/
1:eac0369: 		int position = 0;
1:eac0369: 		int size = size();
1:eac0369: 		for (int loc = 0; loc < size; loc++)
1:eac0369: 		{
1:eac0369: 			OrderByColumn obc = getOrderByColumn(loc);
1:eac0369: 
1:cc30c0c:             // If the user specified NULLS FIRST or NULLS LAST in such a way
1:cc30c0c:             // as to require NULL values to be re-sorted to be lower than
1:cc30c0c:             // non-NULL values, then a sort is required, as the index holds
1:cc30c0c:             // NULL values unconditionally higher than non-NULL values
1:cc30c0c:             //
1:cc30c0c:             if (obc.isNullsOrderedLow())
1:cc30c0c: 				return RequiredRowOrdering.SORT_REQUIRED;
1:cc30c0c: 
1:eac0369: 			// ResultColumn rc = obc.getResultColumn();
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** This presumes that the OrderByColumn refers directly to
1:eac0369: 			** the base column, i.e. there is no intervening VirtualColumnNode.
1:eac0369: 			*/
1:eac0369: 			// ValueNode expr = obc.getNonRedundantExpression();
1:eac0369: 			ValueNode expr = obc.getResultColumn().getExpression();
1:eac0369: 
1:eac0369: 			if ( ! (expr instanceof ColumnReference))
1:eac0369: 			{
1:eac0369: 				return RequiredRowOrdering.SORT_REQUIRED;
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			ColumnReference cr = (ColumnReference) expr;
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Check whether the table referred to is in the table map (if any).
1:eac0369: 			** If it isn't, we may have an ordering that does not require
1:eac0369: 			** sorting for the tables in a partial join order.  Look for
1:eac0369: 			** columns beyond this column to see whether a referenced table
1:eac0369: 			** is found - if so, sorting is required (for example, in a
1:eac0369: 			** case like ORDER BY S.A, T.B, S.C, sorting is required).
1:eac0369: 			*/
1:eac0369: 			if (tableMap != null)
1:eac0369: 			{
1:eac0369: 				if ( ! tableMap.get(cr.getTableNumber()))
1:eac0369: 				{
1:eac0369: 					/* Table not in partial join order */
1:eac0369: 					for (int remainingPosition = loc + 1;
1:eac0369: 						 remainingPosition < size();
1:eac0369: 						 remainingPosition++)
1:eac0369: 					{
1:eac0369: 						OrderByColumn remainingobc = getOrderByColumn(loc);
1:eac0369: 
1:eac0369: 						ResultColumn remainingrc =
1:eac0369: 												remainingobc.getResultColumn();
1:eac0369: 
1:eac0369: 						ValueNode remainingexpr = remainingrc.getExpression();
1:eac0369: 
1:eac0369: 						if (remainingexpr instanceof ColumnReference)
1:eac0369: 						{
1:eac0369: 							ColumnReference remainingcr =
1:eac0369: 											(ColumnReference) remainingexpr;
1:eac0369: 							if (tableMap.get(remainingcr.getTableNumber()))
1:eac0369: 							{
1:eac0369: 								return RequiredRowOrdering.SORT_REQUIRED;
1:eac0369: 							}
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					return RequiredRowOrdering.NOTHING_REQUIRED;
1:eac0369: 				}
1:eac0369: 			}
1:200a5ea: 			/*
1:200a5ea: 			 * Does this order by column belong to the outermost optimizable in
1:200a5ea: 			 * the current join order?
1:200a5ea: 			 * 
1:200a5ea: 			 * If yes, then we do not need worry about the ordering of the rows
1:200a5ea: 			 * feeding into it. Because the order by column is associated with 
1:200a5ea: 			 * the outermost optimizable, optimizer will not have to deal with 
1:200a5ea: 			 * the order of any rows coming in from the previous optimizables. 
1:200a5ea: 			 * 
1:200a5ea: 			 * But if the current order by column belongs to an inner 
1:200a5ea: 			 * optimizable in the join order, then go through the following
1:200a5ea: 			 * if condition logic.
1:200a5ea: 			 */
1:eac0369: 
1:200a5ea: 			/* If the following boolean is true, then it means that the join 
1:200a5ea: 			 * order being considered has more than one table 
1:200a5ea: 			 */
1:200a5ea: 			boolean moreThanOneTableInJoinOrder = tableMap!=null?
1:200a5ea: 					(!tableMap.hasSingleBitSet()) : false;
1:200a5ea: 			if (moreThanOneTableInJoinOrder) 
1:200a5ea: 			{
1:200a5ea: 				/*
1:200a5ea: 				 * First check if the order by column has a constant comparison
1:200a5ea: 				 * predicate on it or it belongs to an optimizable which is 
1:200a5ea: 				 * always ordered(that means it is a single row table) or the 
1:200a5ea: 				 * column is involved in an equijoin with an optimizable which 
1:200a5ea: 				 * is always ordered on the column on which the equijoin is 
1:200a5ea: 				 * happening. If yes, then we know that the rows will always be 
1:200a5ea: 				 * sorted and hence we do not need to worry if (any) prior 
1:200a5ea: 				 * optimizables in join order are one-row resultsets or not. 
1:200a5ea: 				 */
1:200a5ea: 				if ((!rowOrdering.alwaysOrdered(cr.getTableNumber())) &&
1:200a5ea: 						(!rowOrdering.isColumnAlwaysOrdered(
1:200a5ea: 								cr.getTableNumber(), cr.getColumnNumber())))
1:200a5ea: 				{
1:200a5ea: 					/*
1:200a5ea: 					 * The current order by column is not always ordered which 
1:200a5ea: 					 * means that the rows from it will not necessarily be in 
1:200a5ea: 					 * the sorted order on that column. Because of this, we 
1:200a5ea: 					 * need to make sure that the outer optimizables (outer to 
1:200a5ea: 					 * the order by columns's optimizable) in the join order 
1:200a5ea: 					 * are all one row optimizables, meaning that they can at 
1:200a5ea: 					 * the most return only one row. If they return more than 
1:200a5ea: 					 * one row, then it will require multiple scans of the 
1:200a5ea: 					 * order by column's optimizable and the rows returned 
1:200a5ea: 					 * from those multiple scans may not be ordered correctly.
1:200a5ea: 					 */
1:9f0dc0e: 
1:9f0dc0e:                    for (int i=0;
1:9f0dc0e:                         i < proposedJoinOrder.length &&
1:9f0dc0e:                             proposedJoinOrder[i] != -1; // -1: partial order
1:9f0dc0e:                         i++)
1:200a5ea: 					{
1:9f0dc0e:                        // Get one outer optimizable at a time from the join
1:9f0dc0e:                        // order
1:9f0dc0e:                         Optimizable considerOptimizable = optimizableList.
1:9f0dc0e:                                 getOptimizable(proposedJoinOrder[i]);
1:9f0dc0e: 
1:9f0dc0e:                        // If we have come across the optimizable for the order
1:9f0dc0e:                        // by column in the join order, then we do not need to
1:9f0dc0e:                        // look at the inner optimizables in the join order. As
1:9f0dc0e:                        // long as the outer optimizables are one row
1:9f0dc0e:                        // resultset, or is ordered on the order by column (see
1:9f0dc0e:                        // below check), we are fine to consider sort
1:9f0dc0e:                        // avoidance.
1:200a5ea: 						if (considerOptimizable.getTableNumber() == 
1:200a5ea: 							cr.getTableNumber())
1:200a5ea: 							break;
1:200a5ea: 						/*
1:200a5ea: 						 * The following if condition is checking if the
1:200a5ea: 						 * outer optimizable to the order by column's 
1:200a5ea: 						 * optimizable is one row resultset or not. 
1:200a5ea: 						 * 
1:200a5ea: 						 * If the outer optimizable is one row resultset, 
1:200a5ea: 						 * then move on to the next optimizable in the join 
1:200a5ea: 						 * order and do the same check on that optimizable. 
1:200a5ea: 						 * Continue this  until we are done checking that all 
1:200a5ea: 						 * the outer optimizables in the join order are single 
1:200a5ea: 						 * row resultsets. If we run into an outer optimizable 
1:200a5ea: 						 * which is not one row resultset, then we can not 
1:200a5ea: 						 * consider sort avoidance for the query.
1:200a5ea: 						 */
1:200a5ea: 						if (rowOrdering.alwaysOrdered(
1:200a5ea: 								considerOptimizable.getTableNumber()))
1:200a5ea: 							continue;
1:200a5ea: 						else
1:200a5ea: 							//This outer optimizable can return more than 
1:200a5ea: 							//one row. Because of this, we can't avoid the
1:200a5ea: 							//sorting for this query.
1:200a5ea: 							return RequiredRowOrdering.SORT_REQUIRED;
1:200a5ea: 					}
1:200a5ea: 				}
1:200a5ea: 			}
1:eac0369: 			if ( ! rowOrdering.alwaysOrdered(cr.getTableNumber()))
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** Check whether the ordering is ordered on this column in
1:eac0369: 				** this position.
1:eac0369: 				*/
1:eac0369: 				if ( ! rowOrdering.orderedOnColumn(
1:eac0369: 			  		obc.isAscending() ?
1:eac0369: 								RowOrdering.ASCENDING : RowOrdering.DESCENDING,
1:eac0369: 			  		position,
1:eac0369: 			  		cr.getTableNumber(),
1:eac0369: 			  		cr.getColumnNumber()
1:eac0369: 			  		))
1:eac0369: 				{
1:eac0369: 					return RequiredRowOrdering.SORT_REQUIRED;
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				/*
1:eac0369: 				** The position to ask about is for the columns in tables
1:eac0369: 				** that are *not* always ordered.  The always-ordered tables
1:eac0369: 				** are not counted as part of the list of ordered columns
1:eac0369: 				*/
1:eac0369: 				position++;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return RequiredRowOrdering.NOTHING_REQUIRED;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see RequiredRowOrdering#estimateCost
1:eac0369: 	 *
1:c723732: 	 * @exception StandardException		Thrown on error
1:c723732: 	 */
1:eac0369: 	public void estimateCost(double estimatedInputRows,
1:eac0369: 								RowOrdering rowOrdering,
1:eac0369: 								CostEstimate resultCost)
1:c723732: 					throws StandardException
1:c723732: 	{
1:c723732: 		/*
1:eac0369: 		** Do a bunch of set-up the first time: get the SortCostController,
1:eac0369: 		** the template row, the ColumnOrdering array, and the estimated
1:eac0369: 		** row size.
1:eac0369: 		*/
1:eac0369: 		if (scc == null)
1:eac0369: 		{
1:eac0369: 			scc = getCompilerContext().getSortCostController();
1:eac0369: 
1:c723732: 			resultRow =
1:c723732: 				resultToSort.getResultColumns().buildEmptyRow().getRowArray();
1:c723732: 			columnOrdering = getColumnOrdering();
1:eac0369: 			estimatedRowSize =
1:eac0369: 						resultToSort.getResultColumns().getTotalColumnSize();
1:c723732: 		}
1:c9a1206: 
1:eac0369: 		long inputRows = (long) estimatedInputRows;
1:eac0369: 		long exportRows = inputRows;
1:eac0369: 		double sortCost;
1:c9a1206: 
1:eac0369: 		sortCost = scc.getSortCost(
1:eac0369: 									(DataValueDescriptor[]) resultRow,
1:eac0369: 									columnOrdering,
1:eac0369: 									false,
1:eac0369: 									inputRows,
1:eac0369: 									exportRows,
1:eac0369: 									estimatedRowSize
1:eac0369: 									);
1:eac0369: 
1:eac0369: 		resultCost.setCost(sortCost, estimatedInputRows, estimatedInputRows);
1:c723732: 	}
1:eac0369: 
1:eac0369: 	/** @see RequiredRowOrdering#sortNeeded */
1:eac0369: 	public void sortNeeded()
1:eac0369: 	{
1:eac0369: 		sortNeeded = true;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** @see RequiredRowOrdering#sortNotNeeded */
1:eac0369: 	public void sortNotNeeded()
1:eac0369: 	{
1:eac0369: 		sortNeeded = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Remap all ColumnReferences in this tree to be clones of the
1:eac0369: 	 * underlying expression.
1:c723732: 	 *
4:eac0369: 	 * @exception StandardException		Thrown on error
1:c723732: 	 */
1:eac0369: 	void remapColumnReferencesToExpressions() throws StandardException
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get whether or not a sort is needed.
1:eac0369: 	 *
1:eac0369: 	 * @return Whether or not a sort is needed.
1:eac0369: 	 */
1:eac0369: 	public boolean getSortNeeded()
1:eac0369: 	{
1:eac0369: 		return sortNeeded;
1:eac0369: 	}
1:20bd3c0: 
1:20bd3c0: 	/**
1:20bd3c0: 	 * Determine whether or not this RequiredRowOrdering has a
1:20bd3c0: 	 * DESCENDING requirement for the column referenced by the
1:20bd3c0: 	 * received ColumnReference.
1:20bd3c0: 	 */
1:20bd3c0: 	boolean requiresDescending(ColumnReference cRef, int numOptimizables)
1:20bd3c0: 		throws StandardException
1:20bd3c0: 	{
1:20bd3c0: 		int size = size();
1:20bd3c0: 
1:20bd3c0: 		/* Start by getting the table number and column position for
1:20bd3c0: 		 * the table to which the ColumnReference points.
1:20bd3c0: 		 */
1:20bd3c0: 		JBitSet tNum = new JBitSet(numOptimizables);
1:20bd3c0: 		BaseTableNumbersVisitor btnVis = new BaseTableNumbersVisitor(tNum);
1:20bd3c0: 
1:20bd3c0: 		cRef.accept(btnVis);
1:20bd3c0: 		int crTableNumber = tNum.getFirstSetBit();
1:20bd3c0: 		int crColPosition = btnVis.getColumnNumber();
1:20bd3c0: 
1:20bd3c0: 		if (SanityManager.DEBUG)
1:20bd3c0: 		{
1:20bd3c0: 			/* We assume that we only ever get here if the column
1:20bd3c0: 			 * reference points to a specific column in a specific
1:20bd3c0: 			 * table...
1:20bd3c0: 			 */
1:20bd3c0: 			if ((crTableNumber < 0) || (crColPosition < 0))
1:20bd3c0: 			{
1:20bd3c0: 				SanityManager.THROWASSERT(
1:20bd3c0: 					"Failed to find table/column number for column '" +
1:20bd3c0: 					cRef.getColumnName() + "' when checking for an " +
1:20bd3c0: 					"ORDER BY requirement.");
1:20bd3c0: 			}
1:20bd3c0: 
1:20bd3c0: 			/* Since we started with a single ColumnReference there
1:20bd3c0: 			 * should be exactly one table number.
1:20bd3c0: 			 */
1:20bd3c0: 			if (!tNum.hasSingleBitSet())
1:20bd3c0: 			{
1:20bd3c0: 				SanityManager.THROWASSERT(
1:20bd3c0: 					"Expected ColumnReference '" + cRef.getColumnName() +
1:20bd3c0: 					"' to reference exactly one table, but tables found " +
1:20bd3c0: 					"were: " + tNum);
1:20bd3c0: 			}
1:20bd3c0: 		}
1:20bd3c0: 
1:20bd3c0: 		/* Walk through the various ORDER BY elements to see if
1:20bd3c0: 		 * any of them point to the same table and column that
1:20bd3c0: 		 * we found above.
1:20bd3c0: 		 */
1:20bd3c0: 		for (int loc = 0; loc < size; loc++)
1:20bd3c0: 		{
1:20bd3c0: 			OrderByColumn obc = getOrderByColumn(loc);
1:20bd3c0: 			ResultColumn rcOrderBy = obc.getResultColumn();
1:20bd3c0: 
1:20bd3c0: 			btnVis.reset();
1:20bd3c0: 			rcOrderBy.accept(btnVis);
1:20bd3c0: 			int obTableNumber = tNum.getFirstSetBit();
1:20bd3c0: 			int obColPosition = btnVis.getColumnNumber();
1:20bd3c0: 
1:20bd3c0: 			/* ORDER BY target should always have a table number and
1:20bd3c0: 			 * a column position.  It may not necessarily be a base
1:20bd3c0: 			 * table, but there should be some FromTable for which
1:20bd3c0: 			 * we have a ResultColumnList, and the ORDER BY should
1:20bd3c0: 			 * reference one of the columns in that list (otherwise
1:20bd3c0: 			 * we shouldn't have made it this far).
1:20bd3c0: 			 */
1:20bd3c0: 			if (SanityManager.DEBUG)
1:20bd3c0: 			{
1:20bd3c0: 				/* Since we started with a single ResultColumn there
1:20bd3c0: 				 * should exactly one table number.
1:20bd3c0: 				 */
1:20bd3c0: 				if (!tNum.hasSingleBitSet())
1:20bd3c0: 				{
1:20bd3c0: 					SanityManager.THROWASSERT("Expected ResultColumn '" +
1:20bd3c0: 						rcOrderBy.getColumnName() + "' to reference " +
1:20bd3c0: 						"exactly one table, but found: " + tNum);
1:20bd3c0: 				}
1:20bd3c0: 
1:20bd3c0: 				if (obColPosition < 0)
1:20bd3c0: 				{
1:20bd3c0: 					SanityManager.THROWASSERT(
1:20bd3c0: 						"Failed to find orderBy column number " +
1:20bd3c0: 						"for ORDER BY check on column '" + 
1:20bd3c0: 						cRef.getColumnName() + "'.");
1:20bd3c0: 				}
1:20bd3c0: 			}
1:20bd3c0: 
1:20bd3c0: 			if (crTableNumber != obTableNumber)
1:20bd3c0: 				continue;
1:20bd3c0: 
1:20bd3c0: 			/* They point to the same base table, so check the
1:20bd3c0: 			 * column positions.
1:20bd3c0: 			 */
1:20bd3c0: 
1:20bd3c0: 			if (crColPosition == obColPosition)
1:20bd3c0: 			{
1:20bd3c0: 				/* This ORDER BY element points to the same table
1:20bd3c0: 				 * and column as the received ColumnReference.  So
1:20bd3c0: 				 * return whether or not this ORDER BY element is
1:20bd3c0: 				 * descending.
1:20bd3c0: 				 */
1:20bd3c0: 				return !obc.isAscending();
1:20bd3c0: 			}
1:20bd3c0: 		}
1:20bd3c0: 
1:20bd3c0: 		/* None of the ORDER BY elements referenced the same table
1:20bd3c0: 		 * and column as the received ColumnReference, so there
1:20bd3c0: 		 * is no descending requirement for the ColumnReference's
1:20bd3c0: 		 * source (at least not from this OrderByList).
1:20bd3c0: 		 */
1:20bd3c0: 		return false;
1:20bd3c0: 	}
1:eac0369: 
1:3bb140c:     @Override
1:c9a1206: 	public String toString() {
1:c9a1206: 
1:3bb140c:         StringBuilder buff = new StringBuilder();
1:c9a1206: 
1:c9a1206: 		if (columnOrdering != null) {
1:c9a1206: 			for (int i = 0; i < columnOrdering.length; i++) {
1:c9a1206: 				buff.append("[" + i + "] " + columnOrdering[i] + "\n");
1:c9a1206: 			}
1:c9a1206: 		}
1:c9a1206: 
1:c9a1206: 		return
1:c9a1206: 			"allAscending: " + allAscending + "\n" +
1:c9a1206: 			"alwaysSort:" + allAscending + "\n" +
1:c9a1206: 			"sortNeeded: " + sortNeeded  + "\n" +
1:c9a1206: 			"columnOrdering: " + "\n" +
1:c9a1206: 			buff.toString() + "\n" +
1:c9a1206: 			super.toString();
1:c9a1206: 	}
1:2060c4a: 
1:2060c4a: 	public int getResultSetNumber() {
1:2060c4a: 		return resultSetNumber;
1:2060c4a: 	}
1:49300a7: 
1:49300a7:     /**
1:49300a7:      * @return {@code true} if the {@code ORDER BY} is attached to a
1:49300a7:      * {@literal <table value constructor>}, i.e. a {@code VALUES} clause.
1:49300a7:      */
1:49300a7:     public boolean isTableValueCtorOrdering() {
1:49300a7:         return isTableValueCtorOrdering;
1:49300a7:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
commit:cc30c0c
/////////////////////////////////////////////////////////////////////////
1:             // If the user specified NULLS FIRST or NULLS LAST in such a way
1:             // as to require NULL values to be re-sorted to be lower than
1:             // non-NULL values, then a sort is required, as the index holds
1:             // NULL values unconditionally higher than non-NULL values
1:             //
1:             if (obc.isNullsOrderedLow())
1: 				return RequiredRowOrdering.SORT_REQUIRED;
1: 
commit:2bb13ac
/////////////////////////////////////////////////////////////////////////
1: 			obc.bindOrderByColumn(target, this);
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Adjust addedColumnOffset values due to removal of a duplicate column
1: 	 *
1: 	 * This routine is called by bind processing when it identifies and
1: 	 * removes a column from the result column list which was pulled up due
1: 	 * to its presence in the ORDER BY clause, but which was later found to
1: 	 * be a duplicate. The OrderByColumn instance for the removed column
1: 	 * has been adjusted to point to the true column in the result column
1: 	 * list and its addedColumnOffset has been reset to -1. This routine
1: 	 * finds any other OrderByColumn instances which had an offset greater
1: 	 * than that of the column that has been deleted, and decrements their
1: 	 * addedColumOffset to account for the deleted column's removal.
1: 	 *
1: 	 * @param gap   column which has been removed from the result column list
1: 	 */
1: 	void closeGap(int gap)
1: 	{
0: 		for (int index = 0; index < size(); index++)
1: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
1: 			obc.collapseAddedColumnGap(gap);
1: 		}
1: 	}
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1: class OrderByList extends OrderedColumnList<OrderByColumn>
/////////////////////////////////////////////////////////////////////////
1:        super(OrderByColumn.class, cm);
/////////////////////////////////////////////////////////////////////////
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT(position >=0 && position < size());
1:         }
1: 
1:         return elementAt(position);
/////////////////////////////////////////////////////////////////////////
1:         if (size() > Limits.DB2_MAX_ELEMENTS_IN_ORDER_BY)
1:         for (OrderByColumn obc : this)
/////////////////////////////////////////////////////////////////////////
1:         for (OrderByColumn obc : this)
/////////////////////////////////////////////////////////////////////////
1:         for (OrderByColumn obc : this)
/////////////////////////////////////////////////////////////////////////
1:             if (elementAt(index).getResultColumn() !=
1:                 sourceRCL.elementAt(index))
/////////////////////////////////////////////////////////////////////////
1:         for (OrderByColumn obc : this)
/////////////////////////////////////////////////////////////////////////
1:         for (OrderByColumn obc : this)
/////////////////////////////////////////////////////////////////////////
1:             if (elementAt(loc).constantColumn(whereClause))
/////////////////////////////////////////////////////////////////////////
1:             OrderByColumn obc = elementAt(loc);
1:                 OrderByColumn prev_obc = elementAt(inner);
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
1: import org.apache.derby.iapi.sql.compile.CostEstimate;
1: import org.apache.derby.iapi.sql.compile.Optimizable;
1: import org.apache.derby.iapi.sql.compile.OptimizableList;
1: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
1: import org.apache.derby.iapi.sql.compile.RowOrdering;
1: import org.apache.derby.iapi.store.access.ColumnOrdering;
1: import org.apache.derby.iapi.store.access.SortCostController;
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.util.JBitSet;
/////////////////////////////////////////////////////////////////////////
0: class OrderByList extends OrderedColumnList
/////////////////////////////////////////////////////////////////////////
1:      * Constructor.
1:      * @param rs The result set this {@code OrderByList} is ordering. May be
1:      *           null
1:      * @param cm The context manager
1:    OrderByList(ResultSetNode rs, ContextManager cm) {
0:        super(cm);
0:        setNodeType(C_NodeTypes.ORDER_BY_LIST);
1:        this.isTableValueCtorOrdering =
/////////////////////////////////////////////////////////////////////////
1:     void addOrderByColumn(OrderByColumn column)
/////////////////////////////////////////////////////////////////////////
1:     OrderByColumn getOrderByColumn(int position) {
/////////////////////////////////////////////////////////////////////////
1:     void bindOrderByColumns(ResultSetNode target)
/////////////////////////////////////////////////////////////////////////
1:     void pullUpOrderByColumns(ResultSetNode target)
/////////////////////////////////////////////////////////////////////////
1:             int rclSize = sourceRCL.size();
1:             if (size() > rclSize)
/////////////////////////////////////////////////////////////////////////
1:         ResultColumnList newRCL = new ResultColumnList(getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:         StringBuilder buff = new StringBuilder();
commit:9f0dc0e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @see RequiredRowOrdering#sortRequired(RowOrdering, OptimizableList, int[])
1:      *
1:      * @exception StandardException     Thrown on error
1:      */
1:     public int sortRequired(
1:         RowOrdering rowOrdering,
1:         OptimizableList optimizableList,
1:         int[] proposedJoinOrder) throws StandardException
1:     {
1:         return sortRequired(rowOrdering,
1:                             (JBitSet)null,
1:                             optimizableList,
1:                             proposedJoinOrder);
1:     }
1:     /**
1:      * @see RequiredRowOrdering#sortRequired(RowOrdering, JBitSet, OptimizableList, int[])
1:      *
1:      * @exception StandardException     Thrown on error
1:      */
1:     public int sortRequired(
1:         RowOrdering rowOrdering,
1:         JBitSet tableMap,
1:         OptimizableList optimizableList,
1:         int[] proposedJoinOrder) throws StandardException
1:     {
/////////////////////////////////////////////////////////////////////////
1: 
1:                    for (int i=0;
1:                         i < proposedJoinOrder.length &&
1:                             proposedJoinOrder[i] != -1; // -1: partial order
1:                         i++)
1:                        // Get one outer optimizable at a time from the join
1:                        // order
1:                         Optimizable considerOptimizable = optimizableList.
1:                                 getOptimizable(proposedJoinOrder[i]);
1: 
1:                        // If we have come across the optimizable for the order
1:                        // by column in the join order, then we do not need to
1:                        // look at the inner optimizables in the join order. As
1:                        // long as the outer optimizables are one row
1:                        // resultset, or is ordered on the order by column (see
1:                        // below check), we are fine to consider sort
1:                        // avoidance.
commit:49300a7
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * {@code true} if this instance orders a
1:      * {@literal <table value constructor>}.
1:      * See {@link #isTableValueCtorOrdering}.
1:      */
1:     private boolean isTableValueCtorOrdering;
1: 
1:     /**
1:      * Initialize with the type of the result set this {@code OrderByList} is
1:      * attached to, e.g. {@code SELECT}, {@code VALUES} or a set operation.
0:      * @param rs The result set this {@code OrderByList} is ordering.
1:     */
0:    public void init(Object rs) {
0:         this.isTableValueCtorOrdering =
1:                 (rs instanceof UnionNode &&
1:                 ((UnionNode)rs).tableConstructor()) ||
1:                 rs instanceof RowResultSetNode;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return {@code true} if the {@code ORDER BY} is attached to a
1:      * {@literal <table value constructor>}, i.e. a {@code VALUES} clause.
1:      */
1:     public boolean isTableValueCtorOrdering() {
1:         return isTableValueCtorOrdering;
1:     }
commit:74d0488
/////////////////////////////////////////////////////////////////////////
1:      * cursor specification.
commit:2060c4a
/////////////////////////////////////////////////////////////////////////
1: 	private int resultSetNumber = -1;
/////////////////////////////////////////////////////////////////////////
1: 	 *	Bind the update columns by their names to the target resultset of the
0: 	 * cursor specification. This variant is used by InsertNode.
1: 	 *
1: 	 * 	@param target	The underlying result set
1: 	 *	@exception StandardException		Thrown on error
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1: 		resultSetNumber = cc.getNextResultSetNumber();
/////////////////////////////////////////////////////////////////////////
1: 
1: 	public int getResultSetNumber() {
1: 		return resultSetNumber;
1: 	}
commit:3527fd5
/////////////////////////////////////////////////////////////////////////
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1: 
1: 	public String toString() {
1: 
0: 		StringBuffer buff = new StringBuffer();
1: 
1: 		if (columnOrdering != null) {
1: 			for (int i = 0; i < columnOrdering.length; i++) {
1: 				buff.append("[" + i + "] " + columnOrdering[i] + "\n");
1: 			}
1: 		}
1: 
1: 		return
1: 			"allAscending: " + allAscending + "\n" +
1: 			"alwaysSort:" + allAscending + "\n" +
1: 			"sortNeeded: " + sortNeeded  + "\n" +
1: 			"columnOrdering: " + "\n" +
1: 			buff.toString() + "\n" +
1: 			super.toString();
1: 	}
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9f2ed7d
/////////////////////////////////////////////////////////////////////////
1:     void generate(ActivationClassBuilder acb,
commit:402f3c2
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:bda7291
/////////////////////////////////////////////////////////////////////////
1:         mb.push(acb.addItem(child.getResultColumns().buildRowTemplate()));
commit:d868eed
/////////////////////////////////////////////////////////////////////////
0:         mb.push(acb.addItem(child.getResultColumns().buildRowTemplate(null)));
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:200a5ea
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.sql.compile.Optimizable;
0: import org.apache.derby.iapi.sql.compile.OptimizableList;
/////////////////////////////////////////////////////////////////////////
0: 	public int sortRequired(RowOrdering rowOrdering,
0: 			OptimizableList optimizableList) throws StandardException
0: 		return sortRequired(rowOrdering, (JBitSet) null, optimizableList);
/////////////////////////////////////////////////////////////////////////
0: 	public int sortRequired(RowOrdering rowOrdering, 
0: 			JBitSet tableMap,
0: 			OptimizableList optimizableList)
/////////////////////////////////////////////////////////////////////////
1: 			/*
1: 			 * Does this order by column belong to the outermost optimizable in
1: 			 * the current join order?
1: 			 * 
1: 			 * If yes, then we do not need worry about the ordering of the rows
1: 			 * feeding into it. Because the order by column is associated with 
1: 			 * the outermost optimizable, optimizer will not have to deal with 
1: 			 * the order of any rows coming in from the previous optimizables. 
1: 			 * 
1: 			 * But if the current order by column belongs to an inner 
1: 			 * optimizable in the join order, then go through the following
1: 			 * if condition logic.
1: 			 */
1: 			/* If the following boolean is true, then it means that the join 
1: 			 * order being considered has more than one table 
1: 			 */
1: 			boolean moreThanOneTableInJoinOrder = tableMap!=null?
1: 					(!tableMap.hasSingleBitSet()) : false;
1: 			if (moreThanOneTableInJoinOrder) 
1: 			{
1: 				/*
1: 				 * First check if the order by column has a constant comparison
1: 				 * predicate on it or it belongs to an optimizable which is 
1: 				 * always ordered(that means it is a single row table) or the 
1: 				 * column is involved in an equijoin with an optimizable which 
1: 				 * is always ordered on the column on which the equijoin is 
1: 				 * happening. If yes, then we know that the rows will always be 
1: 				 * sorted and hence we do not need to worry if (any) prior 
1: 				 * optimizables in join order are one-row resultsets or not. 
1: 				 */
1: 				if ((!rowOrdering.alwaysOrdered(cr.getTableNumber())) &&
1: 						(!rowOrdering.isColumnAlwaysOrdered(
1: 								cr.getTableNumber(), cr.getColumnNumber())))
1: 				{
1: 					/*
1: 					 * The current order by column is not always ordered which 
1: 					 * means that the rows from it will not necessarily be in 
1: 					 * the sorted order on that column. Because of this, we 
1: 					 * need to make sure that the outer optimizables (outer to 
1: 					 * the order by columns's optimizable) in the join order 
1: 					 * are all one row optimizables, meaning that they can at 
1: 					 * the most return only one row. If they return more than 
1: 					 * one row, then it will require multiple scans of the 
1: 					 * order by column's optimizable and the rows returned 
1: 					 * from those multiple scans may not be ordered correctly.
1: 					 */
0: 					for (int i=0; i < optimizableList.size(); i++)
1: 					{
0: 						//Get one outer optimizable at a time from the join
0: 						//order
0: 						Optimizable considerOptimizable = 
0: 							optimizableList.getOptimizable(i);
0: 						//If we have come across the optimizable for the order 
0: 						//by column in the join order, then we do not need to 
0: 						//look at the inner optimizables in the join order. As
0: 						//long as the outer optimizables are one row resultset,
0: 						//we are fine to consider sort avoidance.
1: 						if (considerOptimizable.getTableNumber() == 
1: 							cr.getTableNumber())
1: 							break;
1: 						/*
1: 						 * The following if condition is checking if the
1: 						 * outer optimizable to the order by column's 
1: 						 * optimizable is one row resultset or not. 
1: 						 * 
1: 						 * If the outer optimizable is one row resultset, 
1: 						 * then move on to the next optimizable in the join 
1: 						 * order and do the same check on that optimizable. 
1: 						 * Continue this  until we are done checking that all 
1: 						 * the outer optimizables in the join order are single 
1: 						 * row resultsets. If we run into an outer optimizable 
1: 						 * which is not one row resultset, then we can not 
1: 						 * consider sort avoidance for the query.
1: 						 */
1: 						if (rowOrdering.alwaysOrdered(
1: 								considerOptimizable.getTableNumber()))
1: 							continue;
1: 						else
1: 							//This outer optimizable can return more than 
1: 							//one row. Because of this, we can't avoid the
1: 							//sorting for this query.
1: 							return RequiredRowOrdering.SORT_REQUIRED;
1: 					}
1: 				}
1: 			}
author:Army
-------------------------------------------------------------------------------
commit:c723732
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * Adjust the OrderByList after removal of window function columns.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void adjustForWindowFunctionColumns() 	
1: 		throws StandardException
1: 	{	
1: 		/* 
0: 		 * Recreate the template due to removal of window function columns 
0: 		 * in the resultToSort RCL.
1: 		 */
1: 		resultRow =				
1: 				resultToSort.getResultColumns().buildEmptyRow().getRowArray();				
1: 		/*
0: 		 * Adjust the VirtualColumnIds OrderByColumns to the updated RCL. 
1: 		 */
0: 		for (int index = 0; index < size(); index++)
1: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
0: 			obc.bindOrderByColumn(resultToSort, this);
1: 		}
1: 		/* 
0: 		 * Update the columOrdering
1: 		 *
0: 		 * TODO - is this really necessary?
1: 		 */
1: 		columnOrdering = getColumnOrdering();		
1: 	}
commit:20bd3c0
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Determine whether or not this RequiredRowOrdering has a
1: 	 * DESCENDING requirement for the column referenced by the
1: 	 * received ColumnReference.
1: 	 */
1: 	boolean requiresDescending(ColumnReference cRef, int numOptimizables)
1: 		throws StandardException
1: 	{
1: 		int size = size();
1: 
1: 		/* Start by getting the table number and column position for
1: 		 * the table to which the ColumnReference points.
1: 		 */
1: 		JBitSet tNum = new JBitSet(numOptimizables);
1: 		BaseTableNumbersVisitor btnVis = new BaseTableNumbersVisitor(tNum);
1: 
1: 		cRef.accept(btnVis);
1: 		int crTableNumber = tNum.getFirstSetBit();
1: 		int crColPosition = btnVis.getColumnNumber();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			/* We assume that we only ever get here if the column
1: 			 * reference points to a specific column in a specific
1: 			 * table...
1: 			 */
1: 			if ((crTableNumber < 0) || (crColPosition < 0))
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"Failed to find table/column number for column '" +
1: 					cRef.getColumnName() + "' when checking for an " +
1: 					"ORDER BY requirement.");
1: 			}
1: 
1: 			/* Since we started with a single ColumnReference there
1: 			 * should be exactly one table number.
1: 			 */
1: 			if (!tNum.hasSingleBitSet())
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"Expected ColumnReference '" + cRef.getColumnName() +
1: 					"' to reference exactly one table, but tables found " +
1: 					"were: " + tNum);
1: 			}
1: 		}
1: 
1: 		/* Walk through the various ORDER BY elements to see if
1: 		 * any of them point to the same table and column that
1: 		 * we found above.
1: 		 */
1: 		for (int loc = 0; loc < size; loc++)
1: 		{
1: 			OrderByColumn obc = getOrderByColumn(loc);
1: 			ResultColumn rcOrderBy = obc.getResultColumn();
1: 
1: 			btnVis.reset();
1: 			rcOrderBy.accept(btnVis);
1: 			int obTableNumber = tNum.getFirstSetBit();
1: 			int obColPosition = btnVis.getColumnNumber();
1: 
1: 			/* ORDER BY target should always have a table number and
1: 			 * a column position.  It may not necessarily be a base
1: 			 * table, but there should be some FromTable for which
1: 			 * we have a ResultColumnList, and the ORDER BY should
1: 			 * reference one of the columns in that list (otherwise
1: 			 * we shouldn't have made it this far).
1: 			 */
1: 			if (SanityManager.DEBUG)
1: 			{
1: 				/* Since we started with a single ResultColumn there
1: 				 * should exactly one table number.
1: 				 */
1: 				if (!tNum.hasSingleBitSet())
1: 				{
1: 					SanityManager.THROWASSERT("Expected ResultColumn '" +
1: 						rcOrderBy.getColumnName() + "' to reference " +
1: 						"exactly one table, but found: " + tNum);
1: 				}
1: 
1: 				if (obColPosition < 0)
1: 				{
1: 					SanityManager.THROWASSERT(
1: 						"Failed to find orderBy column number " +
1: 						"for ORDER BY check on column '" + 
1: 						cRef.getColumnName() + "'.");
1: 				}
1: 			}
1: 
1: 			if (crTableNumber != obTableNumber)
1: 				continue;
1: 
1: 			/* They point to the same base table, so check the
1: 			 * column positions.
1: 			 */
1: 
1: 			if (crColPosition == obColPosition)
1: 			{
1: 				/* This ORDER BY element points to the same table
1: 				 * and column as the received ColumnReference.  So
1: 				 * return whether or not this ORDER BY element is
1: 				 * descending.
1: 				 */
1: 				return !obc.isAscending();
1: 			}
1: 		}
1: 
1: 		/* None of the ORDER BY elements referenced the same table
1: 		 * and column as the received ColumnReference, so there
1: 		 * is no descending requirement for the ColumnReference's
1: 		 * source (at least not from this OrderByList).
1: 		 */
1: 		return false;
1: 	}
commit:d5ef906
/////////////////////////////////////////////////////////////////////////
1: 		newRCL.copyOrderBySelect(resultColumns);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:3dd03e5
/////////////////////////////////////////////////////////////////////////
commit:9e6e461
/////////////////////////////////////////////////////////////////////////
1: 							ClassName.NoPutResultSet, 9);
commit:bb579f8
/////////////////////////////////////////////////////////////////////////
0:         mb.pushNull(ClassName.GeneratedMethod);
commit:93ff8cc
/////////////////////////////////////////////////////////////////////////
1: 		 *  arg5: rowAllocator - method to construct rows for fetching
1: 		 *  arg6: row size
1: 		 *  arg7: resultSetNumber
1: 		 *  arg8: estimated row count
1: 		 *  arg9: estimated cost
0: 		 *  arg10: closeCleanup
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 							ClassName.NoPutResultSet, 10);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.OrderByList
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
1: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
1: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
1: 
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.store.access.SortCostController;
0: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.DB2Limit;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.util.JBitSet;
1: import org.apache.derby.iapi.services.classfile.VMOpcode;
1: 
0: import java.util.Properties;
1: 
1: /**
1:  * An OrderByList is an ordered list of columns in the ORDER BY clause.
1:  * That is, the order of columns in this list is significant - the
1:  * first column in the list is the most significant in the ordering,
1:  * and the last column in the list is the least significant.
1:  *
0: 	@author ames
1:  */
0: public class OrderByList extends OrderedColumnList
1: 						implements RequiredRowOrdering {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private boolean allAscending = true;
1: 	private boolean alwaysSort;
1: 	private ResultSetNode resultToSort;
1: 	private SortCostController scc;
1: 	private Object[] resultRow;
1: 	private ColumnOrdering[] columnOrdering;
1: 	private int estimatedRowSize;
1: 	private boolean sortNeeded = true;
1: 
1: 	/**
1: 		Add a column to the list
1: 	
1: 		@param column	The column to add to the list
1: 	 */
0: 	public void addOrderByColumn(OrderByColumn column) 
1: 	{
1: 		addElement(column);
1: 
1: 		if (! column.isAscending())
1: 			allAscending = false;
1: 	}
1: 
1: 	/**
1: 	 * Are all columns in the list ascending.
1: 	 *
1: 	 * @return	Whether or not all columns in the list ascending.
1: 	 */
1: 	boolean allAscending()
1: 	{
1: 		return allAscending;
1: 	}
1: 
1: 	/**
1: 		Get a column from the list
1: 	
1: 		@param position	The column to get from the list
1: 	 */
0: 	public OrderByColumn getOrderByColumn(int position) {
1: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(position >=0 && position < size());
0: 		return (OrderByColumn) elementAt(position);
1: 	}
1: 
1: 	/**
0: 		Print the list.
1: 	
0: 		@param depth		The depth at which to indent the sub-nodes
1: 	 */
0: 	public void printSubNodes(int depth) {
1: 
1: 		if (SanityManager.DEBUG) 
1: 		{
0: 			for (int index = 0; index < size(); index++)
1: 			{
0: 				( (OrderByColumn) (elementAt(index)) ).treePrint(depth);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
0: 		Bind the update columns by their names to the target resultset
1: 		of the cursor specification.
1: 
1: 		@param target	The underlying result set
1: 	
0: 		@exception StandardException		Thrown on error
1: 	 */
0: 	public void bindOrderByColumns(ResultSetNode target)
1: 					throws StandardException {
1: 
1: 		/* Remember the target for use in optimization */
1: 		resultToSort = target;
1: 
1: 		int size = size();
1: 
1: 		/* Only 1012 columns allowed in ORDER BY clause */
0: 		if (size > DB2Limit.DB2_MAX_ELEMENTS_IN_ORDER_BY)
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_ELEMENTS);
1: 		}
1: 
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
0: 			obc.bindOrderByColumn(target);
1: 
1: 			/*
1: 			** Always sort if we are ordering on an expression, and not
1: 			** just a column.
1: 			*/
1: 			if ( !
1: 			 (obc.getResultColumn().getExpression() instanceof ColumnReference))
1: 			{
1: 				alwaysSort = true;
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 		Pull up Order By columns by their names to the target resultset
1: 		of the cursor specification.
1: 
1: 		@param target	The underlying result set
1: 	
1: 	 */
0: 	public void pullUpOrderByColumns(ResultSetNode target)
1: 					throws StandardException {
1: 
1: 		/* Remember the target for use in optimization */
1: 		resultToSort = target;
1: 
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
1: 			obc.pullUpOrderByColumn(target);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * Is this order by list an in order prefix of the specified RCL.
1: 	 * This is useful when deciding if an order by list can be eliminated
1: 	 * due to a sort from an underlying distinct or union.
1: 	 *
1: 	 * @param sourceRCL	The source RCL.
1: 	 *
1: 	 * @return Whether or not this order by list an in order prefix of the specified RCL.
1: 	 */
1: 	boolean isInOrderPrefix(ResultColumnList sourceRCL)
1: 	{
0: 		boolean inOrderPrefix = true;
0: 		int rclSize = sourceRCL.size();
1: 
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (size() > sourceRCL.size())
1: 			{
1: 				SanityManager.THROWASSERT(
1: 					"size() (" + size() + 
1: 					") expected to be <= sourceRCL.size() (" +
1: 					sourceRCL.size() + ")");
1: 			}
1: 		}
1: 
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			if (((OrderByColumn) elementAt(index)).getResultColumn() !=
0: 				(ResultColumn) sourceRCL.elementAt(index))
1: 			{
1: 				return false;
1: 			}
1: 		}
1: 		return true;
1: 	}
1: 
1: 	/**
1: 	 * Order by columns now point to the PRN above the node of interest.
1: 	 * We need them to point to the RCL under that one.  This is useful
1: 	 * when combining sorts where we need to reorder the sorting
1: 	 * columns.
1: 	 *
0: 	 * @return Nothing.
1: 	 */
1: 	void resetToSourceRCs()
1: 	{
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
1: 			obc.resetToSourceRC();
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Build a new RCL with the same RCs as the passed in RCL
1: 	 * but in an order that matches the ordering columns.
1: 	 *
1: 	 * @param resultColumns	The RCL to reorder.
1: 	 *	
1: 	 *	@exception StandardException		Thrown on error
1: 	 */
1: 	ResultColumnList reorderRCL(ResultColumnList resultColumns)
1: 		throws StandardException
1: 	{
0: 		ResultColumnList newRCL = (ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
1: 
1: 		/* The new RCL starts with the ordering columns */
1: 		int size = size();
1: 		for (int index = 0; index < size; index++)
1: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
1: 			newRCL.addElement(obc.getResultColumn());
1: 			resultColumns.removeElement(obc.getResultColumn());
1: 		}
1: 
1: 		/* And ends with the non-ordering columns */
1: 		newRCL.destructiveAppend(resultColumns);
1: 		newRCL.resetVirtualColumnIds();
1: 		return newRCL;
1: 	}
1: 
1: 	/**
1: 		Remove any constant columns from this order by list.
1: 		Constant columns are ones where all of the column references
1: 		are equal to constant expressions according to the given
1: 		predicate list.
1: 	 */
1: 	void removeConstantColumns(PredicateList whereClause)
1: 	{
1: 		/* Walk the list backwards so we can remove elements safely */
1: 		for (int loc = size() - 1;
1: 			 loc >= 0;
1: 			 loc--)
1: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(loc);
1: 
0: 			if (obc.constantColumn(whereClause))
1: 			{
1: 				removeElementAt(loc);
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 		Remove any duplicate columns from this order by list.
1: 		For example, one may "ORDER BY 1, 1, 2" can be reduced
1: 		to "ORDER BY 1, 2".
1: 		Beetle 5401.
1: 	 */
1: 	void removeDupColumns()
1: 	{
1: 		/* Walk the list backwards so we can remove elements safely */
1: 		for (int loc = size() - 1; loc > 0; loc--)
1: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(loc);
1: 			int           colPosition = obc.getColumnPosition();
1: 
1: 			for (int inner = 0; inner < loc; inner++)
1: 			{
0: 				OrderByColumn prev_obc = (OrderByColumn) elementAt(inner);
1: 				if (colPosition == prev_obc.getColumnPosition())
1: 				{
1: 					removeElementAt(loc);
1: 					break;
1: 				}
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1:     	generate the sort result set operating over the source
1: 		expression.
1: 
1: 		@param acb the tool for building the class
1: 		@param mb	the method the generated code is to go into
1: 		@exception StandardException thrown on failure
1: 	 */
0: 	public void generate(ActivationClassBuilder acb, 
1: 								MethodBuilder mb,
1: 								ResultSetNode child)
1: 							throws StandardException 
1: 	{
1: 		/*
1: 		** If sorting is not required, don't generate a sort result set -
1: 		** just return the child result set.
1: 		*/
1: 		if ( ! sortNeeded) {
1: 			child.generate(acb, mb);
1: 			return;
1: 		}
1: 
1: 		/* Get the next ResultSet#, so we can number this ResultSetNode, its
1: 		 * ResultColumnList and ResultSet.
1: 		 *
1: 		 * REMIND: to do this properly (if order bys can live throughout
1: 		 * the tree) there ought to be an OrderByNode that holds its own
1: 		 * ResultColumnList that is a lsit of virtual column nodes pointing
1: 		 * to the source's result columns.  But since we know it is outermost,
1: 		 * we just gloss over that and get ourselves a resultSetNumber
1: 		 * directly.
1: 		 */
1: 		CompilerContext cc = getCompilerContext();
1: 
1: 
1: 		/*
1: 			create the orderItem and stuff it in.
1: 		 */
1: 		int orderItem = acb.addItem(acb.getColumnOrdering(this));
1: 
1: 
1: 		/* Generate the SortResultSet:
1: 		 *	arg1: childExpress - Expression for childResultSet
1: 		 *  arg2: distinct - always false, we have a separate node
1: 		 *				for distincts
1: 		 *  arg3: isInSortedOrder - is the source result set in sorted order
1: 		 *  arg4: orderItem - entry in saved objects for the ordering
0: 		 *  arg5: Activation
0: 		 *  arg6: rowAllocator - method to construct rows for fetching
1: 		 *			from the sort
0: 		 *  arg7: row size
0: 		 *  arg8: resultSetNumber
0: 		 *  arg9: estimated row count
0: 		 *  arg10: estimated cost
0: 		 *  arg11: closeCleanup
1: 		 */
1: 
1: 		acb.pushGetResultSetFactoryExpression(mb);
1: 
1: 		child.generate(acb, mb);
1: 
0: 		int resultSetNumber = cc.getNextResultSetNumber();
1: 
1: 		// is a distinct query
1: 		mb.push(false);
1: 
1: 		// not in sorted order
1: 		mb.push(false);
1: 
1: 		mb.push(orderItem);
1: 
0: 		acb.pushThisAsActivation(mb);
1: 
1: 		// row allocator
0: 		child.getResultColumns().generateHolder(acb, mb);
1: 
1: 		mb.push(child.getResultColumns().getTotalColumnSize());
1: 
1: 		mb.push(resultSetNumber);
1: 
1: 		// Get the cost estimate for the child
1: 		// RESOLVE - we will eventually include the cost of the sort
0: 		CostEstimate costEstimate = child.getCostEstimate(); 
1: 
1: 		mb.push(costEstimate.rowCount());
1: 		mb.push(costEstimate.getEstimatedCost());
1: 
1: 		/**
0: 			if this is the statement result set (today, it always is), 
0: 			and there is a current
0: 			date/time request, then a method will have been generated.
0: 			Otherwise, a simple null is passed in to the result set method.
1: 		 */
0: 		acb.pushResultSetClosedMethodFieldAccess(mb);
1: 
1: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getSortResultSet",
0: 							ClassName.NoPutResultSet, 11);
1: 
1: 	}
1: 
1: 	/* RequiredRowOrdering interface */
1: 
1: 	/**
0: 	 * @see RequiredRowOrdering#sortRequired
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public int sortRequired(RowOrdering rowOrdering) throws StandardException
1: 	{
0: 		return sortRequired(rowOrdering, (JBitSet) null);
1: 	}
1: 
1: 	/**
0: 	 * @see RequiredRowOrdering#sortRequired
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public int sortRequired(RowOrdering rowOrdering, JBitSet tableMap)
1: 				throws StandardException
1: 	{
1: 		/*
1: 		** Currently, all indexes are ordered ascending, so a descending
1: 		** ORDER BY always requires a sort.
1: 		*/
1: 		if (alwaysSort)
1: 		{
1: 			return RequiredRowOrdering.SORT_REQUIRED;
1: 		}
1: 
1: 		/*
1: 		** Step through the columns in this list, and ask the
1: 		** row ordering whether it is ordered on each column.
1: 		*/
1: 		int position = 0;
1: 		int size = size();
1: 		for (int loc = 0; loc < size; loc++)
1: 		{
1: 			OrderByColumn obc = getOrderByColumn(loc);
1: 
1: 			// ResultColumn rc = obc.getResultColumn();
1: 
1: 			/*
1: 			** This presumes that the OrderByColumn refers directly to
1: 			** the base column, i.e. there is no intervening VirtualColumnNode.
1: 			*/
1: 			// ValueNode expr = obc.getNonRedundantExpression();
1: 			ValueNode expr = obc.getResultColumn().getExpression();
1: 
1: 			if ( ! (expr instanceof ColumnReference))
1: 			{
1: 				return RequiredRowOrdering.SORT_REQUIRED;
1: 			}
1: 
1: 			ColumnReference cr = (ColumnReference) expr;
1: 
1: 			/*
1: 			** Check whether the table referred to is in the table map (if any).
1: 			** If it isn't, we may have an ordering that does not require
1: 			** sorting for the tables in a partial join order.  Look for
1: 			** columns beyond this column to see whether a referenced table
1: 			** is found - if so, sorting is required (for example, in a
1: 			** case like ORDER BY S.A, T.B, S.C, sorting is required).
1: 			*/
1: 			if (tableMap != null)
1: 			{
1: 				if ( ! tableMap.get(cr.getTableNumber()))
1: 				{
1: 					/* Table not in partial join order */
1: 					for (int remainingPosition = loc + 1;
1: 						 remainingPosition < size();
1: 						 remainingPosition++)
1: 					{
1: 						OrderByColumn remainingobc = getOrderByColumn(loc);
1: 
1: 						ResultColumn remainingrc =
1: 												remainingobc.getResultColumn();
1: 
1: 						ValueNode remainingexpr = remainingrc.getExpression();
1: 
1: 						if (remainingexpr instanceof ColumnReference)
1: 						{
1: 							ColumnReference remainingcr =
1: 											(ColumnReference) remainingexpr;
1: 							if (tableMap.get(remainingcr.getTableNumber()))
1: 							{
1: 								return RequiredRowOrdering.SORT_REQUIRED;
1: 							}
1: 						}
1: 					}
1: 
1: 					return RequiredRowOrdering.NOTHING_REQUIRED;
1: 				}
1: 			}
1: 
1: 			if ( ! rowOrdering.alwaysOrdered(cr.getTableNumber()))
1: 			{
1: 				/*
1: 				** Check whether the ordering is ordered on this column in
1: 				** this position.
1: 				*/
1: 				if ( ! rowOrdering.orderedOnColumn(
1: 			  		obc.isAscending() ?
1: 								RowOrdering.ASCENDING : RowOrdering.DESCENDING,
1: 			  		position,
1: 			  		cr.getTableNumber(),
1: 			  		cr.getColumnNumber()
1: 			  		))
1: 				{
1: 					return RequiredRowOrdering.SORT_REQUIRED;
1: 				}
1: 
1: 				/*
1: 				** The position to ask about is for the columns in tables
1: 				** that are *not* always ordered.  The always-ordered tables
1: 				** are not counted as part of the list of ordered columns
1: 				*/
1: 				position++;
1: 			}
1: 		}
1: 
1: 		return RequiredRowOrdering.NOTHING_REQUIRED;
1: 	}
1: 
1: 	/**
1: 	 * @see RequiredRowOrdering#estimateCost
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void estimateCost(double estimatedInputRows,
1: 								RowOrdering rowOrdering,
1: 								CostEstimate resultCost)
1: 					throws StandardException
1: 	{
1: 		/*
1: 		** Do a bunch of set-up the first time: get the SortCostController,
1: 		** the template row, the ColumnOrdering array, and the estimated
1: 		** row size.
1: 		*/
1: 		if (scc == null)
1: 		{
1: 			scc = getCompilerContext().getSortCostController();
1: 
0: 			resultRow =
0: 				resultToSort.getResultColumns().buildEmptyRow().getRowArray();
0: 			columnOrdering = getColumnOrdering();
1: 			estimatedRowSize =
1: 						resultToSort.getResultColumns().getTotalColumnSize();
1: 		}
1: 
1: 		long inputRows = (long) estimatedInputRows;
1: 		long exportRows = inputRows;
1: 		double sortCost;
1: 
1: 		sortCost = scc.getSortCost(
1: 									(DataValueDescriptor[]) resultRow,
1: 									columnOrdering,
1: 									false,
1: 									inputRows,
1: 									exportRows,
1: 									estimatedRowSize
1: 									);
1: 
1: 		resultCost.setCost(sortCost, estimatedInputRows, estimatedInputRows);
1: 	}
1: 
1: 	/** @see RequiredRowOrdering#sortNeeded */
1: 	public void sortNeeded()
1: 	{
1: 		sortNeeded = true;
1: 	}
1: 
1: 	/** @see RequiredRowOrdering#sortNotNeeded */
1: 	public void sortNotNeeded()
1: 	{
1: 		sortNeeded = false;
1: 	}
1: 
1: 	/**
1: 	 * Remap all ColumnReferences in this tree to be clones of the
1: 	 * underlying expression.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	void remapColumnReferencesToExpressions() throws StandardException
1: 	{
1: 	}
1: 
1: 	/**
1: 	 * Get whether or not a sort is needed.
1: 	 *
1: 	 * @return Whether or not a sort is needed.
1: 	 */
1: 	public boolean getSortNeeded()
1: 	{
1: 		return sortNeeded;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ab10884
/////////////////////////////////////////////////////////////////////////
1: 		CostEstimate costEstimate = child.getFinalCostEstimate(); 
commit:b1f84c1
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
0: 		if (size > Limits.DB2_MAX_ELEMENTS_IN_ORDER_BY)
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.CostEstimate;
0: import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
0: import org.apache.derby.iapi.sql.compile.RowOrdering;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: 
0: import org.apache.derby.iapi.sql.Activation;
0: import org.apache.derby.iapi.sql.ResultSet;
0: 
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.loader.GeneratedMethod;
0: 
0: import org.apache.derby.iapi.store.access.ColumnOrdering;
0: import org.apache.derby.iapi.store.access.SortCostController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.reference.ClassName;
0: import org.apache.derby.iapi.reference.DB2Limit;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: import org.apache.derby.iapi.services.classfile.VMOpcode;
0: 
0: import java.util.Properties;
0: 
0: /**
0:  * An OrderByList is an ordered list of columns in the ORDER BY clause.
0:  * That is, the order of columns in this list is significant - the
0:  * first column in the list is the most significant in the ordering,
0:  * and the last column in the list is the least significant.
0:  *
0: 	@author ames
0:  */
0: public class OrderByList extends OrderedColumnList
0: 						implements RequiredRowOrdering {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private boolean allAscending = true;
0: 	private boolean alwaysSort;
0: 	private ResultSetNode resultToSort;
0: 	private SortCostController scc;
0: 	private Object[] resultRow;
0: 	private ColumnOrdering[] columnOrdering;
0: 	private int estimatedRowSize;
0: 	private boolean sortNeeded = true;
0: 
0: 	/**
0: 		Add a column to the list
0: 	
0: 		@param column	The column to add to the list
0: 	 */
0: 	public void addOrderByColumn(OrderByColumn column) 
0: 	{
0: 		addElement(column);
0: 
0: 		if (! column.isAscending())
0: 			allAscending = false;
0: 	}
0: 
0: 	/**
0: 	 * Are all columns in the list ascending.
0: 	 *
0: 	 * @return	Whether or not all columns in the list ascending.
0: 	 */
0: 	boolean allAscending()
0: 	{
0: 		return allAscending;
0: 	}
0: 
0: 	/**
0: 		Get a column from the list
0: 	
0: 		@param position	The column to get from the list
0: 	 */
0: 	public OrderByColumn getOrderByColumn(int position) {
0: 		if (SanityManager.DEBUG)
0: 		SanityManager.ASSERT(position >=0 && position < size());
0: 		return (OrderByColumn) elementAt(position);
0: 	}
0: 
0: 	/**
0: 		Print the list.
0: 	
0: 		@param depth		The depth at which to indent the sub-nodes
0: 	 */
0: 	public void printSubNodes(int depth) {
0: 
0: 		if (SanityManager.DEBUG) 
0: 		{
0: 			for (int index = 0; index < size(); index++)
0: 			{
0: 				( (OrderByColumn) (elementAt(index)) ).treePrint(depth);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Bind the update columns by their names to the target resultset
0: 		of the cursor specification.
0: 
0: 		@param target	The underlying result set
0: 	
0: 		@exception StandardException		Thrown on error
0: 	 */
0: 	public void bindOrderByColumns(ResultSetNode target)
0: 					throws StandardException {
0: 
0: 		/* Remember the target for use in optimization */
0: 		resultToSort = target;
0: 
0: 		int size = size();
0: 
0: 		/* Only 1012 columns allowed in ORDER BY clause */
0: 		if (size > DB2Limit.DB2_MAX_ELEMENTS_IN_ORDER_BY)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_TOO_MANY_ELEMENTS);
0: 		}
0: 
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
0: 			obc.bindOrderByColumn(target);
0: 
0: 			/*
0: 			** Always sort if we are ordering on an expression, and not
0: 			** just a column.
0: 			*/
0: 			if ( !
0: 			 (obc.getResultColumn().getExpression() instanceof ColumnReference))
0: 			{
0: 				alwaysSort = true;
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Pull up Order By columns by their names to the target resultset
0: 		of the cursor specification.
0: 
0: 		@param target	The underlying result set
0: 	
0: 	 */
0: 	public void pullUpOrderByColumns(ResultSetNode target)
0: 					throws StandardException {
0: 
0: 		/* Remember the target for use in optimization */
0: 		resultToSort = target;
0: 
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
0: 			obc.pullUpOrderByColumn(target);
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * Is this order by list an in order prefix of the specified RCL.
0: 	 * This is useful when deciding if an order by list can be eliminated
0: 	 * due to a sort from an underlying distinct or union.
0: 	 *
0: 	 * @param sourceRCL	The source RCL.
0: 	 *
0: 	 * @return Whether or not this order by list an in order prefix of the specified RCL.
0: 	 */
0: 	boolean isInOrderPrefix(ResultColumnList sourceRCL)
0: 	{
0: 		boolean inOrderPrefix = true;
0: 		int rclSize = sourceRCL.size();
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (size() > sourceRCL.size())
0: 			{
0: 				SanityManager.THROWASSERT(
0: 					"size() (" + size() + 
0: 					") expected to be <= sourceRCL.size() (" +
0: 					sourceRCL.size() + ")");
0: 			}
0: 		}
0: 
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			if (((OrderByColumn) elementAt(index)).getResultColumn() !=
0: 				(ResultColumn) sourceRCL.elementAt(index))
0: 			{
0: 				return false;
0: 			}
0: 		}
0: 		return true;
0: 	}
0: 
0: 	/**
0: 	 * Order by columns now point to the PRN above the node of interest.
0: 	 * We need them to point to the RCL under that one.  This is useful
0: 	 * when combining sorts where we need to reorder the sorting
0: 	 * columns.
0: 	 *
0: 	 * @return Nothing.
0: 	 */
0: 	void resetToSourceRCs()
0: 	{
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
0: 			obc.resetToSourceRC();
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Build a new RCL with the same RCs as the passed in RCL
0: 	 * but in an order that matches the ordering columns.
0: 	 *
0: 	 * @param resultColumns	The RCL to reorder.
0: 	 *	
0: 	 *	@exception StandardException		Thrown on error
0: 	 */
0: 	ResultColumnList reorderRCL(ResultColumnList resultColumns)
0: 		throws StandardException
0: 	{
0: 		ResultColumnList newRCL = (ResultColumnList) getNodeFactory().getNode(
0: 												C_NodeTypes.RESULT_COLUMN_LIST,
0: 												getContextManager());
0: 
0: 		/* The new RCL starts with the ordering columns */
0: 		int size = size();
0: 		for (int index = 0; index < size; index++)
0: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(index);
0: 			newRCL.addElement(obc.getResultColumn());
0: 			resultColumns.removeElement(obc.getResultColumn());
0: 		}
0: 
0: 		/* And ends with the non-ordering columns */
0: 		newRCL.destructiveAppend(resultColumns);
0: 		newRCL.resetVirtualColumnIds();
0: 		return newRCL;
0: 	}
0: 
0: 	/**
0: 		Remove any constant columns from this order by list.
0: 		Constant columns are ones where all of the column references
0: 		are equal to constant expressions according to the given
0: 		predicate list.
0: 	 */
0: 	void removeConstantColumns(PredicateList whereClause)
0: 	{
0: 		/* Walk the list backwards so we can remove elements safely */
0: 		for (int loc = size() - 1;
0: 			 loc >= 0;
0: 			 loc--)
0: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(loc);
0: 
0: 			if (obc.constantColumn(whereClause))
0: 			{
0: 				removeElementAt(loc);
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 		Remove any duplicate columns from this order by list.
0: 		For example, one may "ORDER BY 1, 1, 2" can be reduced
0: 		to "ORDER BY 1, 2".
0: 		Beetle 5401.
0: 	 */
0: 	void removeDupColumns()
0: 	{
0: 		/* Walk the list backwards so we can remove elements safely */
0: 		for (int loc = size() - 1; loc > 0; loc--)
0: 		{
0: 			OrderByColumn obc = (OrderByColumn) elementAt(loc);
0: 			int           colPosition = obc.getColumnPosition();
0: 
0: 			for (int inner = 0; inner < loc; inner++)
0: 			{
0: 				OrderByColumn prev_obc = (OrderByColumn) elementAt(inner);
0: 				if (colPosition == prev_obc.getColumnPosition())
0: 				{
0: 					removeElementAt(loc);
0: 					break;
0: 				}
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0:     	generate the sort result set operating over the source
0: 		expression.
0: 
0: 		@param acb the tool for building the class
0: 		@param mb	the method the generated code is to go into
0: 		@exception StandardException thrown on failure
0: 	 */
0: 	public void generate(ActivationClassBuilder acb, 
0: 								MethodBuilder mb,
0: 								ResultSetNode child)
0: 							throws StandardException 
0: 	{
0: 		/*
0: 		** If sorting is not required, don't generate a sort result set -
0: 		** just return the child result set.
0: 		*/
0: 		if ( ! sortNeeded) {
0: 			child.generate(acb, mb);
0: 			return;
0: 		}
0: 
0: 		/* Get the next ResultSet#, so we can number this ResultSetNode, its
0: 		 * ResultColumnList and ResultSet.
0: 		 *
0: 		 * REMIND: to do this properly (if order bys can live throughout
0: 		 * the tree) there ought to be an OrderByNode that holds its own
0: 		 * ResultColumnList that is a lsit of virtual column nodes pointing
0: 		 * to the source's result columns.  But since we know it is outermost,
0: 		 * we just gloss over that and get ourselves a resultSetNumber
0: 		 * directly.
0: 		 */
0: 		CompilerContext cc = getCompilerContext();
0: 
0: 
0: 		/*
0: 			create the orderItem and stuff it in.
0: 		 */
0: 		int orderItem = acb.addItem(acb.getColumnOrdering(this));
0: 
0: 
0: 		/* Generate the SortResultSet:
0: 		 *	arg1: childExpress - Expression for childResultSet
0: 		 *  arg2: distinct - always false, we have a separate node
0: 		 *				for distincts
0: 		 *  arg3: isInSortedOrder - is the source result set in sorted order
0: 		 *  arg4: orderItem - entry in saved objects for the ordering
0: 		 *  arg5: Activation
0: 		 *  arg6: rowAllocator - method to construct rows for fetching
0: 		 *			from the sort
0: 		 *  arg7: row size
0: 		 *  arg8: resultSetNumber
0: 		 *  arg9: estimated row count
0: 		 *  arg10: estimated cost
0: 		 *  arg11: closeCleanup
0: 		 */
0: 
0: 		acb.pushGetResultSetFactoryExpression(mb);
0: 
0: 		child.generate(acb, mb);
0: 
0: 		int resultSetNumber = cc.getNextResultSetNumber();
0: 
0: 		// is a distinct query
0: 		mb.push(false);
0: 
0: 		// not in sorted order
0: 		mb.push(false);
0: 
0: 		mb.push(orderItem);
0: 
0: 		acb.pushThisAsActivation(mb);
0: 
0: 		// row allocator
0: 		child.getResultColumns().generateHolder(acb, mb);
0: 
0: 		mb.push(child.getResultColumns().getTotalColumnSize());
0: 
0: 		mb.push(resultSetNumber);
0: 
0: 		// Get the cost estimate for the child
0: 		// RESOLVE - we will eventually include the cost of the sort
0: 		CostEstimate costEstimate = child.getCostEstimate(); 
0: 
0: 		mb.push(costEstimate.rowCount());
0: 		mb.push(costEstimate.getEstimatedCost());
0: 
0: 		/**
0: 			if this is the statement result set (today, it always is), 
0: 			and there is a current
0: 			date/time request, then a method will have been generated.
0: 			Otherwise, a simple null is passed in to the result set method.
0: 		 */
0: 		acb.pushResultSetClosedMethodFieldAccess(mb);
0: 
0: 		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, "getSortResultSet",
0: 							ClassName.NoPutResultSet, 11);
0: 
0: 	}
0: 
0: 	/* RequiredRowOrdering interface */
0: 
0: 	/**
0: 	 * @see RequiredRowOrdering#sortRequired
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public int sortRequired(RowOrdering rowOrdering) throws StandardException
0: 	{
0: 		return sortRequired(rowOrdering, (JBitSet) null);
0: 	}
0: 
0: 	/**
0: 	 * @see RequiredRowOrdering#sortRequired
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public int sortRequired(RowOrdering rowOrdering, JBitSet tableMap)
0: 				throws StandardException
0: 	{
0: 		/*
0: 		** Currently, all indexes are ordered ascending, so a descending
0: 		** ORDER BY always requires a sort.
0: 		*/
0: 		if (alwaysSort)
0: 		{
0: 			return RequiredRowOrdering.SORT_REQUIRED;
0: 		}
0: 
0: 		/*
0: 		** Step through the columns in this list, and ask the
0: 		** row ordering whether it is ordered on each column.
0: 		*/
0: 		int position = 0;
0: 		int size = size();
0: 		for (int loc = 0; loc < size; loc++)
0: 		{
0: 			OrderByColumn obc = getOrderByColumn(loc);
0: 
0: 			// ResultColumn rc = obc.getResultColumn();
0: 
0: 			/*
0: 			** This presumes that the OrderByColumn refers directly to
0: 			** the base column, i.e. there is no intervening VirtualColumnNode.
0: 			*/
0: 			// ValueNode expr = obc.getNonRedundantExpression();
0: 			ValueNode expr = obc.getResultColumn().getExpression();
0: 
0: 			if ( ! (expr instanceof ColumnReference))
0: 			{
0: 				return RequiredRowOrdering.SORT_REQUIRED;
0: 			}
0: 
0: 			ColumnReference cr = (ColumnReference) expr;
0: 
0: 			/*
0: 			** Check whether the table referred to is in the table map (if any).
0: 			** If it isn't, we may have an ordering that does not require
0: 			** sorting for the tables in a partial join order.  Look for
0: 			** columns beyond this column to see whether a referenced table
0: 			** is found - if so, sorting is required (for example, in a
0: 			** case like ORDER BY S.A, T.B, S.C, sorting is required).
0: 			*/
0: 			if (tableMap != null)
0: 			{
0: 				if ( ! tableMap.get(cr.getTableNumber()))
0: 				{
0: 					/* Table not in partial join order */
0: 					for (int remainingPosition = loc + 1;
0: 						 remainingPosition < size();
0: 						 remainingPosition++)
0: 					{
0: 						OrderByColumn remainingobc = getOrderByColumn(loc);
0: 
0: 						ResultColumn remainingrc =
0: 												remainingobc.getResultColumn();
0: 
0: 						ValueNode remainingexpr = remainingrc.getExpression();
0: 
0: 						if (remainingexpr instanceof ColumnReference)
0: 						{
0: 							ColumnReference remainingcr =
0: 											(ColumnReference) remainingexpr;
0: 							if (tableMap.get(remainingcr.getTableNumber()))
0: 							{
0: 								return RequiredRowOrdering.SORT_REQUIRED;
0: 							}
0: 						}
0: 					}
0: 
0: 					return RequiredRowOrdering.NOTHING_REQUIRED;
0: 				}
0: 			}
0: 
0: 			if ( ! rowOrdering.alwaysOrdered(cr.getTableNumber()))
0: 			{
0: 				/*
0: 				** Check whether the ordering is ordered on this column in
0: 				** this position.
0: 				*/
0: 				if ( ! rowOrdering.orderedOnColumn(
0: 			  		obc.isAscending() ?
0: 								RowOrdering.ASCENDING : RowOrdering.DESCENDING,
0: 			  		position,
0: 			  		cr.getTableNumber(),
0: 			  		cr.getColumnNumber()
0: 			  		))
0: 				{
0: 					return RequiredRowOrdering.SORT_REQUIRED;
0: 				}
0: 
0: 				/*
0: 				** The position to ask about is for the columns in tables
0: 				** that are *not* always ordered.  The always-ordered tables
0: 				** are not counted as part of the list of ordered columns
0: 				*/
0: 				position++;
0: 			}
0: 		}
0: 
0: 		return RequiredRowOrdering.NOTHING_REQUIRED;
0: 	}
0: 
0: 	/**
0: 	 * @see RequiredRowOrdering#estimateCost
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void estimateCost(double estimatedInputRows,
0: 								RowOrdering rowOrdering,
0: 								CostEstimate resultCost)
0: 					throws StandardException
0: 	{
0: 		/*
0: 		** Do a bunch of set-up the first time: get the SortCostController,
0: 		** the template row, the ColumnOrdering array, and the estimated
0: 		** row size.
0: 		*/
0: 		if (scc == null)
0: 		{
0: 			scc = getCompilerContext().getSortCostController();
0: 
0: 			resultRow =
0: 				resultToSort.getResultColumns().buildEmptyRow().getRowArray();
0: 			columnOrdering = getColumnOrdering();
0: 			estimatedRowSize =
0: 						resultToSort.getResultColumns().getTotalColumnSize();
0: 		}
0: 
0: 		long inputRows = (long) estimatedInputRows;
0: 		long exportRows = inputRows;
0: 		double sortCost;
0: 
0: 		sortCost = scc.getSortCost(
0: 									(DataValueDescriptor[]) resultRow,
0: 									columnOrdering,
0: 									false,
0: 									inputRows,
0: 									exportRows,
0: 									estimatedRowSize
0: 									);
0: 
0: 		resultCost.setCost(sortCost, estimatedInputRows, estimatedInputRows);
0: 	}
0: 
0: 	/** @see RequiredRowOrdering#sortNeeded */
0: 	public void sortNeeded()
0: 	{
0: 		sortNeeded = true;
0: 	}
0: 
0: 	/** @see RequiredRowOrdering#sortNotNeeded */
0: 	public void sortNotNeeded()
0: 	{
0: 		sortNeeded = false;
0: 	}
0: 
0: 	/**
0: 	 * Remap all ColumnReferences in this tree to be clones of the
0: 	 * underlying expression.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	void remapColumnReferencesToExpressions() throws StandardException
0: 	{
0: 	}
0: 
0: 	/**
0: 	 * Get whether or not a sort is needed.
0: 	 *
0: 	 * @return Whether or not a sort is needed.
0: 	 */
0: 	public boolean getSortNeeded()
0: 	{
0: 		return sortNeeded;
0: 	}
0: }
============================================================================