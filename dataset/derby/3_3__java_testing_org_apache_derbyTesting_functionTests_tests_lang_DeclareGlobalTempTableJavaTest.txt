1:ca2807d: /*
2:ca2807d: 
1:f10793f:  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.DeclareGlobalTempTableJavaTest
1:ca2807d: 
1:ca2807d:  Licensed to the Apache Software Foundation (ASF) under one or more
1:ca2807d:  contributor license agreements.  See the NOTICE file distributed with
1:ca2807d:  this work for additional information regarding copyright ownership.
1:ca2807d:  The ASF licenses this file to You under the Apache License, Version 2.0
1:ca2807d:  (the "License"); you may not use this file except in compliance with
1:ca2807d:  the License.  You may obtain a copy of the License at
1:ca2807d: 
1:ca2807d:  http://www.apache.org/licenses/LICENSE-2.0
1:ca2807d: 
1:ca2807d:  Unless required by applicable law or agreed to in writing, software
1:ca2807d:  distributed under the License is distributed on an "AS IS" BASIS,
1:ca2807d:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ca2807d:  See the License for the specific language governing permissions and
1:ca2807d:  limitations under the License.
1:ca2807d: 
1:ca2807d:  */
1:ca2807d: 
1:ca2807d: package org.apache.derbyTesting.functionTests.tests.lang;
1:ca2807d: 
1:ca2807d: import java.sql.ResultSet;
1:ca2807d: import java.sql.ResultSetMetaData;
1:ca2807d: import java.sql.SQLException;
1:ca2807d: import java.sql.Statement;
1:ca2807d: import java.sql.PreparedStatement;
1:ca2807d: import java.sql.DatabaseMetaData;
1:ca2807d: import java.sql.Connection;
1:ca2807d: 
1:ca2807d: import junit.framework.Test;
1:063dd55: import org.apache.derbyTesting.functionTests.util.SampleVTI;
1:ca2807d: 
1:ca2807d: 
1:ca2807d: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:ca2807d: import org.apache.derbyTesting.junit.JDBC;
1:ca2807d: import org.apache.derbyTesting.junit.TestConfiguration;
1:ca2807d: 
1:ca2807d: 
1:ca2807d: /**
1:ca2807d:  * Test for declared global temporary tables introduced in Cloudscape 5.2 The
1:ca2807d:  * temp table tests with holdable cursor and savepoints are in
1:ca2807d:  * declareGlobalTempTableJavaJDBC30 class. The reason for a different test class
1:ca2807d:  * is that the holdability and savepoint support is under jdk14 and higher. But
1:ca2807d:  * we want to be able to run the non-jdk14 specific tests under all the jdks we
1:ca2807d:  * support and hence splitting the tests into 2 different classes Global
1:ca2807d:  * Temporary Tables are referenced as GTT to make it easy for Naming.
1:ca2807d:  */
1:ca2807d: 
1:ca2807d: public class DeclareGlobalTempTableJavaTest extends BaseJDBCTestCase {
1:ca2807d: 
1:ca2807d:     public DeclareGlobalTempTableJavaTest(String name) {
1:ca2807d:         super(name);
5:ca2807d:     }
1:ca2807d: 
1:ca2807d:     public static Test suite() {
1:f10793f: 	return TestConfiguration.defaultSuite(DeclareGlobalTempTableJavaTest.class);
1:ca2807d:     }
1:ca2807d:     protected void setUp() throws Exception {
1:ca2807d:         super.setUp();
1:ca2807d:         dropSchemaTables();
1:ca2807d:         getConnection().setAutoCommit(false);
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     protected void tearDown() throws Exception {
1:ca2807d:         super.tearDown();
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test switching to session schema (it doesn't yet exist because no create
1:ca2807d:      * schema session has been issued yet) and then try to create first persistent
1:ca2807d:      * object in it. This used to cause null pointer exception (DERBY-1706).
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      *                Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testDerby1706() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // the try/catch block ensures to drop the SESSION schema if exists.
6:ca2807d:         try {
1:ca2807d:             s.executeUpdate("drop schema SESSION restrict");
6:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("42Y07", e);
1:ca2807d:         }
1:ca2807d:         assertUpdateCount(s , 0 , "set schema SESSION");
1:ca2807d:         // This used to cause NullPointerException before.
1:ca2807d:         assertUpdateCount(s, 0, "create table DERBY1706(c11 int)");
1:ca2807d:  	assertUpdateCount(s, 0, "drop table DERBY1706");
1:ca2807d:         assertUpdateCount(s, 0, "set schema APP");
1:ca2807d:  	assertUpdateCount(s, 0, "drop schema SESSION restrict");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test the schema of Golabal Temporary Tables.
1:ca2807d:      * Global Temporary Tables can only be in SESSION schema. Declaring them in Other schemas Should give an  Error. 
1:ca2807d:      * Global Temporary Tables always goes into SESSION schema. Even if
1:ca2807d:      * the current schema is not SESSION.
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      *                Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testGTTSchemaName() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "set schema APP");
1:ca2807d:         // Global Temporary Tables can only be created in SESSION schema
1:ca2807d:         assertStatementError("428EK",s,"DECLARE GLOBAL TEMPORARY TABLE APP.t2(c21 int) on commit delete rows not logged");
1:ca2807d:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE t2(c21 int) on commit delete rows not logged");
1:ca2807d:         // temp table t2 is not in APP schema
1:ca2807d:         assertStatementError("42X05", s, "insert into APP.t2 values(7)");
1:ca2807d:         // temp table should be referred as SESSIO.t2
1:ca2807d:         assertStatementError("42X05", s, "insert into t2 values(7)");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(7)");
1:ca2807d:         // temp table t2 must be qualified with SESSION
1:ca2807d:         assertStatementError("42Y55", s, "drop table t2");
1:ca2807d:         assertUpdateCount(s , 0 , "drop table SESSION.t2");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Some positive Grammar tests for the DECLARE GLOBAL TEMPORARY TABLE
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      *                Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testPositiveGrammars() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s, 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tA(c1 int) not logged");
1:ca2807d:         assertUpdateCount(s, 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tB(c1 int) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s, 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tC(c1 int) not logged on commit delete rows");
1:ca2807d:         assertUpdateCount(s, 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tD(c1 int) on commit preserve rows not logged");
1:ca2807d:         assertUpdateCount(s, 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tE(c1 int) not logged on commit preserve rows");
1:ca2807d:         assertUpdateCount(s, 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tF(c1 int) on rollback delete rows not logged");
1:ca2807d:         assertUpdateCount(s, 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tG(c1 int) not logged on rollback delete rows");
1:ca2807d:         assertUpdateCount(
1:ca2807d:                 s,
1:ca2807d:                 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tH(c1 int) on commit preserve rows not logged on rollback delete rows");
1:ca2807d:         assertUpdateCount(
1:ca2807d:                 s,
1:ca2807d:                 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tI(c1 int) not logged on commit preserve rows on rollback delete rows");
1:ca2807d:         assertUpdateCount(
1:ca2807d:                 s,
1:ca2807d:                 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tJ(c1 int) not logged on rollback delete rows on commit preserve rows");
1:ca2807d:         assertUpdateCount(
1:ca2807d:                 s,
1:ca2807d:                 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tK(c1 int) on commit delete rows not logged on rollback delete rows");
1:ca2807d:         assertUpdateCount(
1:ca2807d:                 s,
1:ca2807d:                 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tL(c1 int) not logged on commit delete rows on rollback delete rows");
1:ca2807d:         assertUpdateCount(
1:ca2807d:                 s,
1:ca2807d:                 0,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE tM(c1 int) not logged on rollback delete rows on commit delete rows");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tA");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tB");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tC");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tD");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tE");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tF");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tG");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tH");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tI");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tJ");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tK");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tL");
1:ca2807d:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tM");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Some Negative Grammar tests for the DECLARE GLOBAL TEMPORARY TABLE
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      * Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testNegativeGrammars() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertStatementError("42X01", s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int)");
1:ca2807d:         assertStatementError("42613", s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int) NOT LOGGED NOT LOGGED");
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42613",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int) NOT LOGGED ON COMMIT PRESERVE ROWS ON COMMIT DELETE ROWS");
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42613",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int) NOT LOGGED ON ROLLBACK DELETE ROWS ON ROLLBACK DELETE ROWS");
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42X01",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int) ON ROLLBACK DELETE ROWS ON COMMIT PRESERVE ROWS");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test some of the features that are not allowed on temp tables namely
1:ca2807d:      * ALTER TABLE , LOCK TABLE , RENAME TABLE , CREATE INDEX AND CREATE VIEW
1:ca2807d:      * CREATE VIEW is some what special in that it can't have reference to the
1:ca2807d:      * temp tables. The Other two features are generated always as identity and
1:ca2807d:      * Long datatype.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testFeaturesNotAllowedOnGTTs() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) not logged on commit delete rows");
1:ca2807d:         // Alter Table is not allowed on temp tables.
1:ca2807d:         assertStatementError("42995", s,"ALTER TABLE SESSION.t2 add column c22 int");
1:ca2807d:         // Lock Table is not allowed on temp tables.
1:ca2807d:         assertStatementError("42995", s, "LOCK TABLE SESSION.t2 IN SHARE MODE");
1:ca2807d:         // Rename Table is not allowed on temp tables.
1:ca2807d:         assertStatementError("42995", s, "RENAME TABLE SESSION.t2 TO t3");
1:ca2807d:         // Create Index is not allowed on temp tables.
1:ca2807d:         assertStatementError("42995", s, "CREATE index t2i1 on SESSION.t2 (c21)");
1:ca2807d:         // Create view that references temp tables is not allowed
1:ca2807d:         assertStatementError("XCL51", s, "CREATE VIEW t2v1 as select * from SESSION.t2");
1:ca2807d:         // generated always as identity not allowed on temp tables.
1:ca2807d:         assertStatementError("42995",s,"DECLARE GLOBAL TEMPORARY TABLE SESSION.t1(c21 int generated always as identity) on commit delete rows not logged");
1:ca2807d:         // Long datatypes are not supported.
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42962",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t1(c21 int, c22 blob(3k)) on commit delete rows not logged");
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42962",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t1(c21 int, c22 clob(3k)) on commit delete rows not logged");
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42962",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t1(c21 int, c22 long varchar) on commit delete rows not logged");
2:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t2");
1:ca2807d:         assertStatementError("42Y55", s, "DROP TABLE SESSION.t1");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test some features that allowed on physical tables in SESSION Schema
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testFeaturesAllowedOnPhysicalTablesOfSESSIONSchema()
1:ca2807d:             throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         try {
1:ca2807d:             s.executeUpdate("CREATE schema SESSION");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("X0Y68", e);
1:ca2807d:         }
1:ca2807d:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t2(c21 int)");
1:ca2807d:         // Alter Table is allowed on physical tables in SESSION schema
1:ca2807d:         assertUpdateCount(s, 0, "ALTER TABLE SESSION.t2 add column c22 int");
1:ca2807d:         // Lock Table is allowed on physical tables in SESSION schema
1:ca2807d:   	assertUpdateCount(s , 0 , "LOCK TABLE SESSION.t2 IN EXCLUSIVE MODE");
1:ca2807d:         // Rename Table is allowed on physical tables in SESSION schema
1:ca2807d:         assertUpdateCount(s , 0 , "RENAME TABLE SESSION.t2 TO t3");
1:ca2807d:         // Lock column is allowed on physical tables in SESSION schema
1:ca2807d:         assertUpdateCount(s , 0 , "RENAME COLUMN SESSION.t3.c21 TO c23");
1:ca2807d:         // Create Index is allowed on physical tables in SESSION schema
1:ca2807d:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t2 (c21 int)");
1:ca2807d:         assertUpdateCount(s , 0 , "CREATE index t2i1 on SESSION.t2 (c21)");
1:ca2807d:         // Create View referencing physical tables in SESSION schema is not
1:ca2807d:         // supported
1:ca2807d:         assertStatementError("XCL51", s,
1:ca2807d:                 "CREATE VIEW t2v1 as select * from SESSION.t2");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t3");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Test the various constraints not allowed on temp tables namely primary
1:ca2807d:      * key constraints , Unique constraints , check constraints and foreign key
1:ca2807d:      * constraints.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testConstraintsNotAllowedOnGTTs() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // primary key constraints are not allowed on temp tables.
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42995",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int not null, constraint pk primary key (c21)) on commit delete rows not logged");
1:ca2807d:         // Unique constraints are not allowed on temp tables.
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42995",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int not null unique) on commit delete rows not logged");
1:ca2807d:         // foreign key constraints are not allowed on temp tables.
1:ca2807d:         s.executeUpdate("CREATE TABLE t1(c11 int not null unique)");
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42995",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int references t1(c11)) on commit delete rows not logged");
1:ca2807d:         // check constraints are not allowed on temp tables.
1:ca2807d:         assertStatementError(
1:ca2807d:                 "42995",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int check (c21 > 0)) on commit delete rows not logged");
1:ca2807d:         s.executeUpdate("DROP TABLE t1");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test the constraints allowed on physical tables in SESSION schema.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testConstraintsAllowedOnSESSIONPhysicalTables()
1:ca2807d:             throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         try {
1:ca2807d:             s.executeUpdate("CREATE SCHEMA SESSION");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("X0Y68", e);
1:ca2807d:         }
1:ca2807d:         // primary key constraints allowed on SESSION physical tables
1:ca2807d:         s
1:ca2807d:                 .executeUpdate("CREATE TABLE SESSION.t1(c21 int not null, constraint pk primary key (c21))");
1:ca2807d:         // unique constraints allowed on SESSION physical tables
1:ca2807d:         s.executeUpdate("CREATE TABLE SESSION.t2(c21 int not null unique)");
1:ca2807d:         // check constraints allowed on SESSION physical tables
1:ca2807d:         s.executeUpdate("CREATE TABLE SESSION.t3(c21 int check (c21 > 0))");
1:ca2807d:         // foreign key constraints allowed on SESSION physical tables
1:ca2807d:         s.executeUpdate("CREATE TABLE t4(c11 int not null unique)");
1:ca2807d:         s.executeUpdate("CREATE TABLE SESSION.t5(c21 int references t4(c11))");
1:ca2807d:         // cleanUp
2:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t1");
1:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t2");
2:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t3");
2:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t5");
1:ca2807d:         s.executeUpdate("DROP TABLE t4");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test declared temporary table with ON COMMIT DELETE ROWS with and without
1:ca2807d:      * open cursors. Tests with holdable cursor are in a different class since
1:ca2807d:      * holdability support is only under jdk14 and higher.
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      *                Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testOnCommiDeleteRowsWithAndWithoutOpenCursors()
1:ca2807d:             throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // Temp table t2 with not holdable cursor open on it. Data should get
1:ca2807d:         // deleted from t2 at commit time
1:ca2807d:         assertUpdateCount(s, 0, "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(22, 22)");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(23, 23)");
1:ca2807d:         ResultSet rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         // Before commit t2 has 2 columns.
1:ca2807d:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:ca2807d:         // eventhough this cursor is open, it is not a hold cursor. Commit
1:ca2807d:         // should delete the rows
1:ca2807d:         rs2 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs2.next();
1:ca2807d:         // Temp table t3 with no open cursors of any kind on it. Data should get
1:ca2807d:         // deleted from t3 at commit time
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(c31 int, c32 int) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t3 values(32, 32)");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t3 values(33, 33)");
1:ca2807d:         ResultSet rs3 = s.executeQuery("select count(*) from SESSION.t3");
1:ca2807d:         // Before commit t3 has 2 columns.
1:ca2807d:         JDBC.assertSingleValueResultSet(rs3 , "2");
1:ca2807d:         // commiting the above statements
1:ca2807d: 	commit();
1:ca2807d:         // The 2 rows from t2 got deleted
1:ca2807d:         rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs2 , "0");
1:ca2807d:         // The 2 rows from t3 got deleted
1:ca2807d:         rs3 = s.executeQuery("select count(*) from SESSION.t3");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs3 , "0");
1:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t2");
1:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t3");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Declare a temporary table with ON COMMIT PRESERVE ROWS with and without
1:ca2807d:      * open cursors. Tests with holdable cursor are in a different class since
1:ca2807d:      * holdability support is only under jdk14 and higher.
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      *                Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testOnCommitPreserveRowsWithAndWithoutOpenCursors()
1:ca2807d:             throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // Temp table t2 with not holdable cursor open on it. Data should be
1:ca2807d:         // preserved, holdability shouldn't matter
1:ca2807d:         s
1:ca2807d:                 .executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit preserve rows not logged");
1:ca2807d:         s.executeUpdate("insert into SESSION.t2 values(22, 22)");
1:ca2807d:         s.executeUpdate("insert into SESSION.t2 values(23, 23)");
1:ca2807d:         ResultSet rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         // t2 has 2 rows before commiting.
1:ca2807d:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:ca2807d:         // eventhough this cursor is open, it is not a hold cursor.
1:ca2807d:         rs2 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs2.next();
1:ca2807d:         // Temp table t3 with no open cursors of any kind on it. Data should be
1:ca2807d:         // preserved, holdability shouldn't matter
1:ca2807d:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(c31 int, c32 int) on commit preserve rows not logged");
1:ca2807d:         s.executeUpdate("insert into SESSION.t3 values(32, 32)");
1:ca2807d:         s.executeUpdate("insert into SESSION.t3 values(33, 33)");
1:ca2807d:         ResultSet rs3 = s.executeQuery("select count(*) from SESSION.t3");
1:ca2807d:         // t3 has 2 rows before commiting.
1:ca2807d:         JDBC.assertSingleValueResultSet(rs3 , "2");
1:ca2807d:         // commit point
1:ca2807d:         commit();
1:ca2807d:         rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         // The rows in t2 got preserved
1:ca2807d:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:ca2807d:         rs3 = s.executeQuery("select count(*) from SESSION.t3");
1:ca2807d:         // The rows in t3 got preserved
1:ca2807d:         JDBC.assertSingleValueResultSet(rs3 , "2");
1:ca2807d: 
1:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t2");
1:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t3");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test that We can't create the temp table twice and we can'd drop a temp
1:ca2807d:      * table that doesn't wxist.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testDuplicateAndNullGTT() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:ca2807d:         // temp table t2 already exists.
1:ca2807d:         assertStatementError(
1:ca2807d:                 "X0Y32",
1:ca2807d:                 s,
1:ca2807d:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) not logged on commit preserve rows");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         // t2 has already been dropped.
1:ca2807d:         assertStatementError("42Y55", s, "DROP TABLE SESSION.t2");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test That Insert command allowed on temp tables in various conditions.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testInsertOnGTT() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 char(2)) on commit delete rows not logged");
1:ca2807d:         // Regular Insertion - Inserting with values.
1:ca2807d:         assertUpdateCount(s, 1, "insert into SESSION.t2 values (1, 'aa')");
1:ca2807d:         assertUpdateCount(s, 3, "insert into SESSION.t2 values (2, 'bb'),(3, 'cc'),(4, null)");
1:ca2807d:         assertUpdateCount(s, 0, "CREATE TABLE t1(c11 int, c22 char(2))");
1:ca2807d:         assertUpdateCount(s, 3, "insert into t1 values (5, null),(6, null),(7, 'gg')");
1:ca2807d:         // Insert into a table values selected from the Other table.
1:ca2807d:         assertUpdateCount(s, 3, "insert into SESSION.t2 (select * from t1 where c11>4)");
1:ca2807d:         assertUpdateCount(s, 7, "insert into SESSION.t2 select * from SESSION.t2");
1:ca2807d:         ResultSet rs1 = s.executeQuery("select sum(c21) from SESSION.t2");
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "56");
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(c21 int, c22 char(2) not null) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t3 values (1, 'aa')");
1:ca2807d:         // test inserting a null value into a non null column
1:ca2807d:         assertStatementError("23502", s, "insert into SESSION.t3 values (2, null)");
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t4(c21 int, c22 char(2) default 'aa', c23 varchar(20) default user ) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s, 1, "insert into SESSION.t4 values (1, 'aa', null)");
1:ca2807d:         // Inserting into a table of which some columns have default values.
1:ca2807d:         assertUpdateCount(s, 1, "insert into SESSION.t4(c21) values (2)");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t4");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t3");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE t1");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test Delete Operation on temp tables.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testDeleteOnGTT() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 decimal) not logged");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(1, 1.1)");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(2, 2.2)");
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         // Initially t2 has 2 rows
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:ca2807d:         assertUpdateCount(s , 2 , "DELETE FROM SESSION.t2 where c21 > 0");
1:ca2807d:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         // After deletion t2 has nothing
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "0");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test Update on temp tables in various ways.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testUpdateOnGTT() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(1, 1)");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(2, 1)");
1:ca2807d:         ResultSet rs2 = s.executeQuery("select count(*) from SESSION.t2 where c22 = 1");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:ca2807d:         assertUpdateCount(s , 2 , "UPDATE SESSION.t2 SET c22 = 2 where c21>0");
1:ca2807d:         rs2 = s.executeQuery("select count(*) from SESSION.t2 where c22 = 1");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs2 , "0");
1:ca2807d:         rs2 = s.executeQuery("select count(*) from SESSION.t2 where c22 = 2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Test CREATE and DROP operations on SESSION schema
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testSESSIONschema() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // SESSION schema can be created like any other schema
1:ca2807d:         try {
1:ca2807d: 
1:ca2807d:             s.executeUpdate("CREATE SCHEMA SESSION");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("X0Y68", e);
1:ca2807d:         }
1:ca2807d:         // SESSION schema can be dropped like any Other Schema
1:ca2807d:         assertUpdateCount(s , 0 , "DROP SCHEMA SESSION restrict");
1:ca2807d:         // We can't drop the In-Memory SESSION schema
1:ca2807d:         assertStatementError("42Y07", s, "DROP SCHEMA SESSION restrict");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * CREATE VIEW in SESSION schema referencing a table outside of SESSION
1:ca2807d:      * schema.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testCreateView() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "CREATE TABLE t2 (c28 int)");
1:ca2807d:         assertUpdateCount(s , 2 , "INSERT INTO t2 VALUES (280),(281)");
1:ca2807d:         // Create a VIEW in SESSION schema referencing a table outside of
1:ca2807d:         // SESSION schema
1:ca2807d:         assertUpdateCount(s, 0, "CREATE VIEW SESSION.t2v1 as select * from t2");
1:ca2807d:         // Drop the view.
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2v1");
1:ca2807d:         // Test the values in View as selected from Table.
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP VIEW SESSION.t2v1");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE t2");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Multiple tests to make sure we do not do statement caching for statement
1:ca2807d:      * referencing SESSION schema tables. CREATE physical table and then DECLARE
1:ca2807d:      * GLOBAL TEMPORARY TABLE with the same name in session schema.
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      *                Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testStatementCaching() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // Need to do following 3 in autocommit mode otherwise the data
1:ca2807d:         // dictionary will be in write mode and statements won't get
1:ca2807d:         // cached. I need to have statement caching enabled here to make sure
1:ca2807d:         // that tables with same names do not conflict
1:ca2807d:         getConnection().setAutoCommit(true);
1:ca2807d:         try {
1:ca2807d:             s.executeUpdate("CREATE schema SESSION");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("X0Y68", e);
1:ca2807d:         }
1:ca2807d:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t2 (c21 int)");
1:ca2807d:         assertUpdateCount(s, 1, "INSERT into SESSION.t2 values(21)");
1:ca2807d:         getConnection().setAutoCommit(false);
1:ca2807d:         // select will return data from physical table t2
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "1");
1:ca2807d:         // declare temporary table with same name as a physical table in SESSION
1:ca2807d:         // schema
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s , 1 , "INSERT into SESSION.t2 values(22, 22)");
1:ca2807d:         assertUpdateCount(s , 1 , "INSERT into SESSION.t2 values(23, 23)");
1:ca2807d:         // select will return data from temp table t2
1:ca2807d:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:ca2807d:         // drop the temp table t2
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         // select will return data from physical table t2 because temp table has
1:ca2807d:         // been deleted
1:ca2807d:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "1");
1:ca2807d: 	// cleanup
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         assertUpdateCount(s , 0 , "drop schema SESSION restrict");
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * After creating SESSION schema and making it current schema, temporary
1:ca2807d:      * tables should not require SESSION qualification
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      */
1:ca2807d:     public void testSESSIONQualifier() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // We have to qualify the temp tables with SESSION qualifier.
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(21, 21)");
1:ca2807d:         assertStatementError("42X05", s, "insert into t2 values(23, 23)");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(22, 22)");
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:ca2807d:         // Create the SESSION Schema Manually
1:ca2807d:         try {
1:ca2807d:             s.executeUpdate("CREATE SCHEMA SESSION");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("X0Y68", e);
1:ca2807d:         }
1:ca2807d:         // Set the SESSION schema as current schema
1:ca2807d:         s.executeUpdate("SET SCHEMA SESSION");
1:ca2807d:         // we don't need the SESSION qualifier for referencing temp tables.
1:ca2807d:         rs1 = s.executeQuery("select count(*) from t2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE t2");
1:ca2807d:         assertUpdateCount(s , 0 , "SET SCHEMA APP");
1:ca2807d:         assertUpdateCount(s , 0 , "drop schema SESSION restrict");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Temporary table created in one connection should not be available in
1:ca2807d:      * another connection.
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      *                Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testOneGTTInConnection() throws SQLException {
1:ca2807d:         Statement s1 = createStatement();
1:ca2807d:         // creating the temp table in connection 1
1:ca2807d:         assertUpdateCount(s1 , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:ca2807d:         assertUpdateCount(s1, 1, "insert into SESSION.t2 values(22, 22)");
1:ca2807d:         // Getting the Second Connection
1:ca2807d:         Connection con2 = openDefaultConnection();
1:ca2807d:         Statement s2 = con2.createStatement();
1:ca2807d:         // con2 should not find temp table declared in con1
1:ca2807d:         assertStatementError("42X05", s2, "select count(*) from SESSION.t2");
1:ca2807d:         // connection1 will be closed in tearDown() methos automatically.
1:ca2807d:         s2.close();
1:ca2807d:         con2.close();
1:ca2807d:     }
1:ca2807d: 
1:ca2807d:     /**
1:ca2807d:      * Temp table in one connection should not conflict with temp table with
1:ca2807d:      * same name in another connection.
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      *                Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testSameGTTNameForTwoConnections() throws SQLException {
1:ca2807d:         Statement s1 = createStatement();
1:ca2807d:         // creating the temp table t2 in First Connection
1:ca2807d:         assertUpdateCount(s1 , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:ca2807d:         assertUpdateCount(s1, 1, "insert into SESSION.t2 values(22, 22)");
1:ca2807d:         // Getting the Second Connection.
1:ca2807d:         Connection con2 = openDefaultConnection();
1:ca2807d:         Statement s2 = con2.createStatement();
1:ca2807d:         // creating the temp table with same name (t2) in the Sesond Connection
1:ca2807d: 	assertUpdateCount(s2 , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) not logged");
1:ca2807d:         assertUpdateCount(s2, 1, "insert into SESSION.t2 values(99)");
1:ca2807d:         // dropping temp table t2 defined for con1
1:ca2807d:         assertUpdateCount(s1 , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         // dropping temp table t2 defined for con2
1:ca2807d:         assertUpdateCount(s2 , 0 , "DROP TABLE SESSION.t2");
1:ca2807d: 	s2.close();
1:ca2807d:         con2.close();
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Prepared statement test - drop the temp table underneath
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testPreparedStatement1() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:ca2807d:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:ca2807d:         pStmt.setInt(1, 21);
1:ca2807d:         pStmt.setInt(2, 1);
1:ca2807d:         pStmt.execute();
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "1");
1:ca2807d:         // drop the temp table t2
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         // now try to insert into the table t2 which was dropped
1:ca2807d:         try {
1:ca2807d:             pStmt.setInt(1, 22);
1:ca2807d:             pStmt.setInt(2, 2);
1:ca2807d:             pStmt.execute();
1:ca2807d:             fail(" Table/View 'SESSION.T2' does not exist:");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("42X05", e);
1:ca2807d:         }
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Prepared statement test - drop and recreate the temp table with different
1:ca2807d:      * definition underneath
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testPreparedStatement2() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // create the temporary table t2 with 2 columns.
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:ca2807d:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:ca2807d:         pStmt.setInt(1, 21);
1:ca2807d:         pStmt.setInt(2, 1);
1:ca2807d:         pStmt.execute();
1:ca2807d:         pStmt.close();
1:ca2807d:         ResultSet rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d: 	rs1.next();
1:ca2807d: 	ResultSetMetaData rsmd = rs1.getMetaData();
1:ca2807d: 	assertEquals(2 , rsmd.getColumnCount());
1:ca2807d:  	//JDBC.assertSingleValueResultSet(rs1 , "1");
1:ca2807d:         // drop the temp table t2
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         // recreate the temp table t2 with 3 columns
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int, c23 int) not logged");
1:ca2807d:         pStmt = prepareStatement("insert into SESSION.t2 values (?, ? , ?)");
1:ca2807d:         pStmt.setInt(1, 22);
1:ca2807d:         pStmt.setInt(2, 2);
1:ca2807d:         pStmt.setNull(3, java.sql.Types.INTEGER);
1:ca2807d:         pStmt.execute();
1:ca2807d:         rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d: 	rsmd = rs1.getMetaData();
1:ca2807d:         assertEquals(3 , rsmd.getColumnCount());
1:ca2807d:         // drop the temp table t2
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         // recreate the temp table t2 with 4 columns.
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int, c23 int, c24 int not null) not logged");
1:ca2807d:         pStmt = prepareStatement("insert into SESSION.t2 values (?, ? , ? , ?)");
1:ca2807d:         // try to insert a null value into a non-null column
1:ca2807d:         try {
1:ca2807d:             pStmt.setInt(1, 22);
1:ca2807d:             pStmt.setInt(2, 2);
1:ca2807d:             pStmt.setNull(3, java.sql.Types.INTEGER);
1:ca2807d:             pStmt.setNull(4, java.sql.Types.INTEGER);
1:ca2807d:             pStmt.execute();
1:ca2807d:             fail("trying to Insert a null value into non null column:");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("23502", e);
1:ca2807d:         }
1:ca2807d:     }
1:ca2807d:     /**
1:f10793f:      *  Temporary table create and drop Rollback behaviour
1:f10793f:      *  Tests the basic function of temporary table with holdability
1:f10793f:      *
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testTempTableDDLRollbackbehaviour1() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit preserve rows  not logged");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         // we've removed the table, so select should fail
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:         rollback();
1:f10793f:         // should still fail after rollback; we don't have savepoints and
1:f10793f:         // we rolled back entire transaction, incl. creation of temp table
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:     }
1:f10793f: 
1:f10793f:     /**
1:f10793f:      *  Temporary table create and drop Rollback behaviour
1:f10793f:      *  Tests drop of temp table and rollback - select should still work
1:f10793f:      *
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testTempTableDDLRollbackbehaviour2() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit preserve rows  not logged");
1:f10793f:         commit();
1:f10793f:         // drop table and rollback - select should still work
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:         rollback();
1:f10793f:         // select should work again
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:f10793f:     }
1:f10793f: 
1:f10793f:     /**
1:f10793f:      *  Temporary table create and drop Rollback behaviour
1:f10793f:      *  Tests drop of temp table and commit - select should no longer work
1:f10793f:      *
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testTempTableDDLRollbackbehaviour3() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit preserve rows  not logged");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:f10793f:         commit();
1:f10793f:         // drop table and commit - select should no longer work
1:f10793f:         s.executeUpdate("drop table SESSION.t1");
1:f10793f:         commit();
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:     }
1:f10793f: 
1:f10793f:     /**
1:f10793f:      *  Temporary table create and drop Rollback behaviour
1:f10793f:      *  Tests create of temp table and rollback - select should fail
1:f10793f:      *
1:f10793f:      *  @throws SQLException 
1:f10793f:      */
1:f10793f:     public void testTempTableDDLRollbackbehaviour4() throws SQLException {
1:f10793f:         Statement s = createStatement();
1:f10793f:         s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit preserve rows  not logged");
1:f10793f:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:f10793f:         rollback();
1:f10793f:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:f10793f:     }
1:f10793f:     
1:f10793f:     /**
1:ca2807d:      * Rollback behavior - declare temp table, rollback, select should fail.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testRollbackBehavior1() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:ca2807d:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:ca2807d:         pStmt.setInt(1, 21);
1:ca2807d:         pStmt.setInt(2, 1);
1:ca2807d:         pStmt.execute();
1:ca2807d:         pStmt.close();
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs1 , "1");
1:ca2807d:         // RollBack to the last committed point
1:ca2807d:         rollback();
1:ca2807d:         // Now select from SESSION.t2 should fail
1:ca2807d:         assertStatementError("42X05", s, "select * from SESSION.t2");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Rollback behavior - declare temp table, commit, drop temp table,
1:ca2807d:      * rollback, select should pass
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testRollbackBehavior2() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // create a temp table t2
1:ca2807d:     	assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit preserve rows not logged");
1:ca2807d:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:ca2807d:         pStmt.setInt(1, 21);
1:ca2807d:         pStmt.setInt(2, 1);
1:ca2807d:         pStmt.execute();
1:ca2807d:         pStmt.close();
1:ca2807d:         // commit the changes
1:ca2807d:         commit();
1:ca2807d:         // After commiting drop the temp table t2
1:ca2807d:         s.executeUpdate("DROP TABLE SESSION.t2");
1:ca2807d:         // Rollback the last Operation that is the DROP TABBE SESSION.t2 operation
1:ca2807d:         rollback();
1:ca2807d:         // now select will pass
1:ca2807d:         ResultSet rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         JDBC.assertSingleValueResultSet(rs2 , "0");	
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         commit();
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Rollback behavior - create temp table , commit , drop it and create
1:ca2807d:      * another temp table with samename , rollback select will select from the
1:ca2807d:      * first temp table.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testRollbackBehavior3() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // create temp table t2 with 3 columns.
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int, c23 int) on commit preserve rows not logged");
1:ca2807d:         assertUpdateCount(s, 1, "insert into session.t2 values(1,1,1)");
1:ca2807d:         ResultSet rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d: 	ResultSetMetaData rsmd = rs1.getMetaData();
1:ca2807d:         assertEquals(3 , rsmd.getColumnCount());
1:ca2807d:         // drop the temp table t2 with 3 columns.
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         assertStatementError("42X05", s, "select * from SESSION.t2");
1:ca2807d:         // create temp table with 2 columns.
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit preserve rows not logged");
1:ca2807d:         assertUpdateCount(s, 1, "insert into session.t2 values(1,1)");
1:ca2807d:         rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d: 	rsmd = rs1.getMetaData();
1:ca2807d:         assertEquals(2 , rsmd.getColumnCount());
1:ca2807d:         // commit point
1:ca2807d:         commit();
1:ca2807d:         // drop the temp table with 2 columns.
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         // create the temp table with 1 column.
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s, 1, "insert into session.t2 values(1)");
1:ca2807d:         rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d: 	rs1.next();
1:ca2807d: 	rsmd = rs1.getMetaData();
1:ca2807d:         assertEquals(1 , rsmd.getColumnCount());
1:ca2807d:         rs1.close();
1:ca2807d:         // rollback to the last committed point
1:ca2807d:         rollback();
1:ca2807d:         // Now we have the temp table with 2 columns.
1:ca2807d:         rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d: 	rsmd = rs1.getMetaData();
1:ca2807d:         assertEquals(2 , rsmd.getColumnCount());
1:ca2807d:         rs1.close();
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Rollback behavior for tables touched with DML
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testRollbackBehavior4() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         // Declare temp table t2 & t3 & t4 & t5 with preserve rows, insert data
1:ca2807d:         // and commit
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit preserve rows not logged on rollback delete rows");
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(c31 int, c32 int) not logged on commit preserve rows on rollback delete rows");
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t4(c41 int, c42 int) not logged on rollback delete rows on commit preserve rows");
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t5(c51 int, c52 int) on commit preserve rows not logged");
1:ca2807d:         s.executeUpdate("insert into session.t2 values(21,1)");
1:ca2807d:         s.executeUpdate("insert into session.t2 values(22,2)");
1:ca2807d:         s.executeUpdate("insert into session.t2 values(23,3)");
1:ca2807d:         s.executeUpdate("insert into session.t3 values(31,1)");
1:ca2807d:         s.executeUpdate("insert into session.t3 values(32,2)");
1:ca2807d:         s.executeUpdate("insert into session.t3 values(33,3)");
1:ca2807d:         s.executeUpdate("insert into session.t4 values(41,1)");
1:ca2807d:         s.executeUpdate("insert into session.t4 values(42,2)");
1:ca2807d:         s.executeUpdate("insert into session.t4 values(43,3)");
1:ca2807d:         s.executeUpdate("insert into session.t5 values(51,1)");
1:ca2807d:         s.executeUpdate("insert into session.t5 values(52,2)");
1:ca2807d:         s.executeUpdate("insert into session.t5 values(53,3)");
1:ca2807d:         // commit point
1:ca2807d:         commit();
1:ca2807d:         // create a temp table t6 with preserve rows , insert data.
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t6(c61 int, c62 int) on commit preserve rows not logged on rollback delete rows");
1:ca2807d:         s.executeUpdate("insert into session.t6 values(61,1)");
1:ca2807d:         s.executeUpdate("insert into session.t6 values(62,2)");
1:ca2807d:         s.executeUpdate("insert into session.t6 values(63,3)");
1:ca2807d:         // DML Operations.
1:ca2807d:         s.executeUpdate("DELETE FROM session.t2 WHERE c22> (select c52 from session.t5 where c52=2)");
1:ca2807d:         s.executeUpdate("DELETE FROM session.t3 WHERE c32>3");
1:ca2807d:         // rollback to the last commit point
1:ca2807d:         rollback();
1:ca2807d:         // After rollback t2 should have nothing.
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "0");
1:ca2807d:         // temp table t3 should have no rows because attempt was made to delete
1:ca2807d:         // from it even though nothing actually got deleted from it in the transaction
1:ca2807d:         rs1 = s.executeQuery("select count(*) from SESSION.t3");
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "0");
1:ca2807d:         // temp table t4 should have its data intact because it was not touched
1:ca2807d:         // in the transaction that got rolled back
1:ca2807d:         rs1 = s.executeQuery("select count(*) from SESSION.t4");
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "3");
1:ca2807d:         // temp table t5 should have its data intact because it was only used in
1:ca2807d:         // where clause and not touched in the transaction that got rolled back
1:ca2807d:         rs1 = s.executeQuery("select count(*) from SESSION.t5");
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "3");
1:ca2807d:         // temp table t6 got dropped as part of rollback of this transaction
1:ca2807d:         // since it was declared in this same transaction
1:ca2807d:         assertStatementError("42X05", s, "select * from SESSION.t6");
1:ca2807d:         // CleanUp
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t3");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t4");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t5");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * The Test Verifies that there is no entry in system catalogs for temporary
1:ca2807d:      * tables. while physical tables from SESSION schema have an entry.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testEntryForSESSIONTablesToSysCatalog() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:ca2807d:        ResultSet rs1 = s.executeQuery("select count(*) from sys.systables where CAST(tablename AS VARCHAR(128)) like 'T2'");
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "0");
1:ca2807d:         // drop the temp table t2
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         // create a physical table in SESSION schema
1:ca2807d:         try {
1:ca2807d:             s.executeUpdate("CREATE SCHEMA SESSION");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("X0Y68", e);
1:ca2807d:         }
1:ca2807d:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t2(c21 int, c22 int)");
1:ca2807d:         rs1 = s.executeQuery("select count(*) from sys.systables where CAST(tablename AS VARCHAR(128)) like 'T2'");
1:ca2807d:         // System Catalog contains the physical tables from SESSION schema.
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "1");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         assertUpdateCount(s , 0 , "drop schema SESSION restrict");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Verify that there is no entry in system catalogs for SESSION schmea after
1:ca2807d:      * declare table.
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testEntryForSEESSIONtoSysCatalog() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         try {
1:ca2807d:             s.executeUpdate("drop schema SESSION restrict");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("42Y07", e);
1:ca2807d:         }
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(schemaname) from sys.sysschemas where CAST(schemaname AS VARCHAR(128)) like 'SESSION'");
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "0");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * DatabaseMetaData.getTables() should not return temporary tables
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testDatabaseMetadata() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         int count = 0;
1:ca2807d:         DatabaseMetaData databaseMetaData;
1:ca2807d:         databaseMetaData = getConnection().getMetaData();
1:ca2807d:         try {
1:ca2807d:             s.executeUpdate("CREATE SCHEMA SESSION");
1:ca2807d:         } catch (SQLException e) {
1:ca2807d:             assertSQLState("X0Y68", e);
1:ca2807d:         }
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t3(c31 int, c32 int)");
1:ca2807d:         ResultSet rs1 = databaseMetaData.getTables("", null, "%", null);
1:ca2807d:         while (rs1.next()) {
1:caa8627:             if (("T2".equals(rs1.getString(3))) &&
1:caa8627:                     ("SESSION".equals(rs1.getString(2))))
1:ca2807d:                 fail("Temporary table Found");
1:ca2807d:             count++;
1:ca2807d:         }
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t3");
1:ca2807d:         assertUpdateCount(s , 0 , "drop schema SESSION restrict");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Test for delete where current of on temporary tables
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testDeleteWhereCurrentOfOnGTT() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(21, 1)");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(22, 1)");
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "2");
1:ca2807d:         PreparedStatement pStmt1 = prepareStatement("select c21 from session.t2 for update");
1:ca2807d:         ResultSet rs2 = pStmt1.executeQuery();
1:ca2807d:         rs2.next();
1:ca2807d:         PreparedStatement pStmt2 = prepareStatement("delete from session.t2 where current of "+ rs2.getCursorName());
1:ca2807d:         pStmt2.executeUpdate();
1:ca2807d:         rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(22, rs1.getInt(1));
1:ca2807d:         assertEquals(1, rs1.getInt(2));
1:ca2807d:         rs2.next();
1:ca2807d:         pStmt2.executeUpdate();
1:ca2807d:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(0, rs1.getInt(1));
1:ca2807d:         rs2.close();
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:     }
1:063dd55:     /**
1:ca2807d:      * Test for update where current of on temporary tables
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void UpdateWhereCurrentOfOnGTT() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit delete rows not logged");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(21, 1)");
1:ca2807d:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(22, 1)");
1:ca2807d:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d: 	JDBC.assertSingleValueResultSet(rs1 , "2");
1:ca2807d:         PreparedStatement pStmt1 = prepareStatement("select c21 from session.t2 for update");
1:ca2807d:         ResultSet rs2 = pStmt1.executeQuery();
1:ca2807d:         rs2.next();
1:ca2807d:         PreparedStatement pStmt2 = prepareStatement("update session.t2 set c22 = 2 where current of "+ rs2.getCursorName());
1:ca2807d:         pStmt2.executeUpdate();
1:ca2807d:         rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(21, rs1.getInt(1));
1:ca2807d:         assertEquals(2, rs1.getInt(2));
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(22, rs1.getInt(1));
1:ca2807d:         assertEquals(1, rs1.getInt(2));
1:ca2807d:         rs2.next();
1:ca2807d:         pStmt2.executeUpdate();
1:ca2807d:         rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(21, rs1.getInt(1));
1:ca2807d:         assertEquals(2, rs1.getInt(2));
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(22, rs1.getInt(1));
1:ca2807d:         assertEquals(2, rs1.getInt(2));
1:ca2807d:         rs2.close();
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Prepared statement test - DML and rollback behavior
1:ca2807d:      * 
1:ca2807d:      * @throws SQLException
1:ca2807d:      */
1:ca2807d:     public void testDMLRollback1() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged on commit preserve rows");
1:ca2807d:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:ca2807d:         pStmt.setInt(1, 21);
1:ca2807d:         pStmt.setInt(2, 1);
1:ca2807d:         pStmt.execute();
1:ca2807d:         commit();
1:ca2807d:         ResultSet rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(21, rs1.getInt(1));
1:ca2807d:         assertEquals(1, rs1.getInt(2));
1:ca2807d:         pStmt.setInt(1, 22);
1:ca2807d:         pStmt.setInt(2, 2);
1:ca2807d:         pStmt.execute();
1:ca2807d:         rollback();
1:ca2807d:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(0, rs1.getInt(1));
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:     }
1:ca2807d:     /**
1:ca2807d:      * Prepared statement test - DML and rollback behavior.
1:ca2807d:      * 
1:ca2807d:      * @exception SQLException
1:ca2807d:      *                Thrown if some unexpected error happens
1:ca2807d:      */
1:ca2807d:     public void testDMLRollback2() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:ca2807d:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged on commit preserve rows");
1:ca2807d:         assertUpdateCount(s , 1 , "INSERT INTO SESSION.t2 VALUES(21, 1)");
1:ca2807d:         commit();
1:ca2807d:         ResultSet rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(21, rs1.getInt(1));
1:ca2807d:         assertEquals(1, rs1.getInt(2));
1:ca2807d:         prepareStatement("insert into SESSION.t2 values (?, ?)");
1:ca2807d:         rollback();
1:ca2807d:         rs1 = s.executeQuery("select * from SESSION.t2");
1:ca2807d:         rs1.next();
1:ca2807d:         assertEquals(21, rs1.getInt(1));
1:ca2807d:         assertEquals(1, rs1.getInt(2));
1:ca2807d:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:ca2807d:     }
1:063dd55: 
1:ca2807d:     /**
1:063dd55:      * Tests that you can insert data into a GTT with a VTI as the source.
1:063dd55:      * <p>
1:063dd55:      * This used to fail because inserting from a VTI would trigger bulk insert,
1:063dd55:      * but the bulk insert code path is not supported for GTT as the
1:063dd55:      * destination of the insert.
1:063dd55:      * <p>
1:063dd55:      * See DERBY-5614.
1:063dd55:      */
1:063dd55:     public void testVtiInsertIntoGTT()
1:063dd55:             throws SQLException {
1:063dd55:         Statement s = createStatement();
1:063dd55:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.vtitogtt(" +
1:063dd55:                 "c1 varchar(10)) not logged on commit preserve rows");
1:063dd55:         // Use an empty VTI as the source.
1:063dd55:         s.executeUpdate("CREATE FUNCTION emptySampleVTI() " +
1:063dd55:                 "RETURNS TABLE(v1 varchar(10))" +
1:063dd55:                 "LANGUAGE JAVA " +
1:063dd55:                 "PARAMETER STYLE DERBY_JDBC_RESULT_SET " +
1:063dd55:                 "NO SQL " +
1:063dd55:                 "EXTERNAL NAME 'org.apache.derbyTesting.functionTests." +
1:063dd55:                 "util.SampleVTI.emptySampleVTI'");
1:063dd55:         s.executeUpdate("insert into session.vtitogtt " +
1:063dd55:                 "select * from table(emptySampleVTI()) as v");
1:063dd55:         JDBC.assertEmpty(s.executeQuery("select * from session.vtitogtt"));
1:063dd55:         s.executeUpdate("DROP FUNCTION emptySampleVTI");
1:063dd55: 
1:063dd55:         // Now try to actually insert some data.
1:063dd55:         s.executeUpdate("CREATE FUNCTION sampleVTI() " +
1:063dd55:                 "RETURNS TABLE(v1 varchar(10))" +
1:063dd55:                 "LANGUAGE JAVA " +
1:063dd55:                 "PARAMETER STYLE DERBY_JDBC_RESULT_SET " +
1:063dd55:                 "NO SQL " +
1:063dd55:                 "EXTERNAL NAME 'org.apache.derbyTesting.functionTests." +
1:063dd55:                 "util.SampleVTI.oneColSampleVTI'");
1:063dd55:         s.executeUpdate("insert into session.vtitogtt " +
1:063dd55:                 "select * from table(sampleVTI()) as v");
1:063dd55:         JDBC.assertUnorderedResultSet(
1:063dd55:                 s.executeQuery("select * from session.vtitogtt"),
1:063dd55:                 SampleVTI.oneColSampleVTIData());
1:063dd55:         s.executeUpdate("DROP FUNCTION sampleVTI");
1:063dd55:     }
1:063dd55: 
1:ca2807d:     /**
1:ca2807d:      * 
1:ca2807d:      * A Utility method that deletes all the SESSION schema tables before each fixture.
1:ca2807d:      *
1:ca2807d:      * @exception SQLException
1:ca2807d:      */
1:ca2807d:     public void dropSchemaTables() throws SQLException {
1:ca2807d:         Statement s = createStatement();
1:063dd55:         // Query the meta data to avoid filling the log with lots of
1:063dd55:         // table-not-found error messages.
1:063dd55:         ResultSet rs = getConnection().getMetaData().getTables(
1:063dd55:                 null, "SESSION", "%", null);
1:063dd55:         while (rs.next()) {
1:063dd55:             try {
1:063dd55:                 s.executeUpdate("DROP TABLE " + rs.getString(2) + "." +
1:063dd55:                         rs.getString(3));
1:063dd55:             } catch (SQLException e) {
1:063dd55:             }
1:ca2807d:         }
1:063dd55:         rs.close();
1:ca2807d:     }
1:ca2807d: }
============================================================================
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:063dd55
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.SampleVTI;
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Tests that you can insert data into a GTT with a VTI as the source.
1:      * <p>
1:      * This used to fail because inserting from a VTI would trigger bulk insert,
1:      * but the bulk insert code path is not supported for GTT as the
1:      * destination of the insert.
1:      * <p>
1:      * See DERBY-5614.
1:      */
1:     public void testVtiInsertIntoGTT()
1:             throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.vtitogtt(" +
1:                 "c1 varchar(10)) not logged on commit preserve rows");
1:         // Use an empty VTI as the source.
1:         s.executeUpdate("CREATE FUNCTION emptySampleVTI() " +
1:                 "RETURNS TABLE(v1 varchar(10))" +
1:                 "LANGUAGE JAVA " +
1:                 "PARAMETER STYLE DERBY_JDBC_RESULT_SET " +
1:                 "NO SQL " +
1:                 "EXTERNAL NAME 'org.apache.derbyTesting.functionTests." +
1:                 "util.SampleVTI.emptySampleVTI'");
1:         s.executeUpdate("insert into session.vtitogtt " +
1:                 "select * from table(emptySampleVTI()) as v");
1:         JDBC.assertEmpty(s.executeQuery("select * from session.vtitogtt"));
1:         s.executeUpdate("DROP FUNCTION emptySampleVTI");
1: 
1:         // Now try to actually insert some data.
1:         s.executeUpdate("CREATE FUNCTION sampleVTI() " +
1:                 "RETURNS TABLE(v1 varchar(10))" +
1:                 "LANGUAGE JAVA " +
1:                 "PARAMETER STYLE DERBY_JDBC_RESULT_SET " +
1:                 "NO SQL " +
1:                 "EXTERNAL NAME 'org.apache.derbyTesting.functionTests." +
1:                 "util.SampleVTI.oneColSampleVTI'");
1:         s.executeUpdate("insert into session.vtitogtt " +
1:                 "select * from table(sampleVTI()) as v");
1:         JDBC.assertUnorderedResultSet(
1:                 s.executeQuery("select * from session.vtitogtt"),
1:                 SampleVTI.oneColSampleVTIData());
1:         s.executeUpdate("DROP FUNCTION sampleVTI");
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Query the meta data to avoid filling the log with lots of
1:         // table-not-found error messages.
1:         ResultSet rs = getConnection().getMetaData().getTables(
1:                 null, "SESSION", "%", null);
1:         while (rs.next()) {
1:             try {
1:                 s.executeUpdate("DROP TABLE " + rs.getString(2) + "." +
1:                         rs.getString(3));
1:             } catch (SQLException e) {
1:             }
1:         rs.close();
commit:caa8627
/////////////////////////////////////////////////////////////////////////
1:             if (("T2".equals(rs1.getString(3))) &&
1:                     ("SESSION".equals(rs1.getString(2))))
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:f10793f
/////////////////////////////////////////////////////////////////////////
1:  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.DeclareGlobalTempTableJavaTest
/////////////////////////////////////////////////////////////////////////
1: 	return TestConfiguration.defaultSuite(DeclareGlobalTempTableJavaTest.class);
/////////////////////////////////////////////////////////////////////////
1:      *  Temporary table create and drop Rollback behaviour
1:      *  Tests the basic function of temporary table with holdability
1:      *
1:      *  @throws SQLException 
1:      */
1:     public void testTempTableDDLRollbackbehaviour1() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit preserve rows  not logged");
1:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:         s.executeUpdate("drop table SESSION.t1");
1:         // we've removed the table, so select should fail
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:         rollback();
1:         // should still fail after rollback; we don't have savepoints and
1:         // we rolled back entire transaction, incl. creation of temp table
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:     }
1: 
1:     /**
1:      *  Temporary table create and drop Rollback behaviour
1:      *  Tests drop of temp table and rollback - select should still work
1:      *
1:      *  @throws SQLException 
1:      */
1:     public void testTempTableDDLRollbackbehaviour2() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit preserve rows  not logged");
1:         commit();
1:         // drop table and rollback - select should still work
1:         s.executeUpdate("drop table SESSION.t1");
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:         rollback();
1:         // select should work again
1:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:     }
1: 
1:     /**
1:      *  Temporary table create and drop Rollback behaviour
1:      *  Tests drop of temp table and commit - select should no longer work
1:      *
1:      *  @throws SQLException 
1:      */
1:     public void testTempTableDDLRollbackbehaviour3() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit preserve rows  not logged");
1:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:         commit();
1:         // drop table and commit - select should no longer work
1:         s.executeUpdate("drop table SESSION.t1");
1:         commit();
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:     }
1: 
1:     /**
1:      *  Temporary table create and drop Rollback behaviour
1:      *  Tests create of temp table and rollback - select should fail
1:      *
1:      *  @throws SQLException 
1:      */
1:     public void testTempTableDDLRollbackbehaviour4() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("declare global temporary table SESSION.t1(c11 int, c12 int) on commit preserve rows  not logged");
1:         JDBC.assertSingleValueResultSet(s.executeQuery("select count(*) from SESSION.t1") , "0");
1:         rollback();
1:         assertStatementError("42X05" , s , "select * from SESSION.t1");
1:     }
1:     
1:     /**
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:ca2807d
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:  Derby - Class org.apache.derbyTesting.functionTests.tests.lang.DeclareGlobalTempTableJava
1: 
1:  Licensed to the Apache Software Foundation (ASF) under one or more
1:  contributor license agreements.  See the NOTICE file distributed with
1:  this work for additional information regarding copyright ownership.
1:  The ASF licenses this file to You under the Apache License, Version 2.0
1:  (the "License"); you may not use this file except in compliance with
1:  the License.  You may obtain a copy of the License at
1: 
1:  http://www.apache.org/licenses/LICENSE-2.0
1: 
1:  Unless required by applicable law or agreed to in writing, software
1:  distributed under the License is distributed on an "AS IS" BASIS,
1:  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:  See the License for the specific language governing permissions and
1:  limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.ResultSet;
1: import java.sql.ResultSetMetaData;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import java.sql.PreparedStatement;
1: import java.sql.DatabaseMetaData;
1: import java.sql.Connection;
1: 
1: import junit.framework.Test;
1: 
1: 
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: 
1: /**
1:  * Test for declared global temporary tables introduced in Cloudscape 5.2 The
1:  * temp table tests with holdable cursor and savepoints are in
1:  * declareGlobalTempTableJavaJDBC30 class. The reason for a different test class
1:  * is that the holdability and savepoint support is under jdk14 and higher. But
1:  * we want to be able to run the non-jdk14 specific tests under all the jdks we
1:  * support and hence splitting the tests into 2 different classes Global
1:  * Temporary Tables are referenced as GTT to make it easy for Naming.
1:  */
1: 
1: public class DeclareGlobalTempTableJavaTest extends BaseJDBCTestCase {
1: 
1:     public DeclareGlobalTempTableJavaTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0: 	return TestConfiguration.embeddedSuite(DeclareGlobalTempTableJavaTest.class);
1:     }
1:     protected void setUp() throws Exception {
1:         super.setUp();
1:         dropSchemaTables();
1:         getConnection().setAutoCommit(false);
1:     }
1: 
1:     protected void tearDown() throws Exception {
1:         super.tearDown();
1:     }
1: 
1:     /**
1:      * Test switching to session schema (it doesn't yet exist because no create
1:      * schema session has been issued yet) and then try to create first persistent
1:      * object in it. This used to cause null pointer exception (DERBY-1706).
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testDerby1706() throws SQLException {
1:         Statement s = createStatement();
1:         // the try/catch block ensures to drop the SESSION schema if exists.
1:         try {
1:             s.executeUpdate("drop schema SESSION restrict");
1:         } catch (SQLException e) {
1:             assertSQLState("42Y07", e);
1:         }
1:         assertUpdateCount(s , 0 , "set schema SESSION");
1:         // This used to cause NullPointerException before.
1:         assertUpdateCount(s, 0, "create table DERBY1706(c11 int)");
1:  	assertUpdateCount(s, 0, "drop table DERBY1706");
1:         assertUpdateCount(s, 0, "set schema APP");
1:  	assertUpdateCount(s, 0, "drop schema SESSION restrict");
1:     }
1: 
1:     /**
1:      * Test the schema of Golabal Temporary Tables.
1:      * Global Temporary Tables can only be in SESSION schema. Declaring them in Other schemas Should give an  Error. 
1:      * Global Temporary Tables always goes into SESSION schema. Even if
1:      * the current schema is not SESSION.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testGTTSchemaName() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "set schema APP");
1:         // Global Temporary Tables can only be created in SESSION schema
1:         assertStatementError("428EK",s,"DECLARE GLOBAL TEMPORARY TABLE APP.t2(c21 int) on commit delete rows not logged");
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE t2(c21 int) on commit delete rows not logged");
1:         // temp table t2 is not in APP schema
1:         assertStatementError("42X05", s, "insert into APP.t2 values(7)");
1:         // temp table should be referred as SESSIO.t2
1:         assertStatementError("42X05", s, "insert into t2 values(7)");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(7)");
1:         // temp table t2 must be qualified with SESSION
1:         assertStatementError("42Y55", s, "drop table t2");
1:         assertUpdateCount(s , 0 , "drop table SESSION.t2");
1:     }
1: 
1:     /**
1:      * Some positive Grammar tests for the DECLARE GLOBAL TEMPORARY TABLE
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testPositiveGrammars() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s, 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tA(c1 int) not logged");
1:         assertUpdateCount(s, 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tB(c1 int) on commit delete rows not logged");
1:         assertUpdateCount(s, 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tC(c1 int) not logged on commit delete rows");
1:         assertUpdateCount(s, 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tD(c1 int) on commit preserve rows not logged");
1:         assertUpdateCount(s, 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tE(c1 int) not logged on commit preserve rows");
1:         assertUpdateCount(s, 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tF(c1 int) on rollback delete rows not logged");
1:         assertUpdateCount(s, 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tG(c1 int) not logged on rollback delete rows");
1:         assertUpdateCount(
1:                 s,
1:                 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tH(c1 int) on commit preserve rows not logged on rollback delete rows");
1:         assertUpdateCount(
1:                 s,
1:                 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tI(c1 int) not logged on commit preserve rows on rollback delete rows");
1:         assertUpdateCount(
1:                 s,
1:                 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tJ(c1 int) not logged on rollback delete rows on commit preserve rows");
1:         assertUpdateCount(
1:                 s,
1:                 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tK(c1 int) on commit delete rows not logged on rollback delete rows");
1:         assertUpdateCount(
1:                 s,
1:                 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tL(c1 int) not logged on commit delete rows on rollback delete rows");
1:         assertUpdateCount(
1:                 s,
1:                 0,
1:                 "DECLARE GLOBAL TEMPORARY TABLE tM(c1 int) not logged on rollback delete rows on commit delete rows");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tA");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tB");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tC");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tD");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tE");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tF");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tG");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tH");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tI");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tJ");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tK");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tL");
1:         assertUpdateCount(s, 0, "DROP TABLE SESSION.tM");
1:     }
1: 
1:     /**
1:      * Some Negative Grammar tests for the DECLARE GLOBAL TEMPORARY TABLE
1:      * 
1:      * @exception SQLException
1:      * Thrown if some unexpected error happens
1:      */
1:     public void testNegativeGrammars() throws SQLException {
1:         Statement s = createStatement();
1:         assertStatementError("42X01", s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int)");
1:         assertStatementError("42613", s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int) NOT LOGGED NOT LOGGED");
1:         assertStatementError(
1:                 "42613",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int) NOT LOGGED ON COMMIT PRESERVE ROWS ON COMMIT DELETE ROWS");
1:         assertStatementError(
1:                 "42613",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int) NOT LOGGED ON ROLLBACK DELETE ROWS ON ROLLBACK DELETE ROWS");
1:         assertStatementError(
1:                 "42X01",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE t1(c11 int) ON ROLLBACK DELETE ROWS ON COMMIT PRESERVE ROWS");
1:     }
1: 
1:     /**
1:      * Test some of the features that are not allowed on temp tables namely
1:      * ALTER TABLE , LOCK TABLE , RENAME TABLE , CREATE INDEX AND CREATE VIEW
1:      * CREATE VIEW is some what special in that it can't have reference to the
1:      * temp tables. The Other two features are generated always as identity and
1:      * Long datatype.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testFeaturesNotAllowedOnGTTs() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) not logged on commit delete rows");
1:         // Alter Table is not allowed on temp tables.
1:         assertStatementError("42995", s,"ALTER TABLE SESSION.t2 add column c22 int");
1:         // Lock Table is not allowed on temp tables.
1:         assertStatementError("42995", s, "LOCK TABLE SESSION.t2 IN SHARE MODE");
1:         // Rename Table is not allowed on temp tables.
1:         assertStatementError("42995", s, "RENAME TABLE SESSION.t2 TO t3");
1:         // Create Index is not allowed on temp tables.
1:         assertStatementError("42995", s, "CREATE index t2i1 on SESSION.t2 (c21)");
1:         // Create view that references temp tables is not allowed
1:         assertStatementError("XCL51", s, "CREATE VIEW t2v1 as select * from SESSION.t2");
1:         // generated always as identity not allowed on temp tables.
1:         assertStatementError("42995",s,"DECLARE GLOBAL TEMPORARY TABLE SESSION.t1(c21 int generated always as identity) on commit delete rows not logged");
1:         // Long datatypes are not supported.
1:         assertStatementError(
1:                 "42962",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t1(c21 int, c22 blob(3k)) on commit delete rows not logged");
1:         assertStatementError(
1:                 "42962",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t1(c21 int, c22 clob(3k)) on commit delete rows not logged");
1:         assertStatementError(
1:                 "42962",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t1(c21 int, c22 long varchar) on commit delete rows not logged");
1:         s.executeUpdate("DROP TABLE SESSION.t2");
1:         assertStatementError("42Y55", s, "DROP TABLE SESSION.t1");
1:     }
1: 
1:     /**
1:      * Test some features that allowed on physical tables in SESSION Schema
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testFeaturesAllowedOnPhysicalTablesOfSESSIONSchema()
1:             throws SQLException {
1:         Statement s = createStatement();
1:         try {
1:             s.executeUpdate("CREATE schema SESSION");
1:         } catch (SQLException e) {
1:             assertSQLState("X0Y68", e);
1:         }
1:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t2(c21 int)");
1:         // Alter Table is allowed on physical tables in SESSION schema
1:         assertUpdateCount(s, 0, "ALTER TABLE SESSION.t2 add column c22 int");
1:         // Lock Table is allowed on physical tables in SESSION schema
1:   	assertUpdateCount(s , 0 , "LOCK TABLE SESSION.t2 IN EXCLUSIVE MODE");
1:         // Rename Table is allowed on physical tables in SESSION schema
1:         assertUpdateCount(s , 0 , "RENAME TABLE SESSION.t2 TO t3");
1:         // Lock column is allowed on physical tables in SESSION schema
1:         assertUpdateCount(s , 0 , "RENAME COLUMN SESSION.t3.c21 TO c23");
1:         // Create Index is allowed on physical tables in SESSION schema
1:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t2 (c21 int)");
1:         assertUpdateCount(s , 0 , "CREATE index t2i1 on SESSION.t2 (c21)");
1:         // Create View referencing physical tables in SESSION schema is not
1:         // supported
1:         assertStatementError("XCL51", s,
1:                 "CREATE VIEW t2v1 as select * from SESSION.t2");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t3");
1:     }
1:     /**
1:      * Test the various constraints not allowed on temp tables namely primary
1:      * key constraints , Unique constraints , check constraints and foreign key
1:      * constraints.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testConstraintsNotAllowedOnGTTs() throws SQLException {
1:         Statement s = createStatement();
1:         // primary key constraints are not allowed on temp tables.
1:         assertStatementError(
1:                 "42995",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int not null, constraint pk primary key (c21)) on commit delete rows not logged");
1:         // Unique constraints are not allowed on temp tables.
1:         assertStatementError(
1:                 "42995",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int not null unique) on commit delete rows not logged");
1:         // foreign key constraints are not allowed on temp tables.
1:         s.executeUpdate("CREATE TABLE t1(c11 int not null unique)");
1:         assertStatementError(
1:                 "42995",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int references t1(c11)) on commit delete rows not logged");
1:         // check constraints are not allowed on temp tables.
1:         assertStatementError(
1:                 "42995",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int check (c21 > 0)) on commit delete rows not logged");
1:         s.executeUpdate("DROP TABLE t1");
1:     }
1: 
1:     /**
1:      * Test the constraints allowed on physical tables in SESSION schema.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testConstraintsAllowedOnSESSIONPhysicalTables()
1:             throws SQLException {
1:         Statement s = createStatement();
1:         try {
1:             s.executeUpdate("CREATE SCHEMA SESSION");
1:         } catch (SQLException e) {
1:             assertSQLState("X0Y68", e);
1:         }
1:         // primary key constraints allowed on SESSION physical tables
1:         s
1:                 .executeUpdate("CREATE TABLE SESSION.t1(c21 int not null, constraint pk primary key (c21))");
1:         // unique constraints allowed on SESSION physical tables
1:         s.executeUpdate("CREATE TABLE SESSION.t2(c21 int not null unique)");
1:         // check constraints allowed on SESSION physical tables
1:         s.executeUpdate("CREATE TABLE SESSION.t3(c21 int check (c21 > 0))");
1:         // foreign key constraints allowed on SESSION physical tables
1:         s.executeUpdate("CREATE TABLE t4(c11 int not null unique)");
1:         s.executeUpdate("CREATE TABLE SESSION.t5(c21 int references t4(c11))");
1:         // cleanUp
1:         s.executeUpdate("DROP TABLE SESSION.t1");
1:         s.executeUpdate("DROP TABLE SESSION.t2");
1:         s.executeUpdate("DROP TABLE SESSION.t3");
1:         s.executeUpdate("DROP TABLE SESSION.t5");
1:         s.executeUpdate("DROP TABLE t4");
1:     }
1: 
1:     /**
1:      * Test declared temporary table with ON COMMIT DELETE ROWS with and without
1:      * open cursors. Tests with holdable cursor are in a different class since
1:      * holdability support is only under jdk14 and higher.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testOnCommiDeleteRowsWithAndWithoutOpenCursors()
1:             throws SQLException {
1:         Statement s = createStatement();
1:         // Temp table t2 with not holdable cursor open on it. Data should get
1:         // deleted from t2 at commit time
1:         assertUpdateCount(s, 0, "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit delete rows not logged");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(22, 22)");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(23, 23)");
1:         ResultSet rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:         // Before commit t2 has 2 columns.
1:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:         // eventhough this cursor is open, it is not a hold cursor. Commit
1:         // should delete the rows
1:         rs2 = s.executeQuery("select * from SESSION.t2");
1:         rs2.next();
1:         // Temp table t3 with no open cursors of any kind on it. Data should get
1:         // deleted from t3 at commit time
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(c31 int, c32 int) on commit delete rows not logged");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t3 values(32, 32)");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t3 values(33, 33)");
1:         ResultSet rs3 = s.executeQuery("select count(*) from SESSION.t3");
1:         // Before commit t3 has 2 columns.
1:         JDBC.assertSingleValueResultSet(rs3 , "2");
1:         // commiting the above statements
1: 	commit();
1:         // The 2 rows from t2 got deleted
1:         rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:         JDBC.assertSingleValueResultSet(rs2 , "0");
1:         // The 2 rows from t3 got deleted
1:         rs3 = s.executeQuery("select count(*) from SESSION.t3");
1:         JDBC.assertSingleValueResultSet(rs3 , "0");
1:         s.executeUpdate("DROP TABLE SESSION.t2");
1:         s.executeUpdate("DROP TABLE SESSION.t3");
1:     }
1:     /**
1:      * Declare a temporary table with ON COMMIT PRESERVE ROWS with and without
1:      * open cursors. Tests with holdable cursor are in a different class since
1:      * holdability support is only under jdk14 and higher.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testOnCommitPreserveRowsWithAndWithoutOpenCursors()
1:             throws SQLException {
1:         Statement s = createStatement();
1:         // Temp table t2 with not holdable cursor open on it. Data should be
1:         // preserved, holdability shouldn't matter
1:         s
1:                 .executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit preserve rows not logged");
1:         s.executeUpdate("insert into SESSION.t2 values(22, 22)");
1:         s.executeUpdate("insert into SESSION.t2 values(23, 23)");
1:         ResultSet rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:         // t2 has 2 rows before commiting.
1:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:         // eventhough this cursor is open, it is not a hold cursor.
1:         rs2 = s.executeQuery("select * from SESSION.t2");
1:         rs2.next();
1:         // Temp table t3 with no open cursors of any kind on it. Data should be
1:         // preserved, holdability shouldn't matter
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(c31 int, c32 int) on commit preserve rows not logged");
1:         s.executeUpdate("insert into SESSION.t3 values(32, 32)");
1:         s.executeUpdate("insert into SESSION.t3 values(33, 33)");
1:         ResultSet rs3 = s.executeQuery("select count(*) from SESSION.t3");
1:         // t3 has 2 rows before commiting.
1:         JDBC.assertSingleValueResultSet(rs3 , "2");
1:         // commit point
1:         commit();
1:         rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:         // The rows in t2 got preserved
1:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:         rs3 = s.executeQuery("select count(*) from SESSION.t3");
1:         // The rows in t3 got preserved
1:         JDBC.assertSingleValueResultSet(rs3 , "2");
1: 
1:         s.executeUpdate("DROP TABLE SESSION.t2");
1:         s.executeUpdate("DROP TABLE SESSION.t3");
1:     }
1: 
1:     /**
1:      * Test that We can't create the temp table twice and we can'd drop a temp
1:      * table that doesn't wxist.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testDuplicateAndNullGTT() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:         // temp table t2 already exists.
1:         assertStatementError(
1:                 "X0Y32",
1:                 s,
1:                 "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) not logged on commit preserve rows");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         // t2 has already been dropped.
1:         assertStatementError("42Y55", s, "DROP TABLE SESSION.t2");
1:     }
1: 
1:     /**
1:      * Test That Insert command allowed on temp tables in various conditions.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testInsertOnGTT() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 char(2)) on commit delete rows not logged");
1:         // Regular Insertion - Inserting with values.
1:         assertUpdateCount(s, 1, "insert into SESSION.t2 values (1, 'aa')");
1:         assertUpdateCount(s, 3, "insert into SESSION.t2 values (2, 'bb'),(3, 'cc'),(4, null)");
1:         assertUpdateCount(s, 0, "CREATE TABLE t1(c11 int, c22 char(2))");
1:         assertUpdateCount(s, 3, "insert into t1 values (5, null),(6, null),(7, 'gg')");
1:         // Insert into a table values selected from the Other table.
1:         assertUpdateCount(s, 3, "insert into SESSION.t2 (select * from t1 where c11>4)");
1:         assertUpdateCount(s, 7, "insert into SESSION.t2 select * from SESSION.t2");
1:         ResultSet rs1 = s.executeQuery("select sum(c21) from SESSION.t2");
1: 	JDBC.assertSingleValueResultSet(rs1 , "56");
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(c21 int, c22 char(2) not null) on commit delete rows not logged");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t3 values (1, 'aa')");
1:         // test inserting a null value into a non null column
1:         assertStatementError("23502", s, "insert into SESSION.t3 values (2, null)");
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t4(c21 int, c22 char(2) default 'aa', c23 varchar(20) default user ) on commit delete rows not logged");
1:         assertUpdateCount(s, 1, "insert into SESSION.t4 values (1, 'aa', null)");
1:         // Inserting into a table of which some columns have default values.
1:         assertUpdateCount(s, 1, "insert into SESSION.t4(c21) values (2)");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t4");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t3");
1:         assertUpdateCount(s , 0 , "DROP TABLE t1");
1:     }
1: 
1:     /**
1:      * Test Delete Operation on temp tables.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testDeleteOnGTT() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 decimal) not logged");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(1, 1.1)");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(2, 2.2)");
1:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         // Initially t2 has 2 rows
1:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:         assertUpdateCount(s , 2 , "DELETE FROM SESSION.t2 where c21 > 0");
1:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         // After deletion t2 has nothing
1:         JDBC.assertSingleValueResultSet(rs1 , "0");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:     }
1: 
1:     /**
1:      * Test Update on temp tables in various ways.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testUpdateOnGTT() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(1, 1)");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(2, 1)");
1:         ResultSet rs2 = s.executeQuery("select count(*) from SESSION.t2 where c22 = 1");
1:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:         assertUpdateCount(s , 2 , "UPDATE SESSION.t2 SET c22 = 2 where c21>0");
1:         rs2 = s.executeQuery("select count(*) from SESSION.t2 where c22 = 1");
1:         JDBC.assertSingleValueResultSet(rs2 , "0");
1:         rs2 = s.executeQuery("select count(*) from SESSION.t2 where c22 = 2");
1:         JDBC.assertSingleValueResultSet(rs2 , "2");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:     }
1: 
1:     /**
1:      * Test CREATE and DROP operations on SESSION schema
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testSESSIONschema() throws SQLException {
1:         Statement s = createStatement();
1:         // SESSION schema can be created like any other schema
1:         try {
1: 
1:             s.executeUpdate("CREATE SCHEMA SESSION");
1:         } catch (SQLException e) {
1:             assertSQLState("X0Y68", e);
1:         }
1:         // SESSION schema can be dropped like any Other Schema
1:         assertUpdateCount(s , 0 , "DROP SCHEMA SESSION restrict");
1:         // We can't drop the In-Memory SESSION schema
1:         assertStatementError("42Y07", s, "DROP SCHEMA SESSION restrict");
1:     }
1:     /**
1:      * CREATE VIEW in SESSION schema referencing a table outside of SESSION
1:      * schema.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testCreateView() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "CREATE TABLE t2 (c28 int)");
1:         assertUpdateCount(s , 2 , "INSERT INTO t2 VALUES (280),(281)");
1:         // Create a VIEW in SESSION schema referencing a table outside of
1:         // SESSION schema
1:         assertUpdateCount(s, 0, "CREATE VIEW SESSION.t2v1 as select * from t2");
1:         // Drop the view.
1:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2v1");
1:         // Test the values in View as selected from Table.
1:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:         assertUpdateCount(s , 0 , "DROP VIEW SESSION.t2v1");
1:         assertUpdateCount(s , 0 , "DROP TABLE t2");
1:     }
1:     /**
1:      * Multiple tests to make sure we do not do statement caching for statement
1:      * referencing SESSION schema tables. CREATE physical table and then DECLARE
1:      * GLOBAL TEMPORARY TABLE with the same name in session schema.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testStatementCaching() throws SQLException {
1:         Statement s = createStatement();
1:         // Need to do following 3 in autocommit mode otherwise the data
1:         // dictionary will be in write mode and statements won't get
1:         // cached. I need to have statement caching enabled here to make sure
1:         // that tables with same names do not conflict
1:         getConnection().setAutoCommit(true);
1:         try {
1:             s.executeUpdate("CREATE schema SESSION");
1:         } catch (SQLException e) {
1:             assertSQLState("X0Y68", e);
1:         }
1:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t2 (c21 int)");
1:         assertUpdateCount(s, 1, "INSERT into SESSION.t2 values(21)");
1:         getConnection().setAutoCommit(false);
1:         // select will return data from physical table t2
1:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         JDBC.assertSingleValueResultSet(rs1 , "1");
1:         // declare temporary table with same name as a physical table in SESSION
1:         // schema
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit delete rows not logged");
1:         assertUpdateCount(s , 1 , "INSERT into SESSION.t2 values(22, 22)");
1:         assertUpdateCount(s , 1 , "INSERT into SESSION.t2 values(23, 23)");
1:         // select will return data from temp table t2
1:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:         // drop the temp table t2
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         // select will return data from physical table t2 because temp table has
1:         // been deleted
1:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         JDBC.assertSingleValueResultSet(rs1 , "1");
1: 	// cleanup
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         assertUpdateCount(s , 0 , "drop schema SESSION restrict");
1:     }
1: 
1:     /**
1:      * After creating SESSION schema and making it current schema, temporary
1:      * tables should not require SESSION qualification
1:      * 
1:      * @exception SQLException
1:      */
1:     public void testSESSIONQualifier() throws SQLException {
1:         Statement s = createStatement();
1:         // We have to qualify the temp tables with SESSION qualifier.
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(21, 21)");
1:         assertStatementError("42X05", s, "insert into t2 values(23, 23)");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(22, 22)");
1:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:         // Create the SESSION Schema Manually
1:         try {
1:             s.executeUpdate("CREATE SCHEMA SESSION");
1:         } catch (SQLException e) {
1:             assertSQLState("X0Y68", e);
1:         }
1:         // Set the SESSION schema as current schema
1:         s.executeUpdate("SET SCHEMA SESSION");
1:         // we don't need the SESSION qualifier for referencing temp tables.
1:         rs1 = s.executeQuery("select count(*) from t2");
1:         JDBC.assertSingleValueResultSet(rs1 , "2");
1:         assertUpdateCount(s , 0 , "DROP TABLE t2");
1:         assertUpdateCount(s , 0 , "SET SCHEMA APP");
1:         assertUpdateCount(s , 0 , "drop schema SESSION restrict");
1:     }
1:     /**
1:      * Temporary table created in one connection should not be available in
1:      * another connection.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testOneGTTInConnection() throws SQLException {
1:         Statement s1 = createStatement();
1:         // creating the temp table in connection 1
1:         assertUpdateCount(s1 , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:         assertUpdateCount(s1, 1, "insert into SESSION.t2 values(22, 22)");
1:         // Getting the Second Connection
1:         Connection con2 = openDefaultConnection();
1:         Statement s2 = con2.createStatement();
1:         // con2 should not find temp table declared in con1
1:         assertStatementError("42X05", s2, "select count(*) from SESSION.t2");
1:         // connection1 will be closed in tearDown() methos automatically.
1:         s2.close();
1:         con2.close();
1:     }
1: 
1:     /**
1:      * Temp table in one connection should not conflict with temp table with
1:      * same name in another connection.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testSameGTTNameForTwoConnections() throws SQLException {
1:         Statement s1 = createStatement();
1:         // creating the temp table t2 in First Connection
1:         assertUpdateCount(s1 , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:         assertUpdateCount(s1, 1, "insert into SESSION.t2 values(22, 22)");
1:         // Getting the Second Connection.
1:         Connection con2 = openDefaultConnection();
1:         Statement s2 = con2.createStatement();
1:         // creating the temp table with same name (t2) in the Sesond Connection
1: 	assertUpdateCount(s2 , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) not logged");
1:         assertUpdateCount(s2, 1, "insert into SESSION.t2 values(99)");
1:         // dropping temp table t2 defined for con1
1:         assertUpdateCount(s1 , 0 , "DROP TABLE SESSION.t2");
1:         // dropping temp table t2 defined for con2
1:         assertUpdateCount(s2 , 0 , "DROP TABLE SESSION.t2");
1: 	s2.close();
1:         con2.close();
1:     }
1:     /**
1:      * Prepared statement test - drop the temp table underneath
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testPreparedStatement1() throws SQLException {
1:         Statement s = createStatement();
1:         s.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:         pStmt.setInt(1, 21);
1:         pStmt.setInt(2, 1);
1:         pStmt.execute();
1:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         JDBC.assertSingleValueResultSet(rs1 , "1");
1:         // drop the temp table t2
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         // now try to insert into the table t2 which was dropped
1:         try {
1:             pStmt.setInt(1, 22);
1:             pStmt.setInt(2, 2);
1:             pStmt.execute();
1:             fail(" Table/View 'SESSION.T2' does not exist:");
1:         } catch (SQLException e) {
1:             assertSQLState("42X05", e);
1:         }
1:     }
1:     /**
1:      * Prepared statement test - drop and recreate the temp table with different
1:      * definition underneath
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testPreparedStatement2() throws SQLException {
1:         Statement s = createStatement();
1:         // create the temporary table t2 with 2 columns.
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:         pStmt.setInt(1, 21);
1:         pStmt.setInt(2, 1);
1:         pStmt.execute();
1:         pStmt.close();
1:         ResultSet rs1 = s.executeQuery("select * from SESSION.t2");
1: 	rs1.next();
1: 	ResultSetMetaData rsmd = rs1.getMetaData();
1: 	assertEquals(2 , rsmd.getColumnCount());
1:  	//JDBC.assertSingleValueResultSet(rs1 , "1");
1:         // drop the temp table t2
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         // recreate the temp table t2 with 3 columns
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int, c23 int) not logged");
1:         pStmt = prepareStatement("insert into SESSION.t2 values (?, ? , ?)");
1:         pStmt.setInt(1, 22);
1:         pStmt.setInt(2, 2);
1:         pStmt.setNull(3, java.sql.Types.INTEGER);
1:         pStmt.execute();
1:         rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1: 	rsmd = rs1.getMetaData();
1:         assertEquals(3 , rsmd.getColumnCount());
1:         // drop the temp table t2
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         // recreate the temp table t2 with 4 columns.
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int, c23 int, c24 int not null) not logged");
1:         pStmt = prepareStatement("insert into SESSION.t2 values (?, ? , ? , ?)");
1:         // try to insert a null value into a non-null column
1:         try {
1:             pStmt.setInt(1, 22);
1:             pStmt.setInt(2, 2);
1:             pStmt.setNull(3, java.sql.Types.INTEGER);
1:             pStmt.setNull(4, java.sql.Types.INTEGER);
1:             pStmt.execute();
1:             fail("trying to Insert a null value into non null column:");
1:         } catch (SQLException e) {
1:             assertSQLState("23502", e);
1:         }
1:     }
1:     /**
1:      * Rollback behavior - declare temp table, rollback, select should fail.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testRollbackBehavior1() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged");
1:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:         pStmt.setInt(1, 21);
1:         pStmt.setInt(2, 1);
1:         pStmt.execute();
1:         pStmt.close();
1:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         JDBC.assertSingleValueResultSet(rs1 , "1");
1:         // RollBack to the last committed point
1:         rollback();
1:         // Now select from SESSION.t2 should fail
1:         assertStatementError("42X05", s, "select * from SESSION.t2");
1:     }
1:     /**
1:      * Rollback behavior - declare temp table, commit, drop temp table,
1:      * rollback, select should pass
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testRollbackBehavior2() throws SQLException {
1:         Statement s = createStatement();
1:         // create a temp table t2
1:     	assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit preserve rows not logged");
1:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:         pStmt.setInt(1, 21);
1:         pStmt.setInt(2, 1);
1:         pStmt.execute();
1:         pStmt.close();
1:         // commit the changes
1:         commit();
1:         // After commiting drop the temp table t2
1:         s.executeUpdate("DROP TABLE SESSION.t2");
1:         // Rollback the last Operation that is the DROP TABBE SESSION.t2 operation
1:         rollback();
1:         // now select will pass
1:         ResultSet rs2 = s.executeQuery("select count(*) from SESSION.t2");
1:         JDBC.assertSingleValueResultSet(rs2 , "0");	
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         commit();
1:     }
1:     /**
1:      * Rollback behavior - create temp table , commit , drop it and create
1:      * another temp table with samename , rollback select will select from the
1:      * first temp table.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testRollbackBehavior3() throws SQLException {
1:         Statement s = createStatement();
1:         // create temp table t2 with 3 columns.
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int, c23 int) on commit preserve rows not logged");
1:         assertUpdateCount(s, 1, "insert into session.t2 values(1,1,1)");
1:         ResultSet rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1: 	ResultSetMetaData rsmd = rs1.getMetaData();
1:         assertEquals(3 , rsmd.getColumnCount());
1:         // drop the temp table t2 with 3 columns.
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         assertStatementError("42X05", s, "select * from SESSION.t2");
1:         // create temp table with 2 columns.
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit preserve rows not logged");
1:         assertUpdateCount(s, 1, "insert into session.t2 values(1,1)");
1:         rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1: 	rsmd = rs1.getMetaData();
1:         assertEquals(2 , rsmd.getColumnCount());
1:         // commit point
1:         commit();
1:         // drop the temp table with 2 columns.
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         // create the temp table with 1 column.
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:         assertUpdateCount(s, 1, "insert into session.t2 values(1)");
1:         rs1 = s.executeQuery("select * from SESSION.t2");
1: 	rs1.next();
1: 	rsmd = rs1.getMetaData();
1:         assertEquals(1 , rsmd.getColumnCount());
1:         rs1.close();
1:         // rollback to the last committed point
1:         rollback();
1:         // Now we have the temp table with 2 columns.
1:         rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1: 	rsmd = rs1.getMetaData();
1:         assertEquals(2 , rsmd.getColumnCount());
1:         rs1.close();
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:     }
1:     /**
1:      * Rollback behavior for tables touched with DML
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testRollbackBehavior4() throws SQLException {
1:         Statement s = createStatement();
1:         // Declare temp table t2 & t3 & t4 & t5 with preserve rows, insert data
1:         // and commit
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit preserve rows not logged on rollback delete rows");
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t3(c31 int, c32 int) not logged on commit preserve rows on rollback delete rows");
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t4(c41 int, c42 int) not logged on rollback delete rows on commit preserve rows");
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t5(c51 int, c52 int) on commit preserve rows not logged");
1:         s.executeUpdate("insert into session.t2 values(21,1)");
1:         s.executeUpdate("insert into session.t2 values(22,2)");
1:         s.executeUpdate("insert into session.t2 values(23,3)");
1:         s.executeUpdate("insert into session.t3 values(31,1)");
1:         s.executeUpdate("insert into session.t3 values(32,2)");
1:         s.executeUpdate("insert into session.t3 values(33,3)");
1:         s.executeUpdate("insert into session.t4 values(41,1)");
1:         s.executeUpdate("insert into session.t4 values(42,2)");
1:         s.executeUpdate("insert into session.t4 values(43,3)");
1:         s.executeUpdate("insert into session.t5 values(51,1)");
1:         s.executeUpdate("insert into session.t5 values(52,2)");
1:         s.executeUpdate("insert into session.t5 values(53,3)");
1:         // commit point
1:         commit();
1:         // create a temp table t6 with preserve rows , insert data.
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t6(c61 int, c62 int) on commit preserve rows not logged on rollback delete rows");
1:         s.executeUpdate("insert into session.t6 values(61,1)");
1:         s.executeUpdate("insert into session.t6 values(62,2)");
1:         s.executeUpdate("insert into session.t6 values(63,3)");
1:         // DML Operations.
1:         s.executeUpdate("DELETE FROM session.t2 WHERE c22> (select c52 from session.t5 where c52=2)");
1:         s.executeUpdate("DELETE FROM session.t3 WHERE c32>3");
1:         // rollback to the last commit point
1:         rollback();
1:         // After rollback t2 should have nothing.
1:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1: 	JDBC.assertSingleValueResultSet(rs1 , "0");
1:         // temp table t3 should have no rows because attempt was made to delete
1:         // from it even though nothing actually got deleted from it in the transaction
1:         rs1 = s.executeQuery("select count(*) from SESSION.t3");
1: 	JDBC.assertSingleValueResultSet(rs1 , "0");
1:         // temp table t4 should have its data intact because it was not touched
1:         // in the transaction that got rolled back
1:         rs1 = s.executeQuery("select count(*) from SESSION.t4");
1: 	JDBC.assertSingleValueResultSet(rs1 , "3");
1:         // temp table t5 should have its data intact because it was only used in
1:         // where clause and not touched in the transaction that got rolled back
1:         rs1 = s.executeQuery("select count(*) from SESSION.t5");
1: 	JDBC.assertSingleValueResultSet(rs1 , "3");
1:         // temp table t6 got dropped as part of rollback of this transaction
1:         // since it was declared in this same transaction
1:         assertStatementError("42X05", s, "select * from SESSION.t6");
1:         // CleanUp
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t3");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t4");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t5");
1:     }
1:     /**
1:      * The Test Verifies that there is no entry in system catalogs for temporary
1:      * tables. while physical tables from SESSION schema have an entry.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testEntryForSESSIONTablesToSysCatalog() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:        ResultSet rs1 = s.executeQuery("select count(*) from sys.systables where CAST(tablename AS VARCHAR(128)) like 'T2'");
1: 	JDBC.assertSingleValueResultSet(rs1 , "0");
1:         // drop the temp table t2
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         // create a physical table in SESSION schema
1:         try {
1:             s.executeUpdate("CREATE SCHEMA SESSION");
1:         } catch (SQLException e) {
1:             assertSQLState("X0Y68", e);
1:         }
1:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t2(c21 int, c22 int)");
1:         rs1 = s.executeQuery("select count(*) from sys.systables where CAST(tablename AS VARCHAR(128)) like 'T2'");
1:         // System Catalog contains the physical tables from SESSION schema.
1: 	JDBC.assertSingleValueResultSet(rs1 , "1");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         assertUpdateCount(s , 0 , "drop schema SESSION restrict");
1:     }
1:     /**
1:      * Verify that there is no entry in system catalogs for SESSION schmea after
1:      * declare table.
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testEntryForSEESSIONtoSysCatalog() throws SQLException {
1:         Statement s = createStatement();
1:         try {
1:             s.executeUpdate("drop schema SESSION restrict");
1:         } catch (SQLException e) {
1:             assertSQLState("42Y07", e);
1:         }
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:         ResultSet rs1 = s.executeQuery("select count(schemaname) from sys.sysschemas where CAST(schemaname AS VARCHAR(128)) like 'SESSION'");
1: 	JDBC.assertSingleValueResultSet(rs1 , "0");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:     }
1:     /**
1:      * DatabaseMetaData.getTables() should not return temporary tables
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testDatabaseMetadata() throws SQLException {
1:         Statement s = createStatement();
1:         int count = 0;
1:         DatabaseMetaData databaseMetaData;
1:         databaseMetaData = getConnection().getMetaData();
1:         try {
1:             s.executeUpdate("CREATE SCHEMA SESSION");
1:         } catch (SQLException e) {
1:             assertSQLState("X0Y68", e);
1:         }
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int) on commit delete rows not logged");
1:         assertUpdateCount(s , 0 , "CREATE TABLE SESSION.t3(c31 int, c32 int)");
1:         ResultSet rs1 = databaseMetaData.getTables("", null, "%", null);
1:         while (rs1.next()) {
0:             if (("T2" == rs1.getString(3)) && ("SESSION" == rs1.getString(2)))
1:                 fail("Temporary table Found");
1:             count++;
1:         }
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t3");
1:         assertUpdateCount(s , 0 , "drop schema SESSION restrict");
1:     }
1:     /**
1:      * Test for delete where current of on temporary tables
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testDeleteWhereCurrentOfOnGTT() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit delete rows not logged");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(21, 1)");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(22, 1)");
1:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1: 	JDBC.assertSingleValueResultSet(rs1 , "2");
1:         PreparedStatement pStmt1 = prepareStatement("select c21 from session.t2 for update");
1:         ResultSet rs2 = pStmt1.executeQuery();
1:         rs2.next();
1:         PreparedStatement pStmt2 = prepareStatement("delete from session.t2 where current of "+ rs2.getCursorName());
1:         pStmt2.executeUpdate();
1:         rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1:         assertEquals(22, rs1.getInt(1));
1:         assertEquals(1, rs1.getInt(2));
1:         rs2.next();
1:         pStmt2.executeUpdate();
1:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         rs1.next();
1:         assertEquals(0, rs1.getInt(1));
1:         rs2.close();
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:     }
1:     /**
1:      * Test for update where current of on temporary tables
1:      * 
1:      * @throws SQLException
1:      */
1:     public void UpdateWhereCurrentOfOnGTT() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) on commit delete rows not logged");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(21, 1)");
1:         assertUpdateCount(s , 1 , "insert into SESSION.t2 values(22, 1)");
1:         ResultSet rs1 = s.executeQuery("select count(*) from SESSION.t2");
1: 	JDBC.assertSingleValueResultSet(rs1 , "2");
1:         PreparedStatement pStmt1 = prepareStatement("select c21 from session.t2 for update");
1:         ResultSet rs2 = pStmt1.executeQuery();
1:         rs2.next();
1:         PreparedStatement pStmt2 = prepareStatement("update session.t2 set c22 = 2 where current of "+ rs2.getCursorName());
1:         pStmt2.executeUpdate();
1:         rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1:         assertEquals(21, rs1.getInt(1));
1:         assertEquals(2, rs1.getInt(2));
1:         rs1.next();
1:         assertEquals(22, rs1.getInt(1));
1:         assertEquals(1, rs1.getInt(2));
1:         rs2.next();
1:         pStmt2.executeUpdate();
1:         rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1:         assertEquals(21, rs1.getInt(1));
1:         assertEquals(2, rs1.getInt(2));
1:         rs1.next();
1:         assertEquals(22, rs1.getInt(1));
1:         assertEquals(2, rs1.getInt(2));
1:         rs2.close();
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:     }
1:     /**
1:      * Prepared statement test - DML and rollback behavior
1:      * 
1:      * @throws SQLException
1:      */
1:     public void testDMLRollback1() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged on commit preserve rows");
1:         PreparedStatement pStmt = prepareStatement("insert into SESSION.t2 values (?, ?)");
1:         pStmt.setInt(1, 21);
1:         pStmt.setInt(2, 1);
1:         pStmt.execute();
1:         commit();
1:         ResultSet rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1:         assertEquals(21, rs1.getInt(1));
1:         assertEquals(1, rs1.getInt(2));
1:         pStmt.setInt(1, 22);
1:         pStmt.setInt(2, 2);
1:         pStmt.execute();
1:         rollback();
1:         rs1 = s.executeQuery("select count(*) from SESSION.t2");
1:         rs1.next();
1:         assertEquals(0, rs1.getInt(1));
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:     }
1:     /**
1:      * Prepared statement test - DML and rollback behavior.
1:      * 
1:      * @exception SQLException
1:      *                Thrown if some unexpected error happens
1:      */
1:     public void testDMLRollback2() throws SQLException {
1:         Statement s = createStatement();
1:         assertUpdateCount(s , 0 , "DECLARE GLOBAL TEMPORARY TABLE SESSION.t2(c21 int, c22 int) not logged on commit preserve rows");
1:         assertUpdateCount(s , 1 , "INSERT INTO SESSION.t2 VALUES(21, 1)");
1:         commit();
1:         ResultSet rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1:         assertEquals(21, rs1.getInt(1));
1:         assertEquals(1, rs1.getInt(2));
1:         prepareStatement("insert into SESSION.t2 values (?, ?)");
1:         rollback();
1:         rs1 = s.executeQuery("select * from SESSION.t2");
1:         rs1.next();
1:         assertEquals(21, rs1.getInt(1));
1:         assertEquals(1, rs1.getInt(2));
1:         assertUpdateCount(s , 0 , "DROP TABLE SESSION.t2");
1:     }
1:     /**
1:      * 
1:      * A Utility method that deletes all the SESSION schema tables before each fixture.
1:      *
1:      * @exception SQLException
1:      */
1:     public void dropSchemaTables() throws SQLException {
1:         Statement s = createStatement();
1:         try {
1:             s.executeUpdate("DROP TABLE SESSION.t1");
1:         } catch (SQLException e) {
1:         }
1:         try {
1:             s.executeUpdate("DROP TABLE SESSION.t2");
1:         } catch (SQLException e) {
1:         }
1:         try {
1:             s.executeUpdate("DROP TABLE SESSION.t3");
1:         } catch (SQLException e) {
1:         }
1:         try {
0:             s.executeUpdate("DROP TABLE SESSION.t4");
1:         } catch (SQLException e) {
1:         }
1:         try {
1:             s.executeUpdate("DROP TABLE SESSION.t5");
1:         } catch (SQLException e) {
1:         }
1:     }
1: }
1: 
============================================================================