4:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.compile.AggregateNode
1:345de35: 
1:2d37fd6:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2d37fd6:    contributor license agreements.  See the NOTICE file distributed with
1:2d37fd6:    this work for additional information regarding copyright ownership.
1:2d37fd6:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2d37fd6:    (the "License"); you may not use this file except in compliance with
1:2d37fd6:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
20:eac0369: 
7:eac0369:  */
1:eac0369: 
1:eac0369: package	org.apache.derby.impl.sql.compile;
1:eac0369: 
1:d389f7d: import java.util.List;
1:3bb140c: import org.apache.derby.catalog.AliasInfo;
1:2782d72: import org.apache.derby.catalog.TypeDescriptor;
1:2782d72: import org.apache.derby.catalog.types.AggregateAliasInfo;
2:eac0369: import org.apache.derby.iapi.error.StandardException;
2:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1:3bb140c: import org.apache.derby.iapi.services.context.ContextManager;
1:3bb140c: import org.apache.derby.iapi.services.loader.ClassFactory;
1:3bb140c: import org.apache.derby.iapi.services.loader.ClassInspector;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:3bb140c: import org.apache.derby.iapi.sql.compile.CompilerContext;
1:69f8afa: import org.apache.derby.iapi.sql.compile.Visitor;
1:d389f7d: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1:3bb140c: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:d389f7d: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:3bb140c: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:eac0369: 
3:eac0369: /**
1:3bb140c:  * An Aggregate Node is a node that represents a set function/aggregate.
1:eac0369:  * It used for all system aggregates as well as user defined aggregates.
1:eac0369:  */
1:eac0369: 
1:3bb140c: class AggregateNode extends UnaryOperatorNode
21:eac0369: {
1:2782d72:     static final class BuiltinAggDescriptor
1:2782d72:     {
1:2782d72:         public  final   String  aggName;
1:2782d72:         public  final   String  aggClassName;
1:2782d72:         public  final   TypeDescriptor  argType;
1:2782d72:         public  final   TypeDescriptor  returnType;
1:2782d72: 
1:2782d72:         public BuiltinAggDescriptor
1:2782d72:             (
1:2782d72:              String aggName,
1:2782d72:              String aggClassName,
1:2782d72:              TypeDescriptor argType,
1:2782d72:              TypeDescriptor returnType
1:2782d72:              )
1:2782d72:         {
1:2782d72:             this.aggName = aggName;
1:2782d72:             this.aggClassName = aggClassName;
1:2782d72:             this.argType = argType;
1:2782d72:             this.returnType = returnType;
1:2782d72:         }
1:2782d72:     }
1:2782d72:     
1:2782d72:     //
1:2782d72:     // Builtin aggregates which implement org.apache.derby.agg.Aggregator.
1:2782d72:     //
1:2782d72:     private static  BuiltinAggDescriptor[]  BUILTIN_MODERN_AGGS =
1:2782d72:     {
1:2782d72:         new BuiltinAggDescriptor
1:2782d72:         (
1:2782d72:          "VAR_POP",
1:2782d72:          "org.apache.derby.impl.sql.execute.VarPAggregator",
1:2782d72:          TypeDescriptor.DOUBLE,
1:2782d72:          TypeDescriptor.DOUBLE
1:2782d72:          ),
1:2782d72:         new BuiltinAggDescriptor
1:2782d72:         (
1:2782d72:          "VAR_SAMP",
1:2782d72:          "org.apache.derby.impl.sql.execute.VarSAggregator",
1:2782d72:          TypeDescriptor.DOUBLE,
1:2782d72:          TypeDescriptor.DOUBLE
1:2782d72:          ),
1:2782d72:         new BuiltinAggDescriptor
1:2782d72:         (
1:2782d72:          "STDDEV_POP",
1:2782d72:          "org.apache.derby.impl.sql.execute.StdDevPAggregator",
1:2782d72:          TypeDescriptor.DOUBLE,
1:2782d72:          TypeDescriptor.DOUBLE
1:2782d72:          ),
1:2782d72:         new BuiltinAggDescriptor
1:2782d72:         (
1:2782d72:          "STDDEV_SAMP",
1:2782d72:          "org.apache.derby.impl.sql.execute.StdDevSAggregator",
1:2782d72:          TypeDescriptor.DOUBLE,
1:2782d72:          TypeDescriptor.DOUBLE
1:2782d72:          ),
1:2782d72:     };
1:2782d72:     
1:eac0369: 	private boolean					distinct;
1:d861c23: 
1:eac0369: 	private AggregateDefinition		uad;
1:d389f7d:     private TableName           userAggregateName;
1:eac0369: 	private StringBuffer			aggregatorClassName;
1:eac0369: 	private String					aggregateDefinitionClassName;
1:e1f49ca:     private Class<?>                aggregateDefinitionClass;
1:eac0369: 	private ClassInspector			classInspector;
1:eac0369: 	private String					aggregateName;
1:d389f7d: 
1:eac0369: 	/*
1:eac0369: 	** We wind up pushing all aggregates into a different
1:eac0369: 	** resultColumnList.  When we do this (in 
1:eac0369: 	** replaceAggregateWithColumnReference), we return a
1:eac0369: 	** column reference and create a new result column.
1:eac0369: 	** This is used to store that result column.
1:eac0369: 	*/
1:eac0369: 	private ResultColumn			generatedRC;
1:eac0369: 	private ColumnReference			generatedRef;
1:c8603c4: 
1:3bb140c:     /**
1:3bb140c:      * Constructed when binding a StaticMethodNode that we realize is
1:3bb140c:      * an aggregate.
1:3bb140c:      *
1:3bb140c:      * @param operand the value expression for the aggregate
1:3bb140c:      * @param uadClass the class of the user aggregate definition
1:0cefeda:      * @param alias the name by which the aggregate was called
1:3bb140c:      * @param distinct boolean indicating whether this is distinct
1:eac0369: 	 *					or not.
1:3bb140c:      * @param aggregateName the name of the aggregate from the user's
1:3bb140c:      *                  perspective, e.g. MAX
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:      AggregateNode(
1:3bb140c:             ValueNode operand,
1:3bb140c:             UserAggregateDefinition uadClass,
1:0cefeda:             TableName alias,
1:3bb140c:             boolean distinct,
1:3bb140c:             String aggregateName,
1:3bb140c:             ContextManager cm) throws StandardException {
1:0cefeda:         this(operand, alias, distinct, aggregateName, cm);
1:3bb140c:         setUserDefinedAggregate(uadClass);
1:d389f7d:     }
1:0cefeda: 
1:3bb140c:     /**
1:3bb140c:      * @param operand the value expression for the aggregate
1:3bb140c:      * @param uadClass the class name for user aggregate definition
1:3bb140c:      * for the aggregate
1:3bb140c:      * @param distinct boolean indicating whether this is distinct
1:3bb140c:      *                  or not.
1:3bb140c:      * @param aggregateName the name of the aggregate from the user's
1:3bb140c:      *                  perspective, e.g. MAX
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     AggregateNode(
1:3bb140c:             ValueNode operand,
1:3bb140c:             TableName uadClass,
1:3bb140c:             boolean distinct,
1:3bb140c:             String aggregateName,
1:3bb140c:             ContextManager cm) throws StandardException {
2:3bb140c:         super(operand, cm);
2:3bb140c:         this.aggregateName = aggregateName;
1:3bb140c:         this.userAggregateName = uadClass;
2:3bb140c:         this.distinct = distinct;
1:3bb140c:     }
1:eac0369: 
1:3bb140c:     /**
1:3bb140c:      * @param operand the value expression for the aggregate
1:3bb140c:      * @param uadClass Class for the internal aggregate type
1:3bb140c:      * @param distinct boolean indicating whether this is distinct
1:3bb140c:      *                  or not.
1:3bb140c:      * @param aggregateName the name of the aggregate from the user's
1:3bb140c:      *                  perspective, e.g. MAX
1:3bb140c:      * @param cm context manager
1:3bb140c:      * @throws StandardException
1:3bb140c:      */
1:3bb140c:     AggregateNode(
1:3bb140c:             ValueNode operand,
1:e1f49ca:             Class<?> uadClass,
1:3bb140c:             boolean distinct,
1:3bb140c:             String aggregateName,
1:3bb140c:             ContextManager cm) throws StandardException {
1:3bb140c:         super(operand, cm);
1:3bb140c:         this.aggregateName = aggregateName;
1:3bb140c:         this.aggregateDefinitionClass = uadClass;
1:eac0369: 
1:3bb140c:         // Distinct is meaningless for min and max
1:3bb140c:         if (!aggregateDefinitionClass.equals(MaxMinAggregateDefinition.class)) {
1:3bb140c:             this.distinct = distinct;
1:3bb140c:         }
1:3bb140c: 
1:d389f7d:         this.aggregateDefinitionClassName = aggregateDefinitionClass.getName();
1:3bb140c:     }
1:3bb140c: 
1:3bb140c: 
1:d389f7d:     /** initialize fields for user defined aggregate */
1:d389f7d:     private void setUserDefinedAggregate( UserAggregateDefinition userAgg )
1:d389f7d:     {
1:d389f7d:         this.uad = userAgg;
1:d389f7d:         this.aggregateDefinitionClass = uad.getClass();
1:d389f7d:         this.aggregateDefinitionClassName = aggregateDefinitionClass.getName();
1:d389f7d:     }
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Replace aggregates in the expression tree with a ColumnReference to
1:eac0369: 	 * that aggregate, append the aggregate to the supplied RCL (assumed to
1:eac0369: 	 * be from the child ResultSetNode) and return the ColumnReference.
1:eac0369: 	 * This is useful for pushing aggregates in the Having clause down to
1:eac0369: 	 * the user's select at parse time.  It is also used for moving around 
1:eac0369: 	 * Aggregates in the select list when creating the Group By node.  In 
1:eac0369: 	 * that case it is called <B> after </B> bind time, so we need to create
1:eac0369: 	 * the column differently.
5:eac0369: 	 *
1:6b50965: 	 * @param rcl	The RCL to append to.
1:eac0369: 	 * @param tableNumber	The tableNumber for the new ColumnReference
1:eac0369: 	 *
1:eac0369: 	 * @return ValueNode	The (potentially) modified tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException			Thrown on error
1:eac0369: 	 */
1:3bb140c:     ValueNode replaceAggregatesWithColumnReferences(
1:3bb140c:         ResultColumnList rcl, int tableNumber) throws StandardException
1:d389f7d: 	{
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** This call is idempotent.  Do
1:eac0369: 		** the right thing if we have already
1:eac0369: 		** replaced ourselves.
1:eac0369: 		*/
1:eac0369: 		if (generatedRef == null)
1:71b5630: 		{
1:eac0369: 			String					generatedColName;
1:eac0369: 			CompilerContext 		cc = getCompilerContext();
1:eac0369: 			generatedColName ="SQLCol" + cc.getNextColumnNumber();
1:3bb140c:             generatedRC =
1:3bb140c:                 new ResultColumn(generatedColName, this, getContextManager());
1:eac0369: 			generatedRC.markGenerated();
1:eac0369: 	
1:eac0369: 			/*
1:eac0369: 			** Parse time.	
1:eac0369: 			*/
1:3bb140c:             generatedRef = new ColumnReference(generatedRC.getName(),
1:3bb140c:                                                null,
1:3bb140c:                                                getContextManager());
1:8fe9561: 
1:eac0369: 			// RESOLVE - unknown nesting level, but not correlated, so nesting levels must be 0
1:8fe9561:             generatedRef.setSource(generatedRC);
1:eac0369: 			generatedRef.setNestingLevel(0);
1:eac0369: 			generatedRef.setSourceLevel(0);
1:8fe9561:             
1:eac0369: 			if (tableNumber != -1)
1:eac0369: 			{
1:eac0369: 				generatedRef.setTableNumber(tableNumber);
1:3bb140c: 			}
1:eac0369: 
1:eac0369: 			rcl.addResultColumn(generatedRC);
1:eac0369: 
1:eac0369: 			/* 
1:eac0369: 			** Mark the ColumnReference as being generated to replace
1:eac0369: 			** an aggregate
1:eac0369: 			*/
1:eac0369: 			generatedRef.markGeneratedToReplaceAggregate();
20:eac0369: 		}
5:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			rcl.addResultColumn(generatedRC);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return generatedRef;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the AggregateDefinition.
1:eac0369: 	 *
1:eac0369: 	 * @return The AggregateDefinition
1:eac0369: 	 */
1:eac0369: 	AggregateDefinition getAggregateDefinition()
1:eac0369: 	{
1:eac0369: 		return uad;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the generated ResultColumn where this
1:eac0369: 	 * aggregate now resides after a call to 
1:eac0369: 	 * replaceAggregatesWithColumnReference().
1:eac0369: 	 *
1:eac0369: 	 * @return the result column
1:eac0369: 	 */
1:3bb140c:     ResultColumn getGeneratedRC()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(generatedRC != null, 
1:eac0369: 				"generatedRC is null.  replaceAggregateWithColumnReference() "+
1:eac0369: 				"has not been called on this AggergateNode.  Make sure "+
1:eac0369: 				"the node is under a ResultColumn as expected.");
1:eac0369: 		}
1:eac0369: 					
1:eac0369: 		return generatedRC;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the generated ColumnReference to this
1:eac0369: 	 * aggregate after the parent called
1:eac0369: 	 * replaceAggregatesWithColumnReference().
1:eac0369: 	 *
1:eac0369: 	 * @return the column reference
1:eac0369: 	 */
1:3bb140c:     ColumnReference getGeneratedRef()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.ASSERT(generatedRef != null, 
1:eac0369: 				"generatedRef is null.  replaceAggregateWithColumnReference() "+
1:eac0369: 				"has not been called on this AggergateNode.  Make sure "+
1:eac0369: 				"the node is under a ResultColumn as expected.");
1:eac0369: 		}
1:eac0369: 		return generatedRef;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Bind this operator.  Determine the type of the subexpression,
1:eac0369: 	 * and pass that into the UserAggregate.
1:eac0369: 	 *
1:eac0369: 	 * @param fromList			The query's FROM list
1:eac0369: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
1:09c2697:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:eac0369: 	 *
1:eac0369: 	 * @return	The new top of the expression tree.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:09c2697:     ValueNode bindExpression(
1:71c8e86:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
1:d861c23: 			throws StandardException
1:eac0369: 	{
1:d389f7d:         DataDictionary  dd = getDataDictionary();
1:eac0369: 		DataTypeDescriptor 	dts = null;
1:eac0369: 		ClassFactory		cf;
1:eac0369: 
1:eac0369: 		cf = getClassFactory();
1:eac0369: 		classInspector = cf.getClassInspector();
1:eac0369: 
1:a37ea51:         boolean noSchema = true;
1:d389f7d:         if ( userAggregateName != null )
1:d389f7d:         {
1:a37ea51:             noSchema = (userAggregateName.getSchemaName() == null );
1:eab88ec:             userAggregateName.bind();
1:0cefeda:         }
1:d389f7d: 
1:0cefeda:         // If this is a user-defined aggregate that hasn't been bound yet,
1:0cefeda:         // bind it now.
1:0cefeda:         if (userAggregateName != null && uad == null)
1:0cefeda:         {
1:2782d72:             String  schemaName = userAggregateName.getSchemaName();
1:d389f7d:             AliasDescriptor ad = resolveAggregate
1:d389f7d:                 (
1:d389f7d:                  dd,
1:2782d72:                  getSchemaDescriptor( schemaName, true ),
1:2782d72:                  userAggregateName.getTableName(),
1:2782d72:                  noSchema
1:d389f7d:                  );
1:d389f7d: 
1:d389f7d:             if ( ad == null )
1:d389f7d:             {
1:d389f7d:                 throw StandardException.newException
1:d389f7d:                     (
1:d389f7d:                      SQLState.LANG_OBJECT_NOT_FOUND,
1:d389f7d:                      AliasDescriptor.getAliasType( AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR ),
2:d389f7d:                      userAggregateName.getTableName()
1:d389f7d:                      );
1:d389f7d:             }
1:d389f7d:             
1:d389f7d:             setUserDefinedAggregate( new UserAggregateDefinition( ad ) );
1:d389f7d:             aggregateName = ad.getJavaClassName();
1:d389f7d:          }
1:d389f7d: 
1:eac0369: 		instantiateAggDef();
1:eac0369: 
1:f3c6217:         // if this is a user-defined aggregate
1:2cf546d:         if ( isUserDefinedAggregate() )
1:f3c6217:         {
1:f3c6217:             AliasDescriptor ad = ((UserAggregateDefinition) uad).getAliasDescriptor();
1:a37ea51:             boolean         isModernBuiltinAggregate =
1:a37ea51:                 SchemaDescriptor.STD_SYSTEM_SCHEMA_NAME.equals( ad.getSchemaName() );
1:a37ea51: 
1:a37ea51:             if ( distinct && isModernBuiltinAggregate )
1:a37ea51:             {
1:a37ea51:                 throw StandardException.newException( SQLState.LANG_BAD_DISTINCT_AGG );
1:a37ea51:             }
1:f3c6217: 
1:f3c6217:             // set up dependency on the user-defined aggregate and compile a check for USAGE
1:f3c6217:             // priv if needed
1:f3c6217:             getCompilerContext().createDependency( ad );
1:f3c6217: 
1:f3c6217:             if ( isPrivilegeCollectionRequired() )
1:f3c6217:             {
1:2782d72:                 //
1:2782d72:                 // Don't need a privilege check for modern, builtin (system)
1:2782d72:                 // aggregates. They are tricky. They masquerade as user-defined
1:2782d72:                 // aggregates because they implement org.apache.derby.agg.Aggregator
1:2782d72:                 //
1:a37ea51:                 if ( !isModernBuiltinAggregate )
1:2782d72:                 {
1:2782d72:                     getCompilerContext().addRequiredUsagePriv( ad );
1:2782d72:                 }
1:f3c6217:             }
1:f3c6217:         }
1:f3c6217: 
1:09c2697:         // Add ourselves to the list of aggregates before we do anything else.
1:09c2697:         aggregates.add(this);
1:eac0369: 
1:e671fc7:         CompilerContext cc = getCompilerContext();
1:e671fc7:         
1:85ddc17:         // operand being null means a count(*)
1:eac0369: 		if (operand != null)
1:eac0369: 		{
1:e671fc7:             int previousReliability = orReliability( CompilerContext.AGGREGATE_RESTRICTION );
1:09c2697:             bindOperand(fromList, subqueryList, aggregates);
1:e671fc7:             cc.setReliability( previousReliability );
1:3233189:             
1:eac0369: 			/*
1:eac0369: 			** Make sure that we don't have an aggregate 
1:eac0369: 			** IMMEDIATELY below us.  Don't search below
1:eac0369: 			** any ResultSetNodes.
1:eac0369: 			*/
1:eac0369: 			HasNodeVisitor visitor = new HasNodeVisitor(this.getClass(), ResultSetNode.class);
1:eac0369: 			operand.accept(visitor);
1:eac0369: 			if (visitor.hasNode())
1:eac0369: 			{
1:cb25c65: 				throw StandardException.newException
1:cb25c65:                     (
1:cb25c65:                      SQLState.LANG_USER_AGGREGATE_CONTAINS_AGGREGATE, 
1:cb25c65:                      getSQLName()
1:cb25c65:                     );
1:eac0369: 			}
1:eac0369: 
1:7a9ce7e: 			// Also forbid any window function inside an aggregate unless in
1:7a9ce7e: 			// subquery, cf. SQL 2003, section 10.9, SR 7 a).
1:7a9ce7e: 			SelectNode.checkNoWindowFunctions(operand, aggregateName);
1:7a9ce7e: 
1:eac0369: 			/*
1:eac0369: 			** Check the type of the operand.  Make sure that the user
1:eac0369: 			** defined aggregate can handle the operand datatype.
1:eac0369: 			*/
1:eac0369: 			dts = operand.getTypeServices();
1:eac0369: 
1:eac0369: 			/* Convert count(nonNullableColumn) to count(*)	*/
1:eac0369: 			if (uad instanceof CountAggregateDefinition &&
1:eac0369: 				!dts.isNullable())
1:eac0369: 			{
1:eac0369: 				setOperator(aggregateName);
1:eac0369: 				setMethodName(aggregateName);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** If we have a distinct, then the value expression
1:eac0369: 			** MUST implement Orderable because we are going
1:eac0369: 			** to process it using it as part of a sort.
1:eac0369: 			*/
1:eac0369: 			if (distinct)
1:eac0369: 			{
1:eac0369: 				/*
1:eac0369: 				** For now, we check to see if orderable() returns
1:eac0369: 				** true for this type.  In the future we may need
1:eac0369: 				** to check to see if the type implements Orderable
1:eac0369: 				**
1:eac0369: 				*/
1:eac0369: 				if (!operand.getTypeId().orderable(cf))
1:eac0369: 				{
1:eac0369: 					throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION, 
1:eac0369: 							dts.getTypeId().getSQLTypeName());
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			/*
1:eac0369: 			** Don't allow an untyped null
1:eac0369: 			*/
1:eac0369: 			if (operand instanceof UntypedNullConstantNode)
1:eac0369: 			{
1:cb25c65: 				throw StandardException.newException
1:cb25c65:                     (SQLState.LANG_USER_AGGREGATE_BAD_TYPE_NULL, getSQLName());
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Ask the aggregate definition whether it can handle
1:85ddc17: 	 	** the input datatype.
1:eac0369: 	 	*/
1:85ddc17:         aggregatorClassName = new StringBuffer();
1:85ddc17:         DataTypeDescriptor resultType = uad.getAggregator(dts, aggregatorClassName);
1:eac0369: 
1:eac0369: 		if (resultType == null)
1:eac0369: 		{
1:d861c23: 			throw StandardException.newException
1:d861c23:                 (
1:d861c23:                  SQLState.LANG_USER_AGGREGATE_BAD_TYPE, 
1:d861c23:                  getSQLName(), 
1:d861c23:                  operand.getTypeId().getSQLTypeName()
1:d861c23:                  );
1:eac0369: 		}
1:eac0369: 
1:2cf546d:         // For user-defined aggregates, the input operand may need to be
1:2cf546d:         // coerced to the expected input type of the aggregator.
1:2cf546d:         if ( isUserDefinedAggregate() )
1:2cf546d:         {
1:2cf546d:             ValueNode   castNode = ((UserAggregateDefinition) uad).castInputValue
1:3bb140c:                 ( operand, getContextManager() );
1:2cf546d: 
1:2cf546d:             if ( castNode != null )
1:2cf546d:             {
1:09c2697:                 operand = castNode.bindExpression( fromList, subqueryList, aggregates );
1:2cf546d:             }
1:2cf546d:         }
1:2cf546d: 
1:eac0369: 		checkAggregatorClassName(aggregatorClassName.toString());
1:eac0369: 
1:85ddc17: 		setType(resultType);
1:eac0369: 
1:eac0369: 		return this;
1:eac0369: 	}
1:eac0369: 
1:d389f7d: 	/**
1:d389f7d: 	 * Resolve a user-defined aggregate.
1:d389f7d: 	 */
1:2782d72:     static AliasDescriptor resolveAggregate
1:2782d72:         ( DataDictionary dd, SchemaDescriptor sd, String rawName, boolean noSchema )
1:d389f7d:         throws StandardException
1:d389f7d:     {
1:2782d72:         // first see if this is one of the builtin aggregates which
1:2782d72:         // implements the Aggregator interface
1:2782d72:         AliasDescriptor ad = resolveBuiltinAggregate( dd, rawName, noSchema );
1:2782d72:         if ( ad != null ) { return ad; }
1:2782d72:         
1:fbf52ee:         // if the schema has a null UUID, that means the schema has not
1:fbf52ee:         // been created yet. in that case, it doesn't have any aggregates in it.
1:fbf52ee:         if ( sd.getUUID() == null ) { return null; }
1:fbf52ee:         
1:3bb140c:         java.util.List<AliasDescriptor> list = dd.getRoutineList
1:d389f7d:             ( sd.getUUID().toString(), rawName, AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR );
1:d389f7d: 
1:3bb140c:         if ( list.size() > 0 ) { return list.get( 0 ); }
1:d389f7d: 
1:d389f7d:         return null;
1:d389f7d:     }
1:2782d72: 
1:2782d72:     /**
1:2782d72:      * Construct an AliasDescriptor for a modern builtin aggregate.
1:2782d72:      */
1:2782d72:     private static AliasDescriptor resolveBuiltinAggregate
1:2782d72:         ( DataDictionary dd, String rawName, boolean noSchema )
1:2782d72:         throws StandardException
1:2782d72:     {
1:2782d72:         // builtin aggregates may not be schema-qualified
1:2782d72:         if ( !noSchema ) { return null; }
1:2782d72: 
1:2782d72:         BuiltinAggDescriptor    bad = null;
1:2782d72: 
1:2782d72:         for ( BuiltinAggDescriptor aggDescriptor : BUILTIN_MODERN_AGGS )
1:2782d72:         {
1:2782d72:             if ( aggDescriptor.aggName.equals( rawName ) )
1:2782d72:             {
1:2782d72:                 bad = aggDescriptor;
1:2782d72:                 break;
1:2782d72:             }
1:2782d72:         }
1:2782d72:         if ( bad == null ) { return null; }
1:2782d72: 
1:2782d72:         AliasInfo   aliasInfo = new AggregateAliasInfo( bad.argType, bad.returnType );
1:2782d72:         
1:2782d72:         return new AliasDescriptor
1:2782d72:             (
1:2782d72:              dd,
1:2782d72:              null,
1:2782d72:              rawName,
1:2782d72:              dd.getSystemSchemaDescriptor().getUUID(),
1:2782d72:              bad.aggClassName,
1:2782d72:              AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR,
1:2782d72:              AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR,
1:2782d72:              false,
1:2782d72:              aliasInfo,
1:2782d72:              null
1:2782d72:              );
1:2782d72:     }
1:d389f7d:     
1:eac0369: 	/*
1:eac0369: 	** Make sure the aggregator class is ok
1:eac0369: 	*/
1:eac0369: 	private void checkAggregatorClassName(String className) throws StandardException
1:eac0369: 	{
1:2e1b5e8: 		verifyClassExist(className);
1:eac0369: 
1:eac0369: 		if (!classInspector.assignableTo(className, "org.apache.derby.iapi.sql.execute.ExecAggregator"))
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_BAD_AGGREGATOR_CLASS2, 
1:eac0369: 													className, 
1:cb25c65: 													getSQLName(),
2:eac0369: 													operand.getTypeId().getSQLTypeName());
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 		
1:eac0369: 	/*
1:eac0369: 	** Instantiate the aggregate definition.
1:eac0369: 	*/
1:eac0369: 	private void instantiateAggDef() throws StandardException
1:eac0369: 	{
1:c8603c4:         if ( uad == null )
1:c8603c4:         {
1:e1f49ca:             Class<?> theClass = aggregateDefinitionClass;
1:eac0369: 
1:c8603c4:             // get the class
1:c8603c4:             if (theClass == null)
1:c8603c4:             {
1:c8603c4:                 String aggClassName = aggregateDefinitionClassName;
1:c8603c4:                 verifyClassExist(aggClassName);
1:eac0369: 
1:c8603c4:                 try
1:c8603c4:                 {
1:c8603c4:                     theClass = classInspector.getClass(aggClassName);
1:c8603c4:                 }
1:c8603c4:                 catch (Throwable t)
1:c8603c4:                 {
1:c8603c4:                     throw StandardException.unexpectedUserException(t);
1:c8603c4:                 }
1:c8603c4:             }
1:eac0369: 
1:c8603c4:             // get an instance
1:c8603c4:             Object instance = null;
1:c8603c4:             try
1:c8603c4:             {
1:4469400:                 instance = theClass.getConstructor().newInstance();
1:c8603c4:             }
1:c8603c4:             catch (Throwable t)
1:c8603c4:             {
1:c8603c4:                 throw StandardException.unexpectedUserException(t);
1:c8603c4:             }
1:eac0369: 
1:c8603c4:             if (!(instance instanceof AggregateDefinition))
1:c8603c4:             {
1:c8603c4:                 throw StandardException.newException(SQLState.LANG_INVALID_USER_AGGREGATE_DEFINITION2, aggregateDefinitionClassName);
1:c8603c4:             }
1:eac0369: 
1:c8603c4:             if (instance instanceof MaxMinAggregateDefinition)
1:c8603c4:             {
1:c8603c4:                 MaxMinAggregateDefinition temp = (MaxMinAggregateDefinition)instance;
1:c8603c4:                 if (aggregateName.equals("MAX"))
1:c8603c4:                     temp.setMaxOrMin(true);
1:c8603c4:                 else
1:c8603c4:                     temp.setMaxOrMin(false);
1:c8603c4:             }
1:eac0369: 
1:c8603c4:             if (instance instanceof SumAvgAggregateDefinition)
1:c8603c4:             {
1:c8603c4:                 SumAvgAggregateDefinition temp1 = (SumAvgAggregateDefinition)instance;
1:c8603c4:                 if (aggregateName.equals("SUM"))
1:c8603c4:                     temp1.setSumOrAvg(true);
1:c8603c4:                 else
1:c8603c4:                     temp1.setSumOrAvg(false);
1:c8603c4:             }
1:eac0369: 
1:c8603c4:             this.uad = (AggregateDefinition)instance;
1:c8603c4:         }
1:eac0369: 	
1:eac0369: 		setOperator(aggregateName);
1:eac0369: 		setMethodName(aggregateDefinitionClassName);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Indicate whether this aggregate is distinct or not.
1:eac0369: 	 *
1:eac0369: 	 * @return 	true/false
1:eac0369: 	 */
1:3bb140c:     boolean isDistinct()
1:eac0369: 	{
1:eac0369: 		return distinct;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the class that implements that aggregator for this
1:eac0369: 	 * node.
1:eac0369: 	 *
1:eac0369: 	 * @return the class name
1:eac0369: 	 */
1:3bb140c:     String  getAggregatorClassName()
1:eac0369: 	{
1:eac0369: 		return aggregatorClassName.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the class that implements that aggregator for this
1:eac0369: 	 * node.
1:eac0369: 	 *
1:eac0369: 	 * @return the class name
1:eac0369: 	 */
1:3bb140c:     String  getAggregateName()
1:eac0369: 	{
1:cb25c65: 		return aggregateName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the result column that has a new aggregator.
1:eac0369: 	 * This aggregator will be fed into the sorter.
1:eac0369: 	 *
1:6b50965: 	 * @param dd	the data dictionary
1:eac0369: 	 *
1:eac0369: 	 * @return the result column.  WARNING: it still needs to be bound
1:eac0369: 	 *
2:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     ResultColumn    getNewAggregatorResultColumn(DataDictionary dd)
3:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		String	className = aggregatorClassName.toString();
1:eac0369: 
1:d1fbe3c: 		DataTypeDescriptor compType =
1:d1fbe3c:             DataTypeDescriptor.getSQLDataTypeDescriptor(className);
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Create a null of the right type.  The proper aggregators
1:eac0369: 		** are created dynamically by the SortObservers
1:eac0369: 		*/
1:d1fbe3c: 		ConstantNode nullNode = getNullNode(compType);
1:eac0369: 
1:eac0369: 		nullNode.bindExpression(
1:eac0369: 						null,	// from
1:eac0369: 						null,	// subquery
1:eac0369: 						null);	// aggregate
1:eac0369: 
1:eac0369: 		/*
1:eac0369: 		** Create a result column with this new node below
1:eac0369: 		** it.
1:eac0369: 		*/
1:3bb140c:         return new ResultColumn(aggregateName, nullNode, getContextManager());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the aggregate expression in a new result
1:eac0369: 	 * column.
1:eac0369: 	 *
1:6b50965: 	 * @param dd the data dictionary
1:eac0369: 	 *
1:eac0369: 	 * @return the result column.  WARNING: it still needs to be bound
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:eac0369: 	 */
1:3bb140c:     ResultColumn    getNewExpressionResultColumn(DataDictionary dd)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		ValueNode		node;
1:eac0369: 		/*
1:eac0369: 		** Create a result column with the aggrergate operand
1:eac0369: 		** it.  If there is no operand, then we have a COUNT(*),
1:eac0369: 		** so we'll have to create a new null node and put
1:eac0369: 		** that in place.
1:eac0369: 		*/
1:eac0369: 		node = (operand == null) ?
1:eac0369: 			this.getNewNullResultExpression() :
1:eac0369: 			operand;
1:8d13a1f: 
1:3bb140c:         return new ResultColumn(
1:3bb140c:             "##aggregate expression", node, getContextManager());
1:8d13a1f: 	}
1:8d13a1f: 
1:eac0369: 	/**
1:eac0369: 	 * Get the null aggregate result expression
1:eac0369: 	 * column.
1:eac0369: 	 *
1:eac0369: 	 * @return the value node
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException on error
1:8d13a1f: 	 */
1:3bb140c:     ValueNode   getNewNullResultExpression()
1:eac0369: 		throws StandardException
1:8d13a1f: 	{
1:eac0369: 		/*
1:eac0369: 		** Create a result column with the aggrergate operand
1:eac0369: 		** it.
1:eac0369: 		*/
1:d1fbe3c: 		return getNullNode(getTypeServices());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Do code generation for this unary operator.  Should
1:eac0369: 	 * never be called for an aggregate -- it should be converted
1:eac0369: 	 * into something else by code generation time.
1:eac0369: 	 *
1:eac0369: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1:eac0369: 	 * @param mb	The method the code to place the code
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:3bb140c:     @Override
1:8fe3166:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:eac0369: 			SanityManager.THROWASSERT("generateExpression() should never "+
1:eac0369: 					"be called on an AggregateNode.  "+
1:eac0369: 					"replaceAggregatesWithColumnReferences should have " +
1:eac0369: 					"been called prior to generateExpression");
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Print a string ref of this node.
1:eac0369: 	 *
1:eac0369: 	 * @return a string representation of this node 
1:eac0369: 	 */
1:3bb140c:     @Override
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 		{
1:cb25c65: 			return "aggregateName: " + getSQLName() + "\n" +
1:c9a1206: 				"distinct: " + distinct + "\n" +
1:eac0369: 				super.toString();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			return "";
1:eac0369: 		}
1:eac0369: 	}
1:71b5630: 
1:3bb140c:     boolean isConstant()
1:71b5630: 	{
1:71b5630: 		return false;
1:71b5630: 	}
1:71b5630: 	
1:3bb140c:     @Override
1:3bb140c:     boolean constantExpression(PredicateList where)
1:d861c23: 	{
1:71b5630: 		return false;
1:71b5630: 	}
1:eac0369: 
1:d861c23:     /** Get the SQL name of the aggregate */
1:d861c23:     public  String  getSQLName()
1:cb25c65:     {
1:2cf546d:         if ( isUserDefinedAggregate() )
1:d861c23:         {
1:3d1bc57:             return ((UserAggregateDefinition) uad).
1:3d1bc57:                     getAliasDescriptor().getQualifiedName();
1:cb25c65:         }
1:d861c23:         else { return aggregateName; }
1:d861c23:     }
1:2cf546d:     
1:2cf546d:     /** Return true if this is a user-defined aggregate */
1:2cf546d:     private boolean isUserDefinedAggregate()
1:2cf546d:     {
1:3d1bc57:         return uad instanceof UserAggregateDefinition;
1:2cf546d:     }
1:2cf546d: 
1:69f8afa:     @Override
1:69f8afa:     void acceptChildren(Visitor v) throws StandardException {
1:69f8afa:         super.acceptChildren(v);
1:69f8afa: 
1:69f8afa:         if (userAggregateName != null) {
1:69f8afa:             userAggregateName = (TableName) userAggregateName.accept(v);
1:d861c23:         }
1:69f8afa:     }
1:69f8afa: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                 instance = theClass.getConstructor().newInstance();
commit:a37ea51
/////////////////////////////////////////////////////////////////////////
1:         boolean noSchema = true;
1:             noSchema = (userAggregateName.getSchemaName() == null );
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             boolean         isModernBuiltinAggregate =
1:                 SchemaDescriptor.STD_SYSTEM_SCHEMA_NAME.equals( ad.getSchemaName() );
1: 
1:             if ( distinct && isModernBuiltinAggregate )
1:             {
1:                 throw StandardException.newException( SQLState.LANG_BAD_DISTINCT_AGG );
1:             }
/////////////////////////////////////////////////////////////////////////
1:                 if ( !isModernBuiltinAggregate )
commit:2782d72
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.catalog.TypeDescriptor;
1: import org.apache.derby.catalog.types.AggregateAliasInfo;
/////////////////////////////////////////////////////////////////////////
1:     static final class BuiltinAggDescriptor
1:     {
1:         public  final   String  aggName;
1:         public  final   String  aggClassName;
1:         public  final   TypeDescriptor  argType;
1:         public  final   TypeDescriptor  returnType;
1: 
1:         public BuiltinAggDescriptor
1:             (
1:              String aggName,
1:              String aggClassName,
1:              TypeDescriptor argType,
1:              TypeDescriptor returnType
1:              )
1:         {
1:             this.aggName = aggName;
1:             this.aggClassName = aggClassName;
1:             this.argType = argType;
1:             this.returnType = returnType;
1:         }
1:     }
1:     
1:     //
1:     // Builtin aggregates which implement org.apache.derby.agg.Aggregator.
1:     //
1:     private static  BuiltinAggDescriptor[]  BUILTIN_MODERN_AGGS =
1:     {
1:         new BuiltinAggDescriptor
1:         (
1:          "VAR_POP",
1:          "org.apache.derby.impl.sql.execute.VarPAggregator",
1:          TypeDescriptor.DOUBLE,
1:          TypeDescriptor.DOUBLE
1:          ),
1:         new BuiltinAggDescriptor
1:         (
1:          "VAR_SAMP",
1:          "org.apache.derby.impl.sql.execute.VarSAggregator",
1:          TypeDescriptor.DOUBLE,
1:          TypeDescriptor.DOUBLE
1:          ),
1:         new BuiltinAggDescriptor
1:         (
1:          "STDDEV_POP",
1:          "org.apache.derby.impl.sql.execute.StdDevPAggregator",
1:          TypeDescriptor.DOUBLE,
1:          TypeDescriptor.DOUBLE
1:          ),
1:         new BuiltinAggDescriptor
1:         (
1:          "STDDEV_SAMP",
1:          "org.apache.derby.impl.sql.execute.StdDevSAggregator",
1:          TypeDescriptor.DOUBLE,
1:          TypeDescriptor.DOUBLE
1:          ),
1:     };
1:     
/////////////////////////////////////////////////////////////////////////
1:             String  schemaName = userAggregateName.getSchemaName();
0:             boolean noSchema = schemaName == null;
1:                  getSchemaDescriptor( schemaName, true ),
1:                  userAggregateName.getTableName(),
1:                  noSchema
/////////////////////////////////////////////////////////////////////////
1:                 //
1:                 // Don't need a privilege check for modern, builtin (system)
1:                 // aggregates. They are tricky. They masquerade as user-defined
1:                 // aggregates because they implement org.apache.derby.agg.Aggregator
1:                 //
0:                 if ( !SchemaDescriptor.STD_SYSTEM_SCHEMA_NAME.equals( ad.getSchemaName() ) )
1:                 {
1:                     getCompilerContext().addRequiredUsagePriv( ad );
1:                 }
/////////////////////////////////////////////////////////////////////////
1:     static AliasDescriptor resolveAggregate
1:         ( DataDictionary dd, SchemaDescriptor sd, String rawName, boolean noSchema )
1:         // first see if this is one of the builtin aggregates which
1:         // implements the Aggregator interface
1:         AliasDescriptor ad = resolveBuiltinAggregate( dd, rawName, noSchema );
1:         if ( ad != null ) { return ad; }
1:         
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Construct an AliasDescriptor for a modern builtin aggregate.
1:      */
1:     private static AliasDescriptor resolveBuiltinAggregate
1:         ( DataDictionary dd, String rawName, boolean noSchema )
1:         throws StandardException
1:     {
1:         // builtin aggregates may not be schema-qualified
1:         if ( !noSchema ) { return null; }
1: 
1:         BuiltinAggDescriptor    bad = null;
1: 
1:         for ( BuiltinAggDescriptor aggDescriptor : BUILTIN_MODERN_AGGS )
1:         {
1:             if ( aggDescriptor.aggName.equals( rawName ) )
1:             {
1:                 bad = aggDescriptor;
1:                 break;
1:             }
1:         }
1:         if ( bad == null ) { return null; }
1: 
1:         AliasInfo   aliasInfo = new AggregateAliasInfo( bad.argType, bad.returnType );
1:         
1:         return new AliasDescriptor
1:             (
1:              dd,
1:              null,
1:              rawName,
1:              dd.getSystemSchemaDescriptor().getUUID(),
1:              bad.aggClassName,
1:              AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR,
1:              AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR,
1:              false,
1:              aliasInfo,
1:              null
1:              );
1:     }
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:         FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)
commit:fbf52ee
/////////////////////////////////////////////////////////////////////////
1:         // if the schema has a null UUID, that means the schema has not
1:         // been created yet. in that case, it doesn't have any aggregates in it.
1:         if ( sd.getUUID() == null ) { return null; }
1:         
commit:b215dfd
/////////////////////////////////////////////////////////////////////////
0:             //
0:             // In theory, we could incur a StandardException while looking up the schema
0:             // descriptor. In practice that would mean a seriously corrupted database and
0:             // we would expect the schema resolution problem to have surfaced long before
0:             // we got to this code. But, just in case, if we can't find the schema, we will return
0:             // a different handle for the user-defined aggregate, in order to give the user
0:             // some information.
0:             //
commit:cb25c65
/////////////////////////////////////////////////////////////////////////
1: 				throw StandardException.newException
1:                     (
1:                      SQLState.LANG_USER_AGGREGATE_CONTAINS_AGGREGATE, 
1:                      getSQLName()
1:                     );
/////////////////////////////////////////////////////////////////////////
1: 				throw StandardException.newException
1:                     (SQLState.LANG_USER_AGGREGATE_BAD_TYPE_NULL, getSQLName());
/////////////////////////////////////////////////////////////////////////
1: 													getSQLName(),
/////////////////////////////////////////////////////////////////////////
1: 			return "aggregateName: " + getSQLName() + "\n" +
/////////////////////////////////////////////////////////////////////////
0:             try {
0:                 return ((UserAggregateDefinition) uad).getAliasDescriptor().getQualifiedName();
0:             } catch (StandardException se)
1:             {
1:                 return aggregateName;
1:             }
commit:2cf546d
/////////////////////////////////////////////////////////////////////////
1:         if ( isUserDefinedAggregate() )
/////////////////////////////////////////////////////////////////////////
1:         // For user-defined aggregates, the input operand may need to be
1:         // coerced to the expected input type of the aggregator.
1:         if ( isUserDefinedAggregate() )
1:         {
1:             ValueNode   castNode = ((UserAggregateDefinition) uad).castInputValue
0:                 ( operand, getNodeFactory(), getContextManager() );
1: 
1:             if ( castNode != null )
1:             {
0:                 operand = castNode.bindExpression( fromList, subqueryList, aggregateVector );
1:             }
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ( isUserDefinedAggregate() )
1:     
1:     /** Return true if this is a user-defined aggregate */
1:     private boolean isUserDefinedAggregate()
1:     {
0:         return ( (uad != null) && (uad instanceof UserAggregateDefinition) );
1:     }
1: 
commit:d861c23
/////////////////////////////////////////////////////////////////////////
1: 			throw StandardException.newException
1:                 (
1:                  SQLState.LANG_USER_AGGREGATE_BAD_TYPE, 
1:                  getSQLName(), 
1:                  operand.getTypeId().getSQLTypeName()
1:                  );
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Get the SQL name of the aggregate */
1:     public  String  getSQLName()
1:         throws StandardException
1:     {
0:         if ( uad instanceof UserAggregateDefinition )
1:         {
0:             return ((UserAggregateDefinition) uad).getAliasDescriptor().getQualifiedName();
1:         }
1:         else { return aggregateName; }
1:     }
commit:f3c6217
/////////////////////////////////////////////////////////////////////////
1:         // if this is a user-defined aggregate
0:         if ( (uad != null) && (uad instanceof UserAggregateDefinition) )
1:         {
1:             AliasDescriptor ad = ((UserAggregateDefinition) uad).getAliasDescriptor();
1: 
1:             // set up dependency on the user-defined aggregate and compile a check for USAGE
1:             // priv if needed
1:             getCompilerContext().createDependency( ad );
1: 
1:             if ( isPrivilegeCollectionRequired() )
1:             {
0:                 getCompilerContext().addRequiredUsagePriv( ad );
1:             }
1:         }
1: 
commit:d389f7d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
/////////////////////////////////////////////////////////////////////////
1: import java.util.List;
/////////////////////////////////////////////////////////////////////////
1:     private TableName           userAggregateName;
/////////////////////////////////////////////////////////////////////////
0: 		if ( uadClass instanceof UserAggregateDefinition )
0:             setUserDefinedAggregate( (UserAggregateDefinition) uadClass );
0: 			this.distinct = ((Boolean) distinct).booleanValue();
1: 		}
0: 		else if ( uadClass instanceof TableName )
1: 		{
0: 			this.userAggregateName = (TableName) uadClass;
/////////////////////////////////////////////////////////////////////////
1: 
1:             this.aggregateDefinitionClassName = aggregateDefinitionClass.getName();
1:     /** initialize fields for user defined aggregate */
1:     private void setUserDefinedAggregate( UserAggregateDefinition userAgg )
1:     {
1:         this.uad = userAgg;
1:         this.aggregateDefinitionClass = uad.getClass();
1:         this.aggregateDefinitionClassName = aggregateDefinitionClass.getName();
1:     }
/////////////////////////////////////////////////////////////////////////
1:         DataDictionary  dd = getDataDictionary();
1:         if ( userAggregateName != null )
1:         {
0:             userAggregateName.bind( dd );
1: 
1:             AliasDescriptor ad = resolveAggregate
1:                 (
1:                  dd,
0:                  getSchemaDescriptor( userAggregateName.getSchemaName(), true ),
1:                  userAggregateName.getTableName()
1:                  );
1: 
1:             if ( ad == null )
1:             {
1:                 throw StandardException.newException
1:                     (
1:                      SQLState.LANG_OBJECT_NOT_FOUND,
1:                      AliasDescriptor.getAliasType( AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR ),
1:                      userAggregateName.getTableName()
1:                      );
1:             }
1:             
1:             setUserDefinedAggregate( new UserAggregateDefinition( ad ) );
1:             aggregateName = ad.getJavaClassName();
1:          }
1: 
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Resolve a user-defined aggregate.
1: 	 */
0: 	public  static AliasDescriptor resolveAggregate
0:         ( DataDictionary dd, SchemaDescriptor sd, String rawName )
1:         throws StandardException
1:     {
0: 		java.util.List list = dd.getRoutineList
1:             ( sd.getUUID().toString(), rawName, AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR );
1: 
0:         if ( list.size() > 0 ) { return (AliasDescriptor) list.get( 0 ); }
1: 
1:         return null;
1:     }
1:     
commit:c8603c4
/////////////////////////////////////////////////////////////////////////
0: 		if (uadClass instanceof AggregateDefinition)
0: 			this.uad = (AggregateDefinition) uadClass;
0: 			this.aggregateDefinitionClass = uad.getClass();
/////////////////////////////////////////////////////////////////////////
1:         
0:         this.aggregateDefinitionClassName = aggregateDefinitionClass.getName();
/////////////////////////////////////////////////////////////////////////
1:         if ( uad == null )
1:         {
0:             Class theClass = aggregateDefinitionClass;
1:             // get the class
1:             if (theClass == null)
1:             {
1:                 String aggClassName = aggregateDefinitionClassName;
1:                 verifyClassExist(aggClassName);
1:                 try
1:                 {
1:                     theClass = classInspector.getClass(aggClassName);
1:                 }
1:                 catch (Throwable t)
1:                 {
1:                     throw StandardException.unexpectedUserException(t);
1:                 }
1:             }
1:             // get an instance
1:             Object instance = null;
1:             try
1:             {
0:                 instance = theClass.newInstance();
1:             }
1:             catch (Throwable t)
1:             {
1:                 throw StandardException.unexpectedUserException(t);
1:             }
1:             if (!(instance instanceof AggregateDefinition))
1:             {
1:                 throw StandardException.newException(SQLState.LANG_INVALID_USER_AGGREGATE_DEFINITION2, aggregateDefinitionClassName);
1:             }
1:             if (instance instanceof MaxMinAggregateDefinition)
1:             {
1:                 MaxMinAggregateDefinition temp = (MaxMinAggregateDefinition)instance;
1:                 if (aggregateName.equals("MAX"))
1:                     temp.setMaxOrMin(true);
1:                 else
1:                     temp.setMaxOrMin(false);
1:             }
1:             if (instance instanceof SumAvgAggregateDefinition)
1:             {
1:                 SumAvgAggregateDefinition temp1 = (SumAvgAggregateDefinition)instance;
1:                 if (aggregateName.equals("SUM"))
1:                     temp1.setSumOrAvg(true);
1:                 else
1:                     temp1.setSumOrAvg(false);
1:             }
1:             this.uad = (AggregateDefinition)instance;
1:         }
commit:e671fc7
/////////////////////////////////////////////////////////////////////////
1:         CompilerContext cc = getCompilerContext();
1:         
1:             int previousReliability = orReliability( CompilerContext.AGGREGATE_RESTRICTION );
1:             cc.setReliability( previousReliability );
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:eab88ec
/////////////////////////////////////////////////////////////////////////
1:             userAggregateName.bind();
commit:0cefeda
/////////////////////////////////////////////////////////////////////////
1:      * @param alias the name by which the aggregate was called
/////////////////////////////////////////////////////////////////////////
1:             TableName alias,
1:         this(operand, alias, distinct, aggregateName, cm);
/////////////////////////////////////////////////////////////////////////
1:         }
1: 
1:         // If this is a user-defined aggregate that hasn't been bound yet,
1:         // bind it now.
1:         if (userAggregateName != null && uad == null)
1:         {
commit:69f8afa
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.sql.compile.Visitor;
/////////////////////////////////////////////////////////////////////////
1:     @Override
1:     void acceptChildren(Visitor v) throws StandardException {
1:         super.acceptChildren(v);
1: 
1:         if (userAggregateName != null) {
1:             userAggregateName = (TableName) userAggregateName.accept(v);
1:         }
1:     }
commit:8fe3166
/////////////////////////////////////////////////////////////////////////
1:     void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)
commit:09c2697
/////////////////////////////////////////////////////////////////////////
1:      * @param aggregates        The aggregate list being built as we find AggregateNodes
1:     ValueNode bindExpression(
0:         FromList fromList, SubqueryList subqueryList, List aggregates)
/////////////////////////////////////////////////////////////////////////
1:         // Add ourselves to the list of aggregates before we do anything else.
1:         aggregates.add(this);
/////////////////////////////////////////////////////////////////////////
1:             bindOperand(fromList, subqueryList, aggregates);
/////////////////////////////////////////////////////////////////////////
1:                 operand = castNode.bindExpression( fromList, subqueryList, aggregates );
commit:f33fbaf
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					List				aggregateVector)
commit:3d1bc57
/////////////////////////////////////////////////////////////////////////
1:             return ((UserAggregateDefinition) uad).
1:                     getAliasDescriptor().getQualifiedName();
/////////////////////////////////////////////////////////////////////////
1:         return uad instanceof UserAggregateDefinition;
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
0: 		aggregateVector.add(this);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2706d1f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:e1f49ca
/////////////////////////////////////////////////////////////////////////
1:     private Class<?>                aggregateDefinitionClass;
/////////////////////////////////////////////////////////////////////////
1:             Class<?> uadClass,
/////////////////////////////////////////////////////////////////////////
1:             Class<?> theClass = aggregateDefinitionClass;
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
0: import java.util.List;
1: import org.apache.derby.catalog.AliasInfo;
1: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.types.DataTypeDescriptor;
1:  * An Aggregate Node is a node that represents a set function/aggregate.
1: class AggregateNode extends UnaryOperatorNode
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Constructed when binding a StaticMethodNode that we realize is
1:      * an aggregate.
1:      *
1:      * @param operand the value expression for the aggregate
1:      * @param uadClass the class of the user aggregate definition
1:      * @param distinct boolean indicating whether this is distinct
1:      * @param aggregateName the name of the aggregate from the user's
1:      *                  perspective, e.g. MAX
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
1:      AggregateNode(
1:             ValueNode operand,
1:             UserAggregateDefinition uadClass,
1:             boolean distinct,
1:             String aggregateName,
1:             ContextManager cm) throws StandardException {
1:         super(operand, cm);
0:         setNodeType(C_NodeTypes.AGGREGATE_NODE);
1:         this.aggregateName = aggregateName;
1:         setUserDefinedAggregate(uadClass);
1:         this.distinct = distinct;
1:     }
1:     /**
1:      * @param operand the value expression for the aggregate
1:      * @param uadClass the class name for user aggregate definition
1:      * for the aggregate
1:      * @param distinct boolean indicating whether this is distinct
1:      *                  or not.
1:      * @param aggregateName the name of the aggregate from the user's
1:      *                  perspective, e.g. MAX
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
1:     AggregateNode(
1:             ValueNode operand,
1:             TableName uadClass,
1:             boolean distinct,
1:             String aggregateName,
1:             ContextManager cm) throws StandardException {
1:         super(operand, cm);
0:         setNodeType(C_NodeTypes.AGGREGATE_NODE);
1:         this.aggregateName = aggregateName;
1:         this.userAggregateName = uadClass;
1:         this.distinct = distinct;
1:     }
1:     /**
1:      * @param operand the value expression for the aggregate
1:      * @param uadClass Class for the internal aggregate type
1:      * @param distinct boolean indicating whether this is distinct
1:      *                  or not.
1:      * @param aggregateName the name of the aggregate from the user's
1:      *                  perspective, e.g. MAX
1:      * @param cm context manager
1:      * @throws StandardException
1:      */
1:     AggregateNode(
1:             ValueNode operand,
0:             Class uadClass,
1:             boolean distinct,
1:             String aggregateName,
1:             ContextManager cm) throws StandardException {
1:         super(operand, cm);
0:         setNodeType(C_NodeTypes.AGGREGATE_NODE);
1:         this.aggregateName = aggregateName;
1:         this.aggregateDefinitionClass = uadClass;
1:         // Distinct is meaningless for min and max
1:         if (!aggregateDefinitionClass.equals(MaxMinAggregateDefinition.class)) {
1:             this.distinct = distinct;
1:         }
1: 
0:         this.aggregateDefinitionClassName = aggregateDefinitionClass.getName();
1:     }
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     ValueNode replaceAggregatesWithColumnReferences(
1:         ResultColumnList rcl, int tableNumber) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:             generatedRC =
1:                 new ResultColumn(generatedColName, this, getContextManager());
1:             generatedRef = new ColumnReference(generatedRC.getName(),
1:                                                null,
1:                                                getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     ResultColumn getGeneratedRC()
/////////////////////////////////////////////////////////////////////////
1:     ColumnReference getGeneratedRef()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:                 ( operand, getContextManager() );
/////////////////////////////////////////////////////////////////////////
0:      static AliasDescriptor resolveAggregate
/////////////////////////////////////////////////////////////////////////
1:         java.util.List<AliasDescriptor> list = dd.getRoutineList
1:         if ( list.size() > 0 ) { return list.get( 0 ); }
/////////////////////////////////////////////////////////////////////////
1:     boolean isDistinct()
/////////////////////////////////////////////////////////////////////////
1:     String  getAggregatorClassName()
/////////////////////////////////////////////////////////////////////////
1:     String  getAggregateName()
/////////////////////////////////////////////////////////////////////////
1:     ResultColumn    getNewAggregatorResultColumn(DataDictionary dd)
/////////////////////////////////////////////////////////////////////////
1:         return new ResultColumn(aggregateName, nullNode, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     ResultColumn    getNewExpressionResultColumn(DataDictionary dd)
/////////////////////////////////////////////////////////////////////////
1:         return new ResultColumn(
1:             "##aggregate expression", node, getContextManager());
/////////////////////////////////////////////////////////////////////////
1:     ValueNode   getNewNullResultExpression()
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     @Override
/////////////////////////////////////////////////////////////////////////
1:     boolean isConstant()
1:     @Override
1:     boolean constantExpression(PredicateList where)
commit:2e7e8f6
/////////////////////////////////////////////////////////////////////////
commit:7a9ce7e
/////////////////////////////////////////////////////////////////////////
1: 			// Also forbid any window function inside an aggregate unless in
1: 			// subquery, cf. SQL 2003, section 10.9, SR 7 a).
1: 			SelectNode.checkNoWindowFunctions(operand, aggregateName);
1: 
commit:c9a1206
/////////////////////////////////////////////////////////////////////////
0: 			return "aggregateName: " + aggregateName + "\n" +
1: 				"distinct: " + distinct + "\n" +
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:8d13a1f
/////////////////////////////////////////////////////////////////////////
1: 
0: 		/* The operand for this aggregate node was initialized at bind
0: 		 * time. Between then and now it's possible that certain changes
0: 		 * have been made to the query tree which affect this operand. In
0: 		 * particular, if the operand was pointing to a result column in
0: 		 * a JoinNode and then that JoinNode was flattened during pre-
0: 		 * processing, all of the references to that JoinNode--including
0: 		 * this aggregate's operand--need to be updated to reflect the
0: 		 * fact that the Join Node no longer exists. So check to see if
0: 		 * the operand is a column reference, and if so, make a call to
0: 		 * remap it to its underlying expression. If nothing has happened
0: 		 * then this will be a no-op; but if something has changed to void
0: 		 * out the result column to which the operand points, the result
0: 		 * column will be marked "redundant" and the following call should
0: 		 * remap as appropriate. DERBY-3880.
1: 		 */
0: 		if (operand instanceof ColumnReference)
1: 		{
0: 			((ColumnReference)operand).remapColumnReferencesToExpressions();
1: 		}
1: 
author:Army
-------------------------------------------------------------------------------
commit:71b5630
/////////////////////////////////////////////////////////////////////////
1: 
0: 	public boolean isConstant()
1: 	{
1: 		return false;
1: 	}
1: 	
0: 	public boolean constantExpression(PredicateList where)
1: 	{
1: 		return false;
1: 	}
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:8fe9561
/////////////////////////////////////////////////////////////////////////
0: 			generatedRef = (ColumnReference) getNodeFactory().getNode(
1: 
1:             generatedRef.setSource(generatedRC);
1:             
commit:d1fbe3c
/////////////////////////////////////////////////////////////////////////
1: 		DataTypeDescriptor compType =
1:             DataTypeDescriptor.getSQLDataTypeDescriptor(className);
1: 		ConstantNode nullNode = getNullNode(compType);
/////////////////////////////////////////////////////////////////////////
1: 		return getNullNode(getTypeServices());
commit:3233189
/////////////////////////////////////////////////////////////////////////
0:             bindOperand(fromList, subqueryList, aggregateVector);
1:             
commit:85ddc17
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // operand being null means a count(*)
/////////////////////////////////////////////////////////////////////////
1: 	 	** the input datatype.
1:         aggregatorClassName = new StringBuffer();
1:         DataTypeDescriptor resultType = uad.getAggregator(dts, aggregatorClassName);
/////////////////////////////////////////////////////////////////////////
1: 		setType(resultType);
commit:2e1b5e8
/////////////////////////////////////////////////////////////////////////
1: 		verifyClassExist(className);
/////////////////////////////////////////////////////////////////////////
0: 			verifyClassExist(aggClassName);
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.compile.AggregateNode
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:61070a6
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package	org.apache.derby.impl.sql.compile;
1: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.execute.ExecAggregator;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
1: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
1: 
0: import org.apache.derby.impl.sql.compile.CountAggregateDefinition;
0: import org.apache.derby.impl.sql.compile.MaxMinAggregateDefinition;
0: import org.apache.derby.impl.sql.compile.SumAvgAggregateDefinition;
1: 
0: import java.util.Vector;
1: 
1: /**
0:  * An Aggregate Node is a node that reprsents a set function/aggregate.
1:  * It used for all system aggregates as well as user defined aggregates.
1:  *
0:  * @author jamie
1:  */
1: 
0: public class AggregateNode extends UnaryOperatorNode
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	private boolean					distinct;
1: 
1: 	private AggregateDefinition		uad;
1: 	private StringBuffer			aggregatorClassName;
1: 	private String					aggregateDefinitionClassName;
0: 	private Class					aggregateDefinitionClass;
1: 	private ClassInspector			classInspector;
1: 	private String					aggregateName;
1: 
1: 	/*
1: 	** We wind up pushing all aggregates into a different
1: 	** resultColumnList.  When we do this (in 
1: 	** replaceAggregateWithColumnReference), we return a
1: 	** column reference and create a new result column.
1: 	** This is used to store that result column.
1: 	*/
1: 	private ResultColumn			generatedRC;
1: 	private ColumnReference			generatedRef;
1: 
1: 	/**
0: 	 * Intializer.  Used for user defined and internally defined aggregates.
0: 	 * Called when binding a StaticMethodNode that we realize is an aggregate.
1: 	 *
0: 	 * @param operand	the value expression for the aggregate
0: 	 * @param uadClass	the class name for user aggregate definition for the aggregate
0: 	 *					or the Class for the internal aggregate type.
0: 	 * @param distinct	boolean indicating whether this is distinct
1: 	 *					or not.
0: 	 * @param aggregateName	the name of the aggregate from the user's perspective,
0: 	 *					e.g. MAX
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public void init
0: 	(
0: 		Object	operand,
0: 		Object		uadClass,
0: 		Object		distinct,
0: 		Object		aggregateName
0: 	) throws StandardException
1: 	{
0: 		super.init(operand);
0: 		this.aggregateName = (String) aggregateName;
1: 
0: 		if (uadClass instanceof String)
1: 		{
0: 			this.aggregateDefinitionClassName = (String) uadClass;
0: 			this.distinct = ((Boolean) distinct).booleanValue();
1: 		}
1: 		else
1: 		{
0: 			this.aggregateDefinitionClass = (Class) uadClass;
0: 			this.aggregateDefinitionClassName =
0: 										aggregateDefinitionClass.getName();
1: 
0: 			// Distinct is meaningless for min and max
0: 			if (!aggregateDefinitionClass.equals(MaxMinAggregateDefinition.class))
1: 			{
0: 				this.distinct = ((Boolean) distinct).booleanValue();
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Replace aggregates in the expression tree with a ColumnReference to
1: 	 * that aggregate, append the aggregate to the supplied RCL (assumed to
1: 	 * be from the child ResultSetNode) and return the ColumnReference.
1: 	 * This is useful for pushing aggregates in the Having clause down to
1: 	 * the user's select at parse time.  It is also used for moving around 
1: 	 * Aggregates in the select list when creating the Group By node.  In 
1: 	 * that case it is called <B> after </B> bind time, so we need to create
1: 	 * the column differently.
1: 	 *
0: 	 * @param childRCL	The RCL to append to.
1: 	 * @param tableNumber	The tableNumber for the new ColumnReference
1: 	 *
1: 	 * @return ValueNode	The (potentially) modified tree.
1: 	 *
1: 	 * @exception StandardException			Thrown on error
1: 	 */
0: 	public ValueNode replaceAggregatesWithColumnReferences(ResultColumnList rcl, int tableNumber)
1: 		throws StandardException
1: 	{
1: 
1: 		/*
1: 		** This call is idempotent.  Do
1: 		** the right thing if we have already
1: 		** replaced ourselves.
1: 		*/
1: 		if (generatedRef == null)
1: 		{
1: 			String					generatedColName;
1: 			CompilerContext 		cc = getCompilerContext();
1: 			generatedColName ="SQLCol" + cc.getNextColumnNumber();
0: 			generatedRC = (ResultColumn) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN,
0: 											generatedColName,
0: 											this,
0: 											getContextManager());
1: 			generatedRC.markGenerated();
1: 	
1: 			/*
1: 			** Parse time.	
1: 			*/
0: 			if (getTypeServices() == null)
1: 			{
0: 				generatedRef = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												generatedColName,
0: 												null,
0: 												getContextManager());
1: 			}
1: 			else
1: 			{
0: 				generatedRef = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												generatedRC.getName(),
0: 												null,
0: 												getContextManager());
0: 				generatedRef.setType(this.getTypeServices());
1: 			}
1: 			// RESOLVE - unknown nesting level, but not correlated, so nesting levels must be 0
1: 			generatedRef.setNestingLevel(0);
1: 			generatedRef.setSourceLevel(0);
1: 			if (tableNumber != -1)
1: 			{
1: 				generatedRef.setTableNumber(tableNumber);
1: 			}
1: 
1: 			rcl.addResultColumn(generatedRC);
1: 
1: 			/* 
1: 			** Mark the ColumnReference as being generated to replace
1: 			** an aggregate
1: 			*/
1: 			generatedRef.markGeneratedToReplaceAggregate();
1: 		}
1: 		else
1: 		{
1: 			rcl.addResultColumn(generatedRC);
1: 		}
1: 
1: 		return generatedRef;
1: 	}
1: 
1: 	/**
1: 	 * Get the AggregateDefinition.
1: 	 *
1: 	 * @return The AggregateDefinition
1: 	 */
1: 	AggregateDefinition getAggregateDefinition()
1: 	{
1: 		return uad;
1: 	}
1: 
1: 	/**
1: 	 * Get the generated ResultColumn where this
1: 	 * aggregate now resides after a call to 
1: 	 * replaceAggregatesWithColumnReference().
1: 	 *
1: 	 * @return the result column
1: 	 */
0: 	public ResultColumn getGeneratedRC()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(generatedRC != null, 
1: 				"generatedRC is null.  replaceAggregateWithColumnReference() "+
1: 				"has not been called on this AggergateNode.  Make sure "+
1: 				"the node is under a ResultColumn as expected.");
1: 		}
1: 					
1: 		return generatedRC;
1: 	}
1: 
1: 	/**
1: 	 * Get the generated ColumnReference to this
1: 	 * aggregate after the parent called
1: 	 * replaceAggregatesWithColumnReference().
1: 	 *
1: 	 * @return the column reference
1: 	 */
0: 	public ColumnReference getGeneratedRef()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.ASSERT(generatedRef != null, 
1: 				"generatedRef is null.  replaceAggregateWithColumnReference() "+
1: 				"has not been called on this AggergateNode.  Make sure "+
1: 				"the node is under a ResultColumn as expected.");
1: 		}
1: 		return generatedRef;
1: 	}
1: 
1: 	/**
1: 	 * Bind this operator.  Determine the type of the subexpression,
1: 	 * and pass that into the UserAggregate.
1: 	 *
1: 	 * @param fromList			The query's FROM list
1: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate list being built as we find AggregateNodes
1: 	 *
1: 	 * @return	The new top of the expression tree.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public ValueNode bindExpression(
0: 					FromList			fromList,
0: 					SubqueryList		subqueryList,
0: 					Vector				aggregateVector)
1: 			throws StandardException
1: 	{
0: 		TypeId	outType;
0: 		TypeId	inputType = null;
0: 		Class				inputClass = null;
0: 		String				inputTypeName = null;
0: 		Class				inputInterfaceClass = null;
0: 		String				inputInterfaceName = null;
1: 		DataTypeDescriptor 	dts = null;
0: 		TypeDescriptor 		resultType = null;
1: 		ClassFactory		cf;
1: 
1: 		cf = getClassFactory();
1: 		classInspector = cf.getClassInspector();
1: 
1: 		instantiateAggDef();
1: 
0: 		/* Add ourselves to the aggregateVector before we do anything else */
0: 		aggregateVector.addElement(this);
1: 
0: 		super.bindExpression(
0: 				fromList, subqueryList,
0: 				aggregateVector);
1: 
1: 		if (operand != null)
1: 		{
1: 			/*
1: 			** Make sure that we don't have an aggregate 
1: 			** IMMEDIATELY below us.  Don't search below
1: 			** any ResultSetNodes.
1: 			*/
1: 			HasNodeVisitor visitor = new HasNodeVisitor(this.getClass(), ResultSetNode.class);
1: 			operand.accept(visitor);
1: 			if (visitor.hasNode())
1: 			{
0: 				throw StandardException.newException(SQLState.LANG_USER_AGGREGATE_CONTAINS_AGGREGATE, 
0: 						aggregateName);
1: 			}
1: 
1: 			/*
1: 			** Check the type of the operand.  Make sure that the user
1: 			** defined aggregate can handle the operand datatype.
1: 			*/
1: 			dts = operand.getTypeServices();
1: 
1: 			/* Convert count(nonNullableColumn) to count(*)	*/
1: 			if (uad instanceof CountAggregateDefinition &&
1: 				!dts.isNullable())
1: 			{
1: 				setOperator(aggregateName);
1: 				setMethodName(aggregateName);
1: 			}
1: 
1: 			/*
1: 			** If we have a distinct, then the value expression
1: 			** MUST implement Orderable because we are going
1: 			** to process it using it as part of a sort.
1: 			*/
1: 			if (distinct)
1: 			{
1: 				/*
1: 				** For now, we check to see if orderable() returns
1: 				** true for this type.  In the future we may need
1: 				** to check to see if the type implements Orderable
1: 				**
1: 				*/
1: 				if (!operand.getTypeId().orderable(cf))
1: 				{
1: 					throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION, 
1: 							dts.getTypeId().getSQLTypeName());
1: 				}
1: 
1: 			}
1: 
1: 			/*
1: 			** Don't allow an untyped null
1: 			*/
1: 			if (operand instanceof UntypedNullConstantNode)
1: 			{
0: 				throw StandardException.newException(SQLState.LANG_USER_AGGREGATE_BAD_TYPE_NULL, aggregateName);
1: 			}
1: 		}
1: 
1: 		/*
1: 		** Ask the aggregate definition whether it can handle
0: 	 	** the input datatype.  If an exception is thrown,
0: 		** barf.
1: 	 	*/
0: 		try
1: 		{
0: 			aggregatorClassName = new StringBuffer();
0: 			resultType = uad.getAggregator(dts, aggregatorClassName);
0: 		} catch (Exception e)
1: 		{
0: 			//RESOLVE: would be a good idea to add some additional text to
0: 			// this error, like during getResultDataType on aggregate x
0: 			// maybe enhance this error everywhere (seems like execution
0: 			// should also add some text, at the very least saying during
0: 			// execution.  see Compiltion/Generator/UserExpressionBuilder.java
0: 			throw StandardException.unexpectedUserException(e);
1: 		}
1: 
1: 		if (resultType == null)
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_USER_AGGREGATE_BAD_TYPE, 
0: 						aggregateName, 
1: 						operand.getTypeId().getSQLTypeName());
1: 		}
1: 
1: 		checkAggregatorClassName(aggregatorClassName.toString());
1: 
1: 		/*
0: 		** Try for a built in type matching the
0: 		** type name.  
1: 		*/
0: 		TypeId compTypeId = TypeId.getBuiltInTypeId(resultType.getTypeName());
1: 		/*
0: 		** If not built in, it is probably a java type.
0: 		** Get the sql type descriptor for that.  
1: 		*/
0: 		if (compTypeId == null)
1: 		{
0: 			compTypeId = TypeId.getSQLTypeForJavaType(resultType.getTypeName());
1: 		}
1: 
1: 		/*
0: 		** Now set the type.  Get a new descriptor
0: 		** in case the user returned the same descriptor
0: 		** as was passed in.
1: 		*/
0: 		setType(new DataTypeDescriptor(
0: 							compTypeId,
0: 							resultType.getPrecision(),
0: 							resultType.getScale(),
0: 							resultType.isNullable(),
0: 							resultType.getMaximumWidth()
0: 						)
0: 				);
1: 
1: 		return this;
1: 	}
1: 
1: 	/*
1: 	** Make sure the aggregator class is ok
1: 	*/
1: 	private void checkAggregatorClassName(String className) throws StandardException
1: 	{
0: 		className = verifyClassExist(className, false);
1: 
1: 		if (!classInspector.assignableTo(className, "org.apache.derby.iapi.sql.execute.ExecAggregator"))
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_BAD_AGGREGATOR_CLASS2, 
1: 													className, 
0: 													aggregateName,
1: 													operand.getTypeId().getSQLTypeName());
1: 		}
1: 	}
1: 
1: 		
1: 	/*
1: 	** Instantiate the aggregate definition.
1: 	*/
1: 	private void instantiateAggDef() throws StandardException
1: 	{
0: 		Class theClass = aggregateDefinitionClass;
1: 
0: 		// get the class
0: 		if (theClass == null)
1: 		{
0: 			String aggClassName = aggregateDefinitionClassName;
0: 			aggClassName = verifyClassExist(aggClassName, false);
1: 
0: 			try
1: 			{
0: 				theClass = classInspector.getClass(aggClassName);
1: 			}
0: 			catch (Throwable t)
1: 			{
0: 				throw StandardException.unexpectedUserException(t);
1: 			}
1: 		}
1: 
0: 		// get an instance
0: 		Object instance = null;
0: 		try
1: 		{
0: 			instance = theClass.newInstance();
1: 		}
0: 		catch (Throwable t)
1: 		{
0: 			throw StandardException.unexpectedUserException(t);
1: 		}
1: 
0: 		if (!(instance instanceof AggregateDefinition))
1: 		{
0: 			throw StandardException.newException(SQLState.LANG_INVALID_USER_AGGREGATE_DEFINITION2, aggregateDefinitionClassName);
1: 		}
1: 
0: 		if (instance instanceof MaxMinAggregateDefinition)
1: 		{
0: 			MaxMinAggregateDefinition temp = (MaxMinAggregateDefinition)instance;
0: 			if (aggregateName.equals("MAX"))
0: 				temp.setMaxOrMin(true);
1: 			else
0: 				temp.setMaxOrMin(false);
1: 		}
1: 
0: 		if (instance instanceof SumAvgAggregateDefinition)
1: 		{
0: 			SumAvgAggregateDefinition temp1 = (SumAvgAggregateDefinition)instance;
0: 			if (aggregateName.equals("SUM"))
0: 				temp1.setSumOrAvg(true);
1: 			else
0: 				temp1.setSumOrAvg(false);
1: 		}
1: 
0: 		this.uad = (AggregateDefinition)instance;
1: 	
1: 		setOperator(aggregateName);
1: 		setMethodName(aggregateDefinitionClassName);
1: 
1: 	}
1: 
1: 	/**
1: 	 * Indicate whether this aggregate is distinct or not.
1: 	 *
1: 	 * @return 	true/false
1: 	 */
0: 	public boolean isDistinct()
1: 	{
1: 		return distinct;
1: 	}
1: 
1: 	/**
1: 	 * Get the class that implements that aggregator for this
1: 	 * node.
1: 	 *
1: 	 * @return the class name
1: 	 */
0: 	public String	getAggregatorClassName()
1: 	{
1: 		return aggregatorClassName.toString();
1: 	}
1: 
1: 	/**
1: 	 * Get the class that implements that aggregator for this
1: 	 * node.
1: 	 *
1: 	 * @return the class name
1: 	 */
0: 	public String	getAggregateName()
1: 	{
0: 		return aggregateName;
1: 	}
1: 
1: 	/**
1: 	 * Get the result column that has a new aggregator.
1: 	 * This aggregator will be fed into the sorter.
1: 	 *
0: 	 * @param the data dictionary
1: 	 *
1: 	 * @return the result column.  WARNING: it still needs to be bound
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public ResultColumn	getNewAggregatorResultColumn(DataDictionary	dd)
1: 		throws StandardException
1: 	{
1: 		String	className = aggregatorClassName.toString();
1: 
0: 		TypeId compTypeId = TypeId.getSQLTypeForJavaType(className);
1: 
1: 		/*
1: 		** Create a null of the right type.  The proper aggregators
1: 		** are created dynamically by the SortObservers
1: 		*/
0: 		ConstantNode nullNode = getNullNode(
0: 							compTypeId,
0: 							getContextManager());		// no params
1: 
1: 		nullNode.bindExpression(
1: 						null,	// from
1: 						null,	// subquery
1: 						null);	// aggregate
1: 
1: 		/*
1: 		** Create a result column with this new node below
1: 		** it.
1: 		*/
0: 		return (ResultColumn) getNodeFactory().getNode(
0: 									C_NodeTypes.RESULT_COLUMN,
0: 									aggregateName,
0: 									nullNode, 
0: 									getContextManager());
1: 	}
1: 
1: 
1: 	/**
1: 	 * Get the aggregate expression in a new result
1: 	 * column.
1: 	 *
0: 	 * @param the data dictionary
1: 	 *
1: 	 * @return the result column.  WARNING: it still needs to be bound
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public ResultColumn	getNewExpressionResultColumn(DataDictionary	dd)
1: 		throws StandardException
1: 	{
1: 		ValueNode		node;
1: 		/*
1: 		** Create a result column with the aggrergate operand
1: 		** it.  If there is no operand, then we have a COUNT(*),
1: 		** so we'll have to create a new null node and put
1: 		** that in place.
1: 		*/
1: 		node = (operand == null) ?
1: 			this.getNewNullResultExpression() :
1: 			operand;
1: 
0: 		return (ResultColumn) getNodeFactory().getNode(
0: 								C_NodeTypes.RESULT_COLUMN,
0: 								"##aggregate expression",
0: 								node,
0: 								getContextManager());
1: 	}
1: 
1: 	/**
1: 	 * Get the null aggregate result expression
1: 	 * column.
1: 	 *
1: 	 * @return the value node
1: 	 *
1: 	 * @exception StandardException on error
1: 	 */
0: 	public ValueNode	getNewNullResultExpression()
1: 		throws StandardException
1: 	{
1: 		/*
1: 		** Create a result column with the aggrergate operand
1: 		** it.
1: 		*/
0: 		return getNullNode(this.getTypeId(),
0: 							getContextManager());
1: 	}
1: 
1: 	/**
1: 	 * Do code generation for this unary operator.  Should
1: 	 * never be called for an aggregate -- it should be converted
1: 	 * into something else by code generation time.
1: 	 *
1: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
1: 	 * @param mb	The method the code to place the code
1: 	 *
0: 	 * @return	An expression to evaluate this operator
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
1: 		throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			SanityManager.THROWASSERT("generateExpression() should never "+
1: 					"be called on an AggregateNode.  "+
1: 					"replaceAggregatesWithColumnReferences should have " +
1: 					"been called prior to generateExpression");
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * Print a string ref of this node.
1: 	 *
1: 	 * @return a string representation of this node 
1: 	 */
1: 	public String toString()
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
0: 			return "Aggregate: "+aggregateName+
0: 				"\ndistinct: "+distinct+
1: 				super.toString();
1: 		}
1: 		else
1: 		{
1: 			return "";
1: 		}
1: 	}
1: }
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:68f9f47
/////////////////////////////////////////////////////////////////////////
0: 				compTypeId,
0: 				getContextManager(),
0: 				getTypeServices().getCollationType(),
0: 				getTypeServices().getCollationDerivation()
0: 				); // no params
/////////////////////////////////////////////////////////////////////////
0: 							getContextManager(), this.getTypeServices().getCollationType(),
0: 							this.getTypeServices().getCollationDerivation());
commit:f90d449
/////////////////////////////////////////////////////////////////////////
0: 							resultType.getMaximumWidth(),
0: 							resultType.getCollationType(),
0: 							resultType.getCollationDerivation()
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:2d37fd6
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	 * @param rcl	The RCL to append to.
/////////////////////////////////////////////////////////////////////////
1: 	 * @param dd	the data dictionary
/////////////////////////////////////////////////////////////////////////
1: 	 * @param dd the data dictionary
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.compile
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package	org.apache.derby.impl.sql.compile;
0: 
0: import org.apache.derby.iapi.services.compiler.MethodBuilder;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.loader.ClassInspector;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: 
0: import org.apache.derby.iapi.sql.compile.CompilerContext;
0: import org.apache.derby.iapi.sql.compile.C_NodeTypes;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.execute.ExecAggregator;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
0: import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
0: 
0: import org.apache.derby.catalog.AliasInfo;
0: import org.apache.derby.catalog.TypeDescriptor;
0: 
0: import org.apache.derby.impl.sql.compile.CountAggregateDefinition;
0: import org.apache.derby.impl.sql.compile.MaxMinAggregateDefinition;
0: import org.apache.derby.impl.sql.compile.SumAvgAggregateDefinition;
0: 
0: import java.util.Vector;
0: 
0: /**
0:  * An Aggregate Node is a node that reprsents a set function/aggregate.
0:  * It used for all system aggregates as well as user defined aggregates.
0:  *
0:  * @author jamie
0:  */
0: 
0: public class AggregateNode extends UnaryOperatorNode
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	private boolean					distinct;
0: 
0: 	private AggregateDefinition		uad;
0: 	private StringBuffer			aggregatorClassName;
0: 	private String					aggregateDefinitionClassName;
0: 	private Class					aggregateDefinitionClass;
0: 	private ClassInspector			classInspector;
0: 	private String					aggregateName;
0: 
0: 	/*
0: 	** We wind up pushing all aggregates into a different
0: 	** resultColumnList.  When we do this (in 
0: 	** replaceAggregateWithColumnReference), we return a
0: 	** column reference and create a new result column.
0: 	** This is used to store that result column.
0: 	*/
0: 	private ResultColumn			generatedRC;
0: 	private ColumnReference			generatedRef;
0: 
0: 	/**
0: 	 * Intializer.  Used for user defined and internally defined aggregates.
0: 	 * Called when binding a StaticMethodNode that we realize is an aggregate.
0: 	 *
0: 	 * @param operand	the value expression for the aggregate
0: 	 * @param uadClass	the class name for user aggregate definition for the aggregate
0: 	 *					or the Class for the internal aggregate type.
0: 	 * @param distinct	boolean indicating whether this is distinct
0: 	 *					or not.
0: 	 * @param aggregateName	the name of the aggregate from the user's perspective,
0: 	 *					e.g. MAX
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public void init
0: 	(
0: 		Object	operand,
0: 		Object		uadClass,
0: 		Object		distinct,
0: 		Object		aggregateName
0: 	) throws StandardException
0: 	{
0: 		super.init(operand);
0: 		this.aggregateName = (String) aggregateName;
0: 
0: 		if (uadClass instanceof String)
0: 		{
0: 			this.aggregateDefinitionClassName = (String) uadClass;
0: 			this.distinct = ((Boolean) distinct).booleanValue();
0: 		}
0: 		else
0: 		{
0: 			this.aggregateDefinitionClass = (Class) uadClass;
0: 			this.aggregateDefinitionClassName =
0: 										aggregateDefinitionClass.getName();
0: 
0: 			// Distinct is meaningless for min and max
0: 			if (!aggregateDefinitionClass.equals(MaxMinAggregateDefinition.class))
0: 			{
0: 				this.distinct = ((Boolean) distinct).booleanValue();
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Replace aggregates in the expression tree with a ColumnReference to
0: 	 * that aggregate, append the aggregate to the supplied RCL (assumed to
0: 	 * be from the child ResultSetNode) and return the ColumnReference.
0: 	 * This is useful for pushing aggregates in the Having clause down to
0: 	 * the user's select at parse time.  It is also used for moving around 
0: 	 * Aggregates in the select list when creating the Group By node.  In 
0: 	 * that case it is called <B> after </B> bind time, so we need to create
0: 	 * the column differently.
0: 	 *
0: 	 * @param childRCL	The RCL to append to.
0: 	 * @param tableNumber	The tableNumber for the new ColumnReference
0: 	 *
0: 	 * @return ValueNode	The (potentially) modified tree.
0: 	 *
0: 	 * @exception StandardException			Thrown on error
0: 	 */
0: 	public ValueNode replaceAggregatesWithColumnReferences(ResultColumnList rcl, int tableNumber)
0: 		throws StandardException
0: 	{
0: 
0: 		/*
0: 		** This call is idempotent.  Do
0: 		** the right thing if we have already
0: 		** replaced ourselves.
0: 		*/
0: 		if (generatedRef == null)
0: 		{
0: 			String					generatedColName;
0: 			CompilerContext 		cc = getCompilerContext();
0: 			generatedColName ="SQLCol" + cc.getNextColumnNumber();
0: 			generatedRC = (ResultColumn) getNodeFactory().getNode(
0: 											C_NodeTypes.RESULT_COLUMN,
0: 											generatedColName,
0: 											this,
0: 											getContextManager());
0: 			generatedRC.markGenerated();
0: 	
0: 			/*
0: 			** Parse time.	
0: 			*/
0: 			if (getTypeServices() == null)
0: 			{
0: 				generatedRef = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												generatedColName,
0: 												null,
0: 												getContextManager());
0: 			}
0: 			else
0: 			{
0: 				generatedRef = (ColumnReference) getNodeFactory().getNode(
0: 												C_NodeTypes.COLUMN_REFERENCE,
0: 												generatedRC.getName(),
0: 												null,
0: 												getContextManager());
0: 				generatedRef.setType(this.getTypeServices());
0: 			}
0: 			// RESOLVE - unknown nesting level, but not correlated, so nesting levels must be 0
0: 			generatedRef.setNestingLevel(0);
0: 			generatedRef.setSourceLevel(0);
0: 			if (tableNumber != -1)
0: 			{
0: 				generatedRef.setTableNumber(tableNumber);
0: 			}
0: 
0: 			rcl.addResultColumn(generatedRC);
0: 
0: 			/* 
0: 			** Mark the ColumnReference as being generated to replace
0: 			** an aggregate
0: 			*/
0: 			generatedRef.markGeneratedToReplaceAggregate();
0: 		}
0: 		else
0: 		{
0: 			rcl.addResultColumn(generatedRC);
0: 		}
0: 
0: 		return generatedRef;
0: 	}
0: 
0: 	/**
0: 	 * Get the AggregateDefinition.
0: 	 *
0: 	 * @return The AggregateDefinition
0: 	 */
0: 	AggregateDefinition getAggregateDefinition()
0: 	{
0: 		return uad;
0: 	}
0: 
0: 	/**
0: 	 * Get the generated ResultColumn where this
0: 	 * aggregate now resides after a call to 
0: 	 * replaceAggregatesWithColumnReference().
0: 	 *
0: 	 * @return the result column
0: 	 */
0: 	public ResultColumn getGeneratedRC()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(generatedRC != null, 
0: 				"generatedRC is null.  replaceAggregateWithColumnReference() "+
0: 				"has not been called on this AggergateNode.  Make sure "+
0: 				"the node is under a ResultColumn as expected.");
0: 		}
0: 					
0: 		return generatedRC;
0: 	}
0: 
0: 	/**
0: 	 * Get the generated ColumnReference to this
0: 	 * aggregate after the parent called
0: 	 * replaceAggregatesWithColumnReference().
0: 	 *
0: 	 * @return the column reference
0: 	 */
0: 	public ColumnReference getGeneratedRef()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.ASSERT(generatedRef != null, 
0: 				"generatedRef is null.  replaceAggregateWithColumnReference() "+
0: 				"has not been called on this AggergateNode.  Make sure "+
0: 				"the node is under a ResultColumn as expected.");
0: 		}
0: 		return generatedRef;
0: 	}
0: 
0: 	/**
0: 	 * Bind this operator.  Determine the type of the subexpression,
0: 	 * and pass that into the UserAggregate.
0: 	 *
0: 	 * @param fromList			The query's FROM list
0: 	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
0: 	 * @param aggregateVector	The aggregate list being built as we find AggregateNodes
0: 	 *
0: 	 * @return	The new top of the expression tree.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public ValueNode bindExpression(
0: 					FromList			fromList,
0: 					SubqueryList		subqueryList,
0: 					Vector				aggregateVector)
0: 			throws StandardException
0: 	{
0: 		TypeId	outType;
0: 		TypeId	inputType = null;
0: 		Class				inputClass = null;
0: 		String				inputTypeName = null;
0: 		Class				inputInterfaceClass = null;
0: 		String				inputInterfaceName = null;
0: 		DataTypeDescriptor 	dts = null;
0: 		TypeDescriptor 		resultType = null;
0: 		ClassFactory		cf;
0: 
0: 		cf = getClassFactory();
0: 		classInspector = cf.getClassInspector();
0: 
0: 		instantiateAggDef();
0: 
0: 		/* Add ourselves to the aggregateVector before we do anything else */
0: 		aggregateVector.addElement(this);
0: 
0: 		super.bindExpression(
0: 				fromList, subqueryList,
0: 				aggregateVector);
0: 
0: 		if (operand != null)
0: 		{
0: 			/*
0: 			** Make sure that we don't have an aggregate 
0: 			** IMMEDIATELY below us.  Don't search below
0: 			** any ResultSetNodes.
0: 			*/
0: 			HasNodeVisitor visitor = new HasNodeVisitor(this.getClass(), ResultSetNode.class);
0: 			operand.accept(visitor);
0: 			if (visitor.hasNode())
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_USER_AGGREGATE_CONTAINS_AGGREGATE, 
0: 						aggregateName);
0: 			}
0: 
0: 			/*
0: 			** Check the type of the operand.  Make sure that the user
0: 			** defined aggregate can handle the operand datatype.
0: 			*/
0: 			dts = operand.getTypeServices();
0: 
0: 			/* Convert count(nonNullableColumn) to count(*)	*/
0: 			if (uad instanceof CountAggregateDefinition &&
0: 				!dts.isNullable())
0: 			{
0: 				setOperator(aggregateName);
0: 				setMethodName(aggregateName);
0: 			}
0: 
0: 			/*
0: 			** If we have a distinct, then the value expression
0: 			** MUST implement Orderable because we are going
0: 			** to process it using it as part of a sort.
0: 			*/
0: 			if (distinct)
0: 			{
0: 				/*
0: 				** For now, we check to see if orderable() returns
0: 				** true for this type.  In the future we may need
0: 				** to check to see if the type implements Orderable
0: 				**
0: 				*/
0: 				if (!operand.getTypeId().orderable(cf))
0: 				{
0: 					throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION, 
0: 							dts.getTypeId().getSQLTypeName());
0: 				}
0: 
0: 			}
0: 
0: 			/*
0: 			** Don't allow an untyped null
0: 			*/
0: 			if (operand instanceof UntypedNullConstantNode)
0: 			{
0: 				throw StandardException.newException(SQLState.LANG_USER_AGGREGATE_BAD_TYPE_NULL, aggregateName);
0: 			}
0: 		}
0: 
0: 		/*
0: 		** Ask the aggregate definition whether it can handle
0: 	 	** the input datatype.  If an exception is thrown,
0: 		** barf.
0: 	 	*/
0: 		try
0: 		{
0: 			aggregatorClassName = new StringBuffer();
0: 			resultType = uad.getAggregator(dts, aggregatorClassName);
0: 		} catch (Exception e)
0: 		{
0: 			//RESOLVE: would be a good idea to add some additional text to
0: 			// this error, like during getResultDataType on aggregate x
0: 			// maybe enhance this error everywhere (seems like execution
0: 			// should also add some text, at the very least saying during
0: 			// execution.  see Compiltion/Generator/UserExpressionBuilder.java
0: 			throw StandardException.unexpectedUserException(e);
0: 		}
0: 
0: 		if (resultType == null)
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_USER_AGGREGATE_BAD_TYPE, 
0: 						aggregateName, 
0: 						operand.getTypeId().getSQLTypeName());
0: 		}
0: 
0: 		checkAggregatorClassName(aggregatorClassName.toString());
0: 
0: 		/*
0: 		** Try for a built in type matching the
0: 		** type name.  
0: 		*/
0: 		TypeId compTypeId = TypeId.getBuiltInTypeId(resultType.getTypeName());
0: 		/*
0: 		** If not built in, it is probably a java type.
0: 		** Get the sql type descriptor for that.  
0: 		*/
0: 		if (compTypeId == null)
0: 		{
0: 			compTypeId = TypeId.getSQLTypeForJavaType(resultType.getTypeName());
0: 		}
0: 
0: 		/*
0: 		** Now set the type.  Get a new descriptor
0: 		** in case the user returned the same descriptor
0: 		** as was passed in.
0: 		*/
0: 		setType(new DataTypeDescriptor(
0: 							compTypeId,
0: 							resultType.getPrecision(),
0: 							resultType.getScale(),
0: 							resultType.isNullable(),
0: 							resultType.getMaximumWidth()
0: 						)
0: 				);
0: 
0: 		return this;
0: 	}
0: 
0: 	/*
0: 	** Make sure the aggregator class is ok
0: 	*/
0: 	private void checkAggregatorClassName(String className) throws StandardException
0: 	{
0: 		className = verifyClassExist(className, false);
0: 
0: 		if (!classInspector.assignableTo(className, "org.apache.derby.iapi.sql.execute.ExecAggregator"))
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_BAD_AGGREGATOR_CLASS2, 
0: 													className, 
0: 													aggregateName,
0: 													operand.getTypeId().getSQLTypeName());
0: 		}
0: 	}
0: 
0: 		
0: 	/*
0: 	** Instantiate the aggregate definition.
0: 	*/
0: 	private void instantiateAggDef() throws StandardException
0: 	{
0: 		Class theClass = aggregateDefinitionClass;
0: 
0: 		// get the class
0: 		if (theClass == null)
0: 		{
0: 			String aggClassName = aggregateDefinitionClassName;
0: 			aggClassName = verifyClassExist(aggClassName, false);
0: 
0: 			try
0: 			{
0: 				theClass = classInspector.getClass(aggClassName);
0: 			}
0: 			catch (Throwable t)
0: 			{
0: 				throw StandardException.unexpectedUserException(t);
0: 			}
0: 		}
0: 
0: 		// get an instance
0: 		Object instance = null;
0: 		try
0: 		{
0: 			instance = theClass.newInstance();
0: 		}
0: 		catch (Throwable t)
0: 		{
0: 			throw StandardException.unexpectedUserException(t);
0: 		}
0: 
0: 		if (!(instance instanceof AggregateDefinition))
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_INVALID_USER_AGGREGATE_DEFINITION2, aggregateDefinitionClassName);
0: 		}
0: 
0: 		if (instance instanceof MaxMinAggregateDefinition)
0: 		{
0: 			MaxMinAggregateDefinition temp = (MaxMinAggregateDefinition)instance;
0: 			if (aggregateName.equals("MAX"))
0: 				temp.setMaxOrMin(true);
0: 			else
0: 				temp.setMaxOrMin(false);
0: 		}
0: 
0: 		if (instance instanceof SumAvgAggregateDefinition)
0: 		{
0: 			SumAvgAggregateDefinition temp1 = (SumAvgAggregateDefinition)instance;
0: 			if (aggregateName.equals("SUM"))
0: 				temp1.setSumOrAvg(true);
0: 			else
0: 				temp1.setSumOrAvg(false);
0: 		}
0: 
0: 		this.uad = (AggregateDefinition)instance;
0: 	
0: 		setOperator(aggregateName);
0: 		setMethodName(aggregateDefinitionClassName);
0: 
0: 	}
0: 
0: 	/**
0: 	 * Indicate whether this aggregate is distinct or not.
0: 	 *
0: 	 * @return 	true/false
0: 	 */
0: 	public boolean isDistinct()
0: 	{
0: 		return distinct;
0: 	}
0: 
0: 	/**
0: 	 * Get the class that implements that aggregator for this
0: 	 * node.
0: 	 *
0: 	 * @return the class name
0: 	 */
0: 	public String	getAggregatorClassName()
0: 	{
0: 		return aggregatorClassName.toString();
0: 	}
0: 
0: 	/**
0: 	 * Get the class that implements that aggregator for this
0: 	 * node.
0: 	 *
0: 	 * @return the class name
0: 	 */
0: 	public String	getAggregateName()
0: 	{
0: 		return aggregateName;
0: 	}
0: 
0: 	/**
0: 	 * Get the result column that has a new aggregator.
0: 	 * This aggregator will be fed into the sorter.
0: 	 *
0: 	 * @param the data dictionary
0: 	 *
0: 	 * @return the result column.  WARNING: it still needs to be bound
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public ResultColumn	getNewAggregatorResultColumn(DataDictionary	dd)
0: 		throws StandardException
0: 	{
0: 		String	className = aggregatorClassName.toString();
0: 
0: 		TypeId compTypeId = TypeId.getSQLTypeForJavaType(className);
0: 
0: 		/*
0: 		** Create a null of the right type.  The proper aggregators
0: 		** are created dynamically by the SortObservers
0: 		*/
0: 		ConstantNode nullNode = getNullNode(
0: 							compTypeId,
0: 							getContextManager());		// no params
0: 
0: 		nullNode.bindExpression(
0: 						null,	// from
0: 						null,	// subquery
0: 						null);	// aggregate
0: 
0: 		/*
0: 		** Create a result column with this new node below
0: 		** it.
0: 		*/
0: 		return (ResultColumn) getNodeFactory().getNode(
0: 									C_NodeTypes.RESULT_COLUMN,
0: 									aggregateName,
0: 									nullNode, 
0: 									getContextManager());
0: 	}
0: 
0: 
0: 	/**
0: 	 * Get the aggregate expression in a new result
0: 	 * column.
0: 	 *
0: 	 * @param the data dictionary
0: 	 *
0: 	 * @return the result column.  WARNING: it still needs to be bound
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public ResultColumn	getNewExpressionResultColumn(DataDictionary	dd)
0: 		throws StandardException
0: 	{
0: 		ValueNode		node;
0: 		/*
0: 		** Create a result column with the aggrergate operand
0: 		** it.  If there is no operand, then we have a COUNT(*),
0: 		** so we'll have to create a new null node and put
0: 		** that in place.
0: 		*/
0: 		node = (operand == null) ?
0: 			this.getNewNullResultExpression() :
0: 			operand;
0: 
0: 		return (ResultColumn) getNodeFactory().getNode(
0: 								C_NodeTypes.RESULT_COLUMN,
0: 								"##aggregate expression",
0: 								node,
0: 								getContextManager());
0: 	}
0: 
0: 	/**
0: 	 * Get the null aggregate result expression
0: 	 * column.
0: 	 *
0: 	 * @return the value node
0: 	 *
0: 	 * @exception StandardException on error
0: 	 */
0: 	public ValueNode	getNewNullResultExpression()
0: 		throws StandardException
0: 	{
0: 		/*
0: 		** Create a result column with the aggrergate operand
0: 		** it.
0: 		*/
0: 		return getNullNode(this.getTypeId(),
0: 							getContextManager());
0: 	}
0: 
0: 	/**
0: 	 * Do code generation for this unary operator.  Should
0: 	 * never be called for an aggregate -- it should be converted
0: 	 * into something else by code generation time.
0: 	 *
0: 	 * @param acb	The ExpressionClassBuilder for the class we're generating
0: 	 * @param mb	The method the code to place the code
0: 	 *
0: 	 * @return	An expression to evaluate this operator
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void generateExpression(ExpressionClassBuilder acb,
0: 											MethodBuilder mb)
0: 		throws StandardException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			SanityManager.THROWASSERT("generateExpression() should never "+
0: 					"be called on an AggregateNode.  "+
0: 					"replaceAggregatesWithColumnReferences should have " +
0: 					"been called prior to generateExpression");
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Print a string ref of this node.
0: 	 *
0: 	 * @return a string representation of this node 
0: 	 */
0: 	public String toString()
0: 	{
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			return "Aggregate: "+aggregateName+
0: 				"\ndistinct: "+distinct+
0: 				super.toString();
0: 		}
0: 		else
0: 		{
0: 			return "";
0: 		}
0: 	}
0: }
============================================================================