1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.BTreePostCommit
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
19:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextManager;
1:eac0369: import org.apache.derby.iapi.services.daemon.Serviceable;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactory;
1:eac0369: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:63bc195: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:63bc195: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: The BTreePostCommit class implements the Serviceable protocol.  
1:eac0369: 
1:eac0369: In it's role as a Serviceable object, it stores the state necessary to 
1:eac0369: find a page in a btree that may have committed delete's to reclaim.
1:eac0369: 
1:eac0369: In it's role as a PostCommitProcessor it looks up the page described, and
1:eac0369: reclaims space in the btree.  It first trys to clean up any deleted commits
1:eac0369: on the page.  It then will shrink the tree if it is going to delete all
1:eac0369: rows from the page (RESOLVE - not done yet).
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: class BTreePostCommit implements Serviceable
3:eac0369: {
1:eac0369:     private     AccessFactory access_factory  = null;
1:eac0369:     private     long          page_number = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 
1:eac0369:     protected   BTree         btree           = null;
1:eac0369: 
1:eac0369:     /* Constructors for This class: */
1:eac0369:     BTreePostCommit(
1:eac0369:     AccessFactory   access_factory,
1:eac0369:     BTree           btree,
1:eac0369:     long            input_page_number)
1:eac0369:     {
1:eac0369:         this.access_factory = access_factory; 
1:eac0369:         this.btree          = btree; 
1:eac0369:         this.page_number    = input_page_number; 
4:eac0369:     }
1:eac0369: 
1:eac0369:     /* Private/Protected methods of This class: */
1:eac0369: 
1:eac0369:     /* Public Methods of This class: */
1:eac0369: 
1:eac0369:     /* Public Methods of Serviceable class: */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The urgency of this post commit work.
1:eac0369:      * <p>
1:eac0369:      * This determines where this Serviceable is put in the post commit 
1:eac0369:      * queue.  Post commit work in the btree can be safely delayed until there
1:eac0369:      * is not user work to do.
1:eac0369:      *
1:eac0369: 	 * @return false, this work should not be serviced ASAP
1:eac0369:      **/
1:eac0369:     public boolean serviceASAP()
1:eac0369:     {
1:eac0369:         return(true);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	// @return true, if this work needs to be done on a user thread immediately
1:eac0369: 	public boolean serviceImmediately()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}	
1:eac0369: 
1:eac0369:     private final void doShrink(
1:eac0369:     OpenBTree               open_btree, 
1:eac0369:     DataValueDescriptor[]	shrink_row)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         ControlRow root = null;
1:eac0369: 
1:eac0369:         /*
1:eac0369:         System.out.println(
1:eac0369:             "Calling shrink on tree with levels = " + 
1:eac0369:             open_btree.getHeight() + "\n");
1:eac0369:         */
1:eac0369: 
1:eac0369:         // Get the root page back, and perform a split following the
1:eac0369:         // to-be-inserted key.  The split releases the root page latch.
1:4a2b0d9:         root = ControlRow.get(open_btree, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369:         root.shrinkFor(open_btree, shrink_row);
1:eac0369: 
1:eac0369:         root = null;
1:eac0369: 
1:eac0369:         // on return from shrinkFor the root pointer is invalid.  The
1:eac0369:         // latch has been released, the root page may have changed from
1:eac0369:         // a branch to a leaf.
1:eac0369: 
2:63bc195:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:63bc195:      * Open index for either table level or row level update.
1:63bc195:      * <p>
1:63bc195:      * @param lock_level For table level use TransactionManager.MODE_TABLE,
1:63bc195:      *                   for row   level use TransactionManager.MODE_RECORD
1:63bc195:      * @param lock_mode  For table level use LockingPolicy.MODE_CONTAINER,
1:63bc195:      *                   for row   level use LockingPolicy.MODE_RECORD
1:63bc195:      *
1:63bc195:      * @exception  StandardException  Standard exception policy.
1:63bc195:      **/
1:63bc195:     private final OpenBTree openIndex(
1:63bc195:     TransactionManager internal_xact,
1:63bc195:     int                lock_level,
1:63bc195:     int                lock_mode)
1:63bc195:         throws StandardException
1:63bc195:     {
1:63bc195:         OpenBTree open_btree = new OpenBTree();
1:63bc195: 
1:63bc195:         ConglomerateController base_cc = 
1:63bc195:             btree.lockTable(
1:63bc195:                 internal_xact, 
1:63bc195:                 (ContainerHandle.MODE_FORUPDATE |
1:63bc195:                  ContainerHandle.MODE_LOCK_NOWAIT), 
1:63bc195:                 lock_level,
1:63bc195:                 TransactionController.ISOLATION_REPEATABLE_READ);
1:63bc195: 
1:63bc195:         open_btree.init(
1:63bc195:             (TransactionManager) null, 
1:63bc195:             internal_xact, 
1:63bc195:             (ContainerHandle) null,           // open the container 
1:63bc195:             internal_xact.getRawStoreXact(),
1:63bc195:             false,
1:63bc195:             (ContainerHandle.MODE_FORUPDATE | ContainerHandle.MODE_LOCK_NOWAIT),
1:63bc195:             lock_level,
1:63bc195:             btree.getBtreeLockingPolicy(
1:63bc195:                 internal_xact.getRawStoreXact(),
1:63bc195:                 lock_level,
1:63bc195:                 lock_mode,
1:63bc195:                 TransactionController.ISOLATION_REPEATABLE_READ, 
1:63bc195:                 base_cc,
1:63bc195:                 open_btree),
1:63bc195:             btree, 
1:63bc195:             (LogicalUndo) null,              // No logical undo necessry.
1:63bc195:             (DynamicCompiledOpenConglomInfo) null);
1:63bc195: 
1:63bc195:         return(open_btree);
1:63bc195:     }
1:63bc195: 
1:63bc195:     /**
1:eac0369:      * perform the work described in the postcommit work.
1:eac0369:      * <p>
1:eac0369:      * In this implementation the only work that can be executed by this
1:eac0369:      * post commit processor is this class itself.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return Returns Serviceable.DONE when work has completed, or
1:eac0369:      *         returns Serviceable.REQUEUE if work needs to be requeued.
1:eac0369:      *
1:eac0369:      * @param contextMgr the context manager started by the
1:eac0369: 	 *         post commit daemon
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public int performWork(ContextManager contextMgr)
1:eac0369:         throws StandardException
1:eac0369:     {
1:63bc195: 
1:eac0369:         // requeue if work was not completed in this try because of locks
1:eac0369:         boolean             requeue_work = false;
1:eac0369: 
1:eac0369:         TransactionManager tc             = (TransactionManager)
1:eac0369:             this.access_factory.getAndNameTransaction(
1:eac0369:                 contextMgr, AccessFactoryGlobals.SYS_TRANS_NAME);
1:eac0369: 
1:45b5ae1:         TransactionManager  internal_xact  = tc.getInternalTransaction();
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG_ON("verbose_btree_post_commit"))
1:eac0369:                 System.out.println("starting internal xact\n");
1:eac0369:         }
1:eac0369: 
1:45b5ae1:         OpenBTree           open_btree = null;
1:eac0369: 
2:eac0369:         try
1:eac0369:         {
1:eac0369:             // Get lock on base table.
1:eac0369:             
1:63bc195:             // First attempt to get a table lock on the btree.  This lock is
1:63bc195:             // requested NOWAIT to not impede normal operation on the table.
1:63bc195:             // If the lock were to wait then the current lock manager livelock 
1:63bc195:             // algorithm would block all subsequent lock requests on this 
1:63bc195:             // btree even if they are compatible with the current holder of 
1:63bc195:             // the lock.
2:eac0369:             //
1:63bc195:             // If this lock is granted then:
1:63bc195:             // 1) deleted rows on the page can automatically be purged as
1:63bc195:             //    they must be committed, otherwise lock would not have been
1:63bc195:             //    granted.
1:63bc195:             // 2) if all rows from page are reclaimed then a structure shrink
1:63bc195:             //    which requires table level lock can be executed.
1:63bc195:             //
1:63bc195:             open_btree = 
1:63bc195:                 openIndex(
2:eac0369:                     internal_xact, 
1:63bc195:                     TransactionController.MODE_TABLE, 
1:63bc195:                     LockingPolicy.MODE_CONTAINER);
1:eac0369: 
1:eac0369:             DataValueDescriptor[] shrink_key = 
1:eac0369:                 purgeCommittedDeletes(open_btree, this.page_number);
1:eac0369: 
1:eac0369:             if (shrink_key != null)
1:eac0369:                 doShrink(open_btree, shrink_key);
1:eac0369:         }
1:eac0369:         catch (StandardException se)
1:eac0369:         {
1:63bc195:             // 2 kinds of errors here expected here.  Either container not 
1:63bc195:             // found or could not obtain lock (LOCK_TIMEOUT or DEADLOCK).
1:63bc195:             //
1:eac0369:             // It is possible by the time this post commit work gets scheduled 
1:eac0369:             // that the container has been dropped and that the open container 
1:eac0369:             // call will return null - in this case just return assuming no 
1:eac0369:             // work to be done.
1:eac0369: 
1:c9ef166:             if (se.isLockTimeoutOrDeadlock())
1:eac0369: 			{
1:63bc195:                 // Could not get exclusive table lock, so try row level
1:63bc195:                 // reclaim of just the rows on this page.  No merge is 
1:63bc195:                 // attempted.
1:eac0369: 
1:63bc195:                 try
1:63bc195:                 {
1:63bc195:                     open_btree = 
1:63bc195:                         openIndex(
1:63bc195:                             internal_xact, 
1:63bc195:                             TransactionController.MODE_RECORD, 
1:63bc195:                             LockingPolicy.MODE_RECORD);
1:63bc195: 
1:63bc195:                     purgeRowLevelCommittedDeletes(open_btree);
1:63bc195: 
1:63bc195:                 }
1:63bc195:                 catch (StandardException se2)
1:63bc195:                 {
1:c9ef166:                     if (se2.isLockTimeoutOrDeadlock())
1:63bc195:                     {
1:63bc195:                         // Could not get intended exclusive table lock, so 
1:63bc195:                         // requeue and hope other user gives up table level
1:63bc195:                         // lock soon.  This should not be normal case.
1:63bc195:                         requeue_work = true;
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
2:eac0369:         finally
1:eac0369:         {
1:45b5ae1:             if (open_btree != null)
1:45b5ae1:                 open_btree.close();
1:45b5ae1: 
1:45b5ae1:             // counting on this commit to release latches associated with
1:45b5ae1:             // row level purge, that have been left to prevent others from
1:45b5ae1:             // getting to purged pages before the commit.  If latch is released
1:45b5ae1:             // early, other transactions could insert on the page which could
1:45b5ae1:             // prevent undo of the purges in case of a crash before the commit
1:45b5ae1:             // gets to the disk.
1:eac0369:             internal_xact.commit();
1:eac0369:             internal_xact.destroy();
1:63bc195:         }
1:eac0369: 
1:eac0369:         return(requeue_work ? Serviceable.REQUEUE : Serviceable.DONE);
1:63bc195:     }
1:eac0369: 
1:eac0369:     private final DataValueDescriptor[] getShrinkKey(
1:eac0369:     OpenBTree   open_btree, 
1:eac0369:     ControlRow  control_row,
1:eac0369:     int         slot_no)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         DataValueDescriptor[] shrink_key = 
1:722a889:             open_btree.getConglomerate().createTemplate(
1:63bc195:                     open_btree.getRawTran());
1:eac0369: 
1:eac0369:         control_row.page.fetchFromSlot(
1:eac0369:             (RecordHandle) null,
1:eac0369:             slot_no, shrink_key, 
1:eac0369:             (FetchDescriptor) null,
1:eac0369: 			true);
1:eac0369: 
1:eac0369:         return(shrink_key);
1:63bc195:     }
1:63bc195: 
1:63bc195:     /**
1:eac0369:      * Reclaim space taken up by committed deleted rows.
1:63bc195:      * <p>
1:eac0369:      * This routine assumes it has been called by an internal transaction which
1:eac0369:      * has performed no work so far, and that it has an exclusive table lock.  
1:eac0369:      * These assumptions mean that any deleted rows encountered must be from
1:eac0369:      * committed transactions (otherwise we could not have gotten the exclusive
1:eac0369:      * table lock).
1:eac0369:      * <p>
1:45b5ae1:      * This routine handles purging committed deletes while holding a table
1:45b5ae1:      * level exclusive lock.  See purgeRowLevelCommittedDeletes() for row level
1:45b5ae1:      * purging.
1:eac0369:      *
1:eac0369:      * @param open_btree The btree already opened.
1:eac0369:      * @param pageno The page number of the page to look for committed deletes.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     private final DataValueDescriptor[] purgeCommittedDeletes(
1:eac0369:     OpenBTree           open_btree,
1:eac0369:     long                pageno)
1:eac0369:         throws StandardException
1:63bc195:     {
1:eac0369:         ControlRow              control_row = null;
1:eac0369:         DataValueDescriptor[]	shrink_key  = null; 
1:63bc195: 
1:63bc195:         try
1:eac0369:         {
1:eac0369:             // The following can fail either if it can't get the latch or
1:eac0369:             // somehow the page requested no longer exists.  In either case
1:eac0369:             // the post commit work will just skip it.
1:4a2b0d9:             control_row = ControlRow.getNoWait(open_btree, pageno);
1:63bc195: 
1:eac0369:             if (control_row != null)
1:eac0369:             {
1:eac0369:                 Page page   = control_row.page;
1:63bc195: 
1:63bc195:                 // The number records that can be reclaimed is:
1:63bc195:                 // total recs - control row - recs_not_deleted
1:63bc195:                 int num_possible_commit_delete = 
1:eac0369:                     page.recordCount() - 1 - page.nonDeletedRecordCount();
1:63bc195: 
1:86e051f:                 if (num_possible_commit_delete > 0)
1:eac0369:                 {
1:63bc195:                     // loop backward so that purges which affect the slot table 
1:63bc195:                     // don't affect the loop (ie. they only move records we 
1:63bc195:                     // have already looked at).
1:63bc195:                     for (int slot_no = page.recordCount() - 1; 
1:63bc195:                          slot_no > 0; 
1:63bc195:                          slot_no--) 
1:eac0369:                     {
1:63bc195:                         if (page.isDeletedAtSlot(slot_no))
1:63bc195:                         {
1:63bc195: 
1:eac0369:                             if (page.recordCount() == 2)
1:eac0369:                             {
1:eac0369:                                 // About to purge last row from page so 
1:eac0369:                                 // remember the key so we can shrink the 
1:eac0369:                                 // tree.
1:eac0369:                                 shrink_key = this.getShrinkKey(
1:eac0369:                                     open_btree, control_row, slot_no);
1:eac0369:                             }
1:eac0369: 
1:63bc195:                             page.purgeAtSlot(slot_no, 1, true);
1:86e051f:                             // Tell scans positioned on this page to reposition
1:86e051f:                             // because the row they are positioned on may have
1:86e051f:                             // disappeared.
1:86e051f:                             page.setRepositionNeeded();
1:63bc195: 
1:eac0369:                             if (SanityManager.DEBUG)
1:eac0369:                             {
1:eac0369:                                 if (SanityManager.DEBUG_ON(
1:eac0369:                                         "verbose_btree_post_commit"))
1:eac0369:                                 {
1:eac0369:                                     System.out.println(
1:eac0369:                                         "Purging row[" + slot_no + "]" + 
1:eac0369:                                         "on page:" + pageno + ".\n");
1:63bc195:                                 }
1:eac0369:                             }
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                 }
1:63bc195: 
1:eac0369:                 if (page.recordCount() == 1)
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG)
1:eac0369:                     {
1:eac0369:                         if (SanityManager.DEBUG_ON("verbose_btree_post_commit"))
1:eac0369:                         {
1:eac0369:                             System.out.println("Chance to shrink.\n");
1:eac0369:                         }
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369: 				if (SanityManager.DEBUG)
1:eac0369:                 {
1:eac0369:                     if (SanityManager.DEBUG_ON("verbose_btree_post_commit"))
1:eac0369:                     {
1:eac0369:                         System.out.println(
1:eac0369:                             "Get No Wait returned null. page num = " + pageno +
1:eac0369:                             "\n");
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:63bc195:         finally
1:eac0369:         {
1:eac0369:             if (control_row != null)
1:eac0369:                 control_row.release();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(shrink_key);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:63bc195:      * Attempt to reclaim committed deleted rows from the page with row locking.
1:eac0369:      * <p>
1:63bc195:      * Get exclusive latch on page, and then loop backward through
1:63bc195:      * page searching for deleted rows which are committed.  
1:63bc195:      * This routine is called only from post commit processing so it will never
1:63bc195:      * see rows deleted by the current transaction.
1:63bc195:      * For each deleted row on the page
1:63bc195:      * it attempts to get an exclusive lock on the deleted row, NOWAIT.
1:63bc195:      * If it succeeds, and since this transaction did not delete the row then 
1:63bc195:      * the row must have been deleted by a transaction which has committed, so
1:63bc195:      * it is safe to purge the row.  It then purges the row from the page.
1:45b5ae1:      * <p>
1:45b5ae1:      * The latch on the leaf page containing the purged rows must be kept until
1:45b5ae1:      * after the transaction has been committed or aborted in order to insure
1:45b5ae1:      * proper undo of the purges can take place.  Otherwise another transaction
1:45b5ae1:      * could use the space freed by the purge and then prevent the purge from
1:45b5ae1:      * being able to undo.
1:63bc195:      *
1:63bc195:      * @param open_btree The already open btree, which has been locked with IX
1:63bc195:      *                   table lock, to use to get latch on page.
1:63bc195:      *
1:63bc195: 	 * @exception  StandardException  Standard exception policy.
1:63bc195:      **/
1:63bc195:     private final void purgeRowLevelCommittedDeletes(
1:63bc195:     OpenBTree           open_btree)
1:63bc195:         throws StandardException
1:63bc195:     {
1:dd2ce24:         LeafControlRow leaf = null;
1:63bc195: 
1:45b5ae1:         // The following can fail, returning null, either if it can't get
1:45b5ae1:         // the latch or somehow the page requested no longer exists.  In 
1:45b5ae1:         // either case the post commit work will just skip it.
1:45b5ae1:         leaf = (LeafControlRow) 
1:45b5ae1:             ControlRow.getNoWait(open_btree, page_number);
1:45b5ae1:         if (leaf == null)
1:45b5ae1:             return;
1:45b5ae1: 
1:45b5ae1:         BTreeLockingPolicy  btree_locking_policy = 
1:45b5ae1:             open_btree.getLockingPolicy();
1:45b5ae1: 
1:45b5ae1:         // The number records that can be reclaimed is:
1:45b5ae1:         // total recs - control row - recs_not_deleted
1:45b5ae1:         int num_possible_commit_delete = 
1:45b5ae1:             leaf.page.recordCount() - 1 - leaf.page.nonDeletedRecordCount();
1:45b5ae1: 
1:45b5ae1:         if (num_possible_commit_delete > 0)
1:63bc195:         {
1:45b5ae1:             DataValueDescriptor[] scratch_template = 
1:45b5ae1:                 open_btree.getRuntimeMem().get_template(
1:45b5ae1:                     open_btree.getRawTran());
1:63bc195: 
1:45b5ae1:             Page page   = leaf.page;
1:63bc195: 
1:63bc195: 
1:45b5ae1:             // RowLocation column is in last column of template.
1:45b5ae1:             FetchDescriptor lock_fetch_desc = 
1:45b5ae1:                 RowUtil.getFetchDescriptorConstant(
1:45b5ae1:                     scratch_template.length - 1);
1:45b5ae1: 
1:45b5ae1:             // loop backward so that purges which affect the slot table 
1:45b5ae1:             // don't affect the loop (ie. they only move records we 
1:45b5ae1:             // have already looked at).
1:45b5ae1:             for (int slot_no = page.recordCount() - 1; 
1:45b5ae1:                  slot_no > 0; 
1:45b5ae1:                  slot_no--) 
1:63bc195:             {
1:45b5ae1:                 if (page.isDeletedAtSlot(slot_no))
1:63bc195:                 {
1:45b5ae1:                     // try to get an exclusive lock on the row, if we can 
1:45b5ae1:                     // then the row is a committed deleted row and it is 
1:45b5ae1:                     // safe to purge it.
1:45b5ae1:                     if (btree_locking_policy.lockScanCommittedDeletedRow(
1:45b5ae1:                             open_btree, leaf, scratch_template, 
1:45b5ae1:                             lock_fetch_desc, slot_no))
1:63bc195:                     {
1:45b5ae1:                         // the row is a committed deleted row, purge it.
1:45b5ae1:                         page.purgeAtSlot(slot_no, 1, true);
1:45b5ae1:                         // Tell scans positioned on this page to reposition
1:45b5ae1:                         // because the row they are positioned on may have
1:45b5ae1:                         // disappeared.
1:45b5ae1:                         page.setRepositionNeeded();
1:63bc195:                     }
1:63bc195:                 }
1:63bc195:             }
1:45b5ae1: 
1:63bc195:         }
1:45b5ae1: 
1:45b5ae1:         // need to maintain latch on leaf until xact is committed.  The
1:45b5ae1:         // commit will clear the latch as part of releasing all 
1:45b5ae1:         // locks/latches associated with a transaction.
1:45b5ae1: 
1:45b5ae1:         return;
1:63bc195:     }
1:63bc195: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:c9ef166
/////////////////////////////////////////////////////////////////////////
1:             if (se.isLockTimeoutOrDeadlock())
/////////////////////////////////////////////////////////////////////////
1:                     if (se2.isLockTimeoutOrDeadlock())
commit:45b5ae1
/////////////////////////////////////////////////////////////////////////
1:         TransactionManager  internal_xact  = tc.getInternalTransaction();
/////////////////////////////////////////////////////////////////////////
1:         OpenBTree           open_btree = null;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if (open_btree != null)
1:                 open_btree.close();
1: 
1:             // counting on this commit to release latches associated with
1:             // row level purge, that have been left to prevent others from
1:             // getting to purged pages before the commit.  If latch is released
1:             // early, other transactions could insert on the page which could
1:             // prevent undo of the purges in case of a crash before the commit
1:             // gets to the disk.
/////////////////////////////////////////////////////////////////////////
1:      * This routine handles purging committed deletes while holding a table
1:      * level exclusive lock.  See purgeRowLevelCommittedDeletes() for row level
1:      * purging.
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * The latch on the leaf page containing the purged rows must be kept until
1:      * after the transaction has been committed or aborted in order to insure
1:      * proper undo of the purges can take place.  Otherwise another transaction
1:      * could use the space freed by the purge and then prevent the purge from
1:      * being able to undo.
/////////////////////////////////////////////////////////////////////////
1:         // The following can fail, returning null, either if it can't get
1:         // the latch or somehow the page requested no longer exists.  In 
1:         // either case the post commit work will just skip it.
1:         leaf = (LeafControlRow) 
1:             ControlRow.getNoWait(open_btree, page_number);
1:         if (leaf == null)
1:             return;
1: 
1:         BTreeLockingPolicy  btree_locking_policy = 
1:             open_btree.getLockingPolicy();
1: 
1:         // The number records that can be reclaimed is:
1:         // total recs - control row - recs_not_deleted
1:         int num_possible_commit_delete = 
1:             leaf.page.recordCount() - 1 - leaf.page.nonDeletedRecordCount();
1: 
1:         if (num_possible_commit_delete > 0)
1:             DataValueDescriptor[] scratch_template = 
1:                 open_btree.getRuntimeMem().get_template(
1:                     open_btree.getRawTran());
1:             Page page   = leaf.page;
1:             // RowLocation column is in last column of template.
1:             FetchDescriptor lock_fetch_desc = 
1:                 RowUtil.getFetchDescriptorConstant(
1:                     scratch_template.length - 1);
1: 
1:             // loop backward so that purges which affect the slot table 
1:             // don't affect the loop (ie. they only move records we 
1:             // have already looked at).
1:             for (int slot_no = page.recordCount() - 1; 
1:                  slot_no > 0; 
1:                  slot_no--) 
1:                 if (page.isDeletedAtSlot(slot_no))
1:                     // try to get an exclusive lock on the row, if we can 
1:                     // then the row is a committed deleted row and it is 
1:                     // safe to purge it.
1:                     if (btree_locking_policy.lockScanCommittedDeletedRow(
1:                             open_btree, leaf, scratch_template, 
1:                             lock_fetch_desc, slot_no))
1:                         // the row is a committed deleted row, purge it.
1:                         page.purgeAtSlot(slot_no, 1, true);
1:                         // Tell scans positioned on this page to reposition
1:                         // because the row they are positioned on may have
1:                         // disappeared.
1:                         page.setRepositionNeeded();
1: 
1: 
1:         // need to maintain latch on leaf until xact is committed.  The
1:         // commit will clear the latch as part of releasing all 
1:         // locks/latches associated with a transaction.
1: 
1:         return;
commit:dd2ce24
/////////////////////////////////////////////////////////////////////////
1:         LeafControlRow leaf = null;
0:             // The following can fail, returning null, either if it can't get
0:             // the latch or somehow the page requested no longer exists.  In 
0:             // either case the post commit work will just skip it.
0:             leaf = (LeafControlRow) 
0:                 ControlRow.getNoWait(open_btree, page_number);
0:             if (leaf == null)
/////////////////////////////////////////////////////////////////////////
0:             if (leaf != null)
0:                 leaf.release();
commit:0489adb
/////////////////////////////////////////////////////////////////////////
commit:63bc195
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.RowUtil;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * Open index for either table level or row level update.
1:      * <p>
1:      * @param lock_level For table level use TransactionManager.MODE_TABLE,
1:      *                   for row   level use TransactionManager.MODE_RECORD
1:      * @param lock_mode  For table level use LockingPolicy.MODE_CONTAINER,
1:      *                   for row   level use LockingPolicy.MODE_RECORD
1:      *
1:      * @exception  StandardException  Standard exception policy.
1:      **/
1:     private final OpenBTree openIndex(
1:     TransactionManager internal_xact,
1:     int                lock_level,
1:     int                lock_mode)
1:         throws StandardException
1:     {
1:         OpenBTree open_btree = new OpenBTree();
1: 
1:         ConglomerateController base_cc = 
1:             btree.lockTable(
1:                 internal_xact, 
1:                 (ContainerHandle.MODE_FORUPDATE |
1:                  ContainerHandle.MODE_LOCK_NOWAIT), 
1:                 lock_level,
1:                 TransactionController.ISOLATION_REPEATABLE_READ);
1: 
1:         open_btree.init(
1:             (TransactionManager) null, 
1:             internal_xact, 
1:             (ContainerHandle) null,           // open the container 
1:             internal_xact.getRawStoreXact(),
1:             false,
1:             (ContainerHandle.MODE_FORUPDATE | ContainerHandle.MODE_LOCK_NOWAIT),
1:             lock_level,
1:             btree.getBtreeLockingPolicy(
1:                 internal_xact.getRawStoreXact(),
1:                 lock_level,
1:                 lock_mode,
1:                 TransactionController.ISOLATION_REPEATABLE_READ, 
1:                 base_cc,
1:                 open_btree),
1:             btree, 
1:             (LogicalUndo) null,              // No logical undo necessry.
1:             (DynamicCompiledOpenConglomInfo) null);
1: 
1:         return(open_btree);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
0:         OpenBTree open_btree = null;
1:             // First attempt to get a table lock on the btree.  This lock is
1:             // requested NOWAIT to not impede normal operation on the table.
1:             // If the lock were to wait then the current lock manager livelock 
1:             // algorithm would block all subsequent lock requests on this 
1:             // btree even if they are compatible with the current holder of 
1:             // the lock.
1:             // If this lock is granted then:
1:             // 1) deleted rows on the page can automatically be purged as
1:             //    they must be committed, otherwise lock would not have been
1:             //    granted.
1:             // 2) if all rows from page are reclaimed then a structure shrink
1:             //    which requires table level lock can be executed.
1:             //
1:             open_btree = 
1:                 openIndex(
1:                     TransactionController.MODE_TABLE, 
1:                     LockingPolicy.MODE_CONTAINER);
/////////////////////////////////////////////////////////////////////////
1:             // 2 kinds of errors here expected here.  Either container not 
1:             // found or could not obtain lock (LOCK_TIMEOUT or DEADLOCK).
1:             //
1:                 // Could not get exclusive table lock, so try row level
1:                 // reclaim of just the rows on this page.  No merge is 
1:                 // attempted.
1:                 try
1:                 {
1:                     open_btree = 
1:                         openIndex(
1:                             internal_xact, 
1:                             TransactionController.MODE_RECORD, 
1:                             LockingPolicy.MODE_RECORD);
1:                     purgeRowLevelCommittedDeletes(open_btree);
1: 
0:                     open_btree.close();
1: 
1:                 }
1:                 catch (StandardException se2)
1:                 {
0:                     if (se2.getMessageId().equals(SQLState.LOCK_TIMEOUT) ||
0:                         se2.getMessageId().equals(SQLState.DEADLOCK))
1:                     {
1:                         // Could not get intended exclusive table lock, so 
1:                         // requeue and hope other user gives up table level
1:                         // lock soon.  This should not be normal case.
1:                         requeue_work = true;
1:                     }
1:                 }
1:             }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Attempt to reclaim committed deleted rows from the page with row locking.
1:      * <p>
1:      * Get exclusive latch on page, and then loop backward through
1:      * page searching for deleted rows which are committed.  
1:      * This routine is called only from post commit processing so it will never
1:      * see rows deleted by the current transaction.
1:      * For each deleted row on the page
1:      * it attempts to get an exclusive lock on the deleted row, NOWAIT.
1:      * If it succeeds, and since this transaction did not delete the row then 
1:      * the row must have been deleted by a transaction which has committed, so
1:      * it is safe to purge the row.  It then purges the row from the page.
1:      *
1:      * @param open_btree The already open btree, which has been locked with IX
1:      *                   table lock, to use to get latch on page.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private final void purgeRowLevelCommittedDeletes(
1:     OpenBTree           open_btree)
1:         throws StandardException
1:     {
0:         ControlRow  controlRow              = null; 
1: 
1:         try
1:         {
1: 
0:             if ((controlRow = ControlRow.get(open_btree, page_number)) == null)
1:                 return;
1: 
0:             LeafControlRow leaf = (LeafControlRow) controlRow;
1: 
0:             BTreeLockingPolicy  btree_locking_policy = 
0:                 open_btree.getLockingPolicy();
1: 
1:             // The number records that can be reclaimed is:
1:             // total recs - control row - recs_not_deleted
1:             int num_possible_commit_delete = 
0:                 leaf.page.recordCount() - 1 - leaf.page.nonDeletedRecordCount();
1: 
0:             if ((num_possible_commit_delete > 0) &&
0:                 (btree_locking_policy.lockScanForReclaimSpace(leaf)))
1:             {
0:                 DataValueDescriptor[] scratch_template = 
0:                     open_btree.getRuntimeMem().get_template(
1:                         open_btree.getRawTran());
1: 
0:                 // Need to get an exclusive scan lock on the page before we can
0:                 // do any sort of purges, otherwise other concurrent scans would
0:                 // not work.  If we can't get the lock NOWAIT, just give up on
0:                 // purging rows. 
0:                 Page page   = leaf.page;
1: 
1: 
0:                 // RowLocation column is in last column of template.
0:                 FetchDescriptor lock_fetch_desc = 
0:                     RowUtil.getFetchDescriptorConstant(
0:                         scratch_template.length - 1);
1: 
1:                 // loop backward so that purges which affect the slot table 
1:                 // don't affect the loop (ie. they only move records we 
1:                 // have already looked at).
1:                 for (int slot_no = page.recordCount() - 1; 
1:                      slot_no > 0; 
1:                      slot_no--) 
1:                 {
1:                     if (page.isDeletedAtSlot(slot_no))
1:                     {
0:                         // try to get an exclusive lock on the row, if we can 
0:                         // then the row is a committed deleted row and it is 
0:                         // safe to purge it.
0:                         if (btree_locking_policy.lockScanCommittedDeletedRow(
0:                                 open_btree, leaf, scratch_template, 
0:                                 lock_fetch_desc, slot_no))
1:                         {
0:                             // the row is a committed deleted row, purge it.
1:                             page.purgeAtSlot(slot_no, 1, true);
1:                         }
1:                     }
1:                 }
1: 
1:             }
1:         }
1:         finally
1:         {
0:             if (controlRow != null)
0:                 controlRow.release();
1: 
1:             return;
1:         }
1:     }
1: 
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:             open_btree.getConglomerate().createTemplate(
0:                     open_btree.getRawTran());
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:86e051f
/////////////////////////////////////////////////////////////////////////
1:                             // Tell scans positioned on this page to reposition
1:                             // because the row they are positioned on may have
1:                             // disappeared.
1:                             page.setRepositionNeeded();
/////////////////////////////////////////////////////////////////////////
1:             if (num_possible_commit_delete > 0)
/////////////////////////////////////////////////////////////////////////
0:                             // Tell scans positioned on this page to reposition
0:                             // because the row they are positioned on may have
0:                             // disappeared.
0:                             page.setRepositionNeeded();
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:         root = ControlRow.get(open_btree, BTree.ROOTPAGEID);
/////////////////////////////////////////////////////////////////////////
1:             control_row = ControlRow.getNoWait(open_btree, pageno);
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.BTreePostCommit
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
1: import org.apache.derby.iapi.services.context.ContextManager;
1: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.store.access.AccessFactory;
1: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
0: import org.apache.derby.iapi.store.access.Qualifier;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: /**
1: 
1: The BTreePostCommit class implements the Serviceable protocol.  
1: 
1: In it's role as a Serviceable object, it stores the state necessary to 
1: find a page in a btree that may have committed delete's to reclaim.
1: 
1: In it's role as a PostCommitProcessor it looks up the page described, and
1: reclaims space in the btree.  It first trys to clean up any deleted commits
1: on the page.  It then will shrink the tree if it is going to delete all
1: rows from the page (RESOLVE - not done yet).
1: 
1: **/
1: 
1: class BTreePostCommit implements Serviceable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1:     private     AccessFactory access_factory  = null;
1:     private     long          page_number = ContainerHandle.INVALID_PAGE_NUMBER;
1: 
1:     protected   BTree         btree           = null;
1: 
1:     /* Constructors for This class: */
1:     BTreePostCommit(
1:     AccessFactory   access_factory,
1:     BTree           btree,
1:     long            input_page_number)
1:     {
1:         this.access_factory = access_factory; 
1:         this.btree          = btree; 
1:         this.page_number    = input_page_number; 
1:     }
1: 
1:     /* Private/Protected methods of This class: */
1: 
1:     /* Public Methods of This class: */
1: 
1:     /* Public Methods of Serviceable class: */
1: 
1:     /**
1:      * The urgency of this post commit work.
1:      * <p>
1:      * This determines where this Serviceable is put in the post commit 
1:      * queue.  Post commit work in the btree can be safely delayed until there
1:      * is not user work to do.
1:      *
1: 	 * @return false, this work should not be serviced ASAP
1:      **/
1:     public boolean serviceASAP()
1:     {
1:         return(true);
1:     }
1: 
1: 
1: 	// @return true, if this work needs to be done on a user thread immediately
1: 	public boolean serviceImmediately()
1: 	{
1: 		return false;
1: 	}	
1: 
1:     private final void doShrink(
1:     OpenBTree               open_btree, 
1:     DataValueDescriptor[]	shrink_row)
1:         throws StandardException
1:     {
1:         ControlRow root = null;
1: 
1:         /*
1:         System.out.println(
1:             "Calling shrink on tree with levels = " + 
1:             open_btree.getHeight() + "\n");
1:         */
1: 
1:         // Get the root page back, and perform a split following the
1:         // to-be-inserted key.  The split releases the root page latch.
0:         root = ControlRow.Get(open_btree, BTree.ROOTPAGEID);
1: 
1:         root.shrinkFor(open_btree, shrink_row);
1: 
1:         root = null;
1: 
1:         // on return from shrinkFor the root pointer is invalid.  The
1:         // latch has been released, the root page may have changed from
1:         // a branch to a leaf.
1: 
0:         return;
1:     }
1: 
1:     /**
1:      * perform the work described in the postcommit work.
1:      * <p>
1:      * In this implementation the only work that can be executed by this
1:      * post commit processor is this class itself.
1:      * <p>
1:      *
1: 	 * @return Returns Serviceable.DONE when work has completed, or
1:      *         returns Serviceable.REQUEUE if work needs to be requeued.
1:      *
1:      * @param contextMgr the context manager started by the
1: 	 *         post commit daemon
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public int performWork(ContextManager contextMgr)
1:         throws StandardException
1:     {
1: 
1:         // requeue if work was not completed in this try because of locks
1:         boolean             requeue_work = false;
1: 
1:         TransactionManager tc             = (TransactionManager)
1:             this.access_factory.getAndNameTransaction(
1:                 contextMgr, AccessFactoryGlobals.SYS_TRANS_NAME);
1: 
0:         TransactionManager internal_xact  = tc.getInternalTransaction();
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             if (SanityManager.DEBUG_ON("verbose_btree_post_commit"))
1:                 System.out.println("starting internal xact\n");
1:         }
1: 
0:         OpenBTree open_btree = new OpenBTree();
1: 
1:         try
1:         {
1:             // Get lock on base table.
1:             
0:             // The current space reclamation algorithm requires a table level
0:             // lock on the btree - this is mostly because the shrink algorithm
0:             // is not multi-user.  This lock is requested NOWAIT as it does
0:             // not want to impedede normal operation on the table.  If the lock
0:             // were to wait then the current lock manager livelock algorithm 
0:             // would block all subsequent lock requests on this btree even if
0:             // they are compatible with the current holder of the lock.
1:             // 
0:             // There are currently 3 outstanding enhancement requests:
0:             // track 4237 - retry the work intelligently
0:             // track 4238 - if can't get table lock, at least reclaim the rows
0:             // track 4239 - do row level lock shrink - very hard to do.
1:             //
0:             ConglomerateController base_cc = 
0:                 btree.lockTable(
1:                     internal_xact, 
0:                     (ContainerHandle.MODE_FORUPDATE |
0:                      ContainerHandle.MODE_LOCK_NOWAIT), 
0:                     TransactionController.MODE_TABLE,
0:                     TransactionController.ISOLATION_REPEATABLE_READ);
1: 
0:             open_btree.init(
0:                 (TransactionManager) null, 
1:                 internal_xact, 
0:                 (ContainerHandle) null,           // open the container 
0:                 internal_xact.getRawStoreXact(),
0:                 false,
0:                 ContainerHandle.MODE_FORUPDATE,
0:                 TransactionController.MODE_TABLE,
0:                 btree.getBtreeLockingPolicy(
0:                     internal_xact.getRawStoreXact(),
0:                     TransactionController.MODE_TABLE,
0:                     LockingPolicy.MODE_CONTAINER,
0:                     TransactionController.ISOLATION_REPEATABLE_READ, 
0:                     base_cc,
0:                     open_btree),
0:                 btree, 
0:                 (LogicalUndo) null,              // No logical undo necessry.
0:                 (DynamicCompiledOpenConglomInfo) null);
1: 
1:             DataValueDescriptor[] shrink_key = 
1:                 purgeCommittedDeletes(open_btree, this.page_number);
1: 
0:             // RESOLVE (mikem) - move this call when doing row level locking.
1:             if (shrink_key != null)
1:                 doShrink(open_btree, shrink_key);
1: 
0:             open_btree.close();
1:         }
1:         catch (StandardException se)
1:         {
1: 
1: 			
0:             //2 kinds of errors here expected here.  Either container not found or dead lock. 
1:             // It is possible by the time this post commit work gets scheduled 
1:             // that the container has been dropped and that the open container 
1:             // call will return null - in this case just return assuming no 
1:             // work to be done.
1: 
0: 			//If it is a locking error, work is requeued. (4237)
1: 		   
0: 			if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT) ||
0: 				se.getMessageId().equals(SQLState.DEADLOCK))
1: 			{
0: 				requeue_work = true;
1: 			}
1: 
0: 			//RESSOLVE-mike (4238) If you can't get a table level lock for btree space recovery in 
0: 			//the post commit thread, maybe you should at least reclaim the 
0: 			//rows on the page while you are at it.  Use the same algorithm 
0: 			//as exists in BTreeController.java.  row level shrink is still a 
0: 			//big problem and a separate track exists for it.
1: 			
1: 
1:         }
1:         finally
1:         {
1:             internal_xact.commit();
1:             internal_xact.destroy();
1:         }
1: 
1:         return(requeue_work ? Serviceable.REQUEUE : Serviceable.DONE);
1:     }
1: 
1:     private final DataValueDescriptor[] getShrinkKey(
1:     OpenBTree   open_btree, 
1:     ControlRow  control_row,
1:     int         slot_no)
1:         throws StandardException
1:     {
1:         DataValueDescriptor[] shrink_key = 
0:             open_btree.getConglomerate().createTemplate();
1: 
1:         control_row.page.fetchFromSlot(
1:             (RecordHandle) null,
1:             slot_no, shrink_key, 
1:             (FetchDescriptor) null,
1: 			true);
1: 
1:         return(shrink_key);
1:     }
1: 
1:     /**
1:      * Reclaim space taken up by committed deleted rows.
1:      * <p>
1:      * This routine assumes it has been called by an internal transaction which
1:      * has performed no work so far, and that it has an exclusive table lock.  
1:      * These assumptions mean that any deleted rows encountered must be from
1:      * committed transactions (otherwise we could not have gotten the exclusive
1:      * table lock).
1:      * <p>
0:      * RESOLVE (mikem) - under row locking this routine must do more work to
0:      * determine a deleted row is a committed deleted row.
1:      *
1:      * @param open_btree The btree already opened.
1:      * @param pageno The page number of the page to look for committed deletes.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     private final DataValueDescriptor[] purgeCommittedDeletes(
1:     OpenBTree           open_btree,
1:     long                pageno)
1:         throws StandardException
1:     {
1:         ControlRow              control_row = null;
1:         DataValueDescriptor[]	shrink_key  = null; 
1: 
1:         try
1:         {
1:             // The following can fail either if it can't get the latch or
1:             // somehow the page requested no longer exists.  In either case
1:             // the post commit work will just skip it.
0:             control_row = ControlRow.GetNoWait(open_btree, pageno);
1: 
1:             if (control_row != null)
1:             {
1:                 Page page   = control_row.page;
1: 
0:                 // The number records that can be reclaimed is:
0:                 // total recs - control row - recs_not_deleted
0:                 int num_possible_commit_delete = 
1:                     page.recordCount() - 1 - page.nonDeletedRecordCount();
1: 
0:                 if (num_possible_commit_delete > 0)
1:                 {
0:                     // loop backward so that purges which affect the slot table 
0:                     // don't affect the loop (ie. they only move records we 
0:                     // have already looked at).
0:                     for (int slot_no = page.recordCount() - 1; 
0:                          slot_no > 0; 
0:                          slot_no--) 
1:                     {
0:                         if (page.isDeletedAtSlot(slot_no))
1:                         {
1: 
1:                             if (page.recordCount() == 2)
1:                             {
1:                                 // About to purge last row from page so 
1:                                 // remember the key so we can shrink the 
1:                                 // tree.
1:                                 shrink_key = this.getShrinkKey(
1:                                     open_btree, control_row, slot_no);
1:                             }
1: 
0:                             page.purgeAtSlot(slot_no, 1, true);
1: 
1:                             if (SanityManager.DEBUG)
1:                             {
1:                                 if (SanityManager.DEBUG_ON(
1:                                         "verbose_btree_post_commit"))
1:                                 {
1:                                     System.out.println(
1:                                         "Purging row[" + slot_no + "]" + 
1:                                         "on page:" + pageno + ".\n");
1:                                 }
1:                             }
1:                         }
1:                     }
1:                 }
1: 
1:                 if (page.recordCount() == 1)
1:                 {
1:                     if (SanityManager.DEBUG)
1:                     {
1:                         if (SanityManager.DEBUG_ON("verbose_btree_post_commit"))
1:                         {
1:                             System.out.println("Chance to shrink.\n");
1:                         }
1:                     }
1:                 }
1:             }
1:             else
1:             {
1: 				if (SanityManager.DEBUG)
1:                 {
1:                     if (SanityManager.DEBUG_ON("verbose_btree_post_commit"))
1:                     {
1:                         System.out.println(
1:                             "Get No Wait returned null. page num = " + pageno +
1:                             "\n");
1:                     }
1:                 }
1:             }
1:         }
1:         finally
1:         {
1:             if (control_row != null)
1:                 control_row.release();
1:         }
1: 
1:         return(shrink_key);
1:     }
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.daemon.Serviceable;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.store.access.AccessFactoryGlobals;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.Qualifier;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: /**
0: 
0: The BTreePostCommit class implements the Serviceable protocol.  
0: 
0: In it's role as a Serviceable object, it stores the state necessary to 
0: find a page in a btree that may have committed delete's to reclaim.
0: 
0: In it's role as a PostCommitProcessor it looks up the page described, and
0: reclaims space in the btree.  It first trys to clean up any deleted commits
0: on the page.  It then will shrink the tree if it is going to delete all
0: rows from the page (RESOLVE - not done yet).
0: 
0: **/
0: 
0: class BTreePostCommit implements Serviceable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0:     private     AccessFactory access_factory  = null;
0:     private     long          page_number = ContainerHandle.INVALID_PAGE_NUMBER;
0: 
0:     protected   BTree         btree           = null;
0: 
0:     /* Constructors for This class: */
0:     BTreePostCommit(
0:     AccessFactory   access_factory,
0:     BTree           btree,
0:     long            input_page_number)
0:     {
0:         this.access_factory = access_factory; 
0:         this.btree          = btree; 
0:         this.page_number    = input_page_number; 
0:     }
0: 
0:     /* Private/Protected methods of This class: */
0: 
0:     /* Public Methods of This class: */
0: 
0:     /* Public Methods of Serviceable class: */
0: 
0:     /**
0:      * The urgency of this post commit work.
0:      * <p>
0:      * This determines where this Serviceable is put in the post commit 
0:      * queue.  Post commit work in the btree can be safely delayed until there
0:      * is not user work to do.
0:      *
0: 	 * @return false, this work should not be serviced ASAP
0:      **/
0:     public boolean serviceASAP()
0:     {
0:         return(true);
0:     }
0: 
0: 
0: 	// @return true, if this work needs to be done on a user thread immediately
0: 	public boolean serviceImmediately()
0: 	{
0: 		return false;
0: 	}	
0: 
0:     private final void doShrink(
0:     OpenBTree               open_btree, 
0:     DataValueDescriptor[]	shrink_row)
0:         throws StandardException
0:     {
0:         ControlRow root = null;
0: 
0:         /*
0:         System.out.println(
0:             "Calling shrink on tree with levels = " + 
0:             open_btree.getHeight() + "\n");
0:         */
0: 
0:         // Get the root page back, and perform a split following the
0:         // to-be-inserted key.  The split releases the root page latch.
0:         root = ControlRow.Get(open_btree, BTree.ROOTPAGEID);
0: 
0:         root.shrinkFor(open_btree, shrink_row);
0: 
0:         root = null;
0: 
0:         // on return from shrinkFor the root pointer is invalid.  The
0:         // latch has been released, the root page may have changed from
0:         // a branch to a leaf.
0: 
0:         return;
0:     }
0: 
0:     /**
0:      * perform the work described in the postcommit work.
0:      * <p>
0:      * In this implementation the only work that can be executed by this
0:      * post commit processor is this class itself.
0:      * <p>
0:      *
0: 	 * @return Returns Serviceable.DONE when work has completed, or
0:      *         returns Serviceable.REQUEUE if work needs to be requeued.
0:      *
0:      * @param contextMgr the context manager started by the
0: 	 *         post commit daemon
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public int performWork(ContextManager contextMgr)
0:         throws StandardException
0:     {
0: 
0:         // requeue if work was not completed in this try because of locks
0:         boolean             requeue_work = false;
0: 
0:         TransactionManager tc             = (TransactionManager)
0:             this.access_factory.getAndNameTransaction(
0:                 contextMgr, AccessFactoryGlobals.SYS_TRANS_NAME);
0: 
0:         TransactionManager internal_xact  = tc.getInternalTransaction();
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             if (SanityManager.DEBUG_ON("verbose_btree_post_commit"))
0:                 System.out.println("starting internal xact\n");
0:         }
0: 
0:         OpenBTree open_btree = new OpenBTree();
0: 
0:         try
0:         {
0:             // Get lock on base table.
0:             
0:             // The current space reclamation algorithm requires a table level
0:             // lock on the btree - this is mostly because the shrink algorithm
0:             // is not multi-user.  This lock is requested NOWAIT as it does
0:             // not want to impedede normal operation on the table.  If the lock
0:             // were to wait then the current lock manager livelock algorithm 
0:             // would block all subsequent lock requests on this btree even if
0:             // they are compatible with the current holder of the lock.
0:             // 
0:             // There are currently 3 outstanding enhancement requests:
0:             // track 4237 - retry the work intelligently
0:             // track 4238 - if can't get table lock, at least reclaim the rows
0:             // track 4239 - do row level lock shrink - very hard to do.
0:             //
0:             ConglomerateController base_cc = 
0:                 btree.lockTable(
0:                     internal_xact, 
0:                     (ContainerHandle.MODE_FORUPDATE |
0:                      ContainerHandle.MODE_LOCK_NOWAIT), 
0:                     TransactionController.MODE_TABLE,
0:                     TransactionController.ISOLATION_REPEATABLE_READ);
0: 
0:             open_btree.init(
0:                 (TransactionManager) null, 
0:                 internal_xact, 
0:                 (ContainerHandle) null,           // open the container 
0:                 internal_xact.getRawStoreXact(),
0:                 false,
0:                 ContainerHandle.MODE_FORUPDATE,
0:                 TransactionController.MODE_TABLE,
0:                 btree.getBtreeLockingPolicy(
0:                     internal_xact.getRawStoreXact(),
0:                     TransactionController.MODE_TABLE,
0:                     LockingPolicy.MODE_CONTAINER,
0:                     TransactionController.ISOLATION_REPEATABLE_READ, 
0:                     base_cc,
0:                     open_btree),
0:                 btree, 
0:                 (LogicalUndo) null,              // No logical undo necessry.
0:                 (DynamicCompiledOpenConglomInfo) null);
0: 
0:             DataValueDescriptor[] shrink_key = 
0:                 purgeCommittedDeletes(open_btree, this.page_number);
0: 
0:             // RESOLVE (mikem) - move this call when doing row level locking.
0:             if (shrink_key != null)
0:                 doShrink(open_btree, shrink_key);
0: 
0:             open_btree.close();
0:         }
0:         catch (StandardException se)
0:         {
0: 
0: 			
0:             //2 kinds of errors here expected here.  Either container not found or dead lock. 
0:             // It is possible by the time this post commit work gets scheduled 
0:             // that the container has been dropped and that the open container 
0:             // call will return null - in this case just return assuming no 
0:             // work to be done.
0: 
0: 			//If it is a locking error, work is requeued. (4237)
0: 		   
0: 			if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT) ||
0: 				se.getMessageId().equals(SQLState.DEADLOCK))
0: 			{
0: 				requeue_work = true;
0: 			}
0: 
0: 			//RESSOLVE-mike (4238) If you can't get a table level lock for btree space recovery in 
0: 			//the post commit thread, maybe you should at least reclaim the 
0: 			//rows on the page while you are at it.  Use the same algorithm 
0: 			//as exists in BTreeController.java.  row level shrink is still a 
0: 			//big problem and a separate track exists for it.
0: 			
0: 
0:         }
0:         finally
0:         {
0:             internal_xact.commit();
0:             internal_xact.destroy();
0:         }
0: 
0:         return(requeue_work ? Serviceable.REQUEUE : Serviceable.DONE);
0:     }
0: 
0:     private final DataValueDescriptor[] getShrinkKey(
0:     OpenBTree   open_btree, 
0:     ControlRow  control_row,
0:     int         slot_no)
0:         throws StandardException
0:     {
0:         DataValueDescriptor[] shrink_key = 
0:             open_btree.getConglomerate().createTemplate();
0: 
0:         control_row.page.fetchFromSlot(
0:             (RecordHandle) null,
0:             slot_no, shrink_key, 
0:             (FetchDescriptor) null,
0: 			true);
0: 
0:         return(shrink_key);
0:     }
0: 
0:     /**
0:      * Reclaim space taken up by committed deleted rows.
0:      * <p>
0:      * This routine assumes it has been called by an internal transaction which
0:      * has performed no work so far, and that it has an exclusive table lock.  
0:      * These assumptions mean that any deleted rows encountered must be from
0:      * committed transactions (otherwise we could not have gotten the exclusive
0:      * table lock).
0:      * <p>
0:      * RESOLVE (mikem) - under row locking this routine must do more work to
0:      * determine a deleted row is a committed deleted row.
0:      *
0:      * @param open_btree The btree already opened.
0:      * @param pageno The page number of the page to look for committed deletes.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     private final DataValueDescriptor[] purgeCommittedDeletes(
0:     OpenBTree           open_btree,
0:     long                pageno)
0:         throws StandardException
0:     {
0:         ControlRow              control_row = null;
0:         DataValueDescriptor[]	shrink_key  = null; 
0: 
0:         try
0:         {
0:             // The following can fail either if it can't get the latch or
0:             // somehow the page requested no longer exists.  In either case
0:             // the post commit work will just skip it.
0:             control_row = ControlRow.GetNoWait(open_btree, pageno);
0: 
0:             if (control_row != null)
0:             {
0:                 Page page   = control_row.page;
0: 
0:                 // The number records that can be reclaimed is:
0:                 // total recs - control row - recs_not_deleted
0:                 int num_possible_commit_delete = 
0:                     page.recordCount() - 1 - page.nonDeletedRecordCount();
0: 
0:                 if (num_possible_commit_delete > 0)
0:                 {
0:                     // loop backward so that purges which affect the slot table 
0:                     // don't affect the loop (ie. they only move records we 
0:                     // have already looked at).
0:                     for (int slot_no = page.recordCount() - 1; 
0:                          slot_no > 0; 
0:                          slot_no--) 
0:                     {
0:                         if (page.isDeletedAtSlot(slot_no))
0:                         {
0: 
0:                             if (page.recordCount() == 2)
0:                             {
0:                                 // About to purge last row from page so 
0:                                 // remember the key so we can shrink the 
0:                                 // tree.
0:                                 shrink_key = this.getShrinkKey(
0:                                     open_btree, control_row, slot_no);
0:                             }
0: 
0:                             page.purgeAtSlot(slot_no, 1, true);
0: 
0:                             if (SanityManager.DEBUG)
0:                             {
0:                                 if (SanityManager.DEBUG_ON(
0:                                         "verbose_btree_post_commit"))
0:                                 {
0:                                     System.out.println(
0:                                         "Purging row[" + slot_no + "]" + 
0:                                         "on page:" + pageno + ".\n");
0:                                 }
0:                             }
0:                         }
0:                     }
0:                 }
0: 
0:                 if (page.recordCount() == 1)
0:                 {
0:                     if (SanityManager.DEBUG)
0:                     {
0:                         if (SanityManager.DEBUG_ON("verbose_btree_post_commit"))
0:                         {
0:                             System.out.println("Chance to shrink.\n");
0:                         }
0:                     }
0:                 }
0:             }
0:             else
0:             {
0: 				if (SanityManager.DEBUG)
0:                 {
0:                     if (SanityManager.DEBUG_ON("verbose_btree_post_commit"))
0:                     {
0:                         System.out.println(
0:                             "Get No Wait returned null. page num = " + pageno +
0:                             "\n");
0:                     }
0:                 }
0:             }
0:         }
0:         finally
0:         {
0:             if (control_row != null)
0:                 control_row.release();
0:         }
0: 
0:         return(shrink_key);
0:     }
0: 
0: }
============================================================================