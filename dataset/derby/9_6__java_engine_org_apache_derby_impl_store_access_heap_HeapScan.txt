2:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.heap.HeapScan
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
11:eac0369: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.heap;
1:eac0369: 
1:eac0369: 
3:eac0369: /**
1:eac0369: 
1:eac0369:   A heap scan object represents an instance of an scan on a heap conglomerate.
1:eac0369: 
2:eac0369: **/
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: 
1:fa09146: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: import org.apache.derby.iapi.store.access.ScanInfo;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.RecordHandle;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:fa09146: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.GenericScanController;
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
1:eac0369: 
1:eac0369: class HeapScan 
1:eac0369:     extends GenericScanController implements ScanManager
2:eac0369: {
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constants of HeapScan
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Fields of HeapScan
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * A 1 element array to turn fetchNext and fetch calls into 
1:eac0369:      * fetchNextGroup calls.
1:eac0369:      **/
1:eac0369:     private DataValueDescriptor[][] fetchNext_one_slot_array = 
1:eac0369:         new DataValueDescriptor[1][];
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constructors for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 ** The only constructor for a heap scan returns a scan in the
1:eac0369: 	 ** closed state, the caller must call open.
1:eac0369: 	 **/
1:eac0369: 	
1:eac0369: 	public HeapScan()
1:eac0369: 	{
2:eac0369: 	}
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Protected concrete impl of abstract methods of 
1:eac0369:      *     GenericController class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369:     protected void queueDeletePostCommitWork(
1:eac0369:     RowPosition pos)
2:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         TransactionManager xact_mgr = open_conglom.getXactMgr();
1:eac0369: 
1:eac0369:         xact_mgr.addPostCommitWork(
1:eac0369:             new HeapPostCommit(
1:eac0369:                 xact_mgr.getAccessManager(), 
1:888d12e:                 pos.current_page.getPageKey()));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Private/Protected methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:bbc927c:     protected void setRowLocationArray(
1:bbc927c:     RowLocation[]   rowloc_array,
1:bbc927c:     int             index,
1:eac0369:     RowPosition     pos)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (rowloc_array[index] == null)
1:eac0369:         {
1:eac0369:             rowloc_array[index] = new HeapRowLocation(pos.current_rh);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     rowloc_array[index] instanceof HeapRowLocation);
1:eac0369:             }
1:eac0369: 
1:eac0369:             ((HeapRowLocation)rowloc_array[index]).setFrom(pos.current_rh);
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:e81e52c:     protected RowLocation makeRowLocation( RowPosition pos )
1:e81e52c:         throws StandardException
1:e81e52c:     {
1:e81e52c:         return new HeapRowLocation( pos.current_rh );
1:e81e52c:     }
1:e81e52c: 
1:eac0369:     protected void setRowLocationArray(
1:eac0369:     RowLocation[]   rowloc_array,
1:eac0369:     int             index,
1:bbc927c:     RecordHandle    rh)
1:bbc927c:         throws StandardException
1:bbc927c:     {
1:bbc927c:         if (rowloc_array[index] == null)
1:bbc927c:         {
1:bbc927c:             rowloc_array[index] = new HeapRowLocation(rh);
1:bbc927c:         }
1:bbc927c:         else
1:bbc927c:         {
1:bbc927c:             if (SanityManager.DEBUG)
1:bbc927c:             {
1:bbc927c:                 SanityManager.ASSERT(
1:bbc927c:                     rowloc_array[index] instanceof HeapRowLocation);
1:bbc927c:             }
1:bbc927c: 
1:bbc927c:             ((HeapRowLocation)rowloc_array[index]).setFrom(rh);
1:bbc927c:         }
1:bbc927c:     }
1:bbc927c: 
1:eac0369:     /**
1:d376440:      * Reposition the current scan and sets the necessary locks.
1:d376440:      *
1:d376440:      * @param rh An existing RecordHandle within the conglomerate,
1:d376440:      * at which to position the start of the scan.  The scan will begin at this
1:d376440:      * location and continue forward until the end of the conglomerate.  
1:d376440:      * Positioning at a non-existent RowLocation (ie. an invalid one or one that
1:d376440:      * had been deleted), will result in an exception being thrown when the 
1:d376440:      * first next operation is attempted.
1:d376440:      * @return true if the scan was successfully repositioned
1:d376440:      *
1:d376440:      * @exception StandardException Standard exception policy.
1:d376440:      */
1:d376440:     private boolean reopenScanByRecordHandleAndSetLocks (RecordHandle rh) 
1:d376440:             throws StandardException 
1:d376440:     {
1:d376440:         if (rh == null) 
1:d376440:         {
1:d376440:             return (false);
1:d376440:         }
1:d376440:         
1:d376440:         // Unlock current position
1:d376440:         if (scan_position.current_rh != null) 
1:d376440:         {
1:d376440:             open_conglom.unlockPositionAfterRead(scan_position);
1:d376440:         }
1:d376440:         
1:d376440:         // Position scan at new row
1:d376440:         scan_position.current_rh = rh;
1:d376440:         scan_position.current_rh_qualified = false;
1:d376440:         
1:d376440:         // Latch page and reposition scan
1:d376440:         final boolean rowLocationDisappeared = 
1:d376440:             open_conglom.latchPageAndRepositionScan(scan_position);
1:d376440:         
1:d376440:         if (!rowLocationDisappeared)
1:d376440:         {
1:d376440:             setScanState(SCAN_INPROGRESS);
1:d376440:             open_conglom.lockPositionForRead
1:d376440:                 (scan_position, null, true, true);
1:d376440:         }
1:d376440:         
1:d376440:         // Unlatch page
1:d376440:         scan_position.unlatch();
1:d376440:         
1:d376440:         return (!rowLocationDisappeared);
1:d376440:     }
1:d376440: 
1:d376440:     /**
1:eac0369:     Fetch the row at the next position of the Scan.
1:eac0369: 
1:eac0369:     If there is a valid next position in the scan then
1:eac0369: 	the value in the template storable row is replaced
1:eac0369: 	with the value of the row at the current scan
1:eac0369: 	position.  The columns of the template row must
1:eac0369: 	be of the same type as the actual columns in the
1:eac0369: 	underlying conglomerate.
1:eac0369: 
1:eac0369:     The resulting contents of templateRow after a fetchNext() 
1:eac0369:     which returns false is undefined.
1:eac0369: 
1:eac0369:     The result of calling fetchNext(row) is exactly logically
1:eac0369:     equivalent to making a next() call followed by a fetch(row)
1:eac0369:     call.  This interface allows implementations to optimize 
1:eac0369:     the 2 calls if possible.
1:eac0369: 
1:eac0369:     @param fetch_row The template row into which the value
1:eac0369: 	of the next position in the scan is to be stored.
1:eac0369: 
1:eac0369:     @return True if there is a next position in the scan,
1:eac0369: 	false if there isn't.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369:     public boolean fetchNext(DataValueDescriptor[] fetch_row)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         // Turn this call into a group fetch of a 1 element group.
1:eac0369:         if (fetch_row == null)
1:eac0369:             fetchNext_one_slot_array[0] = RowUtil.EMPTY_ROW;
1:eac0369:         else
1:eac0369:             fetchNext_one_slot_array[0] = fetch_row;
1:eac0369: 
1:eac0369:         boolean ret_val = 
1:eac0369:             fetchRows(
1:eac0369:                 fetchNext_one_slot_array, 
1:eac0369:                 (RowLocation[]) null,
1:eac0369:                 (BackingStoreHashtable) null,
1:eac0369:                 1,
1:eac0369:                 (int[]) null) == 1;
1:eac0369: 
1:eac0369:         return(ret_val);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:d376440:     /**
1:fa09146: 	@see org.apache.derby.iapi.store.access.ScanController#next
1:eac0369: 	**/
1:eac0369:     public boolean next()
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369:         // if there is no row template from the caller, we need to
1:eac0369:         // read the row into something, Use the scratch row.
1:eac0369:         // We could optimize this, if there are no qualifiers and read
1:eac0369:         // into a zero column row, but callers should be using fetchNext()
1:eac0369:         // instead.
1:722a889:         fetchNext_one_slot_array[0] = 
1:722a889:             open_conglom.getRuntimeMem().get_scratch_row(
1:722a889:                     open_conglom.getRawTran());
1:eac0369: 
1:eac0369:         boolean ret_val = 
1:eac0369:             fetchRows(
1:eac0369:                 fetchNext_one_slot_array, 
1:eac0369:                 (RowLocation[]) null,
1:eac0369:                 (BackingStoreHashtable) null,
1:eac0369:                 1,
1:eac0369:                 (int[]) null) == 1;
1:eac0369: 
1:eac0369:         return(ret_val);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:fa09146:      * @see org.apache.derby.iapi.store.access.ScanController#positionAtRowLocation
1:d376440:      */
1:d376440:     public boolean positionAtRowLocation(RowLocation rl) throws StandardException {
1:d376440:         if (open_conglom.isClosed() && !rowLocationsInvalidated) 
1:d376440:         {
1:d376440:             reopenAfterEndTransaction();
1:d376440:         }
1:d376440:         
1:d376440:         if (rowLocationsInvalidated) 
1:d376440:         {
1:d376440:             return(false);
1:d376440:             
1:d376440:         } else {
1:d376440:             return(reopenScanByRecordHandleAndSetLocks
1:d376440:                 (((HeapRowLocation)rl).
1:d376440:                  getRecordHandle(open_conglom.getContainer())));
1:d376440:         }
1:d376440:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of ScanController interface:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:fa09146: 	@see org.apache.derby.iapi.store.access.ScanController#fetchLocation
1:eac0369: 	**/
1:eac0369: 	public void fetchLocation(RowLocation templateLocation)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		if (open_conglom.getContainer() == null  || 
1:eac0369:             scan_position.current_rh == null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.HEAP_SCAN_NOT_POSITIONED);
1:eac0369:         }
1:eac0369: 		HeapRowLocation hrl = (HeapRowLocation) templateLocation;
1:eac0369: 		hrl.setFrom(scan_position.current_rh);
1:eac0369: 	}
1:eac0369: 
1:eac0369:     public int fetchNextGroup(
1:eac0369:     DataValueDescriptor[][] row_array,
1:eac0369:     RowLocation[]           rowloc_array)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369:         return(
1:eac0369:             fetchRows(
1:eac0369:                 row_array, 
1:eac0369:                 rowloc_array,
1:eac0369:                 (BackingStoreHashtable) null,
1:eac0369:                 row_array.length,
1:eac0369:                 (int[]) null));
1:eac0369:     }
1:eac0369: 
1:bbc927c:     public int fetchNextGroup(
1:bbc927c:     DataValueDescriptor[][] row_array,
1:bbc927c:     RowLocation[]           old_rowloc_array,
1:bbc927c:     RowLocation[]           new_rowloc_array)
1:bbc927c:         throws StandardException
1:bbc927c: 	{
1:bbc927c:         throw(StandardException.newException(
1:bbc927c:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));
1:bbc927c:     }
1:bbc927c: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return ScanInfo object which describes performance of scan.
3:eac0369:      * <p>
1:eac0369:      * Return ScanInfo object which contains information about the current
1:eac0369:      * scan.
1:eac0369:      * <p>
3:eac0369:      *
1:eac0369:      * @see ScanInfo
1:eac0369:      *
1:eac0369: 	 * @return The ScanInfo object which contains info about current scan.
1:eac0369:      *
2:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public ScanInfo getScanInfo()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return(new HeapScanInfo(this));
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Reposition the current scan.  This call is semantically the same as if
1:eac0369:     the current scan had been closed and a openScan() had been called instead.
1:eac0369:     The scan is reopened against the same conglomerate, and the scan
1:eac0369:     is reopened with the same "scan column list", "hold" and "forUpdate"
1:eac0369:     parameters passed in the original openScan.  
1:eac0369:     <p>
1:eac0369:     The statistics gathered by the scan are not reset to 0 by a reopenScan(),
1:eac0369:     rather they continue to accumulate.
1:eac0369:     <p>
1:eac0369:     Note that this operation is currently only supported on Heap conglomerates.
1:eac0369:     Also note that order of rows within are heap are not guaranteed, so for
1:eac0369:     instance positioning at a RowLocation in the "middle" of a heap, then
1:eac0369:     inserting more data, then continuing the scan is not guaranteed to see
1:eac0369:     the new rows - they may be put in the "beginning" of the heap.
1:eac0369: 
1:eac0369: 	@param startRowLocation  An existing RowLocation within the conglomerate,
1:eac0369:     at which to position the start of the scan.  The scan will begin at this
1:eac0369:     location and continue forward until the end of the conglomerate.  
1:eac0369:     Positioning at a non-existent RowLocation (ie. an invalid one or one that
1:eac0369:     had been deleted), will result in an exception being thrown when the 
1:eac0369:     first next operation is attempted.
1:eac0369: 
1:eac0369: 	@param qualifier An array of qualifiers which, applied
1:eac0369: 	to each key, restrict the rows returned by the scan.  Rows
1:eac0369: 	for which any one of the qualifiers returns false are not
1:eac0369: 	returned by the scan. If null, all rows are returned.
1:eac0369: 
1:eac0369: 	@exception StandardException Standard exception policy.
1:eac0369:     **/
1:eac0369: 	public void reopenScanByRowLocation(
1:eac0369:     RowLocation startRowLocation,
1:eac0369:     Qualifier qualifier[][])
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         reopenScanByRecordHandle(
1:eac0369:             ((HeapRowLocation) startRowLocation).getRecordHandle(
1:eac0369:                  open_conglom.getContainer()),
1:eac0369:             qualifier);
1:eac0369:     }
1:eac0369: }
============================================================================
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:888d12e
/////////////////////////////////////////////////////////////////////////
1:                 pos.current_page.getPageKey()));
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:         fetchNext_one_slot_array[0] = 
1:             open_conglom.getRuntimeMem().get_scratch_row(
1:                     open_conglom.getRawTran());
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1:     protected void setRowLocationArray(
1:     RowLocation[]   rowloc_array,
1:     int             index,
1:     RecordHandle    rh)
1:         throws StandardException
1:     {
1:         if (rowloc_array[index] == null)
1:         {
1:             rowloc_array[index] = new HeapRowLocation(rh);
1:         }
1:         else
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(
1:                     rowloc_array[index] instanceof HeapRowLocation);
1:             }
1: 
1:             ((HeapRowLocation)rowloc_array[index]).setFrom(rh);
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public int fetchNextGroup(
1:     DataValueDescriptor[][] row_array,
1:     RowLocation[]           old_rowloc_array,
1:     RowLocation[]           new_rowloc_array)
1:         throws StandardException
1: 	{
1:         throw(StandardException.newException(
1:                 SQLState.HEAP_UNIMPLEMENTED_FEATURE));
1:     }
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:e81e52c
/////////////////////////////////////////////////////////////////////////
1:     protected RowLocation makeRowLocation( RowPosition pos )
1:         throws StandardException
1:     {
1:         return new HeapRowLocation( pos.current_rh );
1:     }
1: 
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:86e051f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:fa09146
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
1: import org.apache.derby.iapi.types.RowLocation;
/////////////////////////////////////////////////////////////////////////
1: 	@see org.apache.derby.iapi.store.access.ScanController#next
/////////////////////////////////////////////////////////////////////////
1:      * @see org.apache.derby.iapi.store.access.ScanController#positionAtRowLocation
/////////////////////////////////////////////////////////////////////////
1: 	@see org.apache.derby.iapi.store.access.ScanController#fetchLocation
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d376440
/////////////////////////////////////////////////////////////////////////
1:      * Reposition the current scan and sets the necessary locks.
1:      *
1:      * @param rh An existing RecordHandle within the conglomerate,
1:      * at which to position the start of the scan.  The scan will begin at this
1:      * location and continue forward until the end of the conglomerate.  
1:      * Positioning at a non-existent RowLocation (ie. an invalid one or one that
1:      * had been deleted), will result in an exception being thrown when the 
1:      * first next operation is attempted.
1:      * @return true if the scan was successfully repositioned
1:      *
1:      * @exception StandardException Standard exception policy.
1:      */
1:     private boolean reopenScanByRecordHandleAndSetLocks (RecordHandle rh) 
1:             throws StandardException 
1:     {
1:         if (rh == null) 
1:         {
1:             return (false);
1:         }
1:         
1:         // Unlock current position
1:         if (scan_position.current_rh != null) 
1:         {
1:             open_conglom.unlockPositionAfterRead(scan_position);
1:         }
1:         
1:         // Position scan at new row
1:         scan_position.current_rh = rh;
1:         scan_position.current_rh_qualified = false;
1:         
1:         // Latch page and reposition scan
1:         final boolean rowLocationDisappeared = 
1:             open_conglom.latchPageAndRepositionScan(scan_position);
1:         
1:         if (!rowLocationDisappeared)
1:         {
1:             setScanState(SCAN_INPROGRESS);
1:             open_conglom.lockPositionForRead
1:                 (scan_position, null, true, true);
1:         }
1:         
1:         // Unlatch page
1:         scan_position.unlatch();
1:         
1:         return (!rowLocationDisappeared);
1:     }
1: 
1:     /**
/////////////////////////////////////////////////////////////////////////
1:     /**
0:      * @see ScanController#positionAtRowLocation
1:      */
1:     public boolean positionAtRowLocation(RowLocation rl) throws StandardException {
1:         if (open_conglom.isClosed() && !rowLocationsInvalidated) 
1:         {
1:             reopenAfterEndTransaction();
1:         }
1:         
1:         if (rowLocationsInvalidated) 
1:         {
1:             return(false);
1:             
1:         } else {
1:             return(reopenScanByRecordHandleAndSetLocks
1:                 (((HeapRowLocation)rl).
1:                  getRecordHandle(open_conglom.getContainer())));
1:         }
1:     }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.heap.HeapScan
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.heap;
1: 
1: 
1: /**
1: 
1:   A heap scan object represents an instance of an scan on a heap conglomerate.
1: 
1: **/
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.ScanInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.raw.Page;
1: import org.apache.derby.iapi.store.raw.RecordHandle;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
1: import org.apache.derby.impl.store.access.conglomerate.GenericScanController;
1: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
1: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
0: import java.util.Hashtable;
0: import java.util.Vector;
1: 
1: class HeapScan 
1:     extends GenericScanController implements ScanManager
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1:     /**************************************************************************
1:      * Constants of HeapScan
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Fields of HeapScan
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * A 1 element array to turn fetchNext and fetch calls into 
1:      * fetchNextGroup calls.
1:      **/
1:     private DataValueDescriptor[][] fetchNext_one_slot_array = 
1:         new DataValueDescriptor[1][];
1: 
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1: 	/**
1: 	 ** The only constructor for a heap scan returns a scan in the
1: 	 ** closed state, the caller must call open.
1: 	 **/
1: 	
1: 	public HeapScan()
1: 	{
1: 	}
1: 
1:     /**************************************************************************
1:      * Protected concrete impl of abstract methods of 
1:      *     GenericController class:
1:      **************************************************************************
1:      */
1:     protected void queueDeletePostCommitWork(
1:     RowPosition pos)
1:         throws StandardException
1:     {
1:         TransactionManager xact_mgr = open_conglom.getXactMgr();
1: 
1:         xact_mgr.addPostCommitWork(
1:             new HeapPostCommit(
1:                 xact_mgr.getAccessManager(), 
0:                 (Heap) open_conglom.getConglomerate(),
0:                 pos.current_page.getPageNumber()));
1:     }
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of This class:
1:      **************************************************************************
1:      */
1:     protected void setRowLocationArray(
1:     RowLocation[]   rowloc_array,
1:     int             index,
1:     RowPosition     pos)
1:         throws StandardException
1:     {
1:         if (rowloc_array[index] == null)
1:         {
1:             rowloc_array[index] = new HeapRowLocation(pos.current_rh);
1:         }
1:         else
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(
1:                     rowloc_array[index] instanceof HeapRowLocation);
1:             }
1: 
1:             ((HeapRowLocation)rowloc_array[index]).setFrom(pos.current_rh);
1:         }
1:     }
1: 
1:     /**
1:     Fetch the row at the next position of the Scan.
1: 
1:     If there is a valid next position in the scan then
1: 	the value in the template storable row is replaced
1: 	with the value of the row at the current scan
1: 	position.  The columns of the template row must
1: 	be of the same type as the actual columns in the
1: 	underlying conglomerate.
1: 
1:     The resulting contents of templateRow after a fetchNext() 
1:     which returns false is undefined.
1: 
1:     The result of calling fetchNext(row) is exactly logically
1:     equivalent to making a next() call followed by a fetch(row)
1:     call.  This interface allows implementations to optimize 
1:     the 2 calls if possible.
1: 
1:     @param fetch_row The template row into which the value
1: 	of the next position in the scan is to be stored.
1: 
1:     @return True if there is a next position in the scan,
1: 	false if there isn't.
1: 
1: 	@exception StandardException Standard exception policy.
1:     **/
1:     public boolean fetchNext(DataValueDescriptor[] fetch_row)
1: 		throws StandardException
1: 	{
1:         // Turn this call into a group fetch of a 1 element group.
1:         if (fetch_row == null)
1:             fetchNext_one_slot_array[0] = RowUtil.EMPTY_ROW;
1:         else
1:             fetchNext_one_slot_array[0] = fetch_row;
1: 
1:         boolean ret_val = 
1:             fetchRows(
1:                 fetchNext_one_slot_array, 
1:                 (RowLocation[]) null,
1:                 (BackingStoreHashtable) null,
1:                 1,
1:                 (int[]) null) == 1;
1: 
1:         return(ret_val);
1:     }
1: 
1: 
1:     /**
0: 	@see ScanController#next
1: 	**/
1:     public boolean next()
1: 		throws StandardException
1: 	{
1:         // if there is no row template from the caller, we need to
1:         // read the row into something, Use the scratch row.
1:         // We could optimize this, if there are no qualifiers and read
1:         // into a zero column row, but callers should be using fetchNext()
1:         // instead.
0:         fetchNext_one_slot_array[0] = open_conglom.getRuntimeMem().get_scratch_row();
1: 
1:         boolean ret_val = 
1:             fetchRows(
1:                 fetchNext_one_slot_array, 
1:                 (RowLocation[]) null,
1:                 (BackingStoreHashtable) null,
1:                 1,
1:                 (int[]) null) == 1;
1: 
1:         return(ret_val);
1: 	}
1: 
1: 
1:     /**************************************************************************
1:      * Public Methods of ScanController interface:
1:      **************************************************************************
1:      */
1: 
1:     /**
0: 	@see ScanController#fetchLocation
1: 	**/
1: 	public void fetchLocation(RowLocation templateLocation)
1: 		throws StandardException
1: 	{
1: 		if (open_conglom.getContainer() == null  || 
1:             scan_position.current_rh == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.HEAP_SCAN_NOT_POSITIONED);
1:         }
1: 		HeapRowLocation hrl = (HeapRowLocation) templateLocation;
1: 		hrl.setFrom(scan_position.current_rh);
1: 	}
1: 
1:     public int fetchNextGroup(
1:     DataValueDescriptor[][] row_array,
1:     RowLocation[]           rowloc_array)
1:         throws StandardException
1: 	{
1:         return(
1:             fetchRows(
1:                 row_array, 
1:                 rowloc_array,
1:                 (BackingStoreHashtable) null,
1:                 row_array.length,
1:                 (int[]) null));
1:     }
1: 
1: 
1:     /**
1:      * Return ScanInfo object which describes performance of scan.
1:      * <p>
1:      * Return ScanInfo object which contains information about the current
1:      * scan.
1:      * <p>
1:      *
1:      * @see ScanInfo
1:      *
1: 	 * @return The ScanInfo object which contains info about current scan.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public ScanInfo getScanInfo()
1: 		throws StandardException
1:     {
1:         return(new HeapScanInfo(this));
1:     }
1: 
1:     /**
1:     Reposition the current scan.  This call is semantically the same as if
1:     the current scan had been closed and a openScan() had been called instead.
1:     The scan is reopened against the same conglomerate, and the scan
1:     is reopened with the same "scan column list", "hold" and "forUpdate"
1:     parameters passed in the original openScan.  
1:     <p>
1:     The statistics gathered by the scan are not reset to 0 by a reopenScan(),
1:     rather they continue to accumulate.
1:     <p>
1:     Note that this operation is currently only supported on Heap conglomerates.
1:     Also note that order of rows within are heap are not guaranteed, so for
1:     instance positioning at a RowLocation in the "middle" of a heap, then
1:     inserting more data, then continuing the scan is not guaranteed to see
1:     the new rows - they may be put in the "beginning" of the heap.
1: 
1: 	@param startRowLocation  An existing RowLocation within the conglomerate,
1:     at which to position the start of the scan.  The scan will begin at this
1:     location and continue forward until the end of the conglomerate.  
1:     Positioning at a non-existent RowLocation (ie. an invalid one or one that
1:     had been deleted), will result in an exception being thrown when the 
1:     first next operation is attempted.
1: 
1: 	@param qualifier An array of qualifiers which, applied
1: 	to each key, restrict the rows returned by the scan.  Rows
1: 	for which any one of the qualifiers returns false are not
1: 	returned by the scan. If null, all rows are returned.
1: 
1: 	@exception StandardException Standard exception policy.
1:     **/
1: 	public void reopenScanByRowLocation(
1:     RowLocation startRowLocation,
1:     Qualifier qualifier[][])
1:         throws StandardException
1:     {
1:         reopenScanByRecordHandle(
1:             ((HeapRowLocation) startRowLocation).getRecordHandle(
1:                  open_conglom.getContainer()),
1:             qualifier);
1:     }
1: 
1: 
1: 	/*
0: 	** Methods of ScanManager
1: 	*/
1: 
1:     /**
0:      * Do work necessary to maintain the current position in the scan.
1:      * <p>
0:      * The latched page in the conglomerate "congomid" is changing, do
0:      * whatever is necessary to maintain the current position of the scan.
0:      * For some conglomerates this may be a no-op.
1:      * <p>
1:      *
0:      * @param conglom   Conglomerate being changed.
0:      * @param page      Page in the conglomerate being changed.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     public void savePosition(Conglomerate conglom, Page page)
1:         throws StandardException
1: 	{
0:         // RESOLVE (mikem), under the current implementation all scans within
0:         // a transaction are called rather than just the ones with the right
0:         // conglom.  For now just have heaps ignore the call. 
1:         
0: 		// throw HeapOperationException.unimplementedFeature();
0:         return;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.heap
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.heap;
0: 
0: 
0: /**
0: 
0:   A heap scan object represents an instance of an scan on a heap conglomerate.
0: 
0: **/
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.ScanManager;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.ScanInfo;
0: import org.apache.derby.iapi.store.access.ScanController;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.impl.store.access.conglomerate.ConglomerateUtil;
0: import org.apache.derby.impl.store.access.conglomerate.GenericScanController;
0: import org.apache.derby.impl.store.access.conglomerate.RowPosition;
0: 
0: import org.apache.derby.iapi.store.access.BackingStoreHashtable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: import java.util.Hashtable;
0: import java.util.Vector;
0: 
0: class HeapScan 
0:     extends GenericScanController implements ScanManager
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0:     /**************************************************************************
0:      * Constants of HeapScan
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Fields of HeapScan
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * A 1 element array to turn fetchNext and fetch calls into 
0:      * fetchNextGroup calls.
0:      **/
0:     private DataValueDescriptor[][] fetchNext_one_slot_array = 
0:         new DataValueDescriptor[1][];
0: 
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 
0: 	/**
0: 	 ** The only constructor for a heap scan returns a scan in the
0: 	 ** closed state, the caller must call open.
0: 	 **/
0: 	
0: 	public HeapScan()
0: 	{
0: 	}
0: 
0:     /**************************************************************************
0:      * Protected concrete impl of abstract methods of 
0:      *     GenericController class:
0:      **************************************************************************
0:      */
0:     protected void queueDeletePostCommitWork(
0:     RowPosition pos)
0:         throws StandardException
0:     {
0:         TransactionManager xact_mgr = open_conglom.getXactMgr();
0: 
0:         xact_mgr.addPostCommitWork(
0:             new HeapPostCommit(
0:                 xact_mgr.getAccessManager(), 
0:                 (Heap) open_conglom.getConglomerate(),
0:                 pos.current_page.getPageNumber()));
0:     }
0: 
0:     /**************************************************************************
0:      * Private/Protected methods of This class:
0:      **************************************************************************
0:      */
0:     protected void setRowLocationArray(
0:     RowLocation[]   rowloc_array,
0:     int             index,
0:     RowPosition     pos)
0:         throws StandardException
0:     {
0:         if (rowloc_array[index] == null)
0:         {
0:             rowloc_array[index] = new HeapRowLocation(pos.current_rh);
0:         }
0:         else
0:         {
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(
0:                     rowloc_array[index] instanceof HeapRowLocation);
0:             }
0: 
0:             ((HeapRowLocation)rowloc_array[index]).setFrom(pos.current_rh);
0:         }
0:     }
0: 
0:     /**
0:     Fetch the row at the next position of the Scan.
0: 
0:     If there is a valid next position in the scan then
0: 	the value in the template storable row is replaced
0: 	with the value of the row at the current scan
0: 	position.  The columns of the template row must
0: 	be of the same type as the actual columns in the
0: 	underlying conglomerate.
0: 
0:     The resulting contents of templateRow after a fetchNext() 
0:     which returns false is undefined.
0: 
0:     The result of calling fetchNext(row) is exactly logically
0:     equivalent to making a next() call followed by a fetch(row)
0:     call.  This interface allows implementations to optimize 
0:     the 2 calls if possible.
0: 
0:     @param fetch_row The template row into which the value
0: 	of the next position in the scan is to be stored.
0: 
0:     @return True if there is a next position in the scan,
0: 	false if there isn't.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0:     public boolean fetchNext(DataValueDescriptor[] fetch_row)
0: 		throws StandardException
0: 	{
0:         // Turn this call into a group fetch of a 1 element group.
0:         if (fetch_row == null)
0:             fetchNext_one_slot_array[0] = RowUtil.EMPTY_ROW;
0:         else
0:             fetchNext_one_slot_array[0] = fetch_row;
0: 
0:         boolean ret_val = 
0:             fetchRows(
0:                 fetchNext_one_slot_array, 
0:                 (RowLocation[]) null,
0:                 (BackingStoreHashtable) null,
0:                 1,
0:                 (int[]) null) == 1;
0: 
0:         return(ret_val);
0:     }
0: 
0: 
0:     /**
0: 	@see ScanController#next
0: 	**/
0:     public boolean next()
0: 		throws StandardException
0: 	{
0:         // if there is no row template from the caller, we need to
0:         // read the row into something, Use the scratch row.
0:         // We could optimize this, if there are no qualifiers and read
0:         // into a zero column row, but callers should be using fetchNext()
0:         // instead.
0:         fetchNext_one_slot_array[0] = open_conglom.getRuntimeMem().get_scratch_row();
0: 
0:         boolean ret_val = 
0:             fetchRows(
0:                 fetchNext_one_slot_array, 
0:                 (RowLocation[]) null,
0:                 (BackingStoreHashtable) null,
0:                 1,
0:                 (int[]) null) == 1;
0: 
0:         return(ret_val);
0: 	}
0: 
0: 
0:     /**************************************************************************
0:      * Public Methods of ScanController interface:
0:      **************************************************************************
0:      */
0: 
0:     /**
0: 	@see ScanController#fetchLocation
0: 	**/
0: 	public void fetchLocation(RowLocation templateLocation)
0: 		throws StandardException
0: 	{
0: 		if (open_conglom.getContainer() == null  || 
0:             scan_position.current_rh == null)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.HEAP_SCAN_NOT_POSITIONED);
0:         }
0: 		HeapRowLocation hrl = (HeapRowLocation) templateLocation;
0: 		hrl.setFrom(scan_position.current_rh);
0: 	}
0: 
0:     public int fetchNextGroup(
0:     DataValueDescriptor[][] row_array,
0:     RowLocation[]           rowloc_array)
0:         throws StandardException
0: 	{
0:         return(
0:             fetchRows(
0:                 row_array, 
0:                 rowloc_array,
0:                 (BackingStoreHashtable) null,
0:                 row_array.length,
0:                 (int[]) null));
0:     }
0: 
0: 
0:     /**
0:      * Return ScanInfo object which describes performance of scan.
0:      * <p>
0:      * Return ScanInfo object which contains information about the current
0:      * scan.
0:      * <p>
0:      *
0:      * @see ScanInfo
0:      *
0: 	 * @return The ScanInfo object which contains info about current scan.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public ScanInfo getScanInfo()
0: 		throws StandardException
0:     {
0:         return(new HeapScanInfo(this));
0:     }
0: 
0:     /**
0:     Reposition the current scan.  This call is semantically the same as if
0:     the current scan had been closed and a openScan() had been called instead.
0:     The scan is reopened against the same conglomerate, and the scan
0:     is reopened with the same "scan column list", "hold" and "forUpdate"
0:     parameters passed in the original openScan.  
0:     <p>
0:     The statistics gathered by the scan are not reset to 0 by a reopenScan(),
0:     rather they continue to accumulate.
0:     <p>
0:     Note that this operation is currently only supported on Heap conglomerates.
0:     Also note that order of rows within are heap are not guaranteed, so for
0:     instance positioning at a RowLocation in the "middle" of a heap, then
0:     inserting more data, then continuing the scan is not guaranteed to see
0:     the new rows - they may be put in the "beginning" of the heap.
0: 
0: 	@param startRowLocation  An existing RowLocation within the conglomerate,
0:     at which to position the start of the scan.  The scan will begin at this
0:     location and continue forward until the end of the conglomerate.  
0:     Positioning at a non-existent RowLocation (ie. an invalid one or one that
0:     had been deleted), will result in an exception being thrown when the 
0:     first next operation is attempted.
0: 
0: 	@param qualifier An array of qualifiers which, applied
0: 	to each key, restrict the rows returned by the scan.  Rows
0: 	for which any one of the qualifiers returns false are not
0: 	returned by the scan. If null, all rows are returned.
0: 
0: 	@exception StandardException Standard exception policy.
0:     **/
0: 	public void reopenScanByRowLocation(
0:     RowLocation startRowLocation,
0:     Qualifier qualifier[][])
0:         throws StandardException
0:     {
0:         reopenScanByRecordHandle(
0:             ((HeapRowLocation) startRowLocation).getRecordHandle(
0:                  open_conglom.getContainer()),
0:             qualifier);
0:     }
0: 
0: 
0: 	/*
0: 	** Methods of ScanManager
0: 	*/
0: 
0:     /**
0:      * Do work necessary to maintain the current position in the scan.
0:      * <p>
0:      * The latched page in the conglomerate "congomid" is changing, do
0:      * whatever is necessary to maintain the current position of the scan.
0:      * For some conglomerates this may be a no-op.
0:      * <p>
0:      *
0:      * @param conglom   Conglomerate being changed.
0:      * @param page      Page in the conglomerate being changed.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void savePosition(Conglomerate conglom, Page page)
0:         throws StandardException
0: 	{
0:         // RESOLVE (mikem), under the current implementation all scans within
0:         // a transaction are called rather than just the ones with the right
0:         // conglom.  For now just have heaps ignore the call. 
0:         
0: 		// throw HeapOperationException.unimplementedFeature();
0:         return;
0: 	}
0: }
============================================================================