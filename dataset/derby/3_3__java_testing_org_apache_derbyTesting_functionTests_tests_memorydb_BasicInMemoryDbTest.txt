1:497dc13: /*
3:497dc13: 
1:497dc13:    Derby - Class org.apache.derbyTesting.functionTests.tests.memorydb.BasicInMemoryDbTest
1:497dc13: 
1:497dc13:        Licensed to the Apache Software Foundation (ASF) under one
1:497dc13:        or more contributor license agreements.  See the NOTICE file
1:497dc13:        distributed with this work for additional information
1:497dc13:        regarding copyright ownership.  The ASF licenses this file
1:497dc13:        to you under the Apache License, Version 2.0 (the
1:497dc13:        "License"); you may not use this file except in compliance
1:497dc13:        with the License.  You may obtain a copy of the License at
1:497dc13: 
1:497dc13:          http://www.apache.org/licenses/LICENSE-2.0
1:497dc13: 
1:497dc13:        Unless required by applicable law or agreed to in writing,
1:497dc13:        software distributed under the License is distributed on an
1:497dc13:        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:497dc13:        KIND, either express or implied.  See the License for the
1:497dc13:        specific language governing permissions and limitations
1:497dc13:        under the License
1:497dc13: */
1:497dc13: package org.apache.derbyTesting.functionTests.tests.memorydb;
1:497dc13: 
1:497dc13: import java.io.File;
1:497dc13: import java.io.IOException;
1:497dc13: import java.sql.CallableStatement;
1:497dc13: import java.sql.Connection;
1:497dc13: import java.sql.DriverManager;
1:497dc13: import java.sql.PreparedStatement;
1:497dc13: import java.sql.ResultSet;
1:497dc13: import java.sql.SQLException;
1:497dc13: import java.sql.Statement;
1:497dc13: import junit.framework.Test;
1:497dc13: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1:497dc13: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1:497dc13: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1:497dc13: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:497dc13: import org.apache.derbyTesting.junit.JDBC;
1:497dc13: import org.apache.derbyTesting.junit.SupportFilesSetup;
1:497dc13: 
1:497dc13: /**
1:497dc13:  * Basic tests of the in-memory db storage back end.
1:497dc13:  */
1:497dc13: public class BasicInMemoryDbTest
1:497dc13:         extends BaseJDBCTestCase {
1:497dc13: 
1:88e75e5:     /**
1:88e75e5:      * Helper for dealing with memory databases. For now we use a single
1:88e75e5:      * instance for all test classes / cases, as the tests are run single
1:88e75e5:      * threaded.
1:88e75e5:      */
1:88e75e5:     private static final MemoryDbManager dbm =
1:88e75e5:             MemoryDbManager.getSharedInstance();
1:88e75e5: 
1:497dc13:     public BasicInMemoryDbTest(String name) {
1:497dc13:         super(name);
1:497dc13:     }
1:497dc13: 
1:d5036cd:     /**
1:88e75e5:      * Closes all opened statements and connections that are known, and also
1:88e75e5:      * deletes all known in-memory databases.
1:88e75e5:      *
1:88e75e5:      * @throws Exception if something goes wrong
1:88e75e5:      */
1:88e75e5:     public void tearDown()
1:88e75e5:             throws Exception {
1:88e75e5:         dbm.cleanUp();
1:04c0d4e:         super.tearDown();
1:04c0d4e:     }
1:04c0d4e: 
1:04c0d4e:     /**
1:04c0d4e:      * Helper method to make sure the driver is loaded. May be needed when
1:04c0d4e:      * calling DriverManager.getConnection() directly since the driver may
1:04c0d4e:      * not already be loaded (in particular when running from classes so that
1:04c0d4e:      * driver auto-loading doesn't come into play), or it may have been
1:04c0d4e:      * unloaded by an engine shutdown in an earlier test case.
1:04c0d4e:      */
1:04c0d4e:     private void loadDriver() throws SQLException {
1:04c0d4e:         // If we get a default connection through the framework, the driver
1:04c0d4e:         // will be loaded implicitly.
1:04c0d4e:         getConnection();
1:88e75e5:     }
1:88e75e5: 
1:88e75e5:     /**
1:497dc13:      * Tries to connect to a non-existing database with the in-memory protocol,
1:497dc13:      * expecting an error saying the database doesn't exist.
1:497dc13:      */
1:497dc13:     public void testFunctionalityPresent() {
1:497dc13:         try {
1:88e75e5:             dbm.getConnection("nonExistingDb");
1:497dc13:         } catch (SQLException e) {
1:497dc13:             // Expect a database not found exception.
1:497dc13:             assertSQLState("XJ004", e);
1:497dc13:         }
1:497dc13:     }
1:497dc13: 
1:5bef31e:     /**
1:497dc13:      * Performs a cycle to test that the in-memory db is compatible with the
1:497dc13:      * deafult directory protocol.
1:497dc13:      * <p>
1:497dc13:      * <ol> <li>Create an in-memory db and add a table with a few rows.</li>
1:497dc13:      *      <li>Backup to disk.</li>
1:497dc13:      *      <li>Boot the database with the directory (default) protocol.</li>
1:497dc13:      *      <li>Verify content, add a new row, shutdown.</li>
1:497dc13:      *      <li>Use createFrom to restore database from disk into the in-memory
1:497dc13:      *          representation.</li>
1:497dc13:      *      <li>Verify new content.</li>
1:497dc13:      * </ol>
1:497dc13:      *
1:497dc13:      * @throws IOException if something goes wrong
1:497dc13:      * @throws SQLException if something goes wrong
1:497dc13:      */
1:497dc13:     public void testCreateBackupBootRestore()
1:497dc13:             throws IOException, SQLException {
1:497dc13:         // 1. Create the database with the in-memory protocol.
1:88e75e5:         Connection memCon = dbm.createDatabase("newMemDb");
1:497dc13:         // Make sure the database is newly created.
1:497dc13:         assertNull(memCon.getWarnings());
1:88e75e5:         Statement stmt = dbm.createStatement(memCon);
1:497dc13:         stmt.executeUpdate("create table toverify(" +
1:497dc13:                 "id int, val1 varchar(10), val2 clob, primary key(id))");
1:88e75e5:         PreparedStatement ps = dbm.prepareStatement(memCon,
1:88e75e5:                 "insert into toverify values (?,?,?)");
1:497dc13:         // The content to insert into the table.
1:497dc13:         String[][] firstContent = new String[][] {
1:497dc13:             {"1", "one", getString(1000, CharAlphabet.modernLatinLowercase())},
1:497dc13:             {"2", "two", getString(10000, CharAlphabet.tamil())},
1:497dc13:             {"3", "three", getString(50000, CharAlphabet.cjkSubset())}
1:497dc13:         };
1:497dc13:         for (int i=0; i < firstContent.length; i++) {
1:497dc13:             ps.setString(1, firstContent[i][0]);
1:497dc13:             ps.setString(2, firstContent[i][1]);
1:497dc13:             ps.setString(3, firstContent[i][2]);
1:497dc13:             ps.executeUpdate();
1:497dc13:         }
1:497dc13:         ResultSet rs = stmt.executeQuery("select * from toverify");
1:497dc13:         JDBC.assertFullResultSet(rs, firstContent);
1:497dc13:         ps.close();
2:497dc13:         stmt.close();
1:497dc13: 
1:497dc13:         // 2. Backup the database.
1:497dc13:         String dbPath = SupportFilesSetup.getReadWrite("backedUpDb").getPath();
1:497dc13:         CallableStatement cs = memCon.prepareCall(
1:497dc13:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
1:497dc13:         cs.setString(1, dbPath);
1:497dc13:         cs.execute();
2:497dc13:         memCon.close();
1:497dc13: 
1:497dc13:         // 3. Open the database with the default protocol.
1:497dc13:         String dbPathBackedUp = PrivilegedFileOpsForTests.getAbsolutePath(
1:497dc13:                 new File(dbPath, "newMemDb"));
1:497dc13:         Connection dirCon = DriverManager.getConnection(
1:497dc13:                 "jdbc:derby:" + dbPathBackedUp);
1:497dc13:         // 4. Verify content, then add one more row.
1:497dc13:         stmt = dirCon.createStatement();
1:497dc13:         rs = stmt.executeQuery("select * from toverify");
1:497dc13:         JDBC.assertFullResultSet(rs, firstContent);
1:497dc13:         ps = dirCon.prepareStatement("insert into toverify values (?,?,?)");
1:497dc13:         String[] rowToAdd = new String[] {
1:497dc13:             "4", "four", getString(32*1024, CharAlphabet.tamil())};
1:497dc13:         ps.setString(1, rowToAdd[0]);
1:497dc13:         ps.setString(2, rowToAdd[1]);
1:497dc13:         ps.setString(3, rowToAdd[2]);
1:497dc13:         ps.executeUpdate();
1:497dc13:         ps.close();
1:497dc13:         dirCon.close();
1:497dc13:         // Shutdown.
1:497dc13:         try {
1:497dc13:             DriverManager.getConnection(
1:497dc13:                 "jdbc:derby:" + dbPathBackedUp + ";shutdown=true");
1:497dc13:         } catch (SQLException sqle) {
1:497dc13:             assertSQLState("08006", sqle);
1:497dc13:         }
1:497dc13: 
1:497dc13:         // 5. Restore modified backup into memory.
1:88e75e5:         memCon = dbm.getConnection("newMemDb2;createFrom=" + dbPathBackedUp);
1:497dc13: 
1:497dc13:         // 6. Verify the new content, where the original in-memory database was
1:497dc13:         //    backed up and the directory protocol was used to add one more row
1:497dc13:         //    to the backed up database. Now we have restored the on-disk
1:497dc13:         //    modified backup, again representing it as an in-memory database.
1:88e75e5:         stmt = dbm.createStatement(memCon);
1:497dc13:         rs = stmt.executeQuery("select * from toverify");
1:497dc13:         String[][] secondContent = new String[4][3];
1:497dc13:         System.arraycopy(firstContent, 0, secondContent, 0, 3);
1:497dc13:         System.arraycopy(rowToAdd, 0, secondContent[3], 0, 3);
1:497dc13:         JDBC.assertFullResultSet(rs, secondContent);
1:497dc13: 
1:88e75e5:         // Delete the second in memory database.
1:88e75e5:         dbm.dropDatabase("newMemDb2");
1:497dc13:     }
1:497dc13: 
1:497dc13:     /**
1:d5036cd:      * Makes sure shutting down an in-memory database works.
1:d5036cd:      *
1:d5036cd:      * @throws SQLException if something goes wrong
1:d5036cd:      */
1:d5036cd:     public void testShutdown()
1:d5036cd:             throws SQLException {
1:88e75e5:         dbm.createDatabase("/tmp/myDB");
1:d5036cd:         try {
1:d5036cd:             DriverManager.getConnection(
1:d5036cd:                     "jdbc:derby:memory:/tmp/myDB;shutdown=true");
1:d5036cd:             fail("Engine shutdown should have caused exception");
1:d5036cd:         } catch (SQLException sqle) {
1:d5036cd:             assertSQLState("08006", sqle);
1:d5036cd:         }
1:d5036cd:     }
1:d5036cd: 
1:d5036cd:     /**
1:d5036cd:      * Makes sure shutting down the Derby engine with an in-memory database
1:d5036cd:      * already booted works.
1:d5036cd:      * <p>
1:d5036cd:      * Related to DERBY-4093
1:d5036cd:      *
1:d5036cd:      * @throws SQLException if something goes wrong
1:d5036cd:      */
1:d5036cd:     public void testEnginehutdown()
1:d5036cd:             throws SQLException {
1:04c0d4e:         dbm.createDatabase("/tmp/myDB");
1:d5036cd:         try {
1:d5036cd:             DriverManager.getConnection(
1:d5036cd:                     "jdbc:derby:;shutdown=true");
1:d5036cd:             fail("Engine shutdown should have caused exception");
1:d5036cd:         } catch (SQLException sqle) {
1:d5036cd:             assertSQLState("XJ015", sqle);
1:d5036cd:         }
1:d5036cd:         // Another hack, to make sure later tests in this class doesn't fail.
1:d5036cd:         // Get a connection to the default database to reload the engine.
1:04c0d4e:         loadDriver();
1:d5036cd:     }
1:d5036cd: 
1:497dc13:     /**
1:5bef31e:      * Verify that booting two databases with the same name but with different
1:5bef31e:      * subsubprotocols doesn't result in two connections to the same database.
1:5bef31e:      *
1:5bef31e:      * @throws SQLException if something goes wrong
1:5bef31e:      */
1:5bef31e:     public void testBootSameDbDifferentSubSubProtocol()
1:5bef31e:             throws SQLException {
1:5bef31e:         final String dbName = "BSDDSSP";
1:5bef31e:         // Connect to the in-memory database and create a table.
1:88e75e5:         Connection con1 = dbm.createDatabase(dbName);
1:88e75e5:         Statement stmt1 = dbm.createStatement(con1);
1:5bef31e:         stmt1.execute("create table t (text varchar(255))");
1:5bef31e:         stmt1.execute("insert into t values ('Inserted into in-memory db')");
1:5bef31e:         // Connect to the on-disk database. The table we created in the
1:5bef31e:         // in-memory database shouldn't exist in the on-disk database.
1:5bef31e:         Connection con2 = DriverManager.getConnection(
1:5bef31e:                 "jdbc:derby:" + dbName + ";create=true");
1:5bef31e:         // Table t should not exist.
1:5bef31e:         Statement stmt2 = con2.createStatement();
1:5bef31e:         try {
1:5bef31e:             stmt2.executeQuery("select * from t");
1:5bef31e:             fail("Table 't' should not exist");
1:5bef31e:         } catch (SQLException sqle) {
1:5bef31e:             assertSQLState("42X05", sqle);
1:5bef31e:         }
1:5bef31e:         con2.close();
1:88e75e5:     }
1:88e75e5: 
1:88e75e5:     /**
1:88e75e5:      * Test deletion of an in-memory database:
1:88e75e5:      *  - create database
1:88e75e5:      *  - delete database
1:88e75e5:      *  - try to connection to database, should fail
1:88e75e5:      *  - recreate and delete again
1:88e75e5:      *
1:88e75e5:      * @throws SQLException if something else goes wrong
1:88e75e5:      */
1:c406220:     public void testDelete()
1:88e75e5:             throws SQLException {
1:04c0d4e:             loadDriver();
1:88e75e5:             Connection conCreate = DriverManager.getConnection(
1:88e75e5:                     "jdbc:derby:memory:deleteDbSimple;create=true");
1:88e75e5:             Statement stmt = dbm.createStatement(conCreate);
1:88e75e5:             JDBC.assertDrainResults(stmt.executeQuery(
1:88e75e5:                     "select * from sys.systables"));
1:88e75e5:             // Delete the database.
1:88e75e5:             try {
1:88e75e5:                 DriverManager.getConnection(
1:c406220:                     "jdbc:derby:memory:deleteDbSimple;drop=true");
1:88e75e5:                 fail("Dropping database should have raised exception.");
1:88e75e5:             } catch (SQLException sqle) {
1:88e75e5:                 assertSQLState("08006", sqle);
1:88e75e5:             }
1:88e75e5:             // Try to connect to the database again, without creation.
1:88e75e5:             try {
1:88e75e5:                 DriverManager.getConnection(
1:88e75e5:                     "jdbc:derby:memory:deleteDbSimple;create=false");
1:88e75e5:                 fail("Database should not exist after deletion.");
1:88e75e5:             } catch (SQLException sqle) {
1:88e75e5:                 assertSQLState("XJ004", sqle);
1:88e75e5:             }
1:88e75e5: 
1:88e75e5:             // Recreate and delete again.
1:88e75e5:             conCreate = DriverManager.getConnection(
1:88e75e5:                     "jdbc:derby:memory:deleteDbSimple;create=true");
1:88e75e5:             stmt = dbm.createStatement(conCreate);
1:88e75e5:             JDBC.assertDrainResults(stmt.executeQuery(
1:88e75e5:                     "select * from sys.systables"));
1:88e75e5:             // Delete the database.
1:88e75e5:             try {
1:88e75e5:                 DriverManager.getConnection(
1:88e75e5:                     "jdbc:derby:memory:deleteDbSimple;drop=true");
1:88e75e5:                 fail("Dropping database should have raised exception.");
1:88e75e5:             } catch (SQLException sqle) {
1:88e75e5:                 assertSQLState("08006", sqle);
1:88e75e5:             }
1:88e75e5:     }
1:88e75e5: 
1:88e75e5:     /**
1:88e75e5:      * Deletes the database when in use by a different connection.
1:88e75e5:      * <p>
1:88e75e5:      * The expected outcome is that the first connection will be closed when
1:88e75e5:      * the second one deletes the database.
1:88e75e5:      *
1:88e75e5:      * @throws IOException if something goes wrong
1:88e75e5:      * @throws SQLException if something goes wrong
1:88e75e5:      */
1:c406220:     public void testDeleteWhenInUse()
1:88e75e5:             throws IOException, SQLException {
1:04c0d4e:         loadDriver();
1:88e75e5:         Connection con = DriverManager.getConnection(
1:88e75e5:                 "jdbc:derby:memory:deleteDb;create=true");
1:88e75e5:         PreparedStatement ps = dbm.prepareStatement(con,
1:88e75e5:                 "select * from sys.systables");
1:88e75e5:         JDBC.assertDrainResults(ps.executeQuery());
1:88e75e5:         // Delete the database.
1:88e75e5:         try {
1:88e75e5:             DriverManager.getConnection(
1:88e75e5:                 "jdbc:derby:memory:deleteDb;drop=true");
1:88e75e5:             fail("Dropping database should have raised exception.");
1:88e75e5:         } catch (SQLException sqle) {
1:88e75e5:             assertSQLState("08006", sqle);
1:88e75e5:         }
1:88e75e5:         // Execute query from first connection again.
1:88e75e5:         assertTrue(con.isClosed());
1:88e75e5:         try {
1:88e75e5:             JDBC.assertDrainResults(ps.executeQuery());
1:88e75e5:             fail("Database has been dropped, query shouldn't work.");
1:88e75e5:         } catch (SQLException sqle) {
1:88e75e5:             // Expect no current connection.
1:88e75e5:             assertSQLState("08003", sqle);
1:88e75e5:         }
1:88e75e5:     }
1:88e75e5: 
1:88e75e5:     /**
1:88e75e5:      * Shuts down the database when in use by a different connection.
1:88e75e5:      * <p>
1:88e75e5:      * The expected outcome is that the first connection will be closed when
1:88e75e5:      * the second one shuts down the database.
1:88e75e5:      *
1:88e75e5:      * @throws IOException if something goes wrong
1:88e75e5:      * @throws SQLException if something goes wrong
1:88e75e5:      */
1:88e75e5:     public void testShutdownWhenInUse()
1:88e75e5:             throws IOException, SQLException {
1:88e75e5:         Connection con = dbm.createDatabase("deleteDb");
1:88e75e5:         PreparedStatement ps = dbm.prepareStatement(con,
1:88e75e5:                 "select * from sys.systables");
1:88e75e5:         JDBC.assertDrainResults(ps.executeQuery());
1:88e75e5:         // Delete the database.
1:88e75e5:         try {
1:88e75e5:             DriverManager.getConnection(
1:88e75e5:                 "jdbc:derby:memory:deleteDb;shutdown=true");
1:88e75e5:             fail("Database shutdown should have raised exception.");
1:88e75e5:         } catch (SQLException sqle) {
1:88e75e5:             assertSQLState("08006", sqle);
1:88e75e5:         }
1:88e75e5:         // Execute query from first connection again.
1:88e75e5:         assertTrue(con.isClosed());
1:88e75e5:         try {
1:88e75e5:             JDBC.assertDrainResults(ps.executeQuery());
1:88e75e5:             fail("Database has been shut down, query shouldn't work.");
1:88e75e5:         } catch (SQLException sqle) {
1:88e75e5:             // Expect no current connection.
1:88e75e5:             assertSQLState("08003", sqle);
1:88e75e5:         }
1:5bef31e:     }
1:5bef31e: 
1:497dc13:     public static Test suite() {
1:497dc13:         // Run only in embedded-mode for now.
1:1ae02c9:         return new SupportFilesSetup(
1:1ae02c9:             new BaseTestSuite(BasicInMemoryDbTest.class));
1:497dc13:     }
1:497dc13: 
1:497dc13:     /**
1:497dc13:      * Generates a string.
1:497dc13:      *
1:497dc13:      * @param length length of the string
1:497dc13:      * @param alphabet the alphabet to use for the content
1:497dc13:      * @return A string.
1:497dc13:      * @throws IOException if reading from the source stream fails
1:497dc13:      */
1:497dc13:     public static String getString(int length, CharAlphabet alphabet)
1:497dc13:             throws IOException {
1:497dc13:         LoopingAlphabetReader reader =
1:497dc13:                 new LoopingAlphabetReader(length, alphabet);
1:497dc13:         char[] strChar = new char[length];
1:497dc13:         int read = 0;
1:497dc13:         while (read < length) {
1:497dc13:             int readNow = reader.read(strChar, read, length - read);
1:497dc13:             if (readNow < 1) {
1:497dc13:                 fail("Creating string failed, stream returned " + readNow);
1:497dc13:             }
1:497dc13:             read += readNow;
1:497dc13:         }
1:497dc13:         return String.copyValueOf(strChar);
1:497dc13:     }
1:497dc13: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         return new SupportFilesSetup(
1:             new BaseTestSuite(BasicInMemoryDbTest.class));
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:04c0d4e
/////////////////////////////////////////////////////////////////////////
1:         super.tearDown();
1:     }
1: 
1:     /**
1:      * Helper method to make sure the driver is loaded. May be needed when
1:      * calling DriverManager.getConnection() directly since the driver may
1:      * not already be loaded (in particular when running from classes so that
1:      * driver auto-loading doesn't come into play), or it may have been
1:      * unloaded by an engine shutdown in an earlier test case.
1:      */
1:     private void loadDriver() throws SQLException {
1:         // If we get a default connection through the framework, the driver
1:         // will be loaded implicitly.
1:         getConnection();
/////////////////////////////////////////////////////////////////////////
1:         dbm.createDatabase("/tmp/myDB");
/////////////////////////////////////////////////////////////////////////
1:         loadDriver();
/////////////////////////////////////////////////////////////////////////
1:             loadDriver();
/////////////////////////////////////////////////////////////////////////
1:         loadDriver();
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:c406220
/////////////////////////////////////////////////////////////////////////
1:     public void testDelete()
/////////////////////////////////////////////////////////////////////////
1:                     "jdbc:derby:memory:deleteDbSimple;drop=true");
/////////////////////////////////////////////////////////////////////////
1:     public void testDeleteWhenInUse()
commit:88e75e5
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Helper for dealing with memory databases. For now we use a single
1:      * instance for all test classes / cases, as the tests are run single
1:      * threaded.
1:      */
1:     private static final MemoryDbManager dbm =
1:             MemoryDbManager.getSharedInstance();
1: 
1:      * Closes all opened statements and connections that are known, and also
1:      * deletes all known in-memory databases.
1:      *
1:      * @throws Exception if something goes wrong
1:      */
1:     public void tearDown()
1:             throws Exception {
1:         dbm.cleanUp();
1:     }
1: 
1:     /**
1:             dbm.getConnection("nonExistingDb");
/////////////////////////////////////////////////////////////////////////
1:         Connection memCon = dbm.createDatabase("newMemDb");
1:         Statement stmt = dbm.createStatement(memCon);
1:         PreparedStatement ps = dbm.prepareStatement(memCon,
1:                 "insert into toverify values (?,?,?)");
/////////////////////////////////////////////////////////////////////////
1:         memCon = dbm.getConnection("newMemDb2;createFrom=" + dbPathBackedUp);
1:         stmt = dbm.createStatement(memCon);
1:         // Delete the second in memory database.
1:         dbm.dropDatabase("newMemDb2");
/////////////////////////////////////////////////////////////////////////
1:         dbm.createDatabase("/tmp/myDB");
/////////////////////////////////////////////////////////////////////////
1:         Connection con1 = dbm.createDatabase(dbName);
1:         Statement stmt1 = dbm.createStatement(con1);
/////////////////////////////////////////////////////////////////////////
1:     }
1: 
1:     /**
1:      * Test deletion of an in-memory database:
1:      *  - create database
1:      *  - delete database
1:      *  - try to connection to database, should fail
1:      *  - recreate and delete again
1:      *
1:      * @throws SQLException if something else goes wrong
1:      */
0:     // DISABLED because the feature isn't implemented yet (see DERBY-4428)
0:     public void DISABLED_testDelete()
1:             throws SQLException {
1:             Connection conCreate = DriverManager.getConnection(
1:                     "jdbc:derby:memory:deleteDbSimple;create=true");
1:             Statement stmt = dbm.createStatement(conCreate);
1:             JDBC.assertDrainResults(stmt.executeQuery(
1:                     "select * from sys.systables"));
1:             // Delete the database.
1:             try {
1:                 DriverManager.getConnection(
1:                     "jdbc:derby:memory:deleteDbSimple;drop=true");
1:                 fail("Dropping database should have raised exception.");
1:             } catch (SQLException sqle) {
1:                 assertSQLState("08006", sqle);
1:             }
1:             // Try to connect to the database again, without creation.
1:             try {
1:                 DriverManager.getConnection(
1:                     "jdbc:derby:memory:deleteDbSimple;create=false");
1:                 fail("Database should not exist after deletion.");
1:             } catch (SQLException sqle) {
1:                 assertSQLState("XJ004", sqle);
1:             }
1: 
1:             // Recreate and delete again.
1:             conCreate = DriverManager.getConnection(
1:                     "jdbc:derby:memory:deleteDbSimple;create=true");
1:             stmt = dbm.createStatement(conCreate);
1:             JDBC.assertDrainResults(stmt.executeQuery(
1:                     "select * from sys.systables"));
1:             // Delete the database.
1:             try {
1:                 DriverManager.getConnection(
0:                     "jdbc:derby:memory:deleteDbSimple;delete=true");
1:                 fail("Dropping database should have raised exception.");
1:             } catch (SQLException sqle) {
1:                 assertSQLState("08006", sqle);
1:             }
1:     }
1: 
1:     /**
1:      * Deletes the database when in use by a different connection.
1:      * <p>
1:      * The expected outcome is that the first connection will be closed when
1:      * the second one deletes the database.
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
0:     // DISABLED because the feature isn't implemented yet (see DERBY-4428)
0:     public void DISABLED_testDeleteWhenInUse()
1:             throws IOException, SQLException {
1:         Connection con = DriverManager.getConnection(
1:                 "jdbc:derby:memory:deleteDb;create=true");
1:         PreparedStatement ps = dbm.prepareStatement(con,
1:                 "select * from sys.systables");
1:         JDBC.assertDrainResults(ps.executeQuery());
1:         // Delete the database.
1:         try {
1:             DriverManager.getConnection(
1:                 "jdbc:derby:memory:deleteDb;drop=true");
1:             fail("Dropping database should have raised exception.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08006", sqle);
1:         }
1:         // Execute query from first connection again.
1:         assertTrue(con.isClosed());
1:         try {
1:             JDBC.assertDrainResults(ps.executeQuery());
1:             fail("Database has been dropped, query shouldn't work.");
1:         } catch (SQLException sqle) {
1:             // Expect no current connection.
1:             assertSQLState("08003", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Shuts down the database when in use by a different connection.
1:      * <p>
1:      * The expected outcome is that the first connection will be closed when
1:      * the second one shuts down the database.
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testShutdownWhenInUse()
1:             throws IOException, SQLException {
1:         Connection con = dbm.createDatabase("deleteDb");
1:         PreparedStatement ps = dbm.prepareStatement(con,
1:                 "select * from sys.systables");
1:         JDBC.assertDrainResults(ps.executeQuery());
1:         // Delete the database.
1:         try {
1:             DriverManager.getConnection(
1:                 "jdbc:derby:memory:deleteDb;shutdown=true");
1:             fail("Database shutdown should have raised exception.");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08006", sqle);
1:         }
1:         // Execute query from first connection again.
1:         assertTrue(con.isClosed());
1:         try {
1:             JDBC.assertDrainResults(ps.executeQuery());
1:             fail("Database has been shut down, query shouldn't work.");
1:         } catch (SQLException sqle) {
1:             // Expect no current connection.
1:             assertSQLState("08003", sqle);
1:         }
commit:5bef31e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that booting two databases with the same name but with different
1:      * subsubprotocols doesn't result in two connections to the same database.
1:      *
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testBootSameDbDifferentSubSubProtocol()
1:             throws SQLException {
1:         final String dbName = "BSDDSSP";
1:         // Connect to the in-memory database and create a table.
0:         Connection con1 = DriverManager.getConnection(
0:                 "jdbc:derby:memory:" + dbName + ";create=true");
0:         Statement stmt1 = con1.createStatement();
1:         stmt1.execute("create table t (text varchar(255))");
1:         stmt1.execute("insert into t values ('Inserted into in-memory db')");
1:         // Connect to the on-disk database. The table we created in the
1:         // in-memory database shouldn't exist in the on-disk database.
1:         Connection con2 = DriverManager.getConnection(
1:                 "jdbc:derby:" + dbName + ";create=true");
1:         // Table t should not exist.
1:         Statement stmt2 = con2.createStatement();
1:         try {
1:             stmt2.executeQuery("select * from t");
1:             fail("Table 't' should not exist");
1:         } catch (SQLException sqle) {
1:             assertSQLState("42X05", sqle);
1:         }
1:         con2.close();
0:         con1.close();
1:     }
1: 
commit:d5036cd
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Makes sure shutting down an in-memory database works.
1:      *
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testShutdown()
1:             throws SQLException {
0:         DriverManager.getConnection("jdbc:derby:memory:/tmp/myDB;create=true");
1:         try {
1:             DriverManager.getConnection(
1:                     "jdbc:derby:memory:/tmp/myDB;shutdown=true");
1:             fail("Engine shutdown should have caused exception");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08006", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Makes sure shutting down the Derby engine with an in-memory database
1:      * already booted works.
1:      * <p>
1:      * Related to DERBY-4093
1:      *
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testEnginehutdown()
1:             throws SQLException {
0:         DriverManager.getConnection("jdbc:derby:memory:/tmp/myDB;create=true");
1:         try {
1:             DriverManager.getConnection(
1:                     "jdbc:derby:;shutdown=true");
1:             fail("Engine shutdown should have caused exception");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ015", sqle);
1:         }
1:         // Another hack, to make sure later tests in this class doesn't fail.
1:         // Get a connection to the default database to reload the engine.
0:         getConnection();
1:     }
1: 
commit:497dc13
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.memorydb.BasicInMemoryDbTest
1: 
1:        Licensed to the Apache Software Foundation (ASF) under one
1:        or more contributor license agreements.  See the NOTICE file
1:        distributed with this work for additional information
1:        regarding copyright ownership.  The ASF licenses this file
1:        to you under the Apache License, Version 2.0 (the
1:        "License"); you may not use this file except in compliance
1:        with the License.  You may obtain a copy of the License at
1: 
1:          http://www.apache.org/licenses/LICENSE-2.0
1: 
1:        Unless required by applicable law or agreed to in writing,
1:        software distributed under the License is distributed on an
1:        "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
1:        KIND, either express or implied.  See the License for the
1:        specific language governing permissions and limitations
1:        under the License
1: */
1: package org.apache.derbyTesting.functionTests.tests.memorydb;
1: 
1: import java.io.File;
1: import java.io.IOException;
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.DriverManager;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
1: import org.apache.derbyTesting.functionTests.util.PrivilegedFileOpsForTests;
1: import org.apache.derbyTesting.functionTests.util.streams.CharAlphabet;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetReader;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.SupportFilesSetup;
1: 
1: /**
1:  * Basic tests of the in-memory db storage back end.
1:  */
1: public class BasicInMemoryDbTest
1:         extends BaseJDBCTestCase {
1: 
1:     public BasicInMemoryDbTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Tries to connect to a non-existing database with the in-memory protocol,
1:      * expecting an error saying the database doesn't exist.
1:      */
1:     public void testFunctionalityPresent() {
1:         try {
0:             getConnection(); // Make sure the driver is loaded (slight hack).
0:             DriverManager.getConnection("jdbc:derby:memory:nonExistingDb");
1:         } catch (SQLException e) {
1:             // Expect a database not found exception.
1:             assertSQLState("XJ004", e);
1:         }
1:     }
1: 
1:     /**
1:      * Performs a cycle to test that the in-memory db is compatible with the
1:      * deafult directory protocol.
1:      * <p>
1:      * <ol> <li>Create an in-memory db and add a table with a few rows.</li>
1:      *      <li>Backup to disk.</li>
1:      *      <li>Boot the database with the directory (default) protocol.</li>
1:      *      <li>Verify content, add a new row, shutdown.</li>
1:      *      <li>Use createFrom to restore database from disk into the in-memory
1:      *          representation.</li>
1:      *      <li>Verify new content.</li>
1:      * </ol>
1:      *
1:      * @throws IOException if something goes wrong
1:      * @throws SQLException if something goes wrong
1:      */
1:     public void testCreateBackupBootRestore()
1:             throws IOException, SQLException {
1:         // 1. Create the database with the in-memory protocol.
0:         Connection memCon = DriverManager.getConnection(
0:                 "jdbc:derby:memory:newMemDb;create=true");
1:         // Make sure the database is newly created.
1:         assertNull(memCon.getWarnings());
0:         Statement stmt = memCon.createStatement();
1:         stmt.executeUpdate("create table toverify(" +
1:                 "id int, val1 varchar(10), val2 clob, primary key(id))");
0:         PreparedStatement ps = memCon.prepareStatement("insert into toverify " +
0:                 "values (?,?,?)");
1:         // The content to insert into the table.
1:         String[][] firstContent = new String[][] {
1:             {"1", "one", getString(1000, CharAlphabet.modernLatinLowercase())},
1:             {"2", "two", getString(10000, CharAlphabet.tamil())},
1:             {"3", "three", getString(50000, CharAlphabet.cjkSubset())}
1:         };
1:         for (int i=0; i < firstContent.length; i++) {
1:             ps.setString(1, firstContent[i][0]);
1:             ps.setString(2, firstContent[i][1]);
1:             ps.setString(3, firstContent[i][2]);
1:             ps.executeUpdate();
1:         }
1:         ResultSet rs = stmt.executeQuery("select * from toverify");
1:         JDBC.assertFullResultSet(rs, firstContent);
1:         ps.close();
1:         stmt.close();
1: 
1:         // 2. Backup the database.
1:         String dbPath = SupportFilesSetup.getReadWrite("backedUpDb").getPath();
1:         CallableStatement cs = memCon.prepareCall(
1:                 "CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE(?)");
1:         cs.setString(1, dbPath);
1:         cs.execute();
1:         memCon.close();
1: 
1:         // 3. Open the database with the default protocol.
1:         String dbPathBackedUp = PrivilegedFileOpsForTests.getAbsolutePath(
1:                 new File(dbPath, "newMemDb"));
1:         Connection dirCon = DriverManager.getConnection(
1:                 "jdbc:derby:" + dbPathBackedUp);
1:         // 4. Verify content, then add one more row.
1:         stmt = dirCon.createStatement();
1:         rs = stmt.executeQuery("select * from toverify");
1:         JDBC.assertFullResultSet(rs, firstContent);
1:         ps = dirCon.prepareStatement("insert into toverify values (?,?,?)");
1:         String[] rowToAdd = new String[] {
1:             "4", "four", getString(32*1024, CharAlphabet.tamil())};
1:         ps.setString(1, rowToAdd[0]);
1:         ps.setString(2, rowToAdd[1]);
1:         ps.setString(3, rowToAdd[2]);
1:         ps.executeUpdate();
1:         ps.close();
1:         dirCon.close();
1:         // Shutdown.
1:         try {
1:             DriverManager.getConnection(
1:                 "jdbc:derby:" + dbPathBackedUp + ";shutdown=true");
1:         } catch (SQLException sqle) {
1:             assertSQLState("08006", sqle);
1:         }
1: 
1:         // 5. Restore modified backup into memory.
0:         memCon = DriverManager.getConnection("jdbc:derby:memory:newMemDb2" +
0:                 ";createFrom=" + dbPathBackedUp);
1: 
1:         // 6. Verify the new content, where the original in-memory database was
1:         //    backed up and the directory protocol was used to add one more row
1:         //    to the backed up database. Now we have restored the on-disk
1:         //    modified backup, again representing it as an in-memory database.
0:         stmt = memCon.createStatement();
1:         rs = stmt.executeQuery("select * from toverify");
1:         String[][] secondContent = new String[4][3];
1:         System.arraycopy(firstContent, 0, secondContent, 0, 3);
1:         System.arraycopy(rowToAdd, 0, secondContent[3], 0, 3);
1:         JDBC.assertFullResultSet(rs, secondContent);
1:         stmt.close();
1:         memCon.close();
1: 
0:         // The data will probably hang around in memory at this point.
0:         // How to fix that?
1:     }
1: 
1:     public static Test suite() {
1:         // Run only in embedded-mode for now.
0:         return new SupportFilesSetup(new TestSuite(BasicInMemoryDbTest.class));
1:     }
1: 
1:     /**
1:      * Generates a string.
1:      *
1:      * @param length length of the string
1:      * @param alphabet the alphabet to use for the content
1:      * @return A string.
1:      * @throws IOException if reading from the source stream fails
1:      */
1:     public static String getString(int length, CharAlphabet alphabet)
1:             throws IOException {
1:         LoopingAlphabetReader reader =
1:                 new LoopingAlphabetReader(length, alphabet);
1:         char[] strChar = new char[length];
1:         int read = 0;
1:         while (read < length) {
1:             int readNow = reader.read(strChar, read, length - read);
1:             if (readNow < 1) {
1:                 fail("Creating string failed, stream returned " + readNow);
1:             }
1:             read += readNow;
1:         }
1:         return String.copyValueOf(strChar);
1:     }
1: }
============================================================================