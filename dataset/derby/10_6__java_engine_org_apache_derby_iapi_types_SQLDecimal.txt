5:eac0369: /*
1:6d0a34c: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.types.SQLDecimal
1:7ecc1f2: 
1:2431ece:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2431ece:    contributor license agreements.  See the NOTICE file distributed with
1:2431ece:    this work for additional information regarding copyright ownership.
1:2431ece:    The ASF licenses this file to you under the Apache License, Version 2.0
1:2431ece:    (the "License"); you may not use this file except in compliance with
1:2431ece:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
13:eac0369:  */
29:eac0369: 
1:eac0369: package org.apache.derby.iapi.types;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.cache.ClassSize;
1:eac0369: 
1:eac0369: import java.math.BigDecimal;
1:eac0369: import java.math.BigInteger;
1:4469400: import java.math.RoundingMode;
1:eac0369: import java.io.ObjectOutput;
1:eac0369: import java.io.ObjectInput;
1:eac0369: import java.io.IOException;
1:eac0369: 
1:eac0369: import java.sql.ResultSet;
1:eac0369: import java.sql.PreparedStatement;
1:eac0369: import java.sql.SQLException;
1:2c6f0a2: import java.sql.Types;
1:eac0369: 
7:eac0369: /**
1:eac0369:  * SQLDecimal satisfies the DataValueDescriptor
1:eac0369:  * interfaces (i.e., OrderableDataType). It implements a numeric/decimal column, 
1:eac0369:  * e.g. for * storing a column value; it can be specified
1:eac0369:  * when constructed to not allow nulls. Nullability cannot be changed
1:eac0369:  * after construction, as it affects the storage size and mechanism.
1:eac0369:  * <p>
1:eac0369:  * Because OrderableDataType is a subtype of DataType,
1:eac0369:  * SQLDecimal can play a role in either a DataType/Row
1:eac0369:  * or a OrderableDataType/Row, interchangeably.
1:eac0369:  * <p>
1:eac0369:  * We assume the store has a flag for nullness of the value,
1:eac0369:  * and simply return a 0-length array for the stored form
1:eac0369:  * when the value is null.
9:eac0369:  *
1:eac0369:  */
1:fdb2deb: public final class SQLDecimal extends NumberDataType implements VariableSizeDataValue
19:eac0369: {
1:eac0369: 	/**
1:eac0369: 	 * object state.  Note that scale and precision are 
1:eac0369: 	 * always determined dynamically from value when
1:eac0369: 	 * it is not null.
1:eac0369: 
1:eac0369:        The field value can be null without the data value being null.
1:eac0369: 	   In this case the value is stored in rawData and rawScale. This
1:eac0369: 	   is to allow the minimal amount of work to read a SQLDecimal from disk.
1:eac0369: 	   Creating the BigDecimal is expensive as it requires allocating
1:eac0369: 	   three objects, the last two are a waste in the case the row does
1:eac0369: 	   not qualify or the row will be written out by the sorter before being
1:eac0369: 	   returned to the application.
1:eac0369: 		<P>
1:eac0369: 		This means that this field must be accessed for read indirectly through
1:eac0369: 		the getBigDecimal() method, and when setting it the rawData field must
1:eac0369: 		be set to null.
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	private BigDecimal	value;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		See comments for value
1:eac0369: 	*/
1:eac0369: 	private byte[]		rawData;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		See comments for value
1:eac0369: 	*/
1:eac0369: 	private int			rawScale;
1:eac0369: 
1:eac0369:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLDecimal.class);
1:eac0369:     private static final int BIG_DECIMAL_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( BigDecimal.class);
1:eac0369: 
1:eac0369:     public int estimateMemoryUsage()
1:eac0369:     {
1:eac0369:         int sz = BASE_MEMORY_USAGE;
1:eac0369:         if( null != value)
1:eac0369:             sz += BIG_DECIMAL_MEMORY_USAGE + (value.unscaledValue().bitLength() + 8)/8;
1:eac0369:         if( null != rawData)
1:eac0369:             sz += rawData.length;
1:eac0369:         return sz;
26:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// CLASS INTERFACE
1:eac0369: 	//
1:eac0369: 	////////////////////////////////////////////////////////////////////
1:eac0369: 	/** no-arg constructor, required by Formattable */
1:eac0369: 	public SQLDecimal() 
1:eac0369: 	{
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public SQLDecimal(BigDecimal val)
1:eac0369: 	{
1:eac0369: 		value = val;
1:eac0369: 	}
1:eac0369: 
1:8bf0832: 	public SQLDecimal(BigDecimal val, int nprecision, int scale)
2:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		
1:eac0369: 		value = val;
1:eac0369: 		if ((value != null) && (scale >= 0))
1:eac0369: 		{
1:4469400: 			value = value.setScale(scale, RoundingMode.DOWN);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public SQLDecimal(String val) 
1:eac0369: 	{
1:eac0369: 		value = new BigDecimal(val);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 * (mostly implemented in DataType)
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 
1:854dd10: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public int	getInt() throws StandardException
1:eac0369: 	{
1:2c6f0a2: 		if (isNull())
2:eac0369: 			return 0;
1:c655d66: 
1:1ccdf3e: 		try {
1:eac0369: 			long lv = getLong();
1:1ccdf3e: 
1:eac0369: 			if ((lv >= Integer.MIN_VALUE) && (lv <= Integer.MAX_VALUE))
1:eac0369: 				return (int) lv;
1:1ccdf3e: 
1:eac0369: 		} catch (StandardException se) {
1:1ccdf3e: 		}
1:b69c0b7: 
1:eac0369: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1:e7c5a46: 	}
1:e7c5a46: 
1:1ccdf3e: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:e7c5a46: 	 */
1:eac0369: 	public byte	getByte() throws StandardException
1:1ccdf3e: 	{
1:2c6f0a2: 		if (isNull())
1:eac0369: 			return (byte)0;
1:e7c5a46: 
1:1ccdf3e: 		try {
1:eac0369: 			long lv = getLong();
1:eac0369: 
1:eac0369: 			if ((lv >= Byte.MIN_VALUE) && (lv <= Byte.MAX_VALUE))
1:eac0369: 				return (byte) lv;
1:eac0369: 
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TINYINT");
1:eac0369: 	}
1:eac0369: 
1:1ccdf3e: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public short	getShort() throws StandardException
1:e7c5a46: 	{
1:2c6f0a2: 		if (isNull())
1:eac0369: 			return (short)0;
1:eac0369: 
2:8bf0832: 		try {
1:eac0369: 			long lv = getLong();
1:eac0369: 
1:eac0369: 			if ((lv >= Short.MIN_VALUE) && (lv <= Short.MAX_VALUE))
1:eac0369: 				return (short) lv;
1:eac0369: 
1:eac0369: 		} catch (StandardException se) {
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "SMALLINT");
1:eac0369: 	}
1:eac0369: 
1:e7c5a46: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public long	getLong() throws StandardException
1:eac0369: 	{
5:eac0369: 		BigDecimal localValue = getBigDecimal();
5:eac0369: 		if (localValue == null)
1:eac0369: 			return (long)0;
1:2c6f0a2: 
1:eac0369: 		// Valid range for long is
1:eac0369: 		//   greater than Long.MIN_VALUE - 1
1:eac0369: 		// *and*
1:eac0369: 		//   less than Long.MAX_VALUE + 1
1:eac0369: 		//
1:eac0369: 		// This ensures that DECIMAL values with an integral value
1:eac0369: 		// equal to the Long.MIN/MAX_VALUE round correctly to those values.
1:eac0369: 		// e.g. 9223372036854775807.1  converts to 9223372036854775807
1:eac0369: 		// this matches DB2 UDB behaviour
1:eac0369: 
1:96748ad: 		if (   (localValue.compareTo(MINLONG_MINUS_ONE) == 1)
1:96748ad: 			&& (localValue.compareTo(MAXLONG_PLUS_ONE) == -1)) {
1:eac0369: 
1:eac0369: 			return localValue.longValue();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "BIGINT");
1:eac0369: 	}
1:eac0369: 
1:2c6f0a2: 	/**
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public float getFloat() throws StandardException
1:8bf0832: 	{
1:eac0369: 		BigDecimal localValue = getBigDecimal();
1:eac0369: 		if (localValue == null)
1:eac0369: 			return (float)0;
1:eac0369: 
1:eac0369: 		// If the BigDecimal is out of range for the float
1:eac0369: 		// then positive or negative infinity is returned.
1:eac0369: 		float value = NumberDataType.normalizeREAL(localValue.floatValue());
1:eac0369: 
1:eac0369: 		return value;
1:eac0369: 	}
1:2c6f0a2: 
1:2c6f0a2: 	/**
1:eac0369: 	 * 
1:eac0369: 	 * If we have a value that is greater than the maximum double,
1:eac0369: 	 * exception is thrown.  Otherwise, ok.  If the value is less
1:eac0369: 	 * than can be represented by a double, ti will get set to
1:eac0369: 	 * the smallest double value.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException thrown on failure to convert
1:eac0369: 	 */
1:eac0369: 	public double getDouble() throws StandardException
1:eac0369: 	{
1:eac0369: 		BigDecimal localValue = getBigDecimal();
1:eac0369: 		if (localValue == null)
1:eac0369: 			return (double)0;
1:eac0369: 
1:eac0369: 		// If the BigDecimal is out of range for double
1:eac0369: 		// then positive or negative infinity is returned.
1:eac0369: 		double value = NumberDataType.normalizeDOUBLE(localValue.doubleValue());
1:eac0369: 		return value;
1:eac0369: 	}
1:eac0369: 
1:2a58829: 	private BigDecimal	getBigDecimal()
1:eac0369: 	{
1:eac0369: 		if ((value == null) && (rawData != null)) 
1:eac0369: 		{
1:eac0369: 			value = new BigDecimal(new BigInteger(rawData), rawScale);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return value;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:2c6f0a2: 	 * DECIMAL implementation. Convert to a BigDecimal using getObject
1:2c6f0a2: 	 * which will return a BigDecimal
1:2c6f0a2: 	 */
1:2c6f0a2: 	public int typeToBigDecimal()
1:2c6f0a2: 	{
1:2c6f0a2: 		return java.sql.Types.DECIMAL;
1:2c6f0a2: 	}
1:eac0369: 
1:eac0369:     // 0 or null is false, all else is true
1:eac0369: 	public boolean	getBoolean()
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		BigDecimal localValue = getBigDecimal();
1:eac0369: 		if (localValue == null)
1:eac0369: 			return false;
1:eac0369: 
1:5465561: 		return localValue.compareTo(BigDecimal.ZERO) != 0;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String	getString()
1:eac0369: 	{
1:eac0369: 		BigDecimal localValue = getBigDecimal();
1:c655d66:         return (localValue == null) ? null : localValue.toPlainString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public Object	getObject()
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		** BigDecimal is immutable
1:eac0369: 		*/
2:eac0369: 		return getBigDecimal();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:806114c: 	 * Set the value from a correctly typed BigDecimal object.
1:806114c: 	 * @throws StandardException 
1:806114c: 	 */
1:806114c: 	void setObject(Object theValue) throws StandardException
1:eac0369: 	{
1:806114c: 		setValue((BigDecimal) theValue);
1:eac0369: 	}
1:806114c: 	
1:eac0369: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1:eac0369: 
1:2a58829: 		setCoreValue(SQLDecimal.getBigDecimal(theValue));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public int	getLength()
1:eac0369: 	{
1:509ccb9: 		return getDecimalValuePrecision();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	// this is for DataType's error generator
1:eac0369: 	public String getTypeName()
1:eac0369: 	{
1:eac0369: 		return TypeId.DECIMAL_NAME;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Storable interface, implies Externalizable, TypedFormat
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return my format identifier.
1:eac0369: 
1:eac0369: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1:eac0369: 	*/
1:eac0369: 	public int getTypeFormatId() 
1:eac0369: 	{
1:eac0369: 		return StoredFormatIds.SQL_DECIMAL_ID;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * see if the decimal value is null.
1:eac0369: 	 */
1:eac0369: 	/** @see Storable#isNull */
1:eac0369: 	public boolean isNull()
1:eac0369: 	{
1:eac0369: 		return (value == null) && (rawData == null);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * Distill the BigDecimal to a byte array and
1:eac0369: 	 * write out: <UL>
1:1ccdf3e: 	 *	<LI> scale (zero or positive) as a byte </LI>
1:1ccdf3e: 	 *	<LI> length of byte array as a byte</LI>
1:eac0369: 	 *	<LI> the byte array </LI> </UL>
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void writeExternal(ObjectOutput out) throws IOException 
1:eac0369: 	{
1:eac0369: 		// never called when value is null
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(! isNull());
1:eac0369: 
1:eac0369: 		int scale;
1:eac0369: 		byte[] byteArray;
1:eac0369: 
1:eac0369: 		if (value != null) {
1:eac0369: 			scale = value.scale();
1:1ccdf3e: 			
1:1ccdf3e: 			// J2SE 5.0 introduced negative scale value for BigDecimals.
1:1ccdf3e: 			// In previouse Java releases a negative scale was not allowed
1:1ccdf3e: 			// (threw an exception on setScale and the constructor that took
1:1ccdf3e: 			// a scale).
1:1ccdf3e: 			//
1:1ccdf3e: 			// Thus the Derby format for DECIMAL implictly assumed a
1:1ccdf3e: 			// positive or zero scale value, and thus now must explicitly
1:1ccdf3e: 			// be positive. This is to allow databases created under J2SE 5.0
1:1ccdf3e: 			// to continue to be supported under JDK 1.3/JDK 1.4, ie. to continue
1:1ccdf3e: 			// the platform independence, independent of OS/cpu and JVM.
1:1ccdf3e: 			//
1:1ccdf3e: 			// If the scale is negative set the scale to be zero, this results
1:1ccdf3e: 			// in an unchanged value with a new scale. A BigDecimal with a
1:1ccdf3e: 			// negative scale by definition is a whole number.
1:1ccdf3e: 			// e.g. 1000 can be represented by:
1:1ccdf3e: 			//    a BigDecimal with scale -3 (unscaled value of 1)
1:1ccdf3e: 			// or a BigDecimal with scale 0 (unscaled value of 1000)
1:1ccdf3e: 			
1:1ccdf3e: 			if (scale < 0) {			
1:1ccdf3e: 				scale = 0;
1:1ccdf3e: 				value = value.setScale(0);
1:1ccdf3e: 			}
1:1ccdf3e: 
1:95dfbea: 			BigInteger bi = value.unscaledValue();
1:eac0369: 			byteArray = bi.toByteArray();
1:1ccdf3e: 		} else {
1:eac0369: 			scale = rawScale;
1:eac0369: 			byteArray = rawData;
1:1ccdf3e: 		}
1:1ccdf3e: 		
1:1ccdf3e: 		if (SanityManager.DEBUG)
1:1ccdf3e: 		{
1:1ccdf3e: 			if (scale < 0)
1:1ccdf3e: 				SanityManager.THROWASSERT("DECIMAL scale at writeExternal is negative "
1:1ccdf3e: 					+ scale + " value " + toString());
1:1ccdf3e: 		}
1:1ccdf3e: 
1:eac0369: 		out.writeByte(scale);
1:eac0369: 		out.writeByte(byteArray.length);
1:eac0369: 		out.write(byteArray);
1:eac0369: 	}
1:1ccdf3e: 
1:eac0369: 	/** 
1:eac0369: 	 * Note the use of rawData: we reuse the array if the
1:eac0369: 	 * incoming array is the same length or smaller than
1:eac0369: 	 * the array length.  
1:eac0369: 	 * 
1:eac0369: 	 * @see java.io.Externalizable#readExternal 
1:eac0369: 	 */
1:eac0369: 	public void readExternal(ObjectInput in) throws IOException 
1:eac0369: 	{
2:eac0369: 		// clear the previous value to ensure that the
2:eac0369: 		// rawData value will be used
2:eac0369: 		value = null;
1:eac0369: 
2:eac0369: 		rawScale = in.readUnsignedByte();
2:eac0369: 		int size = in.readUnsignedByte();
1:eac0369: 
1:eac0369: 		/*
2:eac0369: 		** Allocate a new array if the data to read
2:eac0369: 		** is larger than the existing array, or if
2:eac0369: 		** we don't have an array yet.
1:eac0369: 
2:eac0369:         Need to use readFully below and NOT just read because read does not
2:eac0369:         guarantee getting size bytes back, whereas readFully does (unless EOF).
1:eac0369:         */
2:eac0369: 		if ((rawData == null) || size != rawData.length)
1:eac0369: 		{
2:eac0369: 			rawData = new byte[size];
1:eac0369: 		}
1:95dfbea: 		in.readFully(rawData);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see Storable#restoreToNull
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void restoreToNull()
1:eac0369: 	{
1:eac0369: 		value = null;
2:eac0369: 		rawData = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/** @exception StandardException		Thrown on error */
1:eac0369: 	protected int typeCompare(DataValueDescriptor arg) throws StandardException
1:eac0369: 	{
1:2a58829: 		BigDecimal otherValue = SQLDecimal.getBigDecimal(arg);
1:eac0369: 		return getBigDecimal().compareTo(otherValue);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369:     /**
1:854dd10:      * @see DataValueDescriptor#cloneValue
1:854dd10:      */
1:854dd10:     public DataValueDescriptor cloneValue(boolean forceMaterialization)
1:eac0369: 	{
1:eac0369: 		return new SQLDecimal(getBigDecimal());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see DataValueDescriptor#getNewNull
1:eac0369: 	 */
1:eac0369: 	public DataValueDescriptor getNewNull()
1:eac0369: 	{
1:eac0369: 		return new SQLDecimal();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/** 
1:eac0369: 	 * @see DataValueDescriptor#setValueFromResultSet 
1:eac0369: 	 *
1:eac0369: 	 * @exception SQLException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1:eac0369: 									  boolean isNullable)
1:eac0369: 		throws SQLException
1:eac0369: 	{
1:2c6f0a2: 			value = resultSet.getBigDecimal(colNumber);
1:eac0369: 			rawData = null;
1:eac0369: 	}
1:eac0369: 	/**
1:eac0369: 		Set the value into a PreparedStatement.
1:eac0369: 
1:eac0369: 		@exception SQLException Error setting value in PreparedStatement
1:eac0369: 	*/
1:eac0369: 	public final void setInto(PreparedStatement ps, int position) throws SQLException {
1:eac0369: 
1:eac0369: 		if (isNull()) {
1:eac0369: 			ps.setNull(position, java.sql.Types.DECIMAL);
1:eac0369: 			return;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		ps.setBigDecimal(position, getBigDecimal());
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	 *
1:eac0369: 	 * <B> WARNING </B> there is no checking to make sure
1:eac0369: 	 * that theValue doesn't exceed the precision/scale of
1:eac0369: 	 * the current SQLDecimal.  It is just assumed that the
1:eac0369: 	 * SQLDecimal is supposed to take the precision/scale of
1:eac0369: 	 * the BigDecimalized String.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException throws NumberFormatException
1:eac0369: 	 *		when the String format is not recognized.
1:eac0369: 	 */
1:eac0369: 	public void setValue(String theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		rawData = null;
1:eac0369: 
1:eac0369: 		if (theValue == null)
1:eac0369: 		{
1:eac0369: 			value = null;
1:eac0369: 		}
1:8bf0832: 		else
1:eac0369: 		{
1:eac0369: 		    try 
1:eac0369: 			{
1:eac0369: 				theValue = theValue.trim();
2:eac0369: 		        value = new BigDecimal(theValue);
1:eac0369: 				rawData = null;
1:eac0369: 			} catch (NumberFormatException nfe) 
1:eac0369: 			{
1:eac0369: 			    throw invalidFormat();
1:8bf0832: 			}
1:8bf0832: 		}
1:8bf0832: 	}
1:8bf0832: 
1:eac0369: 	/**
4:eac0369: 	 * @see NumberDataValue#setValue
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void setValue(double theValue) throws StandardException
1:eac0369: 	{
1:eac0369: 		setCoreValue(NumberDataType.normalizeDOUBLE(theValue));
1:8bf0832: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NumberDataValue#setValue
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(float theValue)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		setCoreValue((double)NumberDataType.normalizeREAL(theValue));
1:8bf0832: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NumberDataValue#setValue
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(long theValue)
1:eac0369: 	{
1:eac0369: 		value = BigDecimal.valueOf(theValue);
1:eac0369: 		rawData = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NumberDataValue#setValue
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(int theValue)
1:eac0369: 	{
3:eac0369: 		setValue((long)theValue);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:d7f7457: 		Only to be called when the application sets a value using BigDecimal
1:d7f7457: 		through setBigDecimal calls.
1:d7f7457: 	*/
1:9548d38: 	public void setBigDecimal(BigDecimal theValue) throws StandardException
1:eac0369: 	{
1:9548d38: 		setCoreValue(theValue);
1:d7f7457: 	}
1:d7f7457: 
1:d7f7457: 	/**
1:d7f7457: 		Called when setting a DECIMAL value internally or from
1:d7f7457: 		through a procedure or function.
1:d7f7457: 		Handles long in addition to BigDecimal to handle
1:d7f7457: 		identity being stored as a long but returned as a DECIMAL.
1:d7f7457: 	*/
1:d7f7457: 	public void setValue(Number theValue) throws StandardException
1:d7f7457: 	{
1:d7f7457: 		if (SanityManager.ASSERT)
1:d7f7457: 		{
1:d7f7457: 			if (theValue != null &&
1:d7f7457: 				!(theValue instanceof java.math.BigDecimal) &&
1:d7f7457: 				!(theValue instanceof java.lang.Long))
1:d7f7457: 				SanityManager.THROWASSERT("SQLDecimal.setValue(Number) passed a " + theValue.getClass());
1:d7f7457: 		}
1:d7f7457: 
1:d7f7457: 		if (theValue instanceof BigDecimal || theValue == null)
2:d7f7457: 			setCoreValue((BigDecimal) theValue);
1:d7f7457: 		else
1:d7f7457: 			setValue(theValue.longValue());
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * @see NumberDataValue#setValue
1:eac0369: 	 *
1:eac0369: 	 */
1:eac0369: 	public void setValue(boolean theValue)
1:eac0369: 	{
1:5465561: 		setCoreValue(theValue ? BigDecimal.ONE : BigDecimal.ZERO);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * DataValueDescriptor interface
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	/** @see DataValueDescriptor#typePrecedence */
1:eac0369: 	public int typePrecedence()
1:eac0369: 	{
1:eac0369: 		return TypeId.DECIMAL_PRECEDENCE;
1:eac0369: 	}
1:eac0369:     // END DataValueDescriptor interface
1:eac0369: 
1:eac0369: 	private void setCoreValue(BigDecimal theValue)
1:eac0369: 	{
1:eac0369: 		value = theValue;
1:eac0369: 		rawData = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void setCoreValue(double theValue) {
1:c2d0dcc: 		value = new BigDecimal(Double.toString(theValue));
1:eac0369: 		rawData = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Normalization method - this method may be called when putting
1:eac0369: 	 * a value into a SQLDecimal, for example, when inserting into a SQLDecimal
1:eac0369: 	 * column.  See NormalizeResultSet in execution.
1:eac0369: 	 * <p>
1:eac0369: 	 * Note that truncation is allowed on the decimal portion
1:eac0369: 	 * of a numeric only.	
1:eac0369: 	 *
1:eac0369: 	 * @param desiredType	The type to normalize the source column to
1:eac0369: 	 * @param source		The value to normalize
1:eac0369: 	 *
1:e7c5a46: 	 * @throws StandardException				Thrown for null into
1:eac0369: 	 *											non-nullable column, and for
1:eac0369: 	 *											truncation error
1:eac0369: 	 */
1:eac0369: 	public void normalize(
1:eac0369: 				DataTypeDescriptor desiredType,
1:eac0369: 				DataValueDescriptor source)
1:eac0369: 						throws StandardException
1:eac0369: 	{
1:eac0369: 		int desiredScale = desiredType.getScale();
1:eac0369: 		int desiredPrecision = desiredType.getPrecision();
1:eac0369: 
1:6d0a34c: 		setFrom(source);
1:eac0369: 		setWidth(desiredPrecision, desiredScale, true);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** SQL Operators
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:6d0a34c: 	 * This method implements the + operator for DECIMAL.
1:eac0369: 	 *
1:eac0369: 	 * @param addend1	One of the addends
1:eac0369: 	 * @param addend2	The other addend
1:eac0369: 	 * @param result	The result of a previous call to this method, null
1:eac0369: 	 *					if not called yet
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQLDecimal containing the result of the addition
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public NumberDataValue plus(NumberDataValue addend1,
1:eac0369: 							NumberDataValue addend2,
1:eac0369: 							NumberDataValue result)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		if (result == null)
1:eac0369: 		{
1:eac0369: 			result = new SQLDecimal();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (addend1.isNull() || addend2.isNull())
1:eac0369: 		{
1:eac0369: 			result.setToNull();
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 
1:2a58829: 		result.setBigDecimal(SQLDecimal.getBigDecimal(addend1).add(SQLDecimal.getBigDecimal(addend2)));
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This method implements the - operator for "decimal - decimal".
1:eac0369: 	 *
1:eac0369: 	 * @param left	The value to be subtracted from
1:eac0369: 	 * @param right	The value to be subtracted
1:eac0369: 	 * @param result	The result of a previous call to this method, null
1:eac0369: 	 *					if not called yet
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQLDecimal containing the result of the subtraction
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public NumberDataValue minus(NumberDataValue left,
1:eac0369: 							NumberDataValue right,
1:eac0369: 							NumberDataValue result)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		if (result == null)
1:eac0369: 		{
1:eac0369: 			result = new SQLDecimal();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (left.isNull() || right.isNull())
1:eac0369: 		{
1:eac0369: 			result.setToNull();
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 
1:2a58829: 		result.setBigDecimal(SQLDecimal.getBigDecimal(left).subtract(SQLDecimal.getBigDecimal(right)));
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This method implements the * operator for "double * double".
1:eac0369: 	 *
1:eac0369: 	 * @param left	The first value to be multiplied
1:eac0369: 	 * @param right	The second value to be multiplied
1:eac0369: 	 * @param result	The result of a previous call to this method, null
1:eac0369: 	 *					if not called yet
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQLDecimal containing the result of the multiplication
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public NumberDataValue times(NumberDataValue left,
1:eac0369: 							NumberDataValue right,
1:eac0369: 							NumberDataValue result)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		if (result == null)
1:eac0369: 		{
1:eac0369: 			result = new SQLDecimal();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (left.isNull() || right.isNull())
1:eac0369: 		{
1:eac0369: 			result.setToNull();
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 
1:2a58829: 		result.setBigDecimal(SQLDecimal.getBigDecimal(left).multiply(SQLDecimal.getBigDecimal(right)));
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This method implements the / operator for BigDecimal/BigDecimal
1:eac0369: 	 *
1:eac0369: 	 * @param dividend	The numerator
1:eac0369: 	 * @param divisor	The denominator
1:eac0369: 	 * @param result	The result of a previous call to this method, null
1:eac0369: 	 *					if not called yet
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQLDecimal containing the result of the division
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public NumberDataValue divide(NumberDataValue dividend,
1:eac0369: 							 NumberDataValue divisor,
1:eac0369: 							 NumberDataValue result)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		return divide(dividend, divisor, result, -1);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This method implements the / operator for BigDecimal/BigDecimal
1:eac0369: 	 *
1:eac0369: 	 * @param dividend	The numerator
1:eac0369: 	 * @param divisor	The denominator
1:eac0369: 	 * @param result	The result of a previous call to this method, null
1:eac0369: 	 *					if not called yet
1:dbed020: 	 * @param scale		The result scale, if &lt; 0, calculate the scale according
1:eac0369: 	 *					to the actual values' sizes
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQLDecimal containing the result of the division
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public NumberDataValue divide(NumberDataValue dividend,
1:eac0369: 							 NumberDataValue divisor,
1:eac0369: 							 NumberDataValue result,
1:eac0369: 							 int scale)
1:eac0369: 				throws StandardException
1:eac0369: 	{
1:eac0369: 		if (result == null)
1:eac0369: 		{
1:eac0369: 			result = new SQLDecimal();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (dividend.isNull() || divisor.isNull())
1:eac0369: 		{
1:eac0369: 			result.setToNull();
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 
1:2a58829: 		BigDecimal divisorBigDecimal = SQLDecimal.getBigDecimal(divisor);
1:eac0369: 
1:5465561: 		if (divisorBigDecimal.compareTo(BigDecimal.ZERO) == 0)
1:eac0369: 		{
1:eac0369: 			throw  StandardException.newException(SQLState.LANG_DIVIDE_BY_ZERO);
1:eac0369: 		}
1:2a58829: 		BigDecimal dividendBigDecimal = SQLDecimal.getBigDecimal(dividend);
1:6d0a34c: 		
1:eac0369: 		/*
1:eac0369: 		** Set the result scale to be either the passed in scale, whcih was
1:eac0369: 		** calculated at bind time to be max(ls+rp-rs+1, 4), where ls,rp,rs
1:eac0369: 		** are static data types' sizes, which are predictable and stable
1:eac0369: 		** (for the whole result set column, eg.); otherwise dynamically
1:eac0369: 		** calculates the scale according to actual values.  Beetle 3901
1:eac0369: 		*/
1:4469400: 		result.setBigDecimal
1:4469400:           (
1:4469400:            dividendBigDecimal.divide
1:4469400:            (
1:4469400:             divisorBigDecimal,
1:4469400:             scale > -1 ?
1:4469400:             scale :
1:4469400:             Math.max
1:4469400:             (
1:4469400:              (dividendBigDecimal.scale() + SQLDecimal.getWholeDigits(divisorBigDecimal) + 1), 
1:4469400:              NumberDataValue.MIN_DECIMAL_DIVIDE_SCALE
1:4469400:             ),
1:4469400:             RoundingMode.DOWN)
1:4469400:            );
1:eac0369: 		
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * This method implements the unary minus operator for double.
1:eac0369: 	 *
1:eac0369: 	 * @param result	The result of a previous call to this method, null
1:eac0369: 	 *					if not called yet
1:eac0369: 	 *
1:eac0369: 	 * @return	A SQLDecimal containing the result of the division
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public NumberDataValue minus(NumberDataValue result)
1:eac0369: 									throws StandardException
1:eac0369: 	{
1:eac0369: 		if (result == null)
1:eac0369: 		{
1:eac0369: 			result = new SQLDecimal();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (this.isNull())
1:eac0369: 		{
1:eac0369: 			result.setToNull();
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 
1:d7f7457: 		result.setBigDecimal(getBigDecimal().negate());
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * This method implements the isNegative method.
1:eac0369:      * 
1:eac0369:      * @return  A boolean.  If this.value is negative, return true.
1:eac0369:      *          For positive values or null, return false.
1:eac0369:      */
1:eac0369: 
1:eac0369:     protected boolean isNegative()
1:eac0369:     {
1:5465561:         return !isNull() && (getBigDecimal().compareTo(BigDecimal.ZERO) == -1);
1:eac0369:     }
1:eac0369:     
1:eac0369: 	/*
1:eac0369: 	 * String display of value
1:eac0369: 	 */
1:eac0369: 	public String toString()
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:eac0369: 			return "NULL";
6:eac0369: 		else
1:a765e16: 			return getString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Hash code
1:eac0369: 	 */
1:eac0369: 	public int hashCode()
1:eac0369: 	{
1:eac0369: 		long longVal;
1:eac0369: 		BigDecimal localValue = getBigDecimal();
1:eac0369: 
1:eac0369: 		double doubleVal = (localValue != null) ? localValue.doubleValue() : 0;
1:eac0369: 
1:eac0369: 		if (Double.isInfinite(doubleVal))
1:eac0369: 		{
1:eac0369: 			/*
1:eac0369: 			 ** This loses the fractional part, but it probably doesn't
1:eac0369: 			 ** matter for numbers that are big enough to overflow a double -
1:eac0369: 			 ** it's probably rare for numbers this big to be different only in
1:eac0369: 			 ** their fractional parts.
1:eac0369: 			 */
1:eac0369: 			longVal = localValue.longValue();
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			longVal = (long) doubleVal;
1:eac0369: 			if (longVal != doubleVal)
1:eac0369: 			{
1:eac0369: 				longVal = Double.doubleToLongBits(doubleVal);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return (int) (longVal ^ (longVal >> 32));
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 	//
1:eac0369: 	// VariableSizeDataValue interface
1:eac0369: 	//
1:eac0369: 	///////////////////////////////////////////////////////////////////////////////
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Set the precision/scale of the to the desired values. 
1:eac0369: 	 * Used when CASTing.  Ideally we'd recycle normalize(), but
1:eac0369: 	 * the use is different.  
1:eac0369: 	 *
1:eac0369: 	 * @param desiredPrecision	the desired precision -- IGNORE_PREICISION
1:eac0369: 	 *					if it is to be ignored.
1:eac0369: 	 * @param desiredScale	the desired scale 
1:eac0369: 	 * @param errorOnTrunc	throw error on truncation (ignored -- 
1:eac0369: 	 *		always thrown if we truncate the non-decimal part of
1:eac0369: 	 *		the value)
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on non-zero truncation
1:eac0369: 	 *		if errorOnTrunc is true	
1:eac0369: 	 */
1:806114c: 	public void setWidth(int desiredPrecision, 
1:eac0369: 			int desiredScale,
1:eac0369: 			boolean errorOnTrunc)
1:eac0369: 			throws StandardException
1:eac0369: 	{
1:eac0369: 		if (isNull())
1:806114c: 			return;
1:eac0369: 			
1:eac0369: 		if (desiredPrecision != IGNORE_PRECISION &&
1:1ccdf3e: 			((desiredPrecision - desiredScale) <  SQLDecimal.getWholeDigits(getBigDecimal())))
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, 
1:eac0369: 									("DECIMAL/NUMERIC("+desiredPrecision+","+desiredScale+")"));
1:eac0369: 		}
1:4469400: 		value = value.setScale(desiredScale, RoundingMode.DOWN);
1:eac0369: 		rawData = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:1ccdf3e: 	 * Return the SQL scale of this value, number of digits after the
1:1ccdf3e: 	 * decimal point, or zero for a whole number. This does not match the
1:1ccdf3e: 	 * return from BigDecimal.scale() since in J2SE 5.0 onwards that can return
1:1ccdf3e: 	 * negative scales.
1:1ccdf3e: 	 */
1:509ccb9: 	public int getDecimalValuePrecision()
1:eac0369: 	{
1:1ccdf3e: 		if (isNull())
1:eac0369: 			return 0;
1:1ccdf3e: 			
1:1ccdf3e: 		BigDecimal localValue = getBigDecimal();
1:eac0369: 
1:1ccdf3e: 		return SQLDecimal.getWholeDigits(localValue) + getDecimalValueScale();
1:eac0369: 	}
1:eac0369: 
1:1ccdf3e: 	/**
1:1ccdf3e: 	 * Return the SQL scale of this value, number of digits after the
1:1ccdf3e: 	 * decimal point, or zero for a whole number. This does not match the
1:1ccdf3e: 	 * return from BigDecimal.scale() since in J2SE 5.0 onwards that can return
1:1ccdf3e: 	 * negative scales.
1:1ccdf3e: 	 */
1:509ccb9: 	public int getDecimalValueScale()
1:eac0369: 	{
1:1ccdf3e: 		if (isNull())
1:1ccdf3e: 			return 0;
1:1ccdf3e: 		
1:1ccdf3e: 		if (value == null)
1:1ccdf3e: 			return rawScale;
1:1ccdf3e: 	
1:1ccdf3e: 		int scale = value.scale();
1:1ccdf3e: 		if (scale >= 0)
1:1ccdf3e: 			return scale;
1:1ccdf3e: 		
1:1ccdf3e: 		// BigDecimal scale is negative, so number must have no fractional
1:1ccdf3e: 		// part as its value is the unscaled value * 10^-scale
1:1ccdf3e: 		return 0;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:2c6f0a2: 	 * Get a BigDecimal representing the value of a DataValueDescriptor
1:2c6f0a2: 	 * @param value Non-null value to be converted
1:2c6f0a2: 	 * @return BigDecimal value
1:2c6f0a2: 	 * @throws StandardException Invalid conversion or out of range.
1:2c6f0a2: 	 */
1:2c6f0a2: 	public static BigDecimal getBigDecimal(DataValueDescriptor value) throws StandardException
1:2c6f0a2: 	{
1:2c6f0a2: 		if (SanityManager.DEBUG)
1:2c6f0a2: 		{
1:2c6f0a2: 			if (value.isNull())
1:2c6f0a2: 				SanityManager.THROWASSERT("NULL value passed to SQLDecimal.getBigDecimal");
1:2c6f0a2: 		}
1:2c6f0a2: 		
1:2c6f0a2: 		switch (value.typeToBigDecimal())
1:2c6f0a2: 		{
1:2c6f0a2: 		case Types.DECIMAL:
1:2c6f0a2: 			return (BigDecimal) value.getObject();
1:2c6f0a2: 		case Types.CHAR:
1:2c6f0a2: 			try {
1:2c6f0a2: 				return new BigDecimal(value.getString().trim());
1:2c6f0a2: 			} catch (NumberFormatException nfe) {
1:2c6f0a2: 				throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "java.math.BigDecimal");
1:2c6f0a2: 			}
1:2c6f0a2: 		case Types.BIGINT:
1:2c6f0a2: 			return BigDecimal.valueOf(value.getLong());
1:2c6f0a2: 		default:
1:2c6f0a2: 			if (SanityManager.DEBUG)
1:2c6f0a2: 				SanityManager.THROWASSERT("invalid return from " + value.getClass() + ".typeToBigDecimal() " + value.typeToBigDecimal());
1:2c6f0a2: 			return null;
1:2c6f0a2: 		}
1:2c6f0a2: 	}
1:eac0369: 
1:eac0369: 	/**
1:1ccdf3e: 	 * Calculate the number of digits to the left of the decimal point
1:1ccdf3e: 	 * of the passed in value.
1:1ccdf3e: 	 * @param decimalValue Value to get whole digits from, never null.
1:1ccdf3e: 	 * @return number of whole digits.
1:1ccdf3e: 	 */
1:509ccb9: 	private static int getWholeDigits(BigDecimal decimalValue)
1:eac0369: 	{
1:eac0369:         /**
1:e7c5a46:          * if ONE > abs(value) then the number of whole digits is 0
1:eac0369:          */
1:e7c5a46:         decimalValue = decimalValue.abs();
1:5465561:         if (BigDecimal.ONE.compareTo(decimalValue) == 1)
1:eac0369:         {
1:e7c5a46:             return 0;
1:eac0369:         }
1:eac0369: 
1:c655d66:         // precision is the number of digits in the unscaled value,
1:c655d66:         // subtracting the scale (positive or negative) will give the
1:c655d66:         // number of whole digits.
1:c655d66:         return decimalValue.precision() - decimalValue.scale();
1:1ccdf3e: 	}
1:1ccdf3e: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * @param scale		The result scale, if &lt; 0, calculate the scale according
commit:4469400
/////////////////////////////////////////////////////////////////////////
1: import java.math.RoundingMode;
/////////////////////////////////////////////////////////////////////////
1: 			value = value.setScale(scale, RoundingMode.DOWN);
/////////////////////////////////////////////////////////////////////////
1: 		result.setBigDecimal
1:           (
1:            dividendBigDecimal.divide
1:            (
1:             divisorBigDecimal,
1:             scale > -1 ?
1:             scale :
1:             Math.max
1:             (
1:              (dividendBigDecimal.scale() + SQLDecimal.getWholeDigits(divisorBigDecimal) + 1), 
1:              NumberDataValue.MIN_DECIMAL_DIVIDE_SCALE
1:             ),
1:             RoundingMode.DOWN)
1:            );
/////////////////////////////////////////////////////////////////////////
1: 		value = value.setScale(desiredScale, RoundingMode.DOWN);
commit:96748ad
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (   (localValue.compareTo(MINLONG_MINUS_ONE) == 1)
1: 			&& (localValue.compareTo(MAXLONG_PLUS_ONE) == -1)) {
commit:2431ece
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c655d66
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return (localValue == null) ? null : localValue.toPlainString();
/////////////////////////////////////////////////////////////////////////
1: 
1:         // precision is the number of digits in the unscaled value,
1:         // subtracting the scale (positive or negative) will give the
1:         // number of whole digits.
1:         return decimalValue.precision() - decimalValue.scale();
commit:5465561
/////////////////////////////////////////////////////////////////////////
1: 		return localValue.compareTo(BigDecimal.ZERO) != 0;
/////////////////////////////////////////////////////////////////////////
1: 		setCoreValue(theValue ? BigDecimal.ONE : BigDecimal.ZERO);
/////////////////////////////////////////////////////////////////////////
1: 		if (divisorBigDecimal.compareTo(BigDecimal.ZERO) == 0)
/////////////////////////////////////////////////////////////////////////
1:         return !isNull() && (getBigDecimal().compareTo(BigDecimal.ZERO) == -1);
/////////////////////////////////////////////////////////////////////////
1:         if (BigDecimal.ONE.compareTo(decimalValue) == 1)
commit:9548d38
/////////////////////////////////////////////////////////////////////////
1: 	public void setBigDecimal(BigDecimal theValue) throws StandardException
1: 		setCoreValue(theValue);
commit:4ecfb0e
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:854dd10
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * @see DataValueDescriptor#cloneValue
1:      */
1:     public DataValueDescriptor cloneValue(boolean forceMaterialization)
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:5b9d451
/////////////////////////////////////////////////////////////////////////
0: 		else if (toPlainString == null)
/////////////////////////////////////////////////////////////////////////
0:         if (bdPrecision != null)
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:806114c
/////////////////////////////////////////////////////////////////////////
1: 	 * Set the value from a correctly typed BigDecimal object.
1: 	 * @throws StandardException 
1: 	 */
1: 	void setObject(Object theValue) throws StandardException
1: 		setValue((BigDecimal) theValue);
1: 	
/////////////////////////////////////////////////////////////////////////
1: 	public void setWidth(int desiredPrecision, 
1: 			return;
/////////////////////////////////////////////////////////////////////////
commit:a765e16
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 			return getString();
commit:6d0a34c
/////////////////////////////////////////////////////////////////////////
1: 		setFrom(source);
/////////////////////////////////////////////////////////////////////////
1: 	 * This method implements the + operator for DECIMAL.
/////////////////////////////////////////////////////////////////////////
1: 		
/////////////////////////////////////////////////////////////////////////
1: 		
commit:9d34086
/////////////////////////////////////////////////////////////////////////
commit:1ccdf3e
/////////////////////////////////////////////////////////////////////////
0:     private static final Method bdPrecision;
/////////////////////////////////////////////////////////////////////////
1:         try {
0:             m = BigDecimal.class.getMethod("precision", null);
0:         } catch (NoSuchMethodException e) {
0:             m = null;
1:         }
0:         bdPrecision = m;
/////////////////////////////////////////////////////////////////////////
1: 	 *	<LI> scale (zero or positive) as a byte </LI>
1: 	 *	<LI> length of byte array as a byte</LI>
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			// J2SE 5.0 introduced negative scale value for BigDecimals.
1: 			// In previouse Java releases a negative scale was not allowed
1: 			// (threw an exception on setScale and the constructor that took
1: 			// a scale).
1: 			//
1: 			// Thus the Derby format for DECIMAL implictly assumed a
1: 			// positive or zero scale value, and thus now must explicitly
1: 			// be positive. This is to allow databases created under J2SE 5.0
1: 			// to continue to be supported under JDK 1.3/JDK 1.4, ie. to continue
1: 			// the platform independence, independent of OS/cpu and JVM.
1: 			//
1: 			// If the scale is negative set the scale to be zero, this results
1: 			// in an unchanged value with a new scale. A BigDecimal with a
1: 			// negative scale by definition is a whole number.
1: 			// e.g. 1000 can be represented by:
1: 			//    a BigDecimal with scale -3 (unscaled value of 1)
1: 			// or a BigDecimal with scale 0 (unscaled value of 1000)
1: 			
1: 			if (scale < 0) {			
1: 				scale = 0;
1: 				value = value.setScale(0);
1: 			}
1: 
1: 		
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (scale < 0)
1: 				SanityManager.THROWASSERT("DECIMAL scale at writeExternal is negative "
1: 					+ scale + " value " + toString());
1: 		}
/////////////////////////////////////////////////////////////////////////
1: 			
1: 			((desiredPrecision - desiredScale) <  SQLDecimal.getWholeDigits(getBigDecimal())))
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Return the SQL scale of this value, number of digits after the
1: 	 * decimal point, or zero for a whole number. This does not match the
1: 	 * return from BigDecimal.scale() since in J2SE 5.0 onwards that can return
1: 	 * negative scales.
1: 	 */
1: 		if (isNull())
1: 			
1: 		BigDecimal localValue = getBigDecimal();
1: 		return SQLDecimal.getWholeDigits(localValue) + getDecimalValueScale();
1: 	/**
1: 	 * Return the SQL scale of this value, number of digits after the
1: 	 * decimal point, or zero for a whole number. This does not match the
1: 	 * return from BigDecimal.scale() since in J2SE 5.0 onwards that can return
1: 	 * negative scales.
1: 	 */
1: 		if (isNull())
1: 			return 0;
1: 		
1: 		if (value == null)
1: 			return rawScale;
1: 	
1: 		int scale = value.scale();
1: 		if (scale >= 0)
1: 			return scale;
1: 		
1: 		// BigDecimal scale is negative, so number must have no fractional
1: 		// part as its value is the unscaled value * 10^-scale
1: 		return 0;
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	 * Calculate the number of digits to the left of the decimal point
1: 	 * of the passed in value.
1: 	 * @param decimalValue Value to get whole digits from, never null.
1: 	 * @return number of whole digits.
1: 	 */
/////////////////////////////////////////////////////////////////////////
1:         
0:         if (JVMInfo.JDK_ID >= JVMInfo.J2SE_15)
1: 		{
0: 	        // use reflection so we can still compile using JDK1.4
0: 			// if we are prepared to require 1.5 to compile then this can be a
0: 			// direct call
1: 			try {
0: 				// precision is the number of digits in the unscaled value,
0: 				// subtracting the scale (positive or negative) will give the
0: 				// number of whole digits.
0: 				int precision = ((Integer) bdPrecision.invoke(decimalValue,
0: 						null)).intValue();
0: 				return precision - decimalValue.scale();
0: 			} catch (IllegalAccessException e) {
0: 				// can't happen based on the JDK spec
0: 				throw new IllegalAccessError("precision");
0: 			} catch (InvocationTargetException e) {
0: 				Throwable t = e.getTargetException();
0: 				if (t instanceof RuntimeException) {
0: 					throw (RuntimeException) t;
0: 				} else if (t instanceof Error) {
0: 					throw (Error) t;
1: 				} else {
0: 					// can't happen
0: 					throw new IncompatibleClassChangeError("precision");
1: 				}
1: 			}
1:             
1: 		}
1:    
commit:b69c0b7
/////////////////////////////////////////////////////////////////////////
0: 											SQLDecimal.getWholeDigits(divisorBigDecimal) +
/////////////////////////////////////////////////////////////////////////
1: 				
/////////////////////////////////////////////////////////////////////////
0: 		return SQLDecimal.getWholeDigits(decimalValue) + decimalValue.scale();
/////////////////////////////////////////////////////////////////////////
0: 		return SQLDecimal.getWholeDigits(getBigDecimal());
commit:a1970a9
/////////////////////////////////////////////////////////////////////////
0: 	private static final BigDecimal ZERO = BigDecimal.valueOf(0L);
0: 	private static final BigDecimal ONE = BigDecimal.valueOf(1L);
commit:2a58829
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private BigDecimal	getBigDecimal()
/////////////////////////////////////////////////////////////////////////
1: 		setCoreValue(SQLDecimal.getBigDecimal(theValue));
/////////////////////////////////////////////////////////////////////////
1: 		BigDecimal otherValue = SQLDecimal.getBigDecimal(arg);
/////////////////////////////////////////////////////////////////////////
0: 		setCoreValue(SQLDecimal.getBigDecimal(source));
/////////////////////////////////////////////////////////////////////////
1: 		result.setBigDecimal(SQLDecimal.getBigDecimal(addend1).add(SQLDecimal.getBigDecimal(addend2)));
/////////////////////////////////////////////////////////////////////////
1: 		result.setBigDecimal(SQLDecimal.getBigDecimal(left).subtract(SQLDecimal.getBigDecimal(right)));
/////////////////////////////////////////////////////////////////////////
1: 		result.setBigDecimal(SQLDecimal.getBigDecimal(left).multiply(SQLDecimal.getBigDecimal(right)));
/////////////////////////////////////////////////////////////////////////
1: 		BigDecimal divisorBigDecimal = SQLDecimal.getBigDecimal(divisor);
1: 		BigDecimal dividendBigDecimal = SQLDecimal.getBigDecimal(dividend);
commit:2c6f0a2
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Types;
/////////////////////////////////////////////////////////////////////////
1: 		if (isNull())
/////////////////////////////////////////////////////////////////////////
1: 		if (isNull())
/////////////////////////////////////////////////////////////////////////
1: 		if (isNull())
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * DECIMAL implementation. Convert to a BigDecimal using getObject
1: 	 * which will return a BigDecimal
1: 	 */
1: 	public int typeToBigDecimal()
1: 	{
1: 		return java.sql.Types.DECIMAL;
1: 	}
/////////////////////////////////////////////////////////////////////////
1: 			value = resultSet.getBigDecimal(colNumber);
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/**
1: 	 * Get a BigDecimal representing the value of a DataValueDescriptor
1: 	 * @param value Non-null value to be converted
1: 	 * @return BigDecimal value
1: 	 * @throws StandardException Invalid conversion or out of range.
1: 	 */
1: 	public static BigDecimal getBigDecimal(DataValueDescriptor value) throws StandardException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 		{
1: 			if (value.isNull())
1: 				SanityManager.THROWASSERT("NULL value passed to SQLDecimal.getBigDecimal");
1: 		}
1: 		
1: 		switch (value.typeToBigDecimal())
1: 		{
1: 		case Types.DECIMAL:
1: 			return (BigDecimal) value.getObject();
1: 		case Types.CHAR:
1: 			try {
1: 				return new BigDecimal(value.getString().trim());
1: 			} catch (NumberFormatException nfe) {
1: 				throw StandardException.newException(SQLState.LANG_FORMAT_EXCEPTION, "java.math.BigDecimal");
1: 			}
1: 		case Types.BIGINT:
1: 			return BigDecimal.valueOf(value.getLong());
1: 		default:
1: 			if (SanityManager.DEBUG)
1: 				SanityManager.THROWASSERT("invalid return from " + value.getClass() + ".typeToBigDecimal() " + value.typeToBigDecimal());
1: 			return null;
1: 		}
1: 	}
commit:6ae3022
/////////////////////////////////////////////////////////////////////////
0: 		else if (JVMInfo.JDK_ID < JVMInfo.J2SE_15)
commit:d7f7457
/////////////////////////////////////////////////////////////////////////
0: 			setCoreValue((BigDecimal)theValue);
/////////////////////////////////////////////////////////////////////////
0: 		setCoreValue(theValue.getBigDecimal());
/////////////////////////////////////////////////////////////////////////
1: 		Only to be called when the application sets a value using BigDecimal
1: 		through setBigDecimal calls.
1: 	*/
0: 	public void setBigDecimal(Number theValue) throws StandardException
1: 		setCoreValue((BigDecimal) theValue);
1: 	}
1: 
1: 	/**
1: 		Called when setting a DECIMAL value internally or from
1: 		through a procedure or function.
1: 		Handles long in addition to BigDecimal to handle
1: 		identity being stored as a long but returned as a DECIMAL.
1: 	*/
1: 	public void setValue(Number theValue) throws StandardException
1: 	{
1: 		if (SanityManager.ASSERT)
1: 		{
1: 			if (theValue != null &&
1: 				!(theValue instanceof java.math.BigDecimal) &&
1: 				!(theValue instanceof java.lang.Long))
1: 				SanityManager.THROWASSERT("SQLDecimal.setValue(Number) passed a " + theValue.getClass());
1: 		}
1: 
1: 		if (theValue instanceof BigDecimal || theValue == null)
1: 			setCoreValue((BigDecimal) theValue);
1: 		else
1: 			setValue(theValue.longValue());
/////////////////////////////////////////////////////////////////////////
0: 		setCoreValue(source.getBigDecimal());
/////////////////////////////////////////////////////////////////////////
0: 		result.setBigDecimal(addend1.getBigDecimal().add(addend2.getBigDecimal()));
/////////////////////////////////////////////////////////////////////////
0: 		result.setBigDecimal(left.getBigDecimal().subtract(right.getBigDecimal()));
/////////////////////////////////////////////////////////////////////////
0: 		result.setBigDecimal(left.getBigDecimal().multiply(right.getBigDecimal()));
/////////////////////////////////////////////////////////////////////////
0: 		result.setBigDecimal(dividendBigDecimal.divide(
/////////////////////////////////////////////////////////////////////////
1: 		result.setBigDecimal(getBigDecimal().negate());
commit:fdb2deb
/////////////////////////////////////////////////////////////////////////
1: public final class SQLDecimal extends NumberDataType implements VariableSizeDataValue
commit:509ccb9
/////////////////////////////////////////////////////////////////////////
0: final class SQLDecimal extends NumberDataType implements VariableSizeDataValue
0: 	static final BigDecimal ZERO = BigDecimal.valueOf(0L);
0: 	static final BigDecimal ONE = BigDecimal.valueOf(1L);
0: 	static final BigDecimal MAXLONG_PLUS_ONE = BigDecimal.valueOf(Long.MAX_VALUE).add(ONE);
0: 	static final BigDecimal MINLONG_MINUS_ONE = BigDecimal.valueOf(Long.MIN_VALUE).subtract(ONE);
/////////////////////////////////////////////////////////////////////////
1: 		return getDecimalValuePrecision();
/////////////////////////////////////////////////////////////////////////
1: 	public int getDecimalValuePrecision()
/////////////////////////////////////////////////////////////////////////
0: 	private static int getPrecision(BigDecimal decimalValue)
/////////////////////////////////////////////////////////////////////////
1: 	public int getDecimalValueScale()
0: 	private int getWholeDigits()
1: 	private static int getWholeDigits(BigDecimal decimalValue)
/////////////////////////////////////////////////////////////////////////
commit:8bf0832
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.info.JVMInfo;
0: import java.lang.reflect.Method;
0: import java.lang.reflect.InvocationTargetException;
/////////////////////////////////////////////////////////////////////////
1: 	public SQLDecimal(BigDecimal val, int nprecision, int scale)
/////////////////////////////////////////////////////////////////////////
0: 		else if (JVMInfo.JDK_ID < 6)
1:         else
1:         {
0:             // use reflection so we can still compile using JDK1.4
0:             // if we are prepared to require 1.5 to compile then this can be a direct call
1:             try {
0:                 return (String) toPlainString.invoke(localValue, null);
0:             } catch (IllegalAccessException e) {
0:                 // can't happen based on the JDK spec
0:                 throw new IllegalAccessError("toPlainString");
0:             } catch (InvocationTargetException e) {
0:                 Throwable t = e.getTargetException();
0:                 if (t instanceof RuntimeException) {
0:                     throw (RuntimeException) t;
0:                 } else if (t instanceof Error) {
0:                     throw (Error) t;
0:                 } else {
0:                     // can't happen
0:                     throw new IncompatibleClassChangeError("toPlainString");
1:                 }
1:             }
1:         }
0:     private static final Method toPlainString;
0:     static {
0:         Method m;
1:         try {
0:             m = BigDecimal.class.getMethod("toPlainString", null);
0:         } catch (NoSuchMethodException e) {
0:             m = null;
1:         }
0:         toPlainString = m;
1:     }
1: 
commit:e7c5a46
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	 * @throws StandardException				Thrown for null into
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	 * @param decimalValue the big decimal
/////////////////////////////////////////////////////////////////////////
1:         /**
1:          * if ONE > abs(value) then the number of whole digits is 0
1:          */
1:         decimalValue = decimalValue.abs();
0:         if (ONE.compareTo(decimalValue) == 1)
1:         {
1:             return 0;
1:         }
1: 
0: 		String s = decimalValue.toString();
0:         return (decimalValue.scale() == 0) ? s.length() : s.indexOf('.');
1: 
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.types.SQLDecimal
1: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:95dfbea
/////////////////////////////////////////////////////////////////////////
1: 			BigInteger bi = value.unscaledValue();
/////////////////////////////////////////////////////////////////////////
1: 		in.readFully(rawData);
/////////////////////////////////////////////////////////////////////////
0: 		in.readFully(rawData);
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.types;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.VariableSizeDataValue;
1: 
0: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: import org.apache.derby.iapi.services.io.Storable;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.services.cache.ClassSize;
1: 
0: import org.apache.derby.iapi.types.*;
1: 
1: import java.math.BigDecimal;
1: import java.math.BigInteger;
0: import java.lang.Math;
1: import java.io.ObjectOutput;
1: import java.io.ObjectInput;
1: import java.io.IOException;
1: 
1: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: 
1: /**
1:  * SQLDecimal satisfies the DataValueDescriptor
1:  * interfaces (i.e., OrderableDataType). It implements a numeric/decimal column, 
1:  * e.g. for * storing a column value; it can be specified
1:  * when constructed to not allow nulls. Nullability cannot be changed
1:  * after construction, as it affects the storage size and mechanism.
1:  * <p>
1:  * Because OrderableDataType is a subtype of DataType,
1:  * SQLDecimal can play a role in either a DataType/Row
1:  * or a OrderableDataType/Row, interchangeably.
1:  * <p>
1:  * We assume the store has a flag for nullness of the value,
1:  * and simply return a 0-length array for the stored form
1:  * when the value is null.
1:  *
0:  * @author jamie
1:  */
0: public final class SQLDecimal extends NumberDataType implements VariableSizeDataValue
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	public static final BigDecimal ZERO = BigDecimal.valueOf(0L);
0: 	public static final BigDecimal ONE = BigDecimal.valueOf(1L);
0: 	public static final BigDecimal MAXLONG_PLUS_ONE = BigDecimal.valueOf(Long.MAX_VALUE).add(ONE);
0: 	public static final BigDecimal MINLONG_MINUS_ONE = BigDecimal.valueOf(Long.MIN_VALUE).subtract(ONE);
1: 
1: 
1: 
1: 	/**
1: 	 * object state.  Note that scale and precision are 
1: 	 * always determined dynamically from value when
1: 	 * it is not null.
1: 
1:        The field value can be null without the data value being null.
1: 	   In this case the value is stored in rawData and rawScale. This
1: 	   is to allow the minimal amount of work to read a SQLDecimal from disk.
1: 	   Creating the BigDecimal is expensive as it requires allocating
1: 	   three objects, the last two are a waste in the case the row does
1: 	   not qualify or the row will be written out by the sorter before being
1: 	   returned to the application.
1: 		<P>
1: 		This means that this field must be accessed for read indirectly through
1: 		the getBigDecimal() method, and when setting it the rawData field must
1: 		be set to null.
1: 
1: 	 */
1: 	private BigDecimal	value;
1: 
1: 	/**
1: 		See comments for value
1: 	*/
1: 	private byte[]		rawData;
1: 
1: 	/**
1: 		See comments for value
1: 	*/
1: 	private int			rawScale;
1: 
1:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLDecimal.class);
1:     private static final int BIG_DECIMAL_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( BigDecimal.class);
1: 
1:     public int estimateMemoryUsage()
1:     {
1:         int sz = BASE_MEMORY_USAGE;
1:         if( null != value)
1:             sz += BIG_DECIMAL_MEMORY_USAGE + (value.unscaledValue().bitLength() + 8)/8;
1:         if( null != rawData)
1:             sz += rawData.length;
1:         return sz;
1:     }
1: 
1: 
1: 	////////////////////////////////////////////////////////////////////
1: 	//
1: 	// CLASS INTERFACE
1: 	//
1: 	////////////////////////////////////////////////////////////////////
1: 	/** no-arg constructor, required by Formattable */
1: 	public SQLDecimal() 
1: 	{
1: 	}
1: 
1: 	public SQLDecimal(BigDecimal val)
1: 	{
1: 		value = val;
1: 	}
1: 
0: 	public SQLDecimal(BigDecimal val, int precision, int scale) 
1: 			throws StandardException
1: 	{
1: 		
1: 		value = val;
1: 		if ((value != null) && (scale >= 0))
1: 		{
0: 			value = value.setScale(scale, 
0: 							BigDecimal.ROUND_DOWN);
1: 		}
1: 	}
1: 
1: 	public SQLDecimal(String val) 
1: 	{
1: 		value = new BigDecimal(val);
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 * (mostly implemented in DataType)
1: 	 *
1: 	 */
1: 
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public int	getInt() throws StandardException
1: 	{
1: 		BigDecimal localValue = getBigDecimal();
1: 		if (localValue == null)
1: 			return 0;
1: 
0: 		try {
1: 			long lv = getLong();
1: 
1: 			if ((lv >= Integer.MIN_VALUE) && (lv <= Integer.MAX_VALUE))
1: 				return (int) lv;
1: 
1: 		} catch (StandardException se) {
1: 		}
1: 
1: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public byte	getByte() throws StandardException
1: 	{
1: 		BigDecimal localValue = getBigDecimal();
1: 
1: 		if (localValue == null)
1: 			return (byte)0;
1: 
0: 		try {
1: 			long lv = getLong();
1: 
1: 			if ((lv >= Byte.MIN_VALUE) && (lv <= Byte.MAX_VALUE))
1: 				return (byte) lv;
1: 
1: 		} catch (StandardException se) {
1: 		}
1: 
1: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TINYINT");
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public short	getShort() throws StandardException
1: 	{
1: 		BigDecimal localValue = getBigDecimal();
1: 		if (localValue == null)
1: 			return (short)0;
1: 
0: 		try {
1: 			long lv = getLong();
1: 
1: 			if ((lv >= Short.MIN_VALUE) && (lv <= Short.MAX_VALUE))
1: 				return (short) lv;
1: 
1: 		} catch (StandardException se) {
1: 		}
1: 
1: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "SMALLINT");
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public long	getLong() throws StandardException
1: 	{
1: 		BigDecimal localValue = getBigDecimal();
1: 		if (localValue == null)
1: 			return (long)0;
1: 
1: 		// Valid range for long is
1: 		//   greater than Long.MIN_VALUE - 1
1: 		// *and*
1: 		//   less than Long.MAX_VALUE + 1
1: 		//
1: 		// This ensures that DECIMAL values with an integral value
1: 		// equal to the Long.MIN/MAX_VALUE round correctly to those values.
1: 		// e.g. 9223372036854775807.1  converts to 9223372036854775807
1: 		// this matches DB2 UDB behaviour
1: 
0: 		if (   (localValue.compareTo(SQLDecimal.MINLONG_MINUS_ONE) == 1)
0: 			&& (localValue.compareTo(SQLDecimal.MAXLONG_PLUS_ONE) == -1)) {
1: 
1: 			return localValue.longValue();
1: 		}
1: 
1: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "BIGINT");
1: 	}
1: 
1: 	/**
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public float getFloat() throws StandardException
1: 	{
1: 		BigDecimal localValue = getBigDecimal();
1: 		if (localValue == null)
1: 			return (float)0;
1: 
1: 		// If the BigDecimal is out of range for the float
1: 		// then positive or negative infinity is returned.
1: 		float value = NumberDataType.normalizeREAL(localValue.floatValue());
1: 
1: 		return value;
1: 	}
1: 
1: 	/**
1: 	 * 
1: 	 * If we have a value that is greater than the maximum double,
1: 	 * exception is thrown.  Otherwise, ok.  If the value is less
1: 	 * than can be represented by a double, ti will get set to
1: 	 * the smallest double value.
1: 	 *
1: 	 * @exception StandardException thrown on failure to convert
1: 	 */
1: 	public double getDouble() throws StandardException
1: 	{
1: 		BigDecimal localValue = getBigDecimal();
1: 		if (localValue == null)
1: 			return (double)0;
1: 
1: 		// If the BigDecimal is out of range for double
1: 		// then positive or negative infinity is returned.
1: 		double value = NumberDataType.normalizeDOUBLE(localValue.doubleValue());
1: 		return value;
1: 	}
1: 
0: 	public BigDecimal	getBigDecimal()
1: 	{
1: 		if ((value == null) && (rawData != null)) 
1: 		{
1: 			value = new BigDecimal(new BigInteger(rawData), rawScale);
1: 		}
1: 
1: 		return value;
1: 	}
1: 
1:     // 0 or null is false, all else is true
1: 	public boolean	getBoolean()
1: 	{
1: 
1: 		BigDecimal localValue = getBigDecimal();
1: 		if (localValue == null)
1: 			return false;
1: 
0: 		return localValue.compareTo(ZERO) != 0;
1: 	}
1: 
1: 	public String	getString()
1: 	{
1: 		BigDecimal localValue = getBigDecimal();
1: 		if (localValue == null)
0: 			return null;
1: 		else
0: 			return localValue.toString();
1: 	}
1: 
1: 	public Object	getObject()
1: 	{
1: 		/*
1: 		** BigDecimal is immutable
1: 		*/
1: 		return getBigDecimal();
1: 	}
1: 
1: 	/**
0: 	 * @see DataValueDescriptor#setValue
1: 	 *
1: 	 */	
0: 	public void setValue(Object theValue)
1: 		throws StandardException
1: 	{
1: 		rawData = null;
0: 		if ((theValue instanceof BigDecimal) ||
0: 			(theValue == null))
1: 		{
0: 			setValue((BigDecimal)theValue);
1: 		}
0: 		else if (theValue instanceof Number)
1: 		{
0: 			value = new BigDecimal(((Number)theValue).doubleValue());
1: 		}
1: 		else
1: 		{
0: 			genericSetObject(theValue);
1: 		}
1: 	}
1: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
1: 
0: 		setValue(theValue.getBigDecimal());
1: 	}
1: 
1: 	public int	getLength()
1: 	{
0: 		return getPrecision();
1: 	}
1: 
1: 	// this is for DataType's error generator
1: 	public String getTypeName()
1: 	{
1: 		return TypeId.DECIMAL_NAME;
1: 	}
1: 
1: 	/*
1: 	 * Storable interface, implies Externalizable, TypedFormat
1: 	 */
1: 
1: 	/**
1: 		Return my format identifier.
1: 
1: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
1: 	*/
1: 	public int getTypeFormatId() 
1: 	{
1: 		return StoredFormatIds.SQL_DECIMAL_ID;
1: 	}
1: 
1: 	/*
1: 	 * see if the decimal value is null.
1: 	 */
1: 	/** @see Storable#isNull */
1: 	public boolean isNull()
1: 	{
1: 		return (value == null) && (rawData == null);
1: 	}
1: 
1: 	/** 
1: 	 * Distill the BigDecimal to a byte array and
1: 	 * write out: <UL>
0: 	 *	<LI> scale (int) </LI>
0: 	 *	<LI> length of byte array </LI>
1: 	 *	<LI> the byte array </LI> </UL>
1: 	 *
1: 	 */
1: 	public void writeExternal(ObjectOutput out) throws IOException 
1: 	{
1: 		// never called when value is null
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(! isNull());
1: 
1: 		int scale;
1: 		byte[] byteArray;
1: 
1: 		if (value != null) {
1: 			scale = value.scale();
0: 			BigInteger bi = value.movePointRight(scale).toBigInteger();
1: 			byteArray = bi.toByteArray();
0: 		} else {
1: 			scale = rawScale;
1: 			byteArray = rawData;
1: 		}
1: 
1: 		out.writeByte(scale);
1: 		out.writeByte(byteArray.length);
1: 		out.write(byteArray);
1: 	}
1: 
1: 	/** 
1: 	 * Note the use of rawData: we reuse the array if the
1: 	 * incoming array is the same length or smaller than
1: 	 * the array length.  
1: 	 * 
1: 	 * @see java.io.Externalizable#readExternal 
1: 	 */
1: 	public void readExternal(ObjectInput in) throws IOException 
1: 	{
1: 		// clear the previous value to ensure that the
1: 		// rawData value will be used
1: 		value = null;
1: 
1: 		rawScale = in.readUnsignedByte();
1: 		int size = in.readUnsignedByte();
1: 
1: 		/*
1: 		** Allocate a new array if the data to read
1: 		** is larger than the existing array, or if
1: 		** we don't have an array yet.
1: 
1:         Need to use readFully below and NOT just read because read does not
1:         guarantee getting size bytes back, whereas readFully does (unless EOF).
1:         */
1: 		if ((rawData == null) || size != rawData.length)
1: 		{
1: 			rawData = new byte[size];
0: 			in.readFully(rawData);
1: 		}
1: 		/*
0: 		** Copy the incoming array into the last
0: 		** bytes of the existing array.  BigInteger
0: 		** is implemented to ignore leading zeroed bytes.
1: 		*/
1: 		else
1: 		{
0: 			// zero out the leading bytes
0: 			int stop = (rawData.length - size);
0: 			for (int i = 0; i < stop; i++)
1: 			{
0: 				rawData[i] = 0;
1: 			}
0: 			in.readFully(rawData,
0: 					     stop,  // start at rawData[stop]
0: 					     size); // read in size bytes
1: 		}
1: 
1: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException 
1: 	{
1: 		// clear the previous value to ensure that the
1: 		// rawData value will be used
1: 		value = null;
1: 
1: 		rawScale = in.readUnsignedByte();
1: 		int size = in.readUnsignedByte();
1: 
1: 		/*
1: 		** Allocate a new array if the data to read
1: 		** is larger than the existing array, or if
1: 		** we don't have an array yet.
1: 
1:         Need to use readFully below and NOT just read because read does not
1:         guarantee getting size bytes back, whereas readFully does (unless EOF).
1:         */
1: 		if ((rawData == null) || size != rawData.length)
1: 		{
1: 			rawData = new byte[size];
0: 			in.readFully(rawData);
1: 		}
1: 		/*
0: 		** Copy the incoming array into the last
0: 		** bytes of the existing array.  BigInteger
0: 		** is implemented to ignore leading zeroed bytes.
1: 		*/
1: 		else
1: 		{
0: 			// zero out the leading bytes
0: 			int stop = (rawData.length - size);
0: 			for (int i = 0; i < stop; i++)
1: 			{
0: 				rawData[i] = 0;
1: 			}
0: 			in.readFully(rawData,
0: 					     stop,  // start at rawData[stop]
0: 					     size); // read in size bytes
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 	 * @see Storable#restoreToNull
1: 	 *
1: 	 */
1: 	public void restoreToNull()
1: 	{
1: 		value = null;
1: 		rawData = null;
1: 	}
1: 
1: 
1: 	/** @exception StandardException		Thrown on error */
1: 	protected int typeCompare(DataValueDescriptor arg) throws StandardException
1: 	{
0: 		BigDecimal otherValue = arg.getBigDecimal();
1: 
1: 		return getBigDecimal().compareTo(otherValue);
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/**
0: 	 * <B> WARNING </B> clone is a shallow copy
0:  	 * @see DataValueDescriptor#getClone 
1: 	 */
0: 	public DataValueDescriptor getClone()
1: 	{
1: 		return new SQLDecimal(getBigDecimal());
1: 	}
1: 
1: 	/**
1: 	 * @see DataValueDescriptor#getNewNull
1: 	 */
1: 	public DataValueDescriptor getNewNull()
1: 	{
1: 		return new SQLDecimal();
1: 	}
1: 
1: 	/** 
1: 	 * @see DataValueDescriptor#setValueFromResultSet 
1: 	 *
1: 	 * @exception SQLException		Thrown on error
1: 	 */
1: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
1: 									  boolean isNullable)
1: 		throws SQLException
1: 	{
0: 			ResultSetMetaData rsmd = resultSet.getMetaData();
0: 			value = resultSet.getBigDecimal(colNumber,
0: 											rsmd.getScale(colNumber));
1: 			rawData = null;
1: 	}
1: 	/**
1: 		Set the value into a PreparedStatement.
1: 
1: 		@exception SQLException Error setting value in PreparedStatement
1: 	*/
1: 	public final void setInto(PreparedStatement ps, int position) throws SQLException {
1: 
1: 		if (isNull()) {
1: 			ps.setNull(position, java.sql.Types.DECIMAL);
1: 			return;
1: 		}
1: 
1: 		ps.setBigDecimal(position, getBigDecimal());
1: 	}
1: 	
1: 	/**
1: 	 *
1: 	 * <B> WARNING </B> there is no checking to make sure
1: 	 * that theValue doesn't exceed the precision/scale of
1: 	 * the current SQLDecimal.  It is just assumed that the
1: 	 * SQLDecimal is supposed to take the precision/scale of
1: 	 * the BigDecimalized String.
1: 	 *
1: 	 * @exception StandardException throws NumberFormatException
1: 	 *		when the String format is not recognized.
1: 	 */
1: 	public void setValue(String theValue) throws StandardException
1: 	{
1: 		rawData = null;
1: 
1: 		if (theValue == null)
1: 		{
1: 			value = null;
1: 		}
1: 		else
1: 		{
1: 		    try 
1: 			{
1: 				theValue = theValue.trim();
1: 		        value = new BigDecimal(theValue);
1: 				rawData = null;
1: 			} catch (NumberFormatException nfe) 
1: 			{
1: 			    throw invalidFormat();
1: 			}
1: 		}
1: 	}
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void setValue(double theValue) throws StandardException
1: 	{
1: 		setCoreValue(NumberDataType.normalizeDOUBLE(theValue));
1: 	}
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 */
1: 	public void setValue(float theValue)
1: 		throws StandardException
1: 	{
1: 		setCoreValue((double)NumberDataType.normalizeREAL(theValue));
1: 	}
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 */
1: 	public void setValue(long theValue)
1: 	{
1: 		value = BigDecimal.valueOf(theValue);
1: 		rawData = null;
1: 	}
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 */
1: 	public void setValue(int theValue)
1: 	{
1: 		setValue((long)theValue);
1: 	}
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 */
0: 	public void setValue(short theValue)
1: 	{
1: 		setValue((long)theValue);
1: 	}
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 */
0: 	public void setValue(byte theValue)
1: 	{
1: 		setValue((long)theValue);
1: 	}
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 */
0: 	public void setValue(BigDecimal theValue)
1: 	{
0: 		setCoreValue(theValue);
1: 	}
1: 
1: 	/**
1: 	 * @see NumberDataValue#setValue
1: 	 *
1: 	 */
1: 	public void setValue(boolean theValue)
1: 	{
0: 		setCoreValue(theValue ? ONE : ZERO);
1: 	}
1: 
1: 	/*
1: 	 * DataValueDescriptor interface
1: 	 */
1: 
1: 	/** @see DataValueDescriptor#typePrecedence */
1: 	public int typePrecedence()
1: 	{
1: 		return TypeId.DECIMAL_PRECEDENCE;
1: 	}
1:     // END DataValueDescriptor interface
1: 
1: 	private void setCoreValue(BigDecimal theValue)
1: 	{
1: 		value = theValue;
1: 		rawData = null;
1: 	}
1: 
1: 	private void setCoreValue(double theValue) {
1: 		value = new BigDecimal(theValue);
1: 		rawData = null;
1: 	}
1: 
1: 	/**
1: 	 * Normalization method - this method may be called when putting
1: 	 * a value into a SQLDecimal, for example, when inserting into a SQLDecimal
1: 	 * column.  See NormalizeResultSet in execution.
1: 	 * <p>
1: 	 * Note that truncation is allowed on the decimal portion
1: 	 * of a numeric only.	
1: 	 *
1: 	 * @param desiredType	The type to normalize the source column to
1: 	 * @param source		The value to normalize
0: 	 * @param cachedDest	DataValueDescriptor, if non-null, to hold result
0: 	 *						(Reuse if normalizing multiple rows)
1: 	 *
0: 	 * @return	The normalized SQLDecimal
1: 	 *
0: 	 * @exception StandardException				Thrown for null into
1: 	 *											non-nullable column, and for
1: 	 *											truncation error
1: 	 */
1: 	public void normalize(
1: 				DataTypeDescriptor desiredType,
1: 				DataValueDescriptor source)
1: 						throws StandardException
1: 	{
1: 		int desiredScale = desiredType.getScale();
1: 		int desiredPrecision = desiredType.getPrecision();
1: 
0: 		setValue(source.getBigDecimal());
1: 		setWidth(desiredPrecision, desiredScale, true);
1: 	}
1: 
1: 
1: 	/*
1: 	** SQL Operators
1: 	*/
1: 
1: 
1: 	/**
0: 	 * This method implements the + operator for "double + double".
1: 	 *
1: 	 * @param addend1	One of the addends
1: 	 * @param addend2	The other addend
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
1: 	 *
1: 	 * @return	A SQLDecimal containing the result of the addition
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public NumberDataValue plus(NumberDataValue addend1,
1: 							NumberDataValue addend2,
1: 							NumberDataValue result)
1: 				throws StandardException
1: 	{
1: 		if (result == null)
1: 		{
1: 			result = new SQLDecimal();
1: 		}
1: 
1: 		if (addend1.isNull() || addend2.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 
0: 		result.setValue(addend1.getBigDecimal().add(addend2.getBigDecimal()));
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	 * This method implements the - operator for "decimal - decimal".
1: 	 *
1: 	 * @param left	The value to be subtracted from
1: 	 * @param right	The value to be subtracted
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
1: 	 *
1: 	 * @return	A SQLDecimal containing the result of the subtraction
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public NumberDataValue minus(NumberDataValue left,
1: 							NumberDataValue right,
1: 							NumberDataValue result)
1: 				throws StandardException
1: 	{
1: 		if (result == null)
1: 		{
1: 			result = new SQLDecimal();
1: 		}
1: 
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 
0: 		result.setValue(left.getBigDecimal().subtract(right.getBigDecimal()));
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	 * This method implements the * operator for "double * double".
1: 	 *
1: 	 * @param left	The first value to be multiplied
1: 	 * @param right	The second value to be multiplied
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
1: 	 *
1: 	 * @return	A SQLDecimal containing the result of the multiplication
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public NumberDataValue times(NumberDataValue left,
1: 							NumberDataValue right,
1: 							NumberDataValue result)
1: 				throws StandardException
1: 	{
0: 		double		tempResult;
1: 
1: 		if (result == null)
1: 		{
1: 			result = new SQLDecimal();
1: 		}
1: 
1: 		if (left.isNull() || right.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 
0: 		result.setValue(left.getBigDecimal().multiply(right.getBigDecimal()));
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	 * This method implements the / operator for BigDecimal/BigDecimal
1: 	 *
1: 	 * @param dividend	The numerator
1: 	 * @param divisor	The denominator
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
1: 	 *
1: 	 * @return	A SQLDecimal containing the result of the division
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public NumberDataValue divide(NumberDataValue dividend,
1: 							 NumberDataValue divisor,
1: 							 NumberDataValue result)
1: 				throws StandardException
1: 	{
1: 		return divide(dividend, divisor, result, -1);
1: 	}
1: 
1: 	/**
1: 	 * This method implements the / operator for BigDecimal/BigDecimal
1: 	 *
1: 	 * @param dividend	The numerator
1: 	 * @param divisor	The denominator
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
0: 	 * @param scale		The result scale, if < 0, calculate the scale according
1: 	 *					to the actual values' sizes
1: 	 *
1: 	 * @return	A SQLDecimal containing the result of the division
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public NumberDataValue divide(NumberDataValue dividend,
1: 							 NumberDataValue divisor,
1: 							 NumberDataValue result,
1: 							 int scale)
1: 				throws StandardException
1: 	{
1: 		if (result == null)
1: 		{
1: 			result = new SQLDecimal();
1: 		}
1: 
1: 		if (dividend.isNull() || divisor.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 
0: 		BigDecimal divisorBigDecimal = divisor.getBigDecimal();
1: 
0: 		if (divisorBigDecimal.compareTo(ZERO) == 0)
1: 		{
1: 			throw  StandardException.newException(SQLState.LANG_DIVIDE_BY_ZERO);
1: 		}
0: 		BigDecimal dividendBigDecimal = dividend.getBigDecimal();
1: 
1: 		/*
1: 		** Set the result scale to be either the passed in scale, whcih was
1: 		** calculated at bind time to be max(ls+rp-rs+1, 4), where ls,rp,rs
1: 		** are static data types' sizes, which are predictable and stable
1: 		** (for the whole result set column, eg.); otherwise dynamically
1: 		** calculates the scale according to actual values.  Beetle 3901
1: 		*/
0: 		result.setValue(dividendBigDecimal.divide(
0: 									divisorBigDecimal,
0: 									scale > -1 ? scale :
0: 									Math.max((dividendBigDecimal.scale() + 
0: 											getWholeDigits(divisorBigDecimal) +
0: 											1), 
0: 										NumberDataValue.MIN_DECIMAL_DIVIDE_SCALE),
0: 									BigDecimal.ROUND_DOWN));
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	 * This method implements the unary minus operator for double.
1: 	 *
1: 	 * @param result	The result of a previous call to this method, null
1: 	 *					if not called yet
1: 	 *
1: 	 * @return	A SQLDecimal containing the result of the division
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 
1: 	public NumberDataValue minus(NumberDataValue result)
1: 									throws StandardException
1: 	{
1: 		if (result == null)
1: 		{
1: 			result = new SQLDecimal();
1: 		}
1: 
1: 		if (this.isNull())
1: 		{
1: 			result.setToNull();
1: 			return result;
1: 		}
1: 
0: 		result.setValue(getBigDecimal().negate());
1: 		return result;
1: 	}
1: 
1:     /**
1:      * This method implements the isNegative method.
1:      * 
1:      * @return  A boolean.  If this.value is negative, return true.
1:      *          For positive values or null, return false.
1:      */
1: 
1:     protected boolean isNegative()
1:     {
0:         return !isNull() && (getBigDecimal().compareTo(ZERO) == -1);
1:     }
1:     
1: 	/*
1: 	 * String display of value
1: 	 */
1: 	public String toString()
1: 	{
1: 		if (isNull())
1: 			return "NULL";
1: 		else
0: 			return getBigDecimal().toString();
1: 	}
1: 
1: 	/*
1: 	 * Hash code
1: 	 */
1: 	public int hashCode()
1: 	{
1: 		long longVal;
1: 		BigDecimal localValue = getBigDecimal();
1: 
1: 		double doubleVal = (localValue != null) ? localValue.doubleValue() : 0;
1: 
1: 		if (Double.isInfinite(doubleVal))
1: 		{
1: 			/*
1: 			 ** This loses the fractional part, but it probably doesn't
1: 			 ** matter for numbers that are big enough to overflow a double -
1: 			 ** it's probably rare for numbers this big to be different only in
1: 			 ** their fractional parts.
1: 			 */
1: 			longVal = localValue.longValue();
1: 		}
1: 		else
1: 		{
1: 			longVal = (long) doubleVal;
1: 			if (longVal != doubleVal)
1: 			{
1: 				longVal = Double.doubleToLongBits(doubleVal);
1: 			}
1: 		}
1: 
1: 		return (int) (longVal ^ (longVal >> 32));
1: 	}
1: 
1: 	///////////////////////////////////////////////////////////////////////////////
1: 	//
1: 	// VariableSizeDataValue interface
1: 	//
1: 	///////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Set the precision/scale of the to the desired values. 
1: 	 * Used when CASTing.  Ideally we'd recycle normalize(), but
1: 	 * the use is different.  
1: 	 *
1: 	 * @param desiredPrecision	the desired precision -- IGNORE_PREICISION
1: 	 *					if it is to be ignored.
1: 	 * @param desiredScale	the desired scale 
1: 	 * @param errorOnTrunc	throw error on truncation (ignored -- 
1: 	 *		always thrown if we truncate the non-decimal part of
1: 	 *		the value)
0: 	 * @return this with the target width
1: 	 *
1: 	 * @exception StandardException		Thrown on non-zero truncation
1: 	 *		if errorOnTrunc is true	
1: 	 */
0: 	public DataValueDescriptor setWidth(int desiredPrecision, 
1: 			int desiredScale,
1: 			boolean errorOnTrunc)
1: 			throws StandardException
1: 	{
1: 		if (isNull())
0: 			return this;
1: 
0: 		// the getWholeDigits() call will ensure via getBigDecimal()
0: 		// that the rawData is translated into the BigDecimal in value.
1: 		if (desiredPrecision != IGNORE_PRECISION &&
0: 			((desiredPrecision - desiredScale) <  getWholeDigits()))
1: 		{
1: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, 
1: 									("DECIMAL/NUMERIC("+desiredPrecision+","+desiredScale+")"));
1: 		}
0: 		value = value.setScale(desiredScale, BigDecimal.ROUND_DOWN);
1: 		rawData = null;
0: 		return this;
1: 	}
1: 
0: 	public int getPrecision()
1: 	{
0: 		return getPrecision(getBigDecimal());
1: 	}
1: 	/**
1: 	 *
0: 	 * @param the big decimal
1: 	 *
0: 	 * @return the precision
1: 	 */	
0: 	public static int getPrecision(BigDecimal decimalValue)
1: 	{
0: 		if ((decimalValue == null) ||
0: 			 decimalValue.equals(ZERO))
1: 		{
1: 			return 0;
1: 		}	
1: 
0: 		return getWholeDigits(decimalValue) + decimalValue.scale();
1: 	}
1: 
0: 	public int getScale()
1: 	{
1: 		BigDecimal localValue = getBigDecimal();
0: 		return (localValue == null) ? 0 : localValue.scale();
1: 	}
1: 
0: 	public int getWholeDigits()
1: 	{
0: 		return getWholeDigits(getBigDecimal());
1: 	}
1: 
0: 	public static int getWholeDigits(BigDecimal decimalValue)
1: 	{
0: 		if ((decimalValue == null) ||
0: 			 decimalValue.equals(ZERO))
1: 		{
1: 			return 0;
1: 		}
1: 
1: 		/*
0: 		** Get the absolute value so we dont
0: 		** get a leading '-' sign.  Make sure
0: 		** we don't count the leading '0' as
0: 		** precision.  Would be nice to use log10, but
0: 		** we might be bigger than a double.
1: 		*/
0: 		String s = decimalValue.abs().toString();
0: 		int scale = decimalValue.scale();
0: 		return (scale == 0) ? 
0: 			s.length() :
0: 			s.indexOf('.') - (s.startsWith("0.") ? 1 : 0);
1: 	}
1: 	/**
0: 	 * Return the value field
1: 	 *
0: 	 * @return BigDecimal
1: 	 */
0: 	public BigDecimal getValue()
1: 	{
1: 		return getBigDecimal();
1: 	}
1: }
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:c2d0dcc
/////////////////////////////////////////////////////////////////////////
0: 			value = new BigDecimal(Double.toString(((Number)theValue).doubleValue()));
/////////////////////////////////////////////////////////////////////////
1: 		value = new BigDecimal(Double.toString(theValue));
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.types
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.types;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.types.DataTypeDescriptor;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: import org.apache.derby.iapi.types.NumberDataValue;
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.BooleanDataValue;
0: import org.apache.derby.iapi.types.StringDataValue;
0: import org.apache.derby.iapi.types.VariableSizeDataValue;
0: 
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.services.io.FormatIdUtil;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: import org.apache.derby.iapi.services.io.Storable;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.cache.ClassSize;
0: 
0: import org.apache.derby.iapi.types.*;
0: 
0: import java.math.BigDecimal;
0: import java.math.BigInteger;
0: import java.lang.Math;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: 
0: import java.sql.ResultSet;
0: import java.sql.ResultSetMetaData;
0: import java.sql.PreparedStatement;
0: import java.sql.SQLException;
0: 
0: /**
0:  * SQLDecimal satisfies the DataValueDescriptor
0:  * interfaces (i.e., OrderableDataType). It implements a numeric/decimal column, 
0:  * e.g. for * storing a column value; it can be specified
0:  * when constructed to not allow nulls. Nullability cannot be changed
0:  * after construction, as it affects the storage size and mechanism.
0:  * <p>
0:  * Because OrderableDataType is a subtype of DataType,
0:  * SQLDecimal can play a role in either a DataType/Row
0:  * or a OrderableDataType/Row, interchangeably.
0:  * <p>
0:  * We assume the store has a flag for nullness of the value,
0:  * and simply return a 0-length array for the stored form
0:  * when the value is null.
0:  *
0:  * @author jamie
0:  */
0: public final class SQLDecimal extends NumberDataType implements VariableSizeDataValue
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
0: 	public static final BigDecimal ZERO = BigDecimal.valueOf(0L);
0: 	public static final BigDecimal ONE = BigDecimal.valueOf(1L);
0: 	public static final BigDecimal MAXLONG_PLUS_ONE = BigDecimal.valueOf(Long.MAX_VALUE).add(ONE);
0: 	public static final BigDecimal MINLONG_MINUS_ONE = BigDecimal.valueOf(Long.MIN_VALUE).subtract(ONE);
0: 
0: 
0: 
0: 	/**
0: 	 * object state.  Note that scale and precision are 
0: 	 * always determined dynamically from value when
0: 	 * it is not null.
0: 
0:        The field value can be null without the data value being null.
0: 	   In this case the value is stored in rawData and rawScale. This
0: 	   is to allow the minimal amount of work to read a SQLDecimal from disk.
0: 	   Creating the BigDecimal is expensive as it requires allocating
0: 	   three objects, the last two are a waste in the case the row does
0: 	   not qualify or the row will be written out by the sorter before being
0: 	   returned to the application.
0: 		<P>
0: 		This means that this field must be accessed for read indirectly through
0: 		the getBigDecimal() method, and when setting it the rawData field must
0: 		be set to null.
0: 
0: 	 */
0: 	private BigDecimal	value;
0: 
0: 	/**
0: 		See comments for value
0: 	*/
0: 	private byte[]		rawData;
0: 
0: 	/**
0: 		See comments for value
0: 	*/
0: 	private int			rawScale;
0: 
0:     private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLDecimal.class);
0:     private static final int BIG_DECIMAL_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( BigDecimal.class);
0: 
0:     public int estimateMemoryUsage()
0:     {
0:         int sz = BASE_MEMORY_USAGE;
0:         if( null != value)
0:             sz += BIG_DECIMAL_MEMORY_USAGE + (value.unscaledValue().bitLength() + 8)/8;
0:         if( null != rawData)
0:             sz += rawData.length;
0:         return sz;
0:     }
0: 
0: 
0: 	////////////////////////////////////////////////////////////////////
0: 	//
0: 	// CLASS INTERFACE
0: 	//
0: 	////////////////////////////////////////////////////////////////////
0: 	/** no-arg constructor, required by Formattable */
0: 	public SQLDecimal() 
0: 	{
0: 	}
0: 
0: 	public SQLDecimal(BigDecimal val)
0: 	{
0: 		value = val;
0: 	}
0: 
0: 	public SQLDecimal(BigDecimal val, int precision, int scale) 
0: 			throws StandardException
0: 	{
0: 		
0: 		value = val;
0: 		if ((value != null) && (scale >= 0))
0: 		{
0: 			value = value.setScale(scale, 
0: 							BigDecimal.ROUND_DOWN);
0: 		}
0: 	}
0: 
0: 	public SQLDecimal(String val) 
0: 	{
0: 		value = new BigDecimal(val);
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 * (mostly implemented in DataType)
0: 	 *
0: 	 */
0: 
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public int	getInt() throws StandardException
0: 	{
0: 		BigDecimal localValue = getBigDecimal();
0: 		if (localValue == null)
0: 			return 0;
0: 
0: 		try {
0: 			long lv = getLong();
0: 
0: 			if ((lv >= Integer.MIN_VALUE) && (lv <= Integer.MAX_VALUE))
0: 				return (int) lv;
0: 
0: 		} catch (StandardException se) {
0: 		}
0: 
0: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "INTEGER");
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public byte	getByte() throws StandardException
0: 	{
0: 		BigDecimal localValue = getBigDecimal();
0: 
0: 		if (localValue == null)
0: 			return (byte)0;
0: 
0: 		try {
0: 			long lv = getLong();
0: 
0: 			if ((lv >= Byte.MIN_VALUE) && (lv <= Byte.MAX_VALUE))
0: 				return (byte) lv;
0: 
0: 		} catch (StandardException se) {
0: 		}
0: 
0: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "TINYINT");
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public short	getShort() throws StandardException
0: 	{
0: 		BigDecimal localValue = getBigDecimal();
0: 		if (localValue == null)
0: 			return (short)0;
0: 
0: 		try {
0: 			long lv = getLong();
0: 
0: 			if ((lv >= Short.MIN_VALUE) && (lv <= Short.MAX_VALUE))
0: 				return (short) lv;
0: 
0: 		} catch (StandardException se) {
0: 		}
0: 
0: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "SMALLINT");
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public long	getLong() throws StandardException
0: 	{
0: 		BigDecimal localValue = getBigDecimal();
0: 		if (localValue == null)
0: 			return (long)0;
0: 
0: 		// Valid range for long is
0: 		//   greater than Long.MIN_VALUE - 1
0: 		// *and*
0: 		//   less than Long.MAX_VALUE + 1
0: 		//
0: 		// This ensures that DECIMAL values with an integral value
0: 		// equal to the Long.MIN/MAX_VALUE round correctly to those values.
0: 		// e.g. 9223372036854775807.1  converts to 9223372036854775807
0: 		// this matches DB2 UDB behaviour
0: 
0: 		if (   (localValue.compareTo(SQLDecimal.MINLONG_MINUS_ONE) == 1)
0: 			&& (localValue.compareTo(SQLDecimal.MAXLONG_PLUS_ONE) == -1)) {
0: 
0: 			return localValue.longValue();
0: 		}
0: 
0: 		throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, "BIGINT");
0: 	}
0: 
0: 	/**
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public float getFloat() throws StandardException
0: 	{
0: 		BigDecimal localValue = getBigDecimal();
0: 		if (localValue == null)
0: 			return (float)0;
0: 
0: 		// If the BigDecimal is out of range for the float
0: 		// then positive or negative infinity is returned.
0: 		float value = NumberDataType.normalizeREAL(localValue.floatValue());
0: 
0: 		return value;
0: 	}
0: 
0: 	/**
0: 	 * 
0: 	 * If we have a value that is greater than the maximum double,
0: 	 * exception is thrown.  Otherwise, ok.  If the value is less
0: 	 * than can be represented by a double, ti will get set to
0: 	 * the smallest double value.
0: 	 *
0: 	 * @exception StandardException thrown on failure to convert
0: 	 */
0: 	public double getDouble() throws StandardException
0: 	{
0: 		BigDecimal localValue = getBigDecimal();
0: 		if (localValue == null)
0: 			return (double)0;
0: 
0: 		// If the BigDecimal is out of range for double
0: 		// then positive or negative infinity is returned.
0: 		double value = NumberDataType.normalizeDOUBLE(localValue.doubleValue());
0: 		return value;
0: 	}
0: 
0: 	public BigDecimal	getBigDecimal()
0: 	{
0: 		if ((value == null) && (rawData != null)) 
0: 		{
0: 			value = new BigDecimal(new BigInteger(rawData), rawScale);
0: 		}
0: 
0: 		return value;
0: 	}
0: 
0:     // 0 or null is false, all else is true
0: 	public boolean	getBoolean()
0: 	{
0: 
0: 		BigDecimal localValue = getBigDecimal();
0: 		if (localValue == null)
0: 			return false;
0: 
0: 		return localValue.compareTo(ZERO) != 0;
0: 	}
0: 
0: 	public String	getString()
0: 	{
0: 		BigDecimal localValue = getBigDecimal();
0: 		if (localValue == null)
0: 			return null;
0: 		else
0: 			return localValue.toString();
0: 	}
0: 
0: 	public Object	getObject()
0: 	{
0: 		/*
0: 		** BigDecimal is immutable
0: 		*/
0: 		return getBigDecimal();
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#setValue
0: 	 *
0: 	 */	
0: 	public void setValue(Object theValue)
0: 		throws StandardException
0: 	{
0: 		rawData = null;
0: 		if ((theValue instanceof BigDecimal) ||
0: 			(theValue == null))
0: 		{
0: 			setValue((BigDecimal)theValue);
0: 		}
0: 		else if (theValue instanceof Number)
0: 		{
0: 			value = new BigDecimal(((Number)theValue).doubleValue());
0: 		}
0: 		else
0: 		{
0: 			genericSetObject(theValue);
0: 		}
0: 	}
0: 	protected void setFrom(DataValueDescriptor theValue) throws StandardException {
0: 
0: 		setValue(theValue.getBigDecimal());
0: 	}
0: 
0: 	public int	getLength()
0: 	{
0: 		return getPrecision();
0: 	}
0: 
0: 	// this is for DataType's error generator
0: 	public String getTypeName()
0: 	{
0: 		return TypeId.DECIMAL_NAME;
0: 	}
0: 
0: 	/*
0: 	 * Storable interface, implies Externalizable, TypedFormat
0: 	 */
0: 
0: 	/**
0: 		Return my format identifier.
0: 
0: 		@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId
0: 	*/
0: 	public int getTypeFormatId() 
0: 	{
0: 		return StoredFormatIds.SQL_DECIMAL_ID;
0: 	}
0: 
0: 	/*
0: 	 * see if the decimal value is null.
0: 	 */
0: 	/** @see Storable#isNull */
0: 	public boolean isNull()
0: 	{
0: 		return (value == null) && (rawData == null);
0: 	}
0: 
0: 	/** 
0: 	 * Distill the BigDecimal to a byte array and
0: 	 * write out: <UL>
0: 	 *	<LI> scale (int) </LI>
0: 	 *	<LI> length of byte array </LI>
0: 	 *	<LI> the byte array </LI> </UL>
0: 	 *
0: 	 */
0: 	public void writeExternal(ObjectOutput out) throws IOException 
0: 	{
0: 		// never called when value is null
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(! isNull());
0: 
0: 		int scale;
0: 		byte[] byteArray;
0: 
0: 		if (value != null) {
0: 			scale = value.scale();
0: 			BigInteger bi = value.movePointRight(scale).toBigInteger();
0: 			byteArray = bi.toByteArray();
0: 		} else {
0: 			scale = rawScale;
0: 			byteArray = rawData;
0: 		}
0: 
0: 		out.writeByte(scale);
0: 		out.writeByte(byteArray.length);
0: 		out.write(byteArray);
0: 	}
0: 
0: 	/** 
0: 	 * Note the use of rawData: we reuse the array if the
0: 	 * incoming array is the same length or smaller than
0: 	 * the array length.  
0: 	 * 
0: 	 * @see java.io.Externalizable#readExternal 
0: 	 */
0: 	public void readExternal(ObjectInput in) throws IOException 
0: 	{
0: 		// clear the previous value to ensure that the
0: 		// rawData value will be used
0: 		value = null;
0: 
0: 		rawScale = in.readUnsignedByte();
0: 		int size = in.readUnsignedByte();
0: 
0: 		/*
0: 		** Allocate a new array if the data to read
0: 		** is larger than the existing array, or if
0: 		** we don't have an array yet.
0: 
0:         Need to use readFully below and NOT just read because read does not
0:         guarantee getting size bytes back, whereas readFully does (unless EOF).
0:         */
0: 		if ((rawData == null) || size != rawData.length)
0: 		{
0: 			rawData = new byte[size];
0: 			in.readFully(rawData);
0: 		}
0: 		/*
0: 		** Copy the incoming array into the last
0: 		** bytes of the existing array.  BigInteger
0: 		** is implemented to ignore leading zeroed bytes.
0: 		*/
0: 		else
0: 		{
0: 			// zero out the leading bytes
0: 			int stop = (rawData.length - size);
0: 			for (int i = 0; i < stop; i++)
0: 			{
0: 				rawData[i] = 0;
0: 			}
0: 			in.readFully(rawData,
0: 					     stop,  // start at rawData[stop]
0: 					     size); // read in size bytes
0: 		}
0: 
0: 	}
0: 	public void readExternalFromArray(ArrayInputStream in) throws IOException 
0: 	{
0: 		// clear the previous value to ensure that the
0: 		// rawData value will be used
0: 		value = null;
0: 
0: 		rawScale = in.readUnsignedByte();
0: 		int size = in.readUnsignedByte();
0: 
0: 		/*
0: 		** Allocate a new array if the data to read
0: 		** is larger than the existing array, or if
0: 		** we don't have an array yet.
0: 
0:         Need to use readFully below and NOT just read because read does not
0:         guarantee getting size bytes back, whereas readFully does (unless EOF).
0:         */
0: 		if ((rawData == null) || size != rawData.length)
0: 		{
0: 			rawData = new byte[size];
0: 			in.readFully(rawData);
0: 		}
0: 		/*
0: 		** Copy the incoming array into the last
0: 		** bytes of the existing array.  BigInteger
0: 		** is implemented to ignore leading zeroed bytes.
0: 		*/
0: 		else
0: 		{
0: 			// zero out the leading bytes
0: 			int stop = (rawData.length - size);
0: 			for (int i = 0; i < stop; i++)
0: 			{
0: 				rawData[i] = 0;
0: 			}
0: 			in.readFully(rawData,
0: 					     stop,  // start at rawData[stop]
0: 					     size); // read in size bytes
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 	 * @see Storable#restoreToNull
0: 	 *
0: 	 */
0: 	public void restoreToNull()
0: 	{
0: 		value = null;
0: 		rawData = null;
0: 	}
0: 
0: 
0: 	/** @exception StandardException		Thrown on error */
0: 	protected int typeCompare(DataValueDescriptor arg) throws StandardException
0: 	{
0: 		BigDecimal otherValue = arg.getBigDecimal();
0: 
0: 		return getBigDecimal().compareTo(otherValue);
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/**
0: 	 * <B> WARNING </B> clone is a shallow copy
0:  	 * @see DataValueDescriptor#getClone 
0: 	 */
0: 	public DataValueDescriptor getClone()
0: 	{
0: 		return new SQLDecimal(getBigDecimal());
0: 	}
0: 
0: 	/**
0: 	 * @see DataValueDescriptor#getNewNull
0: 	 */
0: 	public DataValueDescriptor getNewNull()
0: 	{
0: 		return new SQLDecimal();
0: 	}
0: 
0: 	/** 
0: 	 * @see DataValueDescriptor#setValueFromResultSet 
0: 	 *
0: 	 * @exception SQLException		Thrown on error
0: 	 */
0: 	public void setValueFromResultSet(ResultSet resultSet, int colNumber,
0: 									  boolean isNullable)
0: 		throws SQLException
0: 	{
0: 			ResultSetMetaData rsmd = resultSet.getMetaData();
0: 			value = resultSet.getBigDecimal(colNumber,
0: 											rsmd.getScale(colNumber));
0: 			rawData = null;
0: 	}
0: 	/**
0: 		Set the value into a PreparedStatement.
0: 
0: 		@exception SQLException Error setting value in PreparedStatement
0: 	*/
0: 	public final void setInto(PreparedStatement ps, int position) throws SQLException {
0: 
0: 		if (isNull()) {
0: 			ps.setNull(position, java.sql.Types.DECIMAL);
0: 			return;
0: 		}
0: 
0: 		ps.setBigDecimal(position, getBigDecimal());
0: 	}
0: 	
0: 	/**
0: 	 *
0: 	 * <B> WARNING </B> there is no checking to make sure
0: 	 * that theValue doesn't exceed the precision/scale of
0: 	 * the current SQLDecimal.  It is just assumed that the
0: 	 * SQLDecimal is supposed to take the precision/scale of
0: 	 * the BigDecimalized String.
0: 	 *
0: 	 * @exception StandardException throws NumberFormatException
0: 	 *		when the String format is not recognized.
0: 	 */
0: 	public void setValue(String theValue) throws StandardException
0: 	{
0: 		rawData = null;
0: 
0: 		if (theValue == null)
0: 		{
0: 			value = null;
0: 		}
0: 		else
0: 		{
0: 		    try 
0: 			{
0: 				theValue = theValue.trim();
0: 		        value = new BigDecimal(theValue);
0: 				rawData = null;
0: 			} catch (NumberFormatException nfe) 
0: 			{
0: 			    throw invalidFormat();
0: 			}
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void setValue(double theValue) throws StandardException
0: 	{
0: 		setCoreValue(NumberDataType.normalizeDOUBLE(theValue));
0: 	}
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 */
0: 	public void setValue(float theValue)
0: 		throws StandardException
0: 	{
0: 		setCoreValue((double)NumberDataType.normalizeREAL(theValue));
0: 	}
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 */
0: 	public void setValue(long theValue)
0: 	{
0: 		value = BigDecimal.valueOf(theValue);
0: 		rawData = null;
0: 	}
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 */
0: 	public void setValue(int theValue)
0: 	{
0: 		setValue((long)theValue);
0: 	}
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 */
0: 	public void setValue(short theValue)
0: 	{
0: 		setValue((long)theValue);
0: 	}
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 */
0: 	public void setValue(byte theValue)
0: 	{
0: 		setValue((long)theValue);
0: 	}
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 */
0: 	public void setValue(BigDecimal theValue)
0: 	{
0: 		setCoreValue(theValue);
0: 	}
0: 
0: 	/**
0: 	 * @see NumberDataValue#setValue
0: 	 *
0: 	 */
0: 	public void setValue(boolean theValue)
0: 	{
0: 		setCoreValue(theValue ? ONE : ZERO);
0: 	}
0: 
0: 	/*
0: 	 * DataValueDescriptor interface
0: 	 */
0: 
0: 	/** @see DataValueDescriptor#typePrecedence */
0: 	public int typePrecedence()
0: 	{
0: 		return TypeId.DECIMAL_PRECEDENCE;
0: 	}
0:     // END DataValueDescriptor interface
0: 
0: 	private void setCoreValue(BigDecimal theValue)
0: 	{
0: 		value = theValue;
0: 		rawData = null;
0: 	}
0: 
0: 	private void setCoreValue(double theValue) {
0: 		value = new BigDecimal(theValue);
0: 		rawData = null;
0: 	}
0: 
0: 	/**
0: 	 * Normalization method - this method may be called when putting
0: 	 * a value into a SQLDecimal, for example, when inserting into a SQLDecimal
0: 	 * column.  See NormalizeResultSet in execution.
0: 	 * <p>
0: 	 * Note that truncation is allowed on the decimal portion
0: 	 * of a numeric only.	
0: 	 *
0: 	 * @param desiredType	The type to normalize the source column to
0: 	 * @param source		The value to normalize
0: 	 * @param cachedDest	DataValueDescriptor, if non-null, to hold result
0: 	 *						(Reuse if normalizing multiple rows)
0: 	 *
0: 	 * @return	The normalized SQLDecimal
0: 	 *
0: 	 * @exception StandardException				Thrown for null into
0: 	 *											non-nullable column, and for
0: 	 *											truncation error
0: 	 */
0: 	public void normalize(
0: 				DataTypeDescriptor desiredType,
0: 				DataValueDescriptor source)
0: 						throws StandardException
0: 	{
0: 		int desiredScale = desiredType.getScale();
0: 		int desiredPrecision = desiredType.getPrecision();
0: 
0: 		setValue(source.getBigDecimal());
0: 		setWidth(desiredPrecision, desiredScale, true);
0: 	}
0: 
0: 
0: 	/*
0: 	** SQL Operators
0: 	*/
0: 
0: 
0: 	/**
0: 	 * This method implements the + operator for "double + double".
0: 	 *
0: 	 * @param addend1	One of the addends
0: 	 * @param addend2	The other addend
0: 	 * @param result	The result of a previous call to this method, null
0: 	 *					if not called yet
0: 	 *
0: 	 * @return	A SQLDecimal containing the result of the addition
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public NumberDataValue plus(NumberDataValue addend1,
0: 							NumberDataValue addend2,
0: 							NumberDataValue result)
0: 				throws StandardException
0: 	{
0: 		if (result == null)
0: 		{
0: 			result = new SQLDecimal();
0: 		}
0: 
0: 		if (addend1.isNull() || addend2.isNull())
0: 		{
0: 			result.setToNull();
0: 			return result;
0: 		}
0: 
0: 		result.setValue(addend1.getBigDecimal().add(addend2.getBigDecimal()));
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * This method implements the - operator for "decimal - decimal".
0: 	 *
0: 	 * @param left	The value to be subtracted from
0: 	 * @param right	The value to be subtracted
0: 	 * @param result	The result of a previous call to this method, null
0: 	 *					if not called yet
0: 	 *
0: 	 * @return	A SQLDecimal containing the result of the subtraction
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public NumberDataValue minus(NumberDataValue left,
0: 							NumberDataValue right,
0: 							NumberDataValue result)
0: 				throws StandardException
0: 	{
0: 		if (result == null)
0: 		{
0: 			result = new SQLDecimal();
0: 		}
0: 
0: 		if (left.isNull() || right.isNull())
0: 		{
0: 			result.setToNull();
0: 			return result;
0: 		}
0: 
0: 		result.setValue(left.getBigDecimal().subtract(right.getBigDecimal()));
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * This method implements the * operator for "double * double".
0: 	 *
0: 	 * @param left	The first value to be multiplied
0: 	 * @param right	The second value to be multiplied
0: 	 * @param result	The result of a previous call to this method, null
0: 	 *					if not called yet
0: 	 *
0: 	 * @return	A SQLDecimal containing the result of the multiplication
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public NumberDataValue times(NumberDataValue left,
0: 							NumberDataValue right,
0: 							NumberDataValue result)
0: 				throws StandardException
0: 	{
0: 		double		tempResult;
0: 
0: 		if (result == null)
0: 		{
0: 			result = new SQLDecimal();
0: 		}
0: 
0: 		if (left.isNull() || right.isNull())
0: 		{
0: 			result.setToNull();
0: 			return result;
0: 		}
0: 
0: 		result.setValue(left.getBigDecimal().multiply(right.getBigDecimal()));
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * This method implements the / operator for BigDecimal/BigDecimal
0: 	 *
0: 	 * @param dividend	The numerator
0: 	 * @param divisor	The denominator
0: 	 * @param result	The result of a previous call to this method, null
0: 	 *					if not called yet
0: 	 *
0: 	 * @return	A SQLDecimal containing the result of the division
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public NumberDataValue divide(NumberDataValue dividend,
0: 							 NumberDataValue divisor,
0: 							 NumberDataValue result)
0: 				throws StandardException
0: 	{
0: 		return divide(dividend, divisor, result, -1);
0: 	}
0: 
0: 	/**
0: 	 * This method implements the / operator for BigDecimal/BigDecimal
0: 	 *
0: 	 * @param dividend	The numerator
0: 	 * @param divisor	The denominator
0: 	 * @param result	The result of a previous call to this method, null
0: 	 *					if not called yet
0: 	 * @param scale		The result scale, if < 0, calculate the scale according
0: 	 *					to the actual values' sizes
0: 	 *
0: 	 * @return	A SQLDecimal containing the result of the division
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public NumberDataValue divide(NumberDataValue dividend,
0: 							 NumberDataValue divisor,
0: 							 NumberDataValue result,
0: 							 int scale)
0: 				throws StandardException
0: 	{
0: 		if (result == null)
0: 		{
0: 			result = new SQLDecimal();
0: 		}
0: 
0: 		if (dividend.isNull() || divisor.isNull())
0: 		{
0: 			result.setToNull();
0: 			return result;
0: 		}
0: 
0: 		BigDecimal divisorBigDecimal = divisor.getBigDecimal();
0: 
0: 		if (divisorBigDecimal.compareTo(ZERO) == 0)
0: 		{
0: 			throw  StandardException.newException(SQLState.LANG_DIVIDE_BY_ZERO);
0: 		}
0: 		BigDecimal dividendBigDecimal = dividend.getBigDecimal();
0: 
0: 		/*
0: 		** Set the result scale to be either the passed in scale, whcih was
0: 		** calculated at bind time to be max(ls+rp-rs+1, 4), where ls,rp,rs
0: 		** are static data types' sizes, which are predictable and stable
0: 		** (for the whole result set column, eg.); otherwise dynamically
0: 		** calculates the scale according to actual values.  Beetle 3901
0: 		*/
0: 		result.setValue(dividendBigDecimal.divide(
0: 									divisorBigDecimal,
0: 									scale > -1 ? scale :
0: 									Math.max((dividendBigDecimal.scale() + 
0: 											getWholeDigits(divisorBigDecimal) +
0: 											1), 
0: 										NumberDataValue.MIN_DECIMAL_DIVIDE_SCALE),
0: 									BigDecimal.ROUND_DOWN));
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	 * This method implements the unary minus operator for double.
0: 	 *
0: 	 * @param result	The result of a previous call to this method, null
0: 	 *					if not called yet
0: 	 *
0: 	 * @return	A SQLDecimal containing the result of the division
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 
0: 	public NumberDataValue minus(NumberDataValue result)
0: 									throws StandardException
0: 	{
0: 		if (result == null)
0: 		{
0: 			result = new SQLDecimal();
0: 		}
0: 
0: 		if (this.isNull())
0: 		{
0: 			result.setToNull();
0: 			return result;
0: 		}
0: 
0: 		result.setValue(getBigDecimal().negate());
0: 		return result;
0: 	}
0: 
0:     /**
0:      * This method implements the isNegative method.
0:      * 
0:      * @return  A boolean.  If this.value is negative, return true.
0:      *          For positive values or null, return false.
0:      */
0: 
0:     protected boolean isNegative()
0:     {
0:         return !isNull() && (getBigDecimal().compareTo(ZERO) == -1);
0:     }
0:     
0: 	/*
0: 	 * String display of value
0: 	 */
0: 	public String toString()
0: 	{
0: 		if (isNull())
0: 			return "NULL";
0: 		else
0: 			return getBigDecimal().toString();
0: 	}
0: 
0: 	/*
0: 	 * Hash code
0: 	 */
0: 	public int hashCode()
0: 	{
0: 		long longVal;
0: 		BigDecimal localValue = getBigDecimal();
0: 
0: 		double doubleVal = (localValue != null) ? localValue.doubleValue() : 0;
0: 
0: 		if (Double.isInfinite(doubleVal))
0: 		{
0: 			/*
0: 			 ** This loses the fractional part, but it probably doesn't
0: 			 ** matter for numbers that are big enough to overflow a double -
0: 			 ** it's probably rare for numbers this big to be different only in
0: 			 ** their fractional parts.
0: 			 */
0: 			longVal = localValue.longValue();
0: 		}
0: 		else
0: 		{
0: 			longVal = (long) doubleVal;
0: 			if (longVal != doubleVal)
0: 			{
0: 				longVal = Double.doubleToLongBits(doubleVal);
0: 			}
0: 		}
0: 
0: 		return (int) (longVal ^ (longVal >> 32));
0: 	}
0: 
0: 	///////////////////////////////////////////////////////////////////////////////
0: 	//
0: 	// VariableSizeDataValue interface
0: 	//
0: 	///////////////////////////////////////////////////////////////////////////////
0: 
0: 	/**
0: 	 * Set the precision/scale of the to the desired values. 
0: 	 * Used when CASTing.  Ideally we'd recycle normalize(), but
0: 	 * the use is different.  
0: 	 *
0: 	 * @param desiredPrecision	the desired precision -- IGNORE_PREICISION
0: 	 *					if it is to be ignored.
0: 	 * @param desiredScale	the desired scale 
0: 	 * @param errorOnTrunc	throw error on truncation (ignored -- 
0: 	 *		always thrown if we truncate the non-decimal part of
0: 	 *		the value)
0: 	 * @return this with the target width
0: 	 *
0: 	 * @exception StandardException		Thrown on non-zero truncation
0: 	 *		if errorOnTrunc is true	
0: 	 */
0: 	public DataValueDescriptor setWidth(int desiredPrecision, 
0: 			int desiredScale,
0: 			boolean errorOnTrunc)
0: 			throws StandardException
0: 	{
0: 		if (isNull())
0: 			return this;
0: 
0: 		// the getWholeDigits() call will ensure via getBigDecimal()
0: 		// that the rawData is translated into the BigDecimal in value.
0: 		if (desiredPrecision != IGNORE_PRECISION &&
0: 			((desiredPrecision - desiredScale) <  getWholeDigits()))
0: 		{
0: 			throw StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, 
0: 									("DECIMAL/NUMERIC("+desiredPrecision+","+desiredScale+")"));
0: 		}
0: 		value = value.setScale(desiredScale, BigDecimal.ROUND_DOWN);
0: 		rawData = null;
0: 		return this;
0: 	}
0: 
0: 	public int getPrecision()
0: 	{
0: 		return getPrecision(getBigDecimal());
0: 	}
0: 	/**
0: 	 *
0: 	 * @param the big decimal
0: 	 *
0: 	 * @return the precision
0: 	 */	
0: 	public static int getPrecision(BigDecimal decimalValue)
0: 	{
0: 		if ((decimalValue == null) ||
0: 			 decimalValue.equals(ZERO))
0: 		{
0: 			return 0;
0: 		}	
0: 
0: 		return getWholeDigits(decimalValue) + decimalValue.scale();
0: 	}
0: 
0: 	public int getScale()
0: 	{
0: 		BigDecimal localValue = getBigDecimal();
0: 		return (localValue == null) ? 0 : localValue.scale();
0: 	}
0: 
0: 	public int getWholeDigits()
0: 	{
0: 		return getWholeDigits(getBigDecimal());
0: 	}
0: 
0: 	public static int getWholeDigits(BigDecimal decimalValue)
0: 	{
0: 		if ((decimalValue == null) ||
0: 			 decimalValue.equals(ZERO))
0: 		{
0: 			return 0;
0: 		}
0: 
0: 		/*
0: 		** Get the absolute value so we dont
0: 		** get a leading '-' sign.  Make sure
0: 		** we don't count the leading '0' as
0: 		** precision.  Would be nice to use log10, but
0: 		** we might be bigger than a double.
0: 		*/
0: 		String s = decimalValue.abs().toString();
0: 		int scale = decimalValue.scale();
0: 		return (scale == 0) ? 
0: 			s.length() :
0: 			s.indexOf('.') - (s.startsWith("0.") ? 1 : 0);
0: 	}
0: 	/**
0: 	 * Return the value field
0: 	 *
0: 	 * @return BigDecimal
0: 	 */
0: 	public BigDecimal getValue()
0: 	{
0: 		return getBigDecimal();
0: 	}
0: }
============================================================================