1:33776ff: /*
25:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.net.NetPackageRequest
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:33776ff: */
1:33776ff: package org.apache.derby.client.net;
1:33776ff: 
1:33776ff: import org.apache.derby.client.am.Configuration;
1:33776ff: import org.apache.derby.client.am.Section;
1:33776ff: import org.apache.derby.client.am.SqlException;
1:f271471: import org.apache.derby.client.am.ClientMessageId;
1:f271471: import org.apache.derby.shared.common.reference.SQLState;
1:70f7692: 
1:70f7692: 
1:0326967: class NetPackageRequest extends NetConnectionRequest {
1:0326967:     private static final String COLLECTIONNAME = "NULLID";
1:33776ff: 
1:1451af7:     NetPackageRequest(NetAgent netAgent, int bufferSize) {
1:1451af7:         super(netAgent, bufferSize);
25:33776ff:     }
1:b005ffa: 
1:0326967:     private void buildCommonPKGNAMinfo(Section section) throws SqlException {
1:70f7692:         String collectionToFlow = COLLECTIONNAME;
1:70f7692:         // the scalar data length field may or may not be required.  it depends
1:70f7692:         // on the level of support and length of the data.
1:70f7692:         // check the lengths of the RDBNAM, RDBCOLID, and PKGID.
1:70f7692:         // Determine if the lengths require an SCLDTALEN object.
1:70f7692:         // Note: if an SQLDTALEN is required for ONE of them,
1:70f7692:         // it is needed for ALL of them.  This is why this check is
1:70f7692:         // up front.
1:70f7692:         // the SQLAM level dictates the maximum size for
1:70f7692:         // RDB Collection Identifier (RDBCOLID)
1:70f7692:         // Relational Database Name (RDBNAM)
1:70f7692:         // RDB Package Identifier (PKGID)
1:70f7692:         int maxIdentifierLength = NetConfiguration.PKG_IDENTIFIER_MAX_LEN;
1:018948a:         CcsidManager ccsidMgr = netAgent_.getCurrentCcsidManager();
1:018948a: 
1:018948a:         byte[] dbnameBytes = ccsidMgr.convertFromJavaString(
1:018948a:                 netAgent_.netConnection_.databaseName_, netAgent_);
1:018948a: 
1:018948a:         byte[] collectionToFlowBytes = ccsidMgr.convertFromJavaString(
1:018948a:                 collectionToFlow, netAgent_);
1:018948a: 
1:018948a:         byte[] pkgNameBytes = ccsidMgr.convertFromJavaString(
1:018948a:                 section.getPackageName(), netAgent_);
1:70f7692: 
1:813aa38:         //Maximum RDBNAM length would depend on the server level. 
1:813aa38:         // Server under 10.11 support only 255 bytes but server
1:813aa38:         // at 10.11 and higher support higher limit of 1024
1:49be70b:         boolean scldtalenRequired =
1:49be70b:                 checkPKGNAMlengths(netAgent_.netConnection_.databaseName_,
1:018948a:                 dbnameBytes.length,
1:813aa38:                 (netAgent_.netConnection_.databaseMetaData_.serverSupportLongRDBNAM())? 
1:813aa38:                         NetConfiguration.RDBNAM_MAX_LEN 
1:813aa38:                         : NetConfiguration.PKG_IDENTIFIER_MAX_LEN,  
4:70f7692:                 NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:70f7692: 
1:70f7692:         if (!scldtalenRequired) {
1:70f7692:             scldtalenRequired = checkPKGNAMlengths(collectionToFlow,
1:018948a:                     collectionToFlowBytes.length,
2:70f7692:                     maxIdentifierLength,
1:70f7692:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:70f7692:         }
1:70f7692: 
1:70f7692:         if (!scldtalenRequired) {
1:70f7692:             scldtalenRequired = checkPKGNAMlengths(section.getPackageName(),
1:018948a:                     pkgNameBytes.length,
1:70f7692:                     maxIdentifierLength,
1:70f7692:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:70f7692:         }
1:70f7692: 
1:70f7692:         // the format is different depending on if an SCLDTALEN is required.
1:70f7692:         if (!scldtalenRequired) {
1:018948a:             byte padByte = ccsidMgr.space_;
1:018948a:             writeScalarPaddedBytes(dbnameBytes,
1:018948a:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN, padByte);
1:018948a:             writeScalarPaddedBytes(collectionToFlowBytes,
1:018948a:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN, padByte);
1:018948a:             writeScalarPaddedBytes(pkgNameBytes,
1:018948a:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN, padByte);
3:70f7692:         } else {
1:018948a:             buildSCLDTA(dbnameBytes, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:018948a:             buildSCLDTA(collectionToFlowBytes, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:018948a:             buildSCLDTA(pkgNameBytes, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:018948a:     private void buildSCLDTA(byte[] identifier, int minimumLength)
1:018948a:             throws SqlException {
1:018948a:         int length = Math.max(minimumLength, identifier.length);
1:018948a:         write2Bytes(length);
1:018948a:         byte padByte = netAgent_.getCurrentCcsidManager().space_;
1:018948a:         writeScalarPaddedBytes(identifier, length, padByte);
1:33776ff:     }
1:70f7692: 
1:33776ff: 
1:70f7692:     // this specifies the fully qualified package name,
1:70f7692:     // consistency token, and section number within the package being used
1:70f7692:     // to execute the SQL.  If the connection supports reusing the previous
1:70f7692:     // package information and this information is the same except for the section
1:70f7692:     // number then only the section number needs to be sent to the server.
1:70f7692:     void buildPKGNAMCSN(Section section) throws SqlException {
1:70f7692:         if (!canCommandUseDefaultPKGNAMCSN()) {
1:70f7692:             markLengthBytes(CodePoint.PKGNAMCSN);
1:70f7692:             // If PKGNAMCBytes is already available, copy the bytes to the request buffer directly.
1:70f7692:             if (section.getPKGNAMCBytes() != null) {
1:70f7692:                 writeStoredPKGNAMCBytes(section);
1:70f7692:             } else {
1:70f7692:                 // Mark the beginning of PKGNAMCSN bytes.
1:70f7692:                 markForCachingPKGNAMCSN();
1:70f7692:                 buildCommonPKGNAMinfo(section);
1:49be70b:                 writeScalarPaddedBytes(
1:49be70b:                         Configuration.getDncPackageConsistencyToken(),
1:70f7692:                         NetConfiguration.PKGCNSTKN_FIXED_LEN,
1:70f7692:                         NetConfiguration.NON_CHAR_DDM_DATA_PAD_BYTE);
1:70f7692:                 // store the PKGNAMCbytes
1:70f7692:                 storePKGNAMCBytes(section);
1:70f7692:             }
1:70f7692:             write2Bytes(section.getSectionNumber());
1:70f7692:             updateLengthBytes();
1:70f7692:         } else {
1:70f7692:             writeScalar2Bytes(CodePoint.PKGSN, section.getSectionNumber());
1:70f7692:         }
1:33776ff:     }
1:33776ff: 
1:70f7692:     private void storePKGNAMCBytes(Section section) {
1:70f7692:         // Get the locaton where we started writing PKGNAMCSN
1:70f7692:         int startPos = popMarkForCachingPKGNAMCSN();
1:f6e1e6f:         byte[] b = new byte[buffer.position() - startPos];
1:f6e1e6f:         buffer.position(startPos);
1:f6e1e6f:         buffer.get(b);
1:70f7692:         section.setPKGNAMCBytes(b);
1:33776ff:     }
1:33776ff: 
1:70f7692:     private void writeStoredPKGNAMCBytes(Section section) {
1:f6e1e6f:         writeBytes(section.getPKGNAMCBytes());
1:33776ff:     }
1:70f7692: 
1:70f7692:     private boolean canCommandUseDefaultPKGNAMCSN() {
1:70f7692:         return false;
1:70f7692:     }
1:70f7692: 
1:33776ff: 
1:70f7692:     // throws an exception if lengths exceed the maximum.
1:70f7692:     // returns a boolean indicating if SLCDTALEN is required.
1:70f7692:     private boolean checkPKGNAMlengths(String identifier,
1:018948a:                                        int length,
1:70f7692:                                        int maxIdentifierLength,
1:70f7692:                                        int lengthRequiringScldta) throws SqlException {
1:70f7692:         if (length > maxIdentifierLength) {
1:f271471:             throw new SqlException(netAgent_.logWriter_,
1:f271471:                 new ClientMessageId(SQLState.LANG_IDENTIFIER_TOO_LONG),
1:66527ec:                 identifier, maxIdentifierLength);
1:70f7692:         }
1:70f7692: 
1:70f7692:         return (length > lengthRequiringScldta);
1:70f7692:     }
1:33776ff: 
1:70f7692:     private void buildNOCMorNOCS(String string) throws SqlException {
1:70f7692:         if (string == null) {
1:70f7692:             write2Bytes(0xffff);
1:70f7692:         } else {
1:70f7692:             if (netAgent_.typdef_.isCcsidMbcSet()) {
1:a0b8943:                 byte[] sqlBytes =
1:a0b8943:                     string.getBytes(netAgent_.typdef_.getCcsidMbcEncoding());
1:70f7692:                 write1Byte(0x00);
1:70f7692:                 write4Bytes(sqlBytes.length);
1:70f7692:                 writeBytes(sqlBytes, sqlBytes.length);
1:70f7692:                 write1Byte(0xff);
1:70f7692:             } else {
1:a0b8943:                 byte[] sqlBytes =
1:a0b8943:                     string.getBytes(netAgent_.typdef_.getCcsidSbcEncoding());
1:70f7692:                 write1Byte(0xff);
1:70f7692:                 write1Byte(0x00);
1:70f7692:                 write4Bytes(sqlBytes.length);
1:70f7692:                 writeBytes(sqlBytes, sqlBytes.length);
1:70f7692:             }
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     // SQLSTTGRP : FDOCA EARLY GROUP
1:70f7692:     // SQL Statement Group Description
2:70f7692:     //
1:70f7692:     // FORMAT FOR SQLAM <= 6
1:70f7692:     //   SQLSTATEMENT_m; PROTOCOL TYPE LVCM; ENVLID 0x40; Length Override 32767
1:70f7692:     //   SQLSTATEMENT_s; PROTOCOL TYPE LVCS; ENVLID 0x34; Length Override 32767
1:70f7692:     //
1:70f7692:     // FORMAT FOR SQLAM >= 7
1:70f7692:     //   SQLSTATEMENT_m; PROTOCOL TYPE NOCM; ENVLID 0xCF; Length Override 4
1:70f7692:     //   SQLSTATEMENT_s; PROTOCOL TYPE NOCS; ENVLID 0xCB; Length Override 4
1:70f7692:     private void buildSQLSTTGRP(String string) throws SqlException {
1:70f7692:         buildNOCMorNOCS(string);
1:70f7692:     }
1:33776ff: 
1:70f7692:     // SQLSTT : FDOCA EARLY ROW
1:70f7692:     // SQL Statement Row Description
1:70f7692:     //
1:70f7692:     // FORMAT FOR ALL SQLAM LEVELS
1:70f7692:     //   SQLSTTGRP; GROUP LID 0x5C; ELEMENT TAKEN 0(all); REP FACTOR 1
1:70f7692:     private void buildSQLSTT(String string) throws SqlException {
1:70f7692:         buildSQLSTTGRP(string);
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected void buildSQLSTTcommandData(String sql) throws SqlException {
1:70f7692:         createEncryptedCommandData();
1:f6e1e6f:         int loc = buffer.position();
1:70f7692:         markLengthBytes(CodePoint.SQLSTT);
1:70f7692:         buildSQLSTT(sql);
1:70f7692:         updateLengthBytes();
1:70f7692:         if (netAgent_.netConnection_.getSecurityMechanism() ==
1:70f7692:                 NetConfiguration.SECMEC_EUSRIDDTA ||
1:70f7692:                 netAgent_.netConnection_.getSecurityMechanism() ==
1:70f7692:                 NetConfiguration.SECMEC_EUSRPWDDTA) {
1:70f7692:             encryptDataStream(loc);
1:70f7692:         }
1:70f7692: 
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:70f7692:     protected void buildSQLATTRcommandData(String sql) throws SqlException {
1:70f7692:         createEncryptedCommandData();
1:f6e1e6f:         int loc = buffer.position();
1:70f7692:         markLengthBytes(CodePoint.SQLATTR);
1:70f7692:         buildSQLSTT(sql);
1:70f7692:         updateLengthBytes();
1:70f7692:         if (netAgent_.netConnection_.getSecurityMechanism() ==
1:70f7692:                 NetConfiguration.SECMEC_EUSRIDDTA ||
1:70f7692:                 netAgent_.netConnection_.getSecurityMechanism() ==
1:70f7692:                 NetConfiguration.SECMEC_EUSRPWDDTA) {
1:70f7692:             encryptDataStream(loc);
1:70f7692:         }
1:33776ff: 
1:70f7692:     }
1:33776ff: 
1:33776ff: 
1:0326967:     void encryptDataStream(int lengthLocation) throws SqlException {
1:f6e1e6f:         byte[] clearedBytes = new byte[buffer.position() - lengthLocation];
1:f6e1e6f:         buffer.position(lengthLocation);
1:f6e1e6f:         buffer.get(clearedBytes);
1:f6e1e6f: 
1:70f7692:         byte[] encryptedBytes;
1:33776ff: 
1:70f7692:         encryptedBytes = netAgent_.netConnection_.getEncryptionManager().
1:70f7692:                 encryptData(clearedBytes,
1:70f7692:                         NetConfiguration.SECMEC_EUSRIDPWD,
1:70f7692:                         netAgent_.netConnection_.getTargetPublicKey(),
1:70f7692:                         netAgent_.netConnection_.getTargetPublicKey());
1:33776ff: 
1:f6e1e6f:         buffer.position(lengthLocation);
1:f6e1e6f:         writeBytes(encryptedBytes);
1:33776ff: 
1:70f7692:         //we need to update the length in DSS header here.
1:f6e1e6f:         buffer.putShort(lengthLocation - 6, (short) encryptedBytes.length);
1:70f7692:     }
1:33776ff: 
1:70f7692: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:813aa38
/////////////////////////////////////////////////////////////////////////
1:         //Maximum RDBNAM length would depend on the server level. 
1:         // Server under 10.11 support only 255 bytes but server
1:         // at 10.11 and higher support higher limit of 1024
1:                 (netAgent_.netConnection_.databaseMetaData_.serverSupportLongRDBNAM())? 
1:                         NetConfiguration.RDBNAM_MAX_LEN 
1:                         : NetConfiguration.PKG_IDENTIFIER_MAX_LEN,  
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a0b8943
/////////////////////////////////////////////////////////////////////////
1:                 byte[] sqlBytes =
1:                     string.getBytes(netAgent_.typdef_.getCcsidMbcEncoding());
1:                 byte[] sqlBytes =
1:                     string.getBytes(netAgent_.typdef_.getCcsidSbcEncoding());
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                 identifier, maxIdentifierLength);
commit:018948a
/////////////////////////////////////////////////////////////////////////
1:         CcsidManager ccsidMgr = netAgent_.getCurrentCcsidManager();
1: 
1:         byte[] dbnameBytes = ccsidMgr.convertFromJavaString(
1:                 netAgent_.netConnection_.databaseName_, netAgent_);
1: 
1:         byte[] collectionToFlowBytes = ccsidMgr.convertFromJavaString(
1:                 collectionToFlow, netAgent_);
1: 
1:         byte[] pkgNameBytes = ccsidMgr.convertFromJavaString(
1:                 section.getPackageName(), netAgent_);
1:                 dbnameBytes.length,
1:                     collectionToFlowBytes.length,
1:                     pkgNameBytes.length,
1:             byte padByte = ccsidMgr.space_;
1:             writeScalarPaddedBytes(dbnameBytes,
1:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN, padByte);
1:             writeScalarPaddedBytes(collectionToFlowBytes,
1:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN, padByte);
1:             writeScalarPaddedBytes(pkgNameBytes,
1:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN, padByte);
1:             buildSCLDTA(dbnameBytes, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:             buildSCLDTA(collectionToFlowBytes, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:             buildSCLDTA(pkgNameBytes, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:     private void buildSCLDTA(byte[] identifier, int minimumLength)
1:             throws SqlException {
1:         int length = Math.max(minimumLength, identifier.length);
1:         write2Bytes(length);
1:         byte padByte = netAgent_.getCurrentCcsidManager().space_;
1:         writeScalarPaddedBytes(identifier, length, padByte);
/////////////////////////////////////////////////////////////////////////
1:                                        int length,
commit:f6e1e6f
/////////////////////////////////////////////////////////////////////////
1:         byte[] b = new byte[buffer.position() - startPos];
1:         buffer.position(startPos);
1:         buffer.get(b);
1:         writeBytes(section.getPKGNAMCBytes());
/////////////////////////////////////////////////////////////////////////
1:         int loc = buffer.position();
/////////////////////////////////////////////////////////////////////////
1:         int loc = buffer.position();
/////////////////////////////////////////////////////////////////////////
1:         byte[] clearedBytes = new byte[buffer.position() - lengthLocation];
1:         buffer.position(lengthLocation);
1:         buffer.get(clearedBytes);
1: 
/////////////////////////////////////////////////////////////////////////
1:         buffer.position(lengthLocation);
1:         writeBytes(encryptedBytes);
1:         buffer.putShort(lengthLocation - 6, (short) encryptedBytes.length);
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b565f41
/////////////////////////////////////////////////////////////////////////
commit:0326967
/////////////////////////////////////////////////////////////////////////
1: class NetPackageRequest extends NetConnectionRequest {
1:     private static final String COLLECTIONNAME = "NULLID";
/////////////////////////////////////////////////////////////////////////
1:     private void buildCommonPKGNAMinfo(Section section) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     void encryptDataStream(int lengthLocation) throws SqlException {
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
0:         } catch (Exception e) {
commit:49be70b
/////////////////////////////////////////////////////////////////////////
1:         boolean scldtalenRequired =
1:                 checkPKGNAMlengths(netAgent_.netConnection_.databaseName_,
/////////////////////////////////////////////////////////////////////////
1:                 writeScalarPaddedBytes(
1:                         Configuration.getDncPackageConsistencyToken(),
/////////////////////////////////////////////////////////////////////////
0:             byte[] sqlBytes;
/////////////////////////////////////////////////////////////////////////
author:Tiago Aur¨¦lio Rodrigues Espinha
-------------------------------------------------------------------------------
commit:b005ffa
/////////////////////////////////////////////////////////////////////////
0:         int length = netAgent_.getCurrentCcsidManager().getByteLength(identifier);
1:         
0:         if (length <= minimumLength) {
0:             write2Bytes(length);
0:             writeScalarPaddedString(identifier, length);
/////////////////////////////////////////////////////////////////////////
0:         int length = netAgent_.getCurrentCcsidManager().getByteLength(identifier);;
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:1451af7
/////////////////////////////////////////////////////////////////////////
1:     NetPackageRequest(NetAgent netAgent, int bufferSize) {
1:         super(netAgent, bufferSize);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f271471
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientMessageId;
1: import org.apache.derby.shared.common.reference.SQLState;
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(netAgent_.logWriter_,
1:                 new ClientMessageId(SQLState.LANG_IDENTIFIER_TOO_LONG),
0:                 identifier, new Integer(maxIdentifierLength));
/////////////////////////////////////////////////////////////////////////
0:             throw new SqlException(netAgent_.logWriter_, 
0:                 new ClientMessageId(SQLState.JAVA_EXCEPTION), 
0:                 e.getClass().getName(), e.getMessage(), e);
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
0: public class NetPackageRequest extends NetConnectionRequest {
0:     static final String COLLECTIONNAME = "NULLID";
0:     NetPackageRequest(NetAgent netAgent, CcsidManager ccsidManager, int bufferSize) {
0:         super(netAgent, ccsidManager, bufferSize);
1: 
0:     // RDB Package Name, Consistency Token
0:     // Scalar Object specifies the fully qualified name of a relational
0:     // database package and its consistency token.
1:     //
0:     // To accomodate larger lengths, the Scalar Data Length
0:     // (SCLDTALEN) Field is used to specify the length of the instance
0:     // variable which follows.
0:     static final String collectionName = "NULLID";
1: 
0:     void buildCommonPKGNAMinfo(Section section) throws SqlException {
1:         String collectionToFlow = COLLECTIONNAME;
1:         // the scalar data length field may or may not be required.  it depends
1:         // on the level of support and length of the data.
1:         // check the lengths of the RDBNAM, RDBCOLID, and PKGID.
1:         // Determine if the lengths require an SCLDTALEN object.
1:         // Note: if an SQLDTALEN is required for ONE of them,
1:         // it is needed for ALL of them.  This is why this check is
1:         // up front.
1:         // the SQLAM level dictates the maximum size for
1:         // RDB Collection Identifier (RDBCOLID)
1:         // Relational Database Name (RDBNAM)
1:         // RDB Package Identifier (PKGID)
1:         int maxIdentifierLength = NetConfiguration.PKG_IDENTIFIER_MAX_LEN;
1: 
0:         boolean scldtalenRequired = false;
0:         scldtalenRequired = checkPKGNAMlengths(netAgent_.netConnection_.databaseName_,
1:                 maxIdentifierLength,
1:                 NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1: 
1:         if (!scldtalenRequired) {
1:             scldtalenRequired = checkPKGNAMlengths(collectionToFlow,
1:                     maxIdentifierLength,
1:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:         }
1: 
1:         if (!scldtalenRequired) {
1:             scldtalenRequired = checkPKGNAMlengths(section.getPackageName(),
1:                     maxIdentifierLength,
1:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:         }
1: 
1:         // the format is different depending on if an SCLDTALEN is required.
1:         if (!scldtalenRequired) {
0:             writeScalarPaddedString(netAgent_.netConnection_.databaseName_,
1:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
0:             writeScalarPaddedString(collectionToFlow,
1:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
0:             writeScalarPaddedString(section.getPackageName(),
1:                     NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:         } else {
0:             buildSCLDTA(netAgent_.netConnection_.databaseName_, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
0:             buildSCLDTA(collectionToFlow, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
0:             buildSCLDTA(section.getPackageName(), NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:         }
0:     private void buildSCLDTA(String identifier, int minimumLength) throws SqlException {
0:         if (identifier.length() <= minimumLength) {
0:             write2Bytes(minimumLength);
0:             writeScalarPaddedString(identifier, minimumLength);
1:         } else {
0:             write2Bytes(identifier.length());
0:             writeScalarPaddedString(identifier, identifier.length());
1:         }
1: 
1: 
1:     // this specifies the fully qualified package name,
1:     // consistency token, and section number within the package being used
1:     // to execute the SQL.  If the connection supports reusing the previous
1:     // package information and this information is the same except for the section
1:     // number then only the section number needs to be sent to the server.
1:     void buildPKGNAMCSN(Section section) throws SqlException {
1:         if (!canCommandUseDefaultPKGNAMCSN()) {
1:             markLengthBytes(CodePoint.PKGNAMCSN);
1:             // If PKGNAMCBytes is already available, copy the bytes to the request buffer directly.
1:             if (section.getPKGNAMCBytes() != null) {
1:                 writeStoredPKGNAMCBytes(section);
1:             } else {
1:                 // Mark the beginning of PKGNAMCSN bytes.
1:                 markForCachingPKGNAMCSN();
1:                 buildCommonPKGNAMinfo(section);
0:                 writeScalarPaddedBytes(Configuration.dncPackageConsistencyToken,
1:                         NetConfiguration.PKGCNSTKN_FIXED_LEN,
1:                         NetConfiguration.NON_CHAR_DDM_DATA_PAD_BYTE);
1:                 // store the PKGNAMCbytes
1:                 storePKGNAMCBytes(section);
1:             }
1:             write2Bytes(section.getSectionNumber());
1:             updateLengthBytes();
1:         } else {
1:             writeScalar2Bytes(CodePoint.PKGSN, section.getSectionNumber());
1:         }
1:     private void storePKGNAMCBytes(Section section) {
1:         // Get the locaton where we started writing PKGNAMCSN
1:         int startPos = popMarkForCachingPKGNAMCSN();
0:         int copyLength = offset_ - startPos;
0:         byte[] b = new byte[copyLength];
0:         System.arraycopy(bytes_,
0:                 startPos,
0:                 b,
0:                 0,
0:                 copyLength);
1:         section.setPKGNAMCBytes(b);
1:     private void writeStoredPKGNAMCBytes(Section section) {
0:         byte[] b = section.getPKGNAMCBytes();
0:         // Mare sure request buffer has enough space to write this byte array.
0:         ensureLength(offset_ + b.length);
0:         System.arraycopy(b,
0:                 0,
0:                 bytes_,
0:                 offset_,
0:                 b.length);
0:         offset_ += b.length;
1: 
1:     private boolean canCommandUseDefaultPKGNAMCSN() {
1:         return false;
1: 
1:     // throws an exception if lengths exceed the maximum.
1:     // returns a boolean indicating if SLCDTALEN is required.
1:     private boolean checkPKGNAMlengths(String identifier,
1:                                        int maxIdentifierLength,
1:                                        int lengthRequiringScldta) throws SqlException {
0:         int length = identifier.length();
1:         if (length > maxIdentifierLength) {
0:             throw new SqlException(netAgent_.logWriter_, "" + identifier + " exceeds maximum identifier length of ' " +
0:                     maxIdentifierLength + "'");
1:         }
1: 
1:         return (length > lengthRequiringScldta);
0:     private byte[] getBytes(String string, String encoding) throws SqlException {
0:         try {
0:             return string.getBytes(encoding);
0:         } catch (java.lang.Exception e) {
0:             throw new SqlException(netAgent_.logWriter_, e, "error on getBytes");
1:         }
1:     private void buildNOCMorNOCS(String string) throws SqlException {
1:         if (string == null) {
1:             write2Bytes(0xffff);
1:         } else {
0:             byte[] sqlBytes = null;
1:             if (netAgent_.typdef_.isCcsidMbcSet()) {
0:                 sqlBytes = getBytes(string, netAgent_.typdef_.getCcsidMbcEncoding());
1:                 write1Byte(0x00);
1:                 write4Bytes(sqlBytes.length);
1:                 writeBytes(sqlBytes, sqlBytes.length);
1:                 write1Byte(0xff);
1:             } else {
0:                 sqlBytes = getBytes(string, netAgent_.typdef_.getCcsidSbcEncoding());
1:                 write1Byte(0xff);
1:                 write1Byte(0x00);
1:                 write4Bytes(sqlBytes.length);
1:                 writeBytes(sqlBytes, sqlBytes.length);
1:             }
1:         }
1:     }
1:     // SQLSTTGRP : FDOCA EARLY GROUP
1:     // SQL Statement Group Description
1:     //
1:     // FORMAT FOR SQLAM <= 6
1:     //   SQLSTATEMENT_m; PROTOCOL TYPE LVCM; ENVLID 0x40; Length Override 32767
1:     //   SQLSTATEMENT_s; PROTOCOL TYPE LVCS; ENVLID 0x34; Length Override 32767
1:     //
1:     // FORMAT FOR SQLAM >= 7
1:     //   SQLSTATEMENT_m; PROTOCOL TYPE NOCM; ENVLID 0xCF; Length Override 4
1:     //   SQLSTATEMENT_s; PROTOCOL TYPE NOCS; ENVLID 0xCB; Length Override 4
1:     private void buildSQLSTTGRP(String string) throws SqlException {
1:         buildNOCMorNOCS(string);
0:         return;
1:     }
1:     // SQLSTT : FDOCA EARLY ROW
1:     // SQL Statement Row Description
1:     //
1:     // FORMAT FOR ALL SQLAM LEVELS
1:     //   SQLSTTGRP; GROUP LID 0x5C; ELEMENT TAKEN 0(all); REP FACTOR 1
1:     private void buildSQLSTT(String string) throws SqlException {
1:         buildSQLSTTGRP(string);
1:     }
1: 
1:     protected void buildSQLSTTcommandData(String sql) throws SqlException {
1:         createEncryptedCommandData();
0:         int loc = offset_;
1:         markLengthBytes(CodePoint.SQLSTT);
1:         buildSQLSTT(sql);
1:         updateLengthBytes();
1:         if (netAgent_.netConnection_.getSecurityMechanism() ==
1:                 NetConfiguration.SECMEC_EUSRIDDTA ||
1:                 netAgent_.netConnection_.getSecurityMechanism() ==
1:                 NetConfiguration.SECMEC_EUSRPWDDTA) {
1:             encryptDataStream(loc);
1:         }
1: 
1:     }
1:     protected void buildSQLATTRcommandData(String sql) throws SqlException {
1:         createEncryptedCommandData();
0:         int loc = offset_;
1:         markLengthBytes(CodePoint.SQLATTR);
1:         buildSQLSTT(sql);
1:         updateLengthBytes();
1:         if (netAgent_.netConnection_.getSecurityMechanism() ==
1:                 NetConfiguration.SECMEC_EUSRIDDTA ||
1:                 netAgent_.netConnection_.getSecurityMechanism() ==
1:                 NetConfiguration.SECMEC_EUSRPWDDTA) {
1:             encryptDataStream(loc);
1:         }
1:     }
0:     public void encryptDataStream(int lengthLocation) throws SqlException {
0:         byte[] clearedBytes = new byte[offset_ - lengthLocation];
1:         byte[] encryptedBytes;
0:         for (int i = lengthLocation; i < offset_; i++) {
0:             clearedBytes[i - lengthLocation] = bytes_[i];
1:         }
1:         encryptedBytes = netAgent_.netConnection_.getEncryptionManager().
1:                 encryptData(clearedBytes,
1:                         NetConfiguration.SECMEC_EUSRIDPWD,
1:                         netAgent_.netConnection_.getTargetPublicKey(),
1:                         netAgent_.netConnection_.getTargetPublicKey());
0:         int length = encryptedBytes.length;
0:         if (bytes_.length >= lengthLocation + length) {
0:             System.arraycopy(encryptedBytes, 0, bytes_, lengthLocation, length);
1:         } else {
0:             byte[] largeByte = new byte[lengthLocation + length];
0:             System.arraycopy(bytes_, 0, largeByte, 0, lengthLocation);
0:             System.arraycopy(encryptedBytes, 0, largeByte, lengthLocation, length);
0:             bytes_ = largeByte;
1:         }
0:         offset_ += length - clearedBytes.length;
1:         //we need to update the length in DSS header here.
0:         bytes_[lengthLocation - 6] = (byte) ((length >>> 8) & 0xff);
0:         bytes_[lengthLocation - 5] = (byte) (length & 0xff);
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.net.NetPackageRequest
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: package org.apache.derby.client.net;
1: 
1: import org.apache.derby.client.am.Configuration;
1: import org.apache.derby.client.am.Section;
1: import org.apache.derby.client.am.SqlException;
1: 
1: 
0: public class NetPackageRequest extends NetConnectionRequest
0: {
0:   static final String COLLECTIONNAME = "NULLID";
1: 
0:   NetPackageRequest (NetAgent netAgent, CcsidManager ccsidManager, int bufferSize)
0:   {
0:     super (netAgent, ccsidManager, bufferSize);
1:   }
1: 
0:   // RDB Package Name, Consistency Token
0:   // Scalar Object specifies the fully qualified name of a relational
0:   // database package and its consistency token.
0:   //
0:   // To accomodate larger lengths, the Scalar Data Length
0:   // (SCLDTALEN) Field is used to specify the length of the instance
0:   // variable which follows.
0:   static final String collectionName = "NULLID";
0:   void buildCommonPKGNAMinfo (Section section) throws SqlException
0:   {
0:     String collectionToFlow = COLLECTIONNAME;
0:     // the scalar data length field may or may not be required.  it depends
0:     // on the level of support and length of the data.
0:     // check the lengths of the RDBNAM, RDBCOLID, and PKGID.
0:     // Determine if the lengths require an SCLDTALEN object.
0:     // Note: if an SQLDTALEN is required for ONE of them,
0:     // it is needed for ALL of them.  This is why this check is
0:     // up front.
0:     // the SQLAM level dictates the maximum size for
0:     // RDB Collection Identifier (RDBCOLID)
0:     // Relational Database Name (RDBNAM)
0:     // RDB Package Identifier (PKGID)
0: 	int maxIdentifierLength = NetConfiguration.PKG_IDENTIFIER_MAX_LEN;
1: 
0:     boolean scldtalenRequired = false;
0:     scldtalenRequired = checkPKGNAMlengths (netAgent_.netConnection_.databaseName_,
0:                                             maxIdentifierLength,
0:                                             NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1: 
0:     if (!scldtalenRequired)
0:       scldtalenRequired = checkPKGNAMlengths (collectionToFlow,
0:                                               maxIdentifierLength,
0:                                               NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1: 
0:     if (!scldtalenRequired)
0:       scldtalenRequired = checkPKGNAMlengths (section.getPackageName(),
0:                                               maxIdentifierLength,
0:                                               NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1: 
0:     // the format is different depending on if an SCLDTALEN is required.
0:     if (!scldtalenRequired) {
0:       writeScalarPaddedString (netAgent_.netConnection_.databaseName_,
0:                                NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
0:       writeScalarPaddedString (collectionToFlow,
0:                                NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
0:       writeScalarPaddedString (section.getPackageName(),
0:                                NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:     }
0:     else {
0:       buildSCLDTA (netAgent_.netConnection_.databaseName_, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
0:       buildSCLDTA (collectionToFlow, NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
0:       buildSCLDTA (section.getPackageName(), NetConfiguration.PKG_IDENTIFIER_FIXED_LEN);
1:     }
1:   }
1: 
0:   private void buildSCLDTA (String identifier, int minimumLength) throws SqlException
0:   {
0:     if (identifier.length() <= minimumLength) {
0:       write2Bytes (minimumLength);
0:       writeScalarPaddedString (identifier, minimumLength);
1:     }
0:     else {
0:       write2Bytes (identifier.length());
0:       writeScalarPaddedString (identifier, identifier.length());
1:     }
1:   }
1: 
1: 
0:   // this specifies the fully qualified package name,
0:   // consistency token, and section number within the package being used
0:   // to execute the SQL.  If the connection supports reusing the previous
0:   // package information and this information is the same except for the section
0:   // number then only the section number needs to be sent to the server.
0:   void buildPKGNAMCSN (Section section) throws SqlException
0:   {
0:     if (!canCommandUseDefaultPKGNAMCSN ()) {
0:       markLengthBytes (CodePoint.PKGNAMCSN);
0:       // If PKGNAMCBytes is already available, copy the bytes to the request buffer directly.
0:       if (section.getPKGNAMCBytes() != null)
0:         writeStoredPKGNAMCBytes (section);
0:       else {
0:         // Mark the beginning of PKGNAMCSN bytes.
0:         markForCachingPKGNAMCSN ();
0:         buildCommonPKGNAMinfo (section);
0:         writeScalarPaddedBytes (Configuration.dncPackageConsistencyToken,
0:                               NetConfiguration.PKGCNSTKN_FIXED_LEN,
0:                               NetConfiguration.NON_CHAR_DDM_DATA_PAD_BYTE);
0:         // store the PKGNAMCbytes 
0:         storePKGNAMCBytes (section);
1:       }
0:       write2Bytes (section.getSectionNumber());
0:       updateLengthBytes();
1:     }
0:     else
0:       writeScalar2Bytes (CodePoint.PKGSN, section.getSectionNumber());
1:   }
1: 
0:   private void storePKGNAMCBytes (Section section)
0:   {
0:     // Get the locaton where we started writing PKGNAMCSN
0:     int startPos = popMarkForCachingPKGNAMCSN ();
0:     int copyLength = offset_ - startPos;
0:     byte[] b = new byte[copyLength];
0:     System.arraycopy (bytes_,
0:                       startPos,
0:                       b,
0:                       0,
0:                       copyLength);
0:     section.setPKGNAMCBytes(b);
1:   }
1: 
0:   private void writeStoredPKGNAMCBytes (Section section)
0:   {
0:     byte[] b = section.getPKGNAMCBytes();
1: 
0:     // Mare sure request buffer has enough space to write this byte array.
0:     ensureLength (offset_ + b.length);
1: 
0:     System.arraycopy (b,
0:                       0,
0:                       bytes_,
0:                       offset_,
0:                       b.length);
1: 
0:     offset_ += b.length;
1:   }
1: 
0:   private boolean canCommandUseDefaultPKGNAMCSN ()
0:   {
0:     return false;
1:   }
1: 
1: 
0:   // throws an exception if lengths exceed the maximum.
0:   // returns a boolean indicating if SLCDTALEN is required.
0:   private boolean checkPKGNAMlengths (String identifier,
0:                                       int maxIdentifierLength,
0:                                       int lengthRequiringScldta) throws SqlException
0:   {
0:     int length = identifier.length();
0:     if (length > maxIdentifierLength)
0:       throw new SqlException (netAgent_.logWriter_, "" + identifier + " exceeds maximum identifier length of ' " +
0:                               maxIdentifierLength + "'");
1: 
0:     return (length > lengthRequiringScldta);
1:   }
1: 
0:   private byte[] getBytes (String string, String encoding) throws SqlException
0:   {
0:     try {
0:       return string.getBytes (encoding);
1:     }
0:     catch (java.lang.Exception e) {
0:       throw new SqlException (netAgent_.logWriter_, e, "error on getBytes");
1:     }
1:   }
1: 
0:   private void buildNOCMorNOCS (String string) throws SqlException
0:   {
0:     if (string == null) {
0:       write2Bytes (0xffff);
1:     }
0:     else {
0:       byte[] sqlBytes = null;
1: 
0:       if (netAgent_.typdef_.isCcsidMbcSet()) {
0:         sqlBytes = getBytes (string, netAgent_.typdef_.getCcsidMbcEncoding());
0:         write1Byte (0x00);
0:         write4Bytes (sqlBytes.length);
0:         writeBytes (sqlBytes, sqlBytes.length);
0:         write1Byte (0xff);
1:       }
0:       else {
0:         sqlBytes = getBytes (string, netAgent_.typdef_.getCcsidSbcEncoding());
0:         write1Byte (0xff);
0:         write1Byte (0x00);
0:         write4Bytes (sqlBytes.length);
0:         writeBytes (sqlBytes, sqlBytes.length);
1:       }
1:     }
1:   }
1: 
0:   // SQLSTTGRP : FDOCA EARLY GROUP
0:   // SQL Statement Group Description
0:   //
0:   // FORMAT FOR SQLAM <= 6
0:   //   SQLSTATEMENT_m; PROTOCOL TYPE LVCM; ENVLID 0x40; Length Override 32767
0:   //   SQLSTATEMENT_s; PROTOCOL TYPE LVCS; ENVLID 0x34; Length Override 32767
0:   //
0:   // FORMAT FOR SQLAM >= 7
0:   //   SQLSTATEMENT_m; PROTOCOL TYPE NOCM; ENVLID 0xCF; Length Override 4
0:   //   SQLSTATEMENT_s; PROTOCOL TYPE NOCS; ENVLID 0xCB; Length Override 4
0:   private void buildSQLSTTGRP (String string) throws SqlException
0:   {
0:       buildNOCMorNOCS (string);
0:       return;
1:   }
1: 
0:   // SQLSTT : FDOCA EARLY ROW
0:   // SQL Statement Row Description
0:   //
0:   // FORMAT FOR ALL SQLAM LEVELS
0:   //   SQLSTTGRP; GROUP LID 0x5C; ELEMENT TAKEN 0(all); REP FACTOR 1
0:   private void buildSQLSTT (String string) throws SqlException
0:   {
0:     buildSQLSTTGRP (string);
1:   }
1: 
0:   protected void buildSQLSTTcommandData (String sql) throws SqlException
0:   {
0:     createEncryptedCommandData ();
0:     int loc = offset_;
0:     markLengthBytes (CodePoint.SQLSTT);
0:     buildSQLSTT (sql);
0:     updateLengthBytes();
0:     if (netAgent_.netConnection_.getSecurityMechanism() ==
0:           NetConfiguration.SECMEC_EUSRIDDTA ||
0:           netAgent_.netConnection_.getSecurityMechanism() ==
0:           NetConfiguration.SECMEC_EUSRPWDDTA)
0:       encryptDataStream(loc);
1: 
1:   }
1: 
1: 
1: 
0:   protected void buildSQLATTRcommandData (String sql) throws SqlException
0:   {
0:     createEncryptedCommandData ();
0:     int loc = offset_;
0:     markLengthBytes (CodePoint.SQLATTR);
0:     buildSQLSTT (sql);
0:     updateLengthBytes();
0:     if (netAgent_.netConnection_.getSecurityMechanism() ==
0:             NetConfiguration.SECMEC_EUSRIDDTA ||
0:             netAgent_.netConnection_.getSecurityMechanism() ==
0:             NetConfiguration.SECMEC_EUSRPWDDTA)
0:        encryptDataStream (loc);
1: 
1:   }
1: 
1: 
0:   public void encryptDataStream(int lengthLocation) throws SqlException
0:   {
0:     byte[] clearedBytes = new byte[offset_ - lengthLocation];
0:     byte[] encryptedBytes;
0:       for (int i = lengthLocation; i < offset_; i++)
0:         clearedBytes[i - lengthLocation] = bytes_[i];
1: 
0:       encryptedBytes = netAgent_.netConnection_.getEncryptionManager().
0:           encryptData(
0:           clearedBytes,
0:           NetConfiguration.SECMEC_EUSRIDPWD,
0:           netAgent_.netConnection_.getTargetPublicKey(),
0:           netAgent_.netConnection_.getTargetPublicKey());
1: 
0:       int length = encryptedBytes.length;
1: 
0:       if(bytes_.length >= lengthLocation + length)
0:         System.arraycopy(encryptedBytes, 0, bytes_, lengthLocation, length);
0:       else {
0:         byte[] largeByte = new byte[lengthLocation + length];
0:         System.arraycopy(bytes_,0,largeByte,0,lengthLocation);
0:         System.arraycopy(encryptedBytes, 0, largeByte, lengthLocation, length);
0:         bytes_ = largeByte;
1:       }
1: 
0:       offset_ += length - clearedBytes.length;
1: 
0:       //we need to update the length in DSS header here.
1: 
0:       bytes_[lengthLocation - 6] = (byte) ( (length >>> 8) & 0xff);
0:       bytes_[lengthLocation - 5] = (byte) (length & 0xff);
1:   }
1: 
1: }
============================================================================