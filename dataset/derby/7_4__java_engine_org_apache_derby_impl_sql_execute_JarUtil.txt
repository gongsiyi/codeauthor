1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.sql.execute.JarUtil
1:345de35: 
1:f6123ee:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f6123ee:    contributor license agreements.  See the NOTICE file distributed with
1:f6123ee:    this work for additional information regarding copyright ownership.
1:f6123ee:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f6123ee:    (the "License"); you may not use this file except in compliance with
1:f6123ee:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
24:eac0369: 
4:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.sql.execute;
1:eac0369: 
1:78c2db1: import java.io.File;
1:ed1c2e3: import java.io.FileInputStream;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.InputStream;
1:ed1c2e3: import java.net.MalformedURLException;
1:ed1c2e3: import java.net.URL;
1:ed1c2e3: import java.security.AccessController;
1:a0dbbd7: import java.security.PrivilegedAction;
1:ed1c2e3: import java.security.PrivilegedActionException;
1:78c2db1: import java.util.HashMap;
1:78c2db1: import java.util.Iterator;
1:78c2db1: import java.util.List;
1:78c2db1: import java.util.Map;
1:78c2db1: import org.apache.derby.catalog.UUID;
1:c2a8161: import org.apache.derby.iapi.error.StandardException;
1:c2a8161: import org.apache.derby.iapi.reference.Property;
1:c2a8161: import org.apache.derby.iapi.reference.SQLState;
1:bf32514: import org.apache.derby.iapi.security.Securable;
1:bf32514: import org.apache.derby.iapi.security.SecurityUtil;
1:a0dbbd7: import org.apache.derby.iapi.services.context.Context;
1:78c2db1: import org.apache.derby.iapi.services.context.ContextService;
1:78c2db1: import org.apache.derby.iapi.services.io.FileUtil;
1:c2a8161: import org.apache.derby.iapi.services.loader.ClassFactory;
1:78c2db1: import org.apache.derby.iapi.services.monitor.Monitor;
1:c2a8161: import org.apache.derby.iapi.services.property.PropertyUtil;
1:c2a8161: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:c2a8161: import org.apache.derby.iapi.sql.depend.DependencyManager;
1:c2a8161: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1:c2a8161: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:c2a8161: import org.apache.derby.iapi.sql.dictionary.FileInfoDescriptor;
1:c2a8161: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1:c2a8161: import org.apache.derby.iapi.store.access.FileResource;
1:78c2db1: import org.apache.derby.iapi.store.access.TransactionController;
1:c2a8161: import org.apache.derby.iapi.util.IdUtil;
1:78c2db1: import org.apache.derby.io.StorageFile;
1:c2a8161: 
1:c2a8161: public class JarUtil
7:eac0369: {
1:eac0369: 	//
1:eac0369: 	//State passed in by the caller
1:c2a8161:     private LanguageConnectionContext lcc;
1:eac0369: 	private String schemaName;
1:eac0369: 	private String sqlName;
1:ed1c2e3: 
1:eac0369: 	//Derived state
1:c2a8161: 	
1:eac0369: 	private FileResource fr;
1:eac0369: 	private DataDictionary dd;
1:eac0369: 	private DataDescriptorGenerator ddg;
1:eac0369: 	
1:eac0369: 	//
1:eac0369: 	//State derived from the caller's context
1:c2a8161: 	private JarUtil(LanguageConnectionContext lcc,
1:c2a8161:             String schemaName, String sqlName)
3:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		this.schemaName = schemaName;
1:eac0369: 		this.sqlName = sqlName;
1:eac0369: 
1:c2a8161:         this.lcc = lcc;
1:eac0369: 		fr = lcc.getTransactionExecute().getFileHandler();
1:eac0369: 		dd = lcc.getDataDictionary();
1:eac0369: 		ddg = dd.getDataDescriptorGenerator();
12:eac0369: 	}
1:c2a8161: 
3:eac0369: 	/**
1:c2a8161: 	  install a jar file to the current connection's database.
1:eac0369: 
3:eac0369: 	  @param schemaName the name for the schema that holds the jar file.
3:eac0369: 	  @param sqlName the sql name for the jar file.
1:eac0369: 	  @param externalPath the path for the jar file to add.
1:eac0369: 	  @return The generationId for the jar file we add.
1:eac0369: 
3:eac0369: 	  @exception StandardException Opps
1:eac0369: 	  */
1:c2a8161: 	public static long
1:c2a8161: 	install(LanguageConnectionContext lcc,
1:c2a8161:             String schemaName, String sqlName, String externalPath)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:bf32514:         // make sure that application code doesn't bypass security checks
1:bf32514:         // by calling this public entry point
1:bf32514:         SecurityUtil.authorize( Securable.INSTALL_JAR );
1:bf32514:             
1:c2a8161: 		JarUtil jutil = new JarUtil(lcc, schemaName, sqlName);
1:eac0369: 		InputStream is = null;
1:eac0369: 		
3:eac0369: 		try {
1:ed1c2e3: 			is = openJarURL(externalPath);
1:eac0369: 			return jutil.add(is);
1:eac0369: 		} catch (java.io.IOException fnfe) {
1:eac0369: 			throw StandardException.newException(SQLState.SQLJ_INVALID_JAR, fnfe, externalPath);
1:eac0369: 		}
1:eac0369: 		finally {
1:eac0369: 			try {if (is != null) is.close();}
1:eac0369: 			catch (IOException ioe) {}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	  Add a jar file to the current connection's database.
1:eac0369: 
1:eac0369: 	  <P> The reason for adding the jar file in this private instance
1:eac0369: 	  method is that it allows us to share set up logic with drop and
1:eac0369: 	  replace.
1:eac0369: 	  @param is A stream for reading the content of the file to add.
1:eac0369: 	  @exception StandardException Opps
1:eac0369: 	  */
1:9fef639: 	private long add(final InputStream is) throws StandardException
1:eac0369: 	{
1:eac0369: 		//
1:eac0369: 		//Like create table we say we are writing before we read the dd
1:eac0369: 		dd.startWriting(lcc);
1:eac0369: 		FileInfoDescriptor fid = getInfo();
1:eac0369: 		if (fid != null)
1:eac0369: 			throw
1:eac0369: 				StandardException.newException(SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT, 
1:eac0369: 											   fid.getDescriptorType(), sqlName, fid.getSchemaDescriptor().getDescriptorType(), schemaName);
1:eac0369: 
1:9fef639:         SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
1:9fef639:         try {
1:9fef639:             notifyLoader(false);
1:9fef639:             dd.invalidateAllSPSPlans();
1:56c1dc2:             UUID id = BaseActivation.getMonitor().getUUIDFactory().createUUID();
1:78c2db1:             final String jarExternalName = JarUtil.mkExternalName(
1:78c2db1:                 id, schemaName, sqlName, fr.getSeparatorChar());
1:eac0369: 
1:66f66a1:             long generationId = setJar(jarExternalName, is, true, 0L);
1:eac0369: 
1:78c2db1:             fid = ddg.newFileInfoDescriptor(id, sd, sqlName, generationId);
1:9fef639:             dd.addDescriptor(fid, sd, DataDictionary.SYSFILES_CATALOG_NUM,
1:9fef639:                     false, lcc.getTransactionExecute());
1:9fef639:             return generationId;
1:9fef639:         } finally {
1:9fef639:             notifyLoader(true);
1:9fef639:         }
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:9fef639:      * Drop a jar file from the current connection's database.
1:9fef639:      * 
1:9fef639:      * @param schemaName
1:9fef639:      *            the name for the schema that holds the jar file.
1:9fef639:      * @param sqlName
1:9fef639:      *            the sql name for the jar file.
1:9fef639:      * 
1:9fef639:      * @exception StandardException
1:9fef639:      *                Opps
1:9fef639:      */
1:c2a8161: 	public static void
1:c2a8161: 	drop(LanguageConnectionContext lcc, String schemaName, String sqlName)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:bf32514:         // make sure that application code doesn't bypass security checks
1:bf32514:         // by calling this public entry point
1:bf32514:         SecurityUtil.authorize( Securable.REMOVE_JAR );
1:bf32514:             
1:c2a8161: 		JarUtil jutil = new JarUtil(lcc, schemaName,sqlName);
1:609999f: 		jutil.drop();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:eac0369: 	  Drop a jar file from the current connection's database.
1:eac0369: 
1:eac0369: 	  <P> The reason for dropping  the jar file in this private instance
1:eac0369: 	  method is that it allows us to share set up logic with add and
1:eac0369: 	  replace.
1:eac0369: 
1:eac0369: 	  @exception StandardException Opps
1:eac0369: 	  */
1:609999f: 	private void drop() throws StandardException
1:eac0369: 	{
1:eac0369: 		//
1:eac0369: 		//Like create table we say we are writing before we read the dd
1:eac0369: 		dd.startWriting(lcc);
1:eac0369: 		FileInfoDescriptor fid = getInfo();
2:eac0369: 		if (fid == null)
2:eac0369: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
1:eac0369: 
1:eac0369: 		String dbcp_s = PropertyUtil.getServiceProperty(lcc.getTransactionExecute(),Property.DATABASE_CLASSPATH);
1:eac0369: 		if (dbcp_s != null)
1:eac0369: 		{
1:9067662: 			String[][]dbcp= IdUtil.parseDbClassPath(dbcp_s);
1:eac0369: 			boolean found = false;
1:eac0369: 			//
1:eac0369: 			//Look for the jar we are dropping on our database classpath.
1:eac0369: 			//We don't concern ourselves with 3 part names since they may
1:eac0369: 			//refer to a jar file in another database and may not occur in
1:eac0369: 			//a database classpath that is stored in the propert congomerate.
1:eac0369: 			for (int ix=0;ix<dbcp.length;ix++)
1:eac0369: 				if (dbcp.length == 2 &&
1:eac0369: 					dbcp[ix][0].equals(schemaName) && dbcp[ix][1].equals(sqlName))
1:eac0369: 					found = true;
1:eac0369: 			if (found)
1:eac0369: 				throw StandardException.newException(SQLState.LANG_CANT_DROP_JAR_ON_DB_CLASS_PATH_DURING_EXECUTION, 
1:eac0369: 									IdUtil.mkQualifiedName(schemaName,sqlName),
1:eac0369: 									dbcp_s);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 		
2:eac0369: 			notifyLoader(false);
2:eac0369: 			dd.invalidateAllSPSPlans();
1:eac0369: 			DependencyManager dm = dd.getDependencyManager();
1:eac0369: 			dm.invalidateFor(fid, DependencyManager.DROP_JAR, lcc);
1:eac0369: 
1:78c2db1:             UUID id = fid.getUUID();
1:eac0369: 			dd.dropFileInfoDescriptor(fid);
1:78c2db1:             fr.remove(
1:78c2db1:                 JarUtil.mkExternalName(
1:78c2db1:                     id, schemaName, sqlName, fr.getSeparatorChar()),
1:609999f: 				fid.getGenerationId());
2:eac0369: 		} finally {
2:eac0369: 			notifyLoader(true);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Replace a jar file from the current connection's database with the content of an
1:eac0369: 	  external file. 
1:eac0369: 
1:eac0369: 
1:eac0369: 	  @param schemaName the name for the schema that holds the jar file.
1:eac0369: 	  @param sqlName the sql name for the jar file.
1:eac0369: 	  @param externalPath the path for the jar file to add.
1:eac0369: 	  @return The new generationId for the jar file we replace.
1:eac0369: 
1:eac0369: 	  @exception StandardException Opps
1:eac0369: 	  */
1:c2a8161: 	public static long
1:c2a8161: 	replace(LanguageConnectionContext lcc, String schemaName, String sqlName,
1:609999f: 			String externalPath)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:bf32514:         // make sure that application code doesn't bypass security checks
1:bf32514:         // by calling this public entry point
1:bf32514:         SecurityUtil.authorize( Securable.REPLACE_JAR );
1:bf32514:             
1:c2a8161: 		JarUtil jutil = new JarUtil(lcc, schemaName,sqlName);
1:eac0369: 		InputStream is = null;
1:eac0369: 		
1:eac0369: 
1:eac0369: 		try {
1:ed1c2e3: 			is = openJarURL(externalPath);
1:eac0369: 
1:609999f: 			return jutil.replace(is);
1:eac0369: 		} catch (java.io.IOException fnfe) {
1:eac0369: 			throw StandardException.newException(SQLState.SQLJ_INVALID_JAR, fnfe, externalPath);
1:eac0369: 		}
1:eac0369: 		finally {
1:eac0369: 			try {if (is != null) is.close();}
1:eac0369: 			catch (IOException ioe) {}
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Replace a jar file in the current connection's database with the
1:eac0369: 	  content of an external file.
1:eac0369: 
1:eac0369: 	  <P> The reason for adding the jar file in this private instance
1:eac0369: 	  method is that it allows us to share set up logic with add and
1:eac0369: 	  drop.
1:eac0369: 	  @param is An input stream for reading the new content of the jar file.
1:eac0369: 	  @exception StandardException Opps
1:eac0369: 	  */
1:609999f: 	private long replace(InputStream is) throws StandardException
1:eac0369: 	{
1:eac0369: 		//
1:eac0369: 		//Like create table we say we are writing before we read the dd
1:eac0369: 		dd.startWriting(lcc);
1:eac0369: 
1:eac0369: 		//
1:eac0369: 		//Temporarily drop the FileInfoDescriptor from the data dictionary.
1:eac0369: 		FileInfoDescriptor fid = getInfo();
1:eac0369: 		if (fid == null)
1:eac0369: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
1:eac0369: 
1:eac0369: 		try {
1:eac0369: 			// disable loads from this jar
1:eac0369: 			notifyLoader(false);
1:eac0369: 			dd.invalidateAllSPSPlans();
1:eac0369: 			dd.dropFileInfoDescriptor(fid);
1:9fef639:             final String jarExternalName =
1:78c2db1:                 JarUtil.mkExternalName(
1:78c2db1:                     fid.getUUID(), schemaName, sqlName, fr.getSeparatorChar());
1:eac0369: 
1:eac0369: 			//
1:eac0369: 			//Replace the file.
1:66f66a1: 			long generationId = setJar(jarExternalName, is, false,
1:66f66a1: 					fid.getGenerationId());
1:66f66a1:             
1:eac0369: 			//
1:eac0369: 			//Re-add the descriptor to the data dictionary.
1:eac0369: 			FileInfoDescriptor fid2 = 
1:eac0369: 				ddg.newFileInfoDescriptor(fid.getUUID(),fid.getSchemaDescriptor(),
1:eac0369: 								sqlName,generationId);
1:eac0369: 			dd.addDescriptor(fid2, fid.getSchemaDescriptor(),
1:eac0369: 							 DataDictionary.SYSFILES_CATALOG_NUM, false, lcc.getTransactionExecute());
2:eac0369: 			return generationId;
1:eac0369: 
1:eac0369: 		} finally {
1:eac0369: 
1:eac0369: 			// reenable class loading from this jar
1:eac0369: 			notifyLoader(true);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Get the FileInfoDescriptor for the Jar file or null if it does not exist.
1:eac0369: 	  @exception StandardException Ooops
1:eac0369: 	  */
1:eac0369: 	private FileInfoDescriptor getInfo()
1:eac0369: 		 throws StandardException
1:eac0369: 	{
2:eac0369: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
1:eac0369: 		return dd.getFileInfoDescriptor(sd,sqlName);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void notifyLoader(boolean reload) throws StandardException {
1:eac0369: 		ClassFactory cf = lcc.getLanguageConnectionFactory().getClassFactory();
1:eac0369: 		cf.notifyModifyJar(reload);
1:eac0369: 	}
1:ed1c2e3: 
1:ed1c2e3:     /**
1:ed1c2e3:      * Open an input stream to read a URL or a file.
1:ed1c2e3:      * URL is attempted first, if the string does not conform
1:ed1c2e3:      * to a URL then an attempt to open it as a regular file
1:ed1c2e3:      * is tried.
1:ed1c2e3:      * <BR>
1:ed1c2e3:      * Attempting the file first can throw a security execption
1:ed1c2e3:      * when a valid URL is passed in.
1:ed1c2e3:      * The security exception is due to not have the correct permissions
1:ed1c2e3:      * to access the bogus file path. To avoid this the order was reversed
1:ed1c2e3:      * to attempt the URL first and only attempt a file open if creating
1:ed1c2e3:      * the URL throws a MalformedURLException.
1:ed1c2e3:      */
1:ed1c2e3:     private static InputStream openJarURL(final String externalPath)
1:ed1c2e3:         throws IOException
1:ed1c2e3:     {
1:ed1c2e3:         try {
1:71c8e86:             return AccessController.doPrivileged
1:71c8e86:             (new java.security.PrivilegedExceptionAction<InputStream>(){
1:ed1c2e3:                 
1:71c8e86:                 public InputStream run() throws IOException {    
1:ed1c2e3:                     try {
1:ed1c2e3:                         return new URL(externalPath).openStream();
1:ed1c2e3:                     } catch (MalformedURLException mfurle)
1:ed1c2e3:                     {
1:ed1c2e3:                         return new FileInputStream(externalPath);
1:ed1c2e3:                     }
1:ed1c2e3:                 }
1:ed1c2e3:             });
1:ed1c2e3:         } catch (PrivilegedActionException e) {
1:ed1c2e3:             throw (IOException) e.getException();
1:ed1c2e3:         }
1:ed1c2e3:     }
1:9fef639:     
1:9fef639:     /**
1:9fef639:      * Copy the jar from the externally obtained 
1:9fef639:      * input stream into the database
1:9fef639:      * @param jarExternalName Name of jar with database structure.
1:9fef639:      * @param contents Contents of jar file.
1:66f66a1:      * @param add true to add, false to replace
1:66f66a1:      * @param currentGenerationId generation id of existing version, ignored when adding.
1:9fef639:      */
1:66f66a1:     private long setJar(final String jarExternalName,
1:66f66a1:             final InputStream contents,
1:66f66a1:             final boolean add,
1:66f66a1:             final long currentGenerationId)
1:9fef639:             throws StandardException {
1:9fef639:         try {
1:71c8e86:             return (AccessController
1:71c8e86:                     .doPrivileged(new java.security.PrivilegedExceptionAction<Long>() {
1:9fef639: 
1:71c8e86:                         public Long run() throws StandardException {
1:66f66a1:                             long generationId;
1:66f66a1:                             
1:66f66a1:                             if (add)
1:66f66a1:                                 generationId = fr.add(jarExternalName, contents);
1:66f66a1:                             else
1:66f66a1:                                 generationId =  fr.replace(jarExternalName,
1:66f66a1:                                         currentGenerationId, contents);
1:ce40a31:                             return generationId;
1:9fef639:                         }
1:9fef639:                     })).longValue();
1:9fef639:         } catch (PrivilegedActionException e) {
1:9fef639:             throw (StandardException) e.getException();
1:9fef639:         }
1:9fef639:     }
1:c2a8161:     
1:c2a8161:     /**
1:c2a8161:       Make an external name for a jar file stored in the database.
1:c2a8161:       */
1:78c2db1:     public static String mkExternalName(
1:78c2db1:             UUID id, 
1:78c2db1:             String schemaName, 
1:78c2db1:             String sqlName, 
1:78c2db1:             char separatorChar) throws StandardException
1:78c2db1:     {
1:78c2db1:         return mkExternalNameInternal(
1:78c2db1:             id, schemaName, sqlName, separatorChar, false, false);
1:78c2db1:     }
1:78c2db1: 
1:78c2db1:     private static String mkExternalNameInternal(
1:78c2db1:             UUID id,
1:78c2db1:             String schemaName,
1:78c2db1:             String sqlName,
1:78c2db1:             char separatorChar,
1:78c2db1:             boolean upgrading,
1:78c2db1:             boolean newStyle) throws StandardException
1:c2a8161:     {
1:c2a8161:         StringBuffer sb = new StringBuffer(30);
1:c2a8161:         sb.append(FileResource.JAR_DIRECTORY_NAME);
2:c2a8161:         sb.append(separatorChar);
1:78c2db1: 
1:78c2db1:         boolean uuidSupported = false;
1:78c2db1: 
1:78c2db1:         if (!upgrading) {
1:78c2db1:             LanguageConnectionContext lcc =
1:a0dbbd7:                 (LanguageConnectionContext)getContextOrNull(
1:78c2db1:                     LanguageConnectionContext.CONTEXT_ID);
1:78c2db1: 
1:78c2db1:             // DERBY-5357 UUIDs introduced in jar file names in 10.9
1:78c2db1:             uuidSupported =
1:78c2db1:                 lcc.getDataDictionary().
1:78c2db1:                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_9, null);
1:78c2db1:         }
1:78c2db1: 
1:78c2db1: 
1:78c2db1:         if (!upgrading && uuidSupported || upgrading && newStyle) {
1:78c2db1:             sb.append(id.toString());
1:78c2db1:             sb.append(".jar");
1:78c2db1:         } else {
1:78c2db1:             sb.append(schemaName);
1:78c2db1:             sb.append(separatorChar);
1:78c2db1:             sb.append(sqlName);
1:78c2db1:             sb.append(".jar");
1:78c2db1:         }
1:78c2db1: 
1:c2a8161:         return sb.toString();
1:c2a8161:     }
1:78c2db1: 
1:78c2db1:     /**
1:dbed020:      * Upgrade code: upgrade one jar file to new style (&gt;= 10.9)
1:78c2db1:      *
1:78c2db1:      * @param tc transaction controller
1:78c2db1:      * @param fid the jar file to be upgraded
1:78c2db1:      * @throws StandardException
1:78c2db1:      */
1:78c2db1:     public static void upgradeJar(
1:78c2db1:             TransactionController tc,
1:78c2db1:             FileInfoDescriptor fid)
1:78c2db1:             throws StandardException {
1:78c2db1: 
1:78c2db1:         FileResource fh = tc.getFileHandler();
1:78c2db1: 
1:78c2db1:         StorageFile oldFile = fh.getAsFile(
1:78c2db1:             mkExternalNameInternal(
1:78c2db1:                 fid.getUUID(),
1:78c2db1:                 fid.getSchemaDescriptor().getSchemaName(),
1:78c2db1:                 fid.getName(),
1:78c2db1:                 File.separatorChar,
1:78c2db1:                 true,
1:78c2db1:                 false),
1:78c2db1:             fid.getGenerationId());
1:78c2db1: 
1:78c2db1:         StorageFile newFile = fh.getAsFile(
1:78c2db1:             mkExternalNameInternal(
1:78c2db1:                 fid.getUUID(),
1:78c2db1:                 fid.getSchemaDescriptor().getSchemaName(),
1:78c2db1:                 fid.getName(),
1:78c2db1:                 File.separatorChar,
1:78c2db1:                 true,
1:78c2db1:                 true),
1:78c2db1:             fid.getGenerationId());
1:78c2db1: 
1:78c2db1:         FileUtil.copyFile(
1:78c2db1:                 new File(oldFile.getPath()),
1:78c2db1:                 new File(newFile.getPath()), null);
1:78c2db1:     }
1:a0dbbd7:     
1:a0dbbd7:     /**
1:a0dbbd7:      * Privileged lookup of a Context. Must be private so that user code
1:a0dbbd7:      * can't call this entry point.
1:a0dbbd7:      */
1:a0dbbd7:     private  static  Context    getContextOrNull( final String contextID )
1:a0dbbd7:     {
1:a0dbbd7:         if ( System.getSecurityManager() == null )
1:a0dbbd7:         {
1:a0dbbd7:             return ContextService.getContextOrNull( contextID );
1:a0dbbd7:         }
1:a0dbbd7:         else
1:a0dbbd7:         {
1:a0dbbd7:             return AccessController.doPrivileged
1:a0dbbd7:                 (
1:a0dbbd7:                  new PrivilegedAction<Context>()
1:a0dbbd7:                  {
1:a0dbbd7:                      public Context run()
1:a0dbbd7:                      {
1:a0dbbd7:                          return ContextService.getContextOrNull( contextID );
1:a0dbbd7:                      }
1:a0dbbd7:                  }
1:a0dbbd7:                  );
1:a0dbbd7:         }
1:a0dbbd7:     }
1:a0dbbd7: 
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      * Upgrade code: upgrade one jar file to new style (&gt;= 10.9)
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                             return generationId;
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1:             UUID id = BaseActivation.getMonitor().getUUIDFactory().createUUID();
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.context.Context;
/////////////////////////////////////////////////////////////////////////
1:                 (LanguageConnectionContext)getContextOrNull(
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Privileged lookup of a Context. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  Context    getContextOrNull( final String contextID )
1:     {
1:         if ( System.getSecurityManager() == null )
1:         {
1:             return ContextService.getContextOrNull( contextID );
1:         }
1:         else
1:         {
1:             return AccessController.doPrivileged
1:                 (
1:                  new PrivilegedAction<Context>()
1:                  {
1:                      public Context run()
1:                      {
1:                          return ContextService.getContextOrNull( contextID );
1:                      }
1:                  }
1:                  );
1:         }
1:     }
1: 
commit:bf32514
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.security.Securable;
1: import org.apache.derby.iapi.security.SecurityUtil;
/////////////////////////////////////////////////////////////////////////
1:         // make sure that application code doesn't bypass security checks
1:         // by calling this public entry point
1:         SecurityUtil.authorize( Securable.INSTALL_JAR );
1:             
/////////////////////////////////////////////////////////////////////////
1:         // make sure that application code doesn't bypass security checks
1:         // by calling this public entry point
1:         SecurityUtil.authorize( Securable.REMOVE_JAR );
1:             
/////////////////////////////////////////////////////////////////////////
1:         // make sure that application code doesn't bypass security checks
1:         // by calling this public entry point
1:         SecurityUtil.authorize( Securable.REPLACE_JAR );
1:             
commit:71c8e86
/////////////////////////////////////////////////////////////////////////
1:             return AccessController.doPrivileged
1:             (new java.security.PrivilegedExceptionAction<InputStream>(){
1:                 public InputStream run() throws IOException {    
/////////////////////////////////////////////////////////////////////////
1:             return (AccessController
1:                     .doPrivileged(new java.security.PrivilegedExceptionAction<Long>() {
1:                         public Long run() throws StandardException {
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:78c2db1
/////////////////////////////////////////////////////////////////////////
1: import java.io.File;
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
1: import java.util.Iterator;
1: import java.util.List;
1: import java.util.Map;
1: import org.apache.derby.catalog.UUID;
1: import org.apache.derby.iapi.services.context.ContextService;
1: import org.apache.derby.iapi.services.io.FileUtil;
1: import org.apache.derby.iapi.services.monitor.Monitor;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.io.StorageFile;
/////////////////////////////////////////////////////////////////////////
0:             UUID id = Monitor.getMonitor().getUUIDFactory().createUUID();
1:             final String jarExternalName = JarUtil.mkExternalName(
1:                 id, schemaName, sqlName, fr.getSeparatorChar());
1:             fid = ddg.newFileInfoDescriptor(id, sd, sqlName, generationId);
/////////////////////////////////////////////////////////////////////////
1:             UUID id = fid.getUUID();
1:             fr.remove(
1:                 JarUtil.mkExternalName(
1:                     id, schemaName, sqlName, fr.getSeparatorChar()),
/////////////////////////////////////////////////////////////////////////
1:                 JarUtil.mkExternalName(
1:                     fid.getUUID(), schemaName, sqlName, fr.getSeparatorChar());
/////////////////////////////////////////////////////////////////////////
1:     public static String mkExternalName(
1:             UUID id, 
1:             String schemaName, 
1:             String sqlName, 
1:             char separatorChar) throws StandardException
1:     {
1:         return mkExternalNameInternal(
1:             id, schemaName, sqlName, separatorChar, false, false);
1:     }
1: 
1:     private static String mkExternalNameInternal(
1:             UUID id,
1:             String schemaName,
1:             String sqlName,
1:             char separatorChar,
1:             boolean upgrading,
1:             boolean newStyle) throws StandardException
1: 
1:         boolean uuidSupported = false;
1: 
1:         if (!upgrading) {
1:             LanguageConnectionContext lcc =
0:                 (LanguageConnectionContext)ContextService.getContextOrNull(
1:                     LanguageConnectionContext.CONTEXT_ID);
1: 
1:             // DERBY-5357 UUIDs introduced in jar file names in 10.9
1:             uuidSupported =
1:                 lcc.getDataDictionary().
1:                 checkVersion(DataDictionary.DD_VERSION_DERBY_10_9, null);
1:         }
1: 
1: 
1:         if (!upgrading && uuidSupported || upgrading && newStyle) {
1:             sb.append(id.toString());
1:             sb.append(".jar");
1:         } else {
1:             sb.append(schemaName);
1:             sb.append(separatorChar);
1:             sb.append(sqlName);
1:             sb.append(".jar");
1:         }
1: 
1: 
1:     /**
0:      * Upgrade code: upgrade one jar file to new style (>= 10.9)
1:      *
1:      * @param tc transaction controller
1:      * @param fid the jar file to be upgraded
1:      * @throws StandardException
1:      */
1:     public static void upgradeJar(
1:             TransactionController tc,
1:             FileInfoDescriptor fid)
1:             throws StandardException {
1: 
1:         FileResource fh = tc.getFileHandler();
1: 
1:         StorageFile oldFile = fh.getAsFile(
1:             mkExternalNameInternal(
1:                 fid.getUUID(),
1:                 fid.getSchemaDescriptor().getSchemaName(),
1:                 fid.getName(),
1:                 File.separatorChar,
1:                 true,
1:                 false),
1:             fid.getGenerationId());
1: 
1:         StorageFile newFile = fh.getAsFile(
1:             mkExternalNameInternal(
1:                 fid.getUUID(),
1:                 fid.getSchemaDescriptor().getSchemaName(),
1:                 fid.getName(),
1:                 File.separatorChar,
1:                 true,
1:                 true),
1:             fid.getGenerationId());
1: 
1:         FileUtil.copyFile(
1:                 new File(oldFile.getPath()),
1:                 new File(newFile.getPath()), null);
1:     }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:9067662
/////////////////////////////////////////////////////////////////////////
1: 			String[][]dbcp= IdUtil.parseDbClassPath(dbcp_s);
commit:03f03b6
/////////////////////////////////////////////////////////////////////////
0: 			String[][]dbcp= IdUtil.parseDbClassPath(dbcp_s, true);
commit:c2a8161
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.loader.ClassFactory;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.sql.depend.DependencyManager;
1: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.FileInfoDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: import org.apache.derby.iapi.store.access.FileResource;
1: import org.apache.derby.iapi.util.IdUtil;
1: 
1: public class JarUtil
1:     private LanguageConnectionContext lcc;
1: 	
1: 	private JarUtil(LanguageConnectionContext lcc,
1:             String schemaName, String sqlName)
1:         this.lcc = lcc;
1: 	  install a jar file to the current connection's database.
/////////////////////////////////////////////////////////////////////////
1: 	public static long
1: 	install(LanguageConnectionContext lcc,
1:             String schemaName, String sqlName, String externalPath)
1: 		JarUtil jutil = new JarUtil(lcc, schemaName, sqlName);
/////////////////////////////////////////////////////////////////////////
0:             final String jarExternalName = JarUtil.mkExternalName(schemaName,
/////////////////////////////////////////////////////////////////////////
1: 	public static void
1: 	drop(LanguageConnectionContext lcc, String schemaName, String sqlName)
1: 		JarUtil jutil = new JarUtil(lcc, schemaName,sqlName);
/////////////////////////////////////////////////////////////////////////
0: 			fr.remove(JarUtil.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),
/////////////////////////////////////////////////////////////////////////
1: 	public static long
1: 	replace(LanguageConnectionContext lcc, String schemaName, String sqlName,
1: 		JarUtil jutil = new JarUtil(lcc, schemaName,sqlName);
/////////////////////////////////////////////////////////////////////////
0:                 JarUtil.mkExternalName(schemaName, sqlName, fr.getSeparatorChar());
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:       Make an external name for a jar file stored in the database.
1:       */
0:     public static String mkExternalName(String schemaName, String sqlName, char separatorChar)
1:     {
1:         StringBuffer sb = new StringBuffer(30);
1: 
1:         sb.append(FileResource.JAR_DIRECTORY_NAME);
1:         sb.append(separatorChar);
0:         sb.append(schemaName);
1:         sb.append(separatorChar);
0:         sb.append(sqlName);
0:         sb.append(".jar");
1:         return sb.toString();
1:     }
commit:66f66a1
/////////////////////////////////////////////////////////////////////////
1:             long generationId = setJar(jarExternalName, is, true, 0L);
/////////////////////////////////////////////////////////////////////////
1: 			long generationId = setJar(jarExternalName, is, false,
1: 					fid.getGenerationId());
1:             
/////////////////////////////////////////////////////////////////////////
1:      * @param add true to add, false to replace
1:      * @param currentGenerationId generation id of existing version, ignored when adding.
1:     private long setJar(final String jarExternalName,
1:             final InputStream contents,
1:             final boolean add,
1:             final long currentGenerationId)
1:                             long generationId;
1:                             
1:                             if (add)
1:                                 generationId = fr.add(jarExternalName, contents);
1:                             else
1:                                 generationId =  fr.replace(jarExternalName,
1:                                         currentGenerationId, contents);
0:                             return new Long(generationId);
commit:609999f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 	private JarUtil(String schemaName, String sqlName)
/////////////////////////////////////////////////////////////////////////
0: 	add(String schemaName, String sqlName, String externalPath)
0: 		JarUtil jutil = new JarUtil(schemaName, sqlName);
/////////////////////////////////////////////////////////////////////////
0:             fid = ddg.newFileInfoDescriptor(/*DJD*/null, sd, sqlName, generationId);
/////////////////////////////////////////////////////////////////////////
0: 	drop(String schemaName, String sqlName)
0: 		JarUtil jutil = new JarUtil(schemaName,sqlName);
1: 		jutil.drop();
/////////////////////////////////////////////////////////////////////////
1: 	private void drop() throws StandardException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 				fid.getGenerationId());
/////////////////////////////////////////////////////////////////////////
0: 	replace(String schemaName, String sqlName,
1: 			String externalPath)
0: 		JarUtil jutil = new JarUtil(schemaName,sqlName);
1: 			return jutil.replace(is);
/////////////////////////////////////////////////////////////////////////
1: 	private long replace(InputStream is) throws StandardException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 					fid.getGenerationId(), is);
commit:9fef639
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	private long add(final InputStream is) throws StandardException
/////////////////////////////////////////////////////////////////////////
1:         SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
1:         try {
1:             notifyLoader(false);
1:             dd.invalidateAllSPSPlans();
0:             final String jarExternalName = JarDDL.mkExternalName(schemaName,
0:                     sqlName, fr.getSeparatorChar());
0:             long generationId = setJar(jarExternalName, is);
0:             fid = ddg.newFileInfoDescriptor(id, sd, sqlName, generationId);
1:             dd.addDescriptor(fid, sd, DataDictionary.SYSFILES_CATALOG_NUM,
1:                     false, lcc.getTransactionExecute());
1:             return generationId;
1:         } finally {
1:             notifyLoader(true);
1:         }
1:      * Drop a jar file from the current connection's database.
1:      * 
0:      * @param id
0:      *            The id for the jar file we drop. Ignored if null.
1:      * @param schemaName
1:      *            the name for the schema that holds the jar file.
1:      * @param sqlName
1:      *            the sql name for the jar file.
0:      * @param purgeOnCommit
0:      *            True means purge the old jar file on commit. False means leave
0:      *            it around for use by replication.
1:      * 
1:      * @exception StandardException
1:      *                Opps
1:      */
/////////////////////////////////////////////////////////////////////////
1:             final String jarExternalName =
0:                 JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar());
0: 				fr.replace(jarExternalName,
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Copy the jar from the externally obtained 
1:      * input stream into the database
1:      * @param jarExternalName Name of jar with database structure.
1:      * @param contents Contents of jar file.
1:      */
0:     private long setJar(final String jarExternalName, final InputStream contents)
1:             throws StandardException {
1:         try {
0:             return ((Long) AccessController
0:                     .doPrivileged(new java.security.PrivilegedExceptionAction() {
1: 
0:                         public Object run() throws StandardException {
0:                             long generatedId = fr.add(jarExternalName, contents);
0:                             return new Long(generatedId);
1:                         }
1:                     })).longValue();
1:         } catch (PrivilegedActionException e) {
1:             throw (StandardException) e.getException();
1:         }
1:     }
commit:ed1c2e3
/////////////////////////////////////////////////////////////////////////
1: import java.io.FileInputStream;
1: import java.net.MalformedURLException;
1: import java.net.URL;
1: import java.security.AccessController;
1: import java.security.PrivilegedActionException;
1: 
/////////////////////////////////////////////////////////////////////////
1: 			is = openJarURL(externalPath);
/////////////////////////////////////////////////////////////////////////
1: 			is = openJarURL(externalPath);
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Open an input stream to read a URL or a file.
1:      * URL is attempted first, if the string does not conform
1:      * to a URL then an attempt to open it as a regular file
1:      * is tried.
1:      * <BR>
1:      * Attempting the file first can throw a security execption
1:      * when a valid URL is passed in.
1:      * The security exception is due to not have the correct permissions
1:      * to access the bogus file path. To avoid this the order was reversed
1:      * to attempt the URL first and only attempt a file open if creating
1:      * the URL throws a MalformedURLException.
1:      */
1:     private static InputStream openJarURL(final String externalPath)
1:         throws IOException
1:     {
1:         try {
0:             return (InputStream) AccessController.doPrivileged
0:             (new java.security.PrivilegedExceptionAction(){
1:                 
0:                 public Object run() throws IOException {    
1:                     try {
1:                         return new URL(externalPath).openStream();
1:                     } catch (MalformedURLException mfurle)
1:                     {
1:                         return new FileInputStream(externalPath);
1:                     }
1:                 }
1:             });
1:         } catch (PrivilegedActionException e) {
1:             throw (IOException) e.getException();
1:         }
1:     }
commit:6989c4c
/////////////////////////////////////////////////////////////////////////
0: class JarUtil
/////////////////////////////////////////////////////////////////////////
0: 	private JarUtil(UUID id, String schemaName, String sqlName)
/////////////////////////////////////////////////////////////////////////
0: 	static long
/////////////////////////////////////////////////////////////////////////
0: 	private long add(InputStream is) throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	static void
/////////////////////////////////////////////////////////////////////////
0: 	private void drop(boolean purgeOnCommit) throws StandardException
/////////////////////////////////////////////////////////////////////////
0: 	static long
/////////////////////////////////////////////////////////////////////////
0: 	private long replace(InputStream is,boolean purgeOnCommit) throws StandardException
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.sql.execute.JarUtil
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:9e5097f
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.sql.execute;
1: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.util.IdUtil;
0: import org.apache.derby.impl.sql.execute.JarDDL;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.FileInfoDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
1: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.store.access.FileResource;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.io.FileUtil;
0: import org.apache.derby.io.StorageFile;
1: 
1: import java.io.IOException;
1: import java.io.InputStream;
0: import java.sql.CallableStatement;
0: import java.sql.Connection;
0: import java.sql.SQLException;
1: 
0: public class JarUtil
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	public static final String ADD_JAR_DDL = "ADD JAR";
0: 	public static final String DROP_JAR_DDL = "DROP JAR";
0: 	public static final String REPLACE_JAR_DDL = "REPLACE JAR";
0: 	public static final String READ_JAR = "READ JAR";
1: 	//
1: 	//State passed in by the caller
0: 	private UUID id; //For add null means create a new id.
1: 	private String schemaName;
1: 	private String sqlName;
1: 
1: 	//Derived state
0: 	private LanguageConnectionContext lcc;
1: 	private FileResource fr;
1: 	private DataDictionary dd;
1: 	private DataDescriptorGenerator ddg;
1: 	
1: 	//
1: 	//State derived from the caller's context
0: 	public JarUtil(UUID id, String schemaName, String sqlName)
1: 		 throws StandardException
1: 	{
0: 		this.id = id;
1: 		this.schemaName = schemaName;
1: 		this.sqlName = sqlName;
1: 
0:         lcc = (LanguageConnectionContext)
0: 			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
1: 		fr = lcc.getTransactionExecute().getFileHandler();
1: 		dd = lcc.getDataDictionary();
1: 		ddg = dd.getDataDescriptorGenerator();
1: 	}
1: 
1: 	/**
1: 	  Add a jar file to the current connection's database.
1: 
0: 	  @param id The id for the jar file we add. If null this makes up a new id.
1: 	  @param schemaName the name for the schema that holds the jar file.
1: 	  @param sqlName the sql name for the jar file.
1: 	  @param externalPath the path for the jar file to add.
1: 	  @return The generationId for the jar file we add.
1: 
1: 	  @exception StandardException Opps
1: 	  */
0: 	static public long
0: 	add(UUID id, String schemaName, String sqlName, String externalPath)
1: 		 throws StandardException
1: 	{
0: 		JarUtil jutil = new JarUtil(id, schemaName, sqlName);
1: 		InputStream is = null;
1: 		
1: 		try {
0: 			is = FileUtil.getInputStream(externalPath, 0);
1: 			return jutil.add(is);
1: 		} catch (java.io.IOException fnfe) {
1: 			throw StandardException.newException(SQLState.SQLJ_INVALID_JAR, fnfe, externalPath);
1: 		}
1: 		finally {
1: 			try {if (is != null) is.close();}
1: 			catch (IOException ioe) {}
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Add a jar file to the current connection's database.
1: 
1: 	  <P> The reason for adding the jar file in this private instance
1: 	  method is that it allows us to share set up logic with drop and
1: 	  replace.
1: 	  @param is A stream for reading the content of the file to add.
1: 	  @exception StandardException Opps
1: 	  */
0: 	public long add(InputStream is) throws StandardException
1: 	{
1: 		//
1: 		//Like create table we say we are writing before we read the dd
1: 		dd.startWriting(lcc);
1: 		FileInfoDescriptor fid = getInfo();
1: 		if (fid != null)
1: 			throw
1: 				StandardException.newException(SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT, 
1: 											   fid.getDescriptorType(), sqlName, fid.getSchemaDescriptor().getDescriptorType(), schemaName);
1: 
1: 		try {
1: 			notifyLoader(false);
1: 			dd.invalidateAllSPSPlans();
0: 			long generationId = fr.add(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),is);
1: 
1: 			SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
1: 
0: 			fid = ddg.newFileInfoDescriptor(id, sd,
0: 							sqlName, generationId);
0: 			dd.addDescriptor(fid, sd, DataDictionary.SYSFILES_CATALOG_NUM,
0: 							 false, lcc.getTransactionExecute());
1: 			return generationId;
1: 		} finally {
1: 			notifyLoader(true);
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Drop a jar file from the current connection's database.
1: 
0: 	  @param id The id for the jar file we drop. Ignored if null.
1: 	  @param schemaName the name for the schema that holds the jar file.
1: 	  @param sqlName the sql name for the jar file.
0: 	  @param purgeOnCommit True means purge the old jar file on commit. False
0: 	    means leave it around for use by replication.
1: 
1: 	  @exception StandardException Opps
1: 	  */
0: 	static public void
0: 	drop(UUID id, String schemaName, String sqlName,boolean purgeOnCommit)
1: 		 throws StandardException
1: 	{
0: 		JarUtil jutil = new JarUtil(id, schemaName,sqlName);
0: 		jutil.drop(purgeOnCommit);
1: 	}
1: 
1: 	/**
1: 	  Drop a jar file from the current connection's database.
1: 
1: 	  <P> The reason for dropping  the jar file in this private instance
1: 	  method is that it allows us to share set up logic with add and
1: 	  replace.
0: 	  @param purgeOnCommit True means purge the old jar file on commit. False
0: 	    means leave it around for use by replication.
1: 
1: 	  @exception StandardException Opps
1: 	  */
0: 	public void drop(boolean purgeOnCommit) throws StandardException
1: 	{
1: 		//
1: 		//Like create table we say we are writing before we read the dd
1: 		dd.startWriting(lcc);
1: 		FileInfoDescriptor fid = getInfo();
1: 		if (fid == null)
1: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
1: 
0: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (id != null && !fid.getUUID().equals(id))
1: 			{
0: 				SanityManager.THROWASSERT("Drop id mismatch want="+id+
0: 						" have "+fid.getUUID());
1: 			}
1: 		}
1: 
1: 		String dbcp_s = PropertyUtil.getServiceProperty(lcc.getTransactionExecute(),Property.DATABASE_CLASSPATH);
1: 		if (dbcp_s != null)
1: 		{
0: 			String[][]dbcp= IdUtil.parseDbClassPath(dbcp_s,
0:                                                             lcc.getIdentifierCasing() != lcc.ANTI_ANSI_CASING );
1: 			boolean found = false;
1: 			//
1: 			//Look for the jar we are dropping on our database classpath.
1: 			//We don't concern ourselves with 3 part names since they may
1: 			//refer to a jar file in another database and may not occur in
1: 			//a database classpath that is stored in the propert congomerate.
1: 			for (int ix=0;ix<dbcp.length;ix++)
1: 				if (dbcp.length == 2 &&
1: 					dbcp[ix][0].equals(schemaName) && dbcp[ix][1].equals(sqlName))
1: 					found = true;
1: 			if (found)
1: 				throw StandardException.newException(SQLState.LANG_CANT_DROP_JAR_ON_DB_CLASS_PATH_DURING_EXECUTION, 
1: 									IdUtil.mkQualifiedName(schemaName,sqlName),
1: 									dbcp_s);
1: 		}
1: 
1: 		try {
1: 		
1: 			notifyLoader(false);
1: 			dd.invalidateAllSPSPlans();
1: 			DependencyManager dm = dd.getDependencyManager();
1: 			dm.invalidateFor(fid, DependencyManager.DROP_JAR, lcc);
1: 
1: 			dd.dropFileInfoDescriptor(fid);
1: 
0: 			fr.remove(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),
0: 				fid.getGenerationId(), true /*purgeOnCommit*/);
1: 		} finally {
1: 			notifyLoader(true);
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Replace a jar file from the current connection's database with the content of an
1: 	  external file. 
1: 
1: 
0: 	  @param id The id for the jar file we add. Ignored if null.
1: 	  @param schemaName the name for the schema that holds the jar file.
1: 	  @param sqlName the sql name for the jar file.
1: 	  @param externalPath the path for the jar file to add.
0: 	  @param purgeOnCommit True means purge the old jar file on commit. False
0: 	    means leave it around for use by replication.
1: 	  @return The new generationId for the jar file we replace.
1: 
1: 	  @exception StandardException Opps
1: 	  */
0: 	static public long
0: 	replace(UUID id,String schemaName, String sqlName,
0: 			String externalPath,boolean purgeOnCommit)
1: 		 throws StandardException
1: 	{
0: 		JarUtil jutil = new JarUtil(id,schemaName,sqlName);
1: 		InputStream is = null;
1: 		
1: 
1: 		try {
0: 			is = FileUtil.getInputStream(externalPath, 0);
1: 
0: 			return jutil.replace(is,purgeOnCommit);
1: 		} catch (java.io.IOException fnfe) {
1: 			throw StandardException.newException(SQLState.SQLJ_INVALID_JAR, fnfe, externalPath);
1: 		}
1: 		finally {
1: 			try {if (is != null) is.close();}
1: 			catch (IOException ioe) {}
1: 		}
1: 	}
1: 
1: 	/**
1: 	  Replace a jar file in the current connection's database with the
1: 	  content of an external file.
1: 
1: 	  <P> The reason for adding the jar file in this private instance
1: 	  method is that it allows us to share set up logic with add and
1: 	  drop.
1: 	  @param is An input stream for reading the new content of the jar file.
0: 	  @param purgeOnCommit True means purge the old jar file on commit. False
0: 	    means leave it around for use by replication.
1: 	  @exception StandardException Opps
1: 	  */
0: 	public long replace(InputStream is,boolean purgeOnCommit) throws StandardException
1: 	{
1: 		//
1: 		//Like create table we say we are writing before we read the dd
1: 		dd.startWriting(lcc);
1: 
1: 		//
1: 		//Temporarily drop the FileInfoDescriptor from the data dictionary.
1: 		FileInfoDescriptor fid = getInfo();
1: 		if (fid == null)
1: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
1: 
0: 		if (SanityManager.DEBUG)
1: 		{
0: 			if (id != null && !fid.getUUID().equals(id))
1: 			{
0: 				SanityManager.THROWASSERT("Replace id mismatch want="+
0: 					id+" have "+fid.getUUID());
1: 			}
1: 		}
1: 
1: 		try {
1: 			// disable loads from this jar
1: 			notifyLoader(false);
1: 			dd.invalidateAllSPSPlans();
1: 			dd.dropFileInfoDescriptor(fid);
1: 
1: 			//
1: 			//Replace the file.
0: 			long generationId = 
0: 				fr.replace(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),
0: 					fid.getGenerationId(), is, purgeOnCommit);
1: 
1: 			//
1: 			//Re-add the descriptor to the data dictionary.
1: 			FileInfoDescriptor fid2 = 
1: 				ddg.newFileInfoDescriptor(fid.getUUID(),fid.getSchemaDescriptor(),
1: 								sqlName,generationId);
1: 			dd.addDescriptor(fid2, fid.getSchemaDescriptor(),
1: 							 DataDictionary.SYSFILES_CATALOG_NUM, false, lcc.getTransactionExecute());
1: 			return generationId;
1: 
1: 		} finally {
1: 
1: 			// reenable class loading from this jar
1: 			notifyLoader(true);
1: 		}
1: 	}
1: 
1: 	/**
0: 	  Get the FileInfoDescriptor for a jar file from the current connection's database or
0: 	  null if it does not exist.
1: 
1: 	  @param schemaName the name for the schema that holds the jar file.
1: 	  @param sqlName the sql name for the jar file.
0: 	  @return The FileInfoDescriptor.
1: 	  @exception StandardException Opps
1: 	  */
0: 	public static FileInfoDescriptor getInfo(String schemaName, String sqlName, String statementType)
1: 		 throws StandardException
1: 	{
0: 		JarUtil jUtil = new JarUtil(null,schemaName,sqlName);
0: 		return jUtil.getInfo();
1: 	}
1: 
1: 	/**
1: 	  Get the FileInfoDescriptor for the Jar file or null if it does not exist.
1: 	  @exception StandardException Ooops
1: 	  */
1: 	private FileInfoDescriptor getInfo()
1: 		 throws StandardException
1: 	{
1: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
1: 		return dd.getFileInfoDescriptor(sd,sqlName);
1: 	}
1: 
0: 	// get the current version of the jar file as a File or InputStream
0: 	public static Object getAsObject(String schemaName, String sqlName)
1: 		 throws StandardException
1: 	{
0: 		JarUtil jUtil = new JarUtil(null,schemaName,sqlName);
1: 
0: 		FileInfoDescriptor fid = jUtil.getInfo();
1: 		if (fid == null)
1: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
1: 
0: 		long generationId = fid.getGenerationId();
1: 
0: 		StorageFile f = jUtil.getAsFile(generationId);
0: 		if (f != null)
0: 			return f;
1: 
0: 		return jUtil.getAsStream(generationId);
1: 	}
1: 
0: 	private StorageFile getAsFile(long generationId) {
0: 		return fr.getAsFile(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()), generationId);
1: 	}
1: 
0: 	public static InputStream getAsStream(String schemaName, String sqlName,
0: 		long generationId) throws StandardException {
0: 		JarUtil jUtil = new JarUtil(null,schemaName,sqlName);
1: 
0: 		return jUtil.getAsStream(generationId);		
1: 	}
1: 
0: 	private InputStream getAsStream(long generationId) throws StandardException {
1: 		try {
0: 			return fr.getAsStream(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()), generationId);
0: 		} catch (IOException ioe) {
0: 			throw StandardException.newException(SQLState.LANG_FILE_ERROR, ioe.toString(),ioe);	
1: 		}
1: 	}
1: 
1: 	private void notifyLoader(boolean reload) throws StandardException {
1: 		ClassFactory cf = lcc.getLanguageConnectionFactory().getClassFactory();
1: 		cf.notifyModifyJar(reload);
1: 	}
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:911b189
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:f6123ee
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:75fb1cf
/////////////////////////////////////////////////////////////////////////
0:             throw StandardException.newException(SQLState.LANG_FILE_ERROR, ioe, ioe.toString());    
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.sql.execute
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.sql.execute;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.iapi.util.IdUtil;
0: import org.apache.derby.impl.sql.execute.JarDDL;
0: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.loader.ClassFactory;
0: import org.apache.derby.iapi.services.context.ContextService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.FileInfoDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
0: 
0: import org.apache.derby.iapi.sql.depend.DependencyManager;
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.store.access.FileResource;
0: import org.apache.derby.catalog.UUID;
0: import org.apache.derby.iapi.services.io.FileUtil;
0: import org.apache.derby.io.StorageFile;
0: 
0: import java.io.IOException;
0: import java.io.InputStream;
0: import java.sql.CallableStatement;
0: import java.sql.Connection;
0: import java.sql.SQLException;
0: 
0: public class JarUtil
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	public static final String ADD_JAR_DDL = "ADD JAR";
0: 	public static final String DROP_JAR_DDL = "DROP JAR";
0: 	public static final String REPLACE_JAR_DDL = "REPLACE JAR";
0: 	public static final String READ_JAR = "READ JAR";
0: 	//
0: 	//State passed in by the caller
0: 	private UUID id; //For add null means create a new id.
0: 	private String schemaName;
0: 	private String sqlName;
0: 
0: 	//Derived state
0: 	private LanguageConnectionContext lcc;
0: 	private FileResource fr;
0: 	private DataDictionary dd;
0: 	private DataDescriptorGenerator ddg;
0: 	
0: 	//
0: 	//State derived from the caller's context
0: 	public JarUtil(UUID id, String schemaName, String sqlName)
0: 		 throws StandardException
0: 	{
0: 		this.id = id;
0: 		this.schemaName = schemaName;
0: 		this.sqlName = sqlName;
0: 
0:         lcc = (LanguageConnectionContext)
0: 			ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0: 		fr = lcc.getTransactionExecute().getFileHandler();
0: 		dd = lcc.getDataDictionary();
0: 		ddg = dd.getDataDescriptorGenerator();
0: 	}
0: 
0: 	/**
0: 	  Add a jar file to the current connection's database.
0: 
0: 	  @param id The id for the jar file we add. If null this makes up a new id.
0: 	  @param schemaName the name for the schema that holds the jar file.
0: 	  @param sqlName the sql name for the jar file.
0: 	  @param externalPath the path for the jar file to add.
0: 	  @return The generationId for the jar file we add.
0: 
0: 	  @exception StandardException Opps
0: 	  */
0: 	static public long
0: 	add(UUID id, String schemaName, String sqlName, String externalPath)
0: 		 throws StandardException
0: 	{
0: 		JarUtil jutil = new JarUtil(id, schemaName, sqlName);
0: 		InputStream is = null;
0: 		
0: 		try {
0: 			is = FileUtil.getInputStream(externalPath, 0);
0: 			return jutil.add(is);
0: 		} catch (java.io.IOException fnfe) {
0: 			throw StandardException.newException(SQLState.SQLJ_INVALID_JAR, fnfe, externalPath);
0: 		}
0: 		finally {
0: 			try {if (is != null) is.close();}
0: 			catch (IOException ioe) {}
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Add a jar file to the current connection's database.
0: 
0: 	  <P> The reason for adding the jar file in this private instance
0: 	  method is that it allows us to share set up logic with drop and
0: 	  replace.
0: 	  @param is A stream for reading the content of the file to add.
0: 	  @exception StandardException Opps
0: 	  */
0: 	public long add(InputStream is) throws StandardException
0: 	{
0: 		//
0: 		//Like create table we say we are writing before we read the dd
0: 		dd.startWriting(lcc);
0: 		FileInfoDescriptor fid = getInfo();
0: 		if (fid != null)
0: 			throw
0: 				StandardException.newException(SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT, 
0: 											   fid.getDescriptorType(), sqlName, fid.getSchemaDescriptor().getDescriptorType(), schemaName);
0: 
0: 		try {
0: 			notifyLoader(false);
0: 			dd.invalidateAllSPSPlans();
0: 			long generationId = fr.add(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),is);
0: 
0: 			SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
0: 
0: 			fid = ddg.newFileInfoDescriptor(id, sd,
0: 							sqlName, generationId);
0: 			dd.addDescriptor(fid, sd, DataDictionary.SYSFILES_CATALOG_NUM,
0: 							 false, lcc.getTransactionExecute());
0: 			return generationId;
0: 		} finally {
0: 			notifyLoader(true);
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Drop a jar file from the current connection's database.
0: 
0: 	  @param id The id for the jar file we drop. Ignored if null.
0: 	  @param schemaName the name for the schema that holds the jar file.
0: 	  @param sqlName the sql name for the jar file.
0: 	  @param purgeOnCommit True means purge the old jar file on commit. False
0: 	    means leave it around for use by replication.
0: 
0: 	  @exception StandardException Opps
0: 	  */
0: 	static public void
0: 	drop(UUID id, String schemaName, String sqlName,boolean purgeOnCommit)
0: 		 throws StandardException
0: 	{
0: 		JarUtil jutil = new JarUtil(id, schemaName,sqlName);
0: 		jutil.drop(purgeOnCommit);
0: 	}
0: 
0: 	/**
0: 	  Drop a jar file from the current connection's database.
0: 
0: 	  <P> The reason for dropping  the jar file in this private instance
0: 	  method is that it allows us to share set up logic with add and
0: 	  replace.
0: 	  @param purgeOnCommit True means purge the old jar file on commit. False
0: 	    means leave it around for use by replication.
0: 
0: 	  @exception StandardException Opps
0: 	  */
0: 	public void drop(boolean purgeOnCommit) throws StandardException
0: 	{
0: 		//
0: 		//Like create table we say we are writing before we read the dd
0: 		dd.startWriting(lcc);
0: 		FileInfoDescriptor fid = getInfo();
0: 		if (fid == null)
0: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (id != null && !fid.getUUID().equals(id))
0: 			{
0: 				SanityManager.THROWASSERT("Drop id mismatch want="+id+
0: 						" have "+fid.getUUID());
0: 			}
0: 		}
0: 
0: 		String dbcp_s = PropertyUtil.getServiceProperty(lcc.getTransactionExecute(),Property.DATABASE_CLASSPATH);
0: 		if (dbcp_s != null)
0: 		{
0: 			String[][]dbcp= IdUtil.parseDbClassPath(dbcp_s,
0:                                                             lcc.getIdentifierCasing() != lcc.ANTI_ANSI_CASING );
0: 			boolean found = false;
0: 			//
0: 			//Look for the jar we are dropping on our database classpath.
0: 			//We don't concern ourselves with 3 part names since they may
0: 			//refer to a jar file in another database and may not occur in
0: 			//a database classpath that is stored in the propert congomerate.
0: 			for (int ix=0;ix<dbcp.length;ix++)
0: 				if (dbcp.length == 2 &&
0: 					dbcp[ix][0].equals(schemaName) && dbcp[ix][1].equals(sqlName))
0: 					found = true;
0: 			if (found)
0: 				throw StandardException.newException(SQLState.LANG_CANT_DROP_JAR_ON_DB_CLASS_PATH_DURING_EXECUTION, 
0: 									IdUtil.mkQualifiedName(schemaName,sqlName),
0: 									dbcp_s);
0: 		}
0: 
0: 		try {
0: 		
0: 			notifyLoader(false);
0: 			dd.invalidateAllSPSPlans();
0: 			DependencyManager dm = dd.getDependencyManager();
0: 			dm.invalidateFor(fid, DependencyManager.DROP_JAR, lcc);
0: 
0: 			dd.dropFileInfoDescriptor(fid);
0: 
0: 			fr.remove(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),
0: 				fid.getGenerationId(), true /*purgeOnCommit*/);
0: 		} finally {
0: 			notifyLoader(true);
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Replace a jar file from the current connection's database with the content of an
0: 	  external file. 
0: 
0: 
0: 	  @param id The id for the jar file we add. Ignored if null.
0: 	  @param schemaName the name for the schema that holds the jar file.
0: 	  @param sqlName the sql name for the jar file.
0: 	  @param externalPath the path for the jar file to add.
0: 	  @param purgeOnCommit True means purge the old jar file on commit. False
0: 	    means leave it around for use by replication.
0: 	  @return The new generationId for the jar file we replace.
0: 
0: 	  @exception StandardException Opps
0: 	  */
0: 	static public long
0: 	replace(UUID id,String schemaName, String sqlName,
0: 			String externalPath,boolean purgeOnCommit)
0: 		 throws StandardException
0: 	{
0: 		JarUtil jutil = new JarUtil(id,schemaName,sqlName);
0: 		InputStream is = null;
0: 		
0: 
0: 		try {
0: 			is = FileUtil.getInputStream(externalPath, 0);
0: 
0: 			return jutil.replace(is,purgeOnCommit);
0: 		} catch (java.io.IOException fnfe) {
0: 			throw StandardException.newException(SQLState.SQLJ_INVALID_JAR, fnfe, externalPath);
0: 		}
0: 		finally {
0: 			try {if (is != null) is.close();}
0: 			catch (IOException ioe) {}
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Replace a jar file in the current connection's database with the
0: 	  content of an external file.
0: 
0: 	  <P> The reason for adding the jar file in this private instance
0: 	  method is that it allows us to share set up logic with add and
0: 	  drop.
0: 	  @param is An input stream for reading the new content of the jar file.
0: 	  @param purgeOnCommit True means purge the old jar file on commit. False
0: 	    means leave it around for use by replication.
0: 	  @exception StandardException Opps
0: 	  */
0: 	public long replace(InputStream is,boolean purgeOnCommit) throws StandardException
0: 	{
0: 		//
0: 		//Like create table we say we are writing before we read the dd
0: 		dd.startWriting(lcc);
0: 
0: 		//
0: 		//Temporarily drop the FileInfoDescriptor from the data dictionary.
0: 		FileInfoDescriptor fid = getInfo();
0: 		if (fid == null)
0: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
0: 
0: 		if (SanityManager.DEBUG)
0: 		{
0: 			if (id != null && !fid.getUUID().equals(id))
0: 			{
0: 				SanityManager.THROWASSERT("Replace id mismatch want="+
0: 					id+" have "+fid.getUUID());
0: 			}
0: 		}
0: 
0: 		try {
0: 			// disable loads from this jar
0: 			notifyLoader(false);
0: 			dd.invalidateAllSPSPlans();
0: 			dd.dropFileInfoDescriptor(fid);
0: 
0: 			//
0: 			//Replace the file.
0: 			long generationId = 
0: 				fr.replace(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),
0: 					fid.getGenerationId(), is, purgeOnCommit);
0: 
0: 			//
0: 			//Re-add the descriptor to the data dictionary.
0: 			FileInfoDescriptor fid2 = 
0: 				ddg.newFileInfoDescriptor(fid.getUUID(),fid.getSchemaDescriptor(),
0: 								sqlName,generationId);
0: 			dd.addDescriptor(fid2, fid.getSchemaDescriptor(),
0: 							 DataDictionary.SYSFILES_CATALOG_NUM, false, lcc.getTransactionExecute());
0: 			return generationId;
0: 
0: 		} finally {
0: 
0: 			// reenable class loading from this jar
0: 			notifyLoader(true);
0: 		}
0: 	}
0: 
0: 	/**
0: 	  Get the FileInfoDescriptor for a jar file from the current connection's database or
0: 	  null if it does not exist.
0: 
0: 	  @param schemaName the name for the schema that holds the jar file.
0: 	  @param sqlName the sql name for the jar file.
0: 	  @return The FileInfoDescriptor.
0: 	  @exception StandardException Opps
0: 	  */
0: 	public static FileInfoDescriptor getInfo(String schemaName, String sqlName, String statementType)
0: 		 throws StandardException
0: 	{
0: 		JarUtil jUtil = new JarUtil(null,schemaName,sqlName);
0: 		return jUtil.getInfo();
0: 	}
0: 
0: 	/**
0: 	  Get the FileInfoDescriptor for the Jar file or null if it does not exist.
0: 	  @exception StandardException Ooops
0: 	  */
0: 	private FileInfoDescriptor getInfo()
0: 		 throws StandardException
0: 	{
0: 		SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
0: 		return dd.getFileInfoDescriptor(sd,sqlName);
0: 	}
0: 
0: 	// get the current version of the jar file as a File or InputStream
0: 	public static Object getAsObject(String schemaName, String sqlName)
0: 		 throws StandardException
0: 	{
0: 		JarUtil jUtil = new JarUtil(null,schemaName,sqlName);
0: 
0: 		FileInfoDescriptor fid = jUtil.getInfo();
0: 		if (fid == null)
0: 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
0: 
0: 		long generationId = fid.getGenerationId();
0: 
0: 		StorageFile f = jUtil.getAsFile(generationId);
0: 		if (f != null)
0: 			return f;
0: 
0: 		return jUtil.getAsStream(generationId);
0: 	}
0: 
0: 	private StorageFile getAsFile(long generationId) {
0: 		return fr.getAsFile(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()), generationId);
0: 	}
0: 
0: 	public static InputStream getAsStream(String schemaName, String sqlName,
0: 		long generationId) throws StandardException {
0: 		JarUtil jUtil = new JarUtil(null,schemaName,sqlName);
0: 
0: 		return jUtil.getAsStream(generationId);		
0: 	}
0: 
0: 	private InputStream getAsStream(long generationId) throws StandardException {
0: 		try {
0: 			return fr.getAsStream(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()), generationId);
0: 		} catch (IOException ioe) {
0: 			throw StandardException.newException(SQLState.LANG_FILE_ERROR, ioe.toString(),ioe);	
0: 		}
0: 	}
0: 
0: 	private void notifyLoader(boolean reload) throws StandardException {
0: 		ClassFactory cf = lcc.getLanguageConnectionFactory().getClassFactory();
0: 		cf.notifyModifyJar(reload);
0: 	}
0: }
============================================================================