1:f3c6217: /*
2:f3c6217: 
1:a37ea51:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.UDAPermsTestz
1:f3c6217: 
1:f3c6217:    Licensed to the Apache Software Foundation (ASF) under one or more
1:f3c6217:    contributor license agreements.  See the NOTICE file distributed with
1:f3c6217:    this work for additional information regarding copyright ownership.
1:f3c6217:    The ASF licenses this file to you under the Apache License, Version 2.0
1:f3c6217:    (the "License"); you may not use this file except in compliance with
1:f3c6217:    the License.  You may obtain a copy of the License at
1:f3c6217: 
1:f3c6217:      http://www.apache.org/licenses/LICENSE-2.0
1:f3c6217: 
1:f3c6217:    Unless required by applicable law or agreed to in writing, software
1:f3c6217:    distributed under the License is distributed on an "AS IS" BASIS,
1:f3c6217:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f3c6217:    See the License for the specific language governing permissions and
1:f3c6217:    limitations under the License.
1:f3c6217: 
1:f3c6217:  */
1:f3c6217: 
1:f3c6217: package org.apache.derbyTesting.functionTests.tests.lang;
1:f3c6217: 
1:f3c6217: import java.sql.Connection;
1:f3c6217: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:f3c6217: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:f3c6217: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:f3c6217: import org.apache.derbyTesting.junit.TestConfiguration;
1:f3c6217: 
1:f3c6217: /**
1:f3c6217:  * <p>
1:f3c6217:  * Test permissions on user-defined aggregates. See DERBY-672.
1:f3c6217:  * </p>
1:f3c6217:  */
1:f3c6217: public class UDAPermsTest extends GeneratedColumnsHelper
1:f3c6217: {
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217:     //
1:f3c6217:     // CONSTANTS
1:f3c6217:     //
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217: 
1:f3c6217:     private static  final   String      TEST_DBO = "TEST_DBO";
1:f3c6217:     private static  final   String      RUTH = "RUTH";
1:f3c6217:     private static  final   String      ALICE = "ALICE";
1:f3c6217:     private static  final   String      FRANK = "FRANK";
1:fbf52ee:     private static  final   String      TONY = "TONY";
1:fbf52ee:     private static  final   String[]    LEGAL_USERS = { TEST_DBO, ALICE, RUTH, FRANK, TONY  };
1:fbf52ee: 
1:fbf52ee:     private static  final   String      MISSING_ROUTINE = "42Y03";
1:2782d72:     private static  final   String      IMPLICIT_CAST_ERROR = "42Y22";
1:a37ea51:     private static  final   String      PARSE_ERROR = "42X01";
1:a37ea51:     private static  final   String      BAD_DISTINCT = "42XAS";
1:f3c6217: 
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217:     //
1:f3c6217:     // STATE
1:f3c6217:     //
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217: 
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217:     //
1:f3c6217:     // CONSTRUCTOR
1:f3c6217:     //
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217: 
1:f3c6217:     /**
1:f3c6217:      * Create a new instance.
1:f3c6217:      */
1:f3c6217: 
1:f3c6217:     public UDAPermsTest(String name)
1:f3c6217:     {
1:f3c6217:         super(name);
1:f3c6217:     }
1:f3c6217: 
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217:     //
1:f3c6217:     // JUnit BEHAVIOR
1:f3c6217:     //
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217: 
1:f3c6217: 
1:f3c6217:     /**
1:f3c6217:      * Construct top level suite in this JUnit test
1:f3c6217:      */
1:f3c6217:     public static Test suite()
1:f3c6217:     {
1:1ae02c9:         BaseTestSuite suite = (BaseTestSuite)TestConfiguration.embeddedSuite(
1:1ae02c9:             UDAPermsTest.class);
1:f3c6217: 
1:f3c6217:         Test        cleanTest = new CleanDatabaseTestSetup( suite );
1:f3c6217:         Test        authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
1:f3c6217:             ( cleanTest, LEGAL_USERS, "udaPermissions" );
1:f3c6217:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecorator( authenticatedTest );
1:f3c6217: 
1:f3c6217:         return authorizedTest;
1:f3c6217:     }
1:f3c6217: 
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217:     //
1:f3c6217:     // TESTS
1:f3c6217:     //
1:f3c6217:     ///////////////////////////////////////////////////////////////////////////////////
1:f3c6217: 
1:f3c6217:     /**
1:f3c6217:      * <p>
1:f3c6217:      * Test that you need USAGE privilege on an aggregate in order to invoke it.
1:f3c6217:      * and in order to declare objects which mention that type.
1:f3c6217:      * </p>
1:f3c6217:      */
1:f3c6217:     public  void    test_001_basicGrant()
1:f3c6217:         throws Exception
1:f3c6217:     {
1:f3c6217:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:f3c6217:         Connection  ruthConnection = openUserConnection( RUTH );
1:f3c6217:         Connection  aliceConnection = openUserConnection( ALICE );
1:f3c6217: 
1:f3c6217:         //
1:f3c6217:         // Create an aggregate and table.
1:f3c6217:         //
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              "create derby aggregate mode_01 for int\n" +
1:f3c6217:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.ModeAggregate'\n"
1:f3c6217:              );
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              "create table mode_inputs_01( a int, b int )\n"
1:f3c6217:              );
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              "insert into mode_inputs_01( a, b ) values ( 1, 1 ), ( 1, 2 ), ( 1, 2 ), ( 1, 2 ), ( 2, 3 ), ( 2, 3 ), ( 2, 4 )\n"
1:f3c6217:              );
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              "grant select on mode_inputs_01 to public\n"
1:f3c6217:              );
1:f3c6217: 
1:f3c6217:         expectExecutionError
1:f3c6217:             (
1:f3c6217:              aliceConnection,
1:f3c6217:              LACK_USAGE_PRIV,
1:f3c6217:              "select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a\n"
1:f3c6217:              );
1:f3c6217:         expectExecutionError
1:f3c6217:             (
1:f3c6217:              aliceConnection,
1:f3c6217:              LACK_USAGE_PRIV,
1:f3c6217:              "create view v_alice_01( a, modeOfA ) as select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a\n"
1:f3c6217:              );
1:f3c6217: 
1:f3c6217:         //
1:f3c6217:         // The DBO however is almighty.
1:f3c6217:         //
1:f3c6217:         assertResults
1:f3c6217:             (
1:f3c6217:              dboConnection,
1:f3c6217:              "select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a",
1:f3c6217:              new String[][]
1:f3c6217:              {
1:f3c6217:                  { "1", "2" },
1:f3c6217:                  { "2", "3" },
1:f3c6217:              },
1:f3c6217:              false
1:f3c6217:              );
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              dboConnection,
1:f3c6217:              "create view v_dbo_01( a, modeOfA ) as select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a\n"
1:f3c6217:              );
1:f3c6217:         assertResults
1:f3c6217:             (
1:f3c6217:              dboConnection,
1:f3c6217:              "select * from v_dbo_01",
1:f3c6217:              new String[][]
1:f3c6217:              {
1:f3c6217:                  { "1", "2" },
1:f3c6217:                  { "2", "3" },
1:f3c6217:              },
1:f3c6217:              false
1:f3c6217:              );
1:f3c6217: 
1:f3c6217:         //
1:f3c6217:         // Now grant USAGE on the user-defined aggregate. User Alice should now have all the
1:f3c6217:         // privileges she needs.
1:f3c6217:         //
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              "grant usage on derby aggregate mode_01 to public\n"
1:f3c6217:              );
1:f3c6217:         
1:f3c6217:         assertResults
1:f3c6217:             (
1:f3c6217:              aliceConnection,
1:f3c6217:              "select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a",
1:f3c6217:              new String[][]
1:f3c6217:              {
1:f3c6217:                  { "1", "2" },
1:f3c6217:                  { "2", "3" },
1:f3c6217:              },
1:f3c6217:              false
1:f3c6217:              );
1:f3c6217: 
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              aliceConnection,
1:f3c6217:              "create view v_alice_01( a, modeOfA ) as select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a\n"
1:f3c6217:              );
1:f3c6217:         assertResults
1:f3c6217:             (
1:f3c6217:              aliceConnection,
1:f3c6217:              "select * from v_alice_01",
1:f3c6217:              new String[][]
1:f3c6217:              {
1:f3c6217:                  { "1", "2" },
1:f3c6217:                  { "2", "3" },
1:f3c6217:              },
1:f3c6217:              false
1:f3c6217:              );
1:f3c6217: 
1:f3c6217:     }
1:f3c6217:     
1:fbf52ee:    /**
1:fbf52ee:      * <p>
1:f3c6217:      * Test that USAGE privilege can't be revoked if it would make objects
1:f3c6217:      * unusable by their owners.
1:f3c6217:      * </p>
1:f3c6217:      */
1:f3c6217:     public  void    test_002_basicRevoke()
1:f3c6217:         throws Exception
1:f3c6217:     {
1:f3c6217:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:f3c6217:         Connection  ruthConnection = openUserConnection( RUTH );
1:f3c6217:         Connection  aliceConnection = openUserConnection( ALICE );
1:f3c6217: 
1:f3c6217:         //
1:f3c6217:         // Create an aggregate and table.
1:f3c6217:         //
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              "create derby aggregate mode_02 for int\n" +
1:f3c6217:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.ModeAggregate'\n"
1:f3c6217:              );
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              "create table mode_inputs_02( a int, b int )\n"
1:f3c6217:              );
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              "grant select on mode_inputs_02 to public\n"
1:f3c6217:              );
1:f3c6217:         goodStatement
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              "insert into mode_inputs_02( a, b ) values ( 1, 1 ), ( 1, 2 ), ( 1, 2 ), ( 1, 2 ), ( 2, 3 ), ( 2, 3 ), ( 2, 4 )\n"
1:f3c6217:              );
1:f3c6217: 
1:f3c6217:         // only RESTRICTed revocations allowed
1:f3c6217:         expectCompilationError( ruthConnection, SYNTAX_ERROR, "revoke usage on derby aggregate mode_02 from ruth\n" );
1:f3c6217: 
1:f3c6217:         // can't revoke USAGE from owner
1:f3c6217:         expectCompilationError
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              GRANT_REVOKE_NOT_ALLOWED,
1:f3c6217:              "revoke usage on derby aggregate mode_02 from ruth restrict\n"
1:f3c6217:              );
1:f3c6217: 
1:f3c6217:         String grantUsage = "grant usage on derby aggregate mode_02 to alice\n";
1:f3c6217:         String revokeUsage = "revoke usage on derby aggregate mode_02 from alice restrict\n";
1:f3c6217:         String createStatement;
1:f3c6217:         String dropStatement;
1:f3c6217:         String badRevokeSQLState;
1:f3c6217:         
1:f3c6217:         // can't revoke USAGE if a view depends on it
1:f3c6217:         createStatement =
1:f3c6217:              "create view v_alice_02( a, modeOfA ) as select a, ruth.mode_02( b ) from ruth.mode_inputs_02 group by a"
1:f3c6217:             ;
1:f3c6217:         dropStatement = "drop view v_alice_02\n";
1:f3c6217:         badRevokeSQLState = VIEW_DEPENDENCY;
1:f3c6217:         verifyRevokePrivilege
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              aliceConnection,
1:f3c6217:              grantUsage,
1:f3c6217:              revokeUsage,
1:f3c6217:              createStatement,
1:f3c6217:              dropStatement,
1:f3c6217:              badRevokeSQLState
1:f3c6217:              );
1:f3c6217: 
1:f3c6217:         // can't revoke USAGE if a trigger depends on it
1:f3c6217:         goodStatement( aliceConnection, "create table t_source_02( a int )\n" );
1:f3c6217:         goodStatement( aliceConnection, "create table t_target_02( a int )\n" );
1:f3c6217:         createStatement =
1:f3c6217:             "create trigger t_insert_trigger_02\n" +
1:f3c6217:             "after insert on t_source_02\n" +
1:f3c6217:             "for each row\n" +
1:f3c6217:             "insert into t_target_02( a ) select ruth.mode_02( b ) from ruth.mode_inputs_02\n";
1:f3c6217:         dropStatement = "drop trigger t_insert_trigger_02\n";
1:f3c6217:         badRevokeSQLState = OPERATION_FORBIDDEN;
1:f3c6217:         verifyRevokePrivilege
1:f3c6217:             (
1:f3c6217:              ruthConnection,
1:f3c6217:              aliceConnection,
1:f3c6217:              grantUsage,
1:f3c6217:              revokeUsage,
1:f3c6217:              createStatement,
1:f3c6217:              dropStatement,
1:f3c6217:              badRevokeSQLState
1:f3c6217:              );
1:f3c6217:     }
1:f3c6217:     
1:aad6057:    /**
1:aad6057:      * <p>
1:aad6057:      * Test that you need USAGE privilege on user-defined types in order to use them in
1:aad6057:      * user-defined aggregates.
1:aad6057:      * </p>
1:aad6057:      */
1:aad6057:     public  void    test_003_typePrivs()
1:aad6057:         throws Exception
1:aad6057:     {
1:aad6057:         Connection  ruthConnection = openUserConnection( RUTH );
1:aad6057:         Connection  aliceConnection = openUserConnection( ALICE );
1:aad6057: 
1:aad6057:         // can't revoke USAGE on a type if an aggregate's input/return depends on it
1:aad6057:         goodStatement
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:aad6057:              );
1:aad6057: 
1:aad6057:         String grantUsage = "grant usage on type Price to public";
1:aad6057:         String revokeUsage = "revoke usage on type Price from public restrict";
1:aad6057:         String createStatement =
1:aad6057:             "create derby aggregate priceMode for ruth.Price\n" +
1:aad6057:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.GenericMode'\n";
1:aad6057:         String dropStatement = "drop derby aggregate priceMode restrict";
1:aad6057:         String badRevokeSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:aad6057: 
1:aad6057:         verifyRevokePrivilege
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              aliceConnection,
1:aad6057:              grantUsage,
1:aad6057:              revokeUsage,
1:aad6057:              createStatement,
1:aad6057:              dropStatement,
1:aad6057:              badRevokeSQLState
1:aad6057:              );
1:aad6057:         
1:aad6057:         // can't revoke USAGE on a type if an aggregate's input depends on it
1:aad6057:         goodStatement
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              "create type Price_input external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:aad6057:              );
1:aad6057:         goodStatement
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              "create type Price_return external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:aad6057:              );
1:aad6057:         goodStatement
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              "grant usage on type Price_return to public"
1:aad6057:              );
1:aad6057: 
1:aad6057:         grantUsage = "grant usage on type Price_input to public";
1:aad6057:         revokeUsage = "revoke usage on type Price_input from public restrict";
1:aad6057:         createStatement =
1:aad6057:             "create derby aggregate priceMode for ruth.Price_input returns ruth.Price_return\n" +
1:aad6057:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.GenericMode'\n";
1:aad6057:         dropStatement = "drop derby aggregate priceMode restrict";
1:aad6057:         badRevokeSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:aad6057:         
1:aad6057:         verifyRevokePrivilege
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              aliceConnection,
1:aad6057:              grantUsage,
1:aad6057:              revokeUsage,
1:aad6057:              createStatement,
1:aad6057:              dropStatement,
1:aad6057:              badRevokeSQLState
1:aad6057:              );
1:aad6057:         
1:aad6057:         // can't revoke USAGE on a type if an aggregate's return value depends on it
1:aad6057:         goodStatement
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              "create type Price_input_2 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:aad6057:              );
1:aad6057:         goodStatement
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              "create type Price_return_2 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:aad6057:              );
1:aad6057:         goodStatement
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              "grant usage on type Price_input_2 to public"
1:aad6057:              );
1:aad6057: 
1:aad6057:         grantUsage = "grant usage on type Price_return_2 to public";
1:aad6057:         revokeUsage = "revoke usage on type Price_return_2 from public restrict";
1:aad6057:         createStatement =
1:aad6057:             "create derby aggregate priceMode for ruth.Price_input_2 returns ruth.Price_return_2\n" +
1:aad6057:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.GenericMode'\n";
1:aad6057:         dropStatement = "drop derby aggregate priceMode restrict";
1:aad6057:         badRevokeSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:aad6057:         
1:aad6057:         verifyRevokePrivilege
1:aad6057:             (
1:aad6057:              ruthConnection,
1:aad6057:              aliceConnection,
1:aad6057:              grantUsage,
1:aad6057:              revokeUsage,
1:aad6057:              createStatement,
1:aad6057:              dropStatement,
1:aad6057:              badRevokeSQLState
1:aad6057:              );
1:aad6057:     }
1:aad6057:     
1:f3c6217:    /**
1:f3c6217:      * <p>
1:fbf52ee:      * Test that we fixed an NPE in resolving function names when the
1:fbf52ee:      * schema hasn't been created yet.
1:fbf52ee:      * </p>
1:fbf52ee:      */
1:fbf52ee:     public  void    test_004_emptySchema()
1:fbf52ee:         throws Exception
1:fbf52ee:     {
1:fbf52ee:         Connection  tonyConnection = openUserConnection( TONY );
1:fbf52ee: 
1:fbf52ee:         expectCompilationError( tonyConnection, MISSING_ROUTINE, "values toString( 100 )" );
1:fbf52ee:     }
1:fbf52ee: 
1:2782d72:    /**
1:2782d72:      * <p>
1:2782d72:      * Test that anyone can run the modern, builtin system aggregates
1:2782d72:      * which implement org.apache.derby.agg.Aggregator.
1:2782d72:      * </p>
1:2782d72:      */
1:2782d72:     public  void    test_005_builtinAggregators()
1:2782d72:         throws Exception
1:2782d72:     {
1:2782d72:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:2782d72:         Connection  ruthConnection = openUserConnection( RUTH );
1:2782d72: 
1:2782d72:         createSchema_005( ruthConnection );
1:2782d72: 
1:2782d72:         vetStatsBuiltins_005( dboConnection );
1:2782d72:         vetStatsBuiltins_005( ruthConnection );
1:2782d72:         
1:2782d72:         dropSchema_005( ruthConnection );
1:2782d72:     }
1:2782d72:     private void vetStatsBuiltins_005( Connection conn )
1:2782d72:         throws Exception
1:2782d72:     {
1:2782d72:         vetBuiltinAgg_005
1:2782d72:             (
1:2782d72:              conn,
1:2782d72:              "var_pop",
1:2782d72:              new String[][] { { "8.079999999999991" } },
1:2782d72:              new String[][] { { "8.0" } }
1:2782d72:              );
1:2782d72:         vetBuiltinAgg_005
1:2782d72:             (
1:2782d72:              conn,
1:2782d72:              "var_samp",
1:2782d72:              new String[][] { { "10.099999999999994" } },
1:2782d72:              new String[][] { { "10.0" } }
1:2782d72:              );
1:2782d72:         vetBuiltinAgg_005
1:2782d72:             (
1:2782d72:              conn,
1:2782d72:              "stddev_pop",
1:2782d72:              new String[][] { { "2.8425340807103776" } },
1:2782d72:              new String[][] { { "2.8284271247461903" } }
1:2782d72:              );
1:2782d72:         vetBuiltinAgg_005
1:2782d72:             (
1:2782d72:              conn,
1:2782d72:              "stddev_samp",
1:2782d72:              new String[][] { { "3.1780497164141397" } },
1:2782d72:              new String[][] { { "3.1622776601683795" } }
1:2782d72:              );
1:2782d72:     }
1:2782d72:     private void vetBuiltinAgg_005
1:2782d72:         (
1:2782d72:          Connection conn,
1:2782d72:          String aggName,
1:2782d72:          String[][] expectedInexactResults,
1:2782d72:          String[][] expectedExactResults
1:2782d72:          )
1:2782d72:         throws Exception
1:2782d72:     {
1:2782d72:         vetBuiltinAgg_005( conn, aggName, "doubles", expectedInexactResults );
1:2782d72:         vetBuiltinAgg_005( conn, aggName, "floats", expectedInexactResults );
1:2782d72:         vetBuiltinAgg_005( conn, aggName, "bigints", expectedExactResults );
1:2782d72:         vetBuiltinAgg_005( conn, aggName, "ints", expectedExactResults );
1:2782d72:         vetBuiltinAgg_005( conn, aggName, "smallints", expectedExactResults );
1:2782d72:         vetBuiltinNegative_005( conn, aggName );
1:2782d72:     }
1:2782d72:     private void vetBuiltinAgg_005
1:2782d72:         (
1:2782d72:          Connection conn,
1:2782d72:          String aggName,
1:2782d72:          String tableName,
1:2782d72:          String[][] expectedResults
1:2782d72:          )
1:2782d72:         throws Exception
1:2782d72:     {
1:2782d72:         assertResults
1:2782d72:             (
1:2782d72:              conn,
1:2782d72:              "select " + aggName + "( a ) from ruth." + tableName,
1:2782d72:              expectedResults,
1:2782d72:              false
1:2782d72:              );
1:2782d72:     }
1:2782d72:     private void vetBuiltinNegative_005
1:2782d72:         (
1:2782d72:          Connection conn,
1:2782d72:          String aggName
1:2782d72:          )
1:2782d72:         throws Exception
1:2782d72:     {
1:2782d72:         // varchar can not be implicitly cast to double
1:2782d72:         expectCompilationError( conn, IMPLICIT_CAST_ERROR,
1:2782d72:                                 "select " + aggName + "( a ) from ruth.varchars" );
1:2782d72: 
1:2782d72:         // cannot schema-qualify a builtin aggregate name
1:2782d72:         expectCompilationError( conn, MISSING_ROUTINE,
1:2782d72:                                 "select sys." + aggName + "( a ) from ruth.doubles" );
1:a37ea51: 
1:a37ea51:         // cannot use ALL or DISTINCT with a builtin aggregate
1:a37ea51:         expectCompilationError( conn, PARSE_ERROR,
1:a37ea51:                                 "select " + aggName + "( all a ) from ruth.doubles" );
1:a37ea51:         expectCompilationError( conn, BAD_DISTINCT,
1:a37ea51:                                 "select " + aggName + "( distinct a ) from ruth.doubles" );
1:2782d72:     }
1:2782d72:     private void createSchema_005( Connection ruthConnection )
1:2782d72:         throws Exception
1:2782d72:     {
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "create table doubles( a double )"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "insert into doubles values ( 1.2 ), ( 3.4 ), (5.6), (7.8), (9.0)"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "create table floats( a double )"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "insert into floats values ( 1.2 ), ( 3.4 ), (5.6), (7.8), (9.0)"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "create table bigints( a bigint )"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "insert into bigints values ( 1 ), ( 3 ), (5), (7), (9)"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "create table ints( a bigint )"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "insert into ints values ( 1 ), ( 3 ), (5), (7), (9)"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "create table smallints( a bigint )"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "insert into smallints values ( 1 ), ( 3 ), (5), (7), (9)"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "create table varchars( a varchar( 10 ) )"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "insert into varchars values ( '1' ), ( '3' ), ( '5' ), ( '7' ), ( '9' )"
1:2782d72:              );
1:2782d72:     }
1:2782d72:     private void dropSchema_005( Connection ruthConnection )
1:2782d72:         throws Exception
1:2782d72:     {
1:2782d72:         // drop schema
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "drop table varchars"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "drop table smallints"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "drop table ints"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "drop table bigints"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "drop table floats"
1:2782d72:              );
1:2782d72:         goodStatement
1:2782d72:             (
1:2782d72:              ruthConnection,
1:2782d72:              "drop table doubles"
1:2782d72:              );
1:2782d72:     }
1:f3c6217: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:a37ea51
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.UDAPermsTestz
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      PARSE_ERROR = "42X01";
1:     private static  final   String      BAD_DISTINCT = "42XAS";
/////////////////////////////////////////////////////////////////////////
1: 
1:         // cannot use ALL or DISTINCT with a builtin aggregate
1:         expectCompilationError( conn, PARSE_ERROR,
1:                                 "select " + aggName + "( all a ) from ruth.doubles" );
1:         expectCompilationError( conn, BAD_DISTINCT,
1:                                 "select " + aggName + "( distinct a ) from ruth.doubles" );
commit:2782d72
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      IMPLICIT_CAST_ERROR = "42Y22";
/////////////////////////////////////////////////////////////////////////
1:    /**
1:      * <p>
1:      * Test that anyone can run the modern, builtin system aggregates
1:      * which implement org.apache.derby.agg.Aggregator.
1:      * </p>
1:      */
1:     public  void    test_005_builtinAggregators()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1: 
1:         createSchema_005( ruthConnection );
1: 
1:         vetStatsBuiltins_005( dboConnection );
1:         vetStatsBuiltins_005( ruthConnection );
1:         
1:         dropSchema_005( ruthConnection );
1:     }
1:     private void vetStatsBuiltins_005( Connection conn )
1:         throws Exception
1:     {
1:         vetBuiltinAgg_005
1:             (
1:              conn,
1:              "var_pop",
1:              new String[][] { { "8.079999999999991" } },
1:              new String[][] { { "8.0" } }
1:              );
1:         vetBuiltinAgg_005
1:             (
1:              conn,
1:              "var_samp",
1:              new String[][] { { "10.099999999999994" } },
1:              new String[][] { { "10.0" } }
1:              );
1:         vetBuiltinAgg_005
1:             (
1:              conn,
1:              "stddev_pop",
1:              new String[][] { { "2.8425340807103776" } },
1:              new String[][] { { "2.8284271247461903" } }
1:              );
1:         vetBuiltinAgg_005
1:             (
1:              conn,
1:              "stddev_samp",
1:              new String[][] { { "3.1780497164141397" } },
1:              new String[][] { { "3.1622776601683795" } }
1:              );
1:     }
1:     private void vetBuiltinAgg_005
1:         (
1:          Connection conn,
1:          String aggName,
1:          String[][] expectedInexactResults,
1:          String[][] expectedExactResults
1:          )
1:         throws Exception
1:     {
1:         vetBuiltinAgg_005( conn, aggName, "doubles", expectedInexactResults );
1:         vetBuiltinAgg_005( conn, aggName, "floats", expectedInexactResults );
1:         vetBuiltinAgg_005( conn, aggName, "bigints", expectedExactResults );
1:         vetBuiltinAgg_005( conn, aggName, "ints", expectedExactResults );
1:         vetBuiltinAgg_005( conn, aggName, "smallints", expectedExactResults );
1:         vetBuiltinNegative_005( conn, aggName );
1:     }
1:     private void vetBuiltinAgg_005
1:         (
1:          Connection conn,
1:          String aggName,
1:          String tableName,
1:          String[][] expectedResults
1:          )
1:         throws Exception
1:     {
1:         assertResults
1:             (
1:              conn,
1:              "select " + aggName + "( a ) from ruth." + tableName,
1:              expectedResults,
1:              false
1:              );
1:     }
1:     private void vetBuiltinNegative_005
1:         (
1:          Connection conn,
1:          String aggName
1:          )
1:         throws Exception
1:     {
1:         // varchar can not be implicitly cast to double
1:         expectCompilationError( conn, IMPLICIT_CAST_ERROR,
1:                                 "select " + aggName + "( a ) from ruth.varchars" );
1: 
1:         // cannot schema-qualify a builtin aggregate name
1:         expectCompilationError( conn, MISSING_ROUTINE,
1:                                 "select sys." + aggName + "( a ) from ruth.doubles" );
1:     }
1:     private void createSchema_005( Connection ruthConnection )
1:         throws Exception
1:     {
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create table doubles( a double )"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "insert into doubles values ( 1.2 ), ( 3.4 ), (5.6), (7.8), (9.0)"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create table floats( a double )"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "insert into floats values ( 1.2 ), ( 3.4 ), (5.6), (7.8), (9.0)"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create table bigints( a bigint )"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "insert into bigints values ( 1 ), ( 3 ), (5), (7), (9)"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create table ints( a bigint )"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "insert into ints values ( 1 ), ( 3 ), (5), (7), (9)"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create table smallints( a bigint )"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "insert into smallints values ( 1 ), ( 3 ), (5), (7), (9)"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create table varchars( a varchar( 10 ) )"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "insert into varchars values ( '1' ), ( '3' ), ( '5' ), ( '7' ), ( '9' )"
1:              );
1:     }
1:     private void dropSchema_005( Connection ruthConnection )
1:         throws Exception
1:     {
1:         // drop schema
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "drop table varchars"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "drop table smallints"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "drop table ints"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "drop table bigints"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "drop table floats"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "drop table doubles"
1:              );
1:     }
commit:fbf52ee
/////////////////////////////////////////////////////////////////////////
1:     private static  final   String      TONY = "TONY";
1:     private static  final   String[]    LEGAL_USERS = { TEST_DBO, ALICE, RUTH, FRANK, TONY  };
1: 
1:     private static  final   String      MISSING_ROUTINE = "42Y03";
/////////////////////////////////////////////////////////////////////////
1:    /**
1:      * <p>
1:      * Test that we fixed an NPE in resolving function names when the
1:      * schema hasn't been created yet.
1:      * </p>
1:      */
1:     public  void    test_004_emptySchema()
1:         throws Exception
1:     {
1:         Connection  tonyConnection = openUserConnection( TONY );
1: 
1:         expectCompilationError( tonyConnection, MISSING_ROUTINE, "values toString( 100 )" );
1:     }
1: 
commit:aad6057
/////////////////////////////////////////////////////////////////////////
1:    /**
1:      * <p>
1:      * Test that you need USAGE privilege on user-defined types in order to use them in
1:      * user-defined aggregates.
1:      * </p>
1:      */
1:     public  void    test_003_typePrivs()
1:         throws Exception
1:     {
1:         Connection  ruthConnection = openUserConnection( RUTH );
1:         Connection  aliceConnection = openUserConnection( ALICE );
1: 
1:         // can't revoke USAGE on a type if an aggregate's input/return depends on it
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:              );
1: 
1:         String grantUsage = "grant usage on type Price to public";
1:         String revokeUsage = "revoke usage on type Price from public restrict";
1:         String createStatement =
1:             "create derby aggregate priceMode for ruth.Price\n" +
1:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.GenericMode'\n";
1:         String dropStatement = "drop derby aggregate priceMode restrict";
1:         String badRevokeSQLState = ROUTINE_DEPENDS_ON_TYPE;
1: 
1:         verifyRevokePrivilege
1:             (
1:              ruthConnection,
1:              aliceConnection,
1:              grantUsage,
1:              revokeUsage,
1:              createStatement,
1:              dropStatement,
1:              badRevokeSQLState
1:              );
1:         
1:         // can't revoke USAGE on a type if an aggregate's input depends on it
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create type Price_input external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create type Price_return external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "grant usage on type Price_return to public"
1:              );
1: 
1:         grantUsage = "grant usage on type Price_input to public";
1:         revokeUsage = "revoke usage on type Price_input from public restrict";
1:         createStatement =
1:             "create derby aggregate priceMode for ruth.Price_input returns ruth.Price_return\n" +
1:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.GenericMode'\n";
1:         dropStatement = "drop derby aggregate priceMode restrict";
1:         badRevokeSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:         
1:         verifyRevokePrivilege
1:             (
1:              ruthConnection,
1:              aliceConnection,
1:              grantUsage,
1:              revokeUsage,
1:              createStatement,
1:              dropStatement,
1:              badRevokeSQLState
1:              );
1:         
1:         // can't revoke USAGE on a type if an aggregate's return value depends on it
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create type Price_input_2 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create type Price_return_2 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "grant usage on type Price_input_2 to public"
1:              );
1: 
1:         grantUsage = "grant usage on type Price_return_2 to public";
1:         revokeUsage = "revoke usage on type Price_return_2 from public restrict";
1:         createStatement =
1:             "create derby aggregate priceMode for ruth.Price_input_2 returns ruth.Price_return_2\n" +
1:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.GenericMode'\n";
1:         dropStatement = "drop derby aggregate priceMode restrict";
1:         badRevokeSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:         
1:         verifyRevokePrivilege
1:             (
1:              ruthConnection,
1:              aliceConnection,
1:              grantUsage,
1:              revokeUsage,
1:              createStatement,
1:              dropStatement,
1:              badRevokeSQLState
1:              );
1:     }
1:     
commit:f3c6217
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.UDAPermsTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
0: import java.sql.SQLException;
0: import java.sql.SQLWarning;
1: import java.sql.Connection;
0: import java.sql.Statement;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.DriverManager;
0: import java.util.ArrayList;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derby.iapi.util.StringUtil;
0: import org.apache.derby.catalog.DefaultInfo;
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
1: 
0: import org.apache.derby.catalog.types.RoutineAliasInfo;
1: 
1: /**
1:  * <p>
1:  * Test permissions on user-defined aggregates. See DERBY-672.
1:  * </p>
1:  */
1: public class UDAPermsTest extends GeneratedColumnsHelper
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String      TEST_DBO = "TEST_DBO";
1:     private static  final   String      RUTH = "RUTH";
1:     private static  final   String      ALICE = "ALICE";
1:     private static  final   String      FRANK = "FRANK";
0:     private static  final   String[]    LEGAL_USERS = { TEST_DBO, ALICE, RUTH, FRANK  };
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Create a new instance.
1:      */
1: 
1:     public UDAPermsTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = (TestSuite) TestConfiguration.embeddedSuite(UDAPermsTest.class);
1: 
1:         Test        cleanTest = new CleanDatabaseTestSetup( suite );
1:         Test        authenticatedTest = DatabasePropertyTestSetup.builtinAuthentication
1:             ( cleanTest, LEGAL_USERS, "udaPermissions" );
1:         Test        authorizedTest = TestConfiguration.sqlAuthorizationDecorator( authenticatedTest );
1: 
1:         return authorizedTest;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Test that you need USAGE privilege on an aggregate in order to invoke it.
1:      * and in order to declare objects which mention that type.
1:      * </p>
1:      */
1:     public  void    test_001_basicGrant()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1:         Connection  aliceConnection = openUserConnection( ALICE );
1: 
1:         //
1:         // Create an aggregate and table.
1:         //
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create derby aggregate mode_01 for int\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.ModeAggregate'\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create table mode_inputs_01( a int, b int )\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "insert into mode_inputs_01( a, b ) values ( 1, 1 ), ( 1, 2 ), ( 1, 2 ), ( 1, 2 ), ( 2, 3 ), ( 2, 3 ), ( 2, 4 )\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "grant select on mode_inputs_01 to public\n"
1:              );
1: 
1:         expectExecutionError
1:             (
1:              aliceConnection,
1:              LACK_USAGE_PRIV,
1:              "select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a\n"
1:              );
1:         expectExecutionError
1:             (
1:              aliceConnection,
1:              LACK_USAGE_PRIV,
1:              "create view v_alice_01( a, modeOfA ) as select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a\n"
1:              );
1: 
1:         //
1:         // The DBO however is almighty.
1:         //
1:         assertResults
1:             (
1:              dboConnection,
1:              "select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a",
1:              new String[][]
1:              {
1:                  { "1", "2" },
1:                  { "2", "3" },
1:              },
1:              false
1:              );
1:         goodStatement
1:             (
1:              dboConnection,
1:              "create view v_dbo_01( a, modeOfA ) as select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a\n"
1:              );
1:         assertResults
1:             (
1:              dboConnection,
1:              "select * from v_dbo_01",
1:              new String[][]
1:              {
1:                  { "1", "2" },
1:                  { "2", "3" },
1:              },
1:              false
1:              );
1: 
1:         //
1:         // Now grant USAGE on the user-defined aggregate. User Alice should now have all the
1:         // privileges she needs.
1:         //
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "grant usage on derby aggregate mode_01 to public\n"
1:              );
1:         
1:         assertResults
1:             (
1:              aliceConnection,
1:              "select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a",
1:              new String[][]
1:              {
1:                  { "1", "2" },
1:                  { "2", "3" },
1:              },
1:              false
1:              );
1: 
1:         goodStatement
1:             (
1:              aliceConnection,
1:              "create view v_alice_01( a, modeOfA ) as select a, ruth.mode_01( b ) from ruth.mode_inputs_01 group by a\n"
1:              );
1:         assertResults
1:             (
1:              aliceConnection,
1:              "select * from v_alice_01",
1:              new String[][]
1:              {
1:                  { "1", "2" },
1:                  { "2", "3" },
1:              },
1:              false
1:              );
1: 
1:     }
1:     
1:    /**
1:      * <p>
1:      * Test that USAGE privilege can't be revoked if it would make objects
1:      * unusable by their owners.
1:      * </p>
1:      */
1:     public  void    test_002_basicRevoke()
1:         throws Exception
1:     {
1:         Connection  dboConnection = openUserConnection( TEST_DBO );
1:         Connection  ruthConnection = openUserConnection( RUTH );
1:         Connection  aliceConnection = openUserConnection( ALICE );
1: 
1:         //
1:         // Create an aggregate and table.
1:         //
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create derby aggregate mode_02 for int\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.ModeAggregate'\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "create table mode_inputs_02( a int, b int )\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "grant select on mode_inputs_02 to public\n"
1:              );
1:         goodStatement
1:             (
1:              ruthConnection,
1:              "insert into mode_inputs_02( a, b ) values ( 1, 1 ), ( 1, 2 ), ( 1, 2 ), ( 1, 2 ), ( 2, 3 ), ( 2, 3 ), ( 2, 4 )\n"
1:              );
1: 
1:         // only RESTRICTed revocations allowed
1:         expectCompilationError( ruthConnection, SYNTAX_ERROR, "revoke usage on derby aggregate mode_02 from ruth\n" );
1: 
1:         // can't revoke USAGE from owner
1:         expectCompilationError
1:             (
1:              ruthConnection,
1:              GRANT_REVOKE_NOT_ALLOWED,
1:              "revoke usage on derby aggregate mode_02 from ruth restrict\n"
1:              );
1: 
1:         String grantUsage = "grant usage on derby aggregate mode_02 to alice\n";
1:         String revokeUsage = "revoke usage on derby aggregate mode_02 from alice restrict\n";
1:         String createStatement;
1:         String dropStatement;
1:         String badRevokeSQLState;
1:         
1:         // can't revoke USAGE if a view depends on it
1:         createStatement =
1:              "create view v_alice_02( a, modeOfA ) as select a, ruth.mode_02( b ) from ruth.mode_inputs_02 group by a"
1:             ;
1:         dropStatement = "drop view v_alice_02\n";
1:         badRevokeSQLState = VIEW_DEPENDENCY;
1:         verifyRevokePrivilege
1:             (
1:              ruthConnection,
1:              aliceConnection,
1:              grantUsage,
1:              revokeUsage,
1:              createStatement,
1:              dropStatement,
1:              badRevokeSQLState
1:              );
1: 
1:         // can't revoke USAGE if a trigger depends on it
1:         goodStatement( aliceConnection, "create table t_source_02( a int )\n" );
1:         goodStatement( aliceConnection, "create table t_target_02( a int )\n" );
1:         createStatement =
1:             "create trigger t_insert_trigger_02\n" +
1:             "after insert on t_source_02\n" +
1:             "for each row\n" +
1:             "insert into t_target_02( a ) select ruth.mode_02( b ) from ruth.mode_inputs_02\n";
1:         dropStatement = "drop trigger t_insert_trigger_02\n";
1:         badRevokeSQLState = OPERATION_FORBIDDEN;
1:         verifyRevokePrivilege
1:             (
1:              ruthConnection,
1:              aliceConnection,
1:              grantUsage,
1:              revokeUsage,
1:              createStatement,
1:              dropStatement,
1:              badRevokeSQLState
1:              );
1:     }
1:     
1: }
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = (BaseTestSuite)TestConfiguration.embeddedSuite(
1:             UDAPermsTest.class);
============================================================================