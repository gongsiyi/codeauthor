1:33776ff: /*
1:1451af7: 
1:33776ff:    Derby - Class org.apache.derby.client.net.Request
1:1451af7: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:1451af7: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:018948a: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:41674ac: 
1:33776ff: */
1:33776ff: package org.apache.derby.client.net;
1:41674ac: 
1:bead0ab: import org.apache.derby.client.am.DateTime;
1:c1d0340: import org.apache.derby.client.am.DateTimeValue;
1:f6e1e6f: import org.apache.derby.client.am.Decimal;
1:33776ff: import org.apache.derby.client.am.DisconnectException;
1:e65b4db: import org.apache.derby.client.am.ClientMessageId;
1:70f7692: import org.apache.derby.client.am.SqlException;
1:6eb9730: import org.apache.derby.shared.common.reference.SQLState;
1:506f4c8: import org.apache.derby.shared.common.sanity.SanityManager;
1:506f4c8: import org.apache.derby.iapi.reference.DRDAConstants;
1:6eb9730: 
1:fefd864: import java.io.BufferedInputStream;
1:3f3312e: import java.io.IOException;
1:69e3d06: import java.io.InputStream;
1:506f4c8: import java.io.ObjectOutputStream;
1:69e3d06: import java.io.OutputStream;
1:69e3d06: import java.io.Reader;
1:69e3d06: import java.math.BigDecimal;
1:f6e1e6f: import java.nio.ByteBuffer;
1:018948a: import java.nio.CharBuffer;
1:a0b8943: import java.nio.charset.Charset;
1:69e3d06: import java.util.Hashtable;
1:93ded62: import org.apache.derby.shared.common.error.ExceptionUtil;
1:fefd864: 
1:0326967: class Request {
1:41674ac: 
1:70f7692:     // byte array buffer used for constructing requests.
1:70f7692:     // currently requests are built starting at the beginning of the buffer.
1:f6e1e6f:     protected ByteBuffer buffer;
1:41674ac: 
1:70f7692:     // a stack is used to keep track of offsets into the buffer where 2 byte
1:70f7692:     // ddm length values are located.  these length bytes will be automatically updated
1:70f7692:     // by this object when construction of a particular object has completed.
1:70f7692:     // right now the max size of the stack is 10. this is an arbitrary number which
1:70f7692:     // should be sufficiently large enough to handle all situations.
1:70f7692:     private final static int MAX_MARKS_NESTING = 10;
1:70f7692:     private int[] markStack_ = new int[MAX_MARKS_NESTING];
1:70f7692:     private int top_ = 0;
1:41674ac: 
1:70f7692:     //  This Object tracks the location of the current
1:70f7692:     //  Dss header length bytes.  This is done so
1:70f7692:     //  the length bytes can be automatically
1:70f7692:     //  updated as information is added to this stream.
1:70f7692:     private int dssLengthLocation_ = 0;
1:a1a1192: 
1:70f7692:     // tracks the request correlation ID to use for commands and command objects.
1:70f7692:     // this is automatically updated as commands are built and sent to the server.
1:70f7692:     private int correlationID_ = 0;
1:6a925a3: 
1:70f7692:     private boolean simpleDssFinalize = false;
1:6a925a3: 
1:70f7692:     // Used to mask out password when trace is on.
1:70f7692:     protected boolean passwordIncluded_ = false;
1:70f7692:     protected int passwordStart_ = 0;
1:70f7692:     protected int passwordLength_ = 0;
1:6a925a3: 
1:70f7692:     protected NetAgent netAgent_;
1:6a925a3: 
86:70f7692: 
1:70f7692:     // construct a request object specifying the minimum buffer size
1:70f7692:     // to be used to buffer up the built requests.  also specify the ccsid manager
1:70f7692:     // instance to be used when building ddm character data.
1:1451af7:     Request(NetAgent netAgent, int minSize) {
1:70f7692:         netAgent_ = netAgent;
1:f6e1e6f:         buffer = ByteBuffer.allocate(minSize);
1:70f7692:         clearBuffer();
1:506f4c8:     }
1:cf5cebf: 
1:0326967:     private final void clearBuffer() {
1:f6e1e6f:         buffer.clear();
1:70f7692:         top_ = 0;
1:70f7692:         for (int i = 0; i < markStack_.length; i++) {
1:70f7692:             if (markStack_[i] != 0) {
1:70f7692:                 markStack_[i] = 0;
1:41674ac:             } else {
1:70f7692:                 break;
1:cf5cebf:             }
73:70f7692:         }
1:70f7692:         dssLengthLocation_ = 0;
1:70f7692:     }
1:fefd864: 
1:70f7692:     final void initialize() {
1:70f7692:         clearBuffer();
1:70f7692:         correlationID_ = 0;
1:70f7692:     }
1:fefd864: 
1:70f7692:     // ensure length at the end of the buffer for a certain amount of data.
1:70f7692:     // if the buffer does not contain sufficient room for the data, the buffer
1:70f7692:     // will be expanded by the larger of (2 * current size) or (current size + length).
1:70f7692:     // the data from the previous buffer is copied into the larger buffer.
1:0326967:     private final void ensureLength(int length) {
1:f6e1e6f:         if (length > buffer.remaining()) {
1:f6e1e6f:             int newLength =
1:f6e1e6f:                 Math.max(buffer.capacity() * 2, buffer.position() + length);
1:f6e1e6f:             // copy the old buffer into a new one
1:f6e1e6f:             buffer.flip();
1:f6e1e6f:             buffer = ByteBuffer.allocate(newLength).put(buffer);
1:70f7692:         }
1:70f7692:     }
1:fefd864: 
2:70f7692:     // creates an request dss in the buffer to contain a ddm command
2:70f7692:     // object.  calling this method means any previous dss objects in
2:70f7692:     // the buffer are complete and their length and chaining bytes can
2:70f7692:     // be updated appropriately.
1:70f7692:     protected final void createCommand() {
1:70f7692:         buildDss(false, false, false, DssConstants.GDSFMT_RQSDSS, ++correlationID_, false);
1:70f7692:     }
1:fefd864: 
1:70f7692:     // creates an object dss in the buffer to contain a ddm command
1:70f7692:     // data object.  calling this method means any previous dss objects in
1:70f7692:     // the buffer are complete and their length and chaining bytes can
1:70f7692:     // be updated appropriately.
1:70f7692:     final void createCommandData() {
1:70f7692:         buildDss(true,
3:33776ff:                 false,
1:33776ff:                 false,
3:33776ff:                 DssConstants.GDSFMT_OBJDSS,
4:33776ff:                 correlationID_,
2:33776ff:                 false);
1:fefd864:     }
1:fefd864: 
1:70f7692:     final void createEncryptedCommandData() {
1:41674ac:         if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
1:41674ac:                 netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA) {
1:70f7692:             buildDss(true, false, false, DssConstants.GDSFMT_ENCOBJDSS, correlationID_, false);
1:fefd864:         } else {
1:70f7692:             buildDss(true,
1:70f7692:                     false,
1:70f7692:                     false,
1:70f7692:                     DssConstants.GDSFMT_OBJDSS,
1:70f7692:                     correlationID_,
1:70f7692:                     false);
1:41674ac:         }
1:41674ac:     }
1:fefd864: 
1:fefd864: 
1:70f7692:     // experimental lob section
1:41674ac: 
1:70f7692:     private final void buildDss(boolean dssHasSameCorrelator,
1:70f7692:                                 boolean chainedToNextStructure,
1:70f7692:                                 boolean nextHasSameCorrelator,
1:70f7692:                                 int dssType,
1:70f7692:                                 int corrId,
1:70f7692:                                 boolean simpleFinalizeBuildingNextDss) {
1:70f7692:         if (doesRequestContainData()) {
1:70f7692:             if (simpleDssFinalize) {
1:70f7692:                 finalizeDssLength();
1:41674ac:             } else {
1:70f7692:                 finalizePreviousChainedDss(dssHasSameCorrelator);
1:41674ac:             }
1:70f7692:         }
1:41674ac: 
1:f1567ea:         // RQSDSS header is 6 bytes long: (ll)(Cf)(rc)
1:f6e1e6f:         ensureLength(6);
1:41674ac: 
1:f1567ea:         // Save the position of the length bytes, so they can be updated with a
1:f1567ea:         // different value at a later time.
1:f6e1e6f:         dssLengthLocation_ = buffer.position();
1:f1567ea:         // Dummy values for the DSS length (token ll above).
1:f1567ea:         // The correct length will be inserted when the DSS is finalized.
1:f6e1e6f:         buffer.putShort((short) 0xFFFF);
1:41674ac: 
1:f1567ea:         // Insert the mandatory 0xD0 (token C).
1:f6e1e6f:         buffer.put((byte) 0xD0);
1:f6e1e6f: 
1:f1567ea:         // Insert the dssType (token f), which also tells if the DSS is chained
1:f1567ea:         // or not. See DSSFMT in the DRDA specification for details.
1:70f7692:         if (chainedToNextStructure) {
1:70f7692:             dssType |= DssConstants.GDSCHAIN;
1:70f7692:             if (nextHasSameCorrelator) {
1:70f7692:                 dssType |= DssConstants.GDSCHAIN_SAME_ID;
1:70f7692:             }
1:70f7692:         }
1:f6e1e6f:         buffer.put((byte) dssType);
1:41674ac: 
1:f1567ea:         // Write the request correlation id (two bytes, token rc).
1:70f7692:         // use method that writes a short
1:f6e1e6f:         buffer.putShort((short) corrId);
1:41674ac: 
1:70f7692:         simpleDssFinalize = simpleFinalizeBuildingNextDss;
1:41674ac:     }
1:6eb29f6:     
1:fefd864:     
1:fefd864:     final void writeScalarStream(boolean chained,
1:fefd864:                                  boolean chainedWithSameCorrelator,
1:fefd864:                                  int codePoint,
1:69e3d06:                                  InputStream in,
1:fefd864:                                  boolean writeNullByte,
1:fefd864:                                  int parameterIndex) throws DisconnectException, SqlException {
1:fefd864:         
1:fefd864:         writePlainScalarStream(chained,
1:fefd864:                                chainedWithSameCorrelator,
1:fefd864:                                codePoint,
1:fefd864:                                in,
1:fefd864:                                writeNullByte,
1:fefd864:                                parameterIndex);
1:6eb29f6:         
1:6eb29f6:     }
1:fefd864:     
1:fefd864:     
1:6eb29f6:     final void writeScalarStream(boolean chained,
1:fefd864:                                  boolean chainedWithSameCorrelator,
1:fefd864:                                  int codePoint,
1:3f3312e:                                  long length,
1:69e3d06:                                  InputStream in,
1:fefd864:                                  boolean writeNullByte,
1:8f0a531:                                  int parameterIndex) throws DisconnectException, SqlException {
1:3f3312e: 
1:6eb29f6:         if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
1:6eb29f6:             netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA) {
1:ccfada3:             // DERBY-4706
1:ccfada3:             // The network server doesn't support the security mechanisms above.
1:ccfada3:             // Further, the code in writeEncryptedScalarStream is/was in a bad
1:ccfada3:             // state.
1:ccfada3:             // Throw an exception for now until we're positive the code can be
1:ccfada3:             // ditched, later this comment/code itself can also be removed.
1:6eb9730:             throw new SqlException(netAgent_.logWriter_,
1:ccfada3:                     new ClientMessageId(SQLState.NOT_IMPLEMENTED),
1:ccfada3:                     "encrypted scalar streams");
1:018948a: 
1:6eb29f6:         }else{
1:6eb29f6:             
1:6eb29f6:             writePlainScalarStream(chained,
1:6eb29f6:                                    chainedWithSameCorrelator,
1:6eb29f6:                                    codePoint,
1:6eb29f6:                                    length,
1:6eb29f6:                                    in,
1:6eb29f6:                                    writeNullByte,
1:6eb29f6:                                    parameterIndex);
1:6eb29f6:             
1:6eb29f6:         }
1:fefd864: 
1:6eb29f6:     }
1:fefd864:     
1:ffe112b:     /**
1:cf5cebf:      * Writes a stream with a known length onto the wire.
1:cf5cebf:      * <p>
1:cf5cebf:      * To avoid DRDA protocol exceptions, the data is truncated or padded as
1:cf5cebf:      * required to complete the transfer. This can be avoided by implementing
1:cf5cebf:      * the request abort mechanism specified by DRDA, but it is rather complex
1:cf5cebf:      * and may not be worth the trouble.
1:cf5cebf:      * <p>
1:cf5cebf:      * Also note that any exceptions generated while writing the stream will
1:cf5cebf:      * be accumulated and raised at a later time.
1:cf5cebf:      *
1:cf5cebf:      * @param length the byte length of the stream
1:cf5cebf:      * @param in the stream to transfer
1:cf5cebf:      * @param writeNullByte whether or not to write a NULL indicator
1:cf5cebf:      * @param parameterIndex one-based parameter index
1:cf5cebf:      * @throws DisconnectException if a severe error condition is encountered,
1:cf5cebf:      *      causing the connection to be broken
1:cf5cebf:      */
1:6eb29f6:     final private void writePlainScalarStream(boolean chained,
1:fefd864:                                               boolean chainedWithSameCorrelator,
1:fefd864:                                               int codePoint,
1:3f3312e:                                               long length,
1:69e3d06:                                               InputStream in,
1:fefd864:                                               boolean writeNullByte,
1:fefd864:                                               int parameterIndex) throws DisconnectException, SqlException {
1:cf5cebf:         // We don't have the metadata available when we create this request
1:cf5cebf:         // object, so we have to check here if we are going to write the status
1:cf5cebf:         // byte or not.
1:cf5cebf:         final boolean writeEXTDTAStatusByte =
1:cf5cebf:                 netAgent_.netConnection_.serverSupportsEXTDTAAbort();
1:cf5cebf: 
1:cf5cebf:         // If the Derby specific status byte is sent, the number of bytes to
1:cf5cebf:         // send differs from the number of bytes to read (off by one byte).
1:3f3312e:         long leftToRead = length;
1:3f3312e:         long bytesToSend = writeEXTDTAStatusByte ? leftToRead + 1 : leftToRead;
1:6eb29f6:         int extendedLengthByteCount = prepScalarStream(chained,
1:6eb29f6:                                                        chainedWithSameCorrelator,
1:6eb29f6:                                                        writeNullByte,
1:cf5cebf:                                                        bytesToSend);
1:3f3312e:         int nullIndicatorSize = writeNullByte ? 1 : 0;
1:3f3312e:         int dssMaxDataLength = DssConstants.MAX_DSS_LEN - 6 - 4 -
1:3f3312e:                 nullIndicatorSize - extendedLengthByteCount;
1:3f3312e:         int bytesToRead = (int)Math.min(bytesToSend, dssMaxDataLength);
1:cf5cebf: 
1:cf5cebf:         // If we are sending the status byte and we can send the user value as
1:cf5cebf:         // one DSS, correct for the status byte (otherwise we read one byte too
1:cf5cebf:         // much from the stream).
1:cf5cebf:         if (writeEXTDTAStatusByte && bytesToRead == bytesToSend) {
1:cf5cebf:             bytesToRead--;
1:6eb9730:         }
1:cf5cebf: 
1:6eb29f6:         buildLengthAndCodePointForLob(codePoint,
1:cf5cebf:                                       bytesToSend,
1:6eb29f6:                                       writeNullByte,
1:6eb29f6:                                       extendedLengthByteCount);
1:cf5cebf:         byte status = DRDAConstants.STREAM_OK;
1:6eb29f6:         int bytesRead = 0;
1:6eb29f6:         do {
1:6eb29f6:             do {
1:6eb29f6:                 try {
1:6eb29f6:                     bytesRead =
1:f6e1e6f:                         in.read(buffer.array(), buffer.position(), bytesToRead);
1:b862050:                 } catch (IOException ioe) {
1:b862050:                     if (netAgent_.getOutputStream() == null) {
1:b862050:                         // The exception has taken down the connection, so we 
1:b862050:                         // check if it was caused by attempting to 
1:b862050:                         // read the stream from our own connection...
1:b862050:                         for (Throwable t = ioe; t != null; t = t.getCause()) {
1:b862050:                             if (t instanceof SqlException
1:b862050:                                     && ((SqlException) t).getSQLState().equals(ExceptionUtil.getSQLStateFromIdentifier(SQLState.NET_WRITE_CHAIN_IS_DIRTY))) {
1:6eb9730:                                 throw new SqlException(netAgent_.logWriter_,
1:b862050:                                         new ClientMessageId(SQLState.NET_LOCATOR_STREAM_PARAMS_NOT_SUPPORTED),
1:b862050:                                         ioe, parameterIndex);
1:b862050:                             }
1:b862050:                         }
1:b862050:                         // Something else has killed the connection, fast forward to despair...
2:b862050:                         throw new SqlException(netAgent_.logWriter_,
1:b862050:                                 new ClientMessageId(SQLState.NET_DISCONNECT_EXCEPTION_ON_READ),
1:b862050:                                 ioe, parameterIndex, ioe.getMessage());
1:b862050:                     }
1:b862050:                     // The OutPutStream is still intact so try to finish request
1:b862050:                     // with what we managed to read
1:b862050: 
1:cf5cebf:                     status = DRDAConstants.STREAM_READ_ERROR;
1:cf5cebf:                     padScalarStreamForError(leftToRead, bytesToRead,
1:cf5cebf:                             writeEXTDTAStatusByte, status);
1:6eb29f6:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
1:66527ec:                     netAgent_.accumulateReadException(
1:b862050:                             new SqlException(
1:66527ec:                             netAgent_.logWriter_,
1:66527ec:                             new ClientMessageId(SQLState.NET_EXCEPTION_ON_READ),
1:b862050:                             ioe, parameterIndex, ioe.getMessage()));
1:fefd864: 
1:6eb29f6:                     return;
1:6eb29f6:                 }
1:6eb29f6:                 if (bytesRead == -1) {
1:cf5cebf:                     status = DRDAConstants.STREAM_TOO_SHORT;
1:cf5cebf:                     padScalarStreamForError(leftToRead, bytesToRead,
1:cf5cebf:                             writeEXTDTAStatusByte, status);
1:6eb29f6:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
1:66527ec:                     netAgent_.accumulateReadException(
1:66527ec:                         new SqlException(netAgent_.logWriter_,
1:66527ec:                             new ClientMessageId(SQLState.NET_PREMATURE_EOS),
1:66527ec:                             parameterIndex));
1:6eb29f6:                     return;
1:6eb29f6:                 } else {
1:6eb29f6:                     bytesToRead -= bytesRead;
1:f6e1e6f:                     buffer.position(buffer.position() + bytesRead);
1:6eb29f6:                     leftToRead -= bytesRead;
1:6eb29f6:                 }
1:6eb29f6:             } while (bytesToRead > 0);
1:fefd864: 
1:6eb29f6:             bytesToRead = flushScalarStreamSegment(leftToRead, bytesToRead);
1:6eb29f6:         } while (leftToRead > 0);
1:cf5cebf: 
1:6eb29f6:         // check to make sure that the specified length wasn't too small
1:6eb29f6:         try {
1:6eb29f6:             if (in.read() != -1) {
1:cf5cebf:                 status = DRDAConstants.STREAM_TOO_LONG;
1:6eb29f6:                 // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
1:66527ec:                 netAgent_.accumulateReadException(new SqlException(
1:66527ec:                         netAgent_.logWriter_,
1:66527ec:                         new ClientMessageId(
1:66527ec:                             SQLState.NET_INPUTSTREAM_LENGTH_TOO_SMALL),
1:66527ec:                         parameterIndex));
1:6eb29f6:             }
1:6eb29f6:         } catch (Exception e) {
1:cf5cebf:             status = DRDAConstants.STREAM_READ_ERROR;
1:66527ec:             netAgent_.accumulateReadException(new SqlException(
1:66527ec:                     netAgent_.logWriter_,
1:66527ec:                     new ClientMessageId(
1:66527ec:                         SQLState.NET_EXCEPTION_ON_STREAMLEN_VERIFICATION),
1:e1a79c3:                     e, parameterIndex, e.getMessage()));
1:6eb29f6:         }
1:cf5cebf:         // Write the status byte to the send buffer.
1:cf5cebf:         if (writeEXTDTAStatusByte) {
1:cf5cebf:             writeEXTDTAStatus(status);
1:6eb29f6:         }
1:cf5cebf:     }
1:cf5cebf: 
1:fefd864: 
1:fefd864: 
1:53795a1:     /**
1:cf5cebf:      * Writes a stream with unknown length onto the wire.
1:cf5cebf:      * <p>
1:cf5cebf:      * To avoid DRDA protocol exceptions, the data is truncated or padded as
1:cf5cebf:      * required to complete the transfer. This can be avoided by implementing
1:cf5cebf:      * the request abort mechanism specified by DRDA, but it is rather complex
1:cf5cebf:      * and may not be worth the trouble.
1:cf5cebf:      * <p>
1:cf5cebf:      * Also note that any exceptions generated while writing the stream will
1:cf5cebf:      * be accumulated and raised at a later time.
1:cf5cebf:      * <p>
1:cf5cebf:      * <em>Implementation note:</em> This method does not support sending
1:cf5cebf:      * values with a specified length using layer B streaming and at the same
1:cf5cebf:      * time applying length checking. For large values layer B streaming may be
1:cf5cebf:      * more efficient than using layer A streaming.
1:cf5cebf:      *
1:cf5cebf:      * @param in the stream to transfer
1:cf5cebf:      * @param writeNullByte whether or not to write a NULL indicator
1:cf5cebf:      * @param parameterIndex one-based parameter index
1:cf5cebf:      * @throws DisconnectException if a severe error condition is encountered,
1:cf5cebf:      *      causing the connection to be broken
1:cf5cebf:      */
1:6eb29f6:     final private void writePlainScalarStream(boolean chained,
1:8f0a531:                                               boolean chainedWithSameCorrelator,
1:8f0a531:                                               int codePoint,
1:69e3d06:                                               InputStream in,
1:41674ac:                                               boolean writeNullByte,
1:cf5cebf:                                               int parameterIndex)
1:cf5cebf:             throws DisconnectException {
1:6eb29f6:         
1:cf5cebf:         // We don't have the metadata available when we create this request
1:cf5cebf:         // object, so we have to check here if we are going to write the status
1:cf5cebf:         // byte or not.
1:cf5cebf:         final boolean writeEXTDTAStatusByte =
1:cf5cebf:                 netAgent_.netConnection_.serverSupportsEXTDTAAbort();
1:cf5cebf: 
1:fefd864:         in = new BufferedInputStream( in );
1:fefd864: 
1:fefd864:         flushExistingDSS();
1:6eb29f6:         
1:f6e1e6f:         ensureLength(DssConstants.MAX_DSS_LEN - buffer.position());
1:fefd864:         
1:fefd864:         buildDss(true,
1:fefd864:                  chained,
1:fefd864:                  chainedWithSameCorrelator,
1:fefd864:                  DssConstants.GDSFMT_OBJDSS,
1:fefd864:                  correlationID_,
1:fefd864:                  true);
1:fefd864:         
1:fefd864:         int spareInDss;
1:fefd864:         
1:6eb29f6:         if (writeNullByte) {
1:6eb29f6:             spareInDss = DssConstants.MAX_DSS_LEN - 6 - 4 - 1;
1:6eb29f6:         } else {
1:6eb29f6:             spareInDss = DssConstants.MAX_DSS_LEN - 6 - 4;
1:6eb29f6:         }
1:6eb29f6:                 
1:6eb29f6:         buildLengthAndCodePointForLob(codePoint,
1:6eb29f6:                                       writeNullByte);
1:fefd864:         
2:6eb9730:         try{
1:fefd864:             
1:fefd864:             int bytesRead = 0;
1:fefd864:             
1:fefd864:             while( ( bytesRead = 
1:f6e1e6f:                      in.read(buffer.array(), buffer.position(), spareInDss)
1:fefd864:                      ) > -1 ) {
1:fefd864:                 
1:fefd864:                 spareInDss -= bytesRead;
1:f6e1e6f:                 buffer.position(buffer.position() + bytesRead);
1:fefd864: 
1:fefd864:                 if( spareInDss <= 0 ){
1:fefd864:                     
1:fefd864:                     if( ! peekStream( (  BufferedInputStream ) in ) )
1:fefd864:                         break;
1:fefd864:                     
1:fefd864:                     flushScalarStreamSegment();
1:f6e1e6f: 
1:f6e1e6f:                     buffer.putShort((short) 0xFFFF);
1:fefd864:                     
1:fefd864:                     spareInDss = DssConstants.MAX_DSS_LEN - 2;
1:fefd864:                     
1:fefd864:                 }
1:fefd864:                 
1:fefd864:             }
1:6eb29f6:         } catch (Exception e) {
1:cf5cebf:             if (writeEXTDTAStatusByte) {
1:cf5cebf:                 writeEXTDTAStatus(DRDAConstants.STREAM_READ_ERROR);
1:cf5cebf:             }
2:fefd864:             final SqlException sqlex = 
2:fefd864:                 new SqlException(netAgent_.logWriter_,
1:419a664:                                  new ClientMessageId(SQLState.NET_EXCEPTION_ON_READ),
1:e1a79c3:                                  e, parameterIndex, e.getMessage());
1:fefd864: 
2:fefd864:             netAgent_.accumulateReadException(sqlex);
1:fefd864:             
1:6eb29f6:                     return;
1:fefd864:         }
1:fefd864: 
1:cf5cebf:         if (writeEXTDTAStatusByte) {
1:cf5cebf:             writeEXTDTAStatus(DRDAConstants.STREAM_OK);
1:6eb29f6:         }
1:cf5cebf:     }
1:fefd864: 
1:fefd864: 
1:70f7692:     // Throw DataTruncation, instead of closing connection if input size mismatches
1:70f7692:     // An implication of this, is that we need to extend the chaining model
1:70f7692:     // for writes to accomodate chained write exceptoins
1:fefd864:     final void writeScalarStream(boolean chained,
1:8f0a531:                                  boolean chainedWithSameCorrelator,
1:8f0a531:                                  int codePoint,
1:8f0a531:                                  int length,
1:69e3d06:                                  Reader r,
1:8f0a531:                                  boolean writeNullByte,
1:fefd864:                                  int parameterIndex) throws DisconnectException, 
1:956354d:                                                             SqlException{
1:3f3312e: 
1:956354d:         writeScalarStream(chained,
1:956354d:                           chainedWithSameCorrelator,
1:956354d:                           codePoint,
1:3f3312e:                           length * 2L,
1:956354d:                           EncodedInputStream.createUTF16BEStream(r),
1:956354d:                           writeNullByte,
1:956354d:                           parameterIndex);
1:fefd864:     }
1:fefd864:     
1:fefd864:     
1:41674ac:     final void writeScalarStream(boolean chained,
1:41674ac:                                  boolean chainedWithSameCorrelator,
2:41674ac:                                  int codePoint,
1:69e3d06:                                  Reader r,
1:8f0a531:                                  boolean writeNullByte,
1:a1a1192:                                  int parameterIndex) throws DisconnectException, 
1:fefd864:                                                             SqlException{
1:fefd864:         writeScalarStream(chained,
1:fefd864:                           chainedWithSameCorrelator,
1:fefd864:                           codePoint,
1:fefd864:                           EncodedInputStream.createUTF16BEStream(r),
1:fefd864:                           writeNullByte,
1:fefd864:                           parameterIndex);
1:fefd864:     }
1:fefd864:     
1:fefd864:     
1:70f7692:     // prepScalarStream does the following prep for writing stream data:
1:70f7692:     // 1.  Flushes an existing DSS segment, if necessary
1:70f7692:     // 2.  Determines if extended length bytes are needed
1:70f7692:     // 3.  Creates a new DSS/DDM header and a null byte indicator, if applicable
1:0326967:     private final int prepScalarStream(boolean chained,
1:41674ac:                                          boolean chainedWithSameCorrelator,
1:41674ac:                                          boolean writeNullByte,
1:3f3312e:                                          long leftToRead)
1:3f3312e:             throws DisconnectException {
1:3f3312e:         int nullIndicatorSize = writeNullByte ? 1 : 0;
1:3f3312e:         int extendedLengthByteCount = calculateExtendedLengthByteCount(
1:3f3312e:                     leftToRead + 4 + nullIndicatorSize);
1:fefd864: 
1:70f7692:         // flush the existing DSS segment if this stream will not fit in the send buffer
1:3f3312e:         if ((10 + extendedLengthByteCount + nullIndicatorSize +
1:f6e1e6f:                 leftToRead + buffer.position()) > DssConstants.MAX_DSS_LEN) {
1:fefd864:             try {
1:70f7692:                 if (simpleDssFinalize) {
1:70f7692:                     finalizeDssLength();
1:41674ac:                 } else {
1:70f7692:                     finalizePreviousChainedDss(true);
1:fefd864:                 }
1:41674ac:                 sendBytes(netAgent_.getOutputStream());
1:69e3d06:             } catch (IOException e) {
1:1b39163:                 netAgent_.throwCommunicationsFailure(e);
1:fefd864:             }
1:fefd864:         }
1:fefd864: 
3:70f7692:         if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
3:70f7692:                 netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA) {
1:70f7692:             buildDss(true,
1:70f7692:                     chained,
3:41674ac:                     chainedWithSameCorrelator,
1:70f7692:                     DssConstants.GDSFMT_ENCOBJDSS,
1:70f7692:                     correlationID_,
1:70f7692:                     true);
1:70f7692:         } else
1:70f7692:         // buildDss should not call ensure length.
1:6eb9730:         {
1:70f7692:             buildDss(true,
1:70f7692:                     chained,
1:41674ac:                     chainedWithSameCorrelator,
1:70f7692:                     DssConstants.GDSFMT_OBJDSS,
1:70f7692:                     correlationID_,
1:70f7692:                     true);
1:6eb9730:         }
1:506f4c8: 
1:70f7692:         return extendedLengthByteCount;
1:6eb9730:     }
1:fefd864: 
1:fefd864:     
1:0326967:     private final void flushExistingDSS() throws DisconnectException {
1:fefd864:         
1:fefd864:         try {
1:fefd864:             if (simpleDssFinalize) {
1:fefd864:                 finalizeDssLength();
1:fefd864:             } else {
1:fefd864:                 finalizePreviousChainedDss(true);
1:fefd864:             }
1:fefd864:             sendBytes(netAgent_.getOutputStream());
1:69e3d06:         } catch (IOException e) {
1:fefd864:             netAgent_.throwCommunicationsFailure(e);
1:fefd864:         }
1:fefd864:         
1:fefd864:     }
1:41674ac: 
1:41674ac: 
1:70f7692:     // Writes out a scalar stream DSS segment, along with DSS continuation headers,
1:70f7692:     // if necessary.
1:0326967:     private final int flushScalarStreamSegment(long leftToRead,
1:70f7692:                                                  int bytesToRead) throws DisconnectException {
1:70f7692:         int newBytesToRead = bytesToRead;
1:41674ac: 
1:70f7692:         // either at end of data, end of dss segment, or both.
1:70f7692:         if (leftToRead != 0) {
1:70f7692:             // 32k segment filled and not at end of data.
1:f6e1e6f:             if ((Math.min(2 + leftToRead, 32767)) > buffer.remaining()) {
4:41674ac:                 try {
1:41674ac:                     sendBytes(netAgent_.getOutputStream());
1:69e3d06:                 } catch (IOException ioe) {
2:41674ac:                     netAgent_.throwCommunicationsFailure(ioe);
1:41674ac:                 }
1:41674ac:             }
1:f6e1e6f:             dssLengthLocation_ = buffer.position();
1:f6e1e6f:             buffer.putShort((short) 0xFFFF);
1:3f3312e:             newBytesToRead = (int)Math.min(leftToRead, 32765L);
1:41674ac:         }
1:41674ac: 
1:70f7692:         return newBytesToRead;
1:fefd864:     }
1:fefd864:     
1:0326967:     private final int flushScalarStreamSegment() throws DisconnectException {
1:fefd864:         
1:fefd864:         try {
1:fefd864:             sendBytes(netAgent_.getOutputStream());
1:69e3d06:         } catch (IOException ioe) {
1:fefd864:             netAgent_.throwCommunicationsFailure(ioe);
1:41674ac:         }
1:fefd864:         
1:f6e1e6f:         dssLengthLocation_ = buffer.position();
1:fefd864:         return DssConstants.MAX_DSS_LEN;
1:fefd864:     }
1:fefd864:     
1:41674ac: 
1:cf5cebf:     /**
1:cf5cebf:      * Pads a value with zeros until it has reached its defined length.
1:cf5cebf:      * <p>
1:cf5cebf:      * This functionality was introduced to handle the error situation where
1:cf5cebf:      * the actual length of the user stream is shorter than specified. To avoid
1:cf5cebf:      * DRDA protocol errors (or in this case a hang), we have to pad the data
1:cf5cebf:      * until the specified length has been reached. In a later increment the
1:cf5cebf:      * Derby-specific EXTDTA status flag was introduced to allow the client to
1:cf5cebf:      * inform the server that the value sent is invalid.
1:cf5cebf:      *
1:cf5cebf:      * @param leftToRead total number of bytes left to read
1:cf5cebf:      * @param bytesToRead remaining bytes to read before flushing
1:cf5cebf:      * @param writeStatus whether or not to wrote the Derby-specific trailing
1:cf5cebf:      *      EXTDTA status flag (see DRDAConstants)
1:cf5cebf:      * @param status the EXTDTA status (for this data value), ignored if
1:cf5cebf:      *      {@code writeStatus} is {@code false}
1:cf5cebf:      * @throws DisconnectException if flushing the buffer fails
1:cf5cebf:      */
1:0326967:     private final void padScalarStreamForError(long leftToRead,
1:cf5cebf:                                                  int bytesToRead,
1:cf5cebf:                                                  boolean writeStatus,
1:cf5cebf:                                                  byte status)
1:cf5cebf:             throws DisconnectException {
1:41674ac:         do {
1:41674ac:             do {
1:f6e1e6f:                 buffer.put((byte) 0x0); // use 0x0 as the padding byte
3:70f7692:                 bytesToRead--;
3:70f7692:                 leftToRead--;
1:41674ac:             } while (bytesToRead > 0);
1:41674ac: 
1:41674ac:             bytesToRead = flushScalarStreamSegment(leftToRead, bytesToRead);
2:41674ac:         } while (leftToRead > 0);
1:41674ac: 
1:cf5cebf:         // Append the EXTDTA status flag if appropriate.
1:cf5cebf:         if (writeStatus) {
1:cf5cebf:             writeEXTDTAStatus(status);
1:cf5cebf:         }
1:41674ac:     }
1:41674ac: 
1:70f7692:     private final void writeExtendedLengthBytes(int extendedLengthByteCount, long length) {
2:70f7692:         int shiftSize = (extendedLengthByteCount - 1) * 8;
2:70f7692:         for (int i = 0; i < extendedLengthByteCount; i++) {
1:f6e1e6f:             buffer.put((byte) (length >>> shiftSize));
2:70f7692:             shiftSize -= 8;
1:41674ac:         }
1:41674ac:     }
1:41674ac: 
1:70f7692:     // experimental lob section - end
1:6a925a3: 
1:70f7692:     // used to finialize a dss which is already in the buffer
1:70f7692:     // before another dss is built.  this includes updating length
1:70f7692:     // bytes and chaining bits.
1:0326967:     private final void finalizePreviousChainedDss(
1:0326967:         boolean dssHasSameCorrelator) {
1:0326967: 
1:70f7692:         finalizeDssLength();
1:f6e1e6f:         int pos = dssLengthLocation_ + 3;
1:f6e1e6f:         byte value = buffer.get(pos);
1:f6e1e6f:         value |= 0x40;
1:70f7692:         if (dssHasSameCorrelator) // for blobs
1:506f4c8:         {
1:f6e1e6f:             value |= 0x10;
1:41674ac:         }
1:f6e1e6f:         buffer.put(pos, value);
1:41674ac:     }
1:6a925a3: 
1:70f7692:     // method to determine if any data is in the request.
1:70f7692:     // this indicates there is a dss object already in the buffer.
1:0326967:     private final boolean doesRequestContainData() {
1:f6e1e6f:         return buffer.position() != 0;
1:41674ac:     }
1:6a925a3: 
1:cf5cebf:     /**
1:f1567ea:      * Signal the completion of a DSS Layer A object.
1:f1567ea:      * <p>
1:f1567ea:      * The length of the DSS object will be calculated based on the difference
1:f1567ea:      * between the start of the DSS, saved in the variable
1:f1567ea:      * {@link #dssLengthLocation_}, and the current offset into the buffer which
1:f1567ea:      * marks the end of the data.
1:f1567ea:      * <p>
1:f1567ea:      * In the event the length requires the use of continuation DSS headers,
1:f1567ea:      * one for each 32k chunk of data, the data will be shifted and the
1:f1567ea:      * continuation headers will be inserted with the correct values as needed.
1:f1567ea:      * Note: In the future, we may try to optimize this approach
1:f1567ea:      * in an attempt to avoid these shifts.
1:f1567ea:      */
1:0326967:     private final void finalizeDssLength() {
1:70f7692:         // calculate the total size of the dss and the number of bytes which would
1:70f7692:         // require continuation dss headers.  The total length already includes the
1:70f7692:         // the 6 byte dss header located at the beginning of the dss.  It does not
1:70f7692:         // include the length of any continuation headers.
1:f6e1e6f:         int totalSize = buffer.position() - dssLengthLocation_;
1:70f7692:         int bytesRequiringContDssHeader = totalSize - 32767;
1:70f7692: 
1:70f7692:         // determine if continuation headers are needed
1:70f7692:         if (bytesRequiringContDssHeader > 0) {
1:70f7692: 
1:70f7692:             // the continuation headers are needed, so calculate how many.
1:70f7692:             // after the first 32767 worth of data, a continuation header is
1:70f7692:             // needed for every 32765 bytes (32765 bytes of data + 2 bytes of
1:70f7692:             // continuation header = 32767 Dss Max Size).
1:70f7692:             int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
1:70f7692:             if (bytesRequiringContDssHeader % 32765 != 0) {
1:70f7692:                 contDssHeaderCount++;
1:41674ac:             }
1:70f7692: 
1:70f7692:             // right now the code will shift to the right.  In the future we may want
1:70f7692:             // to try something fancier to help reduce the copying (maybe keep
1:70f7692:             // space in the beginning of the buffer??).
1:70f7692:             // the offset points to the next available offset in the buffer to place
1:70f7692:             // a piece of data, so the last dataByte is at offset -1.
1:70f7692:             // various bytes will need to be shifted by different amounts
1:70f7692:             // depending on how many dss headers to insert so the amount to shift
1:70f7692:             // will be calculated and adjusted as needed.  ensure there is enough room
1:70f7692:             // for all the conutinuation headers and adjust the offset to point to the
1:70f7692:             // new end of the data.
1:f6e1e6f:             int dataByte = buffer.position() - 1;
1:70f7692:             int shiftOffset = contDssHeaderCount * 2;
1:f6e1e6f:             ensureLength(shiftOffset);
1:f6e1e6f:             buffer.position(buffer.position() + shiftOffset);
1:70f7692: 
1:70f7692:             // mark passOne to help with calculating the length of the final (first or
1:70f7692:             // rightmost) continuation header.
1:70f7692:             boolean passOne = true;
1:41674ac:             do {
1:70f7692:                 // calculate chunk of data to shift
1:70f7692:                 int dataToShift = bytesRequiringContDssHeader % 32765;
1:70f7692:                 if (dataToShift == 0) {
1:70f7692:                     dataToShift = 32765;
1:41674ac:                 }
1:70f7692: 
1:70f7692:                 // perform the shift
1:9f5bc90:                 dataByte -= dataToShift;
1:f6e1e6f:                 byte[] array = buffer.array();
1:f6e1e6f:                 System.arraycopy(array, dataByte + 1,
1:f6e1e6f:                         array, dataByte + shiftOffset + 1, dataToShift);
1:70f7692: 
1:70f7692:                 // calculate the value the value of the 2 byte continuation dss header which
1:70f7692:                 // includes the length of itself.  On the first pass, if the length is 32767
1:70f7692:                 // we do not want to set the continuation dss header flag.
1:70f7692:                 int twoByteContDssHeader = dataToShift + 2;
1:70f7692:                 if (passOne) {
1:70f7692:                     passOne = false;
1:41674ac:                 } else {
1:70f7692:                     if (twoByteContDssHeader == 32767) {
1:70f7692:                         twoByteContDssHeader = 0xFFFF;
1:41674ac:                     }
1:41674ac:                 }
1:70f7692: 
1:70f7692:                 // insert the header's length bytes
1:f6e1e6f:                 buffer.putShort(dataByte + shiftOffset - 1,
1:f6e1e6f:                                 (short) twoByteContDssHeader);
1:70f7692: 
1:70f7692:                 // adjust the bytesRequiringContDssHeader and the amount to shift for
1:70f7692:                 // data in upstream headers.
1:70f7692:                 bytesRequiringContDssHeader -= dataToShift;
1:70f7692:                 shiftOffset -= 2;
1:70f7692: 
1:70f7692:                 // shift and insert another header for more data.
1:70f7692:             } while (bytesRequiringContDssHeader > 0);
1:70f7692: 
1:70f7692:             // set the continuation dss header flag on for the first header
1:70f7692:             totalSize = 0xFFFF;
1:70f7692: 
1:70f7692:         }
1:70f7692: 
1:70f7692:         // insert the length bytes in the 6 byte dss header.
1:f6e1e6f:         buffer.putShort(dssLengthLocation_, (short) totalSize);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // mark the location of a two byte ddm length field in the buffer,
1:70f7692:     // skip the length bytes for later update, and insert a ddm codepoint
1:70f7692:     // into the buffer.  The value of the codepoint is not checked.
1:70f7692:     // this length will be automatically updated when construction of
1:70f7692:     // the ddm object is complete (see updateLengthBytes method).
1:70f7692:     // Note: this mechanism handles extended length ddms.
1:70f7692:     protected final void markLengthBytes(int codePoint) {
1:f6e1e6f:         ensureLength(4);
1:70f7692: 
1:70f7692:         // save the location of length bytes in the mark stack.
1:70f7692:         mark();
1:70f7692: 
1:70f7692:         // skip the length bytes and insert the codepoint
1:f6e1e6f:         buffer.position(buffer.position() + 2);
1:f6e1e6f:         buffer.putShort((short) codePoint);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // mark an offest into the buffer by placing the current offset value on
1:70f7692:     // a stack.
1:70f7692:     private final void mark() {
1:f6e1e6f:         markStack_[top_++] = buffer.position();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // remove and return the top offset value from mark stack.
1:70f7692:     private final int popMark() {
1:70f7692:         return markStack_[--top_];
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected final void markForCachingPKGNAMCSN() {
1:70f7692:         mark();
1:70f7692:     }
1:70f7692: 
1:70f7692:     protected final int popMarkForCachingPKGNAMCSN() {
1:70f7692:         return popMark();
1:70f7692:     }
1:70f7692: 
1:70f7692:     // Called to update the last ddm length bytes marked (lengths are updated
1:70f7692:     // in the reverse order that they are marked).  It is up to the caller
1:70f7692:     // to make sure length bytes were marked before calling this method.
1:70f7692:     // If the length requires ddm extended length bytes, the data will be
1:70f7692:     // shifted as needed and the extended length bytes will be automatically
1:70f7692:     // inserted.
1:70f7692:     protected final void updateLengthBytes() throws SqlException {
1:70f7692:         // remove the top length location offset from the mark stack\
1:70f7692:         // calculate the length based on the marked location and end of data.
1:70f7692:         int lengthLocation = popMark();
1:f6e1e6f:         int length = buffer.position() - lengthLocation;
1:70f7692: 
1:70f7692:         // determine if any extended length bytes are needed.  the value returned
1:70f7692:         // from calculateExtendedLengthByteCount is the number of extended length
1:70f7692:         // bytes required. 0 indicates no exteneded length.
1:70f7692:         int extendedLengthByteCount = calculateExtendedLengthByteCount(length);
1:70f7692:         if (extendedLengthByteCount != 0) {
1:70f7692: 
1:70f7692:             // ensure there is enough room in the buffer for the extended length bytes.
1:f6e1e6f:             ensureLength(extendedLengthByteCount);
1:70f7692: 
1:70f7692:             // calculate the length to be placed in the extended length bytes.
1:70f7692:             // this length does not include the 4 byte llcp.
1:70f7692:             int extendedLength = length - 4;
1:70f7692: 
1:70f7692:             // shift the data to the right by the number of extended length bytes needed.
1:70f7692:             int extendedLengthLocation = lengthLocation + 4;
1:f6e1e6f:             byte[] array = buffer.array();
1:f6e1e6f:             System.arraycopy(array,
1:70f7692:                     extendedLengthLocation,
1:f6e1e6f:                     array,
1:70f7692:                     extendedLengthLocation + extendedLengthByteCount,
1:70f7692:                     extendedLength);
1:70f7692: 
1:70f7692:             // write the extended length
1:70f7692:             int shiftSize = (extendedLengthByteCount - 1) * 8;
1:70f7692:             for (int i = 0; i < extendedLengthByteCount; i++) {
1:f6e1e6f:                 buffer.put(extendedLengthLocation++,
1:f6e1e6f:                            (byte) (extendedLength >>> shiftSize));
1:70f7692:                 shiftSize -= 8;
1:70f7692:             }
1:70f7692:             // adjust the offset to account for the shift and insert
1:f6e1e6f:             buffer.position(buffer.position() + extendedLengthByteCount);
1:70f7692: 
1:70f7692:             // the two byte length field before the codepoint contains the length
1:70f7692:             // of itself, the length of the codepoint, and the number of bytes used
1:70f7692:             // to hold the extended length.  the 2 byte length field also has the first
1:70f7692:             // bit on to indicate extended length bytes were used.
1:70f7692:             length = extendedLengthByteCount + 4;
1:70f7692:             length |= 0x8000;
1:70f7692:         }
1:70f7692: 
1:70f7692:         // write the 2 byte length field (2 bytes before codepoint).
1:f6e1e6f:         buffer.putShort(lengthLocation, (short) length);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // helper method to calculate the minimum number of extended length bytes needed
1:70f7692:     // for a ddm.  a return value of 0 indicates no extended length needed.
1:70f7692:     private final int calculateExtendedLengthByteCount(long ddmSize) //throws SqlException
4:70f7692:     {
1:70f7692:         // according to Jim and some tests perfomred on Lob data,
1:70f7692:         // the extended length bytes are signed.  Assume that
1:70f7692:         // if this is the case for Lobs, it is the case for
1:70f7692:         // all extended length scenarios.
1:70f7692:         if (ddmSize <= 0x7FFF) {
1:70f7692:             return 0;
1:70f7692:         } else if (ddmSize <= 0x7FFFFFFFL) {
1:70f7692:             return 4;
1:70f7692:         } else if (ddmSize <= 0x7FFFFFFFFFFFL) {
1:70f7692:             return 6;
1:41674ac:         } else {
1:70f7692:             return 8;
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert the padByte into the buffer by length number of times.
1:0326967:     private final void padBytes(byte padByte, int length) {
1:f6e1e6f:         ensureLength(length);
2:70f7692:         for (int i = 0; i < length; i++) {
1:f6e1e6f:             buffer.put(padByte);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert an unsigned single byte value into the buffer.
1:70f7692:     final void write1Byte(int value) {
1:f6e1e6f:         writeByte((byte) value);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert 3 unsigned bytes into the buffer.  this was
1:70f7692:     // moved up from NetStatementRequest for performance
1:70f7692:     final void buildTripletHeader(int tripletLength,
1:70f7692:                                   int tripletType,
1:70f7692:                                   int tripletId) {
1:f6e1e6f:         ensureLength(3);
1:f6e1e6f:         buffer.put((byte) tripletLength);
1:f6e1e6f:         buffer.put((byte) tripletType);
1:f6e1e6f:         buffer.put((byte) tripletId);
1:70f7692:     }
1:70f7692: 
1:0326967:     private void writeLidAndLengths(int[][] lidAndLengthOverrides,
1:0326967:                                     int count,
1:0326967:                                     int offset) {
1:f6e1e6f:         ensureLength(count * 3);
1:70f7692:         for (int i = 0; i < count; i++, offset++) {
1:f6e1e6f:             buffer.put((byte) lidAndLengthOverrides[offset][0]);
1:f6e1e6f:             buffer.putShort((short) lidAndLengthOverrides[offset][1]);
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // if mdd overrides are not required, lids and lengths are copied straight into the
1:70f7692:     // buffer.
1:70f7692:     // otherwise, lookup the protocolType in the map.  if an entry exists, substitute the
1:70f7692:     // protocolType with the corresponding override lid.
1:70f7692:     final void writeLidAndLengths(int[][] lidAndLengthOverrides,
1:70f7692:                                   int count,
1:70f7692:                                   int offset,
1:70f7692:                                   boolean mddRequired,
1:69e3d06:                                   Hashtable map) {
1:70f7692:         if (!mddRequired) {
1:70f7692:             writeLidAndLengths(lidAndLengthOverrides, count, offset);
1:70f7692:         }
1:70f7692:         // if mdd overrides are required, lookup the protocolType in the map, and substitute
1:70f7692:         // the protocolType with the override lid.
10:33776ff:         else {
1:f6e1e6f:             ensureLength(count * 3);
1:70f7692:             int protocolType, overrideLid;
1:70f7692:             Object entry;
1:70f7692:             for (int i = 0; i < count; i++, offset++) {
1:70f7692:                 protocolType = lidAndLengthOverrides[offset][0];
1:70f7692:                 // lookup the protocolType in the protocolType->overrideLid map
1:70f7692:                 // if an entry exists, replace the protocolType with the overrideLid
1:66527ec:                 entry = map.get(protocolType);
1:70f7692:                 overrideLid = (entry == null) ? protocolType : ((Integer) entry).intValue();
1:f6e1e6f:                 buffer.put((byte) overrideLid);
1:f6e1e6f:                 buffer.putShort((short) lidAndLengthOverrides[offset][1]);
1:70f7692:             }
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:33776ff: // perf end
1:70f7692: 
1:70f7692:     // insert a big endian unsigned 2 byte value into the buffer.
1:70f7692:     final void write2Bytes(int value) {
1:f6e1e6f:         writeShort((short) value);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a big endian unsigned 4 byte value into the buffer.
1:70f7692:     final void write4Bytes(long value) {
1:f6e1e6f:         writeInt((int) value);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // copy length number of bytes starting at offset 0 of the byte array, buf,
1:70f7692:     // into the buffer.  it is up to the caller to make sure buf has at least length
1:70f7692:     // number of elements.  no checking will be done by this method.
1:70f7692:     final void writeBytes(byte[] buf, int length) {
1:f6e1e6f:         ensureLength(length);
1:f6e1e6f:         buffer.put(buf, 0, length);
1:70f7692:     }
1:70f7692: 
1:70f7692:     final void writeBytes(byte[] buf) {
1:f6e1e6f:         writeBytes(buf, buf.length);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a pair of unsigned 2 byte values into the buffer.
1:70f7692:     final void writeCodePoint4Bytes(int codePoint, int value) {                                                      // should this be writeCodePoint2Bytes
1:f6e1e6f:         ensureLength(4);
1:f6e1e6f:         buffer.putShort((short) codePoint);
1:f6e1e6f:         buffer.putShort((short) value);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a 4 byte length/codepoint pair and a 1 byte unsigned value into the buffer.
1:70f7692:     // total of 5 bytes inserted in buffer.
1:70f7692:     protected final void writeScalar1Byte(int codePoint, int value) {
1:f6e1e6f:         ensureLength(5);
1:f6e1e6f:         buffer.put((byte) 0x00);
1:f6e1e6f:         buffer.put((byte) 0x05);
1:f6e1e6f:         buffer.putShort((short) codePoint);
1:f6e1e6f:         buffer.put((byte) value);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a 4 byte length/codepoint pair and a 2 byte unsigned value into the buffer.
1:70f7692:     // total of 6 bytes inserted in buffer.
1:70f7692:     final void writeScalar2Bytes(int codePoint, int value) {
1:f6e1e6f:         ensureLength(6);
1:f6e1e6f:         buffer.put((byte) 0x00);
1:f6e1e6f:         buffer.put((byte) 0x06);
1:f6e1e6f:         buffer.putShort((short) codePoint);
1:f6e1e6f:         buffer.putShort((short) value);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a 4 byte length/codepoint pair and a 4 byte unsigned value into the
1:70f7692:     // buffer.  total of 8 bytes inserted in the buffer.
1:70f7692:     protected final void writeScalar4Bytes(int codePoint, long value) {
1:f6e1e6f:         ensureLength(8);
1:f6e1e6f:         buffer.put((byte) 0x00);
1:f6e1e6f:         buffer.put((byte) 0x08);
1:f6e1e6f:         buffer.putShort((short) codePoint);
1:f6e1e6f:         buffer.putInt((int) value);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a 4 byte length/codepoint pair and a 8 byte unsigned value into the
1:70f7692:     // buffer.  total of 12 bytes inserted in the buffer.
1:70f7692:     final void writeScalar8Bytes(int codePoint, long value) {
1:f6e1e6f:         ensureLength(12);
1:f6e1e6f:         buffer.put((byte) 0x00);
1:f6e1e6f:         buffer.put((byte) 0x0C);
1:f6e1e6f:         buffer.putShort((short) codePoint);
1:f6e1e6f:         buffer.putLong(value);
1:70f7692:     }
1:70f7692: 
2:70f7692:     // insert a 4 byte length/codepoint pair into the buffer.
2:70f7692:     // total of 4 bytes inserted in buffer.
1:70f7692:     // Note: the length value inserted in the buffer is the same as the value
1:70f7692:     // passed in as an argument (this value is NOT incremented by 4 before being
1:70f7692:     // inserted).
1:70f7692:     final void writeLengthCodePoint(int length, int codePoint) {
1:f6e1e6f:         ensureLength(4);
1:f6e1e6f:         buffer.putShort((short) length);
1:f6e1e6f:         buffer.putShort((short) codePoint);
1:70f7692:     }
1:70f7692: 
1:cf5cebf:     /**
1:ffe112b:      * Write string with no minimum or maximum limit.
1:ffe112b:      * @param codePoint codepoint to write  
1:ffe112b:      * @param string    value to write
1:ffe112b:      * @throws SqlException
1:ffe112b:      */
1:70f7692:     final void writeScalarString(int codePoint, String string) throws SqlException {
1:ffe112b:         writeScalarString(codePoint, string, 0,Integer.MAX_VALUE,null);
1:ffe112b:         
1:ffe112b:     } 
1:ffe112b:    
1:ffe112b:     /**
1:ffe112b:      *  insert a 4 byte length/codepoint pair plus ddm character data into
1:ffe112b:      * the buffer.  This method assumes that the String argument can be
1:ffe112b:      * converted by the ccsid manager.  This should be fine because usually
1:ffe112b:      * there are restrictions on the characters which can be used for ddm
1:ffe112b:      * character data. 
1:ffe112b:      * The two byte length field will contain the length of the character data
1:ffe112b:      * and the length of the 4 byte llcp.  This method does not handle
1:ffe112b:      * scenarios which require extended length bytes.
1:ffe112b:      * 
1:ffe112b:      * @param codePoint  codepoint to write 
1:ffe112b:      * @param string     value
1:ffe112b:      * @param byteMinLength minimum length. String will be padded with spaces 
1:ffe112b:      * if value is too short. Assumes space character is one byte.
1:ffe112b:      * @param byteLengthLimit  Limit to string length. SQLException will be 
1:ffe112b:      * thrown if we exceed this limit.
1:ffe112b:      * @param sqlState  SQLState to throw with string as param if byteLengthLimit
1:ffe112b:      * is exceeded.
1:ffe112b:      * @throws SqlException if string exceeds byteLengthLimit
1:ffe112b:      */
1:ffe112b:     final void writeScalarString(int codePoint, String string, int byteMinLength,
1:1451af7:             int byteLengthLimit, String sqlState) throws SqlException {
1:1451af7:         
1:1451af7:         /* Grab the current CCSID MGR from the NetAgent */ 
1:1451af7:         CcsidManager currentCcsidMgr = netAgent_.getCurrentCcsidManager();
1:1451af7: 
1:018948a:         // We don't know the length of the string yet, so set it to 0 for now.
1:018948a:         // Will be updated later.
1:018948a:         int lengthPos = buffer.position();
1:018948a:         writeLengthCodePoint(0, codePoint);
1:1451af7: 
1:018948a:         int stringByteLength = encodeString(string);
1:ffe112b:         if (stringByteLength > byteLengthLimit) {
1:ffe112b:             throw new SqlException(netAgent_.logWriter_,
1:ffe112b:                     new ClientMessageId(sqlState), string);
1:ffe112b:         }
1:1451af7: 
1:ffe112b:         // pad if we don't reach the byteMinLength limit
1:ffe112b:         if (stringByteLength < byteMinLength) {
1:f6e1e6f:             padBytes(currentCcsidMgr.space_, byteMinLength - stringByteLength);
1:ffe112b:             stringByteLength = byteMinLength;
1:ffe112b:         }
1:1451af7: 
1:018948a:         // Update the length field. The length includes two bytes for the
1:018948a:         // length field itself and two bytes for the codepoint.
1:018948a:         buffer.putShort(lengthPos, (short) (stringByteLength + 4));
1:ffe112b:     }
1:ffe112b: 
1:018948a:     /**
1:018948a:      * Encode a string and put it into the buffer. A larger buffer will be
1:018948a:      * allocated if the current buffer is too small to hold the entire string.
1:018948a:      *
1:018948a:      * @param string the string to encode
1:018948a:      * @return the number of bytes in the encoded representation of the string
1:018948a:      */
1:018948a:     private int encodeString(String string) throws SqlException {
1:018948a:         int startPos = buffer.position();
1:018948a:         CharBuffer src = CharBuffer.wrap(string);
1:018948a:         CcsidManager ccsidMgr = netAgent_.getCurrentCcsidManager();
1:018948a:         ccsidMgr.startEncoding();
1:018948a:         while (!ccsidMgr.encode(src, buffer, netAgent_)) {
1:018948a:             // The buffer was too small to hold the entire string. Let's
1:018948a:             // allocate a larger one. We don't know how much more space we
1:018948a:             // need, so we just tell ensureLength() that we need more than
1:018948a:             // what we have, until we manage to encode the entire string.
1:018948a:             // ensureLength() typically doubles the size of the buffer, so
1:018948a:             // we shouldn't have to call it many times before we get a large
1:018948a:             // enough buffer.
1:018948a:             ensureLength(buffer.remaining() + 1);
1:018948a:         }
1:018948a:         return buffer.position() - startPos;
1:70f7692:     }
1:ffe112b: 
1:70f7692:     // this method writes a 4 byte length/codepoint pair plus the bytes contained
1:70f7692:     // in array buff to the buffer.
1:70f7692:     // the 2 length bytes in the llcp will contain the length of the data plus
1:70f7692:     // the length of the llcp.  This method does not handle scenarios which
1:70f7692:     // require extended length bytes.
1:70f7692:     final void writeScalarBytes(int codePoint, byte[] buff) {
1:f6e1e6f:         writeScalarBytes(codePoint, buff, 0, buff.length);
1:70f7692:     }
1:ffe112b: 
1:70f7692:     // this method inserts a 4 byte length/codepoint pair plus length number of bytes
1:70f7692:     // from array buff starting at offset start.
1:70f7692:     // Note: no checking will be done on the values of start and length with respect
1:70f7692:     // the actual length of the byte array.  The caller must provide the correct
1:70f7692:     // values so an array index out of bounds exception does not occur.
1:70f7692:     // the length will contain the length of the data plus the length of the llcp.
2:70f7692:     // This method does not handle scenarios which require extended length bytes.
1:70f7692:     final void writeScalarBytes(int codePoint, byte[] buff, int start, int length) {
1:f6e1e6f:         writeLengthCodePoint(length + 4, codePoint);
1:f6e1e6f:         ensureLength(length);
1:f6e1e6f:         buffer.put(buff, start, length);
1:70f7692:     }
1:ffe112b: 
1:70f7692:     // this method inserts binary data into the buffer and pads the
1:70f7692:     // data with the padByte if the data length is less than the paddedLength.
1:70f7692:     // Not: this method is not to be used for truncation and buff.length
4:70f7692:     // must be <= paddedLength.
1:70f7692:     final void writeScalarPaddedBytes(byte[] buff, int paddedLength, byte padByte) {
1:f6e1e6f:         writeBytes(buff);
1:f6e1e6f:         padBytes(padByte, paddedLength - buff.length);
1:70f7692:     }
1:f6e1e6f: 
1:70f7692:     // write the request to the OutputStream and flush the OutputStream.
1:70f7692:     // trace the send if PROTOCOL trace is on.
1:69e3d06:     protected void flush(OutputStream socketOutputStream) throws IOException {
1:70f7692:         if (doesRequestContainData()) {
1:70f7692:             finalizeDssLength();
1:70f7692:             sendBytes(socketOutputStream);
1:70f7692:         }
1:70f7692:     }
1:f6e1e6f: 
1:0326967:     private void sendBytes(OutputStream socketOutputStream)
1:69e3d06:             throws IOException {
1:41674ac:         try {
1:b862050:             netAgent_.markWriteChainAsDirty();
1:f6e1e6f:             socketOutputStream.write(buffer.array(), 0, buffer.position());
1:70f7692:             socketOutputStream.flush();
1:70f7692:         } finally {
1:70f7692:             if (netAgent_.logWriter_ != null && passwordIncluded_) {
1:70f7692:                 // if password is in the buffer, need to mask it out.
1:70f7692:                 maskOutPassword();
1:70f7692:                 passwordIncluded_ = false;
1:70f7692:             }
1:70f7692:             if (netAgent_.loggingEnabled()) {
1:f6e1e6f:                 ((NetLogWriter) netAgent_.logWriter_).traceProtocolFlow(
1:f6e1e6f:                         buffer.array(),
1:70f7692:                         0,
1:f6e1e6f:                         buffer.position(),
1:70f7692:                         NetLogWriter.TYPE_TRACE_SEND,
1:70f7692:                         "Request",
1:70f7692:                         "flush",
1:70f7692:                         1); // tracepoint
1:70f7692:             }
1:70f7692:             clearBuffer();
1:70f7692:         }
1:70f7692:     }
1:f6e1e6f: 
1:0326967:     private final void maskOutPassword() {
1:018948a:         int savedPos = buffer.position();
1:41674ac:         try {
1:70f7692:             String maskChar = "*";
1:70f7692:             // construct a mask using the maskChar.
1:70f7692:             StringBuffer mask = new StringBuffer();
1:70f7692:             for (int i = 0; i < passwordLength_; i++) {
1:70f7692:                 mask.append(maskChar);
1:70f7692:             }
1:70f7692:             // try to write mask over password.
1:018948a:             buffer.position(passwordStart_);
1:018948a:             encodeString(mask.toString());
1:70f7692:         } catch (SqlException sqle) {
1:70f7692:             // failed to convert mask,
1:70f7692:             // them simply replace with 0xFF.
1:70f7692:             for (int i = 0; i < passwordLength_; i++) {
1:f6e1e6f:                 buffer.put(passwordStart_ + i, (byte) 0xFF);
1:70f7692:             }
1:018948a:         } finally {
1:018948a:             buffer.position(savedPos);
1:70f7692:         }
1:70f7692:     }
1:f6e1e6f: 
1:70f7692:     // insert a java byte into the buffer.
1:0326967:     private void writeByte(byte v) {
1:f6e1e6f:         ensureLength(1);
1:f6e1e6f:         buffer.put(v);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a java short into the buffer.
1:70f7692:     final void writeShort(short v) {
1:f6e1e6f:         ensureLength(2);
1:f6e1e6f:         buffer.putShort(v);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a java int into the buffer.
1:70f7692:     void writeInt(int v) {
1:f6e1e6f:         ensureLength(4);
1:f6e1e6f:         buffer.putInt(v);
1:70f7692:     }
1:70f7692: 
1:cf5cebf:     /**
1:53795a1:      * Writes a long into the buffer, using six bytes.
1:53795a1:      *
1:53795a1:      * @param v the value to write
1:53795a1:      * @throws IllegalArgumentException if the long value is too large to be
1:53795a1:      *      represented by six bytes.
1:53795a1:      */
1:53795a1:     final void writeLong6Bytes(long v) {
1:f6e1e6f:         ensureLength(6);
1:f6e1e6f:         buffer.putShort((short) (v >> 32));
1:f6e1e6f:         buffer.putInt((int) v);
1:53795a1:     }
1:53795a1: 
1:70f7692:     // insert a java long into the buffer.
1:70f7692:     final void writeLong(long v) {
1:f6e1e6f:         ensureLength(8);
1:f6e1e6f:         buffer.putLong(v);
1:70f7692:     }
1:70f7692: 
1:70f7692:     //-- The following are the write short/int/long in bigEndian byte ordering --
1:70f7692: 
1:70f7692:     // when writing Fdoca data.
1:70f7692:     protected void writeShortFdocaData(short v) {
1:f6e1e6f:         writeShort(v);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // when writing Fdoca data.
1:70f7692:     protected void writeIntFdocaData(int v) {
1:f6e1e6f:         writeInt(v);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // when writing Fdoca data.
1:70f7692:     protected void writeLongFdocaData(long v) {
1:f6e1e6f:         writeLong(v);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a java float into the buffer.
1:70f7692:     protected void writeFloat(float v) {
1:f6e1e6f:         writeInt(Float.floatToIntBits(v));
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a java double into the buffer.
1:70f7692:     protected void writeDouble(double v) {
1:f6e1e6f:         writeLong(Double.doubleToLongBits(v));
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a java.math.BigDecimal into the buffer.
1:69e3d06:     final void writeBigDecimal(BigDecimal v,
1:70f7692:                                int declaredPrecision,
1:70f7692:                                int declaredScale) throws SqlException {
1:f6e1e6f:         ensureLength(16);
1:f6e1e6f:         int length = Decimal.bigDecimalToPackedDecimalBytes(
1:f6e1e6f:                 buffer.array(), buffer.position(),
1:f6e1e6f:                 v, declaredPrecision, declaredScale);
1:f6e1e6f:         buffer.position(buffer.position() + length);
1:70f7692:     }
1:70f7692: 
1:c1d0340:     final void writeDate(DateTimeValue date) throws SqlException {
1:a0b8943:         ensureLength(10);
1:a0b8943:         DateTime.dateToDateBytes(buffer.array(), buffer.position(), date);
1:a0b8943:         buffer.position(buffer.position() + 10);
1:70f7692:     }
1:70f7692: 
1:a0b8943:     final void writeTime(DateTimeValue time) {
1:a0b8943:         ensureLength(8);
1:a0b8943:         DateTime.timeToTimeBytes(buffer.array(), buffer.position(), time);
1:a0b8943:         buffer.position(buffer.position() + 8);
1:70f7692:     }
1:70f7692: 
1:c1d0340:     final void writeTimestamp(DateTimeValue timestamp) throws SqlException {
1:a0b8943:         boolean supportsTimestampNanoseconds = netAgent_.netConnection_.serverSupportsTimestampNanoseconds();
1:a0b8943:         int length = DateTime.getTimestampLength( supportsTimestampNanoseconds );
1:a0b8943:         ensureLength(length);
1:a0b8943:         DateTime.timestampToTimestampBytes(
1:a0b8943:                 buffer.array(), buffer.position(),
1:a0b8943:                 timestamp, supportsTimestampNanoseconds);
1:a0b8943:         buffer.position(buffer.position() + length);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // insert a java boolean into the buffer.  the boolean is written
1:70f7692:     // as a signed byte having the value 0 or 1.
1:70f7692:     final void writeBoolean(boolean v) {
1:f6e1e6f:         write1Byte(v ? 1 : 0);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // follows the TYPDEF rules (note: don't think ddm char data is ever length
1:70f7692:     // delimited)
1:70f7692:     // should this throw SqlException
1:70f7692:     // Will write a varchar mixed or single
1:70f7692:     //  this was writeLDString
1:a0b8943:     final void writeSingleorMixedCcsidLDString(String s, Charset encoding) throws SqlException {
1:a0b8943:         byte[] b = s.getBytes(encoding);
1:70f7692:         if (b.length > 0x7FFF) {
1:6eb9730:             throw new SqlException(netAgent_.logWriter_, 
1:6a925a3:                 new ClientMessageId(SQLState.LANG_STRING_TOO_LONG),
1:6a925a3:                 "32767");
1:70f7692:         }
1:f6e1e6f:         writeLDBytes(b);
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     final void writeLDBytes(byte[] bytes) {
1:70f7692:         writeLDBytesX(bytes.length, bytes);
1:70f7692:     }
1:70f7692: 
1:70f7692:     // private helper method which should only be called by a Request method.
1:70f7692:     // must call ensureLength before calling this method.
1:70f7692:     // added for code reuse and helps perf by reducing ensureLength calls.
1:70f7692:     // ldSize and bytes.length may not be the same.  this is true
1:70f7692:     // when writing graphic ld strings.
1:70f7692:     private final void writeLDBytesX(int ldSize, byte[] bytes) {
1:506f4c8:         writeLDBytesXSubset( ldSize, bytes.length, bytes );
1:506f4c8:     }
1:506f4c8: 
1:506f4c8:     // private helper method for writing just a subset of a byte array
1:506f4c8:     private final void writeLDBytesXSubset( int ldSize, int bytesToCopy, byte[] bytes )
1:506f4c8:     {
1:f6e1e6f:         writeShort((short) ldSize);
1:f6e1e6f:         writeBytes(bytes, bytesToCopy);
1:506f4c8:     }
1:506f4c8: 
1:2aa32e8:     // should not be called if val is null
1:506f4c8:     final void writeUDT( Object val ) throws SqlException
1:506f4c8:     {
1:506f4c8:         byte[] buffer = null;
1:506f4c8:         int length = 0;
1:506f4c8:         
1:6eb9730:         try
1:506f4c8:         {
1:2371470:             PublicBufferOutputStream pbos = new PublicBufferOutputStream();
1:2371470:             ObjectOutputStream oos = new ObjectOutputStream( pbos );
1:506f4c8: 
1:506f4c8:             oos.writeObject( val );
1:506f4c8: 
1:2371470:             buffer = pbos.getBuffer();
1:2371470:             length = pbos.size();
1:506f4c8:         }
1:506f4c8:         catch (Exception e)
1:506f4c8:         {
1:506f4c8:             throw new SqlException
1:506f4c8:                 (
1:506f4c8:                  netAgent_.logWriter_, 
1:506f4c8:                  new ClientMessageId (SQLState.NET_MARSHALLING_UDT_ERROR),
1:e1a79c3:                  e,
1:e1a79c3:                  e.getMessage()
1:506f4c8:                  );
1:506f4c8:         }
1:506f4c8: 
1:506f4c8:         if ( length > DRDAConstants.MAX_DRDA_UDT_SIZE )
1:506f4c8:         {
1:506f4c8:             throw new SqlException
1:506f4c8:                 (
1:506f4c8:                  netAgent_.logWriter_, 
1:506f4c8:                  new ClientMessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
1:506f4c8:                  Integer.toString( DRDAConstants.MAX_DRDA_UDT_SIZE ),
1:506f4c8:                  val.getClass().getName()
1:506f4c8:                  );
1:506f4c8:         }
1:506f4c8: 
1:506f4c8:         writeLDBytesXSubset( length, length, buffer );
1:70f7692:     }
1:70f7692: 
1:fefd864:     private void buildLengthAndCodePointForLob(int codePoint,
1:3f3312e:                                                long leftToRead,
5:70f7692:                                                boolean writeNullByte,
2:70f7692:                                                int extendedLengthByteCount) throws DisconnectException {
1:3f3312e:         int nullIndicatorSize = writeNullByte ? 1 : 0;
3:70f7692:         if (extendedLengthByteCount > 0) {
2:70f7692:             // method should never ensure length
1:70f7692:             writeLengthCodePoint(0x8004 + extendedLengthByteCount, codePoint);
1:3f3312e:             writeExtendedLengthBytes(
1:3f3312e:                     extendedLengthByteCount, leftToRead + nullIndicatorSize);
1:41674ac:         } else {
1:3f3312e:             if (SanityManager.DEBUG) {
1:3f3312e:                 SanityManager.ASSERT(leftToRead +4 + nullIndicatorSize <=
1:3f3312e:                         DssConstants.MAX_DSS_LEN);
1:70f7692:             }
1:3f3312e:             writeLengthCodePoint((int)(leftToRead + 4 + nullIndicatorSize),
1:3f3312e:                     codePoint);
1:70f7692:         }
1:70f7692: 
1:70f7692:         // write the null byte, if necessary
1:fefd864:         if (writeNullByte) {
1:70f7692:             write1Byte(0x0);
1:70f7692:         }
1:70f7692: 
1:70f7692:     }
1:70f7692:     
1:70f7692:     
1:70f7692:     private void buildLengthAndCodePointForLob(int codePoint,
1:fefd864:                                                boolean writeNullByte) throws DisconnectException {
1:fefd864:         
1:fefd864:         //0x8004 is for Layer B Streaming. 
1:fefd864:         //See DRDA, Version 3, Volume 3: Distributed Data Management (DDM) Architecture page 315.
1:fefd864:         writeLengthCodePoint(0x8004, codePoint);
1:fefd864:         
1:fefd864:         // write the null byte, if necessary
1:fefd864:         if (writeNullByte) {
1:fefd864:             write1Byte(0x0);
1:fefd864:         }
1:fefd864:         
1:fefd864:     }
1:fefd864: 
1:f1567ea:     /**
1:cf5cebf:      * Writes the Derby-specific EXTDTA status flag to the send buffer.
1:cf5cebf:      * <p>
1:cf5cebf:      * The existing buffer is flushed to make space for the flag if required.
1:cf5cebf:      *
1:cf5cebf:      * @param flag the Derby-specific EXTDTA status flag
1:cf5cebf:      * @throws DisconnectException if flushing the buffer fails
1:cf5cebf:      */
1:cf5cebf:     private void writeEXTDTAStatus(byte flag)
1:cf5cebf:             throws DisconnectException {
1:cf5cebf:         // Write the status byte to the send buffer.
1:cf5cebf:         // Make sure we have enough space for the status byte.
1:f6e1e6f: 
1:f6e1e6f:         if (buffer.remaining() == 0) {
1:cf5cebf:             flushScalarStreamSegment(1, 0); // Trigger a flush.
1:cf5cebf:         }
1:f6e1e6f:         buffer.put(flag);
1:cf5cebf:         // The last byte will be sent on the next flush.
1:cf5cebf:     }
1:70f7692: 
1:70f7692:     public void setDssLengthLocation(int location) {
1:70f7692:         dssLengthLocation_ = location;
1:70f7692:     }
1:fefd864:     
1:fefd864:     
1:70f7692:     public void setCorrelationID(int id) {
1:70f7692:         correlationID_ = id;
1:70f7692:     }
1:fefd864:     
1:fefd864:     
1:fefd864:     private static boolean peekStream( BufferedInputStream in ) 
1:fefd864:         throws IOException {
1:fefd864:         
1:fefd864:         in.mark( 1 );
1:fefd864:         boolean notYet =  in.read() > -1;
1:fefd864:         in.reset();
1:fefd864:         return notYet;
1:fefd864:         
1:fefd864:     }
1:fefd864: 
1:70f7692: }
============================================================================
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:93ded62
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.error.ExceptionUtil;
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
1:     
/////////////////////////////////////////////////////////////////////////
1:     }
1:     
1:     final void writeScalarStream(boolean chained,
/////////////////////////////////////////////////////////////////////////
1:         if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
1:             netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA) {
/////////////////////////////////////////////////////////////////////////
1:         }else{
1:             
1:             writePlainScalarStream(chained,
1:                                    chainedWithSameCorrelator,
1:                                    codePoint,
1:                                    length,
1:                                    in,
1:                                    writeNullByte,
1:                                    parameterIndex);
1:             
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     final private void writePlainScalarStream(boolean chained,
/////////////////////////////////////////////////////////////////////////
1:         int extendedLengthByteCount = prepScalarStream(chained,
1:                                                        chainedWithSameCorrelator,
1:                                                        writeNullByte,
/////////////////////////////////////////////////////////////////////////
1:         buildLengthAndCodePointForLob(codePoint,
1:                                       writeNullByte,
1:                                       extendedLengthByteCount);
1:         int bytesRead = 0;
1:         do {
1:             do {
1:                 try {
1:                     bytesRead =
1:                 } catch (Exception e) {
1:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
1:                     return;
1:                 }
1:                 if (bytesRead == -1) {
1:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
1:                     return;
1:                 } else {
1:                     bytesToRead -= bytesRead;
1:                     leftToRead -= bytesRead;
1:                 }
1:             } while (bytesToRead > 0);
1:             bytesToRead = flushScalarStreamSegment(leftToRead, bytesToRead);
1:         } while (leftToRead > 0);
1:         // check to make sure that the specified length wasn't too small
1:         try {
1:             if (in.read() != -1) {
1:                 // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
1:             }
1:         } catch (Exception e) {
1:         }
1:     }
/////////////////////////////////////////////////////////////////////////
1:     final private void writePlainScalarStream(boolean chained,
1:         
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
1:         if (writeNullByte) {
1:             spareInDss = DssConstants.MAX_DSS_LEN - 6 - 4 - 1;
1:         } else {
1:             spareInDss = DssConstants.MAX_DSS_LEN - 6 - 4;
1:         }
1:                 
1:         buildLengthAndCodePointForLob(codePoint,
1:                                       writeNullByte);
/////////////////////////////////////////////////////////////////////////
1:                     return;
1:     }
commit:1451af7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     Request(NetAgent netAgent, int minSize) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             int byteLengthLimit, String sqlState) throws SqlException {
1:         
1:         /* Grab the current CCSID MGR from the NetAgent */ 
1:         CcsidManager currentCcsidMgr = netAgent_.getCurrentCcsidManager();
1:         
0:         int maxByteLength = currentCcsidMgr.getByteLength(string);
1: 
/////////////////////////////////////////////////////////////////////////
0:         offset_ = currentCcsidMgr.convertFromJavaString(string, bytes_, offset_, netAgent_);
/////////////////////////////////////////////////////////////////////////
0:                 bytes_[offset_++] = currentCcsidMgr.space_;
/////////////////////////////////////////////////////////////////////////
1:         
0:         /* Grab the current CCSID MGR from the NetAgent */ 
0:         CcsidManager currentCcsidMgr = netAgent_.getCurrentCcsidManager();
1:         
0:         int stringLength = currentCcsidMgr.getByteLength(string);
1:         
0:         offset_ = currentCcsidMgr.convertFromJavaString(string, bytes_, offset_, netAgent_);
0:             bytes_[offset_++] = currentCcsidMgr.space_;
/////////////////////////////////////////////////////////////////////////
0:             netAgent_.getCurrentCcsidManager()
0:                     .convertFromJavaString(mask.toString(), bytes_, passwordStart_, netAgent_);
/////////////////////////////////////////////////////////////////////////
0:         CcsidManager currentCcsidManager = netAgent_.getCurrentCcsidManager();
1:         
0:         ensureLength(offset_ + currentCcsidManager.getByteLength(s));
1:         
0:         offset_ = currentCcsidManager.convertFromJavaString(s, bytes_, offset_, netAgent_);
commit:ffe112b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Write string with no minimum or maximum limit.
1:      * @param codePoint codepoint to write  
1:      * @param string    value to write
1:      * @throws SqlException
1:      */
1:         writeScalarString(codePoint, string, 0,Integer.MAX_VALUE,null);
1:         
1:     } 
1:    
1:     /**
1:      *  insert a 4 byte length/codepoint pair plus ddm character data into
1:      * the buffer.  This method assumes that the String argument can be
1:      * converted by the ccsid manager.  This should be fine because usually
1:      * there are restrictions on the characters which can be used for ddm
1:      * character data. 
1:      * The two byte length field will contain the length of the character data
1:      * and the length of the 4 byte llcp.  This method does not handle
1:      * scenarios which require extended length bytes.
1:      * 
1:      * @param codePoint  codepoint to write 
1:      * @param string     value
1:      * @param byteMinLength minimum length. String will be padded with spaces 
1:      * if value is too short. Assumes space character is one byte.
1:      * @param byteLengthLimit  Limit to string length. SQLException will be 
1:      * thrown if we exceed this limit.
1:      * @param sqlState  SQLState to throw with string as param if byteLengthLimit
1:      * is exceeded.
1:      * @throws SqlException if string exceeds byteLengthLimit
1:      */
1:     final void writeScalarString(int codePoint, String string, int byteMinLength,
0:             int byteLengthLimit, String sqlState) throws SqlException {        
0:         int maxByteLength = ccsidManager_.maxBytesPerChar() * string.length();
0:         ensureLength(offset_ + maxByteLength + 4);
0:         // Skip length for now until we know actual length
0:         int lengthOffset = offset_;
0:         offset_ += 2;
1:         
1:         
1:        
0:         int stringByteLength = offset_ - lengthOffset - 4;
0:         // reset the buffer and throw an SQLException if the length is too long
1:         if (stringByteLength > byteLengthLimit) {
0:             offset_ = lengthOffset;
1:             throw new SqlException(netAgent_.logWriter_, 
1:                     new ClientMessageId(sqlState), string);
1:         }
1:         // pad if we don't reach the byteMinLength limit
1:         if (stringByteLength < byteMinLength) {
0:             for (int i = stringByteLength ; i < byteMinLength; i++) {
0:                 bytes_[offset_++] = ccsidManager_.space_;
1:             }
1:             stringByteLength = byteMinLength;
1:         }
0:         // now write the length.  We have the string byte length plus
0:         // 4 bytes, 2 for length and 2 for codepoint.
0:         int totalLength = stringByteLength + 4;
0:         bytes_[lengthOffset] = (byte) ((totalLength >>> 8) & 0xff);
0:         bytes_[lengthOffset + 1] = (byte) ((totalLength) & 0xff);
1:     
commit:6eb9730
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.am.MessageId;
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
0: import java.io.UnsupportedEncodingException;
/////////////////////////////////////////////////////////////////////////
1:         try
1:         {
0:             ensureLength(offset_ + 10);
0:             org.apache.derby.client.am.DateTime.dateToDateBytes(bytes_, offset_, date);
0:             offset_ += 10;
0:         } catch (java.io.UnsupportedEncodingException e) {
1:             throw new SqlException(netAgent_.logWriter_, 
0:                     new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                     "java.sql.Date", "DATE", e);
1:         }
1:         try{
0:             ensureLength(offset_ + 8);
0:             org.apache.derby.client.am.DateTime.timeToTimeBytes(bytes_, offset_, time);
0:             offset_ += 8;
0:         } catch(UnsupportedEncodingException e) {
1:             throw new SqlException(netAgent_.logWriter_, 
0:                     new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                     "java.sql.Time", "TIME", e);
1:       }
1:         try{
0:             ensureLength(offset_ + 26);
0:             org.apache.derby.client.am.DateTime.timestampToTimestampBytes(bytes_, offset_, timestamp);
0:             offset_ += 26;
0:         }catch(UnsupportedEncodingException e) {
1:             throw new SqlException(netAgent_.logWriter_,  
0:                     new MessageId(SQLState.UNSUPPORTED_ENCODING),
0:                     "java.sql.Timestamp", "TIMESTAMP", e);
1:         }
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:b862050
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.error.ExceptionUtil;
/////////////////////////////////////////////////////////////////////////
1:                 } catch (IOException ioe) {
1:                     if (netAgent_.getOutputStream() == null) {
1:                         // The exception has taken down the connection, so we 
1:                         // check if it was caused by attempting to 
1:                         // read the stream from our own connection...
1:                         for (Throwable t = ioe; t != null; t = t.getCause()) {
1:                             if (t instanceof SqlException
1:                                     && ((SqlException) t).getSQLState().equals(ExceptionUtil.getSQLStateFromIdentifier(SQLState.NET_WRITE_CHAIN_IS_DIRTY))) {
1:                                 throw new SqlException(netAgent_.logWriter_,
1:                                         new ClientMessageId(SQLState.NET_LOCATOR_STREAM_PARAMS_NOT_SUPPORTED),
1:                                         ioe, parameterIndex);
1:                             }
1:                         }
1:                         // Something else has killed the connection, fast forward to despair...
1:                         throw new SqlException(netAgent_.logWriter_,
1:                                 new ClientMessageId(SQLState.NET_DISCONNECT_EXCEPTION_ON_READ),
1:                                 ioe, parameterIndex, ioe.getMessage());
1:                     }
1:                     // The OutPutStream is still intact so try to finish request
1:                     // with what we managed to read
1: 
1:                             new SqlException(
1:                             ioe, parameterIndex, ioe.getMessage()));
/////////////////////////////////////////////////////////////////////////
1:             netAgent_.markWriteChainAsDirty();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e1a79c3
/////////////////////////////////////////////////////////////////////////
1:                             e, parameterIndex, e.getMessage()));
/////////////////////////////////////////////////////////////////////////
0:                     e, parameterIndex, e.getMessage()));
/////////////////////////////////////////////////////////////////////////
1:                                  e, parameterIndex, e.getMessage());
/////////////////////////////////////////////////////////////////////////
1:                  e,
1:                  e.getMessage()
commit:a0b8943
/////////////////////////////////////////////////////////////////////////
1: import java.nio.charset.Charset;
/////////////////////////////////////////////////////////////////////////
1:         ensureLength(10);
1:         DateTime.dateToDateBytes(buffer.array(), buffer.position(), date);
1:         buffer.position(buffer.position() + 10);
1:     final void writeTime(DateTimeValue time) {
1:         ensureLength(8);
1:         DateTime.timeToTimeBytes(buffer.array(), buffer.position(), time);
1:         buffer.position(buffer.position() + 8);
1:         boolean supportsTimestampNanoseconds = netAgent_.netConnection_.serverSupportsTimestampNanoseconds();
1:         int length = DateTime.getTimestampLength( supportsTimestampNanoseconds );
1:         ensureLength(length);
1:         DateTime.timestampToTimestampBytes(
1:                 buffer.array(), buffer.position(),
1:                 timestamp, supportsTimestampNanoseconds);
1:         buffer.position(buffer.position() + length);
/////////////////////////////////////////////////////////////////////////
1:     final void writeSingleorMixedCcsidLDString(String s, Charset encoding) throws SqlException {
1:         byte[] b = s.getBytes(encoding);
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                     netAgent_.accumulateReadException(
0:                         new SqlException(
1:                             netAgent_.logWriter_,
1:                             new ClientMessageId(SQLState.NET_EXCEPTION_ON_READ),
0:                             parameterIndex, e.getMessage(), e));
/////////////////////////////////////////////////////////////////////////
1:                     netAgent_.accumulateReadException(
1:                         new SqlException(netAgent_.logWriter_,
1:                             new ClientMessageId(SQLState.NET_PREMATURE_EOS),
1:                             parameterIndex));
/////////////////////////////////////////////////////////////////////////
1:                 netAgent_.accumulateReadException(new SqlException(
1:                         netAgent_.logWriter_,
1:                         new ClientMessageId(
1:                             SQLState.NET_INPUTSTREAM_LENGTH_TOO_SMALL),
1:                         parameterIndex));
1:             netAgent_.accumulateReadException(new SqlException(
1:                     netAgent_.logWriter_,
1:                     new ClientMessageId(
1:                         SQLState.NET_EXCEPTION_ON_STREAMLEN_VERIFICATION),
0:                     parameterIndex, e.getMessage(), e));
/////////////////////////////////////////////////////////////////////////
0:                                  parameterIndex, e.getMessage(), e);
/////////////////////////////////////////////////////////////////////////
1:                 entry = map.get(protocolType);
commit:018948a
/////////////////////////////////////////////////////////////////////////
1: import java.nio.CharBuffer;
/////////////////////////////////////////////////////////////////////////
1:         // We don't know the length of the string yet, so set it to 0 for now.
1:         // Will be updated later.
1:         int lengthPos = buffer.position();
1:         writeLengthCodePoint(0, codePoint);
1: 
1:         int stringByteLength = encodeString(string);
0:             stringByteLength = byteMinLength;
1: 
1:         // Update the length field. The length includes two bytes for the
1:         // length field itself and two bytes for the codepoint.
1:         buffer.putShort(lengthPos, (short) (stringByteLength + 4));
1:     /**
1:      * Encode a string and put it into the buffer. A larger buffer will be
1:      * allocated if the current buffer is too small to hold the entire string.
1:      *
1:      * @param string the string to encode
1:      * @return the number of bytes in the encoded representation of the string
1:      */
1:     private int encodeString(String string) throws SqlException {
1:         int startPos = buffer.position();
1:         CharBuffer src = CharBuffer.wrap(string);
1:         CcsidManager ccsidMgr = netAgent_.getCurrentCcsidManager();
1:         ccsidMgr.startEncoding();
1:         while (!ccsidMgr.encode(src, buffer, netAgent_)) {
1:             // The buffer was too small to hold the entire string. Let's
1:             // allocate a larger one. We don't know how much more space we
1:             // need, so we just tell ensureLength() that we need more than
1:             // what we have, until we manage to encode the entire string.
1:             // ensureLength() typically doubles the size of the buffer, so
1:             // we shouldn't have to call it many times before we get a large
1:             // enough buffer.
1:             ensureLength(buffer.remaining() + 1);
1:         }
1:         return buffer.position() - startPos;
/////////////////////////////////////////////////////////////////////////
1:         int savedPos = buffer.position();
/////////////////////////////////////////////////////////////////////////
1:             buffer.position(passwordStart_);
1:             encodeString(mask.toString());
1:         } finally {
1:             buffer.position(savedPos);
/////////////////////////////////////////////////////////////////////////
0:         encodeString(s);
commit:f6e1e6f
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.Decimal;
/////////////////////////////////////////////////////////////////////////
1: import java.nio.ByteBuffer;
1:     protected ByteBuffer buffer;
/////////////////////////////////////////////////////////////////////////
1:         buffer = ByteBuffer.allocate(minSize);
1:         buffer.clear();
/////////////////////////////////////////////////////////////////////////
1:         if (length > buffer.remaining()) {
1:             int newLength =
1:                 Math.max(buffer.capacity() * 2, buffer.position() + length);
1:             // copy the old buffer into a new one
1:             buffer.flip();
1:             buffer = ByteBuffer.allocate(newLength).put(buffer);
/////////////////////////////////////////////////////////////////////////
1:         ensureLength(6);
1:         dssLengthLocation_ = buffer.position();
1:         buffer.putShort((short) 0xFFFF);
1:         buffer.put((byte) 0xD0);
1: 
/////////////////////////////////////////////////////////////////////////
1:         buffer.put((byte) dssType);
1:         buffer.putShort((short) corrId);
/////////////////////////////////////////////////////////////////////////
0: 					bytesRead =
1:                         in.read(buffer.array(), buffer.position(), bytesToRead);
/////////////////////////////////////////////////////////////////////////
1:                     buffer.position(buffer.position() + bytesRead);
/////////////////////////////////////////////////////////////////////////
1:         ensureLength(DssConstants.MAX_DSS_LEN - buffer.position());
/////////////////////////////////////////////////////////////////////////
1:                      in.read(buffer.array(), buffer.position(), spareInDss)
1:                 buffer.position(buffer.position() + bytesRead);
/////////////////////////////////////////////////////////////////////////
1: 
1:                     buffer.putShort((short) 0xFFFF);
/////////////////////////////////////////////////////////////////////////
1:                 leftToRead + buffer.position()) > DssConstants.MAX_DSS_LEN) {
/////////////////////////////////////////////////////////////////////////
1:             if ((Math.min(2 + leftToRead, 32767)) > buffer.remaining()) {
1:             dssLengthLocation_ = buffer.position();
1:             buffer.putShort((short) 0xFFFF);
/////////////////////////////////////////////////////////////////////////
1:         dssLengthLocation_ = buffer.position();
/////////////////////////////////////////////////////////////////////////
1:                 buffer.put((byte) 0x0); // use 0x0 as the padding byte
/////////////////////////////////////////////////////////////////////////
1:             buffer.put((byte) (length >>> shiftSize));
/////////////////////////////////////////////////////////////////////////
1:         int pos = dssLengthLocation_ + 3;
1:         byte value = buffer.get(pos);
1:         value |= 0x40;
1:             value |= 0x10;
1:         buffer.put(pos, value);
1:         return buffer.position() != 0;
/////////////////////////////////////////////////////////////////////////
1:         int totalSize = buffer.position() - dssLengthLocation_;
/////////////////////////////////////////////////////////////////////////
1:             int dataByte = buffer.position() - 1;
1:             ensureLength(shiftOffset);
1:             buffer.position(buffer.position() + shiftOffset);
/////////////////////////////////////////////////////////////////////////
1:                 byte[] array = buffer.array();
1:                 System.arraycopy(array, dataByte + 1,
1:                         array, dataByte + shiftOffset + 1, dataToShift);
/////////////////////////////////////////////////////////////////////////
1:                 buffer.putShort(dataByte + shiftOffset - 1,
1:                                 (short) twoByteContDssHeader);
/////////////////////////////////////////////////////////////////////////
1:         buffer.putShort(dssLengthLocation_, (short) totalSize);
/////////////////////////////////////////////////////////////////////////
1:         ensureLength(4);
1:         buffer.position(buffer.position() + 2);
1:         buffer.putShort((short) codePoint);
1:         markStack_[top_++] = buffer.position();
/////////////////////////////////////////////////////////////////////////
1:         int length = buffer.position() - lengthLocation;
/////////////////////////////////////////////////////////////////////////
1:             ensureLength(extendedLengthByteCount);
/////////////////////////////////////////////////////////////////////////
1:             byte[] array = buffer.array();
1:             System.arraycopy(array,
1:                     array,
1:                 buffer.put(extendedLengthLocation++,
1:                            (byte) (extendedLength >>> shiftSize));
1:             buffer.position(buffer.position() + extendedLengthByteCount);
/////////////////////////////////////////////////////////////////////////
1:         buffer.putShort(lengthLocation, (short) length);
/////////////////////////////////////////////////////////////////////////
1:         ensureLength(length);
1:             buffer.put(padByte);
1:         writeByte((byte) value);
/////////////////////////////////////////////////////////////////////////
1:         ensureLength(3);
1:         buffer.put((byte) tripletLength);
1:         buffer.put((byte) tripletType);
1:         buffer.put((byte) tripletId);
1:         ensureLength(count * 3);
1:             buffer.put((byte) lidAndLengthOverrides[offset][0]);
1:             buffer.putShort((short) lidAndLengthOverrides[offset][1]);
/////////////////////////////////////////////////////////////////////////
1:             ensureLength(count * 3);
/////////////////////////////////////////////////////////////////////////
1:                 buffer.put((byte) overrideLid);
1:                 buffer.putShort((short) lidAndLengthOverrides[offset][1]);
/////////////////////////////////////////////////////////////////////////
1:         writeShort((short) value);
1:         writeInt((int) value);
1:         ensureLength(length);
1:         buffer.put(buf, 0, length);
1:         writeBytes(buf, buf.length);
1:         ensureLength(4);
1:         buffer.putShort((short) codePoint);
1:         buffer.putShort((short) value);
1:         ensureLength(5);
1:         buffer.put((byte) 0x00);
1:         buffer.put((byte) 0x05);
1:         buffer.putShort((short) codePoint);
1:         buffer.put((byte) value);
1:         ensureLength(6);
1:         buffer.put((byte) 0x00);
1:         buffer.put((byte) 0x06);
1:         buffer.putShort((short) codePoint);
1:         buffer.putShort((short) value);
1:         ensureLength(8);
1:         buffer.put((byte) 0x00);
1:         buffer.put((byte) 0x08);
1:         buffer.putShort((short) codePoint);
1:         buffer.putInt((int) value);
1:         ensureLength(12);
1:         buffer.put((byte) 0x00);
1:         buffer.put((byte) 0x0C);
1:         buffer.putShort((short) codePoint);
1:         buffer.putLong(value);
/////////////////////////////////////////////////////////////////////////
1:         ensureLength(4);
1:         buffer.putShort((short) length);
1:         buffer.putShort((short) codePoint);
/////////////////////////////////////////////////////////////////////////
0:         writeScalarBytes(codePoint, buf, 0, length);
/////////////////////////////////////////////////////////////////////////
0:         writeLengthCodePoint(dataLength + 4, codePoint);
0:         ensureLength(dataLength);
/////////////////////////////////////////////////////////////////////////
0:         int stringByteLength = currentCcsidMgr.getByteLength(string);
0:             throw new SqlException(netAgent_.logWriter_,
1: 
0:         writeScalarHeader(codePoint, Math.max(byteMinLength, stringByteLength));
1: 
0:         buffer.position(
0:             currentCcsidMgr.convertFromJavaString(
0:                 string, buffer.array(), buffer.position(), netAgent_));
1: 
1:             padBytes(currentCcsidMgr.space_, byteMinLength - stringByteLength);
/////////////////////////////////////////////////////////////////////////
0:         ensureLength(paddedLength);
0:         buffer.position(currentCcsidMgr.convertFromJavaString(
0:                 string, buffer.array(), buffer.position(), netAgent_));
1: 
0:         padBytes(currentCcsidMgr.space_, paddedLength - stringLength);
/////////////////////////////////////////////////////////////////////////
1:         writeScalarBytes(codePoint, buff, 0, buff.length);
/////////////////////////////////////////////////////////////////////////
1:         writeLengthCodePoint(length + 4, codePoint);
1:         ensureLength(length);
1:         buffer.put(buff, start, length);
/////////////////////////////////////////////////////////////////////////
0:         writeLengthCodePoint(paddedLength + 4, codePoint);
0:         writeScalarPaddedBytes(buff, paddedLength, padByte);
/////////////////////////////////////////////////////////////////////////
1:         writeBytes(buff);
1:         padBytes(padByte, paddedLength - buff.length);
/////////////////////////////////////////////////////////////////////////
1:             socketOutputStream.write(buffer.array(), 0, buffer.position());
/////////////////////////////////////////////////////////////////////////
1:                 ((NetLogWriter) netAgent_.logWriter_).traceProtocolFlow(
1:                         buffer.array(),
1:                         buffer.position(),
/////////////////////////////////////////////////////////////////////////
0:             netAgent_.getCurrentCcsidManager().convertFromJavaString(
0:                 mask.toString(), buffer.array(), passwordStart_, netAgent_);
1:                 buffer.put(passwordStart_ + i, (byte) 0xFF);
1:         ensureLength(1);
1:         buffer.put(v);
1:         ensureLength(2);
1:         buffer.putShort(v);
1:         ensureLength(4);
1:         buffer.putInt(v);
/////////////////////////////////////////////////////////////////////////
1:         ensureLength(6);
1:         buffer.putShort((short) (v >> 32));
1:         buffer.putInt((int) v);
1:         ensureLength(8);
1:         buffer.putLong(v);
1:         writeShort(v);
1:         writeInt(v);
1:         writeLong(v);
1:         writeInt(Float.floatToIntBits(v));
1:         writeLong(Double.doubleToLongBits(v));
1:         ensureLength(16);
1:         int length = Decimal.bigDecimalToPackedDecimalBytes(
1:                 buffer.array(), buffer.position(),
1:                 v, declaredPrecision, declaredScale);
1:         buffer.position(buffer.position() + length);
0:             ensureLength(10);
0:             DateTime.dateToDateBytes(buffer.array(), buffer.position(), date);
0:             buffer.position(buffer.position() + 10);
/////////////////////////////////////////////////////////////////////////
0:             ensureLength(8);
0:             DateTime.timeToTimeBytes(buffer.array(), buffer.position(), time);
0:             buffer.position(buffer.position() + 8);
/////////////////////////////////////////////////////////////////////////
0:             ensureLength(length);
0:             DateTime.timestampToTimestampBytes(
0:                     buffer.array(), buffer.position(),
0:                     timestamp, supportsTimestampNanoseconds);
0:             buffer.position(buffer.position() + length);
/////////////////////////////////////////////////////////////////////////
1:         write1Byte(v ? 1 : 0);
/////////////////////////////////////////////////////////////////////////
1:         writeLDBytes(b);
/////////////////////////////////////////////////////////////////////////
1:         writeShort((short) ldSize);
1:         writeBytes(bytes, bytesToCopy);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         ensureLength(currentCcsidManager.getByteLength(s));
0:         buffer.position(currentCcsidManager.convertFromJavaString(
0:                 s, buffer.array(), buffer.position(), netAgent_));
/////////////////////////////////////////////////////////////////////////
1: 
1:         if (buffer.remaining() == 0) {
1:         buffer.put(flag);
commit:c1d0340
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.DateTimeValue;
/////////////////////////////////////////////////////////////////////////
1:     final void writeDate(DateTimeValue date) throws SqlException {
/////////////////////////////////////////////////////////////////////////
0:     final void writeTime(DateTimeValue time) throws SqlException {
/////////////////////////////////////////////////////////////////////////
1:     final void writeTimestamp(DateTimeValue timestamp) throws SqlException {
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:0326967
/////////////////////////////////////////////////////////////////////////
1: class Request {
/////////////////////////////////////////////////////////////////////////
1:     private final void clearBuffer() {
/////////////////////////////////////////////////////////////////////////
1:     private final void ensureLength(int length) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private final int prepScalarStream(boolean chained,
/////////////////////////////////////////////////////////////////////////
1:     private final void flushExistingDSS() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     private final int flushScalarStreamSegment(long leftToRead,
/////////////////////////////////////////////////////////////////////////
1:     private final int flushScalarStreamSegment() throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1:     private final void padScalarStreamForError(long leftToRead,
/////////////////////////////////////////////////////////////////////////
1:     private final void finalizePreviousChainedDss(
1:         boolean dssHasSameCorrelator) {
1: 
/////////////////////////////////////////////////////////////////////////
1:     private final boolean doesRequestContainData() {
/////////////////////////////////////////////////////////////////////////
1:     private final void finalizeDssLength() {
/////////////////////////////////////////////////////////////////////////
1:     private final void padBytes(byte padByte, int length) {
/////////////////////////////////////////////////////////////////////////
1:     private void writeLidAndLengths(int[][] lidAndLengthOverrides,
1:                                     int count,
1:                                     int offset) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private void sendBytes(OutputStream socketOutputStream)
/////////////////////////////////////////////////////////////////////////
1:     private final void maskOutPassword() {
/////////////////////////////////////////////////////////////////////////
1:     private void writeByte(byte v) {
/////////////////////////////////////////////////////////////////////////
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.io.Reader;
1: import java.math.BigDecimal;
1: import java.util.Hashtable;
/////////////////////////////////////////////////////////////////////////
1:                                  InputStream in,
/////////////////////////////////////////////////////////////////////////
1:                                  InputStream in,
/////////////////////////////////////////////////////////////////////////
1:                                               InputStream in,
/////////////////////////////////////////////////////////////////////////
1:                                               InputStream in,
/////////////////////////////////////////////////////////////////////////
1:                                  Reader r,
/////////////////////////////////////////////////////////////////////////
1:                                  Reader r,
/////////////////////////////////////////////////////////////////////////
1:             } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (IOException e) {
/////////////////////////////////////////////////////////////////////////
1:                 } catch (IOException ioe) {
/////////////////////////////////////////////////////////////////////////
1:         } catch (IOException ioe) {
/////////////////////////////////////////////////////////////////////////
1:                                   Hashtable map) {
/////////////////////////////////////////////////////////////////////////
1:     protected void flush(OutputStream socketOutputStream) throws IOException {
0:     protected void sendBytes(OutputStream socketOutputStream)
1:             throws IOException {
/////////////////////////////////////////////////////////////////////////
1:     final void writeBigDecimal(BigDecimal v,
/////////////////////////////////////////////////////////////////////////
0:         } catch (UnsupportedEncodingException e) {
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:2371470
/////////////////////////////////////////////////////////////////////////
1:             PublicBufferOutputStream pbos = new PublicBufferOutputStream();
1:             ObjectOutputStream oos = new ObjectOutputStream( pbos );
1:             buffer = pbos.getBuffer();
1:             length = pbos.size();
commit:b9687fb
/////////////////////////////////////////////////////////////////////////
0:         offset_ = ccsidManager_.convertFromJavaString(string, bytes_, offset_, netAgent_);
/////////////////////////////////////////////////////////////////////////
0:         offset_ = ccsidManager_.convertFromJavaString(string, bytes_, offset_, netAgent_);
/////////////////////////////////////////////////////////////////////////
0:             ccsidManager_.convertFromJavaString(mask.toString(), bytes_, passwordStart_, netAgent_);
/////////////////////////////////////////////////////////////////////////
0:         offset_ = ccsidManager_.convertFromJavaString(s, bytes_, offset_, netAgent_);
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:419a664
/////////////////////////////////////////////////////////////////////////
0: 				} catch (Exception e) {
1: 																	   new ClientMessageId(SQLState.NET_EXCEPTION_ON_READ),
/////////////////////////////////////////////////////////////////////////
0: 		} catch (Exception e) {
0: 																				   SQLState.NET_EXCEPTION_ON_STREAMLEN_VERIFICATION),
/////////////////////////////////////////////////////////////////////////
0:         } catch (Exception e) {
0:                                  new ClientMessageId(SQLState.NET_EXCEPTION_ON_READ),
commit:bead0ab
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.DateTime;
/////////////////////////////////////////////////////////////////////////
0:             boolean supportsTimestampNanoseconds = netAgent_.netConnection_.serverSupportsTimestampNanoseconds();
0:             int length = DateTime.getTimestampLength( supportsTimestampNanoseconds );
0:             ensureLength( offset_ + length );
0:             org.apache.derby.client.am.DateTime.timestampToTimestampBytes
0:                 ( bytes_, offset_, timestamp, supportsTimestampNanoseconds );
0:             offset_ += length;
commit:2aa32e8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     // should not be called if val is null
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.io.DynamicByteArrayOutputStream;
1: import org.apache.derby.shared.common.sanity.SanityManager;
1: import org.apache.derby.iapi.reference.DRDAConstants;
1: import java.io.ObjectOutputStream;
/////////////////////////////////////////////////////////////////////////
1:         writeLDBytesXSubset( ldSize, bytes.length, bytes );
1:     }
1: 
1:     // private helper method for writing just a subset of a byte array
1:     private final void writeLDBytesXSubset( int ldSize, int bytesToCopy, byte[] bytes )
1:     {
0:         System.arraycopy( bytes, 0, bytes_, offset_, bytesToCopy );
0:         offset_ += bytesToCopy;
1:     }
1: 
1:     final void writeUDT( Object val ) throws SqlException
1:     {
0:         // should not be called if val is null
0:         if ( val == null )
1:         {
0:             SanityManager.THROWASSERT( "UDT is null" );
1:         }
1: 
1:         byte[] buffer = null;
1:         int length = 0;
1:         
0:         try
1:         {
0:             DynamicByteArrayOutputStream dbaos = new DynamicByteArrayOutputStream();
0:             ObjectOutputStream oos = new ObjectOutputStream( dbaos );
1: 
1:             oos.writeObject( val );
1: 
0:             buffer = dbaos.getByteArray();
0:             length = dbaos.getUsed();
1:         }
1:         catch (Exception e)
1:         {
1:             throw new SqlException
1:                 (
1:                  netAgent_.logWriter_, 
1:                  new ClientMessageId (SQLState.NET_MARSHALLING_UDT_ERROR),
0:                  e.getMessage(),
0:                  e
1:                  );
1:         }
1: 
1:         if ( length > DRDAConstants.MAX_DRDA_UDT_SIZE )
1:         {
1:             throw new SqlException
1:                 (
1:                  netAgent_.logWriter_, 
1:                  new ClientMessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
1:                  Integer.toString( DRDAConstants.MAX_DRDA_UDT_SIZE ),
1:                  val.getClass().getName()
1:                  );
1:         }
1: 
0:         ensureLength( offset_ + length + 2 );
1:         writeLDBytesXSubset( length, length, buffer );
commit:956354d
/////////////////////////////////////////////////////////////////////////
1:                                                             SqlException{
1:         writeScalarStream(chained,
1:                           chainedWithSameCorrelator,
1:                           codePoint,
0:                           length * 2,
1:                           EncodedInputStream.createUTF16BEStream(r),
1:                           writeNullByte,
1:                           parameterIndex);
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:3f3312e
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.client.am.DateTimeValue;
0: import org.apache.derby.shared.common.sanity.SanityManager;
1: import java.io.IOException;
/////////////////////////////////////////////////////////////////////////
1:                                  long length,
1: 
/////////////////////////////////////////////////////////////////////////
1:                                               long length,
/////////////////////////////////////////////////////////////////////////
1:         long leftToRead = length;
1:         long bytesToSend = writeEXTDTAStatusByte ? leftToRead + 1 : leftToRead;
1:         int nullIndicatorSize = writeNullByte ? 1 : 0;
1:         int dssMaxDataLength = DssConstants.MAX_DSS_LEN - 6 - 4 -
1:                 nullIndicatorSize - extendedLengthByteCount;
1:         int bytesToRead = (int)Math.min(bytesToSend, dssMaxDataLength);
/////////////////////////////////////////////////////////////////////////
1: 
1:                           length * 2L,
/////////////////////////////////////////////////////////////////////////
1:                                          long leftToRead)
1:             throws DisconnectException {
1:         int nullIndicatorSize = writeNullByte ? 1 : 0;
1:         int extendedLengthByteCount = calculateExtendedLengthByteCount(
1:                     leftToRead + 4 + nullIndicatorSize);
1:         if ((10 + extendedLengthByteCount + nullIndicatorSize +
0:                 leftToRead + offset_) > DssConstants.MAX_DSS_LEN) {
/////////////////////////////////////////////////////////////////////////
0:     protected final int flushScalarStreamSegment(long leftToRead,
/////////////////////////////////////////////////////////////////////////
1:             newBytesToRead = (int)Math.min(leftToRead, 32765L);
/////////////////////////////////////////////////////////////////////////
0:     protected final void padScalarStreamForError(long leftToRead,
/////////////////////////////////////////////////////////////////////////
1:                                                long leftToRead,
1:         int nullIndicatorSize = writeNullByte ? 1 : 0;
1:             writeExtendedLengthBytes(
1:                     extendedLengthByteCount, leftToRead + nullIndicatorSize);
1:             if (SanityManager.DEBUG) {
1:                 SanityManager.ASSERT(leftToRead +4 + nullIndicatorSize <=
1:                         DssConstants.MAX_DSS_LEN);
1:             writeLengthCodePoint((int)(leftToRead + 4 + nullIndicatorSize),
1:                     codePoint);
commit:ccfada3
/////////////////////////////////////////////////////////////////////////
1:             // DERBY-4706
1:             // The network server doesn't support the security mechanisms above.
1:             // Further, the code in writeEncryptedScalarStream is/was in a bad
1:             // state.
1:             // Throw an exception for now until we're positive the code can be
1:             // ditched, later this comment/code itself can also be removed.
0:             throw new SqlException(netAgent_.logWriter_,
1:                     new ClientMessageId(SQLState.NOT_IMPLEMENTED),
1:                     "encrypted scalar streams");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:53795a1
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Writes a long into the buffer, using six bytes.
1:      *
1:      * @param v the value to write
1:      * @throws IllegalArgumentException if the long value is too large to be
1:      *      represented by six bytes.
1:      */
1:     final void writeLong6Bytes(long v) {
0:         ensureLength(offset_ + 6);
0:         org.apache.derby.client.am.SignedBinary.long6BytesToBigEndianBytes(
0:                 bytes_, offset_, v);
0:         offset_ += 6;
1:     }
1: 
commit:cf5cebf
/////////////////////////////////////////////////////////////////////////
0:     // WARNING: The code encrypting EXTDTA still has the problems described by
0:     //          DERBY-2017. The server doesn't support this security mechanism
0:     //          (see for instance DERBY-1345), and it is not clear whether this
0:     //          piece of code is ever used.
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 padScalarStreamForError(leftToRead, bytesToRead,
0:                         false, (byte)-1);
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Writes a stream with a known length onto the wire.
1:      * <p>
1:      * To avoid DRDA protocol exceptions, the data is truncated or padded as
1:      * required to complete the transfer. This can be avoided by implementing
1:      * the request abort mechanism specified by DRDA, but it is rather complex
1:      * and may not be worth the trouble.
1:      * <p>
1:      * Also note that any exceptions generated while writing the stream will
1:      * be accumulated and raised at a later time.
1:      *
1:      * @param length the byte length of the stream
1:      * @param in the stream to transfer
1:      * @param writeNullByte whether or not to write a NULL indicator
1:      * @param parameterIndex one-based parameter index
1:      * @throws DisconnectException if a severe error condition is encountered,
1:      *      causing the connection to be broken
1:      */
/////////////////////////////////////////////////////////////////////////
1:         // We don't have the metadata available when we create this request
1:         // object, so we have to check here if we are going to write the status
1:         // byte or not.
1:         final boolean writeEXTDTAStatusByte =
1:                 netAgent_.netConnection_.serverSupportsEXTDTAAbort();
1: 
1:         // If the Derby specific status byte is sent, the number of bytes to
1:         // send differs from the number of bytes to read (off by one byte).
0:         int bytesToSend = writeEXTDTAStatusByte ? leftToRead + 1 : leftToRead;
1:                                                        bytesToSend);
0:             bytesToRead = Math.min(bytesToSend, DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount);
0:             bytesToRead = Math.min(bytesToSend, DssConstants.MAX_DSS_LEN - 6 - 4 - extendedLengthByteCount);
1: 
1:         // If we are sending the status byte and we can send the user value as
1:         // one DSS, correct for the status byte (otherwise we read one byte too
1:         // much from the stream).
1:         if (writeEXTDTAStatusByte && bytesToRead == bytesToSend) {
1:             bytesToRead--;
1:         }
1: 
1:                                       bytesToSend,
1:         byte status = DRDAConstants.STREAM_OK;
1:                     status = DRDAConstants.STREAM_READ_ERROR;
1:                     padScalarStreamForError(leftToRead, bytesToRead,
1:                             writeEXTDTAStatusByte, status);
/////////////////////////////////////////////////////////////////////////
1:                     status = DRDAConstants.STREAM_TOO_SHORT;
0:                     padScalarStreamForError(leftToRead, bytesToRead,
1:                             writeEXTDTAStatusByte, status);
/////////////////////////////////////////////////////////////////////////
1:                 status = DRDAConstants.STREAM_TOO_LONG;
1:             status = DRDAConstants.STREAM_READ_ERROR;
/////////////////////////////////////////////////////////////////////////
1:         // Write the status byte to the send buffer.
1:         if (writeEXTDTAStatusByte) {
1:             writeEXTDTAStatus(status);
1:         }
1: 
1:     /**
1:      * Writes a stream with unknown length onto the wire.
1:      * <p>
1:      * To avoid DRDA protocol exceptions, the data is truncated or padded as
1:      * required to complete the transfer. This can be avoided by implementing
1:      * the request abort mechanism specified by DRDA, but it is rather complex
1:      * and may not be worth the trouble.
1:      * <p>
1:      * Also note that any exceptions generated while writing the stream will
1:      * be accumulated and raised at a later time.
1:      * <p>
1:      * <em>Implementation note:</em> This method does not support sending
1:      * values with a specified length using layer B streaming and at the same
1:      * time applying length checking. For large values layer B streaming may be
1:      * more efficient than using layer A streaming.
1:      *
1:      * @param in the stream to transfer
1:      * @param writeNullByte whether or not to write a NULL indicator
1:      * @param parameterIndex one-based parameter index
1:      * @throws DisconnectException if a severe error condition is encountered,
1:      *      causing the connection to be broken
1:      */
1:                                               int parameterIndex)
1:             throws DisconnectException {
1:         // We don't have the metadata available when we create this request
1:         // object, so we have to check here if we are going to write the status
1:         // byte or not.
1:         final boolean writeEXTDTAStatusByte =
1:                 netAgent_.netConnection_.serverSupportsEXTDTAAbort();
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (writeEXTDTAStatusByte) {
1:                 writeEXTDTAStatus(DRDAConstants.STREAM_READ_ERROR);
1:             }
/////////////////////////////////////////////////////////////////////////
1:         if (writeEXTDTAStatusByte) {
1:             writeEXTDTAStatus(DRDAConstants.STREAM_OK);
1:         }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Pads a value with zeros until it has reached its defined length.
1:      * <p>
1:      * This functionality was introduced to handle the error situation where
1:      * the actual length of the user stream is shorter than specified. To avoid
1:      * DRDA protocol errors (or in this case a hang), we have to pad the data
1:      * until the specified length has been reached. In a later increment the
1:      * Derby-specific EXTDTA status flag was introduced to allow the client to
1:      * inform the server that the value sent is invalid.
1:      *
1:      * @param leftToRead total number of bytes left to read
1:      * @param bytesToRead remaining bytes to read before flushing
1:      * @param writeStatus whether or not to wrote the Derby-specific trailing
1:      *      EXTDTA status flag (see DRDAConstants)
1:      * @param status the EXTDTA status (for this data value), ignored if
1:      *      {@code writeStatus} is {@code false}
1:      * @throws DisconnectException if flushing the buffer fails
1:      */
0:     protected final void padScalarStreamForError(int leftToRead,
1:                                                  int bytesToRead,
1:                                                  boolean writeStatus,
1:                                                  byte status)
1:             throws DisconnectException {
/////////////////////////////////////////////////////////////////////////
1: 
1:         // Append the EXTDTA status flag if appropriate.
1:         if (writeStatus) {
1:             writeEXTDTAStatus(status);
1:         }
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Writes the Derby-specific EXTDTA status flag to the send buffer.
1:      * <p>
1:      * The existing buffer is flushed to make space for the flag if required.
1:      *
1:      * @param flag the Derby-specific EXTDTA status flag
1:      * @throws DisconnectException if flushing the buffer fails
1:      */
1:     private void writeEXTDTAStatus(byte flag)
1:             throws DisconnectException {
1:         // Write the status byte to the send buffer.
1:         // Make sure we have enough space for the status byte.
0:         if (offset_ == bytes_.length) {
1:             flushScalarStreamSegment(1, 0); // Trigger a flush.
1:         }
0:         bytes_[offset_++] = flag;
1:         // The last byte will be sent on the next flush.
1:     }
commit:6391648
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			bytesToRead = Math.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount);
0: 			bytesToRead = Math.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - extendedLengthByteCount);
/////////////////////////////////////////////////////////////////////////
0: 			bytesToRead = Math.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount);
0: 			bytesToRead = Math.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - extendedLengthByteCount);
/////////////////////////////////////////////////////////////////////////
0:             if ((Math.min(2 + leftToRead, 32767)) > (bytes_.length - offset_)) {
/////////////////////////////////////////////////////////////////////////
0:             newBytesToRead = Math.min(leftToRead, 32765);
commit:f1567ea
/////////////////////////////////////////////////////////////////////////
1:         // RQSDSS header is 6 bytes long: (ll)(Cf)(rc)
1:         // Save the position of the length bytes, so they can be updated with a
1:         // different value at a later time.
1:         // Dummy values for the DSS length (token ll above).
1:         // The correct length will be inserted when the DSS is finalized.
1:         // Insert the mandatory 0xD0 (token C).
1:         // Insert the dssType (token f), which also tells if the DSS is chained
1:         // or not. See DSSFMT in the DRDA specification for details.
/////////////////////////////////////////////////////////////////////////
1:         // Write the request correlation id (two bytes, token rc).
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Signal the completion of a DSS Layer A object.
1:      * <p>
1:      * The length of the DSS object will be calculated based on the difference
1:      * between the start of the DSS, saved in the variable
1:      * {@link #dssLengthLocation_}, and the current offset into the buffer which
1:      * marks the end of the data.
1:      * <p>
1:      * In the event the length requires the use of continuation DSS headers,
1:      * one for each 32k chunk of data, the data will be shifted and the
1:      * continuation headers will be inserted with the correct values as needed.
1:      * Note: In the future, we may try to optimize this approach
1:      * in an attempt to avoid these shifts.
1:      */
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:fefd864
/////////////////////////////////////////////////////////////////////////
1: import java.io.BufferedInputStream;
0: import java.io.IOException;
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     final void writeScalarStream(boolean chained,
1:                                  boolean chainedWithSameCorrelator,
1:                                  int codePoint,
0:                                  java.io.InputStream in,
1:                                  boolean writeNullByte,
1:                                  int parameterIndex) throws DisconnectException, SqlException {
1:         
1:         writePlainScalarStream(chained,
1:                                chainedWithSameCorrelator,
1:                                codePoint,
1:                                in,
1:                                writeNullByte,
1:                                parameterIndex);
1:         
1: 	}
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     
/////////////////////////////////////////////////////////////////////////
0:     // We need to reuse the agent's sql exception accumulation mechanism
0:     // for this write exception, pad if the length is too big, and truncation if the length is too small
0: 	final private void writePlainScalarStream(boolean chained,
1:                                               boolean chainedWithSameCorrelator,
1:                                               int codePoint,
0:                                               java.io.InputStream in,
1:                                               boolean writeNullByte,
1:                                               int parameterIndex) throws DisconnectException, SqlException {
1: 		
1:         in = new BufferedInputStream( in );
1: 
1:         flushExistingDSS();
1: 		
0:         ensureLength( DssConstants.MAX_DSS_LEN );
1:         
1:         buildDss(true,
1:                  chained,
1:                  chainedWithSameCorrelator,
1:                  DssConstants.GDSFMT_OBJDSS,
1:                  correlationID_,
1:                  true);
1:         
1:         int spareInDss;
1:         
1: 		if (writeNullByte) {
0: 			spareInDss = DssConstants.MAX_DSS_LEN - 6 - 4 - 1;
1: 		} else {
0: 			spareInDss = DssConstants.MAX_DSS_LEN - 6 - 4;
1: 		}
1: 				
0: 		buildLengthAndCodePointForLob(codePoint,
0: 									  writeNullByte);
1:         
0:         try{
1:             
1:             int bytesRead = 0;
1:             
1:             while( ( bytesRead = 
0:                      in.read(bytes_, offset_, spareInDss )  
1:                      ) > -1 ) {
1:                 
1:                 spareInDss -= bytesRead;
0:                 offset_ += bytesRead;
1: 
1:                 if( spareInDss <= 0 ){
1:                     
1:                     if( ! peekStream( (  BufferedInputStream ) in ) )
1:                         break;
1:                     
1:                     flushScalarStreamSegment();
1:                     
0:                     bytes_[offset_++] = (byte) (0xff);
0:                     bytes_[offset_++] = (byte) (0xff);
1:                     
1:                     spareInDss = DssConstants.MAX_DSS_LEN - 2;
1:                     
1:                 }
1:                 
1:             }
1:             
1:             
0:         } catch (java.io.IOException e) {
1:             
1:             final SqlException sqlex = 
1:                 new SqlException(netAgent_.logWriter_,
0:                                  new ClientMessageId(SQLState.NET_IOEXCEPTION_ON_READ),
0:                                  new Integer(parameterIndex),
0:                                  e.getMessage(),
0:                                  e);
1: 
1:             netAgent_.accumulateReadException(sqlex);
1:             
0: 					return;
1:         }
1:         
1:         
1:         
0: 		// check to make sure that the specified length wasn't too small
1: 		try {
0: 			if (in.read() != -1) {
0: 				// set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
1: 
1:                 final SqlException sqlex = 
1:                     new SqlException(netAgent_.logWriter_,
0:                                      new ClientMessageId(SQLState.NET_INPUTSTREAM_LENGTH_TOO_SMALL),
0:                                      new Integer(parameterIndex));
1: 
1: 				netAgent_.accumulateReadException(sqlex);
1: 			}
0: 		} catch (java.io.IOException e) {
0: 			netAgent_.accumulateReadException(new SqlException(
0: 															   netAgent_.logWriter_,
0: 															   new ClientMessageId(
0: 																				   SQLState.NET_IOEXCEPTION_ON_STREAMLEN_VERIFICATION),
0: 															   new Integer(parameterIndex),
0: 															   e.getMessage(),
0: 															   e));
1: 		}
1: 	}
1: 
1: 
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     final void writeScalarStream(boolean chained,
1:                                  boolean chainedWithSameCorrelator,
1:                                  int codePoint,
0:                                  java.io.Reader r,
1:                                  boolean writeNullByte,
1:                                  int parameterIndex) throws DisconnectException, 
1:                                                             SqlException{
1:         writeScalarStream(chained,
1:                           chainedWithSameCorrelator,
1:                           codePoint,
1:                           EncodedInputStream.createUTF16BEStream(r),
1:                           writeNullByte,
1:                           parameterIndex);
1:     }
1:     
1:     
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected final void flushExistingDSS() throws DisconnectException {
1:         
1:         try {
1:             if (simpleDssFinalize) {
1:                 finalizeDssLength();
1:             } else {
1:                 finalizePreviousChainedDss(true);
1:             }
1:             sendBytes(netAgent_.getOutputStream());
0:         } catch (java.io.IOException e) {
1:             netAgent_.throwCommunicationsFailure(e);
1:         }
1:         
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     
0:     protected final int flushScalarStreamSegment() throws DisconnectException {
1:         
1:         try {
1:             sendBytes(netAgent_.getOutputStream());
0:         } catch (java.io.IOException ioe) {
1:             netAgent_.throwCommunicationsFailure(ioe);
1:         }
1:         
0:         dssLengthLocation_ = offset_;
1:         return DssConstants.MAX_DSS_LEN;
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     private void buildLengthAndCodePointForLob(int codePoint,
1:                                                boolean writeNullByte) throws DisconnectException {
1:         
1:         //0x8004 is for Layer B Streaming. 
1:         //See DRDA, Version 3, Volume 3: Distributed Data Management (DDM) Architecture page 315.
1:         writeLengthCodePoint(0x8004, codePoint);
1:         
1:         // write the null byte, if necessary
1:         if (writeNullByte) {
1:             write1Byte(0x0);
1:         }
1:         
1:     }
1:     
1:     
1:     
1:     
1:     
1:     private static boolean peekStream( BufferedInputStream in ) 
1:         throws IOException {
1:         
1:         in.mark( 1 );
1:         boolean notYet =  in.read() > -1;
1:         in.reset();
1:         return notYet;
1:         
1:     }
1: 
commit:8f0a531
/////////////////////////////////////////////////////////////////////////
0:     final private void writeEncryptedScalarStream(boolean chained,
1:                                                   boolean chainedWithSameCorrelator,
1:                                                   int codePoint,
1:                                                   int length,
0:                                                   java.io.InputStream in,
1:                                                   boolean writeNullByte,
1:                                                   int parameterIndex) throws DisconnectException, SqlException {
/////////////////////////////////////////////////////////////////////////
0: 	final private void writePlainScalarStream(boolean chained,
1:                                               boolean chainedWithSameCorrelator,
1:                                               int codePoint,
0:                                               int length,
0:                                               java.io.InputStream in,
1:                                               boolean writeNullByte,
0:                                               int parameterIndex) throws DisconnectException, SqlException {
commit:41674ac
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	
1: 	final void writeScalarStream(boolean chained,
1: 		
1: 		if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
1: 			netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA) {
1: 			
0: 			writeEncryptedScalarStream(chained,
1: 									   chainedWithSameCorrelator,
0: 									   codePoint,
0: 									   length,
0: 									   in,
0: 									   writeNullByte,
0: 									   parameterIndex);
0: 		}else{
1: 			
0: 			writePlainScalarStream(chained,
1: 								   chainedWithSameCorrelator,
0: 								   codePoint,
0: 								   length,
0: 								   in,
0: 								   writeNullByte,
0: 								   parameterIndex);
1: 			
1: 		}
1: 	}
0:     // We need to reuse the agent's sql exception accumulation mechanism
0:     // for this write exception, pad if the length is too big, and truncation if the length is too small
0:     final void writeEncryptedScalarStream(boolean chained,
1: 										  boolean chainedWithSameCorrelator,
1: 										  int codePoint,
0: 										  int length,
0: 										  java.io.InputStream in,
1: 										  boolean writeNullByte,
0: 										  int parameterIndex) throws DisconnectException, SqlException {
1:         
1: 
1: 			
0: 		int leftToRead = length;
0: 		int extendedLengthByteCount = prepScalarStream(chained,
1: 													   chainedWithSameCorrelator,
0: 													   writeNullByte,
0: 													   leftToRead);
0: 		int bytesToRead;
1: 
0: 		if (writeNullByte) {
0: 			bytesToRead = Utils.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount);
1: 		} else {
0: 			bytesToRead = Utils.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - extendedLengthByteCount);
1: 		}
1: 			
0: 		byte[] lengthAndCodepoint;
0: 		lengthAndCodepoint = buildLengthAndCodePointForEncryptedLob(codePoint,
0: 																	leftToRead,
0: 																	writeNullByte,
0: 																	extendedLengthByteCount);
0: 		// we need to stream the input, rather than fully materialize it
0: 		// write the data
0: 		byte[] clearedBytes = new byte[leftToRead];
0: 		int bytesRead = 0;
0: 		int totalBytesRead = 0;
0: 		int pos = 0;
1: 		do {
1: 			try {
0: 				bytesRead = in.read(clearedBytes, pos, leftToRead);
0: 				totalBytesRead += bytesRead;
0: 			} catch (java.io.IOException e) {
0: 				padScalarStreamForError(leftToRead, bytesToRead);
0: 				// set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0: 				netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0: 																   new ClientMessageId(SQLState.NET_IOEXCEPTION_ON_READ),
0: 																   new Integer(parameterIndex), e.getMessage(), e));
0: 				return;
1: 			}
0: 			if (bytesRead == -1) {
0: 				//padScalarStreamForError(leftToRead, bytesToRead);
0: 				// set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0: 				/*throw new SqlException(netAgent_.logWriter_,
0: 				  "End of Stream prematurely reached while reading InputStream, parameter #" +
0: 				  parameterIndex +
0: 				  ".  Remaining data has been padded with 0x0.");*/
0: 				//is it OK to do a chain break Exception here. It's not good to
0: 				//pad it with 0 and encrypt and send it to the server because it takes too much time
0: 				//can't just throw a SQLException either because some of the data PRPSQLSTT etc have already
0: 				//been sent to the server, and server is waiting for EXTDTA, server hangs for this.
0: 				netAgent_.accumulateChainBreakingReadExceptionAndThrow(
0: 																	   new DisconnectException(netAgent_,
0: 																							   new ClientMessageId(SQLState.NET_PREMATURE_EOS_DISCONNECT),
0: 																							   new Integer(parameterIndex)));
0: 				return;
0: 				/*netAgent_.accumulateReadException(
0: 				  new SqlException(netAgent_.logWriter_,
0: 				  "End of Stream prematurely reached while reading InputStream, parameter #" +
0: 				  parameterIndex +
0: 				  ".  Remaining data has been padded with 0x0."));
0: 				  return;*/
1: 			} else {
0: 				pos += bytesRead;
0: 				//offset_ += bytesRead;  //comment this out for data stream encryption.
0: 				leftToRead -= bytesRead;
1: 			}
1: 		} while (leftToRead > 0);
0: 		// check to make sure that the specified length wasn't too small
1: 		try {
0: 			if (in.read() != -1) {
0: 				// set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0: 				netAgent_.accumulateReadException(new SqlException(
0: 																   netAgent_.logWriter_,
0: 																   new ClientMessageId(SQLState.NET_INPUTSTREAM_LENGTH_TOO_SMALL),
0: 																   new Integer(parameterIndex)));
1: 			}
0: 		} catch (java.io.IOException e) {
0: 			netAgent_.accumulateReadException(new SqlException(
0: 															   netAgent_.logWriter_,
0: 															   new ClientMessageId(
0: 																				   SQLState.NET_IOEXCEPTION_ON_STREAMLEN_VERIFICATION),
0: 															   new Integer(parameterIndex), 
0: 															   e.getMessage(), 
0: 															   e));
1: 		}
0: 		byte[] newClearedBytes = new byte[clearedBytes.length +
0: 										  lengthAndCodepoint.length];
0: 		System.arraycopy(lengthAndCodepoint, 0, newClearedBytes, 0,
0: 						 lengthAndCodepoint.length);
0: 		System.arraycopy(clearedBytes, 0, newClearedBytes, lengthAndCodepoint.length, clearedBytes.length);
0: 		//it's wrong here, need to add in the real length after the codepoing 146c
0: 		byte[] encryptedBytes;
0: 		encryptedBytes = netAgent_.netConnection_.getEncryptionManager().
0: 			encryptData(newClearedBytes,
0: 						NetConfiguration.SECMEC_EUSRIDPWD,
0: 						netAgent_.netConnection_.getTargetPublicKey(),
0: 						netAgent_.netConnection_.getTargetPublicKey());
0: 		int encryptedBytesLength = encryptedBytes.length;
0: 		int sendingLength = bytes_.length - offset_;
0: 		if (encryptedBytesLength > (bytes_.length - offset_)) {
0: 			System.arraycopy(encryptedBytes, 0, bytes_, offset_, (bytes_.length - offset_));
0: 			offset_ = 32767;
1: 			try {
1: 				sendBytes(netAgent_.getOutputStream());
0: 			} catch (java.io.IOException ioe) {
1: 				netAgent_.throwCommunicationsFailure(ioe);
1: 			}
1: 		} else {
0: 			System.arraycopy(encryptedBytes, 0, bytes_, offset_, encryptedBytesLength);
0: 			offset_ = offset_ + encryptedBytes.length;
1: 		}
0: 		encryptedBytesLength = encryptedBytesLength - sendingLength;
0: 		while (encryptedBytesLength > 0) {
0: 			//dssLengthLocation_ = offset_;
0: 			offset_ = 0;
0: 			if ((encryptedBytesLength - 32765) > 0) {
0: 				bytes_[offset_++] = (byte) (0xff);
0: 				bytes_[offset_++] = (byte) (0xff);
0: 				System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, 32765);
0: 				encryptedBytesLength -= 32765;
0: 				sendingLength += 32765;
0: 				offset_ = 32767;
1: 				try {
1: 					sendBytes(netAgent_.getOutputStream());
0: 				} catch (java.io.IOException ioe) {
1: 					netAgent_.throwCommunicationsFailure(ioe);
1: 				}
1: 			} else {
0: 				int leftlength = encryptedBytesLength + 2;
0: 				bytes_[offset_++] = (byte) ((leftlength >>> 8) & 0xff);
0: 				bytes_[offset_++] = (byte) (leftlength & 0xff);
0: 				System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, encryptedBytesLength);
0: 				offset_ += encryptedBytesLength;
0: 				dssLengthLocation_ = offset_;
0: 				encryptedBytesLength = 0;
1: 			}
1: 		}
1: 	
1: 	
0: 	// We need to reuse the agent's sql exception accumulation mechanism
0:     // for this write exception, pad if the length is too big, and truncation if the length is too small
0: 	final void writePlainScalarStream(boolean chained,
1: 									  boolean chainedWithSameCorrelator,
1: 									  int codePoint,
0: 									  int length,
0: 									  java.io.InputStream in,
1: 									  boolean writeNullByte,
0: 									  int parameterIndex) throws DisconnectException, SqlException {
0: 		int leftToRead = length;
0: 		int extendedLengthByteCount = prepScalarStream(chained,
1: 													   chainedWithSameCorrelator,
0: 													   writeNullByte,
0: 													   leftToRead);
0: 		int bytesToRead;
1: 				
0: 		if (writeNullByte) {
0: 			bytesToRead = Utils.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount);
1: 		} else {
0: 			bytesToRead = Utils.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - extendedLengthByteCount);
1: 		}
1: 				
0: 		buildLengthAndCodePointForLob(codePoint,
0: 									  leftToRead,
0: 									  writeNullByte,
0: 									  extendedLengthByteCount);
1: 
0: 		int bytesRead = 0;
0: 		int totalBytesRead = 0;
1: 		do {
1: 			do {
1: 				try {
0: 					bytesRead = in.read(bytes_, offset_, bytesToRead);
0: 					totalBytesRead += bytesRead;
0: 				} catch (java.io.IOException e) {
0: 					padScalarStreamForError(leftToRead, bytesToRead);
0: 					// set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0: 					netAgent_.accumulateReadException(new SqlException(
0: 																	   netAgent_.logWriter_,
0: 																	   new ClientMessageId(SQLState.NET_IOEXCEPTION_ON_READ),
0: 																	   new Integer(parameterIndex),
0: 																	   e.getMessage(),
0: 																	   e));
1: 
0: 					return;
1: 				}
0: 				if (bytesRead == -1) {
0: 					padScalarStreamForError(leftToRead, bytesToRead);
0: 					// set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0: 					netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0: 																	   new ClientMessageId(SQLState.NET_PREMATURE_EOS),
0: 																	   new Integer(parameterIndex)));
0: 					return;
1: 				} else {
0: 					bytesToRead -= bytesRead;
0: 					offset_ += bytesRead;
0: 					leftToRead -= bytesRead;
1: 				}
1: 			} while (bytesToRead > 0);
1: 
1: 			bytesToRead = flushScalarStreamSegment(leftToRead, bytesToRead);
1: 		} while (leftToRead > 0);
1: 
0: 		// check to make sure that the specified length wasn't too small
1: 		try {
0: 			if (in.read() != -1) {
0: 				// set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0: 				netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0: 																   new ClientMessageId(SQLState.NET_INPUTSTREAM_LENGTH_TOO_SMALL),
0: 																   new Integer(parameterIndex)));
1: 			}
0: 		} catch (java.io.IOException e) {
0: 			netAgent_.accumulateReadException(new SqlException(
0: 															   netAgent_.logWriter_,
0: 															   new ClientMessageId(
0: 																				   SQLState.NET_IOEXCEPTION_ON_STREAMLEN_VERIFICATION),
0: 															   new Integer(parameterIndex),
0: 															   e.getMessage(),
0: 															   e));
1: 		}
1: 	}
1: 
commit:a1a1192
/////////////////////////////////////////////////////////////////////////
1:                                  int parameterIndex) throws DisconnectException, 
0: 															SqlException{
1:         
0: 		writeScalarStream(chained,
0: 						  chainedWithSameCorrelator,
0: 						  codePoint,
0: 						  length * 2,
0: 						  new UTF32BEEncodedInputStream( r ),
0: 						  writeNullByte,
0: 						  parameterIndex);
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6a925a3
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.NET_IOEXCEPTION_ON_READ),
0:                         new Integer(parameterIndex), e.getMessage(), e));
/////////////////////////////////////////////////////////////////////////
0:                     netAgent_.accumulateChainBreakingReadExceptionAndThrow(
0:                         new DisconnectException(netAgent_,
0:                             new ClientMessageId(SQLState.NET_PREMATURE_EOS_DISCONNECT),
0:                             new Integer(parameterIndex)));
/////////////////////////////////////////////////////////////////////////
0:                     netAgent_.accumulateReadException(new SqlException(
0:                         netAgent_.logWriter_,
0:                         new ClientMessageId(SQLState.NET_INPUTSTREAM_LENGTH_TOO_SMALL),
0:                         new Integer(parameterIndex)));
0:                 netAgent_.accumulateReadException(new SqlException(
0:                     netAgent_.logWriter_,
0:                     new ClientMessageId(
0:                         SQLState.NET_IOEXCEPTION_ON_STREAMLEN_VERIFICATION),
0:                     new Integer(parameterIndex), 
0:                     e.getMessage(), 
0:                     e));
/////////////////////////////////////////////////////////////////////////
0:                         netAgent_.accumulateReadException(new SqlException(
0:                             netAgent_.logWriter_,
0:                             new ClientMessageId(SQLState.NET_IOEXCEPTION_ON_READ),
0:                             new Integer(parameterIndex),
0:                             e.getMessage(),
0:                             e));
1: 
0:                             new ClientMessageId(SQLState.NET_PREMATURE_EOS),
0:                             new Integer(parameterIndex)));
/////////////////////////////////////////////////////////////////////////
0:                         new ClientMessageId(SQLState.NET_INPUTSTREAM_LENGTH_TOO_SMALL),
0:                         new Integer(parameterIndex)));
0:                 netAgent_.accumulateReadException(new SqlException(
0:                     netAgent_.logWriter_,
0:                     new ClientMessageId(
0:                         SQLState.NET_IOEXCEPTION_ON_STREAMLEN_VERIFICATION),
0:                     new Integer(parameterIndex),
0:                     e.getMessage(),
0:                     e));
/////////////////////////////////////////////////////////////////////////
0:                             netAgent_.accumulateReadException(new SqlException(
0:                                 netAgent_.logWriter_,
0:                                 new ClientMessageId(
0:                                     SQLState.NET_IOEXCEPTION_ON_READ),
0:                                 new Integer(parameterIndex),
0:                                 e.getMessage(),
0:                                 e));
1: 
0:                             netAgent_.accumulateReadException(new SqlException(
0:                                 netAgent_.logWriter_,
0:                                 new ClientMessageId(SQLState.NET_PREMATURE_EOS),
0:                                 new Integer(parameterIndex)));
1: 
/////////////////////////////////////////////////////////////////////////
0:                             netAgent_.accumulateReadException(new SqlException(
0:                                 netAgent_.logWriter_,
0:                                 new ClientMessageId(
0:                                     SQLState.NET_IOEXCEPTION_ON_READ),
0:                                 new Integer(parameterIndex),
0:                                 e.getMessage(),
0:                                 e));
1: 
0:                             netAgent_.accumulateReadException(new SqlException(
0:                                 netAgent_.logWriter_,
0:                                 new ClientMessageId(SQLState.NET_PREMATURE_EOS),
0:                                 new Integer(parameterIndex)));
1: 
/////////////////////////////////////////////////////////////////////////
0:                     netAgent_.accumulateReadException(new SqlException(
0:                         netAgent_.logWriter_,
0:                         new ClientMessageId(SQLState.NET_READER_LENGTH_TOO_SMALL),
0:                         new Integer(parameterIndex)));
0:                 netAgent_.accumulateReadException(new SqlException(
0:                     netAgent_.logWriter_,
0:                     new ClientMessageId(
0:                         SQLState.NET_IOEXCEPTION_ON_STREAMLEN_VERIFICATION),
0:                     new Integer(parameterIndex),
0:                     e.getMessage(),
0:                     e));
/////////////////////////////////////////////////////////////////////////
0:                     netAgent_.accumulateReadException(new SqlException(
0:                         netAgent_.logWriter_, 
0:                         new ClientMessageId(SQLState.NET_IOEXCEPTION_ON_READ),
0:                         new Integer(parameterIndex),
0:                         e.getMessage(),
0:                         e));
1: 
0:                     netAgent_.accumulateReadException(new SqlException(
0:                         netAgent_.logWriter_,
0:                         new ClientMessageId(SQLState.NET_PREMATURE_EOS),
0:                         new Integer(parameterIndex)));
1: 
/////////////////////////////////////////////////////////////////////////
0:                     netAgent_.accumulateReadException(new SqlException(
0:                         netAgent_.logWriter_,
0:                         new ClientMessageId(SQLState.NET_READER_LENGTH_TOO_SMALL),
0:                         new Integer(parameterIndex)));
0:                 netAgent_.accumulateReadException(new SqlException(
0:                     netAgent_.logWriter_, 
0:                     new ClientMessageId(
0:                         SQLState.NET_IOEXCEPTION_ON_STREAMLEN_VERIFICATION),
0:                     new Integer(parameterIndex),
0:                     e.getMessage(),
0:                     e));
/////////////////////////////////////////////////////////////////////////
0:         } catch (UnsupportedEncodingException e) {
0:             throw new SqlException(netAgent_.logWriter_,  
0:                     new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
0:                     "String", "byte", e);
0:             throw new SqlException(netAgent_.logWriter_, 
1:                 new ClientMessageId(SQLState.LANG_STRING_TOO_LONG),
1:                 "32767");
commit:1b39163
/////////////////////////////////////////////////////////////////////////
0:                     netAgent_.throwCommunicationsFailure(ioe);
/////////////////////////////////////////////////////////////////////////
0:                         netAgent_.throwCommunicationsFailure(ioe);
/////////////////////////////////////////////////////////////////////////
0:                     netAgent_.throwCommunicationsFailure(ioe);
/////////////////////////////////////////////////////////////////////////
0:                         netAgent_.throwCommunicationsFailure(ioe);
/////////////////////////////////////////////////////////////////////////
1:                 netAgent_.throwCommunicationsFailure(e);
/////////////////////////////////////////////////////////////////////////
0:                     netAgent_.throwCommunicationsFailure(ioe);
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.ClientMessageId;
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
/////////////////////////////////////////////////////////////////////////
0:                     new ClientMessageId(SQLState.UNSUPPORTED_ENCODING),
commit:5d2e2bd
/////////////////////////////////////////////////////////////////////////
0:         int length = org.apache.derby.client.am.Decimal.bigDecimalToPackedDecimalBytes(bytes_, offset_, v, declaredPrecision, declaredScale);
0:         offset_ += length;
0:         ensureLength(offset_ + 10);
0:         org.apache.derby.client.am.DateTime.dateToDateBytes(bytes_, offset_, date);
0:         offset_ += 10;
/////////////////////////////////////////////////////////////////////////
0:         ensureLength(offset_ + 26);
0:         org.apache.derby.client.am.DateTime.timestampToTimestampBytes(bytes_, offset_, timestamp);
0:         offset_ += 26;
commit:9f5bc90
/////////////////////////////////////////////////////////////////////////
1:                 dataByte -= dataToShift;
0:                 System.arraycopy(bytes_, dataByte + 1,bytes_, dataByte + shiftOffset + 1, dataToShift);
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.client.am.Utils;
0: public class Request {
1:     // byte array buffer used for constructing requests.
1:     // currently requests are built starting at the beginning of the buffer.
0:     protected byte[] bytes_;
0:     // keeps track of the next position to place a byte in the buffer.
0:     // so the last valid byte in the message is at bytes_[offset - 1]
0:     protected int offset_;
1:     // a stack is used to keep track of offsets into the buffer where 2 byte
1:     // ddm length values are located.  these length bytes will be automatically updated
1:     // by this object when construction of a particular object has completed.
1:     // right now the max size of the stack is 10. this is an arbitrary number which
1:     // should be sufficiently large enough to handle all situations.
1:     private final static int MAX_MARKS_NESTING = 10;
1:     private int[] markStack_ = new int[MAX_MARKS_NESTING];
1:     private int top_ = 0;
0:     // the ccsid manager for the connection is stored in this object.  it will
0:     // be used when constructing character ddm data.  it will NOT be used for
0:     // building any FDOCA data.
0:     protected CcsidManager ccsidManager_;
1:     //  This Object tracks the location of the current
1:     //  Dss header length bytes.  This is done so
1:     //  the length bytes can be automatically
1:     //  updated as information is added to this stream.
1:     private int dssLengthLocation_ = 0;
1:     // tracks the request correlation ID to use for commands and command objects.
1:     // this is automatically updated as commands are built and sent to the server.
1:     private int correlationID_ = 0;
1:     private boolean simpleDssFinalize = false;
1:     // Used to mask out password when trace is on.
1:     protected boolean passwordIncluded_ = false;
1:     protected int passwordStart_ = 0;
1:     protected int passwordLength_ = 0;
1:     protected NetAgent netAgent_;
1:     // construct a request object specifying the minimum buffer size
1:     // to be used to buffer up the built requests.  also specify the ccsid manager
1:     // instance to be used when building ddm character data.
0:     Request(NetAgent netAgent, int minSize, CcsidManager ccsidManager) {
1:         netAgent_ = netAgent;
0:         bytes_ = new byte[minSize];
0:         ccsidManager_ = ccsidManager;
1:         clearBuffer();
0:     // construct a request object specifying the ccsid manager instance
0:     // to be used when building ddm character data.  This will also create
0:     // a buffer using the default size (see final static DEFAULT_BUFFER_SIZE value).
0:     Request(NetAgent netAgent, CcsidManager ccsidManager, int bufferSize) {
0:         //this (netAgent, Request.DEFAULT_BUFFER_SIZE, ccsidManager);
0:         this(netAgent, bufferSize, ccsidManager);
0:     protected final void clearBuffer() {
0:         offset_ = 0;
1:         top_ = 0;
1:         for (int i = 0; i < markStack_.length; i++) {
1:             if (markStack_[i] != 0) {
1:                 markStack_[i] = 0;
0:             } else {
1:                 break;
1:             }
1:         }
1:         dssLengthLocation_ = 0;
1:     }
1:     final void initialize() {
1:         clearBuffer();
1:         correlationID_ = 0;
1:     }
0:     // set the ccsid manager value.  this method allows the ccsid manager to be
0:     // changed so a request object can be reused by different connections with
0:     // different ccsid managers.
0:     final void setCcsidMgr(CcsidManager ccsidManager) {
0:         ccsidManager_ = ccsidManager;
1:     }
1:     // ensure length at the end of the buffer for a certain amount of data.
1:     // if the buffer does not contain sufficient room for the data, the buffer
1:     // will be expanded by the larger of (2 * current size) or (current size + length).
1:     // the data from the previous buffer is copied into the larger buffer.
0:     protected final void ensureLength(int length) {
0:         if (length > bytes_.length) {
0:             byte newBytes[] = new byte[Math.max(bytes_.length << 1, length)];
0:             System.arraycopy(bytes_, 0, newBytes, 0, offset_);
0:             bytes_ = newBytes;
1:         }
1:     }
1: 
1:     // creates an request dss in the buffer to contain a ddm command
1:     // object.  calling this method means any previous dss objects in
1:     // the buffer are complete and their length and chaining bytes can
1:     // be updated appropriately.
1:     protected final void createCommand() {
1:         buildDss(false, false, false, DssConstants.GDSFMT_RQSDSS, ++correlationID_, false);
1:     }
1: 
1:     // creates an request dss in the buffer to contain a ddm command
1:     // object.  calling this method means any previous dss objects in
1:     // the buffer are complete and their length and chaining bytes can
1:     // be updated appropriately.
0:     protected void createXACommand() {
0:         buildDss(false, false, false, DssConstants.GDSFMT_RQSDSS_NOREPLY, ++correlationID_, false);
1:     }
1: 
1:     // creates an object dss in the buffer to contain a ddm command
1:     // data object.  calling this method means any previous dss objects in
1:     // the buffer are complete and their length and chaining bytes can
1:     // be updated appropriately.
1:     final void createCommandData() {
1:         buildDss(true,
1:     final void createEncryptedCommandData() {
1:         if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
1:                 netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA) {
1:             buildDss(true, false, false, DssConstants.GDSFMT_ENCOBJDSS, correlationID_, false);
0:         } else {
1:             buildDss(true,
1:                     false,
1:                     false,
1:                     DssConstants.GDSFMT_OBJDSS,
1:                     correlationID_,
1:                     false);
1:         }
1:     // experimental lob section
1:     private final void buildDss(boolean dssHasSameCorrelator,
1:                                 boolean chainedToNextStructure,
1:                                 boolean nextHasSameCorrelator,
1:                                 int dssType,
1:                                 int corrId,
1:                                 boolean simpleFinalizeBuildingNextDss) {
1:         if (doesRequestContainData()) {
1:             if (simpleDssFinalize) {
1:                 finalizeDssLength();
0:             } else {
1:                 finalizePreviousChainedDss(dssHasSameCorrelator);
1:             }
0:         ensureLength(offset_ + 6);
0:         // save the length position and skip
0:         // note: the length position is saved so it can be updated
0:         // with a different value later.
0:         // always turn on chaining flags... this is helpful for lobs...
0:         // these bytes will get rest if dss lengths are finalized.
0:         bytes_[offset_++] = (byte) 0xFF;
0:         bytes_[offset_++] = (byte) 0xFF;
0:         // insert the manditory 0xD0 and the dssType
0:         bytes_[offset_++] = (byte) 0xD0;
1:         if (chainedToNextStructure) {
1:             dssType |= DssConstants.GDSCHAIN;
1:             if (nextHasSameCorrelator) {
1:                 dssType |= DssConstants.GDSCHAIN_SAME_ID;
0:         bytes_[offset_++] = (byte) (dssType & 0xff);
0:         // write the request correlation id
1:         // use method that writes a short
0:         bytes_[offset_++] = (byte) ((corrId >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (corrId & 0xff);
1:         simpleDssFinalize = simpleFinalizeBuildingNextDss;
0:     // We need to reuse the agent's sql exception accumulation mechanism
0:     // for this write exception, pad if the length is too big, and truncation if the length is too small
0:     final void writeScalarStream(boolean chained,
0:                                  boolean chainedWithSameCorrelator,
0:                                  int codePoint,
0:                                  int length,
0:                                  java.io.InputStream in,
1:                                  boolean writeNullByte,
0:                                  int parameterIndex) throws DisconnectException, SqlException {
0:         int leftToRead = length;
0:         int extendedLengthByteCount = prepScalarStream(chained,
0:                 writeNullByte,
0:                 leftToRead);
0:         int bytesToRead;
0:         if (writeNullByte) {
0:             bytesToRead = Utils.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount);
0:         } else {
0:             bytesToRead = Utils.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - extendedLengthByteCount);
1:         if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
1:                 netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA) {
1: 
0:             byte[] lengthAndCodepoint;
0:             lengthAndCodepoint = buildLengthAndCodePointForEncryptedLob(codePoint,
0:                     leftToRead,
0:                     writeNullByte,
0:                     extendedLengthByteCount);
1: 
1: 
1: 
0:             // we need to stream the input, rather than fully materialize it
0:             // write the data
1: 
0:             byte[] clearedBytes = new byte[leftToRead];
0:             int bytesRead = 0;
0:             int totalBytesRead = 0;
0:             int pos = 0;
0:             do {
0:                 try {
0:                     bytesRead = in.read(clearedBytes, pos, leftToRead);
0:                     totalBytesRead += bytesRead;
0:                 } catch (java.io.IOException e) {
0:                     padScalarStreamForError(leftToRead, bytesToRead);
0:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                     netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                             "Encountered an IOException reading InputStream, parameter #" +
0:                             parameterIndex +
0:                             ".  Remaining data has been padded with 0x0. Message: " +
0:                             e.getMessage()));
0:                     return;
1:                 }
0:                 if (bytesRead == -1) {
0:                     //padScalarStreamForError(leftToRead, bytesToRead);
0:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                     /*throw new SqlException(netAgent_.logWriter_,
0:                         "End of Stream prematurely reached while reading InputStream, parameter #" +
0:                         parameterIndex +
0:                         ".  Remaining data has been padded with 0x0.");*/
0:                     //is it OK to do a chain break Exception here. It's not good to
0:                     //pad it with 0 and encrypt and send it to the server because it takes too much time
0:                     //can't just throw a SQLException either because some of the data PRPSQLSTT etc have already
0:                     //been sent to the server, and server is waiting for EXTDTA, server hangs for this.
0:                     netAgent_.accumulateChainBreakingReadExceptionAndThrow(new org.apache.derby.client.am.DisconnectException(netAgent_,
0:                             "End of Stream prematurely reached while reading InputStream, parameter #" +
0:                             parameterIndex +
0:                             ". "));
0:                     return;
1: 
0:                     /*netAgent_.accumulateReadException(
0:                         new SqlException(netAgent_.logWriter_,
0:                         "End of Stream prematurely reached while reading InputStream, parameter #" +
0:                         parameterIndex +
0:                         ".  Remaining data has been padded with 0x0."));
0:                     return;*/
0:                 } else {
0:                     pos += bytesRead;
0:                     //offset_ += bytesRead;  //comment this out for data stream encryption.
0:                     leftToRead -= bytesRead;
1:                 }
1: 
0:             } while (leftToRead > 0);
1: 
0:             // check to make sure that the specified length wasn't too small
0:             try {
0:                 if (in.read() != -1) {
0:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                     netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                             "The specified size of the InputStream, parameter #" +
0:                             parameterIndex +
0:                             ", is less than the actual InputStream length"));
1:                 }
0:             } catch (java.io.IOException e) {
0:                 netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                         "Encountered error in stream length verification for InputStream, parameter #" +
0:                         parameterIndex +
0:                         ".  Message: " + e.getMessage()));
1:             }
1: 
0:             byte[] newClearedBytes = new byte[clearedBytes.length +
0:                     lengthAndCodepoint.length];
0:             System.arraycopy(lengthAndCodepoint, 0, newClearedBytes, 0,
0:                     lengthAndCodepoint.length);
0:             System.arraycopy(clearedBytes, 0, newClearedBytes, lengthAndCodepoint.length, clearedBytes.length);
0:             //it's wrong here, need to add in the real length after the codepoing 146c
0:             byte[] encryptedBytes;
0:             encryptedBytes = netAgent_.netConnection_.getEncryptionManager().
0:                     encryptData(newClearedBytes,
0:                             NetConfiguration.SECMEC_EUSRIDPWD,
0:                             netAgent_.netConnection_.getTargetPublicKey(),
0:                             netAgent_.netConnection_.getTargetPublicKey());
1: 
0:             int encryptedBytesLength = encryptedBytes.length;
0:             int sendingLength = bytes_.length - offset_;
0:             if (encryptedBytesLength > (bytes_.length - offset_)) {
1: 
0:                 System.arraycopy(encryptedBytes, 0, bytes_, offset_, (bytes_.length - offset_));
0:                 offset_ = 32767;
0:                 try {
0:                     sendBytes(netAgent_.getOutputStream());
0:                 } catch (java.io.IOException ioe) {
0:                     netAgent_.throwCommunicationsFailure("Request.writeScalarStream(...,InputStream)",
0:                             "OutputStream.flush()",
0:                             ioe.getMessage(),
0:                             "*");
1:                 }
0:             } else {
0:                 System.arraycopy(encryptedBytes, 0, bytes_, offset_, encryptedBytesLength);
0:                 offset_ = offset_ + encryptedBytes.length;
1:             }
1: 
0:             encryptedBytesLength = encryptedBytesLength - sendingLength;
0:             while (encryptedBytesLength > 0) {
0:                 //dssLengthLocation_ = offset_;
0:                 offset_ = 0;
1: 
0:                 if ((encryptedBytesLength - 32765) > 0) {
0:                     bytes_[offset_++] = (byte) (0xff);
0:                     bytes_[offset_++] = (byte) (0xff);
0:                     System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, 32765);
0:                     encryptedBytesLength -= 32765;
0:                     sendingLength += 32765;
0:                     offset_ = 32767;
0:                     try {
0:                         sendBytes(netAgent_.getOutputStream());
0:                     } catch (java.io.IOException ioe) {
0:                         netAgent_.throwCommunicationsFailure("Request.writeScalarStream(...,InputStream)",
0:                                 "OutputStream.flush()",
0:                                 ioe.getMessage(),
0:                                 "*");
1:                     }
0:                 } else {
0:                     int leftlength = encryptedBytesLength + 2;
0:                     bytes_[offset_++] = (byte) ((leftlength >>> 8) & 0xff);
0:                     bytes_[offset_++] = (byte) (leftlength & 0xff);
1: 
0:                     System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, encryptedBytesLength);
1: 
0:                     offset_ += encryptedBytesLength;
0:                     dssLengthLocation_ = offset_;
0:                     encryptedBytesLength = 0;
1:                 }
1: 
1:             }
0:         } else //if not data strteam encryption
1:         {
0:             buildLengthAndCodePointForLob(codePoint,
0:                     leftToRead,
0:                     writeNullByte,
0:                     extendedLengthByteCount);
1: 
0:             int bytesRead = 0;
0:             int totalBytesRead = 0;
0:             do {
0:                 do {
0:                     try {
0:                         bytesRead = in.read(bytes_, offset_, bytesToRead);
0:                         totalBytesRead += bytesRead;
0:                     } catch (java.io.IOException e) {
0:                         padScalarStreamForError(leftToRead, bytesToRead);
0:                         // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                         netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                                 "Encountered an IOException reading InputStream, parameter #" + parameterIndex +
0:                                 ".  Remaining data has been padded with 0x0. Message: " + e.getMessage()));
0:                         return;
1:                     }
0:                     if (bytesRead == -1) {
0:                         padScalarStreamForError(leftToRead, bytesToRead);
0:                         // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                         netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                                 "End of Stream prematurely reached while reading InputStream, parameter #" + parameterIndex +
0:                                 ".  Remaining data has been padded with 0x0."));
0:                         return;
0:                     } else {
0:                         bytesToRead -= bytesRead;
0:                         offset_ += bytesRead;
0:                         leftToRead -= bytesRead;
1:                     }
0:                 } while (bytesToRead > 0);
1: 
0:                 bytesToRead = flushScalarStreamSegment(leftToRead, bytesToRead);
0:             } while (leftToRead > 0);
1: 
0:             // check to make sure that the specified length wasn't too small
0:             try {
0:                 if (in.read() != -1) {
0:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                     netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                             "The specified size of the InputStream, parameter #" + parameterIndex +
0:                             ", is less than the actual InputStream length"));
1:                 }
0:             } catch (java.io.IOException e) {
0:                 netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                         "Encountered error in stream length verification for InputStream, parameter #" + parameterIndex +
0:                         ".  Message: " + e.getMessage()));
1:             }
1: 
1:         }
1: 
1: 
1:     }
1: 
1:     // Throw DataTruncation, instead of closing connection if input size mismatches
1:     // An implication of this, is that we need to extend the chaining model
1:     // for writes to accomodate chained write exceptoins
0:     final void writeScalarStream(boolean chained,
0:                                  boolean chainedWithSameCorrelator,
0:                                  int codePoint,
0:                                  int length,
0:                                  java.io.Reader r,
1:                                  boolean writeNullByte,
0:                                  int parameterIndex) throws DisconnectException {
0:         int leftToRead = length * 2; // the bytes to read
0:         int extendedLengthByteCount = prepScalarStream(chained,
0:                 chainedWithSameCorrelator,
0:                 writeNullByte,
0:                 leftToRead);
0:         int bytesToRead;
1: 
0:         if (writeNullByte) {
0:             bytesToRead = Utils.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount);
0:         } else {
0:             bytesToRead = Utils.min(leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - extendedLengthByteCount);
1:         }
1: 
1: 
0:         if (netAgent_.netConnection_.getSecurityMechanism() != NetConfiguration.SECMEC_EUSRIDDTA &&
0:                 netAgent_.netConnection_.getSecurityMechanism() != NetConfiguration.SECMEC_EUSRPWDDTA) {
0:             buildLengthAndCodePointForLob(codePoint,
0:                     leftToRead,
0:                     writeNullByte,
0:                     extendedLengthByteCount);
1: 
1: 
0:             // write the data
0:             int charsRead = 0;
0:             boolean haveHalfChar = false;
0:             byte halfChar = (byte) 0x0;
0:             char[] buf = new char[1 + 32765 / 2]; // enough for one DSS segment
1: 
0:             do {
0:                 do {
0:                     // fill in a half-character if we have one from a previous segment
0:                     if (haveHalfChar) {
0:                         bytes_[offset_++] = halfChar;
1:                         bytesToRead--;
1:                         leftToRead--;
0:                         haveHalfChar = false;
1:                     }
1: 
0:                     if (bytesToRead == 1) {
0:                         try {
0:                             charsRead = r.read(buf, 0, 1);
0:                         } catch (java.io.IOException e) {
0:                             padScalarStreamForError(leftToRead, bytesToRead);
0:                             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                             netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                                     "Encountered an IOException reading Reader, parameter #" +
0:                                     parameterIndex +
0:                                     ".  Remaining data has been padded with 0x0. Message: " +
0:                                     e.getMessage()));
0:                             return;
1:                         }
0:                         if (charsRead == -1) {
0:                             padScalarStreamForError(leftToRead, bytesToRead);
0:                             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                             netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                                     "End of Stream prematurely reached while reading Reader, parameter #" +
0:                                     parameterIndex +
0:                                     ".  Remaining data has been padded with 0x0."));
0:                             return;
1:                         }
0:                         // set first half-char in buffer and save the other half for later
0:                         bytes_[offset_++] = (byte) (buf[0] >>> 8);
0:                         halfChar = (byte) buf[0];
0:                         haveHalfChar = true;
1:                         bytesToRead--;
1:                         leftToRead--;
0:                     } else if (bytesToRead != 0) {
0:                         try {
0:                             // read as many whole characters as needed to fill the buffer
0:                             // half characters are handled above
0:                             charsRead = r.read(buf, 0, bytesToRead / 2);
0:                         } catch (java.io.IOException e) {
0:                             padScalarStreamForError(leftToRead, bytesToRead);
0:                             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                             netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_, e,
0:                                     "Encountered an IOException reading Reader, parameter #" +
0:                                     parameterIndex +
0:                                     ".  Remaining data has been padded with 0x0. Message: " +
0:                                     e.getMessage()));
0:                             return;
1:                         }
1: 
0:                         if (charsRead == -1) {
0:                             padScalarStreamForError(leftToRead, bytesToRead);
0:                             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                             netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                                     "End of Stream prematurely reached while reading Reader, parameter #" +
0:                                     parameterIndex +
0:                                     ".  Remaining data has been padded with 0x0."));
0:                             return;
1:                         }
0:                         for (int i = 0; i < charsRead; i++) {
0:                             bytes_[offset_++] = (byte) (buf[i] >>> 8);
0:                             bytes_[offset_++] = (byte) (buf[i]);
1:                         }
1: 
0:                         bytesToRead -= 2 * charsRead;
0:                         leftToRead -= 2 * charsRead;
1:                     }
0:                 } while (bytesToRead > 0);
1: 
0:                 bytesToRead = flushScalarStreamSegment(leftToRead, bytesToRead);
0:             } while (leftToRead > 0);
1: 
0:             // check to make sure that the specified length wasn't too small
0:             try {
0:                 if (r.read() != -1) {
0:                     netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                             "The specified size of the Reader, parameter #" +
0:                             parameterIndex +
0:                             ", is less than the actual InputStream length"));
1:                 }
0:             } catch (java.io.IOException e) {
0:                 netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_, e,
0:                         "Encountered error in stream length verification for Reader, parameter #" +
0:                         parameterIndex + ".  Message: " + e.getMessage()));
1:             }
0:         } else {  //data stream encryption
1: 
0:             byte[] lengthAndCodepoint;
0:             lengthAndCodepoint = buildLengthAndCodePointForEncryptedLob(codePoint,
0:                     leftToRead,
0:                     writeNullByte,
0:                     extendedLengthByteCount);
1: 
0:             // write the data
0:             int charsRead = 0;
0:             char[] buf = new char[leftToRead / 2];
0:             byte[] clearedBytes = new byte[leftToRead];
0:             int pos = 0;
1: 
1: 
0:             do {
0:                 // fill in a half-character if we have one from a previous segment
1: 
0:                 try {
0:                     // read as many whole characters as needed to fill the buffer
0:                     // half characters are handled above
0:                     charsRead = r.read(buf, 0, leftToRead / 2);
0:                 } catch (java.io.IOException e) {
0:                     padScalarStreamForError(leftToRead, bytesToRead);
0:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                     netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_, e,
0:                             "Encountered an IOException reading Reader, parameter #" +
0:                             parameterIndex +
0:                             ".  Remaining data has been padded with 0x0. Message: " +
0:                             e.getMessage()));
0:                     return;
1:                 }
1: 
0:                 if (charsRead == -1) {
0:                     padScalarStreamForError(leftToRead, bytesToRead);
0:                     // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:                     netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                             "End of Stream prematurely reached while reading Reader, parameter #" +
0:                             parameterIndex +
0:                             ".  Remaining data has been padded with 0x0."));
0:                     return;
1:                 }
0:                 for (int i = 0; i < charsRead; i++) {
0:                     clearedBytes[pos++] = (byte) (buf[i] >>> 8);
0:                     clearedBytes[pos++] = (byte) (buf[i]);
1:                 }
1: 
0:                 bytesToRead -= 2 * charsRead;
0:                 leftToRead -= 2 * charsRead;
0:             } while (leftToRead > 0);
1: 
0:             // check to make sure that the specified length wasn't too small
0:             try {
0:                 if (r.read() != -1) {
0:                     netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_,
0:                             "The specified size of the Reader, parameter #" +
0:                             parameterIndex +
0:                             ", is less than the actual InputStream length"));
1:                 }
0:             } catch (java.io.IOException e) {
0:                 netAgent_.accumulateReadException(new SqlException(netAgent_.logWriter_, e,
0:                         "Encountered error in stream length verification for Reader, parameter #" +
0:                         parameterIndex + ".  Message: " + e.getMessage()));
1:             }
1: 
0:             byte[] newClearedBytes = new byte[clearedBytes.length +
0:                     lengthAndCodepoint.length];
0:             System.arraycopy(lengthAndCodepoint, 0, newClearedBytes, 0,
0:                     lengthAndCodepoint.length);
0:             System.arraycopy(clearedBytes, 0, newClearedBytes, lengthAndCodepoint.length, clearedBytes.length);
0:             int encryptedBytesLength = 0;
0:             byte[] encryptedBytes = null;
0:             try {
0:                 EncryptionManager encryptionMgr = netAgent_.netConnection_.getEncryptionManager();
0:                 byte[] publicKey = netAgent_.netConnection_.getTargetPublicKey();
0:                 encryptedBytes = encryptionMgr.encryptData(newClearedBytes,
0:                         NetConfiguration.SECMEC_EUSRIDPWD,
0:                         publicKey,
0:                         publicKey);
0:                 encryptedBytesLength = encryptedBytes.length;
0:             } catch (Exception e) {
0:                 e.printStackTrace();
1:             }
1: 
1: 
0:             int sendingLength = bytes_.length - offset_;
0:             if (encryptedBytesLength > bytes_.length - offset_) {
1: 
1: 
0:                 System.arraycopy(encryptedBytes, 0, bytes_, offset_, (bytes_.length - offset_));
0:                 offset_ = 32767;
0:                 try {
0:                     sendBytes(netAgent_.getOutputStream());
0:                 } catch (java.io.IOException ioe) {
0:                     netAgent_.throwCommunicationsFailure("Request.writeScalarStream(...,InputStream)",
0:                             "OutputStream.flush()",
0:                             ioe.getMessage(),
0:                             "*");
1:                 }
0:             } else {
0:                 System.arraycopy(encryptedBytes, 0, bytes_, offset_, encryptedBytesLength);
0:                 offset_ = offset_ + encryptedBytes.length;
1:             }
1: 
0:             encryptedBytesLength = encryptedBytesLength - sendingLength;
0:             while (encryptedBytesLength > 0) {
0:                 offset_ = 0;
1: 
0:                 if ((encryptedBytesLength - 32765) > 0) {
0:                     bytes_[offset_++] = (byte) (0xff);
0:                     bytes_[offset_++] = (byte) (0xff);
0:                     System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, 32765);
0:                     encryptedBytesLength -= 32765;
0:                     sendingLength += 32765;
0:                     offset_ = 32767;
0:                     try {
0:                         sendBytes(netAgent_.getOutputStream());
0:                     } catch (java.io.IOException ioe) {
0:                         netAgent_.throwCommunicationsFailure("Request.writeScalarStream(...,InputStream)",
0:                                 "OutputStream.flush()",
0:                                 ioe.getMessage(),
0:                                 "*");
1:                     }
0:                 } else {
0:                     int leftlength = encryptedBytesLength + 2;
0:                     bytes_[offset_++] = (byte) ((leftlength >>> 8) & 0xff);
0:                     bytes_[offset_++] = (byte) (leftlength & 0xff);
1: 
0:                     System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, encryptedBytesLength);
1: 
0:                     offset_ += encryptedBytesLength;
0:                     dssLengthLocation_ = offset_;
0:                     encryptedBytesLength = 0;
1:                 }
1: 
1:             }
1: 
1: 
1:         }
1:     }
1: 
1: 
1:     // prepScalarStream does the following prep for writing stream data:
1:     // 1.  Flushes an existing DSS segment, if necessary
1:     // 2.  Determines if extended length bytes are needed
1:     // 3.  Creates a new DSS/DDM header and a null byte indicator, if applicable
0:     protected final int prepScalarStream(boolean chained,
0:                                          boolean chainedWithSameCorrelator,
1:                                          boolean writeNullByte,
0:                                          int leftToRead) throws DisconnectException {
0:         int extendedLengthByteCount;
1: 
0:         int nullIndicatorSize = 0;
0:         if (writeNullByte) {
0:             // leftToRead is cast to (long) on the off chance that +4+1 pushes it outside the range of int
0:             extendedLengthByteCount = calculateExtendedLengthByteCount((long) leftToRead + 4 + 1);
0:             nullIndicatorSize = 1;
0:         } else {
0:             extendedLengthByteCount = calculateExtendedLengthByteCount(leftToRead + 4);
1:         }
1: 
1:         // flush the existing DSS segment if this stream will not fit in the send buffer
0:         // leftToRead is cast to (long) on the off chance that +4+1 pushes it outside the range of int
0:         if (10 + extendedLengthByteCount + nullIndicatorSize + (long) leftToRead + offset_ > DssConstants.MAX_DSS_LEN) {
0:             try {
1:                 if (simpleDssFinalize) {
1:                     finalizeDssLength();
0:                 } else {
1:                     finalizePreviousChainedDss(true);
1:                 }
0:                 sendBytes(netAgent_.getOutputStream());
0:             } catch (java.io.IOException e) {
0:                 netAgent_.throwCommunicationsFailure("Request.writeScalarStream(...,InputStream)",
0:                         "OutputStream.flush()",
0:                         e.getMessage(),
0:                         "*");
1:             }
1:         }
1: 
1:         if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
1:                 netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA) {
1:             buildDss(true,
1:                     chained,
0:                     chainedWithSameCorrelator,
1:                     DssConstants.GDSFMT_ENCOBJDSS,
1:                     correlationID_,
1:                     true);
1:         } else
1:         // buildDss should not call ensure length.
1:         {
1:             buildDss(true,
1:                     chained,
0:                     chainedWithSameCorrelator,
1:                     DssConstants.GDSFMT_OBJDSS,
1:                     correlationID_,
1:                     true);
1:         }
1: 
1:         return extendedLengthByteCount;
1:     }
1: 
1: 
1:     // Writes out a scalar stream DSS segment, along with DSS continuation headers,
1:     // if necessary.
0:     protected final int flushScalarStreamSegment(int leftToRead,
1:                                                  int bytesToRead) throws DisconnectException {
1:         int newBytesToRead = bytesToRead;
1: 
1:         // either at end of data, end of dss segment, or both.
1:         if (leftToRead != 0) {
1:             // 32k segment filled and not at end of data.
0:             if ((Utils.min(2 + leftToRead, 32767)) > (bytes_.length - offset_)) {
0:                 try {
0:                     sendBytes(netAgent_.getOutputStream());
0:                 } catch (java.io.IOException ioe) {
0:                     netAgent_.throwCommunicationsFailure("Request.writeScalarStream(...,InputStream)",
0:                             "OutputStream.flush()",
0:                             ioe.getMessage(),
0:                             "*");
1:                 }
1:             }
0:             dssLengthLocation_ = offset_;
0:             bytes_[offset_++] = (byte) (0xff);
0:             bytes_[offset_++] = (byte) (0xff);
0:             newBytesToRead = Utils.min(leftToRead, 32765);
1:         }
1: 
1:         return newBytesToRead;
1:     }
1: 
0:     // the offset_ must not be updated when an error is encountered
0:     // note valid data may be overwritten
0:     protected final void padScalarStreamForError(int leftToRead, int bytesToRead) throws DisconnectException {
0:         do {
0:             do {
0:                 bytes_[offset_++] = (byte) (0x0); // use 0x0 as the padding byte
1:                 bytesToRead--;
1:                 leftToRead--;
0:             } while (bytesToRead > 0);
1: 
0:             bytesToRead = flushScalarStreamSegment(leftToRead, bytesToRead);
0:         } while (leftToRead > 0);
1:     }
1: 
1:     private final void writeExtendedLengthBytes(int extendedLengthByteCount, long length) {
1:         int shiftSize = (extendedLengthByteCount - 1) * 8;
1:         for (int i = 0; i < extendedLengthByteCount; i++) {
0:             bytes_[offset_++] = (byte) ((length >>> shiftSize) & 0xff);
1:             shiftSize -= 8;
1:         }
1:     }
1: 
0:     private final byte[] writeExtendedLengthBytesForEncryption(int extendedLengthByteCount, long length) {
1:         int shiftSize = (extendedLengthByteCount - 1) * 8;
0:         byte[] extendedLengthBytes = new byte[extendedLengthByteCount];
1:         for (int i = 0; i < extendedLengthByteCount; i++) {
0:             extendedLengthBytes[i] = (byte) ((length >>> shiftSize) & 0xff);
1:             shiftSize -= 8;
1:         }
0:         return extendedLengthBytes;
1:     }
1: 
1:     // experimental lob section - end
1: 
1:     // used to finialize a dss which is already in the buffer
1:     // before another dss is built.  this includes updating length
1:     // bytes and chaining bits.
0:     protected final void finalizePreviousChainedDss(boolean dssHasSameCorrelator) {
1:         finalizeDssLength();
0:         bytes_[dssLengthLocation_ + 3] |= 0x40;
1:         if (dssHasSameCorrelator) // for blobs
1:         {
0:             bytes_[dssLengthLocation_ + 3] |= 0x10;
1:         }
1:     }
1: 
1:     // method to determine if any data is in the request.
1:     // this indicates there is a dss object already in the buffer.
0:     protected final boolean doesRequestContainData() {
0:         return offset_ != 0;
1:     }
1: 
0:     // signal the completion of a Dss Layer A object. The length of
0:     // dss object will be calculated based on the difference between the
0:     // start of the dss, saved on the beginDss call, and the current
0:     // offset into the buffer which marks the end of the data.  In the event
0:     // the length requires the use of continuation Dss headers, one for each 32k
0:     // chunk of data, the data will be shifted and the continuation headers
0:     // will be inserted with the correct values as needed.
0:     // Note: In the future, we may try to optimize this approach
0:     // in an attempt to avoid these shifts.
0:     protected final void finalizeDssLength() {
1:         // calculate the total size of the dss and the number of bytes which would
1:         // require continuation dss headers.  The total length already includes the
1:         // the 6 byte dss header located at the beginning of the dss.  It does not
1:         // include the length of any continuation headers.
0:         int totalSize = offset_ - dssLengthLocation_;
1:         int bytesRequiringContDssHeader = totalSize - 32767;
1: 
1:         // determine if continuation headers are needed
1:         if (bytesRequiringContDssHeader > 0) {
1: 
1:             // the continuation headers are needed, so calculate how many.
1:             // after the first 32767 worth of data, a continuation header is
1:             // needed for every 32765 bytes (32765 bytes of data + 2 bytes of
1:             // continuation header = 32767 Dss Max Size).
1:             int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
1:             if (bytesRequiringContDssHeader % 32765 != 0) {
1:                 contDssHeaderCount++;
1:             }
1: 
1:             // right now the code will shift to the right.  In the future we may want
1:             // to try something fancier to help reduce the copying (maybe keep
1:             // space in the beginning of the buffer??).
1:             // the offset points to the next available offset in the buffer to place
1:             // a piece of data, so the last dataByte is at offset -1.
1:             // various bytes will need to be shifted by different amounts
1:             // depending on how many dss headers to insert so the amount to shift
1:             // will be calculated and adjusted as needed.  ensure there is enough room
1:             // for all the conutinuation headers and adjust the offset to point to the
1:             // new end of the data.
0:             int dataByte = offset_ - 1;
1:             int shiftOffset = contDssHeaderCount * 2;
0:             ensureLength(offset_ + shiftOffset);
0:             offset_ += shiftOffset;
1: 
1:             // mark passOne to help with calculating the length of the final (first or
1:             // rightmost) continuation header.
1:             boolean passOne = true;
0:             do {
1:                 // calculate chunk of data to shift
1:                 int dataToShift = bytesRequiringContDssHeader % 32765;
1:                 if (dataToShift == 0) {
1:                     dataToShift = 32765;
1:                 }
1: 
1:                 // perform the shift
0:                 for (int i = 0; i < dataToShift; i++) {
0:                     bytes_[dataByte + shiftOffset] = bytes_[dataByte];
0:                     dataByte--;
1:                 }
1: 
1:                 // calculate the value the value of the 2 byte continuation dss header which
1:                 // includes the length of itself.  On the first pass, if the length is 32767
1:                 // we do not want to set the continuation dss header flag.
1:                 int twoByteContDssHeader = dataToShift + 2;
1:                 if (passOne) {
1:                     passOne = false;
0:                 } else {
1:                     if (twoByteContDssHeader == 32767) {
1:                         twoByteContDssHeader = 0xFFFF;
1:                     }
1:                 }
1: 
1:                 // insert the header's length bytes
0:                 bytes_[dataByte + shiftOffset - 1] = (byte) ((twoByteContDssHeader >>> 8) & 0xff);
0:                 bytes_[dataByte + shiftOffset] = (byte) (twoByteContDssHeader & 0xff);
1: 
1:                 // adjust the bytesRequiringContDssHeader and the amount to shift for
1:                 // data in upstream headers.
1:                 bytesRequiringContDssHeader -= dataToShift;
1:                 shiftOffset -= 2;
1: 
1:                 // shift and insert another header for more data.
1:             } while (bytesRequiringContDssHeader > 0);
1: 
1:             // set the continuation dss header flag on for the first header
1:             totalSize = 0xFFFF;
1: 
1:         }
1: 
1:         // insert the length bytes in the 6 byte dss header.
0:         bytes_[dssLengthLocation_] = (byte) ((totalSize >>> 8) & 0xff);
0:         bytes_[dssLengthLocation_ + 1] = (byte) (totalSize & 0xff);
1:     }
1: 
1:     // mark the location of a two byte ddm length field in the buffer,
1:     // skip the length bytes for later update, and insert a ddm codepoint
1:     // into the buffer.  The value of the codepoint is not checked.
1:     // this length will be automatically updated when construction of
1:     // the ddm object is complete (see updateLengthBytes method).
1:     // Note: this mechanism handles extended length ddms.
1:     protected final void markLengthBytes(int codePoint) {
0:         ensureLength(offset_ + 4);
1: 
1:         // save the location of length bytes in the mark stack.
1:         mark();
1: 
1:         // skip the length bytes and insert the codepoint
0:         offset_ += 2;
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
1:     }
1: 
1:     // mark an offest into the buffer by placing the current offset value on
1:     // a stack.
1:     private final void mark() {
0:         markStack_[top_++] = offset_;
1:     }
1: 
1:     // remove and return the top offset value from mark stack.
1:     private final int popMark() {
1:         return markStack_[--top_];
1:     }
1: 
1:     protected final void markForCachingPKGNAMCSN() {
1:         mark();
1:     }
1: 
1:     protected final int popMarkForCachingPKGNAMCSN() {
1:         return popMark();
1:     }
1: 
1:     // Called to update the last ddm length bytes marked (lengths are updated
1:     // in the reverse order that they are marked).  It is up to the caller
1:     // to make sure length bytes were marked before calling this method.
1:     // If the length requires ddm extended length bytes, the data will be
1:     // shifted as needed and the extended length bytes will be automatically
1:     // inserted.
1:     protected final void updateLengthBytes() throws SqlException {
1:         // remove the top length location offset from the mark stack\
1:         // calculate the length based on the marked location and end of data.
1:         int lengthLocation = popMark();
0:         int length = offset_ - lengthLocation;
1: 
1:         // determine if any extended length bytes are needed.  the value returned
1:         // from calculateExtendedLengthByteCount is the number of extended length
1:         // bytes required. 0 indicates no exteneded length.
1:         int extendedLengthByteCount = calculateExtendedLengthByteCount(length);
1:         if (extendedLengthByteCount != 0) {
1: 
1:             // ensure there is enough room in the buffer for the extended length bytes.
0:             ensureLength(offset_ + extendedLengthByteCount);
1: 
1:             // calculate the length to be placed in the extended length bytes.
1:             // this length does not include the 4 byte llcp.
1:             int extendedLength = length - 4;
1: 
1:             // shift the data to the right by the number of extended length bytes needed.
1:             int extendedLengthLocation = lengthLocation + 4;
0:             System.arraycopy(bytes_,
1:                     extendedLengthLocation,
0:                     bytes_,
1:                     extendedLengthLocation + extendedLengthByteCount,
1:                     extendedLength);
1: 
1:             // write the extended length
1:             int shiftSize = (extendedLengthByteCount - 1) * 8;
1:             for (int i = 0; i < extendedLengthByteCount; i++) {
0:                 bytes_[extendedLengthLocation++] = (byte) ((extendedLength >>> shiftSize) & 0xff);
1:                 shiftSize -= 8;
1:             }
1:             // adjust the offset to account for the shift and insert
0:             offset_ += extendedLengthByteCount;
1: 
1:             // the two byte length field before the codepoint contains the length
1:             // of itself, the length of the codepoint, and the number of bytes used
1:             // to hold the extended length.  the 2 byte length field also has the first
1:             // bit on to indicate extended length bytes were used.
1:             length = extendedLengthByteCount + 4;
1:             length |= 0x8000;
1:         }
1: 
1:         // write the 2 byte length field (2 bytes before codepoint).
0:         bytes_[lengthLocation] = (byte) ((length >>> 8) & 0xff);
0:         bytes_[lengthLocation + 1] = (byte) (length & 0xff);
1:     }
1: 
1:     // helper method to calculate the minimum number of extended length bytes needed
1:     // for a ddm.  a return value of 0 indicates no extended length needed.
1:     private final int calculateExtendedLengthByteCount(long ddmSize) //throws SqlException
1:     {
1:         // according to Jim and some tests perfomred on Lob data,
1:         // the extended length bytes are signed.  Assume that
1:         // if this is the case for Lobs, it is the case for
1:         // all extended length scenarios.
1:         if (ddmSize <= 0x7FFF) {
1:             return 0;
1:         } else if (ddmSize <= 0x7FFFFFFFL) {
1:             return 4;
1:         } else if (ddmSize <= 0x7FFFFFFFFFFFL) {
1:             return 6;
0:         } else {
1:             return 8;
1:         }
1:     }
1: 
1:     // insert the padByte into the buffer by length number of times.
0:     final void padBytes(byte padByte, int length) {
0:         ensureLength(offset_ + length);
1:         for (int i = 0; i < length; i++) {
0:             bytes_[offset_++] = padByte;
1:         }
1:     }
1: 
1:     // insert an unsigned single byte value into the buffer.
1:     final void write1Byte(int value) {
0:         ensureLength(offset_ + 1);
0:         bytes_[offset_++] = (byte) (value & 0xff);
1:     }
1: 
1:     // insert 3 unsigned bytes into the buffer.  this was
1:     // moved up from NetStatementRequest for performance
1:     final void buildTripletHeader(int tripletLength,
1:                                   int tripletType,
1:                                   int tripletId) {
0:         ensureLength(offset_ + 3);
0:         bytes_[offset_++] = (byte) (tripletLength & 0xff);
0:         bytes_[offset_++] = (byte) (tripletType & 0xff);
0:         bytes_[offset_++] = (byte) (tripletId & 0xff);
1:     }
1: 
0:     final void writeLidAndLengths(int[][] lidAndLengthOverrides, int count, int offset) {
0:         ensureLength(offset_ + (count * 3));
1:         for (int i = 0; i < count; i++, offset++) {
0:             bytes_[offset_++] = (byte) (lidAndLengthOverrides[offset][0] & 0xff);
0:             bytes_[offset_++] = (byte) ((lidAndLengthOverrides[offset][1] >>> 8) & 0xff);
0:             bytes_[offset_++] = (byte) (lidAndLengthOverrides[offset][1] & 0xff);
1:         }
1:     }
1: 
1:     // if mdd overrides are not required, lids and lengths are copied straight into the
1:     // buffer.
1:     // otherwise, lookup the protocolType in the map.  if an entry exists, substitute the
1:     // protocolType with the corresponding override lid.
1:     final void writeLidAndLengths(int[][] lidAndLengthOverrides,
1:                                   int count,
1:                                   int offset,
1:                                   boolean mddRequired,
0:                                   java.util.Hashtable map) {
1:         if (!mddRequired) {
1:             writeLidAndLengths(lidAndLengthOverrides, count, offset);
1:         }
1:         // if mdd overrides are required, lookup the protocolType in the map, and substitute
1:         // the protocolType with the override lid.
0:             ensureLength(offset_ + (count * 3));
1:             int protocolType, overrideLid;
1:             Object entry;
1:             for (int i = 0; i < count; i++, offset++) {
1:                 protocolType = lidAndLengthOverrides[offset][0];
1:                 // lookup the protocolType in the protocolType->overrideLid map
1:                 // if an entry exists, replace the protocolType with the overrideLid
0:                 entry = map.get(new Integer(protocolType));
1:                 overrideLid = (entry == null) ? protocolType : ((Integer) entry).intValue();
0:                 bytes_[offset_++] = (byte) (overrideLid & 0xff);
0:                 bytes_[offset_++] = (byte) ((lidAndLengthOverrides[offset][1] >>> 8) & 0xff);
0:                 bytes_[offset_++] = (byte) (lidAndLengthOverrides[offset][1] & 0xff);
1:             }
1:     // insert a big endian unsigned 2 byte value into the buffer.
1:     final void write2Bytes(int value) {
0:         ensureLength(offset_ + 2);
0:         bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (value & 0xff);
1:     // insert a big endian unsigned 4 byte value into the buffer.
1:     final void write4Bytes(long value) {
0:         ensureLength(offset_ + 4);
0:         bytes_[offset_++] = (byte) ((value >>> 24) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 16) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (value & 0xff);
1:     // copy length number of bytes starting at offset 0 of the byte array, buf,
1:     // into the buffer.  it is up to the caller to make sure buf has at least length
1:     // number of elements.  no checking will be done by this method.
1:     final void writeBytes(byte[] buf, int length) {
0:         ensureLength(offset_ + length);
0:         System.arraycopy(buf, 0, bytes_, offset_, length);
0:         offset_ += length;
1:     final void writeBytes(byte[] buf) {
0:         ensureLength(offset_ + buf.length);
0:         System.arraycopy(buf, 0, bytes_, offset_, buf.length);
0:         offset_ += buf.length;
1:     // insert a pair of unsigned 2 byte values into the buffer.
1:     final void writeCodePoint4Bytes(int codePoint, int value) {                                                      // should this be writeCodePoint2Bytes
0:         ensureLength(offset_ + 4);
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (value & 0xff);
1:     // insert a 4 byte length/codepoint pair and a 1 byte unsigned value into the buffer.
1:     // total of 5 bytes inserted in buffer.
1:     protected final void writeScalar1Byte(int codePoint, int value) {
0:         ensureLength(offset_ + 5);
0:         bytes_[offset_++] = 0x00;
0:         bytes_[offset_++] = 0x05;
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         bytes_[offset_++] = (byte) (value & 0xff);
1:     // insert a 4 byte length/codepoint pair and a 2 byte unsigned value into the buffer.
1:     // total of 6 bytes inserted in buffer.
1:     final void writeScalar2Bytes(int codePoint, int value) {
0:         ensureLength(offset_ + 6);
0:         bytes_[offset_++] = 0x00;
0:         bytes_[offset_++] = 0x06;
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (value & 0xff);
1: 
1:     // insert a 4 byte length/codepoint pair and a 4 byte unsigned value into the
1:     // buffer.  total of 8 bytes inserted in the buffer.
1:     protected final void writeScalar4Bytes(int codePoint, long value) {
0:         ensureLength(offset_ + 8);
0:         bytes_[offset_++] = 0x00;
0:         bytes_[offset_++] = 0x08;
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 24) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 16) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (value & 0xff);
1:     }
1: 
1:     // insert a 4 byte length/codepoint pair and a 8 byte unsigned value into the
1:     // buffer.  total of 12 bytes inserted in the buffer.
1:     final void writeScalar8Bytes(int codePoint, long value) {
0:         ensureLength(offset_ + 12);
0:         bytes_[offset_++] = 0x00;
0:         bytes_[offset_++] = 0x0C;
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 56) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 48) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 40) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 32) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 24) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 16) & 0xff);
0:         bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (value & 0xff);
1:     }
1: 
1:     // insert a 4 byte length/codepoint pair into the buffer.
1:     // total of 4 bytes inserted in buffer.
1:     // Note: the length value inserted in the buffer is the same as the value
1:     // passed in as an argument (this value is NOT incremented by 4 before being
1:     // inserted).
1:     final void writeLengthCodePoint(int length, int codePoint) {
0:         ensureLength(offset_ + 4);
0:         bytes_[offset_++] = (byte) ((length >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (length & 0xff);
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
1:     }
1: 
0:     final byte[] writeEXTDTALengthCodePointForEncryption(int length, int codePoint) {
0:         //how to encure length and offset later?
0:         byte[] clearedBytes = new byte[4];
0:         clearedBytes[0] = (byte) ((length >>> 8) & 0xff);
0:         clearedBytes[1] = (byte) (length & 0xff);
0:         clearedBytes[2] = (byte) ((codePoint >>> 8) & 0xff);
0:         clearedBytes[3] = (byte) (codePoint & 0xff);
0:         return clearedBytes;
1:     }
1: 
0:     // insert a 4 byte length/codepoint pair into the buffer followed
0:     // by length number of bytes copied from array buf starting at offset 0.
0:     // the length of this scalar must not exceed the max for the two byte length
0:     // field.  This method does not support extended length.  The length
0:     // value inserted in the buffer includes the number of bytes to copy plus
0:     // the size of the llcp (or length + 4). It is up to the caller to make sure
0:     // the array, buf, contains at least length number of bytes.
0:     final void writeScalarBytes(int codePoint, byte[] buf, int length) {
0:         ensureLength(offset_ + length + 4);
0:         bytes_[offset_++] = (byte) (((length + 4) >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) ((length + 4) & 0xff);
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
1:         for (int i = 0; i < length; i++) {
0:             bytes_[offset_++] = buf[i];
1:     // insert a 4 byte length/codepoint pair into the buffer.
1:     // total of 4 bytes inserted in buffer.
0:     // Note: datalength will be incremented by the size of the llcp, 4,
0:     // before being inserted.
0:     final void writeScalarHeader(int codePoint, int dataLength) {
0:         ensureLength(offset_ + dataLength + 4);
0:         bytes_[offset_++] = (byte) (((dataLength + 4) >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) ((dataLength + 4) & 0xff);
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     // insert a 4 byte length/codepoint pair plus ddm character data into
0:     // the buffer.  This method assumes that the String argument can be
0:     // converted by the ccsid manager.  This should be fine because usually
0:     // there are restrictions on the characters which can be used for ddm
0:     // character data. This method also assumes that the string.length() will
0:     // be the number of bytes following the conversion.
0:     // The two byte length field will contain the length of the character data
0:     // and the length of the 4 byte llcp.  This method does not handle
0:     // scenarios which require extended length bytes.
1:     final void writeScalarString(int codePoint, String string) throws SqlException {
0:         int stringLength = string.length();
0:         ensureLength(offset_ + stringLength + 4);
0:         bytes_[offset_++] = (byte) (((stringLength + 4) >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) ((stringLength + 4) & 0xff);
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         offset_ = ccsidManager_.convertFromUCS2(string, bytes_, offset_, netAgent_);
0:     // insert a 4 byte length/codepoint pair plus ddm character data into the
0:     // buffer.  The ddm character data is padded if needed with the ccsid manager's
0:     // space character if the length of the character data is less than paddedLength.
0:     // Note: this method is not to be used for String truncation and the string length
1:     // must be <= paddedLength.
0:     // This method assumes that the String argument can be
0:     // converted by the ccsid manager.  This should be fine because usually
0:     // there are restrictions on the characters which can be used for ddm
0:     // character data. This method also assumes that the string.length() will
0:     // be the number of bytes following the conversion.  The two byte length field
0:     // of the llcp will contain the length of the character data including the pad
0:     // and the length of the llcp or 4.  This method will not handle extended length
0:     // scenarios.
0:     final void writeScalarPaddedString(int codePoint, String string, int paddedLength) throws SqlException {
0:         int stringLength = string.length();
0:         ensureLength(offset_ + paddedLength + 4);
0:         bytes_[offset_++] = (byte) (((paddedLength + 4) >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) ((paddedLength + 4) & 0xff);
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         offset_ = ccsidManager_.convertFromUCS2(string, bytes_, offset_, netAgent_);
0:         for (int i = 0; i < paddedLength - stringLength; i++) {
0:             bytes_[offset_++] = ccsidManager_.space_;
1:         }
1:     }
0:     // this method inserts ddm character data into the buffer and pad's the
0:     // data with the ccsid manager's space character if the character data length
0:     // is less than paddedLength.
0:     // Not: this method is not to be used for String truncation and the string length
1:     // must be <= paddedLength.
0:     // This method assumes that the String argument can be
0:     // converted by the ccsid manager.  This should be fine because usually
0:     // there are restrictions on the characters which can be used for ddm
0:     // character data. This method also assumes that the string.length() will
0:     // be the number of bytes following the conversion.
0:     final void writeScalarPaddedString(String string, int paddedLength) throws SqlException {
0:         int stringLength = string.length();
0:         ensureLength(offset_ + paddedLength);
0:         offset_ = ccsidManager_.convertFromUCS2(string, bytes_, offset_, netAgent_);
0:         for (int i = 0; i < paddedLength - stringLength; i++) {
0:             bytes_[offset_++] = ccsidManager_.space_;
1:         }
1:     }
1:     // this method writes a 4 byte length/codepoint pair plus the bytes contained
1:     // in array buff to the buffer.
1:     // the 2 length bytes in the llcp will contain the length of the data plus
1:     // the length of the llcp.  This method does not handle scenarios which
1:     // require extended length bytes.
1:     final void writeScalarBytes(int codePoint, byte[] buff) {
0:         int buffLength = buff.length;
0:         ensureLength(offset_ + buffLength + 4);
0:         bytes_[offset_++] = (byte) (((buffLength + 4) >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) ((buffLength + 4) & 0xff);
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         System.arraycopy(buff, 0, bytes_, offset_, buffLength);
0:         offset_ += buffLength;
1:     }
1: 
1:     // this method inserts a 4 byte length/codepoint pair plus length number of bytes
1:     // from array buff starting at offset start.
1:     // Note: no checking will be done on the values of start and length with respect
1:     // the actual length of the byte array.  The caller must provide the correct
1:     // values so an array index out of bounds exception does not occur.
1:     // the length will contain the length of the data plus the length of the llcp.
1:     // This method does not handle scenarios which require extended length bytes.
1:     final void writeScalarBytes(int codePoint, byte[] buff, int start, int length) {
0:         ensureLength(offset_ + length + 4);
0:         bytes_[offset_++] = (byte) (((length + 4) >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) ((length + 4) & 0xff);
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         System.arraycopy(buff, start, bytes_, offset_, length);
0:         offset_ += length;
1:     }
1: 
0:     // insert a 4 byte length/codepoint pair plus ddm binary data into the
0:     // buffer.  The binary data is padded if needed with the padByte
0:     // if the data is less than paddedLength.
0:     // Note: this method is not to be used for truncation and buff.length
1:     // must be <= paddedLength.
0:     // The llcp length bytes will contain the length of the data plus
0:     // the length of the llcp or 4.
1:     // This method does not handle scenarios which require extended length bytes.
0:     final void writeScalarPaddedBytes(int codePoint, byte[] buff, int paddedLength, byte padByte) {
0:         int buffLength = buff.length;
0:         ensureLength(offset_ + paddedLength + 4);
0:         bytes_[offset_++] = (byte) (((paddedLength + 4) >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) ((paddedLength + 4) & 0xff);
0:         bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (codePoint & 0xff);
0:         System.arraycopy(buff, 0, bytes_, offset_, buffLength);
0:         offset_ += buffLength;
1: 
0:         for (int i = 0; i < paddedLength - buffLength; i++) {
0:             bytes_[offset_++] = padByte;
1:         }
1:     }
1: 
1:     // this method inserts binary data into the buffer and pads the
1:     // data with the padByte if the data length is less than the paddedLength.
1:     // Not: this method is not to be used for truncation and buff.length
1:     // must be <= paddedLength.
1:     final void writeScalarPaddedBytes(byte[] buff, int paddedLength, byte padByte) {
0:         int buffLength = buff.length;
0:         ensureLength(offset_ + paddedLength);
0:         System.arraycopy(buff, 0, bytes_, offset_, buffLength);
0:         offset_ += buffLength;
1: 
0:         for (int i = 0; i < paddedLength - buffLength; i++) {
0:             bytes_[offset_++] = padByte;
1:         }
1:     }
1: 
1:     // write the request to the OutputStream and flush the OutputStream.
1:     // trace the send if PROTOCOL trace is on.
0:     protected void flush(java.io.OutputStream socketOutputStream) throws java.io.IOException {
1:         if (doesRequestContainData()) {
1:             finalizeDssLength();
1:             sendBytes(socketOutputStream);
1:         }
1:     }
1: 
0:     protected void sendBytes(java.io.OutputStream socketOutputStream) throws java.io.IOException {
0:         try {
0:             socketOutputStream.write(bytes_, 0, offset_);
1:             socketOutputStream.flush();
1:         } finally {
1:             if (netAgent_.logWriter_ != null && passwordIncluded_) {
1:                 // if password is in the buffer, need to mask it out.
1:                 maskOutPassword();
1:                 passwordIncluded_ = false;
1:             }
1:             if (netAgent_.loggingEnabled()) {
0:                 ((NetLogWriter) netAgent_.logWriter_).traceProtocolFlow(bytes_,
1:                         0,
0:                         offset_,
1:                         NetLogWriter.TYPE_TRACE_SEND,
1:                         "Request",
1:                         "flush",
1:                         1); // tracepoint
1:             }
1:             clearBuffer();
1:         }
1:     }
1: 
0:     final void maskOutPassword() {
0:         try {
1:             String maskChar = "*";
1:             // construct a mask using the maskChar.
1:             StringBuffer mask = new StringBuffer();
1:             for (int i = 0; i < passwordLength_; i++) {
1:                 mask.append(maskChar);
1:             }
1:             // try to write mask over password.
0:             ccsidManager_.convertFromUCS2(mask.toString(), bytes_, passwordStart_, netAgent_);
1:         } catch (SqlException sqle) {
1:             // failed to convert mask,
1:             // them simply replace with 0xFF.
1:             for (int i = 0; i < passwordLength_; i++) {
0:                 bytes_[passwordStart_ + i] = (byte) 0xFF;
1:             }
1:         }
1:     }
1: 
1:     // insert a java byte into the buffer.
0:     final void writeByte(byte v) {
0:         ensureLength(offset_ + 1);
0:         bytes_[offset_++] = v;
1:     }
1: 
1:     // insert a java short into the buffer.
1:     final void writeShort(short v) {
0:         ensureLength(offset_ + 2);
0:         org.apache.derby.client.am.SignedBinary.shortToBigEndianBytes(bytes_, offset_, v);
0:         offset_ += 2;
1:     }
1: 
1:     // insert a java int into the buffer.
1:     void writeInt(int v) {
0:         ensureLength(offset_ + 4);
0:         org.apache.derby.client.am.SignedBinary.intToBigEndianBytes(bytes_, offset_, v);
0:         offset_ += 4;
1:     }
1: 
1:     // insert a java long into the buffer.
1:     final void writeLong(long v) {
0:         ensureLength(offset_ + 8);
0:         org.apache.derby.client.am.SignedBinary.longToBigEndianBytes(bytes_, offset_, v);
0:         offset_ += 8;
1:     }
1: 
1:     //-- The following are the write short/int/long in bigEndian byte ordering --
1: 
1:     // when writing Fdoca data.
1:     protected void writeShortFdocaData(short v) {
0:         ensureLength(offset_ + 2);
0:         org.apache.derby.client.am.SignedBinary.shortToBigEndianBytes(bytes_, offset_, v);
0:         offset_ += 2;
1:     }
1: 
1:     // when writing Fdoca data.
1:     protected void writeIntFdocaData(int v) {
0:         ensureLength(offset_ + 4);
0:         org.apache.derby.client.am.SignedBinary.intToBigEndianBytes(bytes_, offset_, v);
0:         offset_ += 4;
1:     }
1: 
1:     // when writing Fdoca data.
1:     protected void writeLongFdocaData(long v) {
0:         ensureLength(offset_ + 8);
0:         org.apache.derby.client.am.SignedBinary.longToBigEndianBytes(bytes_, offset_, v);
0:         offset_ += 8;
1:     }
1: 
1:     // insert a java float into the buffer.
1:     protected void writeFloat(float v) {
0:         ensureLength(offset_ + 4);
0:         org.apache.derby.client.am.FloatingPoint.floatToIeee754Bytes(bytes_, offset_, v);
0:         offset_ += 4;
1:     }
1: 
1:     // insert a java double into the buffer.
1:     protected void writeDouble(double v) {
0:         ensureLength(offset_ + 8);
0:         org.apache.derby.client.am.FloatingPoint.doubleToIeee754Bytes(bytes_, offset_, v);
0:         offset_ += 8;
1:     }
1: 
1:     // insert a java.math.BigDecimal into the buffer.
0:     final void writeBigDecimal(java.math.BigDecimal v,
1:                                int declaredPrecision,
1:                                int declaredScale) throws SqlException {
0:         ensureLength(offset_ + 16);
0:         try {
0:             int length = org.apache.derby.client.am.Decimal.bigDecimalToPackedDecimalBytes(bytes_, offset_, v, declaredPrecision, declaredScale);
0:             offset_ += length;
0:         } catch (org.apache.derby.client.am.ConversionException e) {
0:             throw new SqlException(netAgent_.logWriter_, e,
0:                     "BigDecimal conversion exception " + e.getMessage() + ". See attached Throwable.");
1:         }
1:     }
1: 
0:     final void writeDate(java.sql.Date date) throws SqlException {
0:         try {
0:             ensureLength(offset_ + 10);
0:             org.apache.derby.client.am.DateTime.dateToDateBytes(bytes_, offset_, date);
0:             offset_ += 10;
0:         } catch (org.apache.derby.client.am.ConversionException e) {
0:             throw new SqlException(netAgent_.logWriter_, e,
0:                     "Date conversion exception " + e.getMessage() + ". See attached Throwable.");
1:         }
1:     }
1: 
0:     final void writeTime(java.sql.Time time) throws SqlException {
0:         ensureLength(offset_ + 8);
0:         org.apache.derby.client.am.DateTime.timeToTimeBytes(bytes_, offset_, time);
0:         offset_ += 8;
1:     }
1: 
0:     final void writeTimestamp(java.sql.Timestamp timestamp) throws SqlException {
0:         try {
0:             ensureLength(offset_ + 26);
0:             org.apache.derby.client.am.DateTime.timestampToTimestampBytes(bytes_, offset_, timestamp);
0:             offset_ += 26;
0:         } catch (org.apache.derby.client.am.ConversionException e) {
0:             throw new SqlException(netAgent_.logWriter_, e,
0:                     "Timestamp conversion exception " + e.getMessage() + ". See attached Throwable.");
1:         }
1:     }
1: 
1:     // insert a java boolean into the buffer.  the boolean is written
1:     // as a signed byte having the value 0 or 1.
1:     final void writeBoolean(boolean v) {
0:         ensureLength(offset_ + 1);
0:         bytes_[offset_++] = (byte) ((v ? 1 : 0) & 0xff);
1:     }
1: 
1:     // follows the TYPDEF rules (note: don't think ddm char data is ever length
1:     // delimited)
1:     // should this throw SqlException
1:     // Will write a varchar mixed or single
1:     //  this was writeLDString
0:     final void writeSingleorMixedCcsidLDString(String s, String encoding) throws SqlException {
0:         byte[] b;
0:         try {
0:             b = s.getBytes(encoding);
0:         } catch (java.io.UnsupportedEncodingException e) {
0:             throw new SqlException(netAgent_.logWriter_, e,
0:                     "Unsupported encoding " + e.getMessage() + ". See attached Throwable.");
1:         }
1:         if (b.length > 0x7FFF) {
0:             throw new SqlException(netAgent_.logWriter_, "string exceed maximum length 32767");
1:         }
0:         ensureLength(offset_ + b.length + 2);
0:         writeLDBytesX(b.length, b);
1:     }
1: 
1: 
1:     final void writeLDBytes(byte[] bytes) {
0:         ensureLength(offset_ + bytes.length + 2);
1:         writeLDBytesX(bytes.length, bytes);
1:     }
1: 
1:     // private helper method which should only be called by a Request method.
1:     // must call ensureLength before calling this method.
1:     // added for code reuse and helps perf by reducing ensureLength calls.
1:     // ldSize and bytes.length may not be the same.  this is true
1:     // when writing graphic ld strings.
1:     private final void writeLDBytesX(int ldSize, byte[] bytes) {
0:         bytes_[offset_++] = (byte) ((ldSize >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (ldSize & 0xff);
0:         System.arraycopy(bytes, 0, bytes_, offset_, bytes.length);
0:         offset_ += bytes.length;
1:     }
1: 
0:     // does it follows
0:     // ccsid manager or typdef rules.  should this method write ddm character
0:     // data or fodca data right now it is coded for ddm char data only
0:     final void writeDDMString(String s) throws SqlException {
0:         ensureLength(offset_ + s.length());
0:         offset_ = ccsidManager_.convertFromUCS2(s, bytes_, offset_, netAgent_);
1:     }
1: 
1: 
0:     private byte[] buildLengthAndCodePointForEncryptedLob(int codePoint,
0:                                                           int leftToRead,
1:                                                           boolean writeNullByte,
1:                                                           int extendedLengthByteCount) throws DisconnectException {
0:         byte[] lengthAndCodepoint = new byte[4];
0:         byte[] extendedLengthBytes = new byte[extendedLengthByteCount];
1: 
1:         if (extendedLengthByteCount > 0) {
1:             // method should never ensure length
0:             lengthAndCodepoint = writeEXTDTALengthCodePointForEncryption(0x8004 + extendedLengthByteCount, codePoint);
1: 
0:             if (writeNullByte) {
1: 
0:                 extendedLengthBytes = writeExtendedLengthBytesForEncryption(extendedLengthByteCount, leftToRead + 1);
0:             } else {
0:                 extendedLengthBytes = writeExtendedLengthBytesForEncryption(extendedLengthByteCount, leftToRead);
1:             }
0:         } else {
0:             if (writeNullByte) {
0:                 lengthAndCodepoint = writeEXTDTALengthCodePointForEncryption(leftToRead + 4 + 1, codePoint);
0:             } else {
0:                 lengthAndCodepoint = writeEXTDTALengthCodePointForEncryption(leftToRead + 4, codePoint);
1:             }
1:         }
1: 
1:         if (extendedLengthByteCount > 0) {
0:             byte[] newLengthAndCodepoint = new byte[4 + extendedLengthBytes.length];
0:             System.arraycopy(lengthAndCodepoint, 0, newLengthAndCodepoint, 0, lengthAndCodepoint.length);
0:             System.arraycopy(extendedLengthBytes, 0, newLengthAndCodepoint, lengthAndCodepoint.length, extendedLengthBytes.length);
0:             lengthAndCodepoint = newLengthAndCodepoint;
1:         }
1: 
0:         if (writeNullByte) {
0:             byte[] nullByte = new byte[1 + lengthAndCodepoint.length];
0:             System.arraycopy(lengthAndCodepoint, 0, nullByte, 0, lengthAndCodepoint.length);
0:             nullByte[lengthAndCodepoint.length] = 0;
0:             lengthAndCodepoint = nullByte;
1:         }
0:         return lengthAndCodepoint;
1:     }
1: 
1: 
1:     private void buildLengthAndCodePointForLob(int codePoint,
0:                                                int leftToRead,
1:                                                boolean writeNullByte,
1:                                                int extendedLengthByteCount) throws DisconnectException {
1:         if (extendedLengthByteCount > 0) {
1:             // method should never ensure length
1:             writeLengthCodePoint(0x8004 + extendedLengthByteCount, codePoint);
1: 
0:             if (writeNullByte) {
0:                 writeExtendedLengthBytes(extendedLengthByteCount, leftToRead + 1);
0:             } else {
0:                 writeExtendedLengthBytes(extendedLengthByteCount, leftToRead);
1:             }
0:         } else {
0:             if (writeNullByte) {
0:                 writeLengthCodePoint(leftToRead + 4 + 1, codePoint);
0:             } else {
0:                 writeLengthCodePoint(leftToRead + 4, codePoint);
1:             }
1:         }
1: 
1:         // write the null byte, if necessary
0:         if (writeNullByte) {
1:             write1Byte(0x0);
1:         }
1: 
1:     }
1: 
1:     public void setDssLengthLocation(int location) {
1:         dssLengthLocation_ = location;
1:     }
1: 
1:     public void setCorrelationID(int id) {
1:         correlationID_ = id;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
0: 
1:    Derby - Class org.apache.derby.client.net.Request
0: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
1: */
1: package org.apache.derby.client.net;
0: 
0: import org.apache.derby.client.am.SqlException;
0: import org.apache.derby.client.am.Utils;
1: import org.apache.derby.client.am.DisconnectException;
0: import org.apache.derby.client.am.EncryptionManager;
0: 
0: public class Request
0: {
0: 
0:   // byte array buffer used for constructing requests.
0:   // currently requests are built starting at the beginning of the buffer.
0:   protected byte[] bytes_;
0: 
0:   // keeps track of the next position to place a byte in the buffer.
0:   // so the last valid byte in the message is at bytes_[offset - 1]
0:   protected int offset_;
0: 
0:   // a stack is used to keep track of offsets into the buffer where 2 byte
0:   // ddm length values are located.  these length bytes will be automatically updated
0:   // by this object when construction of a particular object has completed.
0:   // right now the max size of the stack is 10. this is an arbitrary number which
0:   // should be sufficiently large enough to handle all situations.
0:   private final static int MAX_MARKS_NESTING = 10;
0:   private int[] markStack_ = new int[MAX_MARKS_NESTING];
0:   private int top_ = 0;
0: 
0:   // the ccsid manager for the connection is stored in this object.  it will
0:   // be used when constructing character ddm data.  it will NOT be used for
0:   // building any FDOCA data.
0:   protected CcsidManager ccsidManager_;
0: 
0:   //  This Object tracks the location of the current
0:   //  Dss header length bytes.  This is done so
0:   //  the length bytes can be automatically
0:   //  updated as information is added to this stream.
0:   private int dssLengthLocation_ = 0;
0: 
0:   // tracks the request correlation ID to use for commands and command objects.
0:   // this is automatically updated as commands are built and sent to the server.
0:   private int correlationID_ = 0;
0: 
0:   private boolean simpleDssFinalize = false;
0: 
0:   // Used to mask out password when trace is on.
0:   protected boolean passwordIncluded_ = false;
0:   protected int passwordStart_ = 0;
0:   protected int passwordLength_ = 0;
0: 
0:   protected NetAgent netAgent_;
0: 
0: 
0:   // construct a request object specifying the minimum buffer size
0:   // to be used to buffer up the built requests.  also specify the ccsid manager
0:   // instance to be used when building ddm character data.
0:   Request (NetAgent netAgent, int minSize, CcsidManager ccsidManager)
0:   {
0:     netAgent_ = netAgent;
0:     bytes_ = new byte[minSize];
0:     ccsidManager_ = ccsidManager;
0:     clearBuffer();
0:   }
0: 
0:   // construct a request object specifying the ccsid manager instance
0:   // to be used when building ddm character data.  This will also create
0:   // a buffer using the default size (see final static DEFAULT_BUFFER_SIZE value).
0:   Request (NetAgent netAgent, CcsidManager ccsidManager, int bufferSize)
0:   {
0:     //this (netAgent, Request.DEFAULT_BUFFER_SIZE, ccsidManager);
0:     this (netAgent, bufferSize, ccsidManager);
0:   }
0: 
0:   protected final void clearBuffer()
0:   {
0:     offset_ = 0;
0:     top_ = 0;
0:     for (int i = 0; i < markStack_.length; i++) {
0:       if (markStack_[i] != 0)
0:         markStack_[i] = 0;
0:       else
0:         break;
0:     }
0:     dssLengthLocation_ = 0;
0:   }
0: 
0:   final void initialize()
0:   {
0:     clearBuffer();
0:     correlationID_ = 0;
0:   }
0: 
0:   // set the ccsid manager value.  this method allows the ccsid manager to be
0:   // changed so a request object can be reused by different connections with
0:   // different ccsid managers.
0:   final void setCcsidMgr (CcsidManager ccsidManager)
0:   {
0:     ccsidManager_ = ccsidManager;
0:   }
0: 
0:   // ensure length at the end of the buffer for a certain amount of data.
0:   // if the buffer does not contain sufficient room for the data, the buffer
0:   // will be expanded by the larger of (2 * current size) or (current size + length).
0:   // the data from the previous buffer is copied into the larger buffer.
0:   protected final void ensureLength (int length)
0:   {
0:     if (length > bytes_.length) {
0:       byte newBytes[] = new byte[Math.max (bytes_.length << 1, length)];
0:       System.arraycopy (bytes_, 0, newBytes, 0, offset_);
0:       bytes_ = newBytes;
0:     }
0:   }
0: 
0:   // creates an request dss in the buffer to contain a ddm command
0:   // object.  calling this method means any previous dss objects in
0:   // the buffer are complete and their length and chaining bytes can
0:   // be updated appropriately.
0:   protected final void createCommand ()
0:   {
0:     buildDss (false, false, false, DssConstants.GDSFMT_RQSDSS, ++correlationID_, false);
0:   }
0: 
0:   // creates an request dss in the buffer to contain a ddm command
0:   // object.  calling this method means any previous dss objects in
0:   // the buffer are complete and their length and chaining bytes can
0:   // be updated appropriately.
0:   protected void createXACommand ()
0:   {
0:     buildDss (false, false, false, DssConstants.GDSFMT_RQSDSS_NOREPLY, ++correlationID_, false);
0:   }
0: 
0:   // creates an object dss in the buffer to contain a ddm command
0:   // data object.  calling this method means any previous dss objects in
0:   // the buffer are complete and their length and chaining bytes can
0:   // be updated appropriately.
0:   final void createCommandData ()
0:   {
0:     buildDss (true,
1:               false,
1:               false,
1:               DssConstants.GDSFMT_OBJDSS,
1:               correlationID_,
1:               false);
0:   }
0: 
0:   final void createEncryptedCommandData ()
0:   {
0:     if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
0:         netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA)
0:       buildDss (true, false, false, DssConstants.GDSFMT_ENCOBJDSS, correlationID_, false);
0:     else
0:       buildDss (true,
1:                 false,
1:                 false,
1:                 DssConstants.GDSFMT_OBJDSS,
1:                 correlationID_,
1:                 false);
0:   }
0: 
0: 
0:   // experimental lob section
0: 
0:   private final void buildDss (boolean dssHasSameCorrelator,
0:                          boolean chainedToNextStructure,
0:                          boolean nextHasSameCorrelator,
0:                          int dssType,
0:                          int corrId,
0:                          boolean simpleFinalizeBuildingNextDss)
0:   {
0:     if (doesRequestContainData()) {
0:       if (simpleDssFinalize)
0:         finalizeDssLength();
0:       else
0:         finalizePreviousChainedDss (dssHasSameCorrelator);
0:     }
0: 
0:     ensureLength (offset_ + 6);
0: 
0:     // save the length position and skip
0:     // note: the length position is saved so it can be updated
0:     // with a different value later.
0:     dssLengthLocation_ = offset_;
0:     // always turn on chaining flags... this is helpful for lobs...
0:     // these bytes will get rest if dss lengths are finalized.
0:     bytes_[offset_++] = (byte) 0xFF;
0:     bytes_[offset_++] = (byte) 0xFF;
0: 
0:     // insert the manditory 0xD0 and the dssType
0:     bytes_[offset_++] = (byte) 0xD0;
0:     if (chainedToNextStructure) {
0:       dssType |= DssConstants.GDSCHAIN;
0:       if (nextHasSameCorrelator)
0:         dssType |= DssConstants.GDSCHAIN_SAME_ID;
0:     }
0:     bytes_[offset_++] = (byte) (dssType & 0xff);
0: 
0:     // write the request correlation id
0:     // use method that writes a short 
0:     bytes_[offset_++] = (byte) ((corrId >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (corrId & 0xff);
0: 
0:     simpleDssFinalize = simpleFinalizeBuildingNextDss;
0:   }
0: 
0:   // We need to reuse the agent's sql exception accumulation mechanism 
0:   // for this write exception, pad if the length is too big, and truncation if the length is too small 
0:   final void writeScalarStream (boolean chained,
0:                           boolean chainedWithSameCorrelator,
0:                           int codePoint,
0:                           int length,
0:                           java.io.InputStream in,
0:                           boolean writeNullByte,
0:                           int parameterIndex) throws DisconnectException,SqlException
0:   {
0:     int leftToRead = length;
0:     int extendedLengthByteCount = prepScalarStream (chained,
0:                                         chainedWithSameCorrelator,
0:                                         writeNullByte,
0:                                         leftToRead);
0:     int bytesToRead;
0: 
0:     if (writeNullByte)
0:       bytesToRead = Utils.min (leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount);
0:     else
0:       bytesToRead = Utils.min (leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - extendedLengthByteCount);
0: 
0:     if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
0:         netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA) {
0: 
0:       byte[] lengthAndCodepoint;
0:       lengthAndCodepoint = buildLengthAndCodePointForEncryptedLob (codePoint,
0:                                             leftToRead,
0:                                             writeNullByte,
0:                                             extendedLengthByteCount);
0: 
0: 
0: 
0:     // we need to stream the input, rather than fully materialize it 
0:     // write the data
0: 
0:       byte[] clearedBytes = new byte[leftToRead];
0:       int bytesRead = 0;
0:       int totalBytesRead = 0;
0:       int pos = 0;
0:       do {
0:           try {
0:             bytesRead = in.read(clearedBytes, pos, leftToRead);
0:             totalBytesRead += bytesRead;
0:           }
0:           catch (java.io.IOException e) {
0:             padScalarStreamForError(leftToRead, bytesToRead);
0:             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:             netAgent_.accumulateReadException(
0:                 new SqlException(netAgent_.logWriter_,
0:                 "Encountered an IOException reading InputStream, parameter #" +
0:                 parameterIndex +
0:                 ".  Remaining data has been padded with 0x0. Message: " +
0:                 e.getMessage()));
0:             return;
0:           }
0:           if (bytesRead == -1) {
0:             //padScalarStreamForError(leftToRead, bytesToRead);
0:             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:             /*throw new SqlException(netAgent_.logWriter_,
0:                 "End of Stream prematurely reached while reading InputStream, parameter #" +
0:                 parameterIndex +
0:                 ".  Remaining data has been padded with 0x0.");*/
0:             //is it OK to do a chain break Exception here. It's not good to
0:             //pad it with 0 and encrypt and send it to the server because it takes too much time
0:             //can't just throw a SQLException either because some of the data PRPSQLSTT etc have already
0:             //been sent to the server, and server is waiting for EXTDTA, server hangs for this.
0:              netAgent_.accumulateChainBreakingReadExceptionAndThrow(
0:               new org.apache.derby.client.am.DisconnectException(netAgent_,
0:                "End of Stream prematurely reached while reading InputStream, parameter #" +
0:                parameterIndex +
0:                ". "));
0:             return;
0: 
0:             /*netAgent_.accumulateReadException(
0:                 new SqlException(netAgent_.logWriter_,
0:                 "End of Stream prematurely reached while reading InputStream, parameter #" +
0:                 parameterIndex +
0:                 ".  Remaining data has been padded with 0x0."));
0:             return;*/
0:           }
1:           else {
0:             pos += bytesRead;
0:             //offset_ += bytesRead;  //comment this out for data stream encryption.
0:             leftToRead -= bytesRead;
0:           }
0: 
0:       }
0:       while (leftToRead > 0);
0: 
0:       // check to make sure that the specified length wasn't too small
0:       try {
0:         if (in.read() != -1) {
0:           // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:           netAgent_.accumulateReadException(
0:               new SqlException(netAgent_.logWriter_,
0:               "The specified size of the InputStream, parameter #" +
0:               parameterIndex +
0:               ", is less than the actual InputStream length"));
0:         }
0:       }
0:       catch (java.io.IOException e) {
0:         netAgent_.accumulateReadException(
0:             new SqlException(netAgent_.logWriter_,
0:             "Encountered error in stream length verification for InputStream, parameter #" +
0:             parameterIndex +
0:             ".  Message: " + e.getMessage()));
0:       }
0: 
0:       byte[] newClearedBytes = new byte[clearedBytes.length +
0:           lengthAndCodepoint.length];
0:       System.arraycopy(lengthAndCodepoint, 0, newClearedBytes, 0,
0:                        lengthAndCodepoint.length);
0:       System.arraycopy(clearedBytes, 0, newClearedBytes,lengthAndCodepoint.length , clearedBytes.length);
0:       //it's wrong here, need to add in the real length after the codepoing 146c
0:       byte[] encryptedBytes;
0:       encryptedBytes = netAgent_.netConnection_.getEncryptionManager().
0:           encryptData(
0:           newClearedBytes,
0:           NetConfiguration.SECMEC_EUSRIDPWD,
0:           netAgent_.netConnection_.getTargetPublicKey(),
0:           netAgent_.netConnection_.getTargetPublicKey());
0: 
0:       int encryptedBytesLength = encryptedBytes.length;
0:       int sendingLength = bytes_.length - offset_;
0:       if (encryptedBytesLength > (bytes_.length - offset_)) {
0: 
0:           System.arraycopy(encryptedBytes, 0, bytes_, offset_, (bytes_.length - offset_));
0:           offset_ = 32767;
0:           try {
0:             sendBytes(netAgent_.getOutputStream());
0:           }
0: 
0:           catch (java.io.IOException ioe) {
0:           netAgent_.throwCommunicationsFailure ("Request.writeScalarStream(...,InputStream)",
0:                                              "OutputStream.flush()",
0:                                              ioe.getMessage(),
0:                                              "*");
0:           }
0:       }
1:       else {
0:         System.arraycopy(encryptedBytes, 0, bytes_, offset_, encryptedBytesLength);
0:         offset_ = offset_ + encryptedBytes.length ;
0:       }
0: 
0:     encryptedBytesLength =  encryptedBytesLength  - sendingLength;
0:     while(encryptedBytesLength > 0) {
0:       //dssLengthLocation_ = offset_;
0:       offset_ = 0;
0: 
0:       if ((encryptedBytesLength  - 32765 ) > 0) {
0:         bytes_[offset_++] = (byte) (0xff);
0:         bytes_[offset_++] = (byte) (0xff);
0:         System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, 32765);
0:         encryptedBytesLength -= 32765;
0:         sendingLength +=  32765;
0:         offset_ = 32767;
0:         try {
0:           sendBytes(netAgent_.getOutputStream());
0:         }
0: 
0:         catch (java.io.IOException ioe) {
0:           netAgent_.throwCommunicationsFailure(
0:               "Request.writeScalarStream(...,InputStream)",
0:               "OutputStream.flush()",
0:               ioe.getMessage(),
0:               "*");
0:         }
0:       }
1:       else {
0:         int leftlength = encryptedBytesLength + 2;
0:         bytes_[offset_++] = (byte) ((leftlength >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) ( leftlength & 0xff);
0: 
0:         System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, encryptedBytesLength);
0: 
0:         offset_ += encryptedBytesLength;
0:         dssLengthLocation_ = offset_;
0:         encryptedBytesLength = 0;
0:       }
0: 
0:     }
0:     }
0:     else //if not data strteam encryption
0:     {
0:       buildLengthAndCodePointForLob (codePoint,
0:                                      leftToRead,
0:                                      writeNullByte,
0:                                      extendedLengthByteCount);
0: 
0:     int bytesRead = 0;
0:     int totalBytesRead = 0;
0:     do {
0:       do {
0:         try {
0:           bytesRead = in.read (bytes_, offset_, bytesToRead);
0:           totalBytesRead += bytesRead;
0:         }
0:         catch (java.io.IOException e) {
0:           padScalarStreamForError (leftToRead, bytesToRead);
0:           // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:           netAgent_.accumulateReadException (
0:             new SqlException (netAgent_.logWriter_,
0:               "Encountered an IOException reading InputStream, parameter #" + parameterIndex +
0:               ".  Remaining data has been padded with 0x0. Message: " + e.getMessage()));
0:           return;
0:         }
0:         if (bytesRead == -1) {
0:           padScalarStreamForError (leftToRead, bytesToRead);
0:           // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:           netAgent_.accumulateReadException (
0:             new SqlException (netAgent_.logWriter_,
0:               "End of Stream prematurely reached while reading InputStream, parameter #" + parameterIndex +
0:               ".  Remaining data has been padded with 0x0."));
0:           return;
0:         }
1:         else {
0:           bytesToRead -= bytesRead;
0:           offset_ += bytesRead;
0:           leftToRead -= bytesRead;
0:         }
0:       } while (bytesToRead > 0);
0: 
0:       bytesToRead = flushScalarStreamSegment (leftToRead, bytesToRead);
0:     } while (leftToRead > 0);
0: 
0:     // check to make sure that the specified length wasn't too small
0:     try {
0:       if (in.read() != -1) {
0:         // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:         netAgent_.accumulateReadException (
0:           new SqlException (netAgent_.logWriter_,
0:             "The specified size of the InputStream, parameter #" + parameterIndex +
0:             ", is less than the actual InputStream length"));
0:       }
0:     }
0:     catch (java.io.IOException e) {
0:       netAgent_.accumulateReadException(
0:         new SqlException (netAgent_.logWriter_,
0:           "Encountered error in stream length verification for InputStream, parameter #" + parameterIndex +
0:           ".  Message: " + e.getMessage()));
0:     }
0: 
0:     }
0: 
0: 
0:   }
0: 
0:   // Throw DataTruncation, instead of closing connection if input size mismatches 
0:   // An implication of this, is that we need to extend the chaining model
0:   // for writes to accomodate chained write exceptoins 
0:   final void writeScalarStream (boolean chained,
0:                           boolean chainedWithSameCorrelator,
0:                           int codePoint,
0:                           int length,
0:                           java.io.Reader r,
0:                           boolean writeNullByte,
0:                           int parameterIndex) throws DisconnectException
0:   {
0:     int leftToRead = length * 2; // the bytes to read
0:     int extendedLengthByteCount = prepScalarStream (chained,
0:                                         chainedWithSameCorrelator,
0:                                         writeNullByte,
0:                                         leftToRead);
0:    int bytesToRead;
0: 
0:    if (writeNullByte)
0:      bytesToRead = Utils.min (leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - 1 - extendedLengthByteCount);
0:   else
0:     bytesToRead = Utils.min (leftToRead, DssConstants.MAX_DSS_LEN - 6 - 4 - extendedLengthByteCount);
0: 
0: 
0: 
0:   if (netAgent_.netConnection_.getSecurityMechanism() != NetConfiguration.SECMEC_EUSRIDDTA &&
0:         netAgent_.netConnection_.getSecurityMechanism() != NetConfiguration.SECMEC_EUSRPWDDTA) {
0:       buildLengthAndCodePointForLob (codePoint,
0:                                      leftToRead,
0:                                      writeNullByte,
0:                                      extendedLengthByteCount);
0: 
0: 
0:     // write the data
0:     int charsRead = 0;
0:     boolean haveHalfChar = false;
0:     byte halfChar = (byte) 0x0;
0:     char[] buf = new char[1 + 32765 / 2]; // enough for one DSS segment
0: 
0:     do {
0:       do {
0:         // fill in a half-character if we have one from a previous segment
0:         if (haveHalfChar) {
0:           bytes_[offset_++] = halfChar;
0:           bytesToRead--;
0:           leftToRead--;
0:           haveHalfChar = false;
0:         }
0: 
0:         if (bytesToRead == 1) {
0:           try {
0:             charsRead = r.read (buf, 0, 1);
0:           }
0:           catch (java.io.IOException e) {
0:             padScalarStreamForError (leftToRead, bytesToRead);
0:             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:             netAgent_.accumulateReadException (
0:               new SqlException (netAgent_.logWriter_,
0:                   "Encountered an IOException reading Reader, parameter #" +
0:                   parameterIndex +
0:                   ".  Remaining data has been padded with 0x0. Message: " +
0:                   e.getMessage()));
0:             return;
0:           }
0:           if (charsRead == -1) {
0:             padScalarStreamForError (leftToRead, bytesToRead);
0:             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:             netAgent_.accumulateReadException (
0:               new SqlException (netAgent_.logWriter_,
0:                   "End of Stream prematurely reached while reading Reader, parameter #" +
0:                   parameterIndex +
0:                 ".  Remaining data has been padded with 0x0."));
0:             return;
0:           }
0:           // set first half-char in buffer and save the other half for later
0:           bytes_[offset_++] = (byte) (buf[0] >>> 8);
0:           halfChar = (byte) buf[0];
0:           haveHalfChar = true;
0:           bytesToRead--;
0:           leftToRead--;
0:         }
0:         else if (bytesToRead != 0) {
0:           try {
0:             // read as many whole characters as needed to fill the buffer
0:             // half characters are handled above
0:             charsRead = r.read (buf, 0, bytesToRead/2);
0:           }
0:           catch (java.io.IOException e) {
0:             padScalarStreamForError (leftToRead, bytesToRead);
0:             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:             netAgent_.accumulateReadException (
0:               new SqlException (netAgent_.logWriter_, e,
0:                   "Encountered an IOException reading Reader, parameter #" +
0:                   parameterIndex +
0:                   ".  Remaining data has been padded with 0x0. Message: " +
0:                   e.getMessage()));
0:             return;
0:           }
0: 
0:           if (charsRead == -1) {
0:             padScalarStreamForError (leftToRead, bytesToRead);
0:             // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:             netAgent_.accumulateReadException (
0:               new SqlException (netAgent_.logWriter_,
0:                   "End of Stream prematurely reached while reading Reader, parameter #" +
0:                   parameterIndex +
0:                 ".  Remaining data has been padded with 0x0."));
0:             return;
0:           }
0:           for (int i = 0; i < charsRead; i++) {
0:             bytes_[offset_++] = (byte) (buf[i] >>> 8);
0:             bytes_[offset_++] = (byte) (buf[i]);
0:           }
0: 
0:           bytesToRead -= 2 * charsRead;
0:           leftToRead -= 2 * charsRead;
0:         }
0:       }
0:       while (bytesToRead > 0);
0: 
0:       bytesToRead = flushScalarStreamSegment (leftToRead, bytesToRead);
0:     }
0:     while (leftToRead > 0);
0: 
0:     // check to make sure that the specified length wasn't too small
0:     try {
0:       if (r.read() != -1)
0:         netAgent_.accumulateReadException (
0:           new SqlException (netAgent_.logWriter_,
0:                                "The specified size of the Reader, parameter #" +
0:                                parameterIndex +
0:                                ", is less than the actual InputStream length"));
0:       }
0:       catch (java.io.IOException e) {
0:         netAgent_.accumulateReadException(
0:             new SqlException(netAgent_.logWriter_, e,
0:             "Encountered error in stream length verification for Reader, parameter #" +
0:             parameterIndex + ".  Message: " + e.getMessage()));
0:       }
0:     }
0:     else {  //data stream encryption
0: 
0:       byte[] lengthAndCodepoint;
0:       lengthAndCodepoint = buildLengthAndCodePointForEncryptedLob (codePoint,
0:                                               leftToRead,
0:                                               writeNullByte,
0:                                               extendedLengthByteCount);
0: 
0:       // write the data
0:       int charsRead = 0;
0:       char[] buf = new char[leftToRead/2 ];
0:       byte[] clearedBytes = new byte[leftToRead];
0:       int pos = 0;
0: 
0: 
0:       do {
0:           // fill in a half-character if we have one from a previous segment
0: 
0:             try {
0:               // read as many whole characters as needed to fill the buffer
0:               // half characters are handled above
0:               charsRead = r.read(buf, 0, leftToRead / 2);
0:             }
0:             catch (java.io.IOException e) {
0:               padScalarStreamForError(leftToRead, bytesToRead);
0:               // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:               netAgent_.accumulateReadException(
0:                   new SqlException(netAgent_.logWriter_, e,
0:                   "Encountered an IOException reading Reader, parameter #" +
0:                   parameterIndex +
0:                   ".  Remaining data has been padded with 0x0. Message: " +
0:                   e.getMessage()));
0:               return;
0:             }
0: 
0:             if (charsRead == -1) {
0:               padScalarStreamForError(leftToRead, bytesToRead);
0:               // set with SQLSTATE 01004: The value of a string was truncated when assigned to a host variable.
0:               netAgent_.accumulateReadException(
0:                   new SqlException(netAgent_.logWriter_,
0:                   "End of Stream prematurely reached while reading Reader, parameter #" +
0:                   parameterIndex +
0:                   ".  Remaining data has been padded with 0x0."));
0:               return;
0:             }
0:             for (int i = 0; i < charsRead; i++) {
0:               clearedBytes[pos++] = (byte) (buf[i] >>> 8);
0:               clearedBytes[pos++] = (byte) (buf[i]);
0:             }
0: 
0:             bytesToRead -= 2 * charsRead;
0:             leftToRead -= 2 * charsRead;
0:         }
0:         while (leftToRead > 0);
0: 
0:       // check to make sure that the specified length wasn't too small
0:       try {
0:         if (r.read() != -1)
0:           netAgent_.accumulateReadException(
0:               new SqlException(netAgent_.logWriter_,
0:                                "The specified size of the Reader, parameter #" +
0:                                parameterIndex +
0:                                ", is less than the actual InputStream length"));
0:     }
0:     catch (java.io.IOException e) {
0:       netAgent_.accumulateReadException(
0:         new SqlException (netAgent_.logWriter_, e,
0:             "Encountered error in stream length verification for Reader, parameter #" +
0:             parameterIndex + ".  Message: " + e.getMessage()));
0:       }
0: 
0:       byte[] newClearedBytes = new byte[clearedBytes.length +
0:           lengthAndCodepoint.length];
0:       System.arraycopy(lengthAndCodepoint, 0, newClearedBytes, 0,
0:                        lengthAndCodepoint.length);
0:       System.arraycopy(clearedBytes, 0, newClearedBytes, lengthAndCodepoint.length, clearedBytes.length);
0:       int encryptedBytesLength  = 0;
0:       byte[] encryptedBytes = null;
0:       try {
0:         EncryptionManager encryptionMgr = netAgent_.netConnection_.getEncryptionManager();
0:         byte[] publicKey = netAgent_.netConnection_.getTargetPublicKey();
0:         encryptedBytes = encryptionMgr.encryptData(
0:             newClearedBytes,
0:             NetConfiguration.SECMEC_EUSRIDPWD,
0:             publicKey,
0:             publicKey);
0:         encryptedBytesLength = encryptedBytes.length;
0:       }
0:       catch(Exception e)
0:       {
0:         e.printStackTrace();
0:       }
0: 
0: 
0:       int sendingLength = bytes_.length - offset_;
0:       if (encryptedBytesLength > bytes_.length - offset_) {
0: 
0: 
0:           System.arraycopy(encryptedBytes, 0, bytes_, offset_, (bytes_.length - offset_));
0:           offset_ = 32767;
0:           try {
0:             sendBytes(netAgent_.getOutputStream());
0:           }
0: 
0:           catch (java.io.IOException ioe) {
0:           netAgent_.throwCommunicationsFailure ("Request.writeScalarStream(...,InputStream)",
0:                                              "OutputStream.flush()",
0:                                              ioe.getMessage(),
0:                                              "*");
0:           }
0:       }
1:       else {
0:         System.arraycopy(encryptedBytes, 0, bytes_, offset_, encryptedBytesLength);
0:         offset_ = offset_ + encryptedBytes.length ;
0:       }
0: 
0:     encryptedBytesLength =  encryptedBytesLength  - sendingLength;
0:     while(encryptedBytesLength > 0) {
0:       offset_ = 0;
0: 
0:       if ((encryptedBytesLength  - 32765 ) > 0) {
0:         bytes_[offset_++] = (byte) (0xff);
0:         bytes_[offset_++] = (byte) (0xff);
0:         System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, 32765);
0:         encryptedBytesLength -= 32765;
0:         sendingLength +=  32765;
0:         offset_ = 32767;
0:         try {
0:           sendBytes(netAgent_.getOutputStream());
0:         }
0: 
0:         catch (java.io.IOException ioe) {
0:           netAgent_.throwCommunicationsFailure(
0:               "Request.writeScalarStream(...,InputStream)",
0:               "OutputStream.flush()",
0:               ioe.getMessage(),
0:               "*");
0:         }
0:       }
1:       else {
0:         int leftlength = encryptedBytesLength + 2;
0:         bytes_[offset_++] = (byte) ((leftlength >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) ( leftlength & 0xff);
0: 
0:         System.arraycopy(encryptedBytes, sendingLength, bytes_, offset_, encryptedBytesLength);
0: 
0:         offset_ += encryptedBytesLength;
0:         dssLengthLocation_ = offset_;
0:         encryptedBytesLength = 0;
0:       }
0: 
0:     }
0: 
0: 
0:     }
0:   }
0: 
0: 
0: 
0:   // prepScalarStream does the following prep for writing stream data:
0:   // 1.  Flushes an existing DSS segment, if necessary
0:   // 2.  Determines if extended length bytes are needed
0:   // 3.  Creates a new DSS/DDM header and a null byte indicator, if applicable
0:   protected final int prepScalarStream  (boolean chained,
0:                                    boolean chainedWithSameCorrelator,
0:                                    boolean writeNullByte,
0:                                    int leftToRead) throws DisconnectException
0:   {
0:     int extendedLengthByteCount;
0: 
0:     int nullIndicatorSize = 0;
0:     if (writeNullByte) {
0:       // leftToRead is cast to (long) on the off chance that +4+1 pushes it outside the range of int
0:       extendedLengthByteCount = calculateExtendedLengthByteCount ((long)leftToRead + 4 + 1);
0:       nullIndicatorSize = 1;
0:     }
0:     else
0:       extendedLengthByteCount = calculateExtendedLengthByteCount (leftToRead + 4);
0: 
0:     // flush the existing DSS segment if this stream will not fit in the send buffer
0:     // leftToRead is cast to (long) on the off chance that +4+1 pushes it outside the range of int
0:     if (10 + extendedLengthByteCount + nullIndicatorSize + (long)leftToRead + offset_ > DssConstants.MAX_DSS_LEN) {
0:       try {
0:         if (simpleDssFinalize)
0:           finalizeDssLength();
0:         else
0:           finalizePreviousChainedDss (true);
0:         sendBytes(netAgent_.getOutputStream());
0:       }
0:       catch (java.io.IOException e) {
0:          netAgent_.throwCommunicationsFailure ("Request.writeScalarStream(...,InputStream)",
0:                                               "OutputStream.flush()",
0:                                               e.getMessage(),
0:                                               "*");
0:       }
0:     }
0: 
0:     if (netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRIDDTA ||
0:         netAgent_.netConnection_.getSecurityMechanism() == NetConfiguration.SECMEC_EUSRPWDDTA)
0:     buildDss (true,
0:               chained,
0:               chainedWithSameCorrelator,
0:                 DssConstants.GDSFMT_ENCOBJDSS,
1:               correlationID_,
0:               true);
0: 
0:       else
0:     // buildDss should not call ensure length.
0:       buildDss (true,
0:                 chained,
0:                 chainedWithSameCorrelator,
1:                 DssConstants.GDSFMT_OBJDSS,
1:                 correlationID_,
0:                 true);
0: 
0:     return extendedLengthByteCount;
0:   }
0: 
0: 
0:   // Writes out a scalar stream DSS segment, along with DSS continuation headers,
0:   // if necessary.
0:   protected final int flushScalarStreamSegment (int leftToRead,
0:                                           int bytesToRead) throws DisconnectException
0:   {
0:     int newBytesToRead = bytesToRead;
0: 
0:     // either at end of data, end of dss segment, or both.
0:     if (leftToRead != 0) {
0:       // 32k segment filled and not at end of data.
0:       if ((Utils.min (2 + leftToRead, 32767)) > (bytes_.length - offset_)) {
0:         try {
0:           sendBytes (netAgent_.getOutputStream());
0:         }
0:         catch (java.io.IOException ioe) {
0:           netAgent_.throwCommunicationsFailure ("Request.writeScalarStream(...,InputStream)",
0:                                                "OutputStream.flush()",
0:                                                ioe.getMessage(),
0:                                                "*");
0:         }
0:       }
0:       dssLengthLocation_ = offset_;
0:       bytes_[offset_++] = (byte) (0xff);
0:       bytes_[offset_++] = (byte) (0xff);
0:       newBytesToRead = Utils.min (leftToRead,32765);
0:     }
0: 
0:     return newBytesToRead;
0:   }
0: 
0:   // the offset_ must not be updated when an error is encountered
0:   // note valid data may be overwritten
0:   protected final void padScalarStreamForError (int leftToRead, int bytesToRead) throws DisconnectException
0:   {
0:     do {
0:       do {
0:         bytes_[offset_++] = (byte)(0x0); // use 0x0 as the padding byte
0:         bytesToRead--;
0:         leftToRead--;
0:       } while (bytesToRead > 0);
0: 
0:       bytesToRead = flushScalarStreamSegment (leftToRead, bytesToRead);
0:     } while(leftToRead > 0);
0:   }
0: 
0:   private final void writeExtendedLengthBytes (int extendedLengthByteCount, long length)
0:   {
0:     int shiftSize = (extendedLengthByteCount -1) * 8;
0:     for (int i = 0; i < extendedLengthByteCount; i++) {
0:       bytes_[offset_++] = (byte) ((length >>> shiftSize) & 0xff);
0:       shiftSize -= 8;
0:     }
0:   }
0: 
0:   private final byte[] writeExtendedLengthBytesForEncryption (int extendedLengthByteCount, long length)
0:   {
0:     int shiftSize = (extendedLengthByteCount -1) * 8;
0:     byte[] extendedLengthBytes = new byte[extendedLengthByteCount];
0:     for (int i = 0; i < extendedLengthByteCount; i++) {
0:       extendedLengthBytes[i] = (byte) ((length >>> shiftSize) & 0xff);
0:       shiftSize -= 8;
0:     }
0:     return extendedLengthBytes;
0:   }
0: 
0:   // experimental lob section - end
0: 
0:   // used to finialize a dss which is already in the buffer
0:   // before another dss is built.  this includes updating length
0:   // bytes and chaining bits.
0:   protected final void finalizePreviousChainedDss (boolean dssHasSameCorrelator)
0:   {
0:     finalizeDssLength();
0:     bytes_[dssLengthLocation_ + 3] |= 0x40;
0:     if (dssHasSameCorrelator) // for blobs
0:       bytes_[dssLengthLocation_ + 3] |= 0x10;
0:   }
0: 
0:   // method to determine if any data is in the request.
0:   // this indicates there is a dss object already in the buffer.
0:   protected final boolean doesRequestContainData()
0:   {
0:     return offset_ != 0;
0:   }
0: 
0:   // signal the completion of a Dss Layer A object. The length of
0:   // dss object will be calculated based on the difference between the
0:   // start of the dss, saved on the beginDss call, and the current
0:   // offset into the buffer which marks the end of the data.  In the event
0:   // the length requires the use of continuation Dss headers, one for each 32k
0:   // chunk of data, the data will be shifted and the continuation headers
0:   // will be inserted with the correct values as needed.
0:   // Note: In the future, we may try to optimize this approach
0:   // in an attempt to avoid these shifts.
0:   protected final void finalizeDssLength ()
0:   {
0:     // calculate the total size of the dss and the number of bytes which would
0:     // require continuation dss headers.  The total length already includes the
0:     // the 6 byte dss header located at the beginning of the dss.  It does not
0:     // include the length of any continuation headers.
0:     int totalSize = offset_ - dssLengthLocation_;
0:     int bytesRequiringContDssHeader = totalSize - 32767;
0: 
0:     // determine if continuation headers are needed
0:     if (bytesRequiringContDssHeader > 0) {
0: 
0:       // the continuation headers are needed, so calculate how many.
0:       // after the first 32767 worth of data, a continuation header is
0:       // needed for every 32765 bytes (32765 bytes of data + 2 bytes of
0:       // continuation header = 32767 Dss Max Size).
0:       int contDssHeaderCount = bytesRequiringContDssHeader / 32765;
0:       if (bytesRequiringContDssHeader % 32765 != 0)
0:         contDssHeaderCount++;
0: 
0:       // right now the code will shift to the right.  In the future we may want
0:       // to try something fancier to help reduce the copying (maybe keep
0:       // space in the beginning of the buffer??).
0:       // the offset points to the next available offset in the buffer to place
0:       // a piece of data, so the last dataByte is at offset -1.
0:       // various bytes will need to be shifted by different amounts
0:       // depending on how many dss headers to insert so the amount to shift
0:       // will be calculated and adjusted as needed.  ensure there is enough room
0:       // for all the conutinuation headers and adjust the offset to point to the
0:       // new end of the data.
0:       int dataByte = offset_ - 1;
0:       int shiftOffset = contDssHeaderCount * 2;
0:       ensureLength (offset_ + shiftOffset);
0:       offset_ += shiftOffset;
0: 
0:       // mark passOne to help with calculating the length of the final (first or
0:       // rightmost) continuation header.
0:       boolean passOne = true;
0:       do {
0:         // calculate chunk of data to shift
0:         int dataToShift = bytesRequiringContDssHeader % 32765;
0:         if (dataToShift == 0)
0:           dataToShift = 32765;
0: 
0:         // perform the shift
0:         for (int i = 0; i < dataToShift; i++) {
0:           bytes_[dataByte + shiftOffset] = bytes_[dataByte];
0:           dataByte--;
0:         }
0: 
0:         // calculate the value the value of the 2 byte continuation dss header which
0:         // includes the length of itself.  On the first pass, if the length is 32767
0:         // we do not want to set the continuation dss header flag.
0:         int twoByteContDssHeader = dataToShift + 2;
0:         if (passOne)
0:           passOne = false;
1:         else {
0:           if (twoByteContDssHeader == 32767)
0:             twoByteContDssHeader = 0xFFFF;
0:         }
0: 
0:         // insert the header's length bytes
0:         bytes_[dataByte + shiftOffset - 1] = (byte) ((twoByteContDssHeader >>> 8) & 0xff);
0:         bytes_[dataByte + shiftOffset] = (byte) (twoByteContDssHeader & 0xff);
0: 
0:         // adjust the bytesRequiringContDssHeader and the amount to shift for
0:         // data in upstream headers.
0:         bytesRequiringContDssHeader -= dataToShift;
0:         shiftOffset -= 2;
0: 
0:         // shift and insert another header for more data.
0:       }
0:       while (bytesRequiringContDssHeader > 0);
0: 
0:       // set the continuation dss header flag on for the first header
0:       totalSize = 0xFFFF;
0: 
0:     }
0: 
0:     // insert the length bytes in the 6 byte dss header.
0:     bytes_[dssLengthLocation_] = (byte) ((totalSize >>> 8) & 0xff);
0:     bytes_[dssLengthLocation_ + 1] = (byte) (totalSize & 0xff);
0:   }
0: 
0:   // mark the location of a two byte ddm length field in the buffer,
0:   // skip the length bytes for later update, and insert a ddm codepoint
0:   // into the buffer.  The value of the codepoint is not checked.
0:   // this length will be automatically updated when construction of
0:   // the ddm object is complete (see updateLengthBytes method).
0:   // Note: this mechanism handles extended length ddms.
0:   protected final void markLengthBytes (int codePoint)
0:   {
0:     ensureLength (offset_ + 4);
0: 
0:     // save the location of length bytes in the mark stack.
0:     mark();
0: 
0:     // skip the length bytes and insert the codepoint
0:     offset_ += 2;
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:   }
0: 
0:   // mark an offest into the buffer by placing the current offset value on
0:   // a stack.
0:   private final void mark()
0:   {
0:     markStack_[top_++] = offset_;
0:   }
0: 
0:   // remove and return the top offset value from mark stack.
0:   private final int popMark()
0:   {
0:     return markStack_[--top_];
0:   }
0: 
0:   protected final void markForCachingPKGNAMCSN ()
0:   {
0:     mark();
0:   }
0: 
0:   protected final int popMarkForCachingPKGNAMCSN ()
0:   {
0:     return popMark();
0:   }
0: 
0:   // Called to update the last ddm length bytes marked (lengths are updated
0:   // in the reverse order that they are marked).  It is up to the caller
0:   // to make sure length bytes were marked before calling this method.
0:   // If the length requires ddm extended length bytes, the data will be
0:   // shifted as needed and the extended length bytes will be automatically
0:   // inserted.
0:   protected final void updateLengthBytes () throws SqlException
0:   {
0:     // remove the top length location offset from the mark stack\
0:     // calculate the length based on the marked location and end of data.
0:     int lengthLocation = popMark();
0:     int length = offset_ - lengthLocation;
0: 
0:     // determine if any extended length bytes are needed.  the value returned
0:     // from calculateExtendedLengthByteCount is the number of extended length
0:     // bytes required. 0 indicates no exteneded length.
0:     int extendedLengthByteCount = calculateExtendedLengthByteCount (length);
0:     if (extendedLengthByteCount != 0) {
0: 
0:       // ensure there is enough room in the buffer for the extended length bytes.
0:       ensureLength (offset_ + extendedLengthByteCount);
0: 
0:       // calculate the length to be placed in the extended length bytes.
0:       // this length does not include the 4 byte llcp.
0:       int extendedLength = length - 4;
0: 
0:       // shift the data to the right by the number of extended length bytes needed.
0:       int extendedLengthLocation = lengthLocation + 4;
0:       System.arraycopy (bytes_,
0:                         extendedLengthLocation,
0:                         bytes_,
0:                         extendedLengthLocation + extendedLengthByteCount,
0:                         extendedLength);
0: 
0:       // write the extended length
0:       int shiftSize = (extendedLengthByteCount -1) * 8;
0:       for (int i = 0; i < extendedLengthByteCount; i++) {
0:         bytes_[extendedLengthLocation++] = (byte) ((extendedLength >>> shiftSize ) & 0xff);
0:         shiftSize -= 8;
0:       }
0:       // adjust the offset to account for the shift and insert
0:       offset_ += extendedLengthByteCount;
0: 
0:       // the two byte length field before the codepoint contains the length
0:       // of itself, the length of the codepoint, and the number of bytes used
0:       // to hold the extended length.  the 2 byte length field also has the first
0:       // bit on to indicate extended length bytes were used.
0:       length = extendedLengthByteCount + 4;
0:       length |= 0x8000;
0:     }
0: 
0:     // write the 2 byte length field (2 bytes before codepoint).
0:     bytes_[lengthLocation] = (byte) ((length >>> 8) & 0xff);
0:     bytes_[lengthLocation+1] = (byte) (length & 0xff);
0:   }
0: 
0:   // helper method to calculate the minimum number of extended length bytes needed
0:   // for a ddm.  a return value of 0 indicates no extended length needed.
0:   private final int calculateExtendedLengthByteCount (long ddmSize) //throws SqlException
0:   {
0:     // according to Jim and some tests perfomred on Lob data,
0:     // the extended length bytes are signed.  Assume that
0:     // if this is the case for Lobs, it is the case for
0:     // all extended length scenarios.
0:     if (ddmSize <= 0x7FFF)
0:       return 0;
0:     else if (ddmSize <= 0x7FFFFFFFL)
0:       return 4;
0:     else if (ddmSize <= 0x7FFFFFFFFFFFL)
0:       return 6;
0:     else
0:       return 8;
0:   }
0: 
0:   // insert the padByte into the buffer by length number of times.
0:   final void padBytes (byte padByte, int length)
0:   {
0:     ensureLength (offset_ + length);
0:     for (int i=0; i<length; i++) {
0:       bytes_[offset_++] = padByte;
0:     }
0:   }
0: 
0:   // insert an unsigned single byte value into the buffer.
0:   final void write1Byte (int value)
0:   {
0:     ensureLength (offset_ + 1);
0:     bytes_[offset_++] = (byte) (value & 0xff);
0:   }
0: 
0:   // insert 3 unsigned bytes into the buffer.  this was
0:   // moved up from NetStatementRequest for performance
0:   final void buildTripletHeader (int tripletLength,
0:                            int tripletType,
0:                            int tripletId)
0:   {
0:     ensureLength (offset_ + 3);
0:     bytes_[offset_++] = (byte) (tripletLength & 0xff);
0:     bytes_[offset_++] = (byte) (tripletType & 0xff);
0:     bytes_[offset_++] = (byte) (tripletId & 0xff);
0:   }
0: 
0:   final void writeLidAndLengths (int[][] lidAndLengthOverrides, int count, int offset)
0:   {
0:     ensureLength (offset_ + (count * 3));
0:     for (int i = 0; i < count; i++, offset++) {
0:        bytes_[offset_++] = (byte) (lidAndLengthOverrides[offset][0] & 0xff);
0:        bytes_[offset_++] = (byte) ((lidAndLengthOverrides[offset][1] >>> 8) & 0xff);
0:        bytes_[offset_++] = (byte) (lidAndLengthOverrides[offset][1] & 0xff);
0:     }
0:   }
0: 
0:   // if mdd overrides are not required, lids and lengths are copied straight into the
0:   // buffer.
0:   // otherwise, lookup the protocolType in the map.  if an entry exists, substitute the
0:   // protocolType with the corresponding override lid.
0:   final void writeLidAndLengths (int[][] lidAndLengthOverrides,
0:                                  int count,
0:                                  int offset,
0:                                  boolean mddRequired,
0:                                  java.util.Hashtable map)
0:   {
0:     if (!mddRequired)
0:       writeLidAndLengths (lidAndLengthOverrides, count, offset);
0:     // if mdd overrides are required, lookup the protocolType in the map, and substitute
0:     // the protocolType with the override lid.
1:     else {
0:       ensureLength (offset_ + (count * 3));
0:       int protocolType, overrideLid;
0:       Object entry;
0:       for (int i = 0; i < count; i++, offset++) {
0:         protocolType = lidAndLengthOverrides[offset][0];
0:         // lookup the protocolType in the protocolType->overrideLid map
0:         // if an entry exists, replace the protocolType with the overrideLid
0:         entry = map.get(new Integer(protocolType));
0:         overrideLid = (entry == null) ? protocolType : ((Integer)entry).intValue();
0:         bytes_[offset_++] = (byte) (overrideLid & 0xff);
0:         bytes_[offset_++] = (byte) ((lidAndLengthOverrides[offset][1] >>> 8) & 0xff);
0:         bytes_[offset_++] = (byte) (lidAndLengthOverrides[offset][1] & 0xff);
0:       }
0:     }
0:   }
0: 
1: // perf end
0: 
0:   // insert a big endian unsigned 2 byte value into the buffer.
0:   final void write2Bytes (int value)
0:   {
0:     ensureLength (offset_ + 2);
0:     bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (value & 0xff);
0:   }
0: 
0:   // insert a big endian unsigned 4 byte value into the buffer.
0:   final void write4Bytes (long value)
0:   {
0:     ensureLength (offset_ + 4);
0:     bytes_[offset_++] = (byte) ((value >>> 24) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 16) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (value & 0xff);
0:   }
0: 
0:   // copy length number of bytes starting at offset 0 of the byte array, buf,
0:   // into the buffer.  it is up to the caller to make sure buf has at least length
0:   // number of elements.  no checking will be done by this method.
0:   final void writeBytes (byte[] buf, int length)
0:   {
0:     ensureLength (offset_ + length);
0:     System.arraycopy (buf, 0, bytes_, offset_, length);
0:     offset_ += length;
0:   }
0: 
0:   final void writeBytes (byte[] buf)
0:   {
0:     ensureLength (offset_ + buf.length);
0:     System.arraycopy (buf, 0, bytes_, offset_, buf.length);
0:     offset_ += buf.length;
0:   }
0: 
0:   // insert a pair of unsigned 2 byte values into the buffer.
0:   final void writeCodePoint4Bytes (int codePoint, int value)    
0:   {                                                      // should this be writeCodePoint2Bytes
0:     ensureLength (offset_ + 4);
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (value & 0xff);
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair and a 1 byte unsigned value into the buffer.
0:   // total of 5 bytes inserted in buffer.
0:   protected final void writeScalar1Byte (int codePoint, int value)
0:   {
0:     ensureLength (offset_ + 5);
0:     bytes_[offset_++] = 0x00;
0:     bytes_[offset_++] = 0x05;
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     bytes_[offset_++] = (byte) (value & 0xff);
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair and a 2 byte unsigned value into the buffer.
0:   // total of 6 bytes inserted in buffer.
0:   final void writeScalar2Bytes (int codePoint, int value)
0:   {
0:     ensureLength (offset_ + 6);
0:     bytes_[offset_++] = 0x00;
0:     bytes_[offset_++] = 0x06;
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (value & 0xff);
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair and a 4 byte unsigned value into the
0:   // buffer.  total of 8 bytes inserted in the buffer.
0:   protected final void writeScalar4Bytes (int codePoint, long value)
0:   {
0:     ensureLength (offset_ + 8);
0:     bytes_[offset_++] = 0x00;
0:     bytes_[offset_++] = 0x08;
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 24) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 16) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (value & 0xff);
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair and a 8 byte unsigned value into the
0:   // buffer.  total of 12 bytes inserted in the buffer.
0:   final void writeScalar8Bytes (int codePoint, long value)
0:   {
0:     ensureLength (offset_ + 12);
0:     bytes_[offset_++] = 0x00;
0:     bytes_[offset_++] = 0x0C;
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 56) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 48) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 40) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 32) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 24) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 16) & 0xff);
0:     bytes_[offset_++] = (byte) ((value >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (value & 0xff);
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair into the buffer.
0:   // total of 4 bytes inserted in buffer.
0:   // Note: the length value inserted in the buffer is the same as the value
0:   // passed in as an argument (this value is NOT incremented by 4 before being
0:   // inserted).
0:   final void writeLengthCodePoint (int length, int codePoint)
0:   {
0:     ensureLength (offset_ + 4);
0:     bytes_[offset_++] = (byte) ((length >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (length & 0xff);
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:   }
0: 
0:   final byte[] writeEXTDTALengthCodePointForEncryption (int length, int codePoint)
0:   {
0:     //how to encure length and offset later?
0:     byte[] clearedBytes = new byte[4];
0:     clearedBytes[0] = (byte) ((length >>> 8) & 0xff);
0:     clearedBytes[1] = (byte) (length & 0xff);
0:     clearedBytes[2] = (byte) ((codePoint >>> 8) & 0xff);
0:     clearedBytes[3] = (byte) (codePoint & 0xff);
0:     return clearedBytes;
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair into the buffer followed
0:   // by length number of bytes copied from array buf starting at offset 0.
0:   // the length of this scalar must not exceed the max for the two byte length
0:   // field.  This method does not support extended length.  The length
0:   // value inserted in the buffer includes the number of bytes to copy plus
0:   // the size of the llcp (or length + 4). It is up to the caller to make sure
0:   // the array, buf, contains at least length number of bytes.
0:   final void writeScalarBytes (int codePoint, byte[] buf, int length)
0:   {
0:     ensureLength (offset_ + length + 4);
0:     bytes_[offset_++] = (byte) (((length+4) >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) ((length+4) & 0xff);
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     for (int i=0; i<length; i++) {
0:       bytes_[offset_++] = buf[i];
0:     }
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair into the buffer.
0:   // total of 4 bytes inserted in buffer.
0:   // Note: datalength will be incremented by the size of the llcp, 4,
0:   // before being inserted.
0:   final void writeScalarHeader (int codePoint, int dataLength)
0:   {
0:     ensureLength (offset_ + dataLength + 4);
0:     bytes_[offset_++] = (byte) (((dataLength+4) >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) ((dataLength+4) & 0xff);
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair plus ddm character data into
0:   // the buffer.  This method assumes that the String argument can be
0:   // converted by the ccsid manager.  This should be fine because usually
0:   // there are restrictions on the characters which can be used for ddm
0:   // character data. This method also assumes that the string.length() will
0:   // be the number of bytes following the conversion.
0:   // The two byte length field will contain the length of the character data
0:   // and the length of the 4 byte llcp.  This method does not handle
0:   // scenarios which require extended length bytes.
0:   final void writeScalarString (int codePoint, String string) throws SqlException
0:   {
0:     int stringLength = string.length();
0:     ensureLength (offset_ + stringLength + 4);
0:     bytes_[offset_++] = (byte) (((stringLength+4) >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) ((stringLength+4) & 0xff);
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     offset_ = ccsidManager_.convertFromUCS2 (string, bytes_, offset_, netAgent_);
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair plus ddm character data into the
0:   // buffer.  The ddm character data is padded if needed with the ccsid manager's
0:   // space character if the length of the character data is less than paddedLength.
0:   // Note: this method is not to be used for String truncation and the string length
0:   // must be <= paddedLength.
0:   // This method assumes that the String argument can be
0:   // converted by the ccsid manager.  This should be fine because usually
0:   // there are restrictions on the characters which can be used for ddm
0:   // character data. This method also assumes that the string.length() will
0:   // be the number of bytes following the conversion.  The two byte length field
0:   // of the llcp will contain the length of the character data including the pad
0:   // and the length of the llcp or 4.  This method will not handle extended length
0:   // scenarios.
0:   final void writeScalarPaddedString (int codePoint, String string, int paddedLength) throws SqlException
0:   {
0:     int stringLength = string.length();
0:     ensureLength (offset_ + paddedLength + 4);
0:     bytes_[offset_++] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) ((paddedLength+4) & 0xff);
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     offset_ = ccsidManager_.convertFromUCS2 (string, bytes_, offset_, netAgent_);
0:     for (int i=0; i < paddedLength - stringLength; i++) {
0:       bytes_[offset_++] = ccsidManager_.space_;
0:     }
0:   }
0: 
0:   // this method inserts ddm character data into the buffer and pad's the
0:   // data with the ccsid manager's space character if the character data length
0:   // is less than paddedLength.
0:   // Not: this method is not to be used for String truncation and the string length
0:   // must be <= paddedLength.
0:   // This method assumes that the String argument can be
0:   // converted by the ccsid manager.  This should be fine because usually
0:   // there are restrictions on the characters which can be used for ddm
0:   // character data. This method also assumes that the string.length() will
0:   // be the number of bytes following the conversion.
0:   final void writeScalarPaddedString (String string, int paddedLength) throws SqlException
0:   {
0:     int stringLength = string.length();
0:     ensureLength (offset_ + paddedLength);
0:     offset_ = ccsidManager_.convertFromUCS2 (string, bytes_, offset_, netAgent_);
0:     for (int i=0; i < paddedLength - stringLength; i++) {
0:       bytes_[offset_++] = ccsidManager_.space_;
0:     }
0:   }
0: 
0:   // this method writes a 4 byte length/codepoint pair plus the bytes contained
0:   // in array buff to the buffer.
0:   // the 2 length bytes in the llcp will contain the length of the data plus
0:   // the length of the llcp.  This method does not handle scenarios which
0:   // require extended length bytes.
0:   final void writeScalarBytes (int codePoint, byte[] buff)
0:   {
0:     int buffLength = buff.length;
0:     ensureLength (offset_ + buffLength + 4);
0:     bytes_[offset_++] = (byte) (((buffLength+4) >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) ((buffLength+4) & 0xff);
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     System.arraycopy(buff, 0, bytes_, offset_, buffLength);
0:     offset_ += buffLength;
0:   }
0: 
0:   // this method inserts a 4 byte length/codepoint pair plus length number of bytes
0:   // from array buff starting at offset start.
0:   // Note: no checking will be done on the values of start and length with respect
0:   // the actual length of the byte array.  The caller must provide the correct
0:   // values so an array index out of bounds exception does not occur.
0:   // the length will contain the length of the data plus the length of the llcp.
0:   // This method does not handle scenarios which require extended length bytes.
0:   final void writeScalarBytes (int codePoint, byte[] buff, int start, int length)
0:   {
0:     ensureLength (offset_ + length + 4);
0:     bytes_[offset_++] = (byte) (((length + 4) >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) ((length + 4) & 0xff);
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     System.arraycopy(buff, start, bytes_, offset_, length);
0:     offset_ += length;
0:   }
0: 
0:   // insert a 4 byte length/codepoint pair plus ddm binary data into the
0:   // buffer.  The binary data is padded if needed with the padByte
0:   // if the data is less than paddedLength.
0:   // Note: this method is not to be used for truncation and buff.length
0:   // must be <= paddedLength.
0:   // The llcp length bytes will contain the length of the data plus
0:   // the length of the llcp or 4.
0:   // This method does not handle scenarios which require extended length bytes.
0:   final void writeScalarPaddedBytes (int codePoint, byte[] buff, int paddedLength, byte padByte)
0:   {
0:     int buffLength = buff.length;
0:     ensureLength (offset_ + paddedLength + 4);
0:     bytes_[offset_++] = (byte) (((paddedLength+4) >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) ((paddedLength+4) & 0xff);
0:     bytes_[offset_++] = (byte) ((codePoint >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (codePoint & 0xff);
0:     System.arraycopy(buff, 0, bytes_, offset_, buffLength);
0:     offset_ += buffLength;
0: 
0:     for (int i=0; i < paddedLength - buffLength; i++) {
0:       bytes_[offset_++] = padByte;
0:     }
0:   }
0: 
0:   // this method inserts binary data into the buffer and pads the
0:   // data with the padByte if the data length is less than the paddedLength.
0:   // Not: this method is not to be used for truncation and buff.length
0:   // must be <= paddedLength.
0:   final void writeScalarPaddedBytes (byte[] buff, int paddedLength, byte padByte)
0:   {
0:     int buffLength = buff.length;
0:     ensureLength (offset_ + paddedLength);
0:     System.arraycopy(buff, 0, bytes_, offset_, buffLength);
0:     offset_ += buffLength;
0: 
0:     for (int i=0; i < paddedLength - buffLength; i++) {
0:       bytes_[offset_++] = padByte;
0:     }
0:   }
0: 
0:   // write the request to the OutputStream and flush the OutputStream.
0:   // trace the send if PROTOCOL trace is on.
0:   protected void flush (java.io.OutputStream socketOutputStream) throws java.io.IOException
0:   {
0:     if (doesRequestContainData()) {
0:       finalizeDssLength();
0:       sendBytes (socketOutputStream);
0:     }
0:   }
0: 
0:   protected void sendBytes (java.io.OutputStream socketOutputStream) throws java.io.IOException
0:   {
0:     try {
0:        socketOutputStream.write (bytes_, 0, offset_);
0:       socketOutputStream.flush();
0:     }
0:     finally {
0:       if (netAgent_.logWriter_ != null && passwordIncluded_) {
0:           // if password is in the buffer, need to mask it out.
0:           maskOutPassword ();
0:           passwordIncluded_ = false;
0:         }
0:       if (netAgent_.loggingEnabled()) {
0:         ((NetLogWriter) netAgent_.logWriter_).traceProtocolFlow (bytes_,
0:                                      0,  
0:                                      offset_,
0:                                      NetLogWriter.TYPE_TRACE_SEND,
0:                                      "Request",
0:                                      "flush",
0:                                      1); // tracepoint
0:       }
0:       clearBuffer();
0:     }
0:   }
0: 
0:   final void maskOutPassword ()
0:   {
0:     try {
0:       String maskChar = "*";
0:       // construct a mask using the maskChar.
0:       StringBuffer mask = new StringBuffer();
0:       for (int i=0; i<passwordLength_; i++)
0:         mask.append (maskChar);
0:       // try to write mask over password.
0:       ccsidManager_.convertFromUCS2 (mask.toString(), bytes_, passwordStart_, netAgent_);
0:     }
0:     catch (SqlException sqle) {
0:       // failed to convert mask,
0:       // them simply replace with 0xFF.
0:       for (int i=0; i<passwordLength_; i++)
0:         bytes_[passwordStart_+i] = (byte)0xFF;
0:     }
0:   }
0: 
0:   // insert a java byte into the buffer.
0:   final void writeByte (byte v)
0:   {
0:     ensureLength (offset_ + 1);
0:     bytes_[offset_++] = v;
0:   }
0: 
0:   // insert a java short into the buffer.
0:   final void writeShort (short v)
0:   {
0:     ensureLength (offset_ + 2);
0:     org.apache.derby.client.am.SignedBinary.shortToBigEndianBytes (bytes_, offset_, v);
0:     offset_ += 2;
0:   }
0: 
0:   // insert a java int into the buffer.
0:   void writeInt (int v)
0:   {
0:     ensureLength (offset_ + 4);
0:     org.apache.derby.client.am.SignedBinary.intToBigEndianBytes (bytes_, offset_, v);
0:     offset_ += 4;
0:   }
0: 
0:   // insert a java long into the buffer.
0:   final void writeLong (long v)
0:   {
0:     ensureLength (offset_ + 8);
0:     org.apache.derby.client.am.SignedBinary.longToBigEndianBytes (bytes_, offset_, v);
0:     offset_ += 8;
0:   }
0: 
0:   //-- The following are the write short/int/long in bigEndian byte ordering --
0: 
0:   // when writing Fdoca data.
0:   protected void writeShortFdocaData (short v)
0:   {
0:     ensureLength (offset_ + 2);
0:     org.apache.derby.client.am.SignedBinary.shortToBigEndianBytes (bytes_, offset_, v);
0:     offset_ += 2;
0:   }
0: 
0:   // when writing Fdoca data.
0:   protected void writeIntFdocaData (int v)
0:   {
0:     ensureLength (offset_ + 4);
0:     org.apache.derby.client.am.SignedBinary.intToBigEndianBytes (bytes_, offset_, v);
0:     offset_ += 4;
0:   }
0: 
0:   // when writing Fdoca data.
0:   protected void writeLongFdocaData (long v)
0:   {
0:     ensureLength (offset_ + 8);
0:     org.apache.derby.client.am.SignedBinary.longToBigEndianBytes (bytes_, offset_, v);
0:     offset_ += 8;
0:   }
0: 
0:   // insert a java float into the buffer.
0:   protected void writeFloat (float v)
0:   {
0:     ensureLength (offset_ + 4);
0:     org.apache.derby.client.am.FloatingPoint.floatToIeee754Bytes (bytes_, offset_, v);
0:     offset_ += 4;
0:   }
0: 
0:   // insert a java double into the buffer.
0:   protected void writeDouble (double v)
0:   {
0:     ensureLength (offset_ + 8);
0:     org.apache.derby.client.am.FloatingPoint.doubleToIeee754Bytes (bytes_, offset_, v);
0:     offset_ += 8;
0:   }
0: 
0:   // insert a java.math.BigDecimal into the buffer.
0:   final void writeBigDecimal (java.math.BigDecimal v,
0:                         int declaredPrecision,
0:                         int declaredScale) throws SqlException
0:   {
0:     ensureLength (offset_ + 16);
0:     try {
0:       int length = org.apache.derby.client.am.Decimal.bigDecimalToPackedDecimalBytes (bytes_, offset_, v, declaredPrecision, declaredScale);
0:       offset_ += length;
0:     }
0:     catch (org.apache.derby.client.am.ConversionException e) {
0:       throw new SqlException (netAgent_.logWriter_, e,
0:         "BigDecimal conversion exception " + e.getMessage() + ". See attached Throwable.");
0:     }
0:   }
0: 
0:   final void writeDate (java.sql.Date date) throws SqlException
0:   {
0:    try
0:    {
0:       ensureLength (offset_ + 10); 
0:       org.apache.derby.client.am.DateTime.dateToDateBytes (bytes_, offset_, date);
0:       offset_ += 10;
0:     }
0:     catch (org.apache.derby.client.am.ConversionException e) {
0:       throw new SqlException (netAgent_.logWriter_, e,
0:         "Date conversion exception " + e.getMessage() + ". See attached Throwable.");
0:     }
0:   }
0: 
0:   final void writeTime (java.sql.Time time) throws SqlException
0:   {
0:     ensureLength (offset_ + 8); 
0:     org.apache.derby.client.am.DateTime.timeToTimeBytes (bytes_, offset_, time);
0:     offset_ += 8;
0:  }
0: 
0:   final void writeTimestamp (java.sql.Timestamp timestamp) throws SqlException
0:   {
0:     try
0:     {
0:       ensureLength (offset_ + 26); 
0:       org.apache.derby.client.am.DateTime.timestampToTimestampBytes (bytes_, offset_, timestamp);
0:       offset_ += 26;
0:     }
0:     catch(org.apache.derby.client.am.ConversionException e) {
0:       throw new SqlException (netAgent_.logWriter_, e,
0:         "Timestamp conversion exception " + e.getMessage() + ". See attached Throwable.");
0:     }
0:   }
0: 
0:   // insert a java boolean into the buffer.  the boolean is written
0:   // as a signed byte having the value 0 or 1.
0:   final void writeBoolean (boolean v)
0:   {
0:     ensureLength (offset_ + 1);
0:     bytes_[offset_++] = (byte) ((v ? 1 : 0) & 0xff);
0:   }
0: 
0:   // follows the TYPDEF rules (note: don't think ddm char data is ever length
0:   // delimited)
0:   // should this throw SqlException 
0:   // Will write a varchar mixed or single
0:   //  this was writeLDString
0:   final void writeSingleorMixedCcsidLDString (String s, String encoding) throws SqlException
0:   {
0:     byte[] b;
0:     try {
0:       b = s.getBytes (encoding);  
0:     }
0:     catch (java.io.UnsupportedEncodingException e) {
0:       throw new SqlException (netAgent_.logWriter_, e,
0:         "Unsupported encoding " + e.getMessage() + ". See attached Throwable.");
0:     }
0:     if (b.length > 0x7FFF)
0:       throw new SqlException (netAgent_.logWriter_, "string exceed maximum length 32767");
0:     ensureLength (offset_ + b.length + 2);
0:     writeLDBytesX(b.length, b);
0:   }
0: 
0: 
0:   final void writeLDBytes (byte[] bytes)
0:   {
0:     ensureLength (offset_ + bytes.length + 2);
0:     writeLDBytesX (bytes.length, bytes);
0:   }
0: 
0:   // private helper method which should only be called by a Request method.
0:   // must call ensureLength before calling this method.
0:   // added for code reuse and helps perf by reducing ensureLength calls.
0:   // ldSize and bytes.length may not be the same.  this is true
0:   // when writing graphic ld strings.
0:   private final void writeLDBytesX (int ldSize, byte[] bytes)
0:   {
0:     bytes_[offset_++] = (byte) ((ldSize >>> 8) & 0xff);
0:     bytes_[offset_++] = (byte) (ldSize & 0xff);
0:     System.arraycopy(bytes, 0, bytes_, offset_, bytes.length);
0:     offset_ += bytes.length;
0:   }
0: 
0:   // does it follows
0:   // ccsid manager or typdef rules.  should this method write ddm character
0:   // data or fodca data right now it is coded for ddm char data only
0:   final void writeDDMString (String s) throws SqlException
0:   {
0:     ensureLength (offset_ + s.length());
0:     offset_ = ccsidManager_.convertFromUCS2 (s, bytes_, offset_, netAgent_);
0:   }
0: 
0: 
0:   private byte[] buildLengthAndCodePointForEncryptedLob (int codePoint,
0:                                                         int leftToRead,
0:                                                         boolean writeNullByte,
0:                                                         int extendedLengthByteCount) throws DisconnectException
0: {
0:     byte[] lengthAndCodepoint = new byte[4];
0:     byte[] extendedLengthBytes = new byte[extendedLengthByteCount];
0: 
0:     if (extendedLengthByteCount > 0) {
0:       // method should never ensure length
0:       lengthAndCodepoint = writeEXTDTALengthCodePointForEncryption (0x8004 + extendedLengthByteCount, codePoint);
0: 
0:       if (writeNullByte) {
0: 
0:         extendedLengthBytes = writeExtendedLengthBytesForEncryption(extendedLengthByteCount, leftToRead + 1);
0:       }
0:       else{
0:         extendedLengthBytes = writeExtendedLengthBytesForEncryption(extendedLengthByteCount, leftToRead);
0:       }
0:     }
1:     else {
0:       if (writeNullByte)
0:         lengthAndCodepoint = writeEXTDTALengthCodePointForEncryption (leftToRead + 4 + 1, codePoint);
0:       else
0:         lengthAndCodepoint = writeEXTDTALengthCodePointForEncryption (leftToRead + 4, codePoint);
0:     }
0: 
0:     if (extendedLengthByteCount > 0) {
0:       byte[] newLengthAndCodepoint = new byte[4 + extendedLengthBytes.length];
0:       System.arraycopy(lengthAndCodepoint,0,newLengthAndCodepoint,0,lengthAndCodepoint.length);
0:       System.arraycopy(extendedLengthBytes,0,newLengthAndCodepoint,lengthAndCodepoint.length,extendedLengthBytes.length);
0:       lengthAndCodepoint = newLengthAndCodepoint;
0:     }
0: 
0:     if (writeNullByte) {
0:       byte[] nullByte = new byte[1+lengthAndCodepoint.length];
0:       System.arraycopy(lengthAndCodepoint,0,nullByte,0,lengthAndCodepoint.length);
0:       nullByte[lengthAndCodepoint.length] = 0;
0:       lengthAndCodepoint = nullByte;
0:     }
0:     return lengthAndCodepoint;
0:   }
0: 
0: 
0:   private void buildLengthAndCodePointForLob (int codePoint,
0:                                               int leftToRead,
0:                                               boolean writeNullByte,
0:                                               int extendedLengthByteCount) throws DisconnectException
0: {
0:     if (extendedLengthByteCount > 0) {
0:       // method should never ensure length
0:       writeLengthCodePoint (0x8004 + extendedLengthByteCount, codePoint);
0: 
0:       if (writeNullByte)
0:         writeExtendedLengthBytes (extendedLengthByteCount, leftToRead + 1);
0:       else
0:         writeExtendedLengthBytes (extendedLengthByteCount, leftToRead);
0:     }
1:     else {
0:       if (writeNullByte)
0:         writeLengthCodePoint (leftToRead + 4 + 1, codePoint);
0:       else
0:         writeLengthCodePoint (leftToRead + 4, codePoint);
0:     }
0: 
0:     // write the null byte, if necessary
0:     if (writeNullByte)
0:       write1Byte(0x0);
0: 
0: }
0:   public void setDssLengthLocation (int location)
0:   {
0:     dssLengthLocation_ = location;
0:   }
0: 
0:   public void setCorrelationID (int id)
0:   {
0:     correlationID_ = id;
0:   }
0: }
============================================================================