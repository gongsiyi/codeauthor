1:eac0369: /*
1:7ecc1f2: 
1:c8e864b:    Derby - Class org.apache.derby.iapi.util.IdUtil
1:7ecc1f2: 
1:11ec54f:    Licensed to the Apache Software Foundation (ASF) under one or more
1:11ec54f:    contributor license agreements.  See the NOTICE file distributed with
1:11ec54f:    this work for additional information regarding copyright ownership.
1:11ec54f:    The ASF licenses this file to you under the Apache License, Version 2.0
1:11ec54f:    (the "License"); you may not use this file except in compliance with
1:11ec54f:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
9:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.util;
1:eac0369: 
1:50ba36b: import org.apache.derby.iapi.reference.Attribute;
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:50ba36b: import org.apache.derby.iapi.reference.Property;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import java.io.IOException;
1:eac0369: import java.io.StringReader;
1:eac0369: import java.util.Vector;
1:eac0369: import java.util.HashSet;
1:50ba36b: import java.util.Properties;
1:0ea31ca: import org.apache.derby.iapi.reference.Limits;
1:eac0369: 
1:eac0369: /**
1:eac0369:   Utility class for parsing and producing string representations of
1:eac0369:   ids. This class supports both delimited and un-delimited ids.
1:eac0369: 
1:eac0369:   <P>The syntax for an id follows. 
1:eac0369:   <PRE>
1:eac0369:       id := delim-id | unDelim-id
1:eac0369: 
1:eac0369: 	  delim-id := "[""|[any char but quote]]+"
1:eac0369: 	  undelim-id := (a-z|A-Z|anyunicodeletter)[a-z|A-Z|_|0-9|anyunicodeletter|anyunicodedigit]*
1:eac0369: 
1:eac0369: 	  In the syntax braces show grouping. '*' means repeat 0 or more times.
1:eac0369: 	  '|' means or. '+' means repeat 1 or more times. 
1:eac0369:   </PRE>
1:eac0369: 
1:eac0369:   <P>In addition this class provides support for qualified names. A qualified name
1:eac0369:   is a dot (.) separated list of ids.
1:eac0369: 
1:eac0369:   <P>Limitations:
1:eac0369:   <OL>
1:eac0369:   <LI>Unicode escape sequences in ids are not supported.
1:eac0369:   <LI>Escape sequences (\n...) are not supported.
1:eac0369:   </OL>
1:eac0369:   */
1:eac0369: public abstract class IdUtil
1:eac0369: {
1:eac0369: 	/**
1:ce018f3:      * Produce a delimited form of a normal value.
1:eac0369: 	  @return the delimited identifier.
1:eac0369: 	  */
1:ce018f3: 	public static String normalToDelimited(String id)
1:eac0369: 	{
1:5b90cf1:         return StringUtil.quoteString(id, '"');
3:eac0369: 	}
1:c8e864b: 
1:c8e864b: 	/**
1:eac0369: 	  Produce a delimited two part qualified name from two
1:eac0369: 	  un-delimited identifiers.
1:eac0369: 	  @return the result.
1:eac0369: 	  */
1:eac0369: 	public static String mkQualifiedName(String id1,
1:eac0369: 										 String id2)
1:eac0369: 	{
1:eac0369:         if( null == id1)
1:ce018f3:             return normalToDelimited(id2);
1:eac0369: 		return
1:ce018f3:         normalToDelimited(id1) +
1:eac0369: 			"." +
1:ce018f3:             normalToDelimited(id2);
1:eac0369: 	}
1:ce018f3: 
1:0fd9a50: 	/**
1:eac0369: 	  Make a string form of a qualified name from the array of ids provided.
1:eac0369: 	  */
1:eac0369: 	public static String mkQualifiedName(String[] ids)
1:eac0369: 	{
1:eac0369: 		StringBuffer sb = new StringBuffer();
1:eac0369: 		for (int ix=0; ix < ids.length; ix++)
1:eac0369: 		{
1:eac0369: 			if (ix!=0) sb.append(".");
1:ce018f3: 			sb.append(normalToDelimited(ids[ix]));
1:eac0369: 		}
1:eac0369: 		return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
2:9067662: 	  Parse a multi-part (dot separated) SQL identifier form the
1:9067662:       String provided. Raise an excepion
2:9067662: 	  if the string does not contain valid SQL indentifiers.
2:9067662:       The returned String array contains the normalized form of the
2:9067662:       identifiers.
1:eac0369:       
1:9067662:       @param s The string to be parsed
2:eac0369:       @return An array of strings made by breaking the input string at its dots, '.'.
2:eac0369: 	  @exception StandardException Oops
1:eac0369: 	  */
1:9067662: 	public static String[] parseMultiPartSQLIdentifier(String s)
2:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		StringReader r = new StringReader(s);
1:9067662: 		String[] qName = parseMultiPartSQLIdentifier(r);
1:eac0369: 		verifyEmpty(r);
1:eac0369: 		return qName;
1:eac0369: 	}
1:9067662: 
1:9067662:     /**
1:615b8c7:     @param r The multi-part identifier to be parsed
1:9067662:     @return An array of strings made by breaking the input string at its dots, '.'.
1:9067662:       @exception StandardException Oops
1:9067662:       */
1:9067662: 	private static String[] parseMultiPartSQLIdentifier(StringReader r)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:073b862: 		Vector<String> v = new Vector<String>();
1:eac0369: 		while (true)
1:eac0369: 		{
1:9067662: 			String thisId = parseId(r,true);
1:a32eb9f: 			v.add(thisId);
1:eac0369: 			int dot;
1:eac0369: 
1:eac0369: 			try {
1:eac0369: 				r.mark(0);
1:eac0369: 				dot = r.read();
1:eac0369: 				if (dot != '.')
1:eac0369: 				{
1:eac0369: 					if (dot!=-1) r.reset();
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
2:eac0369: 			catch (IOException ioe){
1:eac0369: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		String[] result = new String[v.size()];
1:eac0369: 		v.copyInto(result);
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:9ac3a76:       Parse a SQL identifier from the String provided. Raise an excepion
1:9ac3a76:       if the string does not contain a valid SQL indentifier.
1:9ac3a76:       The returned String  contains the normalized form of the
1:9ac3a76:       identifier.
1:9ac3a76:         
1:eac0369: 	  @exception StandardException Oops
1:eac0369: 	  */
1:9ac3a76: 	public static String parseSQLIdentifier(String s)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		StringReader r = new StringReader(s);
1:9067662: 		String id = parseId(r,true);
1:eac0369: 		verifyEmpty(r);
2:eac0369: 		return id;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Read an id from the StringReader provided.
1:eac0369: 
1:eac0369: 
1:6b50965: 	  @param normalize true means return ids in nomral form, false means
1:eac0369: 	        return them as they were entered.
1:eac0369: 
1:eac0369: 	  <P>
1:eac0369: 	  Raise an exception if the first thing in the StringReader
1:eac0369: 	  is not a valid id.
1:eac0369: 
1:eac0369: 	  @exception StandardException Ooops.
1:eac0369: 	  */
1:9067662: 	private static String parseId(StringReader r, boolean normalize)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		try {
1:eac0369: 			r.mark(0);
1:eac0369: 			int c = r.read();
1:eac0369: 			if (c == -1)  //id can't be 0-length
1:eac0369: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1:eac0369:  			r.reset();
1:eac0369: 			if (c == '"')
1:eac0369: 				return parseQId(r,normalize);
1:eac0369: 			else
1:aa438ff: 				return parseUnQId(r,normalize);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		catch (IOException ioe){
1:eac0369: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:ade6ac5: 	 * Given a case normal form SQL authorization identifier, convert it to a
1:c8e864b: 	 * form that may be compared with the username of Derby builtin
1:ade6ac5: 	 * authentication, which uses Java properties of the form
1:ade6ac5: 	 * {@code derby.user.}&lt;username&gt;.
1:ade6ac5: 	 * <p>
1:ade6ac5: 	 * The returned form is suitable for comparing against the property string,
1:ade6ac5: 	 * cf.  {@code systemPropertiesExistsBuiltinUser}.
1:ade6ac5: 	 * <p>
1:ade6ac5: 	 * E.g.:
1:ade6ac5: 	 * <p>
1:ade6ac5: 	 * <pre>
1:dbed020: 	 *  Argument -&gt; Return
1:ade6ac5: 	 *  ------------------
1:dbed020: 	 *  EVE      -&gt; eve       [will match Java property: derby.user.eve]
1:dbed020: 	 *  eVe      -&gt; "eVe"     [will match Java property: derby.user."eVe"]
1:dbed020: 	 *  "eve"    -&gt; """eve""" [will match Java property: derby.user."""eVe"""]
1:dbed020: 	 *  \eve\    -&gt; "\eve\"   [will match Java property: derby.user."\eve\"]
2:c8e864b: 	 *
1:ade6ac5: 	 * The latter could look this if specified on a Unix shell command line:
1:c8e864b: 	 *
1:ade6ac5: 	 *                      -Dderby.user.'"\eve\"'=&lt;password&gt;
1:c8e864b: 	 *
1:ade6ac5: 	 * Note: The processing of properties specified on the command line do not
1:ade6ac5: 	 * interpret backslash as escape in the way done by the
1:ade6ac5: 	 * java.util.Properties#load method, so no extra backslash is needed above.
1:c8e864b: 	 *
1:ade6ac5: 	 * </pre>
1:ade6ac5: 	 * Since parseSQLIdentifier maps many-to-one, the backward mapping is
1:ade6ac5: 	 * non-unique, so the chosen lower case canonical form is arbitrary,
1:ade6ac5: 	 * e.g. we will not be able to correctly match the non-canonical:
1:ade6ac5: 	 * <p>
1:ade6ac5:      * <pre>
1:ade6ac5: 	 *                      [Java property: derby.user.eVe]
1:ade6ac5: 	 * </pre>
1:ade6ac5: 	 * since this is internally EVE (but see DERBY-3150), and maps back as eve
1:ade6ac5: 	 * after the rules above.
1:ade6ac5: 	 * @see org.apache.derby.iapi.services.property.PropertyUtil#propertiesContainsBuiltinUser
1:ade6ac5: 	 * @see org.apache.derby.iapi.services.property.PropertyUtil#systemPropertiesExistsBuiltinUser
1:c8e864b: 	 */
1:c8e864b: 	public static String SQLIdentifier2CanonicalPropertyUsername(String authid){
1:c8e864b: 		boolean needsQuote = false;
1:c8e864b: 		String result;
1:c8e864b: 
2:c8e864b: 		for (int i=0; i < authid.length(); i++) {
1:619279e: 			char c = authid.charAt(i);
1:c8e864b: 			// The only external form that needs no quoting contains
1:c8e864b: 			// only uppercase ASCII, underscore, and if not the first
1:c8e864b: 			// character, a decimal number. In all other cases, we
1:c8e864b: 			// envelop in double quotes.
1:c8e864b: 			if (!( (c >= 'A' && c <= 'Z') ||
1:c8e864b: 				   (c == '_') ||
1:c8e864b: 				   (i > 0 && (c >= '0' && c <= '9')))) {
1:c8e864b: 				needsQuote = true;
1:c8e864b: 				break;
1:c8e864b: 			}
1:c8e864b: 		}
1:c8e864b: 
1:c8e864b: 		if (!needsQuote) {
1:c8e864b: 			result = authid.toLowerCase();
1:c8e864b: 		} else {
1:d12a33d: 			result = normalToDelimited(authid);
1:c8e864b: 		}
1:c8e864b: 
1:c8e864b: 		return result;
1:c8e864b: 	}
1:c8e864b: 
1:eac0369:     /**
1:0fd9a50:      * Parse a regular identifier (unquoted) returning returning either
1:0fd9a50:      * the value of the identifier or a delimited identifier. Ensures
1:0fd9a50:      * that all characters in the identifer are valid for a regular identifier.
1:c8e864b:      * 
1:0fd9a50:      * @param r Regular identifier to parse.
1:0fd9a50:      * @param normalize If true return the identifer converted to a single case, otherwise return the identifier as entered.
1:0fd9a50:      * @return the value of the identifer or a delimited identifier
1:0fd9a50:      * @throws IOException Error accessing value
1:0fd9a50:      * @throws StandardException Error parsing identifier.
1:0fd9a50:  
1:0fd9a50:      */
1:aa438ff: 	private static String parseUnQId(StringReader r, boolean normalize)
1:eac0369: 		 throws IOException,StandardException
1:eac0369: 	{
1:c8e864b: 		StringBuffer b = new StringBuffer();
1:eac0369: 		int c;
1:eac0369: 		boolean first;
1:eac0369: 		//
1:eac0369: 		for(first = true; ; first=false)
1:eac0369: 		{
1:eac0369: 			r.mark(0);
1:eac0369: 			if (idChar(first,c=r.read()))
1:eac0369: 				b.append((char)c);
1:eac0369: 			else
1:eac0369: 				break;
1:619279e: 		}
1:eac0369: 		if (c != -1) r.reset();
1:aa438ff:         
1:aa438ff:         String id = b.toString();
1:eac0369: 
1:eac0369: 		if (normalize)
1:aa438ff: 			return StringUtil.SQLToUpperCase(id);
1:eac0369: 		else
1:aa438ff: 			return id;
1:c8e864b: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private static boolean idChar(boolean first,int c)
1:eac0369: 	{
1:eac0369: 		if (((c>='a' && c<='z') || (c>='A' && c<='Z')) ||
1:eac0369: 			(!first &&(c>='0' && c<='9')) || (!first &&c =='_') )
1:eac0369: 			return true;
1:eac0369: 		else if (Character.isLetter((char) c))
1:eac0369: 			return true;
1:eac0369: 		else if (!first && Character.isDigit((char) c))
1:eac0369: 			return true;
1:eac0369: 		return false;
1:eac0369: 	}
1:0fd9a50:     
1:0fd9a50:     /**
1:0fd9a50:      * Parse a delimited (quoted) identifier returning either
1:0fd9a50:      * the value of the identifier or a delimited identifier.
1:0fd9a50:      * @param r Quoted identifier to parse.
1:0fd9a50:      * @param normalize If true return a delimited identifer, otherwise return the identifier's value.
1:0fd9a50:      * @return the value of the identifer or a delimited identifier
1:0fd9a50:      * @throws IOException Error accessing value
1:0fd9a50:      * @throws StandardException Error parsing identifier.
1:0fd9a50:      */
1:eac0369: 	private static String parseQId(StringReader r,boolean normalize)
1:eac0369: 		 throws IOException,StandardException
1:eac0369: 	{
2:eac0369: 		StringBuffer b = new StringBuffer();
1:eac0369: 		int c = r.read();
1:eac0369: 		if (c != '"') throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1:eac0369: 		while (true)
1:eac0369: 		{
1:eac0369: 			c=r.read();
1:eac0369: 			if (c == '"')
1:eac0369: 			{
1:eac0369: 				r.mark(0);
1:eac0369: 				int c2 = r.read();
1:eac0369: 				if (c2 != '"')
1:eac0369: 				{
1:eac0369: 					if (c2!=-1)r.reset();
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			else if (c == -1)
1:eac0369: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1:eac0369: 			
1:eac0369: 			b.append((char)c);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (b.length() == 0) //id can't be 0-length
1:eac0369: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1:eac0369: 
1:eac0369: 		if (normalize)
2:eac0369: 			return b.toString();
1:eac0369: 		else
1:ce018f3: 			return normalToDelimited(b.toString()); //Put the quotes back.
1:eac0369: 	}
1:eac0369: 
1:aa438ff:     /**
1:aa438ff:      * Verify the read is empty (no more characters in its stream).
1:aa438ff:      * @param r
1:aa438ff:      * @throws StandardException
1:aa438ff:      */
1:eac0369: 	private static void verifyEmpty(java.io.Reader r)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		try {
2:eac0369: 			if (r.read() != -1)
1:eac0369: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		catch (IOException ioe){
1:eac0369: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
1:eac0369: 		}			
1:eac0369: 	}
1:eac0369: 	/**Index of the schema name in a jar name on a db classpath*/
1:eac0369: 	public static final int DBCP_SCHEMA_NAME = 0;
1:eac0369: 	/**Index of the sql jar name in a jar name on a db classpath*/
1:eac0369: 	public static final int DBCP_SQL_JAR_NAME = 1;
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	  Scan a database classpath from the string provided. This returns
1:eac0369: 	  an array with one qualified name per entry on the classpath. The
1:eac0369: 	  constants above describe the content of the returned names. This 
1:eac0369: 	  raises an an exception if the string does not contain a valid database 
1:eac0369: 	  class path.
1:eac0369:   <PRE>
1:eac0369:       classpath := item[:item]*
1:eac0369: 	  item := id.id
1:eac0369: 	  
1:eac0369: 	  In the syntax braces ([]) show grouping. '*' means repeat 0 or more times.
1:eac0369: 	  The syntax for id is defined in IdUtil.
1:eac0369:   </PRE>
1:eac0369: 	  <BR>
1:eac0369: 	  Classpath returned is a two part name.	  <BR>
1:eac0369: 	  If the class path is empty then this returns an array
1:eac0369: 	  of zero length.
1:eac0369: 
1:eac0369: 	  @exception StandardException Oops
1:eac0369: 	  */
1:9067662: 	public static String[][] parseDbClassPath(String input)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		//As a special case we accept a zero length dbclasspath.
1:eac0369: 		if (input.length() == 0)
1:eac0369: 			return new String[0][];
1:eac0369: 
1:073b862: 		Vector<String[]> v = new Vector<String[]>();
1:eac0369: 		java.io.StringReader r = new java.io.StringReader(input);
1:eac0369: 		//
1:eac0369: 		while (true)
1:eac0369: 		{
1:eac0369: 			try {
1:9067662: 				String[] thisQName = IdUtil.parseMultiPartSQLIdentifier(r);
1:eac0369: 				if (thisQName.length != 2)
1:eac0369: 					throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,input);
1:eac0369: 
1:a32eb9f: 				v.add(thisQName);
1:eac0369: 				int delim = r.read();
1:eac0369: 				if (delim != ':')
1:eac0369: 				{
1:eac0369: 					if (delim!=-1)
1:eac0369: 						throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,input);
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			catch (StandardException se){
1:eac0369: 			    if (se.getMessageId().equals(SQLState.ID_PARSE_ERROR))
1:eac0369: 					throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,
1:eac0369: 														 se,input);
1:eac0369: 				else
1:eac0369: 					throw se;
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			catch (IOException ioe){
1:eac0369: 				throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,ioe,input);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		String[][] result = new String[v.size()][];
1:eac0369: 		v.copyInto(result);
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods that operate on lists of identifiers.
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:9ac3a76: 	  Scan a list of comma separated SQL identifiers from the string provided.
1:9ac3a76:       This returns an array with containing the normalized forms of the identifiers.
1:9ac3a76:       
1:9ac3a76:       This raises an an exception if
1:eac0369: 	  the string does not contain a valid list of names.
1:eac0369: 
1:eac0369: 	  @exception StandardException Oops
1:eac0369: 	  */
1:eac0369: 	public static String[] parseIdList(String p)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (p==null) return null;
1:eac0369: 		StringReader r = new StringReader(p);
1:eac0369: 		String[] result = parseIdList(r, true);
1:aa438ff: 		verifyEmpty(r);
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	
1:eac0369: 	/**
1:9ac3a76: 	  Parse a list of comma separated SQL identifiers returning
1:9ac3a76:       them a as elements in an array.
1:eac0369: 
1:6b50965: 	  @param normalize true means return ids in nomral form, false means
1:eac0369: 	        return them as they were entered.
1:eac0369: 
1:eac0369: 	  @exception StandardException Oops
1:eac0369: 	  */
1:eac0369: 	private static String[] parseIdList(StringReader r, boolean normalize)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:073b862: 		Vector<String> v = new Vector<String>();
1:eac0369: 		while (true)
1:eac0369: 		{
1:eac0369: 			int delim;
1:eac0369: 			try {
1:9067662: 				String thisId = IdUtil.parseId(r,normalize);
1:a32eb9f: 				v.add(thisId);
1:eac0369: 				r.mark(0);
1:eac0369: 				delim = r.read();
1:eac0369: 				if (delim != ',')
1:eac0369: 				{
1:eac0369: 					if (delim!=-1) r.reset();
1:eac0369: 					break;
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			catch (StandardException se){
1:eac0369: 				if (se.getMessageId().equals(SQLState.ID_LIST_PARSE_ERROR))
1:eac0369: 					throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR,se);
1:eac0369: 				else
1:eac0369: 					throw se;
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 			catch (IOException ioe){
2:eac0369: 				throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR,ioe);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		if (v.size() == 0) return null;
1:eac0369: 		String[] result = new String[v.size()];
1:eac0369: 		v.copyInto(result);
1:eac0369: 		return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return an IdList with all the ids that in l1 and l2
1:eac0369: 	  or null if not ids are on both lists.
1:eac0369: 
1:eac0369: 	  @param l1 An array of ids in normal form
1:eac0369: 	  @param l2 An array of ids in nomral form
1:eac0369: 	  */
1:eac0369: 	public static String intersect(String[] l1, String[] l2)
1:eac0369: 	{
1:eac0369: 		if (l1 == null || l2 == null) return null;
1:073b862: 		HashSet<String> h = new HashSet<String>();
1:eac0369: 		for(int ix=0;ix<l2.length;ix++) h.add(l2[ix]); 
1:073b862: 		Vector<String> v = new Vector<String>();
1:a32eb9f: 		for(int ix=0;ix<l1.length;ix++) if (h.contains(l1[ix])) v.add(l1[ix]);
1:eac0369: 		return vectorToIdList(v,true); 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return an idList in external form with one id for every 
1:eac0369: 	  element of v. If v has no elements, return null.
1:eac0369: 
1:eac0369: 	  @param normal True means the ids in v are in normal form
1:eac0369: 	         and false means they are in external form.
1:eac0369: 	  */
1:073b862: 	private static String vectorToIdList(Vector<String> v,boolean normal)
1:eac0369: 	{
1:eac0369: 		if (v.size() == 0) return null;
1:eac0369: 		String[] a = new String[v.size()];
1:eac0369: 		v.copyInto(a);
1:eac0369: 		if (normal)
1:eac0369: 			return mkIdList(a);
1:eac0369: 		else
1:eac0369: 			return mkIdListAsEntered(a);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:9ac3a76: 	 * Map userName to authorizationId in its normal form.
1:c8e864b: 	 * 
1:9174d61: 	 * @exception StandardException on error or userName is null
1:eac0369: 	 */
1:50ba36b: 	public static String getUserAuthorizationId(String userName) throws StandardException
1:eac0369: 	{
1:eac0369: 		try {
1:9174d61:             if (userName != null)
1:9ac3a76: 			    return parseSQLIdentifier(userName);
1:eac0369: 		}
1:50ba36b: 		catch (StandardException se) {
1:eac0369: 		}
1:9174d61:         throw StandardException.newException(SQLState.AUTH_INVALID_USER_NAME, userName);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:9067662: 	 * Get user name from URL properties (key user) without any transformation.
1:9067662:      * If the user property does not exist or is set to the empty string
1:9067662:      * then Property.DEFAULT_USER_NAME is returned.
1:c8e864b:      * 
1:9067662:      * @see Property#DEFAULT_USER_NAME
1:eac0369: 	 */
1:50ba36b: 	public static String getUserNameFromURLProps(Properties params)
2:50ba36b: 	{
1:50ba36b: 		String userName = params.getProperty(Attribute.USERNAME_ATTR,
1:50ba36b: 							Property.DEFAULT_USER_NAME);
1:50ba36b: 		if (userName.equals(""))
1:50ba36b: 			userName = Property.DEFAULT_USER_NAME;
1:eac0369: 
1:50ba36b: 		return userName;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Return an IdList with all the ids that are repeated
1:eac0369: 	  in l.
1:eac0369: 
1:eac0369: 	  @param l a list of ids in normal form.
1:eac0369: 	  */
1:eac0369: 	public static String dups(String[] l)
1:eac0369: 	{
1:eac0369: 		if (l == null) return null;
1:073b862: 		HashSet<String> h = new HashSet<String>();
1:073b862: 		Vector<String> v = new Vector<String>();
1:eac0369: 		for(int ix=0;ix<l.length;ix++)
1:eac0369: 		{
1:eac0369: 			if (!h.contains(l[ix]))
1:eac0369: 				h.add(l[ix]);
1:eac0369: 			else
1:a32eb9f: 				v.add(l[ix]);
1:eac0369: 		}
1:eac0369: 		return vectorToIdList(v,true);
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	  Return an IdList with all the duplicate ids removed
1:eac0369: 	  @param l a list of ids in external form.
1:eac0369: 	  @exception StandardException Oops.
1:eac0369: 	  */
1:eac0369: 	public static String pruneDups(String l) throws StandardException
1:eac0369: 	{
1:eac0369: 		if (l == null) return null;
1:eac0369: 		String[] normal_a = parseIdList(l);
1:eac0369: 		StringReader r = new StringReader(l);
1:eac0369: 		String[] external_a = parseIdList(r,false);
1:073b862: 		HashSet<String> h = new HashSet<String>();
1:073b862: 		Vector<String> v = new Vector<String>();
1:eac0369: 		for(int ix=0;ix<normal_a.length;ix++)
1:eac0369: 		{
1:eac0369: 			if (!h.contains(normal_a[ix]))
1:eac0369: 			{
1:eac0369: 				h.add(normal_a[ix]);
1:a32eb9f: 				v.add(external_a[ix]);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return vectorToIdList(v,false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Produce a string form of an idList from an array of
1:eac0369: 	  normalized ids.
1:eac0369: 	  */
1:eac0369: 	public static String mkIdList(String[] ids)
1:eac0369: 	{
1:eac0369: 		StringBuffer sb = new StringBuffer();
1:eac0369: 		for (int ix=0;ix<ids.length; ix++)
1:eac0369: 		{
1:eac0369: 			if (ix != 0) sb.append(",");
1:ce018f3: 			sb.append(IdUtil.normalToDelimited(ids[ix]));
1:eac0369: 		}
1:eac0369: 		return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Produce an id list from an array of ids in external form
1:eac0369: 	  */
1:eac0369: 	private static String mkIdListAsEntered(String[] externalIds )
1:eac0369: 	{
1:eac0369: 		StringBuffer sb = new StringBuffer();
1:eac0369: 		for (int ix=0;ix<externalIds.length; ix++)
1:eac0369: 		{
1:eac0369: 			if (ix != 0) sb.append(",");
1:eac0369: 			sb.append(externalIds[ix]);
1:eac0369: 		}
1:eac0369: 		return sb.toString();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:9ac3a76: 	  Return true if the normalized value of an indentifier is on the list 
1:9ac3a76:       of SQL identifiers provided.
1:eac0369: 	  @param id an id in normal form
1:6b50965: 	  @param	list a list of ids in external form.
1:eac0369: 	  @exception StandardException oops.
1:eac0369: 	  */
1:eac0369: 	public static boolean idOnList(String id, String list)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (list==null) return false;
1:eac0369: 		String[] list_a = parseIdList(list);
1:eac0369: 		for (int ix=0; ix < list_a.length; ix++)
1:eac0369: 			if (id.equals(list_a[ix])) return true;
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:9ac3a76: 	  Delete an normal value from a list of SQL identifiers.
1:9ac3a76:       The returned list maintains its remaining identifiers in the
1:9ac3a76:       format they were upon entry to the call.
1:9ac3a76:       
1:9ac3a76:       
1:0fd9a50: 	  @param id an id in normal form (quotes removed, upshifted if regular)
1:eac0369: 	  @param list a comma separated list of ids in external
1:eac0369: 	         form (possibly delmited or not upshifted).
1:eac0369: 	  @return the list with the id deleted or null if the
1:eac0369: 	    resulting list has no ids. If 'id' is not on 'list'
1:9ac3a76: 		this returns list unchanged. If list becomes empty after the removal
1:9ac3a76:         null is returned.
1:eac0369: 				 
1:eac0369: 	  @exception StandardException oops.
1:eac0369: 	  */
1:eac0369: 	public static String deleteId(String id, String list)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		if (list==null) return null;
1:073b862: 		Vector<String> v = new Vector<String>();
1:eac0369: 		StringReader r = new StringReader(list);
1:eac0369: 		String[] enteredList_a = parseIdList(r,false);
1:9ac3a76:         
1:eac0369: 		//
1:eac0369: 		//Loop through enteredList element by element
1:eac0369: 		//removing elements that match id. Before we
1:9ac3a76: 		//compare we parse each SQL indentifier in list to convert
1:eac0369: 		//to normal form.
1:eac0369: 		for (int ix=0; ix < enteredList_a.length; ix++)
1:9ac3a76: 			if (!id.equals(IdUtil.parseSQLIdentifier(enteredList_a[ix])))
1:a32eb9f: 				v.add(enteredList_a[ix]);
1:eac0369: 		if (v.size() == 0)
1:eac0369: 			return null;
1:eac0369: 		else
1:eac0369: 			return vectorToIdList(v,false);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:ce018f3:      * Append an identifier to a comma separated list
1:ce018f3:      * of identifiers. The passed in identifier is its
1:ce018f3:      * normal form, the list contains a list of SQL identifiers,
1:ce018f3:      * either regular or delimited. This routine takes the easy
1:ce018f3:      * way out and always appends a delimited identifier.
1:ce018f3: 	  @return the list with the id appended in its delimited form. 
1:eac0369: 	  @exception StandardException oops
1:eac0369: 	  */
1:ce018f3: 	public static String appendNormalToList(String id, String list)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:ce018f3:         String delimitedId = normalToDelimited(id);
1:eac0369: 		if (list==null)
1:ce018f3: 			return delimitedId;
1:eac0369: 		else
1:ce018f3: 			return list+","+delimitedId;
1:eac0369: 	}
1:0ea31ca: 
1:0ea31ca: 	/**
1:0ea31ca: 	 * Parse role identifier to internal, case normal form. It should not be
1:0ea31ca: 	 * NONE nor exceed Limits.MAX_IDENTIFIER_LENGTH.
1:0ea31ca: 	 *
1:0ea31ca: 	 * @param roleName role identifier to check (SQL form, has possible quoting)
1:0ea31ca: 	 * @return the role name to use (internal, case normal form).
1:0ea31ca: 	 * @exception StandardException normal error policy
1:0ea31ca: 	 */
1:0ea31ca: 	public static String parseRoleId(String roleName) throws StandardException
1:0ea31ca: 	{
1:b8801c5: 		roleName = roleName.trim();
1:0ea31ca: 		// NONE is a special case and is not allowed with its special
1:0ea31ca: 		// meaning in SET ROLE <value specification>. Even if there is
1:0ea31ca: 		// a role with case normal form "NONE", we require it to be
1:0ea31ca: 		// delimited here, since it would have had to be delimited to
1:0ea31ca: 		// get created, too. We could have chosen to be lenient here,
1:0ea31ca: 		// but it seems safer to be restrictive.
1:0ea31ca: 		if (StringUtil.SQLToUpperCase(roleName).equals("NONE")) {
1:0ea31ca: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1:0ea31ca: 		}
1:0ea31ca: 
1:0ea31ca: 		roleName = parseSQLIdentifier(roleName);
1:0ea31ca: 		checkIdentifierLengthLimit(roleName, Limits.MAX_IDENTIFIER_LENGTH);
1:0ea31ca: 
1:0ea31ca: 		return roleName;
1:0ea31ca: 	}
1:0ea31ca: 
1:0ea31ca: 	/**
1:0ea31ca: 	 * Check that identifier is not too long
1:0ea31ca: 	 * @param identifier identifier (in case normal form) to check
1:0ea31ca: 	 * @param identifier_length_limit maximum legal length
1:0ea31ca: 	 * @exception StandardException normal error policy
1:0ea31ca: 	 */
1:0ea31ca: 	public static void checkIdentifierLengthLimit(String identifier,
1:0ea31ca: 												  int identifier_length_limit)
1:0ea31ca: 			throws StandardException
1:0ea31ca: 	{
1:0ea31ca: 		if (identifier.length() > identifier_length_limit)
1:0ea31ca: 			throw StandardException.newException
1:0ea31ca: 				(SQLState.LANG_IDENTIFIER_TOO_LONG,
1:0ea31ca: 				 identifier,
1:0ea31ca: 				 String.valueOf(identifier_length_limit));
1:0ea31ca:     }
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 *  Argument -&gt; Return
1: 	 *  EVE      -&gt; eve       [will match Java property: derby.user.eve]
1: 	 *  eVe      -&gt; "eVe"     [will match Java property: derby.user."eVe"]
1: 	 *  "eve"    -&gt; """eve""" [will match Java property: derby.user."""eVe"""]
1: 	 *  \eve\    -&gt; "\eve\"   [will match Java property: derby.user."\eve\"]
commit:073b862
/////////////////////////////////////////////////////////////////////////
1: 		Vector<String> v = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1: 		Vector<String[]> v = new Vector<String[]>();
/////////////////////////////////////////////////////////////////////////
1: 		Vector<String> v = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1: 		HashSet<String> h = new HashSet<String>();
1: 		Vector<String> v = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1: 	private static String vectorToIdList(Vector<String> v,boolean normal)
/////////////////////////////////////////////////////////////////////////
1: 		HashSet<String> h = new HashSet<String>();
1: 		Vector<String> v = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1: 		HashSet<String> h = new HashSet<String>();
1: 		Vector<String> v = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1: 		Vector<String> v = new Vector<String>();
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:a32eb9f
/////////////////////////////////////////////////////////////////////////
1: 			v.add(thisId);
/////////////////////////////////////////////////////////////////////////
1: 				v.add(thisQName);
/////////////////////////////////////////////////////////////////////////
1: 				v.add(thisId);
/////////////////////////////////////////////////////////////////////////
1: 		for(int ix=0;ix<l1.length;ix++) if (h.contains(l1[ix])) v.add(l1[ix]);
/////////////////////////////////////////////////////////////////////////
1: 				v.add(l[ix]);
/////////////////////////////////////////////////////////////////////////
1: 				v.add(external_a[ix]);
/////////////////////////////////////////////////////////////////////////
1: 				v.add(enteredList_a[ix]);
commit:5b90cf1
/////////////////////////////////////////////////////////////////////////
1:         return StringUtil.quoteString(id, '"');
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:b8801c5
/////////////////////////////////////////////////////////////////////////
1: 		roleName = roleName.trim();
commit:0ea31ca
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Limits;
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Parse role identifier to internal, case normal form. It should not be
1: 	 * NONE nor exceed Limits.MAX_IDENTIFIER_LENGTH.
1: 	 *
1: 	 * @param roleName role identifier to check (SQL form, has possible quoting)
1: 	 * @return the role name to use (internal, case normal form).
1: 	 * @exception StandardException normal error policy
1: 	 */
1: 	public static String parseRoleId(String roleName) throws StandardException
1: 	{
0: 		roleName.trim();
1: 		// NONE is a special case and is not allowed with its special
1: 		// meaning in SET ROLE <value specification>. Even if there is
1: 		// a role with case normal form "NONE", we require it to be
1: 		// delimited here, since it would have had to be delimited to
1: 		// get created, too. We could have chosen to be lenient here,
1: 		// but it seems safer to be restrictive.
1: 		if (StringUtil.SQLToUpperCase(roleName).equals("NONE")) {
1: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1: 		}
1: 
1: 		roleName = parseSQLIdentifier(roleName);
1: 		checkIdentifierLengthLimit(roleName, Limits.MAX_IDENTIFIER_LENGTH);
1: 
1: 		return roleName;
1: 	}
1: 
1: 	/**
1: 	 * Check that identifier is not too long
1: 	 * @param identifier identifier (in case normal form) to check
1: 	 * @param identifier_length_limit maximum legal length
1: 	 * @exception StandardException normal error policy
1: 	 */
1: 	public static void checkIdentifierLengthLimit(String identifier,
1: 												  int identifier_length_limit)
1: 			throws StandardException
1: 	{
1: 		if (identifier.length() > identifier_length_limit)
1: 			throw StandardException.newException
1: 				(SQLState.LANG_IDENTIFIER_TOO_LONG,
1: 				 identifier,
1: 				 String.valueOf(identifier_length_limit));
1:     }
commit:ade6ac5
/////////////////////////////////////////////////////////////////////////
1: 	 * Given a case normal form SQL authorization identifier, convert it to a
1: 	 * authentication, which uses Java properties of the form
1: 	 * {@code derby.user.}&lt;username&gt;.
1: 	 * <p>
1: 	 * The returned form is suitable for comparing against the property string,
1: 	 * cf.  {@code systemPropertiesExistsBuiltinUser}.
1: 	 * <p>
1: 	 * E.g.:
1: 	 * <p>
1: 	 * <pre>
0: 	 *  Argument -> Return
1: 	 *  ------------------
0: 	 *  EVE      -> eve       [will match Java property: derby.user.eve]
0: 	 *  eVe      -> "eVe"     [will match Java property: derby.user."eVe"]
0: 	 *  "eve"    -> """eve""" [will match Java property: derby.user."""eVe"""]
0: 	 *  \eve\    -> "\eve\"   [will match Java property: derby.user."\eve\"]
1: 	 * The latter could look this if specified on a Unix shell command line:
1: 	 *                      -Dderby.user.'"\eve\"'=&lt;password&gt;
1: 	 * Note: The processing of properties specified on the command line do not
1: 	 * interpret backslash as escape in the way done by the
1: 	 * java.util.Properties#load method, so no extra backslash is needed above.
1: 	 * </pre>
1: 	 * Since parseSQLIdentifier maps many-to-one, the backward mapping is
1: 	 * non-unique, so the chosen lower case canonical form is arbitrary,
1: 	 * e.g. we will not be able to correctly match the non-canonical:
1: 	 * <p>
1:      * <pre>
1: 	 *                      [Java property: derby.user.eVe]
1: 	 * </pre>
1: 	 * since this is internally EVE (but see DERBY-3150), and maps back as eve
1: 	 * after the rules above.
1: 	 * @see org.apache.derby.iapi.services.property.PropertyUtil#propertiesContainsBuiltinUser
1: 	 * @see org.apache.derby.iapi.services.property.PropertyUtil#systemPropertiesExistsBuiltinUser
commit:d12a33d
/////////////////////////////////////////////////////////////////////////
1: 			result = normalToDelimited(authid);
commit:619279e
/////////////////////////////////////////////////////////////////////////
1: 				char c = authid.charAt(i);
0: 				if (c == '"') {
0: 					b.append('"'); // " must be escaped as two quotes ("")
1: 				}
0: 				b.append(c);
commit:c8e864b
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.util.IdUtil
/////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
0: 	 * Given an internal SQL authorization identifier, convert it to a
1: 	 * form that may be compared with the username of Derby builtin
0: 	 * authentication, which uses Java properties of the from
0: 	 * derby.user.<username>.
1: 	 *
0: 	 * The returned form is suitable for comparing to the property
0: 	 * string after it has been parsed by Java, e.g. any backslash
0: 	 * quotes has been processed. That is, this method does not add
0: 	 * backslash quotes, either.
1: 	 *
0: 	 * E.g.
0: 	 *  EVE -> eve   (never eVe, or EVE, or EVe: we use a lower case canonical
0: 	 *                form) [external property form: derby.user.eve]
0: 	 *  eVe -> "eVe"        [external property form: derby.user."eVe"]
0: 	 *  "eve" -> "eve"      [external property form: derby.user."\"eVe\""]
0: 	 *  \eve\ -> "\eve\"    [external property form: derby.user."\\eve\\"]
1: 	 *
0: 	 * Since parseSQLIdentifier maps many-to-one, the backward mapping
0: 	 * is non-unique, so the chosen lower case canonical from is
0: 	 * arbitrary.
1: 	 *
0: 	 * E.g. we will not be able to correctly map back the non-canonical:
1: 	 *
0: 	 *                     [external property form: derby.user.eVe]
1: 	 *
0: 	 * since this is internally EVE (but see DERBY-3150), and maps back as eve.
1: 	 *
0: 	 * Note that the returned form is not necessarily parsable back
0: 	 * using parseSQLIdentifier; it may need further quoting, cf. examples
0: 	 * above of external property forms.
1: 	 *
1: 	 */
1: 	public static String SQLIdentifier2CanonicalPropertyUsername(String authid){
1: 		boolean needsQuote = false;
1: 		String result;
1: 
1: 		for (int i=0; i < authid.length(); i++) {
0: 			char c = authid.charAt(i);
1: 			// The only external form that needs no quoting contains
1: 			// only uppercase ASCII, underscore, and if not the first
1: 			// character, a decimal number. In all other cases, we
1: 			// envelop in double quotes.
1: 			if (!( (c >= 'A' && c <= 'Z') ||
1: 				   (c == '_') ||
1: 				   (i > 0 && (c >= '0' && c <= '9')))) {
1: 				needsQuote = true;
1: 				break;
1: 			}
1: 		}
1: 
1: 		if (!needsQuote) {
1: 			result = authid.toLowerCase();
1: 		} else {
1: 			StringBuffer b = new StringBuffer();
0: 			b.append("\"");
1: 			for (int i=0; i < authid.length(); i++) {
0: 				b.append(authid.charAt(i));
1: 			}
0: 			b.append("\"");
0: 			result = b.toString();
1: 		}
1: 
1: 		return result;
1: 	}
1: 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:615b8c7
/////////////////////////////////////////////////////////////////////////
1:     @param r The multi-part identifier to be parsed
commit:aa438ff
/////////////////////////////////////////////////////////////////////////
1: 				return parseUnQId(r,normalize);
/////////////////////////////////////////////////////////////////////////
1: 	private static String parseUnQId(StringReader r, boolean normalize)
/////////////////////////////////////////////////////////////////////////
1:         
1:         String id = b.toString();
1: 			return StringUtil.SQLToUpperCase(id);
1: 			return id;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify the read is empty (no more characters in its stream).
1:      * @param r
1:      * @throws StandardException
1:      */
/////////////////////////////////////////////////////////////////////////
1: 		verifyEmpty(r);
/////////////////////////////////////////////////////////////////////////
commit:ce018f3
/////////////////////////////////////////////////////////////////////////
1:      * Produce a delimited form of a normal value.
1: 	public static String normalToDelimited(String id)
1:         
0: 		for (int ix = 0; ix < id.length(); ix++){
0: 			char currentChar = id.charAt(ix);
/////////////////////////////////////////////////////////////////////////
1:             return normalToDelimited(id2);
1:         normalToDelimited(id1) +
1:             normalToDelimited(id2);
/////////////////////////////////////////////////////////////////////////
1: 			sb.append(normalToDelimited(ids[ix]));
/////////////////////////////////////////////////////////////////////////
1: 			return normalToDelimited(b.toString()); //Put the quotes back.
/////////////////////////////////////////////////////////////////////////
1: 			sb.append(IdUtil.normalToDelimited(ids[ix]));
/////////////////////////////////////////////////////////////////////////
1:      * Append an identifier to a comma separated list
1:      * of identifiers. The passed in identifier is its
1:      * normal form, the list contains a list of SQL identifiers,
1:      * either regular or delimited. This routine takes the easy
1:      * way out and always appends a delimited identifier.
1: 	  @return the list with the id appended in its delimited form. 
1: 	public static String appendNormalToList(String id, String list)
1:         String delimitedId = normalToDelimited(id);
1: 			return delimitedId;
1: 			return list+","+delimitedId;
commit:9ac3a76
/////////////////////////////////////////////////////////////////////////
0: c
/////////////////////////////////////////////////////////////////////////
1:       Parse a SQL identifier from the String provided. Raise an excepion
1:       if the string does not contain a valid SQL indentifier.
1:       The returned String  contains the normalized form of the
1:       identifier.
1:         
1: 	public static String parseSQLIdentifier(String s)
/////////////////////////////////////////////////////////////////////////
1: 	  Scan a list of comma separated SQL identifiers from the string provided.
1:       This returns an array with containing the normalized forms of the identifiers.
1:       
1:       This raises an an exception if
/////////////////////////////////////////////////////////////////////////
1: 	  Parse a list of comma separated SQL identifiers returning
1:       them a as elements in an array.
/////////////////////////////////////////////////////////////////////////
1: 	 * Map userName to authorizationId in its normal form.
/////////////////////////////////////////////////////////////////////////
1: 			    return parseSQLIdentifier(userName);
/////////////////////////////////////////////////////////////////////////
1: 	  Return true if the normalized value of an indentifier is on the list 
1:       of SQL identifiers provided.
/////////////////////////////////////////////////////////////////////////
1: 	  Delete an normal value from a list of SQL identifiers.
1:       The returned list maintains its remaining identifiers in the
1:       format they were upon entry to the call.
1:       
1:       
1: 		this returns list unchanged. If list becomes empty after the removal
1:         null is returned.
/////////////////////////////////////////////////////////////////////////
1:         
1: 		//compare we parse each SQL indentifier in list to convert
1: 			if (!id.equals(IdUtil.parseSQLIdentifier(enteredList_a[ix])))
commit:9067662
/////////////////////////////////////////////////////////////////////////
0: 	private static String delimitId(String id)
/////////////////////////////////////////////////////////////////////////
1: 	  Parse a multi-part (dot separated) SQL identifier form the
1:       String provided. Raise an excepion
1: 	  if the string does not contain valid SQL indentifiers.
1:       The returned String array contains the normalized form of the
1:       identifiers.
1: 	public static String[] parseMultiPartSQLIdentifier(String s)
1: 		String[] qName = parseMultiPartSQLIdentifier(r);
1:     /**
1:       Parse a multi-part (dot separated) SQL identifier form the
0:       StringReader provided. Raise an excepion
1:       if the string does not contain valid SQL indentifiers.
1:       The returned String array contains the normalized form of the
1:       identifiers.
1:     
1:     @param s The string to be parsed
1:     @return An array of strings made by breaking the input string at its dots, '.'.
1:       @exception StandardException Oops
1:       */
1: 	private static String[] parseMultiPartSQLIdentifier(StringReader r)
1: 			String thisId = parseId(r,true);
/////////////////////////////////////////////////////////////////////////
1: 		String id = parseId(r,true);
/////////////////////////////////////////////////////////////////////////
1: 	private static String parseId(StringReader r, boolean normalize)
/////////////////////////////////////////////////////////////////////////
0: 				return parseUnQId(r,normalize, true);
/////////////////////////////////////////////////////////////////////////
1: 	public static String[][] parseDbClassPath(String input)
/////////////////////////////////////////////////////////////////////////
1: 				String[] thisQName = IdUtil.parseMultiPartSQLIdentifier(r);
/////////////////////////////////////////////////////////////////////////
1: 				String thisId = IdUtil.parseId(r,normalize);
/////////////////////////////////////////////////////////////////////////
1: 	 * Get user name from URL properties (key user) without any transformation.
1:      * If the user property does not exist or is set to the empty string
1:      * then Property.DEFAULT_USER_NAME is returned.
0:      * 
1:      * @see Property#DEFAULT_USER_NAME
commit:0fd9a50
/////////////////////////////////////////////////////////////////////////
0: 	private static String parseId(StringReader r, boolean normalize, boolean normalizeToUpper)
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Parse a regular identifier (unquoted) returning returning either
1:      * the value of the identifier or a delimited identifier. Ensures
1:      * that all characters in the identifer are valid for a regular identifier.
0:      * 
1:      * @param r Regular identifier to parse.
1:      * @param normalize If true return the identifer converted to a single case, otherwise return the identifier as entered.
0:      * @param normalizeToUpper
1:      * @return the value of the identifer or a delimited identifier
1:      * @throws IOException Error accessing value
1:      * @throws StandardException Error parsing identifier.
1:  
1:      */
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      * Parse a delimited (quoted) identifier returning either
1:      * the value of the identifier or a delimited identifier.
1:      * @param r Quoted identifier to parse.
1:      * @param normalize If true return a delimited identifer, otherwise return the identifier's value.
1:      * @return the value of the identifer or a delimited identifier
1:      * @throws IOException Error accessing value
1:      * @throws StandardException Error parsing identifier.
1:      */
/////////////////////////////////////////////////////////////////////////
1: 	  @param id an id in normal form (quotes removed, upshifted if regular)
commit:9174d61
/////////////////////////////////////////////////////////////////////////
1: 	 * @exception StandardException on error or userName is null
1:             if (userName != null)
0: 			    return parseId(userName);
1:         throw StandardException.newException(SQLState.AUTH_INVALID_USER_NAME, userName);
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class com.ihost.cs.IdUtil
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package com.ihost.cs
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.util;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.error.StandardException;
1: import java.io.IOException;
1: import java.io.StringReader;
1: import java.util.Vector;
1: import java.util.HashSet;
1: /**
1:   Utility class for parsing and producing string representations of
1:   ids. This class supports both delimited and un-delimited ids.
1: 
1:   <P>The syntax for an id follows. 
1:   <PRE>
1:       id := delim-id | unDelim-id
1: 
1: 	  delim-id := "[""|[any char but quote]]+"
1: 	  undelim-id := (a-z|A-Z|anyunicodeletter)[a-z|A-Z|_|0-9|anyunicodeletter|anyunicodedigit]*
1: 
1: 	  In the syntax braces show grouping. '*' means repeat 0 or more times.
1: 	  '|' means or. '+' means repeat 1 or more times. 
1:   </PRE>
1: 
1:   <P>In addition this class provides support for qualified names. A qualified name
1:   is a dot (.) separated list of ids.
1: 
1:   <P>Limitations:
1:   <OL>
1:   <LI>Unicode escape sequences in ids are not supported.
1:   <LI>Escape sequences (\n...) are not supported.
1:   </OL>
1:   */
1: public abstract class IdUtil
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 	/**
0: 	  Delimit the identifier provided.
1: 	  @return the delimited identifier.
1: 	  */
0: 	public static String delimitId(String id)
1: 	{
0: 		StringBuffer quotedBuffer = new StringBuffer();
0: 		quotedBuffer.append('\"');
0: 	    char[] charArray = id.toCharArray();
1: 
0: 		for (int ix = 0; ix < charArray.length; ix++){
0: 			char currentChar = charArray[ix];
0: 			quotedBuffer.append(currentChar);
0: 			if (currentChar == '\"')
0: 				quotedBuffer.append('\"');
1: 		}
0: 		quotedBuffer.append('\"');
1: 		
0: 		return quotedBuffer.toString();
1: 	}
1: 
1: 	/**
1: 	  Produce a delimited two part qualified name from two
1: 	  un-delimited identifiers.
1: 	  @return the result.
1: 	  */
1: 	public static String mkQualifiedName(String id1,
1: 										 String id2)
1: 	{
1:         if( null == id1)
0:             return delimitId(id2);
1: 		return
0: 			delimitId(id1) +
1: 			"." +
0: 			delimitId(id2);
1: 	}
1: 
1: 	/**
1: 	  Make a string form of a qualified name from the array of ids provided.
1: 	  */
1: 	public static String mkQualifiedName(String[] ids)
1: 	{
1: 		StringBuffer sb = new StringBuffer();
1: 		for (int ix=0; ix < ids.length; ix++)
1: 		{
1: 			if (ix!=0) sb.append(".");
0: 			sb.append(delimitId(ids[ix]));
1: 		}
1: 		return sb.toString();
1: 	}
1: 
1: 	/**
0: 	  Scan a qualified name from the String provided. Raise an excepion
0: 	  if the string does not contain a qualified name.
1:       
0:       @param s The string to be parsed
0:       @param normalizeToUpper If true then undelimited names are converted to upper case (the ANSI standard). If false then undelimited names are converted to lower case (used when the source database is Informix Foundation).
1:       @return An array of strings made by breaking the input string at its dots, '.'.
1: 	  @exception StandardException Oops
1: 	  */
0: 	public static String[] parseQualifiedName(String s, boolean normalizeToUpper)
1: 		 throws StandardException
1: 	{
1: 		StringReader r = new StringReader(s);
0: 		String[] qName = parseQualifiedName(r, normalizeToUpper);
1: 		verifyEmpty(r);
1: 		return qName;
1: 	}
1: 
1: 	/**
0: 	  Scan a qualified name from a StringReader. Return an array
0: 	  of Strings with 1 entry per name scanned. Raise an exception
0: 	  if the StringReader does not contain a valid qualified name.
1: 
0:       @param r A StringReader for the string to be parsed
0:       @param normalizeToUpper If true then undelimited names are converted to upper case (the ANSI standard). If false then undelimited names are converted to lower case (used when the source database is Informix Foundation).
1:       @return An array of strings made by breaking the input string at its dots, '.'.
1: 	  @exception StandardException Oops
1: 	  */
0: 	public static String[] parseQualifiedName(StringReader r, boolean normalizeToUpper)
1: 		 throws StandardException
1: 	{
0: 		Vector v = new Vector();
1: 		while (true)
1: 		{
0: 			String thisId = parseId(r,true, normalizeToUpper);
0: 			v.addElement(thisId);
1: 			int dot;
1: 
1: 			try {
1: 				r.mark(0);
1: 				dot = r.read();
1: 				if (dot != '.')
1: 				{
1: 					if (dot!=-1) r.reset();
1: 					break;
1: 				}
1: 			}
1: 
1: 			catch (IOException ioe){
1: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
1: 			}
1: 		}
1: 		String[] result = new String[v.size()];
1: 		v.copyInto(result);
1: 		return result;
1: 	}
1: 	
1: 	/**
0: 	  Convert the String provided to an ID. Throw an exception
0: 	  iff the string does not contain only a valid external form
0: 	  for an id. This is a convenience routine that simply
0: 	  uses getId(StringReader) to do the work.
1: 	  
0: 	  <P> See the header for getId below for restrictions.
1: 	  
1: 	  @exception StandardException Oops
1: 	  */
0: 	public static String parseId(String s)
1: 		 throws StandardException
1: 	{
1: 		StringReader r = new StringReader(s);
0: 		String id = parseId(r,true, true);
1: 		verifyEmpty(r);
1: 		return id;
1: 	}
1: 
1: 	/**
1: 	  Read an id from the StringReader provided.
1: 
1: 
0: 	  @parm nomrlaize true means return ids in nomral form, false means
1: 	        return them as they were entered.
1: 
1: 	  <P>
1: 	  Raise an exception if the first thing in the StringReader
1: 	  is not a valid id.
1: 
1: 	  @exception StandardException Ooops.
1: 	  */
0: 	public static String parseId(StringReader r, boolean normalize, boolean normalizeToUpper)
1: 		 throws StandardException
1: 	{
1: 		try {
1: 			r.mark(0);
1: 			int c = r.read();
1: 			if (c == -1)  //id can't be 0-length
1: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1:  			r.reset();
1: 			if (c == '"')
1: 				return parseQId(r,normalize);
1: 			else
0: 				return parseUnQId(r,normalize, normalizeToUpper);
1: 		}
1: 
1: 		catch (IOException ioe){
1: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
1: 		}
1: 	}
1: 
0: 	private static String parseUnQId(StringReader r, boolean normalize, boolean normalizeToUpper)
1: 		 throws IOException,StandardException
1: 	{
1: 		StringBuffer b = new StringBuffer();
1: 		int c;
1: 		boolean first;
1: 		//
1: 		for(first = true; ; first=false)
1: 		{
1: 			r.mark(0);
1: 			if (idChar(first,c=r.read()))
1: 				b.append((char)c);
1: 			else
1: 				break;
1: 		}
1: 		if (c != -1) r.reset();
1: 
1: 		if (normalize)
0: 			return normalizeToUpper ? StringUtil.SQLToUpperCase(b.toString()) : StringUtil.SQLToLowerCase(b.toString());
1: 		else
1: 			return b.toString();
1: 	}
1: 
1: 
1: 	private static boolean idChar(boolean first,int c)
1: 	{
1: 		if (((c>='a' && c<='z') || (c>='A' && c<='Z')) ||
1: 			(!first &&(c>='0' && c<='9')) || (!first &&c =='_') )
1: 			return true;
1: 		else if (Character.isLetter((char) c))
1: 			return true;
1: 		else if (!first && Character.isDigit((char) c))
1: 			return true;
1: 		return false;
1: 	}
1: 	private static String parseQId(StringReader r,boolean normalize)
1: 		 throws IOException,StandardException
1: 	{
1: 		StringBuffer b = new StringBuffer();
1: 		int c = r.read();
1: 		if (c != '"') throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1: 		while (true)
1: 		{
1: 			c=r.read();
1: 			if (c == '"')
1: 			{
1: 				r.mark(0);
1: 				int c2 = r.read();
1: 				if (c2 != '"')
1: 				{
1: 					if (c2!=-1)r.reset();
1: 					break;
1: 				}
1: 			}
1: 			else if (c == -1)
1: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1: 			
1: 			b.append((char)c);
1: 		}
1: 
1: 		if (b.length() == 0) //id can't be 0-length
1: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1: 
1: 		if (normalize)
1: 			return b.toString();
1: 		else
0: 			return delimitId(b.toString()); //Put the quotes back.
1: 	}
1: 
1: 	private static void verifyEmpty(java.io.Reader r)
1: 		 throws StandardException
1: 	{
1: 		try {
1: 			if (r.read() != -1)
1: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR);
1: 		}
1: 
1: 		catch (IOException ioe){
1: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
1: 		}			
1: 	}
1: 	/**Index of the schema name in a jar name on a db classpath*/
1: 	public static final int DBCP_SCHEMA_NAME = 0;
1: 	/**Index of the sql jar name in a jar name on a db classpath*/
1: 	public static final int DBCP_SQL_JAR_NAME = 1;
1: 	
1: 	/**
1: 	  Scan a database classpath from the string provided. This returns
1: 	  an array with one qualified name per entry on the classpath. The
1: 	  constants above describe the content of the returned names. This 
1: 	  raises an an exception if the string does not contain a valid database 
1: 	  class path.
1:   <PRE>
1:       classpath := item[:item]*
1: 	  item := id.id
1: 	  
1: 	  In the syntax braces ([]) show grouping. '*' means repeat 0 or more times.
1: 	  The syntax for id is defined in IdUtil.
1:   </PRE>
1: 	  <BR>
1: 	  Classpath returned is a two part name.	  <BR>
1: 	  If the class path is empty then this returns an array
1: 	  of zero length.
1: 
1: 	  @exception StandardException Oops
1: 	  */
0: 	public static String[][] parseDbClassPath(String input, boolean normalizeToUpper)
1: 		 throws StandardException
1: 	{
1: 		//As a special case we accept a zero length dbclasspath.
1: 		if (input.length() == 0)
1: 			return new String[0][];
1: 
0: 		Vector v = new Vector();
1: 		java.io.StringReader r = new java.io.StringReader(input);
1: 		//
1: 		while (true)
1: 		{
1: 			try {
0: 				String[] thisQName = IdUtil.parseQualifiedName(r, normalizeToUpper);
1: 				if (thisQName.length != 2)
1: 					throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,input);
1: 
0: 				v.addElement(thisQName); 
1: 				int delim = r.read();
1: 				if (delim != ':')
1: 				{
1: 					if (delim!=-1)
1: 						throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,input);
1: 					break;
1: 				}
1: 			}
1: 			
1: 			catch (StandardException se){
1: 			    if (se.getMessageId().equals(SQLState.ID_PARSE_ERROR))
1: 					throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,
1: 														 se,input);
1: 				else
1: 					throw se;
1: 			}
1: 			
1: 			catch (IOException ioe){
1: 				throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,ioe,input);
1: 			}
1: 		}
1: 		String[][] result = new String[v.size()][];
1: 		v.copyInto(result);
1: 		return result;
1: 	}
1: 
1: 
1: 	/*
1: 	** Methods that operate on lists of identifiers.
1: 	*/
1: 
1: 
1: 	/**
0: 	  Scan a list of ids from the string provided. This returns
0: 	  an array with id per entry. This raises an an exception if
1: 	  the string does not contain a valid list of names.
1: 
1: 	  @exception StandardException Oops
1: 	  */
1: 	public static String[] parseIdList(String p)
1: 		 throws StandardException
1: 	{
1: 		if (p==null) return null;
1: 		StringReader r = new StringReader(p);
1: 		String[] result = parseIdList(r, true);
0: 		verifyListEmpty(r);
1: 		return result;
1: 	}
1: 	
1: 	
1: 	/**
0: 	  Parse an idList. 
1: 
0: 	  @parm nomralize true means return ids in nomral form, false means
1: 	        return them as they were entered.
1: 
1: 	  @exception StandardException Oops
1: 	  */
1: 	private static String[] parseIdList(StringReader r, boolean normalize)
1: 		 throws StandardException
1: 	{
0: 		Vector v = new Vector();
1: 		while (true)
1: 		{
1: 			int delim;
1: 			try {
0: 				String thisId = IdUtil.parseId(r,normalize, true);
0: 				v.addElement(thisId);
1: 				r.mark(0);
1: 				delim = r.read();
1: 				if (delim != ',')
1: 				{
1: 					if (delim!=-1) r.reset();
1: 					break;
1: 				}
1: 			}
1: 			
1: 			catch (StandardException se){
1: 				if (se.getMessageId().equals(SQLState.ID_LIST_PARSE_ERROR))
1: 					throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR,se);
1: 				else
1: 					throw se;
1: 			}
1: 			
1: 			catch (IOException ioe){
1: 				throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR,ioe);
1: 			}
1: 		}
1: 		if (v.size() == 0) return null;
1: 		String[] result = new String[v.size()];
1: 		v.copyInto(result);
1: 		return result;
1: 	}
1: 
1: 	/**
1: 	  Return an IdList with all the ids that in l1 and l2
1: 	  or null if not ids are on both lists.
1: 
1: 	  @param l1 An array of ids in normal form
1: 	  @param l2 An array of ids in nomral form
1: 	  */
1: 	public static String intersect(String[] l1, String[] l2)
1: 	{
1: 		if (l1 == null || l2 == null) return null;
0: 		HashSet h = new HashSet();
1: 		for(int ix=0;ix<l2.length;ix++) h.add(l2[ix]); 
0: 		Vector v = new Vector();
0: 		for(int ix=0;ix<l1.length;ix++) if (h.contains(l1[ix])) v.addElement(l1[ix]);
1: 		return vectorToIdList(v,true); 
1: 	}
1: 
1: 	/**
1: 	  Return an idList in external form with one id for every 
1: 	  element of v. If v has no elements, return null.
1: 
1: 	  @param normal True means the ids in v are in normal form
1: 	         and false means they are in external form.
1: 	  */
0: 	private static String vectorToIdList(Vector v,boolean normal)
1: 	{
1: 		if (v.size() == 0) return null;
1: 		String[] a = new String[v.size()];
1: 		v.copyInto(a);
1: 		if (normal)
1: 			return mkIdList(a);
1: 		else
1: 			return mkIdListAsEntered(a);
1: 	}
1: 
1: 	/**
1: 	  Return an IdList with all the ids that are repeated
1: 	  in l.
1: 
1: 	  @param l a list of ids in normal form.
1: 	  */
1: 	public static String dups(String[] l)
1: 	{
1: 		if (l == null) return null;
0: 		HashSet h = new HashSet();
0: 		Vector v = new Vector();
1: 		for(int ix=0;ix<l.length;ix++)
1: 		{
1: 			if (!h.contains(l[ix]))
1: 				h.add(l[ix]);
1: 			else
0: 				v.addElement(l[ix]);
1: 		}
1: 		return vectorToIdList(v,true);
1: 	}
1: 	
1: 	/**
1: 	  Return an IdList with all the duplicate ids removed
1: 	  @param l a list of ids in external form.
1: 	  @exception StandardException Oops.
1: 	  */
1: 	public static String pruneDups(String l) throws StandardException
1: 	{
1: 		if (l == null) return null;
1: 		String[] normal_a = parseIdList(l);
1: 		StringReader r = new StringReader(l);
1: 		String[] external_a = parseIdList(r,false);
0: 		HashSet h = new HashSet();
0: 		Vector v = new Vector();
1: 		for(int ix=0;ix<normal_a.length;ix++)
1: 		{
1: 			if (!h.contains(normal_a[ix]))
1: 			{
1: 				h.add(normal_a[ix]);
0: 				v.addElement(external_a[ix]);
1: 			}
1: 		}
1: 		return vectorToIdList(v,false);
1: 	}
1: 
1: 	/**
1: 	  Produce a string form of an idList from an array of
1: 	  normalized ids.
1: 	  */
1: 	public static String mkIdList(String[] ids)
1: 	{
1: 		StringBuffer sb = new StringBuffer();
1: 		for (int ix=0;ix<ids.length; ix++)
1: 		{
1: 			if (ix != 0) sb.append(",");
0: 			sb.append(IdUtil.delimitId(ids[ix]));
1: 		}
1: 		return sb.toString();
1: 	}
1: 
1: 	/**
1: 	  Produce an id list from an array of ids in external form
1: 	  */
1: 	private static String mkIdListAsEntered(String[] externalIds )
1: 	{
1: 		StringBuffer sb = new StringBuffer();
1: 		for (int ix=0;ix<externalIds.length; ix++)
1: 		{
1: 			if (ix != 0) sb.append(",");
1: 			sb.append(externalIds[ix]);
1: 		}
1: 		return sb.toString();
1: 	}
1: 
0: 	private static void verifyListEmpty(StringReader r)
1: 		 throws StandardException
1: 	{
1: 		try {
1: 			if (r.read() != -1)
0: 				throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR);
1: 		}
1: 
1: 		catch (IOException ioe){
1: 			throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR,ioe);
1: 		}
1: 		
1: 
1: 	}
1: 
1: 	/**
0: 	  Return true if the id provided is on the list provided.
1: 	  @param id an id in normal form
0: 	  @list a list of ids in external form.
1: 	  @exception StandardException oops.
1: 	  */
1: 	public static boolean idOnList(String id, String list)
1: 		 throws StandardException
1: 	{
1: 		if (list==null) return false;
1: 		String[] list_a = parseIdList(list);
1: 		for (int ix=0; ix < list_a.length; ix++)
1: 			if (id.equals(list_a[ix])) return true;
1: 		return false;
1: 	}
1: 
1: 	/**
0: 	  Delete an id from a list of ids.
0: 	  @param id an id in normal form (quotes removed, upshifted)
1: 	  @param list a comma separated list of ids in external
1: 	         form (possibly delmited or not upshifted).
1: 	  @return the list with the id deleted or null if the
1: 	    resulting list has no ids. If 'id' is not on 'list'
0: 		this returns list unchanged.
1: 				 
1: 	  @exception StandardException oops.
1: 	  */
1: 	public static String deleteId(String id, String list)
1: 		 throws StandardException
1: 	{
1: 		if (list==null) return null;
0: 		Vector v = new Vector();
1: 		StringReader r = new StringReader(list);
1: 		String[] enteredList_a = parseIdList(r,false);
1: 		//
1: 		//Loop through enteredList element by element
1: 		//removing elements that match id. Before we
0: 		//compare we parse each id in list to convert
1: 		//to normal form.
1: 		for (int ix=0; ix < enteredList_a.length; ix++)
0: 			if (!id.equals(IdUtil.parseId(enteredList_a[ix])))
0: 				v.addElement(enteredList_a[ix]);
1: 		if (v.size() == 0)
1: 			return null;
1: 		else
1: 			return vectorToIdList(v,false);
1: 	}
1: 
1: 
1: 	/**
0: 	  Append an id in external form.
0: 	  @return the list with the id appended. 
1: 	  @exception StandardException oops
1: 	  */
0: 	public static String appendId(String id, String list)
1: 		 throws StandardException
1: 	{
1: 		if (list==null)
1: 			return id;
1: 		else
0: 			return list+","+id;
1: 	}
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:11ec54f
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	  @param normalize true means return ids in nomral form, false means
/////////////////////////////////////////////////////////////////////////
1: 	  @param normalize true means return ids in nomral form, false means
/////////////////////////////////////////////////////////////////////////
1: 	  @param	list a list of ids in external form.
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:50ba36b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.reference.Attribute;
1: import org.apache.derby.iapi.reference.Property;
1: import java.util.Properties;
0: 
/////////////////////////////////////////////////////////////////////////
0: 	 * Map userName to authorizationId
0: 	 * 
0: 	 * @exception StandardException on error
0: 	 */
1: 	public static String getUserAuthorizationId(String userName) throws StandardException
1: 	{
0: 		try {
0: 			return parseId(userName);
0: 		}
1: 		catch (StandardException se) {
0: 			throw StandardException.newException(SQLState.AUTH_INVALID_USER_NAME, userName);
0: 		}
0: 	}
0: 
0: 	/**
0: 	 * Get user name from URL properties. Handles the case of "" user.
0: 	 * 
0: 	 * @exception StandardException on error
0: 	 */
1: 	public static String getUserNameFromURLProps(Properties params)
1: 	{
1: 		String userName = params.getProperty(Attribute.USERNAME_ATTR,
1: 							Property.DEFAULT_USER_NAME);
1: 		if (userName.equals(""))
1: 			userName = Property.DEFAULT_USER_NAME;
0: 
1: 		return userName;
0: 	}
0: 
0: 	/**
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package com.ihost.cs
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.util;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.error.StandardException;
0: import java.io.IOException;
0: import java.io.StringReader;
0: import java.util.Vector;
0: import java.util.HashSet;
0: /**
0:   Utility class for parsing and producing string representations of
0:   ids. This class supports both delimited and un-delimited ids.
0: 
0:   <P>The syntax for an id follows. 
0:   <PRE>
0:       id := delim-id | unDelim-id
0: 
0: 	  delim-id := "[""|[any char but quote]]+"
0: 	  undelim-id := (a-z|A-Z|anyunicodeletter)[a-z|A-Z|_|0-9|anyunicodeletter|anyunicodedigit]*
0: 
0: 	  In the syntax braces show grouping. '*' means repeat 0 or more times.
0: 	  '|' means or. '+' means repeat 1 or more times. 
0:   </PRE>
0: 
0:   <P>In addition this class provides support for qualified names. A qualified name
0:   is a dot (.) separated list of ids.
0: 
0:   <P>Limitations:
0:   <OL>
0:   <LI>Unicode escape sequences in ids are not supported.
0:   <LI>Escape sequences (\n...) are not supported.
0:   </OL>
0:   */
0: public abstract class IdUtil
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 	/**
0: 	  Delimit the identifier provided.
0: 	  @return the delimited identifier.
0: 	  */
0: 	public static String delimitId(String id)
0: 	{
0: 		StringBuffer quotedBuffer = new StringBuffer();
0: 		quotedBuffer.append('\"');
0: 	    char[] charArray = id.toCharArray();
0: 
0: 		for (int ix = 0; ix < charArray.length; ix++){
0: 			char currentChar = charArray[ix];
0: 			quotedBuffer.append(currentChar);
0: 			if (currentChar == '\"')
0: 				quotedBuffer.append('\"');
0: 		}
0: 		quotedBuffer.append('\"');
0: 		
0: 		return quotedBuffer.toString();
0: 	}
0: 
0: 	/**
0: 	  Produce a delimited two part qualified name from two
0: 	  un-delimited identifiers.
0: 	  @return the result.
0: 	  */
0: 	public static String mkQualifiedName(String id1,
0: 										 String id2)
0: 	{
0:         if( null == id1)
0:             return delimitId(id2);
0: 		return
0: 			delimitId(id1) +
0: 			"." +
0: 			delimitId(id2);
0: 	}
0: 
0: 	/**
0: 	  Make a string form of a qualified name from the array of ids provided.
0: 	  */
0: 	public static String mkQualifiedName(String[] ids)
0: 	{
0: 		StringBuffer sb = new StringBuffer();
0: 		for (int ix=0; ix < ids.length; ix++)
0: 		{
0: 			if (ix!=0) sb.append(".");
0: 			sb.append(delimitId(ids[ix]));
0: 		}
0: 		return sb.toString();
0: 	}
0: 
0: 	/**
0: 	  Scan a qualified name from the String provided. Raise an excepion
0: 	  if the string does not contain a qualified name.
0:       
0:       @param s The string to be parsed
0:       @param normalizeToUpper If true then undelimited names are converted to upper case (the ANSI standard). If false then undelimited names are converted to lower case (used when the source database is Informix Foundation).
0:       @return An array of strings made by breaking the input string at its dots, '.'.
0: 	  @exception StandardException Oops
0: 	  */
0: 	public static String[] parseQualifiedName(String s, boolean normalizeToUpper)
0: 		 throws StandardException
0: 	{
0: 		StringReader r = new StringReader(s);
0: 		String[] qName = parseQualifiedName(r, normalizeToUpper);
0: 		verifyEmpty(r);
0: 		return qName;
0: 	}
0: 
0: 	/**
0: 	  Scan a qualified name from a StringReader. Return an array
0: 	  of Strings with 1 entry per name scanned. Raise an exception
0: 	  if the StringReader does not contain a valid qualified name.
0: 
0:       @param r A StringReader for the string to be parsed
0:       @param normalizeToUpper If true then undelimited names are converted to upper case (the ANSI standard). If false then undelimited names are converted to lower case (used when the source database is Informix Foundation).
0:       @return An array of strings made by breaking the input string at its dots, '.'.
0: 	  @exception StandardException Oops
0: 	  */
0: 	public static String[] parseQualifiedName(StringReader r, boolean normalizeToUpper)
0: 		 throws StandardException
0: 	{
0: 		Vector v = new Vector();
0: 		while (true)
0: 		{
0: 			String thisId = parseId(r,true, normalizeToUpper);
0: 			v.addElement(thisId);
0: 			int dot;
0: 
0: 			try {
0: 				r.mark(0);
0: 				dot = r.read();
0: 				if (dot != '.')
0: 				{
0: 					if (dot!=-1) r.reset();
0: 					break;
0: 				}
0: 			}
0: 
0: 			catch (IOException ioe){
0: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
0: 			}
0: 		}
0: 		String[] result = new String[v.size()];
0: 		v.copyInto(result);
0: 		return result;
0: 	}
0: 	
0: 	/**
0: 	  Convert the String provided to an ID. Throw an exception
0: 	  iff the string does not contain only a valid external form
0: 	  for an id. This is a convenience routine that simply
0: 	  uses getId(StringReader) to do the work.
0: 	  
0: 	  <P> See the header for getId below for restrictions.
0: 	  
0: 	  @exception StandardException Oops
0: 	  */
0: 	public static String parseId(String s)
0: 		 throws StandardException
0: 	{
0: 		StringReader r = new StringReader(s);
0: 		String id = parseId(r,true, true);
0: 		verifyEmpty(r);
0: 		return id;
0: 	}
0: 
0: 	/**
0: 	  Read an id from the StringReader provided.
0: 
0: 
0: 	  @parm nomrlaize true means return ids in nomral form, false means
0: 	        return them as they were entered.
0: 
0: 	  <P>
0: 	  Raise an exception if the first thing in the StringReader
0: 	  is not a valid id.
0: 
0: 	  @exception StandardException Ooops.
0: 	  */
0: 	public static String parseId(StringReader r, boolean normalize, boolean normalizeToUpper)
0: 		 throws StandardException
0: 	{
0: 		try {
0: 			r.mark(0);
0: 			int c = r.read();
0: 			if (c == -1)  //id can't be 0-length
0: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR);
0:  			r.reset();
0: 			if (c == '"')
0: 				return parseQId(r,normalize);
0: 			else
0: 				return parseUnQId(r,normalize, normalizeToUpper);
0: 		}
0: 
0: 		catch (IOException ioe){
0: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
0: 		}
0: 	}
0: 
0: 	private static String parseUnQId(StringReader r, boolean normalize, boolean normalizeToUpper)
0: 		 throws IOException,StandardException
0: 	{
0: 		StringBuffer b = new StringBuffer();
0: 		int c;
0: 		boolean first;
0: 		//
0: 		for(first = true; ; first=false)
0: 		{
0: 			r.mark(0);
0: 			if (idChar(first,c=r.read()))
0: 				b.append((char)c);
0: 			else
0: 				break;
0: 		}
0: 		if (c != -1) r.reset();
0: 
0: 		if (normalize)
0: 			return normalizeToUpper ? StringUtil.SQLToUpperCase(b.toString()) : StringUtil.SQLToLowerCase(b.toString());
0: 		else
0: 			return b.toString();
0: 	}
0: 
0: 
0: 	private static boolean idChar(boolean first,int c)
0: 	{
0: 		if (((c>='a' && c<='z') || (c>='A' && c<='Z')) ||
0: 			(!first &&(c>='0' && c<='9')) || (!first &&c =='_') )
0: 			return true;
0: 		else if (Character.isLetter((char) c))
0: 			return true;
0: 		else if (!first && Character.isDigit((char) c))
0: 			return true;
0: 		return false;
0: 	}
0: 	private static String parseQId(StringReader r,boolean normalize)
0: 		 throws IOException,StandardException
0: 	{
0: 		StringBuffer b = new StringBuffer();
0: 		int c = r.read();
0: 		if (c != '"') throw StandardException.newException(SQLState.ID_PARSE_ERROR);
0: 		while (true)
0: 		{
0: 			c=r.read();
0: 			if (c == '"')
0: 			{
0: 				r.mark(0);
0: 				int c2 = r.read();
0: 				if (c2 != '"')
0: 				{
0: 					if (c2!=-1)r.reset();
0: 					break;
0: 				}
0: 			}
0: 			else if (c == -1)
0: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR);
0: 			
0: 			b.append((char)c);
0: 		}
0: 
0: 		if (b.length() == 0) //id can't be 0-length
0: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR);
0: 
0: 		if (normalize)
0: 			return b.toString();
0: 		else
0: 			return delimitId(b.toString()); //Put the quotes back.
0: 	}
0: 
0: 	private static void verifyEmpty(java.io.Reader r)
0: 		 throws StandardException
0: 	{
0: 		try {
0: 			if (r.read() != -1)
0: 				throw StandardException.newException(SQLState.ID_PARSE_ERROR);
0: 		}
0: 
0: 		catch (IOException ioe){
0: 			throw StandardException.newException(SQLState.ID_PARSE_ERROR,ioe);
0: 		}			
0: 	}
0: 	/**Index of the schema name in a jar name on a db classpath*/
0: 	public static final int DBCP_SCHEMA_NAME = 0;
0: 	/**Index of the sql jar name in a jar name on a db classpath*/
0: 	public static final int DBCP_SQL_JAR_NAME = 1;
0: 	
0: 	/**
0: 	  Scan a database classpath from the string provided. This returns
0: 	  an array with one qualified name per entry on the classpath. The
0: 	  constants above describe the content of the returned names. This 
0: 	  raises an an exception if the string does not contain a valid database 
0: 	  class path.
0:   <PRE>
0:       classpath := item[:item]*
0: 	  item := id.id
0: 	  
0: 	  In the syntax braces ([]) show grouping. '*' means repeat 0 or more times.
0: 	  The syntax for id is defined in IdUtil.
0:   </PRE>
0: 	  <BR>
0: 	  Classpath returned is a two part name.	  <BR>
0: 	  If the class path is empty then this returns an array
0: 	  of zero length.
0: 
0: 	  @exception StandardException Oops
0: 	  */
0: 	public static String[][] parseDbClassPath(String input, boolean normalizeToUpper)
0: 		 throws StandardException
0: 	{
0: 		//As a special case we accept a zero length dbclasspath.
0: 		if (input.length() == 0)
0: 			return new String[0][];
0: 
0: 		Vector v = new Vector();
0: 		java.io.StringReader r = new java.io.StringReader(input);
0: 		//
0: 		while (true)
0: 		{
0: 			try {
0: 				String[] thisQName = IdUtil.parseQualifiedName(r, normalizeToUpper);
0: 				if (thisQName.length != 2)
0: 					throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,input);
0: 
0: 				v.addElement(thisQName); 
0: 				int delim = r.read();
0: 				if (delim != ':')
0: 				{
0: 					if (delim!=-1)
0: 						throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,input);
0: 					break;
0: 				}
0: 			}
0: 			
0: 			catch (StandardException se){
0: 			    if (se.getMessageId().equals(SQLState.ID_PARSE_ERROR))
0: 					throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,
0: 														 se,input);
0: 				else
0: 					throw se;
0: 			}
0: 			
0: 			catch (IOException ioe){
0: 				throw StandardException.newException(SQLState.DB_CLASS_PATH_PARSE_ERROR,ioe,input);
0: 			}
0: 		}
0: 		String[][] result = new String[v.size()][];
0: 		v.copyInto(result);
0: 		return result;
0: 	}
0: 
0: 
0: 	/*
0: 	** Methods that operate on lists of identifiers.
0: 	*/
0: 
0: 
0: 	/**
0: 	  Scan a list of ids from the string provided. This returns
0: 	  an array with id per entry. This raises an an exception if
0: 	  the string does not contain a valid list of names.
0: 
0: 	  @exception StandardException Oops
0: 	  */
0: 	public static String[] parseIdList(String p)
0: 		 throws StandardException
0: 	{
0: 		if (p==null) return null;
0: 		StringReader r = new StringReader(p);
0: 		String[] result = parseIdList(r, true);
0: 		verifyListEmpty(r);
0: 		return result;
0: 	}
0: 	
0: 	
0: 	/**
0: 	  Parse an idList. 
0: 
0: 	  @parm nomralize true means return ids in nomral form, false means
0: 	        return them as they were entered.
0: 
0: 	  @exception StandardException Oops
0: 	  */
0: 	private static String[] parseIdList(StringReader r, boolean normalize)
0: 		 throws StandardException
0: 	{
0: 		Vector v = new Vector();
0: 		while (true)
0: 		{
0: 			int delim;
0: 			try {
0: 				String thisId = IdUtil.parseId(r,normalize, true);
0: 				v.addElement(thisId);
0: 				r.mark(0);
0: 				delim = r.read();
0: 				if (delim != ',')
0: 				{
0: 					if (delim!=-1) r.reset();
0: 					break;
0: 				}
0: 			}
0: 			
0: 			catch (StandardException se){
0: 				if (se.getMessageId().equals(SQLState.ID_LIST_PARSE_ERROR))
0: 					throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR,se);
0: 				else
0: 					throw se;
0: 			}
0: 			
0: 			catch (IOException ioe){
0: 				throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR,ioe);
0: 			}
0: 		}
0: 		if (v.size() == 0) return null;
0: 		String[] result = new String[v.size()];
0: 		v.copyInto(result);
0: 		return result;
0: 	}
0: 
0: 	/**
0: 	  Return an IdList with all the ids that in l1 and l2
0: 	  or null if not ids are on both lists.
0: 
0: 	  @param l1 An array of ids in normal form
0: 	  @param l2 An array of ids in nomral form
0: 	  */
0: 	public static String intersect(String[] l1, String[] l2)
0: 	{
0: 		if (l1 == null || l2 == null) return null;
0: 		HashSet h = new HashSet();
0: 		for(int ix=0;ix<l2.length;ix++) h.add(l2[ix]); 
0: 		Vector v = new Vector();
0: 		for(int ix=0;ix<l1.length;ix++) if (h.contains(l1[ix])) v.addElement(l1[ix]);
0: 		return vectorToIdList(v,true); 
0: 	}
0: 
0: 	/**
0: 	  Return an idList in external form with one id for every 
0: 	  element of v. If v has no elements, return null.
0: 
0: 	  @param normal True means the ids in v are in normal form
0: 	         and false means they are in external form.
0: 	  */
0: 	private static String vectorToIdList(Vector v,boolean normal)
0: 	{
0: 		if (v.size() == 0) return null;
0: 		String[] a = new String[v.size()];
0: 		v.copyInto(a);
0: 		if (normal)
0: 			return mkIdList(a);
0: 		else
0: 			return mkIdListAsEntered(a);
0: 	}
0: 
0: 	/**
0: 	  Return an IdList with all the ids that are repeated
0: 	  in l.
0: 
0: 	  @param l a list of ids in normal form.
0: 	  */
0: 	public static String dups(String[] l)
0: 	{
0: 		if (l == null) return null;
0: 		HashSet h = new HashSet();
0: 		Vector v = new Vector();
0: 		for(int ix=0;ix<l.length;ix++)
0: 		{
0: 			if (!h.contains(l[ix]))
0: 				h.add(l[ix]);
0: 			else
0: 				v.addElement(l[ix]);
0: 		}
0: 		return vectorToIdList(v,true);
0: 	}
0: 	
0: 	/**
0: 	  Return an IdList with all the duplicate ids removed
0: 	  @param l a list of ids in external form.
0: 	  @exception StandardException Oops.
0: 	  */
0: 	public static String pruneDups(String l) throws StandardException
0: 	{
0: 		if (l == null) return null;
0: 		String[] normal_a = parseIdList(l);
0: 		StringReader r = new StringReader(l);
0: 		String[] external_a = parseIdList(r,false);
0: 		HashSet h = new HashSet();
0: 		Vector v = new Vector();
0: 		for(int ix=0;ix<normal_a.length;ix++)
0: 		{
0: 			if (!h.contains(normal_a[ix]))
0: 			{
0: 				h.add(normal_a[ix]);
0: 				v.addElement(external_a[ix]);
0: 			}
0: 		}
0: 		return vectorToIdList(v,false);
0: 	}
0: 
0: 	/**
0: 	  Produce a string form of an idList from an array of
0: 	  normalized ids.
0: 	  */
0: 	public static String mkIdList(String[] ids)
0: 	{
0: 		StringBuffer sb = new StringBuffer();
0: 		for (int ix=0;ix<ids.length; ix++)
0: 		{
0: 			if (ix != 0) sb.append(",");
0: 			sb.append(IdUtil.delimitId(ids[ix]));
0: 		}
0: 		return sb.toString();
0: 	}
0: 
0: 	/**
0: 	  Produce an id list from an array of ids in external form
0: 	  */
0: 	private static String mkIdListAsEntered(String[] externalIds )
0: 	{
0: 		StringBuffer sb = new StringBuffer();
0: 		for (int ix=0;ix<externalIds.length; ix++)
0: 		{
0: 			if (ix != 0) sb.append(",");
0: 			sb.append(externalIds[ix]);
0: 		}
0: 		return sb.toString();
0: 	}
0: 
0: 	private static void verifyListEmpty(StringReader r)
0: 		 throws StandardException
0: 	{
0: 		try {
0: 			if (r.read() != -1)
0: 				throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR);
0: 		}
0: 
0: 		catch (IOException ioe){
0: 			throw StandardException.newException(SQLState.ID_LIST_PARSE_ERROR,ioe);
0: 		}
0: 		
0: 
0: 	}
0: 
0: 	/**
0: 	  Return true if the id provided is on the list provided.
0: 	  @param id an id in normal form
0: 	  @list a list of ids in external form.
0: 	  @exception StandardException oops.
0: 	  */
0: 	public static boolean idOnList(String id, String list)
0: 		 throws StandardException
0: 	{
0: 		if (list==null) return false;
0: 		String[] list_a = parseIdList(list);
0: 		for (int ix=0; ix < list_a.length; ix++)
0: 			if (id.equals(list_a[ix])) return true;
0: 		return false;
0: 	}
0: 
0: 	/**
0: 	  Delete an id from a list of ids.
0: 	  @param id an id in normal form (quotes removed, upshifted)
0: 	  @param list a comma separated list of ids in external
0: 	         form (possibly delmited or not upshifted).
0: 	  @return the list with the id deleted or null if the
0: 	    resulting list has no ids. If 'id' is not on 'list'
0: 		this returns list unchanged.
0: 				 
0: 	  @exception StandardException oops.
0: 	  */
0: 	public static String deleteId(String id, String list)
0: 		 throws StandardException
0: 	{
0: 		if (list==null) return null;
0: 		Vector v = new Vector();
0: 		StringReader r = new StringReader(list);
0: 		String[] enteredList_a = parseIdList(r,false);
0: 		//
0: 		//Loop through enteredList element by element
0: 		//removing elements that match id. Before we
0: 		//compare we parse each id in list to convert
0: 		//to normal form.
0: 		for (int ix=0; ix < enteredList_a.length; ix++)
0: 			if (!id.equals(IdUtil.parseId(enteredList_a[ix])))
0: 				v.addElement(enteredList_a[ix]);
0: 		if (v.size() == 0)
0: 			return null;
0: 		else
0: 			return vectorToIdList(v,false);
0: 	}
0: 
0: 
0: 	/**
0: 	  Append an id in external form.
0: 	  @return the list with the id appended. 
0: 	  @exception StandardException oops
0: 	  */
0: 	public static String appendId(String id, String list)
0: 		 throws StandardException
0: 	{
0: 		if (list==null)
0: 			return id;
0: 		else
0: 			return list+","+id;
0: 	}
0: }
============================================================================