1:eac0369: /*
4:eac0369: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.conglomerate.OpenConglomerate
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.conglomerate;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException; 
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.RowUtil;
1:eac0369: import org.apache.derby.iapi.store.access.SpaceInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.RowLocation;
1:eac0369: 
1:eac0369: import java.util.Properties; 
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: A Generic class which implements the basic functionality needed to operate
1:eac0369: on an "open" conglomerate.  This class assumes the following general things
1:eac0369: about the access method.
1:eac0369: <p>
1:eac0369: The access method is page based and contained in a single container maintained
1:eac0369: by raw store.  
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public abstract class OpenConglomerate
2:eac0369: {
1:eac0369:     /**************************************************************************
1:eac0369:      * Fields of the class
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The following group of fields are all basic input parameters which are
1:eac0369:      * provided by the calling code when doing any sort of operation requiring
1:eac0369:      * an open conglomerate (openScan(), open(), openCostController(), ...).
1:eac0369:      * These are just saved values from what was initially input.
1:eac0369:      **/
1:eac0369:     private Conglomerate                    init_conglomerate;
1:eac0369:     private TransactionManager              init_xact_manager;
1:eac0369:     private Transaction                     init_rawtran;
1:eac0369:     private int                             init_openmode;
1:eac0369:     private int                             init_lock_level;
1:eac0369:     private DynamicCompiledOpenConglomInfo  init_dynamic_info;
1:eac0369:     private boolean                         init_hold;
1:eac0369:     private LockingPolicy                   init_locking_policy;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * convenience boolean's for various mode's
1:eac0369:      **/
1:eac0369:     private boolean useUpdateLocks;
1:eac0369:     private boolean forUpdate;
1:eac0369:     private boolean getBaseTableLocks;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * scratch space used for stuff like templates, export rows, ...
1:eac0369:      **/
1:eac0369:     private OpenConglomerateScratchSpace  runtime_mem;
1:eac0369: 
1:eac0369: 
1:eac0369:     /*
1:eac0369:      * The open raw store container associated with this open conglomerate
1:eac0369:      **/
1:eac0369:     private ContainerHandle container;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Constructors for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Private methods for This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * abstract methods of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return an "empty" row location object of the correct type.
1:4f7da81:      * <p>
1:4f7da81:      *
1:eac0369: 	 * @return The empty Rowlocation.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	protected abstract RowLocation newRowLocationTemplate()
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     abstract public int[] getFormatIds();
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implementing standard store row locking interfaces:
1:eac0369:      *     latchPage(RowPosition)
1:eac0369:      *     latchPageAndRepositionScan(RowPosition)
1:eac0369:      *     lockPositionForRead(RowPosition, aux_pos, moveForwardIfRowDisappears)
1:eac0369:      *     lockPositionForWrite(RowPosition, forInsert, wait)
1:eac0369:      *     unlockPositionAfterRead(RowPosition)
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369:     /**
1:eac0369:      * Latch the page containing the current RowPosition, and reposition scan.
1:eac0369:      * <p>
1:eac0369:      * Upon return the scan will hold a latch on the page to continue the
1:eac0369:      * scan on.  The scan will positioned on the record, just before the
1:eac0369:      * next record to return.
1:eac0369:      *
1:eac0369:      * Note that for both hold cursor and read uncommitted support this routine
1:eac0369:      * handles all cases of either the current position "dissappearing" (either
1:eac0369:      * the row and/or page).  The row and/or page can disappear by deleted 
1:eac0369:      * space being reclaimed post commit of that delete, and for some reason 
1:eac0369:      * the code requesting the reposition does not have locks which prevented
1:eac0369:      * the space reclamation.  Both hold cursor and read uncommitted scans are 
1:eac0369:      * examples of ways the caller will not prevent space reclamation from 
1:eac0369:      * claiming the position.
1:eac0369:      *
1:eac0369:      * This implementation also automatically updates the RowPosition to
1:eac0369:      * point at the slot containing the current RowPosition.  This slot 
1:eac0369:      * value is only valid while the latch is held.
1:eac0369:      *
1:eac0369: 	 * @return true if scan had to reposition because a row disappeared.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:bbc927c:     public boolean latchPageAndRepositionScan(RowPosition pos)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         boolean scan_repositioned = false;
1:eac0369: 
1:eac0369:         // Get the page the record handle refers to.
1:eac0369:         pos.current_page = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:bbc927c:             if (pos.current_rh != null)
1:bbc927c:             {
1:bbc927c:                 pos.current_page = 
1:bbc927c:                     container.getPage(pos.current_rh.getPageNumber());
1:bbc927c:             }
1:eac0369: 
2:eac0369:         }
1:eac0369:         catch (Throwable t)
1:eac0369:         {
1:eac0369:             // Assume all errors are caused by the page "disappearing", will
1:eac0369:             // handle this by positioning on next page in code below.
1:eac0369:             // Note that in most cases if the page does not exist, getPage()
1:eac0369:             // will return null rather than throw an exception, so this path
1:eac0369:             // is hard to reach.
1:eac0369: 
1:eac0369:             // just continue on first record of the next page.
1:eac0369:             // This should only happen if the page on which the scan was
1:eac0369:             // positioned had all of it's row deleted and the page was
1:eac0369:             // purged.
1:eac0369: 
1:eac0369:             // This can happen in a cursor held across a commit, where the
1:eac0369:             // scan needs to be repositioned after the first "next()" in the
1:eac0369:             // subsequent reopen() of the held cursor.
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (pos.current_page != null)
1:eac0369:         {
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 // reposition scan at the old position, now that latch is held.
1:eac0369:                 pos.current_slot = 
1:eac0369:                     pos.current_page.getSlotNumber(pos.current_rh);
1:eac0369:             }
1:eac0369:             catch (StandardException se)
1:eac0369:             {
1:eac0369:                 scan_repositioned = true;
1:eac0369: 
1:eac0369:                 // The record that the scan was positioned on, no longer exists.
1:eac0369:                 // The normal way this happens is if we were positioned on
1:eac0369:                 // a deleted row, without holding a lock on it, and while
1:eac0369:                 // the scan did not hold the latch on the page a post commit
1:eac0369:                 // job purged the row as part of space reclamation.   This can
1:eac0369:                 // happen in all ISOLATION level scans below serializable.
1:eac0369:                 pos.current_slot = 
1:eac0369:                     pos.current_page.getNextSlotNumber(pos.current_rh);
1:eac0369: 
1:eac0369:                 if (pos.current_slot == -1)
1:eac0369:                 {
1:eac0369:                     // in this case we there are no more rows on this page
1:eac0369:                     // to visit, so position on the next page.  In this case
1:eac0369:                     // the row that the scan was positioned on was purged,
1:eac0369:                     // and there exists no rows now which are greater than this
1:eac0369:                     // record id.
1:eac0369: 
1:eac0369:                     pos.current_page.unlatch();
1:eac0369:                     pos.current_page = null;
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     // The way scans work, need to position on the row just
1:eac0369:                     // before the one to return "next".  The first thing the
1:eac0369:                     // next loop will do is move the scan forward one row.
1:eac0369:                     pos.current_slot--;
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (pos.current_page == null)
1:eac0369:         {
1:eac0369:             // position on the next page.
1:bbc927c:             long current_pageno;
1:eac0369: 
1:bbc927c:             if (pos.current_rh != null)
1:bbc927c:             {
1:bbc927c:                 current_pageno = pos.current_rh.getPageNumber();
1:bbc927c:             }
1:bbc927c:             else if (pos.current_pageno != ContainerHandle.INVALID_PAGE_NUMBER)
1:bbc927c:             {
1:bbc927c:                 current_pageno = pos.current_pageno;
1:bbc927c:             }
1:bbc927c:             else
1:bbc927c:             {
1:bbc927c:                 // no valid position, return a null page
1:bbc927c:                 return(false);
1:bbc927c:             }
1:bbc927c: 
1:bbc927c:             pos.current_page = container.getNextPage(current_pageno);
1:bbc927c: 
1:bbc927c:             pos.current_slot   = Page.FIRST_SLOT_NUMBER - 1;
1:bbc927c: 
1:bbc927c:             // now position is tracked by active page
1:bbc927c:             pos.current_pageno = ContainerHandle.INVALID_PAGE_NUMBER;
1:eac0369: 
1:eac0369:             scan_repositioned = true;
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (scan_repositioned)
1:eac0369:         {
1:eac0369:             pos.current_rh = null;
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(scan_repositioned);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:4f7da81:      * <p>
1:eac0369:      * Latch the page containing the current RowPosition.
1:4f7da81:      * </p>
1:4f7da81:      *
1:4f7da81:      * <p>
1:eac0369:      * This implementation also automatically updates the RowPosition to
1:eac0369:      * point at the slot containing the current RowPosition.  This slot 
1:eac0369:      * value is only valid while the latch is held.
1:4f7da81:      * </p>
1:eac0369:      *
1:eac0369:      * <p>
1:4f7da81:      * If the row pointed to by {@code pos} does not exist (including the
1:4f7da81:      * case where the page itself does not exist), the page will not be
1:4f7da81:      * latched, and {@code pos.current_page} will be set to {@code null}.
1:4f7da81:      * </p>
1:4f7da81:      *
1:4f7da81:      * @param pos the position to a row on the page that should be latched
1:4f7da81:      * @return {@code true} if the page was successfully latched, or
1:4f7da81:      * {@code false} otherwise
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean latchPage(RowPosition pos)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         pos.current_page = null; 
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
3:eac0369:             pos.current_page = 
2:eac0369:                 container.getPage(pos.current_rh.getPageNumber());
1:eac0369: 
1:eac0369:         }
1:eac0369:         catch (Throwable t)
1:eac0369:         {
1:eac0369:             // Assume all errors are caused by the page "disappearing", will
1:eac0369:             // handle this by returning false indicating that row can't be 
1:eac0369:             // found.  This can easily happen when using read uncommitted 
1:eac0369:             // isolation level.
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (pos.current_page != null)
1:eac0369:         {
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 pos.current_slot = 
1:eac0369:                     pos.current_page.getSlotNumber(pos.current_rh);
1:eac0369:                 
1:eac0369:                 return(true);
1:eac0369:             }
1:eac0369:             catch (Throwable t)
1:eac0369:             {
1:eac0369:                 // Assume all errors are caused by the row "disappearing",
1:eac0369:                 // will handle this by returning false indicating that row
1:eac0369:                 // can't be found.  This can easily happen when using read
1:eac0369:                 // uncommitted isolation level.
1:eac0369: 
1:eac0369:                 pos.current_page.unlatch();
1:eac0369:                 pos.current_page = null;
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(false);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * <p>
1:eac0369:      * Lock row at given row position for read.
1:4f7da81:      * </p>
1:4f7da81:      *
1:eac0369:      * <p>
1:eac0369:      * This routine requests a row lock NOWAIT on the row located at the given
1:eac0369:      * RowPosition.  If the lock is granted NOWAIT the 
1:eac0369:      * routine will return true.  If the lock cannot be granted NOWAIT, then 
1:eac0369:      * the routine will release the latch on "page" and then it will request 
1:eac0369:      * a WAIT lock on the row.  
1:4f7da81:      * </p>
1:4f7da81:      *
1:eac0369:      * <p>
1:eac0369:      * This implementation:
1:eac0369:      * Assumes latch held on current_page.
1:eac0369:      * If the current_rh field of RowPosition is non-null it is assumed that
1:eac0369:      * we want to lock that record handle and that we don't have a slot number.
1:eac0369:      * If the current_rh field of RowPosition is null, it is assumed the we
1:eac0369:      * want to lock the indicated current_slot.  Upon return current_rh will
1:eac0369:      * point to the record handle associated with current_slot.
1:4f7da81:      * </p>
1:4f7da81:      *
1:eac0369:      * <p>
1:eac0369:      * After waiting and getting the lock on the row, this routine will fix up
1:eac0369:      * RowPosition to point at the row locked.  This means it will get the
1:eac0369:      * page latch again, and it will fix the current_slot to point at the 
1:eac0369:      * waited for record handle - it may have moved while waiting on the lock.
1:4f7da81:      * </p>
1:4f7da81:      *
1:4f7da81:      * <p>
1:4f7da81:      * When this method returns, the page holding the row pointed to by the
1:4f7da81:      * {@code RowLocation} is latched. This is however not the case if
1:4f7da81:      * {@code moveForwardIfRowDisappears} is {@code false} and the row has
1:4f7da81:      * disappeared. Then the latch will be released before the method returns,
1:4f7da81:      * and {@code pos.current_page} will be set to {@code null}.
1:4f7da81:      * </p>
1:eac0369:      *
1:eac0369:      * @param pos       Position to lock.
1:eac0369:      * @param aux_pos   If you have to give up latch to get lock, then also 
1:eac0369:      *                  unlock this position if it is non-null.
1:eac0369:      * @param moveForwardIfRowDisappears
1:eac0369:      *                  If true, then this routine must handle the case where
1:eac0369:      *                  the row id we are waiting on disappears when the latch
1:4f7da81:      *                  is released.  If false, and the row disappears, the
1:4f7da81:      *                  latch will be released again and false is returned.
1:eac0369:      * @param waitForLock
1:eac0369:      *                  if true wait for lock, if lock can't be granted NOWAIT,
1:eac0369:      *                  else if false, throw a lock timeout exception if the
1:eac0369:      *                  lock can't be granted without waiting.
1:eac0369:      *
1:eac0369: 	 * @return true if lock granted without releasing the latch, else return
1:eac0369:      *              false.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public boolean lockPositionForRead(
1:eac0369:     RowPosition pos,
1:eac0369:     RowPosition aux_pos,
1:eac0369:     boolean     moveForwardIfRowDisappears,
1:eac0369:     boolean     waitForLock)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (pos.current_rh == null)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     pos.current_page != null &&
1:eac0369:                     pos.current_slot != Page.INVALID_SLOT_NUMBER);
1:eac0369: 
1:eac0369:             }
1:eac0369: 
1:eac0369:             // work around for lockmanager problem with lock/latch releasing.
1:eac0369:             // Get RecordHandle to lock.
1:eac0369:             pos.current_rh = 
1:eac0369:                 pos.current_page.getRecordHandleAtSlot(pos.current_slot);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 // make sure current_rh and current_slot are in sync
1:eac0369:                 if (pos.current_slot !=
1:eac0369:                         pos.current_page.getSlotNumber(pos.current_rh))
1:eac0369:                 {
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "current_slot = " + pos.current_slot +
1:eac0369:                         "current_rh = " + pos.current_rh +
1:eac0369:                         "current_rh.slot = " + 
1:eac0369:                         pos.current_page.getSlotNumber(pos.current_rh));
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(pos.current_rh != null);
1:eac0369: 
1:eac0369:         boolean lock_granted_with_latch_held =
1:eac0369:             this.container.getLockingPolicy().lockRecordForRead(
1:eac0369:                 init_rawtran, container, pos.current_rh, 
1:eac0369:                 false /* NOWAIT */, forUpdate);
1:eac0369: 
1:eac0369:         if (!lock_granted_with_latch_held)
1:eac0369:         {
1:eac0369: 
1:eac0369:             // Could not get the lock NOWAIT, release latch and wait for lock.
1:eac0369:             pos.current_page.unlatch();
1:eac0369:             pos.current_page = null;
1:eac0369: 
1:eac0369: 
1:eac0369:             if (aux_pos != null)
1:eac0369:             {
1:eac0369:                 aux_pos.current_page.unlatch();
1:eac0369:                 aux_pos.current_page = null;
1:eac0369:             }
1:eac0369: 
2:eac0369:             if (!waitForLock)
1:eac0369:             {
2:eac0369:                 // throw lock timeout error.
2:eac0369:                 throw StandardException.newException(SQLState.LOCK_TIMEOUT);
1:eac0369:             }
1:eac0369: 
1:eac0369:             this.container.getLockingPolicy().lockRecordForRead(
1:eac0369:                 init_rawtran, container, pos.current_rh, 
1:eac0369:                 true /* WAIT */, forUpdate);
1:eac0369: 
1:eac0369:             if (moveForwardIfRowDisappears)
1:eac0369:             {
1:eac0369: 
1:eac0369:                 if (latchPageAndRepositionScan(pos))
1:eac0369:                 {
1:eac0369:                     if (pos.current_slot != -1)
1:eac0369:                     {
1:eac0369:                         // If scan was repositioned to just before a valid row
1:eac0369:                         // on the current page, then move forward and lock and
1:eac0369:                         // return that row (slot != -1).  
1:eac0369:                         // 
1:eac0369:                         // Let the caller handle the "-1" 
1:eac0369:                         // case, which may be one of 3 cases - need to go to 
1:eac0369:                         // slot 1 on current page, need to go to next page, 
1:eac0369:                         // need to end scan as there is no "next" page.  All
1:eac0369:                         // 3 cases are handled by the generic scan loop in 
1:eac0369:                         // GenericScanController.fetchRows().
1:eac0369: 
1:eac0369:                         pos.positionAtNextSlot();
1:eac0369:                         lockPositionForRead(pos, aux_pos, true, true);
1:eac0369: 
1:eac0369:                     }
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 latchPage(pos);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(lock_granted_with_latch_held);
1:eac0369:     }
1:eac0369: 
1:4f7da81:     /**
1:4f7da81:      * <p>
1:4f7da81:      * Lock the row at the given position for write.
1:4f7da81:      * </p>
1:4f7da81:      *
1:4f7da81:      * <p>
1:4f7da81:      * The page pointed to by the {@code RowPosition} is assumed to be latched
1:4f7da81:      * when this method is called. If the lock cannot be obtained without
1:4f7da81:      * waiting, the latch will be released and re-obtained when the lock has
1:4f7da81:      * been acquired.
1:4f7da81:      * </p>
1:4f7da81:      *
1:4f7da81:      * <p>
1:4f7da81:      * If the latch was released while waiting for the lock, and the row does
1:4f7da81:      * not exist after the lock is obtained, the latch will be released again
1:4f7da81:      * before the method returns, and {@code pos.current_page} will be set to
1:4f7da81:      * {@code null}.
1:4f7da81:      * </p>
1:4f7da81:      */
1:eac0369:     public boolean lockPositionForWrite(
1:eac0369:     RowPosition pos,
1:eac0369:     boolean     waitForLock)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (pos.current_rh == null)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.ASSERT(pos.current_page != null);
1:eac0369:                 SanityManager.ASSERT(
1:eac0369:                     pos.current_slot != Page.INVALID_SLOT_NUMBER);
1:eac0369: 
1:eac0369:             }
1:eac0369: 
1:eac0369:             // work around for lockmanager problem with lock/latch releasing.
1:eac0369:             // Get RecordHandle to lock.
1:eac0369:             pos.current_rh = 
1:eac0369:                 pos.current_page.fetchFromSlot(
1:eac0369:                     null, 
1:eac0369:                     pos.current_slot, 
1:eac0369:                     RowUtil.EMPTY_ROW, 
1:eac0369:                     RowUtil.EMPTY_ROW_FETCH_DESCRIPTOR, 
1:eac0369:                     true);
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 // make sure current_rh and current_slot are in sync
1:eac0369:                 if (pos.current_slot !=
1:eac0369:                         pos.current_page.getSlotNumber(pos.current_rh))
1:eac0369:                 {
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "current_slot = " + pos.current_slot +
1:eac0369:                         "current_rh = " + pos.current_rh +
1:eac0369:                         "current_rh.slot = " + 
1:eac0369:                         pos.current_page.getSlotNumber(pos.current_rh));
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(pos.current_rh != null);
1:eac0369: 
1:20cc6f6:         // This method is only used for locking existing rows, never for
1:20cc6f6:         // insert operations.
1:20cc6f6:         final boolean forInsert = false;
1:20cc6f6: 
1:eac0369:         boolean lock_granted_with_latch_held =
1:eac0369:             this.container.getLockingPolicy().
1:eac0369:                 lockRecordForWrite(
1:eac0369:                     init_rawtran, pos.current_rh, 
1:eac0369:                     forInsert, false /* NOWAIT */);
1:eac0369: 
1:eac0369:         if (!lock_granted_with_latch_held)
1:eac0369:         {
1:eac0369:             // Could not get the lock NOWAIT, release latch and wait for lock.
1:eac0369:             pos.current_page.unlatch();
1:eac0369:             pos.current_page = null;
1:eac0369: 
1:eac0369:             if (!waitForLock)
1:eac0369:             {
1:eac0369:                 // throw lock timeout error.
1:eac0369:                 throw StandardException.newException(SQLState.LOCK_TIMEOUT);
1:eac0369:             }
1:eac0369: 
1:eac0369:             this.container.getLockingPolicy().
1:eac0369:                 lockRecordForWrite(
1:eac0369:                     init_rawtran, pos.current_rh, forInsert, true /* WAIT */);
1:eac0369: 
1:eac0369:             latchPage(pos);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(lock_granted_with_latch_held);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Unlock the record after a previous request to lock it.
1:eac0369:      * <p>
1:eac0369:      * Unlock the record after a previous call to lockRecordForRead().  It is
1:eac0369:      * expected that RowPosition contains information used to lock the record,
1:eac0369:      * Thus it is important if using a single RowPosition to track a scan to
1:eac0369:      * call unlock before you move the position forward to the next record.
1:eac0369:      * <p>
1:eac0369:      * Note that this routine assumes that the row was locked forUpdate if
1:eac0369:      * the OpenConglomerate is forUpdate, else it assumes the record was
1:eac0369:      * locked for read.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void unlockPositionAfterRead(
1:eac0369:     RowPosition pos) 
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (!isClosed())
1:eac0369:             container.getLockingPolicy().
1:eac0369:                 unlockRecordAfterRead(
1:eac0369:                     init_rawtran, container, pos.current_rh, forUpdate, 
1:eac0369:                     pos.current_rh_qualified);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implementing ConglomPropertyQueryable Interface: 
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Request set of properties associated with a table. 
1:eac0369:      * <p>
1:eac0369:      * Returns a property object containing all properties that the store
1:eac0369:      * knows about, which are stored persistently by the store.  This set
1:eac0369:      * of properties may vary from implementation to implementation of the
1:eac0369:      * store.
1:eac0369:      * <p>
1:eac0369:      * This call is meant to be used only for internal query of the properties
1:eac0369:      * by jbms, for instance by language during bulk insert so that it can
1:eac0369:      * create a new conglomerate which exactly matches the properties that
1:eac0369:      * the original container was created with.  This call should not be used
1:eac0369:      * by the user interface to present properties to users as it may contain
1:eac0369:      * properties that are meant to be internal to jbms.  Some properties are 
1:eac0369:      * meant only to be specified by jbms code and not by users on the command
1:eac0369:      * line.
1:eac0369:      * <p>
1:eac0369:      * Note that not all properties passed into createConglomerate() are stored
1:eac0369:      * persistently, and that set may vary by store implementation.
1:eac0369:      *
1:eac0369:      * @param prop   Property list to add properties to.  If null, routine will
1:eac0369:      *               create a new Properties object, fill it in and return it.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public Properties getInternalTablePropertySet(Properties prop)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         Properties  ret_properties = 
1:eac0369:             ConglomerateUtil.createRawStorePropertySet(prop);
1:eac0369: 
1:eac0369:         getTableProperties(ret_properties);
1:eac0369: 
1:eac0369:         return(ret_properties);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Request the system properties associated with a table. 
1:eac0369:      * <p>
1:eac0369:      * Request the value of properties that are associated with a table.  The
1:eac0369:      * following properties can be requested:
1:eac0369:      *     derby.storage.pageSize 
1:eac0369:      *     derby.storage.pageReservedSpace
1:eac0369:      *     derby.storage.minimumRecordSize
1:eac0369:      *     derby.storage.initialPages
1:eac0369:      * <p>
1:eac0369:      * To get the value of a particular property add it to the property list,
1:eac0369:      * and on return the value of the property will be set to it's current 
1:eac0369:      * value.  For example:
1:eac0369:      *
1:eac0369:      * get_prop(ConglomerateController cc)
1:eac0369:      * {
1:eac0369:      *     Properties prop = new Properties();
1:eac0369:      *     prop.put("derby.storage.pageSize", "");
1:eac0369:      *     cc.getTableProperties(prop);
1:eac0369:      *
1:eac0369:      *     System.out.println(
1:eac0369:      *         "table's page size = " + 
1:eac0369:      *         prop.getProperty("derby.storage.pageSize");
1:eac0369:      * }
1:eac0369:      *
1:eac0369:      * @param prop   Property list to fill in.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void getTableProperties(Properties prop)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         container.getContainerProperties(prop);
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Accessors of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369:     public final TransactionManager getXactMgr()
1:eac0369:     {
1:eac0369:         return(init_xact_manager);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final Transaction getRawTran()
1:eac0369:     {
1:eac0369:         return(init_rawtran);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final ContainerHandle getContainer()
1:eac0369:     {
1:eac0369:         return(container);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final int getOpenMode()
1:eac0369:     {
1:eac0369:         return(init_openmode);
1:eac0369:     }
1:eac0369:     
1:eac0369:     public final Conglomerate getConglomerate()
1:eac0369:     {
1:eac0369:         return(init_conglomerate);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final boolean getHold()
1:eac0369:     {
1:eac0369:         return(init_hold);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     public final boolean isForUpdate()
1:eac0369:     {
1:eac0369:         return(forUpdate);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final boolean isClosed()
1:eac0369:     {
1:eac0369:         return(container == null);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final boolean isUseUpdateLocks()
1:eac0369:     {
1:eac0369:         return(useUpdateLocks);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final OpenConglomerateScratchSpace getRuntimeMem()
1:eac0369:     {
1:eac0369:         return(runtime_mem);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods implementing some ConglomerateController Interfaces: 
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Check consistency of a conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Checks the consistency of the data within a given conglomerate, does not
1:eac0369:      * check consistency external to the conglomerate (ie. does not check that 
1:eac0369:      * base table row pointed at by a secondary index actually exists).
1:eac0369:      * <p>
1:eac0369:      * There is no checking in the default implementation, you must override
1:eac0369:      * to get conglomerate specific consistency checking.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void checkConsistency()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:     public void debugConglomerate()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.DEBUG_PRINT(
1:eac0369:                 "p_heap", "\nHEAP DUMP:containerId " + container.getId());
1:eac0369: 
1:eac0369:             // get a template.
1:eac0369: 
1:722a889:             DataValueDescriptor[] row = 
1:722a889:                 runtime_mem.get_row_for_export(getRawTran());
1:eac0369: 
1:eac0369:             // Print pages of the heap.
1:eac0369:             Page page = container.getFirstPage();
1:eac0369: 
1:eac0369:             while (page != null)
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG_PRINT(
1:eac0369:                     "p_heap", ConglomerateUtil.debugPage(page, 0, false, row));
1:eac0369: 
1:eac0369:                 long pageid = page.getPageNumber();
1:eac0369:                 page.unlatch();
1:eac0369:                 page = container.getNextPage(pageid);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Get information about space used by the conglomerate.
1:eac0369:     **/
1:eac0369:     public SpaceInfo getSpaceInfo()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return container.getSpaceInfo();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	protected boolean isKeyed()
1:eac0369: 	{
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * is the open btree table locked?
1:eac0369:      **/
1:eac0369:     protected boolean isTableLocked()
1:eac0369:     {
1:eac0369:         return(init_lock_level == TransactionController.MODE_TABLE);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of this class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Open the container.
1:eac0369:      * <p>
1:eac0369:      * Open the container, obtaining necessary locks.  Most work is actually
1:eac0369:      * done by RawStore.openContainer().  
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public ContainerHandle init(
1:eac0369:     ContainerHandle                 open_container,
1:eac0369:     Conglomerate                    conglomerate,
1:eac0369:     int[]                           format_ids,
1:722a889:     int[]                           collation_ids,
1:eac0369:     TransactionManager              xact_manager,
1:eac0369:     Transaction                     rawtran,
1:eac0369:     boolean                         hold,
1:eac0369:     int                             openmode,
1:eac0369:     int                             lock_level,
1:eac0369:     LockingPolicy                   locking_policy,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // save state of all inputs.
1:eac0369:         init_conglomerate       = conglomerate;
1:eac0369:         init_xact_manager       = xact_manager;
1:eac0369:         init_rawtran            = rawtran;
1:eac0369:         init_openmode           = openmode;
1:eac0369:         init_lock_level         = lock_level;
1:eac0369:         init_dynamic_info       = dynamic_info;
1:eac0369:         init_hold               = hold;
1:eac0369:         init_locking_policy     = locking_policy;
1:eac0369: 
1:eac0369: 
1:eac0369:         // either use passed in "compiled" runtime scratch space, or create
1:eac0369:         // new space.
1:eac0369:         this.runtime_mem    = 
1:eac0369:             (dynamic_info != null ? 
1:eac0369:              ((OpenConglomerateScratchSpace) dynamic_info) : 
1:9a3cbed:              ((OpenConglomerateScratchSpace)
1:9a3cbed:                 conglomerate.getDynamicCompiledConglomInfo()));
1:eac0369: 
1:eac0369:         // Is this an open for update or read?  This will
1:eac0369: 		// be passed down to the raw store fetch methods, which allows
1:eac0369: 		// it to do the appropriate locking.
1:eac0369: 		this.forUpdate = 
1:eac0369:             ((openmode & ContainerHandle.MODE_FORUPDATE) != 0); 
1:eac0369: 
1:eac0369:         // keep track of whether this open conglomerate should use update locks.
1:eac0369: 		this.useUpdateLocks = 
1:eac0369:             ((openmode & ContainerHandle.MODE_USE_UPDATE_LOCKS) != 0);
1:eac0369: 
1:eac0369:         // If this flag is set, then the client has already locked the row
1:eac0369:         // by accessing it through the secondary index and has already locked
1:eac0369:         // the row, so the base conglomerate need not re-lock the row.
1:eac0369:         this.getBaseTableLocks =
1:eac0369:             ((openmode & ContainerHandle.MODE_SECONDARY_LOCKED) == 0);
1:eac0369: 
1:eac0369: 		// if the conglomerate is temporary, open with IS_KEPT set.
1:eac0369: 		// RESOLVE(mikem): track 1825
1:eac0369: 		// don't want to open temp cantainer with IS_KEPT always.
1:eac0369:         if (conglomerate.isTemporary())
1:eac0369:         {
1:eac0369: 			init_openmode |= ContainerHandle.MODE_TEMP_IS_KEPT;
1:eac0369:         }
1:eac0369: 
1:eac0369:         if (!getBaseTableLocks)
1:eac0369:             init_locking_policy = null;
1:eac0369: 
1:eac0369: 		// Open the container. 
1:eac0369:         this.container = 
1:eac0369:             (open_container != null ?  
1:eac0369:                  open_container : 
1:eac0369:                  rawtran.openContainer(
1:eac0369:                     conglomerate.getId(), init_locking_policy, init_openmode));
1:eac0369: 
1:eac0369:         return(this.container);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Open the container.
1:eac0369:      * <p>
1:eac0369:      * Open the container, obtaining necessary locks.  Most work is actually
1:eac0369:      * done by RawStore.openContainer().  Will only reopen() if the container
1:eac0369:      * is not already open.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public ContainerHandle reopen()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // reget transaction from context manager, in the case of XA
1:eac0369:         // transaction this may have changed.
1:eac0369:         //
1:eac0369:         /* TODO - XA transactions my change the current transaction on the 
1:eac0369:          * context stack.  Will want to something like:
1:eac0369:          *
1:eac0369:          * init_rawtran = context_manager.getcurrenttransaction()
1:eac0369:          */
1:eac0369:      
1:eac0369:         if (this.container == null)
1:eac0369:         {
1:eac0369:             this.container = 
1:eac0369:                  init_rawtran.openContainer(
1:eac0369:                     init_conglomerate.getId(), 
1:eac0369:                     init_locking_policy, 
1:eac0369:                     init_openmode);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(this.container);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Close the container.
1:eac0369:      * <p>
1:eac0369:      * Handles being closed more than once.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void close()
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		if (container != null)
1:eac0369:         {
1:eac0369: 			container.close();
1:eac0369:             container = null;
1:eac0369:         }
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:9a3cbed
/////////////////////////////////////////////////////////////////////////
1:              ((OpenConglomerateScratchSpace)
1:                 conglomerate.getDynamicCompiledConglomInfo()));
commit:fa09146
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:20cc6f6
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // This method is only used for locking existing rows, never for
1:         // insert operations.
1:         final boolean forInsert = false;
1: 
commit:e472df1
/////////////////////////////////////////////////////////////////////////
commit:4f7da81
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * </p>
1:      *
1:      * </p>
1:      *
1:      * <p>
1:      * If the row pointed to by {@code pos} does not exist (including the
1:      * case where the page itself does not exist), the page will not be
1:      * latched, and {@code pos.current_page} will be set to {@code null}.
1:      * </p>
1:      *
1:      * @param pos the position to a row on the page that should be latched
1:      * @return {@code true} if the page was successfully latched, or
1:      * {@code false} otherwise
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * </p>
1:      *
1:      * </p>
1:      *
/////////////////////////////////////////////////////////////////////////
1:      * </p>
1:      *
1:      * </p>
1:      *
1:      * <p>
1:      * When this method returns, the page holding the row pointed to by the
1:      * {@code RowLocation} is latched. This is however not the case if
1:      * {@code moveForwardIfRowDisappears} is {@code false} and the row has
1:      * disappeared. Then the latch will be released before the method returns,
1:      * and {@code pos.current_page} will be set to {@code null}.
1:      * </p>
/////////////////////////////////////////////////////////////////////////
1:      *                  is released.  If false, and the row disappears, the
1:      *                  latch will be released again and false is returned.
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Lock the row at the given position for write.
1:      * </p>
1:      *
1:      * <p>
1:      * The page pointed to by the {@code RowPosition} is assumed to be latched
1:      * when this method is called. If the lock cannot be obtained without
1:      * waiting, the latch will be released and re-obtained when the lock has
1:      * been acquired.
1:      * </p>
1:      *
1:      * <p>
1:      * If the latch was released while waiting for the lock, and the row does
1:      * not exist after the lock is obtained, the latch will be released again
1:      * before the method returns, and {@code pos.current_page} will be set to
1:      * {@code null}.
1:      * </p>
1:      */
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:722a889
/////////////////////////////////////////////////////////////////////////
1:             DataValueDescriptor[] row = 
1:                 runtime_mem.get_row_for_export(getRawTran());
/////////////////////////////////////////////////////////////////////////
1:     int[]                           collation_ids,
/////////////////////////////////////////////////////////////////////////
0:              new OpenConglomerateScratchSpace(format_ids, collation_ids));
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public boolean latchPageAndRepositionScan(RowPosition pos)
/////////////////////////////////////////////////////////////////////////
1:             if (pos.current_rh != null)
1:             {
1:                 pos.current_page = 
1:                     container.getPage(pos.current_rh.getPageNumber());
1:             }
/////////////////////////////////////////////////////////////////////////
1:             long current_pageno;
1:             if (pos.current_rh != null)
1:             {
1:                 current_pageno = pos.current_rh.getPageNumber();
1:             }
1:             else if (pos.current_pageno != ContainerHandle.INVALID_PAGE_NUMBER)
1:             {
1:                 current_pageno = pos.current_pageno;
1:             }
1:             else
1:             {
1:                 // no valid position, return a null page
1:                 return(false);
1:             }
1: 
1:             pos.current_page = container.getNextPage(current_pageno);
1: 
1:             pos.current_slot   = Page.FIRST_SLOT_NUMBER - 1;
1: 
1:             // now position is tracked by active page
1:             pos.current_pageno = ContainerHandle.INVALID_PAGE_NUMBER;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.conglomerate.OpenConglomerate
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.conglomerate
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.conglomerate;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException; 
1: 
1: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1: 
0: import org.apache.derby.iapi.store.access.ConglomPropertyQueryable;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowUtil;
1: import org.apache.derby.iapi.store.access.SpaceInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import java.util.Properties; 
1: 
1: 
1: /**
1: 
1: A Generic class which implements the basic functionality needed to operate
1: on an "open" conglomerate.  This class assumes the following general things
1: about the access method.
1: <p>
1: The access method is page based and contained in a single container maintained
1: by raw store.  
1: 
1: **/
1: 
1: public abstract class OpenConglomerate
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * The following group of fields are all basic input parameters which are
1:      * provided by the calling code when doing any sort of operation requiring
1:      * an open conglomerate (openScan(), open(), openCostController(), ...).
1:      * These are just saved values from what was initially input.
1:      **/
1:     private Conglomerate                    init_conglomerate;
1:     private TransactionManager              init_xact_manager;
1:     private Transaction                     init_rawtran;
1:     private int                             init_openmode;
1:     private int                             init_lock_level;
1:     private DynamicCompiledOpenConglomInfo  init_dynamic_info;
1:     private boolean                         init_hold;
1:     private LockingPolicy                   init_locking_policy;
1: 
1: 
1:     /**
1:      * convenience boolean's for various mode's
1:      **/
1:     private boolean useUpdateLocks;
1:     private boolean forUpdate;
1:     private boolean getBaseTableLocks;
1: 
1:     /**
1:      * scratch space used for stuff like templates, export rows, ...
1:      **/
1:     private OpenConglomerateScratchSpace  runtime_mem;
1: 
1: 
1:     /*
1:      * The open raw store container associated with this open conglomerate
1:      **/
1:     private ContainerHandle container;
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Private methods for This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * abstract methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Return an "empty" row location object of the correct type.
1:      * <p>
1:      *
1: 	 * @return The empty Rowlocation.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	protected abstract RowLocation newRowLocationTemplate()
1: 		throws StandardException;
1: 
1:     abstract public int[] getFormatIds();
1: 
1: 
1:     /**************************************************************************
1:      * Public Methods implementing standard store row locking interfaces:
1:      *     latchPage(RowPosition)
1:      *     latchPageAndRepositionScan(RowPosition)
1:      *     lockPositionForRead(RowPosition, aux_pos, moveForwardIfRowDisappears)
1:      *     lockPositionForWrite(RowPosition, forInsert, wait)
1:      *     unlockPositionAfterRead(RowPosition)
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Latch the page containing the current RowPosition, and reposition scan.
1:      * <p>
1:      * Upon return the scan will hold a latch on the page to continue the
1:      * scan on.  The scan will positioned on the record, just before the
1:      * next record to return.
1:      *
1:      * Note that for both hold cursor and read uncommitted support this routine
1:      * handles all cases of either the current position "dissappearing" (either
1:      * the row and/or page).  The row and/or page can disappear by deleted 
1:      * space being reclaimed post commit of that delete, and for some reason 
1:      * the code requesting the reposition does not have locks which prevented
1:      * the space reclamation.  Both hold cursor and read uncommitted scans are 
1:      * examples of ways the caller will not prevent space reclamation from 
1:      * claiming the position.
1:      *
1:      * This implementation also automatically updates the RowPosition to
1:      * point at the slot containing the current RowPosition.  This slot 
1:      * value is only valid while the latch is held.
1:      *
1: 	 * @return true if scan had to reposition because a row disappeared.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     protected boolean latchPageAndRepositionScan(RowPosition pos)
1: 		throws StandardException
1:     {
1:         boolean scan_repositioned = false;
1: 
1:         // Get the page the record handle refers to.
1:         pos.current_page = null;
1: 
1:         try
1:         {
1:             pos.current_page = 
1:                 container.getPage(pos.current_rh.getPageNumber());
1: 
1:         }
1:         catch (Throwable t)
1:         {
1:             // Assume all errors are caused by the page "disappearing", will
1:             // handle this by positioning on next page in code below.
1:             // Note that in most cases if the page does not exist, getPage()
1:             // will return null rather than throw an exception, so this path
1:             // is hard to reach.
1: 
1:             // just continue on first record of the next page.
1:             // This should only happen if the page on which the scan was
1:             // positioned had all of it's row deleted and the page was
1:             // purged.
1: 
1:             // This can happen in a cursor held across a commit, where the
1:             // scan needs to be repositioned after the first "next()" in the
1:             // subsequent reopen() of the held cursor.
1:         }
1: 
1:         if (pos.current_page != null)
1:         {
1:             try
1:             {
1:                 // reposition scan at the old position, now that latch is held.
1:                 pos.current_slot = 
1:                     pos.current_page.getSlotNumber(pos.current_rh);
1:             }
1:             catch (StandardException se)
1:             {
1:                 scan_repositioned = true;
1: 
1:                 // The record that the scan was positioned on, no longer exists.
1:                 // The normal way this happens is if we were positioned on
1:                 // a deleted row, without holding a lock on it, and while
1:                 // the scan did not hold the latch on the page a post commit
1:                 // job purged the row as part of space reclamation.   This can
1:                 // happen in all ISOLATION level scans below serializable.
1:                 pos.current_slot = 
1:                     pos.current_page.getNextSlotNumber(pos.current_rh);
1: 
1:                 if (pos.current_slot == -1)
1:                 {
1:                     // in this case we there are no more rows on this page
1:                     // to visit, so position on the next page.  In this case
1:                     // the row that the scan was positioned on was purged,
1:                     // and there exists no rows now which are greater than this
1:                     // record id.
1: 
1:                     pos.current_page.unlatch();
1:                     pos.current_page = null;
1:                 }
1:                 else
1:                 {
1:                     // The way scans work, need to position on the row just
1:                     // before the one to return "next".  The first thing the
1:                     // next loop will do is move the scan forward one row.
1:                     pos.current_slot--;
1:                 }
1:             }
1:         }
1: 
1:         if (pos.current_page == null)
1:         {
1:             // position on the next page.
1:             pos.current_page = 
0:                 container.getNextPage(pos.current_rh.getPageNumber());
1: 
0:             pos.current_slot = Page.FIRST_SLOT_NUMBER - 1;
1: 
1:             scan_repositioned = true;
1:         }
1: 
1:         if (scan_repositioned)
1:         {
1:             pos.current_rh = null;
1:         }
1: 
1:         return(scan_repositioned);
1:     }
1: 
1:     /**
1:      * Latch the page containing the current RowPosition.
1:      * <p>
1:      * This implementation also automatically updates the RowPosition to
1:      * point at the slot containing the current RowPosition.  This slot 
1:      * value is only valid while the latch is held.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean latchPage(RowPosition pos)
1: 		throws StandardException
1:     {
1:         pos.current_page = null; 
1: 
1:         try
1:         {
1:             pos.current_page = 
1:                 container.getPage(pos.current_rh.getPageNumber());
1: 
1:         }
1:         catch (Throwable t)
1:         {
1:             // Assume all errors are caused by the page "disappearing", will
1:             // handle this by returning false indicating that row can't be 
1:             // found.  This can easily happen when using read uncommitted 
1:             // isolation level.
1:         }
1: 
1:         if (pos.current_page != null)
1:         {
1:             try
1:             {
1:                 pos.current_slot = 
1:                     pos.current_page.getSlotNumber(pos.current_rh);
1:                 
1:                 return(true);
1:             }
1:             catch (Throwable t)
1:             {
1:                 // Assume all errors are caused by the row "disappearing",
1:                 // will handle this by returning false indicating that row
1:                 // can't be found.  This can easily happen when using read
1:                 // uncommitted isolation level.
1: 
1:                 pos.current_page.unlatch();
1:                 pos.current_page = null;
1:             }
1:         }
1: 
1:         return(false);
1:     }
1: 
1: 
1:     /**
1:      * Lock row at given row position for read.
1:      * <p>
1:      * This routine requests a row lock NOWAIT on the row located at the given
1:      * RowPosition.  If the lock is granted NOWAIT the 
1:      * routine will return true.  If the lock cannot be granted NOWAIT, then 
1:      * the routine will release the latch on "page" and then it will request 
1:      * a WAIT lock on the row.  
1:      * <p>
1:      * This implementation:
1:      * Assumes latch held on current_page.
1:      * If the current_rh field of RowPosition is non-null it is assumed that
1:      * we want to lock that record handle and that we don't have a slot number.
1:      * If the current_rh field of RowPosition is null, it is assumed the we
1:      * want to lock the indicated current_slot.  Upon return current_rh will
1:      * point to the record handle associated with current_slot.
1:      * <p>
1:      * After waiting and getting the lock on the row, this routine will fix up
1:      * RowPosition to point at the row locked.  This means it will get the
1:      * page latch again, and it will fix the current_slot to point at the 
1:      * waited for record handle - it may have moved while waiting on the lock.
1:      *
1:      * @param pos       Position to lock.
1:      * @param aux_pos   If you have to give up latch to get lock, then also 
1:      *                  unlock this position if it is non-null.
1:      * @param moveForwardIfRowDisappears
1:      *                  If true, then this routine must handle the case where
1:      *                  the row id we are waiting on disappears when the latch
0:      *                  is released.  If false an exception will be thrown if
0:      *                  the row disappears.
1:      * @param waitForLock
1:      *                  if true wait for lock, if lock can't be granted NOWAIT,
1:      *                  else if false, throw a lock timeout exception if the
1:      *                  lock can't be granted without waiting.
1:      *
1: 	 * @return true if lock granted without releasing the latch, else return
1:      *              false.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public boolean lockPositionForRead(
1:     RowPosition pos,
1:     RowPosition aux_pos,
1:     boolean     moveForwardIfRowDisappears,
1:     boolean     waitForLock)
1:         throws StandardException
1:     {
1:         if (pos.current_rh == null)
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(
1:                     pos.current_page != null &&
1:                     pos.current_slot != Page.INVALID_SLOT_NUMBER);
1: 
1:             }
1: 
1:             // work around for lockmanager problem with lock/latch releasing.
1:             // Get RecordHandle to lock.
1:             pos.current_rh = 
1:                 pos.current_page.getRecordHandleAtSlot(pos.current_slot);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 // make sure current_rh and current_slot are in sync
1:                 if (pos.current_slot !=
1:                         pos.current_page.getSlotNumber(pos.current_rh))
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "current_slot = " + pos.current_slot +
1:                         "current_rh = " + pos.current_rh +
1:                         "current_rh.slot = " + 
1:                         pos.current_page.getSlotNumber(pos.current_rh));
1:                 }
1:             }
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(pos.current_rh != null);
1: 
1:         boolean lock_granted_with_latch_held =
1:             this.container.getLockingPolicy().lockRecordForRead(
1:                 init_rawtran, container, pos.current_rh, 
1:                 false /* NOWAIT */, forUpdate);
1: 
1:         if (!lock_granted_with_latch_held)
1:         {
1: 
1:             // Could not get the lock NOWAIT, release latch and wait for lock.
1:             pos.current_page.unlatch();
1:             pos.current_page = null;
1: 
1: 
1:             if (aux_pos != null)
1:             {
1:                 aux_pos.current_page.unlatch();
1:                 aux_pos.current_page = null;
1:             }
1: 
1:             if (!waitForLock)
1:             {
1:                 // throw lock timeout error.
1:                 throw StandardException.newException(SQLState.LOCK_TIMEOUT);
1:             }
1: 
1:             this.container.getLockingPolicy().lockRecordForRead(
1:                 init_rawtran, container, pos.current_rh, 
1:                 true /* WAIT */, forUpdate);
1: 
1:             if (moveForwardIfRowDisappears)
1:             {
1: 
1:                 if (latchPageAndRepositionScan(pos))
1:                 {
1:                     if (pos.current_slot != -1)
1:                     {
1:                         // If scan was repositioned to just before a valid row
1:                         // on the current page, then move forward and lock and
1:                         // return that row (slot != -1).  
1:                         // 
1:                         // Let the caller handle the "-1" 
1:                         // case, which may be one of 3 cases - need to go to 
1:                         // slot 1 on current page, need to go to next page, 
1:                         // need to end scan as there is no "next" page.  All
1:                         // 3 cases are handled by the generic scan loop in 
1:                         // GenericScanController.fetchRows().
1: 
1:                         pos.positionAtNextSlot();
1:                         lockPositionForRead(pos, aux_pos, true, true);
1: 
1:                     }
1:                 }
1:             }
1:             else
1:             {
1:                 latchPage(pos);
1:             }
1:         }
1: 
1:         return(lock_granted_with_latch_held);
1:     }
1: 
1:     public boolean lockPositionForWrite(
1:     RowPosition pos,
0:     boolean     forInsert,
1:     boolean     waitForLock)
1:         throws StandardException
1:     {
1:         if (pos.current_rh == null)
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.ASSERT(pos.current_page != null);
1:                 SanityManager.ASSERT(
1:                     pos.current_slot != Page.INVALID_SLOT_NUMBER);
1: 
1:             }
1: 
1:             // work around for lockmanager problem with lock/latch releasing.
1:             // Get RecordHandle to lock.
1:             pos.current_rh = 
1:                 pos.current_page.fetchFromSlot(
1:                     null, 
1:                     pos.current_slot, 
1:                     RowUtil.EMPTY_ROW, 
1:                     RowUtil.EMPTY_ROW_FETCH_DESCRIPTOR, 
1:                     true);
1: 
1:             if (SanityManager.DEBUG)
1:             {
1:                 // make sure current_rh and current_slot are in sync
1:                 if (pos.current_slot !=
1:                         pos.current_page.getSlotNumber(pos.current_rh))
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "current_slot = " + pos.current_slot +
1:                         "current_rh = " + pos.current_rh +
1:                         "current_rh.slot = " + 
1:                         pos.current_page.getSlotNumber(pos.current_rh));
1:                 }
1:             }
1:         }
1: 
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(pos.current_rh != null);
1: 
1:         boolean lock_granted_with_latch_held =
1:             this.container.getLockingPolicy().
1:                 lockRecordForWrite(
1:                     init_rawtran, pos.current_rh, 
1:                     forInsert, false /* NOWAIT */);
1: 
1:         if (!lock_granted_with_latch_held)
1:         {
1:             if (!waitForLock)
1:             {
1:                 // throw lock timeout error.
1:                 throw StandardException.newException(SQLState.LOCK_TIMEOUT);
1:             }
1: 
1:             // Could not get the lock NOWAIT, release latch and wait for lock.
1:             pos.current_page.unlatch();
1:             pos.current_page = null;
1: 
1:             if (!waitForLock)
1:             {
1:                 // throw lock timeout error.
1:                 throw StandardException.newException(SQLState.LOCK_TIMEOUT);
1:             }
1: 
1:             this.container.getLockingPolicy().
1:                 lockRecordForWrite(
1:                     init_rawtran, pos.current_rh, forInsert, true /* WAIT */);
1: 
1:             latchPage(pos);
1:         }
1: 
1:         return(lock_granted_with_latch_held);
1:     }
1: 
1: 
1:     /**
1:      * Unlock the record after a previous request to lock it.
1:      * <p>
1:      * Unlock the record after a previous call to lockRecordForRead().  It is
1:      * expected that RowPosition contains information used to lock the record,
1:      * Thus it is important if using a single RowPosition to track a scan to
1:      * call unlock before you move the position forward to the next record.
1:      * <p>
1:      * Note that this routine assumes that the row was locked forUpdate if
1:      * the OpenConglomerate is forUpdate, else it assumes the record was
1:      * locked for read.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void unlockPositionAfterRead(
1:     RowPosition pos) 
1:         throws StandardException
1:     {
1:         if (!isClosed())
1:             container.getLockingPolicy().
1:                 unlockRecordAfterRead(
1:                     init_rawtran, container, pos.current_rh, forUpdate, 
1:                     pos.current_rh_qualified);
1:     }
1: 
1: 
1:     /**************************************************************************
1:      * Public Methods implementing ConglomPropertyQueryable Interface: 
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Request set of properties associated with a table. 
1:      * <p>
1:      * Returns a property object containing all properties that the store
1:      * knows about, which are stored persistently by the store.  This set
1:      * of properties may vary from implementation to implementation of the
1:      * store.
1:      * <p>
1:      * This call is meant to be used only for internal query of the properties
1:      * by jbms, for instance by language during bulk insert so that it can
1:      * create a new conglomerate which exactly matches the properties that
1:      * the original container was created with.  This call should not be used
1:      * by the user interface to present properties to users as it may contain
1:      * properties that are meant to be internal to jbms.  Some properties are 
1:      * meant only to be specified by jbms code and not by users on the command
1:      * line.
1:      * <p>
1:      * Note that not all properties passed into createConglomerate() are stored
1:      * persistently, and that set may vary by store implementation.
1:      *
1:      * @param prop   Property list to add properties to.  If null, routine will
1:      *               create a new Properties object, fill it in and return it.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public Properties getInternalTablePropertySet(Properties prop)
1: 		throws StandardException
1:     {
1:         Properties  ret_properties = 
1:             ConglomerateUtil.createRawStorePropertySet(prop);
1: 
1:         getTableProperties(ret_properties);
1: 
1:         return(ret_properties);
1:     }
1: 
1:     /**
1:      * Request the system properties associated with a table. 
1:      * <p>
1:      * Request the value of properties that are associated with a table.  The
1:      * following properties can be requested:
1:      *     derby.storage.pageSize 
1:      *     derby.storage.pageReservedSpace
1:      *     derby.storage.minimumRecordSize
1:      *     derby.storage.initialPages
1:      * <p>
1:      * To get the value of a particular property add it to the property list,
1:      * and on return the value of the property will be set to it's current 
1:      * value.  For example:
1:      *
1:      * get_prop(ConglomerateController cc)
1:      * {
1:      *     Properties prop = new Properties();
1:      *     prop.put("derby.storage.pageSize", "");
1:      *     cc.getTableProperties(prop);
1:      *
1:      *     System.out.println(
1:      *         "table's page size = " + 
1:      *         prop.getProperty("derby.storage.pageSize");
1:      * }
1:      *
1:      * @param prop   Property list to fill in.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void getTableProperties(Properties prop)
1: 		throws StandardException
1:     {
1:         container.getContainerProperties(prop);
1: 
1:         return;
1:     }
1: 
1:     /**************************************************************************
1:      * Public Accessors of This class:
1:      **************************************************************************
1:      */
1:     public final TransactionManager getXactMgr()
1:     {
1:         return(init_xact_manager);
1:     }
1: 
1:     public final Transaction getRawTran()
1:     {
1:         return(init_rawtran);
1:     }
1: 
1:     public final ContainerHandle getContainer()
1:     {
1:         return(container);
1:     }
1: 
1:     public final int getOpenMode()
1:     {
1:         return(init_openmode);
1:     }
1:     
1:     public final Conglomerate getConglomerate()
1:     {
1:         return(init_conglomerate);
1:     }
1: 
1:     public final boolean getHold()
1:     {
1:         return(init_hold);
1:     }
1: 
1: 
1:     public final boolean isForUpdate()
1:     {
1:         return(forUpdate);
1:     }
1: 
1:     public final boolean isClosed()
1:     {
1:         return(container == null);
1:     }
1: 
1:     public final boolean isUseUpdateLocks()
1:     {
1:         return(useUpdateLocks);
1:     }
1: 
1:     public final OpenConglomerateScratchSpace getRuntimeMem()
1:     {
1:         return(runtime_mem);
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods implementing some ConglomerateController Interfaces: 
1:      **************************************************************************
1:      */
1: 
1: 
1:     /**
1:      * Check consistency of a conglomerate.
1:      * <p>
1:      * Checks the consistency of the data within a given conglomerate, does not
1:      * check consistency external to the conglomerate (ie. does not check that 
1:      * base table row pointed at by a secondary index actually exists).
1:      * <p>
1:      * There is no checking in the default implementation, you must override
1:      * to get conglomerate specific consistency checking.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void checkConsistency()
1: 		throws StandardException
1:     {
1:         return;
1:     }
1: 
1: 
1: 
1:     public void debugConglomerate()
1: 		throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.DEBUG_PRINT(
1:                 "p_heap", "\nHEAP DUMP:containerId " + container.getId());
1: 
1:             // get a template.
1: 
0:             DataValueDescriptor[] row = runtime_mem.get_row_for_export();
1: 
1:             // Print pages of the heap.
1:             Page page = container.getFirstPage();
1: 
1:             while (page != null)
1:             {
1:                 SanityManager.DEBUG_PRINT(
1:                     "p_heap", ConglomerateUtil.debugPage(page, 0, false, row));
1: 
1:                 long pageid = page.getPageNumber();
1:                 page.unlatch();
1:                 page = container.getNextPage(pageid);
1:             }
1:         }
1: 
1:         return;
1:     }
1: 
1: 
1:     /**
1:     Get information about space used by the conglomerate.
1:     **/
1:     public SpaceInfo getSpaceInfo()
1:         throws StandardException
1:     {
1:         return container.getSpaceInfo();
1:     }
1: 
1: 	protected boolean isKeyed()
1: 	{
1: 		return false;
1: 	}
1: 
1:     /**
1:      * is the open btree table locked?
1:      **/
1:     protected boolean isTableLocked()
1:     {
1:         return(init_lock_level == TransactionController.MODE_TABLE);
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods of this class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Open the container.
1:      * <p>
1:      * Open the container, obtaining necessary locks.  Most work is actually
1:      * done by RawStore.openContainer().  
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public ContainerHandle init(
1:     ContainerHandle                 open_container,
1:     Conglomerate                    conglomerate,
1:     int[]                           format_ids,
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             openmode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:         throws StandardException
1:     {
1:         // save state of all inputs.
1:         init_conglomerate       = conglomerate;
1:         init_xact_manager       = xact_manager;
1:         init_rawtran            = rawtran;
1:         init_openmode           = openmode;
1:         init_lock_level         = lock_level;
1:         init_dynamic_info       = dynamic_info;
1:         init_hold               = hold;
1:         init_locking_policy     = locking_policy;
1: 
1: 
1:         // either use passed in "compiled" runtime scratch space, or create
1:         // new space.
1:         this.runtime_mem    = 
1:             (dynamic_info != null ? 
1:              ((OpenConglomerateScratchSpace) dynamic_info) : 
0:              new OpenConglomerateScratchSpace(format_ids));
1: 
1:         // Is this an open for update or read?  This will
1: 		// be passed down to the raw store fetch methods, which allows
1: 		// it to do the appropriate locking.
1: 		this.forUpdate = 
1:             ((openmode & ContainerHandle.MODE_FORUPDATE) != 0); 
1: 
1:         // keep track of whether this open conglomerate should use update locks.
1: 		this.useUpdateLocks = 
1:             ((openmode & ContainerHandle.MODE_USE_UPDATE_LOCKS) != 0);
1: 
1:         // If this flag is set, then the client has already locked the row
1:         // by accessing it through the secondary index and has already locked
1:         // the row, so the base conglomerate need not re-lock the row.
1:         this.getBaseTableLocks =
1:             ((openmode & ContainerHandle.MODE_SECONDARY_LOCKED) == 0);
1: 
1: 		// if the conglomerate is temporary, open with IS_KEPT set.
1: 		// RESOLVE(mikem): track 1825
1: 		// don't want to open temp cantainer with IS_KEPT always.
1:         if (conglomerate.isTemporary())
1:         {
1: 			init_openmode |= ContainerHandle.MODE_TEMP_IS_KEPT;
1:         }
1: 
1:         if (!getBaseTableLocks)
1:             init_locking_policy = null;
1: 
1: 		// Open the container. 
1:         this.container = 
1:             (open_container != null ?  
1:                  open_container : 
1:                  rawtran.openContainer(
1:                     conglomerate.getId(), init_locking_policy, init_openmode));
1: 
1:         return(this.container);
1:     }
1: 
1:     /**
1:      * Open the container.
1:      * <p>
1:      * Open the container, obtaining necessary locks.  Most work is actually
1:      * done by RawStore.openContainer().  Will only reopen() if the container
1:      * is not already open.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public ContainerHandle reopen()
1:         throws StandardException
1:     {
1:         // reget transaction from context manager, in the case of XA
1:         // transaction this may have changed.
1:         //
1:         /* TODO - XA transactions my change the current transaction on the 
1:          * context stack.  Will want to something like:
1:          *
1:          * init_rawtran = context_manager.getcurrenttransaction()
1:          */
1:      
1:         if (this.container == null)
1:         {
1:             this.container = 
1:                  init_rawtran.openContainer(
1:                     init_conglomerate.getId(), 
1:                     init_locking_policy, 
1:                     init_openmode);
1:         }
1: 
1:         return(this.container);
1:     }
1: 
1:     /**
1:      * Close the container.
1:      * <p>
1:      * Handles being closed more than once.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void close()
1:         throws StandardException
1: 	{
1: 		if (container != null)
1:         {
1: 			container.close();
1:             container = null;
1:         }
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.conglomerate
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.conglomerate;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException; 
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: 
0: import org.apache.derby.iapi.store.access.ConglomPropertyQueryable;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowUtil;
0: import org.apache.derby.iapi.store.access.SpaceInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.FetchDescriptor;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Page;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import java.util.Properties; 
0: 
0: 
0: /**
0: 
0: A Generic class which implements the basic functionality needed to operate
0: on an "open" conglomerate.  This class assumes the following general things
0: about the access method.
0: <p>
0: The access method is page based and contained in a single container maintained
0: by raw store.  
0: 
0: **/
0: 
0: public abstract class OpenConglomerate
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0:     /**************************************************************************
0:      * Fields of the class
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * The following group of fields are all basic input parameters which are
0:      * provided by the calling code when doing any sort of operation requiring
0:      * an open conglomerate (openScan(), open(), openCostController(), ...).
0:      * These are just saved values from what was initially input.
0:      **/
0:     private Conglomerate                    init_conglomerate;
0:     private TransactionManager              init_xact_manager;
0:     private Transaction                     init_rawtran;
0:     private int                             init_openmode;
0:     private int                             init_lock_level;
0:     private DynamicCompiledOpenConglomInfo  init_dynamic_info;
0:     private boolean                         init_hold;
0:     private LockingPolicy                   init_locking_policy;
0: 
0: 
0:     /**
0:      * convenience boolean's for various mode's
0:      **/
0:     private boolean useUpdateLocks;
0:     private boolean forUpdate;
0:     private boolean getBaseTableLocks;
0: 
0:     /**
0:      * scratch space used for stuff like templates, export rows, ...
0:      **/
0:     private OpenConglomerateScratchSpace  runtime_mem;
0: 
0: 
0:     /*
0:      * The open raw store container associated with this open conglomerate
0:      **/
0:     private ContainerHandle container;
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Private methods for This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * abstract methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Return an "empty" row location object of the correct type.
0:      * <p>
0:      *
0: 	 * @return The empty Rowlocation.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	protected abstract RowLocation newRowLocationTemplate()
0: 		throws StandardException;
0: 
0:     abstract public int[] getFormatIds();
0: 
0: 
0:     /**************************************************************************
0:      * Public Methods implementing standard store row locking interfaces:
0:      *     latchPage(RowPosition)
0:      *     latchPageAndRepositionScan(RowPosition)
0:      *     lockPositionForRead(RowPosition, aux_pos, moveForwardIfRowDisappears)
0:      *     lockPositionForWrite(RowPosition, forInsert, wait)
0:      *     unlockPositionAfterRead(RowPosition)
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Latch the page containing the current RowPosition, and reposition scan.
0:      * <p>
0:      * Upon return the scan will hold a latch on the page to continue the
0:      * scan on.  The scan will positioned on the record, just before the
0:      * next record to return.
0:      *
0:      * Note that for both hold cursor and read uncommitted support this routine
0:      * handles all cases of either the current position "dissappearing" (either
0:      * the row and/or page).  The row and/or page can disappear by deleted 
0:      * space being reclaimed post commit of that delete, and for some reason 
0:      * the code requesting the reposition does not have locks which prevented
0:      * the space reclamation.  Both hold cursor and read uncommitted scans are 
0:      * examples of ways the caller will not prevent space reclamation from 
0:      * claiming the position.
0:      *
0:      * This implementation also automatically updates the RowPosition to
0:      * point at the slot containing the current RowPosition.  This slot 
0:      * value is only valid while the latch is held.
0:      *
0: 	 * @return true if scan had to reposition because a row disappeared.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     protected boolean latchPageAndRepositionScan(RowPosition pos)
0: 		throws StandardException
0:     {
0:         boolean scan_repositioned = false;
0: 
0:         // Get the page the record handle refers to.
0:         pos.current_page = null;
0: 
0:         try
0:         {
0:             pos.current_page = 
0:                 container.getPage(pos.current_rh.getPageNumber());
0: 
0:         }
0:         catch (Throwable t)
0:         {
0:             // Assume all errors are caused by the page "disappearing", will
0:             // handle this by positioning on next page in code below.
0:             // Note that in most cases if the page does not exist, getPage()
0:             // will return null rather than throw an exception, so this path
0:             // is hard to reach.
0: 
0:             // just continue on first record of the next page.
0:             // This should only happen if the page on which the scan was
0:             // positioned had all of it's row deleted and the page was
0:             // purged.
0: 
0:             // This can happen in a cursor held across a commit, where the
0:             // scan needs to be repositioned after the first "next()" in the
0:             // subsequent reopen() of the held cursor.
0:         }
0: 
0:         if (pos.current_page != null)
0:         {
0:             try
0:             {
0:                 // reposition scan at the old position, now that latch is held.
0:                 pos.current_slot = 
0:                     pos.current_page.getSlotNumber(pos.current_rh);
0:             }
0:             catch (StandardException se)
0:             {
0:                 scan_repositioned = true;
0: 
0:                 // The record that the scan was positioned on, no longer exists.
0:                 // The normal way this happens is if we were positioned on
0:                 // a deleted row, without holding a lock on it, and while
0:                 // the scan did not hold the latch on the page a post commit
0:                 // job purged the row as part of space reclamation.   This can
0:                 // happen in all ISOLATION level scans below serializable.
0:                 pos.current_slot = 
0:                     pos.current_page.getNextSlotNumber(pos.current_rh);
0: 
0:                 if (pos.current_slot == -1)
0:                 {
0:                     // in this case we there are no more rows on this page
0:                     // to visit, so position on the next page.  In this case
0:                     // the row that the scan was positioned on was purged,
0:                     // and there exists no rows now which are greater than this
0:                     // record id.
0: 
0:                     pos.current_page.unlatch();
0:                     pos.current_page = null;
0:                 }
0:                 else
0:                 {
0:                     // The way scans work, need to position on the row just
0:                     // before the one to return "next".  The first thing the
0:                     // next loop will do is move the scan forward one row.
0:                     pos.current_slot--;
0:                 }
0:             }
0:         }
0: 
0:         if (pos.current_page == null)
0:         {
0:             // position on the next page.
0:             pos.current_page = 
0:                 container.getNextPage(pos.current_rh.getPageNumber());
0: 
0:             pos.current_slot = Page.FIRST_SLOT_NUMBER - 1;
0: 
0:             scan_repositioned = true;
0:         }
0: 
0:         if (scan_repositioned)
0:         {
0:             pos.current_rh = null;
0:         }
0: 
0:         return(scan_repositioned);
0:     }
0: 
0:     /**
0:      * Latch the page containing the current RowPosition.
0:      * <p>
0:      * This implementation also automatically updates the RowPosition to
0:      * point at the slot containing the current RowPosition.  This slot 
0:      * value is only valid while the latch is held.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean latchPage(RowPosition pos)
0: 		throws StandardException
0:     {
0:         pos.current_page = null; 
0: 
0:         try
0:         {
0:             pos.current_page = 
0:                 container.getPage(pos.current_rh.getPageNumber());
0: 
0:         }
0:         catch (Throwable t)
0:         {
0:             // Assume all errors are caused by the page "disappearing", will
0:             // handle this by returning false indicating that row can't be 
0:             // found.  This can easily happen when using read uncommitted 
0:             // isolation level.
0:         }
0: 
0:         if (pos.current_page != null)
0:         {
0:             try
0:             {
0:                 pos.current_slot = 
0:                     pos.current_page.getSlotNumber(pos.current_rh);
0:                 
0:                 return(true);
0:             }
0:             catch (Throwable t)
0:             {
0:                 // Assume all errors are caused by the row "disappearing",
0:                 // will handle this by returning false indicating that row
0:                 // can't be found.  This can easily happen when using read
0:                 // uncommitted isolation level.
0: 
0:                 pos.current_page.unlatch();
0:                 pos.current_page = null;
0:             }
0:         }
0: 
0:         return(false);
0:     }
0: 
0: 
0:     /**
0:      * Lock row at given row position for read.
0:      * <p>
0:      * This routine requests a row lock NOWAIT on the row located at the given
0:      * RowPosition.  If the lock is granted NOWAIT the 
0:      * routine will return true.  If the lock cannot be granted NOWAIT, then 
0:      * the routine will release the latch on "page" and then it will request 
0:      * a WAIT lock on the row.  
0:      * <p>
0:      * This implementation:
0:      * Assumes latch held on current_page.
0:      * If the current_rh field of RowPosition is non-null it is assumed that
0:      * we want to lock that record handle and that we don't have a slot number.
0:      * If the current_rh field of RowPosition is null, it is assumed the we
0:      * want to lock the indicated current_slot.  Upon return current_rh will
0:      * point to the record handle associated with current_slot.
0:      * <p>
0:      * After waiting and getting the lock on the row, this routine will fix up
0:      * RowPosition to point at the row locked.  This means it will get the
0:      * page latch again, and it will fix the current_slot to point at the 
0:      * waited for record handle - it may have moved while waiting on the lock.
0:      *
0:      * @param pos       Position to lock.
0:      * @param aux_pos   If you have to give up latch to get lock, then also 
0:      *                  unlock this position if it is non-null.
0:      * @param moveForwardIfRowDisappears
0:      *                  If true, then this routine must handle the case where
0:      *                  the row id we are waiting on disappears when the latch
0:      *                  is released.  If false an exception will be thrown if
0:      *                  the row disappears.
0:      * @param waitForLock
0:      *                  if true wait for lock, if lock can't be granted NOWAIT,
0:      *                  else if false, throw a lock timeout exception if the
0:      *                  lock can't be granted without waiting.
0:      *
0: 	 * @return true if lock granted without releasing the latch, else return
0:      *              false.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public boolean lockPositionForRead(
0:     RowPosition pos,
0:     RowPosition aux_pos,
0:     boolean     moveForwardIfRowDisappears,
0:     boolean     waitForLock)
0:         throws StandardException
0:     {
0:         if (pos.current_rh == null)
0:         {
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(
0:                     pos.current_page != null &&
0:                     pos.current_slot != Page.INVALID_SLOT_NUMBER);
0: 
0:             }
0: 
0:             // work around for lockmanager problem with lock/latch releasing.
0:             // Get RecordHandle to lock.
0:             pos.current_rh = 
0:                 pos.current_page.getRecordHandleAtSlot(pos.current_slot);
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 // make sure current_rh and current_slot are in sync
0:                 if (pos.current_slot !=
0:                         pos.current_page.getSlotNumber(pos.current_rh))
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "current_slot = " + pos.current_slot +
0:                         "current_rh = " + pos.current_rh +
0:                         "current_rh.slot = " + 
0:                         pos.current_page.getSlotNumber(pos.current_rh));
0:                 }
0:             }
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(pos.current_rh != null);
0: 
0:         boolean lock_granted_with_latch_held =
0:             this.container.getLockingPolicy().lockRecordForRead(
0:                 init_rawtran, container, pos.current_rh, 
0:                 false /* NOWAIT */, forUpdate);
0: 
0:         if (!lock_granted_with_latch_held)
0:         {
0: 
0:             // Could not get the lock NOWAIT, release latch and wait for lock.
0:             pos.current_page.unlatch();
0:             pos.current_page = null;
0: 
0: 
0:             if (aux_pos != null)
0:             {
0:                 aux_pos.current_page.unlatch();
0:                 aux_pos.current_page = null;
0:             }
0: 
0:             if (!waitForLock)
0:             {
0:                 // throw lock timeout error.
0:                 throw StandardException.newException(SQLState.LOCK_TIMEOUT);
0:             }
0: 
0:             this.container.getLockingPolicy().lockRecordForRead(
0:                 init_rawtran, container, pos.current_rh, 
0:                 true /* WAIT */, forUpdate);
0: 
0:             if (moveForwardIfRowDisappears)
0:             {
0: 
0:                 if (latchPageAndRepositionScan(pos))
0:                 {
0:                     if (pos.current_slot != -1)
0:                     {
0:                         // If scan was repositioned to just before a valid row
0:                         // on the current page, then move forward and lock and
0:                         // return that row (slot != -1).  
0:                         // 
0:                         // Let the caller handle the "-1" 
0:                         // case, which may be one of 3 cases - need to go to 
0:                         // slot 1 on current page, need to go to next page, 
0:                         // need to end scan as there is no "next" page.  All
0:                         // 3 cases are handled by the generic scan loop in 
0:                         // GenericScanController.fetchRows().
0: 
0:                         pos.positionAtNextSlot();
0:                         lockPositionForRead(pos, aux_pos, true, true);
0: 
0:                     }
0:                 }
0:             }
0:             else
0:             {
0:                 latchPage(pos);
0:             }
0:         }
0: 
0:         return(lock_granted_with_latch_held);
0:     }
0: 
0:     public boolean lockPositionForWrite(
0:     RowPosition pos,
0:     boolean     forInsert,
0:     boolean     waitForLock)
0:         throws StandardException
0:     {
0:         if (pos.current_rh == null)
0:         {
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.ASSERT(pos.current_page != null);
0:                 SanityManager.ASSERT(
0:                     pos.current_slot != Page.INVALID_SLOT_NUMBER);
0: 
0:             }
0: 
0:             // work around for lockmanager problem with lock/latch releasing.
0:             // Get RecordHandle to lock.
0:             pos.current_rh = 
0:                 pos.current_page.fetchFromSlot(
0:                     null, 
0:                     pos.current_slot, 
0:                     RowUtil.EMPTY_ROW, 
0:                     RowUtil.EMPTY_ROW_FETCH_DESCRIPTOR, 
0:                     true);
0: 
0:             if (SanityManager.DEBUG)
0:             {
0:                 // make sure current_rh and current_slot are in sync
0:                 if (pos.current_slot !=
0:                         pos.current_page.getSlotNumber(pos.current_rh))
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "current_slot = " + pos.current_slot +
0:                         "current_rh = " + pos.current_rh +
0:                         "current_rh.slot = " + 
0:                         pos.current_page.getSlotNumber(pos.current_rh));
0:                 }
0:             }
0:         }
0: 
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(pos.current_rh != null);
0: 
0:         boolean lock_granted_with_latch_held =
0:             this.container.getLockingPolicy().
0:                 lockRecordForWrite(
0:                     init_rawtran, pos.current_rh, 
0:                     forInsert, false /* NOWAIT */);
0: 
0:         if (!lock_granted_with_latch_held)
0:         {
0:             if (!waitForLock)
0:             {
0:                 // throw lock timeout error.
0:                 throw StandardException.newException(SQLState.LOCK_TIMEOUT);
0:             }
0: 
0:             // Could not get the lock NOWAIT, release latch and wait for lock.
0:             pos.current_page.unlatch();
0:             pos.current_page = null;
0: 
0:             if (!waitForLock)
0:             {
0:                 // throw lock timeout error.
0:                 throw StandardException.newException(SQLState.LOCK_TIMEOUT);
0:             }
0: 
0:             this.container.getLockingPolicy().
0:                 lockRecordForWrite(
0:                     init_rawtran, pos.current_rh, forInsert, true /* WAIT */);
0: 
0:             latchPage(pos);
0:         }
0: 
0:         return(lock_granted_with_latch_held);
0:     }
0: 
0: 
0:     /**
0:      * Unlock the record after a previous request to lock it.
0:      * <p>
0:      * Unlock the record after a previous call to lockRecordForRead().  It is
0:      * expected that RowPosition contains information used to lock the record,
0:      * Thus it is important if using a single RowPosition to track a scan to
0:      * call unlock before you move the position forward to the next record.
0:      * <p>
0:      * Note that this routine assumes that the row was locked forUpdate if
0:      * the OpenConglomerate is forUpdate, else it assumes the record was
0:      * locked for read.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void unlockPositionAfterRead(
0:     RowPosition pos) 
0:         throws StandardException
0:     {
0:         if (!isClosed())
0:             container.getLockingPolicy().
0:                 unlockRecordAfterRead(
0:                     init_rawtran, container, pos.current_rh, forUpdate, 
0:                     pos.current_rh_qualified);
0:     }
0: 
0: 
0:     /**************************************************************************
0:      * Public Methods implementing ConglomPropertyQueryable Interface: 
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Request set of properties associated with a table. 
0:      * <p>
0:      * Returns a property object containing all properties that the store
0:      * knows about, which are stored persistently by the store.  This set
0:      * of properties may vary from implementation to implementation of the
0:      * store.
0:      * <p>
0:      * This call is meant to be used only for internal query of the properties
0:      * by jbms, for instance by language during bulk insert so that it can
0:      * create a new conglomerate which exactly matches the properties that
0:      * the original container was created with.  This call should not be used
0:      * by the user interface to present properties to users as it may contain
0:      * properties that are meant to be internal to jbms.  Some properties are 
0:      * meant only to be specified by jbms code and not by users on the command
0:      * line.
0:      * <p>
0:      * Note that not all properties passed into createConglomerate() are stored
0:      * persistently, and that set may vary by store implementation.
0:      *
0:      * @param prop   Property list to add properties to.  If null, routine will
0:      *               create a new Properties object, fill it in and return it.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public Properties getInternalTablePropertySet(Properties prop)
0: 		throws StandardException
0:     {
0:         Properties  ret_properties = 
0:             ConglomerateUtil.createRawStorePropertySet(prop);
0: 
0:         getTableProperties(ret_properties);
0: 
0:         return(ret_properties);
0:     }
0: 
0:     /**
0:      * Request the system properties associated with a table. 
0:      * <p>
0:      * Request the value of properties that are associated with a table.  The
0:      * following properties can be requested:
0:      *     derby.storage.pageSize 
0:      *     derby.storage.pageReservedSpace
0:      *     derby.storage.minimumRecordSize
0:      *     derby.storage.initialPages
0:      * <p>
0:      * To get the value of a particular property add it to the property list,
0:      * and on return the value of the property will be set to it's current 
0:      * value.  For example:
0:      *
0:      * get_prop(ConglomerateController cc)
0:      * {
0:      *     Properties prop = new Properties();
0:      *     prop.put("derby.storage.pageSize", "");
0:      *     cc.getTableProperties(prop);
0:      *
0:      *     System.out.println(
0:      *         "table's page size = " + 
0:      *         prop.getProperty("derby.storage.pageSize");
0:      * }
0:      *
0:      * @param prop   Property list to fill in.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void getTableProperties(Properties prop)
0: 		throws StandardException
0:     {
0:         container.getContainerProperties(prop);
0: 
0:         return;
0:     }
0: 
0:     /**************************************************************************
0:      * Public Accessors of This class:
0:      **************************************************************************
0:      */
0:     public final TransactionManager getXactMgr()
0:     {
0:         return(init_xact_manager);
0:     }
0: 
0:     public final Transaction getRawTran()
0:     {
0:         return(init_rawtran);
0:     }
0: 
0:     public final ContainerHandle getContainer()
0:     {
0:         return(container);
0:     }
0: 
0:     public final int getOpenMode()
0:     {
0:         return(init_openmode);
0:     }
0:     
0:     public final Conglomerate getConglomerate()
0:     {
0:         return(init_conglomerate);
0:     }
0: 
0:     public final boolean getHold()
0:     {
0:         return(init_hold);
0:     }
0: 
0: 
0:     public final boolean isForUpdate()
0:     {
0:         return(forUpdate);
0:     }
0: 
0:     public final boolean isClosed()
0:     {
0:         return(container == null);
0:     }
0: 
0:     public final boolean isUseUpdateLocks()
0:     {
0:         return(useUpdateLocks);
0:     }
0: 
0:     public final OpenConglomerateScratchSpace getRuntimeMem()
0:     {
0:         return(runtime_mem);
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods implementing some ConglomerateController Interfaces: 
0:      **************************************************************************
0:      */
0: 
0: 
0:     /**
0:      * Check consistency of a conglomerate.
0:      * <p>
0:      * Checks the consistency of the data within a given conglomerate, does not
0:      * check consistency external to the conglomerate (ie. does not check that 
0:      * base table row pointed at by a secondary index actually exists).
0:      * <p>
0:      * There is no checking in the default implementation, you must override
0:      * to get conglomerate specific consistency checking.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void checkConsistency()
0: 		throws StandardException
0:     {
0:         return;
0:     }
0: 
0: 
0: 
0:     public void debugConglomerate()
0: 		throws StandardException
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.DEBUG_PRINT(
0:                 "p_heap", "\nHEAP DUMP:containerId " + container.getId());
0: 
0:             // get a template.
0: 
0:             DataValueDescriptor[] row = runtime_mem.get_row_for_export();
0: 
0:             // Print pages of the heap.
0:             Page page = container.getFirstPage();
0: 
0:             while (page != null)
0:             {
0:                 SanityManager.DEBUG_PRINT(
0:                     "p_heap", ConglomerateUtil.debugPage(page, 0, false, row));
0: 
0:                 long pageid = page.getPageNumber();
0:                 page.unlatch();
0:                 page = container.getNextPage(pageid);
0:             }
0:         }
0: 
0:         return;
0:     }
0: 
0: 
0:     /**
0:     Get information about space used by the conglomerate.
0:     **/
0:     public SpaceInfo getSpaceInfo()
0:         throws StandardException
0:     {
0:         return container.getSpaceInfo();
0:     }
0: 
0: 	protected boolean isKeyed()
0: 	{
0: 		return false;
0: 	}
0: 
0:     /**
0:      * is the open btree table locked?
0:      **/
0:     protected boolean isTableLocked()
0:     {
0:         return(init_lock_level == TransactionController.MODE_TABLE);
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods of this class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Open the container.
0:      * <p>
0:      * Open the container, obtaining necessary locks.  Most work is actually
0:      * done by RawStore.openContainer().  
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public ContainerHandle init(
0:     ContainerHandle                 open_container,
0:     Conglomerate                    conglomerate,
0:     int[]                           format_ids,
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran,
0:     boolean                         hold,
0:     int                             openmode,
0:     int                             lock_level,
0:     LockingPolicy                   locking_policy,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0:         throws StandardException
0:     {
0:         // save state of all inputs.
0:         init_conglomerate       = conglomerate;
0:         init_xact_manager       = xact_manager;
0:         init_rawtran            = rawtran;
0:         init_openmode           = openmode;
0:         init_lock_level         = lock_level;
0:         init_dynamic_info       = dynamic_info;
0:         init_hold               = hold;
0:         init_locking_policy     = locking_policy;
0: 
0: 
0:         // either use passed in "compiled" runtime scratch space, or create
0:         // new space.
0:         this.runtime_mem    = 
0:             (dynamic_info != null ? 
0:              ((OpenConglomerateScratchSpace) dynamic_info) : 
0:              new OpenConglomerateScratchSpace(format_ids));
0: 
0:         // Is this an open for update or read?  This will
0: 		// be passed down to the raw store fetch methods, which allows
0: 		// it to do the appropriate locking.
0: 		this.forUpdate = 
0:             ((openmode & ContainerHandle.MODE_FORUPDATE) != 0); 
0: 
0:         // keep track of whether this open conglomerate should use update locks.
0: 		this.useUpdateLocks = 
0:             ((openmode & ContainerHandle.MODE_USE_UPDATE_LOCKS) != 0);
0: 
0:         // If this flag is set, then the client has already locked the row
0:         // by accessing it through the secondary index and has already locked
0:         // the row, so the base conglomerate need not re-lock the row.
0:         this.getBaseTableLocks =
0:             ((openmode & ContainerHandle.MODE_SECONDARY_LOCKED) == 0);
0: 
0: 		// if the conglomerate is temporary, open with IS_KEPT set.
0: 		// RESOLVE(mikem): track 1825
0: 		// don't want to open temp cantainer with IS_KEPT always.
0:         if (conglomerate.isTemporary())
0:         {
0: 			init_openmode |= ContainerHandle.MODE_TEMP_IS_KEPT;
0:         }
0: 
0:         if (!getBaseTableLocks)
0:             init_locking_policy = null;
0: 
0: 		// Open the container. 
0:         this.container = 
0:             (open_container != null ?  
0:                  open_container : 
0:                  rawtran.openContainer(
0:                     conglomerate.getId(), init_locking_policy, init_openmode));
0: 
0:         return(this.container);
0:     }
0: 
0:     /**
0:      * Open the container.
0:      * <p>
0:      * Open the container, obtaining necessary locks.  Most work is actually
0:      * done by RawStore.openContainer().  Will only reopen() if the container
0:      * is not already open.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public ContainerHandle reopen()
0:         throws StandardException
0:     {
0:         // reget transaction from context manager, in the case of XA
0:         // transaction this may have changed.
0:         //
0:         /* TODO - XA transactions my change the current transaction on the 
0:          * context stack.  Will want to something like:
0:          *
0:          * init_rawtran = context_manager.getcurrenttransaction()
0:          */
0:      
0:         if (this.container == null)
0:         {
0:             this.container = 
0:                  init_rawtran.openContainer(
0:                     init_conglomerate.getId(), 
0:                     init_locking_policy, 
0:                     init_openmode);
0:         }
0: 
0:         return(this.container);
0:     }
0: 
0:     /**
0:      * Close the container.
0:      * <p>
0:      * Handles being closed more than once.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void close()
0:         throws StandardException
0: 	{
0: 		if (container != null)
0:         {
0: 			container.close();
0:             container = null;
0:         }
0: 	}
0: }
============================================================================