1:fa292b9: /*
4:fa292b9: 
1:fa292b9:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.UDTTest
1:fa292b9: 
1:fa292b9:    Licensed to the Apache Software Foundation (ASF) under one or more
1:fa292b9:    contributor license agreements.  See the NOTICE file distributed with
1:fa292b9:    this work for additional information regarding copyright ownership.
1:fa292b9:    The ASF licenses this file to you under the Apache License, Version 2.0
1:fa292b9:    (the "License"); you may not use this file except in compliance with
1:fa292b9:    the License.  You may obtain a copy of the License at
1:fa292b9: 
1:fa292b9:      http://www.apache.org/licenses/LICENSE-2.0
1:fa292b9: 
1:fa292b9:    Unless required by applicable law or agreed to in writing, software
1:fa292b9:    distributed under the License is distributed on an "AS IS" BASIS,
1:fa292b9:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:fa292b9:    See the License for the specific language governing permissions and
1:fa292b9:    limitations under the License.
1:fa292b9: 
1:fa292b9:  */
1:fa292b9: 
1:fa292b9: package org.apache.derbyTesting.functionTests.tests.lang;
1:fa292b9: 
1:33bfdc0: import java.sql.CallableStatement;
1:fa292b9: import java.sql.Connection;
1:b4af7da: import java.sql.DriverManager;
1:506f4c8: import java.sql.ParameterMetaData;
1:fa292b9: import java.sql.PreparedStatement;
1:fa292b9: import java.sql.ResultSet;
1:506f4c8: import java.sql.ResultSetMetaData;
1:35c061a: import java.sql.SQLException;
1:35c061a: import java.sql.Statement;
1:2732872: import java.util.HashMap;
1:fa292b9: 
1:fa292b9: import junit.framework.Test;
1:fa292b9: import org.apache.derbyTesting.junit.TestConfiguration;
1:94509ae: import org.apache.derbyTesting.junit.JDBC;
1:fa292b9: 
1:d6c2047: /**
1:d6c2047:  * <p>
1:fa292b9:  * Test user defined types. See DERBY-651.
1:fa292b9:  * </p>
1:fa292b9:  */
1:fa292b9: public class UDTTest  extends GeneratedColumnsHelper
1:fa292b9: {
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9:     //
1:fa292b9:     // CONSTANTS
1:fa292b9:     //
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9: 
1:fa292b9:     public static final String OBJECT_EXISTS = "X0Y68";
1:d6c2047:     public static final String VIEW_DEPENDS_ON_TYPE = "X0Y23";
1:21d74bf:     public static final String TRIGGER_DEPENDS_ON_TYPE = "X0Y24";
1:fa292b9: 
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9:     //
1:fa292b9:     // STATE
1:fa292b9:     //
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9: 
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9:     //
1:fa292b9:     // CONSTRUCTOR
1:fa292b9:     //
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9: 
1:fa292b9: 
1:21d74bf:     /**
1:fa292b9:      * Create a new instance.
1:fa292b9:      */
1:fa292b9: 
1:fa292b9:     public UDTTest(String name)
1:fa292b9:     {
1:fa292b9:         super(name);
1:fa292b9:     }
1:2732872: 
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9:     //
1:fa292b9:     // JUnit BEHAVIOR
1:fa292b9:     //
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:2732872: 
1:fa292b9: 
1:b4af7da:     /**
1:fa292b9:      * Construct top level suite in this JUnit test
1:fa292b9:      */
1:fa292b9:     public static Test suite()
1:fa292b9:     {
1:7141fc7:         return TestConfiguration.defaultSuite(UDTTest.class);
1:fa292b9:     }
1:fa292b9: 
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9:     //
1:fa292b9:     // TESTS
1:fa292b9:     //
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9: 
1:506f4c8:     /**
1:b4af7da:      * <p>
1:fa292b9:      * Basic syntax.
1:fa292b9:      * </p>
1:fa292b9:      */
1:fa292b9:     public void test_01_basicSyntax() throws Exception
1:fa292b9:     {
1:fa292b9:         Connection conn = getConnection();
1:fa292b9: 
1:fa292b9:         goodStatement( conn, "create schema adt_schema\n" );
1:fa292b9: 
1:fa292b9:         // create some types
1:fa292b9:         makeGoodTypes( conn );
1:fa292b9: 
1:fa292b9:         // duplicate type names should raise errors
1:fa292b9:         expectExecutionError( conn, OBJECT_EXISTS, "create type fooType external name 'mypackage.foo' language java\n" );
1:fa292b9:         expectExecutionError( conn, OBJECT_EXISTS, "create type adt_schema.fooType external name 'mypackage.foo' language java\n" );
1:fa292b9:         expectExecutionError( conn, OBJECT_EXISTS, "create type \"smallint\" external name 'mypackage.foo' language java\n" );
1:fa292b9:         expectExecutionError( conn, OBJECT_EXISTS, "create type \"SMALLINT\" external name 'mypackage.foo' language java\n" );
1:fa292b9: 
1:fa292b9:         // only RESTRICTed drops allowed now
1:fa292b9:         expectCompilationError( SYNTAX_ERROR, "drop type fooType\n" );
1:fa292b9: 
1:fa292b9:         // drop some types
1:fa292b9:         goodStatement( conn, "drop type fooType restrict\n" );
1:fa292b9:         goodStatement( conn, "drop type adt_schema.fooType restrict\n" );
1:fa292b9:         goodStatement( conn, "drop type \"smallint\" restrict\n" );
1:fa292b9:         goodStatement( conn, "drop type \"SMALLINT\" restrict\n" );
1:fa292b9: 
1:fa292b9:         // can't drop a non-existent type
1:fa292b9:         expectCompilationError( NONEXISTENT_OBJECT, "drop type fooType restrict\n" );
1:fa292b9:         expectCompilationError( NONEXISTENT_OBJECT, "drop type adt_schema.fooType restrict\n" );
1:fa292b9:         expectCompilationError( NONEXISTENT_OBJECT, "drop type \"smallint\" restrict\n" );
1:fa292b9:         expectCompilationError( NONEXISTENT_OBJECT, "drop type \"SMALLINT\" restrict\n" );
1:fa292b9: 
1:fa292b9:         // re-create the types
1:fa292b9:         makeGoodTypes( conn );
1:fa292b9:     }
1:fa292b9:     private void makeGoodTypes( Connection conn ) throws Exception
1:fa292b9:     {
1:fa292b9:         goodStatement( conn, "create type fooType external name 'mypackage.foo' language java\n" );
1:fa292b9:         goodStatement( conn, "create type adt_schema.fooType external name 'mypackage.foo' language java\n" );
1:fa292b9:         goodStatement( conn, "create type \"smallint\" external name 'mypackage.foo' language java\n" );
1:fa292b9:         goodStatement( conn, "create type \"SMALLINT\" external name 'mypackage.foo' language java\n" );
1:fa292b9:     }
1:fa292b9: 
1:816219f:     /**
1:506f4c8:      * <p>
1:d039ced:      * Basic column, return value, and parameter support.
1:d039ced:      * </p>
1:d039ced:      */
1:d039ced:     public void test_02_basicColumnRetvalParam() throws Exception
1:d039ced:     {
1:94509ae:         //
1:94509ae:         // DECIMAL datatype used here and the JSR169 support for it is less complete.
1:94509ae:         //
1:94509ae:         if ( JDBC.vmSupportsJSR169() ) { return; }
1:d039ced:         Connection conn = getConnection();
1:d039ced: 
1:d039ced:         goodStatement( conn, "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:d039ced:         goodStatement( conn, "create table orders( orderID int generated always as identity, customerID int, totalPrice price )\n" );
1:2209325:         goodStatement
1:2209325:             ( conn,
1:d039ced:               "create function makePrice( currencyCode char( 3 ), amount decimal( 31, 5 ), timeInstant Timestamp )\n" +
1:d039ced:               "returns Price language java parameter style java no sql\n" +
1:d039ced:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n");
1:2209325:         goodStatement
1:2209325:             ( conn,
1:d039ced:               "create function getCurrencyCode( price Price ) returns char( 3 ) language java parameter style java no sql\n" +
1:d039ced:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getCurrencyCode'\n" );
1:d6c2047:         goodStatement
1:d6c2047:             ( conn,
1:d039ced:               "create function getAmount( price Price ) returns decimal( 31, 5 ) language java parameter style java no sql\n" +
1:d039ced:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getAmount'\n" );
1:d6c2047:         goodStatement
15:e126f58:             ( conn,
1:d039ced:               "create function getTimeInstant( price Price ) returns timestamp language java parameter style java no sql\n" +
1:d039ced:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getTimeInstant'\n" );
1:b8c6110:         goodStatement
1:e126f58:             ( conn,
1:d039ced:               "create procedure savePrice( in a Price ) language java parameter style java no sql\n" +
1:d039ced:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.savePrice'\n" );
1:b8c6110:         goodStatement
1:e126f58:             ( conn,
1:d039ced:               "create function getSavedPrice() returns Price language java parameter style java no sql\n" +
1:d039ced:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getSavedPrice'\n" );
19:e126f58:         goodStatement
1:e126f58:             ( conn,
1:d039ced:               "insert into orders( customerID, totalPrice ) values\n" +
1:d039ced:               "( 12345, makePrice( 'USD', cast( 9.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') ) )\n" );
1:d039ced: 
1:d039ced:         assertResults
1:d6c2047:             (
1:d6c2047:              conn,
1:506f4c8:              "select getCurrencyCode( totalPrice ), getTimeInstant( totalPrice ) from orders",
1:d039ced:              new String[][]
1:d039ced:              {
1:506f4c8:                  { "USD" ,         "2009-10-16 14:24:43.0" },
1:d039ced:              },
1:d039ced:              false
1:2209325:              );
1:d039ced:         assertResults
1:d6c2047:             (
1:d6c2047:              conn,
1:d039ced:              "select totalPrice from orders",
1:d039ced:              new String[][]
1:d039ced:              {
1:edea8ab:                  { "Price( USD, 9.99000, 2009-10-16 14:24:43.0 )" },
1:d039ced:              },
1:d039ced:              false
1:2209325:              );
1:d039ced: 
1:2209325:         goodStatement
1:2209325:             ( conn,
1:d039ced:               "call savePrice\n" +
1:edea8ab:               "( makePrice( 'EUR', cast( 1.23 as decimal( 31, 5 ) ), timestamp('2008-10-16 14:24:43') ) )\n" );
1:d039ced:         assertResults
1:d6c2047:             (
1:d6c2047:              conn,
1:d039ced:              "values( getSavedPrice() )",
1:d039ced:              new String[][]
1:d039ced:              {
1:edea8ab:                  { "Price( EUR, 1.23000, 2008-10-16 14:24:43.0 )" },
1:d039ced:              },
1:d039ced:              false
1:2209325:              );
1:d039ced:     }
1:d039ced: 
1:33bfdc0:     /**
1:33bfdc0:      * <p>
1:e126f58:      * Adding and dropping udt columns.
1:e126f58:      * </p>
1:e126f58:      */
1:e126f58:     public void test_03_addDropColumn() throws Exception
1:e126f58:     {
1:e126f58:         Connection conn = getConnection();
1:e126f58:         String tableName1 = "UDTCOLUMNS";
1:e126f58:         String tableName2 = "UDTCOLUMNS2";
1:e126f58: 
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "create type price_03 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:e126f58: 
1:e126f58:         // even though there are 2 price_03 columns, we only create 1 dependency
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "create table " + tableName1 + "\n" +
1:e126f58:               "(\n" +
1:e126f58:               "    a int, b int,\n" +
1:e126f58:               "    price1 price_03,\n" +
1:e126f58:               "    price2 price_03\n" +
1:e126f58:               ")\n"
1:2209325:               );
1:e126f58:         assertEquals( 1, countTableDependencies( conn, tableName1 ) );
1:e126f58: 
1:e126f58:         // verify that we can't drop the type while the table depends on it
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03 restrict\n" );
1:e126f58: 
1:e126f58:         // add another price_03 column. should not add another dependency
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "alter table udtColumns add column price3 price_03\n" );
1:e126f58:         assertEquals( 1, countTableDependencies( conn, tableName1 ) );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03 restrict\n" );
1:e126f58: 
1:e126f58:         // drop one of the price_03 column. there should still be a dependency
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "alter table udtColumns drop column price3\n" );
1:e126f58:         assertEquals( 1, countTableDependencies( conn, tableName1 ) );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03 restrict\n" );
1:e126f58: 
1:e126f58:         // drop another column. same story.
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "alter table udtColumns drop column price2\n" );
1:e126f58:         assertEquals( 1, countTableDependencies( conn, tableName1 ) );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03 restrict\n" );
1:e126f58: 
1:e126f58:         // drop the last udt column. dependency should disappear
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "alter table udtColumns drop column price1\n" );
1:e126f58:         assertEquals( 0, countTableDependencies( conn, tableName1 ) );
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "drop type Price_03 restrict\n" );
1:e126f58: 
1:e126f58:         // similar experiments with more types
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "create type price_03_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "create type price_03_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "create type price_03_c external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:e126f58: 
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "create table udtColumns2\n" +
1:e126f58:               "(\n" +
1:e126f58:               "    a int, b int,\n" +
1:e126f58:               "    price1 price_03_a,\n" +
1:e126f58:               "    price2 price_03_b\n" +
1:e126f58:               ")\n"
4:d6c2047:               );
1:e126f58:         assertEquals( 2, countTableDependencies( conn, tableName2 ) );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_a restrict\n" );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_b restrict\n" );
1:e126f58:         
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "alter table udtColumns2 add column price3 price_03_c\n" );
1:e126f58:         assertEquals( 3, countTableDependencies( conn, tableName2 ) );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_a restrict\n" );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_b restrict\n" );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_c restrict\n" );
1:e126f58: 
1:2209325:         goodStatement
1:2209325:             ( conn,
1:e126f58:               "alter table udtColumns2 drop column b\n" );
1:e126f58:         assertEquals( 3, countTableDependencies( conn, tableName2 ) );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_a restrict\n" );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_b restrict\n" );
1:e126f58:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_c restrict\n" );
1:e126f58: 
1:d6c2047:         goodStatement
1:d6c2047:             ( conn,
1:e126f58:               "alter table udtColumns2 drop column price3\n" );
1:e126f58:         assertEquals( 2, countTableDependencies( conn, tableName2 ) );
1:d6c2047:         goodStatement
1:d6c2047:             ( conn,
1:e126f58:               "drop type Price_03_c restrict\n" );
1:e126f58: 
1:d6c2047:         goodStatement
1:d6c2047:             ( conn,
1:e126f58:               "alter table udtColumns2 drop column price2\n" );
1:e126f58:         assertEquals( 1, countTableDependencies( conn, tableName2 ) );
1:d6c2047:         goodStatement
1:d6c2047:             ( conn,
1:e126f58:               "drop type Price_03_b restrict\n" );
1:e126f58: 
1:d6c2047:         goodStatement
1:d6c2047:             ( conn,
1:e126f58:               "alter table udtColumns2 drop column price1\n" );
1:e126f58:         assertEquals( 0, countTableDependencies( conn, tableName2 ) );
1:d6c2047:         goodStatement
1:e126f58:             ( conn,
1:e126f58:               "drop type Price_03_a restrict\n" );
1:e126f58:     }
1:e126f58: 
1:e5114fd:     /**
1:e5114fd:      * <p>
1:b8c6110:      * Dropping a whole table which has udt columns.
1:b8c6110:      * </p>
1:b8c6110:      */
1:b8c6110:     public void test_04_dropTable() throws Exception
1:b8c6110:     {
1:b8c6110:         Connection conn = getConnection();
1:b8c6110: 
1:d6c2047:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "create type price_orphan external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:d6c2047:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "create type price_orphan2 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "create type price_orphan3 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "create type price_orphan4 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "create table t_orphan( a price_orphan )\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "create table t_orphan2( a price_orphan2, b int, c price_orphan2 )\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "create table t_orphan3( a price_orphan3, b int, c price_orphan4 )\n" );
1:b8c6110:         
1:b8c6110:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type price_orphan restrict\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "drop table t_orphan\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "drop type price_orphan restrict\n" );
1:b8c6110:         
1:b8c6110:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type price_orphan2 restrict\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "drop table t_orphan2\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "drop type price_orphan2 restrict\n" );
1:b8c6110:         
1:b8c6110:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type price_orphan3 restrict\n" );
1:b8c6110:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type price_orphan4 restrict\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "drop table t_orphan3\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "drop type price_orphan3 restrict\n" );
1:b8c6110:         goodStatement
1:b8c6110:             ( conn,
1:b8c6110:               "drop type price_orphan4 restrict\n" );
1:b8c6110:     }
1:d6c2047:     
1:7a2d290:     /**
1:7a2d290:      * <p>
1:d6c2047:      * Dependencies of views on UDTs.
1:d6c2047:      * </p>
1:d6c2047:      */
1:d6c2047:     public void test_05_viewDependencies() throws Exception
1:d6c2047:     {
1:d6c2047:         Connection conn = getConnection();
1:d6c2047: 
1:21d74bf:         String createTypeStatement;
1:21d74bf:         String dropTypeStatement;
1:21d74bf:         String createObjectStatement;
1:21d74bf:         String dropObjectStatement;
1:21d74bf:         String badDropSQLState;
1:21d74bf:         
1:d6c2047:         // view with UDT in select list
1:21d74bf:         createTypeStatement = "create type price_05_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:21d74bf:         dropTypeStatement = "drop type price_05_a restrict\n";
1:21d74bf:         createObjectStatement = 
1:d6c2047:              "create view udtView( a, b, c ) as\n" +
1:816219f:              "select tabletype, cast (null as price_05_a), cast( null as price_05_a)\n" +
1:21d74bf:             "from sys.systables\n";
1:21d74bf:         dropObjectStatement = "drop view udtView\n";
1:21d74bf:         badDropSQLState = VIEW_DEPENDS_ON_TYPE;
1:21d74bf:         verifyDropRestrictions
1:d6c2047:             (
1:d6c2047:              conn,
1:21d74bf:              createTypeStatement,
1:21d74bf:              dropTypeStatement,
1:21d74bf:              createObjectStatement,
1:21d74bf:              dropObjectStatement,
1:21d74bf:              badDropSQLState
1:21d74bf:              );
1:21d74bf: 
1:21d74bf:         // view with UDT in where clause
1:21d74bf:         createTypeStatement = "create type price_05_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:21d74bf:         dropTypeStatement = "drop type price_05_b restrict\n";
1:21d74bf:         createObjectStatement = 
1:d6c2047:              "create view udtView_b( a ) as\n" +
1:21d74bf:             "select tabletype from sys.systables where ( cast (null as price_05_b) ) is not null\n";
1:21d74bf:         dropObjectStatement = "drop view udtView_b\n";
1:21d74bf:         badDropSQLState = VIEW_DEPENDS_ON_TYPE;
1:21d74bf:         verifyDropRestrictions
1:21d74bf:             (
1:21d74bf:              conn,
1:21d74bf:              createTypeStatement,
1:21d74bf:              dropTypeStatement,
1:21d74bf:              createObjectStatement,
1:21d74bf:              dropObjectStatement,
1:21d74bf:              badDropSQLState
1:21d74bf:              );
1:21d74bf: 
1:d6c2047:     }
1:d6c2047: 
1:b8c6110:     /**
1:816219f:      * <p>
1:816219f:      * Casting to UDTs.
1:816219f:      * </p>
1:816219f:      */
1:816219f:     public void test_06_casts() throws Exception
1:816219f:     {
1:816219f:         Connection conn = getConnection();
1:816219f: 
1:816219f:         // cast a NULL as a UDT
1:816219f:         goodStatement
1:816219f:             ( conn,
1:816219f:               "create type price_06_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:816219f:         assertResults
1:816219f:             (
1:816219f:              conn,
1:816219f:              "values ( cast ( null as price_06_b ) )\n",
1:816219f:              new String[][]
1:816219f:              {
1:816219f:                  { null },
1:816219f:              },
1:816219f:              false
1:816219f:              );
1:816219f: 
1:816219f:         // casting an untyped parameter to a UDT
1:816219f:         PreparedStatement ps = chattyPrepare
1:816219f:             ( conn, "values ( cast ( ? as price_06_b ) )" );
1:816219f:         ps.setObject( 1, Price.makePrice() );
1:816219f:         ResultSet rs = ps.executeQuery();
1:816219f:         rs.next();
1:816219f:         Price result = (Price) rs.getObject( 1 );
1:816219f:         rs.close();
1:816219f:         ps.close();
1:816219f:         assertTrue( Price.makePrice().equals( result ) );
1:816219f:     }
1:816219f: 
1:2209325:     /**
1:2209325:      * <p>
1:2209325:      * Dependencies of routines on UDTs.
1:2209325:      * </p>
1:2209325:      */
1:2209325:     public void test_07_routineDependencies() throws Exception
1:2209325:     {
1:2209325:         Connection conn = getConnection();
1:2209325: 
1:21d74bf:         String createTypeStatement;
1:21d74bf:         String dropTypeStatement;
1:21d74bf:         String createObjectStatement;
1:21d74bf:         String dropObjectStatement;
1:21d74bf:         String badDropSQLState;
1:d6c2047:         
1:2209325:         // function that returns a udt
1:21d74bf:         createTypeStatement = "create type price_07_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:21d74bf:         dropTypeStatement = "drop type price_07_a restrict\n";
1:21d74bf:         createObjectStatement = 
1:21d74bf:             "create function makePrice_07_a( )\n" +
1:21d74bf:             "returns price_07_a\n" +
1:21d74bf:             "language java\n" +
1:21d74bf:             "parameter style java\n" +
1:21d74bf:             "no sql\n" +
1:21d74bf:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n";
1:21d74bf:         dropObjectStatement = "drop function makePrice_07_a\n";
1:21d74bf:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:21d74bf:         verifyDropRestrictions
1:21d74bf:             (
1:21d74bf:              conn,
1:21d74bf:              createTypeStatement,
1:21d74bf:              dropTypeStatement,
1:21d74bf:              createObjectStatement,
1:21d74bf:              dropObjectStatement,
1:21d74bf:              badDropSQLState
1:21d74bf:              );
1:2209325: 
1:2209325:         // function with a udt arg
1:21d74bf:         createTypeStatement = "create type price_07_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:21d74bf:         dropTypeStatement = "drop type price_07_b restrict\n";
1:21d74bf:         createObjectStatement = 
1:21d74bf:             "create function getCurrencyCode_07_b(  priceArg1 price_07_b  )\n" +
1:21d74bf:             "returns char( 3 )\n" +
1:21d74bf:             "language java\n" +
1:21d74bf:             "parameter style java\n" +
1:21d74bf:             "no sql\n" +
1:21d74bf:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getCurrencyCode'\n";
1:21d74bf:         dropObjectStatement = "drop function getCurrencyCode_07_b\n";
1:21d74bf:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:21d74bf:         verifyDropRestrictions
1:21d74bf:             (
1:21d74bf:              conn,
1:21d74bf:              createTypeStatement,
1:21d74bf:              dropTypeStatement,
1:21d74bf:              createObjectStatement,
1:21d74bf:              dropObjectStatement,
1:21d74bf:              badDropSQLState
1:21d74bf:              );
1:2209325: 
1:2209325:         // procedure with a udt arg
1:21d74bf:         createTypeStatement = "create type price_07_c external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:21d74bf:         dropTypeStatement = "drop type price_07_c restrict\n";
1:21d74bf:         createObjectStatement = 
1:21d74bf:             "create procedure oneArgPriceProc_07( price1 price_07_c )\n" +
1:21d74bf:             "language java\n" +
1:21d74bf:             "parameter style java\n" +
1:21d74bf:             "no sql\n" +
1:21d74bf:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.oneArgPriceProc_07'\n";
1:21d74bf:         dropObjectStatement = "drop procedure oneArgPriceProc_07\n";
1:21d74bf:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:21d74bf:         verifyDropRestrictions
1:21d74bf:             (
1:21d74bf:              conn,
1:21d74bf:              createTypeStatement,
1:21d74bf:              dropTypeStatement,
1:21d74bf:              createObjectStatement,
1:21d74bf:              dropObjectStatement,
1:21d74bf:              badDropSQLState
1:21d74bf:              );
1:2209325: 
1:2209325:         // procedure with two udt args
1:21d74bf:         createTypeStatement = "create type price_07_d external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:21d74bf:         dropTypeStatement = "drop type price_07_d restrict\n";
1:21d74bf:         createObjectStatement = 
1:21d74bf:             "create procedure twoArgPriceProc_07( price1 price_07_d, price2 price_07_d )\n" +
1:21d74bf:             "language java\n" +
1:21d74bf:             "parameter style java\n" +
1:21d74bf:             "no sql\n" +
1:21d74bf:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.twoArgPriceProc_07'\n";
1:21d74bf:         dropObjectStatement = "drop procedure twoArgPriceProc_07\n";
1:21d74bf:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:21d74bf:         verifyDropRestrictions
1:21d74bf:             (
1:21d74bf:              conn,
1:21d74bf:              createTypeStatement,
1:21d74bf:              dropTypeStatement,
1:21d74bf:              createObjectStatement,
1:21d74bf:              dropObjectStatement,
1:21d74bf:              badDropSQLState
1:21d74bf:              );
1:2209325: 
1:b4af7da:         // table function with a udt column
1:b4af7da:         createTypeStatement = "create type hashmap_07 external name 'java.util.HashMap' language java\n";
1:b4af7da:         dropTypeStatement = "drop type hashmap_07 restrict\n";
1:b4af7da:         createObjectStatement = 
1:b4af7da:             "create function hashmapReader_07() returns table\n" +
1:b4af7da:             "(\n" +
1:b4af7da:             "    a int,\n" +
1:b4af7da:             "    b hashmap_07\n" +
1:b4af7da:             ")\n" +
1:b4af7da:             "language java parameter style derby_jdbc_result_set\n" +
1:b4af7da:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.hashmapReader'\n";
1:b4af7da:         dropObjectStatement = "drop function hashmapReader_07\n";
1:b4af7da:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:b4af7da:         verifyDropRestrictions
1:b4af7da:             (
1:b4af7da:              conn,
1:b4af7da:              createTypeStatement,
1:b4af7da:              dropTypeStatement,
1:b4af7da:              createObjectStatement,
1:b4af7da:              dropObjectStatement,
1:b4af7da:              badDropSQLState
1:b4af7da:              );
1:b4af7da: 
1:b4af7da:         // table function with a udt column and udt arg
1:b4af7da:         createTypeStatement = "create type hashmap_07_a external name 'java.util.HashMap' language java\n";
1:b4af7da:         dropTypeStatement = "drop type hashmap_07_a restrict\n";
1:b4af7da:         createObjectStatement = 
1:b4af7da:             "create function hashmapReader_07_a( a hashmap_07_a ) returns table\n" +
1:b4af7da:             "(\n" +
1:b4af7da:             "    a int,\n" +
1:b4af7da:             "    b hashmap_07_a\n" +
1:b4af7da:             ")\n" +
1:b4af7da:             "language java parameter style derby_jdbc_result_set\n" +
1:b4af7da:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.hashmapReader'\n";
1:b4af7da:         dropObjectStatement = "drop function hashmapReader_07_a\n";
1:b4af7da:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:b4af7da:         verifyDropRestrictions
1:b4af7da:             (
1:b4af7da:              conn,
1:b4af7da:              createTypeStatement,
1:b4af7da:              dropTypeStatement,
1:b4af7da:              createObjectStatement,
1:b4af7da:              dropObjectStatement,
1:b4af7da:              badDropSQLState
1:b4af7da:              );
1:b4af7da: 
1:2209325:     }
1:2209325: 
1:21d74bf:     /**
1:21d74bf:      * <p>
1:21d74bf:      * Dependencies of triggers on UDTs.
1:21d74bf:      * </p>
1:21d74bf:      */
1:21d74bf:     public void test_08_triggerDependencies() throws Exception
1:21d74bf:     {
1:21d74bf:         Connection conn = getConnection();
1:21d74bf: 
1:21d74bf:         goodStatement( conn, "create table t_08_a( a int )" );
1:21d74bf:         goodStatement( conn, "create table t_08_b( a int )" );
1:21d74bf: 
1:21d74bf:         String createTypeStatement;
1:21d74bf:         String dropTypeStatement;
1:21d74bf:         String createObjectStatement;
1:21d74bf:         String dropObjectStatement;
1:21d74bf:         String badDropSQLState;
1:21d74bf:         
1:21d74bf:         // trigger that mentions a udt
1:21d74bf:         createTypeStatement = "create type price_08_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:21d74bf:         dropTypeStatement = "drop type price_08_a restrict\n";
1:21d74bf:         createObjectStatement = 
1:21d74bf:             "create trigger trig_08_a after insert on t_08_a\n" +
1:21d74bf:             "  insert into t_08_b( a ) select ( a ) from t_08_a where ( cast( null as price_08_a ) ) is not null\n";
1:21d74bf:         dropObjectStatement = "drop trigger trig_08_a";
1:21d74bf:         badDropSQLState = TRIGGER_DEPENDS_ON_TYPE;
1:21d74bf:         verifyDropRestrictions
1:21d74bf:             (
1:21d74bf:              conn,
1:21d74bf:              createTypeStatement,
1:21d74bf:              dropTypeStatement,
1:21d74bf:              createObjectStatement,
1:21d74bf:              dropObjectStatement,
1:21d74bf:              badDropSQLState
1:21d74bf:              );
1:21d74bf: 
1:21d74bf:     }
1:21d74bf:     
1:e126f58:     /**
1:b8c6110:      * <p>
1:506f4c8:      * Check result set metadata for UDT columns.
1:506f4c8:      * </p>
1:506f4c8:      */
1:506f4c8:     public void test_09_resultSetMetaData() throws Exception
1:506f4c8:     {
1:506f4c8:         Connection conn = getConnection();
1:506f4c8: 
1:506f4c8:         goodStatement( conn, "create type price_09_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:506f4c8:         goodStatement( conn, "create table t_09_a( a price_09_a )\n" );
1:506f4c8: 
1:506f4c8:         // ANSI UDT
1:506f4c8:         checkRSMD
1:506f4c8:             (
1:506f4c8:              conn,
1:506f4c8:              "select a from t_09_a\n",
1:506f4c8:              "org.apache.derbyTesting.functionTests.tests.lang.Price",
1:506f4c8:              15,
1:506f4c8:              java.sql.Types.JAVA_OBJECT,
2:506f4c8:              "\"APP\".\"PRICE_09_A\"",
1:506f4c8:              0,
1:506f4c8:              0
1:506f4c8:              );
1:506f4c8: 
1:506f4c8:         // old-style objects in Derby system tables do not have
1:506f4c8:         // schema-qualified type names
1:506f4c8:         checkRSMD
1:506f4c8:             (
1:506f4c8:              conn,
1:506f4c8:              "select aliasinfo from sys.sysaliases\n",
1:506f4c8:              "org.apache.derby.catalog.AliasInfo",
1:506f4c8:              15,
1:506f4c8:              java.sql.Types.JAVA_OBJECT,
1:506f4c8:              "org.apache.derby.catalog.AliasInfo",
1:506f4c8:              0,
1:506f4c8:              0
1:506f4c8:              );
1:506f4c8:     }
1:506f4c8: 
1:506f4c8:     /**
1:506f4c8:      * <p>
1:506f4c8:      * Check parameter metadata for UDT parameters.
1:506f4c8:      * </p>
1:506f4c8:      */
1:506f4c8:     public void test_10_parameterMetaData() throws Exception
1:506f4c8:     {
1:28e4255:         //
1:28e4255:         // Parameter meta data is not available on JSR-169 platforms,
1:28e4255:         // so skip this test in those environments.
1:28e4255:         //
1:28e4255:         if ( JDBC.vmSupportsJSR169() ) { return; }
1:28e4255:         
1:506f4c8:         Connection conn = getConnection();
1:506f4c8: 
1:506f4c8:         goodStatement( conn, "create type price_10_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:28e4255:         goodStatement( conn, "create table t_10_a( a price_10_a )\n" );
1:506f4c8: 
1:506f4c8:         // ANSI UDT
1:506f4c8:         checkPMD
1:506f4c8:             (
1:506f4c8:              conn,
1:506f4c8:              "insert into t_10_a( a ) values ( ? )\n",
1:506f4c8:              "org.apache.derbyTesting.functionTests.tests.lang.Price",
1:506f4c8:              java.sql.Types.JAVA_OBJECT,
1:28e4255:              "\"APP\".\"PRICE_10_A\"",
1:506f4c8:              0,
1:506f4c8:              0
1:506f4c8:              );
1:506f4c8: 
1:506f4c8:         //
1:506f4c8:         // I don't know of any way to create a statement with a parameter
1:506f4c8:         // whose type is an old-style object from Derby's system tables.
1:506f4c8:         // If you figure out how to trick Derby into letting you do that,
1:506f4c8:         // this would be a good place to assert the shape of the parameter
1:506f4c8:         // meta data for that statement.
1:506f4c8:         //
1:506f4c8:     }
1:506f4c8: 
1:d039ced:     /**
1:e126f58:      * <p>
1:b4af7da:      * Verify that table functions can have UDT columns.
1:b4af7da:      * </p>
1:b4af7da:      */
1:b4af7da:     public void test_11_tableFunctionColumns() throws Exception
1:b4af7da:     {
1:36461a8:         //
1:36461a8:         // This test uses DriverManager.
1:36461a8:         //
1:36461a8:         if ( JDBC.vmSupportsJSR169() ) { return; }
1:36461a8: 
1:b4af7da:         Connection conn = getConnection();
1:b4af7da: 
1:b4af7da:         goodStatement( conn, "create type hashmap_11 external name 'java.util.HashMap' language java\n" );
1:b4af7da:         goodStatement
1:b4af7da:             (
1:b4af7da:              conn,
1:b4af7da:              "create function makeHashMap_11() returns hashmap_11\n" +
1:b4af7da:              "language java parameter style java no sql\n" +
1:b4af7da:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.makeHashMap'\n"
1:b4af7da:              );
1:b4af7da:         goodStatement
1:b4af7da:             (
1:b4af7da:              conn,
1:b4af7da:              "create function putValue_11( map hashmap_11, k varchar( 100 ), v varchar( 100 ) ) returns hashmap_11\n" +
1:b4af7da:              "language java parameter style java no sql\n" +
1:b4af7da:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.putValue'\n"
1:b4af7da:              );
1:b4af7da:         goodStatement( conn, "create table t_11( intCol int, varcharCol varchar( 10 ), hashmapCol hashmap_11 )\n" );
1:b4af7da:         goodStatement
1:b4af7da:             (
1:b4af7da:              conn,
1:b4af7da:              "create function hashmapReader() returns table\n" +
1:b4af7da:              "(\n" +
1:b4af7da:              "    a int,\n" +
1:b4af7da:              "    b hashmap_11\n" +
1:b4af7da:              ")\n" +
1:b4af7da:              "language java parameter style derby_jdbc_result_set\n" +
1:b4af7da:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.hashmapReader'\n"
1:b4af7da:              );
1:b4af7da:         goodStatement( conn, "insert into t_11( intCol, varcharCol, hashmapCol ) values ( 2, 'def', putValue_11( makeHashMap_11(), 'kangaroo', 'foo' ) )\n" );
1:b4af7da: 
1:b4af7da:         assertResults
1:b4af7da:             (
1:b4af7da:              conn,
1:b4af7da:              "select * from table( hashmapReader() ) s",
1:b4af7da:              new String[][]
1:b4af7da:              {
1:b4af7da:                  { "2" ,         "{kangaroo=foo}" },
1:b4af7da:              },
1:b4af7da:              true
1:b4af7da:              );
1:b4af7da:     }
1:b4af7da: 
1:fa292b9:     /**
1:d039ced:      * <p>
1:7a2d290:      * Verify that you can store large objects in UDT columns.
1:7a2d290:      * </p>
1:7a2d290:      */
1:7a2d290:     public void test_12_largeUDTs() throws Exception
1:7a2d290:     {
1:7a2d290:         Connection conn = getConnection();
1:7a2d290: 
1:7a2d290:         //
1:7a2d290:         // Store and retrieve a UDT which is more than 90K bytes long
1:7a2d290:         //
1:7a2d290:         goodStatement( conn, "create type IntArray external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray' language java\n" );
1:7a2d290:         goodStatement
1:7a2d290:             ( conn,
1:7a2d290:               "create function makeIntArray( arrayLength int ) returns IntArray\n" +
1:7a2d290:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray.makeIntArray'\n" );
1:7a2d290:         goodStatement
1:7a2d290:             ( conn,
1:7a2d290:               "create function setCell( array IntArray, cellNumber int, cellValue int ) returns IntArray\n" +
1:7a2d290:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray.setCell'\n" );
1:7a2d290:         goodStatement
1:7a2d290:             ( conn,
1:7a2d290:               "create function getCell( array IntArray, cellNumber int ) returns int\n" +
1:7a2d290:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray.getCell'\n" );
1:7a2d290:         goodStatement( conn, "create table t_12( id int generated always as identity, data IntArray )\n" );
1:7a2d290:         goodStatement( conn, "insert into t_12( data ) values ( setCell( makeIntArray( 3 ), 1, 5 ) )\n" );
1:7a2d290:         goodStatement( conn, "insert into t_12( data ) values ( setCell( makeIntArray( 100000 ), 90000, 3 ) )\n" );
1:7a2d290: 
1:7a2d290:         assertResults
1:7a2d290:             (
1:7a2d290:              conn,
1:7a2d290:              "select getCell( data, 1 ), getCell( data, 2 ) from t_12 where id = 1",
1:7a2d290:              new String[][]
1:7a2d290:              {
1:7a2d290:                  { "5" ,         "0" },
1:7a2d290:              },
1:7a2d290:              true
1:7a2d290:              );
1:7a2d290: 
1:7a2d290:         assertResults
1:7a2d290:             (
1:7a2d290:              conn,
1:7a2d290:              "select getCell( data, 1 ), getCell( data, 90000 ) from t_12 where id = 2",
1:7a2d290:              new String[][]
1:7a2d290:              {
1:7a2d290:                  { "0" ,         "3" },
1:7a2d290:              },
1:7a2d290:              true
1:7a2d290:              );
1:7a2d290:         
1:7a2d290:         //
1:7a2d290:         // Store and retrieve a UDT which is more than 1000K bytes long
1:7a2d290:         //
1:7a2d290:         goodStatement( conn, "create type FakeByteArray external name 'org.apache.derbyTesting.functionTests.tests.lang.FakeByteArray' language java\n" );
1:7a2d290:         goodStatement
1:7a2d290:             ( conn,
1:7a2d290:               "create function makeFakeByteArray( l int, f int ) returns FakeByteArray\n" +
1:7a2d290:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.FakeByteArray.makeFakeByteArray'\n" );
1:7a2d290:         goodStatement
1:7a2d290:             ( conn,
1:7a2d290:               "create function toString( arg FakeByteArray ) returns varchar( 30 )\n" +
1:7a2d290:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.FakeByteArray.toString'\n" );
1:7a2d290:         goodStatement( conn, "create table t_12_a( id int generated always as identity, data FakeByteArray )\n" );
1:7a2d290:         goodStatement( conn, "insert into t_12_a( data ) values ( makeFakeByteArray( 3, 33 ) )\n" );
1:7a2d290:         goodStatement( conn, "insert into t_12_a( data ) values ( makeFakeByteArray( 1000000, 44 ) )\n" );
1:7a2d290: 
1:7a2d290:         assertResults
1:7a2d290:             (
1:7a2d290:              conn,
1:7a2d290:              "select id, toString( data ) from t_12_a order by id",
1:7a2d290:              new String[][]
1:7a2d290:              {
1:7a2d290:                  { "1" ,         "[ 3, 33 ]" },
1:7a2d290:                  { "2" ,         "[ 1000000, 44 ]" },
1:7a2d290:              },
1:7a2d290:              true
1:7a2d290:              );
1:7a2d290:     }
1:7a2d290:     
1:fa292b9:     /**
1:fa292b9:      * <p>
1:e5114fd:      * Verify that implementing the SQLData interface does not make an object storeable.
1:e5114fd:      * </p>
1:e5114fd:      */
1:e5114fd:     public void test_13_sqlData() throws Exception
1:e5114fd:     {
1:36461a8:         //
1:36461a8:         // SQLData not defined in JSR 169.
1:36461a8:         //
1:36461a8:         if ( JDBC.vmSupportsJSR169() ) { return; }
1:36461a8: 
1:e5114fd:         Connection conn = getConnection();
1:e5114fd: 
1:e5114fd:         goodStatement( conn, "create type SampleSQLData external name 'org.apache.derbyTesting.functionTests.tests.lang.SampleSQLData' language java\n" );
1:e5114fd:         goodStatement
1:e5114fd:             ( conn,
1:e5114fd:               "create function makeSampleSQLData( l int ) returns SampleSQLData\n" +
1:e5114fd:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.SampleSQLData.makeSampleSQLData'\n" );
1:e5114fd:         goodStatement( conn, "create table t_13_a( id int generated always as identity, data SampleSQLData )\n" );
1:e5114fd: 
1:e5114fd:         expectExecutionError( conn, JAVA_EXCEPTION, "insert into t_13_a( data ) values ( makeSampleSQLData( 3 ) )\n" );
1:e5114fd:     }
1:e5114fd:     
1:f2a5622:     /**
1:f2a5622:      * <p>
1:f2a5622:      * Verify that you can't bind UDTs to the classes which back the system types.
1:f2a5622:      * </p>
1:f2a5622:      */
1:f2a5622:     public void test_14_systemClasses() throws Exception
1:f2a5622:     {
1:f2a5622:         Connection conn = getConnection();
1:f2a5622: 
1:f2a5622:         //
1:f2a5622:         // Before checking types, make sure that all types we understand are accounted for.
1:f2a5622:         // If a new system type is added, then we need to add it to the following block
1:f2a5622:         // of compilation errors.
1:f2a5622:         //
1:1292a7f:         assertEquals( 21, vetDatatypeCount( conn ) );
1:f2a5622:         
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'byte[]' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Boolean' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Integer' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Long' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Float' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Double' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.String' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.math.BigDecimal' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Blob' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Clob' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Date' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Ref' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Time' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Timestamp' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'org.apache.derby.iapi.types.XML' language java\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'org.apache.derby.Foo' language java\n" );
1:f2a5622:     }
1:f2a5622:     private int vetDatatypeCount( Connection conn ) throws Exception
1:f2a5622:     {
1:f2a5622:         ResultSet rs = conn.getMetaData().getTypeInfo();
1:f2a5622:         int expectedTypeCount = 0;
1:f2a5622:         while ( rs.next() ) { expectedTypeCount++; }
1:f2a5622:         rs.close();
1:f2a5622: 
1:f2a5622:         expectedTypeCount--; // eliminate JAVA_OBJECT
1:f2a5622: 
1:f2a5622:         int actualTypeCount = org.apache.derby.iapi.types.TypeId.getAllBuiltinTypeIds().length;
1:f2a5622:         actualTypeCount--;  // eliminate TINYINT
1:f2a5622:         actualTypeCount--;  // eliminate REF
1:f2a5622:         actualTypeCount++;  // add FLOAT (synonym of REAL)
1:f2a5622: 
1:f2a5622:         //
1:f2a5622:         // Make sure that all types have been added to TypeId.getAllBuiltinTypeIds().
1:f2a5622:         //
1:f2a5622:         assertEquals( expectedTypeCount, actualTypeCount );
1:f2a5622: 
1:f2a5622:         return actualTypeCount;
1:f2a5622:     }
1:f2a5622:     
1:f2a5622: 
1:f2a5622:     /**
1:f2a5622:      * <p>
1:f2a5622:      * Verify that UDTs have no ordering.
1:f2a5622:      * </p>
1:f2a5622:      */
1:f2a5622:     public void test_15_ordering() throws Exception
1:f2a5622:     {
1:f2a5622:         Connection conn = getConnection();
1:f2a5622: 
1:f2a5622:         // Create a Comparable type. We can't take advantage of that interface yet.
1:f2a5622:         goodStatement( conn, "create type IntArray_15 external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray' language java\n" );
1:f2a5622:         goodStatement
1:f2a5622:             ( conn,
1:f2a5622:               "create function makeIntArray_15( arrayLength int ) returns IntArray_15\n" +
1:f2a5622:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray.makeIntArray'\n" );
1:f2a5622:         goodStatement( conn, "create table t_15( a IntArray_15 )\n" );
1:f2a5622:         goodStatement( conn, "insert into t_15( a ) values ( makeIntArray_15( 3 ) )\n" );
1:f2a5622:         goodStatement( conn, "insert into t_15( a ) values ( makeIntArray_15( 4 ) )\n" );
1:f2a5622: 
1:f2a5622:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "create index t_15_idx on t_15( a )\n" );
1:f2a5622:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select * from t_15 order by a\n" );
1:f2a5622:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select * from t_15 group by a\n" );
1:f2a5622:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select distinct a from t_15\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_AGG, "select max( a ) from t_15\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_AGG, "select min( a ) from t_15\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_AGG, "select avg( a ) from t_15\n" );
1:f2a5622:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select * from t_15 union select * from t_15\n" );
1:36461a8:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 where a = makeIntArray_15( 3 )\n" );
1:36461a8:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 where a between makeIntArray_15( 2 ) and makeIntArray_15( 4 )\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a = r.a\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a < r.a\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a > r.a\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a <= r.a\n" );
1:f2a5622:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a >= r.a\n" );
1:f2a5622:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select count( distinct a ) from t_15\n" );
1:f2a5622: 
1:f2a5622:         // but these don't involve any comparisons
1:f2a5622:         goodStatement( conn, "select count(*) from t_15\n" );
1:f2a5622:         goodStatement( conn, "select all * from t_15\n" );
1:f2a5622:     }
1:f2a5622: 
1:30fa79b:     /**
1:30fa79b:      * <p>
1:30fa79b:      * Verify implicit and explicit casts.
1:30fa79b:      * </p>
1:30fa79b:      */
1:30fa79b:     public void test_16_casts() throws Exception
1:30fa79b:     {
1:30fa79b:         Connection conn = getConnection();
1:30fa79b: 
1:30fa79b:         goodStatement( conn, "create type javaSerializable external name 'java.io.Serializable' language java\n" );
1:30fa79b:         goodStatement( conn, "create type javaNumber external name 'java.lang.Number' language java\n" );
1:30fa79b:         goodStatement( conn, "create type javaDate external name 'java.util.Date' language java\n" );
1:30fa79b:         goodStatement
1:30fa79b:             ( conn,
1:30fa79b:               "create function makeNumber( arg int ) returns javaNumber\n" +
1:30fa79b:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.makeNumber'\n" );
1:30fa79b:         goodStatement( conn, "create table t_16( a int generated always as identity, b javaNumber )\n" );
1:30fa79b:         goodStatement( conn, "create table t_16_1( a int generated always as identity, b javaDate )\n" );
1:30fa79b:         goodStatement( conn, "create table t_16_2( a int generated always as identity, b javaSerializable )\n" );
1:30fa79b:         goodStatement( conn, "insert into t_16( b ) values ( makeNumber( 1 ) )\n" );
1:30fa79b:         goodStatement( conn, "insert into t_16( b ) select b from t_16\n" );
1:30fa79b:         
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16( b ) values ( 1 )\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16( b ) values ( 1.0 )\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16( b ) values ( '1' )\n" );
1:30fa79b:         
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_1( b ) values ( date('1994-02-23') )\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_1( b ) values ( time('15:09:02') )\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_1( b ) values ( timestamp('1960-01-01 23:03:20') )\n" );
1:30fa79b: 
1:30fa79b:         // subtypes not recognized yet
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_2( b ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_2( b ) values( cast (null as javaNumber) )\n" );
1:30fa79b: 
1:30fa79b:         // casts to other udts not allowed
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as javaDate) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as javaSerializable) from t_16\n" );
1:30fa79b: 
1:30fa79b:         //
1:30fa79b:         // If this fails, it means that we need to add another system type to the
1:30fa79b:         // cast checks below.
1:30fa79b:         //
1:1292a7f:         assertEquals( 21, vetDatatypeCount( conn ) );
1:30fa79b:         
1:30fa79b:         // casts to system types not allowed
1:1292a7f:         expectCompilationError( BAD_CAST, "select cast (b as boolean) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as bigint) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as blob) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as char( 1 ) ) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as char( 1 ) for bit data) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as clob) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as date) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as decimal) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as double) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as float) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as int) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as long varchar) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as long varchar for bit data) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as numeric) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as real) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as smallint) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as time) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as timestamp) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as varchar(10)) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as varchar(10) for bit data) from t_16\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (b as xml) from t_16\n" );
1:30fa79b: 
1:30fa79b: 
1:30fa79b:         //
1:30fa79b:         // If this fails, it means that we need to add another system type to the
1:30fa79b:         // t_16_all_types table and add a corresponding cast check below.
1:30fa79b:         //
1:1292a7f:         assertEquals( 21, vetDatatypeCount( conn ) );
1:30fa79b:         
1:30fa79b:         goodStatement
1:30fa79b:             (
1:30fa79b:              conn,
1:30fa79b:              "create table t_16_all_types\n" +
1:30fa79b:              "(\n" +
1:30fa79b:              "    a01 bigint,\n" +
1:30fa79b:              "    a02 blob,\n" +
1:30fa79b:              "    a03 char( 1 ),\n" +
1:30fa79b:              "    a04 char( 1 ) for bit data ,\n" +
1:30fa79b:              "    a05 clob,\n" +
1:30fa79b:              "    a06 date,\n" +
1:30fa79b:              "    a07 decimal,\n" +
1:30fa79b:              "    a08 double,\n" +
1:30fa79b:              "    a09 float,\n" +
1:30fa79b:              "    a10 int,\n" +
1:30fa79b:              "    a11 long varchar,\n" +
1:30fa79b:              "    a12 long varchar for bit data,\n" +
1:30fa79b:              "    a13 numeric,\n" +
1:30fa79b:              "    a14 real,\n" +
1:30fa79b:              "    a15 smallint,\n" +
1:30fa79b:              "    a16 time,\n" +
1:30fa79b:              "    a17 timestamp,\n" +
1:30fa79b:              "    a18 varchar(10),\n" +
1:30fa79b:              "    a19 varchar(10) for bit data,\n" +
1:1292a7f:              "    a20 xml,\n" +
1:1292a7f:              "    a21 boolean\n" +
1:30fa79b:              ")"
1:30fa79b:              );
1:30fa79b: 
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a01 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a02 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a03 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a04 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a05 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a06 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a07 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a08 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a09 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a10 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a11 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a12 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a13 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a14 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a15 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a16 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a17 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a18 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a19 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast( a20 as javaSerializable ) from t_16_all_types\n" );
1:1292a7f:         expectCompilationError( BAD_CAST, "select cast( a21 as javaSerializable ) from t_16_all_types\n" );
1:30fa79b: 
1:30fa79b: 
1:30fa79b:         //
1:30fa79b:         // If this fails, it means that we need to add another system type to the
1:30fa79b:         // implicit casts which follow.
1:30fa79b:         //
1:1292a7f:         assertEquals( 21, vetDatatypeCount( conn ) );
1:30fa79b:         
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a01 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a02 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a03 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a04 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a05 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a06 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a07 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a08 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a09 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a10 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a11 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a12 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a13 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a14 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a15 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a16 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a17 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a18 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a19 ) select b from t_16\n" );
1:30fa79b:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a20 ) select b from t_16\n" );
1:1292a7f:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a21 ) select b from t_16\n" );
1:30fa79b:         
1:30fa79b:         // test cast from the half-supported boolean type
1:30fa79b:         expectCompilationError( BAD_CAST, "select cast (isindex as javaNumber) from sys.sysconglomerates\n" );
1:30fa79b: 
1:30fa79b:         // good cast to self
1:30fa79b:         assertResults
1:30fa79b:             (
1:30fa79b:              conn,
1:30fa79b:              "select cast (b as javaNumber) from t_16",
1:30fa79b:              new String[][]
1:30fa79b:              {
1:30fa79b:                  { "1" },
1:30fa79b:                  { "1" },
1:30fa79b:              },
1:30fa79b:              false
1:30fa79b:              );
1:30fa79b:     }
1:30fa79b: 
1:fa292b9:     /**
1:fa292b9:      * <p>
1:33bfdc0:      * Verify that you can use UDTs as output parameters in database procedures.
1:33bfdc0:      * </p>
1:33bfdc0:      */
1:33bfdc0:     public void test_17_outputParameters() throws Exception
1:33bfdc0:     {
1:33bfdc0:         Connection conn = getConnection();
1:33bfdc0: 
1:33bfdc0:         goodStatement( conn, "create type intArray_17 external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray' language java\n" );
1:33bfdc0:         goodStatement
1:33bfdc0:             ( conn,
1:33bfdc0:               "create procedure changeIntArray_17\n" +
1:33bfdc0:               "( in newSize int, inout oldIntArray intArray_17 )\n" +
1:33bfdc0:               "language java parameter style java no sql\n" +
1:33bfdc0:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.changeIntArray'\n" );
1:33bfdc0:         
1:33bfdc0:         CallableStatement cs = chattyPrepareCall( conn, "call changeIntArray_17( ?, ? )" );
1:33bfdc0:         cs.registerOutParameter( 2, java.sql.Types.JAVA_OBJECT );
1:33bfdc0:         cs.setInt( 1, 2 );
1:33bfdc0:         cs.setObject( 2,  new IntArray( new int[ 5 ] ) );
1:33bfdc0:         cs.execute();
1:33bfdc0:         Object obj = cs.getObject( 2 );
1:33bfdc0:         cs.close();
1:33bfdc0: 
1:33bfdc0:         assertEquals( "[ 0, 0 ]", obj.toString() );
1:33bfdc0:     }
1:33bfdc0: 
1:fa292b9:     /**
1:35c061a:      * Verify that you can cast a value to an UDT in a generation clause or
1:35c061a:      * a CHECK constraint. Regression test case for DERBY-6421.
1:35c061a:      */
1:35c061a:     public void test_18_derby6421() throws SQLException {
1:35c061a:         setAutoCommit(false);
1:2209325: 
1:35c061a:         Statement s = createStatement();
1:35c061a:         s.execute("create type d6421_type external name 'java.util.ArrayList' "
1:35c061a:                 + "language java");
1:35c061a:         s.execute("create table d6421_table "
1:35c061a:                 + "(x generated always as (cast(null as d6421_type)), "
1:35c061a:                 + "check (cast(null as d6421_type) is null))");
1:b8c6110: 
1:35c061a:         // This insert used to cause assert failure (in sane builds) or
1:35c061a:         // NullPointerException (in insane builds).
1:35c061a:         s.execute("insert into d6421_table values default");
1:35c061a:     }
1:e126f58: 
1:2209325:     ///////////////////////////////////////////////////////////////////////////////////
1:2209325:     //
1:2732872:     // PROCEDURES AND FUNCTIONS
1:2209325:     //
1:2209325:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9: 
1:2209325:     public static void oneArgPriceProc( Price price1 ) {}
1:2209325:     public static void twoArgPriceProc( Price price1, Price price2 ) {}
1:506f4c8: 
1:33bfdc0:     public static void changeIntArray( int newSize, IntArray[] array )
1:506f4c8:     {
1:33bfdc0:         IntArray newArray = new IntArray( new int[ newSize ] );
1:506f4c8: 
1:33bfdc0:         array[ 0 ] = newArray;
1:506f4c8:     }
1:2209325: 
1:2732872:     public static HashMap makeHashMap() { return new HashMap(); }
1:2732872: 
1:3c7d0d9:     public static HashMap makeHashMap( String key, Integer value )
1:3c7d0d9:     {
1:3c7d0d9:         HashMap<String,Integer> map = new HashMap<String,Integer>();
1:3c7d0d9:         map.put( key, value );
1:3c7d0d9:         return map;
1:3c7d0d9:     }
1:3c7d0d9: 
1:3f5c48a:     public static HashMap putValue(
1:3f5c48a:             HashMap<String, String> map, String key, String value)
1:2732872:     {
1:2732872:         map.put( key, value );
1:2732872: 
1:2732872:         return map;
1:2732872:     }
1:2732872: 
1:b4af7da:     public static ResultSet hashmapReader() throws Exception
1:b4af7da:     {
1:b4af7da:         Connection conn = DriverManager.getConnection( "jdbc:default:connection" );
1:b4af7da: 
1:b4af7da:         PreparedStatement ps = conn.prepareStatement( "select intCol, hashmapCol from t_11" );
1:b4af7da: 
1:b4af7da:         return ps.executeQuery();
1:b4af7da:     }
1:30fa79b: 
1:39b3237:     public static Number makeNumber( int arg ) { return arg; }
1:b4af7da: 
1:070d37e:     public  static  Integer getIntValue( HashMap<String,Integer> map, String key )
1:070d37e:     {
1:070d37e:         return map.get( key );
1:070d37e:     }
1:070d37e: 
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9:     //
1:fa292b9:     // MINIONS
1:fa292b9:     //
1:fa292b9:     ///////////////////////////////////////////////////////////////////////////////////
1:fa292b9: 
1:35c061a:     /**
1:21d74bf:      * Verify that a type can't be dropped if it is used by a schema object.
1:21d74bf:      */
1:21d74bf:     private void verifyDropRestrictions
1:21d74bf:         (
1:21d74bf:          Connection conn,
1:21d74bf:          String createTypeStatement,
1:21d74bf:          String dropTypeStatement,
1:21d74bf:          String createObjectStatement,
1:21d74bf:          String dropObjectStatement,
1:21d74bf:          String badDropSQLState
1:21d74bf:          )
1:21d74bf:         throws Exception
1:21d74bf:     {
1:21d74bf:         goodStatement( conn, createTypeStatement );
1:21d74bf:         goodStatement( conn, createObjectStatement );
1:21d74bf:         expectExecutionError( conn, badDropSQLState, dropTypeStatement );
1:21d74bf:         goodStatement( conn, dropObjectStatement );
1:21d74bf:         goodStatement( conn, dropTypeStatement );
1:21d74bf:     }
1:21d74bf: 
1:e126f58:     /** Get the number of dependencies that a table has */
1:e126f58:     private int countTableDependencies( Connection conn, String tableName ) throws Exception
1:e126f58:     {
1:e126f58:         PreparedStatement ps = chattyPrepare
1:e126f58:             ( conn, "select count(*) from sys.sysdepends d, sys.systables t where d.dependentid = t.tableid and t.tablename = ?" );
1:e126f58:         ps.setString( 1, tableName );
1:e126f58: 
1:e126f58:         return getScalarInteger( ps );
1:e126f58:     }
1:e126f58: 
1:e126f58:     /** Get a scalar integer result from a query */
1:e126f58:     private int getScalarInteger( PreparedStatement ps ) throws Exception
1:e126f58:     {
1:e126f58:         ResultSet rs = ps.executeQuery();
1:e126f58:         rs.next();
1:e126f58:         int retval = rs.getInt( 1 );
1:e126f58: 
1:e126f58:         rs.close();
1:e126f58:         ps.close();
1:e126f58: 
1:e126f58:         return retval;
1:e126f58:     }
1:e126f58: 
1:506f4c8:     /**
1:506f4c8:      * Check the ResultSetMetaData for a query whose first column is a UDT.
1:506f4c8:      */
1:506f4c8:     private void checkRSMD
1:506f4c8:         (
1:506f4c8:          Connection conn,
1:506f4c8:          String query,
1:506f4c8:          String expectedClassName,
1:506f4c8:          int expectedDisplaySize,
1:506f4c8:          int expectedJDBCType,
1:506f4c8:          String expectedSQLTypeName,
1:506f4c8:          int expectedPrecision,
1:506f4c8:          int expectedScale
1:506f4c8:          ) throws Exception
1:506f4c8:     {
1:506f4c8:         PreparedStatement ps = conn.prepareStatement( query );
1:506f4c8:         ResultSet rs = ps.executeQuery();
1:506f4c8:         ResultSetMetaData rsmd = rs.getMetaData();
1:506f4c8: 
1:506f4c8:         assertEquals( rsmd.getColumnClassName( 1 ), expectedClassName );
1:506f4c8:         assertEquals( rsmd.getColumnDisplaySize( 1 ), expectedDisplaySize );
1:506f4c8:         assertEquals( rsmd.getColumnType( 1 ), expectedJDBCType );
1:506f4c8:         assertEquals( rsmd.getColumnTypeName( 1 ), expectedSQLTypeName );
1:506f4c8:         assertEquals( rsmd.getPrecision( 1 ), expectedPrecision );
1:506f4c8:         assertEquals( rsmd.getScale( 1 ), expectedScale );
1:506f4c8: 
1:506f4c8:         rs.close();
1:506f4c8:         ps.close();
1:506f4c8:     }
1:506f4c8:     
1:506f4c8:     /**
1:506f4c8:      * Check the ParameterMetaData for a statement whose first parameter is a UDT.
1:506f4c8:      */
1:506f4c8:     private void checkPMD
1:506f4c8:         (
1:506f4c8:          Connection conn,
1:506f4c8:          String query,
1:506f4c8:          String expectedClassName,
1:506f4c8:          int expectedJDBCType,
1:506f4c8:          String expectedSQLTypeName,
1:506f4c8:          int expectedPrecision,
1:506f4c8:          int expectedScale
1:506f4c8:          ) throws Exception
1:506f4c8:     {
1:506f4c8:         PreparedStatement ps = conn.prepareStatement( query );
1:506f4c8:         ParameterMetaData pmd = ps.getParameterMetaData();
1:506f4c8: 
1:506f4c8:         assertEquals( pmd.getParameterClassName( 1 ), expectedClassName );
1:506f4c8:         assertEquals( pmd.getParameterType( 1 ), expectedJDBCType );
1:506f4c8:         assertEquals( pmd.getParameterTypeName( 1 ), expectedSQLTypeName );
1:506f4c8:         assertEquals( pmd.getPrecision( 1 ), expectedPrecision );
1:506f4c8:         assertEquals( pmd.getScale( 1 ), expectedScale );
1:506f4c8: 
1:506f4c8:         ps.close();
1:506f4c8:     }
1:506f4c8: 
1:fa292b9: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:     public static Number makeNumber( int arg ) { return arg; }
commit:3c7d0d9
/////////////////////////////////////////////////////////////////////////
1:     public static HashMap makeHashMap( String key, Integer value )
1:     {
1:         HashMap<String,Integer> map = new HashMap<String,Integer>();
1:         map.put( key, value );
1:         return map;
1:     }
1: 
commit:070d37e
/////////////////////////////////////////////////////////////////////////
1:     public  static  Integer getIntValue( HashMap<String,Integer> map, String key )
1:     {
1:         return map.get( key );
1:     }
1: 
commit:1292a7f
/////////////////////////////////////////////////////////////////////////
1:         assertEquals( 21, vetDatatypeCount( conn ) );
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         assertEquals( 21, vetDatatypeCount( conn ) );
1:         expectCompilationError( BAD_CAST, "select cast (b as boolean) from t_16\n" );
/////////////////////////////////////////////////////////////////////////
1:         assertEquals( 21, vetDatatypeCount( conn ) );
/////////////////////////////////////////////////////////////////////////
1:              "    a20 xml,\n" +
1:              "    a21 boolean\n" +
/////////////////////////////////////////////////////////////////////////
1:         expectCompilationError( BAD_CAST, "select cast( a21 as javaSerializable ) from t_16_all_types\n" );
1:         assertEquals( 21, vetDatatypeCount( conn ) );
/////////////////////////////////////////////////////////////////////////
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a21 ) select b from t_16\n" );
commit:33bfdc0
/////////////////////////////////////////////////////////////////////////
1: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify that you can use UDTs as output parameters in database procedures.
1:      * </p>
1:      */
1:     public void test_17_outputParameters() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create type intArray_17 external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create procedure changeIntArray_17\n" +
1:               "( in newSize int, inout oldIntArray intArray_17 )\n" +
1:               "language java parameter style java no sql\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.changeIntArray'\n" );
1:         
1:         CallableStatement cs = chattyPrepareCall( conn, "call changeIntArray_17( ?, ? )" );
1:         cs.registerOutParameter( 2, java.sql.Types.JAVA_OBJECT );
1:         cs.setInt( 1, 2 );
1:         cs.setObject( 2,  new IntArray( new int[ 5 ] ) );
1:         cs.execute();
1:         Object obj = cs.getObject( 2 );
1:         cs.close();
1: 
1:         assertEquals( "[ 0, 0 ]", obj.toString() );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static void changeIntArray( int newSize, IntArray[] array )
1:         IntArray newArray = new IntArray( new int[ newSize ] );
1:         array[ 0 ] = newArray;
commit:30fa79b
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify implicit and explicit casts.
1:      * </p>
1:      */
1:     public void test_16_casts() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create type javaSerializable external name 'java.io.Serializable' language java\n" );
1:         goodStatement( conn, "create type javaNumber external name 'java.lang.Number' language java\n" );
1:         goodStatement( conn, "create type javaDate external name 'java.util.Date' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create function makeNumber( arg int ) returns javaNumber\n" +
1:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.makeNumber'\n" );
1:         goodStatement( conn, "create table t_16( a int generated always as identity, b javaNumber )\n" );
1:         goodStatement( conn, "create table t_16_1( a int generated always as identity, b javaDate )\n" );
1:         goodStatement( conn, "create table t_16_2( a int generated always as identity, b javaSerializable )\n" );
1:         goodStatement( conn, "insert into t_16( b ) values ( makeNumber( 1 ) )\n" );
1:         goodStatement( conn, "insert into t_16( b ) select b from t_16\n" );
1:         
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16( b ) values ( 1 )\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16( b ) values ( 1.0 )\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16( b ) values ( '1' )\n" );
1:         
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_1( b ) values ( date('1994-02-23') )\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_1( b ) values ( time('15:09:02') )\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_1( b ) values ( timestamp('1960-01-01 23:03:20') )\n" );
1: 
1:         // subtypes not recognized yet
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_2( b ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_2( b ) values( cast (null as javaNumber) )\n" );
1: 
1:         // casts to other udts not allowed
1:         expectCompilationError( BAD_CAST, "select cast (b as javaDate) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as javaSerializable) from t_16\n" );
1: 
1:         //
1:         // If this fails, it means that we need to add another system type to the
1:         // cast checks below.
1:         //
0:         assertEquals( 20, vetDatatypeCount( conn ) );
1:         
1:         // casts to system types not allowed
1:         expectCompilationError( BAD_CAST, "select cast (b as bigint) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as blob) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as char( 1 ) ) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as char( 1 ) for bit data) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as clob) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as date) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as decimal) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as double) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as float) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as int) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as long varchar) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as long varchar for bit data) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as numeric) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as real) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as smallint) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as time) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as timestamp) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as varchar(10)) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as varchar(10) for bit data) from t_16\n" );
1:         expectCompilationError( BAD_CAST, "select cast (b as xml) from t_16\n" );
1: 
1: 
1:         //
1:         // If this fails, it means that we need to add another system type to the
1:         // t_16_all_types table and add a corresponding cast check below.
1:         //
0:         assertEquals( 20, vetDatatypeCount( conn ) );
1:         
1:         goodStatement
1:             (
1:              conn,
1:              "create table t_16_all_types\n" +
1:              "(\n" +
1:              "    a01 bigint,\n" +
1:              "    a02 blob,\n" +
1:              "    a03 char( 1 ),\n" +
1:              "    a04 char( 1 ) for bit data ,\n" +
1:              "    a05 clob,\n" +
1:              "    a06 date,\n" +
1:              "    a07 decimal,\n" +
1:              "    a08 double,\n" +
1:              "    a09 float,\n" +
1:              "    a10 int,\n" +
1:              "    a11 long varchar,\n" +
1:              "    a12 long varchar for bit data,\n" +
1:              "    a13 numeric,\n" +
1:              "    a14 real,\n" +
1:              "    a15 smallint,\n" +
1:              "    a16 time,\n" +
1:              "    a17 timestamp,\n" +
1:              "    a18 varchar(10),\n" +
1:              "    a19 varchar(10) for bit data,\n" +
0:              "    a20 xml\n" +
1:              ")"
1:              );
1: 
1:         expectCompilationError( BAD_CAST, "select cast( a01 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a02 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a03 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a04 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a05 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a06 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a07 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a08 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a09 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a10 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a11 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a12 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a13 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a14 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a15 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a16 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a17 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a18 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a19 as javaSerializable ) from t_16_all_types\n" );
1:         expectCompilationError( BAD_CAST, "select cast( a20 as javaSerializable ) from t_16_all_types\n" );
1: 
1: 
1:         //
1:         // If this fails, it means that we need to add another system type to the
1:         // implicit casts which follow.
1:         //
0:         assertEquals( 20, vetDatatypeCount( conn ) );
1:         
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a01 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a02 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a03 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a04 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a05 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a06 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a07 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a08 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a09 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a10 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a11 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a12 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a13 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a14 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a15 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a16 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a17 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a18 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a19 ) select b from t_16\n" );
1:         expectCompilationError( ILLEGAL_STORAGE, "insert into t_16_all_types( a20 ) select b from t_16\n" );
1:         
1:         // test cast from the half-supported boolean type
1:         expectCompilationError( BAD_CAST, "select cast (isindex as javaNumber) from sys.sysconglomerates\n" );
1: 
1:         // good cast to self
1:         assertResults
1:             (
1:              conn,
1:              "select cast (b as javaNumber) from t_16",
1:              new String[][]
1:              {
1:                  { "1" },
1:                  { "1" },
1:              },
1:              false
1:              );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     public static Number makeNumber( int arg ) { return new Integer( arg ); }
1: 
commit:36461a8
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // This test uses DriverManager.
1:         //
1:         if ( JDBC.vmSupportsJSR169() ) { return; }
1: 
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // SQLData not defined in JSR 169.
1:         //
1:         if ( JDBC.vmSupportsJSR169() ) { return; }
1: 
/////////////////////////////////////////////////////////////////////////
1:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 where a = makeIntArray_15( 3 )\n" );
1:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 where a between makeIntArray_15( 2 ) and makeIntArray_15( 4 )\n" );
commit:f2a5622
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify that you can't bind UDTs to the classes which back the system types.
1:      * </p>
1:      */
1:     public void test_14_systemClasses() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         //
1:         // Before checking types, make sure that all types we understand are accounted for.
1:         // If a new system type is added, then we need to add it to the following block
1:         // of compilation errors.
1:         //
0:         assertEquals( 20, vetDatatypeCount( conn ) );
1:         
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'byte[]' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Boolean' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Integer' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Long' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Float' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.Double' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.lang.String' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.math.BigDecimal' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Blob' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Clob' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Date' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Ref' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Time' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'java.sql.Timestamp' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'org.apache.derby.iapi.types.XML' language java\n" );
1:         expectCompilationError( ILLEGAL_UDT_CLASS, "create type java_string external name 'org.apache.derby.Foo' language java\n" );
1:     }
1:     private int vetDatatypeCount( Connection conn ) throws Exception
1:     {
1:         ResultSet rs = conn.getMetaData().getTypeInfo();
1:         int expectedTypeCount = 0;
1:         while ( rs.next() ) { expectedTypeCount++; }
1:         rs.close();
1: 
1:         expectedTypeCount--; // eliminate JAVA_OBJECT
1: 
1:         int actualTypeCount = org.apache.derby.iapi.types.TypeId.getAllBuiltinTypeIds().length;
0:         actualTypeCount--;  // eliminate BOOLEAN
1:         actualTypeCount--;  // eliminate TINYINT
1:         actualTypeCount--;  // eliminate REF
1:         actualTypeCount++;  // add FLOAT (synonym of REAL)
1: 
1:         //
1:         // Make sure that all types have been added to TypeId.getAllBuiltinTypeIds().
1:         //
1:         assertEquals( expectedTypeCount, actualTypeCount );
1: 
1:         return actualTypeCount;
1:     }
1:     
1: 
1:     /**
1:      * <p>
1:      * Verify that UDTs have no ordering.
1:      * </p>
1:      */
1:     public void test_15_ordering() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // Create a Comparable type. We can't take advantage of that interface yet.
1:         goodStatement( conn, "create type IntArray_15 external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create function makeIntArray_15( arrayLength int ) returns IntArray_15\n" +
1:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray.makeIntArray'\n" );
1:         goodStatement( conn, "create table t_15( a IntArray_15 )\n" );
1:         goodStatement( conn, "insert into t_15( a ) values ( makeIntArray_15( 3 ) )\n" );
1:         goodStatement( conn, "insert into t_15( a ) values ( makeIntArray_15( 4 ) )\n" );
1: 
1:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "create index t_15_idx on t_15( a )\n" );
1:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select * from t_15 order by a\n" );
1:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select * from t_15 group by a\n" );
1:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select distinct a from t_15\n" );
1:         expectCompilationError( ILLEGAL_AGG, "select max( a ) from t_15\n" );
1:         expectCompilationError( ILLEGAL_AGG, "select min( a ) from t_15\n" );
1:         expectCompilationError( ILLEGAL_AGG, "select avg( a ) from t_15\n" );
1:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select * from t_15 union select * from t_15\n" );
0:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 where a = makeIntArray( 3 )\n" );
0:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 where a between makeIntArray( 2 ) and makeIntArray( 4 )\n" );
1:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a = r.a\n" );
1:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a < r.a\n" );
1:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a > r.a\n" );
1:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a <= r.a\n" );
1:         expectCompilationError( ILLEGAL_COMPARISON, "select * from t_15 l, t_15 r where l.a >= r.a\n" );
1:         expectCompilationError( FORBIDDEN_ORDERING_OPERATION, "select count( distinct a ) from t_15\n" );
1: 
1:         // but these don't involve any comparisons
1:         goodStatement( conn, "select count(*) from t_15\n" );
1:         goodStatement( conn, "select all * from t_15\n" );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
commit:e5114fd
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify that implementing the SQLData interface does not make an object storeable.
1:      * </p>
1:      */
1:     public void test_13_sqlData() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create type SampleSQLData external name 'org.apache.derbyTesting.functionTests.tests.lang.SampleSQLData' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create function makeSampleSQLData( l int ) returns SampleSQLData\n" +
1:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.SampleSQLData.makeSampleSQLData'\n" );
1:         goodStatement( conn, "create table t_13_a( id int generated always as identity, data SampleSQLData )\n" );
1: 
1:         expectExecutionError( conn, JAVA_EXCEPTION, "insert into t_13_a( data ) values ( makeSampleSQLData( 3 ) )\n" );
1:     }
1:     
commit:139ca85
/////////////////////////////////////////////////////////////////////////
commit:7a2d290
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify that you can store large objects in UDT columns.
1:      * </p>
1:      */
1:     public void test_12_largeUDTs() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         //
1:         // Store and retrieve a UDT which is more than 90K bytes long
1:         //
1:         goodStatement( conn, "create type IntArray external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create function makeIntArray( arrayLength int ) returns IntArray\n" +
1:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray.makeIntArray'\n" );
1:         goodStatement
1:             ( conn,
1:               "create function setCell( array IntArray, cellNumber int, cellValue int ) returns IntArray\n" +
1:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray.setCell'\n" );
1:         goodStatement
1:             ( conn,
1:               "create function getCell( array IntArray, cellNumber int ) returns int\n" +
1:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.IntArray.getCell'\n" );
1:         goodStatement( conn, "create table t_12( id int generated always as identity, data IntArray )\n" );
1:         goodStatement( conn, "insert into t_12( data ) values ( setCell( makeIntArray( 3 ), 1, 5 ) )\n" );
1:         goodStatement( conn, "insert into t_12( data ) values ( setCell( makeIntArray( 100000 ), 90000, 3 ) )\n" );
1: 
1:         assertResults
1:             (
1:              conn,
1:              "select getCell( data, 1 ), getCell( data, 2 ) from t_12 where id = 1",
1:              new String[][]
1:              {
1:                  { "5" ,         "0" },
1:              },
1:              true
1:              );
1: 
1:         assertResults
1:             (
1:              conn,
1:              "select getCell( data, 1 ), getCell( data, 90000 ) from t_12 where id = 2",
1:              new String[][]
1:              {
1:                  { "0" ,         "3" },
1:              },
1:              true
1:              );
1:         
1:         //
1:         // Store and retrieve a UDT which is more than 1000K bytes long
1:         //
1:         goodStatement( conn, "create type FakeByteArray external name 'org.apache.derbyTesting.functionTests.tests.lang.FakeByteArray' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create function makeFakeByteArray( l int, f int ) returns FakeByteArray\n" +
1:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.FakeByteArray.makeFakeByteArray'\n" );
1:         goodStatement
1:             ( conn,
1:               "create function toString( arg FakeByteArray ) returns varchar( 30 )\n" +
1:               "language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.FakeByteArray.toString'\n" );
1:         goodStatement( conn, "create table t_12_a( id int generated always as identity, data FakeByteArray )\n" );
1:         goodStatement( conn, "insert into t_12_a( data ) values ( makeFakeByteArray( 3, 33 ) )\n" );
1:         goodStatement( conn, "insert into t_12_a( data ) values ( makeFakeByteArray( 1000000, 44 ) )\n" );
1: 
1:         assertResults
1:             (
1:              conn,
1:              "select id, toString( data ) from t_12_a order by id",
1:              new String[][]
1:              {
1:                  { "1" ,         "[ 3, 33 ]" },
1:                  { "2" ,         "[ 1000000, 44 ]" },
1:              },
1:              true
1:              );
1:     }
1:     
commit:b4af7da
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DriverManager;
/////////////////////////////////////////////////////////////////////////
1:         // table function with a udt column
1:         createTypeStatement = "create type hashmap_07 external name 'java.util.HashMap' language java\n";
1:         dropTypeStatement = "drop type hashmap_07 restrict\n";
1:         createObjectStatement = 
1:             "create function hashmapReader_07() returns table\n" +
1:             "(\n" +
1:             "    a int,\n" +
1:             "    b hashmap_07\n" +
1:             ")\n" +
1:             "language java parameter style derby_jdbc_result_set\n" +
1:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.hashmapReader'\n";
1:         dropObjectStatement = "drop function hashmapReader_07\n";
1:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:         verifyDropRestrictions
1:             (
1:              conn,
1:              createTypeStatement,
1:              dropTypeStatement,
1:              createObjectStatement,
1:              dropObjectStatement,
1:              badDropSQLState
1:              );
1: 
1:         // table function with a udt column and udt arg
1:         createTypeStatement = "create type hashmap_07_a external name 'java.util.HashMap' language java\n";
1:         dropTypeStatement = "drop type hashmap_07_a restrict\n";
1:         createObjectStatement = 
1:             "create function hashmapReader_07_a( a hashmap_07_a ) returns table\n" +
1:             "(\n" +
1:             "    a int,\n" +
1:             "    b hashmap_07_a\n" +
1:             ")\n" +
1:             "language java parameter style derby_jdbc_result_set\n" +
1:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.hashmapReader'\n";
1:         dropObjectStatement = "drop function hashmapReader_07_a\n";
1:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:         verifyDropRestrictions
1:             (
1:              conn,
1:              createTypeStatement,
1:              dropTypeStatement,
1:              createObjectStatement,
1:              dropObjectStatement,
1:              badDropSQLState
1:              );
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify that table functions can have UDT columns.
1:      * </p>
1:      */
1:     public void test_11_tableFunctionColumns() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create type hashmap_11 external name 'java.util.HashMap' language java\n" );
1:         goodStatement
1:             (
1:              conn,
1:              "create function makeHashMap_11() returns hashmap_11\n" +
1:              "language java parameter style java no sql\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.makeHashMap'\n"
1:              );
1:         goodStatement
1:             (
1:              conn,
1:              "create function putValue_11( map hashmap_11, k varchar( 100 ), v varchar( 100 ) ) returns hashmap_11\n" +
1:              "language java parameter style java no sql\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.putValue'\n"
1:              );
1:         goodStatement( conn, "create table t_11( intCol int, varcharCol varchar( 10 ), hashmapCol hashmap_11 )\n" );
1:         goodStatement
1:             (
1:              conn,
1:              "create function hashmapReader() returns table\n" +
1:              "(\n" +
1:              "    a int,\n" +
1:              "    b hashmap_11\n" +
1:              ")\n" +
1:              "language java parameter style derby_jdbc_result_set\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.hashmapReader'\n"
1:              );
1:         goodStatement( conn, "insert into t_11( intCol, varcharCol, hashmapCol ) values ( 2, 'def', putValue_11( makeHashMap_11(), 'kangaroo', 'foo' ) )\n" );
1: 
1:         assertResults
1:             (
1:              conn,
1:              "select * from table( hashmapReader() ) s",
1:              new String[][]
1:              {
1:                  { "2" ,         "{kangaroo=foo}" },
1:              },
1:              true
1:              );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public static ResultSet hashmapReader() throws Exception
1:     {
1:         Connection conn = DriverManager.getConnection( "jdbc:default:connection" );
1: 
1:         PreparedStatement ps = conn.prepareStatement( "select intCol, hashmapCol from t_11" );
1: 
1:         return ps.executeQuery();
1:     }
1: 
commit:2732872
/////////////////////////////////////////////////////////////////////////
1: import java.util.HashMap;
/////////////////////////////////////////////////////////////////////////
1:     // PROCEDURES AND FUNCTIONS
/////////////////////////////////////////////////////////////////////////
1:     public static HashMap makeHashMap() { return new HashMap(); }
1: 
0:     public static HashMap putValue( HashMap map, String key, String value )
1:     {
1:         map.put( key, value );
1: 
1:         return map;
1:     }
1: 
1:     
1: 
commit:28e4255
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Parameter meta data is not available on JSR-169 platforms,
1:         // so skip this test in those environments.
1:         //
1:         if ( JDBC.vmSupportsJSR169() ) { return; }
1:         
1:         goodStatement( conn, "create table t_10_a( a price_10_a )\n" );
/////////////////////////////////////////////////////////////////////////
1:              "\"APP\".\"PRICE_10_A\"",
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
1: import java.sql.ParameterMetaData;
1: import java.sql.ResultSetMetaData;
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = (TestSuite) TestConfiguration.defaultSuite(UDTTest.class);
/////////////////////////////////////////////////////////////////////////
1:              "select getCurrencyCode( totalPrice ), getTimeInstant( totalPrice ) from orders",
1:                  { "USD" ,         "2009-10-16 14:24:43.0" },
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Check result set metadata for UDT columns.
1:      * </p>
1:      */
1:     public void test_09_resultSetMetaData() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create type price_09_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement( conn, "create table t_09_a( a price_09_a )\n" );
1: 
1:         // ANSI UDT
1:         checkRSMD
1:             (
1:              conn,
1:              "select a from t_09_a\n",
1:              "org.apache.derbyTesting.functionTests.tests.lang.Price",
1:              15,
1:              java.sql.Types.JAVA_OBJECT,
1:              "\"APP\".\"PRICE_09_A\"",
1:              0,
1:              0
1:              );
1: 
1:         // old-style objects in Derby system tables do not have
1:         // schema-qualified type names
1:         checkRSMD
1:             (
1:              conn,
1:              "select aliasinfo from sys.sysaliases\n",
1:              "org.apache.derby.catalog.AliasInfo",
1:              15,
1:              java.sql.Types.JAVA_OBJECT,
1:              "org.apache.derby.catalog.AliasInfo",
1:              0,
1:              0
1:              );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Check parameter metadata for UDT parameters.
1:      * </p>
1:      */
1:     public void test_10_parameterMetaData() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create type price_10_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
0:         goodStatement( conn, "create table t_10_a( a price_09_a )\n" );
1: 
1:         // ANSI UDT
1:         checkPMD
1:             (
1:              conn,
1:              "insert into t_10_a( a ) values ( ? )\n",
1:              "org.apache.derbyTesting.functionTests.tests.lang.Price",
1:              java.sql.Types.JAVA_OBJECT,
1:              "\"APP\".\"PRICE_09_A\"",
1:              0,
1:              0
1:              );
1: 
1:         //
1:         // I don't know of any way to create a statement with a parameter
1:         // whose type is an old-style object from Derby's system tables.
1:         // If you figure out how to trick Derby into letting you do that,
1:         // this would be a good place to assert the shape of the parameter
1:         // meta data for that statement.
1:         //
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     public static void changeCurrencyCode( String newCurrencyCode, Price[] price )
1:     {
0:         Price oldPrice = price[ 0 ];
0:         Price newPrice = new Price( newCurrencyCode, oldPrice.amount, oldPrice.timeInstant );
1: 
0:         price[ 0 ] = newPrice;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check the ResultSetMetaData for a query whose first column is a UDT.
1:      */
1:     private void checkRSMD
1:         (
1:          Connection conn,
1:          String query,
1:          String expectedClassName,
1:          int expectedDisplaySize,
1:          int expectedJDBCType,
1:          String expectedSQLTypeName,
1:          int expectedPrecision,
1:          int expectedScale
1:          ) throws Exception
1:     {
1:         PreparedStatement ps = conn.prepareStatement( query );
1:         ResultSet rs = ps.executeQuery();
1:         ResultSetMetaData rsmd = rs.getMetaData();
1: 
1:         assertEquals( rsmd.getColumnClassName( 1 ), expectedClassName );
1:         assertEquals( rsmd.getColumnDisplaySize( 1 ), expectedDisplaySize );
1:         assertEquals( rsmd.getColumnType( 1 ), expectedJDBCType );
1:         assertEquals( rsmd.getColumnTypeName( 1 ), expectedSQLTypeName );
1:         assertEquals( rsmd.getPrecision( 1 ), expectedPrecision );
1:         assertEquals( rsmd.getScale( 1 ), expectedScale );
1: 
1:         rs.close();
1:         ps.close();
1:     }
1:     
1:     /**
1:      * Check the ParameterMetaData for a statement whose first parameter is a UDT.
1:      */
1:     private void checkPMD
1:         (
1:          Connection conn,
1:          String query,
1:          String expectedClassName,
1:          int expectedJDBCType,
1:          String expectedSQLTypeName,
1:          int expectedPrecision,
1:          int expectedScale
1:          ) throws Exception
1:     {
1:         PreparedStatement ps = conn.prepareStatement( query );
1:         ParameterMetaData pmd = ps.getParameterMetaData();
1: 
1:         assertEquals( pmd.getParameterClassName( 1 ), expectedClassName );
1:         assertEquals( pmd.getParameterType( 1 ), expectedJDBCType );
1:         assertEquals( pmd.getParameterTypeName( 1 ), expectedSQLTypeName );
1:         assertEquals( pmd.getPrecision( 1 ), expectedPrecision );
1:         assertEquals( pmd.getScale( 1 ), expectedScale );
1: 
1:         ps.close();
1:     }
1: 
commit:21d74bf
/////////////////////////////////////////////////////////////////////////
1:     public static final String TRIGGER_DEPENDS_ON_TYPE = "X0Y24";
/////////////////////////////////////////////////////////////////////////
1:         String createTypeStatement;
1:         String dropTypeStatement;
1:         String createObjectStatement;
1:         String dropObjectStatement;
1:         String badDropSQLState;
1:         
1:         createTypeStatement = "create type price_05_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:         dropTypeStatement = "drop type price_05_a restrict\n";
1:         createObjectStatement = 
1:             "from sys.systables\n";
1:         dropObjectStatement = "drop view udtView\n";
1:         badDropSQLState = VIEW_DEPENDS_ON_TYPE;
1:         verifyDropRestrictions
1:              createTypeStatement,
1:              dropTypeStatement,
1:              createObjectStatement,
1:              dropObjectStatement,
1:              badDropSQLState
1:              );
1: 
1:         // view with UDT in where clause
1:         createTypeStatement = "create type price_05_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:         dropTypeStatement = "drop type price_05_b restrict\n";
1:         createObjectStatement = 
1:             "select tabletype from sys.systables where ( cast (null as price_05_b) ) is not null\n";
1:         dropObjectStatement = "drop view udtView_b\n";
1:         badDropSQLState = VIEW_DEPENDS_ON_TYPE;
1:         verifyDropRestrictions
1:             (
1:              conn,
1:              createTypeStatement,
1:              dropTypeStatement,
1:              createObjectStatement,
1:              dropObjectStatement,
1:              badDropSQLState
1:              );
/////////////////////////////////////////////////////////////////////////
1:         String createTypeStatement;
1:         String dropTypeStatement;
1:         String createObjectStatement;
1:         String dropObjectStatement;
1:         String badDropSQLState;
1:         
1:         createTypeStatement = "create type price_07_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:         dropTypeStatement = "drop type price_07_a restrict\n";
1:         createObjectStatement = 
1:             "create function makePrice_07_a( )\n" +
1:             "returns price_07_a\n" +
1:             "language java\n" +
1:             "parameter style java\n" +
1:             "no sql\n" +
1:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n";
1:         dropObjectStatement = "drop function makePrice_07_a\n";
1:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:         verifyDropRestrictions
1:             (
1:              conn,
1:              createTypeStatement,
1:              dropTypeStatement,
1:              createObjectStatement,
1:              dropObjectStatement,
1:              badDropSQLState
1:              );
1:         createTypeStatement = "create type price_07_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:         dropTypeStatement = "drop type price_07_b restrict\n";
1:         createObjectStatement = 
1:             "create function getCurrencyCode_07_b(  priceArg1 price_07_b  )\n" +
1:             "returns char( 3 )\n" +
1:             "language java\n" +
1:             "parameter style java\n" +
1:             "no sql\n" +
1:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getCurrencyCode'\n";
1:         dropObjectStatement = "drop function getCurrencyCode_07_b\n";
1:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:         verifyDropRestrictions
1:             (
1:              conn,
1:              createTypeStatement,
1:              dropTypeStatement,
1:              createObjectStatement,
1:              dropObjectStatement,
1:              badDropSQLState
1:              );
1:         createTypeStatement = "create type price_07_c external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:         dropTypeStatement = "drop type price_07_c restrict\n";
1:         createObjectStatement = 
1:             "create procedure oneArgPriceProc_07( price1 price_07_c )\n" +
1:             "language java\n" +
1:             "parameter style java\n" +
1:             "no sql\n" +
1:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.oneArgPriceProc_07'\n";
1:         dropObjectStatement = "drop procedure oneArgPriceProc_07\n";
1:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:         verifyDropRestrictions
1:             (
1:              conn,
1:              createTypeStatement,
1:              dropTypeStatement,
1:              createObjectStatement,
1:              dropObjectStatement,
1:              badDropSQLState
1:              );
1:         createTypeStatement = "create type price_07_d external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:         dropTypeStatement = "drop type price_07_d restrict\n";
1:         createObjectStatement = 
1:             "create procedure twoArgPriceProc_07( price1 price_07_d, price2 price_07_d )\n" +
1:             "language java\n" +
1:             "parameter style java\n" +
1:             "no sql\n" +
1:             "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.twoArgPriceProc_07'\n";
1:         dropObjectStatement = "drop procedure twoArgPriceProc_07\n";
1:         badDropSQLState = ROUTINE_DEPENDS_ON_TYPE;
1:         verifyDropRestrictions
1:             (
1:              conn,
1:              createTypeStatement,
1:              dropTypeStatement,
1:              createObjectStatement,
1:              dropObjectStatement,
1:              badDropSQLState
1:              );
1:     /**
1:      * <p>
1:      * Dependencies of triggers on UDTs.
1:      * </p>
1:      */
1:     public void test_08_triggerDependencies() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create table t_08_a( a int )" );
1:         goodStatement( conn, "create table t_08_b( a int )" );
1: 
1:         String createTypeStatement;
1:         String dropTypeStatement;
1:         String createObjectStatement;
1:         String dropObjectStatement;
1:         String badDropSQLState;
1:         
1:         // trigger that mentions a udt
1:         createTypeStatement = "create type price_08_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n";
1:         dropTypeStatement = "drop type price_08_a restrict\n";
1:         createObjectStatement = 
1:             "create trigger trig_08_a after insert on t_08_a\n" +
1:             "  insert into t_08_b( a ) select ( a ) from t_08_a where ( cast( null as price_08_a ) ) is not null\n";
1:         dropObjectStatement = "drop trigger trig_08_a";
1:         badDropSQLState = TRIGGER_DEPENDS_ON_TYPE;
1:         verifyDropRestrictions
1:             (
1:              conn,
1:              createTypeStatement,
1:              dropTypeStatement,
1:              createObjectStatement,
1:              dropObjectStatement,
1:              badDropSQLState
1:              );
1: 
1:     }
1:     
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that a type can't be dropped if it is used by a schema object.
1:      */
1:     private void verifyDropRestrictions
1:         (
1:          Connection conn,
1:          String createTypeStatement,
1:          String dropTypeStatement,
1:          String createObjectStatement,
1:          String dropObjectStatement,
1:          String badDropSQLState
1:          )
1:         throws Exception
1:     {
1:         goodStatement( conn, createTypeStatement );
1:         goodStatement( conn, createObjectStatement );
1:         expectExecutionError( conn, badDropSQLState, dropTypeStatement );
1:         goodStatement( conn, dropObjectStatement );
1:         goodStatement( conn, dropTypeStatement );
1:     }
1: 
commit:98c7520
/////////////////////////////////////////////////////////////////////////
commit:2209325
/////////////////////////////////////////////////////////////////////////
0:     public static final String ROUTINE_DEPENDS_ON_TYPE = "X0Y30";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Dependencies of routines on UDTs.
1:      * </p>
1:      */
1:     public void test_07_routineDependencies() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // function that returns a udt
1:         goodStatement
1:             ( conn,
0:               "create type price_07_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
0:               "create function makePrice_07_a( )\n" +
0:               "returns price_07_a\n" +
0:               "language java\n" +
0:               "parameter style java\n" +
0:               "no sql\n" +
0:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n"
1:               );
0:         expectExecutionError( conn, ROUTINE_DEPENDS_ON_TYPE, "drop type price_07_a restrict\n" );
1:         goodStatement
1:             ( conn,
0:               "drop function makePrice_07_a\n" );
1:         goodStatement
1:             ( conn,
0:               "drop type price_07_a restrict\n" );
1: 
1:         // function with a udt arg
1:         goodStatement
1:             ( conn,
0:               "create type price_07_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
0:               "create function getCurrencyCode_07_b(  priceArg1 price_07_b  )\n" +
0:               "returns char( 3 )\n" +
0:               "language java\n" +
0:               "parameter style java\n" +
0:               "no sql\n" +
0:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getCurrencyCode'\n"
1:               );
0:         expectExecutionError( conn, ROUTINE_DEPENDS_ON_TYPE, "drop type price_07_b restrict\n" );
1:         goodStatement
1:             ( conn,
0:               "drop function getCurrencyCode_07_b\n" );
1:         goodStatement
1:             ( conn,
0:               "drop type price_07_b restrict\n" );
1: 
1:         // procedure with a udt arg
1:         goodStatement
1:             ( conn,
0:               "create type price_07_c external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
0:               "create procedure oneArgPriceProc_07( price1 price_07_c )\n" +
0:               "language java\n" +
0:               "parameter style java\n" +
0:               "no sql\n" +
0:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.oneArgPriceProc_07'\n"
1:               );
0:         expectExecutionError( conn, ROUTINE_DEPENDS_ON_TYPE, "drop type price_07_c restrict\n" );
1:         goodStatement
1:             ( conn,
0:               "drop procedure oneArgPriceProc_07\n" );
1:         goodStatement
1:             ( conn,
0:               "drop type price_07_c restrict\n" );
1: 
1:         // procedure with two udt args
1:         goodStatement
1:             ( conn,
0:               "create type price_07_d external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
0:               "create procedure twoArgPriceProc_07( price1 price_07_d, price2 price_07_d )\n" +
0:               "language java\n" +
0:               "parameter style java\n" +
0:               "no sql\n" +
0:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.UDTTest.twoArgPriceProc_07'\n"
1:               );
0:         expectExecutionError( conn, ROUTINE_DEPENDS_ON_TYPE, "drop type price_07_d restrict\n" );
1:         goodStatement
1:             ( conn,
0:               "drop procedure twoArgPriceProc_07\n" );
1:         goodStatement
1:             ( conn,
0:               "drop type price_07_d restrict\n" );
1: 
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
0:     // PROCEDURES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public static void oneArgPriceProc( Price price1 ) {}
1:     public static void twoArgPriceProc( Price price1, Price price2 ) {}
1: 
commit:816219f
/////////////////////////////////////////////////////////////////////////
1:              "select tabletype, cast (null as price_05_a), cast( null as price_05_a)\n" +
/////////////////////////////////////////////////////////////////////////
0:              "select tabletype from sys.systables where ( cast (null as price_05_b) ) is not null\n"
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Casting to UDTs.
1:      * </p>
1:      */
1:     public void test_06_casts() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // cast a NULL as a UDT
1:         goodStatement
1:             ( conn,
1:               "create type price_06_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         assertResults
1:             (
1:              conn,
1:              "values ( cast ( null as price_06_b ) )\n",
1:              new String[][]
1:              {
1:                  { null },
1:              },
1:              false
1:              );
1: 
1:         // casting an untyped parameter to a UDT
1:         PreparedStatement ps = chattyPrepare
1:             ( conn, "values ( cast ( ? as price_06_b ) )" );
1:         ps.setObject( 1, Price.makePrice() );
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1:         Price result = (Price) rs.getObject( 1 );
1:         rs.close();
1:         ps.close();
1:         assertTrue( Price.makePrice().equals( result ) );
1:     }
1: 
commit:d6c2047
/////////////////////////////////////////////////////////////////////////
1:     public static final String VIEW_DEPENDS_ON_TYPE = "X0Y23";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Dependencies of views on UDTs.
1:      * </p>
1:      */
1:     public void test_05_viewDependencies() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         // view with UDT in select list
1:         goodStatement
1:             ( conn,
0:               "create type price_05_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             (
1:              conn,
0:              "create function makePrice_05( )\n" +
0:              "returns price_05_a language java parameter style java no sql\n" +
0:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n"
1:               );
1:         goodStatement
1:             (
1:              conn,
1:              "create view udtView( a, b, c ) as\n" +
0:              "select tabletype, makePrice_05( ), makePrice_05( )\n" +
0:              "from sys.systables\n"
1:               );
0:         expectExecutionError( conn, VIEW_DEPENDS_ON_TYPE, "drop type price_05_a restrict\n" );
1:         goodStatement
1:             ( conn,
0:               "drop view udtView\n" );
1:         goodStatement
1:             ( conn,
0:               "drop type price_05_a restrict\n" );
1: 
0:         // view with UDT in where clause
1:         goodStatement
1:             ( conn,
0:               "create type price_05_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             (
1:              conn,
0:              "create function makePrice_05_b( )\n" +
0:              "returns price_05_b language java parameter style java no sql\n" +
0:              "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n"
1:               );
1:         goodStatement
1:             (
1:              conn,
1:              "create view udtView_b( a ) as\n" +
0:              "select tabletype from sys.systables where makePrice_05_b() is not null\n"
1:               );
0:         expectExecutionError( conn, VIEW_DEPENDS_ON_TYPE, "drop type price_05_b restrict\n" );
1:         goodStatement
1:             ( conn,
0:               "drop view udtView_b\n" );
1:         goodStatement
1:             ( conn,
0:               "drop type price_05_b restrict\n" );
1: 
1:     }
1: 
commit:b8c6110
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Dropping a whole table which has udt columns.
1:      * </p>
1:      */
1:     public void test_04_dropTable() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement
1:             ( conn,
1:               "create type price_orphan external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create type price_orphan2 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create type price_orphan3 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create type price_orphan4 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create table t_orphan( a price_orphan )\n" );
1:         goodStatement
1:             ( conn,
1:               "create table t_orphan2( a price_orphan2, b int, c price_orphan2 )\n" );
1:         goodStatement
1:             ( conn,
1:               "create table t_orphan3( a price_orphan3, b int, c price_orphan4 )\n" );
1:         
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type price_orphan restrict\n" );
1:         goodStatement
1:             ( conn,
1:               "drop table t_orphan\n" );
1:         goodStatement
1:             ( conn,
1:               "drop type price_orphan restrict\n" );
1:         
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type price_orphan2 restrict\n" );
1:         goodStatement
1:             ( conn,
1:               "drop table t_orphan2\n" );
1:         goodStatement
1:             ( conn,
1:               "drop type price_orphan2 restrict\n" );
1:         
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type price_orphan3 restrict\n" );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type price_orphan4 restrict\n" );
1:         goodStatement
1:             ( conn,
1:               "drop table t_orphan3\n" );
1:         goodStatement
1:             ( conn,
1:               "drop type price_orphan3 restrict\n" );
1:         goodStatement
1:             ( conn,
1:               "drop type price_orphan4 restrict\n" );
1:     }
1:     
commit:e126f58
/////////////////////////////////////////////////////////////////////////
0:     public static final String TABLE_DEPENDS_ON_TYPE = "X0Y29";
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Adding and dropping udt columns.
1:      * </p>
1:      */
1:     public void test_03_addDropColumn() throws Exception
1:     {
1:         Connection conn = getConnection();
1:         String tableName1 = "UDTCOLUMNS";
1:         String tableName2 = "UDTCOLUMNS2";
1: 
1:         goodStatement
1:             ( conn,
1:               "create type price_03 external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1: 
1:         // even though there are 2 price_03 columns, we only create 1 dependency
1:         goodStatement
1:             ( conn,
1:               "create table " + tableName1 + "\n" +
1:               "(\n" +
1:               "    a int, b int,\n" +
1:               "    price1 price_03,\n" +
1:               "    price2 price_03\n" +
1:               ")\n"
0:               );
1:         assertEquals( 1, countTableDependencies( conn, tableName1 ) );
1: 
1:         // verify that we can't drop the type while the table depends on it
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03 restrict\n" );
1: 
1:         // add another price_03 column. should not add another dependency
1:         goodStatement
1:             ( conn,
1:               "alter table udtColumns add column price3 price_03\n" );
1:         assertEquals( 1, countTableDependencies( conn, tableName1 ) );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03 restrict\n" );
1: 
1:         // drop one of the price_03 column. there should still be a dependency
1:         goodStatement
1:             ( conn,
1:               "alter table udtColumns drop column price3\n" );
1:         assertEquals( 1, countTableDependencies( conn, tableName1 ) );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03 restrict\n" );
1: 
1:         // drop another column. same story.
1:         goodStatement
1:             ( conn,
1:               "alter table udtColumns drop column price2\n" );
1:         assertEquals( 1, countTableDependencies( conn, tableName1 ) );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03 restrict\n" );
1: 
1:         // drop the last udt column. dependency should disappear
1:         goodStatement
1:             ( conn,
1:               "alter table udtColumns drop column price1\n" );
1:         assertEquals( 0, countTableDependencies( conn, tableName1 ) );
1:         goodStatement
1:             ( conn,
1:               "drop type Price_03 restrict\n" );
1: 
1:         // similar experiments with more types
1:         goodStatement
1:             ( conn,
1:               "create type price_03_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create type price_03_b external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement
1:             ( conn,
1:               "create type price_03_c external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1: 
1:         goodStatement
1:             ( conn,
1:               "create table udtColumns2\n" +
1:               "(\n" +
1:               "    a int, b int,\n" +
1:               "    price1 price_03_a,\n" +
1:               "    price2 price_03_b\n" +
1:               ")\n"
0:               );
1:         assertEquals( 2, countTableDependencies( conn, tableName2 ) );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_a restrict\n" );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_b restrict\n" );
1:         
1:         goodStatement
1:             ( conn,
1:               "alter table udtColumns2 add column price3 price_03_c\n" );
1:         assertEquals( 3, countTableDependencies( conn, tableName2 ) );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_a restrict\n" );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_b restrict\n" );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_c restrict\n" );
1: 
1:         goodStatement
1:             ( conn,
1:               "alter table udtColumns2 drop column b\n" );
1:         assertEquals( 3, countTableDependencies( conn, tableName2 ) );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_a restrict\n" );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_b restrict\n" );
1:         expectExecutionError( conn, TABLE_DEPENDS_ON_TYPE, "drop type Price_03_c restrict\n" );
1: 
1:         goodStatement
1:             ( conn,
1:               "alter table udtColumns2 drop column price3\n" );
1:         assertEquals( 2, countTableDependencies( conn, tableName2 ) );
1:         goodStatement
1:             ( conn,
1:               "drop type Price_03_c restrict\n" );
1: 
1:         goodStatement
1:             ( conn,
1:               "alter table udtColumns2 drop column price2\n" );
1:         assertEquals( 1, countTableDependencies( conn, tableName2 ) );
1:         goodStatement
1:             ( conn,
1:               "drop type Price_03_b restrict\n" );
1: 
1:         goodStatement
1:             ( conn,
1:               "alter table udtColumns2 drop column price1\n" );
1:         assertEquals( 0, countTableDependencies( conn, tableName2 ) );
1:         goodStatement
1:             ( conn,
1:               "drop type Price_03_a restrict\n" );
1: 
1:     }
1: 
1:     /** Get the number of dependencies that a table has */
1:     private int countTableDependencies( Connection conn, String tableName ) throws Exception
1:     {
1:         PreparedStatement ps = chattyPrepare
1:             ( conn, "select count(*) from sys.sysdepends d, sys.systables t where d.dependentid = t.tableid and t.tablename = ?" );
1:         ps.setString( 1, tableName );
1: 
1:         return getScalarInteger( ps );
1:     }
1: 
1:     /** Get a scalar integer result from a query */
1:     private int getScalarInteger( PreparedStatement ps ) throws Exception
1:     {
1:         ResultSet rs = ps.executeQuery();
1:         rs.next();
1:         int retval = rs.getInt( 1 );
1: 
1:         rs.close();
1:         ps.close();
1: 
1:         return retval;
1:     }
1: 
commit:94509ae
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // DECIMAL datatype used here and the JSR169 support for it is less complete.
1:         //
1:         if ( JDBC.vmSupportsJSR169() ) { return; }
commit:edea8ab
/////////////////////////////////////////////////////////////////////////
0:                  { "USD" ,         "9.99000" ,        "2009-10-16 14:24:43.0" },
/////////////////////////////////////////////////////////////////////////
1:                  { "Price( USD, 9.99000, 2009-10-16 14:24:43.0 )" },
/////////////////////////////////////////////////////////////////////////
1:               "( makePrice( 'EUR', cast( 1.23 as decimal( 31, 5 ) ), timestamp('2008-10-16 14:24:43') ) )\n" );
1:                  { "Price( EUR, 1.23000, 2008-10-16 14:24:43.0 )" },
commit:d039ced
/////////////////////////////////////////////////////////////////////////
0: import java.math.BigDecimal;
0: import java.sql.Timestamp;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Basic column, return value, and parameter support.
1:      * </p>
1:      */
1:     public void test_02_basicColumnRetvalParam() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create type Price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
1:         goodStatement( conn, "create table orders( orderID int generated always as identity, customerID int, totalPrice price )\n" );
0:         goodStatement
0:             ( conn,
1:               "create function makePrice( currencyCode char( 3 ), amount decimal( 31, 5 ), timeInstant Timestamp )\n" +
1:               "returns Price language java parameter style java no sql\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n");
0:         goodStatement
0:             ( conn,
1:               "create function getCurrencyCode( price Price ) returns char( 3 ) language java parameter style java no sql\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getCurrencyCode'\n" );
0:         goodStatement
0:             ( conn,
1:               "create function getAmount( price Price ) returns decimal( 31, 5 ) language java parameter style java no sql\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getAmount'\n" );
0:         goodStatement
0:             ( conn,
1:               "create function getTimeInstant( price Price ) returns timestamp language java parameter style java no sql\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getTimeInstant'\n" );
0:         goodStatement
0:             ( conn,
1:               "create procedure savePrice( in a Price ) language java parameter style java no sql\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.savePrice'\n" );
0:         goodStatement
0:             ( conn,
1:               "create function getSavedPrice() returns Price language java parameter style java no sql\n" +
1:               "external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.getSavedPrice'\n" );
0:         goodStatement
0:             ( conn,
1:               "insert into orders( customerID, totalPrice ) values\n" +
1:               "( 12345, makePrice( 'USD', cast( 9.99 as decimal( 31, 5 ) ), timestamp('2009-10-16 14:24:43') ) )\n" );
1: 
1:         assertResults
0:             (
0:              conn,
0:              "select getCurrencyCode( totalPrice ), getAmount( totalPrice ), getTimeInstant( totalPrice ) from orders",
1:              new String[][]
1:              {
0:                  { "USD" ,         "9.99000" ,        "1969-12-31 16:00:00.0" },
1:              },
1:              false
0:              );
1:         assertResults
0:             (
0:              conn,
1:              "select totalPrice from orders",
1:              new String[][]
1:              {
0:                  { "Price( USD, 9.99000, 1969-12-31 16:00:00.0 )" },
1:              },
1:              false
0:              );
1: 
0:         goodStatement
0:             ( conn,
1:               "call savePrice\n" +
0:               "( makePrice( 'EUR', cast( 1.23 as decimal( 31, 5 ) ), timestamp('1969-12-31 16:00:00') ) )\n" );
1:         assertResults
0:             (
0:              conn,
1:              "values( getSavedPrice() )",
1:              new String[][]
1:              {
0:                  { "Price( EUR, 1.23000, 1969-12-31 16:00:00.0 )" },
1:              },
1:              false
0:              );
1:     }
1: 
commit:fa292b9
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.lang.UDTTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:      http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: 
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: 
1: /**
1:  * <p>
1:  * Test user defined types. See DERBY-651.
1:  * </p>
1:  */
1: public class UDTTest  extends GeneratedColumnsHelper
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public static final String OBJECT_EXISTS = "X0Y68";
0:     public static final String NONEXISTENT_OBJECT = "42Y55";
0:     public static final String SYNTAX_ERROR = "42X01";
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Create a new instance.
1:      */
1: 
1:     public UDTTest(String name)
1:     {
1:         super(name);
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // JUnit BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 
1:     /**
1:      * Construct top level suite in this JUnit test
1:      */
1:     public static Test suite()
1:     {
0:         TestSuite suite = (TestSuite) TestConfiguration.embeddedSuite(UDTTest.class);
0:         Test        result = new CleanDatabaseTestSetup( suite );
1: 
0:         return result;
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // TESTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Basic syntax.
1:      * </p>
1:      */
1:     public void test_01_basicSyntax() throws Exception
1:     {
1:         Connection conn = getConnection();
1: 
1:         goodStatement( conn, "create schema adt_schema\n" );
1: 
1:         // create some types
1:         makeGoodTypes( conn );
1: 
1:         // duplicate type names should raise errors
1:         expectExecutionError( conn, OBJECT_EXISTS, "create type fooType external name 'mypackage.foo' language java\n" );
1:         expectExecutionError( conn, OBJECT_EXISTS, "create type adt_schema.fooType external name 'mypackage.foo' language java\n" );
1:         expectExecutionError( conn, OBJECT_EXISTS, "create type \"smallint\" external name 'mypackage.foo' language java\n" );
1:         expectExecutionError( conn, OBJECT_EXISTS, "create type \"SMALLINT\" external name 'mypackage.foo' language java\n" );
1: 
1:         // only RESTRICTed drops allowed now
1:         expectCompilationError( SYNTAX_ERROR, "drop type fooType\n" );
1: 
1:         // drop some types
1:         goodStatement( conn, "drop type fooType restrict\n" );
1:         goodStatement( conn, "drop type adt_schema.fooType restrict\n" );
1:         goodStatement( conn, "drop type \"smallint\" restrict\n" );
1:         goodStatement( conn, "drop type \"SMALLINT\" restrict\n" );
1: 
1:         // can't drop a non-existent type
1:         expectCompilationError( NONEXISTENT_OBJECT, "drop type fooType restrict\n" );
1:         expectCompilationError( NONEXISTENT_OBJECT, "drop type adt_schema.fooType restrict\n" );
1:         expectCompilationError( NONEXISTENT_OBJECT, "drop type \"smallint\" restrict\n" );
1:         expectCompilationError( NONEXISTENT_OBJECT, "drop type \"SMALLINT\" restrict\n" );
1: 
1:         // re-create the types
1:         makeGoodTypes( conn );
1:     }
1:     private void makeGoodTypes( Connection conn ) throws Exception
1:     {
1:         goodStatement( conn, "create type fooType external name 'mypackage.foo' language java\n" );
1:         goodStatement( conn, "create type adt_schema.fooType external name 'mypackage.foo' language java\n" );
1:         goodStatement( conn, "create type \"smallint\" external name 'mypackage.foo' language java\n" );
1:         goodStatement( conn, "create type \"SMALLINT\" external name 'mypackage.foo' language java\n" );
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: }
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:35c061a
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import java.sql.Statement;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Verify that you can cast a value to an UDT in a generation clause or
1:      * a CHECK constraint. Regression test case for DERBY-6421.
1:      */
1:     public void test_18_derby6421() throws SQLException {
1:         setAutoCommit(false);
0: 
1:         Statement s = createStatement();
1:         s.execute("create type d6421_type external name 'java.util.ArrayList' "
1:                 + "language java");
1:         s.execute("create table d6421_table "
1:                 + "(x generated always as (cast(null as d6421_type)), "
1:                 + "check (cast(null as d6421_type) is null))");
0: 
1:         // This insert used to cause assert failure (in sane builds) or
1:         // NullPointerException (in insane builds).
1:         s.execute("insert into d6421_table values default");
1:     }
0: 
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:     public static HashMap putValue(
1:             HashMap<String, String> map, String key, String value)
commit:7141fc7
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         return TestConfiguration.defaultSuite(UDTTest.class);
============================================================================