1:c2b437d: /*
1:c2b437d: 
1:c2b437d:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.XATransactionTest
1:cccf5dd: 
1:c2b437d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:c2b437d:    contributor license agreements.  See the NOTICE file distributed with
1:c2b437d:    this work for additional information regarding copyright ownership.
1:c2b437d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:c2b437d:    (the "License"); you may not use this file except in compliance with
1:c2b437d:    the License.  You may obtain a copy of the License at
1:c2b437d: 
1:c2b437d:       http://www.apache.org/licenses/LICENSE-2.0
1:c2b437d: 
1:c2b437d:    Unless required by applicable law or agreed to in writing, software
1:c2b437d:    distributed under the License is distributed on an "AS IS" BASIS,
1:c2b437d:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:c2b437d:    See the License for the specific language governing permissions and
1:c2b437d:    limitations under the License.
1:c2b437d: 
1:c2b437d:  */
1:c2b437d: 
1:c2b437d: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:c2b437d: 
1:c2b437d: import java.sql.Connection;
1:c2b437d: import java.sql.ResultSet;
1:cccf5dd: import java.sql.SQLException;
1:c2b437d: import java.sql.Statement;
1:c2b437d: import javax.sql.XAConnection;
1:c2b437d: import javax.sql.XADataSource;
1:cccf5dd: import javax.transaction.xa.XAException;
1:c2b437d: import javax.transaction.xa.XAResource;
1:c2b437d: import javax.transaction.xa.Xid;
1:c2b437d: import junit.framework.Test;
1:cccf5dd: import org.apache.derby.shared.common.reference.SQLState;
1:c2b437d: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.J2EEDataSource;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:c2b437d: import org.apache.derbyTesting.junit.TestConfiguration;
1:52acd5a: import org.apache.derbyTesting.junit.XATestUtil;
1:c2b437d: 
1:c2b437d: /** The test of the properties of the XA transaction interface implementation.
1:c2b437d:   */
1:c2b437d: public class XATransactionTest extends BaseJDBCTestCase {
1:c2b437d: 
1:ad40eda: 	/**
1:ad40eda: 	  * This test does following 
1:ad40eda: 	  * 1)Start the network server
1:ad40eda: 	  * 2)Start a local xa transaction
1:ad40eda: 	  * 3)Do not commit the local XA transaction
1:ad40eda: 	  * 4)Shutdown the network server
1:ad40eda: 	  * 5)Start the server again
1:ad40eda: 	  * 
1:ad40eda: 	  * Before the fix for DERBY-4053 went in, step 4) would not shutdown the
1:ad40eda: 	  * server properly because of the pending local XA transaction. During the
1:ad40eda: 	  * server shutdown, we try to close all the open connections but the close 
1:ad40eda: 	  * on the XA connection results into an exception because there is still a
1:ad40eda: 	  * pending transaction. That exception is not handled by the server and
1:ad40eda: 	  * because of that, all the code necessary to shutdown the server is not
1:ad40eda: 	  * executed. The next time around, step 5), when we try to bring up the
1:ad40eda: 	  * server again, it ends up hanging
1:ad40eda: 	  * 2009-07-09 21:21:28.828 GMT : Invalid reply from network server: Insufficient data.
1:ad40eda: 	  * 2009-07-09 21:21:28.843 GMT : Could not listen on port 1527 on host 127.0.0.1: java.net.BindException: Address already in use: JVM_Bind
1:ad40eda: 	  * 
1:ad40eda: 	  * The fix for DERBY-4053 makes sure that before calling close on local XA
1:ad40eda: 	  * transaction, we first rollback any transaction active on the 
1:ad40eda: 	  * connection. 
1:ad40eda: 	 */
1:ad40eda: 	public void testPendingLocalTranAndServerShutdown() throws Exception {
1:ad40eda:         if (usingEmbedded())
1:ad40eda:             return;
1:ad40eda:         //1)Server must be up already through the Derby junit framework
1:ad40eda:         //2)Start a local xa transaction
1:ad40eda:         XADataSource xaDataSource = J2EEDataSource.getXADataSource();
1:ad40eda:         XAConnection xaconn = xaDataSource.getXAConnection();
1:ad40eda:         XAResource xar = xaconn.getXAResource();
1:ad40eda:         Connection conn = xaconn.getConnection();
1:ad40eda:         Statement s = conn.createStatement();
1:ad40eda:         s.executeUpdate("create table tab(i int)");
1:ad40eda:         s.executeUpdate("insert into tab values (1),(2),(3),(4)");
1:ad40eda:         conn.commit();
1:ad40eda:         conn.setAutoCommit(false);
1:ad40eda:         ResultSet rs = s.executeQuery("select * from tab");
1:ad40eda:         rs.next();
1:ad40eda:         //3)Do not commit this pending local XA transaction
1:c2b437d:     	
1:ad40eda:         //4)Shutdown the network server
1:ad40eda:         //bring the server down while the local xa transaction is still active
1:ad40eda:         TestConfiguration.getCurrent().stopNetworkServer();
1:c2b437d:         
1:ad40eda:         //5)Start the server again
1:ad40eda:         TestConfiguration.getCurrent().startNetworkServer();
1:ad40eda: 	}
1:cccf5dd: 	
1:bb9f97a:     /** Tests whether it is possible to reconstruct the original Xid value
1:bb9f97a:       * correctly from SYSCS_DIAG.TRANSACTION_TABLE. */
1:c2b437d:     public void testGlobalXIDinTransactionTable() throws Exception {
1:c2b437d:         Statement stm = getConnection().createStatement();
1:c2b437d:         stm.execute("create table XATT2 (i int, text char(10))");
1:c2b437d: 
1:c2b437d:         XADataSource xaDataSource = J2EEDataSource.getXADataSource();
1:c2b437d:         XAConnection xaConn = xaDataSource.getXAConnection();
1:c2b437d:         XAResource xaRes = xaConn.getXAResource();
1:c2b437d:         Connection conn = xaConn.getConnection();
1:c2b437d: 
1:c2b437d:         // create large enough xid
1:c2b437d:         byte[] gid = new byte[64];
1:c2b437d:         byte[] bid = new byte[64];
1:c2b437d:         for (int i=0; i < 64; i++) {
1:c2b437d:             gid[i] = (byte) i;
1:c2b437d:             bid[i] = (byte) (64 - i);
1:c2b437d:         }
1:8f0d45d:         Xid xid = XATestUtil.getXid(0x1234, gid, bid);
1:c2b437d: 
1:c2b437d:         // get the stuff required to execute the global transaction
2:cccf5dd:         xaConn = xaDataSource.getXAConnection();
2:cccf5dd:         xaRes = xaConn.getXAResource();
2:cccf5dd:         conn = xaConn.getConnection();
1:c2b437d: 
1:c2b437d:         // start the transaction with that xid
1:c2b437d:         xaRes.start(xid, XAResource.TMNOFLAGS);
1:c2b437d: 
1:c2b437d:         // do some work
1:c2b437d:         stm = conn.createStatement();
1:c2b437d:         stm.execute("insert into XATT2 values (1234, 'Test_Entry')");
1:c2b437d:         stm.close();
1:c2b437d: 
1:c2b437d:         // end the wotk on the transaction branch
1:c2b437d:         xaRes.end(xid, XAResource.TMSUCCESS);
1:c2b437d: 
1:c2b437d:         ResultSet rs = null;
1:c2b437d:         stm = null;
1:c2b437d: 
1:c2b437d:         try {
1:bb9f97a:             // check the output of the global xid in 
1:bb9f97a:             // syscs_diag.transaction_table
1:c2b437d:             stm = getConnection().createStatement();
1:c2b437d: 
1:c2b437d:             String query = "select global_xid from syscs_diag.transaction_table"
1:c2b437d:                          + " where global_xid is not null";
1:c2b437d: 
1:c2b437d:             // execute the query to obtain the xid of the global transaction
1:c2b437d:             rs = stm.executeQuery(query);
1:c2b437d: 
1:c2b437d:             // there should be at least one globaltransaction in progress
1:bb9f97a:             assertTrue(rs.next());
1:c2b437d: 
1:c2b437d:             // check whether the xid obtained matches the original xid
1:c2b437d:             Xid rXid = parseXid(rs.getString(1));
1:bb9f97a:             assertEquals(xid, rXid);
1:c2b437d: 
1:c2b437d:             // there should be at most one global transaction in progress
1:bb9f97a:             assertFalse(rs.next());
1:c2b437d: 
1:c2b437d:         } catch (Exception ex) {
1:c2b437d:             try {
1:c2b437d:                 // close all the stuff
1:c2b437d:                 if (rs != null)
1:c2b437d:                     rs.close();
1:c2b437d:                 if (stm != null)
1:c2b437d:                     stm.close();
1:c2b437d: 
1:c2b437d:                 // rollback the global transaction
1:c2b437d:                 xaRes.rollback(xid);
1:c2b437d:                 // close the connection
1:cccf5dd:                 xaConn.close();
1:c2b437d:             } catch (Exception e) {
1:c2b437d:                 // ignore the exception because it
1:c2b437d:                 // would hide the original exception
1:c2b437d:             }
1:c2b437d:             // throw the stuff further
1:c2b437d:             throw ex;
1:c2b437d:         }
1:c2b437d: 
1:c2b437d:         // close all the stuff
1:c2b437d:         rs.close();
1:c2b437d:         stm.close();
1:c2b437d: 
1:c2b437d:         // rollback the global transaction
1:c2b437d:         xaRes.rollback(xid);
1:c2b437d: 
1:c2b437d:         // close the connection
1:cccf5dd:         xaConn.close();
1:c2b437d:     }
1:c2b437d: 
1:c2b437d: 
1:cccf5dd:     /** Tests the functionality of the XA transaction timeout.
1:152986e:       * <p>
1:bb9f97a:       * It executes 66 global transactions during the test. Everyone
1:cccf5dd:       * of them just inserts a row into XATT table. The rows inserted
1:cccf5dd:       * by the transactions are different. Some of these transactions
1:cccf5dd:       * are committed and some of them are left in different stages.
1:cccf5dd:       * The stage of the transaction in which it is left is chosed
1:cccf5dd:       * depending on division remainders.
1:cccf5dd:       * </p>
1:cccf5dd:       * <p>
1:cccf5dd:       * After finishing these 1000 transactions a select statement is executed
1:cccf5dd:       * on that table. However, if there are still some unfinished transactions
1:cccf5dd:       * that were not aborted they will hold a lock on a XATT table until they
1:cccf5dd:       * will get rolled back by the transaction timeout. The number of rows
1:cccf5dd:       * in the XATT table is calculated. It is then compared with the excepted
1:cccf5dd:       * number of rows (the transaction we know we have committed).
1:cccf5dd:       * </p>
1:cccf5dd:       * <p>
1:cccf5dd:       * The call to xaRes.setTransactionTimeout(5) before the call
1:cccf5dd:       * to xaRes.start() makes the transactions to be rolled back
1:cccf5dd:       * due to timeout.
1:cccf5dd:       * </p>
1:cccf5dd:       */
1:cccf5dd:     public void testXATransactionTimeout() throws Exception {
1:cccf5dd: 
1:cccf5dd:         /* The number of statements to execute in timeout related test. */
1:bb9f97a:         int timeoutStatementsToExecute = 66;
1:cccf5dd: 
1:cccf5dd:         /* Specifies the number of total executed statements per one
1:bb9f97a:            commited statement in timeout related test. */
1:cccf5dd:         int timeoutCommitEveryStatement = 3;
1:cccf5dd: 
1:cccf5dd:         /* Specifies the number of statements that should be commited
1:bb9f97a:            during a timeout related test. */
1:cccf5dd:         int timeoutStatementsCommitted
1:cccf5dd:             = (timeoutStatementsToExecute + timeoutCommitEveryStatement - 1)
1:cccf5dd:                 / timeoutCommitEveryStatement;
1:cccf5dd: 
1:cccf5dd:         Statement stm = getConnection().createStatement();
1:cccf5dd:         stm.execute("create table XATT (i int, text char(10))");
1:cccf5dd: 
1:cccf5dd:         XADataSource xaDataSource = J2EEDataSource.getXADataSource();
1:bb9f97a:         XAConnection[] xaConn = new XAConnection[timeoutStatementsToExecute];
1:cccf5dd:         XAResource xaRes = null;
1:cccf5dd:         Connection conn = null;
1:cccf5dd: 
1:cccf5dd:         for (int i=0; i < timeoutStatementsToExecute; i++) {
1:bb9f97a:             xaConn[i] = xaDataSource.getXAConnection();
1:bb9f97a:             xaRes = xaConn[i].getXAResource();
1:bb9f97a:             conn = xaConn[i].getConnection();
1:cccf5dd: 
1:cccf5dd:             Xid xid = createXid(123, i);
1:d4cbc63:             xaRes.setTransactionTimeout(8);
1:cccf5dd:             xaRes.start(xid, XAResource.TMNOFLAGS);
1:cccf5dd: 
1:cccf5dd:             stm = conn.createStatement();
1:cccf5dd:             stm.execute("insert into XATT values (" + i + ", 'Test_Entry')");
1:cccf5dd: 
1:cccf5dd:             if (i % timeoutCommitEveryStatement == 0) {
1:cccf5dd:                 stm.close();
1:cccf5dd:                 xaRes.end(xid, XAResource.TMSUCCESS);
1:cccf5dd:                 xaRes.prepare(xid);
1:cccf5dd:                 xaRes.commit(xid, false);
1:cccf5dd:             } else if (i % 11 != 0) {
1:bb9f97a:                 // check the tiemout for transactions disassociated
1:cccf5dd:                 // with failure.
1:cccf5dd:                 try {
1:cccf5dd:                     xaRes.end(xid, XAResource.TMFAIL);
1:bb9f97a:                     fail();
1:cccf5dd:                 } catch (XAException ex) {
1:cccf5dd:                     if (ex.errorCode < XAException.XA_RBBASE
1:cccf5dd:                         || ex.errorCode > XAException.XA_RBEND)
1:cccf5dd:                     {
1:cccf5dd:                         throw ex;
1:cccf5dd:                     }
1:cccf5dd:                 }
1:cccf5dd:                 stm.close();
1:cccf5dd:             } else if (i % 2 == 0) {
1:bb9f97a:                 // check the timeout for transactions disassociated
1:cccf5dd:                 // with success.
1:cccf5dd:                 xaRes.end(xid, XAResource.TMSUCCESS);
1:cccf5dd:                 stm.close();
1:cccf5dd:             } 
1:cccf5dd:         }
1:cccf5dd: 
1:bb9f97a:         ResultSet rs = null;
1:cccf5dd: 
1:cccf5dd:         stm = getConnection().createStatement();
1:bb9f97a:         rs = stm.executeQuery("select count(*) from XATT");
1:cccf5dd:         rs.next();
1:c2b437d: 
1:cccf5dd:         // Check whether the correct number of transactions
1:cccf5dd:         // was rolled back
1:bb9f97a:         assertTrue(rs.getInt(1) == timeoutStatementsCommitted);
1:cccf5dd: 
1:bb9f97a:         // test the timeout during the statement run
1:bb9f97a:         XAConnection xaConn2 = xaDataSource.getXAConnection();
1:bb9f97a:         xaRes = xaConn2.getXAResource();
1:bb9f97a:         conn = xaConn2.getConnection();
1:cccf5dd: 
1:cccf5dd:         Xid xid = createXid(124, 100);
1:cccf5dd:         xaRes.setTransactionTimeout(10);
1:cccf5dd:         xaRes.start(xid, XAResource.TMNOFLAGS);
1:cccf5dd: 
1:cccf5dd:         stm = conn.createStatement();
1:cccf5dd: 
1:cccf5dd:         // Check whether the statement was correctly timed out
1:cccf5dd:         // and the appropriate exception was thrown
1:cccf5dd:         try {
1:bb9f97a:             // Run this kind of statement just to be sure
1:bb9f97a:             // it will not finish before it will time out
1:cccf5dd:             rs = stm.executeQuery(
1:bb9f97a:                  "select count(*) from sys.syscolumns a, sys.syscolumns b, "
1:bb9f97a:                + "sys.syscolumns c, sys.syscolumns d, sys.syscolumns e "
1:bb9f97a:                + "group by a.referenceid, b.referenceid, c.referenceid, "
1:bb9f97a:                + "d.referenceid");
1:bb9f97a:             fail("An exception is expected here");
1:cccf5dd:         } catch (SQLException ex) {
1:cccf5dd:             // Check the sql state of the thrown exception
1:cccf5dd:             assertSQLState(
1:cccf5dd:                 SQLState.LANG_STATEMENT_CANCELLED_OR_TIMED_OUT.substring(0,5),
1:bb9f97a:                 ex);
1:cccf5dd:         }
1:cccf5dd: 
1:bb9f97a:         // perform a select on the table just to be sure that all
1:bb9f97a:         // the transactions were rolled back.
1:cccf5dd:         stm = getConnection().createStatement();
1:cccf5dd:         rs = stm.executeQuery("select count(*) from XATT");
1:cccf5dd:         rs.next();
1:cccf5dd: 
1:bb9f97a:         // Go throught the XA Connections just to be sure that no code
1:bb9f97a:         // optimization would garbage collect them before (and thus
1:bb9f97a:         // the transactions might get rolled back by a different
1:bb9f97a:         // code).
1:bb9f97a:         for (int i=0; i < timeoutStatementsToExecute; i++) {
1:bb9f97a:             assertNotNull(xaConn[i]);
1:bb9f97a:             xaConn[i].close();
1:d4cbc63:         }
1:c2b437d: 
1:cccf5dd:         // Again, check whether the correct number of transactions
1:cccf5dd:         // was rolled back
1:bb9f97a:         assertTrue(rs.getInt(1) == timeoutStatementsCommitted);
1:cccf5dd:     }
1:cccf5dd: 
1:152986e:     /**
1:52acd5a:      * DERBY-4232: Test that an XA transaction can be suspended and resumed
1:52acd5a:      * when a timeout is in effect.
1:52acd5a:      */
1:52acd5a:     public void testTransactionTimeoutAndSuspendResume() throws Exception {
1:52acd5a:         XADataSource xads = J2EEDataSource.getXADataSource();
1:52acd5a:         XAConnection xac = xads.getXAConnection();
1:52acd5a:         XAResource xar = xac.getXAResource();
1:52acd5a:         Xid xid = XATestUtil.getXid(1, 2, 3);
1:52acd5a: 
1:52acd5a:         // Start work in a new transaction with a timeout
1:52acd5a:         xar.setTransactionTimeout(500);
1:52acd5a:         xar.start(xid, XAResource.TMNOFLAGS);
1:52acd5a: 
1:52acd5a:         // Suspend the transaction
1:52acd5a:         xar.end(xid, XAResource.TMSUSPEND);
1:52acd5a: 
1:52acd5a:         // Resume the transaction (used to fail with a XAER_PROTO on the
1:52acd5a:         // network client)
1:52acd5a:         xar.start(xid, XAResource.TMRESUME);
1:52acd5a: 
1:52acd5a:         // End the transaction and free up the resources
1:52acd5a:         xar.end(xid, XAResource.TMSUCCESS);
1:52acd5a:         xar.rollback(xid);
1:52acd5a:         xac.close();
1:52acd5a:     }
1:52acd5a: 
1:52acd5a:     /**
1:52acd5a:      * DERBY-4232: Test that two branches can be joined after the timeout has
1:52acd5a:      * been set.
1:52acd5a:      */
1:52acd5a:     public void testTransactionTimeoutAndJoin() throws Exception {
1:52acd5a:         XADataSource xads = J2EEDataSource.getXADataSource();
1:52acd5a:         XAConnection xac1 = xads.getXAConnection();
1:52acd5a:         XAResource xar1 = xac1.getXAResource();
1:52acd5a:         Xid xid1 = XATestUtil.getXid(4, 5, 6);
1:52acd5a: 
1:52acd5a:         // Start/end work in a new transaction
1:52acd5a:         xar1.setTransactionTimeout(500);
1:52acd5a:         xar1.start(xid1, XAResource.TMNOFLAGS);
1:52acd5a:         xar1.end(xid1, XAResource.TMSUCCESS);
1:52acd5a: 
1:52acd5a:         // Create a new branch that can be joined with the existing one
1:52acd5a:         XAConnection xac2 = xads.getXAConnection();
1:52acd5a:         XAResource xar2 = xac2.getXAResource();
1:52acd5a:         xar2.setTransactionTimeout(500);
1:52acd5a: 
1:52acd5a:         // Do some work on the new branch before joining (the bug won't be
1:52acd5a:         // reproduced if we join with a fresh branch)
1:52acd5a:         Xid xid2 = XATestUtil.getXid(4, 5, 7);
1:52acd5a:         xar2.start(xid2, XAResource.TMNOFLAGS);
1:52acd5a:         xar2.end(xid2, XAResource.TMSUCCESS);
1:52acd5a:         xar2.rollback(xid2);
1:52acd5a: 
1:52acd5a:         assertTrue(
1:52acd5a:                 "Branches can only be joined if RM is same",
1:52acd5a:                 xar1.isSameRM(xar2));
1:52acd5a: 
1:52acd5a:         // Join the branches. This used to fail with XAER_PROTO on the
1:52acd5a:         // network client.
1:52acd5a:         xar2.start(xid1, XAResource.TMJOIN);
1:52acd5a: 
1:52acd5a:         // End the transaction and free up the resources
1:52acd5a:         xar2.end(xid1, XAResource.TMSUCCESS);
1:52acd5a:         xar2.rollback(xid1);
1:52acd5a:         xac1.close();
1:52acd5a:         xac2.close();
1:52acd5a:     }
1:52acd5a: 
1:52acd5a:     /**
1:31ba8d0:      * DERBY-4141 XAExceptions caused by SQLExceptions should have a
1:31ba8d0:      * non-zero errorCode. SESSION_SEVERITY or greater map to
1:31ba8d0:      * XAException.XAER_RMFAIL. Lesser exceptions map to XAException.XAER_RMERR 
1:31ba8d0:      * @throws Exception
1:31ba8d0:      */
1:31ba8d0:     public void testXAExceptionErrorCodeOnSQLExceptionDerby4141() throws Exception {
1:31ba8d0:         XADataSource xaDataSource = J2EEDataSource.getXADataSource();
1:31ba8d0:         XAConnection xaConn = xaDataSource.getXAConnection();
1:31ba8d0:         XAResource xaRes = xaConn.getXAResource();        
1:31ba8d0:         Xid xid = createXid(123, 1);
1:31ba8d0:         // close the XAConnection so we get an SQLException on
1:31ba8d0:         // start();
1:cccf5dd:         xaConn.close();
1:31ba8d0:         try {
1:31ba8d0:             xaRes.start(xid, XAResource.TMNOFLAGS);
1:31ba8d0:             fail("Should have gotten an XAException. xaConn is closed.");
1:31ba8d0:         } catch (XAException xae) {
1:31ba8d0:             assertEquals(XAException.XAER_RMFAIL, xae.errorCode);
1:31ba8d0:         }
1:31ba8d0:     }
1:cccf5dd: 
1:418e135:     /**
1:418e135:      * This fixture triggers DERBY-1016. It creates an XA transaction, executes
1:418e135:      * an update over it and then prepares the transaction. Trying to forget
1:418e135:      * after preparing should throw XAER_PROTO and not XAER_NOTA.
1:418e135:      */
1:418e135:     public void testForgetExceptionDerby1016PROTO() throws XAException, SQLException {      
1:418e135:         XADataSource xads = J2EEDataSource.getXADataSource();
1:418e135:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:418e135:         
1:418e135:         XAConnection xaconn = xads.getXAConnection();
1:418e135:         XAResource xar = xaconn.getXAResource();
1:418e135:         Xid xid = createXid(93,18);
1:418e135:         xar.start(xid, XAResource.TMNOFLAGS);
1:418e135:         Connection conn = xaconn.getConnection();
1:418e135:         Statement s = conn.createStatement();
1:418e135:         s.executeUpdate("CREATE TABLE Derby1016 (I INT)");
1:418e135:         xar.end(xid, XAResource.TMSUCCESS);
1:418e135:         xar.prepare(xid);
1:418e135:         try {
1:418e135:             xar.forget(xid);
1:418e135:             fail("FAIL: prepared XA-Transaction forgotten");
1:418e135:         } catch (XAException XAeForget) {
1:418e135:             assertEquals("FAIL: Got unexpected exception "
1:418e135:                           + XAeForget.getMessage()   + " errorCode: " 
1:418e135:                           + XAeForget.errorCode  + "  calling forget on a prepared transaction",
1:418e135:                         XAException.XAER_PROTO, XAeForget.errorCode);
1:418e135:         } finally {
1:418e135:             s.close();
1:418e135:             xar.rollback(xid);
1:418e135:             conn.close(); 
1:418e135:             xaconn.close();
1:418e135:         }
1:418e135:     }
1:418e135:  
1:418e135:     /**
1:418e135:      * Further test case prompted by DERBY-1016. Tests that XAER_NOTA is thrown
1:418e135:      * if no transaction exists.
1:418e135:      */
1:418e135:     public void testForgetExceptionDerby1016NOTA() throws XAException, SQLException {      
1:418e135:         XADataSource xads = J2EEDataSource.getXADataSource();
1:418e135:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:418e135:         
1:418e135:         XAConnection xaconn = xads.getXAConnection();
1:418e135:         XAResource xar = xaconn.getXAResource();
1:418e135:         Xid xid = createXid(93,18);
1:418e135:         xar.start(xid, XAResource.TMNOFLAGS);
1:418e135:         Connection conn = xaconn.getConnection();
1:418e135:         Statement s = conn.createStatement();
1:418e135:         s.executeUpdate("CREATE TABLE Derby1016 (I INT)");
1:418e135:         xar.end(xid, XAResource.TMSUCCESS);
1:418e135:         xar.prepare(xid);
1:418e135:         xar.commit(xid, false);
1:418e135:         try {
1:418e135:             // since the transaction was committed, it should no longer exist
1:418e135:             // thus, forget should now throw an XAER_NOTA
1:418e135:             xar.forget(xid);
1:418e135:             fail("FAIL: able to forget committed XA-Transaction");
1:418e135:         } catch (XAException XAeForget) {
1:418e135:             assertEquals("FAIL: Got unexpected exception "
1:418e135:                           + XAeForget.getMessage()   + " errorCode: " 
1:418e135:                           + XAeForget.errorCode  + "  calling forget on a committed transaction",
1:418e135:                         XAException.XAER_NOTA, XAeForget.errorCode);
1:418e135:         } finally {
1:e7c4044:             s.executeUpdate("DROP TABLE Derby1016");
1:e7c4044:             conn.commit();
1:418e135:             s.close();
1:418e135:             conn.close(); 
1:418e135:             xaconn.close();
1:418e135:         }
1:418e135:     }
1:418e135: 
1:31ba8d0:     /**
1:cccf5dd:      * <p>
1:152986e:      * Regression test case for DERBY-5562.
1:152986e:      * </p>
1:152986e:      *
1:152986e:      * <p>
1:152986e:      * The timer that aborts long-running transactions if a transaction timeout
1:152986e:      * has been specified, was not cancelled when preparing a read-only
1:152986e:      * transaction. Since read-only transactions are implicitly committed when
1:152986e:      * they are prepared, this meant that the timer would try to abort an
1:152986e:      * already completed transaction. In addition to printing a confusing
1:152986e:      * message in derby.log about the transaction being rolled back, when it
1:152986e:      * actually had been committed, this could also make the timer roll back
1:152986e:      * the wrong transaction, if a new transaction with the same Xid was
1:152986e:      * started later.
1:152986e:      * </p>
1:152986e:      *
1:152986e:      * <p>
1:152986e:      * This test case exposes the bug by running a read-only transaction with
1:152986e:      * a timeout and preparing it, and then starting a new transaction with the
1:152986e:      * same Xid and no timeout. The bug would cause the second transaction to
1:152986e:      * time out.
1:152986e:      * </p>
1:152986e:      */
1:152986e:     public void testDerby5562ReadOnlyTimeout()
1:152986e:             throws InterruptedException, SQLException, XAException {
1:152986e:         XADataSource xads = J2EEDataSource.getXADataSource();
1:152986e:         XAConnection xac = xads.getXAConnection();
1:152986e:         XAResource xar = xac.getXAResource();
1:152986e: 
1:152986e:         Xid xid = createXid(55, 62);
1:152986e: 
1:152986e:         // Set a transaction timeout. This should be relatively short so that
1:152986e:         // the test case doesn't need to wait very long to trigger the timeout.
1:152986e:         // However, it needs to be long enough to let the first transaction go
1:152986e:         // through without hitting the timeout. Hopefully, four seconds is
1:152986e:         // enough. If the test case starts failing intermittently during the
1:152986e:         // first transaction, we might have to raise the timeout (and raise the
1:152986e:         // sleep time in the second transaction correspondingly).
1:152986e:         assertTrue(xar.setTransactionTimeout(4));
1:152986e: 
1:152986e:         // Start first transaction.
1:152986e:         xar.start(xid, XAResource.TMNOFLAGS);
1:152986e:         Connection c = xac.getConnection();
1:152986e:         Statement s = c.createStatement();
1:152986e:         JDBC.assertSingleValueResultSet(
1:152986e:                 s.executeQuery("select * from sysibm.sysdummy1"),
1:152986e:                 "Y");
1:152986e:         s.close();
1:152986e:         c.close();
1:152986e:         xar.end(xid, XAResource.TMSUCCESS);
1:152986e: 
1:152986e:         // Prepare the first transaction. Since it's a read-only transaction,
1:152986e:         // it'll be automatically committed, so there's no need to call commit.
1:152986e:         assertEquals("XA_RDONLY", XAResource.XA_RDONLY, xar.prepare(xid));
1:152986e: 
1:152986e:         // Reset the timeout for the second transaction.
1:152986e:         assertTrue(xar.setTransactionTimeout(0));
1:152986e: 
1:152986e:         // Start second transaction.
1:152986e:         xar.start(xid, XAResource.TMNOFLAGS);
1:152986e:         c = xac.getConnection();
1:152986e:         s = c.createStatement();
1:152986e:         JDBC.assertSingleValueResultSet(
1:152986e:                 s.executeQuery("select * from sysibm.sysdummy1"),
1:152986e:                 "Y");
1:152986e:         s.close();
1:152986e:         c.close();
1:152986e: 
1:152986e:         // Keep the transaction running so long that it must have exceeded the
1:152986e:         // timeout for the previous transaction.
1:152986e:         Thread.sleep(5000);
1:152986e: 
1:152986e:         // End the transaction. Since there's no timeout on this transaction,
1:152986e:         // it should work. Before DERBY-5562 was fixed, it would fail because
1:152986e:         // it had been rolled back by the timer from the previous transaction.
1:152986e:         xar.end(xid, XAResource.TMSUCCESS);
1:152986e:         assertEquals("XA_RDONLY", XAResource.XA_RDONLY, xar.prepare(xid));
1:152986e: 
1:152986e:         xac.close();
1:152986e:     }
1:152986e: 
1:c2b437d:     /* ------------------- end helper methods  -------------------------- */
1:c2b437d: 
1:cccf5dd:     /** Create the Xid object for global transaction identification
1:cccf5dd:       * with the specified identification values.
1:cccf5dd:       * @param gtrid Global Transaction ID
1:cccf5dd:       * @param bqual Branch Qualifier
1:cccf5dd:       */
1:cccf5dd:     static Xid createXid(int gtrid, int bqual) throws XAException {
1:cccf5dd:         byte[] gid = new byte[2]; gid[0]= (byte) (gtrid % 256); gid[1]= (byte) (gtrid / 256);
1:cccf5dd:         byte[] bid = new byte[2]; bid[0]= (byte) (bqual % 256); bid[1]= (byte) (bqual / 256);
1:8f0d45d:         return XATestUtil.getXid(0x1234, gid, bid);
1:cccf5dd:     }
1:cccf5dd: 
1:c2b437d:     /** Parses the xid value from the string. The format of the input string is
1:c2b437d:       * the same as the global_xid column in syscs_diag.transaction_table table -
1:c2b437d:       * '(formatid_in_dec,global_transaction_id_in_hex,branch_qualifier_in_hex)'
1:c2b437d:       * @param str Global Transaction ID converted to a string.
1:c2b437d:       * @return The xid object corresponding to the xid specified in a string.
1:c2b437d:       */
1:c2b437d:     private static Xid parseXid(String str) {
1:bb9f97a:         assertNotNull(str);
1:bb9f97a:         assertTrue(str.matches("\\(\\p{Digit}+,\\p{XDigit}+,\\p{XDigit}+\\)"));
1:c2b437d: 
1:c2b437d:         String formatIdS = str.substring(1, str.indexOf(','));
1:c2b437d:         String gtidS = str.substring(str.indexOf(',')+1, str.lastIndexOf(','));
1:c2b437d:         String bqualS = str.substring(str.lastIndexOf(',')+1, str.length()-1);
1:c2b437d: 
1:bb9f97a:         assertTrue(gtidS.length() % 2 == 0);
1:bb9f97a:         assertTrue(bqualS.length() % 2 == 0);
1:c2b437d: 
1:c2b437d:         int fmtid = Integer.parseInt(formatIdS);
1:c2b437d:         byte[] gtid = new byte[gtidS.length()/2];
1:c2b437d:         byte[] bqual = new byte[bqualS.length()/2];
1:c2b437d: 
1:c2b437d:         for (int i=0; i < gtid.length; i++) {
1:c2b437d:             gtid[i] = (byte) Integer.parseInt(gtidS.substring(2*i, 2*i + 2), 16);
1:c2b437d:         }
1:c2b437d: 
1:c2b437d:         for (int i=0; i < bqual.length; i++) {
1:c2b437d:             bqual[i] = (byte) Integer.parseInt(bqualS.substring(2*i, 2*i + 2), 16);
1:c2b437d:         }
1:c2b437d: 
1:8f0d45d:         return XATestUtil.getXid(fmtid, gtid, bqual);
1:c2b437d:     }
1:c2b437d: 
1:c2b437d:     public XATransactionTest(String name) {
1:c2b437d:         super(name);
1:c2b437d:     }
1:c2b437d: 
1:c2b437d:     public static Test suite() {
1:60426a1:         // the test requires XADataSource to run
1:60426a1:         if (JDBC.vmSupportsJDBC3()) {
1:bb9f97a:             Test test = TestConfiguration.defaultSuite(XATransactionTest.class);
1:bb9f97a:             // Set the lock timeout back to the default, because when
1:bb9f97a:             // running in a bigger suite the value may have been
1:bb9f97a:             // altered by an earlier test
1:bb9f97a:             test = DatabasePropertyTestSetup.setLockTimeouts(test, 20, 60);
1:bb9f97a:             return test;
1:60426a1:         }
1:c2b437d: 
1:1ae02c9:         return new BaseTestSuite(
1:1ae02c9:             "XATransactionTest cannot run without XA support");
1:c2b437d:     }
1:c2b437d: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         return new BaseTestSuite(
1:             "XATransactionTest cannot run without XA support");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:8f0d45d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Xid xid = XATestUtil.getXid(0x1234, gid, bid);
/////////////////////////////////////////////////////////////////////////
1:         return XATestUtil.getXid(0x1234, gid, bid);
/////////////////////////////////////////////////////////////////////////
1:         return XATestUtil.getXid(fmtid, gtid, bqual);
commit:152986e
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Regression test case for DERBY-5562.
1:      * </p>
1:      *
1:      * <p>
1:      * The timer that aborts long-running transactions if a transaction timeout
1:      * has been specified, was not cancelled when preparing a read-only
1:      * transaction. Since read-only transactions are implicitly committed when
1:      * they are prepared, this meant that the timer would try to abort an
1:      * already completed transaction. In addition to printing a confusing
1:      * message in derby.log about the transaction being rolled back, when it
1:      * actually had been committed, this could also make the timer roll back
1:      * the wrong transaction, if a new transaction with the same Xid was
1:      * started later.
1:      * </p>
1:      *
1:      * <p>
1:      * This test case exposes the bug by running a read-only transaction with
1:      * a timeout and preparing it, and then starting a new transaction with the
1:      * same Xid and no timeout. The bug would cause the second transaction to
1:      * time out.
1:      * </p>
1:      */
1:     public void testDerby5562ReadOnlyTimeout()
1:             throws InterruptedException, SQLException, XAException {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         XAConnection xac = xads.getXAConnection();
1:         XAResource xar = xac.getXAResource();
1: 
1:         Xid xid = createXid(55, 62);
1: 
1:         // Set a transaction timeout. This should be relatively short so that
1:         // the test case doesn't need to wait very long to trigger the timeout.
1:         // However, it needs to be long enough to let the first transaction go
1:         // through without hitting the timeout. Hopefully, four seconds is
1:         // enough. If the test case starts failing intermittently during the
1:         // first transaction, we might have to raise the timeout (and raise the
1:         // sleep time in the second transaction correspondingly).
1:         assertTrue(xar.setTransactionTimeout(4));
1: 
1:         // Start first transaction.
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         Connection c = xac.getConnection();
1:         Statement s = c.createStatement();
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from sysibm.sysdummy1"),
1:                 "Y");
1:         s.close();
1:         c.close();
1:         xar.end(xid, XAResource.TMSUCCESS);
1: 
1:         // Prepare the first transaction. Since it's a read-only transaction,
1:         // it'll be automatically committed, so there's no need to call commit.
1:         assertEquals("XA_RDONLY", XAResource.XA_RDONLY, xar.prepare(xid));
1: 
1:         // Reset the timeout for the second transaction.
1:         assertTrue(xar.setTransactionTimeout(0));
1: 
1:         // Start second transaction.
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         c = xac.getConnection();
1:         s = c.createStatement();
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from sysibm.sysdummy1"),
1:                 "Y");
1:         s.close();
1:         c.close();
1: 
1:         // Keep the transaction running so long that it must have exceeded the
1:         // timeout for the previous transaction.
1:         Thread.sleep(5000);
1: 
1:         // End the transaction. Since there's no timeout on this transaction,
1:         // it should work. Before DERBY-5562 was fixed, it would fail because
1:         // it had been rolled back by the timer from the previous transaction.
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         assertEquals("XA_RDONLY", XAResource.XA_RDONLY, xar.prepare(xid));
1: 
1:         xac.close();
1:     }
1: 
commit:e7c4044
/////////////////////////////////////////////////////////////////////////
1:             s.executeUpdate("DROP TABLE Derby1016");
1:             conn.commit();
commit:52acd5a
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.XATestUtil;
/////////////////////////////////////////////////////////////////////////
1:      * DERBY-4232: Test that an XA transaction can be suspended and resumed
1:      * when a timeout is in effect.
1:      */
1:     public void testTransactionTimeoutAndSuspendResume() throws Exception {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         XAConnection xac = xads.getXAConnection();
1:         XAResource xar = xac.getXAResource();
1:         Xid xid = XATestUtil.getXid(1, 2, 3);
1: 
1:         // Start work in a new transaction with a timeout
1:         xar.setTransactionTimeout(500);
1:         xar.start(xid, XAResource.TMNOFLAGS);
1: 
1:         // Suspend the transaction
1:         xar.end(xid, XAResource.TMSUSPEND);
1: 
1:         // Resume the transaction (used to fail with a XAER_PROTO on the
1:         // network client)
1:         xar.start(xid, XAResource.TMRESUME);
1: 
1:         // End the transaction and free up the resources
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         xar.rollback(xid);
1:         xac.close();
1:     }
1: 
1:     /**
1:      * DERBY-4232: Test that two branches can be joined after the timeout has
1:      * been set.
1:      */
1:     public void testTransactionTimeoutAndJoin() throws Exception {
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         XAConnection xac1 = xads.getXAConnection();
1:         XAResource xar1 = xac1.getXAResource();
1:         Xid xid1 = XATestUtil.getXid(4, 5, 6);
1: 
1:         // Start/end work in a new transaction
1:         xar1.setTransactionTimeout(500);
1:         xar1.start(xid1, XAResource.TMNOFLAGS);
1:         xar1.end(xid1, XAResource.TMSUCCESS);
1: 
1:         // Create a new branch that can be joined with the existing one
1:         XAConnection xac2 = xads.getXAConnection();
1:         XAResource xar2 = xac2.getXAResource();
1:         xar2.setTransactionTimeout(500);
1: 
1:         // Do some work on the new branch before joining (the bug won't be
1:         // reproduced if we join with a fresh branch)
1:         Xid xid2 = XATestUtil.getXid(4, 5, 7);
1:         xar2.start(xid2, XAResource.TMNOFLAGS);
1:         xar2.end(xid2, XAResource.TMSUCCESS);
1:         xar2.rollback(xid2);
1: 
1:         assertTrue(
1:                 "Branches can only be joined if RM is same",
1:                 xar1.isSameRM(xar2));
1: 
1:         // Join the branches. This used to fail with XAER_PROTO on the
1:         // network client.
1:         xar2.start(xid1, XAResource.TMJOIN);
1: 
1:         // End the transaction and free up the resources
1:         xar2.end(xid1, XAResource.TMSUCCESS);
1:         xar2.rollback(xid1);
1:         xac1.close();
1:         xac2.close();
1:     }
1: 
1:     /**
commit:cccf5dd
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLException;
1: import javax.transaction.xa.XAException;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Tests the functionality of the XA transaction timeout.
1:       * <p>
0:       * It executes 1000 global transactions during the test. Everyone
1:       * of them just inserts a row into XATT table. The rows inserted
1:       * by the transactions are different. Some of these transactions
1:       * are committed and some of them are left in different stages.
1:       * The stage of the transaction in which it is left is chosed
1:       * depending on division remainders.
1:       * </p>
1:       * <p>
1:       * After finishing these 1000 transactions a select statement is executed
1:       * on that table. However, if there are still some unfinished transactions
1:       * that were not aborted they will hold a lock on a XATT table until they
1:       * will get rolled back by the transaction timeout. The number of rows
1:       * in the XATT table is calculated. It is then compared with the excepted
1:       * number of rows (the transaction we know we have committed).
1:       * </p>
1:       * <p>
1:       * The call to xaRes.setTransactionTimeout(5) before the call
1:       * to xaRes.start() makes the transactions to be rolled back
1:       * due to timeout.
1:       * </p>
1:       */
1:     public void testXATransactionTimeout() throws Exception {
1: 
1:         /* The number of statements to execute in timeout related test. */
0:         int timeoutStatementsToExecute = 1000;
1: 
1:         /* Specifies the number of total executed statements per one
0:            commited statement in timout related test. */
1:         int timeoutCommitEveryStatement = 3;
1: 
1:         /* Specifies the number of statements that should be commited
0:            during a timout related test. */
1:         int timeoutStatementsCommitted
1:             = (timeoutStatementsToExecute + timeoutCommitEveryStatement - 1)
1:                 / timeoutCommitEveryStatement;
1: 
1:         Statement stm = getConnection().createStatement();
1:         stm.execute("create table XATT (i int, text char(10))");
1: 
1:         XADataSource xaDataSource = J2EEDataSource.getXADataSource();
0:         XAConnection xaConn = null;
1:         XAResource xaRes = null;
1:         Connection conn = null;
1: 
1:         for (int i=0; i < timeoutStatementsToExecute; i++) {
1:             xaConn = xaDataSource.getXAConnection();
1:             xaRes = xaConn.getXAResource();
1:             conn = xaConn.getConnection();
1: 
1:             Xid xid = createXid(123, i);
0:             xaRes.setTransactionTimeout(5);
1:             xaRes.start(xid, XAResource.TMNOFLAGS);
1: 
1:             stm = conn.createStatement();
1:             stm.execute("insert into XATT values (" + i + ", 'Test_Entry')");
1: 
1:             if (i % timeoutCommitEveryStatement == 0) {
1:                 stm.close();
1:                 xaRes.end(xid, XAResource.TMSUCCESS);
1:                 xaRes.prepare(xid);
1:                 xaRes.commit(xid, false);
1:                 xaConn.close();
1:             } else if (i % 11 != 0) {
0:                 // check the timout for transactions disassociated
1:                 // with failure.
1:                 try {
1:                     xaRes.end(xid, XAResource.TMFAIL);
0:                     Assert.fail();
1:                 } catch (XAException ex) {
1:                     if (ex.errorCode < XAException.XA_RBBASE
1:                         || ex.errorCode > XAException.XA_RBEND)
1:                     {
1:                         throw ex;
1:                     }
1:                 }
1:                 stm.close();
1:                 xaConn.close();
1:             } else if (i % 2 == 0) {
0:                 // check the timout for transactions disassociated
1:                 // with success.
1:                 xaRes.end(xid, XAResource.TMSUCCESS);
1:                 stm.close();
1:                 xaConn.close();
0:             } else {
0:                 // check the timout for associated transactions
0:                 ;
1:             }
1:         }
1: 
1:         stm = getConnection().createStatement();
0:         ResultSet rs = stm.executeQuery("select count(*) from XATT");
1:         rs.next();
1: 
1:         // Check whether the correct number of transactions
1:         // was rolled back
0:         Assert.assertTrue(rs.getInt(1) == timeoutStatementsCommitted);
1: 
0:         // test the timout during the statement is run
1:         xaConn = xaDataSource.getXAConnection();
1:         xaRes = xaConn.getXAResource();
1:         conn = xaConn.getConnection();
1: 
1:         Xid xid = createXid(124, 100);
1:         xaRes.setTransactionTimeout(10);
1:         xaRes.start(xid, XAResource.TMNOFLAGS);
1: 
1:         stm = conn.createStatement();
1: 
1:         // Check whether the statement was correctly timed out
1:         // and the appropriate exception was thrown
0:         boolean exceptionThrown = false;
1:         try {
1:             rs = stm.executeQuery(
0:                  "select * from XATT a, XATT b, XATT c, XATT d, XATT e "
0:                + "order by a.i");
1:         } catch (SQLException ex) {
1:             // Check the sql state of the thrown exception
1:             assertSQLState(
1:                 SQLState.LANG_STATEMENT_CANCELLED_OR_TIMED_OUT.substring(0,5),
0:                 ex
0:             );
0:             exceptionThrown = true;
1:         }
0:         Assert.assertTrue(exceptionThrown);
1: 
1:         stm = getConnection().createStatement();
1:         rs = stm.executeQuery("select count(*) from XATT");
1:         rs.next();
1: 
1:         // Again, check whether the correct number of transactions
1:         // was rolled back
0:         Assert.assertTrue(rs.getInt(1) == timeoutStatementsCommitted);
1:     }
1: 
1: 
1:     /** Create the Xid object for global transaction identification
1:       * with the specified identification values.
1:       * @param gtrid Global Transaction ID
1:       * @param bqual Branch Qualifier
1:       */
1:     static Xid createXid(int gtrid, int bqual) throws XAException {
1:         byte[] gid = new byte[2]; gid[0]= (byte) (gtrid % 256); gid[1]= (byte) (gtrid / 256);
1:         byte[] bid = new byte[2]; bid[0]= (byte) (bqual % 256); bid[1]= (byte) (bqual / 256);
0:         Xid xid = new ClientXid(0x1234, gid, bid);
0:         return xid;
1:     }
1: 
commit:60426a1
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         // the test requires XADataSource to run
1:         if (JDBC.vmSupportsJDBC3()) {
0:             return TestConfiguration.defaultSuite(XATransactionTest.class);
1:         }
0:         return new TestSuite("XATransactionTest cannot run without XA support");
commit:c2b437d
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.XATransactionTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.Connection;
1: import java.sql.ResultSet;
1: import java.sql.Statement;
1: import javax.sql.XAConnection;
1: import javax.sql.XADataSource;
1: import javax.transaction.xa.XAResource;
1: import javax.transaction.xa.Xid;
1: 
0: import junit.framework.Assert;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import org.apache.derby.client.ClientXid;
0: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /** The test of the properties of the XA transaction interface implementation.
1:   */
1: public class XATransactionTest extends BaseJDBCTestCase {
1: 
1:     public void testGlobalXIDinTransactionTable() throws Exception {
1:         Statement stm = getConnection().createStatement();
1:         stm.execute("create table XATT2 (i int, text char(10))");
1: 
1:         XADataSource xaDataSource = J2EEDataSource.getXADataSource();
1:         XAConnection xaConn = xaDataSource.getXAConnection();
1:         XAResource xaRes = xaConn.getXAResource();
1:         Connection conn = xaConn.getConnection();
1: 
1:         // create large enough xid
1:         byte[] gid = new byte[64];
1:         byte[] bid = new byte[64];
1:         for (int i=0; i < 64; i++) {
1:             gid[i] = (byte) i;
1:             bid[i] = (byte) (64 - i);
1:         }
0:         Xid xid = new ClientXid(0x1234, gid, bid);
1: 
1:         // get the stuff required to execute the global transaction
0:         xaConn = xaDataSource.getXAConnection();
0:         xaRes = xaConn.getXAResource();
0:         conn = xaConn.getConnection();
1: 
1:         // start the transaction with that xid
1:         xaRes.start(xid, XAResource.TMNOFLAGS);
1: 
1:         // do some work
1:         stm = conn.createStatement();
1:         stm.execute("insert into XATT2 values (1234, 'Test_Entry')");
1:         stm.close();
1: 
1:         // end the wotk on the transaction branch
1:         xaRes.end(xid, XAResource.TMSUCCESS);
1: 
1:         ResultSet rs = null;
1:         stm = null;
1: 
1:         try {
1: 
0:             // check the output of the global xid in syscs_diag.transaction_table
1:             stm = getConnection().createStatement();
1: 
1:             String query = "select global_xid from syscs_diag.transaction_table"
1:                          + " where global_xid is not null";
1: 
1:             // execute the query to obtain the xid of the global transaction
1:             rs = stm.executeQuery(query);
1: 
1:             // there should be at least one globaltransaction in progress
0:             Assert.assertTrue(rs.next());
1: 
1:             // check whether the xid obtained matches the original xid
1:             Xid rXid = parseXid(rs.getString(1));
0:             Assert.assertEquals(xid, rXid);
1: 
1:             // there should be at most one global transaction in progress
0:             Assert.assertFalse(rs.next());
1: 
1:         } catch (Exception ex) {
1:             try {
1:                 // close all the stuff
1:                 if (rs != null)
1:                     rs.close();
1:                 if (stm != null)
1:                     stm.close();
1: 
1:                 // rollback the global transaction
1:                 xaRes.rollback(xid);
1:                 // close the connection
0:                 xaConn.close();
1:             } catch (Exception e) {
1:                 // ignore the exception because it
1:                 // would hide the original exception
1:             }
1:             // throw the stuff further
1:             throw ex;
1:         }
1: 
1:         // close all the stuff
1:         rs.close();
1:         stm.close();
1: 
1:         // rollback the global transaction
1:         xaRes.rollback(xid);
1: 
1:         // close the connection
0:         xaConn.close();
1:     }
1: 
1:     /* ------------------- end helper methods  -------------------------- */
1: 
1:     /** Parses the xid value from the string. The format of the input string is
1:       * the same as the global_xid column in syscs_diag.transaction_table table -
1:       * '(formatid_in_dec,global_transaction_id_in_hex,branch_qualifier_in_hex)'
1:       * @param str Global Transaction ID converted to a string.
1:       * @return The xid object corresponding to the xid specified in a string.
1:       */
1:     private static Xid parseXid(String str) {
0:         Assert.assertNotNull(str);
0:         Assert.assertTrue(str.matches("\\(\\p{Digit}+,\\p{XDigit}+,\\p{XDigit}+\\)"));
1: 
1:         String formatIdS = str.substring(1, str.indexOf(','));
1:         String gtidS = str.substring(str.indexOf(',')+1, str.lastIndexOf(','));
1:         String bqualS = str.substring(str.lastIndexOf(',')+1, str.length()-1);
1: 
0:         Assert.assertTrue(gtidS.length() % 2 == 0);
0:         Assert.assertTrue(bqualS.length() % 2 == 0);
1: 
1:         int fmtid = Integer.parseInt(formatIdS);
1:         byte[] gtid = new byte[gtidS.length()/2];
1:         byte[] bqual = new byte[bqualS.length()/2];
1: 
1:         for (int i=0; i < gtid.length; i++) {
1:             gtid[i] = (byte) Integer.parseInt(gtidS.substring(2*i, 2*i + 2), 16);
1:         }
1: 
1:         for (int i=0; i < bqual.length; i++) {
1:             bqual[i] = (byte) Integer.parseInt(bqualS.substring(2*i, 2*i + 2), 16);
1:         }
1: 
0:         // Using ClientXid is ok also for embedded driver
0:         // since it does not contain any related code
0:         // and there is no implementation of Xid iterface
0:         // for embedded driver
0:         return new ClientXid(fmtid, gtid, bqual);
1:     }
1: 
1:     public XATransactionTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
0:         Test test;
0:         TestSuite suite = new TestSuite("XATransactionTest");
1: 
0:         test = TestConfiguration.defaultSuite(XATransactionTest.class);
0:         suite.addTest(test);
1: 
0:         return suite;
1:     }
1: }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:418e135
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This fixture triggers DERBY-1016. It creates an XA transaction, executes
1:      * an update over it and then prepares the transaction. Trying to forget
1:      * after preparing should throw XAER_PROTO and not XAER_NOTA.
1:      */
1:     public void testForgetExceptionDerby1016PROTO() throws XAException, SQLException {      
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:         
1:         XAConnection xaconn = xads.getXAConnection();
1:         XAResource xar = xaconn.getXAResource();
1:         Xid xid = createXid(93,18);
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         Connection conn = xaconn.getConnection();
1:         Statement s = conn.createStatement();
1:         s.executeUpdate("CREATE TABLE Derby1016 (I INT)");
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         xar.prepare(xid);
1:         try {
1:             xar.forget(xid);
1:             fail("FAIL: prepared XA-Transaction forgotten");
1:         } catch (XAException XAeForget) {
1:             assertEquals("FAIL: Got unexpected exception "
1:                           + XAeForget.getMessage()   + " errorCode: " 
1:                           + XAeForget.errorCode  + "  calling forget on a prepared transaction",
1:                         XAException.XAER_PROTO, XAeForget.errorCode);
1:         } finally {
1:             s.close();
1:             xar.rollback(xid);
1:             conn.close(); 
1:             xaconn.close();
1:         }
1:     }
1:  
1:     /**
1:      * Further test case prompted by DERBY-1016. Tests that XAER_NOTA is thrown
1:      * if no transaction exists.
1:      */
1:     public void testForgetExceptionDerby1016NOTA() throws XAException, SQLException {      
1:         XADataSource xads = J2EEDataSource.getXADataSource();
1:         J2EEDataSource.setBeanProperty(xads, "databaseName", "wombat");
1:         
1:         XAConnection xaconn = xads.getXAConnection();
1:         XAResource xar = xaconn.getXAResource();
1:         Xid xid = createXid(93,18);
1:         xar.start(xid, XAResource.TMNOFLAGS);
1:         Connection conn = xaconn.getConnection();
1:         Statement s = conn.createStatement();
1:         s.executeUpdate("CREATE TABLE Derby1016 (I INT)");
1:         xar.end(xid, XAResource.TMSUCCESS);
1:         xar.prepare(xid);
1:         xar.commit(xid, false);
1:         try {
1:             // since the transaction was committed, it should no longer exist
1:             // thus, forget should now throw an XAER_NOTA
1:             xar.forget(xid);
1:             fail("FAIL: able to forget committed XA-Transaction");
1:         } catch (XAException XAeForget) {
1:             assertEquals("FAIL: Got unexpected exception "
1:                           + XAeForget.getMessage()   + " errorCode: " 
1:                           + XAeForget.errorCode  + "  calling forget on a committed transaction",
1:                         XAException.XAER_NOTA, XAeForget.errorCode);
1:         } finally {
1:             s.close();
1:             conn.close(); 
1:             xaconn.close();
1:         }
1:     }
1: 
commit:b1d6f8e
/////////////////////////////////////////////////////////////////////////
0:             xaRes.setTransactionTimeout(5);
commit:d4cbc63
/////////////////////////////////////////////////////////////////////////
0: 
0:             if (i % timeoutCommitEveryStatement == 0) {
0:                 // Setup the higher value for the transaction timeout
0:                 // if the transaction is going to be committed
0:                 // just to be sure that it would not be rolled back
0:                 // before commit due to a garbage collection
0:                 // in progress, etc.
0:                 xaRes.setTransactionTimeout(60);
0:             } else {
0:                 // We will set the transaction timeout value low
0:                 // for transactions going to be rolled back to keep
0:                 // the number of pending transactions low
1:                 xaRes.setTransactionTimeout(8);
1:             }
0: 
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:ad40eda
/////////////////////////////////////////////////////////////////////////
1: 	/**
1: 	  * This test does following 
1: 	  * 1)Start the network server
1: 	  * 2)Start a local xa transaction
1: 	  * 3)Do not commit the local XA transaction
1: 	  * 4)Shutdown the network server
1: 	  * 5)Start the server again
1: 	  * 
1: 	  * Before the fix for DERBY-4053 went in, step 4) would not shutdown the
1: 	  * server properly because of the pending local XA transaction. During the
1: 	  * server shutdown, we try to close all the open connections but the close 
1: 	  * on the XA connection results into an exception because there is still a
1: 	  * pending transaction. That exception is not handled by the server and
1: 	  * because of that, all the code necessary to shutdown the server is not
1: 	  * executed. The next time around, step 5), when we try to bring up the
1: 	  * server again, it ends up hanging
1: 	  * 2009-07-09 21:21:28.828 GMT : Invalid reply from network server: Insufficient data.
1: 	  * 2009-07-09 21:21:28.843 GMT : Could not listen on port 1527 on host 127.0.0.1: java.net.BindException: Address already in use: JVM_Bind
1: 	  * 
1: 	  * The fix for DERBY-4053 makes sure that before calling close on local XA
1: 	  * transaction, we first rollback any transaction active on the 
1: 	  * connection. 
1: 	 */
1: 	public void testPendingLocalTranAndServerShutdown() throws Exception {
1:         if (usingEmbedded())
1:             return;
1:         //1)Server must be up already through the Derby junit framework
1:         //2)Start a local xa transaction
1:         XADataSource xaDataSource = J2EEDataSource.getXADataSource();
1:         XAConnection xaconn = xaDataSource.getXAConnection();
1:         XAResource xar = xaconn.getXAResource();
1:         Connection conn = xaconn.getConnection();
1:         Statement s = conn.createStatement();
1:         s.executeUpdate("create table tab(i int)");
1:         s.executeUpdate("insert into tab values (1),(2),(3),(4)");
1:         conn.commit();
1:         conn.setAutoCommit(false);
1:         ResultSet rs = s.executeQuery("select * from tab");
1:         rs.next();
1:         //3)Do not commit this pending local XA transaction
0:     	
1:         //4)Shutdown the network server
1:         //bring the server down while the local xa transaction is still active
1:         TestConfiguration.getCurrent().stopNetworkServer();
0:         
1:         //5)Start the server again
1:         TestConfiguration.getCurrent().startNetworkServer();
1: 	}
0: 	
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:31ba8d0
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * DERBY-4141 XAExceptions caused by SQLExceptions should have a
1:      * non-zero errorCode. SESSION_SEVERITY or greater map to
1:      * XAException.XAER_RMFAIL. Lesser exceptions map to XAException.XAER_RMERR 
1:      * @throws Exception
1:      */
1:     public void testXAExceptionErrorCodeOnSQLExceptionDerby4141() throws Exception {
1:         XADataSource xaDataSource = J2EEDataSource.getXADataSource();
1:         XAConnection xaConn = xaDataSource.getXAConnection();
1:         XAResource xaRes = xaConn.getXAResource();        
1:         Xid xid = createXid(123, 1);
1:         // close the XAConnection so we get an SQLException on
1:         // start();
0:         xaConn.close();
1:         try {
1:             xaRes.start(xid, XAResource.TMNOFLAGS);
1:             fail("Should have gotten an XAException. xaConn is closed.");
1:         } catch (XAException xae) {
1:             assertEquals(XAException.XAER_RMFAIL, xae.errorCode);
1:         }
1:     }
author:Dyre Tjeldvoll
-------------------------------------------------------------------------------
commit:bb9f97a
/////////////////////////////////////////////////////////////////////////
0: import java.sql.CallableStatement;
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
/////////////////////////////////////////////////////////////////////////
1:     /** Tests whether it is possible to reconstruct the original Xid value
1:       * correctly from SYSCS_DIAG.TRANSACTION_TABLE. */
/////////////////////////////////////////////////////////////////////////
1:             // check the output of the global xid in 
1:             // syscs_diag.transaction_table
/////////////////////////////////////////////////////////////////////////
1:             assertTrue(rs.next());
1:             assertEquals(xid, rXid);
1:             assertFalse(rs.next());
/////////////////////////////////////////////////////////////////////////
1:       * It executes 66 global transactions during the test. Everyone
/////////////////////////////////////////////////////////////////////////
1:         int timeoutStatementsToExecute = 66;
1:            commited statement in timeout related test. */
1:            during a timeout related test. */
/////////////////////////////////////////////////////////////////////////
1:         XAConnection[] xaConn = new XAConnection[timeoutStatementsToExecute];
1:             xaConn[i] = xaDataSource.getXAConnection();
1:             xaRes = xaConn[i].getXAResource();
1:             conn = xaConn[i].getConnection();
0:             xaRes.setTransactionTimeout(8);
/////////////////////////////////////////////////////////////////////////
1:                 // check the tiemout for transactions disassociated
1:                     fail();
/////////////////////////////////////////////////////////////////////////
1:                 // check the timeout for transactions disassociated
0:             } 
1:         ResultSet rs = null;
0: 
1:         rs = stm.executeQuery("select count(*) from XATT");
1:         assertTrue(rs.getInt(1) == timeoutStatementsCommitted);
1:         // test the timeout during the statement run
1:         XAConnection xaConn2 = xaDataSource.getXAConnection();
1:         xaRes = xaConn2.getXAResource();
1:         conn = xaConn2.getConnection();
/////////////////////////////////////////////////////////////////////////
1:             // Run this kind of statement just to be sure
1:             // it will not finish before it will time out
1:                  "select count(*) from sys.syscolumns a, sys.syscolumns b, "
1:                + "sys.syscolumns c, sys.syscolumns d, sys.syscolumns e "
1:                + "group by a.referenceid, b.referenceid, c.referenceid, "
1:                + "d.referenceid");
1:             fail("An exception is expected here");
1:                 ex);
1:         // perform a select on the table just to be sure that all
1:         // the transactions were rolled back.
1:         // Go throught the XA Connections just to be sure that no code
1:         // optimization would garbage collect them before (and thus
1:         // the transactions might get rolled back by a different
1:         // code).
1:         for (int i=0; i < timeoutStatementsToExecute; i++) {
1:             assertNotNull(xaConn[i]);
1:             xaConn[i].close();
0:         }
0: 
1:         assertTrue(rs.getInt(1) == timeoutStatementsCommitted);
/////////////////////////////////////////////////////////////////////////
1:         assertNotNull(str);
1:         assertTrue(str.matches("\\(\\p{Digit}+,\\p{XDigit}+,\\p{XDigit}+\\)"));
1:         assertTrue(gtidS.length() % 2 == 0);
1:         assertTrue(bqualS.length() % 2 == 0);
/////////////////////////////////////////////////////////////////////////
1:             Test test = TestConfiguration.defaultSuite(XATransactionTest.class);
1:             // Set the lock timeout back to the default, because when
1:             // running in a bigger suite the value may have been
1:             // altered by an earlier test
1:             test = DatabasePropertyTestSetup.setLockTimeouts(test, 20, 60);
1:             return test;
============================================================================