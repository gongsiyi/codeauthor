1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.access.conglomerate.Conglomerate
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.iapi.store.access.conglomerate;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.store.access.ConglomerateController;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.Qualifier;
1:eac0369: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1:eac0369: import org.apache.derby.iapi.store.access.StoreCostController;
1:eac0369: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerKey;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.io.Storable;
1:eac0369: import org.apache.derby.iapi.services.io.FormatableBitSet;
1:eac0369: 
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: A conglomerate is an abstract storage structure (they
1:eac0369: correspond to access methods).  The Conglomerate interface
1:eac0369: corresponds to a single instance of a conglomerate. In
1:eac0369: other words, for each conglomerate in the system, there
1:eac0369: will be one object implementing Conglomerate.
1:eac0369: <P>
1:eac0369: The Conglomerate interface is implemented by each access method.
1:eac0369: The implementation must maintain enough information to properly
1:eac0369: open the conglomerate and scans, and to drop the conglomerate.
1:eac0369: This information typically will include the id of the container
1:eac0369: or containers in which the conglomerate is stored, and my also
1:eac0369: include property information.
1:eac0369: <P>
1:eac0369: Conglomerates are created by a conglomerate factory.  The access
1:eac0369: manager stores them in a directory (which is why they implement
1:eac0369: Storable).
1:eac0369: 
1:eac0369: **/
1:eac0369: 
1:eac0369: public interface Conglomerate extends Storable, DataValueDescriptor
1:eac0369: {
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Add a column to the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * This routine update's the in-memory object version of the 
1:eac0369:      * Conglomerate to have one more column of the type described by the
1:eac0369:      * input template column.
4:eac0369:      *
1:eac0369:      * Note that not all conglomerates may support this feature.
1:eac0369:      * 
1:eac0369: 	 * @param xact_manager     The TransactionController under which this 
1:eac0369:      *                         operation takes place.
1:eac0369:      * @param column_id        The column number to add this column at.
1:eac0369:      * @param template_column  An instance of the column to be added to table.
1:b61f876:      * @param collation_id     Collation id of the added column.
1:eac0369:      *
3:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public void addColumn(
1:eac0369:     TransactionManager  xact_manager,
1:eac0369:     int                 column_id,
1:b61f876:     Storable            template_column,
1:b61f876:     int                 collation_id)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Drop this conglomerate.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	void drop(TransactionManager  xact_manager)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Retrieve the maximum value row in an ordered conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Returns true and fetches the rightmost row of an ordered conglomerate 
1:eac0369:      * into "fetchRow" if there is at least one row in the conglomerate.  If
1:eac0369:      * there are no rows in the conglomerate it returns false.
1:eac0369:      * <p>
1:eac0369:      * Non-ordered conglomerates will not implement this interface, calls
1:eac0369:      * will generate a StandardException.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE - this interface is temporary, long term equivalent (and more) 
1:eac0369:      * functionality will be provided by the openBackwardScan() interface.  
1:eac0369:      *
1:eac0369: 	 * @param xact_manager    The TransactionController under which this 
1:eac0369:      *                        operation takes place.
1:eac0369:      *
1:eac0369:      * @param rawtran         The raw store xact to associate all ops with.
1:eac0369:      *
1:eac0369: 	 * @param conglomId       The identifier of the conglomerate
1:eac0369: 	 *                        to open the scan for.
1:eac0369:      *
1:eac0369: 	 * @param open_mode       Specifiy flags to control opening of table.  
1:eac0369:      *                        OPENMODE_FORUPDATE - if set open the table for
1:eac0369:      *                        update otherwise open table shared.
1:eac0369:      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
1:eac0369:      *
1:eac0369:      * @param locking_policy  The LockingPolicy to use to open the conglomerate.
1:eac0369:      *
1:eac0369:      * @param isolation_level The isolation level to lock the conglomerate at.
1:eac0369:      *                        One of (ISOLATION_READ_COMMITTED, 
1:eac0369:      *                        ISOLATION_REPEATABLE_READ, or 
1:eac0369:      *                        ISOLATION_SERIALIZABLE).
1:eac0369:      *
1:eac0369: 	 * @param scanColumnList  A description of which columns to return from 
1:eac0369:      *                        every fetch in the scan. fetchRow  
1:eac0369:      *                        and scanColumnList work together
1:eac0369:      *                        to describe the row to be returned by the scan - 
1:eac0369:      *                        see RowUtil for description of how these three 
1:eac0369:      *                        parameters work together to describe a "row".
1:eac0369:      *
1:eac0369:      * @param fetchRow        The row to retrieve the maximum value into.
1:eac0369:      *
1:eac0369: 	 * @return boolean indicating if a row was found and retrieved or not.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 
1:eac0369: 	boolean fetchMaxOnBTree(
1:eac0369:     TransactionManager      xact_manager,
1:eac0369:     Transaction             rawtran,
1:eac0369:     long                    conglomId,
1:eac0369:     int                     open_mode,
1:eac0369:     int                     lock_level,
1:eac0369:     LockingPolicy           locking_policy,
1:eac0369:     int                     isolation_level,
1:eac0369:     FormatableBitSet                 scanColumnList,
1:eac0369:     DataValueDescriptor[]   fetchRow)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the containerid of conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Will have to change when a conglomerate could have more than one 
1:eac0369:      * containerid.
1:eac0369:      *
1:eac0369: 	 * @return The containerid.
1:eac0369:      **/
1:eac0369:     long getContainerid();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the id of the container of the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Will have to change when a conglomerate could have more than one 
1:eac0369:      * container.  The ContainerKey is a combination of the container id
1:eac0369:      * and segment id.
1:eac0369:      *
1:eac0369: 	 * @return The ContainerKey.
1:eac0369:      **/
1:eac0369:     ContainerKey getId();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return static information about the conglomerate to be included in a
1:eac0369:      * a compiled plan.
1:eac0369:      * <p>
1:eac0369:      * The static info would be valid until any ddl was executed on the 
1:eac0369:      * conglomid, and would be up to the caller to throw away when that 
1:eac0369:      * happened.  This ties in with what language already does for other 
1:eac0369:      * invalidation of static info.  The type of info in this would be 
1:eac0369:      * containerid and array of format id's from which templates can be created.
1:eac0369:      * The info in this object is read only and can be shared among as many 
1:eac0369:      * threads as necessary.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The static compiled information.
1:eac0369:      *
1:eac0369: 	 * @param tc        The TransactionController under which this operation 
1:eac0369:      *                  takes place.
2:eac0369:      * @param conglomId The identifier of the conglomerate to open.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(
1:eac0369:     TransactionController   tc,
1:eac0369:     long                    conglomId)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return dynamic information about the conglomerate to be dynamically 
1:eac0369:      * reused in repeated execution of a statement.
1:eac0369:      * <p>
1:eac0369:      * The dynamic info is a set of variables to be used in a given 
1:eac0369:      * ScanController or ConglomerateController.  It can only be used in one 
1:eac0369:      * controller at a time.  It is up to the caller to insure the correct 
1:eac0369:      * thread access to this info.  The type of info in this is a scratch 
1:eac0369:      * template for btree traversal, other scratch variables for qualifier 
1:eac0369:      * evaluation, ...
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The dynamic information.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:57a0040:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo()
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Is this conglomerate temporary?
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return whether conglomerate is temporary or not.
1:eac0369:      **/
1:eac0369:     boolean isTemporary();
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Bulk load into the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Individual rows that are loaded into the conglomerate are not
1:eac0369: 	 * logged. After this operation, the underlying database must be backed up
1:eac0369: 	 * with a database backup rather than an transaction log backup (when we 
1:eac0369:      * have them). This warning is put here for the benefit of future 
1:eac0369:      * generation.
1:eac0369:      * <p>
1:eac0369: 	 * @param xact_manager  The TransactionController under which this operation
1:eac0369: 	 *                      takes place.
1:eac0369:      *
1:eac0369: 	 * @param createConglom If true, the conglomerate is being created in the 
1:eac0369:      *                      same operation as the openAndLoadConglomerate.  
1:eac0369:      *                      The enables further optimization as recovery does
1:eac0369:      *                      not require page allocation to be logged. 
1:eac0369:      *
1:eac0369: 	 * @param rowSource     Where the rows come from.
1:eac0369:      *
1:eac0369: 	 * @return The number of rows loaded.
1:eac0369:      *
1:eac0369:      * @exception StandardException Standard exception policy.  If 
1:eac0369:      * conglomerage supports uniqueness checks and has been created to 
1:eac0369:      * disallow duplicates, and one of the rows being loaded had key columns 
1:eac0369:      * which were duplicate of a row already in the conglomerate, then 
1:eac0369:      * raise SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION.
1:eac0369:      *
1:eac0369:      **/
1:eac0369: 	public long load(
1:eac0369: 	TransactionManager      xact_manager,
1:eac0369: 	boolean                 createConglom,
1:eac0369: 	RowLocationRetRowSource rowSource)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Open a conglomerate controller.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return The open ConglomerateController.
1:eac0369:      *
1:eac0369:      * @param xact_manager   The access xact to associate all ops on cc with.
1:eac0369:      * @param rawtran        The raw store xact to associate all ops on cc with.
1:eac0369:      * @param open_mode      A bit mask of TransactionController.MODE_* bits,
1:eac0369:      *                       indicating info about the open.
1:eac0369:      * @param lock_level     Either TransactionController.MODE_TABLE or
1:eac0369:      *                       TransactionController.MODE_RECORD, as passed into
1:eac0369:      *                       the openConglomerate() call.
1:eac0369:      * @param locking_policy The LockingPolicy to use to open the conglomerate.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369:      * @see TransactionController
1:eac0369:      **/
1:eac0369: 	ConglomerateController open(
1:eac0369:     TransactionManager              xact_manager,
1:eac0369:     Transaction                     rawtran, 
1:eac0369:     boolean                         hold,
1:eac0369:     int                             open_mode,
1:eac0369:     int                             lock_level,
1:eac0369:     LockingPolicy                   locking_policy,
1:eac0369:     StaticCompiledOpenConglomInfo   static_info,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Open a scan controller.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	ScanManager openScan(
1:eac0369:     TransactionManager              xact_manager,
1:eac0369:     Transaction                     rawtran,
1:eac0369:     boolean                         hold,
1:eac0369:     int                             open_mode,
1:eac0369:     int                             lock_level,
1:eac0369:     LockingPolicy                   locking_policy,
1:eac0369:     int                             isolation_level,
1:bbc927c: 	FormatableBitSet				scanColumnList,
1:eac0369:     DataValueDescriptor[]	        startKeyValue,
1:eac0369:     int                             startSearchOperator,
1:eac0369:     Qualifier                       qualifier[][],
1:eac0369:     DataValueDescriptor[]           stopKeyValue,
1:eac0369:     int                             stopSearchOperator,
1:eac0369:     StaticCompiledOpenConglomInfo   static_info,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369:         throws StandardException;
1:eac0369: 
1:eac0369:     /**
1:bbc927c:      * Online compress table.
1:bbc927c:      *
1:bbc927c:      * Returns a ScanManager which can be used to move rows
1:bbc927c:      * around in a table, creating a block of free pages at the end of the
1:bbc927c:      * table.  The process of executing the scan will move rows from the end 
1:bbc927c:      * of the table toward the beginning.  The GroupFetchScanController will
1:bbc927c:      * return the old row location, the new row location, and the actual data 
1:bbc927c:      * of any row moved.  Note that this scan only returns moved rows, not an
1:bbc927c:      * entire set of rows, the scan is designed specifically to be
1:bbc927c:      * used by either explicit user call of the SYSCS_ONLINE_COMPRESS_TABLE()
1:bbc927c:      * procedure, or internal background calls to compress the table.
1:bbc927c:      *
1:bbc927c:      * The old and new row locations are returned so that the caller can
1:bbc927c:      * update any indexes necessary.
1:bbc927c:      *
1:bbc927c:      * This scan always returns all collumns of the row.
1:bbc927c:      * 
1:bbc927c:      * All inputs work exactly as in openScan().  The return is 
1:bbc927c:      * a GroupFetchScanController, which only allows fetches of groups
1:bbc927c:      * of rows from the conglomerate.
1:bbc927c:      * <p>
1:bbc927c:      * Note that all Conglomerates may not implement openCompressScan(), 
1:bbc927c:      * currently only the Heap conglomerate implements this scan.
1:bbc927c:      *
1:bbc927c: 	 * @return The GroupFetchScanController to be used to fetch the rows.
1:bbc927c:      *
1:bbc927c:      * @param hold                  see openScan()
1:bbc927c:      * @param open_mode             see openScan()
1:bbc927c:      * @param lock_level            see openScan()
1:bbc927c:      * @param isolation_level       see openScan()
1:bbc927c:      *
1:bbc927c: 	 * @exception  StandardException  Standard exception policy.
1:bbc927c:      **/
1:bbc927c: 	ScanManager defragmentConglomerate(
1:bbc927c:     TransactionManager              xact_manager,
1:bbc927c:     Transaction                     rawtran,
1:bbc927c:     boolean                         hold,
1:bbc927c:     int                             open_mode,
1:bbc927c:     int                             lock_level,
1:bbc927c:     LockingPolicy                   locking_policy,
1:bbc927c:     int                             isolation_level)
1:bbc927c:         throws StandardException;
1:bbc927c: 
1:bbc927c: 	void purgeConglomerate(
1:bbc927c:     TransactionManager              xact_manager,
1:bbc927c:     Transaction                     rawtran)
1:bbc927c:         throws StandardException;
1:bbc927c: 
1:bbc927c: 	void compressConglomerate(
1:bbc927c:     TransactionManager              xact_manager,
1:bbc927c:     Transaction                     rawtran)
1:bbc927c:         throws StandardException;
1:bbc927c: 
1:bbc927c:     /**
1:eac0369:      * Return an open StoreCostController for the conglomerate.
1:eac0369:      * <p>
1:eac0369:      * Return an open StoreCostController which can be used to ask about 
1:eac0369:      * the estimated row counts and costs of ScanController and 
1:eac0369:      * ConglomerateController operations, on the given conglomerate.
1:eac0369:      * <p>
1:eac0369: 	 * @param xact_manager The TransactionController under which this 
1:eac0369:      *                     operation takes place.
1:eac0369: 	 * @param rawtran  raw transaction context in which scan is managed.
1:eac0369:      *
1:eac0369: 	 * @return The open StoreCostController.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      *
1:eac0369:      * @see StoreCostController
1:eac0369:      **/
1:eac0369:     StoreCostController openStoreCost(
1:eac0369:     TransactionManager  xact_manager,
1:eac0369:     Transaction         rawtran)
1:eac0369: 		throws StandardException;
1:eac0369: 
1:eac0369: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:f668d94
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:57a0040
/////////////////////////////////////////////////////////////////////////
1:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo()
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b61f876
/////////////////////////////////////////////////////////////////////////
1:      * @param collation_id     Collation id of the added column.
1:     Storable            template_column,
1:     int                 collation_id)
commit:12c6ed9
/////////////////////////////////////////////////////////////////////////
commit:bbc927c
/////////////////////////////////////////////////////////////////////////
1: 	FormatableBitSet				scanColumnList,
/////////////////////////////////////////////////////////////////////////
1:      * Online compress table.
1:      *
1:      * Returns a ScanManager which can be used to move rows
1:      * around in a table, creating a block of free pages at the end of the
1:      * table.  The process of executing the scan will move rows from the end 
1:      * of the table toward the beginning.  The GroupFetchScanController will
1:      * return the old row location, the new row location, and the actual data 
1:      * of any row moved.  Note that this scan only returns moved rows, not an
1:      * entire set of rows, the scan is designed specifically to be
1:      * used by either explicit user call of the SYSCS_ONLINE_COMPRESS_TABLE()
1:      * procedure, or internal background calls to compress the table.
1:      *
1:      * The old and new row locations are returned so that the caller can
1:      * update any indexes necessary.
1:      *
1:      * This scan always returns all collumns of the row.
1:      * 
1:      * All inputs work exactly as in openScan().  The return is 
1:      * a GroupFetchScanController, which only allows fetches of groups
1:      * of rows from the conglomerate.
1:      * <p>
1:      * Note that all Conglomerates may not implement openCompressScan(), 
1:      * currently only the Heap conglomerate implements this scan.
1:      *
1: 	 * @return The GroupFetchScanController to be used to fetch the rows.
1:      *
0: 	 * @param conglomId             see openScan()
1:      * @param hold                  see openScan()
1:      * @param open_mode             see openScan()
1:      * @param lock_level            see openScan()
1:      * @param isolation_level       see openScan()
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	ScanManager defragmentConglomerate(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     int                             isolation_level)
1:         throws StandardException;
1: 
1: 	void purgeConglomerate(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran)
1:         throws StandardException;
1: 
1: 	void compressConglomerate(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran)
1:         throws StandardException;
1: 
1:     /**
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.access.conglomerate.Conglomerate
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access.conglomerate
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.access.conglomerate;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.Qualifier;
1: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
1: import org.apache.derby.iapi.store.access.StoreCostController;
1: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.raw.ContainerKey;
1: 
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
1: import org.apache.derby.iapi.services.io.Storable;
1: import org.apache.derby.iapi.services.io.FormatableBitSet;
1: 
1: 
1: /**
1: 
1: A conglomerate is an abstract storage structure (they
1: correspond to access methods).  The Conglomerate interface
1: corresponds to a single instance of a conglomerate. In
1: other words, for each conglomerate in the system, there
1: will be one object implementing Conglomerate.
1: <P>
1: The Conglomerate interface is implemented by each access method.
1: The implementation must maintain enough information to properly
1: open the conglomerate and scans, and to drop the conglomerate.
1: This information typically will include the id of the container
1: or containers in which the conglomerate is stored, and my also
1: include property information.
1: <P>
1: Conglomerates are created by a conglomerate factory.  The access
1: manager stores them in a directory (which is why they implement
1: Storable).
1: 
1: **/
1: 
1: public interface Conglomerate extends Storable, DataValueDescriptor
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1:     /**
1:      * Add a column to the conglomerate.
1:      * <p>
1:      * This routine update's the in-memory object version of the 
1:      * Conglomerate to have one more column of the type described by the
1:      * input template column.
1:      *
1:      * Note that not all conglomerates may support this feature.
1:      * 
1: 	 * @param xact_manager     The TransactionController under which this 
1:      *                         operation takes place.
1:      * @param column_id        The column number to add this column at.
1:      * @param template_column  An instance of the column to be added to table.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public void addColumn(
1:     TransactionManager  xact_manager,
1:     int                 column_id,
0:     Storable            template_column)
1:         throws StandardException;
1: 
1:     /**
1:      * Drop this conglomerate.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	void drop(TransactionManager  xact_manager)
1: 		throws StandardException;
1: 
1:     /**
1:      * Retrieve the maximum value row in an ordered conglomerate.
1:      * <p>
1:      * Returns true and fetches the rightmost row of an ordered conglomerate 
1:      * into "fetchRow" if there is at least one row in the conglomerate.  If
1:      * there are no rows in the conglomerate it returns false.
1:      * <p>
1:      * Non-ordered conglomerates will not implement this interface, calls
1:      * will generate a StandardException.
1:      * <p>
1:      * RESOLVE - this interface is temporary, long term equivalent (and more) 
1:      * functionality will be provided by the openBackwardScan() interface.  
1:      *
1: 	 * @param xact_manager    The TransactionController under which this 
1:      *                        operation takes place.
1:      *
1:      * @param rawtran         The raw store xact to associate all ops with.
1:      *
1: 	 * @param conglomId       The identifier of the conglomerate
1: 	 *                        to open the scan for.
1:      *
1: 	 * @param open_mode       Specifiy flags to control opening of table.  
1:      *                        OPENMODE_FORUPDATE - if set open the table for
1:      *                        update otherwise open table shared.
1:      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
1:      *
1:      * @param locking_policy  The LockingPolicy to use to open the conglomerate.
1:      *
1:      * @param isolation_level The isolation level to lock the conglomerate at.
1:      *                        One of (ISOLATION_READ_COMMITTED, 
1:      *                        ISOLATION_REPEATABLE_READ, or 
1:      *                        ISOLATION_SERIALIZABLE).
1:      *
1: 	 * @param scanColumnList  A description of which columns to return from 
1:      *                        every fetch in the scan. fetchRow  
1:      *                        and scanColumnList work together
1:      *                        to describe the row to be returned by the scan - 
1:      *                        see RowUtil for description of how these three 
1:      *                        parameters work together to describe a "row".
1:      *
1:      * @param fetchRow        The row to retrieve the maximum value into.
1:      *
1: 	 * @return boolean indicating if a row was found and retrieved or not.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 
1: 	boolean fetchMaxOnBTree(
1:     TransactionManager      xact_manager,
1:     Transaction             rawtran,
1:     long                    conglomId,
1:     int                     open_mode,
1:     int                     lock_level,
1:     LockingPolicy           locking_policy,
1:     int                     isolation_level,
1:     FormatableBitSet                 scanColumnList,
1:     DataValueDescriptor[]   fetchRow)
1:         throws StandardException;
1: 
1: 
1:     /**
1:      * Get the containerid of conglomerate.
1:      * <p>
1:      * Will have to change when a conglomerate could have more than one 
1:      * containerid.
1:      *
1: 	 * @return The containerid.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     long getContainerid();
1: 
1:     /**
1:      * Get the id of the container of the conglomerate.
1:      * <p>
1:      * Will have to change when a conglomerate could have more than one 
1:      * container.  The ContainerKey is a combination of the container id
1:      * and segment id.
1:      *
1: 	 * @return The ContainerKey.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     ContainerKey getId();
1: 
1:     /**
1:      * Return static information about the conglomerate to be included in a
1:      * a compiled plan.
1:      * <p>
1:      * The static info would be valid until any ddl was executed on the 
1:      * conglomid, and would be up to the caller to throw away when that 
1:      * happened.  This ties in with what language already does for other 
1:      * invalidation of static info.  The type of info in this would be 
1:      * containerid and array of format id's from which templates can be created.
1:      * The info in this object is read only and can be shared among as many 
1:      * threads as necessary.
1:      * <p>
1:      *
1: 	 * @return The static compiled information.
1:      *
1: 	 * @param tc        The TransactionController under which this operation 
1:      *                  takes place.
1:      * @param conglomId The identifier of the conglomerate to open.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(
1:     TransactionController   tc,
1:     long                    conglomId)
1: 		throws StandardException;
1: 
1:     /**
1:      * Return dynamic information about the conglomerate to be dynamically 
1:      * reused in repeated execution of a statement.
1:      * <p>
1:      * The dynamic info is a set of variables to be used in a given 
1:      * ScanController or ConglomerateController.  It can only be used in one 
1:      * controller at a time.  It is up to the caller to insure the correct 
1:      * thread access to this info.  The type of info in this is a scratch 
1:      * template for btree traversal, other scratch variables for qualifier 
1:      * evaluation, ...
1:      * <p>
1:      *
1: 	 * @return The dynamic information.
1:      *
1:      * @param conglomId The identifier of the conglomerate to open.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
0:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo(
0:     long        conglomId)
1: 		throws StandardException;
1: 
1:     /**
1:      * Is this conglomerate temporary?
1:      * <p>
1:      *
1: 	 * @return whether conglomerate is temporary or not.
1:      **/
1:     boolean isTemporary();
1: 
1:     /**
1:      * Bulk load into the conglomerate.
1:      * <p>
1:      * Individual rows that are loaded into the conglomerate are not
1: 	 * logged. After this operation, the underlying database must be backed up
1: 	 * with a database backup rather than an transaction log backup (when we 
1:      * have them). This warning is put here for the benefit of future 
1:      * generation.
1:      * <p>
1: 	 * @param xact_manager  The TransactionController under which this operation
1: 	 *                      takes place.
1:      *
1: 	 * @param createConglom If true, the conglomerate is being created in the 
1:      *                      same operation as the openAndLoadConglomerate.  
1:      *                      The enables further optimization as recovery does
1:      *                      not require page allocation to be logged. 
1:      *
1: 	 * @param rowSource     Where the rows come from.
1:      *
1: 	 * @return The number of rows loaded.
1:      *
1:      * @exception StandardException Standard exception policy.  If 
1:      * conglomerage supports uniqueness checks and has been created to 
1:      * disallow duplicates, and one of the rows being loaded had key columns 
1:      * which were duplicate of a row already in the conglomerate, then 
1:      * raise SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION.
1:      *
1:      **/
1: 	public long load(
1: 	TransactionManager      xact_manager,
1: 	boolean                 createConglom,
1: 	RowLocationRetRowSource rowSource)
1: 		 throws StandardException;
1: 
1: 
1:     /**
1:      * Open a conglomerate controller.
1:      * <p>
1:      *
1: 	 * @return The open ConglomerateController.
1:      *
1:      * @param xact_manager   The access xact to associate all ops on cc with.
1:      * @param rawtran        The raw store xact to associate all ops on cc with.
1:      * @param open_mode      A bit mask of TransactionController.MODE_* bits,
1:      *                       indicating info about the open.
1:      * @param lock_level     Either TransactionController.MODE_TABLE or
1:      *                       TransactionController.MODE_RECORD, as passed into
1:      *                       the openConglomerate() call.
1:      * @param locking_policy The LockingPolicy to use to open the conglomerate.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1:      * @see TransactionController
1:      **/
1: 	ConglomerateController open(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran, 
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     StaticCompiledOpenConglomInfo   static_info,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1: 		throws StandardException;
1: 
1:     /**
1:      * Open a scan controller.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	ScanManager openScan(
1:     TransactionManager              xact_manager,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1:     int                             open_mode,
1:     int                             lock_level,
1:     LockingPolicy                   locking_policy,
1:     int                             isolation_level,
0: 	FormatableBitSet				            scanColumnList,
1:     DataValueDescriptor[]	        startKeyValue,
1:     int                             startSearchOperator,
1:     Qualifier                       qualifier[][],
1:     DataValueDescriptor[]           stopKeyValue,
1:     int                             stopSearchOperator,
1:     StaticCompiledOpenConglomInfo   static_info,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:         throws StandardException;
1: 
1:     /**
1:      * Return an open StoreCostController for the conglomerate.
1:      * <p>
1:      * Return an open StoreCostController which can be used to ask about 
1:      * the estimated row counts and costs of ScanController and 
1:      * ConglomerateController operations, on the given conglomerate.
1:      * <p>
1: 	 * @param xact_manager The TransactionController under which this 
1:      *                     operation takes place.
1: 	 * @param rawtran  raw transaction context in which scan is managed.
1:      *
1: 	 * @return The open StoreCostController.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      *
1:      * @see StoreCostController
1:      **/
1:     StoreCostController openStoreCost(
1:     TransactionManager  xact_manager,
1:     Transaction         rawtran)
1: 		throws StandardException;
1: 
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.access.conglomerate
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.access.conglomerate;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.RowLocationRetRowSource;
0: import org.apache.derby.iapi.store.access.StoreCostController;
0: import org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.raw.ContainerKey;
0: 
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.services.io.Storable;
0: import org.apache.derby.iapi.services.io.FormatableBitSet;
0: 
0: 
0: /**
0: 
0: A conglomerate is an abstract storage structure (they
0: correspond to access methods).  The Conglomerate interface
0: corresponds to a single instance of a conglomerate. In
0: other words, for each conglomerate in the system, there
0: will be one object implementing Conglomerate.
0: <P>
0: The Conglomerate interface is implemented by each access method.
0: The implementation must maintain enough information to properly
0: open the conglomerate and scans, and to drop the conglomerate.
0: This information typically will include the id of the container
0: or containers in which the conglomerate is stored, and my also
0: include property information.
0: <P>
0: Conglomerates are created by a conglomerate factory.  The access
0: manager stores them in a directory (which is why they implement
0: Storable).
0: 
0: **/
0: 
0: public interface Conglomerate extends Storable, DataValueDescriptor
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0:     /**
0:      * Add a column to the conglomerate.
0:      * <p>
0:      * This routine update's the in-memory object version of the 
0:      * Conglomerate to have one more column of the type described by the
0:      * input template column.
0:      *
0:      * Note that not all conglomerates may support this feature.
0:      * 
0: 	 * @param xact_manager     The TransactionController under which this 
0:      *                         operation takes place.
0:      * @param column_id        The column number to add this column at.
0:      * @param template_column  An instance of the column to be added to table.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public void addColumn(
0:     TransactionManager  xact_manager,
0:     int                 column_id,
0:     Storable            template_column)
0:         throws StandardException;
0: 
0:     /**
0:      * Drop this conglomerate.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	void drop(TransactionManager  xact_manager)
0: 		throws StandardException;
0: 
0:     /**
0:      * Retrieve the maximum value row in an ordered conglomerate.
0:      * <p>
0:      * Returns true and fetches the rightmost row of an ordered conglomerate 
0:      * into "fetchRow" if there is at least one row in the conglomerate.  If
0:      * there are no rows in the conglomerate it returns false.
0:      * <p>
0:      * Non-ordered conglomerates will not implement this interface, calls
0:      * will generate a StandardException.
0:      * <p>
0:      * RESOLVE - this interface is temporary, long term equivalent (and more) 
0:      * functionality will be provided by the openBackwardScan() interface.  
0:      *
0: 	 * @param xact_manager    The TransactionController under which this 
0:      *                        operation takes place.
0:      *
0:      * @param rawtran         The raw store xact to associate all ops with.
0:      *
0: 	 * @param conglomId       The identifier of the conglomerate
0: 	 *                        to open the scan for.
0:      *
0: 	 * @param open_mode       Specifiy flags to control opening of table.  
0:      *                        OPENMODE_FORUPDATE - if set open the table for
0:      *                        update otherwise open table shared.
0:      * @param lock_level      One of (MODE_TABLE, MODE_RECORD, or MODE_NONE).
0:      *
0:      * @param locking_policy  The LockingPolicy to use to open the conglomerate.
0:      *
0:      * @param isolation_level The isolation level to lock the conglomerate at.
0:      *                        One of (ISOLATION_READ_COMMITTED, 
0:      *                        ISOLATION_REPEATABLE_READ, or 
0:      *                        ISOLATION_SERIALIZABLE).
0:      *
0: 	 * @param scanColumnList  A description of which columns to return from 
0:      *                        every fetch in the scan. fetchRow  
0:      *                        and scanColumnList work together
0:      *                        to describe the row to be returned by the scan - 
0:      *                        see RowUtil for description of how these three 
0:      *                        parameters work together to describe a "row".
0:      *
0:      * @param fetchRow        The row to retrieve the maximum value into.
0:      *
0: 	 * @return boolean indicating if a row was found and retrieved or not.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 
0: 	boolean fetchMaxOnBTree(
0:     TransactionManager      xact_manager,
0:     Transaction             rawtran,
0:     long                    conglomId,
0:     int                     open_mode,
0:     int                     lock_level,
0:     LockingPolicy           locking_policy,
0:     int                     isolation_level,
0:     FormatableBitSet                 scanColumnList,
0:     DataValueDescriptor[]   fetchRow)
0:         throws StandardException;
0: 
0: 
0:     /**
0:      * Get the containerid of conglomerate.
0:      * <p>
0:      * Will have to change when a conglomerate could have more than one 
0:      * containerid.
0:      *
0: 	 * @return The containerid.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     long getContainerid();
0: 
0:     /**
0:      * Get the id of the container of the conglomerate.
0:      * <p>
0:      * Will have to change when a conglomerate could have more than one 
0:      * container.  The ContainerKey is a combination of the container id
0:      * and segment id.
0:      *
0: 	 * @return The ContainerKey.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     ContainerKey getId();
0: 
0:     /**
0:      * Return static information about the conglomerate to be included in a
0:      * a compiled plan.
0:      * <p>
0:      * The static info would be valid until any ddl was executed on the 
0:      * conglomid, and would be up to the caller to throw away when that 
0:      * happened.  This ties in with what language already does for other 
0:      * invalidation of static info.  The type of info in this would be 
0:      * containerid and array of format id's from which templates can be created.
0:      * The info in this object is read only and can be shared among as many 
0:      * threads as necessary.
0:      * <p>
0:      *
0: 	 * @return The static compiled information.
0:      *
0: 	 * @param tc        The TransactionController under which this operation 
0:      *                  takes place.
0:      * @param conglomId The identifier of the conglomerate to open.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public StaticCompiledOpenConglomInfo getStaticCompiledConglomInfo(
0:     TransactionController   tc,
0:     long                    conglomId)
0: 		throws StandardException;
0: 
0:     /**
0:      * Return dynamic information about the conglomerate to be dynamically 
0:      * reused in repeated execution of a statement.
0:      * <p>
0:      * The dynamic info is a set of variables to be used in a given 
0:      * ScanController or ConglomerateController.  It can only be used in one 
0:      * controller at a time.  It is up to the caller to insure the correct 
0:      * thread access to this info.  The type of info in this is a scratch 
0:      * template for btree traversal, other scratch variables for qualifier 
0:      * evaluation, ...
0:      * <p>
0:      *
0: 	 * @return The dynamic information.
0:      *
0:      * @param conglomId The identifier of the conglomerate to open.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public DynamicCompiledOpenConglomInfo getDynamicCompiledConglomInfo(
0:     long        conglomId)
0: 		throws StandardException;
0: 
0:     /**
0:      * Is this conglomerate temporary?
0:      * <p>
0:      *
0: 	 * @return whether conglomerate is temporary or not.
0:      **/
0:     boolean isTemporary();
0: 
0:     /**
0:      * Bulk load into the conglomerate.
0:      * <p>
0:      * Individual rows that are loaded into the conglomerate are not
0: 	 * logged. After this operation, the underlying database must be backed up
0: 	 * with a database backup rather than an transaction log backup (when we 
0:      * have them). This warning is put here for the benefit of future 
0:      * generation.
0:      * <p>
0: 	 * @param xact_manager  The TransactionController under which this operation
0: 	 *                      takes place.
0:      *
0: 	 * @param createConglom If true, the conglomerate is being created in the 
0:      *                      same operation as the openAndLoadConglomerate.  
0:      *                      The enables further optimization as recovery does
0:      *                      not require page allocation to be logged. 
0:      *
0: 	 * @param rowSource     Where the rows come from.
0:      *
0: 	 * @return The number of rows loaded.
0:      *
0:      * @exception StandardException Standard exception policy.  If 
0:      * conglomerage supports uniqueness checks and has been created to 
0:      * disallow duplicates, and one of the rows being loaded had key columns 
0:      * which were duplicate of a row already in the conglomerate, then 
0:      * raise SQLState.STORE_CONGLOMERATE_DUPLICATE_KEY_EXCEPTION.
0:      *
0:      **/
0: 	public long load(
0: 	TransactionManager      xact_manager,
0: 	boolean                 createConglom,
0: 	RowLocationRetRowSource rowSource)
0: 		 throws StandardException;
0: 
0: 
0:     /**
0:      * Open a conglomerate controller.
0:      * <p>
0:      *
0: 	 * @return The open ConglomerateController.
0:      *
0:      * @param xact_manager   The access xact to associate all ops on cc with.
0:      * @param rawtran        The raw store xact to associate all ops on cc with.
0:      * @param open_mode      A bit mask of TransactionController.MODE_* bits,
0:      *                       indicating info about the open.
0:      * @param lock_level     Either TransactionController.MODE_TABLE or
0:      *                       TransactionController.MODE_RECORD, as passed into
0:      *                       the openConglomerate() call.
0:      * @param locking_policy The LockingPolicy to use to open the conglomerate.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0:      * @see TransactionController
0:      **/
0: 	ConglomerateController open(
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran, 
0:     boolean                         hold,
0:     int                             open_mode,
0:     int                             lock_level,
0:     LockingPolicy                   locking_policy,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0: 		throws StandardException;
0: 
0:     /**
0:      * Open a scan controller.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	ScanManager openScan(
0:     TransactionManager              xact_manager,
0:     Transaction                     rawtran,
0:     boolean                         hold,
0:     int                             open_mode,
0:     int                             lock_level,
0:     LockingPolicy                   locking_policy,
0:     int                             isolation_level,
0: 	FormatableBitSet				            scanColumnList,
0:     DataValueDescriptor[]	        startKeyValue,
0:     int                             startSearchOperator,
0:     Qualifier                       qualifier[][],
0:     DataValueDescriptor[]           stopKeyValue,
0:     int                             stopSearchOperator,
0:     StaticCompiledOpenConglomInfo   static_info,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0:         throws StandardException;
0: 
0:     /**
0:      * Return an open StoreCostController for the conglomerate.
0:      * <p>
0:      * Return an open StoreCostController which can be used to ask about 
0:      * the estimated row counts and costs of ScanController and 
0:      * ConglomerateController operations, on the given conglomerate.
0:      * <p>
0: 	 * @param xact_manager The TransactionController under which this 
0:      *                     operation takes place.
0: 	 * @param rawtran  raw transaction context in which scan is managed.
0:      *
0: 	 * @return The open StoreCostController.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      *
0:      * @see StoreCostController
0:      **/
0:     StoreCostController openStoreCost(
0:     TransactionManager  xact_manager,
0:     Transaction         rawtran)
0: 		throws StandardException;
0: 
0: }
============================================================================