1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.services.jce.JCECipherFactory
1:345de35: 
1:93fea34:    Licensed to the Apache Software Foundation (ASF) under one or more
1:93fea34:    contributor license agreements.  See the NOTICE file distributed with
1:93fea34:    this work for additional information regarding copyright ownership.
1:93fea34:    The ASF licenses this file to you under the Apache License, Version 2.0
1:93fea34:    (the "License"); you may not use this file except in compliance with
1:93fea34:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
11:eac0369: 
1:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.services.jce;
1:eac0369: 
1:b1008f3: import org.apache.derby.iapi.security.SecurityUtil;
1:eac0369: import org.apache.derby.iapi.services.crypto.CipherFactory;
1:eac0369: import org.apache.derby.iapi.services.crypto.CipherProvider;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.reference.Attribute;
2:eac0369: import org.apache.derby.iapi.util.StringUtil;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:ae71c74: import java.util.Enumeration;
1:9b8c04f: import java.security.AccessController;
1:9b8c04f: import java.security.PrivilegedAction;
1:9b8c04f: import java.security.PrivilegedExceptionAction;
1:eac0369: import java.security.Provider;
1:eac0369: import java.security.SecureRandom;
1:eac0369: import java.security.Security;
1:eac0369: import java.security.InvalidKeyException;
1:eac0369: import java.security.NoSuchAlgorithmException;
1:eac0369: import java.security.MessageDigest;
1:eac0369: import java.io.FileNotFoundException;
1:eac0369: import java.io.IOException;
1:97cac2e: import java.io.InputStream;
1:97cac2e: import java.io.DataInputStream;
1:eac0369: 
1:eac0369: import javax.crypto.KeyGenerator;
1:eac0369: import javax.crypto.SecretKey;
1:eac0369: import javax.crypto.spec.DESKeySpec;
1:eac0369: import javax.crypto.spec.SecretKeySpec;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: 
1:eac0369: import org.apache.derby.io.StorageFactory;
1:eac0369: import org.apache.derby.io.StorageFile;
1:eac0369: import org.apache.derby.io.StorageRandomAccessFile;
2:eac0369: /**
1:eac0369: 	This CipherFactory creates new JCECipherProvider.
1:eac0369: 
1:eac0369: 	@see CipherFactory
1:eac0369:  */
1:b1008f3: final class JCECipherFactory implements CipherFactory
1:eac0369: {
1:eac0369:     private final static String MESSAGE_DIGEST = "MD5";
1:eac0369: 
1:eac0369: 	private final static String DEFAULT_ALGORITHM = "DES/CBC/NoPadding";
1:eac0369: 	private final static String DES = "DES";
1:eac0369: 	private final static String DESede = "DESede";
1:eac0369:     private final static String TripleDES = "TripleDES";
1:eac0369:     private final static String AES = "AES";
1:eac0369: 
1:eac0369:     // minimum boot password length in bytes
1:eac0369:     private final static int BLOCK_LENGTH = 8;
1:eac0369: 
1:eac0369:     /**
1:eac0369: 	AES encryption takes in an default Initialization vector length (IV) length of 16 bytes
1:eac0369: 	This is needed to generate an IV to use for encryption and decryption process 
1:eac0369: 	@see CipherProvider
1:eac0369:      */
1:eac0369:     private final static int AES_IV_LENGTH = 16;
1:eac0369: 
1:eac0369:     // key length in bytes
1:eac0369: 	private int keyLengthBits;
1:eac0369:     private int encodedKeyLength;
1:eac0369:     private String cryptoAlgorithm;
1:eac0369:     private String cryptoAlgorithmShort;
1:eac0369:     private String cryptoProvider;
1:eac0369:     private String cryptoProviderShort;
1:eac0369: 	private MessageDigest messageDigest;
1:eac0369: 
1:eac0369: 	private SecretKey mainSecretKey;
1:eac0369: 	private byte[] mainIV;
1:eac0369: 
1:ae71c74:     // properties that needs to be stored in the
1:ae71c74:     // in the service.properties file.
1:ae71c74:     private Properties persistentProperties;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	    Amount of data that is used for verification of external encryption key
1:eac0369: 	    This does not include the MD5 checksum bytes
1:eac0369: 	 */
1:eac0369: 	private final static int VERIFYKEY_DATALEN = 4096;
1:eac0369: 
1:eac0369: 
1:8a62d60:     /*
1:8a62d60:      * Constructor of JCECipherFactory, initializes the new instances.
1:8a62d60:      *
1:8a62d60:      * @param create    true, if the database is getting configured 
1:8a62d60:      *                  for encryption.
1:8a62d60:      * @param props	    encryption properties/attributes to use
1:8a62d60:      *                  for creating the cipher factory.
1:8a62d60:      * @param newAttrs  true, if cipher factory has to be created using 
1:8a62d60:      *                  should using the new attributes specified by the user.  
1:8a62d60:      *                  For example to reencrypt the database with 
1:8a62d60:      *                  a new password.
1:eac0369:      */
1:b1008f3:     JCECipherFactory(boolean create, 
1:8a62d60:                             Properties props,
1:8a62d60:                             boolean newAttributes) 
1:8a62d60:         throws StandardException
1:97cac2e:     {
1:b1008f3:         // Verify that we have permission to execute this method.
1:b1008f3:         SecurityUtil.checkDerbyInternalsPrivilege();
1:b1008f3: 
1:8a62d60:         init(create, props, newAttributes);
4:eac0369:     }
1:eac0369:     
1:eac0369: 
1:eac0369: 
1:eac0369: 	static String providerErrorName(String cps) {
1:eac0369: 
1:eac0369: 		return cps == null ? "default" : cps;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private byte[] generateUniqueBytes() throws StandardException
1:eac0369: 	{
3:eac0369: 		try {
1:eac0369: 
1:eac0369: 			String provider = cryptoProviderShort;
1:eac0369: 
1:eac0369: 			KeyGenerator keyGen;
1:eac0369: 			if (provider == null)
1:eac0369: 			{
1:eac0369: 				keyGen = KeyGenerator.getInstance(cryptoAlgorithmShort);
1:eac0369: 			}
3:eac0369: 			else
1:eac0369: 			{
1:eac0369: 				if( provider.equals("BouncyCastleProvider"))
1:eac0369: 					provider = "BC";
1:eac0369: 				keyGen = KeyGenerator.getInstance(cryptoAlgorithmShort, provider);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			keyGen.init(keyLengthBits);
1:eac0369: 
1:eac0369: 			SecretKey key = keyGen.generateKey();
1:eac0369: 
1:eac0369: 			return key.getEncoded();
1:eac0369: 
1:eac0369: 		} catch (java.security.NoSuchAlgorithmException nsae) {
1:eac0369:     		throw StandardException.newException(SQLState.ENCRYPTION_NOSUCH_ALGORITHM, cryptoAlgorithm,
1:eac0369: 				JCECipherFactory.providerErrorName(cryptoProviderShort));
1:eac0369: 		} catch (java.security.NoSuchProviderException nspe) {
1:eac0369: 			throw StandardException.newException(SQLState.ENCRYPTION_BAD_PROVIDER,
1:eac0369: 				JCECipherFactory.providerErrorName(cryptoProviderShort));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Encrypt the secretKey with the boot password.
1:eac0369: 		This includes the following steps, 
1:eac0369: 		getting muck from the boot password and then using this to generate a key,
1:eac0369: 		generating an appropriate IV using the muck
1:eac0369: 		using the key and IV thus generated to create the appropriate cipher provider
1:eac0369: 		and encrypting the secretKey 
1:eac0369: 		@return hexadecimal string of the encrypted secretKey
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:9d7aba6: 	private EncryptedKeyResult encryptKey(byte[] secretKey, byte[] bootPassword)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		// In case of AES, care needs to be taken to allow for 16 bytes muck as well
1:eac0369: 		// as to have the secretKey that needs encryption to be a aligned appropriately
1:eac0369: 		// AES supports 16 bytes block size
1:eac0369: 
1:eac0369: 		int muckLength = secretKey.length;
1:eac0369: 		if(cryptoAlgorithmShort.equals(AES))
1:eac0369: 			muckLength = AES_IV_LENGTH;		
1:eac0369: 
1:eac0369: 		byte[] muck = getMuckFromBootPassword(bootPassword, muckLength);
1:eac0369: 		SecretKey key = generateKey(muck);
1:eac0369: 		byte[] IV = generateIV(muck);
1:eac0369:                 CipherProvider tmpCipherProvider = createNewCipher(ENCRYPT,key,IV);
1:eac0369: 		
1:eac0369: 		// store the actual secretKey.length before any possible padding  
1:eac0369: 		encodedKeyLength = secretKey.length;
1:eac0369: 
1:eac0369: 		// for the secretKey to be encrypted, first ensure that it is aligned to the block size of the 
1:eac0369: 		// encryption algorithm by padding bytes appropriately if needed
1:eac0369:                 secretKey = padKey(secretKey,tmpCipherProvider.getEncryptionBlockSize());
1:eac0369: 
1:eac0369:                 byte[] result = new byte[secretKey.length];
1:eac0369: 
1:eac0369: 		// encrypt the secretKey using the key generated of muck from  boot password and the generated IV  
1:eac0369: 		tmpCipherProvider.encrypt(secretKey, 0, secretKey.length, result, 0);
1:eac0369: 
1:9d7aba6: 		String hexOutput = org.apache.derby.iapi.util.StringUtil.toHexString(result, 0, result.length);
1:9d7aba6: 
1:9d7aba6:         return new EncryptedKeyResult( hexOutput, secretKey );
1:eac0369: 
1:eac0369: 	}
1:eac0369: 	
1:eac0369: 	/**
1:eac0369:             For block ciphers, and  algorithms using the NoPadding scheme, the data that has 
1:eac0369:             to be encrypted needs to be a multiple of the expected block size for the cipher 
1:eac0369: 	    Pad the key with appropriate padding to make it blockSize align
1:eac0369: 	    @param     secretKey	the data that needs blocksize alignment
1:eac0369: 	    @param     blockSizeAlign   secretKey needs to be blocksize aligned		
1:eac0369: 	    @return    a byte array with the contents of secretKey along with padded bytes in the end
1:eac0369: 		       to make it blockSize aligned
1:eac0369:          */
1:eac0369: 	private byte[] padKey(byte[] secretKey,int blockSizeAlign)
1:eac0369: 	{
1:eac0369: 	    byte [] result = secretKey;
1:eac0369: 	    if(secretKey.length % blockSizeAlign != 0 )
1:eac0369: 	    {
1:eac0369: 		int encryptedLength = secretKey.length + blockSizeAlign - (secretKey.length % blockSizeAlign);
1:eac0369: 		result = new byte[encryptedLength];
1:eac0369: 		System.arraycopy(secretKey,0,result,0,secretKey.length);
1:eac0369: 	    }
1:eac0369: 	    return result;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	    Decrypt the secretKey with the user key .
1:eac0369: 	    This includes the following steps, 
1:eac0369: 	    retrieve the encryptedKey, generate the muck from the boot password and generate an appropriate IV using
1:eac0369: 	    the muck,and using the key and IV decrypt the encryptedKey 
1:eac0369: 	    @return decrypted key  
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	 */
1:eac0369: 	private byte[] decryptKey(String encryptedKey, int encodedKeyCharLength, byte[] bootPassword)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		byte[] secretKey = org.apache.derby.iapi.util.StringUtil.fromHexString(encryptedKey, 0, encodedKeyCharLength);
1:eac0369: 		// In case of AES, care needs to be taken to allow for 16 bytes muck as well
1:eac0369: 		// as to have the secretKey that needs encryption to be a aligned appropriately
1:eac0369: 		// AES supports 16 bytes block size
1:eac0369: 		int muckLength;
1:eac0369: 		if(cryptoAlgorithmShort.equals(AES))
1:eac0369: 		    muckLength = AES_IV_LENGTH;
1:eac0369: 		else
1:eac0369: 	            muckLength = secretKey.length;	
1:eac0369: 
1:eac0369: 		byte[] muck = getMuckFromBootPassword(bootPassword, muckLength);
1:eac0369: 
1:eac0369: 
1:eac0369: 		// decrypt the encryptedKey with the mucked up boot password to recover
1:eac0369: 		// the secretKey
1:eac0369: 		SecretKey key = generateKey(muck);
1:eac0369: 		byte[] IV = generateIV(muck);
1:eac0369: 
1:eac0369: 
1:eac0369: 		createNewCipher(DECRYPT, key, IV).
1:eac0369: 			decrypt(secretKey, 0, secretKey.length, secretKey, 0);
1:eac0369: 
1:eac0369: 		return secretKey;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private byte[] getMuckFromBootPassword(byte[] bootPassword, int encodedKeyByteLength) {
1:eac0369: 		int ulength = bootPassword.length;
1:eac0369: 
1:eac0369: 		byte[] muck = new byte[encodedKeyByteLength];
1:eac0369: 		
1:eac0369: 
1:eac0369: 		int rotation = 0;
1:eac0369: 		for (int i = 0; i < bootPassword.length; i++)
1:eac0369: 			rotation += bootPassword[i];
1:eac0369: 
1:eac0369: 		for (int i = 0; i < encodedKeyByteLength; i++)
1:eac0369: 			muck[i] = (byte)(bootPassword[(i+rotation)%ulength] ^
1:eac0369:                 (bootPassword[i%ulength] << 4));
1:eac0369: 
1:eac0369: 		return muck;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Generate a Key object using the input secretKey that can be used by
1:eac0369: 		JCECipherProvider to encrypt or decrypt.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby Error Policy
1:eac0369: 	 */
1:eac0369: 	private SecretKey generateKey(byte[] secretKey) throws StandardException
1:eac0369: 	{
1:eac0369: 		int length = secretKey.length;
1:eac0369: 
1:eac0369: 		if (length < CipherFactory.MIN_BOOTPASS_LENGTH)
1:ce40a31: 			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH, MIN_BOOTPASS_LENGTH);
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369:             if (cryptoAlgorithmShort.equals(DES))
1:eac0369:             {   // single DES
1:eac0369: 			    if (DESKeySpec.isWeak(secretKey, 0))
1:eac0369: 			    {
1:eac0369: 				    // OK, it is weak, spice it up
1:eac0369: 				    byte[] spice = StringUtil.getAsciiBytes("louDScap");
1:eac0369: 				    for (int i = 0; i < 7; i++)
1:eac0369: 					    secretKey[i] = (byte)((spice[i] << 3) ^ secretKey[i]);
1:eac0369: 			    }
1:eac0369:             }
1:eac0369: 			return new SecretKeySpec(secretKey, cryptoAlgorithmShort);
1:eac0369: 		}
1:eac0369: 		catch (InvalidKeyException ike)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Generate an IV using the input secretKey that can be used by
1:eac0369: 		JCECipherProvider to encrypt or decrypt.
1:eac0369: 	 */
1:eac0369: 	private byte[] generateIV(byte[] secretKey)
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		// do a little simple minded muddling to make the IV not
1:eac0369: 		// strictly alphanumeric and the number of total possible keys a little
1:eac0369: 		// bigger.
1:eac0369: 		int IVlen = BLOCK_LENGTH;
1:49aa62a: 
1:eac0369: 		byte[] iv = null;
1:eac0369: 		if(cryptoAlgorithmShort.equals(AES))
1:eac0369: 		{
1:eac0369: 			IVlen = AES_IV_LENGTH;
1:eac0369: 			iv = new byte[IVlen];
1:eac0369: 			iv[0] = (byte)(((secretKey[secretKey.length-1] << 2) | 0xF) ^ secretKey[0]);
1:eac0369: 			for (int i = 1; i < BLOCK_LENGTH; i++)
1:eac0369: 				iv[i] = (byte)(((secretKey[i-1] << (i%5)) | 0xF) ^ secretKey[i]);
1:eac0369: 			
1:eac0369: 			for(int i = BLOCK_LENGTH ; i < AES_IV_LENGTH ; i++)
1:eac0369: 			{
1:eac0369: 				iv[i]=iv[i-BLOCK_LENGTH];
1:eac0369: 			}
1:eac0369: 			
1:eac0369: 		}	
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			iv = new byte[BLOCK_LENGTH];
1:eac0369: 			iv[0] = (byte)(((secretKey[secretKey.length-1] << 2) | 0xF) ^ secretKey[0]);
1:eac0369: 			for (int i = 1; i < BLOCK_LENGTH; i++)
1:eac0369: 				iv[i] = (byte)(((secretKey[i-1] << (i%5)) | 0xF) ^ secretKey[i]);	
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return iv;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private int digest(byte[] input)
1:eac0369: 	{
1:eac0369: 		messageDigest.reset();
1:eac0369: 		byte[] digest = messageDigest.digest(input);
1:eac0369: 		byte[] condenseDigest = new byte[2];
1:eac0369: 
1:eac0369: 		// no matter how long the digest is, condense it into an short.
1:eac0369: 		for (int i = 0; i < digest.length; i++)
1:eac0369: 			condenseDigest[i%2] ^= digest[i];
1:eac0369: 
1:eac0369: 		int retval = (condenseDigest[0] & 0xFF) | ((condenseDigest[1] << 8) & 0xFF00);
1:eac0369: 
1:eac0369: 		return retval;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public SecureRandom getSecureRandom() {
1:eac0369: 		return new SecureRandom(mainIV);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public CipherProvider createNewCipher(int mode)
1:eac0369: 										  throws StandardException {
1:eac0369: 		return createNewCipher(mode, mainSecretKey, mainIV);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	private CipherProvider createNewCipher(int mode, SecretKey secretKey,
1:eac0369: 										  byte[] iv)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		return new JCECipherProvider(mode, secretKey, iv, cryptoAlgorithm, cryptoProviderShort);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369:     /*
1:8a62d60:      * Initilize the new instance of this class. 
1:eac0369:      */
1:d466c80:     private void init(boolean create, Properties properties, boolean newAttrs)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369:         boolean provider_or_algo_specified = false;
1:eac0369: 		boolean storeProperties = create;
1:ae71c74:         persistentProperties = new Properties();
1:eac0369: 
1:8a62d60:         // get the external key specified by the user to 
1:8a62d60:         // encrypt the database. If user is reencrypting the
1:8a62d60:         // database with a new encryption key,  read the value of 
1:8a62d60:         // the new encryption key. 
1:8a62d60:         String externalKey =  properties.getProperty((newAttrs ? 
1:8a62d60:                                                       Attribute.NEW_CRYPTO_EXTERNAL_KEY:
1:8a62d60:                                                       Attribute.CRYPTO_EXTERNAL_KEY));
1:eac0369: 		if (externalKey != null) {
1:eac0369: 			storeProperties = false;
1:eac0369: 		}
1:eac0369: 
1:eac0369:         cryptoProvider = properties.getProperty(Attribute.CRYPTO_PROVIDER);
1:eac0369: 
1:f12802f: 		if (cryptoProvider != null)
1:eac0369: 		{
1:eac0369:             provider_or_algo_specified = true;
1:eac0369: 
1:eac0369: 			// explictly putting the properties back into the properties
1:eac0369: 			// saves then in service.properties at create time.
1:eac0369: 		//	if (storeProperties)
1:eac0369: 		//		properties.put(Attribute.CRYPTO_PROVIDER, cryptoProvider);
1:eac0369: 
1:eac0369: 			int dotPos = cryptoProvider.lastIndexOf('.');
1:eac0369: 			if (dotPos == -1)
1:eac0369: 				cryptoProviderShort = cryptoProvider;
1:eac0369: 			else
1:eac0369: 				cryptoProviderShort = cryptoProvider.substring(dotPos+1);
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369:         cryptoAlgorithm = properties.getProperty(Attribute.CRYPTO_ALGORITHM);
1:eac0369:         if (cryptoAlgorithm == null)
1:eac0369:             cryptoAlgorithm = DEFAULT_ALGORITHM;
1:eac0369:         else {
1:eac0369:             provider_or_algo_specified = true;
1:eac0369: 
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// explictly putting the properties back into the properties
1:eac0369: 		// saves then in service.properties at create time.
1:eac0369:         if (storeProperties)
1:ae71c74: 			persistentProperties.put(Attribute.CRYPTO_ALGORITHM, 
1:ae71c74:                                      cryptoAlgorithm);
1:eac0369: 
1:eac0369:         int firstSlashPos = cryptoAlgorithm.indexOf('/');
1:eac0369:         int lastSlashPos = cryptoAlgorithm.lastIndexOf('/');
1:eac0369:         if (firstSlashPos < 0 || lastSlashPos < 0 || firstSlashPos == lastSlashPos)
1:eac0369:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_ALG_FORMAT, cryptoAlgorithm);
1:eac0369: 
1:eac0369:         cryptoAlgorithmShort = cryptoAlgorithm.substring(0,firstSlashPos);
1:eac0369: 
1:eac0369:         if (provider_or_algo_specified)
1:eac0369:         {
1:eac0369:             // Track 3715 - disable use of provider/aglo specification if
1:eac0369:             // jce environment is not 1.2.1.  The ExemptionMechanism class
1:eac0369:             // exists in jce1.2.1 and not in jce1.2, so try and load the
1:eac0369:             // class and if you can't find it don't allow the encryption.
1:94f158a:             // This is a requirement from the government to give Cloudscape
1:eac0369:             // export clearance for 3.6.  Note that the check is not needed
1:eac0369:             // if no provider/algo is specified, in that case we default to
1:eac0369:             // a DES weak encryption algorithm which also is allowed for
1:eac0369:             // export (this is how 3.5 got it's clearance).
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 Class c = Class.forName("javax.crypto.ExemptionMechanism");
1:eac0369:             }
1:eac0369:             catch (Throwable t)
1:eac0369:             {
1:eac0369:                 throw StandardException.newException(
1:eac0369:                             SQLState.ENCRYPTION_BAD_JCE);
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// If connecting to an existing database and Attribute.CRYPTO_KEY_LENGTH is set
1:eac0369: 		// then obtain the encoded key length values without padding bytes and retrieve
1:eac0369: 		// the keylength in bits if boot password mechanism is used 
1:eac0369: 		// note: Attribute.CRYPTO_KEY_LENGTH is set during creation time to a supported
1:eac0369: 		// key length in the connection url. Internally , two values are stored in this property
1:eac0369: 		// if encryptionKey is used, this property will have only the encoded key length
1:eac0369: 		// if boot password mechanism is used, this property will have the following 
1:eac0369: 		// keylengthBits-EncodedKeyLength 
1:eac0369:                  
1:eac0369: 		if(!create)
1:eac0369: 		{
1:eac0369: 		    // if available, parse the keylengths stored in Attribute.CRYPTO_KEY_LENGTH 
1:eac0369: 		    if(properties.getProperty(Attribute.CRYPTO_KEY_LENGTH) != null)
1:eac0369: 		    {
1:eac0369: 			String keyLengths = properties.getProperty(Attribute.CRYPTO_KEY_LENGTH);
1:eac0369: 		 	int pos = keyLengths.lastIndexOf('-');
1:eac0369: 			encodedKeyLength = Integer.parseInt(keyLengths.substring(pos+1)); 
1:eac0369: 			if(pos != -1)
1:eac0369: 			   keyLengthBits = Integer.parseInt(keyLengths.substring(0,pos));
1:eac0369: 		    }
1:eac0369: 		}
1:eac0369: 			
1:eac0369: 
1:eac0369: 		// case 1 - if 'encryptionKey' is not set and 'encryptionKeyLength' is set, then use
1:eac0369: 		// the 'encryptionKeyLength' property value  as the keyLength in bits.
1:eac0369: 		// case 2 - 'encryptionKey' property is not set and 'encryptionKeyLength' is not set, then
1:eac0369: 		// use the defaults keylength:  56bits for DES, 168 for DESede and 128 for any other encryption
1:eac0369: 		// algorithm
1:eac0369: 
1:eac0369: 		if (externalKey == null && create) {
1:eac0369: 			if(properties.getProperty(Attribute.CRYPTO_KEY_LENGTH) != null)
1:eac0369: 			{
1:eac0369: 				keyLengthBits = Integer.parseInt(properties.getProperty(Attribute.CRYPTO_KEY_LENGTH));
1:eac0369: 			}
1:eac0369: 			else if (cryptoAlgorithmShort.equals(DES)) {
1:eac0369: 				keyLengthBits = 56;
1:eac0369: 			} else if (cryptoAlgorithmShort.equals(DESede) || cryptoAlgorithmShort.equals(TripleDES)) {
1:eac0369: 				keyLengthBits = 168;
1:eac0369: 
1:eac0369: 			} else {
1:eac0369: 				keyLengthBits = 128;
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 
1:eac0369:         // check the feedback mode
1:eac0369:         String feedbackMode = cryptoAlgorithm.substring(firstSlashPos+1,lastSlashPos);
1:eac0369: 
1:eac0369:         if (!feedbackMode.equals("CBC") && !feedbackMode.equals("CFB") &&
1:eac0369:             !feedbackMode.equals("ECB") && !feedbackMode.equals("OFB"))
1:eac0369:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_FEEDBACKMODE, feedbackMode);
1:eac0369: 
1:eac0369:         // check the NoPadding mode is used
1:eac0369:         String padding = cryptoAlgorithm.substring(lastSlashPos+1,cryptoAlgorithm.length());
1:eac0369:         if (!padding.equals("NoPadding"))
1:eac0369:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_PADDING, padding);
1:eac0369: 
1:eac0369: 		Throwable t;
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			if (cryptoProvider != null) {
1:eac0369: 				// provider package should be set by property
1:eac0369: 				if (Security.getProvider(cryptoProviderShort) == null)
1:eac0369: 				{
1:4469400:                     Class<?> cryptoClass = Class.forName(cryptoProvider);
1:9b8c04f:                     if (!Provider.class.isAssignableFrom(cryptoClass)) {
1:9b8c04f:                         throw StandardException.newException(
1:9b8c04f:                                 SQLState.ENCRYPTION_NOT_A_PROVIDER,
1:9b8c04f:                                 cryptoProvider);
1:9b8c04f:                     }
1:9b8c04f: 
1:4469400:                     java.lang.reflect.Constructor<?> constructor = cryptoClass.getConstructor();
1:4469400:                     final Provider provider = (Provider) constructor.newInstance();
1:9b8c04f: 
1:eac0369: 					// add provider through privileged block.
1:9b8c04f:                     AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:9b8c04f:                         @Override
1:9b8c04f:                         public Void run() {
1:9b8c04f:                             Security.addProvider(provider);
1:9b8c04f:                             return null;
1:9b8c04f:                         }
1:9b8c04f:                     });
1:eac0369: 				}
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// need this to check the boot password
1:eac0369: 			messageDigest = MessageDigest.getInstance(MESSAGE_DIGEST);
1:eac0369: 
1:eac0369: 			byte[] generatedKey;
1:eac0369: 			if (externalKey != null) {
1:eac0369: 
1:eac0369: 				// incorrect to specify external key and boot password
1:8a62d60: 				if (properties.getProperty((newAttrs ? 
1:8a62d60:                                             Attribute.NEW_BOOT_PASSWORD :
1:8a62d60:                                             Attribute.BOOT_PASSWORD)) != null)
1:eac0369: 					throw StandardException.newException(SQLState.SERVICE_WRONG_BOOT_PASSWORD);
1:eac0369: 
1:8a62d60: 				generatedKey = 
1:8a62d60:                     org.apache.derby.iapi.util.StringUtil.fromHexString(externalKey, 
1:8a62d60:                                                                         0, 
1:8a62d60:                                                                         externalKey.length());
1:8e896c5:                 if (generatedKey == null) {
1:8e896c5:                     throw StandardException.newException(
1:8e896c5:                         // If length is even, we assume invalid character(s),
1:8e896c5:                         // based on how 'fromHexString' behaves.
1:8e896c5:                         externalKey.length() % 2 == 0 
1:8e896c5:                             ? SQLState.ENCRYPTION_ILLEGAL_EXKEY_CHARS
1:8e896c5:                             : SQLState.ENCRYPTION_INVALID_EXKEY_LENGTH);
1:8e896c5:                 }
1:eac0369: 
1:eac0369: 			} else {
1:eac0369: 
1:8a62d60: 				generatedKey = handleBootPassword(create, properties, newAttrs);
1:8a62d60: 				if(create || newAttrs)
1:ae71c74: 				   persistentProperties.put(Attribute.CRYPTO_KEY_LENGTH,
1:ae71c74:                                             keyLengthBits+"-"+generatedKey.length);
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			// Make a key and IV object out of the generated key
1:eac0369: 			mainSecretKey = generateKey(generatedKey);
1:eac0369: 			mainIV = generateIV(generatedKey);
1:eac0369: 
2:eac0369: 			if (create)
1:eac0369: 			{
1:ae71c74: 				persistentProperties.put(Attribute.DATA_ENCRYPTION, "true");
1:eac0369: 
1:eac0369: 				// Set two new properties to allow for future changes to the log and data encryption
1:eac0369: 				// schemes. This property is introduced in version 10 , value starts at 1.
1:ae71c74: 				persistentProperties.put(RawStoreFactory.DATA_ENCRYPT_ALGORITHM_VERSION,
1:ae71c74:                                                String.valueOf(1));
1:ae71c74: 				persistentProperties.put(RawStoreFactory.LOG_ENCRYPT_ALGORITHM_VERSION,
1:ae71c74:                                                String.valueOf(1));
1:eac0369: 			}
1:eac0369: 
1:eac0369: 			return;
1:eac0369: 		}
1:9b8c04f:         catch (ClassNotFoundException cnfe)
1:9b8c04f:         {
1:9b8c04f:             t = StandardException.newException(
1:9b8c04f:                     SQLState.ENCRYPTION_NO_PROVIDER_CLASS,
1:9b8c04f:                     cnfe,
1:9b8c04f:                     cryptoProvider);
1:9b8c04f:         }
1:9b8c04f:         catch (InstantiationException ie)
1:eac0369: 		{
1:9b8c04f:             t = ie;
1:eac0369: 		}
1:9b8c04f:         catch (IllegalAccessException iae)
1:9b8c04f:         {
1:9b8c04f:             t = iae;
1:9b8c04f:         }
1:4469400:         catch (NoSuchMethodException nsme)
1:4469400:         {
1:4469400:             t = nsme;
1:4469400:         }
1:4469400: 		catch (java.lang.reflect.InvocationTargetException ite)
1:4469400: 		{
1:4469400: 			t = ite;
1:4469400: 		}
1:eac0369: 		catch (NoSuchAlgorithmException nsae)
1:eac0369: 		{
1:eac0369: 			t = nsae;
1:eac0369: 		}
1:eac0369: 		catch (SecurityException se)
1:eac0369: 		{
1:eac0369: 			t = se;
1:eac0369: 		} catch (LinkageError le) {
1:eac0369: 			t = le;
1:eac0369: 		} catch (ClassCastException cce) {
1:eac0369: 			t = cce;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		throw StandardException.newException(SQLState.MISSING_ENCRYPTION_PROVIDER, t);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:8a62d60: 	private byte[] handleBootPassword(boolean create, 
1:8a62d60:                                       Properties properties, 
1:8a62d60:                                       boolean newPasswd)
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 
1:8a62d60:         // get the key  specifed by the user. If user is reencrypting the
1:8a62d60:         // database; read the value of the new password. 
1:8a62d60: 		String inputKey = properties.getProperty((newPasswd ? 
1:8a62d60:                                                   Attribute.NEW_BOOT_PASSWORD : 
1:8a62d60:                                                   Attribute.BOOT_PASSWORD));
1:eac0369: 		if (inputKey == null)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.SERVICE_WRONG_BOOT_PASSWORD);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		byte[] bootPassword = StringUtil.getAsciiBytes(inputKey);
1:eac0369: 
1:eac0369: 		if (bootPassword.length < CipherFactory.MIN_BOOTPASS_LENGTH)
1:eac0369: 		{
1:eac0369: 			String messageId = create ? SQLState.SERVICE_BOOT_PASSWORD_TOO_SHORT :
1:eac0369: 										SQLState.SERVICE_WRONG_BOOT_PASSWORD;
1:eac0369: 
1:eac0369: 			throw StandardException.newException(messageId);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		// Each database has its own unique encryption key that is
1:eac0369: 		// not known even to the user.  However, this key is masked
1:eac0369: 		// with the user input key and stored in the
1:eac0369: 		// services.properties file so that, with the user key, the
1:eac0369: 		// encryption key can easily be recovered.
1:eac0369: 		// To change the user encryption key to a database, simply
1:eac0369: 		// recover the unique real encryption key and masked it
1:eac0369: 		// with the new user key.
1:eac0369: 
1:eac0369: 		byte[] generatedKey;
1:eac0369: 
1:8a62d60: 		if (create || newPasswd)
1:eac0369: 		{
1:eac0369: 			//
1:eac0369: 			generatedKey = generateUniqueBytes();
1:eac0369: 
1:ae71c74: 			persistentProperties.put(RawStoreFactory.ENCRYPTED_KEY, 
1:ae71c74:                                            saveSecretKey(generatedKey, bootPassword));
1:eac0369: 
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			generatedKey = getDatabaseSecretKey(properties, bootPassword, SQLState.SERVICE_WRONG_BOOT_PASSWORD);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return generatedKey;
1:eac0369: 	}
1:eac0369: 
1:8a62d60:     /* 
1:ae71c74:      * put all the encyrpion cipger related properties that has to 
1:ae71c74:      * be made peristent into the database service properties list.
1:ae71c74:      * @param  properties  properties object that is used to store 
1:ae71c74:      *                     cipher properties persistently. 
1:eac0369:      */
1:ae71c74:     public void saveProperties(Properties properties) 
1:eac0369:     {
1:ae71c74:         // put the cipher properties to be persistent into the 
1:ae71c74:         // system perisistent properties. 
1:ae71c74:         for (Enumeration e = persistentProperties.keys(); 
1:ae71c74:              e.hasMoreElements(); ) 
1:eac0369:         {
1:ae71c74:             String key = (String) e.nextElement();
1:ae71c74:             properties.put(key, persistentProperties.get(key));
1:eac0369: 		}
1:eac0369: 
1:ae71c74:         // clear the cipher properties to be persistent. 
1:ae71c74:         persistentProperties = null;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		get the secretkey used for encryption and decryption when boot password mechanism is used for encryption
1:eac0369: 		Steps include 
1:eac0369: 		retrieve the stored key, decrypt the stored key and verify if the correct boot password was passed 
1:eac0369: 		There is a possibility that the decrypted key includes the original key and padded bytes in order to have
1:eac0369: 		been block size aligned during encryption phase. Hence extract the original key 
1:eac0369: 		
1:eac0369: 		@param	properties	properties to retrieve the encrypted key  
1:eac0369: 		@param	bootPassword	boot password used to connect to the encrypted database
1:eac0369: 		@param	errorState	errorstate to account for any errors during retrieval /creation of the secretKey
1:eac0369: 		@return the original unencrypted key bytes to use for encryption and decrytion   
1:eac0369: 		
1:eac0369:          */
1:eac0369: 	private byte[] getDatabaseSecretKey(Properties properties, byte[] bootPassword, String errorState) throws StandardException {
1:eac0369: 
1:eac0369: 		// recover the generated secret encryption key from the
1:eac0369: 		// services.properties file and the user key.
1:eac0369: 		String keyString = properties.getProperty(RawStoreFactory.ENCRYPTED_KEY);
1:eac0369: 		if (keyString == null)
2:eac0369: 			throw StandardException.newException(errorState);
1:eac0369: 
1:eac0369: 		int encodedKeyCharLength = keyString.indexOf('-');
1:eac0369: 
1:eac0369: 		if (encodedKeyCharLength == -1) // bad form
1:eac0369: 			throw StandardException.newException(errorState);
1:eac0369: 
1:eac0369: 		int verifyKey = Integer.parseInt(keyString.substring(encodedKeyCharLength+1));
1:eac0369: 		byte[] generatedKey = decryptKey(keyString, encodedKeyCharLength, bootPassword);
1:eac0369: 
1:eac0369: 		int checkKey = digest(generatedKey);
1:eac0369: 
1:49aa62a:         if (checkKey != verifyKey)
1:49aa62a:         { throw StandardException.newException(errorState); }
1:eac0369: 
1:eac0369: 		// if encodedKeyLength is not defined, then either it is an old version with no support for different
1:eac0369: 		// key sizes and padding except for defaults
1:eac0369: 	        byte[] result;	
1:eac0369: 		if(encodedKeyLength != 0)
1:eac0369: 		{
1:eac0369: 			result = new byte[encodedKeyLength];
1:eac0369: 
1:eac0369: 			// extract the generated key without the padding bytes
1:eac0369: 			System.arraycopy(generatedKey,0,result,0,encodedKeyLength);
1:eac0369: 			return result;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		return generatedKey;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private String saveSecretKey(byte[] secretKey, byte[] bootPassword) throws StandardException {
1:9d7aba6: 		EncryptedKeyResult ekr = encryptKey(secretKey, bootPassword);
1:9d7aba6: 		String encryptedKey = ekr.hexOutput;
1:eac0369: 
1:eac0369: 		// make a verification key out of the message digest of
1:eac0369: 		// the generated key
1:9d7aba6: 		int verifyKey = digest(ekr.paddedInputKey);
1:eac0369: 
1:eac0369: 		return encryptedKey.concat("-" + verifyKey);
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	public String changeBootPassword(String changeString, Properties properties, CipherProvider verify)
1:eac0369: 		throws StandardException {
1:eac0369: 
1:eac0369: 		// the new bootPassword is expected to be of the form
1:eac0369: 		// oldkey , newkey.
1:eac0369: 		int seperator = changeString.indexOf(',');
1:eac0369: 		if (seperator == -1)
1:eac0369: 			throw StandardException.newException(SQLState.WRONG_PASSWORD_CHANGE_FORMAT);
1:eac0369: 
1:eac0369: 		String oldBP = changeString.substring(0, seperator).trim();
1:eac0369: 		byte[] oldBPAscii = StringUtil.getAsciiBytes(oldBP);
1:eac0369: 		if (oldBPAscii == null || oldBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)
1:eac0369: 			throw StandardException.newException(SQLState.WRONG_BOOT_PASSWORD);;
1:eac0369: 
1:eac0369: 		String newBP = changeString.substring(seperator+1).trim();
1:eac0369: 		byte[] newBPAscii = StringUtil.getAsciiBytes(newBP);
1:eac0369: 		if (newBPAscii == null || newBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)
1:eac0369: 			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH,
1:ce40a31:                 CipherFactory.MIN_BOOTPASS_LENGTH);
1:eac0369: 
1:eac0369: 		// verify old key
1:eac0369: 
1:eac0369: 		byte[] generatedKey = getDatabaseSecretKey(properties, oldBPAscii, SQLState.WRONG_BOOT_PASSWORD);
1:eac0369: 
1:eac0369: 		// make sure the oldKey is correct
1:eac0369: 		byte[] IV = generateIV(generatedKey);
1:eac0369: 
1:eac0369: 		if (!((JCECipherProvider) verify).verifyIV(IV))
1:49aa62a: 		{ throw StandardException.newException(SQLState.WRONG_BOOT_PASSWORD); }
1:eac0369: 
1:49aa62a:         // DERBY-5622:
1:49aa62a:         // if we survive those two quick checks, verify that the generated key is still correct
1:49aa62a:         // by using it to decrypt something encrypted by the original generated key
1:49aa62a:         CipherProvider  newDecrypter = createNewCipher
1:49aa62a:             ( DECRYPT, generateKey( generatedKey ), IV );
1:49aa62a:         vetCipherProviders( newDecrypter, verify, SQLState.WRONG_BOOT_PASSWORD );
1:49aa62a:         
1:eac0369: 		// Make the new key.  The generated key is unchanged, only the
1:eac0369: 		// encrypted key is changed.
1:eac0369: 		String newkey = saveSecretKey(generatedKey, newBPAscii);
1:eac0369: 		
1:eac0369: 		properties.put(Attribute.CRYPTO_KEY_LENGTH,keyLengthBits+"-"+encodedKeyLength);
1:eac0369: 		
1:eac0369: 
1:eac0369: 		return saveSecretKey(generatedKey, newBPAscii);
1:eac0369: 	}
1:eac0369: 
1:49aa62a:     /**
1:49aa62a:      * <p>
1:49aa62a:      * Verify that a decrypter matches an encrypter. Raises an exception if they don't.
1:49aa62a:      * The verification is performed by encrypting a block of text and checking that
1:49aa62a:      * it decrypts to the same block.
1:49aa62a:      * </p>
1:49aa62a:      */
1:49aa62a:     private void    vetCipherProviders
1:49aa62a:         ( CipherProvider decrypter, CipherProvider encrypter, String sqlState )
1:49aa62a:         throws StandardException
1:49aa62a:     {
1:49aa62a:         int     clearTextLength = 1024;
1:49aa62a:         int     byteSize = 256;
1:49aa62a:         byte[]  clearText = new byte[ clearTextLength ];
1:49aa62a:         byte[]  cipherText = new byte[ clearTextLength ];
1:49aa62a:         byte[]  unencryptedText = new byte[ clearTextLength ];
1:49aa62a: 
1:49aa62a:         for ( int i = 0; i < clearTextLength; i++ ) { clearText[ i ] = (byte) (i % byteSize); }
1:49aa62a: 
1:49aa62a:         int     bytesEncrypted = encrypter.encrypt
1:49aa62a:             ( clearText, 0, clearTextLength, cipherText, 0 );
1:49aa62a:         int     bytesDecrypted = decrypter.decrypt
1:49aa62a:             ( cipherText, 0, bytesEncrypted, unencryptedText, 0 );
1:49aa62a: 
1:49aa62a:         if ( (bytesEncrypted != clearTextLength) || (bytesDecrypted != clearTextLength) )
1:49aa62a:         {
1:49aa62a:             throw StandardException.newException( sqlState );
1:49aa62a:         }
1:49aa62a: 
1:49aa62a:         for ( int i = 0; i < clearTextLength; i++ )
1:49aa62a:         {
1:49aa62a:             if ( clearText[ i ] != unencryptedText[ i ] )
1:49aa62a:             {
1:49aa62a:                 throw StandardException.newException( sqlState );
1:49aa62a:             }
1:49aa62a:         }
1:49aa62a:     }
1:49aa62a: 
1:eac0369: 	/**
1:eac0369: 	    The database can be encrypted with an encryption key given in connection url.
1:eac0369: 	    For security reasons, this key is not made persistent in the database.
1:eac0369: 
1:eac0369: 	    But it is necessary to verify the encryption key when booting the database if it is similar
1:eac0369: 	    to the one used when creating the database
1:eac0369: 	    This needs to happen before we access the data/logs to avoid the risk of corrupting the 
1:eac0369: 	    database because of a wrong encryption key.
1:eac0369: 
1:eac0369: 	    This method performs the steps necessary to verify the encryption key if an external
1:eac0369: 	    encryption key is given.
1:eac0369: 
1:eac0369: 	    At database creation, 4k of random data is generated using SecureRandom and MD5 is used
1:eac0369: 	    to compute the checksum for the random data thus generated.  This 4k page of random data
1:eac0369: 	    is then encrypted using the encryption key. The checksum of unencrypted data and
1:eac0369: 	    encrypted data is made persistent in the database in file by name given by
1:eac0369: 	    Attribute.CRYPTO_EXTERNAL_KEY_VERIFYFILE (verifyKey.dat). This file exists directly under the
1:eac0369: 	    database root directory.
1:eac0369: 
1:eac0369: 	    When trying to boot an existing encrypted database, the given encryption key is used to decrypt
1:eac0369: 	    the data in the verifyKey.dat and the checksum is calculated and compared against the original
1:eac0369: 	    stored checksum. If these checksums dont match an exception is thrown.
1:eac0369: 
1:eac0369: 	    Please note, this process of verifying the key  does not provide any added security but only is 
1:eac0369: 	    intended to allow to fail gracefully if a wrong encryption key is used
1:eac0369: 
1:6b50965: 	    StandardException is thrown if there are any problems during the process of verification
1:eac0369: 	    		of the encryption key or if there is any mismatch of the encryption key.
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 
1:eac0369: 	public void verifyKey(boolean create, StorageFactory sf, Properties properties)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 
1:eac0369: 		if(properties.getProperty(Attribute.CRYPTO_EXTERNAL_KEY) == null)
1:eac0369: 			return;
1:eac0369: 
1:eac0369: 		// if firstTime ( ie during creation of database, initial key used )
1:eac0369: 		// In order to allow for verifying the external key for future database boot,
1:eac0369: 		// generate random 4k of data and store the encrypted random data and the checksum
1:eac0369: 		// using MD5 of the unencrypted data. That way, on next database boot a check is performed
1:eac0369: 		// to verify if the key is the same as used when the database was created
1:eac0369: 
1:97cac2e:         InputStream verifyKeyInputStream = null;
1:eac0369: 		StorageRandomAccessFile verifyKeyFile = null;
1:eac0369: 		byte[] data = new byte[VERIFYKEY_DATALEN];
1:eac0369: 		try
1:eac0369: 		{
3:eac0369: 			if(create)
1:eac0369: 			{
1:eac0369: 				getSecureRandom().nextBytes(data);
1:eac0369: 				// get the checksum
1:eac0369: 				byte[] checksum = getMD5Checksum(data);
1:eac0369: 
1:eac0369: 				CipherProvider tmpCipherProvider = createNewCipher(ENCRYPT,mainSecretKey,mainIV);
1:eac0369: 				tmpCipherProvider.encrypt(data, 0, data.length, data, 0);
1:eac0369: 				// openFileForWrite
1:eac0369: 				verifyKeyFile = privAccessFile(sf,Attribute.CRYPTO_EXTERNAL_KEY_VERIFY_FILE,"rw");
1:eac0369: 				// write the checksum length as int, and then the checksum and then the encrypted data
1:eac0369: 				verifyKeyFile.writeInt(checksum.length);
1:eac0369: 				verifyKeyFile.write(checksum);
1:eac0369: 				verifyKeyFile.write(data);
1:2d8c0d3:                 verifyKeyFile.sync();
1:eac0369: 			}
1:eac0369: 			else
1:eac0369: 			{
1:97cac2e: 				// Read from verifyKey.dat as an InputStream. This allows for 
1:97cac2e:                 // reading the information from verifyKey.dat successfully even when using the jar
1:97cac2e:                 // subprotocol to boot derby. (DERBY-1373) 
1:97cac2e: 				verifyKeyInputStream = privAccessGetInputStream(sf,Attribute.CRYPTO_EXTERNAL_KEY_VERIFY_FILE);
1:97cac2e:                 DataInputStream dis = new DataInputStream(verifyKeyInputStream);
1:eac0369: 				// then read the checksum length 
1:97cac2e: 				int checksumLen = dis.readInt();
1:eac0369: 
1:eac0369: 				byte[] originalChecksum = new byte[checksumLen];
1:97cac2e: 				dis.readFully(originalChecksum);
1:eac0369: 
1:97cac2e: 				dis.readFully(data);
1:eac0369: 
1:eac0369: 				// decrypt data with key
1:eac0369: 				CipherProvider tmpCipherProvider = createNewCipher(DECRYPT,mainSecretKey,mainIV);
1:eac0369: 				tmpCipherProvider.decrypt(data, 0, data.length, data, 0);
1:eac0369: 
1:eac0369: 				byte[] verifyChecksum = getMD5Checksum(data);
1:eac0369: 
1:eac0369: 				if(!MessageDigest.isEqual(originalChecksum,verifyChecksum))
1:eac0369: 				{
2:eac0369: 					throw StandardException.newException(SQLState.ENCRYPTION_BAD_EXTERNAL_KEY);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		catch(IOException ioe)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,ioe);
1:eac0369: 		}
1:eac0369: 		finally
1:eac0369: 		{
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				if(verifyKeyFile != null)
1:eac0369: 					verifyKeyFile.close();
1:97cac2e:                 if (verifyKeyInputStream != null )
1:97cac2e:                     verifyKeyInputStream.close();
1:eac0369: 			}
1:eac0369: 			catch(IOException ioee)
1:eac0369: 			{
1:eac0369: 				throw StandardException.newException(SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,ioee);
1:eac0369: 			}
1:eac0369: 		}
1:eac0369: 		return ;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Use MD5 MessageDigest algorithm to generate checksum
1:eac0369: 		@param data	data to be used to compute the hash value
1:eac0369: 		@return returns the hash value computed using the data
1:eac0369: 
1:eac0369: 	 */
1:eac0369: 	private byte[] getMD5Checksum(byte[] data)
1:eac0369: 		throws StandardException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			// get the checksum
1:eac0369: 			MessageDigest md5 = MessageDigest.getInstance("MD5");
1:eac0369: 			return md5.digest(data);
1:eac0369: 		}
1:eac0369: 		catch(NoSuchAlgorithmException nsae)
1:eac0369: 		{
1:eac0369: 			throw StandardException.newException(SQLState.ENCRYPTION_BAD_ALG_FORMAT,MESSAGE_DIGEST);
1:eac0369: 		}
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 	access a file for either read/write
1:eac0369: 	 	@param storageFactory	factory used for io access
1:eac0369: 	 	@param	fileName		name of the file to create and open for write
1:eac0369:  							The file will be created directly under the database root directory
1:eac0369: 		@param	filePerms		file permissions, if "rw" open file with read and write permissions
1:eac0369: 							    if "r" , open file with read permissions
1:eac0369: 	 	@return	StorageRandomAccessFile returns file with fileName for writing
1:eac0369: 		@exception IOException Any exception during accessing the file for read/write
1:eac0369: 	 */
1:9b8c04f:     private StorageRandomAccessFile privAccessFile(
1:9b8c04f:             StorageFactory storageFactory,
1:9b8c04f:             String fileName,
1:9b8c04f:             final String filePerms)
1:eac0369: 		throws java.io.IOException
1:eac0369: 	{
1:9b8c04f:         final StorageFile verifyKeyFile =
1:9b8c04f:                 storageFactory.newStorageFile("", fileName);
1:eac0369: 	    try
1:eac0369:         {
1:9b8c04f:             return AccessController.doPrivileged(
1:9b8c04f:                     new PrivilegedExceptionAction<StorageRandomAccessFile>() {
1:9b8c04f:                 @Override
1:9b8c04f:                 public StorageRandomAccessFile run() throws IOException {
1:9b8c04f:                     return verifyKeyFile.getRandomAccessFile(filePerms);
1:9b8c04f:                 }
1:9b8c04f:             });
1:eac0369: 		}
1:eac0369: 		catch( java.security.PrivilegedActionException pae)
1:eac0369: 		{
1:eac0369: 			throw (java.io.IOException)pae.getException();
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:97cac2e: 	 access a InputStream for a given file for reading.
1:97cac2e: 	 @param storageFactory   factory used for io access
1:97cac2e: 	 @param  fileName        name of the file to open as a stream for reading
1:97cac2e: 	 @return InputStream returns the stream for the file with fileName for reading
1:97cac2e: 	 @exception IOException Any exception during accessing the file for read
1:97cac2e: 	 */
1:97cac2e: 	private InputStream privAccessGetInputStream(StorageFactory storageFactory,String fileName)
1:97cac2e: 	throws StandardException
1:eac0369: 	{
1:9b8c04f:         final StorageFile verifyKeyFile
1:9b8c04f:                 = storageFactory.newStorageFile("", fileName);
1:97cac2e: 	    try
1:97cac2e: 	    {
1:9b8c04f:             return AccessController.doPrivileged(
1:9b8c04f:                     new PrivilegedExceptionAction<InputStream>() {
1:9b8c04f:                 @Override
1:9b8c04f:                 public InputStream run() throws FileNotFoundException {
1:9b8c04f:                     return verifyKeyFile.getInputStream();
1:9b8c04f:                 }
1:9b8c04f:             });
1:eac0369: 	    }
1:97cac2e: 	    catch( java.security.PrivilegedActionException pae)
1:97cac2e: 	    {
1:9b8c04f:             throw StandardException.newException(
1:9b8c04f:                     SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,
1:9b8c04f:                     pae.getCause(),
1:9b8c04f:                     cryptoProvider);
1:eac0369: 	    }
1:eac0369: 	}
1:eac0369: 
1:9d7aba6:     // tuple for returning results from encryptKey()
1:9d7aba6:     private static final class EncryptedKeyResult
1:9d7aba6:     {
1:9d7aba6:         public String hexOutput;
1:9d7aba6:         public byte[] paddedInputKey;
1:9d7aba6: 
1:9d7aba6:         public EncryptedKeyResult( String hexOutput, byte[] paddedInputKey )
1:9d7aba6:         {
1:9d7aba6:             this.hexOutput = hexOutput;
1:9d7aba6:             this.paddedInputKey = paddedInputKey;
1:9d7aba6:         }
1:9d7aba6:     }
1:9d7aba6:     
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:4469400
/////////////////////////////////////////////////////////////////////////
1:                     Class<?> cryptoClass = Class.forName(cryptoProvider);
1:                     java.lang.reflect.Constructor<?> constructor = cryptoClass.getConstructor();
1:                     final Provider provider = (Provider) constructor.newInstance();
/////////////////////////////////////////////////////////////////////////
1:         catch (NoSuchMethodException nsme)
1:         {
1:             t = nsme;
1:         }
1: 		catch (java.lang.reflect.InvocationTargetException ite)
1: 		{
1: 			t = ite;
1: 		}
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1: 			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH, MIN_BOOTPASS_LENGTH);
/////////////////////////////////////////////////////////////////////////
1:                 CipherFactory.MIN_BOOTPASS_LENGTH);
commit:b1008f3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.security.SecurityUtil;
/////////////////////////////////////////////////////////////////////////
1: final class JCECipherFactory implements CipherFactory
/////////////////////////////////////////////////////////////////////////
1:     JCECipherFactory(boolean create, 
1:         // Verify that we have permission to execute this method.
1:         SecurityUtil.checkDerbyInternalsPrivilege();
1: 
commit:a15a470
/////////////////////////////////////////////////////////////////////////
0: public final class JCECipherFactory implements CipherFactory, java.security.PrivilegedExceptionAction<Object>
commit:49aa62a
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         if (checkKey != verifyKey)
1:         { throw StandardException.newException(errorState); }
/////////////////////////////////////////////////////////////////////////
1: 		{ throw StandardException.newException(SQLState.WRONG_BOOT_PASSWORD); }
1:         // DERBY-5622:
1:         // if we survive those two quick checks, verify that the generated key is still correct
1:         // by using it to decrypt something encrypted by the original generated key
1:         CipherProvider  newDecrypter = createNewCipher
1:             ( DECRYPT, generateKey( generatedKey ), IV );
1:         vetCipherProviders( newDecrypter, verify, SQLState.WRONG_BOOT_PASSWORD );
1:         
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Verify that a decrypter matches an encrypter. Raises an exception if they don't.
1:      * The verification is performed by encrypting a block of text and checking that
1:      * it decrypts to the same block.
1:      * </p>
1:      */
1:     private void    vetCipherProviders
1:         ( CipherProvider decrypter, CipherProvider encrypter, String sqlState )
1:         throws StandardException
1:     {
1:         int     clearTextLength = 1024;
1:         int     byteSize = 256;
1:         byte[]  clearText = new byte[ clearTextLength ];
1:         byte[]  cipherText = new byte[ clearTextLength ];
1:         byte[]  unencryptedText = new byte[ clearTextLength ];
1: 
1:         for ( int i = 0; i < clearTextLength; i++ ) { clearText[ i ] = (byte) (i % byteSize); }
1: 
1:         int     bytesEncrypted = encrypter.encrypt
1:             ( clearText, 0, clearTextLength, cipherText, 0 );
1:         int     bytesDecrypted = decrypter.decrypt
1:             ( cipherText, 0, bytesEncrypted, unencryptedText, 0 );
1: 
1:         if ( (bytesEncrypted != clearTextLength) || (bytesDecrypted != clearTextLength) )
1:         {
1:             throw StandardException.newException( sqlState );
1:         }
1: 
1:         for ( int i = 0; i < clearTextLength; i++ )
1:         {
1:             if ( clearText[ i ] != unencryptedText[ i ] )
1:             {
1:                 throw StandardException.newException( sqlState );
1:             }
1:         }
1:     }
1: 
commit:9d7aba6
/////////////////////////////////////////////////////////////////////////
1: 	private EncryptedKeyResult encryptKey(byte[] secretKey, byte[] bootPassword)
/////////////////////////////////////////////////////////////////////////
1: 		String hexOutput = org.apache.derby.iapi.util.StringUtil.toHexString(result, 0, result.length);
1: 
1:         return new EncryptedKeyResult( hexOutput, secretKey );
/////////////////////////////////////////////////////////////////////////
1: 		EncryptedKeyResult ekr = encryptKey(secretKey, bootPassword);
1: 		String encryptedKey = ekr.hexOutput;
1: 		int verifyKey = digest(ekr.paddedInputKey);
/////////////////////////////////////////////////////////////////////////
1:     // tuple for returning results from encryptKey()
1:     private static final class EncryptedKeyResult
1:     {
1:         public String hexOutput;
1:         public byte[] paddedInputKey;
1: 
1:         public EncryptedKeyResult( String hexOutput, byte[] paddedInputKey )
1:         {
1:             this.hexOutput = hexOutput;
1:             this.paddedInputKey = paddedInputKey;
1:         }
1:     }
1:     
commit:93fea34
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9b8c04f
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
1: import java.security.PrivilegedExceptionAction;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public final class JCECipherFactory implements CipherFactory
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                     Class cryptoClass = Class.forName(cryptoProvider);
1:                     if (!Provider.class.isAssignableFrom(cryptoClass)) {
1:                         throw StandardException.newException(
1:                                 SQLState.ENCRYPTION_NOT_A_PROVIDER,
1:                                 cryptoProvider);
1:                     }
1: 
0:                     final Provider provider =
0:                             (Provider) cryptoClass.newInstance();
1: 
1:                     AccessController.doPrivileged(new PrivilegedAction<Void>() {
1:                         @Override
1:                         public Void run() {
1:                             Security.addProvider(provider);
1:                             return null;
1:                         }
1:                     });
/////////////////////////////////////////////////////////////////////////
1:         catch (ClassNotFoundException cnfe)
1:         {
1:             t = StandardException.newException(
1:                     SQLState.ENCRYPTION_NO_PROVIDER_CLASS,
1:                     cnfe,
1:                     cryptoProvider);
1:         }
1:         catch (InstantiationException ie)
1:             t = ie;
1:         catch (IllegalAccessException iae)
1:         {
1:             t = iae;
1:         }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     private StorageRandomAccessFile privAccessFile(
1:             StorageFactory storageFactory,
1:             String fileName,
1:             final String filePerms)
1:         final StorageFile verifyKeyFile =
1:                 storageFactory.newStorageFile("", fileName);
1:             return AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<StorageRandomAccessFile>() {
1:                 @Override
1:                 public StorageRandomAccessFile run() throws IOException {
1:                     return verifyKeyFile.getRandomAccessFile(filePerms);
1:                 }
1:             });
/////////////////////////////////////////////////////////////////////////
1:         final StorageFile verifyKeyFile
1:                 = storageFactory.newStorageFile("", fileName);
1:             return AccessController.doPrivileged(
1:                     new PrivilegedExceptionAction<InputStream>() {
1:                 @Override
1:                 public InputStream run() throws FileNotFoundException {
1:                     return verifyKeyFile.getInputStream();
1:                 }
1:             });
1:             throw StandardException.newException(
1:                     SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,
1:                     pae.getCause(),
1:                     cryptoProvider);
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:d466c80
/////////////////////////////////////////////////////////////////////////
1:     private void init(boolean create, Properties properties, boolean newAttrs)
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:2d8c0d3
/////////////////////////////////////////////////////////////////////////
1:                 verifyKeyFile.sync();
commit:a552fe6
/////////////////////////////////////////////////////////////////////////
0: 				verifyKeyFile.sync();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f12802f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 		if (cryptoProvider != null)
commit:8e896c5
/////////////////////////////////////////////////////////////////////////
1:                 if (generatedKey == null) {
1:                     throw StandardException.newException(
1:                         // If length is even, we assume invalid character(s),
1:                         // based on how 'fromHexString' behaves.
1:                         externalKey.length() % 2 == 0 
1:                             ? SQLState.ENCRYPTION_ILLEGAL_EXKEY_CHARS
1:                             : SQLState.ENCRYPTION_INVALID_EXKEY_LENGTH);
1:                 }
commit:6ae3022
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: 			if (JVMInfo.JDK_ID == JVMInfo.J2SE_13) {
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.services.jce.JCECipherFactory
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:abd7bc1
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.jce
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.services.jce;
1: 
1: import org.apache.derby.iapi.services.crypto.CipherFactory;
1: import org.apache.derby.iapi.services.crypto.CipherProvider;
1: 
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
0: import org.apache.derby.iapi.services.info.JVMInfo;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.reference.Attribute;
1: import org.apache.derby.iapi.util.StringUtil;
1: 
1: import java.util.Properties;
1: 
0: import java.security.Key;
1: import java.security.Provider;
1: import java.security.SecureRandom;
1: import java.security.Security;
1: import java.security.InvalidKeyException;
1: import java.security.NoSuchAlgorithmException;
1: import java.security.MessageDigest;
0: import java.security.spec.KeySpec;
0: import java.security.spec.InvalidKeySpecException;
1: import java.io.FileNotFoundException;
1: import java.io.IOException;
1: 
1: import javax.crypto.KeyGenerator;
1: import javax.crypto.SecretKey;
0: import javax.crypto.SecretKeyFactory;
1: import javax.crypto.spec.DESKeySpec;
1: import javax.crypto.spec.SecretKeySpec;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: 
1: import org.apache.derby.io.StorageFactory;
0: import org.apache.derby.io.WritableStorageFactory;
1: import org.apache.derby.io.StorageFile;
1: import org.apache.derby.io.StorageRandomAccessFile;
1: /**
1: 	This CipherFactory creates new JCECipherProvider.
1: 
1: 	@see CipherFactory
1:  */
0: public final class JCECipherFactory implements CipherFactory, ModuleControl, java.security.PrivilegedExceptionAction
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1:     private final static String MESSAGE_DIGEST = "MD5";
1: 
0: 	private final static String DEFAULT_PROVIDER = "com.sun.crypto.provider.SunJCE";
1: 	private final static String DEFAULT_ALGORITHM = "DES/CBC/NoPadding";
1: 	private final static String DES = "DES";
1: 	private final static String DESede = "DESede";
1:     private final static String TripleDES = "TripleDES";
1:     private final static String AES = "AES";
1: 
1:     // minimum boot password length in bytes
1:     private final static int BLOCK_LENGTH = 8;
1: 
1:     /**
1: 	AES encryption takes in an default Initialization vector length (IV) length of 16 bytes
1: 	This is needed to generate an IV to use for encryption and decryption process 
1: 	@see CipherProvider
1:      */
1:     private final static int AES_IV_LENGTH = 16;
1: 
1:     // key length in bytes
1: 	private int keyLengthBits;
1:     private int encodedKeyLength;
1:     private String cryptoAlgorithm;
1:     private String cryptoAlgorithmShort;
1:     private String cryptoProvider;
1:     private String cryptoProviderShort;
1: 	private MessageDigest messageDigest;
1: 
1: 	private SecretKey mainSecretKey;
1: 	private byte[] mainIV;
1: 
1: 	/**
1: 	    Amount of data that is used for verification of external encryption key
1: 	    This does not include the MD5 checksum bytes
1: 	 */
1: 	private final static int VERIFYKEY_DATALEN = 4096;
0: 	private StorageFile activeFile;
0: 	private int action;
0: 	private String activePerms;
1: 
1: 	static String providerErrorName(String cps) {
1: 
1: 		return cps == null ? "default" : cps;
1: 	}
1: 
1: 
1: 	private byte[] generateUniqueBytes() throws StandardException
1: 	{
1: 		try {
1: 
1: 			String provider = cryptoProviderShort;
1: 
1: 			KeyGenerator keyGen;
1: 			if (provider == null)
1: 			{
1: 				keyGen = KeyGenerator.getInstance(cryptoAlgorithmShort);
1: 			}
1: 			else
1: 			{
1: 				if( provider.equals("BouncyCastleProvider"))
1: 					provider = "BC";
1: 				keyGen = KeyGenerator.getInstance(cryptoAlgorithmShort, provider);
1: 			}
1: 
1: 			keyGen.init(keyLengthBits);
1: 
1: 			SecretKey key = keyGen.generateKey();
1: 
1: 			return key.getEncoded();
1: 
1: 		} catch (java.security.NoSuchAlgorithmException nsae) {
1:     		throw StandardException.newException(SQLState.ENCRYPTION_NOSUCH_ALGORITHM, cryptoAlgorithm,
1: 				JCECipherFactory.providerErrorName(cryptoProviderShort));
1: 		} catch (java.security.NoSuchProviderException nspe) {
1: 			throw StandardException.newException(SQLState.ENCRYPTION_BAD_PROVIDER,
1: 				JCECipherFactory.providerErrorName(cryptoProviderShort));
1: 		}
1: 	}
1: 
1: 	/**
1: 		Encrypt the secretKey with the boot password.
1: 		This includes the following steps, 
1: 		getting muck from the boot password and then using this to generate a key,
1: 		generating an appropriate IV using the muck
1: 		using the key and IV thus generated to create the appropriate cipher provider
1: 		and encrypting the secretKey 
1: 		@return hexadecimal string of the encrypted secretKey
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
0: 	private String encryptKey(byte[] secretKey, byte[] bootPassword)
1: 		 throws StandardException
1: 	{
1: 		// In case of AES, care needs to be taken to allow for 16 bytes muck as well
1: 		// as to have the secretKey that needs encryption to be a aligned appropriately
1: 		// AES supports 16 bytes block size
1: 
1: 		int muckLength = secretKey.length;
1: 		if(cryptoAlgorithmShort.equals(AES))
1: 			muckLength = AES_IV_LENGTH;		
1: 
1: 		byte[] muck = getMuckFromBootPassword(bootPassword, muckLength);
1: 		SecretKey key = generateKey(muck);
1: 		byte[] IV = generateIV(muck);
1:                 CipherProvider tmpCipherProvider = createNewCipher(ENCRYPT,key,IV);
1: 		
1: 		// store the actual secretKey.length before any possible padding  
1: 		encodedKeyLength = secretKey.length;
1: 
1: 		// for the secretKey to be encrypted, first ensure that it is aligned to the block size of the 
1: 		// encryption algorithm by padding bytes appropriately if needed
1:                 secretKey = padKey(secretKey,tmpCipherProvider.getEncryptionBlockSize());
1: 
1:                 byte[] result = new byte[secretKey.length];
1: 
1: 		// encrypt the secretKey using the key generated of muck from  boot password and the generated IV  
1: 		tmpCipherProvider.encrypt(secretKey, 0, secretKey.length, result, 0);
1: 
0: 		return org.apache.derby.iapi.util.StringUtil.toHexString(result, 0, result.length);
1: 
1: 	}
1: 	
1: 	/**
1:             For block ciphers, and  algorithms using the NoPadding scheme, the data that has 
1:             to be encrypted needs to be a multiple of the expected block size for the cipher 
1: 	    Pad the key with appropriate padding to make it blockSize align
1: 	    @param     secretKey	the data that needs blocksize alignment
1: 	    @param     blockSizeAlign   secretKey needs to be blocksize aligned		
1: 	    @return    a byte array with the contents of secretKey along with padded bytes in the end
1: 		       to make it blockSize aligned
1:          */
1: 	private byte[] padKey(byte[] secretKey,int blockSizeAlign)
1: 	{
1: 	    byte [] result = secretKey;
1: 	    if(secretKey.length % blockSizeAlign != 0 )
1: 	    {
1: 		int encryptedLength = secretKey.length + blockSizeAlign - (secretKey.length % blockSizeAlign);
1: 		result = new byte[encryptedLength];
1: 		System.arraycopy(secretKey,0,result,0,secretKey.length);
1: 	    }
1: 	    return result;
1: 	}
1: 
1: 	/**
1: 	    Decrypt the secretKey with the user key .
1: 	    This includes the following steps, 
1: 	    retrieve the encryptedKey, generate the muck from the boot password and generate an appropriate IV using
1: 	    the muck,and using the key and IV decrypt the encryptedKey 
1: 	    @return decrypted key  
0: 		@exception StandardException Standard Cloudscape error policy
1: 	 */
1: 	private byte[] decryptKey(String encryptedKey, int encodedKeyCharLength, byte[] bootPassword)
1: 		 throws StandardException
1: 	{
1: 		byte[] secretKey = org.apache.derby.iapi.util.StringUtil.fromHexString(encryptedKey, 0, encodedKeyCharLength);
1: 		// In case of AES, care needs to be taken to allow for 16 bytes muck as well
1: 		// as to have the secretKey that needs encryption to be a aligned appropriately
1: 		// AES supports 16 bytes block size
1: 		int muckLength;
1: 		if(cryptoAlgorithmShort.equals(AES))
1: 		    muckLength = AES_IV_LENGTH;
1: 		else
1: 	            muckLength = secretKey.length;	
1: 
1: 		byte[] muck = getMuckFromBootPassword(bootPassword, muckLength);
1: 
1: 
1: 		// decrypt the encryptedKey with the mucked up boot password to recover
1: 		// the secretKey
1: 		SecretKey key = generateKey(muck);
1: 		byte[] IV = generateIV(muck);
1: 
1: 
1: 		createNewCipher(DECRYPT, key, IV).
1: 			decrypt(secretKey, 0, secretKey.length, secretKey, 0);
1: 
1: 		return secretKey;
1: 	}
1: 
1: 	private byte[] getMuckFromBootPassword(byte[] bootPassword, int encodedKeyByteLength) {
1: 		int ulength = bootPassword.length;
1: 
1: 		byte[] muck = new byte[encodedKeyByteLength];
1: 		
1: 
1: 		int rotation = 0;
1: 		for (int i = 0; i < bootPassword.length; i++)
1: 			rotation += bootPassword[i];
1: 
1: 		for (int i = 0; i < encodedKeyByteLength; i++)
1: 			muck[i] = (byte)(bootPassword[(i+rotation)%ulength] ^
1:                 (bootPassword[i%ulength] << 4));
1: 
1: 		return muck;
1: 	}
1: 
1: 	/**
1: 		Generate a Key object using the input secretKey that can be used by
1: 		JCECipherProvider to encrypt or decrypt.
1: 
0: 		@exception StandardException Standard Cloudscape Error Policy
1: 	 */
1: 	private SecretKey generateKey(byte[] secretKey) throws StandardException
1: 	{
1: 		int length = secretKey.length;
1: 
1: 		if (length < CipherFactory.MIN_BOOTPASS_LENGTH)
0: 			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH, new Integer(MIN_BOOTPASS_LENGTH));
1: 
1: 		try
1: 		{
1:             if (cryptoAlgorithmShort.equals(DES))
1:             {   // single DES
1: 			    if (DESKeySpec.isWeak(secretKey, 0))
1: 			    {
1: 				    // OK, it is weak, spice it up
1: 				    byte[] spice = StringUtil.getAsciiBytes("louDScap");
1: 				    for (int i = 0; i < 7; i++)
1: 					    secretKey[i] = (byte)((spice[i] << 3) ^ secretKey[i]);
1: 			    }
1:             }
1: 			return new SecretKeySpec(secretKey, cryptoAlgorithmShort);
1: 		}
1: 		catch (InvalidKeyException ike)
1: 		{
1: 			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
1: 		}
1: 
1: 	}
1: 
1: 	/**
1: 		Generate an IV using the input secretKey that can be used by
1: 		JCECipherProvider to encrypt or decrypt.
1: 	 */
1: 	private byte[] generateIV(byte[] secretKey)
1: 	{
1: 
1: 		// do a little simple minded muddling to make the IV not
1: 		// strictly alphanumeric and the number of total possible keys a little
1: 		// bigger.
1: 		int IVlen = BLOCK_LENGTH;
1: 		
1: 		byte[] iv = null;
1: 		if(cryptoAlgorithmShort.equals(AES))
1: 		{
1: 			IVlen = AES_IV_LENGTH;
1: 			iv = new byte[IVlen];
1: 			iv[0] = (byte)(((secretKey[secretKey.length-1] << 2) | 0xF) ^ secretKey[0]);
1: 			for (int i = 1; i < BLOCK_LENGTH; i++)
1: 				iv[i] = (byte)(((secretKey[i-1] << (i%5)) | 0xF) ^ secretKey[i]);
1: 			
1: 			for(int i = BLOCK_LENGTH ; i < AES_IV_LENGTH ; i++)
1: 			{
1: 				iv[i]=iv[i-BLOCK_LENGTH];
1: 			}
1: 			
1: 		}	
1: 		else
1: 		{
1: 			iv = new byte[BLOCK_LENGTH];
1: 			iv[0] = (byte)(((secretKey[secretKey.length-1] << 2) | 0xF) ^ secretKey[0]);
1: 			for (int i = 1; i < BLOCK_LENGTH; i++)
1: 				iv[i] = (byte)(((secretKey[i-1] << (i%5)) | 0xF) ^ secretKey[i]);	
1: 		}
1: 
1: 		return iv;
1: 	}
1: 
1: 	private int digest(byte[] input)
1: 	{
1: 		messageDigest.reset();
1: 		byte[] digest = messageDigest.digest(input);
1: 		byte[] condenseDigest = new byte[2];
1: 
1: 		// no matter how long the digest is, condense it into an short.
1: 		for (int i = 0; i < digest.length; i++)
1: 			condenseDigest[i%2] ^= digest[i];
1: 
1: 		int retval = (condenseDigest[0] & 0xFF) | ((condenseDigest[1] << 8) & 0xFF00);
1: 
1: 		return retval;
1: 	}
1: 
1: 	public SecureRandom getSecureRandom() {
1: 		return new SecureRandom(mainIV);
1: 	}
1: 
1: 	public CipherProvider createNewCipher(int mode)
1: 										  throws StandardException {
1: 		return createNewCipher(mode, mainSecretKey, mainIV);
1: 	}
1: 
1: 
1: 	private CipherProvider createNewCipher(int mode, SecretKey secretKey,
1: 										  byte[] iv)
1: 		 throws StandardException
1: 	{
1: 		return new JCECipherProvider(mode, secretKey, iv, cryptoAlgorithm, cryptoProviderShort);
1: 	}
1: 
1: 	/*
0: 	 * module control methods
1: 	 */
1: 
0: 	public void	boot(boolean create, Properties properties)
1: 		throws StandardException
1: 	{
1: 
0: 		if (SanityManager.DEBUG) {
0: 			if (JVMInfo.JDK_ID < 2)
0: 				SanityManager.THROWASSERT("expected JDK ID to be 2 - is " + JVMInfo.JDK_ID);
1: 		}
1: 
1:         boolean provider_or_algo_specified = false;
1: 		boolean storeProperties = create;
1: 
0: 		String externalKey = properties.getProperty(Attribute.CRYPTO_EXTERNAL_KEY);
1: 		if (externalKey != null) {
1: 			storeProperties = false;
1: 		}
1: 
1:         cryptoProvider = properties.getProperty(Attribute.CRYPTO_PROVIDER);
1: 
0: 		if (cryptoProvider == null)
1: 		{
0: 			// JDK 1.3 does not create providers by itself.
0: 			if (JVMInfo.JDK_ID == 2) {
1: 
0: 				String vendor;
1: 				try {
0: 					vendor = System.getProperty("java.vendor", "");
0: 				} catch (SecurityException se) {
0: 					vendor = "";
1: 				}
1: 
0: 				vendor = StringUtil.SQLToUpperCase(vendor);
1: 
0: 				if (vendor.startsWith("IBM "))
0: 					cryptoProvider = "com.ibm.crypto.provider.IBMJCE";
0: 				else if (vendor.startsWith("SUN "))
0: 					cryptoProvider = "com.sun.crypto.provider.SunJCE";
1: 
1: 			}
1: 		}
1: 		else
1: 		{
1:             provider_or_algo_specified = true;
1: 
1: 			// explictly putting the properties back into the properties
1: 			// saves then in service.properties at create time.
1: 		//	if (storeProperties)
1: 		//		properties.put(Attribute.CRYPTO_PROVIDER, cryptoProvider);
1: 
1: 			int dotPos = cryptoProvider.lastIndexOf('.');
1: 			if (dotPos == -1)
1: 				cryptoProviderShort = cryptoProvider;
1: 			else
1: 				cryptoProviderShort = cryptoProvider.substring(dotPos+1);
1: 
1: 		}
1: 
1:         cryptoAlgorithm = properties.getProperty(Attribute.CRYPTO_ALGORITHM);
1:         if (cryptoAlgorithm == null)
1:             cryptoAlgorithm = DEFAULT_ALGORITHM;
1:         else {
1:             provider_or_algo_specified = true;
1: 
1: 		}
1: 
1: 		// explictly putting the properties back into the properties
1: 		// saves then in service.properties at create time.
1:         if (storeProperties)
0: 			properties.put(Attribute.CRYPTO_ALGORITHM, cryptoAlgorithm);
1: 
1:         int firstSlashPos = cryptoAlgorithm.indexOf('/');
1:         int lastSlashPos = cryptoAlgorithm.lastIndexOf('/');
1:         if (firstSlashPos < 0 || lastSlashPos < 0 || firstSlashPos == lastSlashPos)
1:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_ALG_FORMAT, cryptoAlgorithm);
1: 
1:         cryptoAlgorithmShort = cryptoAlgorithm.substring(0,firstSlashPos);
1: 
1:         if (provider_or_algo_specified)
1:         {
1:             // Track 3715 - disable use of provider/aglo specification if
1:             // jce environment is not 1.2.1.  The ExemptionMechanism class
1:             // exists in jce1.2.1 and not in jce1.2, so try and load the
1:             // class and if you can't find it don't allow the encryption.
0:             // This is a requirement from the government to give cloudscape
1:             // export clearance for 3.6.  Note that the check is not needed
1:             // if no provider/algo is specified, in that case we default to
1:             // a DES weak encryption algorithm which also is allowed for
1:             // export (this is how 3.5 got it's clearance).
1:             try
1:             {
1:                 Class c = Class.forName("javax.crypto.ExemptionMechanism");
1:             }
1:             catch (Throwable t)
1:             {
1:                 throw StandardException.newException(
1:                             SQLState.ENCRYPTION_BAD_JCE);
1:             }
1:         }
1: 
1: 		// If connecting to an existing database and Attribute.CRYPTO_KEY_LENGTH is set
1: 		// then obtain the encoded key length values without padding bytes and retrieve
1: 		// the keylength in bits if boot password mechanism is used 
1: 		// note: Attribute.CRYPTO_KEY_LENGTH is set during creation time to a supported
1: 		// key length in the connection url. Internally , two values are stored in this property
1: 		// if encryptionKey is used, this property will have only the encoded key length
1: 		// if boot password mechanism is used, this property will have the following 
1: 		// keylengthBits-EncodedKeyLength 
1:                  
1: 		if(!create)
1: 		{
1: 		    // if available, parse the keylengths stored in Attribute.CRYPTO_KEY_LENGTH 
1: 		    if(properties.getProperty(Attribute.CRYPTO_KEY_LENGTH) != null)
1: 		    {
1: 			String keyLengths = properties.getProperty(Attribute.CRYPTO_KEY_LENGTH);
1: 		 	int pos = keyLengths.lastIndexOf('-');
1: 			encodedKeyLength = Integer.parseInt(keyLengths.substring(pos+1)); 
1: 			if(pos != -1)
1: 			   keyLengthBits = Integer.parseInt(keyLengths.substring(0,pos));
1: 		    }
1: 		}
1: 			
1: 
1: 		// case 1 - if 'encryptionKey' is not set and 'encryptionKeyLength' is set, then use
1: 		// the 'encryptionKeyLength' property value  as the keyLength in bits.
1: 		// case 2 - 'encryptionKey' property is not set and 'encryptionKeyLength' is not set, then
1: 		// use the defaults keylength:  56bits for DES, 168 for DESede and 128 for any other encryption
1: 		// algorithm
1: 
1: 		if (externalKey == null && create) {
1: 			if(properties.getProperty(Attribute.CRYPTO_KEY_LENGTH) != null)
1: 			{
1: 				keyLengthBits = Integer.parseInt(properties.getProperty(Attribute.CRYPTO_KEY_LENGTH));
1: 			}
1: 			else if (cryptoAlgorithmShort.equals(DES)) {
1: 				keyLengthBits = 56;
1: 			} else if (cryptoAlgorithmShort.equals(DESede) || cryptoAlgorithmShort.equals(TripleDES)) {
1: 				keyLengthBits = 168;
1: 
1: 			} else {
1: 				keyLengthBits = 128;
1: 			}
1: 		}
1: 
1:         // check the feedback mode
1:         String feedbackMode = cryptoAlgorithm.substring(firstSlashPos+1,lastSlashPos);
1: 
1:         if (!feedbackMode.equals("CBC") && !feedbackMode.equals("CFB") &&
1:             !feedbackMode.equals("ECB") && !feedbackMode.equals("OFB"))
1:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_FEEDBACKMODE, feedbackMode);
1: 
1:         // check the NoPadding mode is used
1:         String padding = cryptoAlgorithm.substring(lastSlashPos+1,cryptoAlgorithm.length());
1:         if (!padding.equals("NoPadding"))
1:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_PADDING, padding);
1: 
1: 		Throwable t;
1: 		try
1: 		{
1: 			if (cryptoProvider != null) {
1: 				// provider package should be set by property
1: 				if (Security.getProvider(cryptoProviderShort) == null)
1: 				{
0: 					action = 1;
1: 					// add provider through privileged block.
0: 					java.security.AccessController.doPrivileged(this);
1: 				}
1: 			}
1: 
1: 			// need this to check the boot password
1: 			messageDigest = MessageDigest.getInstance(MESSAGE_DIGEST);
1: 
1: 			byte[] generatedKey;
1: 			if (externalKey != null) {
1: 
1: 				// incorrect to specify external key and boot password
0: 				if (properties.getProperty(Attribute.BOOT_PASSWORD) != null)
1: 					throw StandardException.newException(SQLState.SERVICE_WRONG_BOOT_PASSWORD);
1: 
0: 				generatedKey = org.apache.derby.iapi.util.StringUtil.fromHexString(externalKey, 0, externalKey.length());
1: 				if(create)
0: 		                   properties.put(Attribute.CRYPTO_KEY_LENGTH,String.valueOf(generatedKey.length));	
1: 				else
0: 				  // mismatch in encryptedKey used at creation versus at connecting again
0: 				  if(generatedKey.length != encodedKeyLength && encodedKeyLength > 0)
1: 					throw StandardException.newException(SQLState.ENCRYPTION_BAD_EXTERNAL_KEY);
1: 
1: 			} else {
1: 
0: 				generatedKey = handleBootPassword(create, properties);
1: 				if(create)
0: 				   properties.put(Attribute.CRYPTO_KEY_LENGTH,keyLengthBits+"-"+generatedKey.length);
1: 			}
1: 
1: 			// Make a key and IV object out of the generated key
1: 			mainSecretKey = generateKey(generatedKey);
1: 			mainIV = generateIV(generatedKey);
1: 
1: 			if (create)
1: 			{
0: 				properties.put(Attribute.DATA_ENCRYPTION, "true");
1: 
1: 				// Set two new properties to allow for future changes to the log and data encryption
1: 				// schemes. This property is introduced in version 10 , value starts at 1.
0: 				properties.put(RawStoreFactory.DATA_ENCRYPT_ALGORITHM_VERSION,String.valueOf(1));
0: 				properties.put(RawStoreFactory.LOG_ENCRYPT_ALGORITHM_VERSION,String.valueOf(1));
1: 			}
1: 
1: 			return;
1: 		}
0: 		catch (java.security.PrivilegedActionException  pae)
1: 		{
0: 			t = pae.getException();
1: 		}
1: 		catch (NoSuchAlgorithmException nsae)
1: 		{
1: 			t = nsae;
1: 		}
1: 		catch (SecurityException se)
1: 		{
1: 			t = se;
1: 		} catch (LinkageError le) {
1: 			t = le;
1: 		} catch (ClassCastException cce) {
1: 			t = cce;
1: 		}
1: 
1: 		throw StandardException.newException(SQLState.MISSING_ENCRYPTION_PROVIDER, t);
1: 	}
1: 
0: 	private byte[] handleBootPassword(boolean create, Properties properties)
1: 		throws StandardException {
1: 
0: 		String inputKey = properties.getProperty(Attribute.BOOT_PASSWORD);
1: 		if (inputKey == null)
1: 		{
1: 			throw StandardException.newException(SQLState.SERVICE_WRONG_BOOT_PASSWORD);
1: 		}
1: 
1: 		byte[] bootPassword = StringUtil.getAsciiBytes(inputKey);
1: 
1: 		if (bootPassword.length < CipherFactory.MIN_BOOTPASS_LENGTH)
1: 		{
1: 			String messageId = create ? SQLState.SERVICE_BOOT_PASSWORD_TOO_SHORT :
1: 										SQLState.SERVICE_WRONG_BOOT_PASSWORD;
1: 
1: 			throw StandardException.newException(messageId);
1: 		}
1: 
1: 		// Each database has its own unique encryption key that is
1: 		// not known even to the user.  However, this key is masked
1: 		// with the user input key and stored in the
1: 		// services.properties file so that, with the user key, the
1: 		// encryption key can easily be recovered.
1: 		// To change the user encryption key to a database, simply
1: 		// recover the unique real encryption key and masked it
1: 		// with the new user key.
1: 
1: 		byte[] generatedKey;
1: 
1: 		if (create)
1: 		{
1: 			//
1: 			generatedKey = generateUniqueBytes();
1: 
0: 			properties.put(RawStoreFactory.ENCRYPTED_KEY, saveSecretKey(generatedKey, bootPassword));
1: 
1: 		}
1: 		else
1: 		{
1: 			generatedKey = getDatabaseSecretKey(properties, bootPassword, SQLState.SERVICE_WRONG_BOOT_PASSWORD);
1: 		}
1: 
1: 		return generatedKey;
1: 	}
1: 
0: 	public void stop()
1: 	{
1: 
1: 	}
1: 
1: 
1: 	/**
1: 		get the secretkey used for encryption and decryption when boot password mechanism is used for encryption
1: 		Steps include 
1: 		retrieve the stored key, decrypt the stored key and verify if the correct boot password was passed 
1: 		There is a possibility that the decrypted key includes the original key and padded bytes in order to have
1: 		been block size aligned during encryption phase. Hence extract the original key 
1: 		
1: 		@param	properties	properties to retrieve the encrypted key  
1: 		@param	bootPassword	boot password used to connect to the encrypted database
1: 		@param	errorState	errorstate to account for any errors during retrieval /creation of the secretKey
1: 		@return the original unencrypted key bytes to use for encryption and decrytion   
1: 		
1:          */
1: 	private byte[] getDatabaseSecretKey(Properties properties, byte[] bootPassword, String errorState) throws StandardException {
1: 
1: 		// recover the generated secret encryption key from the
1: 		// services.properties file and the user key.
1: 		String keyString = properties.getProperty(RawStoreFactory.ENCRYPTED_KEY);
1: 		if (keyString == null)
1: 			throw StandardException.newException(errorState);
1: 
1: 		int encodedKeyCharLength = keyString.indexOf('-');
1: 
1: 		if (encodedKeyCharLength == -1) // bad form
1: 			throw StandardException.newException(errorState);
1: 
1: 		int verifyKey = Integer.parseInt(keyString.substring(encodedKeyCharLength+1));
1: 		byte[] generatedKey = decryptKey(keyString, encodedKeyCharLength, bootPassword);
1: 
1: 		int checkKey = digest(generatedKey);
1: 
0: 		if (checkKey != verifyKey)
1: 			throw StandardException.newException(errorState);
1: 
1: 		// if encodedKeyLength is not defined, then either it is an old version with no support for different
1: 		// key sizes and padding except for defaults
1: 	        byte[] result;	
1: 		if(encodedKeyLength != 0)
1: 		{
1: 			result = new byte[encodedKeyLength];
1: 
1: 			// extract the generated key without the padding bytes
1: 			System.arraycopy(generatedKey,0,result,0,encodedKeyLength);
1: 			return result;
1: 		}
1: 
1: 		return generatedKey;
1: 	}
1: 
1: 	private String saveSecretKey(byte[] secretKey, byte[] bootPassword) throws StandardException {
0: 		String encryptedKey = encryptKey(secretKey, bootPassword);
1: 
1: 		// make a verification key out of the message digest of
1: 		// the generated key
0: 		int verifyKey = digest(secretKey);
1: 
1: 		return encryptedKey.concat("-" + verifyKey);
1: 
1: 	}
1: 
1: 	public String changeBootPassword(String changeString, Properties properties, CipherProvider verify)
1: 		throws StandardException {
1: 
1: 		// the new bootPassword is expected to be of the form
1: 		// oldkey , newkey.
1: 		int seperator = changeString.indexOf(',');
1: 		if (seperator == -1)
1: 			throw StandardException.newException(SQLState.WRONG_PASSWORD_CHANGE_FORMAT);
1: 
1: 		String oldBP = changeString.substring(0, seperator).trim();
1: 		byte[] oldBPAscii = StringUtil.getAsciiBytes(oldBP);
1: 		if (oldBPAscii == null || oldBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)
1: 			throw StandardException.newException(SQLState.WRONG_BOOT_PASSWORD);;
1: 
1: 		String newBP = changeString.substring(seperator+1).trim();
1: 		byte[] newBPAscii = StringUtil.getAsciiBytes(newBP);
1: 		if (newBPAscii == null || newBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)
1: 			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH,
0:                 new Integer(CipherFactory.MIN_BOOTPASS_LENGTH));
1: 
1: 		// verify old key
1: 
1: 		byte[] generatedKey = getDatabaseSecretKey(properties, oldBPAscii, SQLState.WRONG_BOOT_PASSWORD);
1: 
1: 		// make sure the oldKey is correct
1: 		byte[] IV = generateIV(generatedKey);
1: 
1: 		if (!((JCECipherProvider) verify).verifyIV(IV))
0: 			throw StandardException.newException(SQLState.WRONG_BOOT_PASSWORD);
1: 
1: 
1: 		// Make the new key.  The generated key is unchanged, only the
1: 		// encrypted key is changed.
1: 		String newkey = saveSecretKey(generatedKey, newBPAscii);
1: 		
1: 		properties.put(Attribute.CRYPTO_KEY_LENGTH,keyLengthBits+"-"+encodedKeyLength);
1: 		
1: 
1: 		return saveSecretKey(generatedKey, newBPAscii);
1: 	}
1: 
1: 	/**
0: 	 	perform actions with privileges enabled.
1: 	 */
0: 	public final Object run() throws StandardException, InstantiationException, IllegalAccessException {
1: 
1: 		try {
1: 
0: 			switch(action)
1: 			{
0: 				case 1:
0: 					Security.addProvider(
0: 					(Provider)(Class.forName(cryptoProvider).newInstance()));
0: 					break;
0: 				case 2:
0: 					// SECURITY PERMISSION - MP1 and/or OP4
0: 					// depends on the value of activePerms
0: 					return activeFile.getRandomAccessFile(activePerms);
1: 
1: 			}
1: 
0: 		} catch (ClassNotFoundException cnfe) {
0: 			throw StandardException.newException(SQLState.ENCRYPTION_NO_PROVIDER_CLASS,cryptoProvider);
1: 		}
0: 		catch(FileNotFoundException fnfe) {
0: 			throw StandardException.newException(SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,cryptoProvider);
1: 		}
0: 		return null;
1: 	}
1: 
1: 
1: 
1: 	/**
1: 	    The database can be encrypted with an encryption key given in connection url.
1: 	    For security reasons, this key is not made persistent in the database.
1: 
1: 	    But it is necessary to verify the encryption key when booting the database if it is similar
1: 	    to the one used when creating the database
1: 	    This needs to happen before we access the data/logs to avoid the risk of corrupting the 
1: 	    database because of a wrong encryption key.
1: 
1: 	    This method performs the steps necessary to verify the encryption key if an external
1: 	    encryption key is given.
1: 
1: 	    At database creation, 4k of random data is generated using SecureRandom and MD5 is used
1: 	    to compute the checksum for the random data thus generated.  This 4k page of random data
1: 	    is then encrypted using the encryption key. The checksum of unencrypted data and
1: 	    encrypted data is made persistent in the database in file by name given by
1: 	    Attribute.CRYPTO_EXTERNAL_KEY_VERIFYFILE (verifyKey.dat). This file exists directly under the
1: 	    database root directory.
1: 
1: 	    When trying to boot an existing encrypted database, the given encryption key is used to decrypt
1: 	    the data in the verifyKey.dat and the checksum is calculated and compared against the original
1: 	    stored checksum. If these checksums dont match an exception is thrown.
1: 
1: 	    Please note, this process of verifying the key  does not provide any added security but only is 
1: 	    intended to allow to fail gracefully if a wrong encryption key is used
1: 
0: 	    @return StandardException is thrown if there are any problems during the process of verification
1: 	    		of the encryption key or if there is any mismatch of the encryption key.
1: 
1: 	 */
1: 
1: 	public void verifyKey(boolean create, StorageFactory sf, Properties properties)
1: 		throws StandardException
1: 	{
1: 
1: 		if(properties.getProperty(Attribute.CRYPTO_EXTERNAL_KEY) == null)
1: 			return;
1: 
1: 		// if firstTime ( ie during creation of database, initial key used )
1: 		// In order to allow for verifying the external key for future database boot,
1: 		// generate random 4k of data and store the encrypted random data and the checksum
1: 		// using MD5 of the unencrypted data. That way, on next database boot a check is performed
1: 		// to verify if the key is the same as used when the database was created
1: 
1: 		StorageRandomAccessFile verifyKeyFile = null;
1: 		byte[] data = new byte[VERIFYKEY_DATALEN];
1: 		try
1: 		{
1: 			if(create)
1: 			{
1: 				getSecureRandom().nextBytes(data);
1: 				// get the checksum
1: 				byte[] checksum = getMD5Checksum(data);
1: 
1: 				CipherProvider tmpCipherProvider = createNewCipher(ENCRYPT,mainSecretKey,mainIV);
1: 				tmpCipherProvider.encrypt(data, 0, data.length, data, 0);
1: 				// openFileForWrite
1: 				verifyKeyFile = privAccessFile(sf,Attribute.CRYPTO_EXTERNAL_KEY_VERIFY_FILE,"rw");
1: 				// write the checksum length as int, and then the checksum and then the encrypted data
1: 				verifyKeyFile.writeInt(checksum.length);
1: 				verifyKeyFile.write(checksum);
1: 				verifyKeyFile.write(data);
0: 				verifyKeyFile.sync(true);
1: 			}
1: 			else
1: 			{
0: 				// open file for reading only
0: 				verifyKeyFile = privAccessFile(sf,Attribute.CRYPTO_EXTERNAL_KEY_VERIFY_FILE,"r");
1: 				// then read the checksum length 
0: 				int checksumLen = verifyKeyFile.readInt();
1: 
1: 				byte[] originalChecksum = new byte[checksumLen];
0: 				verifyKeyFile.readFully(originalChecksum);
1: 
0: 				verifyKeyFile.readFully(data);
1: 
1: 				// decrypt data with key
1: 				CipherProvider tmpCipherProvider = createNewCipher(DECRYPT,mainSecretKey,mainIV);
1: 				tmpCipherProvider.decrypt(data, 0, data.length, data, 0);
1: 
1: 				byte[] verifyChecksum = getMD5Checksum(data);
1: 
1: 				if(!MessageDigest.isEqual(originalChecksum,verifyChecksum))
1: 				{
1: 					throw StandardException.newException(SQLState.ENCRYPTION_BAD_EXTERNAL_KEY);
1: 				}
1: 
1: 			}
1: 		}
1: 		catch(IOException ioe)
1: 		{
1: 			throw StandardException.newException(SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,ioe);
1: 		}
1: 		finally
1: 		{
1: 			try
1: 			{
1: 				if(verifyKeyFile != null)
1: 					verifyKeyFile.close();
1: 			}
1: 			catch(IOException ioee)
1: 			{
1: 				throw StandardException.newException(SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,ioee);
1: 			}
1: 		}
1: 		return ;
1: 	}
1: 
1: 
1: 	/**
1: 		Use MD5 MessageDigest algorithm to generate checksum
1: 		@param data	data to be used to compute the hash value
1: 		@return returns the hash value computed using the data
1: 
1: 	 */
1: 	private byte[] getMD5Checksum(byte[] data)
1: 		throws StandardException
1: 	{
1: 		try
1: 		{
1: 			// get the checksum
1: 			MessageDigest md5 = MessageDigest.getInstance("MD5");
1: 			return md5.digest(data);
1: 		}
1: 		catch(NoSuchAlgorithmException nsae)
1: 		{
1: 			throw StandardException.newException(SQLState.ENCRYPTION_BAD_ALG_FORMAT,MESSAGE_DIGEST);
1: 		}
1: 
1: 	}
1: 
1: 
1: 	/**
1: 	 	access a file for either read/write
1: 	 	@param storageFactory	factory used for io access
1: 	 	@param	fileName		name of the file to create and open for write
1:  							The file will be created directly under the database root directory
1: 		@param	filePerms		file permissions, if "rw" open file with read and write permissions
1: 							    if "r" , open file with read permissions
1: 	 	@return	StorageRandomAccessFile returns file with fileName for writing
1: 		@exception IOException Any exception during accessing the file for read/write
1: 	 */
0: 	private StorageRandomAccessFile privAccessFile(StorageFactory storageFactory,String fileName,String filePerms)
1: 		throws java.io.IOException
1: 	{
0: 		StorageFile verifyKeyFile = storageFactory.newStorageFile("",fileName);
0: 		activeFile  = verifyKeyFile;
0: 		this.action = 2;
0: 		activePerms = filePerms;
1: 	    try
1:         {
0: 			return (StorageRandomAccessFile)java.security.AccessController.doPrivileged(this);
1: 		}
1: 		catch( java.security.PrivilegedActionException pae)
1: 		{
1: 			throw (java.io.IOException)pae.getException();
1: 		}
1: 	}
1: 
1: 
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby Error Policy
/////////////////////////////////////////////////////////////////////////
1:             // This is a requirement from the government to give Cloudscape
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:97cac2e
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.io.DataInputStream;
/////////////////////////////////////////////////////////////////////////
0:                 case 3:
0:                     return activeFile.getInputStream();
/////////////////////////////////////////////////////////////////////////
1:         InputStream verifyKeyInputStream = null;
/////////////////////////////////////////////////////////////////////////
1: 				// Read from verifyKey.dat as an InputStream. This allows for 
1:                 // reading the information from verifyKey.dat successfully even when using the jar
1:                 // subprotocol to boot derby. (DERBY-1373) 
1: 				verifyKeyInputStream = privAccessGetInputStream(sf,Attribute.CRYPTO_EXTERNAL_KEY_VERIFY_FILE);
1:                 DataInputStream dis = new DataInputStream(verifyKeyInputStream);
1: 				int checksumLen = dis.readInt();
1: 				dis.readFully(originalChecksum);
1: 				dis.readFully(data);
/////////////////////////////////////////////////////////////////////////
1:                 if (verifyKeyInputStream != null )
1:                     verifyKeyInputStream.close();
/////////////////////////////////////////////////////////////////////////
0: 	/**
1: 	 access a InputStream for a given file for reading.
1: 	 @param storageFactory   factory used for io access
1: 	 @param  fileName        name of the file to open as a stream for reading
1: 	 @return InputStream returns the stream for the file with fileName for reading
1: 	 @exception IOException Any exception during accessing the file for read
1: 	 */
1: 	private InputStream privAccessGetInputStream(StorageFactory storageFactory,String fileName)
1: 	throws StandardException
1: 	{
0: 	    StorageFile verifyKeyFile = storageFactory.newStorageFile("",fileName);
0: 	    activeFile  = verifyKeyFile;
0: 	    this.action = 3;
1: 	    try
1: 	    {
0: 	        return (InputStream)java.security.AccessController.doPrivileged(this);
0: 	    }
1: 	    catch( java.security.PrivilegedActionException pae)
1: 	    {
0: 	        throw (StandardException)pae.getException();
0: 	    }
0: 	}
commit:8a62d60
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0: public final class JCECipherFactory implements CipherFactory, java.security.PrivilegedExceptionAction
/////////////////////////////////////////////////////////////////////////
0: 
1:     /*
1:      * Constructor of JCECipherFactory, initializes the new instances.
1:      *
1:      * @param create    true, if the database is getting configured 
1:      *                  for encryption.
1:      * @param props	    encryption properties/attributes to use
1:      *                  for creating the cipher factory.
1:      * @param newAttrs  true, if cipher factory has to be created using 
1:      *                  should using the new attributes specified by the user.  
1:      *                  For example to reencrypt the database with 
1:      *                  a new password.
0:      */
0:     public JCECipherFactory(boolean create, 
1:                             Properties props,
1:                             boolean newAttributes) 
1:         throws StandardException
0:     {
1:         init(create, props, newAttributes);
0:     }
0:     
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:     /*
1:      * Initilize the new instance of this class. 
0:      */
0: 	public void	init(boolean create, Properties properties, boolean newAttrs)
/////////////////////////////////////////////////////////////////////////
1:         // get the external key specified by the user to 
1:         // encrypt the database. If user is reencrypting the
1:         // database with a new encryption key,  read the value of 
1:         // the new encryption key. 
1:         String externalKey =  properties.getProperty((newAttrs ? 
1:                                                       Attribute.NEW_CRYPTO_EXTERNAL_KEY:
1:                                                       Attribute.CRYPTO_EXTERNAL_KEY));
/////////////////////////////////////////////////////////////////////////
1: 				if (properties.getProperty((newAttrs ? 
1:                                             Attribute.NEW_BOOT_PASSWORD :
1:                                             Attribute.BOOT_PASSWORD)) != null)
1: 				generatedKey = 
1:                     org.apache.derby.iapi.util.StringUtil.fromHexString(externalKey, 
1:                                                                         0, 
1:                                                                         externalKey.length());
/////////////////////////////////////////////////////////////////////////
1: 				generatedKey = handleBootPassword(create, properties, newAttrs);
1: 				if(create || newAttrs)
/////////////////////////////////////////////////////////////////////////
0: 
1: 	private byte[] handleBootPassword(boolean create, 
1:                                       Properties properties, 
1:                                       boolean newPasswd)
0: 
1:         // get the key  specifed by the user. If user is reencrypting the
1:         // database; read the value of the new password. 
1: 		String inputKey = properties.getProperty((newPasswd ? 
1:                                                   Attribute.NEW_BOOT_PASSWORD : 
1:                                                   Attribute.BOOT_PASSWORD));
/////////////////////////////////////////////////////////////////////////
1: 		if (create || newPasswd)
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ae71c74
/////////////////////////////////////////////////////////////////////////
1: import java.util.Enumeration;
/////////////////////////////////////////////////////////////////////////
1:     // properties that needs to be stored in the
1:     // in the service.properties file.
1:     private Properties persistentProperties;
0: 
0: 
/////////////////////////////////////////////////////////////////////////
1:         persistentProperties = new Properties();
/////////////////////////////////////////////////////////////////////////
1: 			persistentProperties.put(Attribute.CRYPTO_ALGORITHM, 
1:                                      cryptoAlgorithm);
/////////////////////////////////////////////////////////////////////////
1: 				   persistentProperties.put(Attribute.CRYPTO_KEY_LENGTH,
1:                                             keyLengthBits+"-"+generatedKey.length);
/////////////////////////////////////////////////////////////////////////
1: 				persistentProperties.put(Attribute.DATA_ENCRYPTION, "true");
1: 				persistentProperties.put(RawStoreFactory.DATA_ENCRYPT_ALGORITHM_VERSION,
1:                                                String.valueOf(1));
1: 				persistentProperties.put(RawStoreFactory.LOG_ENCRYPT_ALGORITHM_VERSION,
1:                                                String.valueOf(1));
/////////////////////////////////////////////////////////////////////////
1: 			persistentProperties.put(RawStoreFactory.ENCRYPTED_KEY, 
1:                                            saveSecretKey(generatedKey, bootPassword));
/////////////////////////////////////////////////////////////////////////
0:     /* 
1:      * put all the encyrpion cipger related properties that has to 
1:      * be made peristent into the database service properties list.
1:      * @param  properties  properties object that is used to store 
1:      *                     cipher properties persistently. 
0:      */
1:     public void saveProperties(Properties properties) 
0:     {
1:         // put the cipher properties to be persistent into the 
1:         // system perisistent properties. 
1:         for (Enumeration e = persistentProperties.keys(); 
1:              e.hasMoreElements(); ) 
0:         {
1:             String key = (String) e.nextElement();
1:             properties.put(key, persistentProperties.get(key));
0: 		}
0: 
1:         // clear the cipher properties to be persistent. 
1:         persistentProperties = null;
0:     }
0: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	    StandardException is thrown if there are any problems during the process of verification
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.jce
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.services.jce;
0: 
0: import org.apache.derby.iapi.services.crypto.CipherFactory;
0: import org.apache.derby.iapi.services.crypto.CipherProvider;
0: 
0: import org.apache.derby.iapi.services.monitor.ModuleControl;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.services.info.JVMInfo;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.Attribute;
0: import org.apache.derby.iapi.util.StringUtil;
0: 
0: import java.util.Properties;
0: 
0: import java.security.Key;
0: import java.security.Provider;
0: import java.security.SecureRandom;
0: import java.security.Security;
0: import java.security.InvalidKeyException;
0: import java.security.NoSuchAlgorithmException;
0: import java.security.MessageDigest;
0: import java.security.spec.KeySpec;
0: import java.security.spec.InvalidKeySpecException;
0: import java.io.FileNotFoundException;
0: import java.io.IOException;
0: 
0: import javax.crypto.KeyGenerator;
0: import javax.crypto.SecretKey;
0: import javax.crypto.SecretKeyFactory;
0: import javax.crypto.spec.DESKeySpec;
0: import javax.crypto.spec.SecretKeySpec;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: 
0: import org.apache.derby.io.StorageFactory;
0: import org.apache.derby.io.WritableStorageFactory;
0: import org.apache.derby.io.StorageFile;
0: import org.apache.derby.io.StorageRandomAccessFile;
0: /**
0: 	This CipherFactory creates new JCECipherProvider.
0: 
0: 	@see CipherFactory
0:  */
0: public final class JCECipherFactory implements CipherFactory, ModuleControl, java.security.PrivilegedExceptionAction
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0:     private final static String MESSAGE_DIGEST = "MD5";
0: 
0: 	private final static String DEFAULT_PROVIDER = "com.sun.crypto.provider.SunJCE";
0: 	private final static String DEFAULT_ALGORITHM = "DES/CBC/NoPadding";
0: 	private final static String DES = "DES";
0: 	private final static String DESede = "DESede";
0:     private final static String TripleDES = "TripleDES";
0:     private final static String AES = "AES";
0: 
0:     // minimum boot password length in bytes
0:     private final static int BLOCK_LENGTH = 8;
0: 
0:     /**
0: 	AES encryption takes in an default Initialization vector length (IV) length of 16 bytes
0: 	This is needed to generate an IV to use for encryption and decryption process 
0: 	@see CipherProvider
0:      */
0:     private final static int AES_IV_LENGTH = 16;
0: 
0:     // key length in bytes
0: 	private int keyLengthBits;
0:     private int encodedKeyLength;
0:     private String cryptoAlgorithm;
0:     private String cryptoAlgorithmShort;
0:     private String cryptoProvider;
0:     private String cryptoProviderShort;
0: 	private MessageDigest messageDigest;
0: 
0: 	private SecretKey mainSecretKey;
0: 	private byte[] mainIV;
0: 
0: 	/**
0: 	    Amount of data that is used for verification of external encryption key
0: 	    This does not include the MD5 checksum bytes
0: 	 */
0: 	private final static int VERIFYKEY_DATALEN = 4096;
0: 	private StorageFile activeFile;
0: 	private int action;
0: 	private String activePerms;
0: 
0: 	static String providerErrorName(String cps) {
0: 
0: 		return cps == null ? "default" : cps;
0: 	}
0: 
0: 
0: 	private byte[] generateUniqueBytes() throws StandardException
0: 	{
0: 		try {
0: 
0: 			String provider = cryptoProviderShort;
0: 
0: 			KeyGenerator keyGen;
0: 			if (provider == null)
0: 			{
0: 				keyGen = KeyGenerator.getInstance(cryptoAlgorithmShort);
0: 			}
0: 			else
0: 			{
0: 				if( provider.equals("BouncyCastleProvider"))
0: 					provider = "BC";
0: 				keyGen = KeyGenerator.getInstance(cryptoAlgorithmShort, provider);
0: 			}
0: 
0: 			keyGen.init(keyLengthBits);
0: 
0: 			SecretKey key = keyGen.generateKey();
0: 
0: 			return key.getEncoded();
0: 
0: 		} catch (java.security.NoSuchAlgorithmException nsae) {
0:     		throw StandardException.newException(SQLState.ENCRYPTION_NOSUCH_ALGORITHM, cryptoAlgorithm,
0: 				JCECipherFactory.providerErrorName(cryptoProviderShort));
0: 		} catch (java.security.NoSuchProviderException nspe) {
0: 			throw StandardException.newException(SQLState.ENCRYPTION_BAD_PROVIDER,
0: 				JCECipherFactory.providerErrorName(cryptoProviderShort));
0: 		}
0: 	}
0: 
0: 	/**
0: 		Encrypt the secretKey with the boot password.
0: 		This includes the following steps, 
0: 		getting muck from the boot password and then using this to generate a key,
0: 		generating an appropriate IV using the muck
0: 		using the key and IV thus generated to create the appropriate cipher provider
0: 		and encrypting the secretKey 
0: 		@return hexadecimal string of the encrypted secretKey
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	private String encryptKey(byte[] secretKey, byte[] bootPassword)
0: 		 throws StandardException
0: 	{
0: 		// In case of AES, care needs to be taken to allow for 16 bytes muck as well
0: 		// as to have the secretKey that needs encryption to be a aligned appropriately
0: 		// AES supports 16 bytes block size
0: 
0: 		int muckLength = secretKey.length;
0: 		if(cryptoAlgorithmShort.equals(AES))
0: 			muckLength = AES_IV_LENGTH;		
0: 
0: 		byte[] muck = getMuckFromBootPassword(bootPassword, muckLength);
0: 		SecretKey key = generateKey(muck);
0: 		byte[] IV = generateIV(muck);
0:                 CipherProvider tmpCipherProvider = createNewCipher(ENCRYPT,key,IV);
0: 		
0: 		// store the actual secretKey.length before any possible padding  
0: 		encodedKeyLength = secretKey.length;
0: 
0: 		// for the secretKey to be encrypted, first ensure that it is aligned to the block size of the 
0: 		// encryption algorithm by padding bytes appropriately if needed
0:                 secretKey = padKey(secretKey,tmpCipherProvider.getEncryptionBlockSize());
0: 
0:                 byte[] result = new byte[secretKey.length];
0: 
0: 		// encrypt the secretKey using the key generated of muck from  boot password and the generated IV  
0: 		tmpCipherProvider.encrypt(secretKey, 0, secretKey.length, result, 0);
0: 
0: 		return org.apache.derby.iapi.util.StringUtil.toHexString(result, 0, result.length);
0: 
0: 	}
0: 	
0: 	/**
0:             For block ciphers, and  algorithms using the NoPadding scheme, the data that has 
0:             to be encrypted needs to be a multiple of the expected block size for the cipher 
0: 	    Pad the key with appropriate padding to make it blockSize align
0: 	    @param     secretKey	the data that needs blocksize alignment
0: 	    @param     blockSizeAlign   secretKey needs to be blocksize aligned		
0: 	    @return    a byte array with the contents of secretKey along with padded bytes in the end
0: 		       to make it blockSize aligned
0:          */
0: 	private byte[] padKey(byte[] secretKey,int blockSizeAlign)
0: 	{
0: 	    byte [] result = secretKey;
0: 	    if(secretKey.length % blockSizeAlign != 0 )
0: 	    {
0: 		int encryptedLength = secretKey.length + blockSizeAlign - (secretKey.length % blockSizeAlign);
0: 		result = new byte[encryptedLength];
0: 		System.arraycopy(secretKey,0,result,0,secretKey.length);
0: 	    }
0: 	    return result;
0: 	}
0: 
0: 	/**
0: 	    Decrypt the secretKey with the user key .
0: 	    This includes the following steps, 
0: 	    retrieve the encryptedKey, generate the muck from the boot password and generate an appropriate IV using
0: 	    the muck,and using the key and IV decrypt the encryptedKey 
0: 	    @return decrypted key  
0: 		@exception StandardException Standard Cloudscape error policy
0: 	 */
0: 	private byte[] decryptKey(String encryptedKey, int encodedKeyCharLength, byte[] bootPassword)
0: 		 throws StandardException
0: 	{
0: 		byte[] secretKey = org.apache.derby.iapi.util.StringUtil.fromHexString(encryptedKey, 0, encodedKeyCharLength);
0: 		// In case of AES, care needs to be taken to allow for 16 bytes muck as well
0: 		// as to have the secretKey that needs encryption to be a aligned appropriately
0: 		// AES supports 16 bytes block size
0: 		int muckLength;
0: 		if(cryptoAlgorithmShort.equals(AES))
0: 		    muckLength = AES_IV_LENGTH;
0: 		else
0: 	            muckLength = secretKey.length;	
0: 
0: 		byte[] muck = getMuckFromBootPassword(bootPassword, muckLength);
0: 
0: 
0: 		// decrypt the encryptedKey with the mucked up boot password to recover
0: 		// the secretKey
0: 		SecretKey key = generateKey(muck);
0: 		byte[] IV = generateIV(muck);
0: 
0: 
0: 		createNewCipher(DECRYPT, key, IV).
0: 			decrypt(secretKey, 0, secretKey.length, secretKey, 0);
0: 
0: 		return secretKey;
0: 	}
0: 
0: 	private byte[] getMuckFromBootPassword(byte[] bootPassword, int encodedKeyByteLength) {
0: 		int ulength = bootPassword.length;
0: 
0: 		byte[] muck = new byte[encodedKeyByteLength];
0: 		
0: 
0: 		int rotation = 0;
0: 		for (int i = 0; i < bootPassword.length; i++)
0: 			rotation += bootPassword[i];
0: 
0: 		for (int i = 0; i < encodedKeyByteLength; i++)
0: 			muck[i] = (byte)(bootPassword[(i+rotation)%ulength] ^
0:                 (bootPassword[i%ulength] << 4));
0: 
0: 		return muck;
0: 	}
0: 
0: 	/**
0: 		Generate a Key object using the input secretKey that can be used by
0: 		JCECipherProvider to encrypt or decrypt.
0: 
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	private SecretKey generateKey(byte[] secretKey) throws StandardException
0: 	{
0: 		int length = secretKey.length;
0: 
0: 		if (length < CipherFactory.MIN_BOOTPASS_LENGTH)
0: 			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH, new Integer(MIN_BOOTPASS_LENGTH));
0: 
0: 		try
0: 		{
0:             if (cryptoAlgorithmShort.equals(DES))
0:             {   // single DES
0: 			    if (DESKeySpec.isWeak(secretKey, 0))
0: 			    {
0: 				    // OK, it is weak, spice it up
0: 				    byte[] spice = StringUtil.getAsciiBytes("louDScap");
0: 				    for (int i = 0; i < 7; i++)
0: 					    secretKey[i] = (byte)((spice[i] << 3) ^ secretKey[i]);
0: 			    }
0:             }
0: 			return new SecretKeySpec(secretKey, cryptoAlgorithmShort);
0: 		}
0: 		catch (InvalidKeyException ike)
0: 		{
0: 			throw StandardException.newException(SQLState.CRYPTO_EXCEPTION, ike);
0: 		}
0: 
0: 	}
0: 
0: 	/**
0: 		Generate an IV using the input secretKey that can be used by
0: 		JCECipherProvider to encrypt or decrypt.
0: 	 */
0: 	private byte[] generateIV(byte[] secretKey)
0: 	{
0: 
0: 		// do a little simple minded muddling to make the IV not
0: 		// strictly alphanumeric and the number of total possible keys a little
0: 		// bigger.
0: 		int IVlen = BLOCK_LENGTH;
0: 		
0: 		byte[] iv = null;
0: 		if(cryptoAlgorithmShort.equals(AES))
0: 		{
0: 			IVlen = AES_IV_LENGTH;
0: 			iv = new byte[IVlen];
0: 			iv[0] = (byte)(((secretKey[secretKey.length-1] << 2) | 0xF) ^ secretKey[0]);
0: 			for (int i = 1; i < BLOCK_LENGTH; i++)
0: 				iv[i] = (byte)(((secretKey[i-1] << (i%5)) | 0xF) ^ secretKey[i]);
0: 			
0: 			for(int i = BLOCK_LENGTH ; i < AES_IV_LENGTH ; i++)
0: 			{
0: 				iv[i]=iv[i-BLOCK_LENGTH];
0: 			}
0: 			
0: 		}	
0: 		else
0: 		{
0: 			iv = new byte[BLOCK_LENGTH];
0: 			iv[0] = (byte)(((secretKey[secretKey.length-1] << 2) | 0xF) ^ secretKey[0]);
0: 			for (int i = 1; i < BLOCK_LENGTH; i++)
0: 				iv[i] = (byte)(((secretKey[i-1] << (i%5)) | 0xF) ^ secretKey[i]);	
0: 		}
0: 
0: 		return iv;
0: 	}
0: 
0: 	private int digest(byte[] input)
0: 	{
0: 		messageDigest.reset();
0: 		byte[] digest = messageDigest.digest(input);
0: 		byte[] condenseDigest = new byte[2];
0: 
0: 		// no matter how long the digest is, condense it into an short.
0: 		for (int i = 0; i < digest.length; i++)
0: 			condenseDigest[i%2] ^= digest[i];
0: 
0: 		int retval = (condenseDigest[0] & 0xFF) | ((condenseDigest[1] << 8) & 0xFF00);
0: 
0: 		return retval;
0: 	}
0: 
0: 	public SecureRandom getSecureRandom() {
0: 		return new SecureRandom(mainIV);
0: 	}
0: 
0: 	public CipherProvider createNewCipher(int mode)
0: 										  throws StandardException {
0: 		return createNewCipher(mode, mainSecretKey, mainIV);
0: 	}
0: 
0: 
0: 	private CipherProvider createNewCipher(int mode, SecretKey secretKey,
0: 										  byte[] iv)
0: 		 throws StandardException
0: 	{
0: 		return new JCECipherProvider(mode, secretKey, iv, cryptoAlgorithm, cryptoProviderShort);
0: 	}
0: 
0: 	/*
0: 	 * module control methods
0: 	 */
0: 
0: 	public void	boot(boolean create, Properties properties)
0: 		throws StandardException
0: 	{
0: 
0: 		if (SanityManager.DEBUG) {
0: 			if (JVMInfo.JDK_ID < 2)
0: 				SanityManager.THROWASSERT("expected JDK ID to be 2 - is " + JVMInfo.JDK_ID);
0: 		}
0: 
0:         boolean provider_or_algo_specified = false;
0: 		boolean storeProperties = create;
0: 
0: 		String externalKey = properties.getProperty(Attribute.CRYPTO_EXTERNAL_KEY);
0: 		if (externalKey != null) {
0: 			storeProperties = false;
0: 		}
0: 
0:         cryptoProvider = properties.getProperty(Attribute.CRYPTO_PROVIDER);
0: 
0: 		if (cryptoProvider == null)
0: 		{
0: 			// JDK 1.3 does not create providers by itself.
0: 			if (JVMInfo.JDK_ID == 2) {
0: 
0: 				String vendor;
0: 				try {
0: 					vendor = System.getProperty("java.vendor", "");
0: 				} catch (SecurityException se) {
0: 					vendor = "";
0: 				}
0: 
0: 				vendor = StringUtil.SQLToUpperCase(vendor);
0: 
0: 				if (vendor.startsWith("IBM "))
0: 					cryptoProvider = "com.ibm.crypto.provider.IBMJCE";
0: 				else if (vendor.startsWith("SUN "))
0: 					cryptoProvider = "com.sun.crypto.provider.SunJCE";
0: 
0: 			}
0: 		}
0: 		else
0: 		{
0:             provider_or_algo_specified = true;
0: 
0: 			// explictly putting the properties back into the properties
0: 			// saves then in service.properties at create time.
0: 		//	if (storeProperties)
0: 		//		properties.put(Attribute.CRYPTO_PROVIDER, cryptoProvider);
0: 
0: 			int dotPos = cryptoProvider.lastIndexOf('.');
0: 			if (dotPos == -1)
0: 				cryptoProviderShort = cryptoProvider;
0: 			else
0: 				cryptoProviderShort = cryptoProvider.substring(dotPos+1);
0: 
0: 		}
0: 
0:         cryptoAlgorithm = properties.getProperty(Attribute.CRYPTO_ALGORITHM);
0:         if (cryptoAlgorithm == null)
0:             cryptoAlgorithm = DEFAULT_ALGORITHM;
0:         else {
0:             provider_or_algo_specified = true;
0: 
0: 		}
0: 
0: 		// explictly putting the properties back into the properties
0: 		// saves then in service.properties at create time.
0:         if (storeProperties)
0: 			properties.put(Attribute.CRYPTO_ALGORITHM, cryptoAlgorithm);
0: 
0:         int firstSlashPos = cryptoAlgorithm.indexOf('/');
0:         int lastSlashPos = cryptoAlgorithm.lastIndexOf('/');
0:         if (firstSlashPos < 0 || lastSlashPos < 0 || firstSlashPos == lastSlashPos)
0:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_ALG_FORMAT, cryptoAlgorithm);
0: 
0:         cryptoAlgorithmShort = cryptoAlgorithm.substring(0,firstSlashPos);
0: 
0:         if (provider_or_algo_specified)
0:         {
0:             // Track 3715 - disable use of provider/aglo specification if
0:             // jce environment is not 1.2.1.  The ExemptionMechanism class
0:             // exists in jce1.2.1 and not in jce1.2, so try and load the
0:             // class and if you can't find it don't allow the encryption.
0:             // This is a requirement from the government to give cloudscape
0:             // export clearance for 3.6.  Note that the check is not needed
0:             // if no provider/algo is specified, in that case we default to
0:             // a DES weak encryption algorithm which also is allowed for
0:             // export (this is how 3.5 got it's clearance).
0:             try
0:             {
0:                 Class c = Class.forName("javax.crypto.ExemptionMechanism");
0:             }
0:             catch (Throwable t)
0:             {
0:                 throw StandardException.newException(
0:                             SQLState.ENCRYPTION_BAD_JCE);
0:             }
0:         }
0: 
0: 		// If connecting to an existing database and Attribute.CRYPTO_KEY_LENGTH is set
0: 		// then obtain the encoded key length values without padding bytes and retrieve
0: 		// the keylength in bits if boot password mechanism is used 
0: 		// note: Attribute.CRYPTO_KEY_LENGTH is set during creation time to a supported
0: 		// key length in the connection url. Internally , two values are stored in this property
0: 		// if encryptionKey is used, this property will have only the encoded key length
0: 		// if boot password mechanism is used, this property will have the following 
0: 		// keylengthBits-EncodedKeyLength 
0:                  
0: 		if(!create)
0: 		{
0: 		    // if available, parse the keylengths stored in Attribute.CRYPTO_KEY_LENGTH 
0: 		    if(properties.getProperty(Attribute.CRYPTO_KEY_LENGTH) != null)
0: 		    {
0: 			String keyLengths = properties.getProperty(Attribute.CRYPTO_KEY_LENGTH);
0: 		 	int pos = keyLengths.lastIndexOf('-');
0: 			encodedKeyLength = Integer.parseInt(keyLengths.substring(pos+1)); 
0: 			if(pos != -1)
0: 			   keyLengthBits = Integer.parseInt(keyLengths.substring(0,pos));
0: 		    }
0: 		}
0: 			
0: 
0: 		// case 1 - if 'encryptionKey' is not set and 'encryptionKeyLength' is set, then use
0: 		// the 'encryptionKeyLength' property value  as the keyLength in bits.
0: 		// case 2 - 'encryptionKey' property is not set and 'encryptionKeyLength' is not set, then
0: 		// use the defaults keylength:  56bits for DES, 168 for DESede and 128 for any other encryption
0: 		// algorithm
0: 
0: 		if (externalKey == null && create) {
0: 			if(properties.getProperty(Attribute.CRYPTO_KEY_LENGTH) != null)
0: 			{
0: 				keyLengthBits = Integer.parseInt(properties.getProperty(Attribute.CRYPTO_KEY_LENGTH));
0: 			}
0: 			else if (cryptoAlgorithmShort.equals(DES)) {
0: 				keyLengthBits = 56;
0: 			} else if (cryptoAlgorithmShort.equals(DESede) || cryptoAlgorithmShort.equals(TripleDES)) {
0: 				keyLengthBits = 168;
0: 
0: 			} else {
0: 				keyLengthBits = 128;
0: 			}
0: 		}
0: 
0:         // check the feedback mode
0:         String feedbackMode = cryptoAlgorithm.substring(firstSlashPos+1,lastSlashPos);
0: 
0:         if (!feedbackMode.equals("CBC") && !feedbackMode.equals("CFB") &&
0:             !feedbackMode.equals("ECB") && !feedbackMode.equals("OFB"))
0:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_FEEDBACKMODE, feedbackMode);
0: 
0:         // check the NoPadding mode is used
0:         String padding = cryptoAlgorithm.substring(lastSlashPos+1,cryptoAlgorithm.length());
0:         if (!padding.equals("NoPadding"))
0:     		throw StandardException.newException(SQLState.ENCRYPTION_BAD_PADDING, padding);
0: 
0: 		Throwable t;
0: 		try
0: 		{
0: 			if (cryptoProvider != null) {
0: 				// provider package should be set by property
0: 				if (Security.getProvider(cryptoProviderShort) == null)
0: 				{
0: 					action = 1;
0: 					// add provider through privileged block.
0: 					java.security.AccessController.doPrivileged(this);
0: 				}
0: 			}
0: 
0: 			// need this to check the boot password
0: 			messageDigest = MessageDigest.getInstance(MESSAGE_DIGEST);
0: 
0: 			byte[] generatedKey;
0: 			if (externalKey != null) {
0: 
0: 				// incorrect to specify external key and boot password
0: 				if (properties.getProperty(Attribute.BOOT_PASSWORD) != null)
0: 					throw StandardException.newException(SQLState.SERVICE_WRONG_BOOT_PASSWORD);
0: 
0: 				generatedKey = org.apache.derby.iapi.util.StringUtil.fromHexString(externalKey, 0, externalKey.length());
0: 				if(create)
0: 		                   properties.put(Attribute.CRYPTO_KEY_LENGTH,String.valueOf(generatedKey.length));	
0: 				else
0: 				  // mismatch in encryptedKey used at creation versus at connecting again
0: 				  if(generatedKey.length != encodedKeyLength && encodedKeyLength > 0)
0: 					throw StandardException.newException(SQLState.ENCRYPTION_BAD_EXTERNAL_KEY);
0: 
0: 			} else {
0: 
0: 				generatedKey = handleBootPassword(create, properties);
0: 				if(create)
0: 				   properties.put(Attribute.CRYPTO_KEY_LENGTH,keyLengthBits+"-"+generatedKey.length);
0: 			}
0: 
0: 			// Make a key and IV object out of the generated key
0: 			mainSecretKey = generateKey(generatedKey);
0: 			mainIV = generateIV(generatedKey);
0: 
0: 			if (create)
0: 			{
0: 				properties.put(Attribute.DATA_ENCRYPTION, "true");
0: 
0: 				// Set two new properties to allow for future changes to the log and data encryption
0: 				// schemes. This property is introduced in version 10 , value starts at 1.
0: 				properties.put(RawStoreFactory.DATA_ENCRYPT_ALGORITHM_VERSION,String.valueOf(1));
0: 				properties.put(RawStoreFactory.LOG_ENCRYPT_ALGORITHM_VERSION,String.valueOf(1));
0: 			}
0: 
0: 			return;
0: 		}
0: 		catch (java.security.PrivilegedActionException  pae)
0: 		{
0: 			t = pae.getException();
0: 		}
0: 		catch (NoSuchAlgorithmException nsae)
0: 		{
0: 			t = nsae;
0: 		}
0: 		catch (SecurityException se)
0: 		{
0: 			t = se;
0: 		} catch (LinkageError le) {
0: 			t = le;
0: 		} catch (ClassCastException cce) {
0: 			t = cce;
0: 		}
0: 
0: 		throw StandardException.newException(SQLState.MISSING_ENCRYPTION_PROVIDER, t);
0: 	}
0: 
0: 	private byte[] handleBootPassword(boolean create, Properties properties)
0: 		throws StandardException {
0: 
0: 		String inputKey = properties.getProperty(Attribute.BOOT_PASSWORD);
0: 		if (inputKey == null)
0: 		{
0: 			throw StandardException.newException(SQLState.SERVICE_WRONG_BOOT_PASSWORD);
0: 		}
0: 
0: 		byte[] bootPassword = StringUtil.getAsciiBytes(inputKey);
0: 
0: 		if (bootPassword.length < CipherFactory.MIN_BOOTPASS_LENGTH)
0: 		{
0: 			String messageId = create ? SQLState.SERVICE_BOOT_PASSWORD_TOO_SHORT :
0: 										SQLState.SERVICE_WRONG_BOOT_PASSWORD;
0: 
0: 			throw StandardException.newException(messageId);
0: 		}
0: 
0: 		// Each database has its own unique encryption key that is
0: 		// not known even to the user.  However, this key is masked
0: 		// with the user input key and stored in the
0: 		// services.properties file so that, with the user key, the
0: 		// encryption key can easily be recovered.
0: 		// To change the user encryption key to a database, simply
0: 		// recover the unique real encryption key and masked it
0: 		// with the new user key.
0: 
0: 		byte[] generatedKey;
0: 
0: 		if (create)
0: 		{
0: 			//
0: 			generatedKey = generateUniqueBytes();
0: 
0: 			properties.put(RawStoreFactory.ENCRYPTED_KEY, saveSecretKey(generatedKey, bootPassword));
0: 
0: 		}
0: 		else
0: 		{
0: 			generatedKey = getDatabaseSecretKey(properties, bootPassword, SQLState.SERVICE_WRONG_BOOT_PASSWORD);
0: 		}
0: 
0: 		return generatedKey;
0: 	}
0: 
0: 	public void stop()
0: 	{
0: 
0: 	}
0: 
0: 
0: 	/**
0: 		get the secretkey used for encryption and decryption when boot password mechanism is used for encryption
0: 		Steps include 
0: 		retrieve the stored key, decrypt the stored key and verify if the correct boot password was passed 
0: 		There is a possibility that the decrypted key includes the original key and padded bytes in order to have
0: 		been block size aligned during encryption phase. Hence extract the original key 
0: 		
0: 		@param	properties	properties to retrieve the encrypted key  
0: 		@param	bootPassword	boot password used to connect to the encrypted database
0: 		@param	errorState	errorstate to account for any errors during retrieval /creation of the secretKey
0: 		@return the original unencrypted key bytes to use for encryption and decrytion   
0: 		
0:          */
0: 	private byte[] getDatabaseSecretKey(Properties properties, byte[] bootPassword, String errorState) throws StandardException {
0: 
0: 		// recover the generated secret encryption key from the
0: 		// services.properties file and the user key.
0: 		String keyString = properties.getProperty(RawStoreFactory.ENCRYPTED_KEY);
0: 		if (keyString == null)
0: 			throw StandardException.newException(errorState);
0: 
0: 		int encodedKeyCharLength = keyString.indexOf('-');
0: 
0: 		if (encodedKeyCharLength == -1) // bad form
0: 			throw StandardException.newException(errorState);
0: 
0: 		int verifyKey = Integer.parseInt(keyString.substring(encodedKeyCharLength+1));
0: 		byte[] generatedKey = decryptKey(keyString, encodedKeyCharLength, bootPassword);
0: 
0: 		int checkKey = digest(generatedKey);
0: 
0: 		if (checkKey != verifyKey)
0: 			throw StandardException.newException(errorState);
0: 
0: 		// if encodedKeyLength is not defined, then either it is an old version with no support for different
0: 		// key sizes and padding except for defaults
0: 	        byte[] result;	
0: 		if(encodedKeyLength != 0)
0: 		{
0: 			result = new byte[encodedKeyLength];
0: 
0: 			// extract the generated key without the padding bytes
0: 			System.arraycopy(generatedKey,0,result,0,encodedKeyLength);
0: 			return result;
0: 		}
0: 
0: 		return generatedKey;
0: 	}
0: 
0: 	private String saveSecretKey(byte[] secretKey, byte[] bootPassword) throws StandardException {
0: 		String encryptedKey = encryptKey(secretKey, bootPassword);
0: 
0: 		// make a verification key out of the message digest of
0: 		// the generated key
0: 		int verifyKey = digest(secretKey);
0: 
0: 		return encryptedKey.concat("-" + verifyKey);
0: 
0: 	}
0: 
0: 	public String changeBootPassword(String changeString, Properties properties, CipherProvider verify)
0: 		throws StandardException {
0: 
0: 		// the new bootPassword is expected to be of the form
0: 		// oldkey , newkey.
0: 		int seperator = changeString.indexOf(',');
0: 		if (seperator == -1)
0: 			throw StandardException.newException(SQLState.WRONG_PASSWORD_CHANGE_FORMAT);
0: 
0: 		String oldBP = changeString.substring(0, seperator).trim();
0: 		byte[] oldBPAscii = StringUtil.getAsciiBytes(oldBP);
0: 		if (oldBPAscii == null || oldBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)
0: 			throw StandardException.newException(SQLState.WRONG_BOOT_PASSWORD);;
0: 
0: 		String newBP = changeString.substring(seperator+1).trim();
0: 		byte[] newBPAscii = StringUtil.getAsciiBytes(newBP);
0: 		if (newBPAscii == null || newBPAscii.length < CipherFactory.MIN_BOOTPASS_LENGTH)
0: 			throw StandardException.newException(SQLState.ILLEGAL_BP_LENGTH,
0:                 new Integer(CipherFactory.MIN_BOOTPASS_LENGTH));
0: 
0: 		// verify old key
0: 
0: 		byte[] generatedKey = getDatabaseSecretKey(properties, oldBPAscii, SQLState.WRONG_BOOT_PASSWORD);
0: 
0: 		// make sure the oldKey is correct
0: 		byte[] IV = generateIV(generatedKey);
0: 
0: 		if (!((JCECipherProvider) verify).verifyIV(IV))
0: 			throw StandardException.newException(SQLState.WRONG_BOOT_PASSWORD);
0: 
0: 
0: 		// Make the new key.  The generated key is unchanged, only the
0: 		// encrypted key is changed.
0: 		String newkey = saveSecretKey(generatedKey, newBPAscii);
0: 		
0: 		properties.put(Attribute.CRYPTO_KEY_LENGTH,keyLengthBits+"-"+encodedKeyLength);
0: 		
0: 
0: 		return saveSecretKey(generatedKey, newBPAscii);
0: 	}
0: 
0: 	/**
0: 	 	perform actions with privileges enabled.
0: 	 */
0: 	public final Object run() throws StandardException, InstantiationException, IllegalAccessException {
0: 
0: 		try {
0: 
0: 			switch(action)
0: 			{
0: 				case 1:
0: 					Security.addProvider(
0: 					(Provider)(Class.forName(cryptoProvider).newInstance()));
0: 					break;
0: 				case 2:
0: 					// SECURITY PERMISSION - MP1 and/or OP4
0: 					// depends on the value of activePerms
0: 					return activeFile.getRandomAccessFile(activePerms);
0: 
0: 			}
0: 
0: 		} catch (ClassNotFoundException cnfe) {
0: 			throw StandardException.newException(SQLState.ENCRYPTION_NO_PROVIDER_CLASS,cryptoProvider);
0: 		}
0: 		catch(FileNotFoundException fnfe) {
0: 			throw StandardException.newException(SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,cryptoProvider);
0: 		}
0: 		return null;
0: 	}
0: 
0: 
0: 
0: 	/**
0: 	    The database can be encrypted with an encryption key given in connection url.
0: 	    For security reasons, this key is not made persistent in the database.
0: 
0: 	    But it is necessary to verify the encryption key when booting the database if it is similar
0: 	    to the one used when creating the database
0: 	    This needs to happen before we access the data/logs to avoid the risk of corrupting the 
0: 	    database because of a wrong encryption key.
0: 
0: 	    This method performs the steps necessary to verify the encryption key if an external
0: 	    encryption key is given.
0: 
0: 	    At database creation, 4k of random data is generated using SecureRandom and MD5 is used
0: 	    to compute the checksum for the random data thus generated.  This 4k page of random data
0: 	    is then encrypted using the encryption key. The checksum of unencrypted data and
0: 	    encrypted data is made persistent in the database in file by name given by
0: 	    Attribute.CRYPTO_EXTERNAL_KEY_VERIFYFILE (verifyKey.dat). This file exists directly under the
0: 	    database root directory.
0: 
0: 	    When trying to boot an existing encrypted database, the given encryption key is used to decrypt
0: 	    the data in the verifyKey.dat and the checksum is calculated and compared against the original
0: 	    stored checksum. If these checksums dont match an exception is thrown.
0: 
0: 	    Please note, this process of verifying the key  does not provide any added security but only is 
0: 	    intended to allow to fail gracefully if a wrong encryption key is used
0: 
0: 	    @return StandardException is thrown if there are any problems during the process of verification
0: 	    		of the encryption key or if there is any mismatch of the encryption key.
0: 
0: 	 */
0: 
0: 	public void verifyKey(boolean create, StorageFactory sf, Properties properties)
0: 		throws StandardException
0: 	{
0: 
0: 		if(properties.getProperty(Attribute.CRYPTO_EXTERNAL_KEY) == null)
0: 			return;
0: 
0: 		// if firstTime ( ie during creation of database, initial key used )
0: 		// In order to allow for verifying the external key for future database boot,
0: 		// generate random 4k of data and store the encrypted random data and the checksum
0: 		// using MD5 of the unencrypted data. That way, on next database boot a check is performed
0: 		// to verify if the key is the same as used when the database was created
0: 
0: 		StorageRandomAccessFile verifyKeyFile = null;
0: 		byte[] data = new byte[VERIFYKEY_DATALEN];
0: 		try
0: 		{
0: 			if(create)
0: 			{
0: 				getSecureRandom().nextBytes(data);
0: 				// get the checksum
0: 				byte[] checksum = getMD5Checksum(data);
0: 
0: 				CipherProvider tmpCipherProvider = createNewCipher(ENCRYPT,mainSecretKey,mainIV);
0: 				tmpCipherProvider.encrypt(data, 0, data.length, data, 0);
0: 				// openFileForWrite
0: 				verifyKeyFile = privAccessFile(sf,Attribute.CRYPTO_EXTERNAL_KEY_VERIFY_FILE,"rw");
0: 				// write the checksum length as int, and then the checksum and then the encrypted data
0: 				verifyKeyFile.writeInt(checksum.length);
0: 				verifyKeyFile.write(checksum);
0: 				verifyKeyFile.write(data);
0: 				verifyKeyFile.sync(true);
0: 			}
0: 			else
0: 			{
0: 				// open file for reading only
0: 				verifyKeyFile = privAccessFile(sf,Attribute.CRYPTO_EXTERNAL_KEY_VERIFY_FILE,"r");
0: 				// then read the checksum length 
0: 				int checksumLen = verifyKeyFile.readInt();
0: 
0: 				byte[] originalChecksum = new byte[checksumLen];
0: 				verifyKeyFile.readFully(originalChecksum);
0: 
0: 				verifyKeyFile.readFully(data);
0: 
0: 				// decrypt data with key
0: 				CipherProvider tmpCipherProvider = createNewCipher(DECRYPT,mainSecretKey,mainIV);
0: 				tmpCipherProvider.decrypt(data, 0, data.length, data, 0);
0: 
0: 				byte[] verifyChecksum = getMD5Checksum(data);
0: 
0: 				if(!MessageDigest.isEqual(originalChecksum,verifyChecksum))
0: 				{
0: 					throw StandardException.newException(SQLState.ENCRYPTION_BAD_EXTERNAL_KEY);
0: 				}
0: 
0: 			}
0: 		}
0: 		catch(IOException ioe)
0: 		{
0: 			throw StandardException.newException(SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,ioe);
0: 		}
0: 		finally
0: 		{
0: 			try
0: 			{
0: 				if(verifyKeyFile != null)
0: 					verifyKeyFile.close();
0: 			}
0: 			catch(IOException ioee)
0: 			{
0: 				throw StandardException.newException(SQLState.ENCRYPTION_UNABLE_KEY_VERIFICATION,ioee);
0: 			}
0: 		}
0: 		return ;
0: 	}
0: 
0: 
0: 	/**
0: 		Use MD5 MessageDigest algorithm to generate checksum
0: 		@param data	data to be used to compute the hash value
0: 		@return returns the hash value computed using the data
0: 
0: 	 */
0: 	private byte[] getMD5Checksum(byte[] data)
0: 		throws StandardException
0: 	{
0: 		try
0: 		{
0: 			// get the checksum
0: 			MessageDigest md5 = MessageDigest.getInstance("MD5");
0: 			return md5.digest(data);
0: 		}
0: 		catch(NoSuchAlgorithmException nsae)
0: 		{
0: 			throw StandardException.newException(SQLState.ENCRYPTION_BAD_ALG_FORMAT,MESSAGE_DIGEST);
0: 		}
0: 
0: 	}
0: 
0: 
0: 	/**
0: 	 	access a file for either read/write
0: 	 	@param storageFactory	factory used for io access
0: 	 	@param	fileName		name of the file to create and open for write
0:  							The file will be created directly under the database root directory
0: 		@param	filePerms		file permissions, if "rw" open file with read and write permissions
0: 							    if "r" , open file with read permissions
0: 	 	@return	StorageRandomAccessFile returns file with fileName for writing
0: 		@exception IOException Any exception during accessing the file for read/write
0: 	 */
0: 	private StorageRandomAccessFile privAccessFile(StorageFactory storageFactory,String fileName,String filePerms)
0: 		throws java.io.IOException
0: 	{
0: 		StorageFile verifyKeyFile = storageFactory.newStorageFile("",fileName);
0: 		activeFile  = verifyKeyFile;
0: 		this.action = 2;
0: 		activePerms = filePerms;
0: 	    try
0:         {
0: 			return (StorageRandomAccessFile)java.security.AccessController.doPrivileged(this);
0: 		}
0: 		catch( java.security.PrivilegedActionException pae)
0: 		{
0: 			throw (java.io.IOException)pae.getException();
0: 		}
0: 	}
0: 
0: 
0: }
============================================================================