1:8790bb4: /*
17:8790bb4: 
1:8790bb4:    Derby - Class org.apache.derby.tools.SignatureChecker
1:8790bb4: 
1:8790bb4:    Licensed to the Apache Software Foundation (ASF) under one or more
1:8790bb4:    contributor license agreements.  See the NOTICE file distributed with
1:8790bb4:    this work for additional information regarding copyright ownership.
1:8790bb4:    The ASF licenses this file to You under the Apache License, Version 2.0
1:8790bb4:    (the "License"); you may not use this file except in compliance with
1:8790bb4:    the License.  You may obtain a copy of the License at
1:8790bb4: 
1:8790bb4:       http://www.apache.org/licenses/LICENSE-2.0
1:8790bb4: 
1:8790bb4:    Unless required by applicable law or agreed to in writing, software
1:8790bb4:    distributed under the License is distributed on an "AS IS" BASIS,
1:8790bb4:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:8790bb4:    See the License for the specific language governing permissions and
1:8790bb4:    limitations under the License.
1:8790bb4: 
3:8790bb4:  */
1:8790bb4: 
1:8790bb4: package org.apache.derby.tools;
1:8790bb4: 
1:8790bb4: import java.sql.Connection;
1:8790bb4: import java.sql.DatabaseMetaData;
1:a516dd2: import java.sql.DriverManager;
1:8790bb4: import java.sql.PreparedStatement;
1:8790bb4: import java.sql.ResultSet;
1:8790bb4: import java.sql.SQLException;
1:8790bb4: import java.util.ArrayList;
1:8790bb4: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1:8790bb4: 
3:8790bb4: /**
1:8790bb4:    <p>
1:8790bb4:    This class shows which user declared SQL functions and procedures
1:8790bb4:    cannot be matched with Java methods.
1:8790bb4:    </p>
1:8790bb4: 
1:8790bb4:    <p>
1:8790bb4:    To run from the command-line, enter the following if running on J2SE:
1:8790bb4:    </p>
1:8790bb4:    
1:8790bb4:     <p>
1:8790bb4: 	<code>java org.apache.derby.tools.SignatureChecker CONNECTION_URL_TO_DATABASE</code>
1:8790bb4: 	<p>
1:8790bb4: 
1:8790bb4:    <p>
1:8790bb4:    And enter the following if running on J2ME:
1:8790bb4:    </p>
1:8790bb4:    
1:8790bb4:     <p>
1:8790bb4: 	<code>java org.apache.derby.tools.SignatureChecker DATABASE_NAME</code>
1:8790bb4: 	<p>
1:8790bb4: 
1:8790bb4: */
1:8790bb4: 
1:8790bb4: public class SignatureChecker
8:8790bb4: {
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
3:8790bb4:     //
1:8790bb4:     // CONSTANTS
1:8790bb4:     //
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4: 
1:8790bb4:     private static  final   String  WILDCARD = "%";
1:8790bb4: 
1:8790bb4:     private static  final   String[] SYSTEM_SCHEMAS =
1:8790bb4:     {
1:8790bb4:         "SQLJ",
1:8790bb4:         "SYSCS_UTIL",
1:8790bb4:         "SYSIBM",
1:8790bb4:     };
1:8790bb4: 
1:8790bb4: 
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4:     //
1:8790bb4:     // STATE
1:8790bb4:     //
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4: 
1:a516dd2:     private final ParsedArgs _parsedArgs;
1:8790bb4: 
1:a516dd2:     private final ArrayList<SQLRoutine>   _procedures = new ArrayList<SQLRoutine>();
1:a516dd2:     private final ArrayList<SQLRoutine>   _functions = new ArrayList<SQLRoutine>();
1:8790bb4: 
1:a516dd2:     private final boolean     _debugging = false;
1:8790bb4:     
1:8790bb4: 	private static          LocalizedResource _messageFormatter;
1:8790bb4:     
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4:     //
1:8790bb4:     // CONSTRUCTOR
1:8790bb4:     //
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4: 
1:8790bb4:     private SignatureChecker( ParsedArgs parsedArgs )
1:8790bb4:     {
1:8790bb4:         _parsedArgs = parsedArgs;
8:8790bb4:     }
1:8790bb4:     
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4:     //
1:8790bb4:     // ENTRY POINT
1:8790bb4:     //
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4: 
1:8790bb4:     public  static  void    main( String[] args )
1:8790bb4:     {
1:8790bb4:         ParsedArgs  parsedArgs = new ParsedArgs( args );
1:8790bb4:         
1:8790bb4:         if ( !parsedArgs.isValid() )
1:8790bb4:         {
1:8790bb4:             printUsage();
1:8790bb4:             System.exit( 1 );
1:8790bb4:         }
2:8790bb4:         else
1:8790bb4:         {
1:8790bb4:             SignatureChecker    me = new SignatureChecker(  parsedArgs  );
1:8790bb4: 
1:8790bb4:             me.execute();
1:8790bb4:         }
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4:     //
1:8790bb4:     // MACHINERY
1:8790bb4:     //
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4: 
1:8790bb4:     /**
1:8790bb4:      * <p>
1:8790bb4:      * Get a connection to a database and then match the signatures of routines
1:8790bb4:      * in that database.
1:8790bb4:      * </p>
1:8790bb4:      */
1:8790bb4:     private void    execute()
1:8790bb4:     {
3:8790bb4:         try {
1:c712a5b:             Connection conn = getJ2SEConnection();
1:8790bb4: 
1:8790bb4:             if ( conn == null )
1:8790bb4:             {
1:8790bb4:                 println(  formatMessage( "SC_NO_CONN" )  );
1:8790bb4:             }
1:8790bb4:             else
1:8790bb4:             {
1:8790bb4:                 matchSignatures( conn );
1:8790bb4: 
1:8790bb4:                 conn.close();
1:8790bb4:             }
1:8790bb4:             
1:a516dd2:         } catch (SQLException t) { printThrowable( t ); }
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     /**
1:8790bb4:      * <p>
1:8790bb4:      * Match the signatures of routines in the database attached to this connection.
1:8790bb4:      * </p>
1:a516dd2:      * @param conn This connection
1:a516dd2:      * @throws java.sql.SQLException
1:8790bb4:      */
1:8790bb4:     private void matchSignatures( Connection conn )
2:8790bb4:         throws SQLException
1:8790bb4:     {
1:8790bb4:         matchProcedures( conn );
1:8790bb4:         matchFunctions( conn );
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     /**
1:8790bb4:      * <p>
1:8790bb4:      * Match the signatures of procedures in this database.
1:8790bb4:      * </p>
1:a516dd2:      * @param conn The connection to use to access the database
1:a516dd2:      * @throws java.sql.SQLException
1:8790bb4:      */
1:8790bb4:     private void matchProcedures( Connection conn )
1:8790bb4:         throws SQLException
1:8790bb4:     {
1:8790bb4:         DatabaseMetaData    dbmd = conn.getMetaData();
1:8790bb4: 
1:8790bb4:         // find all of the user-declared procedures
1:8790bb4:         findProcedures( dbmd );
1:8790bb4: 
1:8790bb4:         // for each procedure, count its arguments
1:8790bb4:         countProcedureArgs( dbmd );
1:8790bb4: 
1:8790bb4:         //
1:8790bb4:         // Try to prepare an invocation of each procedure. This will generate an error if a
1:8790bb4:         // matching Java signature can not be found.
1:8790bb4:         //
1:8790bb4:         int     count = _procedures.size();
2:8790bb4:         for ( int i = 0; i < count; i++ )
1:8790bb4:         {
1:8790bb4:             SQLRoutine  procedure = getProcedure( i );
1:a516dd2:             StringBuilder buffer = new StringBuilder();
1:8790bb4:             int             argCount = procedure.getArgCount();
1:8790bb4: 
1:8790bb4:             buffer.append( "call " );
1:8790bb4:             buffer.append( procedure.getQualifiedName() );
1:8790bb4:             buffer.append( "( " );
1:8790bb4:             for ( int k = 0; k < argCount; k++ )
1:8790bb4:             {
1:8790bb4:                 if ( k > 0 ) { buffer.append( ", " ); }
1:8790bb4:                 buffer.append( " ? " );
1:8790bb4:             }
1:8790bb4:             buffer.append( " )" );
1:8790bb4: 
1:a516dd2:             checkSignature( conn, buffer.toString(), makeReadableSignature( procedure ) );
1:8790bb4:         }
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     /**
1:8790bb4:      * <p>
1:8790bb4:      * Match the signatures of functions in this database.
1:8790bb4:      * </p>
1:a516dd2:      * @param conn The connection to use to access the database
1:a516dd2:      * @throws java.sql.SQLException
1:8790bb4:      */
1:8790bb4:     private void matchFunctions( Connection conn )
1:8790bb4:         throws SQLException
1:8790bb4:     {
1:8790bb4:         DatabaseMetaData    dbmd = conn.getMetaData();
1:8790bb4: 
1:8790bb4:         // find all of the user-declared functions
1:8790bb4:         findFunctions( dbmd );
1:8790bb4: 
1:8790bb4:         // for each function, count its arguments
1:8790bb4:         countFunctionArgs( dbmd );
1:8790bb4: 
1:8790bb4:         //
1:8790bb4:         // Try to prepare an invocation of each function. This will generate an error if a
1:8790bb4:         // matching Java signature can not be found.
1:8790bb4:         //
2:8790bb4:         int     count = _functions.size();
1:8790bb4:         for ( int i = 0; i < count; i++ )
1:8790bb4:         {
2:8790bb4:             SQLRoutine  function = getFunction( i );
1:a516dd2:             StringBuilder query = new StringBuilder();
1:8790bb4:             int             argCount = function.getArgCount();
1:8790bb4: 
1:8790bb4:             if ( function.isTableFunction() ) { query.append( "select * from table( " ); }
1:8790bb4:             else { query.append( "values(  " ); }
1:8790bb4:             
1:8790bb4:             query.append( function.getQualifiedName() );
1:8790bb4:             query.append( "( " );
1:8790bb4:             for ( int k = 0; k < argCount; k++ )
1:8790bb4:             {
1:8790bb4:                 if ( k > 0 ) { query.append( ", " ); }
1:8790bb4:                 query.append( " ? " );
1:8790bb4:             }
1:8790bb4:             query.append( " ) )" );
1:8790bb4:             if ( function.isTableFunction() ) { query.append( " s" ); }
1:8790bb4: 
1:a516dd2:             checkSignature( conn, query.toString(), makeReadableSignature( function ) );
1:8790bb4:         }
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     /**
1:8790bb4:      * <p>
1:8790bb4:      * Make a human readable signature for a routine. This can be
1:8790bb4:      * used in error messages.
1:8790bb4:      * </p>
1:a516dd2:      * @param routine the routine for which we want a signature
1:a516dd2:      * @return human readable string
1:8790bb4:      */
1:8790bb4:     private String  makeReadableSignature( SQLRoutine routine )
1:8790bb4:     {
1:a516dd2:         StringBuilder signature = new StringBuilder();
1:8790bb4:         int             argCount = routine.getArgCount();
1:8790bb4:         
1:8790bb4:         signature.append( routine.getQualifiedName() );
1:8790bb4:         signature.append( "( " );
1:8790bb4:         for ( int k = 0; k < argCount; k++ )
1:8790bb4:         {
1:8790bb4:             if ( k > 0 ) { signature.append( ", " ); }
1:a516dd2:             signature.append( " " );
1:a516dd2:             signature.append( routine.getArgType( k ) );
1:a516dd2:             signature.append( " " );
1:8790bb4:         }
1:8790bb4:         signature.append( " )" );
1:8790bb4: 
1:8790bb4:         return signature.toString();
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     /**
1:8790bb4:      * <p>
1:8790bb4:      * Find all of the user-declared procedures.
1:8790bb4:      * </p>
1:a516dd2:      * @param dbmd the database metadata of the database
1:a516dd2:      * @throws java.sql.SQLException
1:8790bb4:      */
1:8790bb4:     private void    findProcedures( DatabaseMetaData dbmd )
1:8790bb4:         throws SQLException
1:8790bb4:     {
1:8790bb4:         ResultSet               rs = dbmd.getProcedures( null, null, WILDCARD );
1:8790bb4: 
2:8790bb4:         while( rs.next() )
1:8790bb4:         {
1:8790bb4:             String  schema = rs.getString( 2 );
1:8790bb4:             String  name = rs.getString( 3 );
1:8790bb4: 
1:8790bb4:             if ( isSystemSchema( schema ) ) { continue; }
1:8790bb4: 
1:8790bb4:             putProcedure( schema, name );
1:8790bb4:         }
2:8790bb4:         rs.close();
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     /**
1:8790bb4:      * <p>
1:a516dd2:      * Count up the arguments to the user-coded procedures in
1:a516dd2:      * {@link #_procedures} and update that data structure accordingly
1:8790bb4:      * </p>
1:a516dd2:      * @param dbmd the database metadata of the database
1:a516dd2:      * @throws java.sql.SQLException
1:8790bb4:      */
1:8790bb4:     private void    countProcedureArgs( DatabaseMetaData dbmd )
1:8790bb4:         throws SQLException
1:8790bb4:     {
1:8790bb4:         int     count = _procedures.size();
1:8790bb4:         for ( int i = 0; i < count; i++ )
1:8790bb4:         {
1:8790bb4:             SQLRoutine  procedure = getProcedure( i );
1:8790bb4: 
1:8790bb4:             ResultSet   rs = dbmd.getProcedureColumns( null, procedure.getSchema(), procedure.getName(), WILDCARD );
1:8790bb4: 
1:8790bb4:             while( rs.next() )
1:8790bb4:             {
1:8790bb4:                 procedure.addArg( rs.getString( 7 ) );
1:8790bb4:             }
1:8790bb4:             rs.close();
1:8790bb4:         }
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     /**
1:8790bb4:      * <p>
1:8790bb4:      * Find all of the user-declared functions. We use reflection to get our
1:8790bb4:      * hands on getFunctions() because that method does not appear in
1:a516dd2:      * the JSR169 api for DatabaseMetaData. Update {@link #_functions}.
1:8790bb4:      * </p>
1:a516dd2:      * @param dbmd the database metadata of the database
1:a516dd2:      * @throws java.sql.SQLException
1:8790bb4:      */
1:8790bb4:     private void    findFunctions( DatabaseMetaData dbmd )
1:8790bb4:         throws SQLException
1:8790bb4:     {
1:8790bb4:         try {
1:a516dd2:             ResultSet   rs = dbmd.getFunctions(null, null, WILDCARD);
1:8790bb4: 
1:8790bb4:             while( rs.next() )
1:8790bb4:             {
1:8790bb4:                 String  schema = rs.getString( 2 );
1:8790bb4:                 String  name = rs.getString( 3 );
1:8790bb4:                 short   functionType = rs.getShort( 5 );
1:8790bb4: 
1:8790bb4:                 if ( isSystemSchema( schema ) ) { continue; }
1:8790bb4: 
1:a516dd2:                 boolean isTableFunction =
1:a516dd2:                     functionType == DatabaseMetaData.functionReturnsTable;
1:8790bb4: 
1:8790bb4:                 putFunction( schema, name, isTableFunction );
1:8790bb4:             }
1:8790bb4:             rs.close();
1:8790bb4: 
1:8790bb4:             
1:a516dd2:         } catch (SQLException e) { throw new SQLException( e.getMessage() ); }
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     /**
1:8790bb4:      * <p>
1:8790bb4:      * Count up the arguments to the user-coded procedures. We use
1:8790bb4:      * reflection to look up the getFunctionColumns() method because that
1:8790bb4:      * method does not appear in the JSR169 api for DatabaseMetaData.
1:a516dd2:      * Update {@link #_functions}.
1:8790bb4:      * </p>
1:a516dd2:      * @param dbmd the database metadata of the database
1:a516dd2:      * @throws java.sql.SQLException
1:8790bb4:      */
1:8790bb4:     private void    countFunctionArgs( DatabaseMetaData dbmd )
1:8790bb4:         throws SQLException
1:a516dd2:     {
1:a516dd2:         int     count = _functions.size();
1:a516dd2:         for ( int i = 0; i < count; i++ )
1:8790bb4:         {
1:a516dd2:             SQLRoutine  function = getFunction( i );
1:a516dd2:             ResultSet   rs = dbmd.getFunctionColumns(
1:a516dd2:                 null, function.getSchema(), function.getName(), WILDCARD);
1:8790bb4: 
1:a516dd2:             while( rs.next() )
1:8790bb4:             {
1:a516dd2:                 short   columnType = rs.getShort( 5 );
1:8790bb4: 
1:a516dd2:                 //
1:a516dd2:                 // Skip the return value if this is a table function.
1:a516dd2:                 // Skip all columns in the returned result set if this is a
1:a516dd2:                 // table function.
1:a516dd2:                 //
1:a516dd2:                 if ( columnType == DatabaseMetaData.functionReturn ) { continue; }
1:a516dd2:                 if ( columnType == DatabaseMetaData.functionColumnResult ) { continue; }
1:8790bb4: 
1:a516dd2:                 function.addArg( rs.getString( 7 ) );
1:a516dd2:             }
1:a516dd2:             rs.close();
1:8790bb4:         }
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     /**
1:8790bb4:      * <p>
1:8790bb4:      * Prepared a routine invocation in order to check whether it matches a Java method.
1:8790bb4:      * </p>
1:a516dd2:      * @param conn The connection to the database
1:a516dd2:      * @param query The SQL to prepare
1:a516dd2:      * @param readableSignature the signature: printed if prepare fails
1:8790bb4:      */
1:a516dd2:     private void    checkSignature( Connection conn, String query, String readableSignature )
1:8790bb4:     {
1:8790bb4:         try {
1:8790bb4:             PreparedStatement   ps = prepareStatement( conn, query );
1:8790bb4:             ps.close();
1:8790bb4: 
1:8790bb4:             println( formatMessage( "SC_FOUND_MATCH", readableSignature ) );
1:8790bb4: 
1:8790bb4:                      } catch (SQLException se)
1:8790bb4:         {
1:8790bb4:             println( formatMessage( "SC_UNRESOLVABLE", readableSignature, se.getMessage() ) );
1:8790bb4:         }
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4:     //
1:8790bb4:     // MINIONS
1:8790bb4:     //
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4: 
1:8790bb4:     /**
1:8790bb4:      * We use reflection to get the J2SE connection so that references to
1:8790bb4:      * DriverManager will not generate linkage errors on old J2ME platforms
1:8790bb4:      * which may resolve references eagerly.
1:a516dd2:      *
1:a516dd2:      * @return a connection to the database
1:a516dd2:      * @throws java.sql.SQLException
1:8790bb4:      */
1:8790bb4:     private Connection  getJ2SEConnection()
1:8790bb4:         throws SQLException
1:8790bb4:     {
1:8790bb4:         try {
1:8790bb4:             Class.forName( "org.apache.derby.jdbc.EmbeddedDriver" );
1:8790bb4:             Class.forName( "org.apache.derby.jdbc.ClientDriver" );
1:a516dd2:             Class.forName( "java.sql.DriverManager" );
1:a516dd2:         } catch (ClassNotFoundException t) {}
1:8790bb4: 
1:8790bb4:         try {
1:8790bb4: 
1:a516dd2:             return DriverManager.getConnection(
1:a516dd2:                 _parsedArgs.getJ2seConnectionUrl()  );
1:8790bb4:             
1:a516dd2:         } catch (SQLException t)
1:8790bb4:         {
1:8790bb4:             printThrowable( t );
1:8790bb4:             return null;
1:8790bb4:         }
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     private PreparedStatement prepareStatement( Connection conn, String text )
1:8790bb4:         throws SQLException
1:8790bb4:     {
1:8790bb4:         if ( _debugging ) { println( "Preparing: " + text ); }
1:8790bb4: 
1:8790bb4:         return conn.prepareStatement( text );
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     private static  void printUsage()
1:8790bb4:     {
1:8790bb4:         println(  formatMessage( "SC_USAGE" )  );
1:8790bb4:     }
1:8790bb4: 
1:a516dd2:     @SuppressWarnings("CallToPrintStackTrace")
1:8790bb4:     private static void printThrowable( Throwable t )
1:8790bb4:     {
1:8790bb4:         t.printStackTrace();
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     private static  void println( String text )
1:8790bb4:     {
1:8790bb4:         System.out.println( text );
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     /**
1:8790bb4:      * Return true if the schema is a system schema.
1:a516dd2:      * @param schema the schema to check
1:a516dd2:      * @return {@code true} if the schema is a system schema
1:8790bb4:      */
1:8790bb4:     private boolean isSystemSchema( String schema )
1:8790bb4:     {
1:8790bb4:         int count = SYSTEM_SCHEMAS.length;
1:8790bb4: 
1:8790bb4:         for ( int i = 0; i < count; i++ )
1:8790bb4:         {
1:8790bb4:             if ( SYSTEM_SCHEMAS[ i ].equals( schema ) ) { return true; }
1:8790bb4:         }
1:8790bb4: 
1:8790bb4:         return false;
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     /**
1:a516dd2:      * Store a procedure descriptor. Updates {@link #_procedures}.
1:a516dd2:      * @param schema schema of the procedure
1:a516dd2:      * @param name of a procedure
1:8790bb4:      */
1:8790bb4:     private void putProcedure( String schema, String name )
1:8790bb4:     {
1:8790bb4:         _procedures.add( new SQLRoutine( schema, name, false )  );
1:8790bb4:     }
1:8790bb4:         
1:8790bb4:     /**
1:a516dd2:      * Get a procedure descriptor from {@link #_procedures}.
1:a516dd2:      * @param idx The index of the procedure in {@link #_procedures}.
1:a516dd2:      * @return a procedure descriptor
1:8790bb4:      */
1:8790bb4:     private SQLRoutine getProcedure( int idx )
1:8790bb4:     {
1:0758fb6:         return _procedures.get( idx );
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     /**
1:a516dd2:      * Store a function descriptor. Updates {@link #_functions}.
1:a516dd2:      *
1:a516dd2:      * @param schema The schema of the function
1:a516dd2:      * @param name The name of the function
1:a516dd2:      * @param isTableFunction {@code true} iff the function is a table function
1:8790bb4:      */
1:8790bb4:     private void putFunction( String schema, String name, boolean isTableFunction )
1:8790bb4:     {
1:8790bb4:         _functions.add( new SQLRoutine( schema, name, isTableFunction )  );
1:8790bb4:     }
1:8790bb4:         
1:8790bb4:     /**
1:a516dd2:      * Get a function descriptor from {@link #_functions}
1:a516dd2:      * .
1:a516dd2:      * @param idx The index of the procedure in {@link #_functions}.
1:a516dd2:      * @return a function descriptor
1:8790bb4:      */
1:8790bb4:     private SQLRoutine getFunction( int idx )
1:8790bb4:     {
1:0758fb6:         return _functions.get( idx );
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     /**
1:c465481:      * Format a localizable message.
1:a516dd2:      *
1:a516dd2:      * @param key The message key by which we located the localized text
1:a516dd2:      * @param args Any arguments to the localized text to be filled in
1:a516dd2:      * @return A localized message
1:8790bb4:      */
1:c465481:     private static String formatMessage(String key, Object... args)
1:8790bb4:     {
1:c465481:         return getMessageFormatter().getTextMessage(key, args);
1:8790bb4:     }
1:8790bb4:     
1:8790bb4:     /**
1:8790bb4:      * Get the message resource.
1:a516dd2:      *
1:a516dd2:      * @return localized resource
1:8790bb4:      */
1:8790bb4:     private static  LocalizedResource   getMessageFormatter()
1:8790bb4:     {
1:8790bb4:         if ( _messageFormatter == null )
1:8790bb4:         {
1:8790bb4:             _messageFormatter = LocalizedResource.getInstance();
1:8790bb4:         }
1:8790bb4:         return _messageFormatter;
1:8790bb4:     }
1:8790bb4: 
1:8790bb4: 
1:8790bb4:         
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4:     //
1:8790bb4:     // INNER CLASSES
1:8790bb4:     //
1:8790bb4:     ///////////////////////////////////////////////////////////////////////////////////
1:8790bb4: 
1:8790bb4:     static class ParsedArgs
1:8790bb4:     {
1:8790bb4:         private boolean _isValid;
1:8790bb4:         private String _j2seConnectionUrl;
1:8790bb4: 
1:8790bb4:         public  ParsedArgs( String[] args )
1:8790bb4:         {
1:8790bb4:             _isValid = false;
1:8790bb4:             parseArgs( args );
1:8790bb4:         }
1:8790bb4: 
1:8790bb4:         public boolean isValid() { return _isValid; }
1:8790bb4: 
1:8790bb4:         public String getJ2seConnectionUrl() { return _j2seConnectionUrl; }
1:8790bb4: 
1:8790bb4:         private void parseArgs( String[] args )
1:8790bb4:         {
1:8790bb4:             if ( args == null ) { return; }
1:c712a5b:             if ( args.length != 1 ) { return; }
1:8790bb4: 
1:c712a5b:             _j2seConnectionUrl = args[ 0 ];
1:c712a5b:             _isValid = true;
1:8790bb4:         }
1:8790bb4:     }
1:8790bb4: 
1:8790bb4:     class SQLRoutine
1:8790bb4:     {
1:a516dd2:         private final String _schema;
1:a516dd2:         private final String _name;
1:a516dd2:         private final boolean _isTableFunction;
1:a516dd2:         private final ArrayList<String>   _argList = new ArrayList<String>();
1:8790bb4: 
1:8790bb4:         public SQLRoutine( String schema, String name, boolean isTableFunction )
1:8790bb4:         {
1:8790bb4:             _schema = schema;
1:8790bb4:             _name = name;
1:8790bb4:             _isTableFunction = isTableFunction;
1:8790bb4:         }
1:8790bb4: 
1:8790bb4:         public void addArg( String typeName ) { _argList.add( typeName ); }
1:8790bb4: 
1:8790bb4:         public String getSchema() { return _schema; }
1:8790bb4:         public String getName() { return _name; }
1:8790bb4:         public int      getArgCount() { return _argList.size(); }
1:0758fb6:         public String getArgType( int idx ) { return _argList.get( idx ); }
1:8790bb4:         public boolean isTableFunction() { return _isTableFunction; }
1:8790bb4: 
1:a516dd2:         @Override
1:8790bb4:         public  String  toString()
1:8790bb4:         {
1:a516dd2:             StringBuilder    buffer = new StringBuilder();
1:8790bb4: 
1:8790bb4:             buffer.append( "SQLRoutine( " );
1:a516dd2:             buffer.append( _schema );
1:a516dd2:             buffer.append( ", " );
1:a516dd2:             buffer.append( _name );
1:a516dd2:             buffer.append( ", " );
1:a516dd2:             buffer.append(  "isTableFunction = " );
1:a516dd2:             buffer.append( _isTableFunction );
1:a516dd2:             buffer.append( ", " );
1:a516dd2:             buffer.append( " argCount = " );
1:a516dd2:             buffer.append( getArgCount() );
1:8790bb4:             buffer.append( " )" );
1:8790bb4: 
1:8790bb4:             return buffer.toString();
1:8790bb4:         }
1:8790bb4: 
1:8790bb4:         private String doubleQuote( String raw )
1:8790bb4:         {
1:8790bb4:             return '\"' + raw + '\"';
1:8790bb4:         }
1:8790bb4:         public  String  getQualifiedName()
1:8790bb4:         {
1:8790bb4:             return doubleQuote( _schema ) + '.' + doubleQuote( _name );
1:8790bb4:         }
1:8790bb4: 
1:8790bb4:     }
1:8790bb4:     
1:8790bb4: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:a516dd2
/////////////////////////////////////////////////////////////////////////
1: import java.sql.DriverManager;
/////////////////////////////////////////////////////////////////////////
1:     private final ParsedArgs _parsedArgs;
1:     private final ArrayList<SQLRoutine>   _procedures = new ArrayList<SQLRoutine>();
1:     private final ArrayList<SQLRoutine>   _functions = new ArrayList<SQLRoutine>();
1:     private final boolean     _debugging = false;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         } catch (SQLException t) { printThrowable( t ); }
1:      * @param conn This connection
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      * @param conn The connection to use to access the database
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:             StringBuilder buffer = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:             checkSignature( conn, buffer.toString(), makeReadableSignature( procedure ) );
/////////////////////////////////////////////////////////////////////////
1:      * @param conn The connection to use to access the database
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:             StringBuilder query = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:             checkSignature( conn, query.toString(), makeReadableSignature( function ) );
/////////////////////////////////////////////////////////////////////////
1:      * @param routine the routine for which we want a signature
1:      * @return human readable string
1:         StringBuilder signature = new StringBuilder();
/////////////////////////////////////////////////////////////////////////
1:             signature.append( " " );
1:             signature.append( routine.getArgType( k ) );
1:             signature.append( " " );
/////////////////////////////////////////////////////////////////////////
1:      * @param dbmd the database metadata of the database
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      * Count up the arguments to the user-coded procedures in
1:      * {@link #_procedures} and update that data structure accordingly
1:      * @param dbmd the database metadata of the database
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:      * the JSR169 api for DatabaseMetaData. Update {@link #_functions}.
1:      * @param dbmd the database metadata of the database
1:      * @throws java.sql.SQLException
1:             ResultSet   rs = dbmd.getFunctions(null, null, WILDCARD);
/////////////////////////////////////////////////////////////////////////
1:                 boolean isTableFunction =
1:                     functionType == DatabaseMetaData.functionReturnsTable;
1:         } catch (SQLException e) { throw new SQLException( e.getMessage() ); }
/////////////////////////////////////////////////////////////////////////
1:      * Update {@link #_functions}.
1:      * @param dbmd the database metadata of the database
1:      * @throws java.sql.SQLException
1:         int     count = _functions.size();
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             SQLRoutine  function = getFunction( i );
1:             ResultSet   rs = dbmd.getFunctionColumns(
1:                 null, function.getSchema(), function.getName(), WILDCARD);
1:             while( rs.next() )
1:                 short   columnType = rs.getShort( 5 );
1:                 //
1:                 // Skip the return value if this is a table function.
1:                 // Skip all columns in the returned result set if this is a
1:                 // table function.
1:                 //
1:                 if ( columnType == DatabaseMetaData.functionReturn ) { continue; }
1:                 if ( columnType == DatabaseMetaData.functionColumnResult ) { continue; }
1:                 function.addArg( rs.getString( 7 ) );
1:             rs.close();
1:         }
1:      * @param conn The connection to the database
1:      * @param query The SQL to prepare
1:      * @param readableSignature the signature: printed if prepare fails
1:     private void    checkSignature( Connection conn, String query, String readableSignature )
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @return a connection to the database
1:      * @throws java.sql.SQLException
/////////////////////////////////////////////////////////////////////////
1:             Class.forName( "java.sql.DriverManager" );
1:         } catch (ClassNotFoundException t) {}
1:             return DriverManager.getConnection(
1:                 _parsedArgs.getJ2seConnectionUrl()  );
1:         } catch (SQLException t)
/////////////////////////////////////////////////////////////////////////
1:     @SuppressWarnings("CallToPrintStackTrace")
/////////////////////////////////////////////////////////////////////////
1:      * @param schema the schema to check
1:      * @return {@code true} if the schema is a system schema
/////////////////////////////////////////////////////////////////////////
1:      * Store a procedure descriptor. Updates {@link #_procedures}.
1:      * @param schema schema of the procedure
1:      * @param name of a procedure
/////////////////////////////////////////////////////////////////////////
1:      * Get a procedure descriptor from {@link #_procedures}.
1:      * @param idx The index of the procedure in {@link #_procedures}.
1:      * @return a procedure descriptor
/////////////////////////////////////////////////////////////////////////
1:      * Store a function descriptor. Updates {@link #_functions}.
1:      *
1:      * @param schema The schema of the function
1:      * @param name The name of the function
1:      * @param isTableFunction {@code true} iff the function is a table function
/////////////////////////////////////////////////////////////////////////
1:      * Get a function descriptor from {@link #_functions}
1:      * .
1:      * @param idx The index of the procedure in {@link #_functions}.
1:      * @return a function descriptor
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @param key The message key by which we located the localized text
1:      * @param args Any arguments to the localized text to be filled in
1:      * @return A localized message
/////////////////////////////////////////////////////////////////////////
1:      *
1:      * @return localized resource
/////////////////////////////////////////////////////////////////////////
1:         private final String _schema;
1:         private final String _name;
1:         private final boolean _isTableFunction;
1:         private final ArrayList<String>   _argList = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         @Override
1:             StringBuilder    buffer = new StringBuilder();
1:             buffer.append( _schema );
1:             buffer.append( ", " );
1:             buffer.append( _name );
1:             buffer.append( ", " );
1:             buffer.append(  "isTableFunction = " );
1:             buffer.append( _isTableFunction );
1:             buffer.append( ", " );
1:             buffer.append( " argCount = " );
1:             buffer.append( getArgCount() );
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c465481
/////////////////////////////////////////////////////////////////////////
1:      * Format a localizable message.
1:     private static String formatMessage(String key, Object... args)
1:         return getMessageFormatter().getTextMessage(key, args);
commit:c712a5b
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             Connection conn = getJ2SEConnection();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             if ( args.length != 1 ) { return; }
1:             _j2seConnectionUrl = args[ 0 ];
1:             _isValid = true;
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 if ( functionType == DatabaseMetaData.functionReturnsTable ) { isTableFunction = true; }
/////////////////////////////////////////////////////////////////////////
0:                     if ( columnType == DatabaseMetaData.functionReturn ) { continue; }
0:                     if ( columnType == DatabaseMetaData.functionColumnResult ) { continue; }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:5570eb0
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.jdbc.EmbeddedDataSource40;
/////////////////////////////////////////////////////////////////////////
0:         EmbeddedDataSource40    dataSource = new EmbeddedDataSource40();
commit:0758fb6
/////////////////////////////////////////////////////////////////////////
0:     private ArrayList<SQLRoutine>   _procedures = new ArrayList<SQLRoutine>();
0:     private ArrayList<SQLRoutine>   _functions = new ArrayList<SQLRoutine>();
/////////////////////////////////////////////////////////////////////////
0:             Class<?>   driverManagerClass = Class.forName( "java.sql.DriverManager" );
0:                 ( "getConnection", String.class );
/////////////////////////////////////////////////////////////////////////
1:         return _procedures.get( idx );
/////////////////////////////////////////////////////////////////////////
1:         return _functions.get( idx );
/////////////////////////////////////////////////////////////////////////
0:         private ArrayList<String>   _argList = new ArrayList<String>();
/////////////////////////////////////////////////////////////////////////
1:         public String getArgType( int idx ) { return _argList.get( idx ); }
commit:8790bb4
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.tools.SignatureChecker
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.tools;
1: 
0: import java.lang.reflect.Method;
1: import java.sql.Connection;
1: import java.sql.DatabaseMetaData;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.util.ArrayList;
1: 
0: import org.apache.derby.iapi.services.info.JVMInfo;
0: import org.apache.derby.jdbc.EmbeddedSimpleDataSource;
0: import org.apache.derby.shared.common.reference.JDBC40Translation;
1: import org.apache.derby.iapi.tools.i18n.LocalizedResource;
1: 
1: /**
1:    <p>
1:    This class shows which user declared SQL functions and procedures
1:    cannot be matched with Java methods.
1:    </p>
1: 
1:    <p>
1:    To run from the command-line, enter the following if running on J2SE:
1:    </p>
1:    
1:     <p>
1: 	<code>java org.apache.derby.tools.SignatureChecker CONNECTION_URL_TO_DATABASE</code>
1: 	<p>
1: 
1:    <p>
1:    And enter the following if running on J2ME:
1:    </p>
1:    
1:     <p>
1: 	<code>java org.apache.derby.tools.SignatureChecker DATABASE_NAME</code>
1: 	<p>
1: 
1: */
1: 
1: public class SignatureChecker
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String  WILDCARD = "%";
1: 
1:     private static  final   String[] SYSTEM_SCHEMAS =
1:     {
1:         "SQLJ",
1:         "SYSCS_UTIL",
1:         "SYSIBM",
1:     };
1: 
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
0:     private ParsedArgs _parsedArgs;
1: 
0:     private ArrayList   _procedures = new ArrayList();
0:     private ArrayList   _functions = new ArrayList();
1: 
0:     private boolean     _debugging = false;
1:     
1: 	private static          LocalizedResource _messageFormatter;
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTRUCTOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     private SignatureChecker( ParsedArgs parsedArgs )
1:     {
1:         _parsedArgs = parsedArgs;
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // ENTRY POINT
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     public  static  void    main( String[] args )
1:     {
1:         ParsedArgs  parsedArgs = new ParsedArgs( args );
1:         
1:         if ( !parsedArgs.isValid() )
1:         {
1:             printUsage();
1:             System.exit( 1 );
1:         }
1:         else
1:         {
1:             SignatureChecker    me = new SignatureChecker(  parsedArgs  );
1: 
1:             me.execute();
1:         }
1:     }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MACHINERY
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Get a connection to a database and then match the signatures of routines
1:      * in that database.
1:      * </p>
1:      */
1:     private void    execute()
1:     {
1:         try {
0:             Connection  conn;
1:         
0:             if ( _parsedArgs.isJ2ME() ) { conn = getJ2MEConnection(); }
0:             else { conn = getJ2SEConnection(); }
1: 
1:             if ( conn == null )
1:             {
1:                 println(  formatMessage( "SC_NO_CONN" )  );
0:                 return;
1:             }
1:             else
1:             {
1:                 matchSignatures( conn );
1: 
1:                 conn.close();
1:             }
1:             
0:         } catch (Throwable t) { printThrowable( t ); }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Match the signatures of routines in the database attached to this connection.
1:      * </p>
1:      */
1:     private void matchSignatures( Connection conn )
1:         throws SQLException
1:     {
1:         matchProcedures( conn );
1:         matchFunctions( conn );
1:     }
1:     
1:     /**
1:      * <p>
1:      * Match the signatures of procedures in this database.
1:      * </p>
1:      */
1:     private void matchProcedures( Connection conn )
1:         throws SQLException
1:     {
1:         DatabaseMetaData    dbmd = conn.getMetaData();
1: 
1:         // find all of the user-declared procedures
1:         findProcedures( dbmd );
1: 
1:         // for each procedure, count its arguments
1:         countProcedureArgs( dbmd );
1: 
1:         //
1:         // Try to prepare an invocation of each procedure. This will generate an error if a
1:         // matching Java signature can not be found.
1:         //
1:         int     count = _procedures.size();
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             SQLRoutine  procedure = getProcedure( i );
0:             StringBuffer buffer = new StringBuffer();
1:             int             argCount = procedure.getArgCount();
1: 
1:             buffer.append( "call " );
1:             buffer.append( procedure.getQualifiedName() );
1:             buffer.append( "( " );
1:             for ( int k = 0; k < argCount; k++ )
1:             {
1:                 if ( k > 0 ) { buffer.append( ", " ); }
1:                 buffer.append( " ? " );
1:             }
1:             buffer.append( " )" );
1: 
0:             checkSignature( conn, procedure, buffer.toString(), makeReadableSignature( procedure ) );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Match the signatures of functions in this database.
1:      * </p>
1:      */
1:     private void matchFunctions( Connection conn )
1:         throws SQLException
1:     {
1:         DatabaseMetaData    dbmd = conn.getMetaData();
1: 
1:         // find all of the user-declared functions
1:         findFunctions( dbmd );
1: 
1:         // for each function, count its arguments
1:         countFunctionArgs( dbmd );
1: 
1:         //
1:         // Try to prepare an invocation of each function. This will generate an error if a
1:         // matching Java signature can not be found.
1:         //
1:         int     count = _functions.size();
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             SQLRoutine  function = getFunction( i );
0:             StringBuffer query = new StringBuffer();
1:             int             argCount = function.getArgCount();
1: 
1:             if ( function.isTableFunction() ) { query.append( "select * from table( " ); }
1:             else { query.append( "values(  " ); }
1:             
1:             query.append( function.getQualifiedName() );
1:             query.append( "( " );
1:             for ( int k = 0; k < argCount; k++ )
1:             {
1:                 if ( k > 0 ) { query.append( ", " ); }
1:                 query.append( " ? " );
1:             }
1:             query.append( " ) )" );
1:             if ( function.isTableFunction() ) { query.append( " s" ); }
1: 
0:             checkSignature( conn, function, query.toString(), makeReadableSignature( function ) );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Make a human readable signature for a routine. This can be
1:      * used in error messages.
1:      * </p>
1:      */
1:     private String  makeReadableSignature( SQLRoutine routine )
1:     {
0:         StringBuffer signature = new StringBuffer();
1:         int             argCount = routine.getArgCount();
1:         
1:         signature.append( routine.getQualifiedName() );
1:         signature.append( "( " );
1:         for ( int k = 0; k < argCount; k++ )
1:         {
1:             if ( k > 0 ) { signature.append( ", " ); }
0:             signature.append( " " + routine.getArgType( k ) + " " );
1:         }
1:         signature.append( " )" );
1: 
1:         return signature.toString();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Find all of the user-declared procedures.
1:      * </p>
1:      */
1:     private void    findProcedures( DatabaseMetaData dbmd )
1:         throws SQLException
1:     {
1:         ResultSet               rs = dbmd.getProcedures( null, null, WILDCARD );
1: 
1:         while( rs.next() )
1:         {
1:             String  schema = rs.getString( 2 );
1:             String  name = rs.getString( 3 );
1: 
1:             if ( isSystemSchema( schema ) ) { continue; }
1: 
1:             putProcedure( schema, name );
1:         }
1:         rs.close();
1:     }
1:     
1:     /**
1:      * <p>
0:      * Count up the arguments to the user-coded procedures.
1:      * </p>
1:      */
1:     private void    countProcedureArgs( DatabaseMetaData dbmd )
1:         throws SQLException
1:     {
1:         int     count = _procedures.size();
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             SQLRoutine  procedure = getProcedure( i );
1: 
1:             ResultSet   rs = dbmd.getProcedureColumns( null, procedure.getSchema(), procedure.getName(), WILDCARD );
1: 
1:             while( rs.next() )
1:             {
1:                 procedure.addArg( rs.getString( 7 ) );
1:             }
1:             rs.close();
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Find all of the user-declared functions. We use reflection to get our
1:      * hands on getFunctions() because that method does not appear in
0:      * the JSR169 api for DatabaseMetaData.
1:      * </p>
1:      */
1:     private void    findFunctions( DatabaseMetaData dbmd )
1:         throws SQLException
1:     {
1:         try {
0:             Method      getFunctionsMethod = dbmd.getClass().getMethod
0:                 ( "getFunctions", new Class[] { String.class, String.class, String.class } );
0:             ResultSet   rs = (ResultSet) getFunctionsMethod.invoke
0:                 ( dbmd, new Object[] { null, null, WILDCARD } );
1: 
1:             while( rs.next() )
1:             {
1:                 String  schema = rs.getString( 2 );
1:                 String  name = rs.getString( 3 );
1:                 short   functionType = rs.getShort( 5 );
1: 
1:                 if ( isSystemSchema( schema ) ) { continue; }
1: 
0:                 boolean isTableFunction;
0:                 if ( functionType == JDBC40Translation.FUNCTION_RETURNS_TABLE ) { isTableFunction = true; }
0:                 else { isTableFunction = false; }
1: 
1:                 putFunction( schema, name, isTableFunction );
1:             }
1:             rs.close();
1: 
1:             
0:         } catch (Exception e) { throw new SQLException( e.getMessage() ); }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Count up the arguments to the user-coded procedures. We use
1:      * reflection to look up the getFunctionColumns() method because that
1:      * method does not appear in the JSR169 api for DatabaseMetaData.
1:      * </p>
1:      */
1:     private void    countFunctionArgs( DatabaseMetaData dbmd )
1:         throws SQLException
1:     {
1:         try {
0:             Method      getFunctionColumnsMethod = dbmd.getClass().getMethod
0:                 ( "getFunctionColumns", new Class[] { String.class, String.class, String.class, String.class } );
1: 
1:             int     count = _functions.size();
1:             for ( int i = 0; i < count; i++ )
1:             {
1:                 SQLRoutine  function = getFunction( i );
1: 
0:                 ResultSet   rs = (ResultSet) getFunctionColumnsMethod.invoke
0:                     ( dbmd, new Object[] { null, function.getSchema(), function.getName(), WILDCARD } );
1: 
1:                 while( rs.next() )
1:                 {
0:                     short   columnType = rs.getShort( 5 );
1: 
1:                     //
0:                     // Skip the return value if this is a table function.
0:                     // Skip all columns in the returned result set if this is a
0:                     // table function.
1:                     //
0:                     if ( columnType == JDBC40Translation.FUNCTION_RETURN ) { continue; }
0:                     if ( columnType == JDBC40Translation.FUNCTION_COLUMN_RESULT ) { continue; }
1:                     
0:                     function.addArg( rs.getString( 7 ) );
1:                 }
1:                 rs.close();
1:             }
0:         } catch (Exception e) { throw new SQLException( e.getMessage() ); }
1:         
1:     }
1:     
1:     /**
1:      * <p>
1:      * Prepared a routine invocation in order to check whether it matches a Java method.
1:      * </p>
1:      */
0:     private void    checkSignature( Connection conn, SQLRoutine routine, String query, String readableSignature )
1:     {
1:         try {
1:             PreparedStatement   ps = prepareStatement( conn, query );
1:             ps.close();
1: 
1:             println( formatMessage( "SC_FOUND_MATCH", readableSignature ) );
1: 
1:                      } catch (SQLException se)
1:         {
1:             println( formatMessage( "SC_UNRESOLVABLE", readableSignature, se.getMessage() ) );
1:         }
1:     }
1:     
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // MINIONS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
0:     private Connection  getJ2MEConnection()
1:         throws SQLException
1:     {
0:         EmbeddedSimpleDataSource    dataSource = new EmbeddedSimpleDataSource();
1: 
0:         dataSource.setDatabaseName( _parsedArgs.getJ2meDatabaseName() );
1: 
0:         return dataSource.getConnection();
1:     }
1: 
1:     /**
1:      * We use reflection to get the J2SE connection so that references to
1:      * DriverManager will not generate linkage errors on old J2ME platforms
1:      * which may resolve references eagerly.
1:      */
1:     private Connection  getJ2SEConnection()
1:         throws SQLException
1:     {
1:         try {
1:             Class.forName( "org.apache.derby.jdbc.EmbeddedDriver" );
1:             Class.forName( "org.apache.derby.jdbc.ClientDriver" );
0:         } catch (Throwable t) {}
1: 
1:         try {
0:             Class   driverManagerClass = Class.forName( "java.sql.DriverManager" );
0:             Method  getConnectionMethod = driverManagerClass.getDeclaredMethod
0:                 ( "getConnection", new Class[] { String.class } );
1: 
0:             return (Connection) getConnectionMethod.invoke
0:                 ( null, new Object[] { _parsedArgs.getJ2seConnectionUrl() } );
1:             
0:         } catch (Throwable t)
1:         {
1:             printThrowable( t );
1:             return null;
1:         }
1:     }
1:     
1:     private PreparedStatement prepareStatement( Connection conn, String text )
1:         throws SQLException
1:     {
1:         if ( _debugging ) { println( "Preparing: " + text ); }
1: 
1:         return conn.prepareStatement( text );
1:     }
1: 
1:     private static  void printUsage()
1:     {
1:         println(  formatMessage( "SC_USAGE" )  );
1:     }
1: 
1:     private static void printThrowable( Throwable t )
1:     {
1:         t.printStackTrace();
1:     }
1:     
1:     private static  void println( String text )
1:     {
1:         System.out.println( text );
1:     }
1: 
1:     /**
1:      * Return true if the schema is a system schema.
1:      */
1:     private boolean isSystemSchema( String schema )
1:     {
1:         int count = SYSTEM_SCHEMAS.length;
1: 
1:         for ( int i = 0; i < count; i++ )
1:         {
1:             if ( SYSTEM_SCHEMAS[ i ].equals( schema ) ) { return true; }
1:         }
1: 
1:         return false;
1:     }
1:     
1:     /**
0:      * Store a procedure descriptor.
1:      */
1:     private void putProcedure( String schema, String name )
1:     {
1:         _procedures.add( new SQLRoutine( schema, name, false )  );
1:     }
1:         
1:     /**
0:      * Get a procedure descriptor.
1:      */
1:     private SQLRoutine getProcedure( int idx )
1:     {
0:         return (SQLRoutine) _procedures.get( idx );
1:     }
1: 
1:     /**
0:      * Store a function descriptor.
1:      */
1:     private void putFunction( String schema, String name, boolean isTableFunction )
1:     {
1:         _functions.add( new SQLRoutine( schema, name, isTableFunction )  );
1:     }
1:         
1:     /**
0:      * Get a functon descriptor.
1:      */
1:     private SQLRoutine getFunction( int idx )
1:     {
0:         return (SQLRoutine) _functions.get( idx );
1:     }
1: 
1:     /**
0:      * Format a localizable message with 0 args.
1:      */
0:     private static  String  formatMessage( String key )
1:     {
0:         return getMessageFormatter().getTextMessage( key );
1:     }
1:     
1:     /**
0:      * Format a localizable message with 1 arg.
1:      */
0:     private static  String  formatMessage( String key, String arg0 )
1:     {
0:         return getMessageFormatter().getTextMessage( key, arg0 );
1:     }
1:     
1:     /**
0:      * Format a localizable message with 2 args.
1:      */
0:     private static  String  formatMessage( String key, String arg0, String arg1 )
1:     {
0:         return getMessageFormatter().getTextMessage( key, arg0, arg1 );
1:     }
1:     
1:     /**
1:      * Get the message resource.
1:      */
1:     private static  LocalizedResource   getMessageFormatter()
1:     {
1:         if ( _messageFormatter == null )
1:         {
1:             _messageFormatter = LocalizedResource.getInstance();
1:         }
1:         return _messageFormatter;
1:     }
1: 
1: 
1:         
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // INNER CLASSES
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     static class ParsedArgs
1:     {
1:         private boolean _isValid;
0:         private boolean _isJ2ME;
1:         private String _j2seConnectionUrl;
0:         private String _j2meDatabaseName;
1: 
1:         public  ParsedArgs( String[] args )
1:         {
1:             _isValid = false;
1:             
0:             _isJ2ME = !classExists( "java.sql.DriverManager" );
1: 
1:             parseArgs( args );
1:         }
1: 
1:         public boolean isValid() { return _isValid; }
0:         public boolean isJ2ME() { return _isJ2ME; }
1: 
1:         public String getJ2seConnectionUrl() { return _j2seConnectionUrl; }
0:         public String getJ2meDatabaseName() { return _j2meDatabaseName; }
1: 
1:         private void parseArgs( String[] args )
1:         {
1:             if ( args == null ) { return; }
0:             if ( args.length == 0 ) { return; }
1:             
0:             if ( isJ2ME() )
1:             {
0:                 if ( args.length != 1 ) { return; }
1: 
0:                 _j2meDatabaseName = args[ 0 ];
0:                 _isValid = true;
1:             }
1:             else
1:             {
0:                 if ( args.length != 1 ) { return; }
1: 
0:                 _j2seConnectionUrl = args[ 0 ];
0:                 _isValid = true;
1:             }
1:         }
1: 
0:         private boolean classExists( String className )
1:         {
1:             try {
0:                 Class.forName( className );
1: 
0:                 return true;
0:             } catch (Throwable t) { return false; }
1:         }
1:     }
1: 
1:     class SQLRoutine
1:     {
0:         private String _schema;
0:         private String _name;
0:         private boolean _isTableFunction;
0:         private ArrayList   _argList = new ArrayList();
1: 
1:         public SQLRoutine( String schema, String name, boolean isTableFunction )
1:         {
1:             _schema = schema;
1:             _name = name;
1:             _isTableFunction = isTableFunction;
1:         }
1: 
1:         public void addArg( String typeName ) { _argList.add( typeName ); }
1: 
1:         public String getSchema() { return _schema; }
1:         public String getName() { return _name; }
1:         public int      getArgCount() { return _argList.size(); }
0:         public String getArgType( int idx ) { return (String) _argList.get( idx ); }
1:         public boolean isTableFunction() { return _isTableFunction; }
1: 
1:         public  String  toString()
1:         {
0:             StringBuffer    buffer = new StringBuffer();
1: 
1:             buffer.append( "SQLRoutine( " );
0:             buffer.append( _schema + ", " );
0:             buffer.append( _name + ", " );
0:             buffer.append(  "isTableFunction = " + _isTableFunction + ", " );
0:             buffer.append( " argCount = " + getArgCount() );
1:             buffer.append( " )" );
1: 
1:             return buffer.toString();
1:         }
1: 
1:         private String doubleQuote( String raw )
1:         {
1:             return '\"' + raw + '\"';
1:         }
1:         public  String  getQualifiedName()
1:         {
1:             return doubleQuote( _schema ) + '.' + doubleQuote( _name );
1:         }
1: 
1:     }
1:     
1: }
============================================================================