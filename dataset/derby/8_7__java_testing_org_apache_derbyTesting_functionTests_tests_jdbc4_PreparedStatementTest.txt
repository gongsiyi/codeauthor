3:49335b4: /*
1:c511410:  
1:49335b4:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest
1:c511410:  
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
21:49335b4:  
1:49335b4:       http://www.apache.org/licenses/LICENSE-2.0
1:49335b4:  
1:49335b4:    Unless required by applicable law or agreed to in writing, software
1:49335b4:    distributed under the License is distributed on an "AS IS" BASIS,
1:49335b4:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:49335b4:    See the License for the specific language governing permissions and
1:49335b4:    limitations under the License.
1:49335b4:  
1:49335b4:  */
1:49335b4: 
1:49335b4: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1:49335b4: 
1:1ae02c9: import java.io.ByteArrayInputStream;
1:1ae02c9: import java.io.IOException;
1:1ae02c9: import java.io.InputStream;
1:1ae02c9: import java.io.OutputStream;
1:1ae02c9: import java.io.Reader;
1:1ae02c9: import java.io.StringReader;
1:1ae02c9: import java.sql.Blob;
1:1ae02c9: import java.sql.CallableStatement;
1:1ae02c9: import java.sql.Clob;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.NClob;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.RowId;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.SQLFeatureNotSupportedException;
1:1ae02c9: import java.sql.SQLXML;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import java.sql.Types;
1:1ae02c9: import junit.framework.Test;
1:1ae02c9: import org.apache.derby.iapi.services.io.DerbyIOException;
1:1ae02c9: import org.apache.derby.shared.common.sanity.SanityManager;
1:1ae02c9: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:ee7f668: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:2aa7d95: import org.apache.derbyTesting.junit.JDBC;
1:ec5ae26: import org.apache.derbyTesting.junit.TestConfiguration;
1:10cc70b: 
1:c511410: /**
1:49335b4:  * This class is used to test JDBC4 specific methods in the PreparedStatement(s)
1:49335b4:  * object.
1:10cc70b:  *
1:10cc70b:  * A number of methods and variables are in place to aid the writing of tests:
1:10cc70b:  * <ul><li>setBinaryStreamOnBlob
1:10cc70b:  *     <li>setAsciiStream
1:10cc70b:  *     <li>key - an id. One is generated each time setUp is run.
1:10cc70b:  *     <li>reqeustKey() - generate a new unique id.
1:10cc70b:  *     <li>psInsertX - prepared statements for insert.
1:10cc70b:  *     <li>psFetchX - prepared statements for fetching values.
1:10cc70b:  * </ul>
1:10cc70b:  *
1:10cc70b:  * For table creation, see the <code>suite</code>-method.
1:c511410:  */
1:49335b4: public class PreparedStatementTest extends BaseJDBCTestCase {
1:242c9bd: 
1:10cc70b:     private static final String BLOBTBL = "BlobTestTable";
1:10cc70b:     private static final String CLOBTBL = "ClobTestTable";
1:10cc70b:     private static final String LONGVARCHAR = "LongVarcharTestTable";
1:10cc70b: 
1:10cc70b:     /** Key used to id data inserted into the database. */
1:10cc70b:     private static int globalKey = 1;
1:10cc70b: 
1:242c9bd:     /** Byte array passed in to the database. **/
1:242c9bd:     private static final byte[] BYTES = {
1:242c9bd:         0x65, 0x66, 0x67, 0x68, 0x69,
1:242c9bd:         0x69, 0x68, 0x67, 0x66, 0x65
1:242c9bd:     };
1:242c9bd: 
1:10cc70b:     // Default connection and prepared statements that are used by the tests.
1:10cc70b:     /** 
1:10cc70b:      * Default key to use for insertions.
1:10cc70b:      * Is unique for each fixture. More keys can be fetched by calling
1:10cc70b:      * <link>requestKey</link>.
1:49335b4:      */
1:10cc70b:     private int key;
1:10cc70b:     /** Default connection object. */
1:10cc70b:     /** PreparedStatement object with no positional arguments. */
1:13e9e78:     private PreparedStatement ps = null;
1:10cc70b:     /** PreparedStatement to fetch BLOB with specified id. */
1:10cc70b:     private PreparedStatement psFetchBlob = null;
1:10cc70b:     /** PreparedStatement to insert a BLOB with specified id. */
1:10cc70b:     private PreparedStatement psInsertBlob = null;
1:10cc70b:     /** PreparedStatement to fetch CLOB with specified id. */
1:10cc70b:     private PreparedStatement psFetchClob = null;
1:10cc70b:     /** PreparedStatement to insert a CLOB with specified id. */
1:10cc70b:     private PreparedStatement psInsertClob = null;
1:10cc70b:     /** PreparedStatement to insert a LONG VARCHAR with specified id. */
1:10cc70b:     private PreparedStatement psInsertLongVarchar = null;
1:c511410:     //Statement object
1:13e9e78:     private Statement s = null;
1:10cc70b: 
1:c511410: 
1:49335b4:     
2:49335b4:     /**
1:49335b4:      * Create a test with the given name.
9:49335b4:      * 
1:49335b4:      * @param name name of the test.
1:49335b4:      */
1:49335b4:     public PreparedStatementTest(String name) {
1:49335b4:         super(name);
1:10cc70b:     }
1:242c9bd:     
1:20b2fd9:     /**
1:c511410:      *
1:49335b4:      * Obtain a "regular" connection and PreparedStatement that the tests 
1:49335b4:      * can use.
1:c511410:      * 
1:c511410:      * @throws SQLException
1:20b2fd9:      */
1:10cc70b:     public void setUp() 
1:49335b4:         throws SQLException {
1:10cc70b:         key = requestKey();
1:10cc70b:         //create the statement object
1:13e9e78:         s = createStatement();
1:49335b4:         //Create the PreparedStatement that will then be used as the basis 
1:49335b4:         //throughout this test henceforth
1:49335b4:         //This prepared statement will however NOT be used for testing
1:49335b4:         //setClob and setBlob
1:13e9e78:         ps = prepareStatement("select count(*) from sys.systables");
1:10cc70b:         
1:10cc70b:         // Prepare misc statements.
1:10cc70b:         psFetchBlob = prepareStatement("SELECT dBlob FROM " +
1:10cc70b:                 BLOBTBL + " WHERE sno = ?");
1:10cc70b:         psInsertBlob = prepareStatement("INSERT INTO " + BLOBTBL +
1:10cc70b:                 " VALUES (?, ?)");
1:10cc70b:         psFetchClob = prepareStatement("SELECT dClob FROM " +
1:10cc70b:                 CLOBTBL + " WHERE sno = ?");
1:10cc70b:         psInsertClob = prepareStatement("INSERT INTO " + CLOBTBL +
1:10cc70b:                 " VALUES (?, ?)");
1:10cc70b:         psInsertLongVarchar = prepareStatement("INSERT INTO " + LONGVARCHAR +
1:10cc70b:                 " VALUES (?, ?)");
1:10cc70b:     }
1:054fa3a: 
1:20b2fd9:     /**
1:c511410:      *
1:49335b4:      * Release the resources that are used in this test
1:49335b4:      *
1:49335b4:      * @throws SQLException
1:49335b4:      *
1:49335b4:      */
1:10cc70b:     public void tearDown() 
1:13e9e78:         throws Exception {
1:c511410:         
1:79b7c08:         s.close();
1:79b7c08:         ps.close();
1:79b7c08: 
1:9b52936:         s = null;
1:9b52936:         ps = null;
1:9b52936: 
1:10cc70b:         psFetchBlob.close();
1:10cc70b:         psFetchClob.close();
1:10cc70b:         psInsertBlob.close();
1:10cc70b:         psInsertClob.close();
1:10cc70b:         psInsertLongVarchar.close();
1:c511410:         
1:9b52936:         psFetchBlob = null;
1:9b52936:         psFetchClob = null;
1:9b52936:         psInsertBlob = null;
1:9b52936:         psInsertClob = null;
1:9b52936:         psInsertLongVarchar = null;
1:9b52936: 
1:10cc70b:         super.tearDown();
1:10cc70b:     }
1:c511410: 
1:054fa3a:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("PreparedStatementTest suite");
1:1ae02c9: 
1:ec5ae26:         suite.addTest(baseSuite("PreparedStatementTest:embedded"));
1:ee7f668:         suite.addTest(
1:ee7f668:                 TestConfiguration.connectionXADecorator(
1:ee7f668:                         baseSuite("PreparedStatementTest:embedded XADataSource")));
1:c511410:         
1:ec5ae26:         suite.addTest(TestConfiguration.clientServerDecorator(
1:ec5ae26:             baseSuite("PreparedStatementTest:client")));
1:49335b4: 
1:eb0e14c:         suite.addTest(TestConfiguration.clientServerDecorator(
1:eb0e14c:                         TestConfiguration.connectionCPDecorator( baseSuite
1:eb0e14c:                                 ("PreparedStatementTest:logical"))));
1:eb0e14c: 
1:2aa7d95:         // Tests for the client side JDBC statement cache.
1:2aa7d95:         suite.addTest(TestConfiguration.clientServerDecorator(
1:2aa7d95:                 statementCachingSuite()));
1:49335b4: 
1:ee7f668:         suite.addTest(
1:ee7f668:                 TestConfiguration.clientServerDecorator(
1:ee7f668:                 TestConfiguration.connectionXADecorator(
1:ee7f668:                 baseSuite("PreparedStatementTest:client XXXXADataSource"))));
1:49335b4: 
1:ec5ae26:         return suite;
1:ec5ae26:     }
1:ec5ae26: 
1:ec5ae26:     private static Test baseSuite(String name) {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:054fa3a:         suite.addTestSuite(PreparedStatementTest.class);
1:ee7f668:         return new CleanDatabaseTestSetup(suite) {
1:10cc70b: 
1:ee7f668:             protected void decorateSQL(Statement stmt) throws SQLException
1:ee7f668:             {
1:10cc70b:                     stmt.execute("create table " + BLOBTBL +
1:10cc70b:                             " (sno int, dBlob BLOB(1M))");
1:10cc70b:                     stmt.execute("create table " + CLOBTBL +
1:10cc70b:                             " (sno int, dClob CLOB(1M))");
1:10cc70b:                     stmt.execute("create table " + LONGVARCHAR  +
1:10cc70b:                             " (sno int, dLongVarchar LONG VARCHAR)");
1:10cc70b:                  }
1:10cc70b:             };
1:054fa3a:     }
1:49335b4:     
1:49335b4:     /**
1:2aa7d95:      * Returns a suite for tests that need JDBC statement caching to be enabled.
1:49335b4:      */
1:2aa7d95:     private static Test statementCachingSuite() {
1:1ae02c9:         BaseTestSuite suite =
1:1ae02c9:             new BaseTestSuite("JDBC statement caching suite");
1:1ae02c9: 
1:2aa7d95:         suite.addTest(new PreparedStatementTest("cpTestIsPoolableHintFalse"));
1:2aa7d95:         suite.addTest(new PreparedStatementTest("cpTestIsPoolableHintTrue"));
1:2aa7d95:         return TestConfiguration.connectionCPDecorator(
1:2aa7d95:             new CleanDatabaseTestSetup(suite) {
1:49335b4: 
1:2aa7d95:             protected void decorateSQL(Statement stmt)
1:10cc70b:                     throws SQLException {
1:2aa7d95:                 stmt.execute("create table " + BLOBTBL +
1:2aa7d95:                         " (sno int, dBlob BLOB(1M))");
1:2aa7d95:                 stmt.execute("create table " + CLOBTBL +
1:2aa7d95:                         " (sno int, dClob CLOB(1M))");
1:2aa7d95:                 stmt.execute("create table " + LONGVARCHAR  +
1:2aa7d95:                         " (sno int, dLongVarchar LONG VARCHAR)");
1:20b2fd9:                  }
1:2aa7d95:             });
1:20b2fd9:     }
1:49335b4: 
1:49335b4:     //--------------------------------------------------------------------------
1:49335b4:     //BEGIN THE TEST OF THE METHODS THAT THROW AN UNIMPLEMENTED EXCEPTION IN
1:49335b4:     //THIS CLASS
1:49335b4:     
1:49335b4:     /**
1:49335b4:      * Tests the setRowId method of the PreparedStatement interface
1:49335b4:      *
3:49335b4:      * @throws SQLException upon any failure that occurs in the 
1:49335b4:      *         call to the method.
1:49335b4:      */
1:49335b4:     public void testSetRowId() throws SQLException{
1:10cc70b:         try {
1:49335b4:             RowId rowid = null;
1:49335b4:             ps.setRowId(0,rowid);
1:49335b4:             fail("setRowId should not be implemented");
1:20b2fd9:         }
1:49335b4:         catch(SQLFeatureNotSupportedException sqlfne) {
1:49335b4:             //Do Nothing, This happens as expected
1:20b2fd9:         }
21:49335b4:     }
1:49335b4:     
1:49335b4:     /**
1:49335b4:      * Tests the setNString method of the PreparedStatement interface
1:49335b4:      *
1:49335b4:      * @throws SQLException upon any failure that occurs in the 
1:49335b4:      *         call to the method.
1:49335b4:      */
1:49335b4:     public void testSetNString() throws SQLException{
11:49335b4:         try {
1:49335b4:             String str = null;
1:49335b4:             ps.setNString(0,str);
1:49335b4:             fail("setNString should not be implemented");
1:49335b4:         }
1:49335b4:         catch(SQLFeatureNotSupportedException sqlfne) {
1:49335b4:             //Do Nothing, This happens as expected
1:49335b4:         }
1:49335b4:     }
1:49335b4:     
1:49335b4:     /**
1:49335b4:      * Tests the setNCharacterStream method of the PreparedStatement interface
1:49335b4:      *
1:49335b4:      * @throws SQLException upon any failure that occurs in the 
1:49335b4:      *         call to the method.
1:49335b4:      */
1:49335b4:     public void testSetNCharacterStream() throws SQLException{
1:49335b4:         try {
1:49335b4:             Reader r  = null;
1:49335b4:             ps.setNCharacterStream(0,r,0);
1:49335b4:             fail("setNCharacterStream should not be implemented");
1:49335b4:         }
1:49335b4:         catch(SQLFeatureNotSupportedException sqlfne) {
1:49335b4:             //Do Nothing, This happens as expected
1:49335b4:         }
1:49335b4:     }
1:49335b4:     
1:242c9bd:     public void testSetNCharacterStreamLengthlessNotImplemented()
1:242c9bd:             throws SQLException {
1:242c9bd:         try {
1:242c9bd:             ps.setNCharacterStream(1, new StringReader("A string"));
1:242c9bd:             fail("setNCharacterStream(int,Reader) should not be implemented");
1:242c9bd:         } catch (SQLFeatureNotSupportedException sfnse) {
1:242c9bd:             // Do nothing, this is expected behavior.
1:242c9bd:         }
1:242c9bd:     }
1:242c9bd: 
1:242c9bd:     public void testSetNClobLengthlessNotImplemented()
1:242c9bd:             throws SQLException {
1:242c9bd:         try {
1:242c9bd:             ps.setNClob(1, new StringReader("A string"));
1:242c9bd:             fail("setNClob(int,Reader) should not be implemented");
1:242c9bd:         } catch (SQLFeatureNotSupportedException sfnse) {
1:242c9bd:             // Do nothing, this is expected behaviour.
1:242c9bd:         }
1:242c9bd:     }
1:242c9bd: 
1:49335b4:     /**
1:49335b4:      * Tests the setNClob method of the PreparedStatement interface
1:49335b4:      *
1:49335b4:      * @throws SQLException upon any failure that occurs in the 
1:49335b4:      *         call to the method.
1:49335b4:      */
1:49335b4:     public void testSetNClob1() throws SQLException{
1:49335b4:         try {
1:49335b4:             NClob nclob = null;
1:49335b4:             ps.setNClob(0,nclob);
1:49335b4:             fail("setNClob should not be implemented");
1:49335b4:         }
1:49335b4:         catch(SQLFeatureNotSupportedException sqlfne) {
1:49335b4:             //Do Nothing, This happens as expected
1:49335b4:         }
1:49335b4:     }
1:49335b4:     
1:49335b4:     /**
1:49335b4:      * Tests the setNClob method of the PreparedStatement interface
1:49335b4:      *
1:49335b4:      * @throws SQLException upon any failure that occurs in the 
1:49335b4:      *         call to the method.
1:49335b4:      */
1:49335b4:     public void testSetNClob2() throws SQLException{
1:49335b4:         try {
1:49335b4:             Reader reader = null;
1:49335b4:             ps.setNClob(0,reader,0);
1:49335b4:             fail("setNClob should not be implemented");
1:49335b4:         }
1:49335b4:         catch(SQLFeatureNotSupportedException sqlfne) {
1:49335b4:             //Do Nothing, This happens as expected
1:49335b4:         }
1:49335b4:     }
1:49335b4:     
1:49335b4:     /**
1:49335b4:      * Tests the setSQLXML method of the PreparedStatement interface
1:49335b4:      *
1:49335b4:      * @throws SQLException upon any failure that occurs in the 
1:49335b4:      *         call to the method.
1:49335b4:      */
1:49335b4:     public void testSetSQLXML() throws SQLException{
1:49335b4:         try {
1:49335b4:             SQLXML sqlxml = null;
1:49335b4:             ps.setSQLXML(0,sqlxml);
1:49335b4:             fail("setNClob should not be implemented");
1:49335b4:         }
1:49335b4:         catch(SQLFeatureNotSupportedException sqlfne) {
1:49335b4:             //Do Nothing, This happens as expected
1:49335b4:         }
1:49335b4:     }
1:49335b4:     
1:49335b4:     //--------------------------------------------------------------------------
1:49335b4:     //Now test the methods that are implemented in the PreparedStatement 
1:49335b4:     //interface
1:f631317: 
1:f631317:     public void testIsWrapperForStatement() throws SQLException {
1:f631317:         assertTrue(ps.isWrapperFor(Statement.class));
1:f631317:     }
1:f631317: 
1:f631317:     public void testIsWrapperForPreparedStatement() throws SQLException {
1:f631317:         assertTrue(ps.isWrapperFor(PreparedStatement.class));
1:f631317:     }
1:f631317: 
1:f631317:     public void testIsNotWrapperForCallableStatement() throws SQLException {
1:f631317:         assertFalse(ps.isWrapperFor(CallableStatement.class));
1:f631317:     }
1:f631317: 
1:f631317:     public void testIsNotWrapperForResultSet() throws SQLException {
1:f631317:         assertFalse(ps.isWrapperFor(ResultSet.class));
1:f631317:     }
1:f631317: 
1:2ff02ef:     public void testIsWrapperForSelf() throws SQLException {
1:2ff02ef:         assertTrue(ps.isWrapperFor(ps.getClass()));
1:2ff02ef:     }
1:2ff02ef: 
1:f631317:     public void testUnwrapStatement() throws SQLException {
1:f631317:         Statement stmt = ps.unwrap(Statement.class);
1:f631317:         assertSame("Unwrap returned wrong object.", ps, stmt);
1:f631317:     }
1:f631317: 
1:f631317:     public void testUnwrapPreparedStatement() throws SQLException {
1:f631317:         PreparedStatement ps2 = ps.unwrap(PreparedStatement.class);
1:f631317:         assertSame("Unwrap returned wrong object.", ps, ps2);
1:f631317:     }
1:f631317: 
1:2ff02ef:     public void testUnwrapAsSelf() throws SQLException {
1:2ff02ef:         PreparedStatement ps2 = ps.unwrap(ps.getClass());
1:2ff02ef:         assertSame("Unwrap returned wrong object.", ps, ps2);
1:2ff02ef:     }
1:2ff02ef: 
1:f631317:     public void testUnwrapCallableStatement() {
1:f631317:         try {
1:f631317:             CallableStatement cs = ps.unwrap(CallableStatement.class);
1:f631317:             fail("Unwrap didn't fail.");
1:f631317:         } catch (SQLException e) {
1:f631317:             assertSQLState("XJ128", e);
1:49335b4:         }
1:49335b4:     }
1:f631317: 
1:f631317:     public void testUnwrapResultSet() {
1:f631317:         try {
1:f631317:             ResultSet rs = ps.unwrap(ResultSet.class);
1:f631317:             fail("Unwrap didn't fail.");
1:f631317:         } catch (SQLException e) {
1:f631317:             assertSQLState("XJ128", e);
1:49335b4:         }
1:49335b4:     }
1:49335b4: 
1:49335b4:     //-----------------------------------------------------------------------
1:49335b4:     // Begin test for setClob and setBlob
1:49335b4:     
1:49335b4:     /*
1:49335b4:        we need a table in which a Clob or a Blob can be stored. We basically
1:49335b4:        need to write tests for the setClob and the setBlob methods. 
1:49335b4:        Proper process would be
1:49335b4:        a) Do a createClob or createBlob
1:49335b4:        b) Populate data in the LOB
1:49335b4:        c) Store in Database
1:49335b4: 
1:49335b4:        But the createClob and createBlob implementations are not 
1:49335b4:        available on the EmbeddedServer. So instead the workaround adopted
1:49335b4:        is 
1:49335b4: 
1:49335b4:        a) store a Clob or Blob in Database. 
1:49335b4:        b) Retrieve it from the database.
1:49335b4:        c) store it back using setClob or setBlob
1:49335b4: 
1:49335b4:      */
1:49335b4: 
1:49335b4:     /**
1:49335b4:      *
1:49335b4:      * Test the setClob() method
1:49335b4:      *
1:49335b4:      * @throws SQLException if a failure occurs during the call to setClob
1:49335b4:      *
1:49335b4:      */
1:242c9bd:     public void testSetClob()
1:242c9bd:             throws IOException, SQLException {
1:d3e6a71:         // Life span of Clob objects are limited by the transaction.  Need
1:d3e6a71:         // autocommit off so Clob objects survive execution of next statement.
1:d3e6a71:         getConnection().setAutoCommit(false);
1:d3e6a71: 
2:49335b4:         //insert default values into the table
1:49335b4:         
1:49335b4:         String str = "Test data for the Clob object";
1:49335b4:         StringReader is = new StringReader("Test data for the Clob object");
1:242c9bd:         is.reset();
1:c511410:         
1:49335b4:         //initially insert the data
1:10cc70b:         psInsertClob.setInt(1, key);
1:10cc70b:         psInsertClob.setClob(2, is, str.length());
1:10cc70b:         psInsertClob.executeUpdate();
1:c511410:         
1:c511410:         //Now query to retrieve the Clob
1:10cc70b:         psFetchClob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchClob.executeQuery();
1:49335b4:         rs.next();
1:10cc70b:         Clob clobToBeInserted = rs.getClob(1);
2:c511410:         rs.close();
1:c511410:         
1:49335b4:         //Now use the setClob method
1:10cc70b:         int secondKey = requestKey();
1:10cc70b:         psInsertClob.setInt(1, secondKey);
1:10cc70b:         psInsertClob.setClob(2, clobToBeInserted);
1:10cc70b:         psInsertClob.execute();
1:c511410:         
1:10cc70b:         psInsertClob.close();
1:c511410:         
1:49335b4:         //Now test to see that the Clob has been stored correctly
1:10cc70b:         psFetchClob.setInt(1, secondKey);
1:10cc70b:         rs = psFetchClob.executeQuery();
1:49335b4:         rs.next();
1:10cc70b:         Clob clobRetrieved = rs.getClob(1);
1:c511410:         
1:242c9bd:         assertEquals(clobToBeInserted,clobRetrieved);
1:c511410:     }
1:242c9bd: 
1:242c9bd:     /**
1:242c9bd:      * Insert <code>Clob</code> without specifying length and read it back
1:242c9bd:      * for verification.
1:49335b4:      *
1:d3e6a71:      * @throws IOException If an IOException during the close operation on the
1:d3e6a71:      *                     reader.
1:d3e6a71:      * @throws SQLException If an SQLException occurs.
1:49335b4:      */
1:956354d:     public void testSetClobLengthless()
1:242c9bd:             throws IOException, SQLException {
1:d3e6a71:         // Life span of Clob objects are the transaction.  Need autocommit off
1:d3e6a71:         // to have Clob objects survive execution of next statement.
1:d3e6a71:         getConnection().setAutoCommit(false);
1:d3e6a71: 
1:d3e6a71:         //Create the Clob and insert data into it.
1:d3e6a71:         Clob insertClob = getConnection().createClob();
1:d3e6a71:         OutputStream os = insertClob.setAsciiStream(1);
1:d3e6a71:         os.write(BYTES);
1:d3e6a71: 
1:d3e6a71:         //Insert the Clob created above into the
1:d3e6a71:         //database.
1:10cc70b:         psInsertClob.setInt(1, key);
1:10cc70b:         psInsertClob.setClob(2, insertClob);
1:10cc70b:         psInsertClob.execute();
1:c511410: 
1:242c9bd:         // Read back test data from database.
1:d3e6a71:         psFetchClob.setInt(1, key);
1:d3e6a71:         ResultSet rs = psFetchClob.executeQuery();
1:242c9bd:         assertTrue("No results retrieved", rs.next());
1:242c9bd:         Clob clobRetrieved = rs.getClob(1);
1:c511410: 
1:242c9bd:         // Verify test data.
1:242c9bd:         assertEquals(insertClob, clobRetrieved);
1:c511410:     }
1:49335b4: 
1:49335b4:     /**
1:49335b4:      *
1:49335b4:      * Test the setBlob() method
1:49335b4:      *
1:49335b4:      * @throws SQLException if a failure occurs during the call to setBlob
1:49335b4:      *
1:49335b4:      */
1:242c9bd:     public void testSetBlob()
1:242c9bd:             throws IOException, SQLException {
1:05d610e:         // Life span of Blob objects are limited by the transaction.  Need
1:05d610e:         // autocommit off so Blob objects survive execution of next statement.
1:05d610e:         getConnection().setAutoCommit(false);
1:49335b4:         
1:05d610e:         //insert default values into the table
1:242c9bd:         InputStream is = new java.io.ByteArrayInputStream(BYTES);
1:242c9bd:         is.reset();
1:49335b4:         
1:49335b4:         //initially insert the data
1:10cc70b:         psInsertBlob.setInt(1, key);
1:10cc70b:         psInsertBlob.setBlob(2, is, BYTES.length);
1:10cc70b:         psInsertBlob.executeUpdate();
1:49335b4:         
1:49335b4:         //Now query to retrieve the Blob
1:10cc70b:         psFetchBlob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchBlob.executeQuery();
1:49335b4:         rs.next();
1:10cc70b:         Blob blobToBeInserted = rs.getBlob(1);
1:c511410:         rs.close();
1:49335b4:         
1:49335b4:         //Now use the setBlob method
1:10cc70b:         int secondKey = requestKey();
1:10cc70b:         psInsertBlob.setInt(1, secondKey);
1:10cc70b:         psInsertBlob.setBlob(2, blobToBeInserted);
1:10cc70b:         psInsertBlob.execute();
1:49335b4:         
1:10cc70b:         psInsertBlob.close();
1:49335b4:         
1:49335b4:         //Now test to see that the Blob has been stored correctly
1:10cc70b:         psFetchBlob.setInt(1, secondKey);
1:10cc70b:         rs = psFetchBlob.executeQuery();
1:49335b4:         rs.next();
1:10cc70b:         Blob blobRetrieved = rs.getBlob(1);
1:49335b4:         
1:242c9bd:         assertEquals(blobToBeInserted, blobRetrieved);
1:c511410:     }
1:49335b4:     
1:242c9bd:     /**
1:242c9bd:      * Insert <code>Blob</code> without specifying length and read it back
1:242c9bd:      * for verification.
1:49335b4:      */
1:956354d:     public void testSetBlobLengthless()
1:242c9bd:             throws IOException, SQLException {
1:05d610e:         // Life span of Blob objects are the transaction.  Need autocommit off
1:05d610e:         // to have Blob objects survive execution of next statement.
1:05d610e:         getConnection().setAutoCommit(false);
1:05d610e:         // Create Blob to be inserted
1:05d610e:         Blob insertBlob = getConnection().createBlob();
1:05d610e:         OutputStream os = insertBlob.setBinaryStream(1);
1:05d610e:         os.write(BYTES);
1:10cc70b:         int secondKey = requestKey();
1:10cc70b:         psInsertBlob.setInt(1, secondKey);
1:10cc70b:         psInsertBlob.setBlob(2, insertBlob);
1:10cc70b:         psInsertBlob.execute();
1:05d610e:         os.close();
1:05d610e:         psInsertBlob.close();
1:242c9bd: 
1:242c9bd:         // Read back test data from database.
1:10cc70b:         psFetchBlob.setInt(1, secondKey);
1:05d610e:         ResultSet rs = psFetchBlob.executeQuery();
1:242c9bd:         assertTrue("No results retrieved", rs.next());
1:242c9bd:         Blob blobRetrieved = rs.getBlob(1);
1:242c9bd: 
1:242c9bd:         // Verify test data.
1:242c9bd:         assertEquals(insertBlob, blobRetrieved);
1:49335b4:     }
1:49335b4: 
1:49335b4:     //-------------------------------------------------
1:49335b4:     //Test the methods used to test poolable statements
1:49335b4:     
1:49335b4:     /**
1:49335b4:      *
1:49335b4:      * Tests the PreparedStatement interface method setPoolable
1:49335b4:      *
1:49335b4:      * @throws SQLException
1:49335b4:      */
1:49335b4:     
1:49335b4:     public void testSetPoolable() throws SQLException {
1:79b7c08:         // Set the poolable statement hint to false
1:79b7c08:         ps.setPoolable(false);
1:79b7c08:         assertFalse("Expected a non-poolable statement", ps.isPoolable());
1:79b7c08:         // Set the poolable statement hint to true
1:79b7c08:         ps.setPoolable(true);
1:79b7c08:         assertTrue("Expected a non-poolable statement", ps.isPoolable());
1:79b7c08:     }
1:79b7c08: 
1:79b7c08:     /**
1:79b7c08:      *
1:79b7c08:      * Tests the PreparedStatement interface method setPoolable on a closed
1:79b7c08:      * PreparedStatement
1:79b7c08:      *
1:79b7c08:      * @throws SQLException
1:79b7c08:      */
1:79b7c08:     public void testSetPoolableOnClosed() throws SQLException {
1:c511410:         try {
1:79b7c08:             ps.close();
1:49335b4:             // Set the poolable statement hint to false
1:49335b4:             ps.setPoolable(false);
1:79b7c08:             fail("Expected an exception on closed statement");
1:79b7c08:          } catch(SQLException sqle) {
1:49335b4:             // Check which SQLException state we've got and if it is
1:49335b4:             // expected, do not print a stackTrace
1:49335b4:             // Embedded uses XJ012, client uses XCL31.
1:49335b4:             if (sqle.getSQLState().equals("XJ012") ||
1:49335b4:                 sqle.getSQLState().equals("XCL31")) {
1:49335b4:                 // All is good and is expected
1:10cc70b:             } else {
1:49335b4:                 fail("Unexpected SQLException " + sqle);
1:49335b4:             }
1:49335b4:         }
1:49335b4:     }
1:49335b4:     
1:49335b4:     /**
1:49335b4:      *
1:49335b4:      * Tests the PreparedStatement interface method isPoolable
1:49335b4:      *
1:49335b4:      * @throws SQLException
1:49335b4:      *
1:49335b4:      */
1:2aa7d95:     public void testIsPoolableDefault() throws SQLException {
1:79b7c08:         // By default a prepared statement is poolable
1:79b7c08:         assertTrue("Expected a poolable statement", ps.isPoolable());
1:79b7c08:     }
1:79b7c08: 
1:79b7c08:     /**
1:2aa7d95:      * Tests that the {@code isPoolable}-hint works by exploiting the fact that
1:2aa7d95:      * the client cannot prepare a statement referring to a deleted table
1:2aa7d95:      * (unless the statement is already in the statement cache).
1:79b7c08:      *
1:2aa7d95:      * @throws SQLException if something goes wrong...
1:49335b4:      */
1:2aa7d95:     public void cpTestIsPoolableHintFalse()
1:49335b4:             throws SQLException {
1:2aa7d95:         getConnection().setAutoCommit(false);
1:2aa7d95:         // Create a table, insert a row, then create a statement selecting it.
1:2aa7d95:         Statement stmt = createStatement();
1:2aa7d95:         stmt.executeUpdate("create table testispoolablehint (id int)");
1:2aa7d95:         stmt.executeUpdate("insert into testispoolablehint values 1");
1:2aa7d95:         PreparedStatement ps = prepareStatement(
1:2aa7d95:                 "select * from testispoolablehint");
1:2aa7d95:         ps.setPoolable(false);
1:2aa7d95:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:2aa7d95:         // Close statement, which should be discarded.
1:2aa7d95:         ps.close();
1:2aa7d95:         // Now delete the table.
1:2aa7d95:         stmt.executeUpdate("drop table testispoolablehint");
1:10cc70b:         stmt.close();
1:2aa7d95:         // Since there is no cached statement, we'll get exception here.
1:c511410:         try {
1:2aa7d95:             ps = prepareStatement("select * from testispoolablehint");
1:2aa7d95:             fail("Prepared statement not valid, referring non-existing table");
1:10cc70b:         } catch (SQLException sqle) {
1:2aa7d95:             assertSQLState("42X05", sqle);
1:10cc70b:         }
1:10cc70b:     }
1:10cc70b: 
1:49335b4:     /**
1:2aa7d95:      * Tests that the {@code isPoolable}-hint works by exploiting the fact that
1:2aa7d95:      * the client can prepare a statement referring to a deleted table if JDBC
1:2aa7d95:      * statement caching is enabled and the statement is already in the cache.
1:49335b4:      *
1:2aa7d95:      * @throws SQLException if something goes wrong...
1:49335b4:      */
1:2aa7d95:     public void cpTestIsPoolableHintTrue()
1:10cc70b:             throws SQLException {
1:2aa7d95:         getConnection().setAutoCommit(false);
1:2aa7d95:         // Create a table, insert a row, then create a statement selecting it.
1:2aa7d95:         Statement stmt = createStatement();
1:2aa7d95:         stmt.executeUpdate("create table testispoolablehint (id int)");
1:2aa7d95:         stmt.executeUpdate("insert into testispoolablehint values 1");
1:2aa7d95:         PreparedStatement ps = prepareStatement(
1:2aa7d95:                 "select * from testispoolablehint");
1:49335b4:         ps.setPoolable(true);
1:2aa7d95:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:2aa7d95:         // Put the statement into the cache.
1:2aa7d95:         ps.close();
1:2aa7d95:         // Now delete the table and fetch the cached prepared statement.
1:2aa7d95:         stmt.executeUpdate("drop table testispoolablehint");
1:10cc70b:         stmt.close();
1:2aa7d95:         ps = prepareStatement("select * from testispoolablehint");
1:2aa7d95:         // If we get this far, there is a big change we have fetched an
1:2aa7d95:         // invalid statement from the cache, but we won't get the exception
1:2aa7d95:         // until we try to execute it.
1:c511410:         try {
1:2aa7d95:             ps.executeQuery();
1:2aa7d95:             fail("Prepared statement not valid, referring non-existing table");
1:49335b4:         } catch (SQLException sqle) {
1:2aa7d95:             assertSQLState("42X05", sqle);
1:49335b4:         }
1:49335b4:     }
1:49335b4: 
1:49335b4:     /**
1:49335b4:      *
1:79b7c08:      * Tests the PreparedStatement interface method isPoolable on closed
1:79b7c08:      * PreparedStatement
1:79b7c08:      *
1:79b7c08:      * @throws SQLException
1:79b7c08:      *
1:79b7c08:      */
1:79b7c08:     public void testIsPoolableOnClosed() throws SQLException {
1:49335b4:         try {
1:79b7c08:             ps.close();
1:79b7c08:             boolean p = ps.isPoolable();
1:79b7c08:             fail("Should throw exception on closed statement");
2:49335b4:         } catch(SQLException sqle) {
1:49335b4:             // Check which SQLException state we've got and if it is
1:49335b4:             // expected, do not print a stackTrace
1:49335b4:             // Embedded uses XJ012, client uses XCL31.
1:49335b4:             if (sqle.getSQLState().equals("XJ012") ||
1:49335b4:                 sqle.getSQLState().equals("XCL31")) {
1:49335b4:                 // All is good and is expected
4:49335b4:             } else {
1:49335b4:                 fail("Unexpected SQLException " + sqle);
1:49335b4:             }
1:49335b4:         }
1:49335b4:     }
1:49335b4:     
1:49335b4:     /**
1:49335b4:      *
1:c511410:      * Tests the PreparedStatement interface method setCharacterStream
1:49335b4:      *
1:49335b4:      * @throws SQLException
1:49335b4:      *
1:49335b4:      */
1:ff7369c:     public void testSetCharacterStream() throws Exception {
1:c511410:         String str = "Test data for the Clob object";
1:c511410:         StringReader is = new StringReader("Test data for the Clob object");
1:c511410:         
1:ff7369c:         is.reset();
1:c511410:         
1:c511410:         //initially insert the data
1:10cc70b:         psInsertClob.setInt(1, key);
1:10cc70b:         psInsertClob.setCharacterStream(2, is, str.length());
1:10cc70b:         psInsertClob.executeUpdate();
1:c511410:         
1:c511410:         //Now query to retrieve the Clob
1:10cc70b:         psFetchClob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchClob.executeQuery();
1:c511410:         rs.next();
1:10cc70b:         Clob clobRetrieved = rs.getClob(1);
1:c511410:         
1:c511410:         String str_out = clobRetrieved.getSubString(1L,(int)clobRetrieved.length());
1:c511410:         
1:c511410:         assertEquals("Error in inserting data into the Clob object",str,str_out);
1:10cc70b:         psInsertClob.close();
1:d3e6a71: 
1:d3e6a71:         //Since auto-commit is true in this test
1:d3e6a71:         //this will invalidate the clob object
1:d3e6a71:         //Hence closing the ResultSet after
1:d3e6a71:         //accessing the Clob object.
1:d3e6a71:         //follows the same pattern as testSetBinaryStream().
1:d3e6a71:         rs.close();
1:c511410:     }
1:242c9bd: 
1:956354d:     public void testSetCharacterStreamLengthless()
1:242c9bd:             throws IOException, SQLException {
1:242c9bd:         // Insert test data.
1:242c9bd:         String testString = "Test string for setCharacterStream\u1A00";
1:242c9bd:         Reader reader = new StringReader(testString);
1:10cc70b:         psInsertClob.setInt(1, key);
1:10cc70b:         psInsertClob.setCharacterStream(2, reader);
1:10cc70b:         psInsertClob.execute();
1:242c9bd:         reader.close();
1:242c9bd: 
1:242c9bd:         // Read back test data from database.
1:10cc70b:         psFetchClob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchClob.executeQuery();
1:242c9bd:         assertTrue("No results retrieved", rs.next());
1:242c9bd:         Clob clobRetrieved = rs.getClob(1);
1:242c9bd: 
1:242c9bd:         // Verify test data.
1:242c9bd:         assertEquals("Mismatch test data in/out", testString,
1:242c9bd:                      clobRetrieved.getSubString(1, testString.length()));
1:242c9bd:     }
1:242c9bd: 
1:c511410:      /**
1:c511410:       *
1:c511410:       * Tests the PreparedStatement interface method setAsciiStream
1:c511410:       *
1:c511410:       * @throws SQLException
1:c511410:       *
1:c511410:       */
1:242c9bd:     
1:ff7369c:     public void testSetAsciiStream() throws Exception {
1:c511410:         //insert default values into the table
1:242c9bd:         
1:c511410:         byte [] bytes1 = new byte[10];
1:c511410:         
1:242c9bd:         InputStream is = new java.io.ByteArrayInputStream(BYTES);
1:c511410:         
1:ff7369c:         is.reset();
1:c511410:         
1:c511410:         //initially insert the data
1:10cc70b:         psInsertClob.setInt(1, key);
1:10cc70b:         psInsertClob.setAsciiStream(2, is, BYTES.length);
1:10cc70b:         psInsertClob.executeUpdate();
1:c511410:         
1:c511410:         //Now query to retrieve the Clob
1:10cc70b:         psFetchClob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchClob.executeQuery();
1:c511410:         rs.next();
1:10cc70b:         Clob ClobRetrieved = rs.getClob(1);
1:c511410:         
1:c511410:         try {
1:c511410:             InputStream is_ret = ClobRetrieved.getAsciiStream();
1:c511410:             is_ret.read(bytes1);
1:c511410:         } catch(IOException ioe) {
1:c511410:             fail("IOException while reading the Clob from the database");
1:c511410:         }
1:242c9bd:         for(int i=0;i<BYTES.length;i++) {
1:242c9bd:             assertEquals("Error in inserting data into the Clob",BYTES[i],bytes1[i]);
1:c511410:         }
1:10cc70b:         psInsertClob.close();
1:d3e6a71: 
1:d3e6a71:         //Since auto-commit is true in this test
1:d3e6a71:         //this will invalidate the clob object
1:d3e6a71:         //Hence closing the ResultSet after
1:d3e6a71:         //accessing the Clob object.
1:d3e6a71:         //follows the same pattern as testSetBinaryStream().
1:d3e6a71:         rs.close();
1:c511410:     }
1:242c9bd: 
1:956354d:     public void testSetAsciiStreamLengthless()
1:242c9bd:             throws IOException, SQLException {
1:242c9bd:         // Insert test data.
1:242c9bd:         InputStream is = new ByteArrayInputStream(BYTES);
1:10cc70b:         psInsertClob.setInt(1, key);
1:10cc70b:         psInsertClob.setAsciiStream(2, is);
1:10cc70b:         psInsertClob.execute();
1:242c9bd:         is.close();
1:242c9bd: 
1:242c9bd:         // Read back test data from database.
1:10cc70b:         psFetchClob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchClob.executeQuery();
1:242c9bd:         assertTrue("No results retrieved", rs.next());
1:242c9bd:         Clob clobRetrieved = rs.getClob(1);
1:242c9bd: 
1:242c9bd:         // Verify read back data.
1:242c9bd:         byte[] dbBytes = new byte[10];
1:242c9bd:         InputStream isRetrieved = clobRetrieved.getAsciiStream();
1:242c9bd:         assertEquals("Unexpected number of bytes read", BYTES.length,
1:242c9bd:                 isRetrieved.read(dbBytes));
1:242c9bd:         assertEquals("Stream should be exhausted", -1, isRetrieved.read());
1:242c9bd:         for (int i=0; i < BYTES.length; i++) {
1:242c9bd:             assertEquals("Byte mismatch in/out", BYTES[i], dbBytes[i]);
1:242c9bd:         }
1:242c9bd: 
1:242c9bd:         // Cleanup
1:242c9bd:         isRetrieved.close();
1:10cc70b:         psInsertClob.close();
1:10cc70b:     }
1:10cc70b: 
1:c511410:     /**
1:c511410:      *
1:c511410:      * Tests the PreparedStatement interface method setBinaryStream
1:c511410:      *
1:c511410:      * @throws SQLException
1:c511410:      *
1:c511410:      */
1:242c9bd:     
1:ff7369c:     public void testSetBinaryStream() throws Exception {
1:c511410:         //insert default values into the table
1:242c9bd:         
1:c511410:         byte [] bytes1 = new byte[10];
1:242c9bd:         
1:242c9bd:         InputStream is = new java.io.ByteArrayInputStream(BYTES);
1:c511410:         
1:ff7369c:         is.reset();
1:c511410:         
1:c511410:         //initially insert the data
1:10cc70b:         psInsertBlob.setInt(1, key);
1:10cc70b:         psInsertBlob.setBinaryStream(2, is, BYTES.length);
1:10cc70b:         psInsertBlob.executeUpdate();
1:c511410:         
1:05d610e:         // Now query to retrieve the Blob
1:10cc70b:         psFetchBlob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchBlob.executeQuery();
1:c511410:         rs.next();
1:10cc70b:         Blob blobRetrieved = rs.getBlob(1);
1:c511410:         
1:c511410:         try {
1:c511410:             InputStream is_ret = blobRetrieved.getBinaryStream();
1:c511410:             is_ret.read(bytes1);
1:c511410:         } catch(IOException ioe) {
1:c511410:             fail("IOException while reading the Clob from the database");
1:10cc70b:         }
1:05d610e:         rs.close(); // Because of autocommit, this will invalidate blobRetrieved
1:c511410:         
1:242c9bd:         for(int i=0;i<BYTES.length;i++) {
1:242c9bd:             assertEquals("Error in inserting data into the Blob",BYTES[i],bytes1[i]);
1:10cc70b:         }
1:10cc70b:         psInsertBlob.close();
1:242c9bd:     }
1:242c9bd: 
1:956354d:     public void testSetBinaryStreamLengthless()
1:242c9bd:             throws IOException, SQLException {
1:242c9bd:         // Insert test data.
1:242c9bd:         InputStream is = new ByteArrayInputStream(BYTES);
1:10cc70b:         psInsertBlob.setInt(1, key);
1:10cc70b:         psInsertBlob.setBinaryStream(2, is);
1:10cc70b:         psInsertBlob.execute();
1:242c9bd:         is.close();
1:242c9bd: 
1:242c9bd:         // Read back test data from database.
1:10cc70b:         psFetchBlob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchBlob.executeQuery();
1:242c9bd:         assertTrue("No results retrieved", rs.next());
1:242c9bd:         Blob blobRetrieved = rs.getBlob(1);
1:c511410: 
1:242c9bd:         // Verify read back data.
1:242c9bd:         byte[] dbBytes = new byte[10];
1:242c9bd:         InputStream isRetrieved = blobRetrieved.getBinaryStream();
1:242c9bd:         assertEquals("Unexpected number of bytes read", BYTES.length,
1:242c9bd:                 isRetrieved.read(dbBytes));
1:242c9bd:         assertEquals("Stream should be exhausted", -1, isRetrieved.read());
1:242c9bd:         for (int i=0; i < BYTES.length; i++) {
1:242c9bd:             assertEquals("Byte mismatch in/out", BYTES[i], dbBytes[i]);
1:242c9bd:         }
1:242c9bd: 
1:242c9bd:         // Cleanup
1:242c9bd:         isRetrieved.close();
1:10cc70b:         psInsertBlob.close();
1:242c9bd:     }
1:c511410: 
1:10cc70b:     public void testSetBinaryStreamLengthLess1KOnBlob()
1:10cc70b:             throws IOException, SQLException {
1:10cc70b:         int length = 1*1024;
1:10cc70b:         setBinaryStreamOnBlob(key, length, -1, 0, true);
1:10cc70b:         psFetchBlob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchBlob.executeQuery();
1:10cc70b:         assertTrue("Empty resultset", rs.next());
1:10cc70b:         assertEquals(new LoopingAlphabetStream(length),
1:10cc70b:                      rs.getBinaryStream(1));
1:10cc70b:         assertFalse("Resultset should have been exhausted", rs.next());
1:10cc70b:         rs.close();
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testSetBinaryStreamLengthLess32KOnBlob()
1:10cc70b:             throws IOException, SQLException {
1:10cc70b:         int length = 32*1024;
1:10cc70b:         setBinaryStreamOnBlob(key, length, -1, 0, true);
2:10cc70b:         psFetchBlob.setInt(1, key);
2:10cc70b:         ResultSet rs = psFetchBlob.executeQuery();
1:10cc70b:         assertTrue("Empty resultset", rs.next());
1:10cc70b:         assertEquals(new LoopingAlphabetStream(length),
1:10cc70b:                      rs.getBinaryStream(1));
1:10cc70b:         assertFalse("Resultset should have been exhausted", rs.next());
1:10cc70b:         rs.close();
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testSetBinaryStreamLengthLess65KOnBlob()
1:10cc70b:             throws IOException, SQLException {
1:10cc70b:         int length = 65*1024;
1:10cc70b:         setBinaryStreamOnBlob(key, length, -1, 0, true);
1:10cc70b:         psFetchBlob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchBlob.executeQuery();
1:10cc70b:         assertTrue("Empty resultset", rs.next());
1:10cc70b:         LoopingAlphabetStream s1 = new LoopingAlphabetStream(length);
1:10cc70b:         assertEquals(new LoopingAlphabetStream(length),
1:10cc70b:                      rs.getBinaryStream(1));
1:10cc70b:         assertFalse("Resultset should have been exhausted", rs.next());
1:10cc70b:         rs.close();
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testSetBinaryStreamLengthLessOnBlobTooLong() {
1:10cc70b:         int length = 1*1024*1024+512;
1:10cc70b:         try {
1:10cc70b:             setBinaryStreamOnBlob(key, length, -1, 0, true);
1:10cc70b:         } catch (SQLException sqle) {
1:fefd864:             if (usingEmbedded() || 
1:fefd864:                 usingDerbyNetClient() ) {
1:10cc70b:                 assertSQLState("XSDA4", sqle);
1:10cc70b:             } else {
1:10cc70b:                 assertSQLState("22001", sqle);
1:10cc70b:             }
1:10cc70b:         }
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testExceptionPathOnePage_bs()
1:10cc70b:             throws SQLException {
1:10cc70b:         int length = 11;
1:10cc70b:         try {
1:10cc70b:             setBinaryStreamOnBlob(key, length -1, length, 0, false);
1:10cc70b:             fail("Inserted a BLOB with fewer bytes than specified");
1:10cc70b:         } catch (SQLException sqle) {
5:10cc70b:             if (usingEmbedded()) {
1:9f5214d:                 assertSQLState("XSDA4", sqle);
1:10cc70b:             } else {
1:10cc70b:                 assertSQLState("XN017", sqle);
1:10cc70b:             }
1:10cc70b:         }
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testExceptionPathMultiplePages_bs()
1:10cc70b:             throws SQLException {
1:10cc70b:         int length = 1*1024*1024;
1:10cc70b:         try {
1:10cc70b:             setBinaryStreamOnBlob(key, length -1, length, 0, false);
1:10cc70b:             fail("Inserted a BLOB with fewer bytes than specified");
1:10cc70b:         } catch (SQLException sqle) {
1:10cc70b:             if (usingEmbedded()) {
1:10cc70b:                 assertSQLState("XSDA4", sqle);
1:10cc70b:             } else {
1:10cc70b:                 assertSQLState("XN017", sqle);
1:10cc70b:             }
1:10cc70b:         }
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testBlobExceptionDoesNotRollbackOtherStatements()
1:10cc70b:             throws IOException, SQLException {
1:10cc70b:         getConnection().setAutoCommit(false);
1:10cc70b:         int[] keys = {key, requestKey(), requestKey()};
1:10cc70b:         for (int i=0; i < keys.length; i++) {
1:10cc70b:             psInsertBlob.setInt(1, keys[i]);
1:10cc70b:             psInsertBlob.setNull(2, Types.BLOB);
1:10cc70b:             assertEquals(1, psInsertBlob.executeUpdate());
1:10cc70b:         }
1:10cc70b:         // Now insert a BLOB that fails because the stream is too short.
1:10cc70b:         int failedKey = requestKey();
1:10cc70b:         int length = 1*1024*1024;
1:10cc70b:         try {
1:10cc70b:             setBinaryStreamOnBlob(failedKey, length -1, length, 0, false);
1:10cc70b:             fail("Inserted a BLOB with less data than specified");
1:10cc70b:         } catch (SQLException sqle) {
1:10cc70b:             if (usingEmbedded()) {
1:10cc70b:                 assertSQLState("XSDA4", sqle);
1:10cc70b:             } else {
1:10cc70b:                 assertSQLState("XN017", sqle);
1:10cc70b:             }
1:10cc70b:         }
1:10cc70b:         // Now make sure the previous statements are there, and that the last
1:10cc70b:         // BLOB is not.
1:10cc70b:         ResultSet rs;
1:10cc70b:         for (int i=0; i < keys.length; i++) {
1:10cc70b:             psFetchBlob.setInt(1, keys[i]);
1:10cc70b:             rs = psFetchBlob.executeQuery();
2:10cc70b:             assertTrue(rs.next());
1:10cc70b:             assertFalse(rs.next());
1:10cc70b:             rs.close();
1:10cc70b:         }
1:10cc70b:         psFetchBlob.setInt(1, failedKey);
2:10cc70b:         rs = psFetchBlob.executeQuery();
1:10cc70b:         assertFalse(rs.next());
1:10cc70b:         rs.close();
1:10cc70b:         rollback();
1:10cc70b:         // Make sure all data is gone after the rollback.
1:10cc70b:         for (int i=0; i < keys.length; i++) {
1:10cc70b:             psFetchBlob.setInt(1, keys[i]);
1:10cc70b:             rs = psFetchBlob.executeQuery();
1:10cc70b:             assertFalse(rs.next());
1:10cc70b:             rs.close();
1:10cc70b:         }
1:10cc70b:         // Make sure the failed insert has not "reappeared" somehow...
1:10cc70b:         psFetchBlob.setInt(1, failedKey);
1:10cc70b:         rs = psFetchBlob.executeQuery();
1:10cc70b:         assertFalse(rs.next());
1:10cc70b: 
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testSetAsciiStreamLengthLess1KOnClob()
1:10cc70b:             throws IOException, SQLException {
1:10cc70b:         int length = 1*1024;
1:10cc70b:         setAsciiStream(psInsertClob, key, length, -1, 0, true);
1:10cc70b:         psFetchClob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchClob.executeQuery();
1:10cc70b:         assertTrue("Empty resultset", rs.next());
1:10cc70b:         assertEquals(new LoopingAlphabetStream(length),
1:10cc70b:                      rs.getAsciiStream(1));
1:10cc70b:         assertFalse("Resultset should have been exhausted", rs.next());
1:10cc70b:         rs.close();
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testSetAsciiStreamLengthLess32KOnClob()
1:10cc70b:             throws IOException, SQLException {
1:10cc70b:         int length = 32*1024;
1:10cc70b:         setAsciiStream(psInsertClob, key, length, -1, 0, true);
2:10cc70b:         psFetchClob.setInt(1, key);
2:10cc70b:         ResultSet rs = psFetchClob.executeQuery();
1:10cc70b:         assertTrue("Empty resultset", rs.next());
1:10cc70b:         assertEquals(new LoopingAlphabetStream(length),
1:10cc70b:                      rs.getAsciiStream(1));
1:10cc70b:         assertFalse("Resultset should have been exhausted", rs.next());
1:10cc70b:         rs.close();
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testSetAsciiStreamLengthLess65KOnClob()
1:10cc70b:             throws IOException, SQLException {
1:10cc70b:         int length = 65*1024;
1:10cc70b:         setAsciiStream(psInsertClob, key, length, -1, 0, true);
1:10cc70b:         psFetchClob.setInt(1, key);
1:10cc70b:         ResultSet rs = psFetchClob.executeQuery();
1:10cc70b:         assertTrue("Empty resultset", rs.next());
1:10cc70b:         assertEquals(new LoopingAlphabetStream(length),
1:10cc70b:                      rs.getAsciiStream(1));
1:10cc70b:         assertFalse("Resultset should have been exhausted", rs.next());
1:10cc70b:         rs.close();
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testSetAsciiStreamLengthLessOnClobTooLong() {
1:10cc70b:         int length = 1*1024*1024+512;
1:10cc70b:         try {
1:10cc70b:             setAsciiStream(psInsertClob, key, length, -1, 0, true);
1:10cc70b:         } catch (SQLException sqle) {
1:fefd864:             if (usingEmbedded() || 
1:fefd864:                 usingDerbyNetClient() ){
1:10cc70b:                 assertSQLState("XSDA4", sqle);
1:10cc70b:                 
1:10cc70b:             } else {
1:10cc70b:                 assertSQLState("22001", sqle);
1:c511410:                 
1:10cc70b:             }
1:10cc70b:         }
1:10cc70b:     }
1:c511410: 
1:10cc70b:     public void testSetAsciiStreamLengthLessOnClobTooLongTruncate()
1:10cc70b:             throws SQLException {
1:10cc70b:         int trailingBlanks = 512;
1:10cc70b:         int length = 1*1024*1024 + trailingBlanks;
1:10cc70b:         setAsciiStream(psInsertClob, key, length, -1, trailingBlanks, true);
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     public void testSetAsciiStreamLengthlessOnLongVarCharTooLong() {
1:10cc70b:         int length = 32700+512;
1:10cc70b:         try {
1:10cc70b:             setAsciiStream(psInsertLongVarchar, key, length, -1, 0, true);
1:10cc70b:             fail("Inserted a LONG VARCHAR that is too long");
1:10cc70b:         } catch (SQLException sqle) {
1:fefd864:             if (usingEmbedded()){
1:10cc70b:                 assertInternalDerbyIOExceptionState("XCL30", "22001", sqle);
1:49335b4:                 
1:fefd864:             } else if ( usingDerbyNetClient() ) {
1:10cc70b:                 assertSQLState("XCL30", sqle);
1:10cc70b:                 
1:10cc70b:             } else {
1:10cc70b:                 assertSQLState("22001", sqle);
1:49335b4:                 
1:10cc70b:             }
1:10cc70b:         }
1:10cc70b:     }
1:49335b4: 
1:10cc70b:     public void testSetAsciiStreamLengthlessOnLongVarCharDontTruncate() {
1:10cc70b:         int trailingBlanks = 2000;
1:10cc70b:         int length = 32000 + trailingBlanks;
1:10cc70b:         try {
1:10cc70b:             setAsciiStream(psInsertLongVarchar, key, length, -1,
1:10cc70b:                     trailingBlanks, true);
1:10cc70b:             fail("Truncation is not allowed for LONG VARCHAR");
1:10cc70b:         } catch (SQLException sqle) {
1:fefd864:             if (usingEmbedded()){
1:10cc70b:                 assertInternalDerbyIOExceptionState("XCL30", "22001", sqle);
1:10cc70b:                 
1:fefd864:             } else if( usingDerbyNetClient() ) {
1:fefd864:                 assertSQLState("XCL30", sqle);
1:10cc70b:                 
1:10cc70b:             } else {
1:10cc70b:                 assertSQLState("22001", sqle);
1:49335b4:                 
1:10cc70b:             }
1:10cc70b:         }
1:10cc70b:     }
1:49335b4: 
1:49335b4:     /**
1:20b2fd9:      * Test the large update methods added by JDBC 4.2.
1:20b2fd9:      */
1:20b2fd9:     public void testLargeUpdate_jdbc4_2() throws Exception
1:20b2fd9:     {
1:20b2fd9:         Connection  conn = getConnection();
1:20b2fd9: 
1:20b2fd9:         largeUpdate_jdbc4_2( conn );
1:16e1003:     }
1:20b2fd9: 
1:20b2fd9:     public  static  void    largeUpdate_jdbc4_2( Connection conn )
1:20b2fd9:         throws Exception
1:20b2fd9:     {
1:2e87a4c:         //
1:2e87a4c:         // This test makes use of a debug entry point which is a NOP
1:2e87a4c:         // in an insane production build.
1:2e87a4c:         //
1:2e87a4c:         if (!SanityManager.DEBUG)    { return; }
1:2e87a4c: 
1:20b2fd9:         println( "Running large update test for JDBC 4.2" );
1:20b2fd9:         
1:20b2fd9:         conn.prepareStatement
1:20b2fd9:             (
1:20b2fd9:              "create procedure setRowCountBase( newBase bigint )\n" +
1:20b2fd9:              "language java parameter style java no sql\n" +
1:20b2fd9:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.StatementTest.setRowCountBase'\n"
1:20b2fd9:              ).execute();
1:20b2fd9:         conn.prepareStatement
1:20b2fd9:             (
1:20b2fd9:              "create table bigintTable( col1 int generated always as identity, col2 bigint )"
1:20b2fd9:              ).execute();
1:20b2fd9: 
1:20b2fd9:         Statement   stmt = conn.createStatement();
1:20b2fd9:         PreparedStatementWrapper  psw = new PreparedStatementWrapper
1:20b2fd9:             ( conn.prepareStatement( "insert into bigintTable( col2 ) values ( 1 ), ( 2 ), ( 3 ), ( 4 ), ( 5 )" ) );
1:20b2fd9: 
1:20b2fd9:         largeUpdateTest( stmt, psw, ((long) Integer.MAX_VALUE) + 1L );
1:20b2fd9:         
1:20b2fd9:         StatementTest.setRowCountBase( stmt, false, 0L );
1:c511410:     }
1:20b2fd9:     private static  void    largeUpdateTest
1:20b2fd9:         ( Statement stmt, PreparedStatementWrapper psw, long rowCountBase )
1:20b2fd9:         throws Exception
1:20b2fd9:     {
1:20b2fd9:         StatementTest.setRowCountBase( stmt, false, rowCountBase );
1:20b2fd9: 
1:20b2fd9:         assertEquals( rowCountBase + 5L, psw.executeLargeUpdate() );
1:c511410:     }
1:20b2fd9: 
1:10cc70b:     /************************************************************************
1:10cc70b:      *                 A U X I L I A R Y  M E T H O D S                     *
1:10cc70b:      ************************************************************************/
1:10cc70b: 
1:10cc70b:     /**
1:10cc70b:      * Insert data into a Blob column with setBinaryStream.
1:10cc70b:      *
1:10cc70b:      * @param id unique id for inserted row
1:10cc70b:      * @param actualLength the actual length of the stream
1:10cc70b:      * @param specifiedLength the specified length of the stream
1:10cc70b:      * @param trailingBlanks number of characters at the end that is blank
1:10cc70b:      * @param lengthLess whether to use the length less overloads or not
1:10cc70b:      */
1:10cc70b:     private void setBinaryStreamOnBlob(int id,
1:10cc70b:                                        int actualLength,
1:10cc70b:                                        int specifiedLength,
1:10cc70b:                                        int trailingBlanks,
1:10cc70b:                                        boolean lengthLess)
1:10cc70b:             throws SQLException {
1:10cc70b:         psInsertBlob.setInt(1, id);
1:10cc70b:         if (lengthLess) {
1:10cc70b:             psInsertBlob.setBinaryStream(2, new LoopingAlphabetStream(
1:10cc70b:                                                 actualLength,
1:10cc70b:                                                 trailingBlanks));
1:10cc70b:         } else {
1:10cc70b:             psInsertBlob.setBinaryStream(2,
1:10cc70b:                                new LoopingAlphabetStream(
1:10cc70b:                                         actualLength,
1:10cc70b:                                         trailingBlanks),
1:10cc70b:                                specifiedLength);
1:10cc70b:         }
1:10cc70b:         assertEquals("Insert with setBinaryStream failed",
1:10cc70b:                 1, psInsertBlob.executeUpdate());
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     /**
1:10cc70b:      * Insert data into a column with setAsciiStream.
1:10cc70b:      * The prepared statement passed must have two positional parameters;
1:10cc70b:      * one int and one more. Depending on the last parameter, the execute
1:10cc70b:      * might succeed or it might fail. This is intended behavior, and should
1:10cc70b:      * be handled by the caller. For instance, calling this method on an
1:10cc70b:      * INT-column would fail, calling it on a CLOB-column would succeed.
1:10cc70b:      *
1:10cc70b:      * @param id unique id for inserted row
1:10cc70b:      * @param actualLength the actual length of the stream
1:10cc70b:      * @param specifiedLength the specified length of the stream
1:10cc70b:      * @param trailingBlanks number of characters at the end that is blank
1:10cc70b:      * @param lengthLess whether to use the length less overloads or not
1:10cc70b:      */
1:10cc70b:     private void setAsciiStream(PreparedStatement ps,
1:10cc70b:                                 int id,
1:10cc70b:                                 int actualLength,
1:10cc70b:                                 int specifiedLength,
1:10cc70b:                                 int trailingBlanks,
1:10cc70b:                                 boolean lengthLess)
1:10cc70b:             throws SQLException {
1:10cc70b:         ps.setInt(1, id);
1:10cc70b:         if (lengthLess) {
1:10cc70b:             ps.setAsciiStream(2, 
1:10cc70b:                               new LoopingAlphabetStream(
1:10cc70b:                                                 actualLength,
1:10cc70b:                                                 trailingBlanks));
1:10cc70b:         } else {
1:10cc70b:             ps.setAsciiStream(2,
1:10cc70b:                               new LoopingAlphabetStream(
1:10cc70b:                                                 actualLength,
1:10cc70b:                                                 trailingBlanks),
1:10cc70b:                               specifiedLength);
1:10cc70b:         }
1:10cc70b:         assertEquals("Insert with setAsciiStream failed",
1:10cc70b:                 1, ps.executeUpdate());
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     /**
1:10cc70b:      * Get next key to id inserted data with.
1:10cc70b:      */
1:10cc70b:     private static int requestKey() {
1:10cc70b:         return globalKey++;
1:10cc70b:     }
1:10cc70b: 
1:10cc70b:     /**
1:10cc70b:      * This methods is not to be used, but sometimes you have to!
1:10cc70b:      *
1:10cc70b:      * @param preSQLState the expected outer SQL state
1:10cc70b:      * @param expectedInternal the expected internal SQL state
1:10cc70b:      * @param sqle the outer SQLException
1:10cc70b:      */
1:10cc70b:     private void assertInternalDerbyIOExceptionState(
1:10cc70b:                                         String preSQLState,
1:10cc70b:                                         String expectedInternal,
1:10cc70b:                                         SQLException sqle) {
1:10cc70b:         assertSQLState("Outer/public SQL state incorrect",
1:10cc70b:                        preSQLState, sqle);
1:10cc70b:         // We need to dig a little with the current way exceptions are
1:10cc70b:         // being reported. We can use getCause because we always run with
1:28dc366:         // Java SE 6 or later.
1:10cc70b:         Throwable cause = getLastSQLException(sqle).getCause();
1:28dc366:         assertEquals("org.apache.derby.iapi.error.StandardException",
1:28dc366:                      cause.getClass().getName());
1:1095183:         cause = cause.getCause();
1:10cc70b:         assertTrue("Exception not a DerbyIOException",
1:10cc70b:                    cause instanceof DerbyIOException);
1:10cc70b:         DerbyIOException dioe = (DerbyIOException)cause;
1:10cc70b:         assertEquals("Incorrect internal SQL state", expectedInternal,
1:10cc70b:                      dioe.getSQLState());
1:10cc70b:     }
1:20b2fd9: 
1:20b2fd9:     ////////////////////////////////////////////////////////////////////////
1:20b2fd9:     //
1:20b2fd9:     // NESTED JDBC 4.2 WRAPPER AROUND A PreparedStatement
1:20b2fd9:     //
1:20b2fd9:     ////////////////////////////////////////////////////////////////////////
1:20b2fd9: 
1:10cc70b:     /**
1:20b2fd9:      * <p>
1:20b2fd9:      * This wrapper is used to expose JDBC 4.2 methods which can run on
1:20b2fd9:      * VM rev levels lower than Java 8.
1:20b2fd9:      * </p>
1:10cc70b:      */
1:20b2fd9:     public  static  class   PreparedStatementWrapper    extends StatementTest.StatementWrapper
1:20b2fd9:     {
1:20b2fd9:         private PreparedStatement   _wrappedPreparedStatement;
1:20b2fd9: 
1:20b2fd9:         public  PreparedStatementWrapper( PreparedStatement wrappedPreparedStatement )
1:20b2fd9:         {
1:20b2fd9:             super( wrappedPreparedStatement );
1:10cc70b:         }
1:20b2fd9: 
1:20b2fd9:         PreparedStatement   getWrappedPreparedStatement() { return (PreparedStatement) getWrappedStatement(); }
1:20b2fd9: 
1:20b2fd9:         public  long executeLargeUpdate() throws SQLException
1:20b2fd9:         {
1:20b2fd9:             return ((Long) invoke
1:20b2fd9:                 (
1:20b2fd9:                  "executeLargeUpdate",
1:20b2fd9:                  new Class[] {},
1:20b2fd9:                  new Object[] {}
1:20b2fd9:                  )).longValue();
1:c511410:         }
1:20b2fd9:     }
1:20b2fd9:     
1:20b2fd9: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.io.ByteArrayInputStream;
1: import java.io.IOException;
1: import java.io.InputStream;
1: import java.io.OutputStream;
1: import java.io.Reader;
1: import java.io.StringReader;
1: import java.sql.Blob;
1: import java.sql.CallableStatement;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.NClob;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.RowId;
1: import java.sql.SQLException;
1: import java.sql.SQLFeatureNotSupportedException;
1: import java.sql.SQLXML;
1: import java.sql.Statement;
1: import java.sql.Types;
1: import junit.framework.Test;
1: import org.apache.derby.iapi.services.io.DerbyIOException;
1: import org.apache.derby.shared.common.sanity.SanityManager;
1: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("PreparedStatementTest suite");
1: 
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite =
1:             new BaseTestSuite("JDBC statement caching suite");
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:28dc366
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // Java SE 6 or later.
1:         assertEquals("org.apache.derby.iapi.error.StandardException",
1:                      cause.getClass().getName());
commit:2ff02ef
/////////////////////////////////////////////////////////////////////////
1:     public void testIsWrapperForSelf() throws SQLException {
1:         assertTrue(ps.isWrapperFor(ps.getClass()));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testUnwrapAsSelf() throws SQLException {
1:         PreparedStatement ps2 = ps.unwrap(ps.getClass());
1:         assertSame("Unwrap returned wrong object.", ps, ps2);
1:     }
1: 
commit:d3e6a71
/////////////////////////////////////////////////////////////////////////
1:         // Life span of Clob objects are limited by the transaction.  Need
1:         // autocommit off so Clob objects survive execution of next statement.
1:         getConnection().setAutoCommit(false);
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @throws IOException If an IOException during the close operation on the
1:      *                     reader.
1:      * @throws SQLException If an SQLException occurs.
1:         // Life span of Clob objects are the transaction.  Need autocommit off
1:         // to have Clob objects survive execution of next statement.
1:         getConnection().setAutoCommit(false);
1: 
1:         //Create the Clob and insert data into it.
1:         Clob insertClob = getConnection().createClob();
1:         OutputStream os = insertClob.setAsciiStream(1);
1:         os.write(BYTES);
1: 
1:         //Insert the Clob created above into the
1:         //database.
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
/////////////////////////////////////////////////////////////////////////
1: 
1:         //Since auto-commit is true in this test
1:         //this will invalidate the clob object
1:         //Hence closing the ResultSet after
1:         //accessing the Clob object.
1:         //follows the same pattern as testSetBinaryStream().
1:         rs.close();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         //Since auto-commit is true in this test
1:         //this will invalidate the clob object
1:         //Hence closing the ResultSet after
1:         //accessing the Clob object.
1:         //follows the same pattern as testSetBinaryStream().
1:         rs.close();
commit:9b52936
/////////////////////////////////////////////////////////////////////////
1:         s = null;
1:         ps = null;
1: 
1:         psFetchBlob = null;
1:         psFetchClob = null;
1:         psInsertBlob = null;
1:         psInsertClob = null;
1:         psInsertLongVarchar = null;
1: 
commit:79b7c08
/////////////////////////////////////////////////////////////////////////
1:         s.close();
1:         ps.close();
1: 
/////////////////////////////////////////////////////////////////////////
1:         // Set the poolable statement hint to false
1:         ps.setPoolable(false);
1:         assertFalse("Expected a non-poolable statement", ps.isPoolable());
1:         // Set the poolable statement hint to true
1:         ps.setPoolable(true);
1:         assertTrue("Expected a non-poolable statement", ps.isPoolable());
1:     }
1: 
1:     /**
1:      *
1:      * Tests the PreparedStatement interface method setPoolable on a closed
1:      * PreparedStatement
1:      *
1:      * @throws SQLException
1:      */
1:     public void testSetPoolableOnClosed() throws SQLException {
1:             ps.close();
1:             fail("Expected an exception on closed statement");
1:          } catch(SQLException sqle) {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // By default a prepared statement is poolable
1:         assertTrue("Expected a poolable statement", ps.isPoolable());
1:     }
1: 
1:     /**
1:      *
1:      * Tests the PreparedStatement interface method isPoolable on closed
1:      * PreparedStatement
1:      *
1:      * @throws SQLException
1:      *
1:      */
1:     public void testIsPoolableOnClosed() throws SQLException {
1:             ps.close();
1:             boolean p = ps.isPoolable();
1:             fail("Should throw exception on closed statement");
/////////////////////////////////////////////////////////////////////////
commit:05d610e
/////////////////////////////////////////////////////////////////////////
1:         // Life span of Blob objects are limited by the transaction.  Need
1:         // autocommit off so Blob objects survive execution of next statement.
1:         getConnection().setAutoCommit(false);
1:         //insert default values into the table
/////////////////////////////////////////////////////////////////////////
1:         // Life span of Blob objects are the transaction.  Need autocommit off
1:         // to have Blob objects survive execution of next statement.
1:         getConnection().setAutoCommit(false);
1:         // Create Blob to be inserted
1:         Blob insertBlob = getConnection().createBlob();
1:         OutputStream os = insertBlob.setBinaryStream(1);
1:         os.write(BYTES);
1:         os.close();
1:         psInsertBlob.close();
1:         ResultSet rs = psFetchBlob.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:         // Now query to retrieve the Blob
/////////////////////////////////////////////////////////////////////////
1:         rs.close(); // Because of autocommit, this will invalidate blobRetrieved
commit:1095183
/////////////////////////////////////////////////////////////////////////
1:         cause = cause.getCause();
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite("PreparedStatementTest suite");
1:         suite.addTest(baseSuite("PreparedStatementTest:embedded"));
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:             baseSuite("PreparedStatementTest:client")));
1:         return suite;
1:     }
1: 
1:     private static Test baseSuite(String name) {
0:         TestSuite suite = new TestSuite(name);
commit:9f5214d
/////////////////////////////////////////////////////////////////////////
1:                 assertSQLState("XSDA4", sqle);
commit:10cc70b
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.junit.BaseJDBCTestSetup;
0: import org.apache.derbyTesting.functionTests.util.streams.LoopingAlphabetStream;
0: import org.apache.derby.iapi.services.io.DerbyIOException;
0: import org.apache.derby.impl.jdbc.EmbedSQLException;
1: 
1:  *
1:  * A number of methods and variables are in place to aid the writing of tests:
1:  * <ul><li>setBinaryStreamOnBlob
1:  *     <li>setAsciiStream
1:  *     <li>key - an id. One is generated each time setUp is run.
1:  *     <li>reqeustKey() - generate a new unique id.
1:  *     <li>psInsertX - prepared statements for insert.
1:  *     <li>psFetchX - prepared statements for fetching values.
1:  * </ul>
1:  *
1:  * For table creation, see the <code>suite</code>-method.
1:     private static final String BLOBTBL = "BlobTestTable";
1:     private static final String CLOBTBL = "ClobTestTable";
1:     private static final String LONGVARCHAR = "LongVarcharTestTable";
1: 
1:     /** Key used to id data inserted into the database. */
1:     private static int globalKey = 1;
1: 
1:     // Default connection and prepared statements that are used by the tests.
1:     /** 
1:      * Default key to use for insertions.
1:      * Is unique for each fixture. More keys can be fetched by calling
1:      * <link>requestKey</link>.
1:     private int key;
1:     /** Default connection object. */
1:     /** PreparedStatement object with no positional arguments. */
1:     /** PreparedStatement to fetch BLOB with specified id. */
1:     private PreparedStatement psFetchBlob = null;
1:     /** PreparedStatement to insert a BLOB with specified id. */
1:     private PreparedStatement psInsertBlob = null;
1:     /** PreparedStatement to fetch CLOB with specified id. */
1:     private PreparedStatement psFetchClob = null;
1:     /** PreparedStatement to insert a CLOB with specified id. */
1:     private PreparedStatement psInsertClob = null;
1:     /** PreparedStatement to insert a LONG VARCHAR with specified id. */
1:     private PreparedStatement psInsertLongVarchar = null;
1: 
/////////////////////////////////////////////////////////////////////////
1:         key = requestKey();
1:         //create the statement object
/////////////////////////////////////////////////////////////////////////
1:         // Prepare misc statements.
1:         psFetchBlob = prepareStatement("SELECT dBlob FROM " +
1:                 BLOBTBL + " WHERE sno = ?");
1:         psInsertBlob = prepareStatement("INSERT INTO " + BLOBTBL +
1:                 " VALUES (?, ?)");
1:         psFetchClob = prepareStatement("SELECT dClob FROM " +
1:                 CLOBTBL + " WHERE sno = ?");
1:         psInsertClob = prepareStatement("INSERT INTO " + CLOBTBL +
1:                 " VALUES (?, ?)");
1:         psInsertLongVarchar = prepareStatement("INSERT INTO " + LONGVARCHAR +
1:                 " VALUES (?, ?)");
/////////////////////////////////////////////////////////////////////////
1:         psFetchBlob.close();
1:         psFetchClob.close();
1:         psInsertBlob.close();
1:         psInsertClob.close();
1:         psInsertLongVarchar.close();
/////////////////////////////////////////////////////////////////////////
0:         return new BaseJDBCTestSetup(suite) {
1:                 public void setUp()
0:                         throws java.lang.Exception {
1:                         try {
0:                             create();
1:                         } catch (SQLException sqle) {
0:                             if (sqle.getSQLState().equals("X0Y32")) {
0:                                 drop();
0:                                 create();
1:                             } else {
0:                                 throw sqle;
1:                             }
1:                         }
1:                 }
1: 
1:                 public void tearDown()
0:                         throws java.lang.Exception {
0:                     drop();
1:                     super.tearDown();
1:                 }
1: 
0:                 private void create()
1:                         throws SQLException {
0:                     Statement stmt = getConnection().createStatement();
1:                     stmt.execute("create table " + BLOBTBL +
1:                             " (sno int, dBlob BLOB(1M))");
1:                     stmt.execute("create table " + CLOBTBL +
1:                             " (sno int, dClob CLOB(1M))");
1:                     stmt.execute("create table " + LONGVARCHAR  +
1:                             " (sno int, dLongVarchar LONG VARCHAR)");
1:                     stmt.close();
1:                 }
1: 
0:                 private void drop()
1:                         throws SQLException {
0:                     Statement stmt = getConnection().createStatement();
0:                     stmt.execute("drop table " + BLOBTBL);
0:                     stmt.execute("drop table " + CLOBTBL);
0:                     stmt.execute("drop table " + LONGVARCHAR);
1:                     stmt.close();
1:                 }
1:             };
/////////////////////////////////////////////////////////////////////////
1:         psInsertClob.setInt(1, key);
1:         psInsertClob.setClob(2, is, str.length());
1:         psInsertClob.executeUpdate();
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
1:         Clob clobToBeInserted = rs.getClob(1);
1:         int secondKey = requestKey();
1:         psInsertClob.setInt(1, secondKey);
1:         psInsertClob.setClob(2, clobToBeInserted);
1:         psInsertClob.execute();
1:         psInsertClob.close();
1:         psFetchClob.setInt(1, secondKey);
1:         rs = psFetchClob.executeQuery();
1:         Clob clobRetrieved = rs.getClob(1);
/////////////////////////////////////////////////////////////////////////
1:         psInsertClob.setInt(1, key);
1:         psInsertClob.setCharacterStream(2, reader);
1:         psInsertClob.execute();
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
1:         int secondKey = requestKey();
0:         psInsertClob.setInt(1, secondKey);
1:         psInsertClob.setClob(2, insertClob);
1:         psInsertClob.execute();
0:         psFetchClob.setInt(1, secondKey);
0:         rs = psFetchClob.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:         psInsertBlob.setInt(1, key);
1:         psInsertBlob.setBlob(2, is, BYTES.length);
1:         psInsertBlob.executeUpdate();
1:         psFetchBlob.setInt(1, key);
1:         ResultSet rs = psFetchBlob.executeQuery();
1:         Blob blobToBeInserted = rs.getBlob(1);
1:         int secondKey = requestKey();
1:         psInsertBlob.setInt(1, secondKey);
1:         psInsertBlob.setBlob(2, blobToBeInserted);
1:         psInsertBlob.execute();
1:         psInsertBlob.close();
1:         psFetchBlob.setInt(1, secondKey);
1:         rs = psFetchBlob.executeQuery();
1:         Blob blobRetrieved = rs.getBlob(1);
/////////////////////////////////////////////////////////////////////////
1:         psInsertBlob.setInt(1, key);
1:         psInsertBlob.setBinaryStream(2, is);
1:         psInsertBlob.execute();
1:         psFetchBlob.setInt(1, key);
1:         ResultSet rs = psFetchBlob.executeQuery();
0:         int secondKey = requestKey();
1:         psInsertBlob.setInt(1, secondKey);
1:         psInsertBlob.setBlob(2, insertBlob);
1:         psInsertBlob.execute();
1:         psFetchBlob.setInt(1, secondKey);
1:         rs = psFetchBlob.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:         psInsertClob.setInt(1, key);
1:         psInsertClob.setCharacterStream(2, is, str.length());
1:         psInsertClob.executeUpdate();
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
1:         Clob clobRetrieved = rs.getClob(1);
1:         psInsertClob.close();
/////////////////////////////////////////////////////////////////////////
1:         psInsertClob.setInt(1, key);
0:         psInsertClob.setCharacterStream(2, reader);
1:         psInsertClob.execute();
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:         psInsertClob.setInt(1, key);
1:         psInsertClob.setAsciiStream(2, is, BYTES.length);
1:         psInsertClob.executeUpdate();
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
1:         Clob ClobRetrieved = rs.getClob(1);
/////////////////////////////////////////////////////////////////////////
1:         psInsertClob.close();
1:         psInsertClob.setInt(1, key);
1:         psInsertClob.setAsciiStream(2, is);
0:         psInsertClob.execute();
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:         psInsertClob.close();
/////////////////////////////////////////////////////////////////////////
1:         psInsertBlob.setInt(1, key);
1:         psInsertBlob.setBinaryStream(2, is, BYTES.length);
1:         psInsertBlob.executeUpdate();
1:         psFetchBlob.setInt(1, key);
1:         ResultSet rs = psFetchBlob.executeQuery();
1:         Blob blobRetrieved = rs.getBlob(1);
/////////////////////////////////////////////////////////////////////////
1:         psInsertBlob.close();
0:         psInsertBlob.setInt(1, key);
0:         psInsertBlob.setBinaryStream(2, is);
0:         psInsertBlob.execute();
1:         psFetchBlob.setInt(1, key);
1:         ResultSet rs = psFetchBlob.executeQuery();
/////////////////////////////////////////////////////////////////////////
1:         psInsertBlob.close();
1:     }
1: 
1:     public void testSetBinaryStreamLengthLess1KOnBlob()
1:             throws IOException, SQLException {
1:         int length = 1*1024;
1:         setBinaryStreamOnBlob(key, length, -1, 0, true);
1:         psFetchBlob.setInt(1, key);
1:         ResultSet rs = psFetchBlob.executeQuery();
1:         assertTrue("Empty resultset", rs.next());
1:         assertEquals(new LoopingAlphabetStream(length),
1:                      rs.getBinaryStream(1));
1:         assertFalse("Resultset should have been exhausted", rs.next());
1:         rs.close();
1:     }
1: 
1:     public void testSetBinaryStreamLengthLess32KOnBlob()
1:             throws IOException, SQLException {
1:         int length = 32*1024;
1:         setBinaryStreamOnBlob(key, length, -1, 0, true);
1:         psFetchBlob.setInt(1, key);
1:         ResultSet rs = psFetchBlob.executeQuery();
1:         assertTrue("Empty resultset", rs.next());
1:         assertEquals(new LoopingAlphabetStream(length),
1:                      rs.getBinaryStream(1));
1:         assertFalse("Resultset should have been exhausted", rs.next());
1:         rs.close();
1:     }
1: 
1:     public void testSetBinaryStreamLengthLess65KOnBlob()
1:             throws IOException, SQLException {
1:         int length = 65*1024;
1:         setBinaryStreamOnBlob(key, length, -1, 0, true);
1:         psFetchBlob.setInt(1, key);
1:         ResultSet rs = psFetchBlob.executeQuery();
1:         assertTrue("Empty resultset", rs.next());
1:         LoopingAlphabetStream s1 = new LoopingAlphabetStream(length);
1:         assertEquals(new LoopingAlphabetStream(length),
1:                      rs.getBinaryStream(1));
1:         assertFalse("Resultset should have been exhausted", rs.next());
1:         rs.close();
1:     }
1: 
1:     public void testSetBinaryStreamLengthLessOnBlobTooLong() {
1:         int length = 1*1024*1024+512;
1:         try {
1:             setBinaryStreamOnBlob(key, length, -1, 0, true);
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded()) {
1:                 assertSQLState("XCL30", sqle);
1:             } else {
1:                 assertSQLState("22001", sqle);
1:             }
1:         }
1:     }
1: 
1:     public void testExceptionPathOnePage_bs()
1:             throws SQLException {
1:         int length = 11;
1:         try {
1:             setBinaryStreamOnBlob(key, length -1, length, 0, false);
1:             fail("Inserted a BLOB with fewer bytes than specified");
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded()) {
1:                 assertSQLState("XSDA4", sqle);
1:             } else {
1:                 assertSQLState("XN017", sqle);
1:             }
1:         }
1:     }
1: 
1:     public void testExceptionPathMultiplePages_bs()
1:             throws SQLException {
1:         int length = 1*1024*1024;
1:         try {
1:             setBinaryStreamOnBlob(key, length -1, length, 0, false);
1:             fail("Inserted a BLOB with fewer bytes than specified");
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded()) {
1:                 assertSQLState("XSDA4", sqle);
1:             } else {
1:                 assertSQLState("XN017", sqle);
1:             }
1:         }
1:     }
1: 
1:     public void testBlobExceptionDoesNotRollbackOtherStatements()
1:             throws IOException, SQLException {
1:         getConnection().setAutoCommit(false);
1:         int[] keys = {key, requestKey(), requestKey()};
1:         for (int i=0; i < keys.length; i++) {
1:             psInsertBlob.setInt(1, keys[i]);
1:             psInsertBlob.setNull(2, Types.BLOB);
1:             assertEquals(1, psInsertBlob.executeUpdate());
1:         }
1:         // Now insert a BLOB that fails because the stream is too short.
1:         int failedKey = requestKey();
1:         int length = 1*1024*1024;
1:         try {
1:             setBinaryStreamOnBlob(failedKey, length -1, length, 0, false);
1:             fail("Inserted a BLOB with less data than specified");
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded()) {
1:                 assertSQLState("XSDA4", sqle);
1:             } else {
1:                 assertSQLState("XN017", sqle);
1:             }
1:         }
1:         // Now make sure the previous statements are there, and that the last
1:         // BLOB is not.
1:         ResultSet rs;
1:         for (int i=0; i < keys.length; i++) {
1:             psFetchBlob.setInt(1, keys[i]);
1:             rs = psFetchBlob.executeQuery();
1:             assertTrue(rs.next());
1:             assertFalse(rs.next());
1:             rs.close();
1:         }
1:         psFetchBlob.setInt(1, failedKey);
1:         rs = psFetchBlob.executeQuery();
0:         // When using the Derby client driver, the data seems to be padded
0:         // with 0s and inserted... Thus, the select returns a row.
0:         if (!usingEmbedded()) {
1:             assertTrue(rs.next());
0:             InputStream is = rs.getBinaryStream(1);
0:             int lastByte = -1;
0:             int b = 99; // Just a value > 0.
0:             while (b > -1) {
0:                 lastByte = b;
0:                 b = is.read();
1:             }
0:             assertEquals("Last padded byte is not 0", 0, lastByte);
1:         }
1:         assertFalse(rs.next());
1:         rs.close();
1:         rollback();
1:         // Make sure all data is gone after the rollback.
1:         for (int i=0; i < keys.length; i++) {
1:             psFetchBlob.setInt(1, keys[i]);
1:             rs = psFetchBlob.executeQuery();
1:             assertFalse(rs.next());
1:             rs.close();
1:         }
1:         // Make sure the failed insert has not "reappeared" somehow...
1:         psFetchBlob.setInt(1, failedKey);
1:         rs = psFetchBlob.executeQuery();
1:         assertFalse(rs.next());
1: 
1:     }
1: 
1:     public void testSetAsciiStreamLengthLess1KOnClob()
1:             throws IOException, SQLException {
1:         int length = 1*1024;
1:         setAsciiStream(psInsertClob, key, length, -1, 0, true);
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
1:         assertTrue("Empty resultset", rs.next());
1:         assertEquals(new LoopingAlphabetStream(length),
1:                      rs.getAsciiStream(1));
1:         assertFalse("Resultset should have been exhausted", rs.next());
1:         rs.close();
1:     }
1: 
1:     public void testSetAsciiStreamLengthLess32KOnClob()
1:             throws IOException, SQLException {
1:         int length = 32*1024;
1:         setAsciiStream(psInsertClob, key, length, -1, 0, true);
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
1:         assertTrue("Empty resultset", rs.next());
1:         assertEquals(new LoopingAlphabetStream(length),
1:                      rs.getAsciiStream(1));
1:         assertFalse("Resultset should have been exhausted", rs.next());
1:         rs.close();
1:     }
1: 
1:     public void testSetAsciiStreamLengthLess65KOnClob()
1:             throws IOException, SQLException {
1:         int length = 65*1024;
1:         setAsciiStream(psInsertClob, key, length, -1, 0, true);
1:         psFetchClob.setInt(1, key);
1:         ResultSet rs = psFetchClob.executeQuery();
1:         assertTrue("Empty resultset", rs.next());
1:         assertEquals(new LoopingAlphabetStream(length),
1:                      rs.getAsciiStream(1));
1:         assertFalse("Resultset should have been exhausted", rs.next());
1:         rs.close();
1:     }
1: 
1:     public void testSetAsciiStreamLengthLessOnClobTooLong() {
1:         int length = 1*1024*1024+512;
1:         try {
1:             setAsciiStream(psInsertClob, key, length, -1, 0, true);
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded()) {
1:                 assertSQLState("XSDA4", sqle);
1:             } else {
1:                 assertSQLState("22001", sqle);
1:             }
1:         }
1:     }
1: 
1:     public void testSetAsciiStreamLengthLessOnClobTooLongTruncate()
1:             throws SQLException {
1:         int trailingBlanks = 512;
1:         int length = 1*1024*1024 + trailingBlanks;
1:         setAsciiStream(psInsertClob, key, length, -1, trailingBlanks, true);
1:     }
1: 
1:     public void testSetAsciiStreamLengthlessOnLongVarCharTooLong() {
1:         int length = 32700+512;
1:         try {
1:             setAsciiStream(psInsertLongVarchar, key, length, -1, 0, true);
1:             fail("Inserted a LONG VARCHAR that is too long");
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded()) {
1:                 assertInternalDerbyIOExceptionState("XCL30", "22001", sqle);
1:             } else {
1:                 assertSQLState("22001", sqle);
1:             }
1:         }
1:     }
1: 
1:     public void testSetAsciiStreamLengthlessOnLongVarCharDontTruncate() {
1:         int trailingBlanks = 2000;
1:         int length = 32000 + trailingBlanks;
1:         try {
1:             setAsciiStream(psInsertLongVarchar, key, length, -1,
1:                     trailingBlanks, true);
1:             fail("Truncation is not allowed for LONG VARCHAR");
1:         } catch (SQLException sqle) {
1:             if (usingEmbedded()) {
1:                 assertInternalDerbyIOExceptionState("XCL30", "22001", sqle);
1:             } else {
1:                 assertSQLState("22001", sqle);
1:             }
1:         }
1:     }
1: 
1:     /************************************************************************
1:      *                 A U X I L I A R Y  M E T H O D S                     *
1:      ************************************************************************/
1: 
1:     /**
1:      * Insert data into a Blob column with setBinaryStream.
1:      *
1:      * @param id unique id for inserted row
1:      * @param actualLength the actual length of the stream
1:      * @param specifiedLength the specified length of the stream
1:      * @param trailingBlanks number of characters at the end that is blank
1:      * @param lengthLess whether to use the length less overloads or not
1:      */
1:     private void setBinaryStreamOnBlob(int id,
1:                                        int actualLength,
1:                                        int specifiedLength,
1:                                        int trailingBlanks,
1:                                        boolean lengthLess)
1:             throws SQLException {
1:         psInsertBlob.setInt(1, id);
1:         if (lengthLess) {
1:             psInsertBlob.setBinaryStream(2, new LoopingAlphabetStream(
1:                                                 actualLength,
1:                                                 trailingBlanks));
1:         } else {
1:             psInsertBlob.setBinaryStream(2,
1:                                new LoopingAlphabetStream(
1:                                         actualLength,
1:                                         trailingBlanks),
1:                                specifiedLength);
1:         }
1:         assertEquals("Insert with setBinaryStream failed",
1:                 1, psInsertBlob.executeUpdate());
1:     }
1: 
1:     /**
1:      * Insert data into a column with setAsciiStream.
1:      * The prepared statement passed must have two positional parameters;
1:      * one int and one more. Depending on the last parameter, the execute
1:      * might succeed or it might fail. This is intended behavior, and should
1:      * be handled by the caller. For instance, calling this method on an
1:      * INT-column would fail, calling it on a CLOB-column would succeed.
1:      *
1:      * @param id unique id for inserted row
1:      * @param actualLength the actual length of the stream
1:      * @param specifiedLength the specified length of the stream
1:      * @param trailingBlanks number of characters at the end that is blank
1:      * @param lengthLess whether to use the length less overloads or not
1:      */
1:     private void setAsciiStream(PreparedStatement ps,
1:                                 int id,
1:                                 int actualLength,
1:                                 int specifiedLength,
1:                                 int trailingBlanks,
1:                                 boolean lengthLess)
1:             throws SQLException {
1:         ps.setInt(1, id);
1:         if (lengthLess) {
1:             ps.setAsciiStream(2, 
1:                               new LoopingAlphabetStream(
1:                                                 actualLength,
1:                                                 trailingBlanks));
1:         } else {
1:             ps.setAsciiStream(2,
1:                               new LoopingAlphabetStream(
1:                                                 actualLength,
1:                                                 trailingBlanks),
1:                               specifiedLength);
1:         }
1:         assertEquals("Insert with setAsciiStream failed",
1:                 1, ps.executeUpdate());
1:     }
1: 
1:     /**
1:      * Get next key to id inserted data with.
1:      */
1:     private static int requestKey() {
1:         return globalKey++;
1:     }
1: 
1:     /**
0:      * Return the last chained SQLException.
0:      * If there are no exceptions chained, the original one is returned.
1:      */
0:     private SQLException getLastSQLException(SQLException sqle) {
0:         SQLException last = sqle;
0:         SQLException next = sqle;
0:         while (next != null) {
0:             last = next;
0:             next = last.getNextException();
1:         }
0:         return last;
1:     }
1: 
1:     /**
1:      * This methods is not to be used, but sometimes you have to!
1:      *
1:      * @param preSQLState the expected outer SQL state
1:      * @param expectedInternal the expected internal SQL state
1:      * @param sqle the outer SQLException
1:      */
1:     private void assertInternalDerbyIOExceptionState(
1:                                         String preSQLState,
1:                                         String expectedInternal,
1:                                         SQLException sqle) {
1:         assertSQLState("Outer/public SQL state incorrect",
1:                        preSQLState, sqle);
1:         // We need to dig a little with the current way exceptions are
1:         // being reported. We can use getCause because we always run with
0:         // Mustang/Java SE 6.
1:         Throwable cause = getLastSQLException(sqle).getCause();
0:         assertTrue("Exception not an EmbedSQLException",
0:                    cause instanceof EmbedSQLException);
0:         cause = ((EmbedSQLException)cause).getJavaException();
1:         assertTrue("Exception not a DerbyIOException",
1:                    cause instanceof DerbyIOException);
1:         DerbyIOException dioe = (DerbyIOException)cause;
1:         assertEquals("Incorrect internal SQL state", expectedInternal,
1:                      dioe.getSQLState());
commit:f631317
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:     public void testIsWrapperForStatement() throws SQLException {
1:         assertTrue(ps.isWrapperFor(Statement.class));
1:     }
1: 
1:     public void testIsWrapperForPreparedStatement() throws SQLException {
1:         assertTrue(ps.isWrapperFor(PreparedStatement.class));
1:     }
1: 
1:     public void testIsNotWrapperForCallableStatement() throws SQLException {
1:         assertFalse(ps.isWrapperFor(CallableStatement.class));
1:     }
1: 
1:     public void testIsNotWrapperForResultSet() throws SQLException {
1:         assertFalse(ps.isWrapperFor(ResultSet.class));
1:     }
1: 
1:     public void testUnwrapStatement() throws SQLException {
1:         Statement stmt = ps.unwrap(Statement.class);
1:         assertSame("Unwrap returned wrong object.", ps, stmt);
1:     }
1: 
1:     public void testUnwrapPreparedStatement() throws SQLException {
1:         PreparedStatement ps2 = ps.unwrap(PreparedStatement.class);
1:         assertSame("Unwrap returned wrong object.", ps, ps2);
1:     }
1: 
1:     public void testUnwrapCallableStatement() {
1:         try {
1:             CallableStatement cs = ps.unwrap(CallableStatement.class);
1:             fail("Unwrap didn't fail.");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ128", e);
1: 
1:     public void testUnwrapResultSet() {
1:         try {
1:             ResultSet rs = ps.unwrap(ResultSet.class);
1:             fail("Unwrap didn't fail.");
1:         } catch (SQLException e) {
1:             assertSQLState("XJ128", e);
commit:16e1003
/////////////////////////////////////////////////////////////////////////
0:         if (usingEmbedded()) {
0:             // Add methods temporarily disabled for DerbyNetClient
0:             suite.addTest(new PreparedStatementTest(
0:                         "embonlytmptestSetClobLengthless"));
0:             suite.addTest(new PreparedStatementTest(
0:                         "embonlytmptestSetBlobLengthless"));
0:             suite.addTest(new PreparedStatementTest(
0:                         "embonlytmptestSetCharacterStreamLengthless"));
0:             suite.addTest(new PreparedStatementTest(
0:                         "embonlytmptestSetAsciiStreamLengthless"));
0:             suite.addTest(new PreparedStatementTest(
0:                         "embonlytmptestSetBinaryStreamLengthless"));
1:         }
commit:242c9bd
/////////////////////////////////////////////////////////////////////////
1: 
1:     /** Byte array passed in to the database. **/
1:     private static final byte[] BYTES = {
1:         0x65, 0x66, 0x67, 0x68, 0x69,
1:         0x69, 0x68, 0x67, 0x66, 0x65
1:     };
1: 
/////////////////////////////////////////////////////////////////////////
0:         // Add methods temorarily disabled for DerbyNetClient
0:         suite.addTest(new PreparedStatementTest(
0:                     "embonlytmptestSetClobLengthless"));
0:         suite.addTest(new PreparedStatementTest(
0:                     "embonlytmptestSetBlobLengthless"));
0:         suite.addTest(new PreparedStatementTest(
0:                     "embonlytmptestSetCharacterStreamLengthless"));
0:         suite.addTest(new PreparedStatementTest(
0:                     "embonlytmptestSetAsciiStreamLengthless"));
0:         suite.addTest(new PreparedStatementTest(
0:                     "embonlytmptestSetBinaryStreamLengthless"));
/////////////////////////////////////////////////////////////////////////
1:     public void testSetNCharacterStreamLengthlessNotImplemented()
1:             throws SQLException {
1:         try {
1:             ps.setNCharacterStream(1, new StringReader("A string"));
1:             fail("setNCharacterStream(int,Reader) should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, this is expected behavior.
1:         }
1:     }
1: 
1:     public void testSetNClobLengthlessNotImplemented()
1:             throws SQLException {
1:         try {
1:             ps.setNClob(1, new StringReader("A string"));
1:             fail("setNClob(int,Reader) should not be implemented");
1:         } catch (SQLFeatureNotSupportedException sfnse) {
1:             // Do nothing, this is expected behaviour.
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testSetClob()
1:             throws IOException, SQLException {
1:         is.reset();
/////////////////////////////////////////////////////////////////////////
0:         Clob clobToBeInserted = rs.getClob(2);
0:         ps_sc.setClob(2,clobToBeInserted);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(clobToBeInserted,clobRetrieved);
1: 
1:     /**
1:      * Insert <code>Clob</code> without specifying length and read it back
1:      * for verification.
0:      * Beacuse we don't yet support <code>Connection.createClob</code> in the
0:      * client driver, we must first insert data into the database and read back
0:      * a <code>Clob</code> object. This object is then inserted into the
0:      * database again.
0:     public void embonlytmptestSetClobLengthless()
1:             throws IOException, SQLException {
1:         // Insert test data.
1:         String testString = "Test string for setCharacterStream\u1A00";
1:         Reader reader = new StringReader(testString);
0:         PreparedStatement psChar = conn.prepareStatement(
0:                 "insert into ClobTestTable values (?,?)");
0:         psChar.setInt(1, 1);
0:         psChar.setCharacterStream(2, reader);
0:         psChar.execute();
1:         reader.close();
0:         // Must fetch Clob from database because we don't support
0:         // Connection.createClob on the client yet.
0:         ResultSet rs = s.executeQuery(
0:                 "select clobCol from ClobTestTable where sno = 1");
1:         assertTrue("No results retrieved", rs.next());
0:         Clob insertClob = rs.getClob(1);
0:         psChar.setInt(1, 2);
0:         psChar.setClob(2, insertClob);
0:         psChar.execute();
1: 
1:         // Read back test data from database.
0:         rs = s.executeQuery(
0:                 "select clobCol from ClobTestTable where sno = 2");
1:         assertTrue("No results retrieved", rs.next());
1:         Clob clobRetrieved = rs.getClob(1);
1: 
1:         // Verify test data.
1:         assertEquals(insertClob, clobRetrieved);
1: 
/////////////////////////////////////////////////////////////////////////
1:     public void testSetBlob()
1:             throws IOException, SQLException {
1:         InputStream is = new java.io.ByteArrayInputStream(BYTES);
1:         is.reset();
0:         ps_sb.setBlob(2,is,BYTES.length);
0:         Blob blobToBeInserted = rs.getBlob(2);
0:         ps_sb.setBlob(2,blobToBeInserted);
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(blobToBeInserted, blobRetrieved);
1:     /**
1:      * Insert <code>Blob</code> without specifying length and read it back
1:      * for verification.
0:      * Beacuse we don't yet support <code>Connection.createBlob</code> in the
0:      * client driver, we must first insert data into the database and read back
0:      * a <code>Blob</code> object. This object is then inserted into the
0:      * database again.
0:     public void embonlytmptestSetBlobLengthless()
1:             throws IOException, SQLException {
1:         // Insert test data.
1:         InputStream is = new ByteArrayInputStream(BYTES);
0:         PreparedStatement psByte = conn.prepareStatement(
0:                 "insert into BlobTestTable values (?,?)");
0:         psByte.setInt(1, 1);
0:         psByte.setBinaryStream(2, is);
0:         psByte.execute();
1:         is.close();
0:         // Must fetch Blob from database because we don't support
0:         // Connection.createBlob on the client yet.
0:         ResultSet rs = s.executeQuery(
0:                 "select blobCol from BlobTestTable where sno = 1");
1:         assertTrue("No results retrieved", rs.next());
0:         Blob insertBlob = rs.getBlob(1);
0:         psByte.setInt(1, 2);
0:         psByte.setBlob(2, insertBlob);
0:         psByte.execute();
1: 
1:         // Read back test data from database.
0:         rs = s.executeQuery(
0:                 "select blobCol from BlobTestTable where sno = 2");
1:         assertTrue("No results retrieved", rs.next());
1:         Blob blobRetrieved = rs.getBlob(1);
1: 
1:         // Verify test data.
1:         assertEquals(insertBlob, blobRetrieved);
1: 
/////////////////////////////////////////////////////////////////////////
1: 
0:     public void embonlytmptestSetCharacterStreamLengthless()
1:             throws IOException, SQLException {
1:         // Insert test data.
0:         String testString = "Test string for setCharacterStream\u1A00";
0:         Reader reader = new StringReader(testString);
0:         PreparedStatement psChar = conn.prepareStatement(
0:                 "insert into ClobTestTable values (?,?)");
0:         psChar.setInt(1, 1);
0:         psChar.setCharacterStream(2, reader);
0:         psChar.execute();
0:         reader.close();
1: 
1:         // Read back test data from database.
0:         ResultSet rs = s.executeQuery(
0:                 "select clobCol from ClobTestTable where sno = 1");
1:         assertTrue("No results retrieved", rs.next());
1:         Clob clobRetrieved = rs.getClob(1);
1: 
1:         // Verify test data.
1:         assertEquals("Mismatch test data in/out", testString,
1:                      clobRetrieved.getSubString(1, testString.length()));
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         InputStream is = new java.io.ByteArrayInputStream(BYTES);
/////////////////////////////////////////////////////////////////////////
0:         ps_sb.setAsciiStream(2,is,BYTES.length);
/////////////////////////////////////////////////////////////////////////
1:         for(int i=0;i<BYTES.length;i++) {
1:             assertEquals("Error in inserting data into the Clob",BYTES[i],bytes1[i]);
1: 
0:     public void embonlytmptestSetAsciiStreamLengthless()
1:             throws IOException, SQLException {
0:         // Insert test data.
1:         InputStream is = new ByteArrayInputStream(BYTES);
0:         PreparedStatement psAscii = conn.prepareStatement(
0:                 "insert into ClobTestTable values (?,?)");
0:         psAscii.setInt(1, 1);
0:         psAscii.setAsciiStream(2, is);
0:         psAscii.execute();
1:         is.close();
1: 
1:         // Read back test data from database.
0:         ResultSet rs = s.executeQuery(
0:                 "select clobCol from ClobTestTable where sno = 1");
0:         assertTrue("No results retrieved", rs.next());
1:         Clob clobRetrieved = rs.getClob(1);
1: 
1:         // Verify read back data.
1:         byte[] dbBytes = new byte[10];
1:         InputStream isRetrieved = clobRetrieved.getAsciiStream();
1:         assertEquals("Unexpected number of bytes read", BYTES.length,
1:                 isRetrieved.read(dbBytes));
1:         assertEquals("Stream should be exhausted", -1, isRetrieved.read());
1:         for (int i=0; i < BYTES.length; i++) {
1:             assertEquals("Byte mismatch in/out", BYTES[i], dbBytes[i]);
1:         }
1: 
1:         // Cleanup
1:         isRetrieved.close();
0:         psAscii.close();
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         InputStream is = new java.io.ByteArrayInputStream(BYTES);
/////////////////////////////////////////////////////////////////////////
0:         ps_sb.setBinaryStream(2,is,BYTES.length);
/////////////////////////////////////////////////////////////////////////
1:         for(int i=0;i<BYTES.length;i++) {
1:             assertEquals("Error in inserting data into the Blob",BYTES[i],bytes1[i]);
1: 
0:     public void embonlytmptestSetBinaryStreamLengthless()
1:             throws IOException, SQLException {
0:         // Insert test data.
0:         InputStream is = new ByteArrayInputStream(BYTES);
0:         PreparedStatement psBinary = conn.prepareStatement(
0:                 "insert into BlobTestTable values (?,?)");
0:         psBinary.setInt(1, 1);
0:         psBinary.setBinaryStream(2, is);
0:         psBinary.execute();
0:         is.close();
1: 
1:         // Read back test data from database.
0:         ResultSet rs = s.executeQuery(
0:                 "select blobCol from BlobTestTable where sno = 1");
0:         assertTrue("No results retrieved", rs.next());
1:         Blob blobRetrieved = rs.getBlob(1);
1: 
1:         // Verify read back data.
1:         byte[] dbBytes = new byte[10];
1:         InputStream isRetrieved = blobRetrieved.getBinaryStream();
1:         assertEquals("Unexpected number of bytes read", BYTES.length,
1:                 isRetrieved.read(dbBytes));
1:         assertEquals("Stream should be exhausted", -1, isRetrieved.read());
1:         for (int i=0; i < BYTES.length; i++) {
1:             assertEquals("Byte mismatch in/out", BYTES[i], dbBytes[i]);
1:         }
1: 
1:         // Cleanup
1:         isRetrieved.close();
0:         psBinary.close();
1:     }
commit:054fa3a
/////////////////////////////////////////////////////////////////////////
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite();
1:         suite.addTestSuite(PreparedStatementTest.class);
0:         suite.addTest(SetObjectUnsupportedTest.suite(false));
0:         return suite;
1:     }
commit:ff7369c
/////////////////////////////////////////////////////////////////////////
1:     public void testSetCharacterStream() throws Exception {
1:         is.reset();
/////////////////////////////////////////////////////////////////////////
1:     public void testSetAsciiStream() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         is.reset();
/////////////////////////////////////////////////////////////////////////
1:     public void testSetBinaryStream() throws Exception {
/////////////////////////////////////////////////////////////////////////
1:         is.reset();
commit:c511410
/////////////////////////////////////////////////////////////////////////
1:     //Statement object
0:     Statement s = null;
1: 
/////////////////////////////////////////////////////////////////////////
0:         //create the statement object
0:         s = conn.createStatement();
1:         
0:          // STEP1: create the tables
0:          // Structure of table
0:          // --------------------------
0:          // SNO            Clob Column
0:          // --------------------------
1: 
0:          s.execute("create table ClobTestTable (sno int, clobCol CLOB(1M))");
0:          s.execute("create table BlobTestTable (sno int, blobCol BLOB(1M))");
/////////////////////////////////////////////////////////////////////////
1:         
0:         s.execute("drop table ClobTestTable");
0:         s.execute("drop table BlobTestTable");
0:         s.close();
1:         
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     
1:     
1:     /**
1:      *
1:      * Tests the PreparedStatement interface method setCharacterStream
1:      *
1:      * @throws SQLException
1:      *
1:      */
0:     public void testSetCharacterStream() throws SQLException {
1:         String str = "Test data for the Clob object";
1:         StringReader is = new StringReader("Test data for the Clob object");
1:         
1:         try {
0:             is.reset();
0:         } catch (IOException ioe) {
0:             fail("Failed to reset Clob input stream: " + ioe.getMessage());
1:         }
1:         
0:         PreparedStatement ps_sc = conn.prepareStatement("insert into ClobTestTable values(?,?)");
1:         
1:         //initially insert the data
0:         ps_sc.setInt(1,1);
0:         ps_sc.setCharacterStream(2,is,str.length());
0:         ps_sc.executeUpdate();
1:         
1:         //Now query to retrieve the Clob
0:         ResultSet rs = s.executeQuery("select * from ClobTestTable where sno = 1");
1:         rs.next();
0:         Clob clobRetrieved = rs.getClob(2);
1:         rs.close();
1:         
1:         String str_out = clobRetrieved.getSubString(1L,(int)clobRetrieved.length());
1:         
1:         assertEquals("Error in inserting data into the Clob object",str,str_out);
0:         ps_sc.close();
1:     }
1:     
1:      /**
1:       *
1:       * Tests the PreparedStatement interface method setAsciiStream
1:       *
1:       * @throws SQLException
1:       *
1:       */
1:     
0:     public void testSetAsciiStream() throws SQLException {
1:         //insert default values into the table
1:         
0:         byte[] bytes = new byte[] {
0:             0x65, 0x66, 0x67, 0x68, 0x69,
0:             0x69, 0x68, 0x67, 0x66, 0x65
0:         };
1:         
1:         byte [] bytes1 = new byte[10];
1:         
0:         InputStream is = new java.io.ByteArrayInputStream(bytes);
1:         
1:         try {
0:             is.reset();
0:         } catch (IOException ioe) {
0:             fail("Failed to reset Clob input stream: " + ioe.getMessage());
1:         }
1:         
0:         PreparedStatement ps_sb = conn.prepareStatement("insert into ClobTestTable values(?,?)");
1:         
1:         //initially insert the data
0:         ps_sb.setInt(1,1);
0:         ps_sb.setAsciiStream(2,is,bytes.length);
0:         ps_sb.executeUpdate();
1:         
1:         //Now query to retrieve the Clob
0:         ResultSet rs = s.executeQuery("select * from ClobTestTable where sno = 1");
1:         rs.next();
0:         Clob ClobRetrieved = rs.getClob(2);
1:         rs.close();
1:         
1:         try {
1:             InputStream is_ret = ClobRetrieved.getAsciiStream();
1:             is_ret.read(bytes1);
1:         } catch(IOException ioe) {
1:             fail("IOException while reading the Clob from the database");
1:         }
0:         for(int i=0;i<bytes.length;i++) {
0:             assertEquals("Error in inserting data into the Clob",bytes[i],bytes1[i]);
1:         }
0:         ps_sb.close();
1:     }
1:     
1:     /**
1:      *
1:      * Tests the PreparedStatement interface method setBinaryStream
1:      *
1:      * @throws SQLException
1:      *
1:      */
1:     
0:     public void testSetBinaryStream() throws SQLException {
1:         //insert default values into the table
1:         
0:         byte[] bytes = new byte[] {
0:             0x65, 0x66, 0x67, 0x68, 0x69,
0:             0x69, 0x68, 0x67, 0x66, 0x65
0:         };
1:         
1:         byte [] bytes1 = new byte[10];
1:         
0:         InputStream is = new java.io.ByteArrayInputStream(bytes);
1:         
1:         try {
0:             is.reset();
0:         } catch (IOException ioe) {
0:             fail("Failed to reset blob input stream: " + ioe.getMessage());
1:         }
1:         
0:         PreparedStatement ps_sb = conn.prepareStatement("insert into BlobTestTable values(?,?)");
1:         
1:         //initially insert the data
0:         ps_sb.setInt(1,1);
0:         ps_sb.setBinaryStream(2,is,bytes.length);
0:         ps_sb.executeUpdate();
1:         
1:         //Now query to retrieve the Clob
0:         ResultSet rs = s.executeQuery("select * from BlobTestTable where sno = 1");
1:         rs.next();
0:         Blob blobRetrieved = rs.getBlob(2);
1:         rs.close();
1:         
1:         try {
1:             InputStream is_ret = blobRetrieved.getBinaryStream();
1:             is_ret.read(bytes1);
1:         } catch(IOException ioe) {
1:             fail("IOException while reading the Clob from the database");
1:         }
1:         
0:         for(int i=0;i<bytes.length;i++) {
0:             assertEquals("Error in inserting data into the Blob",bytes[i],bytes1[i]);
1:         }
0:         ps_sb.close();
1:     }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.shared.common.sanity.SanityManager;
commit:eb0e14c
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:                         TestConfiguration.connectionCPDecorator( baseSuite
1:                                 ("PreparedStatementTest:logical"))));
1: 
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2e87a4c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // This test makes use of a debug entry point which is a NOP
1:         // in an insane production build.
1:         //
1:         if (!SanityManager.DEBUG)    { return; }
1: 
commit:20b2fd9
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Test the large update methods added by JDBC 4.2.
1:      */
1:     public void testLargeUpdate_jdbc4_2() throws Exception
1:     {
1:         Connection  conn = getConnection();
1: 
1:         largeUpdate_jdbc4_2( conn );
1:     }
1: 
1:     public  static  void    largeUpdate_jdbc4_2( Connection conn )
1:         throws Exception
1:     {
1:         println( "Running large update test for JDBC 4.2" );
1:         
1:         conn.prepareStatement
1:             (
1:              "create procedure setRowCountBase( newBase bigint )\n" +
1:              "language java parameter style java no sql\n" +
1:              "external name 'org.apache.derbyTesting.functionTests.tests.jdbc4.StatementTest.setRowCountBase'\n"
1:              ).execute();
1:         conn.prepareStatement
1:             (
1:              "create table bigintTable( col1 int generated always as identity, col2 bigint )"
1:              ).execute();
1: 
1:         Statement   stmt = conn.createStatement();
1:         PreparedStatementWrapper  psw = new PreparedStatementWrapper
1:             ( conn.prepareStatement( "insert into bigintTable( col2 ) values ( 1 ), ( 2 ), ( 3 ), ( 4 ), ( 5 )" ) );
1: 
1:         largeUpdateTest( stmt, psw, ((long) Integer.MAX_VALUE) + 1L );
1:         
1:         StatementTest.setRowCountBase( stmt, false, 0L );
1:     }
1:     private static  void    largeUpdateTest
1:         ( Statement stmt, PreparedStatementWrapper psw, long rowCountBase )
1:         throws Exception
1:     {
1:         StatementTest.setRowCountBase( stmt, false, rowCountBase );
1: 
1:         assertEquals( rowCountBase + 5L, psw.executeLargeUpdate() );
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     ////////////////////////////////////////////////////////////////////////
1:     //
1:     // NESTED JDBC 4.2 WRAPPER AROUND A PreparedStatement
1:     //
1:     ////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * This wrapper is used to expose JDBC 4.2 methods which can run on
1:      * VM rev levels lower than Java 8.
1:      * </p>
1:      */
1:     public  static  class   PreparedStatementWrapper    extends StatementTest.StatementWrapper
1:     {
1:         private PreparedStatement   _wrappedPreparedStatement;
1: 
1:         public  PreparedStatementWrapper( PreparedStatement wrappedPreparedStatement )
1:         {
1:             super( wrappedPreparedStatement );
1:         }
1: 
1:         PreparedStatement   getWrappedPreparedStatement() { return (PreparedStatement) getWrappedStatement(); }
1: 
1:         public  long executeLargeUpdate() throws SQLException
1:         {
1:             return ((Long) invoke
1:                 (
1:                  "executeLargeUpdate",
1:                  new Class[] {},
1:                  new Object[] {}
1:                  )).longValue();
1:         }
1:     }
1:     
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:956354d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     public void testSetClobLengthless()
/////////////////////////////////////////////////////////////////////////
1:     public void testSetBlobLengthless()
/////////////////////////////////////////////////////////////////////////
1:     public void testSetCharacterStreamLengthless()
/////////////////////////////////////////////////////////////////////////
1:     public void testSetAsciiStreamLengthless()
/////////////////////////////////////////////////////////////////////////
1:     public void testSetBinaryStreamLengthless()
commit:49335b4
/////////////////////////////////////////////////////////////////////////
1: /*
1:  
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbc4.PreparedStatementTest
1:  
0:    Copyright 2006 The Apache Software Foundation or its licensors, as applicable.
1:  
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1:  
1:       http://www.apache.org/licenses/LICENSE-2.0
1:  
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1:  
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
0: import junit.framework.*;
1: 
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
0: import org.apache.derbyTesting.functionTests.util.SQLStateConstants;
1: 
0: import java.io.*;
0: import java.sql.*;
0: import javax.sql.*;
1: 
1: /**
1:  * This class is used to test JDBC4 specific methods in the PreparedStatement(s)
1:  * object.
1:  */
1: public class PreparedStatementTest extends BaseJDBCTestCase {
1:     /**
0:      * Default connection and prepared statements that are used by the tests.
1:      */
0:     //Connection object
0:     Connection conn      = null;
0:     //PreparedStatement object
0:     PreparedStatement ps = null;
1:     
1:     /**
1:      * Create a test with the given name.
1:      * 
1:      * @param name name of the test.
1:      */
1:     public PreparedStatementTest(String name) {
1:         super(name);
1:     }
1:     
1:     /**
1:      *
1:      * Obtain a "regular" connection and PreparedStatement that the tests 
1:      * can use.
1:      * 
1:      * @throws SQLException
1:      */
0:     public void setUp() 
1:         throws SQLException {
0:         conn = getConnection();
1:         //Create the PreparedStatement that will then be used as the basis 
1:         //throughout this test henceforth
1:         //This prepared statement will however NOT be used for testing
1:         //setClob and setBlob
0:         ps = conn.prepareStatement("select count(*) from sys.systables");
1:     }
1: 
1:     /**
1:      *
1:      * Release the resources that are used in this test
1:      *
1:      * @throws SQLException
1:      *
1:      */
0:     public void tearDown() 
1:         throws SQLException {
0:         if (conn != null && !conn.isClosed()) {
0:             conn.rollback();
0:             conn.close();
1:         }
0:         conn = null;
1:     }
1:     
1:     //--------------------------------------------------------------------------
1:     //BEGIN THE TEST OF THE METHODS THAT THROW AN UNIMPLEMENTED EXCEPTION IN
1:     //THIS CLASS
1:     
1:     /**
1:      * Tests the setRowId method of the PreparedStatement interface
1:      *
1:      * @throws SQLException upon any failure that occurs in the 
1:      *         call to the method.
1:      */
1:     public void testSetRowId() throws SQLException{
1:         try {
1:             RowId rowid = null;
1:             ps.setRowId(0,rowid);
1:             fail("setRowId should not be implemented");
1:         }
1:         catch(SQLFeatureNotSupportedException sqlfne) {
1:             //Do Nothing, This happens as expected
1:         }
1:     }
1:     
1:     /**
1:      * Tests the setNString method of the PreparedStatement interface
1:      *
1:      * @throws SQLException upon any failure that occurs in the 
1:      *         call to the method.
1:      */
1:     public void testSetNString() throws SQLException{
1:         try {
1:             String str = null;
1:             ps.setNString(0,str);
1:             fail("setNString should not be implemented");
1:         }
1:         catch(SQLFeatureNotSupportedException sqlfne) {
1:             //Do Nothing, This happens as expected
1:         }
1:     }
1:     
1:     /**
1:      * Tests the setNCharacterStream method of the PreparedStatement interface
1:      *
1:      * @throws SQLException upon any failure that occurs in the 
1:      *         call to the method.
1:      */
1:     public void testSetNCharacterStream() throws SQLException{
1:         try {
1:             Reader r  = null;
1:             ps.setNCharacterStream(0,r,0);
1:             fail("setNCharacterStream should not be implemented");
1:         }
1:         catch(SQLFeatureNotSupportedException sqlfne) {
1:             //Do Nothing, This happens as expected
1:         }
1:     }
1:     
1:     /**
1:      * Tests the setNClob method of the PreparedStatement interface
1:      *
1:      * @throws SQLException upon any failure that occurs in the 
1:      *         call to the method.
1:      */
1:     public void testSetNClob1() throws SQLException{
1:         try {
1:             NClob nclob = null;
1:             ps.setNClob(0,nclob);
1:             fail("setNClob should not be implemented");
1:         }
1:         catch(SQLFeatureNotSupportedException sqlfne) {
1:             //Do Nothing, This happens as expected
1:         }
1:     }
1:     
1:     /**
1:      * Tests the setNClob method of the PreparedStatement interface
1:      *
1:      * @throws SQLException upon any failure that occurs in the 
1:      *         call to the method.
1:      */
1:     public void testSetNClob2() throws SQLException{
1:         try {
1:             Reader reader = null;
1:             ps.setNClob(0,reader,0);
1:             fail("setNClob should not be implemented");
1:         }
1:         catch(SQLFeatureNotSupportedException sqlfne) {
1:             //Do Nothing, This happens as expected
1:         }
1:     }
1:     
1:     /**
1:      * Tests the setSQLXML method of the PreparedStatement interface
1:      *
1:      * @throws SQLException upon any failure that occurs in the 
1:      *         call to the method.
1:      */
1:     public void testSetSQLXML() throws SQLException{
1:         try {
1:             SQLXML sqlxml = null;
1:             ps.setSQLXML(0,sqlxml);
1:             fail("setNClob should not be implemented");
1:         }
1:         catch(SQLFeatureNotSupportedException sqlfne) {
1:             //Do Nothing, This happens as expected
1:         }
1:     }
1:     
1:     //--------------------------------------------------------------------------
1:     //Now test the methods that are implemented in the PreparedStatement 
1:     //interface
1:     
1:     /**
1:      *
0:      * Tests the wrapper methods isWrapperFor and unwrap. Test
0:      * for the case when isWrapperFor returns true and we call unwrap
0:      * The test is right now being run in the embedded case only
1:      *
1:      * @throws SQLException upon any failure that occurs in the 
0:      *                      call to the method.
1:      *
1:      */
0:     public void testisWrapperReturnsTrue() throws SQLException {
0:         Class<PreparedStatement> wrap_class = PreparedStatement.class;
1:         
0:         //The if should return true enabling us  to call the unwrap method
0:         //without throwing  an exception
0:         if(ps.isWrapperFor(wrap_class)) {
1:             try {
0:                 PreparedStatement stmt1 =
0:                         (PreparedStatement)ps.unwrap(wrap_class);
1:             }
0:             catch(SQLException sqle) {
0:                 fail("Unwrap wrongly throws a SQLException");
1:             }
1:         } else {
0:             fail("isWrapperFor wrongly returns false");
1:         }
1:     }
1:     
1:     /**
1:      *
0:      * Tests the wrapper methods isWrapperFor and unwrap. Test
0:      * for the case when isWrapperFor returns false and we call unwrap
0:      * The test is right now being run in the embedded case only
1:      *
1:      * @throws SQLException upon any failure that occurs in the 
0:      *                      call to the method.
1:      *
1:      */
0:     public void testisWrapperReturnsFalse() throws SQLException {
0:         //test for the case when isWrapper returns false
0:         //using some class that will return false when
0:         //passed to isWrapperFor
0:         Class<ResultSet> wrap_class = ResultSet.class;
1:         
0:         //returning false is the correct behaviour in this case
0:         //Generate a message if it returns true
0:         if(ps.isWrapperFor(wrap_class)) {
0:             fail("isWrapperFor wrongly returns true");
1:         } else {
1:             try {
0:                 ResultSet rs1 = (ResultSet)
0:                 ps.unwrap(wrap_class);
0:                 fail("unwrap does not throw the expected " +
0:                         "exception");
1:             } catch (SQLException sqle) {
0:                 //calling unwrap in this case throws an SQLException
0:                 //check that this SQLException has the correct SQLState
0:                 if(!SQLStateConstants.UNABLE_TO_UNWRAP.equals(sqle.getSQLState())) {
0:                     throw sqle;
1:                 }
1:             }
1:         }
1:     }
1: 
1:     //-----------------------------------------------------------------------
1:     // Begin test for setClob and setBlob
1:     
1:     /*
1:        we need a table in which a Clob or a Blob can be stored. We basically
1:        need to write tests for the setClob and the setBlob methods. 
1:        Proper process would be
1:        a) Do a createClob or createBlob
1:        b) Populate data in the LOB
1:        c) Store in Database
1: 
1:        But the createClob and createBlob implementations are not 
1:        available on the EmbeddedServer. So instead the workaround adopted
1:        is 
1: 
1:        a) store a Clob or Blob in Database. 
1:        b) Retrieve it from the database.
1:        c) store it back using setClob or setBlob
1: 
1:      */
1: 
1:     /**
1:      *
1:      * Test the setClob() method
1:      *
1:      * @throws SQLException if a failure occurs during the call to setClob
1:      *
1:      */
0:     public void testSetClob() throws SQLException {
1:         
0:         // Keeping the above in mind 
0:         // STEP1: create the tables
0:         // Structure of table
0:         // --------------------------
0:         // SNO            Clob Column
0:         // --------------------------
1:         
0:         Statement s = conn.createStatement();
0:         s.execute("create table ClobTestTable (sno int, clobCol CLOB(1M))");
1:         
1:         //insert default values into the table
1:         
1:         String str = "Test data for the Clob object";
1:         StringReader is = new StringReader("Test data for the Clob object");
1:         
1:         try {
0:             is.reset();
0:         } catch (IOException ioe) {
0:             fail("Failed to reset blob input stream: " + ioe.getMessage());
1:         }
1:         
0:         PreparedStatement ps_sc = conn.prepareStatement("insert into ClobTestTable values(?,?)");
1:         
1:         //initially insert the data
0:         ps_sc.setInt(1,1);
0:         ps_sc.setClob(2,is,str.length());
0:         ps_sc.executeUpdate();
1:         
0:         //Now query to retrieve the Clob
0:         ResultSet rs = s.executeQuery("select * from ClobTestTable where sno = 1");
1:         rs.next();
0:         Clob clobToBeInerted = rs.getClob(2);
0:         rs.close();
1:         
1:         //Now use the setClob method
0:         ps_sc.setInt(1,2);
0:         ps_sc.setClob(2,clobToBeInerted);
0:         ps_sc.execute();
1:         
0:         ps_sc.close();
1:         
1:         //Now test to see that the Clob has been stored correctly
0:         rs = s.executeQuery("select * from ClobTestTable where sno = 2");
1:         rs.next();
0:         Clob clobRetrieved = rs.getClob(2);
1:         
0:         if(!equalClob(clobToBeInerted,clobRetrieved)) 
0:             fail("Clob not inserted properly using setClob");
1:         
0:         s.execute("drop table ClobTestTable");
1:     }
1:     
1:     /*
1:      *
0:      * Compares the two clobs supplied to se if they are similar
0:      * returns true if they are similar and false otherwise.
1:      * 
0:      * @param clob1 Clob to be compared
0:      * @param clob1 Clob to be compared
0:      * @return true if they are equal
1:      *
1:      */
0:     boolean equalClob(Clob clob1,Clob clob2) {
0:         int c1,c2;
0:         InputStream is1=null,is2=null;
1:         try {
0:             is1 = clob1.getAsciiStream();
0:             is2 = clob2.getAsciiStream();
0:             if(clob1.length()!=clob2.length())
0:                 return false;
0:         } catch(SQLException sqle){
0:             sqle.printStackTrace();
1:         }
1:         try {
0:             for(long i=0;i<clob1.length();i++) {
0:                 c1=is1.read();
0:                 c2=is2.read();
0:                 if(c1!=c2)
0:                     return false;
1:             }
0:         } catch(IOException e) {
0:             e.printStackTrace();
0:         } catch(SQLException e) {
0:             e.printStackTrace();
1:         }
0:         return true;
1:     }
1:     
1:     /**
1:      *
1:      * Test the setBlob() method
1:      *
1:      * @throws SQLException if a failure occurs during the call to setBlob
1:      *
1:      */
0:     public void testSetBlob() throws SQLException {
1:         
0:         // Keeping the above in mind 
0:         // STEP1: create the tables
0:         // Structure of table
0:         // --------------------------
0:         // SNO            Blob Column
0:         // --------------------------
1:         
0:         Statement s = conn.createStatement();
0:         s.execute("create table BlobTestTable (sno int, blobCol BLOB(1M))");
1:         
1:         //insert default values into the table
1:         
0:         byte[] bytes = new byte[] {
0:             0x65, 0x66, 0x67, 0x68, 0x69,
0:             0x69, 0x68, 0x67, 0x66, 0x65
0:         };
0:         InputStream is = new java.io.ByteArrayInputStream(bytes);
1:         
1:         try {
0:             is.reset();
0:         } catch (IOException ioe) {
0:             fail("Failed to reset blob input stream: " + ioe.getMessage());
1:         }
1:         
0:         PreparedStatement ps_sb = conn.prepareStatement("insert into BlobTestTable values(?,?)");
1:         
1:         //initially insert the data
0:         ps_sb.setInt(1,1);
0:         ps_sb.setBlob(2,is,bytes.length);
0:         ps_sb.executeUpdate();
1:         
1:         //Now query to retrieve the Blob
0:         ResultSet rs = s.executeQuery("select * from BlobTestTable where sno = 1");
1:         rs.next();
0:         Blob blobToBeInerted = rs.getBlob(2);
0:         rs.close();
1:         
1:         //Now use the setBlob method
0:         ps_sb.setInt(1,2);
0:         ps_sb.setBlob(2,blobToBeInerted);
0:         ps_sb.execute();
1:         
0:         ps_sb.close();
1:         
1:         //Now test to see that the Blob has been stored correctly
0:         rs = s.executeQuery("select * from BlobTestTable where sno = 2");
1:         rs.next();
0:         Blob blobRetrieved = rs.getBlob(2);
1:         
0:         if(!equalBlob(blobToBeInerted,blobRetrieved)) 
0:             fail("Blob not inserted properly using setBlob");
1:         
0:         s.execute("drop table BlobTestTable");
1:     }
1:     
1:     /*
0:      * Compares the two blobs supplied to se if they are similar
0:      * returns true if they are similar and false otherwise.
1:      *
0:      * @param blob1 The first Blob that is passed as input
0:      * @param blob2 The second Blob that is passed as input
1:      *
0:      * @return true If the Blob values are equal
1:      */
0:     boolean equalBlob(Blob blob1,Blob blob2) {
0:         int c1,c2;
0:         InputStream is1=null,is2=null;
1:         try {
0:             is1 = blob1.getBinaryStream();
0:             is2 = blob2.getBinaryStream();
0:             if(blob1.length()!=blob2.length())
0:                 return false;
0:         } catch(SQLException sqle){
0:             sqle.printStackTrace();
1:         }
1:         try {
0:             for(long i=0;i<blob1.length();i++) {
0:                 c1=is1.read();
0:                 c2=is2.read();
0:                 if(c1!=c2)
0:                     return false;
1:             }
0:         } catch(IOException e) {
0:             e.printStackTrace();
0:         } catch(SQLException e) {
0:             e.printStackTrace();
1:         }
0:         return true;
1:     }
1:     
1:     //-------------------------------------------------
1:     //Test the methods used to test poolable statements
1:     
1:     /**
1:      *
1:      * Tests the PreparedStatement interface method setPoolable
1:      *
1:      * @throws SQLException
1:      */
1:     
1:     public void testSetPoolable() throws SQLException {
1:         try {
1:             // Set the poolable statement hint to false
1:             ps.setPoolable(false);
0:             if (ps.isPoolable())
0:                 fail("Expected a non-poolable statement");
0:             // Set the poolable statement hint to true
1:             ps.setPoolable(true);
0:             if (!ps.isPoolable())
0:                 fail("Expected a poolable statement");
1:         } catch(SQLException sqle) {
1:             // Check which SQLException state we've got and if it is
1:             // expected, do not print a stackTrace
1:             // Embedded uses XJ012, client uses XCL31.
1:             if (sqle.getSQLState().equals("XJ012") ||
1:                 sqle.getSQLState().equals("XCL31")) {
1:                 // All is good and is expected
1:             } else {
1:                 fail("Unexpected SQLException " + sqle);
1:             }
0:         } catch(Exception e) {
0:             fail("Unexpected exception thrown in method " + e);
1:         }
1:     }
1:     
1:     /**
1:      *
1:      * Tests the PreparedStatement interface method isPoolable
1:      *
1:      * @throws SQLException
1:      *
1:      */
1:     
0:     public void testIsPoolable() throws SQLException {
1:         try {
0:             // By default a prepared statement is poolable
0:             if (!ps.isPoolable())
0:                 fail("Expected a poolable statement");
1:         } catch(SQLException sqle) {
1:             // Check which SQLException state we've got and if it is
1:             // expected, do not print a stackTrace
1:             // Embedded uses XJ012, client uses XCL31.
1:             if (sqle.getSQLState().equals("XJ012") ||
1:                 sqle.getSQLState().equals("XCL31")) {
1:                 // All is good and is expected
1:             } else {
1:                 fail("Unexpected SQLException " + sqle);
1:             }
0:         } catch(Exception e) {
0:             fail("Unexpected exception thrown in method " + e);
1:         }
1:     }
1: }
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:2aa7d95
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         // Tests for the client side JDBC statement cache.
1:         suite.addTest(TestConfiguration.clientServerDecorator(
1:                 statementCachingSuite()));
0: 
/////////////////////////////////////////////////////////////////////////
0:     /**
1:      * Returns a suite for tests that need JDBC statement caching to be enabled.
0:      */
1:     private static Test statementCachingSuite() {
0:         TestSuite suite = new TestSuite("JDBC statement caching suite");
1:         suite.addTest(new PreparedStatementTest("cpTestIsPoolableHintFalse"));
1:         suite.addTest(new PreparedStatementTest("cpTestIsPoolableHintTrue"));
1:         return TestConfiguration.connectionCPDecorator(
1:             new CleanDatabaseTestSetup(suite) {
0: 
1:             protected void decorateSQL(Statement stmt)
0:                     throws SQLException {
1:                 stmt.execute("create table " + BLOBTBL +
1:                         " (sno int, dBlob BLOB(1M))");
1:                 stmt.execute("create table " + CLOBTBL +
1:                         " (sno int, dClob CLOB(1M))");
1:                 stmt.execute("create table " + LONGVARCHAR  +
1:                         " (sno int, dLongVarchar LONG VARCHAR)");
0:                  }
1:             });
0:     }
0: 
/////////////////////////////////////////////////////////////////////////
1:     public void testIsPoolableDefault() throws SQLException {
1:      * Tests that the {@code isPoolable}-hint works by exploiting the fact that
1:      * the client cannot prepare a statement referring to a deleted table
1:      * (unless the statement is already in the statement cache).
0:      *
1:      * @throws SQLException if something goes wrong...
0:      */
1:     public void cpTestIsPoolableHintFalse()
0:             throws SQLException {
1:         getConnection().setAutoCommit(false);
1:         // Create a table, insert a row, then create a statement selecting it.
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("create table testispoolablehint (id int)");
1:         stmt.executeUpdate("insert into testispoolablehint values 1");
1:         PreparedStatement ps = prepareStatement(
1:                 "select * from testispoolablehint");
1:         ps.setPoolable(false);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:         // Close statement, which should be discarded.
1:         ps.close();
1:         // Now delete the table.
1:         stmt.executeUpdate("drop table testispoolablehint");
0:         stmt.close();
1:         // Since there is no cached statement, we'll get exception here.
0:         try {
1:             ps = prepareStatement("select * from testispoolablehint");
1:             fail("Prepared statement not valid, referring non-existing table");
0:         } catch (SQLException sqle) {
1:             assertSQLState("42X05", sqle);
0:         }
0:     }
0: 
0:     /**
1:      * Tests that the {@code isPoolable}-hint works by exploiting the fact that
1:      * the client can prepare a statement referring to a deleted table if JDBC
1:      * statement caching is enabled and the statement is already in the cache.
0:      *
1:      * @throws SQLException if something goes wrong...
0:      */
1:     public void cpTestIsPoolableHintTrue()
0:             throws SQLException {
1:         getConnection().setAutoCommit(false);
1:         // Create a table, insert a row, then create a statement selecting it.
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("create table testispoolablehint (id int)");
1:         stmt.executeUpdate("insert into testispoolablehint values 1");
1:         PreparedStatement ps = prepareStatement(
1:                 "select * from testispoolablehint");
0:         ps.setPoolable(true);
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:         // Put the statement into the cache.
1:         ps.close();
1:         // Now delete the table and fetch the cached prepared statement.
1:         stmt.executeUpdate("drop table testispoolablehint");
0:         stmt.close();
1:         ps = prepareStatement("select * from testispoolablehint");
1:         // If we get this far, there is a big change we have fetched an
1:         // invalid statement from the cache, but we won't get the exception
1:         // until we try to execute it.
0:         try {
1:             ps.executeQuery();
1:             fail("Prepared statement not valid, referring non-existing table");
0:         } catch (SQLException sqle) {
1:             assertSQLState("42X05", sqle);
0:         }
0:     }
0: 
0:     /**
commit:93c4b07
/////////////////////////////////////////////////////////////////////////
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:48154b2
/////////////////////////////////////////////////////////////////////////
author:Tomohito Nakayama
-------------------------------------------------------------------------------
commit:fefd864
/////////////////////////////////////////////////////////////////////////
1:             if (usingEmbedded() || 
1:                 usingDerbyNetClient() ) {
/////////////////////////////////////////////////////////////////////////
1:             if (usingEmbedded() || 
1:                 usingDerbyNetClient() ){
0:                 
0:                 
/////////////////////////////////////////////////////////////////////////
1:             if (usingEmbedded()){
0:                 
1:             } else if ( usingDerbyNetClient() ) {
1:                 assertSQLState("XCL30", sqle);
0:                 
0:                 
/////////////////////////////////////////////////////////////////////////
1:             if (usingEmbedded()){
0:                 
1:             } else if( usingDerbyNetClient() ) {
0:                 assertSQLState("XCL30", sqle);
0:                 
0:                 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:ee7f668
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(
1:                 TestConfiguration.connectionXADecorator(
1:                         baseSuite("PreparedStatementTest:embedded XADataSource")));
0:         
0: 
1:         suite.addTest(
1:                 TestConfiguration.clientServerDecorator(
1:                 TestConfiguration.connectionXADecorator(
1:                 baseSuite("PreparedStatementTest:client XXXXADataSource"))));
0: 
1:         return new CleanDatabaseTestSetup(suite) {
1:             protected void decorateSQL(Statement stmt) throws SQLException
1:             {
0:                  }
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite suite = new TestSuite(
0:                 "PreparedStatementTest and SetObjectUnsupportedTest suite");
commit:13e9e78
/////////////////////////////////////////////////////////////////////////
1:     private PreparedStatement ps = null;
1:     private Statement s = null;
/////////////////////////////////////////////////////////////////////////
0:        //create the statement object
1:         s = createStatement();
1:         ps = prepareStatement("select count(*) from sys.systables");
/////////////////////////////////////////////////////////////////////////
1:         throws Exception {
0:         super.tearDown();
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement ps_sc = prepareStatement("insert into ClobTestTable values(?,?)");
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement psChar = prepareStatement(
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement ps_sb = prepareStatement("insert into BlobTestTable values(?,?)");
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement psByte = prepareStatement(
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement ps_sc = prepareStatement("insert into ClobTestTable values(?,?)");
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement psChar = prepareStatement(
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement ps_sb = prepareStatement("insert into ClobTestTable values(?,?)");
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement psAscii = prepareStatement(
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement ps_sb = prepareStatement("insert into BlobTestTable values(?,?)");
/////////////////////////////////////////////////////////////////////////
0:         PreparedStatement psBinary = prepareStatement(
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
============================================================================