1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.OpenBTree
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
6:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1:eac0369: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
1:eac0369: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: import org.apache.derby.iapi.store.access.SpaceInfo;
1:eac0369: import org.apache.derby.iapi.store.raw.ContainerHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.LockingPolicy;
1:eac0369: import org.apache.derby.iapi.store.raw.Transaction;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.types.DataValueDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerateScratchSpace;
1:eac0369: 
1:eac0369: 
1:eac0369: 
3:eac0369: /**
1:eac0369: 
1:eac0369:   An open b-tree contains fields and methods common to scans and controllers.
1:eac0369:   <P>
1:227eaef:   <B>Concurrency Notes</B>
1:eac0369:   <P>
1:eac0369:   An instance of an open b-tree is owned by a single context.  The b-tree code
1:eac0369:   assumes that the context ensures that only one thread at a time is using
1:eac0369:   the open b-tree.  The open b-tree itself does not enforce or check this.
1:eac0369: 
2:eac0369: **/
1:eac0369: 
1:eac0369: public class OpenBTree 
3:eac0369: {
1:eac0369: 	/*
1:eac0369: 	** Fields of OpenBTree
1:eac0369: 	*/
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The following group of fields are all basic input parameters which are
1:eac0369:      * provided by the calling code when doing any sort of operation requiring
1:eac0369:      * an open conglomerate (openScan(), open(), openCostController(), ...).
1:eac0369:      * These are just saved values from what was initially input.
1:eac0369:      **/
1:eac0369:     private BTree                           init_conglomerate;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     The TransactionManager that open'd this btree.  In the case of Internal
1:eac0369:     transactions used by split this will be the internal transaction, and 
1:eac0369:     init_open_user_scans will be the user transaction that began the internal
1:eac0369:     transaction.
1:eac0369:     **/
1:eac0369:     private TransactionManager              init_xact_manager;
1:eac0369: 
1:eac0369:     private Transaction                     init_rawtran;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	The ContainerHandle mode the container is opened with.  Remember this so
1:eac0369: 	that if the BTree needs to do SMO with another transaction, it would open
1:eac0369: 	the container with the same mode.
1:eac0369: 	**/
1:eac0369:     private int                             init_openmode;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Table or page locking?
1:eac0369:     **/
1:eac0369:     protected int                           init_lock_level;
1:eac0369: 
1:eac0369:     private boolean                         init_hold;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     The Locking Policy to use for for access to this btree.
1:eac0369:     **/
1:eac0369:     private BTreeLockingPolicy              init_btree_locking_policy;
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	The (open) container which contains the b-tree.
1:eac0369: 	**/
1:eac0369: 	protected ContainerHandle container;
1:eac0369: 
1:eac0369:     /**
1:eac0369:     The conglomerate containerid for error reporting.
1:eac0369:     **/
1:eac0369:     protected long  err_containerid;
1:eac0369: 
1:86e051f:     /** The user transaction that opened this B-tree. */
1:eac0369:     protected TransactionManager init_open_user_scans = null;
1:eac0369: 
1:eac0369: 
1:eac0369:     protected LogicalUndo btree_undo = null;
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * scratch space used for stuff like templates, export rows, ...
1:eac0369:      **/
1:eac0369:     protected OpenConglomerateScratchSpace  runtime_mem;
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Accessors of This class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369:     public final TransactionManager getXactMgr()
1:eac0369:     {
1:eac0369:         return(init_xact_manager);
2:eac0369:     }
1:eac0369: 
1:eac0369:     public final Transaction getRawTran()
1:eac0369:     {
1:eac0369:         return(init_rawtran);
1:eac0369:     }
1:eac0369:     public final int getLockLevel()
1:eac0369:     {
1:eac0369:         return(init_lock_level);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final ContainerHandle getContainer()
1:eac0369:     {
1:eac0369:         return(container);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final int getOpenMode()
1:eac0369:     {
1:eac0369:         return(init_openmode);
1:eac0369:     }
1:eac0369:     
1:eac0369:     public final BTree getConglomerate()
1:eac0369:     {
1:eac0369:         return(init_conglomerate);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final boolean getHold()
1:eac0369:     {
1:eac0369:         return(init_hold);
1:eac0369:     }
1:eac0369:     public final BTreeLockingPolicy getLockingPolicy()
1:eac0369:     {
1:eac0369:         return(init_btree_locking_policy);
1:eac0369:     }
1:eac0369:     public final void setLockingPolicy(BTreeLockingPolicy policy)
1:eac0369:     {
1:eac0369:         init_btree_locking_policy = policy;
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     public final boolean isClosed()
1:eac0369:     {
1:eac0369:         return(container == null);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public final OpenConglomerateScratchSpace getRuntimeMem()
1:eac0369:     {
1:eac0369:         return(runtime_mem);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of RowCountable class:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the total estimated number of rows in the container.
1:eac0369:      * <p>
1:eac0369:      * The number is a rough estimate and may be grossly off.  In general
1:eac0369:      * the server will cache the row count and then occasionally write
1:eac0369:      * the count unlogged to a backing store.  If the system happens to 
1:eac0369:      * shutdown before the store gets a chance to update the row count it
1:eac0369:      * may wander from reality.
1:eac0369:      * <p>
1:eac0369:      * This call is currently only supported on Heap conglomerates, it
1:eac0369:      * will throw an exception if called on btree conglomerates.
3:eac0369:      *
2:eac0369: 	 * @return The total estimated number of rows in the conglomerate.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public long getEstimatedRowCount()
2:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         if (container == null)
1:eac0369:             reopen();
1:eac0369: 
1:eac0369:         // Don't return 0 rows (return 1 instead), as this often leads the 
1:eac0369:         // optimizer to produce plans which don't use indexes because of the 0 
1:eac0369:         // row edge case.
1:eac0369:         //
1:eac0369:         // Eventually the plan is recompiled when rows are added, but we
1:eac0369:         // have seen multiple customer cases of deadlocks and timeouts 
1:eac0369:         // because of these 0 row based plans.  
1:eac0369:         long row_count = 
1:eac0369:             this.container.getEstimatedRowCount(/* unused flag */ 0);
1:eac0369: 
1:eac0369:         return(row_count == 0 ? 1 : row_count);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Set the total estimated number of rows in the container.
1:eac0369:      * <p>
1:eac0369:      * Often, after a scan, the client of RawStore has a much better estimate
1:eac0369:      * of the number of rows in the container than what store has.  For 
1:eac0369:      * instance if we implement some sort of update statistics command, or
1:eac0369:      * just after a create index a complete scan will have been done of the
1:eac0369:      * table.  In this case this interface allows the client to set the
1:eac0369:      * estimated row count for the container, and store will use that number
1:eac0369:      * for all future references.
1:eac0369:      * <p>
1:eac0369:      * This call is currently only supported on Heap conglomerates, it
1:eac0369:      * will throw an exception if called on btree conglomerates.
1:eac0369:      *
1:eac0369:      * @param count the estimated number of rows in the container.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void setEstimatedRowCount(long count)
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369:         if (container == null)
1:eac0369:             reopen();
1:eac0369: 
1:eac0369:         this.container.setEstimatedRowCount(count, /* unused flag */ 0);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of ConglomerateController interface:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Check consistency of a btree.
1:eac0369:      * <p>
1:eac0369:      * Read in root and check consistency of entire tree.  Currently raises
1:eac0369:      * sanity check errors.
1:eac0369:      * <p>
1:eac0369:      * RESOLVE (mikem) if this is to be supported in non-sanity servers what 
1:eac0369:      * should it do?
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void checkConsistency()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369: 		ControlRow root = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if (this.container == null)
1:eac0369:             {
1:eac0369:                 throw(StandardException.newException(
1:ce40a31:                         SQLState.BTREE_IS_CLOSED, err_containerid));
1:eac0369:             }
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(this.init_conglomerate.format_ids != null);
1:eac0369: 
1:4a2b0d9:             root = ControlRow.get(this, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369:             int actualpages = root.checkConsistency(this, null, true);
1:eac0369: 
1:eac0369:             // RESOLVE (mikem) - anything useful to assert about number of pages
1:eac0369:             // in the tree?
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (root != null)
1:eac0369:                 root.release();
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**************************************************************************
1:eac0369:      * Public Methods of ScanController interface:
1:eac0369:      **************************************************************************
1:eac0369:      */
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * is the open btree table locked?
1:eac0369:      **/
1:eac0369:     public boolean isTableLocked()
1:eac0369:     {
1:eac0369:         return(init_lock_level == TransactionController.MODE_TABLE);
1:eac0369:     }
1:eac0369: 
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of OpenBTree
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	Initialize the open conglomerate.
1:eac0369: 
1:eac0369:     If container is null, open the container, otherwise use the container
1:eac0369:     passed in.
1:eac0369: 
1:eac0369:     @exception StandardException standard exception policy.
1:eac0369: 	**/
1:eac0369:     /**
1:eac0369:      * Initialize the open conglomerate.
1:eac0369:      * <p>
1:eac0369:      * If container is null, open the container, otherwise use the container
1:eac0369:      * passed in.  The container is always opened with no locking, it is up
1:eac0369:      * to the caller to make the appropriate container locking call.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369:      * @param open_user_scans The user transaction which opened this btree.
1:eac0369:      * @param xact_manager    The current transaction, usually the same as
1:eac0369:      *                        "open_user_scans", but in the case of split it
1:eac0369:      *                        is the internal xact nested below the user xact.
1:eac0369:      * @param input_container The open container holding the index, if it is
1:eac0369:      *                        already open, else null which will mean this
1:eac0369:      *                        routine will open it.
1:eac0369:      * @param rawtran         The current raw store transaction.
1:eac0369:      * @param open_mode       The opening mode for the ContainerHandle.
1:eac0369:      * @param conglomerate    Readonly description of the conglomerate.
1:eac0369:      * @param undo            Logical undo object to associate with all updates
1:eac0369:      *                        done on this open btree.
1:eac0369:      *
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369: 	public void init(
1:eac0369:     TransactionManager              open_user_scans,
1:eac0369:     TransactionManager              xact_manager,
1:eac0369:     ContainerHandle                 input_container,
1:eac0369:     Transaction                     rawtran,
1:eac0369:     boolean                         hold,
1:eac0369: 	int                             open_mode,
1:eac0369:     int                             lock_level,
1:eac0369:     BTreeLockingPolicy              btree_locking_policy,
1:eac0369:     BTree                           conglomerate,
1:eac0369:     LogicalUndo                     undo,
1:eac0369:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		// If the b-tree is already open, close it.
1:eac0369: 		if (this.container != null)
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:                 SanityManager.ASSERT(false, "why is the container open?");
1:eac0369: 			close();
1:eac0369:         }
1:eac0369:         err_containerid = conglomerate.id.getContainerId();
1:eac0369: 
1:eac0369:         // Locking policy to pass back to concrete implementation lock calls
1:eac0369:         this.init_btree_locking_policy = btree_locking_policy;
1:eac0369: 
1:eac0369: 		// if the conglomerate is temporary, open with IS_KEPT set.
1:eac0369: 		// RESOLVE(mikem): track 1825
1:eac0369: 		// don't want to open temp cantainer with IS_KEPT always.
1:eac0369: 		if (conglomerate.isTemporary())
1:eac0369: 			open_mode |= ContainerHandle.MODE_TEMP_IS_KEPT;
1:eac0369: 
1:eac0369:         // now open the container if it wasn't already opened by the client.
1:eac0369:         // No locks will be requested by raw store on this open.
1:eac0369:         if (input_container == null)
1:eac0369:         {
1:eac0369:             // Open the container. 
1:eac0369:             this.container = 
1:eac0369:                 rawtran.openContainer(
1:eac0369:                     conglomerate.id, 
1:eac0369:                     (LockingPolicy) null /* get no locks on btree */,
1:eac0369: 					open_mode);
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             // Use the open container passed in.
1:eac0369:             this.container = input_container;
1:eac0369: 
1:eac0369: 			// RESOLVE (sku) - ContainerHandle should have an interface to
1:eac0369: 			// verify that it is opened with open_mode
1:eac0369:         }
1:eac0369: 
1:eac0369: 		if (this.container == null)
1:eac0369:         {
1:eac0369:             throw StandardException.newException(
1:eac0369:                     SQLState.BTREE_CONTAINER_NOT_FOUND,
1:ce40a31:                     err_containerid);
1:eac0369:         }
1:eac0369: 
1:eac0369: 		// Remember the conglomerate so its properties can be found.
1:eac0369:         init_conglomerate   = conglomerate;
1:eac0369: 
1:eac0369:         // Remember the transaction manager so commit() can be called
1:eac0369:         init_xact_manager   = xact_manager;
1:eac0369: 
1:eac0369:         init_rawtran        = rawtran;
1:eac0369: 
1:eac0369:         init_openmode       = open_mode;
1:eac0369: 
1:eac0369:         // Isolation level of this btree.
1:eac0369:         init_lock_level     = lock_level;
1:eac0369: 
1:eac0369:         init_hold           = hold;
1:eac0369: 
1:eac0369: 
1:eac0369:         this.init_open_user_scans = open_user_scans;
1:eac0369: 
1:eac0369:         // Logical undo class to pass to raw store, on inserts/deletes.
1:eac0369:         this.btree_undo = undo;
1:eac0369: 
1:eac0369:         // either use passed in "compiled" runtime scratch space, or create
1:eac0369:         // new space.
1:eac0369:         this.runtime_mem    = 
1:eac0369:             (dynamic_info != null ? 
1:eac0369:              ((OpenConglomerateScratchSpace) dynamic_info) : 
1:9a3cbed:               (OpenConglomerateScratchSpace)
1:9a3cbed:                 conglomerate.getDynamicCompiledConglomInfo());
1:eac0369: 
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Open the container after it has been closed previously.
1:eac0369:      * <p>
1:eac0369:      * Open the container, obtaining necessary locks.  Most work is actually
1:eac0369:      * done by RawStore.openContainer().  Will only reopen() if the container
1:eac0369:      * is not already open.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public ContainerHandle reopen()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         // reget transaction from context manager, in the case of XA
1:eac0369:         // transaction this may have changed.
1:eac0369:         //
1:eac0369:         /* TODO - XA transactions my change the current transaction on the 
1:eac0369:          * context stack.  Will want to something like:
1:eac0369:          *
1:eac0369:          * init_rawtran = context_manager.getcurrenttransaction()
1:eac0369:          */
1:eac0369: 
1:eac0369: 		// If the b-tree is already open, close it.
1:eac0369: 
1:eac0369:         /*
1:eac0369: 		if (this.container != null)
1:eac0369:         {
1:eac0369: 			close();
1:eac0369:         }
1:eac0369:         */
1:eac0369: 
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(init_xact_manager != null);
1:eac0369:             SanityManager.ASSERT(init_xact_manager.getRawStoreXact() != null);
1:eac0369:             SanityManager.ASSERT(init_conglomerate != null);
1:eac0369:         }
1:eac0369:      
1:eac0369:         if (container == null)
1:eac0369:         {
1:eac0369:             // Open the container. 
1:eac0369:             this.container = 
1:eac0369:                 init_xact_manager.getRawStoreXact().openContainer(
1:eac0369:                     init_conglomerate.id, 
1:eac0369:                     (LockingPolicy) null /* get no locks on btree */,
1:eac0369:                     init_openmode);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(this.container);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Close the open conglomerate.
1:eac0369:     **/
1:eac0369:     public void close()
1:eac0369:         throws StandardException
1:eac0369: 	{
1:eac0369: 		if (container != null)
1:eac0369: 			container.close();
1:eac0369: 		container = null;
1:eac0369: 	}
1:eac0369: 
1:eac0369:     /**
1:eac0369:     Check if all the 
1:eac0369:     columns are Indexable and Storable.  Eventually this routine could
1:eac0369:     check whether all the types were right also.
1:eac0369: 
1:eac0369:     @exception StandardException Standard Exception Policy.
1:eac0369:     **/
1:eac0369:     void isIndexableRowConsistent(DataValueDescriptor[] row)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             DataValueDescriptor[] template = 
1:722a889:                 this.init_conglomerate.createTemplate(getRawTran());
1:eac0369: 
1:eac0369:             for (int i = 0; i < row.length; i++)
1:eac0369:             {
1:66ed101:             	//DERBY-5531 If the row column's value is null, then 
1:66ed101:             	// don't worry about the data type match.
1:66ed101:             	if (row[i].isNull())
1:66ed101:             		continue;
1:44aecca:                 // Compare class's rather than format id's to pick up 
1:44aecca:                 // different problems with wrong collation implementation.
1:eac0369: 				if (!row[i].getClass().equals(template[i].getClass()))
1:eac0369:                 {
1:eac0369:                     SanityManager.THROWASSERT(
1:eac0369:                         "type of inserted column[" + i + "] = " + 
1:eac0369:                         row[i].getClass().getName()                +
1:eac0369:                         "type of template column[" + i + "] = " +
1:eac0369:                         template[i].getClass().getName());
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Return the container handle.
1:eac0369:      * <p>
1:eac0369: 	 * @return The open container handle of the btree.
1:eac0369:      **/
1:eac0369:     public ContainerHandle getContainerHandle()
1:eac0369:     {
1:eac0369:         return(container);
1:eac0369:     }
1:eac0369: 	
1:eac0369: 	/**
1:eac0369:      * get height of the tree.
1:eac0369:      * <p>
1:eac0369:      * Read in root and return the height (number of levels) of the tree.
1:eac0369:      * The level of a tree is 0 in the leaf and increases by 1 for each
1:eac0369:      * level of the tree as you go up the tree.  
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public int getHeight()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369: 		// container.checkConsistency();
1:eac0369: 
1:eac0369: 		ControlRow root = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:4a2b0d9:             root = ControlRow.get(this, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369:             int height = root.getLevel() + 1;
1:eac0369: 
1:eac0369:             return(height);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (root != null)
1:eac0369:                 root.release();
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Dump information about tree into the log.
1:eac0369:      * <p>
1:eac0369:      * Traverse the tree dumping info about tree into the log.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public void debugConglomerate()
1:eac0369: 		throws StandardException
1:eac0369:     {
1:eac0369: 		// container.checkConsistency();
1:eac0369: 
1:eac0369: 		ControlRow root = null;
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             if (SanityManager.DEBUG)
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG_PRINT(
1:eac0369:                     "p_tree", "BTREE Dump: containerId " + container.getId());
1:eac0369:                 SanityManager.DEBUG_PRINT(
1:eac0369:                     "p_tree", "BTREE Dump: btree " + this.init_conglomerate);
1:eac0369:             }
1:eac0369: 
1:4a2b0d9:             root = ControlRow.get(this, BTree.ROOTPAGEID);
1:eac0369:             root.printTree(this);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (root != null)
1:eac0369:                 root.release();
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Testing infrastructure to cause unusual paths through the code.
1:eac0369:      * <p>
1:eac0369:      * Through the use of debug flags allow test code to cause otherwise
1:eac0369:      * hard to cause paths through the code.  
1:eac0369:      * <p>
1:eac0369:      *
1:86e051f:      * @param pos the current scan position if the condition simulated by
1:86e051f:      * this call would have resulted in the position being saved
1:eac0369: 	 * @return whether the latch has been released by this routine.
1:eac0369:      *
1:eac0369: 	 * @exception  StandardException  Standard exception policy.
1:eac0369:      **/
1:eac0369:     public static boolean test_errors(
1:eac0369:     OpenBTree           open_btree,
1:eac0369:     String              debug_string,
1:86e051f:     BTreeRowPosition    pos,
1:eac0369:     BTreeLockingPolicy  btree_locking_policy,
1:eac0369:     LeafControlRow      leaf,
1:eac0369:     boolean             input_latch_released)
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         boolean latch_released = input_latch_released;
1:eac0369: 
1:eac0369:         // special test to see if latch release code works
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:             String debug_lost_latch = debug_string + "1";
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG_ON(debug_lost_latch))
1:eac0369:             {
1:eac0369:                 // Simulate a lost latch because of a wait for a lock.
1:eac0369:                 if (!latch_released)
1:eac0369:                 {
1:86e051f:                     if (pos != null) {
1:86e051f:                         SanityManager.ASSERT(pos.current_leaf == leaf);
1:86e051f:                         pos.saveMeAndReleasePage();
1:86e051f:                     } else {
1:86e051f:                         leaf.release();
1:eac0369:                     }
1:eac0369: 
1:eac0369:                     latch_released = true;
1:eac0369:                     SanityManager.DEBUG_PRINT(
1:eac0369:                         debug_lost_latch, debug_lost_latch);
1:eac0369:                     SanityManager.DEBUG_CLEAR(debug_lost_latch);
1:eac0369:                 }
1:eac0369:             }
1:eac0369: 
1:eac0369:             String debug_deadlock = debug_string + "2";
1:eac0369: 
1:eac0369:             if (SanityManager.DEBUG_ON(debug_deadlock))
1:eac0369:             {
1:eac0369:                 SanityManager.DEBUG_PRINT(debug_deadlock, debug_deadlock);
1:eac0369:                 SanityManager.DEBUG_CLEAR(debug_deadlock);
1:eac0369: 
1:eac0369:                 // Simulate a deadlock error.
1:eac0369:                 StandardException se = 
1:eac0369:                     StandardException.newException(
1:eac0369:                         SQLState.DEADLOCK, "fake deadlock", "fake victim");
1:eac0369: 
1:eac0369: 				se.setReport(StandardException.REPORT_ALWAYS);
1:eac0369: 				throw se;
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(latch_released);
1:eac0369:     }
1:eac0369: 
1:eac0369:     public SpaceInfo getSpaceInfo()
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         return container.getSpaceInfo();
1:eac0369:     }
1:eac0369: 
1:eac0369: 	// return column Sort order information
1:eac0369: 	public boolean[] getColumnSortOrderInfo()
1:eac0369: 		throws	StandardException
1:eac0369: 	{
1:eac0369: 		return init_conglomerate.ascDescInfo;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                         SQLState.BTREE_IS_CLOSED, err_containerid));
/////////////////////////////////////////////////////////////////////////
1:                     err_containerid);
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:66ed101
/////////////////////////////////////////////////////////////////////////
1:             	//DERBY-5531 If the row column's value is null, then 
1:             	// don't worry about the data type match.
1:             	if (row[i].isNull())
1:             		continue;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:9a3cbed
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:               (OpenConglomerateScratchSpace)
1:                 conglomerate.getDynamicCompiledConglomInfo());
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:             root = ControlRow.get(this, BTree.ROOTPAGEID);
/////////////////////////////////////////////////////////////////////////
1:             root = ControlRow.get(this, BTree.ROOTPAGEID);
/////////////////////////////////////////////////////////////////////////
1:             root = ControlRow.get(this, BTree.ROOTPAGEID);
commit:fa09146
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:86e051f
/////////////////////////////////////////////////////////////////////////
1:     /** The user transaction that opened this B-tree. */
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:      * @param pos the current scan position if the condition simulated by
1:      * this call would have resulted in the position being saved
/////////////////////////////////////////////////////////////////////////
1:     BTreeRowPosition    pos,
/////////////////////////////////////////////////////////////////////////
1:                     if (pos != null) {
1:                         SanityManager.ASSERT(pos.current_leaf == leaf);
1:                         pos.saveMeAndReleasePage();
1:                     } else {
1:                         leaf.release();
commit:bbcc923
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                             leaf.page.getProtectionRecordHandle());
commit:227eaef
/////////////////////////////////////////////////////////////////////////
1:   <B>Concurrency Notes</B>
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:44aecca
/////////////////////////////////////////////////////////////////////////
1:                 // Compare class's rather than format id's to pick up 
1:                 // different problems with wrong collation implementation.
commit:722a889
/////////////////////////////////////////////////////////////////////////
0:              new OpenConglomerateScratchSpace(
0:                  conglomerate.format_ids, 
0:                  conglomerate.collation_ids));
/////////////////////////////////////////////////////////////////////////
1:                 this.init_conglomerate.createTemplate(getRawTran());
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.OpenBTree
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
1: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
1: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
1: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ScanController;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.store.access.SpaceInfo;
1: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
1: import org.apache.derby.iapi.store.raw.Transaction;
1: 
1: import org.apache.derby.iapi.types.DataValueDescriptor;
1: 
0: import org.apache.derby.iapi.types.RowLocation;
1: 
1: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerateScratchSpace;
1: 
1: 
1: 
1: /**
1: 
1:   An open b-tree contains fields and methods common to scans and controllers.
1:   <P>
0:   <B>Concurrency Notes<\B>
1:   <P>
1:   An instance of an open b-tree is owned by a single context.  The b-tree code
1:   assumes that the context ensures that only one thread at a time is using
1:   the open b-tree.  The open b-tree itself does not enforce or check this.
1: 
1: **/
1: 
1: public class OpenBTree 
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/*
1: 	** Fields of OpenBTree
1: 	*/
1: 
1:     /**
1:      * The following group of fields are all basic input parameters which are
1:      * provided by the calling code when doing any sort of operation requiring
1:      * an open conglomerate (openScan(), open(), openCostController(), ...).
1:      * These are just saved values from what was initially input.
1:      **/
1:     private BTree                           init_conglomerate;
1: 
1:     /**
1:     The TransactionManager that open'd this btree.  In the case of Internal
1:     transactions used by split this will be the internal transaction, and 
1:     init_open_user_scans will be the user transaction that began the internal
1:     transaction.
1:     **/
1:     private TransactionManager              init_xact_manager;
1: 
1:     private Transaction                     init_rawtran;
1: 
1: 	/**
1: 	The ContainerHandle mode the container is opened with.  Remember this so
1: 	that if the BTree needs to do SMO with another transaction, it would open
1: 	the container with the same mode.
1: 	**/
1:     private int                             init_openmode;
1: 
1:     /**
1:     Table or page locking?
1:     **/
1:     protected int                           init_lock_level;
1: 
0:     private DynamicCompiledOpenConglomInfo  init_dynamic_info;
1:     private boolean                         init_hold;
1: 
1:     /**
1:     The Locking Policy to use for for access to this btree.
1:     **/
1:     private BTreeLockingPolicy              init_btree_locking_policy;
1: 
1: 	
1: 	/**
1: 	The (open) container which contains the b-tree.
1: 	**/
1: 	protected ContainerHandle container;
1: 
1:     /**
1:     The conglomerate containerid for error reporting.
1:     **/
1:     protected long  err_containerid;
1: 
1:     /**
0:     In the case of splits, notify all scans in this transaction to save their
0:     current position by key, because the split may move the row they are 
0:     positioned on.  This is done by calling open_user_scans.saveScanPositions().
0:     Note that not all OpenBTree's will have a non-null open_user_scans.  For
0:     instance logical undo of btree operations will get a OpenBTree with a null
0:     open_user_scans, this is all right because this operation should never need
0:     to call saveScanPositions() (ie. it will never do a split).
1:     **/
1:     protected TransactionManager init_open_user_scans = null;
1: 
1: 
1:     protected LogicalUndo btree_undo = null;
1: 
1:     /**
1:      * scratch space used for stuff like templates, export rows, ...
1:      **/
1:     protected OpenConglomerateScratchSpace  runtime_mem;
1: 
1:     /**************************************************************************
1:      * Public Accessors of This class:
1:      **************************************************************************
1:      */
1:     public final TransactionManager getXactMgr()
1:     {
1:         return(init_xact_manager);
1:     }
1: 
1:     public final Transaction getRawTran()
1:     {
1:         return(init_rawtran);
1:     }
1:     public final int getLockLevel()
1:     {
1:         return(init_lock_level);
1:     }
1: 
1:     public final ContainerHandle getContainer()
1:     {
1:         return(container);
1:     }
1: 
1:     public final int getOpenMode()
1:     {
1:         return(init_openmode);
1:     }
1:     
1:     public final BTree getConglomerate()
1:     {
1:         return(init_conglomerate);
1:     }
1: 
1:     public final boolean getHold()
1:     {
1:         return(init_hold);
1:     }
1:     public final BTreeLockingPolicy getLockingPolicy()
1:     {
1:         return(init_btree_locking_policy);
1:     }
1:     public final void setLockingPolicy(BTreeLockingPolicy policy)
1:     {
1:         init_btree_locking_policy = policy;
1:     }
1: 
1: 
1:     public final boolean isClosed()
1:     {
1:         return(container == null);
1:     }
1: 
1:     public final OpenConglomerateScratchSpace getRuntimeMem()
1:     {
1:         return(runtime_mem);
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods of RowCountable class:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Get the total estimated number of rows in the container.
1:      * <p>
1:      * The number is a rough estimate and may be grossly off.  In general
1:      * the server will cache the row count and then occasionally write
1:      * the count unlogged to a backing store.  If the system happens to 
1:      * shutdown before the store gets a chance to update the row count it
1:      * may wander from reality.
1:      * <p>
1:      * This call is currently only supported on Heap conglomerates, it
1:      * will throw an exception if called on btree conglomerates.
1:      *
1: 	 * @return The total estimated number of rows in the conglomerate.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public long getEstimatedRowCount()
1: 		throws StandardException
1:     {
1:         if (container == null)
1:             reopen();
1: 
1:         // Don't return 0 rows (return 1 instead), as this often leads the 
1:         // optimizer to produce plans which don't use indexes because of the 0 
1:         // row edge case.
1:         //
1:         // Eventually the plan is recompiled when rows are added, but we
1:         // have seen multiple customer cases of deadlocks and timeouts 
1:         // because of these 0 row based plans.  
1:         long row_count = 
1:             this.container.getEstimatedRowCount(/* unused flag */ 0);
1: 
1:         return(row_count == 0 ? 1 : row_count);
1:     }
1: 
1:     /**
1:      * Set the total estimated number of rows in the container.
1:      * <p>
1:      * Often, after a scan, the client of RawStore has a much better estimate
1:      * of the number of rows in the container than what store has.  For 
1:      * instance if we implement some sort of update statistics command, or
1:      * just after a create index a complete scan will have been done of the
1:      * table.  In this case this interface allows the client to set the
1:      * estimated row count for the container, and store will use that number
1:      * for all future references.
1:      * <p>
1:      * This call is currently only supported on Heap conglomerates, it
1:      * will throw an exception if called on btree conglomerates.
1:      *
1:      * @param count the estimated number of rows in the container.
1:      *
1: 	 * @return The total estimated number of rows in the conglomerate.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void setEstimatedRowCount(long count)
1: 		throws StandardException
1:     {
1:         if (container == null)
1:             reopen();
1: 
1:         this.container.setEstimatedRowCount(count, /* unused flag */ 0);
1:     }
1: 
1: 
1:     /**************************************************************************
1:      * Public Methods of ConglomerateController interface:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * Check consistency of a btree.
1:      * <p>
1:      * Read in root and check consistency of entire tree.  Currently raises
1:      * sanity check errors.
1:      * <p>
1:      * RESOLVE (mikem) if this is to be supported in non-sanity servers what 
1:      * should it do?
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void checkConsistency()
1: 		throws StandardException
1:     {
1: 		ControlRow root = null;
1: 
1:         try
1:         {
1:             if (this.container == null)
1:             {
1:                 throw(StandardException.newException(
0:                         SQLState.BTREE_IS_CLOSED, new Long(err_containerid)));
1:             }
1: 
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(this.init_conglomerate.format_ids != null);
1: 
0:             root = ControlRow.Get(this, BTree.ROOTPAGEID);
1: 
1:             int actualpages = root.checkConsistency(this, null, true);
1: 
1:             // RESOLVE (mikem) - anything useful to assert about number of pages
1:             // in the tree?
1:         }
1:         finally
1:         {
1:             if (root != null)
1:                 root.release();
1:         }
1:     }
1: 
1:     /**************************************************************************
1:      * Public Methods of ScanController interface:
1:      **************************************************************************
1:      */
1: 
1:     /**
1:      * is the open btree table locked?
1:      **/
1:     public boolean isTableLocked()
1:     {
1:         return(init_lock_level == TransactionController.MODE_TABLE);
1:     }
1: 
1: 
1: 	/*
1: 	** Methods of OpenBTree
1: 	*/
1: 
1: 	/**
1: 	Initialize the open conglomerate.
1: 
1:     If container is null, open the container, otherwise use the container
1:     passed in.
1: 
1:     @exception StandardException standard exception policy.
1: 	**/
1:     /**
1:      * Initialize the open conglomerate.
1:      * <p>
1:      * If container is null, open the container, otherwise use the container
1:      * passed in.  The container is always opened with no locking, it is up
1:      * to the caller to make the appropriate container locking call.
1:      * <p>
1:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
1:      *
1:      * @param open_user_scans The user transaction which opened this btree.
1:      * @param xact_manager    The current transaction, usually the same as
1:      *                        "open_user_scans", but in the case of split it
1:      *                        is the internal xact nested below the user xact.
1:      * @param input_container The open container holding the index, if it is
1:      *                        already open, else null which will mean this
1:      *                        routine will open it.
1:      * @param rawtran         The current raw store transaction.
1:      * @param open_mode       The opening mode for the ContainerHandle.
1:      * @param conglomerate    Readonly description of the conglomerate.
1:      * @param undo            Logical undo object to associate with all updates
1:      *                        done on this open btree.
1:      *
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1: 	public void init(
1:     TransactionManager              open_user_scans,
1:     TransactionManager              xact_manager,
1:     ContainerHandle                 input_container,
1:     Transaction                     rawtran,
1:     boolean                         hold,
1: 	int                             open_mode,
1:     int                             lock_level,
1:     BTreeLockingPolicy              btree_locking_policy,
1:     BTree                           conglomerate,
1:     LogicalUndo                     undo,
1:     DynamicCompiledOpenConglomInfo  dynamic_info)
1:         throws StandardException
1: 	{
1: 		// If the b-tree is already open, close it.
1: 		if (this.container != null)
1:         {
1:             if (SanityManager.DEBUG)
1:                 SanityManager.ASSERT(false, "why is the container open?");
1: 			close();
1:         }
1:         err_containerid = conglomerate.id.getContainerId();
1: 
1:         // Locking policy to pass back to concrete implementation lock calls
1:         this.init_btree_locking_policy = btree_locking_policy;
1: 
1: 		// if the conglomerate is temporary, open with IS_KEPT set.
1: 		// RESOLVE(mikem): track 1825
1: 		// don't want to open temp cantainer with IS_KEPT always.
1: 		if (conglomerate.isTemporary())
1: 			open_mode |= ContainerHandle.MODE_TEMP_IS_KEPT;
1: 
1:         // now open the container if it wasn't already opened by the client.
1:         // No locks will be requested by raw store on this open.
1:         if (input_container == null)
1:         {
1:             // Open the container. 
1:             this.container = 
1:                 rawtran.openContainer(
1:                     conglomerate.id, 
1:                     (LockingPolicy) null /* get no locks on btree */,
1: 					open_mode);
1:         }
1:         else
1:         {
1:             // Use the open container passed in.
1:             this.container = input_container;
1: 
1: 			// RESOLVE (sku) - ContainerHandle should have an interface to
1: 			// verify that it is opened with open_mode
1:         }
1: 
1: 		if (this.container == null)
1:         {
1:             throw StandardException.newException(
1:                     SQLState.BTREE_CONTAINER_NOT_FOUND,
0:                     new Long(err_containerid));
1:         }
1: 
1: 		// Remember the conglomerate so its properties can be found.
1:         init_conglomerate   = conglomerate;
1: 
1:         // Remember the transaction manager so commit() can be called
1:         init_xact_manager   = xact_manager;
1: 
1:         init_rawtran        = rawtran;
1: 
1:         init_openmode       = open_mode;
1: 
1:         // Isolation level of this btree.
1:         init_lock_level     = lock_level;
1: 
0:         init_dynamic_info   = dynamic_info;
1: 
1:         init_hold           = hold;
1: 
1: 
0:         // Remember the transaction manager so saveScanPositions() can be called
1:         this.init_open_user_scans = open_user_scans;
1: 
1:         // Logical undo class to pass to raw store, on inserts/deletes.
1:         this.btree_undo = undo;
1: 
1:         // either use passed in "compiled" runtime scratch space, or create
1:         // new space.
1:         this.runtime_mem    = 
1:             (dynamic_info != null ? 
1:              ((OpenConglomerateScratchSpace) dynamic_info) : 
0:              new OpenConglomerateScratchSpace(conglomerate.format_ids));
1: 
1: 	}
1: 
1:     /**
1:      * Open the container after it has been closed previously.
1:      * <p>
1:      * Open the container, obtaining necessary locks.  Most work is actually
1:      * done by RawStore.openContainer().  Will only reopen() if the container
1:      * is not already open.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public ContainerHandle reopen()
1:         throws StandardException
1:     {
1:         // reget transaction from context manager, in the case of XA
1:         // transaction this may have changed.
1:         //
1:         /* TODO - XA transactions my change the current transaction on the 
1:          * context stack.  Will want to something like:
1:          *
1:          * init_rawtran = context_manager.getcurrenttransaction()
1:          */
1: 
1: 		// If the b-tree is already open, close it.
1: 
1:         /*
1: 		if (this.container != null)
1:         {
1: 			close();
1:         }
1:         */
1: 
1:         if (SanityManager.DEBUG)
1:         {
1:             SanityManager.ASSERT(init_xact_manager != null);
1:             SanityManager.ASSERT(init_xact_manager.getRawStoreXact() != null);
1:             SanityManager.ASSERT(init_conglomerate != null);
1:         }
1:      
1:         if (container == null)
1:         {
1:             // Open the container. 
1:             this.container = 
1:                 init_xact_manager.getRawStoreXact().openContainer(
1:                     init_conglomerate.id, 
1:                     (LockingPolicy) null /* get no locks on btree */,
1:                     init_openmode);
1:         }
1: 
1:         return(this.container);
1:     }
1: 
1:     /**
1:     Close the open conglomerate.
1:     **/
1:     public void close()
1:         throws StandardException
1: 	{
1: 		if (container != null)
1: 			container.close();
1: 		container = null;
1: 	}
1: 
1:     /**
1:     Check if all the 
1:     columns are Indexable and Storable.  Eventually this routine could
1:     check whether all the types were right also.
1: 
1:     @exception StandardException Standard Exception Policy.
1:     **/
1:     void isIndexableRowConsistent(DataValueDescriptor[] row)
1:         throws StandardException
1:     {
1:         if (SanityManager.DEBUG)
1:         {
1:             DataValueDescriptor[] template = 
0:                 this.init_conglomerate.createTemplate();
1: 
0:             // RESOLVE - could just compare format id's rather than allocate
0:             // objects.
1: 
1:             for (int i = 0; i < row.length; i++)
1:             {
0:                 // RESOLVE (mikem) - use format id's for more efficient test.
1: 				if (!row[i].getClass().equals(template[i].getClass()))
1:                 {
1:                     SanityManager.THROWASSERT(
1:                         "type of inserted column[" + i + "] = " + 
1:                         row[i].getClass().getName()                +
1:                         "type of template column[" + i + "] = " +
1:                         template[i].getClass().getName());
1:                 }
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Return the container handle.
1:      * <p>
1: 	 * @return The open container handle of the btree.
1:      **/
1:     public ContainerHandle getContainerHandle()
1:     {
1:         return(container);
1:     }
1: 	
1: 	/**
1:      * get height of the tree.
1:      * <p>
1:      * Read in root and return the height (number of levels) of the tree.
1:      * The level of a tree is 0 in the leaf and increases by 1 for each
1:      * level of the tree as you go up the tree.  
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public int getHeight()
1: 		throws StandardException
1:     {
1: 		// container.checkConsistency();
1: 
1: 		ControlRow root = null;
1: 
1:         try
1:         {
0:             root = ControlRow.Get(this, BTree.ROOTPAGEID);
1: 
1:             int height = root.getLevel() + 1;
1: 
1:             return(height);
1:         }
1:         finally
1:         {
1:             if (root != null)
1:                 root.release();
1:         }
1:     }
1: 
0:     public RecordHandle makeRecordHandle(
0:     long    page_number,
0:     int     rec_id)
1:         throws StandardException
1:     {
0:         return(
0:             container.makeRecordHandle(
0:                 page_number, rec_id));
1:     }
1: 
1:     /**
1:      * Dump information about tree into the log.
1:      * <p>
1:      * Traverse the tree dumping info about tree into the log.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public void debugConglomerate()
1: 		throws StandardException
1:     {
1: 		// container.checkConsistency();
1: 
1: 		ControlRow root = null;
1: 
1:         try
1:         {
1:             if (SanityManager.DEBUG)
1:             {
1:                 SanityManager.DEBUG_PRINT(
1:                     "p_tree", "BTREE Dump: containerId " + container.getId());
1:                 SanityManager.DEBUG_PRINT(
1:                     "p_tree", "BTREE Dump: btree " + this.init_conglomerate);
1:             }
1: 
0:             root = ControlRow.Get(this, BTree.ROOTPAGEID);
1:             root.printTree(this);
1:         }
1:         finally
1:         {
1:             if (root != null)
1:                 root.release();
1:         }
1:     }
1: 
1:     /**
1:      * Testing infrastructure to cause unusual paths through the code.
1:      * <p>
1:      * Through the use of debug flags allow test code to cause otherwise
1:      * hard to cause paths through the code.  
1:      * <p>
1:      *
1: 	 * @return whether the latch has been released by this routine.
1:      *
1: 	 * @exception  StandardException  Standard exception policy.
1:      **/
1:     public static boolean test_errors(
1:     OpenBTree           open_btree,
1:     String              debug_string,
0:     boolean             release_scan_lock,
1:     BTreeLockingPolicy  btree_locking_policy,
1:     LeafControlRow      leaf,
1:     boolean             input_latch_released)
1:         throws StandardException
1:     {
1:         boolean latch_released = input_latch_released;
1: 
1:         // special test to see if latch release code works
1:         if (SanityManager.DEBUG)
1:         {
1:             String debug_lost_latch = debug_string + "1";
1: 
1:             if (SanityManager.DEBUG_ON(debug_lost_latch))
1:             {
1:                 // Simulate a lost latch because of a wait for a lock.
1:                 if (!latch_released)
1:                 {
0:                     if (release_scan_lock)
1:                     {
0:                         btree_locking_policy.unlockScan(
0:                             leaf.page.getPageNumber());
1:                     }
0:                     leaf.release();
1: 
1:                     latch_released = true;
1:                     SanityManager.DEBUG_PRINT(
1:                         debug_lost_latch, debug_lost_latch);
1:                     SanityManager.DEBUG_CLEAR(debug_lost_latch);
1:                 }
1:             }
1: 
1:             String debug_deadlock = debug_string + "2";
1: 
1:             if (SanityManager.DEBUG_ON(debug_deadlock))
1:             {
1:                 SanityManager.DEBUG_PRINT(debug_deadlock, debug_deadlock);
1:                 SanityManager.DEBUG_CLEAR(debug_deadlock);
1: 
1:                 // Simulate a deadlock error.
1:                 StandardException se = 
1:                     StandardException.newException(
1:                         SQLState.DEADLOCK, "fake deadlock", "fake victim");
1: 
1: 				se.setReport(StandardException.REPORT_ALWAYS);
1: 				throw se;
1:             }
1:         }
1: 
1:         return(latch_released);
1:     }
1: 
1:     public SpaceInfo getSpaceInfo()
1:         throws StandardException
1:     {
1:         return container.getSpaceInfo();
1:     }
1: 
1: 	// return column Sort order information
1: 	public boolean[] getColumnSortOrderInfo()
1: 		throws	StandardException
1: 	{
1: 		return init_conglomerate.ascDescInfo;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.store.access.conglomerate.Conglomerate;
0: import org.apache.derby.iapi.store.access.conglomerate.LogicalUndo;
0: import org.apache.derby.iapi.store.access.conglomerate.TransactionManager;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.DynamicCompiledOpenConglomInfo;
0: import org.apache.derby.iapi.store.access.Qualifier;
0: import org.apache.derby.iapi.store.access.ScanController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.access.SpaceInfo;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.LockingPolicy;
0: import org.apache.derby.iapi.store.raw.RecordHandle;
0: import org.apache.derby.iapi.store.raw.Transaction;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: 
0: import org.apache.derby.iapi.types.RowLocation;
0: 
0: import org.apache.derby.impl.store.access.conglomerate.OpenConglomerateScratchSpace;
0: 
0: 
0: 
0: /**
0: 
0:   An open b-tree contains fields and methods common to scans and controllers.
0:   <P>
0:   <B>Concurrency Notes<\B>
0:   <P>
0:   An instance of an open b-tree is owned by a single context.  The b-tree code
0:   assumes that the context ensures that only one thread at a time is using
0:   the open b-tree.  The open b-tree itself does not enforce or check this.
0: 
0: **/
0: 
0: public class OpenBTree 
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/*
0: 	** Fields of OpenBTree
0: 	*/
0: 
0:     /**
0:      * The following group of fields are all basic input parameters which are
0:      * provided by the calling code when doing any sort of operation requiring
0:      * an open conglomerate (openScan(), open(), openCostController(), ...).
0:      * These are just saved values from what was initially input.
0:      **/
0:     private BTree                           init_conglomerate;
0: 
0:     /**
0:     The TransactionManager that open'd this btree.  In the case of Internal
0:     transactions used by split this will be the internal transaction, and 
0:     init_open_user_scans will be the user transaction that began the internal
0:     transaction.
0:     **/
0:     private TransactionManager              init_xact_manager;
0: 
0:     private Transaction                     init_rawtran;
0: 
0: 	/**
0: 	The ContainerHandle mode the container is opened with.  Remember this so
0: 	that if the BTree needs to do SMO with another transaction, it would open
0: 	the container with the same mode.
0: 	**/
0:     private int                             init_openmode;
0: 
0:     /**
0:     Table or page locking?
0:     **/
0:     protected int                           init_lock_level;
0: 
0:     private DynamicCompiledOpenConglomInfo  init_dynamic_info;
0:     private boolean                         init_hold;
0: 
0:     /**
0:     The Locking Policy to use for for access to this btree.
0:     **/
0:     private BTreeLockingPolicy              init_btree_locking_policy;
0: 
0: 	
0: 	/**
0: 	The (open) container which contains the b-tree.
0: 	**/
0: 	protected ContainerHandle container;
0: 
0:     /**
0:     The conglomerate containerid for error reporting.
0:     **/
0:     protected long  err_containerid;
0: 
0:     /**
0:     In the case of splits, notify all scans in this transaction to save their
0:     current position by key, because the split may move the row they are 
0:     positioned on.  This is done by calling open_user_scans.saveScanPositions().
0:     Note that not all OpenBTree's will have a non-null open_user_scans.  For
0:     instance logical undo of btree operations will get a OpenBTree with a null
0:     open_user_scans, this is all right because this operation should never need
0:     to call saveScanPositions() (ie. it will never do a split).
0:     **/
0:     protected TransactionManager init_open_user_scans = null;
0: 
0: 
0:     protected LogicalUndo btree_undo = null;
0: 
0:     /**
0:      * scratch space used for stuff like templates, export rows, ...
0:      **/
0:     protected OpenConglomerateScratchSpace  runtime_mem;
0: 
0:     /**************************************************************************
0:      * Public Accessors of This class:
0:      **************************************************************************
0:      */
0:     public final TransactionManager getXactMgr()
0:     {
0:         return(init_xact_manager);
0:     }
0: 
0:     public final Transaction getRawTran()
0:     {
0:         return(init_rawtran);
0:     }
0:     public final int getLockLevel()
0:     {
0:         return(init_lock_level);
0:     }
0: 
0:     public final ContainerHandle getContainer()
0:     {
0:         return(container);
0:     }
0: 
0:     public final int getOpenMode()
0:     {
0:         return(init_openmode);
0:     }
0:     
0:     public final BTree getConglomerate()
0:     {
0:         return(init_conglomerate);
0:     }
0: 
0:     public final boolean getHold()
0:     {
0:         return(init_hold);
0:     }
0:     public final BTreeLockingPolicy getLockingPolicy()
0:     {
0:         return(init_btree_locking_policy);
0:     }
0:     public final void setLockingPolicy(BTreeLockingPolicy policy)
0:     {
0:         init_btree_locking_policy = policy;
0:     }
0: 
0: 
0:     public final boolean isClosed()
0:     {
0:         return(container == null);
0:     }
0: 
0:     public final OpenConglomerateScratchSpace getRuntimeMem()
0:     {
0:         return(runtime_mem);
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods of RowCountable class:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Get the total estimated number of rows in the container.
0:      * <p>
0:      * The number is a rough estimate and may be grossly off.  In general
0:      * the server will cache the row count and then occasionally write
0:      * the count unlogged to a backing store.  If the system happens to 
0:      * shutdown before the store gets a chance to update the row count it
0:      * may wander from reality.
0:      * <p>
0:      * This call is currently only supported on Heap conglomerates, it
0:      * will throw an exception if called on btree conglomerates.
0:      *
0: 	 * @return The total estimated number of rows in the conglomerate.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public long getEstimatedRowCount()
0: 		throws StandardException
0:     {
0:         if (container == null)
0:             reopen();
0: 
0:         // Don't return 0 rows (return 1 instead), as this often leads the 
0:         // optimizer to produce plans which don't use indexes because of the 0 
0:         // row edge case.
0:         //
0:         // Eventually the plan is recompiled when rows are added, but we
0:         // have seen multiple customer cases of deadlocks and timeouts 
0:         // because of these 0 row based plans.  
0:         long row_count = 
0:             this.container.getEstimatedRowCount(/* unused flag */ 0);
0: 
0:         return(row_count == 0 ? 1 : row_count);
0:     }
0: 
0:     /**
0:      * Set the total estimated number of rows in the container.
0:      * <p>
0:      * Often, after a scan, the client of RawStore has a much better estimate
0:      * of the number of rows in the container than what store has.  For 
0:      * instance if we implement some sort of update statistics command, or
0:      * just after a create index a complete scan will have been done of the
0:      * table.  In this case this interface allows the client to set the
0:      * estimated row count for the container, and store will use that number
0:      * for all future references.
0:      * <p>
0:      * This call is currently only supported on Heap conglomerates, it
0:      * will throw an exception if called on btree conglomerates.
0:      *
0:      * @param count the estimated number of rows in the container.
0:      *
0: 	 * @return The total estimated number of rows in the conglomerate.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void setEstimatedRowCount(long count)
0: 		throws StandardException
0:     {
0:         if (container == null)
0:             reopen();
0: 
0:         this.container.setEstimatedRowCount(count, /* unused flag */ 0);
0:     }
0: 
0: 
0:     /**************************************************************************
0:      * Public Methods of ConglomerateController interface:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * Check consistency of a btree.
0:      * <p>
0:      * Read in root and check consistency of entire tree.  Currently raises
0:      * sanity check errors.
0:      * <p>
0:      * RESOLVE (mikem) if this is to be supported in non-sanity servers what 
0:      * should it do?
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void checkConsistency()
0: 		throws StandardException
0:     {
0: 		ControlRow root = null;
0: 
0:         try
0:         {
0:             if (this.container == null)
0:             {
0:                 throw(StandardException.newException(
0:                         SQLState.BTREE_IS_CLOSED, new Long(err_containerid)));
0:             }
0: 
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(this.init_conglomerate.format_ids != null);
0: 
0:             root = ControlRow.Get(this, BTree.ROOTPAGEID);
0: 
0:             int actualpages = root.checkConsistency(this, null, true);
0: 
0:             // RESOLVE (mikem) - anything useful to assert about number of pages
0:             // in the tree?
0:         }
0:         finally
0:         {
0:             if (root != null)
0:                 root.release();
0:         }
0:     }
0: 
0:     /**************************************************************************
0:      * Public Methods of ScanController interface:
0:      **************************************************************************
0:      */
0: 
0:     /**
0:      * is the open btree table locked?
0:      **/
0:     public boolean isTableLocked()
0:     {
0:         return(init_lock_level == TransactionController.MODE_TABLE);
0:     }
0: 
0: 
0: 	/*
0: 	** Methods of OpenBTree
0: 	*/
0: 
0: 	/**
0: 	Initialize the open conglomerate.
0: 
0:     If container is null, open the container, otherwise use the container
0:     passed in.
0: 
0:     @exception StandardException standard exception policy.
0: 	**/
0:     /**
0:      * Initialize the open conglomerate.
0:      * <p>
0:      * If container is null, open the container, otherwise use the container
0:      * passed in.  The container is always opened with no locking, it is up
0:      * to the caller to make the appropriate container locking call.
0:      * <p>
0:      *
0: 	 * @return The identifier to be used to open the conglomerate later.
0:      *
0:      * @param open_user_scans The user transaction which opened this btree.
0:      * @param xact_manager    The current transaction, usually the same as
0:      *                        "open_user_scans", but in the case of split it
0:      *                        is the internal xact nested below the user xact.
0:      * @param input_container The open container holding the index, if it is
0:      *                        already open, else null which will mean this
0:      *                        routine will open it.
0:      * @param rawtran         The current raw store transaction.
0:      * @param open_mode       The opening mode for the ContainerHandle.
0:      * @param conglomerate    Readonly description of the conglomerate.
0:      * @param undo            Logical undo object to associate with all updates
0:      *                        done on this open btree.
0:      *
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0: 	public void init(
0:     TransactionManager              open_user_scans,
0:     TransactionManager              xact_manager,
0:     ContainerHandle                 input_container,
0:     Transaction                     rawtran,
0:     boolean                         hold,
0: 	int                             open_mode,
0:     int                             lock_level,
0:     BTreeLockingPolicy              btree_locking_policy,
0:     BTree                           conglomerate,
0:     LogicalUndo                     undo,
0:     DynamicCompiledOpenConglomInfo  dynamic_info)
0:         throws StandardException
0: 	{
0: 		// If the b-tree is already open, close it.
0: 		if (this.container != null)
0:         {
0:             if (SanityManager.DEBUG)
0:                 SanityManager.ASSERT(false, "why is the container open?");
0: 			close();
0:         }
0:         err_containerid = conglomerate.id.getContainerId();
0: 
0:         // Locking policy to pass back to concrete implementation lock calls
0:         this.init_btree_locking_policy = btree_locking_policy;
0: 
0: 		// if the conglomerate is temporary, open with IS_KEPT set.
0: 		// RESOLVE(mikem): track 1825
0: 		// don't want to open temp cantainer with IS_KEPT always.
0: 		if (conglomerate.isTemporary())
0: 			open_mode |= ContainerHandle.MODE_TEMP_IS_KEPT;
0: 
0:         // now open the container if it wasn't already opened by the client.
0:         // No locks will be requested by raw store on this open.
0:         if (input_container == null)
0:         {
0:             // Open the container. 
0:             this.container = 
0:                 rawtran.openContainer(
0:                     conglomerate.id, 
0:                     (LockingPolicy) null /* get no locks on btree */,
0: 					open_mode);
0:         }
0:         else
0:         {
0:             // Use the open container passed in.
0:             this.container = input_container;
0: 
0: 			// RESOLVE (sku) - ContainerHandle should have an interface to
0: 			// verify that it is opened with open_mode
0:         }
0: 
0: 		if (this.container == null)
0:         {
0:             throw StandardException.newException(
0:                     SQLState.BTREE_CONTAINER_NOT_FOUND,
0:                     new Long(err_containerid));
0:         }
0: 
0: 		// Remember the conglomerate so its properties can be found.
0:         init_conglomerate   = conglomerate;
0: 
0:         // Remember the transaction manager so commit() can be called
0:         init_xact_manager   = xact_manager;
0: 
0:         init_rawtran        = rawtran;
0: 
0:         init_openmode       = open_mode;
0: 
0:         // Isolation level of this btree.
0:         init_lock_level     = lock_level;
0: 
0:         init_dynamic_info   = dynamic_info;
0: 
0:         init_hold           = hold;
0: 
0: 
0:         // Remember the transaction manager so saveScanPositions() can be called
0:         this.init_open_user_scans = open_user_scans;
0: 
0:         // Logical undo class to pass to raw store, on inserts/deletes.
0:         this.btree_undo = undo;
0: 
0:         // either use passed in "compiled" runtime scratch space, or create
0:         // new space.
0:         this.runtime_mem    = 
0:             (dynamic_info != null ? 
0:              ((OpenConglomerateScratchSpace) dynamic_info) : 
0:              new OpenConglomerateScratchSpace(conglomerate.format_ids));
0: 
0: 	}
0: 
0:     /**
0:      * Open the container after it has been closed previously.
0:      * <p>
0:      * Open the container, obtaining necessary locks.  Most work is actually
0:      * done by RawStore.openContainer().  Will only reopen() if the container
0:      * is not already open.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public ContainerHandle reopen()
0:         throws StandardException
0:     {
0:         // reget transaction from context manager, in the case of XA
0:         // transaction this may have changed.
0:         //
0:         /* TODO - XA transactions my change the current transaction on the 
0:          * context stack.  Will want to something like:
0:          *
0:          * init_rawtran = context_manager.getcurrenttransaction()
0:          */
0: 
0: 		// If the b-tree is already open, close it.
0: 
0:         /*
0: 		if (this.container != null)
0:         {
0: 			close();
0:         }
0:         */
0: 
0:         if (SanityManager.DEBUG)
0:         {
0:             SanityManager.ASSERT(init_xact_manager != null);
0:             SanityManager.ASSERT(init_xact_manager.getRawStoreXact() != null);
0:             SanityManager.ASSERT(init_conglomerate != null);
0:         }
0:      
0:         if (container == null)
0:         {
0:             // Open the container. 
0:             this.container = 
0:                 init_xact_manager.getRawStoreXact().openContainer(
0:                     init_conglomerate.id, 
0:                     (LockingPolicy) null /* get no locks on btree */,
0:                     init_openmode);
0:         }
0: 
0:         return(this.container);
0:     }
0: 
0:     /**
0:     Close the open conglomerate.
0:     **/
0:     public void close()
0:         throws StandardException
0: 	{
0: 		if (container != null)
0: 			container.close();
0: 		container = null;
0: 	}
0: 
0:     /**
0:     Check if all the 
0:     columns are Indexable and Storable.  Eventually this routine could
0:     check whether all the types were right also.
0: 
0:     @exception StandardException Standard Exception Policy.
0:     **/
0:     void isIndexableRowConsistent(DataValueDescriptor[] row)
0:         throws StandardException
0:     {
0:         if (SanityManager.DEBUG)
0:         {
0:             DataValueDescriptor[] template = 
0:                 this.init_conglomerate.createTemplate();
0: 
0:             // RESOLVE - could just compare format id's rather than allocate
0:             // objects.
0: 
0:             for (int i = 0; i < row.length; i++)
0:             {
0:                 // RESOLVE (mikem) - use format id's for more efficient test.
0: 				if (!row[i].getClass().equals(template[i].getClass()))
0:                 {
0:                     SanityManager.THROWASSERT(
0:                         "type of inserted column[" + i + "] = " + 
0:                         row[i].getClass().getName()                +
0:                         "type of template column[" + i + "] = " +
0:                         template[i].getClass().getName());
0:                 }
0:             }
0:         }
0:     }
0: 
0:     /**
0:      * Return the container handle.
0:      * <p>
0: 	 * @return The open container handle of the btree.
0:      **/
0:     public ContainerHandle getContainerHandle()
0:     {
0:         return(container);
0:     }
0: 	
0: 	/**
0:      * get height of the tree.
0:      * <p>
0:      * Read in root and return the height (number of levels) of the tree.
0:      * The level of a tree is 0 in the leaf and increases by 1 for each
0:      * level of the tree as you go up the tree.  
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public int getHeight()
0: 		throws StandardException
0:     {
0: 		// container.checkConsistency();
0: 
0: 		ControlRow root = null;
0: 
0:         try
0:         {
0:             root = ControlRow.Get(this, BTree.ROOTPAGEID);
0: 
0:             int height = root.getLevel() + 1;
0: 
0:             return(height);
0:         }
0:         finally
0:         {
0:             if (root != null)
0:                 root.release();
0:         }
0:     }
0: 
0:     public RecordHandle makeRecordHandle(
0:     long    page_number,
0:     int     rec_id)
0:         throws StandardException
0:     {
0:         return(
0:             container.makeRecordHandle(
0:                 page_number, rec_id));
0:     }
0: 
0:     /**
0:      * Dump information about tree into the log.
0:      * <p>
0:      * Traverse the tree dumping info about tree into the log.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public void debugConglomerate()
0: 		throws StandardException
0:     {
0: 		// container.checkConsistency();
0: 
0: 		ControlRow root = null;
0: 
0:         try
0:         {
0:             if (SanityManager.DEBUG)
0:             {
0:                 SanityManager.DEBUG_PRINT(
0:                     "p_tree", "BTREE Dump: containerId " + container.getId());
0:                 SanityManager.DEBUG_PRINT(
0:                     "p_tree", "BTREE Dump: btree " + this.init_conglomerate);
0:             }
0: 
0:             root = ControlRow.Get(this, BTree.ROOTPAGEID);
0:             root.printTree(this);
0:         }
0:         finally
0:         {
0:             if (root != null)
0:                 root.release();
0:         }
0:     }
0: 
0:     /**
0:      * Testing infrastructure to cause unusual paths through the code.
0:      * <p>
0:      * Through the use of debug flags allow test code to cause otherwise
0:      * hard to cause paths through the code.  
0:      * <p>
0:      *
0: 	 * @return whether the latch has been released by this routine.
0:      *
0: 	 * @exception  StandardException  Standard exception policy.
0:      **/
0:     public static boolean test_errors(
0:     OpenBTree           open_btree,
0:     String              debug_string,
0:     boolean             release_scan_lock,
0:     BTreeLockingPolicy  btree_locking_policy,
0:     LeafControlRow      leaf,
0:     boolean             input_latch_released)
0:         throws StandardException
0:     {
0:         boolean latch_released = input_latch_released;
0: 
0:         // special test to see if latch release code works
0:         if (SanityManager.DEBUG)
0:         {
0:             String debug_lost_latch = debug_string + "1";
0: 
0:             if (SanityManager.DEBUG_ON(debug_lost_latch))
0:             {
0:                 // Simulate a lost latch because of a wait for a lock.
0:                 if (!latch_released)
0:                 {
0:                     if (release_scan_lock)
0:                     {
0:                         btree_locking_policy.unlockScan(
0:                             leaf.page.getPageNumber());
0:                     }
0:                     leaf.release();
0: 
0:                     latch_released = true;
0:                     SanityManager.DEBUG_PRINT(
0:                         debug_lost_latch, debug_lost_latch);
0:                     SanityManager.DEBUG_CLEAR(debug_lost_latch);
0:                 }
0:             }
0: 
0:             String debug_deadlock = debug_string + "2";
0: 
0:             if (SanityManager.DEBUG_ON(debug_deadlock))
0:             {
0:                 SanityManager.DEBUG_PRINT(debug_deadlock, debug_deadlock);
0:                 SanityManager.DEBUG_CLEAR(debug_deadlock);
0: 
0:                 // Simulate a deadlock error.
0:                 StandardException se = 
0:                     StandardException.newException(
0:                         SQLState.DEADLOCK, "fake deadlock", "fake victim");
0: 
0: 				se.setReport(StandardException.REPORT_ALWAYS);
0: 				throw se;
0:             }
0:         }
0: 
0:         return(latch_released);
0:     }
0: 
0:     public SpaceInfo getSpaceInfo()
0:         throws StandardException
0:     {
0:         return container.getSpaceInfo();
0:     }
0: 
0: 	// return column Sort order information
0: 	public boolean[] getColumnSortOrderInfo()
0: 		throws	StandardException
0: 	{
0: 		return init_conglomerate.ascDescInfo;
0: 	}
0: }
============================================================================