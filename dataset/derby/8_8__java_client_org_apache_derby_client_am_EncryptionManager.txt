1:33776ff: /*
37:33776ff: 
1:33776ff:    Derby - Class org.apache.derby.client.am.EncryptionManager
1:33776ff: 
1:59bf37d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:59bf37d:    contributor license agreements.  See the NOTICE file distributed with
1:59bf37d:    this work for additional information regarding copyright ownership.
1:59bf37d:    The ASF licenses this file to You under the Apache License, Version 2.0
1:59bf37d:    (the "License"); you may not use this file except in compliance with
1:59bf37d:    the License.  You may obtain a copy of the License at
1:33776ff: 
1:33776ff:       http://www.apache.org/licenses/LICENSE-2.0
1:33776ff: 
1:33776ff:    Unless required by applicable law or agreed to in writing, software
1:33776ff:    distributed under the License is distributed on an "AS IS" BASIS,
1:33776ff:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:33776ff:    See the License for the specific language governing permissions and
1:33776ff:    limitations under the License.
1:33776ff: 
1:7233e33: */
1:33776ff: 
1:33776ff: package org.apache.derby.client.am;
1:70f7692: 
1:69e3d06: import java.math.BigInteger;
1:69e3d06: import java.security.GeneralSecurityException;
1:69e3d06: import java.security.Key;
1:69e3d06: import java.security.KeyFactory;
1:69e3d06: import java.security.KeyPair;
1:69e3d06: import java.security.KeyPairGenerator;
1:69e3d06: import java.security.MessageDigest;
1:69e3d06: import java.security.NoSuchAlgorithmException;
1:69e3d06: import java.security.NoSuchProviderException;
1:33776ff: import java.security.Provider;
1:69e3d06: import java.security.PublicKey;
1:69e3d06: import java.security.SecureRandom;
1:70f7692: import java.security.Security;
1:69e3d06: import javax.crypto.BadPaddingException;
1:69e3d06: import javax.crypto.Cipher;
1:69e3d06: import javax.crypto.IllegalBlockSizeException;
1:69e3d06: import javax.crypto.KeyAgreement;
1:69e3d06: import javax.crypto.NoSuchPaddingException;
1:69e3d06: import javax.crypto.SecretKeyFactory;
1:69e3d06: import javax.crypto.interfaces.DHPublicKey;
1:69e3d06: import javax.crypto.spec.DESKeySpec;
1:69e3d06: import javax.crypto.spec.DHParameterSpec;
1:69e3d06: import javax.crypto.spec.DHPublicKeySpec;
1:69e3d06: import javax.crypto.spec.IvParameterSpec;
1:69e3d06: import javax.crypto.spec.SecretKeySpec;
1:486829c: import org.apache.derby.shared.common.reference.SQLState;
1:7233e33: import org.apache.derby.shared.common.sanity.SanityManager;
1:486829c: 
1:33776ff: // This class is get used when using encrypted password and/or userid mechanism.
1:33776ff: // The <b>EncryptionManager</b> classs uses Diffie_Hellman algorithm to get the publick key and
1:33776ff: // secret key, and then DES encryption is done using certain token (based on security
1:33776ff: // mechanism) and server side's public key. Basically, this class is called when using
1:33776ff: // security mechanism User ID and encrypted password (usrencpwd) and Encrypted user ID and password
1:33776ff: // (eusridpwd).
1:33776ff: // This class uses JCE provider to do Diffie_Hellman algorithm and DES encryption,
1:33776ff: // obtainPublicKey(), calculateEncryptionToken(int, byte[]) and encryptData(byte[], int, byte[], byte[])
1:33776ff: // The agreed public value for the Diffie-Hellman prime is 256 bits
1:33776ff: // and hence the encrytion will work only if the jce provider supports a 256 bits prime
1:7233e33: //
1:7233e33: // This class also have methods for the SECMEC_USRSSBPWD security mechanism.
1:33776ff: 
1:70f7692: public class EncryptionManager {
1:ee33904:      // for obtaining an exception log writer only
1:ee33904:     private transient Agent agent_;
1:33776ff: 
1:70f7692:     // PROTOCOL's Diffie-Hellman agreed public value: prime.
1:70f7692:     private static final byte modulusBytes__[] = {
1:70f7692:         (byte) 0xC6, (byte) 0x21, (byte) 0x12, (byte) 0xD7,
1:70f7692:         (byte) 0x3E, (byte) 0xE6, (byte) 0x13, (byte) 0xF0,
1:70f7692:         (byte) 0x94, (byte) 0x7A, (byte) 0xB3, (byte) 0x1F,
1:70f7692:         (byte) 0x0F, (byte) 0x68, (byte) 0x46, (byte) 0xA1,
1:70f7692:         (byte) 0xBF, (byte) 0xF5, (byte) 0xB3, (byte) 0xA4,
1:70f7692:         (byte) 0xCA, (byte) 0x0D, (byte) 0x60, (byte) 0xBC,
1:70f7692:         (byte) 0x1E, (byte) 0x4C, (byte) 0x7A, (byte) 0x0D,
1:70f7692:         (byte) 0x8C, (byte) 0x16, (byte) 0xB3, (byte) 0xE3
1:70f7692:     };
1:33776ff: 
1:70f7692:     //the prime value in BigInteger form. It has to be in BigInteger form because this
1:70f7692:     //is the form used in JCE library.
1:69e3d06:     private static final BigInteger modulus__
1:69e3d06:             = new BigInteger(1, modulusBytes__);
1:33776ff: 
1:70f7692:     //  PROTOCOL's Diffie-Hellman agreed public value: base.
1:70f7692:     private static final byte baseBytes__[] = {
1:70f7692:         (byte) 0x46, (byte) 0x90, (byte) 0xFA, (byte) 0x1F,
1:70f7692:         (byte) 0x7B, (byte) 0x9E, (byte) 0x1D, (byte) 0x44,
1:70f7692:         (byte) 0x42, (byte) 0xC8, (byte) 0x6C, (byte) 0x91,
1:70f7692:         (byte) 0x14, (byte) 0x60, (byte) 0x3F, (byte) 0xDE,
1:70f7692:         (byte) 0xCF, (byte) 0x07, (byte) 0x1E, (byte) 0xDC,
1:70f7692:         (byte) 0xEC, (byte) 0x5F, (byte) 0x62, (byte) 0x6E,
1:70f7692:         (byte) 0x21, (byte) 0xE2, (byte) 0x56, (byte) 0xAE,
1:70f7692:         (byte) 0xD9, (byte) 0xEA, (byte) 0x34, (byte) 0xE4
1:70f7692:     };
1:33776ff: 
1:70f7692:     // The base value in BigInteger form.
1:69e3d06:     private static final BigInteger base__ =
1:69e3d06:             new BigInteger(1, baseBytes__);
1:33776ff: 
1:70f7692:     //PROTOCOL's Diffie-Hellman agreed exponential length
1:70f7692:     private static final int exponential_length__ = 255;
1:33776ff: 
1:69e3d06:     private DHParameterSpec paramSpec_;
1:69e3d06:     private KeyPairGenerator keyPairGenerator_;
1:69e3d06:     private KeyPair keyPair_;
1:69e3d06:     private KeyAgreement keyAgreement_;
1:33776ff: 
1:70f7692:     private byte[] token_; // init vector
1:70f7692:     private byte[] secKey_; // security key
1:69e3d06:     private SecretKeyFactory secretKeyFactory_ = null;
1:70f7692:     private String providerName; // security provider name
1:70f7692:     private Provider provider;
1:33776ff: 
1:7233e33:     // Required for SECMEC_USRSSBPWD DRDA security mechanism
1:7233e33:     // NOTE: In a next incarnation, these constants are being moved
1:7233e33:     // to a dedicated/specialized SecMec_USRSSBPWD class implementing
1:7233e33:     // a SecurityMechanism interface.
1:69e3d06:     private MessageDigest messageDigest = null;
1:69e3d06:     private SecureRandom secureRandom = null;
1:7233e33:     private final static int SECMEC_USRSSBPWD_SEED_LEN = 8;  // Seed length
1:7233e33:     // PWSEQs's 8-byte value constant - See DRDA Vol 3
1:7233e33:     private static final byte SECMEC_USRSSBPWD_PWDSEQS[] = {
1:7233e33:         (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
1:7233e33:         (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01
1:7233e33:     };
1:7233e33:     // Random Number Generator (PRNG) Algorithm
1:7233e33:     private final static String SHA_1_PRNG_ALGORITHM = "SHA1PRNG";
1:7233e33:     public final static String SHA_1_DIGEST_ALGORITHM = "SHA-1";
1:7233e33: 
1:70f7692:     // EncryptionManager constructor. In this constructor,DHParameterSpec,
1:70f7692:     // KeyPairGenerator, KeyPair, and KeyAgreement  are initialized.
1:70f7692:     public EncryptionManager(Agent agent) throws SqlException {
1:70f7692:         agent_ = agent;
1:70f7692:         try {
1:70f7692:             // get a security provider that supports the diffie helman key agreement algorithm
1:70f7692:             Provider[] list = Security.getProviders("KeyAgreement.DH");
1:70f7692:             if (list == null) {
1:69e3d06:                 throw new NoSuchProviderException();
1:70f7692:             }
1:70f7692:             provider = list[0];
1:70f7692:             providerName = provider.getName();
1:69e3d06:             paramSpec_ =
1:69e3d06:                 new DHParameterSpec(modulus__, base__, exponential_length__);
1:69e3d06:             keyPairGenerator_ =
1:69e3d06:                 KeyPairGenerator.getInstance("DH", providerName);
1:70f7692:             keyPairGenerator_.initialize(paramSpec_);
1:70f7692:             keyPair_ = keyPairGenerator_.generateKeyPair();
1:69e3d06:             keyAgreement_ = KeyAgreement.getInstance("DH", providerName);
1:70f7692:             keyAgreement_.init(keyPair_.getPrivate());
1:69e3d06:         } catch (GeneralSecurityException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e); 
1:70f7692:         }
57:33776ff:     }
1:33776ff: 
1:7233e33:     // Retrieve a particular instance of the Encryption manager for a given
1:7233e33:     // (Messsage Digest) algorithm. This is currently required for the
1:7233e33:     // SECMEC_USRSSBPWD (strong password substitute) security mechanism.
1:7233e33:     // 
1:7233e33:     // NOTE: This is temporary logic as the encryption manager is being
1:7233e33:     // rewritten into a DRDASecurityManager and have some of the
1:7233e33:     // client/engine common logic moved to the Derby 'shared' package.
1:7233e33:     public EncryptionManager(Agent agent, String algorithm) throws SqlException {
1:7233e33:         agent_ = agent;
1:7233e33:         try {
1:7233e33:             // Instantiate the encryption manager for the passed-in security
1:7233e33:             // algorithm and this from the default provider
1:7233e33:             // NOTE: We're only dealing with Message Digest algorithms for now.
1:69e3d06:             messageDigest = MessageDigest.getInstance(algorithm);
1:7233e33:             // We're also verifying that we can instantiate a randon number
1:7233e33:             // generator (PRNG).
1:7233e33:             secureRandom =
1:69e3d06:                 SecureRandom.getInstance(SHA_1_PRNG_ALGORITHM);
1:69e3d06:         } catch (NoSuchAlgorithmException nsae) {
1:7233e33:             // The following exception should not be raised for SHA-1 type of
1:7233e33:             // message digest as we've already verified during boot-up that this
1:7233e33:             // algorithm was available as part of the JRE (since BUILT-IN
1:7233e33:             // authentication requires it); but we still raise the exception if
1:7233e33:             // a client were to request a different algorithm.
1:7233e33:             throw new SqlException(agent_.logWriter_, 
1:7233e33:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED),
1:7233e33:                                     nsae); 
1:7233e33:         }
1:7233e33:     }
1:7233e33: 
1:70f7692:     // This method generates the public key and returns it. This
1:70f7692:     // shared public key is the application requester's connection key and will
1:70f7692:     // be exchanged with the application server's connection key. This connection
1:70f7692:     // key will be put in the sectkn in ACCSEC command and send to the application
1:70f7692:     // server.
1:70f7692:     // @param   null
1:70f7692:     // @return  a byte array that is the application requester's public key
1:70f7692:     public byte[] obtainPublicKey() {
1:33776ff: 
1:70f7692:         //we need to get the plain form public key because PROTOCOL accepts plain form
1:70f7692:         //public key only.
1:69e3d06:         BigInteger aPub = ((DHPublicKey) keyPair_.getPublic()).getY();
1:70f7692:         byte[] aPubKey = aPub.toByteArray();
1:33776ff: 
1:70f7692:         //the following lines of code is to adjust the length of the key. PublicKey
1:70f7692:         //in JCE is in the form of BigInteger and it's a signed value. When tranformed
1:70f7692:         //to a Byte array form, normally this array is 32 bytes. However, if the
1:70f7692:         //value happens to take up all 32 X 8 bits and it is positive, an extra
1:70f7692:         //bit is needed and then a 33 byte array will be returned. Since PROTOCOL can't
1:70f7692:         //recogize the 33 byte key, we check the length here, if the length is 33,
1:70f7692:         //we will just trim off the first byte (0) and get the rest of 32 bytes.
1:70f7692:         if (aPubKey.length == 33 && aPubKey[0] == 0) {
1:70f7692:             //System.out.println ("Adjust length");
1:70f7692:             byte[] newKey = new byte[32];
1:70f7692:             for (int i = 0; i < newKey.length; i++) {
1:70f7692:                 newKey[i] = aPubKey[i + 1];
1:70f7692:             }
1:70f7692:             return newKey;
1:70f7692:         }
1:33776ff: 
1:70f7692:         //the following lines of code is to adjust the length of the key. Occasionally,
1:70f7692:         //the length of the public key is less than 32, the reason of this is that the 0 byte
1:70f7692:         //in the beginning is somehow not returned. So we check the length here, if the length
1:70f7692:         //is less than 32, we will pad 0 in the beginning to make the public key 32 bytes
1:70f7692:         if (aPubKey.length < 32) {
1:70f7692:             byte[] newKey = new byte[32];
1:70f7692:             int i;
1:70f7692:             for (i = 0; i < 32 - aPubKey.length; i++) {
1:70f7692:                 newKey[i] = 0;
1:70f7692:             }
1:70f7692:             for (int j = i; j < newKey.length; j++) {
1:70f7692:                 newKey[j] = aPubKey[j - i];
1:70f7692:             }
1:70f7692:             return newKey;
1:70f7692:         }
1:70f7692:         return aPubKey;
1:70f7692:     }
1:33776ff: 
1:70f7692:     // This method is used to calculate the encryption token. DES encrypts the
1:70f7692:     // data using a token and the generated shared private key. The token used
1:70f7692:     // depends on the type of security mechanism being used:
1:70f7692:     // USRENCPWD - The userid is used as the token. The USRID is zero-padded to
1:70f7692:     // 8 bytes if less than 8 bytes or truncated to 8 bytes if greater than 8 bytes.
1:70f7692:     // EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
1:70f7692:     // the token.
1:70f7692:     // @param  int     securityMechanism
1:70f7692:     // @param  byte[]  userid or server's connection key
1:70f7692:     // @return byte[]  the encryption token
1:70f7692:     private byte[] calculateEncryptionToken(int securityMechanism, byte[] initVector) {
1:70f7692:         byte[] token = new byte[8];
1:33776ff: 
1:70f7692:         //USRENCPWD, the userid is used as token
1:70f7692:         if (securityMechanism == 7) {
1:70f7692:             if (initVector.length < 8) { //shorter than 8 bytes, zero padded to 8 bytes
1:b3e9947:                 System.arraycopy(initVector, 0, token, 0, initVector.length);
1:70f7692:                 for (int i = initVector.length; i < 8; i++) {
1:70f7692:                     token[i] = 0;
1:70f7692:                 }
1:70f7692:             } else {  //longer than 8 bytes, truncated to 8 bytes
1:b3e9947:                 System.arraycopy(initVector, 0, token, 0, 8);
1:70f7692:             }
1:70f7692:         }
1:70f7692:         //EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
1:70f7692:         //the token.
1:70f7692:         else if (securityMechanism == 9) {
2:70f7692:             for (int i = 0; i < 8; i++) {
1:70f7692:                 token[i] = initVector[i + 12];
1:70f7692:             }
1:70f7692:         }
1:70f7692:         return token;
1:70f7692:     }
1:33776ff: 
1:70f7692:     //JDK 1.4 has a parity check on the DES encryption key. Each byte needs to have an odd number
1:70f7692:     //of "1"s in it, and this is required by DES. Otherwise JDK 1.4 throws InvalidKeyException.
1:70f7692:     //Older JDK doesn't check this. In order to make encryption work with JDK1.4, we are going to
1:70f7692:     //check each of the 8 byte of our key and flip the last bit if it has even number of 1s.
1:70f7692:     private void keyParityCheck(byte[] key) throws SqlException {
1:70f7692:         byte temp;
1:70f7692:         int changeParity;
1:70f7692:         if (key.length != 8) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.DES_KEY_HAS_WRONG_LENGTH), 
1:66527ec:                 8, key.length);
1:486829c:                         
1:70f7692:         }
1:70f7692:         for (int i = 0; i < 8; i++) {
1:70f7692:             temp = key[i];
1:70f7692:             changeParity = 1;
1:70f7692:             for (int j = 0; j < 8; j++) {
1:70f7692:                 if (temp < 0) {
1:70f7692:                     changeParity = 1 - changeParity;
1:70f7692:                 }
1:70f7692:                 temp = (byte) (temp << 1);
1:70f7692:             }
1:70f7692:             if (changeParity == 1) {
1:70f7692:                 if ((key[i] & 1) != 0) {
1:70f7692:                     key[i] &= 0xfe;
1:70f7692:                 } else {
1:70f7692:                     key[i] |= 1;
1:70f7692:                 }
1:70f7692:             }
1:70f7692:         }
1:70f7692:     }
1:70f7692: 
1:70f7692:     // This method generates a secret key using the application server's
1:70f7692:     // public key
1:70f7692:     private byte[] generatePrivateKey(byte[] targetPublicKey) throws SqlException {
1:70f7692:         try {
1:70f7692: 
1:70f7692:             //initiate a Diffie_Hellman KeyFactory object.
1:69e3d06:             KeyFactory keyFac = KeyFactory.getInstance("DH", provider);
1:70f7692: 
1:70f7692:             //Use server's public key to initiate a DHPublicKeySpec and then use
1:70f7692:             //this DHPublicKeySpec to initiate a publicKey object
1:69e3d06:             BigInteger publicKey = new BigInteger(1, targetPublicKey);
1:69e3d06:             DHPublicKeySpec dhKeySpec =
1:69e3d06:                     new DHPublicKeySpec(publicKey, modulus__, base__);
1:69e3d06:             PublicKey pubKey = keyFac.generatePublic(dhKeySpec);
1:70f7692: 
1:70f7692:             //Execute the first phase of DH keyagreement protocal.
1:70f7692:             keyAgreement_.doPhase(pubKey, true);
1:70f7692: 
1:70f7692:             //generate the shared secret key. The application requestor's shared secret
1:70f7692:             //key should be exactly the same as the application server's shared secret
1:70f7692:             //key
1:70f7692:             byte[] sharedSecret = keyAgreement_.generateSecret();
1:70f7692:             byte[] newKey = new byte[32];
1:70f7692: 
1:70f7692:             //We adjust the length here. If the length of secret key is 33 and the first byte is 0,
1:70f7692:             //we trim off the frist byte. If the length of secret key is less than 32, we will
1:70f7692:             //pad 0 to the beginning of the byte array tho make the secret key 32 bytes.
1:70f7692:             if (sharedSecret.length == 33 && sharedSecret[0] == 0) {
1:70f7692:                 for (int i = 0; i < newKey.length; i++) {
1:70f7692:                     newKey[i] = sharedSecret[i + 1];
1:70f7692:                 }
1:70f7692: 
1:70f7692:             }
1:70f7692:             if (sharedSecret.length < 32) {
1:70f7692:                 int i;
1:70f7692:                 for (i = 0; i < (32 - sharedSecret.length); i++) {
1:70f7692:                     newKey[i] = 0;
1:70f7692:                 }
1:70f7692:                 for (int j = i; j < sharedSecret.length; j++) {
1:70f7692:                     newKey[j] = sharedSecret[j - i];
1:70f7692:                 }
1:70f7692:             }
1:70f7692: 
1:70f7692:             //The Data Encryption Standard (DES) is going to be used to encrypt userid
1:70f7692:             //and password. DES is a block cipher; it encrypts data in 64-bit blocks.
1:70f7692:             //PROTOCOL encryption uses DES CBC mode as defined by the FIPS standard
1:70f7692:             //DES CBC requires an encryption key and an 8 byte token to encrypt the data.
1:70f7692:             //The middle 8 bytes of Diffie-Hellman shared private key is used as the
1:70f7692:             //encryption key. The following code retrieves middle 8 bytes of the shared
1:70f7692:             //private key.
1:70f7692:             byte[] key = new byte[8];
1:70f7692: 
1:70f7692:             //if secret key is not 32, we will use the adjust length secret key
1:70f7692:             if (sharedSecret.length == 32) {
1:70f7692:                 for (int i = 0; i < 8; i++) {
1:70f7692:                     key[i] = sharedSecret[i + 12];
1:70f7692:                 }
1:70f7692:             } else if (sharedSecret.length == 33 || sharedSecret.length < 32) {
1:70f7692:                 for (int i = 0; i < 8; i++) {
1:70f7692:                     key[i] = newKey[i + 12];
1:70f7692:                 }
1:70f7692:             } else {
1:486829c:                 throw new SqlException(agent_.logWriter_, 
1:e65b4db:                     new ClientMessageId(SQLState.SHARED_KEY_LENGTH_ERROR),
1:66527ec:                     sharedSecret.length);
1:70f7692:             }
1:70f7692: 
1:70f7692:             //we do parity check here and flip the parity bit if the byte has even number of 1s
1:70f7692:             keyParityCheck(key);
1:70f7692:             return key;
1:486829c:         }
1:69e3d06:         catch (GeneralSecurityException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e);
1:70f7692:         }
1:70f7692:     }
1:33776ff: 
1:70f7692:     // This method encrypts the usreid/password with the middle 8 bytes of
1:70f7692:     // the generated secret key and an encryption token. Then it returns the
1:70f7692:     // encrypted data in a byte array.
1:70f7692:     // plainText   The byte array form userid/password to encrypt.
1:70f7692:     // initVector  The byte array which is used to calculate the
1:70f7692:     //                             encryption token.
1:70f7692:     // targetPublicKey   DERBY' public key.
1:70f7692:     // Returns the encrypted data in a byte array.
1:70f7692:     public byte[] encryptData(byte[] plainText,
1:70f7692:                               int securityMechanism,
1:70f7692:                               byte[] initVector,
1:70f7692:                               byte[] targetPublicKey) throws SqlException {
1:70f7692: 
1:70f7692:         byte[] cipherText = null;
1:69e3d06:         Key key = null;
1:70f7692: 
1:70f7692:         if (token_ == null) {
1:70f7692:             token_ = calculateEncryptionToken(securityMechanism, initVector);
1:70f7692:         }
1:70f7692: 
1:70f7692:         try {
1:70f7692:             if (secKey_ == null) {
1:70f7692:                 //use this encryption key to initiate a SecretKeySpec object
1:70f7692:                 secKey_ = generatePrivateKey(targetPublicKey);
1:69e3d06:                 SecretKeySpec desKey = new SecretKeySpec(secKey_, "DES");
1:70f7692:                 key = desKey;
1:70f7692:             } else {
1:70f7692:                 //use this encryption key to initiate a SecretKeySpec object
1:69e3d06:                 DESKeySpec desKey = new DESKeySpec(secKey_);
1:70f7692:                 if (secretKeyFactory_ == null) {
1:69e3d06:                     secretKeyFactory_ =
1:69e3d06:                         SecretKeyFactory.getInstance("DES", providerName);
1:70f7692:                 }
1:70f7692:                 key = secretKeyFactory_.generateSecret(desKey);
1:70f7692:             }
1:70f7692: 
1:70f7692:             //We use DES in CBC mode because this is the mode used in PROTOCOL. The
1:70f7692:             //encryption mode has to be consistent for encryption and decryption.
1:70f7692:             //CBC mode requires an initialization vector(IV) parameter. In CBC mode
1:70f7692:             //we need to initialize the Cipher object with an IV, which can be supplied
1:70f7692:             // using the javax.crypto.spec.IvParameterSpec class.
1:69e3d06:             Cipher cipher =
1:69e3d06:                 Cipher.getInstance("DES/CBC/PKCS5Padding", providerName);
1:70f7692: 
1:70f7692:             //generate a IVParameterSpec object and use it to initiate the
1:70f7692:             //Cipher object.
1:69e3d06:             IvParameterSpec ivParam = new IvParameterSpec(token_);
1:70f7692: 
1:70f7692:             //initiate the Cipher using encryption mode, encryption key and the
1:70f7692:             //IV parameter.
1:69e3d06:             cipher.init(Cipher.ENCRYPT_MODE, key, ivParam);
1:70f7692: 
1:70f7692:             //Execute the final phase of encryption
1:70f7692:             cipherText = cipher.doFinal(plainText);
1:69e3d06:         } catch (NoSuchPaddingException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.CRYPTO_NO_SUCH_PADDING)); 
1:69e3d06:         } catch (BadPaddingException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.CRYPTO_BAD_PADDING)); 
1:69e3d06:         } catch (IllegalBlockSizeException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.CRYPTO_ILLEGAL_BLOCK_SIZE)); 
1:69e3d06:         } catch (GeneralSecurityException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e); 
1:70f7692:         }
1:486829c: 
1:70f7692:         return cipherText;
1:70f7692:     }
1:70f7692: 
1:70f7692: 
1:70f7692:     // This method decrypts the usreid/password with the middle 8 bytes of
1:70f7692:     // the generated secret key and an encryption token. Then it returns the
1:70f7692:     // decrypted data in a byte array.
1:70f7692:     // plainText   The byte array form userid/password to encrypt.
1:70f7692:     // initVector  The byte array which is used to calculate the
1:70f7692:     //                             encryption token.
1:70f7692:     // targetPublicKey   DERBY' public key.
1:70f7692:     // Returns the decrypted data in a byte array.
1:70f7692:     public byte[] decryptData(byte[] cipherText,
1:70f7692:                               int securityMechanism,
1:70f7692:                               byte[] initVector,
1:70f7692:                               byte[] targetPublicKey) throws SqlException {
1:70f7692: 
1:70f7692:         byte[] plainText = null;
1:69e3d06:         Key key = null;
1:70f7692: 
1:70f7692:         if (token_ == null) {
1:70f7692:             token_ = calculateEncryptionToken(securityMechanism, initVector);
1:70f7692:         }
1:70f7692: 
1:70f7692:         try {
1:70f7692:             if (secKey_ == null) {
1:70f7692:                 //use this encryption key to initiate a SecretKeySpec object
1:70f7692:                 secKey_ = generatePrivateKey(targetPublicKey);
1:69e3d06:                 SecretKeySpec desKey = new SecretKeySpec(secKey_, "DES");
1:70f7692:                 key = desKey;
1:70f7692:             } else {
1:70f7692:                 //use this encryption key to initiate a SecretKeySpec object
1:69e3d06:                 DESKeySpec desKey = new DESKeySpec(secKey_);
1:70f7692:                 if (secretKeyFactory_ == null) {
1:69e3d06:                     secretKeyFactory_ =
1:69e3d06:                         SecretKeyFactory.getInstance("DES", providerName);
1:70f7692:                 }
1:70f7692:                 key = secretKeyFactory_.generateSecret(desKey);
1:70f7692:             }
1:70f7692: 
1:70f7692:             //We use DES in CBC mode because this is the mode used in PROTOCOL. The
1:70f7692:             //encryption mode has to be consistent for encryption and decryption.
1:70f7692:             //CBC mode requires an initialization vector(IV) parameter. In CBC mode
1:70f7692:             //we need to initialize the Cipher object with an IV, which can be supplied
1:70f7692:             // using the javax.crypto.spec.IvParameterSpec class.
1:69e3d06:             Cipher cipher =
1:69e3d06:                 Cipher.getInstance("DES/CBC/PKCS5Padding", providerName);
1:70f7692: 
1:70f7692:             //generate a IVParameterSpec object and use it to initiate the
1:70f7692:             //Cipher object.
1:69e3d06:             IvParameterSpec ivParam = new IvParameterSpec(token_);
1:70f7692: 
1:70f7692:             //initiate the Cipher using encryption mode, encryption key and the
1:70f7692:             //IV parameter.
1:69e3d06:             cipher.init(Cipher.DECRYPT_MODE, key, ivParam);
1:70f7692: 
1:70f7692:             //Execute the final phase of encryption
1:70f7692:             plainText = cipher.doFinal(cipherText);
1:69e3d06:         } catch (NoSuchPaddingException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.CRYPTO_NO_SUCH_PADDING)); 
1:69e3d06:         } catch (BadPaddingException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.CRYPTO_BAD_PADDING)); 
1:69e3d06:         } catch (IllegalBlockSizeException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                         new ClientMessageId(SQLState.CRYPTO_ILLEGAL_BLOCK_SIZE)); 
1:69e3d06:         } catch (GeneralSecurityException e) {
1:486829c:             throw new SqlException(agent_.logWriter_, 
1:e65b4db:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e); 
1:70f7692:         }
1:70f7692:         return plainText;
1:70f7692:     }
1:70f7692: 
1:70f7692:     public void resetSecurityKeys() {
1:70f7692:         token_ = null;
1:70f7692:         secKey_ = null;
1:70f7692:     }
1:33776ff: 
1:7233e33:     /****************************************************************
1:7233e33:      * Below are methods for the SECMEC_USRSSBPWD security mechanism.
1:7233e33:      ****************************************************************/
1:33776ff: 
1:6eb29f6:     /**
1:6eb29f6:      * This method generates an 8-Byte random seed for the client (source).
1:6eb29f6:      *
1:6eb29f6:      * @return a random 8-Byte seed.
1:6eb29f6:      */
1:7233e33:     public byte[] generateSeed() {
1:7233e33:         byte randomSeedBytes[] = new byte[SECMEC_USRSSBPWD_SEED_LEN];
1:7233e33:         secureRandom.setSeed(secureRandom.generateSeed(
1:7233e33:                                         SECMEC_USRSSBPWD_SEED_LEN));
1:7233e33:         secureRandom.nextBytes(randomSeedBytes);
1:7233e33:         return randomSeedBytes;
1:7233e33:     }
1:7233e33: 
2:7233e33:     /**
1:7233e33:      * Strong Password Substitution (USRSSBPWD).
2:7233e33:      *
1:23f97a5:      * This method generates a password substitute to send to the target
1:7233e33:      * server.
1:7233e33:      * 
1:7233e33:      * Substitution algorithm works as follow:
1:7233e33:      *
1:7233e33:      * PW_TOKEN = SHA-1(PW, ID)
1:7233e33:      * The password (PW) and user name (ID) can be of any length greater
1:7233e33:      * than or equal to 1 byte.
1:7233e33:      * The client generates a 20-byte password substitute (PW_SUB) as follows:
1:7233e33:      * PW_SUB = SHA-1(PW_TOKEN, RDr, RDs, ID, PWSEQs)
1:7233e33:      * 
1:7233e33:      * w/ (RDs) as the random client seed and (RDr) as the server one.
1:7233e33:      * 
1:7233e33:      * See PWDSSB - Strong Password Substitution Security Mechanism
1:7233e33:      * (DRDA Vol.3 - P.650)
1:7233e33:      *
1:7233e33:      * @param userName The user's name
1:7233e33:      * @param password The user's password
1:7233e33:      * @param sourceSeed_ random client seed (RDs)
1:7233e33:      * @param targetSeed_ random server seed (RDr)
1:7233e33:      *
1:7233e33:      * @return a password substitute.
1:7233e33:      */
1:7233e33:     public byte[] substitutePassword(
1:7233e33:                 String userName,
1:7233e33:                 String password,
1:7233e33:                 byte[] sourceSeed_,
1:7233e33:                 byte[] targetSeed_) throws SqlException {
1:7233e33: 
1:7233e33:         // Pattern that is prefixed to the BUILTIN encrypted password
1:7233e33:         String ID_PATTERN_NEW_SCHEME = "3b60";
1:7233e33:         
1:7233e33:         // Generated password substitute
1:7233e33:         byte[] passwordSubstitute;
1:7233e33: 
1:7233e33:         // Assert we have a SHA-1 Message Digest already instantiated
1:7233e33:         if (SanityManager.DEBUG) {
1:7233e33:             SanityManager.ASSERT((messageDigest != null) &&
1:7233e33:                                  (SHA_1_DIGEST_ALGORITHM.equals(
1:7233e33:                                     messageDigest.getAlgorithm())));
1:7233e33:         }
1:7233e33: 
1:7233e33:         // IMPORTANT NOTE: As the password is stored single-hashed in the
1:7233e33:         // database on the target side, it is impossible for the target to
1:7233e33:         // decrypt the password and recompute a substitute to compare with
1:7233e33:         // one generated on the source side - Hence, for now we have to
1:7233e33:         // single-hash and encrypt the password the same way the target is
1:7233e33:         // doing it and we will still generate a substitute obviously - The
1:7233e33:         // password, even pre-hashed will never make it across the wire as
1:7233e33:         // a substitute is generated. In other words, if the target cannot
1:7233e33:         // figure what the original password is (because of not being able
1:7233e33:         // to decrypt it or not being able to retrieve it (i.e. LDAP), then
1:7233e33:         // It may be problematic - so in a way, Strong Password Substitution
1:7233e33:         // (USRSSBPWD) cannot be supported for targets which can't access or
1:7233e33:         // decrypt some password on their side.
1:7233e33:         //
1:7233e33:         // So in short, SECMEC_USRSSBPWD is only supported if the
1:7233e33:         // authentication provider on the target side is NONE or Derby's
1:7233e33:         // BUILTIN one and if using Derby's Client Network driver (for now).
1:7233e33:         //
1:7233e33:         // Encrypt the password as it is done by the derby engine - Note that
1:7233e33:         // this code (logic) is not shared yet - will be in next revision.
1:23f97a5:         //
1:23f97a5:         // Note that this code assumes that the Derby engine has encrypted
1:23f97a5:         // the password using one particular algorithm (based on SHA-1). After
1:23f97a5:         // DERBY-4483, it is possible that the engine uses another algorithm.
1:23f97a5:         // Since the engine has no way to decrypt the encrypted password, it
1:23f97a5:         // has no way to compared the stored password with the hash we send, so
1:23f97a5:         // authentication will fail unless the engine actually uses the SHA-1
1:23f97a5:         // based scheme.
1:23f97a5: 
1:7233e33:         messageDigest.reset();
1:7233e33: 
1:6eb29f6:         messageDigest.update(this.toHexByte(password, 0, password.length()));
1:6eb29f6:         byte[] encryptVal = messageDigest.digest();
1:6eb29f6:         String hexString = ID_PATTERN_NEW_SCHEME +
1:7233e33:                      this.toHexString(encryptVal, 0, encryptVal.length);
1:7233e33: 
1:7233e33:         // Generate some 20-byte password token
1:7233e33:         byte[] userBytes = this.toHexByte(userName, 0, userName.length());
1:7233e33:         messageDigest.update(userBytes);
1:7233e33:         messageDigest.update(this.toHexByte(hexString, 0, hexString.length()));
1:7233e33:         byte[] passwordToken = messageDigest.digest();
1:7233e33:         
1:7233e33:         // Now we generate the 20-byte password substitute
1:7233e33:         messageDigest.update(passwordToken);
1:7233e33:         messageDigest.update(targetSeed_);
1:7233e33:         messageDigest.update(sourceSeed_);
1:7233e33:         messageDigest.update(userBytes);
1:7233e33:         messageDigest.update(SECMEC_USRSSBPWD_PWDSEQS);
1:7233e33: 
1:7233e33:         passwordSubstitute = messageDigest.digest();
1:7233e33: 
1:7233e33:         return passwordSubstitute;
1:7233e33:     }
1:7233e33: 
1:7233e33:     /*********************************************************************
1:7233e33:      * RESOLVE:                                                          *
1:7233e33:      * The methods and static vars below should go into some 'shared'    *
1:7233e33:      * package when the capability is put back in (StringUtil.java).     *
1:7233e33:      *********************************************************************/
1:7233e33: 
1:23ecfcf:     private static final char[] hex_table = {
1:7233e33:                 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
1:7233e33:                 'a', 'b', 'c', 'd', 'e', 'f'
1:7233e33:             };
1:7233e33: 
1:7233e33:     /**
1:b13b17c:         Convert a byte array to a String with a hexadecimal format.
1:7233e33:         The String may be converted back to a byte array using fromHexString.
1:7233e33:         <BR>
1:b13b17c:         For each byte (b) two characters are generated, the first character
1:b13b17c:         represents the high nibble (4 bits) in hexadecimal ({@code b & 0xf0}),
1:b13b17c:         the second character represents the low nibble ({@code b & 0x0f}).
1:7233e33:         <BR>
1:b13b17c:         The byte at {@code data[offset]} is represented by the first two
1:7233e33:         characters in the returned String.
1:7233e33: 
1:7f6e8aa:         @param  data    byte array
1:7f6e8aa:         @param  offset  starting byte (zero based) to convert.
1:7f6e8aa:         @param  length  number of bytes to convert.
1:7233e33: 
1:7233e33:         @return the String (with hexidecimal format) form of the byte array
1:7233e33:     */
1:7233e33:     private String toHexString(byte[] data, int offset, int length)
1:7233e33:     {
1:b13b17c:         StringBuilder s = new StringBuilder(length*2);
1:7233e33:         int end = offset+length;
1:7233e33: 
1:7233e33:         for (int i = offset; i < end; i++)
1:7233e33:         {
1:7233e33:             int high_nibble = (data[i] & 0xf0) >>> 4;
1:7233e33:             int low_nibble = (data[i] & 0x0f);
1:7233e33:             s.append(hex_table[high_nibble]);
1:7233e33:             s.append(hex_table[low_nibble]);
1:7233e33:         }
1:7233e33: 
1:7233e33:         return s.toString();
1:7233e33:     }
1:7233e33: 
1:7233e33:     /**
1:7233e33:   
1:7233e33:         Convert a string into a byte array in hex format.
1:7233e33:         <BR>
1:7233e33:         For each character (b) two bytes are generated, the first byte 
1:b13b17c:         represents the high nibble (4 bits) in hexadecimal ({@code b & 0xf0}),
1:b13b17c:         the second byte represents the low nibble ({@code b & 0x0f}).
1:7233e33:         <BR>
1:b13b17c:         The character at {@code str.charAt(0)} is represented by the
1:b13b17c:         first two bytes in the returned String.
1:7233e33: 
1:7f6e8aa:         @param  str string
1:7f6e8aa:         @param  offset  starting character (zero based) to convert.
1:7f6e8aa:         @param  length  number of characters to convert.
1:7233e33: 
1:b13b17c:         @return the byte[]  (with hexadecimal format) form of the string (str)
1:7233e33:     */
1:7233e33:     private byte[] toHexByte(String str, int offset, int length)
1:7233e33:     {
1:7233e33:         byte[] data = new byte[(length - offset) * 2];
1:7233e33:         int end = offset+length;
1:7233e33: 
1:7233e33:         for (int i = offset; i < end; i++)
1:7233e33:         {
1:7233e33:             char ch = str.charAt(i);
1:7233e33:             int high_nibble = (ch & 0xf0) >>> 4;
1:7233e33:             int low_nibble = (ch & 0x0f);
1:7233e33:             data[i] = (byte)high_nibble;
1:7233e33:             data[i+1] = (byte)low_nibble;
1:7233e33:         }
1:7233e33:         return data;
1:7233e33:     }
1:7233e33: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:69e3d06
/////////////////////////////////////////////////////////////////////////
1: import java.math.BigInteger;
1: import java.security.GeneralSecurityException;
1: import java.security.Key;
1: import java.security.KeyFactory;
1: import java.security.KeyPair;
1: import java.security.KeyPairGenerator;
1: import java.security.MessageDigest;
1: import java.security.NoSuchAlgorithmException;
1: import java.security.NoSuchProviderException;
1: import java.security.PublicKey;
1: import java.security.SecureRandom;
1: import javax.crypto.BadPaddingException;
1: import javax.crypto.Cipher;
1: import javax.crypto.IllegalBlockSizeException;
1: import javax.crypto.KeyAgreement;
1: import javax.crypto.NoSuchPaddingException;
1: import javax.crypto.SecretKeyFactory;
1: import javax.crypto.interfaces.DHPublicKey;
1: import javax.crypto.spec.DESKeySpec;
1: import javax.crypto.spec.DHParameterSpec;
1: import javax.crypto.spec.DHPublicKeySpec;
1: import javax.crypto.spec.IvParameterSpec;
1: import javax.crypto.spec.SecretKeySpec;
/////////////////////////////////////////////////////////////////////////
1:     private static final BigInteger modulus__
1:             = new BigInteger(1, modulusBytes__);
/////////////////////////////////////////////////////////////////////////
1:     private static final BigInteger base__ =
1:             new BigInteger(1, baseBytes__);
1:     private DHParameterSpec paramSpec_;
1:     private KeyPairGenerator keyPairGenerator_;
1:     private KeyPair keyPair_;
1:     private KeyAgreement keyAgreement_;
1:     private SecretKeyFactory secretKeyFactory_ = null;
/////////////////////////////////////////////////////////////////////////
1:     private MessageDigest messageDigest = null;
1:     private SecureRandom secureRandom = null;
/////////////////////////////////////////////////////////////////////////
1:                 throw new NoSuchProviderException();
1:             paramSpec_ =
1:                 new DHParameterSpec(modulus__, base__, exponential_length__);
1:             keyPairGenerator_ =
1:                 KeyPairGenerator.getInstance("DH", providerName);
1:             keyAgreement_ = KeyAgreement.getInstance("DH", providerName);
1:         } catch (GeneralSecurityException e) {
/////////////////////////////////////////////////////////////////////////
1:             messageDigest = MessageDigest.getInstance(algorithm);
1:                 SecureRandom.getInstance(SHA_1_PRNG_ALGORITHM);
1:         } catch (NoSuchAlgorithmException nsae) {
/////////////////////////////////////////////////////////////////////////
1:         BigInteger aPub = ((DHPublicKey) keyPair_.getPublic()).getY();
/////////////////////////////////////////////////////////////////////////
1:             KeyFactory keyFac = KeyFactory.getInstance("DH", provider);
1:             BigInteger publicKey = new BigInteger(1, targetPublicKey);
1:             DHPublicKeySpec dhKeySpec =
1:                     new DHPublicKeySpec(publicKey, modulus__, base__);
1:             PublicKey pubKey = keyFac.generatePublic(dhKeySpec);
/////////////////////////////////////////////////////////////////////////
1:         catch (GeneralSecurityException e) {
/////////////////////////////////////////////////////////////////////////
1:         Key key = null;
/////////////////////////////////////////////////////////////////////////
1:                 SecretKeySpec desKey = new SecretKeySpec(secKey_, "DES");
1:                 DESKeySpec desKey = new DESKeySpec(secKey_);
1:                     secretKeyFactory_ =
1:                         SecretKeyFactory.getInstance("DES", providerName);
/////////////////////////////////////////////////////////////////////////
1:             Cipher cipher =
1:                 Cipher.getInstance("DES/CBC/PKCS5Padding", providerName);
1:             IvParameterSpec ivParam = new IvParameterSpec(token_);
1:             cipher.init(Cipher.ENCRYPT_MODE, key, ivParam);
1:         } catch (NoSuchPaddingException e) {
1:         } catch (BadPaddingException e) {
1:         } catch (IllegalBlockSizeException e) {
1:         } catch (GeneralSecurityException e) {
/////////////////////////////////////////////////////////////////////////
1:         Key key = null;
/////////////////////////////////////////////////////////////////////////
1:                 SecretKeySpec desKey = new SecretKeySpec(secKey_, "DES");
1:                 DESKeySpec desKey = new DESKeySpec(secKey_);
1:                     secretKeyFactory_ =
1:                         SecretKeyFactory.getInstance("DES", providerName);
/////////////////////////////////////////////////////////////////////////
1:             Cipher cipher =
1:                 Cipher.getInstance("DES/CBC/PKCS5Padding", providerName);
1:             IvParameterSpec ivParam = new IvParameterSpec(token_);
1:             cipher.init(Cipher.DECRYPT_MODE, key, ivParam);
1:         } catch (NoSuchPaddingException e) {
1:         } catch (BadPaddingException e) {
1:         } catch (IllegalBlockSizeException e) {
1:         } catch (GeneralSecurityException e) {
commit:b13b17c
/////////////////////////////////////////////////////////////////////////
0:         java.security.Key key;
/////////////////////////////////////////////////////////////////////////
0:         java.security.Key key;
/////////////////////////////////////////////////////////////////////////
1:         Convert a byte array to a String with a hexadecimal format.
1:         For each byte (b) two characters are generated, the first character
1:         represents the high nibble (4 bits) in hexadecimal ({@code b & 0xf0}),
1:         the second character represents the low nibble ({@code b & 0x0f}).
1:         The byte at {@code data[offset]} is represented by the first two
/////////////////////////////////////////////////////////////////////////
1:         StringBuilder s = new StringBuilder(length*2);
/////////////////////////////////////////////////////////////////////////
1:         represents the high nibble (4 bits) in hexadecimal ({@code b & 0xf0}),
1:         the second byte represents the low nibble ({@code b & 0x0f}).
1:         The character at {@code str.charAt(0)} is represented by the
1:         first two bytes in the returned String.
1:         @return the byte[]  (with hexadecimal format) form of the string (str)
commit:ee33904
/////////////////////////////////////////////////////////////////////////
1:      // for obtaining an exception log writer only
1:     private transient Agent agent_;
commit:95049cf
/////////////////////////////////////////////////////////////////////////
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:7f6e8aa
/////////////////////////////////////////////////////////////////////////
1:         @param  data    byte array
1:         @param  offset  starting byte (zero based) to convert.
1:         @param  length  number of bytes to convert.
/////////////////////////////////////////////////////////////////////////
1:         @param  str string
1:         @param  offset  starting character (zero based) to convert.
1:         @param  length  number of characters to convert.
commit:66527ec
/////////////////////////////////////////////////////////////////////////
1:                 8, key.length);
/////////////////////////////////////////////////////////////////////////
1:                     sharedSecret.length);
commit:b3e9947
/////////////////////////////////////////////////////////////////////////
1:                 System.arraycopy(initVector, 0, token, 0, initVector.length);
1:                 System.arraycopy(initVector, 0, token, 0, 8);
commit:23f97a5
/////////////////////////////////////////////////////////////////////////
1:      * This method generates a password substitute to send to the target
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Note that this code assumes that the Derby engine has encrypted
1:         // the password using one particular algorithm (based on SHA-1). After
1:         // DERBY-4483, it is possible that the engine uses another algorithm.
1:         // Since the engine has no way to decrypt the encrypted password, it
1:         // has no way to compared the stored password with the hash we send, so
1:         // authentication will fail unless the engine actually uses the SHA-1
1:         // based scheme.
1: 
commit:23ecfcf
/////////////////////////////////////////////////////////////////////////
1:     private static final char[] hex_table = {
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:6eb29f6
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * This method generates an 8-Byte random seed for the client (source).
1:      *
1:      * @return a random 8-Byte seed.
1:      */
/////////////////////////////////////////////////////////////////////////
1:         messageDigest.update(this.toHexByte(password, 0, password.length()));
1:         byte[] encryptVal = messageDigest.digest();
1:         String hexString = ID_PATTERN_NEW_SCHEME +
/////////////////////////////////////////////////////////////////////////
0:         @param    data    byte array
0:         @param    offset    starting byte (zero based) to convert.
0:         @param    length    number of bytes to convert.
0:         StringBuffer s = new StringBuffer(length*2);
/////////////////////////////////////////////////////////////////////////
0:         @param    str string 
0:         @param    offset    starting character (zero based) to convert.
0:         @param    length    number of characters to convert.
commit:7a20f8d
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:7233e33
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1: //
1: // This class also have methods for the SECMEC_USRSSBPWD security mechanism.
/////////////////////////////////////////////////////////////////////////
1:     // Required for SECMEC_USRSSBPWD DRDA security mechanism
1:     // NOTE: In a next incarnation, these constants are being moved
1:     // to a dedicated/specialized SecMec_USRSSBPWD class implementing
1:     // a SecurityMechanism interface.
0:     private java.security.MessageDigest messageDigest = null;
0:     private java.security.SecureRandom secureRandom = null;
1:     private final static int SECMEC_USRSSBPWD_SEED_LEN = 8;  // Seed length
1:     // PWSEQs's 8-byte value constant - See DRDA Vol 3
1:     private static final byte SECMEC_USRSSBPWD_PWDSEQS[] = {
1:         (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
1:         (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x01
1:     };
1:     // Random Number Generator (PRNG) Algorithm
1:     private final static String SHA_1_PRNG_ALGORITHM = "SHA1PRNG";
1:     public final static String SHA_1_DIGEST_ALGORITHM = "SHA-1";
1: 
/////////////////////////////////////////////////////////////////////////
1:     // Retrieve a particular instance of the Encryption manager for a given
1:     // (Messsage Digest) algorithm. This is currently required for the
1:     // SECMEC_USRSSBPWD (strong password substitute) security mechanism.
1:     // 
1:     // NOTE: This is temporary logic as the encryption manager is being
1:     // rewritten into a DRDASecurityManager and have some of the
1:     // client/engine common logic moved to the Derby 'shared' package.
1:     public EncryptionManager(Agent agent, String algorithm) throws SqlException {
1:         agent_ = agent;
1:         try {
1:             // Instantiate the encryption manager for the passed-in security
1:             // algorithm and this from the default provider
1:             // NOTE: We're only dealing with Message Digest algorithms for now.
0:             messageDigest = java.security.MessageDigest.getInstance(algorithm);
1:             // We're also verifying that we can instantiate a randon number
1:             // generator (PRNG).
1:             secureRandom =
0:                 java.security.SecureRandom.getInstance(SHA_1_PRNG_ALGORITHM);
0:         } catch (java.security.NoSuchAlgorithmException nsae) {
1:             // The following exception should not be raised for SHA-1 type of
1:             // message digest as we've already verified during boot-up that this
1:             // algorithm was available as part of the JRE (since BUILT-IN
1:             // authentication requires it); but we still raise the exception if
1:             // a client were to request a different algorithm.
1:             throw new SqlException(agent_.logWriter_, 
1:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED),
1:                                     nsae); 
1:         }
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:     /****************************************************************
1:      * Below are methods for the SECMEC_USRSSBPWD security mechanism.
1:      ****************************************************************/
1: 	/**
0: 	 * This method generates an 8-Byte random seed for the client (source).
1: 	 *
0: 	 * @return a random 8-Byte seed.
1: 	 */
1:     public byte[] generateSeed() {
1:         byte randomSeedBytes[] = new byte[SECMEC_USRSSBPWD_SEED_LEN];
1:         secureRandom.setSeed(secureRandom.generateSeed(
1:                                         SECMEC_USRSSBPWD_SEED_LEN));
1:         secureRandom.nextBytes(randomSeedBytes);
1:         return randomSeedBytes;
1:     }
1: 
1:     /**
1:      * Strong Password Substitution (USRSSBPWD).
1:      *
0:      * This method generate a password subtitute to send to the target
1:      * server.
1:      * 
1:      * Substitution algorithm works as follow:
1:      *
1:      * PW_TOKEN = SHA-1(PW, ID)
1:      * The password (PW) and user name (ID) can be of any length greater
1:      * than or equal to 1 byte.
1:      * The client generates a 20-byte password substitute (PW_SUB) as follows:
1:      * PW_SUB = SHA-1(PW_TOKEN, RDr, RDs, ID, PWSEQs)
1:      * 
1:      * w/ (RDs) as the random client seed and (RDr) as the server one.
1:      * 
1:      * See PWDSSB - Strong Password Substitution Security Mechanism
1:      * (DRDA Vol.3 - P.650)
1:      *
1:      * @param userName The user's name
1:      * @param password The user's password
1:      * @param sourceSeed_ random client seed (RDs)
1:      * @param targetSeed_ random server seed (RDr)
1:      *
1:      * @return a password substitute.
1:      */
1:     public byte[] substitutePassword(
1:                 String userName,
1:                 String password,
1:                 byte[] sourceSeed_,
1:                 byte[] targetSeed_) throws SqlException {
1: 
1:         // Pattern that is prefixed to the BUILTIN encrypted password
1:         String ID_PATTERN_NEW_SCHEME = "3b60";
1:         
1:         // Generated password substitute
1:         byte[] passwordSubstitute;
1: 
1:         // Assert we have a SHA-1 Message Digest already instantiated
1:         if (SanityManager.DEBUG) {
1:             SanityManager.ASSERT((messageDigest != null) &&
1:                                  (SHA_1_DIGEST_ALGORITHM.equals(
1:                                     messageDigest.getAlgorithm())));
1:         }
1: 
1:         // IMPORTANT NOTE: As the password is stored single-hashed in the
1:         // database on the target side, it is impossible for the target to
1:         // decrypt the password and recompute a substitute to compare with
1:         // one generated on the source side - Hence, for now we have to
1:         // single-hash and encrypt the password the same way the target is
1:         // doing it and we will still generate a substitute obviously - The
1:         // password, even pre-hashed will never make it across the wire as
1:         // a substitute is generated. In other words, if the target cannot
1:         // figure what the original password is (because of not being able
1:         // to decrypt it or not being able to retrieve it (i.e. LDAP), then
1:         // It may be problematic - so in a way, Strong Password Substitution
1:         // (USRSSBPWD) cannot be supported for targets which can't access or
1:         // decrypt some password on their side.
1:         //
1:         // So in short, SECMEC_USRSSBPWD is only supported if the
1:         // authentication provider on the target side is NONE or Derby's
1:         // BUILTIN one and if using Derby's Client Network driver (for now).
1:         //
1:         // Encrypt the password as it is done by the derby engine - Note that
1:         // this code (logic) is not shared yet - will be in next revision.
1:         messageDigest.reset();
1: 
0: 		messageDigest.update(this.toHexByte(password, 0, password.length()));
0: 		byte[] encryptVal = messageDigest.digest();
0: 		String hexString = ID_PATTERN_NEW_SCHEME +
1:                      this.toHexString(encryptVal, 0, encryptVal.length);
1: 
1:         // Generate some 20-byte password token
1:         byte[] userBytes = this.toHexByte(userName, 0, userName.length());
1:         messageDigest.update(userBytes);
1:         messageDigest.update(this.toHexByte(hexString, 0, hexString.length()));
1:         byte[] passwordToken = messageDigest.digest();
1:         
1:         // Now we generate the 20-byte password substitute
1:         messageDigest.update(passwordToken);
1:         messageDigest.update(targetSeed_);
1:         messageDigest.update(sourceSeed_);
1:         messageDigest.update(userBytes);
1:         messageDigest.update(SECMEC_USRSSBPWD_PWDSEQS);
1: 
1:         passwordSubstitute = messageDigest.digest();
1: 
1:         return passwordSubstitute;
1:     }
1: 
1:     /*********************************************************************
1:      * RESOLVE:                                                          *
1:      * The methods and static vars below should go into some 'shared'    *
1:      * package when the capability is put back in (StringUtil.java).     *
1:      *********************************************************************/
1: 
0:     private static char[] hex_table = {
1:                 '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
1:                 'a', 'b', 'c', 'd', 'e', 'f'
1:             };
1: 
1:     /**
0:         Convert a byte array to a String with a hexidecimal format.
1:         The String may be converted back to a byte array using fromHexString.
1:         <BR>
0:         For each byte (b) two characaters are generated, the first character
0:         represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
0:         the second character represents the low nibble (<code>b & 0x0f</code>).
1:         <BR>
0:         The byte at <code>data[offset]</code> is represented by the first two
1:         characters in the returned String.
1: 
0:         @param	data	byte array
0:         @param	offset	starting byte (zero based) to convert.
0:         @param	length	number of bytes to convert.
1: 
1:         @return the String (with hexidecimal format) form of the byte array
1:     */
1:     private String toHexString(byte[] data, int offset, int length)
1:     {
0: 		StringBuffer s = new StringBuffer(length*2);
1:         int end = offset+length;
1: 
1:         for (int i = offset; i < end; i++)
1:         {
1:             int high_nibble = (data[i] & 0xf0) >>> 4;
1:             int low_nibble = (data[i] & 0x0f);
1:             s.append(hex_table[high_nibble]);
1:             s.append(hex_table[low_nibble]);
1:         }
1: 
1:         return s.toString();
1:     }
1: 
1:     /**
1:   
1:         Convert a string into a byte array in hex format.
1:         <BR>
1:         For each character (b) two bytes are generated, the first byte 
0:         represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
0:         the second byte represents the low nibble (<code>b & 0x0f</code>).
1:         <BR>
0:         The character at <code>str.charAt(0)</code> is represented by the first two bytes 
0:         in the returned String.
1: 
0:         @param	str string 
0:         @param	offset	starting character (zero based) to convert.
0:         @param	length	number of characters to convert.
1: 
0:         @return the byte[]  (with hexidecimal format) form of the string (str) 
1:     */
1:     private byte[] toHexByte(String str, int offset, int length)
1:     {
1:         byte[] data = new byte[(length - offset) * 2];
1:         int end = offset+length;
1: 
1:         for (int i = offset; i < end; i++)
1:         {
1:             char ch = str.charAt(i);
1:             int high_nibble = (ch & 0xf0) >>> 4;
1:             int low_nibble = (ch & 0x0f);
1:             data[i] = (byte)high_nibble;
1:             data[i+1] = (byte)low_nibble;
1:         }
1:         return data;
1:     }
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:59bf37d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:David Van Couvering
-------------------------------------------------------------------------------
commit:e65b4db
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e); 
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.DES_KEY_HAS_WRONG_LENGTH), 
/////////////////////////////////////////////////////////////////////////
1:                     new ClientMessageId(SQLState.SHARED_KEY_LENGTH_ERROR),
/////////////////////////////////////////////////////////////////////////
1:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e);
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.CRYPTO_NO_SUCH_PADDING)); 
1:                         new ClientMessageId(SQLState.CRYPTO_BAD_PADDING)); 
1:                         new ClientMessageId(SQLState.CRYPTO_ILLEGAL_BLOCK_SIZE)); 
1:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e); 
/////////////////////////////////////////////////////////////////////////
1:                         new ClientMessageId(SQLState.CRYPTO_NO_SUCH_PADDING)); 
1:                         new ClientMessageId(SQLState.CRYPTO_BAD_PADDING)); 
1:                         new ClientMessageId(SQLState.CRYPTO_ILLEGAL_BLOCK_SIZE)); 
1:                 new ClientMessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e); 
commit:486829c
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.reference.SQLState;
1: 
/////////////////////////////////////////////////////////////////////////
0:         } catch (java.security.GeneralSecurityException e) {
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e); 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.DES_KEY_HAS_WRONG_LENGTH), 
0:                 new Integer(8), new Integer(key.length)); 
1:                         
/////////////////////////////////////////////////////////////////////////
1:                 throw new SqlException(agent_.logWriter_, 
0:                     new MessageId(SQLState.SHARED_KEY_LENGTH_ERROR),
0:                     new Integer(sharedSecret.length)); 
0:         catch (java.security.GeneralSecurityException e) {
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e);
1:         }
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.CRYPTO_NO_SUCH_PADDING)); 
1:             throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.CRYPTO_BAD_PADDING)); 
1:             throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.CRYPTO_ILLEGAL_BLOCK_SIZE)); 
0:         } catch (java.security.GeneralSecurityException e) {
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e); 
1: 
/////////////////////////////////////////////////////////////////////////
1:             throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.CRYPTO_NO_SUCH_PADDING)); 
1:             throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.CRYPTO_BAD_PADDING)); 
1:             throw new SqlException(agent_.logWriter_, 
0:                         new MessageId(SQLState.CRYPTO_ILLEGAL_BLOCK_SIZE)); 
0:         } catch (java.security.GeneralSecurityException e) {
1:             throw new SqlException(agent_.logWriter_, 
0:                 new MessageId(SQLState.SECURITY_EXCEPTION_ENCOUNTERED), e); 
author:Jeremy Boynes
-------------------------------------------------------------------------------
commit:70f7692
/////////////////////////////////////////////////////////////////////////
1: 
1: import java.security.Security;
/////////////////////////////////////////////////////////////////////////
1: public class EncryptionManager {
0:     transient Agent agent_; // for obtaining an exception log writer only
1:     // PROTOCOL's Diffie-Hellman agreed public value: prime.
1:     private static final byte modulusBytes__[] = {
1:         (byte) 0xC6, (byte) 0x21, (byte) 0x12, (byte) 0xD7,
1:         (byte) 0x3E, (byte) 0xE6, (byte) 0x13, (byte) 0xF0,
1:         (byte) 0x94, (byte) 0x7A, (byte) 0xB3, (byte) 0x1F,
1:         (byte) 0x0F, (byte) 0x68, (byte) 0x46, (byte) 0xA1,
1:         (byte) 0xBF, (byte) 0xF5, (byte) 0xB3, (byte) 0xA4,
1:         (byte) 0xCA, (byte) 0x0D, (byte) 0x60, (byte) 0xBC,
1:         (byte) 0x1E, (byte) 0x4C, (byte) 0x7A, (byte) 0x0D,
1:         (byte) 0x8C, (byte) 0x16, (byte) 0xB3, (byte) 0xE3
1:     };
1:     //the prime value in BigInteger form. It has to be in BigInteger form because this
1:     //is the form used in JCE library.
0:     private static final java.math.BigInteger modulus__
0:             = new java.math.BigInteger(1, modulusBytes__);
1:     //  PROTOCOL's Diffie-Hellman agreed public value: base.
1:     private static final byte baseBytes__[] = {
1:         (byte) 0x46, (byte) 0x90, (byte) 0xFA, (byte) 0x1F,
1:         (byte) 0x7B, (byte) 0x9E, (byte) 0x1D, (byte) 0x44,
1:         (byte) 0x42, (byte) 0xC8, (byte) 0x6C, (byte) 0x91,
1:         (byte) 0x14, (byte) 0x60, (byte) 0x3F, (byte) 0xDE,
1:         (byte) 0xCF, (byte) 0x07, (byte) 0x1E, (byte) 0xDC,
1:         (byte) 0xEC, (byte) 0x5F, (byte) 0x62, (byte) 0x6E,
1:         (byte) 0x21, (byte) 0xE2, (byte) 0x56, (byte) 0xAE,
1:         (byte) 0xD9, (byte) 0xEA, (byte) 0x34, (byte) 0xE4
1:     };
1:     // The base value in BigInteger form.
0:     private static final java.math.BigInteger base__ =
0:             new java.math.BigInteger(1, baseBytes__);
1:     //PROTOCOL's Diffie-Hellman agreed exponential length
1:     private static final int exponential_length__ = 255;
0:     private javax.crypto.spec.DHParameterSpec paramSpec_;
0:     private java.security.KeyPairGenerator keyPairGenerator_;
0:     private java.security.KeyPair keyPair_;
0:     private javax.crypto.KeyAgreement keyAgreement_;
1:     private byte[] token_; // init vector
1:     private byte[] secKey_; // security key
0:     private javax.crypto.SecretKeyFactory secretKeyFactory_ = null;
1:     private String providerName; // security provider name
1:     private Provider provider;
1:     // EncryptionManager constructor. In this constructor,DHParameterSpec,
1:     // KeyPairGenerator, KeyPair, and KeyAgreement  are initialized.
1:     public EncryptionManager(Agent agent) throws SqlException {
1:         agent_ = agent;
1:         try {
1:             // get a security provider that supports the diffie helman key agreement algorithm
1:             Provider[] list = Security.getProviders("KeyAgreement.DH");
1:             if (list == null) {
0:                 throw new java.security.NoSuchProviderException();
1:             }
1:             provider = list[0];
1:             providerName = provider.getName();
0:             java.security.Security.addProvider((java.security.Provider) provider);
0:             paramSpec_ = new javax.crypto.spec.DHParameterSpec(modulus__, base__, exponential_length__);
0:             keyPairGenerator_ = java.security.KeyPairGenerator.getInstance("DH", providerName);
1:             keyPairGenerator_.initialize(paramSpec_);
1:             keyPair_ = keyPairGenerator_.generateKeyPair();
0:             keyAgreement_ = javax.crypto.KeyAgreement.getInstance("DH", providerName);
1:             keyAgreement_.init(keyPair_.getPrivate());
0:         } catch (java.security.NoSuchProviderException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.NoSuchProviderException is caught" +
0:                     " when initializing EncryptionManager '" + e.getMessage() + "'");
0:         } catch (java.security.NoSuchAlgorithmException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.NoSuchAlgorithmException is caught" +
0:                     " when initializing EncryptionManager '" + e.getMessage() + "'");
0:         } catch (java.security.InvalidAlgorithmParameterException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.InvalidAlgorithmParameterException is caught" +
0:                     " when initializing EncryptionManager '" + e.getMessage() + "'");
0:         } catch (java.security.InvalidKeyException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.InvalidKeyException is caught" +
0:                     " when initializing EncryptionManager '" + e.getMessage() + "'");
1:         }
1:     // This method generates the public key and returns it. This
1:     // shared public key is the application requester's connection key and will
1:     // be exchanged with the application server's connection key. This connection
1:     // key will be put in the sectkn in ACCSEC command and send to the application
1:     // server.
1:     // @param   null
1:     // @return  a byte array that is the application requester's public key
1:     public byte[] obtainPublicKey() {
1:         //we need to get the plain form public key because PROTOCOL accepts plain form
1:         //public key only.
0:         java.math.BigInteger aPub = ((javax.crypto.interfaces.DHPublicKey) keyPair_.getPublic()).getY();
1:         byte[] aPubKey = aPub.toByteArray();
1:         //the following lines of code is to adjust the length of the key. PublicKey
1:         //in JCE is in the form of BigInteger and it's a signed value. When tranformed
1:         //to a Byte array form, normally this array is 32 bytes. However, if the
1:         //value happens to take up all 32 X 8 bits and it is positive, an extra
1:         //bit is needed and then a 33 byte array will be returned. Since PROTOCOL can't
1:         //recogize the 33 byte key, we check the length here, if the length is 33,
1:         //we will just trim off the first byte (0) and get the rest of 32 bytes.
1:         if (aPubKey.length == 33 && aPubKey[0] == 0) {
1:             //System.out.println ("Adjust length");
1:             byte[] newKey = new byte[32];
1:             for (int i = 0; i < newKey.length; i++) {
1:                 newKey[i] = aPubKey[i + 1];
1:             }
1:             return newKey;
1:         }
1:         //the following lines of code is to adjust the length of the key. Occasionally,
1:         //the length of the public key is less than 32, the reason of this is that the 0 byte
1:         //in the beginning is somehow not returned. So we check the length here, if the length
1:         //is less than 32, we will pad 0 in the beginning to make the public key 32 bytes
1:         if (aPubKey.length < 32) {
1:             byte[] newKey = new byte[32];
1:             int i;
1:             for (i = 0; i < 32 - aPubKey.length; i++) {
1:                 newKey[i] = 0;
1:             }
1:             for (int j = i; j < newKey.length; j++) {
1:                 newKey[j] = aPubKey[j - i];
1:             }
1:             return newKey;
1:         }
1:         return aPubKey;
1:     // This method is used to calculate the encryption token. DES encrypts the
1:     // data using a token and the generated shared private key. The token used
1:     // depends on the type of security mechanism being used:
1:     // USRENCPWD - The userid is used as the token. The USRID is zero-padded to
1:     // 8 bytes if less than 8 bytes or truncated to 8 bytes if greater than 8 bytes.
1:     // EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
1:     // the token.
1:     // @param  int     securityMechanism
1:     // @param  byte[]  userid or server's connection key
1:     // @return byte[]  the encryption token
1:     private byte[] calculateEncryptionToken(int securityMechanism, byte[] initVector) {
1:         byte[] token = new byte[8];
1:         //USRENCPWD, the userid is used as token
1:         if (securityMechanism == 7) {
1:             if (initVector.length < 8) { //shorter than 8 bytes, zero padded to 8 bytes
0:                 for (int i = 0; i < initVector.length; i++) {
0:                     token[i] = initVector[i];
1:                 }
1:                 for (int i = initVector.length; i < 8; i++) {
1:                     token[i] = 0;
1:                 }
1:             } else {  //longer than 8 bytes, truncated to 8 bytes
1:                 for (int i = 0; i < 8; i++) {
0:                     token[i] = initVector[i];
1:                 }
1:             }
1:         }
1:         //EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
1:         //the token.
1:         else if (securityMechanism == 9) {
1:             for (int i = 0; i < 8; i++) {
1:                 token[i] = initVector[i + 12];
1:             }
1:         }
1:         return token;
1:     //JDK 1.4 has a parity check on the DES encryption key. Each byte needs to have an odd number
1:     //of "1"s in it, and this is required by DES. Otherwise JDK 1.4 throws InvalidKeyException.
1:     //Older JDK doesn't check this. In order to make encryption work with JDK1.4, we are going to
1:     //check each of the 8 byte of our key and flip the last bit if it has even number of 1s.
1:     private void keyParityCheck(byte[] key) throws SqlException {
1:         byte temp;
1:         int changeParity;
1:         if (key.length != 8) {
0:             throw new SqlException(agent_.logWriter_, "DES key has the wrong length");
1:         }
1:         for (int i = 0; i < 8; i++) {
1:             temp = key[i];
1:             changeParity = 1;
1:             for (int j = 0; j < 8; j++) {
1:                 if (temp < 0) {
1:                     changeParity = 1 - changeParity;
1:                 }
1:                 temp = (byte) (temp << 1);
1:             }
1:             if (changeParity == 1) {
1:                 if ((key[i] & 1) != 0) {
1:                     key[i] &= 0xfe;
1:                 } else {
1:                     key[i] |= 1;
1:                 }
1:             }
1:         }
1: 
1:     // This method generates a secret key using the application server's
1:     // public key
1:     private byte[] generatePrivateKey(byte[] targetPublicKey) throws SqlException {
1:         try {
1: 
1:             //initiate a Diffie_Hellman KeyFactory object.
0:             java.security.KeyFactory keyFac = java.security.KeyFactory.getInstance("DH", provider);
1: 
1:             //Use server's public key to initiate a DHPublicKeySpec and then use
1:             //this DHPublicKeySpec to initiate a publicKey object
0:             java.math.BigInteger publicKey = new java.math.BigInteger(1, targetPublicKey);
0:             javax.crypto.spec.DHPublicKeySpec dhKeySpec =
0:                     new javax.crypto.spec.DHPublicKeySpec(publicKey, modulus__, base__);
0:             java.security.PublicKey pubKey = keyFac.generatePublic(dhKeySpec);
1: 
1:             //Execute the first phase of DH keyagreement protocal.
1:             keyAgreement_.doPhase(pubKey, true);
1: 
1:             //generate the shared secret key. The application requestor's shared secret
1:             //key should be exactly the same as the application server's shared secret
1:             //key
1:             byte[] sharedSecret = keyAgreement_.generateSecret();
1:             byte[] newKey = new byte[32];
1: 
1:             //We adjust the length here. If the length of secret key is 33 and the first byte is 0,
1:             //we trim off the frist byte. If the length of secret key is less than 32, we will
1:             //pad 0 to the beginning of the byte array tho make the secret key 32 bytes.
1:             if (sharedSecret.length == 33 && sharedSecret[0] == 0) {
1:                 for (int i = 0; i < newKey.length; i++) {
1:                     newKey[i] = sharedSecret[i + 1];
1:                 }
1: 
1:             }
1:             if (sharedSecret.length < 32) {
1:                 int i;
1:                 for (i = 0; i < (32 - sharedSecret.length); i++) {
1:                     newKey[i] = 0;
1:                 }
1:                 for (int j = i; j < sharedSecret.length; j++) {
1:                     newKey[j] = sharedSecret[j - i];
1:                 }
1:             }
1: 
1:             //The Data Encryption Standard (DES) is going to be used to encrypt userid
1:             //and password. DES is a block cipher; it encrypts data in 64-bit blocks.
1:             //PROTOCOL encryption uses DES CBC mode as defined by the FIPS standard
1:             //DES CBC requires an encryption key and an 8 byte token to encrypt the data.
1:             //The middle 8 bytes of Diffie-Hellman shared private key is used as the
1:             //encryption key. The following code retrieves middle 8 bytes of the shared
1:             //private key.
1:             byte[] key = new byte[8];
1: 
1:             //if secret key is not 32, we will use the adjust length secret key
1:             if (sharedSecret.length == 32) {
1:                 for (int i = 0; i < 8; i++) {
1:                     key[i] = sharedSecret[i + 12];
1:                 }
1:             } else if (sharedSecret.length == 33 || sharedSecret.length < 32) {
1:                 for (int i = 0; i < 8; i++) {
1:                     key[i] = newKey[i + 12];
1:                 }
1:             } else {
0:                 throw new SqlException(agent_.logWriter_, "sharedSecret key length error " + sharedSecret.length);
1:             }
1: 
1:             //we do parity check here and flip the parity bit if the byte has even number of 1s
1:             keyParityCheck(key);
1:             return key;
0:         }/*
0:           catch (java.security.NoSuchProviderException e) {
0:             throw new SqlException (agent_.logWriter_, e, "java.security.NoSuchProviderException is caught "
0:                                     + "when encrypting data '" + e.getMessage() + "'");
0:           }*/ catch (java.security.NoSuchAlgorithmException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.NoSuchAlgorithmException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (java.security.spec.InvalidKeySpecException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.InvalidKeySpecException is caught "
0:                     + "when encrypting data");
0:         } catch (java.security.InvalidKeyException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.InvalidKeyException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
1:         }
1:     // This method encrypts the usreid/password with the middle 8 bytes of
1:     // the generated secret key and an encryption token. Then it returns the
1:     // encrypted data in a byte array.
1:     // plainText   The byte array form userid/password to encrypt.
1:     // initVector  The byte array which is used to calculate the
1:     //                             encryption token.
1:     // targetPublicKey   DERBY' public key.
1:     // Returns the encrypted data in a byte array.
1:     public byte[] encryptData(byte[] plainText,
1:                               int securityMechanism,
1:                               byte[] initVector,
1:                               byte[] targetPublicKey) throws SqlException {
1:         byte[] cipherText = null;
0:         java.security.Key key = null;
1:         if (token_ == null) {
1:             token_ = calculateEncryptionToken(securityMechanism, initVector);
1:         }
1: 
1:         try {
1:             if (secKey_ == null) {
1:                 //use this encryption key to initiate a SecretKeySpec object
1:                 secKey_ = generatePrivateKey(targetPublicKey);
0:                 javax.crypto.spec.SecretKeySpec desKey = new javax.crypto.spec.SecretKeySpec(secKey_, "DES");
1:                 key = desKey;
1:             } else {
1:                 //use this encryption key to initiate a SecretKeySpec object
0:                 javax.crypto.spec.DESKeySpec desKey = new javax.crypto.spec.DESKeySpec(secKey_);
1:                 if (secretKeyFactory_ == null) {
0:                     secretKeyFactory_ = javax.crypto.SecretKeyFactory.getInstance("DES", providerName);
1:                 }
1:                 key = secretKeyFactory_.generateSecret(desKey);
1:             }
1: 
1:             //We use DES in CBC mode because this is the mode used in PROTOCOL. The
1:             //encryption mode has to be consistent for encryption and decryption.
1:             //CBC mode requires an initialization vector(IV) parameter. In CBC mode
1:             //we need to initialize the Cipher object with an IV, which can be supplied
1:             // using the javax.crypto.spec.IvParameterSpec class.
0:             javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance("DES/CBC/PKCS5Padding", providerName);
1: 
1:             //generate a IVParameterSpec object and use it to initiate the
1:             //Cipher object.
0:             javax.crypto.spec.IvParameterSpec ivParam = new javax.crypto.spec.IvParameterSpec(token_);
1: 
1:             //initiate the Cipher using encryption mode, encryption key and the
1:             //IV parameter.
0:             cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, key, ivParam);
1: 
1:             //Execute the final phase of encryption
1:             cipherText = cipher.doFinal(plainText);
0:         } catch (java.security.NoSuchProviderException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.NoSuchProviderException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (java.security.NoSuchAlgorithmException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.NoSuchAlgorithmException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (java.security.InvalidKeyException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.InvalidKeyException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (javax.crypto.NoSuchPaddingException e) {
0:             throw new SqlException(agent_.logWriter_, e, "javax.crypto.NoSuchPaddingException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (javax.crypto.BadPaddingException e) {
0:             throw new SqlException(agent_.logWriter_, e, "javax.crypto.BadPaddingException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (java.security.InvalidAlgorithmParameterException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.InvalidAlgorithmParameterException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (javax.crypto.IllegalBlockSizeException e) {
0:             throw new SqlException(agent_.logWriter_, e, "javax.crypto.IllegalBlockSizeException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (java.security.spec.InvalidKeySpecException e) {
0:             throw new SqlException(agent_.logWriter_, e, "javax.crypto.IllegalBlockSizeException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
1:         }
1:         return cipherText;
1:     }
1: 
1: 
1:     // This method decrypts the usreid/password with the middle 8 bytes of
1:     // the generated secret key and an encryption token. Then it returns the
1:     // decrypted data in a byte array.
1:     // plainText   The byte array form userid/password to encrypt.
1:     // initVector  The byte array which is used to calculate the
1:     //                             encryption token.
1:     // targetPublicKey   DERBY' public key.
1:     // Returns the decrypted data in a byte array.
1:     public byte[] decryptData(byte[] cipherText,
1:                               int securityMechanism,
1:                               byte[] initVector,
1:                               byte[] targetPublicKey) throws SqlException {
1: 
1:         byte[] plainText = null;
0:         java.security.Key key = null;
1: 
1:         if (token_ == null) {
1:             token_ = calculateEncryptionToken(securityMechanism, initVector);
1:         }
1: 
1:         try {
1:             if (secKey_ == null) {
1:                 //use this encryption key to initiate a SecretKeySpec object
1:                 secKey_ = generatePrivateKey(targetPublicKey);
0:                 javax.crypto.spec.SecretKeySpec desKey = new javax.crypto.spec.SecretKeySpec(secKey_, "DES");
1:                 key = desKey;
1:             } else {
1:                 //use this encryption key to initiate a SecretKeySpec object
0:                 javax.crypto.spec.DESKeySpec desKey = new javax.crypto.spec.DESKeySpec(secKey_);
1:                 if (secretKeyFactory_ == null) {
0:                     secretKeyFactory_ = javax.crypto.SecretKeyFactory.getInstance("DES", providerName);
1:                 }
1:                 key = secretKeyFactory_.generateSecret(desKey);
1:             }
1: 
1:             //We use DES in CBC mode because this is the mode used in PROTOCOL. The
1:             //encryption mode has to be consistent for encryption and decryption.
1:             //CBC mode requires an initialization vector(IV) parameter. In CBC mode
1:             //we need to initialize the Cipher object with an IV, which can be supplied
1:             // using the javax.crypto.spec.IvParameterSpec class.
0:             javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance("DES/CBC/PKCS5Padding", providerName);
1: 
1:             //generate a IVParameterSpec object and use it to initiate the
1:             //Cipher object.
0:             javax.crypto.spec.IvParameterSpec ivParam = new javax.crypto.spec.IvParameterSpec(token_);
1: 
1:             //initiate the Cipher using encryption mode, encryption key and the
1:             //IV parameter.
0:             cipher.init(javax.crypto.Cipher.DECRYPT_MODE, key, ivParam);
1: 
1:             //Execute the final phase of encryption
1:             plainText = cipher.doFinal(cipherText);
0:         } catch (java.security.NoSuchProviderException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.NoSuchProviderException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (java.security.NoSuchAlgorithmException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.NoSuchAlgorithmException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (java.security.InvalidKeyException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.InvalidKeyException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (javax.crypto.NoSuchPaddingException e) {
0:             throw new SqlException(agent_.logWriter_, e, "javax.crypto.NoSuchPaddingException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (javax.crypto.BadPaddingException e) {
0:             throw new SqlException(agent_.logWriter_, e, "javax.crypto.BadPaddingException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (java.security.InvalidAlgorithmParameterException e) {
0:             throw new SqlException(agent_.logWriter_, e, "java.security.InvalidAlgorithmParameterException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (javax.crypto.IllegalBlockSizeException e) {
0:             throw new SqlException(agent_.logWriter_, e, "javax.crypto.IllegalBlockSizeException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
0:         } catch (java.security.spec.InvalidKeySpecException e) {
0:             throw new SqlException(agent_.logWriter_, e, "javax.crypto.IllegalBlockSizeException is caught "
0:                     + "when encrypting data '" + e.getMessage() + "'");
1:         }
1:         return plainText;
1:     }
1: 
0:     public void setInitVector(byte[] initVector) {
0:         token_ = initVector;
1:     }
1: 
0:     public void setSecKey(byte[] secKey) {
0:         secKey_ = secKey;
1:     }
1: 
1:     public void resetSecurityKeys() {
1:         token_ = null;
1:         secKey_ = null;
1:     }
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:33776ff
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.client.am.EncryptionManager
1: 
0:    Copyright (c) 2001, 2005 The Apache Software Foundation or its licensors, where applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
0: */
1: 
1: package org.apache.derby.client.am;
0: import java.security.Security;
1: import java.security.Provider;
1: 
1: // This class is get used when using encrypted password and/or userid mechanism.
1: // The <b>EncryptionManager</b> classs uses Diffie_Hellman algorithm to get the publick key and
1: // secret key, and then DES encryption is done using certain token (based on security
1: // mechanism) and server side's public key. Basically, this class is called when using
1: // security mechanism User ID and encrypted password (usrencpwd) and Encrypted user ID and password
1: // (eusridpwd).
1: // This class uses JCE provider to do Diffie_Hellman algorithm and DES encryption,
1: // obtainPublicKey(), calculateEncryptionToken(int, byte[]) and encryptData(byte[], int, byte[], byte[])
1: // The agreed public value for the Diffie-Hellman prime is 256 bits
1: // and hence the encrytion will work only if the jce provider supports a 256 bits prime
1: 
0: public class EncryptionManager
0: {
0:   transient Agent agent_; // for obtaining an exception log writer only
1: 
0:   // PROTOCOL's Diffie-Hellman agreed public value: prime.
0:   private static final byte modulusBytes__[] = {
0:     (byte)0xC6, (byte)0x21, (byte)0x12, (byte)0xD7,
0:     (byte)0x3E, (byte)0xE6, (byte)0x13, (byte)0xF0,
0:     (byte)0x94, (byte)0x7A, (byte)0xB3, (byte)0x1F,
0:     (byte)0x0F, (byte)0x68, (byte)0x46, (byte)0xA1,
0:     (byte)0xBF, (byte)0xF5, (byte)0xB3, (byte)0xA4,
0:     (byte)0xCA, (byte)0x0D, (byte)0x60, (byte)0xBC,
0:     (byte)0x1E, (byte)0x4C, (byte)0x7A, (byte)0x0D,
0:     (byte)0x8C, (byte)0x16, (byte)0xB3, (byte)0xE3
0:   };
1: 
0:   //the prime value in BigInteger form. It has to be in BigInteger form because this
0:   //is the form used in JCE library.
0:   private static final java.math.BigInteger modulus__
0:   = new java.math.BigInteger (1, modulusBytes__);
1: 
0:   //  PROTOCOL's Diffie-Hellman agreed public value: base.
0:   private static final byte baseBytes__[] = {
0:     (byte)0x46, (byte)0x90, (byte)0xFA, (byte)0x1F,
0:     (byte)0x7B, (byte)0x9E, (byte)0x1D, (byte)0x44,
0:     (byte)0x42, (byte)0xC8, (byte)0x6C, (byte)0x91,
0:     (byte)0x14, (byte)0x60, (byte)0x3F, (byte)0xDE,
0:     (byte)0xCF, (byte)0x07, (byte)0x1E, (byte)0xDC,
0:     (byte)0xEC, (byte)0x5F, (byte)0x62, (byte)0x6E,
0:     (byte)0x21, (byte)0xE2, (byte)0x56, (byte)0xAE,
0:     (byte)0xD9, (byte)0xEA, (byte)0x34, (byte)0xE4
0:   };
1: 
0:   // The base value in BigInteger form.
0:   private static final java.math.BigInteger base__ =
0:     new java.math.BigInteger (1, baseBytes__);
1: 
0:   //PROTOCOL's Diffie-Hellman agreed exponential length
0:   private static final int exponential_length__ = 255;
1: 
0:   private javax.crypto.spec.DHParameterSpec paramSpec_;
0:   private java.security.KeyPairGenerator keyPairGenerator_;
0:   private java.security.KeyPair keyPair_;
0:   private javax.crypto.KeyAgreement keyAgreement_;
1: 
0:   private byte[] token_; // init vector
0:   private byte[] secKey_; // security key
0:   private javax.crypto.SecretKeyFactory secretKeyFactory_ = null;
0:   private String providerName; // security provider name
0:   private Provider provider;
1: 
0:   // EncryptionManager constructor. In this constructor,DHParameterSpec,
0:   // KeyPairGenerator, KeyPair, and KeyAgreement  are initialized.
0:   public EncryptionManager (Agent agent) throws SqlException
0:   {
0:     agent_ = agent;
0:     try
0:     {
0:       // get a security provider that supports the diffie helman key agreement algorithm
0:       Provider[] list = Security.getProviders("KeyAgreement.DH");
0:       if(list == null)
0: 		 throw new java.security.NoSuchProviderException();
0:       provider = list[0];
0:       providerName = provider.getName();
1: 
0:       java.security.Security.addProvider ((java.security.Provider) provider);
1: 
0:       paramSpec_ = new javax.crypto.spec.DHParameterSpec (modulus__, base__, exponential_length__);
0:       keyPairGenerator_ = java.security.KeyPairGenerator.getInstance ("DH", providerName);
0:       keyPairGenerator_.initialize (paramSpec_);
0:       keyPair_ = keyPairGenerator_.generateKeyPair();
0:       keyAgreement_ = javax.crypto.KeyAgreement.getInstance ("DH", providerName);
0:       keyAgreement_.init (keyPair_.getPrivate());
1:     }
0:     catch (java.security.NoSuchProviderException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.NoSuchProviderException is caught" +
0:                               " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.NoSuchAlgorithmException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.NoSuchAlgorithmException is caught" +
0:             " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.InvalidAlgorithmParameterException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.InvalidAlgorithmParameterException is caught" +
0:             " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1: 
0:     catch (java.security.InvalidKeyException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.InvalidKeyException is caught" +
0:             " when initializing EncryptionManager '" + e.getMessage() + "'");
1:     }
1:   }
1: 
0:   // This method generates the public key and returns it. This
0:   // shared public key is the application requester's connection key and will
0:   // be exchanged with the application server's connection key. This connection
0:   // key will be put in the sectkn in ACCSEC command and send to the application
0:   // server.
0:   // @param   null
0:   // @return  a byte array that is the application requester's public key
0:   public byte[] obtainPublicKey ()
0:   {
1: 
0:     //we need to get the plain form public key because PROTOCOL accepts plain form
0:     //public key only.
0:     java.math.BigInteger aPub = ((javax.crypto.interfaces.DHPublicKey) keyPair_.getPublic()).getY();
0:     byte[] aPubKey = aPub.toByteArray();
1: 
0:     //the following lines of code is to adjust the length of the key. PublicKey
0:     //in JCE is in the form of BigInteger and it's a signed value. When tranformed
0:     //to a Byte array form, normally this array is 32 bytes. However, if the
0:     //value happens to take up all 32 X 8 bits and it is positive, an extra
0:     //bit is needed and then a 33 byte array will be returned. Since PROTOCOL can't
0:     //recogize the 33 byte key, we check the length here, if the length is 33,
0:     //we will just trim off the first byte (0) and get the rest of 32 bytes.
0:     if (aPubKey.length == 33 && aPubKey[0]==0) {
0:       //System.out.println ("Adjust length");
0:       byte[] newKey = new byte[32];
0:       for (int i=0; i < newKey.length; i++)
0:   newKey[i] = aPubKey[i+1];
0:       return newKey;
1:     }
1: 
0:     //the following lines of code is to adjust the length of the key. Occasionally,
0:     //the length of the public key is less than 32, the reason of this is that the 0 byte
0:     //in the beginning is somehow not returned. So we check the length here, if the length
0:     //is less than 32, we will pad 0 in the beginning to make the public key 32 bytes
0:     if (aPubKey.length < 32) {
0:       byte[] newKey = new byte[32];
0:       int i;
0:       for (i=0; i < 32-aPubKey.length; i++) {
0:   newKey[i] = 0;
1:       }
0:       for (int j=i; j<newKey.length; j++)
0:   newKey[j] = aPubKey[j-i];
0:       return newKey;
1:     }
0:     return aPubKey;
1:   }
1: 
0:   // This method is used to calculate the encryption token. DES encrypts the
0:   // data using a token and the generated shared private key. The token used
0:   // depends on the type of security mechanism being used:
0:   // USRENCPWD - The userid is used as the token. The USRID is zero-padded to
0:   // 8 bytes if less than 8 bytes or truncated to 8 bytes if greater than 8 bytes.
0:   // EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
0:   // the token.
0:   // @param  int     securityMechanism
0:   // @param  byte[]  userid or server's connection key
0:   // @return byte[]  the encryption token
0:   private byte[] calculateEncryptionToken (int securityMechanism, byte[] initVector)
0:   {
0:     byte[] token = new byte[8];
1: 
0:     //USRENCPWD, the userid is used as token
0:     if (securityMechanism == 7) {
0:       if (initVector.length < 8) { //shorter than 8 bytes, zero padded to 8 bytes
0:   for (int i=0; i<initVector.length; i++)
0:     token[i] = initVector[i];
0:   for (int i=initVector.length; i<8; i++)
0:     token[i] = 0;
1:       }
0:       else {  //longer than 8 bytes, truncated to 8 bytes
0:   for (int i=0; i<8; i++)
0:     token[i] = initVector[i];
1:       }
1:     }
0:     //EUSRIDPWD - The middle 8 bytes of the server's connection key is used as
0:     //the token.
0:     else if (securityMechanism == 9) {
0:       for (int i = 0; i < 8; i++) {
0:   token[i] = initVector[i + 12];
1:       }
1:     }
0:     return token;
1:   }
1: 
0:   //JDK 1.4 has a parity check on the DES encryption key. Each byte needs to have an odd number
0:   //of "1"s in it, and this is required by DES. Otherwise JDK 1.4 throws InvalidKeyException.
0:   //Older JDK doesn't check this. In order to make encryption work with JDK1.4, we are going to
0:   //check each of the 8 byte of our key and flip the last bit if it has even number of 1s.
0:   private void keyParityCheck(byte[] key) throws SqlException
0:   {
0:      byte temp;
0:      int changeParity;
0:      if (key.length!=8)
0:        throw new SqlException (agent_.logWriter_, "DES key has the wrong length");
0:      for (int i=0; i<8; i++)
0:      {
0:   temp = key[i];
0:   changeParity = 1;
0:   for (int j=0; j<8; j++)
0:   {
0:     if (temp < 0)
0:       changeParity = 1 - changeParity;
0:     temp = (byte) (temp << 1);
1:   }
0:   if (changeParity == 1)
0:   {
0:     if ((key[i] & 1) != 0)
0:       key[i] &= 0xfe;
0:     else
0:       key[i] |= 1;
1:   }
1:       }
1:     }
1: 
0:   // This method generates a secret key using the application server's
0:   // public key
0:   private byte[] generatePrivateKey (byte[] targetPublicKey) throws SqlException
0:   {
0:     try {
1: 
0:       //initiate a Diffie_Hellman KeyFactory object.
0:       java.security.KeyFactory keyFac = java.security.KeyFactory.getInstance ("DH", provider);
1: 
0:       //Use server's public key to initiate a DHPublicKeySpec and then use
0:       //this DHPublicKeySpec to initiate a publicKey object
0:       java.math.BigInteger publicKey = new java.math.BigInteger (1, targetPublicKey);
0:       javax.crypto.spec.DHPublicKeySpec dhKeySpec =
0:         new javax.crypto.spec.DHPublicKeySpec (publicKey, modulus__, base__);
0:       java.security.PublicKey pubKey = keyFac.generatePublic (dhKeySpec);
1: 
0:       //Execute the first phase of DH keyagreement protocal.
0:       keyAgreement_.doPhase (pubKey, true);
1: 
0:       //generate the shared secret key. The application requestor's shared secret
0:       //key should be exactly the same as the application server's shared secret
0:       //key
0:       byte[] sharedSecret = keyAgreement_.generateSecret();
0:       byte[] newKey = new byte[32];
1: 
0:       //We adjust the length here. If the length of secret key is 33 and the first byte is 0,
0:       //we trim off the frist byte. If the length of secret key is less than 32, we will
0:       //pad 0 to the beginning of the byte array tho make the secret key 32 bytes.
0:       if (sharedSecret.length == 33 && sharedSecret[0] == 0) {
0:   for (int i=0; i<newKey.length; i++)
0:     newKey[i] = sharedSecret[i+1];
1: 
1:       }
0:       if (sharedSecret.length < 32) {
0:   int i;
0:   for (i=0; i<(32 - sharedSecret.length); i++) {
0:     newKey[i] = 0;
1:   }
0:   for (int j=i; j<sharedSecret.length; j++)
0:     newKey[j] = sharedSecret[j-i];
1:       }
1: 
0:       //The Data Encryption Standard (DES) is going to be used to encrypt userid
0:       //and password. DES is a block cipher; it encrypts data in 64-bit blocks.
0:       //PROTOCOL encryption uses DES CBC mode as defined by the FIPS standard
0:       //DES CBC requires an encryption key and an 8 byte token to encrypt the data.
0:       //The middle 8 bytes of Diffie-Hellman shared private key is used as the
0:       //encryption key. The following code retrieves middle 8 bytes of the shared
0:       //private key.
0:       byte[] key = new byte[8];
1: 
0:       //if secret key is not 32, we will use the adjust length secret key
0:       if (sharedSecret.length==32) {
0:   for (int i=0; i< 8;i++)
0:     key[i] = sharedSecret[i+12];
1:       }
0:       else if (sharedSecret.length==33 || sharedSecret.length < 32) {
0:   for (int i=0; i< 8;i++)
0:     key[i] = newKey[i+12];
1:       }
0:       else
0:   throw new SqlException (agent_.logWriter_, "sharedSecret key length error " + sharedSecret.length);
1: 
0:       //we do parity check here and flip the parity bit if the byte has even number of 1s
0:       keyParityCheck(key);
0:       return key;
0:       }/*
0:       catch (java.security.NoSuchProviderException e) {
0:         throw new SqlException (agent_.logWriter_, e, "java.security.NoSuchProviderException is caught "
0:                                 + "when encrypting data '" + e.getMessage() + "'");
0:       }*/
0:       catch (java.security.NoSuchAlgorithmException e) {
0:         throw new SqlException (agent_.logWriter_, e, "java.security.NoSuchAlgorithmException is caught "
0:                                 + "when encrypting data '" + e.getMessage() + "'");
1:       }
0:       catch (java.security.spec.InvalidKeySpecException e) {
0:         throw new SqlException (agent_.logWriter_, e, "java.security.InvalidKeySpecException is caught "
0:                                 + "when encrypting data");
1:       }
0:       catch (java.security.InvalidKeyException e) {
0:         throw new SqlException (agent_.logWriter_, e, "java.security.InvalidKeyException is caught "
0:                                 + "when encrypting data '" + e.getMessage() + "'");
1:       }
1: 
1: 
1:   }
1: 
0:   // This method encrypts the usreid/password with the middle 8 bytes of
0:   // the generated secret key and an encryption token. Then it returns the
0:   // encrypted data in a byte array.
0:   // plainText   The byte array form userid/password to encrypt.
0:   // initVector  The byte array which is used to calculate the
0:   //                             encryption token.
0:   // targetPublicKey   DERBY' public key.
0:   // Returns the encrypted data in a byte array.
0:   public byte[] encryptData (byte[] plainText,
0:            int    securityMechanism,
0:            byte[] initVector,
0:            byte[] targetPublicKey) throws SqlException
0:   {
1: 
0:     byte[] cipherText = null;
0:     java.security.Key key = null;
1: 
0:     if (token_ == null)
0:       token_ = calculateEncryptionToken (securityMechanism, initVector);
1: 
0:     try{
0:       if (secKey_ == null)
0:       {
0:         //use this encryption key to initiate a SecretKeySpec object
0:         secKey_ = generatePrivateKey (targetPublicKey);
0:         javax.crypto.spec.SecretKeySpec desKey = new javax.crypto.spec.SecretKeySpec (secKey_, "DES");
0:         key = desKey;
1:       }
0:       else
0:       {
0:       //use this encryption key to initiate a SecretKeySpec object
0:         javax.crypto.spec.DESKeySpec desKey = new javax.crypto.spec.DESKeySpec (secKey_);
0:         if (secretKeyFactory_ == null)
0:           secretKeyFactory_ = javax.crypto.SecretKeyFactory.getInstance("DES", providerName);
0:         key = secretKeyFactory_.generateSecret(desKey);
1:       }
1: 
0:       //We use DES in CBC mode because this is the mode used in PROTOCOL. The
0:       //encryption mode has to be consistent for encryption and decryption.
0:       //CBC mode requires an initialization vector(IV) parameter. In CBC mode
0:       //we need to initialize the Cipher object with an IV, which can be supplied
0:       // using the javax.crypto.spec.IvParameterSpec class.
0:       javax.crypto.Cipher cipher= javax.crypto.Cipher.getInstance ("DES/CBC/PKCS5Padding", providerName);
1: 
0:       //generate a IVParameterSpec object and use it to initiate the
0:       //Cipher object.
0:       javax.crypto.spec.IvParameterSpec ivParam = new javax.crypto.spec.IvParameterSpec (token_);
1: 
0:       //initiate the Cipher using encryption mode, encryption key and the
0:       //IV parameter.
0:       cipher.init (javax.crypto.Cipher.ENCRYPT_MODE, key, ivParam);
1: 
0:       //Execute the final phase of encryption
0:       cipherText = cipher.doFinal (plainText);
1:     }
0:     catch (java.security.NoSuchProviderException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.NoSuchProviderException is caught "
0:             + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.NoSuchAlgorithmException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.NoSuchAlgorithmException is caught "
0:             + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.InvalidKeyException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.InvalidKeyException is caught "
0:             + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (javax.crypto.NoSuchPaddingException e) {
0:       throw new SqlException (agent_.logWriter_, e, "javax.crypto.NoSuchPaddingException is caught "
0:             + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (javax.crypto.BadPaddingException e) {
0:       throw new SqlException (agent_.logWriter_, e, "javax.crypto.BadPaddingException is caught "
0:             + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.InvalidAlgorithmParameterException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.InvalidAlgorithmParameterException is caught "
0:             + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (javax.crypto.IllegalBlockSizeException e) {
0:       throw new SqlException (agent_.logWriter_, e, "javax.crypto.IllegalBlockSizeException is caught "
0:             + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.spec.InvalidKeySpecException e) {
0:       throw new SqlException (agent_.logWriter_, e, "javax.crypto.IllegalBlockSizeException is caught "
0:             + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     return cipherText;
1:   }
1: 
1: 
0:   // This method decrypts the usreid/password with the middle 8 bytes of
0:   // the generated secret key and an encryption token. Then it returns the
0:   // decrypted data in a byte array.
0:   // plainText   The byte array form userid/password to encrypt.
0:   // initVector  The byte array which is used to calculate the
0:   //                             encryption token.
0:   // targetPublicKey   DERBY' public key.
0:   // Returns the decrypted data in a byte array.
0:   public byte[] decryptData (byte[] cipherText,
0:                              int    securityMechanism,
0:                              byte[] initVector,
0:                              byte[] targetPublicKey) throws SqlException
0:   {
1: 
0:     byte[] plainText = null;
0:     java.security.Key key = null;
1: 
0:     if (token_ == null)
0:       token_ = calculateEncryptionToken (securityMechanism, initVector);
1: 
0:     try{
0:       if (secKey_ == null)
0:       {
0:         //use this encryption key to initiate a SecretKeySpec object
0:         secKey_ = generatePrivateKey (targetPublicKey);
0:         javax.crypto.spec.SecretKeySpec desKey = new javax.crypto.spec.SecretKeySpec (secKey_, "DES");
0:         key = desKey;
1:       }
0:       else
0:       {
0:       //use this encryption key to initiate a SecretKeySpec object
0:         javax.crypto.spec.DESKeySpec desKey = new javax.crypto.spec.DESKeySpec (secKey_);
0:         if (secretKeyFactory_ == null)
0:           secretKeyFactory_ = javax.crypto.SecretKeyFactory.getInstance("DES", providerName);
0:         key = secretKeyFactory_.generateSecret(desKey);
1:       }
1: 
0:       //We use DES in CBC mode because this is the mode used in PROTOCOL. The
0:       //encryption mode has to be consistent for encryption and decryption.
0:       //CBC mode requires an initialization vector(IV) parameter. In CBC mode
0:       //we need to initialize the Cipher object with an IV, which can be supplied
0:       // using the javax.crypto.spec.IvParameterSpec class.
0:       javax.crypto.Cipher cipher= javax.crypto.Cipher.getInstance ("DES/CBC/PKCS5Padding", providerName);
1: 
0:       //generate a IVParameterSpec object and use it to initiate the
0:       //Cipher object.
0:       javax.crypto.spec.IvParameterSpec ivParam = new javax.crypto.spec.IvParameterSpec (token_);
1: 
0:       //initiate the Cipher using encryption mode, encryption key and the
0:       //IV parameter.
0:       cipher.init (javax.crypto.Cipher.DECRYPT_MODE, key,ivParam);
1: 
0:       //Execute the final phase of encryption
0:       plainText = cipher.doFinal (cipherText);
1:     }
0:     catch (java.security.NoSuchProviderException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.NoSuchProviderException is caught "
0:                               + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.NoSuchAlgorithmException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.NoSuchAlgorithmException is caught "
0:                               + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.InvalidKeyException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.InvalidKeyException is caught "
0:                               + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (javax.crypto.NoSuchPaddingException e) {
0:       throw new SqlException (agent_.logWriter_, e, "javax.crypto.NoSuchPaddingException is caught "
0:                               + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (javax.crypto.BadPaddingException e) {
0:       throw new SqlException (agent_.logWriter_, e, "javax.crypto.BadPaddingException is caught "
0:                               + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.InvalidAlgorithmParameterException e) {
0:       throw new SqlException (agent_.logWriter_, e, "java.security.InvalidAlgorithmParameterException is caught "
0:                               + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (javax.crypto.IllegalBlockSizeException e) {
0:       throw new SqlException (agent_.logWriter_, e, "javax.crypto.IllegalBlockSizeException is caught "
0:                               + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     catch (java.security.spec.InvalidKeySpecException e) {
0:       throw new SqlException (agent_.logWriter_, e, "javax.crypto.IllegalBlockSizeException is caught "
0:             + "when encrypting data '" + e.getMessage() + "'");
1:     }
0:     return plainText;
1:   }
1: 
0:   public void setInitVector(byte[] initVector)
0:   {
0:      token_ = initVector;
1:   }
1: 
0:   public void setSecKey(byte[] secKey)
0:   {
0:     secKey_ = secKey;
1:   }
1: 
0:   public void resetSecurityKeys()
0:   {
0:     token_ = null;
0:     secKey_ = null;
1:   }
1: 
1: }
1: 
============================================================================