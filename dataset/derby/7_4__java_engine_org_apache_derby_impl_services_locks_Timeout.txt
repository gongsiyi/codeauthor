1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.services.locks.Timeout
1:345de35: 
1:93fea34:    Licensed to the Apache Software Foundation (ASF) under one or more
1:93fea34:    contributor license agreements.  See the NOTICE file distributed with
1:93fea34:    this work for additional information regarding copyright ownership.
1:93fea34:    The ASF licenses this file to you under the Apache License, Version 2.0
1:93fea34:    (the "License"); you may not use this file except in compliance with
1:93fea34:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
4:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.services.locks;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.context.ContextService;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.locks.Latch;
1:eac0369: import org.apache.derby.iapi.services.locks.Lockable;
1:eac0369: import org.apache.derby.iapi.services.locks.VirtualLockTable;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1:eac0369: import org.apache.derby.iapi.store.access.TransactionController;
1:eac0369: 
1:6500326: import java.util.Date;
1:eac0369: import java.util.Enumeration;
1:eac0369: import java.util.Hashtable;
1:eac0369: 
2:eac0369: /**
1:eac0369:  * Code to support Timeout error output.
1:eac0369:  */
1:eac0369: 
1:eac0369: public final class Timeout
1:eac0369: {
1:eac0369:     public static final int TABLE_AND_ROWLOCK = VirtualLockTable.TABLE_AND_ROWLOCK;
1:eac0369:     public static final int ALL = VirtualLockTable.ALL;
1:eac0369: 
1:eac0369:     public static final String newline = "\n";
1:eac0369:     //FIXME: The newline might not be truely platform independent.
1:eac0369:     // We do not want to use a system call because of security reasons.
1:eac0369:     // LINE_SEPARATOR returns ^M for some reason, not ^M<nl>.
1:eac0369:     //public static final String newline = String.valueOf( (char)(new Byte(Character.LINE_SEPARATOR)).intValue() );
1:eac0369:     //public static final String newline = System.getProperty( "line.separator" );
1:eac0369: 
1:eac0369:     private TransactionController tc;
1:eac0369:     private TableNameInfo tabInfo;
1:eac0369: 
1:eac0369:     /* the current Latch to extract info out of */
1:eac0369:     private Latch currentLock;
1:eac0369:     /* the current row output of the lockTable */
1:eac0369:     private char[] outputRow;
1:eac0369:     /* the entire lockTable as a buffer */
1:eac0369:     private StringBuffer sb;
1:eac0369:     /* the hashtable information of the current lock */
1:eac0369:     private Hashtable currentRow;
1:eac0369:     /* the time when the exception was thrown */
1:eac0369:     private final long currentTime;
1:eac0369:     /* the snapshot of the lockTable that timeout */
1:eac0369:     private final Enumeration lockTable;
1:eac0369:     
1:eac0369:     // column1: XID varchar(10) not null
1:eac0369:     // column2: TYPE varchar(13) not null
1:eac0369:     // column3: MODE varchar(4) not null
1:eac0369:     // column4: LOCKCOUNT varchar(9) not null 
1:eac0369:     // column5: LOCKNAME varchar(80) not null
1:eac0369:     // column6: STATE varchar(5) not null
1:eac0369:     // column7: TABLETYPE varchar(38) not null                  / LOCKOBJ varchar(38)
1:eac0369:     // column8: INDEXNAME varchar(50) nullable as String "NULL" / CONTAINER_ID / MODE (latch only) varchar(50)
1:eac0369:     // column9: TABLENAME varchar(38) not null                  / CONGLOM_ID varchar(38)
1:eac0369:     // Total length of this string is 10+1+13+1+6+1+9+1+80+1+5+1+38+1+48+1+38=256
1:eac0369:     private final static String[] column = new String[9];
1:eac0369:     private final static int LENGTHOFTABLE;
1:eac0369:     static
1:eac0369:     {
1:eac0369:         column[0] = "XID       ";
1:eac0369:         column[1] = "TYPE         ";
1:eac0369:         column[2] = "MODE";
1:eac0369:         column[3] = "LOCKCOUNT";
1:eac0369:         column[4] = "LOCKNAME                                                                        ";
1:eac0369:         column[5] = "STATE";
1:eac0369:         column[6] = "TABLETYPE / LOCKOBJ                   ";
1:eac0369:         column[7] = "INDEXNAME / CONTAINER_ID / (MODE for LATCH only)  ";
1:eac0369:         column[8] = "TABLENAME / CONGLOM_ID                ";
1:eac0369: 
1:eac0369:         int length = 0;
1:eac0369:         for( int i = 0 ; i < column.length; i++ )
1:eac0369:         {
1:eac0369:             length += column[i].length();
1:eac0369:         }
1:eac0369:         length += column.length; // for the separator
1:eac0369:         if( SanityManager.DEBUG )
1:eac0369:         {   // 256 is a good number, can be expanded or contracted if necessary
1:eac0369:             SanityManager.ASSERT( length == 256, "TIMEOUT_MONITOR: length of the row is not 256" );
1:eac0369:         }
1:eac0369:         LENGTHOFTABLE = length;
1:eac0369:     }
1:eac0369:     private final static char LINE = '-';
1:eac0369:     private final static char SEPARATOR = '|';
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Constructor
1:eac0369:      * @param myTimeoutLock The Latch that the timeout happened on
1:eac0369:      * @param myLockTable
1:eac0369:      * @param time The time when the lockTable was cloned.
1:eac0369:      */
1:eac0369:     private Timeout( Latch myTimeoutLock, Enumeration myLockTable, long time )
1:eac0369:     {
1:eac0369:         currentLock = myTimeoutLock;
1:eac0369:         lockTable = myLockTable;
1:eac0369:         currentTime = time;
1:eac0369: 
1:eac0369:         if( SanityManager.DEBUG )
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT( currentTime > 0, "TIMEOUT_MONITOR: currentTime is not set correctly" );
1:eac0369:         }
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * createException creates a StandardException based on:
1:eac0369:      *          currentLock
1:eac0369:      *          a snapshot of the lockTable
1:eac0369:      * @return StandardException The exception with the lockTable snapshot in it
1:eac0369:      */
1:eac0369:     private StandardException createException()
1:eac0369:     {
1:eac0369:         try
1:eac0369:         {
1:eac0369:             buildLockTableString();
1:eac0369:         }
1:eac0369:         catch( StandardException se )
1:eac0369:         {
1:eac0369:             return se;
1:eac0369:         }
1:eac0369: 
1:eac0369:         StandardException se = StandardException.newException( SQLState.LOCK_TIMEOUT_LOG, sb.toString() );
1:eac0369:         se.setReport( StandardException.REPORT_ALWAYS );
1:eac0369:         return se;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * buildLockTableString creates a LockTable info String
1:eac0369:      */
1:eac0369:     private String buildLockTableString() throws StandardException
1:eac0369:     {
1:eac0369:         sb = new StringBuffer(8192);
1:eac0369:         outputRow = new char[ LENGTHOFTABLE ];
1:eac0369:         int i; // counter
1:eac0369: 
1:eac0369:         // need language here to print out tablenames
1:eac0369:         LanguageConnectionContext lcc = (LanguageConnectionContext)
1:a0dbbd7:             Deadlock.getContext(LanguageConnectionContext.CONTEXT_ID);
1:eac0369:         if( lcc != null )
1:eac0369:             tc = lcc.getTransactionExecute();
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             tabInfo = new TableNameInfo( lcc, true );
1:eac0369:         }
1:eac0369:         catch (Exception se)
1:eac0369:         {   //just don't do anything
1:eac0369:         }
1:eac0369: 
1:eac0369:         sb.append( newline );
1:6500326:         sb.append(new Date(currentTime));
1:eac0369:         sb.append( newline );
1:eac0369:         for( i = 0; i < column.length; i++ )
1:eac0369:         {
1:eac0369:             sb.append( column[i] );
1:eac0369:             sb.append( SEPARATOR );
1:eac0369:         }
1:eac0369:         sb.append( newline );
1:eac0369: 
1:eac0369:         for( i = 0; i < LENGTHOFTABLE; i++ )
1:eac0369:             sb.append( LINE );
1:eac0369: 
1:eac0369:         sb.append( newline );
1:eac0369: 
1:eac0369:         // get the timeout lock info
1:eac0369:         if( currentLock != null )
1:eac0369:         {
1:eac0369:             dumpLock( );
1:eac0369:             if( timeoutInfoHash() )
1:eac0369:             {
1:eac0369:                 sb.append( "*** The following row is the victim ***" );
1:eac0369:                 sb.append( newline );
1:eac0369:                 sb.append( outputRow );
1:eac0369:                 sb.append( newline );
1:eac0369:                 sb.append( "*** The above row is the victim ***" );
1:eac0369:                 sb.append( newline );
1:eac0369:             }
1:eac0369:             else
1:eac0369:             {
1:eac0369:                 sb.append( "*** A victim was chosen, but it cannot be printed because the lockable object, " + currentLock + ", does not want to participate ***" );
1:eac0369:                 sb.append( newline );
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         // get lock info from the rest of the table
1:eac0369:         if( lockTable != null )
1:eac0369:         {
1:eac0369:             while( lockTable.hasMoreElements() )
1:eac0369:             {
1:eac0369:                 currentLock = (Latch)lockTable.nextElement();
1:eac0369:                 dumpLock( );
1:eac0369:                 if( timeoutInfoHash() )
1:eac0369:                 {
1:eac0369:                     sb.append( outputRow );
1:eac0369:                     sb.append( newline );
1:eac0369:                 }
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     sb.append( "*** A latch/lock, " + currentLock + ", exist in the lockTable that cannot be printed ***" );
1:eac0369:                     sb.append( newline );
1:eac0369:                 }
1:eac0369:             }
1:eac0369:             for( i = 0; i < LENGTHOFTABLE; i++ )
1:eac0369:                 sb.append( LINE );
1:eac0369: 
1:eac0369:             sb.append( newline );
1:eac0369:         }
1:eac0369:         return sb.toString();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * The static entry way to get the LockTable in the system.
1:eac0369:      * @param timeoutLock The Latch that the timeout happened on
1:eac0369:      * @param table The lockTable
1:eac0369:      * @param time The time when the lockTable was cloned
1:eac0369:      * @return StandardException The exception with the lockTable snapshot in it
1:eac0369:      */
1:eac0369:     static StandardException buildException( Latch timeoutLock, Enumeration table, long time )
1:eac0369:     {
1:eac0369:         Timeout myTimeout = new Timeout( timeoutLock, table, time );
1:eac0369:         return myTimeout.createException();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /*
1:eac0369:      * A static entry way to get the LockTable in the system.
1:eac0369:      * For track 3311
1:eac0369:      */
1:eac0369:     public static String buildString( Enumeration table, long time ) throws StandardException
1:eac0369:     {
1:eac0369:         Timeout myTimeout = new Timeout( null, table, time);
1:eac0369:         return myTimeout.buildLockTableString();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * dumpLock puts information about currentLock into currentRow for output later.
1:eac0369:      * @throws StandardException
1:eac0369:      */
1:eac0369:     private void dumpLock() throws StandardException
1:eac0369:     {
1:a15a470:         Hashtable<String,Object> attributes = new Hashtable<String,Object>(17);
1:eac0369:         Object lock_type = currentLock.getQualifier();
1:eac0369: 
1:eac0369:         // want containerId, segmentId, pageNum, recId from locktable
1:eac0369:         Lockable lockable = currentLock.getLockable();
1:eac0369: 
1:eac0369:         // See if the lockable object wants to participate
1:eac0369:         if( !lockable.lockAttributes(ALL, attributes) )
1:eac0369:         {
1:eac0369:             currentRow = null;
1:eac0369:             return;
1:eac0369:         }
1:eac0369: 
1:eac0369:         // if it does, the lockable object must have filled in the following 
1:eac0369:         // fields
1:eac0369:         if( SanityManager.DEBUG )
1:eac0369:         {
1:eac0369:             SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKNAME) != null, "lock table can only represent locks that have a LOCKNAME" );
1:eac0369:             SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKTYPE) != null, "lock table can only represent locks that have a LOCKTYPE" );
1:eac0369:             if( attributes.get(VirtualLockTable.CONTAINERID ) == null &&
1:eac0369:                 attributes.get(VirtualLockTable.CONGLOMID ) == null )
1:eac0369:                 SanityManager.THROWASSERT("lock table can only represent locks that are associated with a container or conglomerate");
1:eac0369:         }
1:eac0369: 
1:eac0369:         Long conglomId = (Long) attributes.get(VirtualLockTable.CONGLOMID);
1:eac0369:         
1:eac0369:         if( conglomId == null )
1:eac0369:         {
1:eac0369:             if( attributes.get(VirtualLockTable.CONTAINERID) != null && tc != null )
1:eac0369:             {   
1:eac0369:                 Long value = (Long)attributes.get(VirtualLockTable.CONTAINERID);
1:ce40a31:                 conglomId = tc.findConglomid( value.longValue() );
1:eac0369:                 attributes.put( VirtualLockTable.CONGLOMID, conglomId );
1:eac0369:             }
1:eac0369:         }
1:eac0369: 
1:eac0369:         Long containerId = (Long) attributes.get(VirtualLockTable.CONTAINERID);
1:eac0369: 
1:eac0369:         if( containerId == null )
1:eac0369:         {
1:eac0369:             if( conglomId != null && tc != null )
1:eac0369:             {
1:eac0369:                 try
1:eac0369:                 {
1:ce40a31:                     containerId = tc.findContainerid( conglomId.longValue() );
1:eac0369:                     attributes.put( VirtualLockTable.CONTAINERID, containerId );
1:eac0369:                 }
1:eac0369:                 catch( Exception e )
1:eac0369:                 {
1:eac0369:                     // just don't do anything
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:         
1:eac0369:         attributes.put( VirtualLockTable.LOCKOBJ, currentLock );
1:94ebe10:         attributes.put( VirtualLockTable.XACTID,
1:94ebe10:                         String.valueOf(
1:94ebe10:                             currentLock.getCompatabilitySpace().getOwner()));
1:eac0369:         attributes.put( VirtualLockTable.LOCKMODE, lock_type.toString() );
1:eac0369:         attributes.put( VirtualLockTable.LOCKCOUNT, Integer.toString( currentLock.getCount() ) );
1:eac0369:         attributes.put( VirtualLockTable.STATE, (currentLock.getCount() != 0 ) ? "GRANT" : "WAIT" );
1:eac0369:         
1:eac0369:         if( tabInfo != null && conglomId != null )
1:eac0369:         {
1:eac0369:             try{
1:eac0369:                 String tableName = tabInfo.getTableName( conglomId );
1:eac0369:                 attributes.put( VirtualLockTable.TABLENAME, tableName );
1:eac0369:             }
1:eac0369:             catch( NullPointerException e )
1:eac0369:             {
1:eac0369:                 attributes.put( VirtualLockTable.TABLENAME, conglomId );
1:eac0369:             }
1:eac0369:         
1:eac0369:             try
1:eac0369:             {
1:eac0369:                 String indexName = tabInfo.getIndexName( conglomId );
1:eac0369:                 if( indexName != null )
1:eac0369:                     attributes.put( VirtualLockTable.INDEXNAME, indexName );
1:eac0369:                 else
1:eac0369:                 {
1:eac0369:                     if( attributes.get(VirtualLockTable.LOCKTYPE).equals("LATCH") )
1:eac0369:                     {   // because MODE field is way to short to display this,
1:eac0369:                         // just put it in the indexname field for LATCH only.
1:eac0369:                         attributes.put( VirtualLockTable.INDEXNAME, attributes.get(VirtualLockTable.LOCKMODE) );
1:eac0369:                     }
1:eac0369:                     else
1:eac0369:                         attributes.put( VirtualLockTable.INDEXNAME, "NULL" );
1:eac0369:                 }
1:eac0369:             }catch( Exception e )
1:eac0369:             {   // we are here because tabInfo.indexCache is null
1:eac0369:                 if( VirtualLockTable.CONTAINERID != null )
1:eac0369:                     attributes.put( VirtualLockTable.INDEXNAME, VirtualLockTable.CONTAINERID );
1:eac0369:                 else
1:eac0369:                     attributes.put( VirtualLockTable.INDEXNAME, "NULL" );
1:eac0369:             }
1:eac0369: 
1:eac0369:             String tableType = tabInfo.getTableType( conglomId );
1:eac0369:             attributes.put( VirtualLockTable.TABLETYPE, tableType );
1:eac0369:         }
1:eac0369:         else
1:eac0369:         { 
1:eac0369:             if( conglomId != null )
1:eac0369:                 attributes.put( VirtualLockTable.TABLENAME, VirtualLockTable.CONGLOMID );
1:eac0369:             else
1:eac0369:                 attributes.put( VirtualLockTable.TABLENAME, "NULL" );
1:eac0369: 
1:eac0369:             if( VirtualLockTable.CONTAINERID != null )
1:eac0369:                 attributes.put( VirtualLockTable.INDEXNAME, VirtualLockTable.CONTAINERID );
1:eac0369:             else
1:eac0369:                 attributes.put( VirtualLockTable.INDEXNAME, "NULL" );
1:eac0369:                 
1:eac0369:             attributes.put( VirtualLockTable.TABLETYPE, currentLock.toString() );
1:eac0369:         }
1:eac0369:         currentRow = attributes;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * cpArray helps built the output string (outputRow).
1:eac0369:      * @param toCp the String to be copied into outputRow
1:eac0369:      * @param start the start place
1:eac0369:      * @param end the end place
1:eac0369:      */
1:eac0369:     private void cpArray( String toCp, int start, int end )
1:eac0369:     {   // build a field in the output string
1:eac0369:         int i = 0;
1:eac0369:         int totalAllowWrite = end - start;
1:eac0369: 
1:eac0369:         if( toCp != null )
1:eac0369:         {
1:eac0369:             for( ; i < toCp.length() ; i++ )
1:eac0369:             {
1:eac0369:                 if( (totalAllowWrite-i) == 0 )
1:eac0369:                     break;
1:eac0369: 
1:eac0369:                 outputRow[ i + start ] = toCp.charAt(i);
1:eac0369:             }
1:eac0369:         }
1:eac0369:         for( ; i + start != end; i++ )
1:eac0369:             outputRow[ i + start ] = ' ';
1:eac0369: 
1:eac0369:         outputRow[ end ] = SEPARATOR;
1:eac0369:     }
1:eac0369:     
1:eac0369:     /**
1:eac0369:      * Copies the needed information from currentRow into the StringBuffer for output
1:eac0369:      * @return true if successful
1:eac0369:      */
1:eac0369:     private boolean timeoutInfoHash( )
1:eac0369:     {
1:eac0369:         if( currentRow == null )
1:eac0369:             return false;
1:eac0369: 
1:eac0369:         String[] myData = new String[9];
1:eac0369:         myData[0] = VirtualLockTable.XACTID;
1:eac0369:         myData[1] = VirtualLockTable.LOCKTYPE;
1:eac0369:         myData[2] = VirtualLockTable.LOCKMODE;
1:eac0369:         myData[3] = VirtualLockTable.LOCKCOUNT;
1:eac0369:         myData[4] = VirtualLockTable.LOCKNAME;
1:eac0369:         myData[5] = VirtualLockTable.STATE;
1:eac0369:         myData[6] = VirtualLockTable.TABLETYPE;
1:eac0369:         myData[7] = VirtualLockTable.INDEXNAME;
1:eac0369:         myData[8] = VirtualLockTable.TABLENAME;
1:eac0369: 
1:eac0369: 
1:eac0369:         int currentLength = 0;
1:eac0369:         for( int i = 0; i < myData.length; i++ )
1:eac0369:         {
1:eac0369:             cpArray( currentRow.get( myData[i] ).toString(), currentLength , currentLength + column[i].length() );
1:eac0369:             // the next beginning position
1:eac0369:             currentLength = currentLength + column[i].length() + 1;
1:eac0369:         }
1:eac0369:         return true;
1:eac0369:     }
1:eac0369: }
1:eac0369: 
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:ce40a31
/////////////////////////////////////////////////////////////////////////
1:                 conglomId = tc.findConglomid( value.longValue() );
/////////////////////////////////////////////////////////////////////////
1:                     containerId = tc.findContainerid( conglomId.longValue() );
commit:a0dbbd7
/////////////////////////////////////////////////////////////////////////
1:             Deadlock.getContext(LanguageConnectionContext.CONTEXT_ID);
commit:a15a470
/////////////////////////////////////////////////////////////////////////
1:         Hashtable<String,Object> attributes = new Hashtable<String,Object>(17);
commit:93fea34
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:6500326
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: import java.util.Date;
/////////////////////////////////////////////////////////////////////////
1:         sb.append(new Date(currentTime));
commit:94ebe10
/////////////////////////////////////////////////////////////////////////
1:         attributes.put( VirtualLockTable.XACTID,
1:                         String.valueOf(
1:                             currentLock.getCompatabilitySpace().getOwner()));
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:6c9dac8
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.services.locks.Timeout
1: 
0:    Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.locks
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.services.locks;
1: 
0: import org.apache.derby.impl.services.locks.TableNameInfo;
1: 
1: import org.apache.derby.iapi.services.context.ContextService;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: 
1: import org.apache.derby.iapi.services.locks.Latch;
1: import org.apache.derby.iapi.services.locks.Lockable;
1: import org.apache.derby.iapi.services.locks.VirtualLockTable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: 
0: import org.apache.derby.iapi.util.CheapDateFormatter;
1: 
1: import java.util.Enumeration;
1: import java.util.Hashtable;
1: 
1: /**
1:  * Code to support Timeout error output.
0:  * @author gavin
1:  */
1: 
1: public final class Timeout
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
1:     public static final int TABLE_AND_ROWLOCK = VirtualLockTable.TABLE_AND_ROWLOCK;
1:     public static final int ALL = VirtualLockTable.ALL;
1: 
1:     public static final String newline = "\n";
1:     //FIXME: The newline might not be truely platform independent.
1:     // We do not want to use a system call because of security reasons.
1:     // LINE_SEPARATOR returns ^M for some reason, not ^M<nl>.
1:     //public static final String newline = String.valueOf( (char)(new Byte(Character.LINE_SEPARATOR)).intValue() );
1:     //public static final String newline = System.getProperty( "line.separator" );
1: 
1:     private TransactionController tc;
1:     private TableNameInfo tabInfo;
1: 
1:     /* the current Latch to extract info out of */
1:     private Latch currentLock;
1:     /* the current row output of the lockTable */
1:     private char[] outputRow;
1:     /* the entire lockTable as a buffer */
1:     private StringBuffer sb;
1:     /* the hashtable information of the current lock */
1:     private Hashtable currentRow;
1:     /* the time when the exception was thrown */
1:     private final long currentTime;
1:     /* the snapshot of the lockTable that timeout */
1:     private final Enumeration lockTable;
1:     
1:     // column1: XID varchar(10) not null
1:     // column2: TYPE varchar(13) not null
1:     // column3: MODE varchar(4) not null
1:     // column4: LOCKCOUNT varchar(9) not null 
1:     // column5: LOCKNAME varchar(80) not null
1:     // column6: STATE varchar(5) not null
1:     // column7: TABLETYPE varchar(38) not null                  / LOCKOBJ varchar(38)
1:     // column8: INDEXNAME varchar(50) nullable as String "NULL" / CONTAINER_ID / MODE (latch only) varchar(50)
1:     // column9: TABLENAME varchar(38) not null                  / CONGLOM_ID varchar(38)
1:     // Total length of this string is 10+1+13+1+6+1+9+1+80+1+5+1+38+1+48+1+38=256
1:     private final static String[] column = new String[9];
1:     private final static int LENGTHOFTABLE;
1:     static
1:     {
1:         column[0] = "XID       ";
1:         column[1] = "TYPE         ";
1:         column[2] = "MODE";
1:         column[3] = "LOCKCOUNT";
1:         column[4] = "LOCKNAME                                                                        ";
1:         column[5] = "STATE";
1:         column[6] = "TABLETYPE / LOCKOBJ                   ";
1:         column[7] = "INDEXNAME / CONTAINER_ID / (MODE for LATCH only)  ";
1:         column[8] = "TABLENAME / CONGLOM_ID                ";
1: 
1:         int length = 0;
1:         for( int i = 0 ; i < column.length; i++ )
1:         {
1:             length += column[i].length();
1:         }
1:         length += column.length; // for the separator
1:         if( SanityManager.DEBUG )
1:         {   // 256 is a good number, can be expanded or contracted if necessary
1:             SanityManager.ASSERT( length == 256, "TIMEOUT_MONITOR: length of the row is not 256" );
1:         }
1:         LENGTHOFTABLE = length;
1:     }
1:     private final static char LINE = '-';
1:     private final static char SEPARATOR = '|';
1: 
1:     /**
1:      * Constructor
1:      * @param myTimeoutLock The Latch that the timeout happened on
1:      * @param myLockTable
1:      * @param time The time when the lockTable was cloned.
1:      */
1:     private Timeout( Latch myTimeoutLock, Enumeration myLockTable, long time )
1:     {
1:         currentLock = myTimeoutLock;
1:         lockTable = myLockTable;
1:         currentTime = time;
1: 
1:         if( SanityManager.DEBUG )
1:         {
1:             SanityManager.ASSERT( currentTime > 0, "TIMEOUT_MONITOR: currentTime is not set correctly" );
1:         }
1:     }
1:     
1:     /**
1:      * createException creates a StandardException based on:
1:      *          currentLock
1:      *          a snapshot of the lockTable
1:      * @return StandardException The exception with the lockTable snapshot in it
1:      */
1:     private StandardException createException()
1:     {
1:         try
1:         {
1:             buildLockTableString();
1:         }
1:         catch( StandardException se )
1:         {
1:             return se;
1:         }
1: 
1:         StandardException se = StandardException.newException( SQLState.LOCK_TIMEOUT_LOG, sb.toString() );
1:         se.setReport( StandardException.REPORT_ALWAYS );
1:         return se;
1:     }
1: 
1:     /**
1:      * buildLockTableString creates a LockTable info String
1:      */
1:     private String buildLockTableString() throws StandardException
1:     {
1:         sb = new StringBuffer(8192);
1:         outputRow = new char[ LENGTHOFTABLE ];
1:         int i; // counter
1: 
1:         // need language here to print out tablenames
1:         LanguageConnectionContext lcc = (LanguageConnectionContext)
0:             ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
1:         if( lcc != null )
1:             tc = lcc.getTransactionExecute();
1: 
1:         try
1:         {
1:             tabInfo = new TableNameInfo( lcc, true );
1:         }
1:         catch (Exception se)
1:         {   //just don't do anything
1:         }
1: 
1:         sb.append( newline );
0:         sb.append(CheapDateFormatter.formatDate(currentTime));
1:         sb.append( newline );
1:         for( i = 0; i < column.length; i++ )
1:         {
1:             sb.append( column[i] );
1:             sb.append( SEPARATOR );
1:         }
1:         sb.append( newline );
1: 
1:         for( i = 0; i < LENGTHOFTABLE; i++ )
1:             sb.append( LINE );
1: 
1:         sb.append( newline );
1: 
1:         // get the timeout lock info
1:         if( currentLock != null )
1:         {
1:             dumpLock( );
1:             if( timeoutInfoHash() )
1:             {
1:                 sb.append( "*** The following row is the victim ***" );
1:                 sb.append( newline );
1:                 sb.append( outputRow );
1:                 sb.append( newline );
1:                 sb.append( "*** The above row is the victim ***" );
1:                 sb.append( newline );
1:             }
1:             else
1:             {
1:                 sb.append( "*** A victim was chosen, but it cannot be printed because the lockable object, " + currentLock + ", does not want to participate ***" );
1:                 sb.append( newline );
1:             }
1:         }
1: 
1:         // get lock info from the rest of the table
1:         if( lockTable != null )
1:         {
1:             while( lockTable.hasMoreElements() )
1:             {
1:                 currentLock = (Latch)lockTable.nextElement();
1:                 dumpLock( );
1:                 if( timeoutInfoHash() )
1:                 {
1:                     sb.append( outputRow );
1:                     sb.append( newline );
1:                 }
1:                 else
1:                 {
1:                     sb.append( "*** A latch/lock, " + currentLock + ", exist in the lockTable that cannot be printed ***" );
1:                     sb.append( newline );
1:                 }
1:             }
1:             for( i = 0; i < LENGTHOFTABLE; i++ )
1:                 sb.append( LINE );
1: 
1:             sb.append( newline );
1:         }
1:         return sb.toString();
1:     }
1: 
1:     /**
1:      * The static entry way to get the LockTable in the system.
1:      * @param timeoutLock The Latch that the timeout happened on
1:      * @param table The lockTable
1:      * @param time The time when the lockTable was cloned
1:      * @return StandardException The exception with the lockTable snapshot in it
1:      */
1:     static StandardException buildException( Latch timeoutLock, Enumeration table, long time )
1:     {
1:         Timeout myTimeout = new Timeout( timeoutLock, table, time );
1:         return myTimeout.createException();
1:     }
1: 
1:     /*
1:      * A static entry way to get the LockTable in the system.
1:      * For track 3311
1:      */
1:     public static String buildString( Enumeration table, long time ) throws StandardException
1:     {
1:         Timeout myTimeout = new Timeout( null, table, time);
1:         return myTimeout.buildLockTableString();
1:     }
1: 
1:     /**
1:      * dumpLock puts information about currentLock into currentRow for output later.
1:      * @throws StandardException
1:      */
1:     private void dumpLock() throws StandardException
1:     {
0:         Hashtable attributes = new Hashtable(17);
1:         Object lock_type = currentLock.getQualifier();
1: 
1:         // want containerId, segmentId, pageNum, recId from locktable
1:         Lockable lockable = currentLock.getLockable();
1: 
1:         // See if the lockable object wants to participate
1:         if( !lockable.lockAttributes(ALL, attributes) )
1:         {
1:             currentRow = null;
1:             return;
1:         }
1: 
1:         // if it does, the lockable object must have filled in the following 
1:         // fields
1:         if( SanityManager.DEBUG )
1:         {
1:             SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKNAME) != null, "lock table can only represent locks that have a LOCKNAME" );
1:             SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKTYPE) != null, "lock table can only represent locks that have a LOCKTYPE" );
1:             if( attributes.get(VirtualLockTable.CONTAINERID ) == null &&
1:                 attributes.get(VirtualLockTable.CONGLOMID ) == null )
1:                 SanityManager.THROWASSERT("lock table can only represent locks that are associated with a container or conglomerate");
1:         }
1: 
1:         Long conglomId = (Long) attributes.get(VirtualLockTable.CONGLOMID);
1:         
1:         if( conglomId == null )
1:         {
1:             if( attributes.get(VirtualLockTable.CONTAINERID) != null && tc != null )
1:             {   
1:                 Long value = (Long)attributes.get(VirtualLockTable.CONTAINERID);
0:                 conglomId = new Long( tc.findConglomid( value.longValue() ) );
1:                 attributes.put( VirtualLockTable.CONGLOMID, conglomId );
1:             }
1:         }
1: 
1:         Long containerId = (Long) attributes.get(VirtualLockTable.CONTAINERID);
1: 
1:         if( containerId == null )
1:         {
1:             if( conglomId != null && tc != null )
1:             {
1:                 try
1:                 {
0:                     containerId = new Long( tc.findContainerid( conglomId.longValue() ) );
1:                     attributes.put( VirtualLockTable.CONTAINERID, containerId );
1:                 }
1:                 catch( Exception e )
1:                 {
1:                     // just don't do anything
1:                 }
1:             }
1:         }
1:         
1:         attributes.put( VirtualLockTable.LOCKOBJ, currentLock );
0:         attributes.put( VirtualLockTable.XACTID, currentLock.getCompatabilitySpace().toString() );
1:         attributes.put( VirtualLockTable.LOCKMODE, lock_type.toString() );
1:         attributes.put( VirtualLockTable.LOCKCOUNT, Integer.toString( currentLock.getCount() ) );
1:         attributes.put( VirtualLockTable.STATE, (currentLock.getCount() != 0 ) ? "GRANT" : "WAIT" );
1:         
1:         if( tabInfo != null && conglomId != null )
1:         {
1:             try{
1:                 String tableName = tabInfo.getTableName( conglomId );
1:                 attributes.put( VirtualLockTable.TABLENAME, tableName );
1:             }
1:             catch( NullPointerException e )
1:             {
1:                 attributes.put( VirtualLockTable.TABLENAME, conglomId );
1:             }
1:         
1:             try
1:             {
1:                 String indexName = tabInfo.getIndexName( conglomId );
1:                 if( indexName != null )
1:                     attributes.put( VirtualLockTable.INDEXNAME, indexName );
1:                 else
1:                 {
1:                     if( attributes.get(VirtualLockTable.LOCKTYPE).equals("LATCH") )
1:                     {   // because MODE field is way to short to display this,
1:                         // just put it in the indexname field for LATCH only.
1:                         attributes.put( VirtualLockTable.INDEXNAME, attributes.get(VirtualLockTable.LOCKMODE) );
1:                     }
1:                     else
1:                         attributes.put( VirtualLockTable.INDEXNAME, "NULL" );
1:                 }
1:             }catch( Exception e )
1:             {   // we are here because tabInfo.indexCache is null
1:                 if( VirtualLockTable.CONTAINERID != null )
1:                     attributes.put( VirtualLockTable.INDEXNAME, VirtualLockTable.CONTAINERID );
1:                 else
1:                     attributes.put( VirtualLockTable.INDEXNAME, "NULL" );
1:             }
1: 
1:             String tableType = tabInfo.getTableType( conglomId );
1:             attributes.put( VirtualLockTable.TABLETYPE, tableType );
1:         }
1:         else
1:         { 
1:             if( conglomId != null )
1:                 attributes.put( VirtualLockTable.TABLENAME, VirtualLockTable.CONGLOMID );
1:             else
1:                 attributes.put( VirtualLockTable.TABLENAME, "NULL" );
1: 
1:             if( VirtualLockTable.CONTAINERID != null )
1:                 attributes.put( VirtualLockTable.INDEXNAME, VirtualLockTable.CONTAINERID );
1:             else
1:                 attributes.put( VirtualLockTable.INDEXNAME, "NULL" );
1:                 
1:             attributes.put( VirtualLockTable.TABLETYPE, currentLock.toString() );
1:         }
1:         currentRow = attributes;
1:     }
1: 
1:     /**
1:      * cpArray helps built the output string (outputRow).
1:      * @param toCp the String to be copied into outputRow
1:      * @param start the start place
1:      * @param end the end place
1:      */
1:     private void cpArray( String toCp, int start, int end )
1:     {   // build a field in the output string
1:         int i = 0;
1:         int totalAllowWrite = end - start;
1: 
1:         if( toCp != null )
1:         {
1:             for( ; i < toCp.length() ; i++ )
1:             {
1:                 if( (totalAllowWrite-i) == 0 )
1:                     break;
1: 
1:                 outputRow[ i + start ] = toCp.charAt(i);
1:             }
1:         }
1:         for( ; i + start != end; i++ )
1:             outputRow[ i + start ] = ' ';
1: 
1:         outputRow[ end ] = SEPARATOR;
1:     }
1:     
1:     /**
1:      * Copies the needed information from currentRow into the StringBuffer for output
1:      * @return true if successful
1:      */
1:     private boolean timeoutInfoHash( )
1:     {
1:         if( currentRow == null )
1:             return false;
1: 
1:         String[] myData = new String[9];
1:         myData[0] = VirtualLockTable.XACTID;
1:         myData[1] = VirtualLockTable.LOCKTYPE;
1:         myData[2] = VirtualLockTable.LOCKMODE;
1:         myData[3] = VirtualLockTable.LOCKCOUNT;
1:         myData[4] = VirtualLockTable.LOCKNAME;
1:         myData[5] = VirtualLockTable.STATE;
1:         myData[6] = VirtualLockTable.TABLETYPE;
1:         myData[7] = VirtualLockTable.INDEXNAME;
1:         myData[8] = VirtualLockTable.TABLENAME;
1: 
1: 
1:         int currentLength = 0;
1:         for( int i = 0; i < myData.length; i++ )
1:         {
1:             cpArray( currentRow.get( myData[i] ).toString(), currentLength , currentLength + column[i].length() );
1:             // the next beginning position
1:             currentLength = currentLength + column[i].length() + 1;
1:         }
1:         return true;
1:     }
1: }
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.services.locks
0:    (C) Copyright IBM Corp. 2000, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.services.locks;
0: 
0: import org.apache.derby.impl.services.locks.TableNameInfo;
0: 
0: import org.apache.derby.iapi.services.context.ContextService;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.locks.Latch;
0: import org.apache.derby.iapi.services.locks.Lockable;
0: import org.apache.derby.iapi.services.locks.VirtualLockTable;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: 
0: import org.apache.derby.iapi.util.CheapDateFormatter;
0: 
0: import java.util.Enumeration;
0: import java.util.Hashtable;
0: 
0: /**
0:  * Code to support Timeout error output.
0:  * @author gavin
0:  */
0: 
0: public final class Timeout
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_2000_2004;
0:     public static final int TABLE_AND_ROWLOCK = VirtualLockTable.TABLE_AND_ROWLOCK;
0:     public static final int ALL = VirtualLockTable.ALL;
0: 
0:     public static final String newline = "\n";
0:     //FIXME: The newline might not be truely platform independent.
0:     // We do not want to use a system call because of security reasons.
0:     // LINE_SEPARATOR returns ^M for some reason, not ^M<nl>.
0:     //public static final String newline = String.valueOf( (char)(new Byte(Character.LINE_SEPARATOR)).intValue() );
0:     //public static final String newline = System.getProperty( "line.separator" );
0: 
0:     private TransactionController tc;
0:     private TableNameInfo tabInfo;
0: 
0:     /* the current Latch to extract info out of */
0:     private Latch currentLock;
0:     /* the current row output of the lockTable */
0:     private char[] outputRow;
0:     /* the entire lockTable as a buffer */
0:     private StringBuffer sb;
0:     /* the hashtable information of the current lock */
0:     private Hashtable currentRow;
0:     /* the time when the exception was thrown */
0:     private final long currentTime;
0:     /* the snapshot of the lockTable that timeout */
0:     private final Enumeration lockTable;
0:     
0:     // column1: XID varchar(10) not null
0:     // column2: TYPE varchar(13) not null
0:     // column3: MODE varchar(4) not null
0:     // column4: LOCKCOUNT varchar(9) not null 
0:     // column5: LOCKNAME varchar(80) not null
0:     // column6: STATE varchar(5) not null
0:     // column7: TABLETYPE varchar(38) not null                  / LOCKOBJ varchar(38)
0:     // column8: INDEXNAME varchar(50) nullable as String "NULL" / CONTAINER_ID / MODE (latch only) varchar(50)
0:     // column9: TABLENAME varchar(38) not null                  / CONGLOM_ID varchar(38)
0:     // Total length of this string is 10+1+13+1+6+1+9+1+80+1+5+1+38+1+48+1+38=256
0:     private final static String[] column = new String[9];
0:     private final static int LENGTHOFTABLE;
0:     static
0:     {
0:         column[0] = "XID       ";
0:         column[1] = "TYPE         ";
0:         column[2] = "MODE";
0:         column[3] = "LOCKCOUNT";
0:         column[4] = "LOCKNAME                                                                        ";
0:         column[5] = "STATE";
0:         column[6] = "TABLETYPE / LOCKOBJ                   ";
0:         column[7] = "INDEXNAME / CONTAINER_ID / (MODE for LATCH only)  ";
0:         column[8] = "TABLENAME / CONGLOM_ID                ";
0: 
0:         int length = 0;
0:         for( int i = 0 ; i < column.length; i++ )
0:         {
0:             length += column[i].length();
0:         }
0:         length += column.length; // for the separator
0:         if( SanityManager.DEBUG )
0:         {   // 256 is a good number, can be expanded or contracted if necessary
0:             SanityManager.ASSERT( length == 256, "TIMEOUT_MONITOR: length of the row is not 256" );
0:         }
0:         LENGTHOFTABLE = length;
0:     }
0:     private final static char LINE = '-';
0:     private final static char SEPARATOR = '|';
0: 
0:     /**
0:      * Constructor
0:      * @param myTimeoutLock The Latch that the timeout happened on
0:      * @param myLockTable
0:      * @param time The time when the lockTable was cloned.
0:      */
0:     private Timeout( Latch myTimeoutLock, Enumeration myLockTable, long time )
0:     {
0:         currentLock = myTimeoutLock;
0:         lockTable = myLockTable;
0:         currentTime = time;
0: 
0:         if( SanityManager.DEBUG )
0:         {
0:             SanityManager.ASSERT( currentTime > 0, "TIMEOUT_MONITOR: currentTime is not set correctly" );
0:         }
0:     }
0:     
0:     /**
0:      * createException creates a StandardException based on:
0:      *          currentLock
0:      *          a snapshot of the lockTable
0:      * @return StandardException The exception with the lockTable snapshot in it
0:      */
0:     private StandardException createException()
0:     {
0:         try
0:         {
0:             buildLockTableString();
0:         }
0:         catch( StandardException se )
0:         {
0:             return se;
0:         }
0: 
0:         StandardException se = StandardException.newException( SQLState.LOCK_TIMEOUT_LOG, sb.toString() );
0:         se.setReport( StandardException.REPORT_ALWAYS );
0:         return se;
0:     }
0: 
0:     /**
0:      * buildLockTableString creates a LockTable info String
0:      */
0:     private String buildLockTableString() throws StandardException
0:     {
0:         sb = new StringBuffer(8192);
0:         outputRow = new char[ LENGTHOFTABLE ];
0:         int i; // counter
0: 
0:         // need language here to print out tablenames
0:         LanguageConnectionContext lcc = (LanguageConnectionContext)
0:             ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);
0:         if( lcc != null )
0:             tc = lcc.getTransactionExecute();
0: 
0:         try
0:         {
0:             tabInfo = new TableNameInfo( lcc, true );
0:         }
0:         catch (Exception se)
0:         {   //just don't do anything
0:         }
0: 
0:         sb.append( newline );
0:         sb.append(CheapDateFormatter.formatDate(currentTime));
0:         sb.append( newline );
0:         for( i = 0; i < column.length; i++ )
0:         {
0:             sb.append( column[i] );
0:             sb.append( SEPARATOR );
0:         }
0:         sb.append( newline );
0: 
0:         for( i = 0; i < LENGTHOFTABLE; i++ )
0:             sb.append( LINE );
0: 
0:         sb.append( newline );
0: 
0:         // get the timeout lock info
0:         if( currentLock != null )
0:         {
0:             dumpLock( );
0:             if( timeoutInfoHash() )
0:             {
0:                 sb.append( "*** The following row is the victim ***" );
0:                 sb.append( newline );
0:                 sb.append( outputRow );
0:                 sb.append( newline );
0:                 sb.append( "*** The above row is the victim ***" );
0:                 sb.append( newline );
0:             }
0:             else
0:             {
0:                 sb.append( "*** A victim was chosen, but it cannot be printed because the lockable object, " + currentLock + ", does not want to participate ***" );
0:                 sb.append( newline );
0:             }
0:         }
0: 
0:         // get lock info from the rest of the table
0:         if( lockTable != null )
0:         {
0:             while( lockTable.hasMoreElements() )
0:             {
0:                 currentLock = (Latch)lockTable.nextElement();
0:                 dumpLock( );
0:                 if( timeoutInfoHash() )
0:                 {
0:                     sb.append( outputRow );
0:                     sb.append( newline );
0:                 }
0:                 else
0:                 {
0:                     sb.append( "*** A latch/lock, " + currentLock + ", exist in the lockTable that cannot be printed ***" );
0:                     sb.append( newline );
0:                 }
0:             }
0:             for( i = 0; i < LENGTHOFTABLE; i++ )
0:                 sb.append( LINE );
0: 
0:             sb.append( newline );
0:         }
0:         return sb.toString();
0:     }
0: 
0:     /**
0:      * The static entry way to get the LockTable in the system.
0:      * @param timeoutLock The Latch that the timeout happened on
0:      * @param table The lockTable
0:      * @param time The time when the lockTable was cloned
0:      * @return StandardException The exception with the lockTable snapshot in it
0:      */
0:     static StandardException buildException( Latch timeoutLock, Enumeration table, long time )
0:     {
0:         Timeout myTimeout = new Timeout( timeoutLock, table, time );
0:         return myTimeout.createException();
0:     }
0: 
0:     /*
0:      * A static entry way to get the LockTable in the system.
0:      * For track 3311
0:      */
0:     public static String buildString( Enumeration table, long time ) throws StandardException
0:     {
0:         Timeout myTimeout = new Timeout( null, table, time);
0:         return myTimeout.buildLockTableString();
0:     }
0: 
0:     /**
0:      * dumpLock puts information about currentLock into currentRow for output later.
0:      * @throws StandardException
0:      */
0:     private void dumpLock() throws StandardException
0:     {
0:         Hashtable attributes = new Hashtable(17);
0:         Object lock_type = currentLock.getQualifier();
0: 
0:         // want containerId, segmentId, pageNum, recId from locktable
0:         Lockable lockable = currentLock.getLockable();
0: 
0:         // See if the lockable object wants to participate
0:         if( !lockable.lockAttributes(ALL, attributes) )
0:         {
0:             currentRow = null;
0:             return;
0:         }
0: 
0:         // if it does, the lockable object must have filled in the following 
0:         // fields
0:         if( SanityManager.DEBUG )
0:         {
0:             SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKNAME) != null, "lock table can only represent locks that have a LOCKNAME" );
0:             SanityManager.ASSERT(attributes.get(VirtualLockTable.LOCKTYPE) != null, "lock table can only represent locks that have a LOCKTYPE" );
0:             if( attributes.get(VirtualLockTable.CONTAINERID ) == null &&
0:                 attributes.get(VirtualLockTable.CONGLOMID ) == null )
0:                 SanityManager.THROWASSERT("lock table can only represent locks that are associated with a container or conglomerate");
0:         }
0: 
0:         Long conglomId = (Long) attributes.get(VirtualLockTable.CONGLOMID);
0:         
0:         if( conglomId == null )
0:         {
0:             if( attributes.get(VirtualLockTable.CONTAINERID) != null && tc != null )
0:             {   
0:                 Long value = (Long)attributes.get(VirtualLockTable.CONTAINERID);
0:                 conglomId = new Long( tc.findConglomid( value.longValue() ) );
0:                 attributes.put( VirtualLockTable.CONGLOMID, conglomId );
0:             }
0:         }
0: 
0:         Long containerId = (Long) attributes.get(VirtualLockTable.CONTAINERID);
0: 
0:         if( containerId == null )
0:         {
0:             if( conglomId != null && tc != null )
0:             {
0:                 try
0:                 {
0:                     containerId = new Long( tc.findContainerid( conglomId.longValue() ) );
0:                     attributes.put( VirtualLockTable.CONTAINERID, containerId );
0:                 }
0:                 catch( Exception e )
0:                 {
0:                     // just don't do anything
0:                 }
0:             }
0:         }
0:         
0:         attributes.put( VirtualLockTable.LOCKOBJ, currentLock );
0:         attributes.put( VirtualLockTable.XACTID, currentLock.getCompatabilitySpace().toString() );
0:         attributes.put( VirtualLockTable.LOCKMODE, lock_type.toString() );
0:         attributes.put( VirtualLockTable.LOCKCOUNT, Integer.toString( currentLock.getCount() ) );
0:         attributes.put( VirtualLockTable.STATE, (currentLock.getCount() != 0 ) ? "GRANT" : "WAIT" );
0:         
0:         if( tabInfo != null && conglomId != null )
0:         {
0:             try{
0:                 String tableName = tabInfo.getTableName( conglomId );
0:                 attributes.put( VirtualLockTable.TABLENAME, tableName );
0:             }
0:             catch( NullPointerException e )
0:             {
0:                 attributes.put( VirtualLockTable.TABLENAME, conglomId );
0:             }
0:         
0:             try
0:             {
0:                 String indexName = tabInfo.getIndexName( conglomId );
0:                 if( indexName != null )
0:                     attributes.put( VirtualLockTable.INDEXNAME, indexName );
0:                 else
0:                 {
0:                     if( attributes.get(VirtualLockTable.LOCKTYPE).equals("LATCH") )
0:                     {   // because MODE field is way to short to display this,
0:                         // just put it in the indexname field for LATCH only.
0:                         attributes.put( VirtualLockTable.INDEXNAME, attributes.get(VirtualLockTable.LOCKMODE) );
0:                     }
0:                     else
0:                         attributes.put( VirtualLockTable.INDEXNAME, "NULL" );
0:                 }
0:             }catch( Exception e )
0:             {   // we are here because tabInfo.indexCache is null
0:                 if( VirtualLockTable.CONTAINERID != null )
0:                     attributes.put( VirtualLockTable.INDEXNAME, VirtualLockTable.CONTAINERID );
0:                 else
0:                     attributes.put( VirtualLockTable.INDEXNAME, "NULL" );
0:             }
0: 
0:             String tableType = tabInfo.getTableType( conglomId );
0:             attributes.put( VirtualLockTable.TABLETYPE, tableType );
0:         }
0:         else
0:         { 
0:             if( conglomId != null )
0:                 attributes.put( VirtualLockTable.TABLENAME, VirtualLockTable.CONGLOMID );
0:             else
0:                 attributes.put( VirtualLockTable.TABLENAME, "NULL" );
0: 
0:             if( VirtualLockTable.CONTAINERID != null )
0:                 attributes.put( VirtualLockTable.INDEXNAME, VirtualLockTable.CONTAINERID );
0:             else
0:                 attributes.put( VirtualLockTable.INDEXNAME, "NULL" );
0:                 
0:             attributes.put( VirtualLockTable.TABLETYPE, currentLock.toString() );
0:         }
0:         currentRow = attributes;
0:     }
0: 
0:     /**
0:      * cpArray helps built the output string (outputRow).
0:      * @param toCp the String to be copied into outputRow
0:      * @param start the start place
0:      * @param end the end place
0:      */
0:     private void cpArray( String toCp, int start, int end )
0:     {   // build a field in the output string
0:         int i = 0;
0:         int totalAllowWrite = end - start;
0: 
0:         if( toCp != null )
0:         {
0:             for( ; i < toCp.length() ; i++ )
0:             {
0:                 if( (totalAllowWrite-i) == 0 )
0:                     break;
0: 
0:                 outputRow[ i + start ] = toCp.charAt(i);
0:             }
0:         }
0:         for( ; i + start != end; i++ )
0:             outputRow[ i + start ] = ' ';
0: 
0:         outputRow[ end ] = SEPARATOR;
0:     }
0:     
0:     /**
0:      * Copies the needed information from currentRow into the StringBuffer for output
0:      * @return true if successful
0:      */
0:     private boolean timeoutInfoHash( )
0:     {
0:         if( currentRow == null )
0:             return false;
0: 
0:         String[] myData = new String[9];
0:         myData[0] = VirtualLockTable.XACTID;
0:         myData[1] = VirtualLockTable.LOCKTYPE;
0:         myData[2] = VirtualLockTable.LOCKMODE;
0:         myData[3] = VirtualLockTable.LOCKCOUNT;
0:         myData[4] = VirtualLockTable.LOCKNAME;
0:         myData[5] = VirtualLockTable.STATE;
0:         myData[6] = VirtualLockTable.TABLETYPE;
0:         myData[7] = VirtualLockTable.INDEXNAME;
0:         myData[8] = VirtualLockTable.TABLENAME;
0: 
0: 
0:         int currentLength = 0;
0:         for( int i = 0; i < myData.length; i++ )
0:         {
0:             cpArray( currentRow.get( myData[i] ).toString(), currentLength , currentLength + column[i].length() );
0:             // the next beginning position
0:             currentLength = currentLength + column[i].length() + 1;
0:         }
0:         return true;
0:     }
0: }
0: 
============================================================================