1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.access.btree.D_BTreeController
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
3:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.access.btree;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.services.diag.DiagnosticableGeneric;
1:eac0369: import org.apache.derby.iapi.services.diag.DiagnosticUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.store.raw.Page;
1:eac0369: 
1:eac0369: import java.util.Properties;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369:   A BTreeDiag class is a "helper" class for the rest of the btree generic
1:eac0369:   code.  It is separated into a separate class so that it can be compiled
1:eac0369:   out if necessary (or loaded at runtime if necessary).
1:eac0369: 
1:eac0369:   <p>
1:eac0369:   more info.
1:eac0369: **/
1:eac0369: class LevelInfo
1:eac0369: {
1:eac0369:     public int num_pages          = 0; // number of pages in heap.
1:eac0369:     public int num_overflow_pgs   = 0; // number of overflow pages heap.
1:eac0369:     public int num_entries        = 0; // number recs on page
1:eac0369:     public int num_deleted        = 0; // number of recs on page marked deleted.
1:eac0369:     public long max_pageno        = 0; // biggest page number allocated
1:eac0369:     public long num_free_bytes    = 0; // number of free bytes on the pages.
1:eac0369:     public long num_res_bytes     = 0; // number of reserved bytes on the pages.
1:eac0369:     public long num_overflow_rows = 0; // number of over flow rows on page.
1:eac0369:     public long num_rowsize_bytes = 0; // number of bytes in rows.
1:eac0369:     public long num_slottab_bytes = 0; // number of bytes in slot table.
1:eac0369:     public long min_rowsize_bytes = Long.MAX_VALUE; // length of shortest row.
1:eac0369:     public long max_rowsize_bytes = Long.MIN_VALUE; // length of longest row.
1:eac0369: }
1:eac0369: 
1:eac0369: public class D_BTreeController extends DiagnosticableGeneric
1:eac0369: {
1:eac0369:     /* Private/Protected methods of This class: */
1:eac0369:     private static void diag_page(
1:eac0369:     OpenBTree   open_btree,
1:eac0369:     ControlRow  control_row, 
1:eac0369:     Properties  prop,
1:eac0369:     LevelInfo   level_info[])
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         LevelInfo li    = level_info[control_row.getLevel()];
1:eac0369:         Page      page  = control_row.page;
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369:         li.num_pages++;
1:eac0369:         li.num_entries += (page.recordCount() - 1);
1:eac0369:         li.num_deleted += (page.recordCount() - page.nonDeletedRecordCount());
1:eac0369:         li.max_pageno  = Math.max(li.max_pageno, page.getPageNumber());
1:eac0369: 
1:eac0369:         DiagnosticUtil.findDiagnostic(page).diag_detail(prop);
1:eac0369: 
1:eac0369: 
1:eac0369:         DiagnosticUtil.findDiagnostic(page).diag_detail(prop);
1:eac0369: 
1:eac0369:         // number of free bytes on page.
1:eac0369:         int free_bytes = 
1:eac0369:             Integer.parseInt(prop.getProperty(Page.DIAG_BYTES_FREE));
1:eac0369: 
1:eac0369:         li.num_free_bytes += free_bytes;
1:eac0369: 
1:eac0369:         // number of bytes reserved on page.
1:eac0369:         int res_bytes = 
1:eac0369:             Integer.parseInt(prop.getProperty(Page.DIAG_BYTES_RESERVED));
1:eac0369: 
1:eac0369:         li.num_res_bytes += res_bytes;
1:eac0369: 
1:eac0369:         // overflow rows.
1:eac0369:         int overflow = 
1:eac0369:             Integer.parseInt(prop.getProperty(Page.DIAG_NUMOVERFLOWED));
1:eac0369: 
1:eac0369:         li.num_overflow_rows += overflow;
1:eac0369: 
1:eac0369:         // size of rows.
1:eac0369:         int rowsize = 
1:eac0369:             Integer.parseInt(prop.getProperty(Page.DIAG_ROWSIZE));
1:eac0369: 
1:eac0369:         li.num_rowsize_bytes += rowsize;
1:eac0369: 
1:eac0369:         // size of slot table.
1:eac0369:         int slottable_size = 
1:eac0369:             Integer.parseInt(prop.getProperty(Page.DIAG_SLOTTABLE_SIZE));
1:eac0369: 
1:eac0369:         li.num_slottab_bytes += slottable_size;
1:eac0369: 
1:eac0369:         // minimum row size.
1:eac0369:         int min_rowsize = 
1:eac0369:             Integer.parseInt(prop.getProperty(Page.DIAG_MINROWSIZE));
1:eac0369: 
1:eac0369:         li.min_rowsize_bytes = Math.min(li.min_rowsize_bytes, min_rowsize);
1:eac0369: 
1:eac0369:         // maximum row size.
1:eac0369:         int max_rowsize = 
1:eac0369:             Integer.parseInt(prop.getProperty(Page.DIAG_MAXROWSIZE));
1:eac0369: 
1:eac0369:         li.max_rowsize_bytes = Math.max(li.max_rowsize_bytes, max_rowsize);
1:eac0369:     }
1:eac0369: 
1:eac0369:     private static void diag_level(
1:eac0369:     OpenBTree   open_btree,
1:eac0369:     ControlRow  control_row, 
1:eac0369:     Properties  prop,
1:eac0369:     LevelInfo   level_info[])
1:eac0369:         throws StandardException
1:eac0369:     {
1:eac0369:         ControlRow      child = null;
1:eac0369: 
1:eac0369:         diag_page(open_btree, control_row, prop, level_info);
1:eac0369: 
1:eac0369:         try
1:eac0369:         {
1:eac0369:             child = control_row.getLeftChild(open_btree);
1:eac0369: 
1:eac0369:             if (child != null)
1:eac0369:             {
1:eac0369:                 // this is a branch page.
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                     SanityManager.ASSERT(
1:eac0369:                         control_row instanceof BranchControlRow);
1:eac0369: 
1:eac0369:                 BranchControlRow branch = (BranchControlRow) control_row;
1:eac0369: 
1:eac0369:                 diag_level(open_btree, child, prop, level_info);
1:eac0369:                 child.release();
1:eac0369:                 child = null;
1:eac0369: 
1:eac0369:                 int numslots = branch.page.recordCount();
1:eac0369:                 for (int slot = 1; slot < numslots; slot++)
1:eac0369:                 {
1:eac0369:                     child = branch.getChildPageAtSlot(open_btree, slot);
1:eac0369:                     diag_level(open_btree, child, prop, level_info);
1:eac0369:                     child.release();
1:eac0369:                     child = null;
1:eac0369:                 }
1:eac0369:             }
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (child != null)
1:eac0369:                 child.release();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return;
1:eac0369:     }
1:eac0369: 
1:eac0369:     private static String out_summary(
1:eac0369:     String  hdr,
1:eac0369:     long    value,
1:eac0369:     double  ratio,
1:eac0369:     String  ratio_desc)
1:eac0369:     {
1:eac0369:         String double_str = "" + ratio;
1:eac0369: 
1:eac0369:         String short_str = double_str.substring(
1:eac0369:             0, Math.min(double_str.lastIndexOf(".") + 3, double_str.length()));
1:eac0369: 
1:eac0369:         return(
1:eac0369:             "\t" + hdr + value + ".\t(" + short_str + 
1:eac0369:             " " + ratio_desc + ").\n");
1:eac0369:     }
1:eac0369: 
1:eac0369:     private static String diag_onelevel(
1:eac0369:     Properties  prop,
1:eac0369:     LevelInfo   li)
1:eac0369:     {
1:4a4b0a8:         String ret_string   = "";
1:eac0369: 
1:eac0369:         ret_string += 
1:eac0369:             "Btree conglom has:\n" + 
1:eac0369:             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +
1:eac0369:             "\t" + li.num_pages           + " total used pages (" +
1:eac0369:                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * 
1:eac0369:                      li.num_pages) + 
1:eac0369:                 " bytes)\n"            +
1:eac0369:             "\tmaximum page number   = " + li.max_pageno + ".\n"         +
1:eac0369:             "\treserved space %      = " + prop.getProperty(Page.DIAG_RESERVED_SPACE) + "%.\n"         +
1:eac0369:             "\tminimum record size   = " + prop.getProperty(Page.DIAG_MINIMUM_REC_SIZE) + ".\n"         +
1:eac0369:             "\tpage overhead bytes   = " + prop.getProperty(Page.DIAG_PAGEOVERHEAD) + " bytes per page.\n"         +
1:eac0369:             "\tminimum record length = " + li.min_rowsize_bytes + ".\n" +
1:eac0369:             "\tmaximum record length = " + li.max_rowsize_bytes + ".\n" +
1:eac0369:             "\t# of bytes in rows    = " + li.num_rowsize_bytes + "." +
1:eac0369:                 "\t(" + 
1:eac0369:                 (li.num_entries == 0 ? 
1:eac0369:                      0 : (li.num_rowsize_bytes / li.num_entries)) + 
1:eac0369:                 " bytes/row).\n"                                  +
1:eac0369:             out_summary(
1:eac0369:                 "# of reserved bytes   = ", 
1:eac0369:                 li.num_res_bytes,
1:eac0369:                 (li.num_res_bytes / li.num_pages),
1:eac0369:                 "reserved bytes/page") +
1:eac0369:             out_summary(
1:eac0369:                 "# of free bytes       = ",
1:eac0369:                 li.num_free_bytes,
1:eac0369:                 (li.num_free_bytes / li.num_pages),
1:eac0369:                 "free bytes/page")  +
1:eac0369:             out_summary(
1:eac0369:                 "# of slot table bytes = ",
1:eac0369:                 li.num_slottab_bytes,
1:eac0369:                 (li.num_slottab_bytes / li.num_pages),
1:eac0369:                 "slot table bytes/page")  +
1:eac0369:             out_summary(
1:eac0369:                 "# of reserved+free+row+slot bytes = ",
1:eac0369:                 (li.num_rowsize_bytes +
1:eac0369:                  li.num_res_bytes     +
1:eac0369:                  li.num_free_bytes     +
1:eac0369:                  li.num_slottab_bytes),
1:eac0369:                 ((li.num_rowsize_bytes +
1:eac0369:                   li.num_res_bytes     +
1:eac0369:                   li.num_free_bytes     +
1:eac0369:                   li.num_slottab_bytes) / li.num_pages),
1:eac0369:                 "summed bytes/page")  +
1:eac0369:             out_summary(
1:eac0369:                 "# of total records    = ",
1:eac0369:                 li.num_entries,
1:eac0369:                 (((double) li.num_entries) / li.num_pages),
1:eac0369:                 "records/page") +
1:eac0369:             out_summary(
1:eac0369:                 "# of overflow records = ",
1:eac0369:                 li.num_overflow_rows,
1:eac0369:                 (((double) li.num_overflow_rows) / li.num_pages),
1:eac0369:                 "overflow records/page") +
1:eac0369:             out_summary(
1:eac0369:                 "# of deleted records  = ",
1:eac0369:                 li.num_deleted,
1:eac0369:                 (((double) li.num_deleted) / li.num_pages),
1:eac0369:                 "deleted records/page"); 
1:eac0369: 
1:eac0369:         return(ret_string);
1:eac0369:     }
1:eac0369:             
1:eac0369: 
1:eac0369:     private static String diag_tabulate(
1:eac0369:     Properties  prop,
1:eac0369:     LevelInfo   level_info[])
1:eac0369:     {
1:4a4b0a8:         String ret_string   = "";
1:eac0369:         LevelInfo   total   = new LevelInfo();
1:eac0369: 
1:eac0369:         // first tabulate totals for all levels
1:eac0369:         
1:eac0369:         for (int level = 0; level < level_info.length; level++) 
1:eac0369:         {
1:eac0369:             LevelInfo li = level_info[level];
1:eac0369: 
1:eac0369:             total.num_pages         += li.num_pages; 
1:eac0369:             total.num_overflow_pgs  += li.num_overflow_pgs; 
1:eac0369:             total.num_entries       += li.num_entries; 
1:eac0369:             total.num_deleted       += li.num_deleted; 
1:eac0369:             total.max_pageno        = Math.max(total.max_pageno, li.max_pageno);
1:eac0369:             total.num_free_bytes    += li.num_free_bytes; 
1:eac0369:             total.num_res_bytes     += li.num_res_bytes; 
1:eac0369:             total.num_overflow_rows += li.num_overflow_rows; 
1:eac0369:             total.num_rowsize_bytes += li.num_rowsize_bytes; 
1:eac0369:             total.num_slottab_bytes += li.num_slottab_bytes; 
1:eac0369:             total.min_rowsize_bytes = 
1:eac0369:                 Math.min(total.min_rowsize_bytes, li.min_rowsize_bytes);
1:eac0369:             total.max_rowsize_bytes = 
1:eac0369:                 Math.max(total.max_rowsize_bytes, li.max_rowsize_bytes);
1:eac0369:         }
1:eac0369: 
1:eac0369:         ret_string +=
1:eac0369:             "Btree conglom has:\n" + 
1:eac0369:             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +
1:eac0369:             "\t" + total.num_pages           + " total used pages (" +
1:eac0369:                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * 
1:eac0369:                      total.num_pages) + 
1:eac0369:                 " bytes)\n"            +
1:eac0369:             "\tmaximum page number   = " + total.max_pageno + ".\n"         +
1:eac0369:             "\treserved space %      = " + prop.getProperty(Page.DIAG_RESERVED_SPACE) + "%.\n"         +
1:eac0369:             "\tminimum record size   = " + prop.getProperty(Page.DIAG_MINIMUM_REC_SIZE) + ".\n"         +
1:eac0369:             "\tpage overhead bytes   = " + prop.getProperty(Page.DIAG_PAGEOVERHEAD) + " bytes per page.\n";
1:eac0369: 
1:eac0369:         // Format Totals:
1:eac0369:         ret_string += diag_onelevel(prop, total);
1:eac0369: 
1:eac0369:         // Format Totals by level:
1:eac0369: 
1:eac0369:         // Totals by level:
1:eac0369:         for (int level = 0; level < level_info.length; level++) 
1:eac0369:         {
1:eac0369:             LevelInfo   li = level_info[level];
1:eac0369: 
1:eac0369:             ret_string += "level[" + level + "] stats:\n";
1:eac0369: 
1:eac0369:             ret_string += diag_onelevel(prop, li);
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_string);
1:eac0369:     }
1:eac0369: 
1:eac0369:     private static String olddiag_tabulate(
1:eac0369:     Properties  prop,
1:eac0369:     LevelInfo   level_info[])
1:eac0369:     {
1:4a4b0a8:         String ret_string   = "";
1:eac0369:         long   total_pages  = 0;
1:eac0369:         long   total_res    = 0;
1:eac0369: 
1:eac0369:         for (int level = 0; level < level_info.length; level++) 
1:eac0369:         {
1:eac0369:             total_pages += level_info[level].num_pages;
1:eac0369:         }
1:eac0369: 
1:eac0369: 
1:eac0369:         // Totals:
1:eac0369:         ret_string += 
1:eac0369:             "Btree conglom has:\n" + 
1:eac0369:             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +
1:eac0369:             "\t" + total_pages               + " total pages ("                +
1:eac0369:                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * 
1:eac0369:                      total_pages) + " bytes)\n"                                +
1:eac0369:             "\t" + level_info.length         + " total levels\n"               +
1:eac0369:             "\t" + level_info[0].num_entries + " total user records\n";
1:eac0369: 
1:eac0369:         // Totals by level:
1:eac0369:         for (int level = 0; level < level_info.length; level++) 
1:eac0369:         {
1:eac0369:             LevelInfo   li = level_info[level];
1:eac0369: 
1:eac0369:             ret_string += "level[" + level + "] stats:\n";
1:eac0369: 
1:eac0369:             ret_string += 
1:eac0369:                 "\t# of pages           = " + li.num_pages      + ".\n" +
1:eac0369:                 "\t# of entries         = " + li.num_entries    + ".  " +
1:eac0369:                 "(" + (li.num_entries / li.num_pages) + " entries/page).\n" +
1:eac0369:                 "\t# of deleted entries = " + li.num_deleted    + ".  " +
1:eac0369:                 "(" + (li.num_deleted / li.num_pages) + " deleted/page).\n" +
1:eac0369:                 "\t# of free bytes      = " + li.num_res_bytes + ".  " +
1:eac0369:                 "(" + (li.num_res_bytes / li.num_pages) + " reserved bytes/page).\n" +
1:eac0369:                 "\t# of free bytes      = " + li.num_free_bytes + ".  " +
1:eac0369:                 "(" + (li.num_free_bytes / li.num_pages) + " free bytes/page).\n" +
1:eac0369:                 "\t# of slot table bytes= " + li.num_slottab_bytes + ".  " +
1:eac0369:                 "(" + (li.num_slottab_bytes / li.num_pages) + " slot table bytes/page).\n";
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(ret_string);
1:eac0369:     }
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of Diagnosticable
1:eac0369: 	*/
1:eac0369:     public void init(Object obj)
1:eac0369:     {
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:             SanityManager.ASSERT(obj instanceof BTreeController);
1:eac0369: 
1:eac0369:         super.init(obj);
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Default implementation of diagnostic on the object.
1:eac0369:      * <p>
1:eac0369:      * This routine returns a string with whatever diagnostic information
1:eac0369:      * you would like to provide about this object.
1:eac0369:      * <p>
1:eac0369:      * This routine returns a summary table of information about pages in
1:eac0369:      * each level of the btree.  It tells the height of the tree, the 
1:eac0369:      * average free and reserved bytes per level, and the page size.
1:eac0369:      * <p>
1:eac0369:      *
1:eac0369: 	 * @return A string with diagnostic information about the object.
1:eac0369:      *
1:94f158a:      * @exception StandardException  Standard Derby exception policy
1:eac0369:      **/
1:eac0369:     public String diag()
1:eac0369:         throws StandardException
1:eac0369:     {
1:7af858d:         OpenBTree   open_btree  = (OpenBTree) this.diag_object;
1:eac0369:         ControlRow  root        = null;
1:eac0369:         int         tree_height;
1:eac0369:         LevelInfo   level_info[] = null;
1:4a4b0a8:         String      diag_info    = "";
1:eac0369: 
1:eac0369:         
1:eac0369:         try
1:eac0369:         {
1:eac0369:             tree_height = open_btree.getHeight();
1:4a2b0d9:             root = ControlRow.get(open_btree, BTree.ROOTPAGEID);
1:eac0369: 
1:eac0369:             // Allocate a LevelInfo array with one entry per level of the tree.
1:eac0369:             level_info = new LevelInfo[tree_height];
1:eac0369:             for (int level = 0; level < level_info.length; level++) 
1:eac0369:                 level_info[level] = new LevelInfo();
1:eac0369: 
1:eac0369:             // ask page to provide diag info:
1:eac0369:             Properties prop = new Properties();
1:eac0369:             prop.put(Page.DIAG_PAGE_SIZE,        "");
1:eac0369:             prop.put(Page.DIAG_BYTES_FREE,       "");
1:eac0369:             prop.put(Page.DIAG_BYTES_RESERVED,   "");
1:eac0369:             prop.put(Page.DIAG_RESERVED_SPACE,   "");
1:eac0369:             prop.put(Page.DIAG_MINIMUM_REC_SIZE, "");
1:eac0369:             prop.put(Page.DIAG_NUMOVERFLOWED,    "");
1:eac0369:             prop.put(Page.DIAG_ROWSIZE,          "");
1:eac0369:             prop.put(Page.DIAG_MINROWSIZE,       "");
1:eac0369:             prop.put(Page.DIAG_MAXROWSIZE,       "");
1:eac0369:             prop.put(Page.DIAG_PAGEOVERHEAD,     "");
1:eac0369:             prop.put(Page.DIAG_SLOTTABLE_SIZE,   "");
1:eac0369: 
1:eac0369:             diag_level(open_btree, root, prop, level_info);
1:eac0369: 
1:eac0369: 
1:eac0369:             diag_info = diag_tabulate(prop, level_info);
1:eac0369:         }
1:eac0369:         finally
1:eac0369:         {
1:eac0369:             if (root != null)
1:eac0369:                 root.release();
1:eac0369:         }
1:eac0369: 
1:eac0369:         return(diag_info);
1:eac0369:     }
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:4a4b0a8
/////////////////////////////////////////////////////////////////////////
1:         String ret_string   = "";
/////////////////////////////////////////////////////////////////////////
1:         String ret_string   = "";
/////////////////////////////////////////////////////////////////////////
1:         String ret_string   = "";
/////////////////////////////////////////////////////////////////////////
1:         String      diag_info    = "";
commit:7af858d
/////////////////////////////////////////////////////////////////////////
1:         OpenBTree   open_btree  = (OpenBTree) this.diag_object;
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:4a2b0d9
/////////////////////////////////////////////////////////////////////////
1:             root = ControlRow.get(open_btree, BTree.ROOTPAGEID);
commit:fa09146
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1:      * @exception StandardException  Standard Derby exception policy
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.access.btree.D_BTreeController
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.access.btree;
1: 
0: import org.apache.derby.iapi.reference.Property;
1: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.diag.Diagnosticable;
1: import org.apache.derby.iapi.services.diag.DiagnosticableGeneric;
1: import org.apache.derby.iapi.services.diag.DiagnosticUtil;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.db.Database;
1: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
1: import org.apache.derby.iapi.store.raw.Page;
1: 
1: import java.util.Properties;
1: 
1: /**
1: 
1:   A BTreeDiag class is a "helper" class for the rest of the btree generic
1:   code.  It is separated into a separate class so that it can be compiled
1:   out if necessary (or loaded at runtime if necessary).
1: 
1:   <p>
1:   more info.
1: **/
1: class LevelInfo
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1:     public int num_pages          = 0; // number of pages in heap.
1:     public int num_overflow_pgs   = 0; // number of overflow pages heap.
1:     public int num_entries        = 0; // number recs on page
1:     public int num_deleted        = 0; // number of recs on page marked deleted.
1:     public long max_pageno        = 0; // biggest page number allocated
1:     public long num_free_bytes    = 0; // number of free bytes on the pages.
1:     public long num_res_bytes     = 0; // number of reserved bytes on the pages.
1:     public long num_overflow_rows = 0; // number of over flow rows on page.
1:     public long num_rowsize_bytes = 0; // number of bytes in rows.
1:     public long num_slottab_bytes = 0; // number of bytes in slot table.
1:     public long min_rowsize_bytes = Long.MAX_VALUE; // length of shortest row.
1:     public long max_rowsize_bytes = Long.MIN_VALUE; // length of longest row.
1: }
1: 
1: public class D_BTreeController extends DiagnosticableGeneric
1: {
1:     /* Private/Protected methods of This class: */
1:     private static void diag_page(
1:     OpenBTree   open_btree,
1:     ControlRow  control_row, 
1:     Properties  prop,
1:     LevelInfo   level_info[])
1:         throws StandardException
1:     {
1:         LevelInfo li    = level_info[control_row.getLevel()];
1:         Page      page  = control_row.page;
1: 
1: 
1: 
1:         li.num_pages++;
1:         li.num_entries += (page.recordCount() - 1);
1:         li.num_deleted += (page.recordCount() - page.nonDeletedRecordCount());
1:         li.max_pageno  = Math.max(li.max_pageno, page.getPageNumber());
1: 
1:         DiagnosticUtil.findDiagnostic(page).diag_detail(prop);
1: 
1: 
1:         DiagnosticUtil.findDiagnostic(page).diag_detail(prop);
1: 
1:         // number of free bytes on page.
1:         int free_bytes = 
1:             Integer.parseInt(prop.getProperty(Page.DIAG_BYTES_FREE));
1: 
1:         li.num_free_bytes += free_bytes;
1: 
1:         // number of bytes reserved on page.
1:         int res_bytes = 
1:             Integer.parseInt(prop.getProperty(Page.DIAG_BYTES_RESERVED));
1: 
1:         li.num_res_bytes += res_bytes;
1: 
1:         // overflow rows.
1:         int overflow = 
1:             Integer.parseInt(prop.getProperty(Page.DIAG_NUMOVERFLOWED));
1: 
1:         li.num_overflow_rows += overflow;
1: 
1:         // size of rows.
1:         int rowsize = 
1:             Integer.parseInt(prop.getProperty(Page.DIAG_ROWSIZE));
1: 
1:         li.num_rowsize_bytes += rowsize;
1: 
1:         // size of slot table.
1:         int slottable_size = 
1:             Integer.parseInt(prop.getProperty(Page.DIAG_SLOTTABLE_SIZE));
1: 
1:         li.num_slottab_bytes += slottable_size;
1: 
1:         // minimum row size.
1:         int min_rowsize = 
1:             Integer.parseInt(prop.getProperty(Page.DIAG_MINROWSIZE));
1: 
1:         li.min_rowsize_bytes = Math.min(li.min_rowsize_bytes, min_rowsize);
1: 
1:         // maximum row size.
1:         int max_rowsize = 
1:             Integer.parseInt(prop.getProperty(Page.DIAG_MAXROWSIZE));
1: 
1:         li.max_rowsize_bytes = Math.max(li.max_rowsize_bytes, max_rowsize);
1:     }
1: 
1:     private static void diag_level(
1:     OpenBTree   open_btree,
1:     ControlRow  control_row, 
1:     Properties  prop,
1:     LevelInfo   level_info[])
1:         throws StandardException
1:     {
1:         ControlRow      child = null;
1: 
1:         diag_page(open_btree, control_row, prop, level_info);
1: 
1:         try
1:         {
1:             child = control_row.getLeftChild(open_btree);
1: 
1:             if (child != null)
1:             {
1:                 // this is a branch page.
1:                 if (SanityManager.DEBUG)
1:                     SanityManager.ASSERT(
1:                         control_row instanceof BranchControlRow);
1: 
1:                 BranchControlRow branch = (BranchControlRow) control_row;
1: 
1:                 diag_level(open_btree, child, prop, level_info);
1:                 child.release();
1:                 child = null;
1: 
1:                 int numslots = branch.page.recordCount();
1:                 for (int slot = 1; slot < numslots; slot++)
1:                 {
1:                     child = branch.getChildPageAtSlot(open_btree, slot);
1:                     diag_level(open_btree, child, prop, level_info);
1:                     child.release();
1:                     child = null;
1:                 }
1:             }
1:         }
1:         finally
1:         {
1:             if (child != null)
1:                 child.release();
1:         }
1: 
1:         return;
1:     }
1: 
1:     private static String out_summary(
1:     String  hdr,
1:     long    value,
1:     double  ratio,
1:     String  ratio_desc)
1:     {
1:         String double_str = "" + ratio;
1: 
1:         String short_str = double_str.substring(
1:             0, Math.min(double_str.lastIndexOf(".") + 3, double_str.length()));
1: 
1:         return(
1:             "\t" + hdr + value + ".\t(" + short_str + 
1:             " " + ratio_desc + ").\n");
1:     }
1: 
1:     private static String diag_onelevel(
1:     Properties  prop,
1:     LevelInfo   li)
1:     {
0:         String ret_string   = new String();
1: 
1:         ret_string += 
1:             "Btree conglom has:\n" + 
1:             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +
1:             "\t" + li.num_pages           + " total used pages (" +
1:                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * 
1:                      li.num_pages) + 
1:                 " bytes)\n"            +
1:             "\tmaximum page number   = " + li.max_pageno + ".\n"         +
1:             "\treserved space %      = " + prop.getProperty(Page.DIAG_RESERVED_SPACE) + "%.\n"         +
1:             "\tminimum record size   = " + prop.getProperty(Page.DIAG_MINIMUM_REC_SIZE) + ".\n"         +
1:             "\tpage overhead bytes   = " + prop.getProperty(Page.DIAG_PAGEOVERHEAD) + " bytes per page.\n"         +
1:             "\tminimum record length = " + li.min_rowsize_bytes + ".\n" +
1:             "\tmaximum record length = " + li.max_rowsize_bytes + ".\n" +
1:             "\t# of bytes in rows    = " + li.num_rowsize_bytes + "." +
1:                 "\t(" + 
1:                 (li.num_entries == 0 ? 
1:                      0 : (li.num_rowsize_bytes / li.num_entries)) + 
1:                 " bytes/row).\n"                                  +
1:             out_summary(
1:                 "# of reserved bytes   = ", 
1:                 li.num_res_bytes,
1:                 (li.num_res_bytes / li.num_pages),
1:                 "reserved bytes/page") +
1:             out_summary(
1:                 "# of free bytes       = ",
1:                 li.num_free_bytes,
1:                 (li.num_free_bytes / li.num_pages),
1:                 "free bytes/page")  +
1:             out_summary(
1:                 "# of slot table bytes = ",
1:                 li.num_slottab_bytes,
1:                 (li.num_slottab_bytes / li.num_pages),
1:                 "slot table bytes/page")  +
1:             out_summary(
1:                 "# of reserved+free+row+slot bytes = ",
1:                 (li.num_rowsize_bytes +
1:                  li.num_res_bytes     +
1:                  li.num_free_bytes     +
1:                  li.num_slottab_bytes),
1:                 ((li.num_rowsize_bytes +
1:                   li.num_res_bytes     +
1:                   li.num_free_bytes     +
1:                   li.num_slottab_bytes) / li.num_pages),
1:                 "summed bytes/page")  +
1:             out_summary(
1:                 "# of total records    = ",
1:                 li.num_entries,
1:                 (((double) li.num_entries) / li.num_pages),
1:                 "records/page") +
1:             out_summary(
1:                 "# of overflow records = ",
1:                 li.num_overflow_rows,
1:                 (((double) li.num_overflow_rows) / li.num_pages),
1:                 "overflow records/page") +
1:             out_summary(
1:                 "# of deleted records  = ",
1:                 li.num_deleted,
1:                 (((double) li.num_deleted) / li.num_pages),
1:                 "deleted records/page"); 
1: 
1:         return(ret_string);
1:     }
1:             
1: 
1:     private static String diag_tabulate(
1:     Properties  prop,
1:     LevelInfo   level_info[])
1:     {
0:         String ret_string   = new String();
1:         LevelInfo   total   = new LevelInfo();
1: 
1:         // first tabulate totals for all levels
1:         
1:         for (int level = 0; level < level_info.length; level++) 
1:         {
1:             LevelInfo li = level_info[level];
1: 
1:             total.num_pages         += li.num_pages; 
1:             total.num_overflow_pgs  += li.num_overflow_pgs; 
1:             total.num_entries       += li.num_entries; 
1:             total.num_deleted       += li.num_deleted; 
1:             total.max_pageno        = Math.max(total.max_pageno, li.max_pageno);
1:             total.num_free_bytes    += li.num_free_bytes; 
1:             total.num_res_bytes     += li.num_res_bytes; 
1:             total.num_overflow_rows += li.num_overflow_rows; 
1:             total.num_rowsize_bytes += li.num_rowsize_bytes; 
1:             total.num_slottab_bytes += li.num_slottab_bytes; 
1:             total.min_rowsize_bytes = 
1:                 Math.min(total.min_rowsize_bytes, li.min_rowsize_bytes);
1:             total.max_rowsize_bytes = 
1:                 Math.max(total.max_rowsize_bytes, li.max_rowsize_bytes);
1:         }
1: 
1:         ret_string +=
1:             "Btree conglom has:\n" + 
1:             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +
1:             "\t" + total.num_pages           + " total used pages (" +
1:                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * 
1:                      total.num_pages) + 
1:                 " bytes)\n"            +
1:             "\tmaximum page number   = " + total.max_pageno + ".\n"         +
1:             "\treserved space %      = " + prop.getProperty(Page.DIAG_RESERVED_SPACE) + "%.\n"         +
1:             "\tminimum record size   = " + prop.getProperty(Page.DIAG_MINIMUM_REC_SIZE) + ".\n"         +
1:             "\tpage overhead bytes   = " + prop.getProperty(Page.DIAG_PAGEOVERHEAD) + " bytes per page.\n";
1: 
1:         // Format Totals:
1:         ret_string += diag_onelevel(prop, total);
1: 
1:         // Format Totals by level:
1: 
1:         // Totals by level:
1:         for (int level = 0; level < level_info.length; level++) 
1:         {
1:             LevelInfo   li = level_info[level];
1: 
1:             ret_string += "level[" + level + "] stats:\n";
1: 
1:             ret_string += diag_onelevel(prop, li);
1:         }
1: 
1:         return(ret_string);
1:     }
1: 
1:     private static String olddiag_tabulate(
1:     Properties  prop,
1:     LevelInfo   level_info[])
1:     {
0:         String ret_string   = new String();
1:         long   total_pages  = 0;
1:         long   total_res    = 0;
1: 
1:         for (int level = 0; level < level_info.length; level++) 
1:         {
1:             total_pages += level_info[level].num_pages;
1:         }
1: 
1: 
1:         // Totals:
1:         ret_string += 
1:             "Btree conglom has:\n" + 
1:             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +
1:             "\t" + total_pages               + " total pages ("                +
1:                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * 
1:                      total_pages) + " bytes)\n"                                +
1:             "\t" + level_info.length         + " total levels\n"               +
1:             "\t" + level_info[0].num_entries + " total user records\n";
1: 
1:         // Totals by level:
1:         for (int level = 0; level < level_info.length; level++) 
1:         {
1:             LevelInfo   li = level_info[level];
1: 
1:             ret_string += "level[" + level + "] stats:\n";
1: 
1:             ret_string += 
1:                 "\t# of pages           = " + li.num_pages      + ".\n" +
1:                 "\t# of entries         = " + li.num_entries    + ".  " +
1:                 "(" + (li.num_entries / li.num_pages) + " entries/page).\n" +
1:                 "\t# of deleted entries = " + li.num_deleted    + ".  " +
1:                 "(" + (li.num_deleted / li.num_pages) + " deleted/page).\n" +
1:                 "\t# of free bytes      = " + li.num_res_bytes + ".  " +
1:                 "(" + (li.num_res_bytes / li.num_pages) + " reserved bytes/page).\n" +
1:                 "\t# of free bytes      = " + li.num_free_bytes + ".  " +
1:                 "(" + (li.num_free_bytes / li.num_pages) + " free bytes/page).\n" +
1:                 "\t# of slot table bytes= " + li.num_slottab_bytes + ".  " +
1:                 "(" + (li.num_slottab_bytes / li.num_pages) + " slot table bytes/page).\n";
1:         }
1: 
1:         return(ret_string);
1:     }
1: 
1: 	/*
1: 	** Methods of Diagnosticable
1: 	*/
1:     public void init(Object obj)
1:     {
1:         if (SanityManager.DEBUG)
1:             SanityManager.ASSERT(obj instanceof BTreeController);
1: 
1:         super.init(obj);
1:     }
1: 
1:     /**
1:      * Default implementation of diagnostic on the object.
1:      * <p>
1:      * This routine returns a string with whatever diagnostic information
1:      * you would like to provide about this object.
1:      * <p>
1:      * This routine returns a summary table of information about pages in
1:      * each level of the btree.  It tells the height of the tree, the 
1:      * average free and reserved bytes per level, and the page size.
1:      * <p>
1:      *
1: 	 * @return A string with diagnostic information about the object.
1:      *
0:      * @exception StandardException  Standard cloudscape exception policy
1:      **/
1:     public String diag()
1:         throws StandardException
1:     {
0:         OpenBTree   open_btree  = (BTreeController) this.diag_object;
1:         ControlRow  root        = null;
1:         int         tree_height;
1:         LevelInfo   level_info[] = null;
0:         String      diag_info    = new String();
1: 
1:         
1:         try
1:         {
1:             tree_height = open_btree.getHeight();
0:             root = ControlRow.Get(open_btree, BTree.ROOTPAGEID);
1: 
1:             // Allocate a LevelInfo array with one entry per level of the tree.
1:             level_info = new LevelInfo[tree_height];
1:             for (int level = 0; level < level_info.length; level++) 
1:                 level_info[level] = new LevelInfo();
1: 
1:             // ask page to provide diag info:
1:             Properties prop = new Properties();
1:             prop.put(Page.DIAG_PAGE_SIZE,        "");
1:             prop.put(Page.DIAG_BYTES_FREE,       "");
1:             prop.put(Page.DIAG_BYTES_RESERVED,   "");
1:             prop.put(Page.DIAG_RESERVED_SPACE,   "");
1:             prop.put(Page.DIAG_MINIMUM_REC_SIZE, "");
1:             prop.put(Page.DIAG_NUMOVERFLOWED,    "");
1:             prop.put(Page.DIAG_ROWSIZE,          "");
1:             prop.put(Page.DIAG_MINROWSIZE,       "");
1:             prop.put(Page.DIAG_MAXROWSIZE,       "");
1:             prop.put(Page.DIAG_PAGEOVERHEAD,     "");
1:             prop.put(Page.DIAG_SLOTTABLE_SIZE,   "");
1: 
1:             diag_level(open_btree, root, prop, level_info);
1: 
1: 
1:             diag_info = diag_tabulate(prop, level_info);
1:         }
1:         finally
1:         {
1:             if (root != null)
1:                 root.release();
1:         }
1: 
1:         return(diag_info);
1:     }
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.access.btree
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.access.btree;
0: 
0: import org.apache.derby.iapi.reference.Property;
0: 
0: import org.apache.derby.iapi.services.context.ContextManager;
0: import org.apache.derby.iapi.services.diag.Diagnosticable;
0: import org.apache.derby.iapi.services.diag.DiagnosticableGeneric;
0: import org.apache.derby.iapi.services.diag.DiagnosticUtil;
0: import org.apache.derby.iapi.services.monitor.Monitor;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.db.Database;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.store.access.AccessFactory;
0: import org.apache.derby.iapi.store.access.ConglomerateController;
0: import org.apache.derby.iapi.store.access.TransactionController;
0: import org.apache.derby.iapi.store.raw.ContainerHandle;
0: import org.apache.derby.iapi.store.raw.Page;
0: 
0: import java.util.Properties;
0: 
0: /**
0: 
0:   A BTreeDiag class is a "helper" class for the rest of the btree generic
0:   code.  It is separated into a separate class so that it can be compiled
0:   out if necessary (or loaded at runtime if necessary).
0: 
0:   <p>
0:   more info.
0: **/
0: class LevelInfo
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0:     public int num_pages          = 0; // number of pages in heap.
0:     public int num_overflow_pgs   = 0; // number of overflow pages heap.
0:     public int num_entries        = 0; // number recs on page
0:     public int num_deleted        = 0; // number of recs on page marked deleted.
0:     public long max_pageno        = 0; // biggest page number allocated
0:     public long num_free_bytes    = 0; // number of free bytes on the pages.
0:     public long num_res_bytes     = 0; // number of reserved bytes on the pages.
0:     public long num_overflow_rows = 0; // number of over flow rows on page.
0:     public long num_rowsize_bytes = 0; // number of bytes in rows.
0:     public long num_slottab_bytes = 0; // number of bytes in slot table.
0:     public long min_rowsize_bytes = Long.MAX_VALUE; // length of shortest row.
0:     public long max_rowsize_bytes = Long.MIN_VALUE; // length of longest row.
0: }
0: 
0: public class D_BTreeController extends DiagnosticableGeneric
0: {
0:     /* Private/Protected methods of This class: */
0:     private static void diag_page(
0:     OpenBTree   open_btree,
0:     ControlRow  control_row, 
0:     Properties  prop,
0:     LevelInfo   level_info[])
0:         throws StandardException
0:     {
0:         LevelInfo li    = level_info[control_row.getLevel()];
0:         Page      page  = control_row.page;
0: 
0: 
0: 
0:         li.num_pages++;
0:         li.num_entries += (page.recordCount() - 1);
0:         li.num_deleted += (page.recordCount() - page.nonDeletedRecordCount());
0:         li.max_pageno  = Math.max(li.max_pageno, page.getPageNumber());
0: 
0:         DiagnosticUtil.findDiagnostic(page).diag_detail(prop);
0: 
0: 
0:         DiagnosticUtil.findDiagnostic(page).diag_detail(prop);
0: 
0:         // number of free bytes on page.
0:         int free_bytes = 
0:             Integer.parseInt(prop.getProperty(Page.DIAG_BYTES_FREE));
0: 
0:         li.num_free_bytes += free_bytes;
0: 
0:         // number of bytes reserved on page.
0:         int res_bytes = 
0:             Integer.parseInt(prop.getProperty(Page.DIAG_BYTES_RESERVED));
0: 
0:         li.num_res_bytes += res_bytes;
0: 
0:         // overflow rows.
0:         int overflow = 
0:             Integer.parseInt(prop.getProperty(Page.DIAG_NUMOVERFLOWED));
0: 
0:         li.num_overflow_rows += overflow;
0: 
0:         // size of rows.
0:         int rowsize = 
0:             Integer.parseInt(prop.getProperty(Page.DIAG_ROWSIZE));
0: 
0:         li.num_rowsize_bytes += rowsize;
0: 
0:         // size of slot table.
0:         int slottable_size = 
0:             Integer.parseInt(prop.getProperty(Page.DIAG_SLOTTABLE_SIZE));
0: 
0:         li.num_slottab_bytes += slottable_size;
0: 
0:         // minimum row size.
0:         int min_rowsize = 
0:             Integer.parseInt(prop.getProperty(Page.DIAG_MINROWSIZE));
0: 
0:         li.min_rowsize_bytes = Math.min(li.min_rowsize_bytes, min_rowsize);
0: 
0:         // maximum row size.
0:         int max_rowsize = 
0:             Integer.parseInt(prop.getProperty(Page.DIAG_MAXROWSIZE));
0: 
0:         li.max_rowsize_bytes = Math.max(li.max_rowsize_bytes, max_rowsize);
0:     }
0: 
0:     private static void diag_level(
0:     OpenBTree   open_btree,
0:     ControlRow  control_row, 
0:     Properties  prop,
0:     LevelInfo   level_info[])
0:         throws StandardException
0:     {
0:         ControlRow      child = null;
0: 
0:         diag_page(open_btree, control_row, prop, level_info);
0: 
0:         try
0:         {
0:             child = control_row.getLeftChild(open_btree);
0: 
0:             if (child != null)
0:             {
0:                 // this is a branch page.
0:                 if (SanityManager.DEBUG)
0:                     SanityManager.ASSERT(
0:                         control_row instanceof BranchControlRow);
0: 
0:                 BranchControlRow branch = (BranchControlRow) control_row;
0: 
0:                 diag_level(open_btree, child, prop, level_info);
0:                 child.release();
0:                 child = null;
0: 
0:                 int numslots = branch.page.recordCount();
0:                 for (int slot = 1; slot < numslots; slot++)
0:                 {
0:                     child = branch.getChildPageAtSlot(open_btree, slot);
0:                     diag_level(open_btree, child, prop, level_info);
0:                     child.release();
0:                     child = null;
0:                 }
0:             }
0:         }
0:         finally
0:         {
0:             if (child != null)
0:                 child.release();
0:         }
0: 
0:         return;
0:     }
0: 
0:     private static String out_summary(
0:     String  hdr,
0:     long    value,
0:     double  ratio,
0:     String  ratio_desc)
0:     {
0:         String double_str = "" + ratio;
0: 
0:         String short_str = double_str.substring(
0:             0, Math.min(double_str.lastIndexOf(".") + 3, double_str.length()));
0: 
0:         return(
0:             "\t" + hdr + value + ".\t(" + short_str + 
0:             " " + ratio_desc + ").\n");
0:     }
0: 
0:     private static String diag_onelevel(
0:     Properties  prop,
0:     LevelInfo   li)
0:     {
0:         String ret_string   = new String();
0: 
0:         ret_string += 
0:             "Btree conglom has:\n" + 
0:             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +
0:             "\t" + li.num_pages           + " total used pages (" +
0:                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * 
0:                      li.num_pages) + 
0:                 " bytes)\n"            +
0:             "\tmaximum page number   = " + li.max_pageno + ".\n"         +
0:             "\treserved space %      = " + prop.getProperty(Page.DIAG_RESERVED_SPACE) + "%.\n"         +
0:             "\tminimum record size   = " + prop.getProperty(Page.DIAG_MINIMUM_REC_SIZE) + ".\n"         +
0:             "\tpage overhead bytes   = " + prop.getProperty(Page.DIAG_PAGEOVERHEAD) + " bytes per page.\n"         +
0:             "\tminimum record length = " + li.min_rowsize_bytes + ".\n" +
0:             "\tmaximum record length = " + li.max_rowsize_bytes + ".\n" +
0:             "\t# of bytes in rows    = " + li.num_rowsize_bytes + "." +
0:                 "\t(" + 
0:                 (li.num_entries == 0 ? 
0:                      0 : (li.num_rowsize_bytes / li.num_entries)) + 
0:                 " bytes/row).\n"                                  +
0:             out_summary(
0:                 "# of reserved bytes   = ", 
0:                 li.num_res_bytes,
0:                 (li.num_res_bytes / li.num_pages),
0:                 "reserved bytes/page") +
0:             out_summary(
0:                 "# of free bytes       = ",
0:                 li.num_free_bytes,
0:                 (li.num_free_bytes / li.num_pages),
0:                 "free bytes/page")  +
0:             out_summary(
0:                 "# of slot table bytes = ",
0:                 li.num_slottab_bytes,
0:                 (li.num_slottab_bytes / li.num_pages),
0:                 "slot table bytes/page")  +
0:             out_summary(
0:                 "# of reserved+free+row+slot bytes = ",
0:                 (li.num_rowsize_bytes +
0:                  li.num_res_bytes     +
0:                  li.num_free_bytes     +
0:                  li.num_slottab_bytes),
0:                 ((li.num_rowsize_bytes +
0:                   li.num_res_bytes     +
0:                   li.num_free_bytes     +
0:                   li.num_slottab_bytes) / li.num_pages),
0:                 "summed bytes/page")  +
0:             out_summary(
0:                 "# of total records    = ",
0:                 li.num_entries,
0:                 (((double) li.num_entries) / li.num_pages),
0:                 "records/page") +
0:             out_summary(
0:                 "# of overflow records = ",
0:                 li.num_overflow_rows,
0:                 (((double) li.num_overflow_rows) / li.num_pages),
0:                 "overflow records/page") +
0:             out_summary(
0:                 "# of deleted records  = ",
0:                 li.num_deleted,
0:                 (((double) li.num_deleted) / li.num_pages),
0:                 "deleted records/page"); 
0: 
0:         return(ret_string);
0:     }
0:             
0: 
0:     private static String diag_tabulate(
0:     Properties  prop,
0:     LevelInfo   level_info[])
0:     {
0:         String ret_string   = new String();
0:         LevelInfo   total   = new LevelInfo();
0: 
0:         // first tabulate totals for all levels
0:         
0:         for (int level = 0; level < level_info.length; level++) 
0:         {
0:             LevelInfo li = level_info[level];
0: 
0:             total.num_pages         += li.num_pages; 
0:             total.num_overflow_pgs  += li.num_overflow_pgs; 
0:             total.num_entries       += li.num_entries; 
0:             total.num_deleted       += li.num_deleted; 
0:             total.max_pageno        = Math.max(total.max_pageno, li.max_pageno);
0:             total.num_free_bytes    += li.num_free_bytes; 
0:             total.num_res_bytes     += li.num_res_bytes; 
0:             total.num_overflow_rows += li.num_overflow_rows; 
0:             total.num_rowsize_bytes += li.num_rowsize_bytes; 
0:             total.num_slottab_bytes += li.num_slottab_bytes; 
0:             total.min_rowsize_bytes = 
0:                 Math.min(total.min_rowsize_bytes, li.min_rowsize_bytes);
0:             total.max_rowsize_bytes = 
0:                 Math.max(total.max_rowsize_bytes, li.max_rowsize_bytes);
0:         }
0: 
0:         ret_string +=
0:             "Btree conglom has:\n" + 
0:             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +
0:             "\t" + total.num_pages           + " total used pages (" +
0:                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * 
0:                      total.num_pages) + 
0:                 " bytes)\n"            +
0:             "\tmaximum page number   = " + total.max_pageno + ".\n"         +
0:             "\treserved space %      = " + prop.getProperty(Page.DIAG_RESERVED_SPACE) + "%.\n"         +
0:             "\tminimum record size   = " + prop.getProperty(Page.DIAG_MINIMUM_REC_SIZE) + ".\n"         +
0:             "\tpage overhead bytes   = " + prop.getProperty(Page.DIAG_PAGEOVERHEAD) + " bytes per page.\n";
0: 
0:         // Format Totals:
0:         ret_string += diag_onelevel(prop, total);
0: 
0:         // Format Totals by level:
0: 
0:         // Totals by level:
0:         for (int level = 0; level < level_info.length; level++) 
0:         {
0:             LevelInfo   li = level_info[level];
0: 
0:             ret_string += "level[" + level + "] stats:\n";
0: 
0:             ret_string += diag_onelevel(prop, li);
0:         }
0: 
0:         return(ret_string);
0:     }
0: 
0:     private static String olddiag_tabulate(
0:     Properties  prop,
0:     LevelInfo   level_info[])
0:     {
0:         String ret_string   = new String();
0:         long   total_pages  = 0;
0:         long   total_res    = 0;
0: 
0:         for (int level = 0; level < level_info.length; level++) 
0:         {
0:             total_pages += level_info[level].num_pages;
0:         }
0: 
0: 
0:         // Totals:
0:         ret_string += 
0:             "Btree conglom has:\n" + 
0:             "\t" + prop.getProperty(Page.DIAG_PAGE_SIZE) + " bytes per page\n" +
0:             "\t" + total_pages               + " total pages ("                +
0:                 (Integer.parseInt(prop.getProperty(Page.DIAG_PAGE_SIZE)) * 
0:                      total_pages) + " bytes)\n"                                +
0:             "\t" + level_info.length         + " total levels\n"               +
0:             "\t" + level_info[0].num_entries + " total user records\n";
0: 
0:         // Totals by level:
0:         for (int level = 0; level < level_info.length; level++) 
0:         {
0:             LevelInfo   li = level_info[level];
0: 
0:             ret_string += "level[" + level + "] stats:\n";
0: 
0:             ret_string += 
0:                 "\t# of pages           = " + li.num_pages      + ".\n" +
0:                 "\t# of entries         = " + li.num_entries    + ".  " +
0:                 "(" + (li.num_entries / li.num_pages) + " entries/page).\n" +
0:                 "\t# of deleted entries = " + li.num_deleted    + ".  " +
0:                 "(" + (li.num_deleted / li.num_pages) + " deleted/page).\n" +
0:                 "\t# of free bytes      = " + li.num_res_bytes + ".  " +
0:                 "(" + (li.num_res_bytes / li.num_pages) + " reserved bytes/page).\n" +
0:                 "\t# of free bytes      = " + li.num_free_bytes + ".  " +
0:                 "(" + (li.num_free_bytes / li.num_pages) + " free bytes/page).\n" +
0:                 "\t# of slot table bytes= " + li.num_slottab_bytes + ".  " +
0:                 "(" + (li.num_slottab_bytes / li.num_pages) + " slot table bytes/page).\n";
0:         }
0: 
0:         return(ret_string);
0:     }
0: 
0: 	/*
0: 	** Methods of Diagnosticable
0: 	*/
0:     public void init(Object obj)
0:     {
0:         if (SanityManager.DEBUG)
0:             SanityManager.ASSERT(obj instanceof BTreeController);
0: 
0:         super.init(obj);
0:     }
0: 
0:     /**
0:      * Default implementation of diagnostic on the object.
0:      * <p>
0:      * This routine returns a string with whatever diagnostic information
0:      * you would like to provide about this object.
0:      * <p>
0:      * This routine returns a summary table of information about pages in
0:      * each level of the btree.  It tells the height of the tree, the 
0:      * average free and reserved bytes per level, and the page size.
0:      * <p>
0:      *
0: 	 * @return A string with diagnostic information about the object.
0:      *
0:      * @exception StandardException  Standard cloudscape exception policy
0:      **/
0:     public String diag()
0:         throws StandardException
0:     {
0:         OpenBTree   open_btree  = (BTreeController) this.diag_object;
0:         ControlRow  root        = null;
0:         int         tree_height;
0:         LevelInfo   level_info[] = null;
0:         String      diag_info    = new String();
0: 
0:         
0:         try
0:         {
0:             tree_height = open_btree.getHeight();
0:             root = ControlRow.Get(open_btree, BTree.ROOTPAGEID);
0: 
0:             // Allocate a LevelInfo array with one entry per level of the tree.
0:             level_info = new LevelInfo[tree_height];
0:             for (int level = 0; level < level_info.length; level++) 
0:                 level_info[level] = new LevelInfo();
0: 
0:             // ask page to provide diag info:
0:             Properties prop = new Properties();
0:             prop.put(Page.DIAG_PAGE_SIZE,        "");
0:             prop.put(Page.DIAG_BYTES_FREE,       "");
0:             prop.put(Page.DIAG_BYTES_RESERVED,   "");
0:             prop.put(Page.DIAG_RESERVED_SPACE,   "");
0:             prop.put(Page.DIAG_MINIMUM_REC_SIZE, "");
0:             prop.put(Page.DIAG_NUMOVERFLOWED,    "");
0:             prop.put(Page.DIAG_ROWSIZE,          "");
0:             prop.put(Page.DIAG_MINROWSIZE,       "");
0:             prop.put(Page.DIAG_MAXROWSIZE,       "");
0:             prop.put(Page.DIAG_PAGEOVERHEAD,     "");
0:             prop.put(Page.DIAG_SLOTTABLE_SIZE,   "");
0: 
0:             diag_level(open_btree, root, prop, level_info);
0: 
0: 
0:             diag_info = diag_tabulate(prop, level_info);
0:         }
0:         finally
0:         {
0:             if (root != null)
0:                 root.release();
0:         }
0: 
0:         return(diag_info);
0:     }
0: }
============================================================================