1:9e7156c: package org.apache.derbyTesting.functionTests.tests.store;
4:9e7156c: 
1:9e7156c: import java.sql.Connection;
1:9e7156c: import java.sql.PreparedStatement;
1:9e7156c: import java.sql.ResultSet;
1:9e7156c: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import junit.framework.Test;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:1ae02c9: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.JDBC;
1:9e7156c: 
1:9e7156c: 
1:9e7156c: /*
1:9e7156c: Class org.apache.derbyTesting.functionTests.tests.store.Derby4577Test
1:9e7156c: 
1:9e7156c: Licensed to the Apache Software Foundation (ASF) under one or more
1:9e7156c: contributor license agreements.  See the NOTICE file distributed with
1:9e7156c: this work for additional information regarding copyright ownership.
1:9e7156c: The ASF licenses this file to you under the Apache License, Version 2.0
1:9e7156c: (the "License"); you may not use this file except in compliance with
1:9e7156c: the License.  You may obtain a copy of the License at
1:9e7156c: 
1:9e7156c:    http://www.apache.org/licenses/LICENSE-2.0
1:9e7156c: 
1:9e7156c: Unless required by applicable law or agreed to in writing, software
1:9e7156c: distributed under the License is distributed on an "AS IS" BASIS,
1:9e7156c: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:9e7156c: See the License for the specific language governing permissions and
1:9e7156c: limitations under the License.
1:9e7156c: 
1:9e7156c: */
1:9e7156c: 
1:9e7156c: 
1:9e7156c: /**
1:9e7156c: 
1:9e7156c: Test to reproduce DERBY-4577, An expanding update fails with an nospc.U error.
1:9e7156c: 
1:9e7156c: **/
1:9e7156c: 
1:9e7156c: public class Derby4577Test extends StoreBaseTest
1:9e7156c: {
1:9e7156c:     /**************************************************************************
1:9e7156c:      * Fields of the class
1:9e7156c:      **************************************************************************
1:9e7156c:      */
1:9e7156c: 
1:9e7156c:     /**************************************************************************
1:9e7156c:      * Constructors for This class:
1:9e7156c:      **************************************************************************
1:9e7156c:      */
1:9e7156c: 
1:9e7156c:     /**************************************************************************
1:9e7156c:      * Private/Protected methods of This class:
1:9e7156c:      **************************************************************************
1:9e7156c:      */
1:9e7156c: 
1:9e7156c:     /**************************************************************************
1:9e7156c:      * Public Methods of This class:
1:9e7156c:      **************************************************************************
1:9e7156c:      */
1:9e7156c: 
1:9e7156c:     /**************************************************************************
1:9e7156c:      * Public Methods of XXXX class:
1:9e7156c:      **************************************************************************
1:9e7156c:      */
1:9e7156c: 
1:9e7156c:     public Derby4577Test(String name) 
1:9e7156c:     {
1:9e7156c:         super(name);
1:9e7156c:     }
1:9e7156c: 
1:9e7156c:     
1:9e7156c:     /**
1:9e7156c:      * DERBY-4577 test case
1:9e7156c:      * <p>
1:9e7156c:      * The update error occurs with the following:
1:9e7156c:      *   o update of a long row which requires an update on it's overflow page
1:9e7156c:      *   o The portion of the long row on the overflow page needs to have 
1:dbed020:      *     max(row size, reserved space) + free space on page &lt;= 12  
1:9e7156c:      *     (12 causes the error, other values might also).
1:9e7156c:      *
1:9e7156c:      * In order to get to this one needs multiple rows on the overflow page,
1:9e7156c:      * so that they can eat up the free space on the page.  This test 
1:9e7156c:      * simulates the overflow page state that I got from running the test case 
1:9e7156c:      * associated with DERBY-2286.  I could only repro on a fast dual core
1:9e7156c:      * linux machine.  I repro'd a few times and it always had 3 rows on
1:9e7156c:      * the page: one that had a long column pointer, one that had a long
1:9e7156c:      * row pointer, and one that had the blob on the page eating up most of
1:9e7156c:      * the space on the overflow page.  
1:9e7156c:      *
1:9e7156c:      * The test does the following:
1:9e7156c:      * o drop/create table
1:9e7156c:      * o insert 3 rows of interest that will all fit on 1st page, with 1 byte
1:9e7156c:      *     blob columns.
1:9e7156c:      * o insert a dummy row that will fill up the rest of the 1st page.
1:9e7156c:      * o update 1st 3 rows so that they are now all long rows that share the
1:9e7156c:      *   same overflow page.
1:9e7156c:      * o update row 1 so that it now has a long column, this actually shrinks
1:9e7156c:      *   it on this overflow page.
1:9e7156c:      * o update row 2 so that blob column is bigger, but still less than a page
1:9e7156c:      *   this results in row 2 getting another long row pointer to a page that
1:9e7156c:      *   holds the new blob value.  Again this actually shrinks the row piece
1:9e7156c:      *   on the overflow page in question.
1:9e7156c:      * o update row 3 so that it's overflow piece fills up all the remaining
1:9e7156c:      *   space on the overflow page.
1:9e7156c:      * o finally update row 1's long column, this update causes the bug.  The
1:9e7156c:      *   no space error should never be thrown to a user on an update.  The only
1:9e7156c:      *   time an error of this type is allowed is if the actual disk is full.
1:9e7156c:      *
1:9e7156c:      **/
1:9e7156c:     public void testDERBY_4577()
1:9e7156c:         throws SQLException
1:9e7156c:     {
1:9e7156c: 
1:9e7156c:         // page 0 - container info/bit map, does not affect test
1:9e7156c: 
1:9e7156c:         // page 1 - 
1:9e7156c:         // row on it that can never be deleted so this page never can be
1:9e7156c:         // made free.
1:9e7156c: 
1:9e7156c:         Statement stmt = createStatement();
1:9e7156c: 
1:9e7156c:         PreparedStatement insert_stmt = 
1:9e7156c:             prepareStatement("INSERT INTO testBadUpdate VALUES(?, ?)");
1:9e7156c: 
1:9e7156c:         PreparedStatement update_stmt = 
1:9e7156c:             prepareStatement("UPDATE testBadUpdate set value = ? where id = ?");
1:9e7156c: 
1:9e7156c:         // insert 3 rows that will fit on same main page.
1:9e7156c:         byte[] pad_blob = new byte[1];
1:9e7156c: 
1:9e7156c:         for (int i = 0; i < 3; i++)
1:9e7156c:         {
1:9e7156c:             insert_stmt.setInt(     1, i);
1:9e7156c:             insert_stmt.setBytes(   2, pad_blob);
1:9e7156c:             insert_stmt.executeUpdate();
1:9e7156c:         }
1:9e7156c: 
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         // insert a row that fills rest of main page
1:9e7156c:         pad_blob = new byte[32000];
1:9e7156c:         insert_stmt.setInt(     1, 3);
1:9e7156c:         insert_stmt.setBytes(   2, pad_blob);
1:9e7156c:         insert_stmt.executeUpdate();
1:9e7156c: 
1:9e7156c:         // now expand each of the rows so that each becomes a "long row", with
1:9e7156c:         // first column on main page with a pointer to overflow page, and each
1:9e7156c:         // 2nd column exists in full on the overflow page.  Want
1:9e7156c:         // each overflow to end up on same page.  
1:9e7156c:         pad_blob = new byte[4000];
1:9e7156c:         for (int i = 0; i < 3; i++)
1:9e7156c:         {
1:9e7156c:             update_stmt.setBytes(   1, pad_blob);
1:9e7156c:             update_stmt.setInt(     2, i);
1:9e7156c:             update_stmt.executeUpdate();
1:9e7156c:         }
1:9e7156c: 
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         // eat up the rest of space on main page, by expanding the 4th row.
1:9e7156c:         pad_blob = new byte[32566];
1:9e7156c:         update_stmt.setBytes(   1, pad_blob);
1:9e7156c:         update_stmt.setInt(     2, 3);
1:9e7156c:         update_stmt.executeUpdate();
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         // expand row 1 so that it's blob column becomes a long column
1:9e7156c:         pad_blob = new byte[60000];
1:9e7156c:         update_stmt.setBytes(   1, pad_blob);
1:9e7156c:         update_stmt.setInt(     2, 0);
1:9e7156c:         update_stmt.executeUpdate();
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         // expand row 2 so that it's blob column becomes another long row
1:9e7156c:         // pointer.
1:9e7156c:         pad_blob = new byte[32500];
1:9e7156c:         update_stmt.setBytes(   1, pad_blob);
1:9e7156c:         update_stmt.setInt(     2, 1);
1:9e7156c:         update_stmt.executeUpdate();
1:9e7156c:         commit();
1:9e7156c:         
1:9e7156c:         // expand row 3 so that it's blob column becomes 32649 long.
1:9e7156c:         //  was 32000
1:9e7156c:         pad_blob = new byte[32646];
1:9e7156c:         update_stmt.setBytes(   1, pad_blob);
1:9e7156c:         update_stmt.setInt(     2, 2);
1:9e7156c:         update_stmt.executeUpdate();
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         // see if we can update the long column of row 1
1:9e7156c:         pad_blob = new byte[120000];
1:9e7156c:         update_stmt.setBytes(   1, pad_blob);
1:9e7156c:         update_stmt.setInt(     2, 0);
1:9e7156c:         update_stmt.executeUpdate();
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         stmt.close();
1:9e7156c:         insert_stmt.close();
1:9e7156c:         update_stmt.close();
1:9e7156c:     }
1:9e7156c: 
1:9e7156c:     public void testSmallRow1()
1:9e7156c:         throws SQLException
1:9e7156c:     {
1:9e7156c:         Statement stmt = createStatement();
1:9e7156c: 
1:9e7156c:         // setup has created:
1:9e7156c:         // CREATE TABLE testSmallRow1 (id char(1))
1:9e7156c:         //     should be a 4k page size.
1:9e7156c: 
1:9e7156c:         PreparedStatement insert_stmt = 
1:9e7156c:             prepareStatement("INSERT INTO testSmallRow1 VALUES(?)");
1:9e7156c: 
1:9e7156c:         // insert more than 3 pages of rows.
1:9e7156c:         insert_stmt.setString(1, "a");
1:9e7156c: 
1:9e7156c:         for (int i = 0; i < 4000; i++)
1:9e7156c:         {
1:9e7156c:             insert_stmt.executeUpdate();
1:9e7156c:         }
1:9e7156c:         insert_stmt.close();
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         // create an index to test btree handling of short key.
1:9e7156c:         stmt.executeUpdate("CREATE INDEX idx1 on testSmallRow1(id)");
1:9e7156c: 
1:9e7156c:         // Check the consistency of the indexes
1:9e7156c:         ResultSet rs = stmt.executeQuery(
1:9e7156c:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'TESTSMALLROW1')");
1:9e7156c:         String [][] expRS = new String [][] {{"1"}};
1:9e7156c:         JDBC.assertFullResultSet(rs, expRS, true);
1:9e7156c: 
1:9e7156c:         // now test on new table with an index during the inserts.
1:9e7156c: 
1:9e7156c:         // create an index to test btree handling of short key.
1:9e7156c:         stmt.executeUpdate("CREATE INDEX idx2 on testSmallRow2(id)");
1:9e7156c: 
1:9e7156c:         insert_stmt = 
1:9e7156c:             prepareStatement("INSERT INTO testSmallRow2 VALUES(?)");
1:9e7156c: 
1:9e7156c:         // insert more than 3 pages of rows.
1:9e7156c:         insert_stmt.setString(1, "a");
1:9e7156c: 
1:9e7156c:         for (int i = 0; i < 4000; i++)
1:9e7156c:         {
1:9e7156c:             insert_stmt.executeUpdate();
1:9e7156c:         }
1:9e7156c:         insert_stmt.close();
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         // Check the consistency of the indexes
1:9e7156c:         rs = stmt.executeQuery(
1:9e7156c:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'TESTSMALLROW2')");
1:9e7156c:         expRS = new String [][] {{"1"}};
1:9e7156c:         JDBC.assertFullResultSet(rs, expRS, true);
1:9e7156c: 
1:9e7156c:         // DDL that caused a bug while trying to fix derby 4577, data is null
1:9e7156c: 
1:9e7156c:         // create an index to test btree handling of short key.
1:9e7156c:         stmt.executeUpdate("CREATE INDEX idx3 on testSmallRow3(id)");
1:9e7156c: 
1:9e7156c:         insert_stmt = 
1:9e7156c:             prepareStatement("INSERT INTO testSmallRow3 VALUES(?, ?)");
1:9e7156c: 
1:9e7156c:         // insert more than 3 pages of rows.
1:9e7156c:         insert_stmt.setString(1, null);
1:9e7156c: 
1:9e7156c:         for (int i = 0; i < 100; i++)
1:9e7156c:         {
1:9e7156c:             insert_stmt.setInt(2, i);
1:9e7156c:             insert_stmt.executeUpdate();
1:9e7156c:         }
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         stmt.executeUpdate("UPDATE testSmallRow3 set id = null where id2 > 1");
1:9e7156c: 
1:9e7156c:         // Deleting rows from root of btree which will then force purges on the
1:9e7156c:         // page before it does a split.  The purges force the raw store 
1:9e7156c:         // through reclaim space on page code path.
1:9e7156c:         stmt.executeUpdate("DELETE from testSmallRow3 where id2 = 40 or id2 = 41 or id2 = 80 or id2 = 81");
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         insert_stmt.setString(1, null);
1:9e7156c:         for (int i = 101; i < 600; i++)
1:9e7156c:         {
1:9e7156c:             insert_stmt.executeUpdate();
1:9e7156c:             insert_stmt.setInt(2, i);
1:9e7156c:         }
1:9e7156c:         
1:9e7156c:         insert_stmt.close();
1:9e7156c:         commit();
1:9e7156c: 
1:9e7156c:         // Check the consistency of the indexes
1:9e7156c:         rs = stmt.executeQuery(
1:9e7156c:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'TESTSMALLROW3')");
1:9e7156c:         expRS = new String [][] {{"1"}};
1:9e7156c:         JDBC.assertFullResultSet(rs, expRS, true);
1:9e7156c: 
1:9e7156c:         stmt.close();
1:9e7156c:     }
1:9e7156c:     
1:9e7156c:     protected static Test baseSuite(String name) 
1:9e7156c:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite(name);
1:9e7156c:         suite.addTestSuite(Derby4577Test.class);
1:9e7156c:         return new CleanDatabaseTestSetup(
1:9e7156c:                 DatabasePropertyTestSetup.setLockTimeouts(suite, 2, 4)) 
1:9e7156c:         {
1:9e7156c:             /**
1:9e7156c:              * Creates the tables used in the test cases.
1:9e7156c:              * @exception SQLException if a database error occurs
1:9e7156c:              */
1:9e7156c:             protected void decorateSQL(Statement stmt) throws SQLException
1:9e7156c:             {
1:9e7156c:                 Connection conn = stmt.getConnection();
1:9e7156c: 
1:9e7156c:                 // create a table, with blob it will be 32k page size
1:9e7156c:                 stmt.executeUpdate(
1:9e7156c:                     "CREATE TABLE testBadUpdate (id int, value blob(1M))");
1:9e7156c: 
1:9e7156c:                 stmt.executeUpdate(
1:9e7156c:                     "CREATE TABLE testSmallRow1 (id char(1))");
1:9e7156c: 
1:9e7156c:                 stmt.executeUpdate(
1:9e7156c:                     "CREATE TABLE testSmallRow2 (id char(1))");
1:9e7156c: 
1:9e7156c:                 stmt.executeUpdate(
1:9e7156c:                     "CREATE TABLE testSmallRow3 (id char(20), id2 int)");
1:9e7156c: 
1:9e7156c:                 conn.setAutoCommit(false);
1:9e7156c:             }
1:9e7156c:         };
1:9e7156c:     }
1:9e7156c: 
1:9e7156c:     public static Test suite() 
1:9e7156c:     {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("Derby4577Test");
1:9e7156c:         suite.addTest(baseSuite("Derby4577Test:embedded"));
1:9e7156c:         return suite;
1:9e7156c:     }
1:9e7156c: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1:      *     max(row size, reserved space) + free space on page &lt;= 12  
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.sql.Statement;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseTestSuite;
1: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
1: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("Derby4577Test");
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:9e7156c
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.store;
1: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
0: import org.apache.derby.shared.common.sanity.SanityManager;
1: 
0: import junit.framework.Assert;
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: 
0: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
0: import java.sql.Statement;
1: import java.sql.SQLException;
1: 
1: 
1: /*
1: Class org.apache.derbyTesting.functionTests.tests.store.Derby4577Test
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to you under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1:    http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: 
1: /**
1: 
1: Test to reproduce DERBY-4577, An expanding update fails with an nospc.U error.
1: 
1: **/
1: 
1: public class Derby4577Test extends StoreBaseTest
1: {
1:     /**************************************************************************
1:      * Fields of the class
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Constructors for This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Private/Protected methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Public Methods of This class:
1:      **************************************************************************
1:      */
1: 
1:     /**************************************************************************
1:      * Public Methods of XXXX class:
1:      **************************************************************************
1:      */
1: 
1:     public Derby4577Test(String name) 
1:     {
1:         super(name);
1:     }
1: 
1:     
1:     /**
1:      * DERBY-4577 test case
1:      * <p>
1:      * The update error occurs with the following:
1:      *   o update of a long row which requires an update on it's overflow page
1:      *   o The portion of the long row on the overflow page needs to have 
0:      *     max(row size, reserved space) + free space on page <= 12  
1:      *     (12 causes the error, other values might also).
1:      *
1:      * In order to get to this one needs multiple rows on the overflow page,
1:      * so that they can eat up the free space on the page.  This test 
1:      * simulates the overflow page state that I got from running the test case 
1:      * associated with DERBY-2286.  I could only repro on a fast dual core
1:      * linux machine.  I repro'd a few times and it always had 3 rows on
1:      * the page: one that had a long column pointer, one that had a long
1:      * row pointer, and one that had the blob on the page eating up most of
1:      * the space on the overflow page.  
1:      *
1:      * The test does the following:
1:      * o drop/create table
1:      * o insert 3 rows of interest that will all fit on 1st page, with 1 byte
1:      *     blob columns.
1:      * o insert a dummy row that will fill up the rest of the 1st page.
1:      * o update 1st 3 rows so that they are now all long rows that share the
1:      *   same overflow page.
1:      * o update row 1 so that it now has a long column, this actually shrinks
1:      *   it on this overflow page.
1:      * o update row 2 so that blob column is bigger, but still less than a page
1:      *   this results in row 2 getting another long row pointer to a page that
1:      *   holds the new blob value.  Again this actually shrinks the row piece
1:      *   on the overflow page in question.
1:      * o update row 3 so that it's overflow piece fills up all the remaining
1:      *   space on the overflow page.
1:      * o finally update row 1's long column, this update causes the bug.  The
1:      *   no space error should never be thrown to a user on an update.  The only
1:      *   time an error of this type is allowed is if the actual disk is full.
1:      *
1:      **/
1:     public void testDERBY_4577()
1:         throws SQLException
1:     {
1: 
1:         // page 0 - container info/bit map, does not affect test
1: 
1:         // page 1 - 
1:         // row on it that can never be deleted so this page never can be
1:         // made free.
1: 
1:         Statement stmt = createStatement();
1: 
1:         PreparedStatement insert_stmt = 
1:             prepareStatement("INSERT INTO testBadUpdate VALUES(?, ?)");
1: 
1:         PreparedStatement update_stmt = 
1:             prepareStatement("UPDATE testBadUpdate set value = ? where id = ?");
1: 
1:         // insert 3 rows that will fit on same main page.
1:         byte[] pad_blob = new byte[1];
1: 
1:         for (int i = 0; i < 3; i++)
1:         {
1:             insert_stmt.setInt(     1, i);
1:             insert_stmt.setBytes(   2, pad_blob);
1:             insert_stmt.executeUpdate();
1:         }
1: 
1:         commit();
1: 
1:         // insert a row that fills rest of main page
1:         pad_blob = new byte[32000];
1:         insert_stmt.setInt(     1, 3);
1:         insert_stmt.setBytes(   2, pad_blob);
1:         insert_stmt.executeUpdate();
1: 
1:         // now expand each of the rows so that each becomes a "long row", with
1:         // first column on main page with a pointer to overflow page, and each
1:         // 2nd column exists in full on the overflow page.  Want
1:         // each overflow to end up on same page.  
1:         pad_blob = new byte[4000];
1:         for (int i = 0; i < 3; i++)
1:         {
1:             update_stmt.setBytes(   1, pad_blob);
1:             update_stmt.setInt(     2, i);
1:             update_stmt.executeUpdate();
1:         }
1: 
1:         commit();
1: 
1:         // eat up the rest of space on main page, by expanding the 4th row.
1:         pad_blob = new byte[32566];
1:         update_stmt.setBytes(   1, pad_blob);
1:         update_stmt.setInt(     2, 3);
1:         update_stmt.executeUpdate();
1:         commit();
1: 
1:         // expand row 1 so that it's blob column becomes a long column
1:         pad_blob = new byte[60000];
1:         update_stmt.setBytes(   1, pad_blob);
1:         update_stmt.setInt(     2, 0);
1:         update_stmt.executeUpdate();
1:         commit();
1: 
1:         // expand row 2 so that it's blob column becomes another long row
1:         // pointer.
1:         pad_blob = new byte[32500];
1:         update_stmt.setBytes(   1, pad_blob);
1:         update_stmt.setInt(     2, 1);
1:         update_stmt.executeUpdate();
1:         commit();
1:         
1:         // expand row 3 so that it's blob column becomes 32649 long.
1:         //  was 32000
1:         pad_blob = new byte[32646];
1:         update_stmt.setBytes(   1, pad_blob);
1:         update_stmt.setInt(     2, 2);
1:         update_stmt.executeUpdate();
1:         commit();
1: 
1:         // see if we can update the long column of row 1
1:         pad_blob = new byte[120000];
1:         update_stmt.setBytes(   1, pad_blob);
1:         update_stmt.setInt(     2, 0);
1:         update_stmt.executeUpdate();
1:         commit();
1: 
1:         stmt.close();
1:         insert_stmt.close();
1:         update_stmt.close();
1:     }
1: 
1:     public void testSmallRow1()
1:         throws SQLException
1:     {
1:         Statement stmt = createStatement();
1: 
1:         // setup has created:
1:         // CREATE TABLE testSmallRow1 (id char(1))
1:         //     should be a 4k page size.
1: 
1:         PreparedStatement insert_stmt = 
1:             prepareStatement("INSERT INTO testSmallRow1 VALUES(?)");
1: 
1:         // insert more than 3 pages of rows.
1:         insert_stmt.setString(1, "a");
1: 
1:         for (int i = 0; i < 4000; i++)
1:         {
1:             insert_stmt.executeUpdate();
1:         }
1:         insert_stmt.close();
1:         commit();
1: 
1:         // create an index to test btree handling of short key.
1:         stmt.executeUpdate("CREATE INDEX idx1 on testSmallRow1(id)");
1: 
1:         // Check the consistency of the indexes
1:         ResultSet rs = stmt.executeQuery(
1:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'TESTSMALLROW1')");
1:         String [][] expRS = new String [][] {{"1"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // now test on new table with an index during the inserts.
1: 
1:         // create an index to test btree handling of short key.
1:         stmt.executeUpdate("CREATE INDEX idx2 on testSmallRow2(id)");
1: 
1:         insert_stmt = 
1:             prepareStatement("INSERT INTO testSmallRow2 VALUES(?)");
1: 
1:         // insert more than 3 pages of rows.
1:         insert_stmt.setString(1, "a");
1: 
1:         for (int i = 0; i < 4000; i++)
1:         {
1:             insert_stmt.executeUpdate();
1:         }
1:         insert_stmt.close();
1:         commit();
1: 
1:         // Check the consistency of the indexes
1:         rs = stmt.executeQuery(
1:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'TESTSMALLROW2')");
1:         expRS = new String [][] {{"1"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         // DDL that caused a bug while trying to fix derby 4577, data is null
1: 
1:         // create an index to test btree handling of short key.
1:         stmt.executeUpdate("CREATE INDEX idx3 on testSmallRow3(id)");
1: 
1:         insert_stmt = 
1:             prepareStatement("INSERT INTO testSmallRow3 VALUES(?, ?)");
1: 
1:         // insert more than 3 pages of rows.
1:         insert_stmt.setString(1, null);
1: 
1:         for (int i = 0; i < 100; i++)
1:         {
1:             insert_stmt.setInt(2, i);
1:             insert_stmt.executeUpdate();
1:         }
1:         commit();
1: 
1:         stmt.executeUpdate("UPDATE testSmallRow3 set id = null where id2 > 1");
1: 
1:         // Deleting rows from root of btree which will then force purges on the
1:         // page before it does a split.  The purges force the raw store 
1:         // through reclaim space on page code path.
1:         stmt.executeUpdate("DELETE from testSmallRow3 where id2 = 40 or id2 = 41 or id2 = 80 or id2 = 81");
1:         commit();
1: 
1:         insert_stmt.setString(1, null);
1:         for (int i = 101; i < 600; i++)
1:         {
1:             insert_stmt.executeUpdate();
1:             insert_stmt.setInt(2, i);
1:         }
1:         
1:         insert_stmt.close();
1:         commit();
1: 
1:         // Check the consistency of the indexes
1:         rs = stmt.executeQuery(
1:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'TESTSMALLROW3')");
1:         expRS = new String [][] {{"1"}};
1:         JDBC.assertFullResultSet(rs, expRS, true);
1: 
1:         stmt.close();
1:     }
1:     
1:     protected static Test baseSuite(String name) 
1:     {
0:         TestSuite suite = new TestSuite(name);
1:         suite.addTestSuite(Derby4577Test.class);
1:         return new CleanDatabaseTestSetup(
1:                 DatabasePropertyTestSetup.setLockTimeouts(suite, 2, 4)) 
1:         {
1:             /**
1:              * Creates the tables used in the test cases.
1:              * @exception SQLException if a database error occurs
1:              */
1:             protected void decorateSQL(Statement stmt) throws SQLException
1:             {
1:                 Connection conn = stmt.getConnection();
1: 
1:                 // create a table, with blob it will be 32k page size
1:                 stmt.executeUpdate(
1:                     "CREATE TABLE testBadUpdate (id int, value blob(1M))");
1: 
1:                 stmt.executeUpdate(
1:                     "CREATE TABLE testSmallRow1 (id char(1))");
1: 
1:                 stmt.executeUpdate(
1:                     "CREATE TABLE testSmallRow2 (id char(1))");
1: 
1:                 stmt.executeUpdate(
1:                     "CREATE TABLE testSmallRow3 (id char(20), id2 int)");
1: 
1:                 conn.setAutoCommit(false);
1:             }
1:         };
1:     }
1: 
1:     public static Test suite() 
1:     {
0:         TestSuite suite = new TestSuite("Derby4577Test");
1:         suite.addTest(baseSuite("Derby4577Test:embedded"));
1:         return suite;
1:     }
1: }
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:2f41733
/////////////////////////////////////////////////////////////////////////
0: package org.apache.derbyTesting.functionTests.tests.store;
0: 
0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
0: import org.apache.derbyTesting.junit.DatabasePropertyTestSetup;
0: import org.apache.derbyTesting.junit.JDBC;
0: import org.apache.derbyTesting.junit.TestConfiguration;
0: 
0: import org.apache.derby.shared.common.sanity.SanityManager;
0: 
0: import junit.framework.Assert;
0: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: 
0: import java.sql.CallableStatement;
0: import java.sql.Connection;
0: import java.sql.PreparedStatement;
0: import java.sql.ResultSet;
0: import java.sql.Statement;
0: import java.sql.SQLException;
0: 
0: 
0: /*
0: Class org.apache.derbyTesting.functionTests.tests.store.Derby4577Test
0: 
0: Licensed to the Apache Software Foundation (ASF) under one or more
0: contributor license agreements.  See the NOTICE file distributed with
0: this work for additional information regarding copyright ownership.
0: The ASF licenses this file to you under the Apache License, Version 2.0
0: (the "License"); you may not use this file except in compliance with
0: the License.  You may obtain a copy of the License at
0: 
0:    http://www.apache.org/licenses/LICENSE-2.0
0: 
0: Unless required by applicable law or agreed to in writing, software
0: distributed under the License is distributed on an "AS IS" BASIS,
0: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0: See the License for the specific language governing permissions and
0: limitations under the License.
0: 
0: */
0: 
0: 
0: /**
0: 
0: Test to reproduce DERBY-4577, An expanding update fails with an nospc.U error.
0: 
0: **/
0: 
0: public class Derby4577Test extends StoreBaseTest
0: {
0:     /**************************************************************************
0:      * Fields of the class
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Constructors for This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Private/Protected methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Public Methods of This class:
0:      **************************************************************************
0:      */
0: 
0:     /**************************************************************************
0:      * Public Methods of XXXX class:
0:      **************************************************************************
0:      */
0: 
0:     public Derby4577Test(String name) 
0:     {
0:         super(name);
0:     }
0: 
0:     
0:     /**
0:      * DERBY-4577 test case
0:      * <p>
0:      * The update error occurs with the following:
0:      *   o update of a long row which requires an update on it's overflow page
0:      *   o The portion of the long row on the overflow page needs to have 
0:      *     max(row size, reserved space) + free space on page <= 12  
0:      *     (12 causes the error, other values might also).
0:      *
0:      * In order to get to this one needs multiple rows on the overflow page,
0:      * so that they can eat up the free space on the page.  This test 
0:      * simulates the overflow page state that I got from running the test case 
0:      * associated with DERBY-2286.  I could only repro on a fast dual core
0:      * linux machine.  I repro'd a few times and it always had 3 rows on
0:      * the page: one that had a long column pointer, one that had a long
0:      * row pointer, and one that had the blob on the page eating up most of
0:      * the space on the overflow page.  
0:      *
0:      * The test does the following:
0:      * o drop/create table
0:      * o insert 3 rows of interest that will all fit on 1st page, with 1 byte
0:      *     blob columns.
0:      * o insert a dummy row that will fill up the rest of the 1st page.
0:      * o update 1st 3 rows so that they are now all long rows that share the
0:      *   same overflow page.
0:      * o update row 1 so that it now has a long column, this actually shrinks
0:      *   it on this overflow page.
0:      * o update row 2 so that blob column is bigger, but still less than a page
0:      *   this results in row 2 getting another long row pointer to a page that
0:      *   holds the new blob value.  Again this actually shrinks the row piece
0:      *   on the overflow page in question.
0:      * o update row 3 so that it's overflow piece fills up all the remaining
0:      *   space on the overflow page.
0:      * o finally update row 1's long column, this update causes the bug.  The
0:      *   no space error should never be thrown to a user on an update.  The only
0:      *   time an error of this type is allowed is if the actual disk is full.
0:      *
0:      **/
0:     public void testDERBY_4577()
0:         throws SQLException
0:     {
0: 
0:         // page 0 - container info/bit map, does not affect test
0: 
0:         // page 1 - 
0:         // row on it that can never be deleted so this page never can be
0:         // made free.
0: 
0:         Statement stmt = createStatement();
0: 
0:         PreparedStatement insert_stmt = 
0:             prepareStatement("INSERT INTO testBadUpdate VALUES(?, ?)");
0: 
0:         PreparedStatement update_stmt = 
0:             prepareStatement("UPDATE testBadUpdate set value = ? where id = ?");
0: 
0:         // insert 3 rows that will fit on same main page.
0:         byte[] pad_blob = new byte[1];
0: 
0:         for (int i = 0; i < 3; i++)
0:         {
0:             insert_stmt.setInt(     1, i);
0:             insert_stmt.setBytes(   2, pad_blob);
0:             insert_stmt.executeUpdate();
0:         }
0: 
0:         commit();
0: 
0:         // insert a row that fills rest of main page
0:         pad_blob = new byte[32000];
0:         insert_stmt.setInt(     1, 3);
0:         insert_stmt.setBytes(   2, pad_blob);
0:         insert_stmt.executeUpdate();
0: 
0:         // now expand each of the rows so that each becomes a "long row", with
0:         // first column on main page with a pointer to overflow page, and each
0:         // 2nd column exists in full on the overflow page.  Want
0:         // each overflow to end up on same page.  
0:         pad_blob = new byte[4000];
0:         for (int i = 0; i < 3; i++)
0:         {
0:             update_stmt.setBytes(   1, pad_blob);
0:             update_stmt.setInt(     2, i);
0:             update_stmt.executeUpdate();
0:         }
0: 
0:         commit();
0: 
0:         // eat up the rest of space on main page, by expanding the 4th row.
0:         pad_blob = new byte[32566];
0:         update_stmt.setBytes(   1, pad_blob);
0:         update_stmt.setInt(     2, 3);
0:         update_stmt.executeUpdate();
0:         commit();
0: 
0:         // expand row 1 so that it's blob column becomes a long column
0:         pad_blob = new byte[60000];
0:         update_stmt.setBytes(   1, pad_blob);
0:         update_stmt.setInt(     2, 0);
0:         update_stmt.executeUpdate();
0:         commit();
0: 
0:         // expand row 2 so that it's blob column becomes another long row
0:         // pointer.
0:         pad_blob = new byte[32500];
0:         update_stmt.setBytes(   1, pad_blob);
0:         update_stmt.setInt(     2, 1);
0:         update_stmt.executeUpdate();
0:         commit();
0:         
0:         // expand row 3 so that it's blob column becomes 32649 long.
0:         //  was 32000
0:         pad_blob = new byte[32646];
0:         update_stmt.setBytes(   1, pad_blob);
0:         update_stmt.setInt(     2, 2);
0:         update_stmt.executeUpdate();
0:         commit();
0: 
0:         // see if we can update the long column of row 1
0:         pad_blob = new byte[120000];
0:         update_stmt.setBytes(   1, pad_blob);
0:         update_stmt.setInt(     2, 0);
0:         update_stmt.executeUpdate();
0:         commit();
0: 
0:         stmt.close();
0:         insert_stmt.close();
0:         update_stmt.close();
0:     }
0: 
0:     public void testSmallRow1()
0:         throws SQLException
0:     {
0:         Statement stmt = createStatement();
0: 
0:         // setup has created:
0:         // CREATE TABLE testSmallRow1 (id char(1))
0:         //     should be a 4k page size.
0: 
0:         PreparedStatement insert_stmt = 
0:             prepareStatement("INSERT INTO testSmallRow1 VALUES(?)");
0: 
0:         // insert more than 3 pages of rows.
0:         insert_stmt.setString(1, "a");
0: 
0:         for (int i = 0; i < 4000; i++)
0:         {
0:             insert_stmt.executeUpdate();
0:         }
0:         insert_stmt.close();
0:         commit();
0: 
0:         // create an index to test btree handling of short key.
0:         stmt.executeUpdate("CREATE INDEX idx1 on testSmallRow1(id)");
0: 
0:         // Check the consistency of the indexes
0:         ResultSet rs = stmt.executeQuery(
0:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'TESTSMALLROW1')");
0:         String [][] expRS = new String [][] {{"1"}};
0:         JDBC.assertFullResultSet(rs, expRS, true);
0: 
0:         // now test on new table with an index during the inserts.
0: 
0:         // create an index to test btree handling of short key.
0:         stmt.executeUpdate("CREATE INDEX idx2 on testSmallRow2(id)");
0: 
0:         insert_stmt = 
0:             prepareStatement("INSERT INTO testSmallRow2 VALUES(?)");
0: 
0:         // insert more than 3 pages of rows.
0:         insert_stmt.setString(1, "a");
0: 
0:         for (int i = 0; i < 4000; i++)
0:         {
0:             insert_stmt.executeUpdate();
0:         }
0:         insert_stmt.close();
0:         commit();
0: 
0:         // Check the consistency of the indexes
0:         rs = stmt.executeQuery(
0:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'TESTSMALLROW2')");
0:         expRS = new String [][] {{"1"}};
0:         JDBC.assertFullResultSet(rs, expRS, true);
0: 
0:         // DDL that caused a bug while trying to fix derby 4577, data is null
0: 
0:         // create an index to test btree handling of short key.
0:         stmt.executeUpdate("CREATE INDEX idx3 on testSmallRow3(id)");
0: 
0:         insert_stmt = 
0:             prepareStatement("INSERT INTO testSmallRow3 VALUES(?, ?)");
0: 
0:         // insert more than 3 pages of rows.
0:         insert_stmt.setString(1, null);
0: 
0:         for (int i = 0; i < 100; i++)
0:         {
0:             insert_stmt.setInt(2, i);
0:             insert_stmt.executeUpdate();
0:         }
0:         commit();
0: 
0:         stmt.executeUpdate("UPDATE testSmallRow3 set id = null where id2 > 1");
0: 
0:         // Deleting rows from root of btree which will then force purges on the
0:         // page before it does a split.  The purges force the raw store 
0:         // through reclaim space on page code path.
0:         stmt.executeUpdate("DELETE from testSmallRow3 where id2 = 40 or id2 = 41 or id2 = 80 or id2 = 81");
0:         commit();
0: 
0:         insert_stmt.setString(1, null);
0:         for (int i = 101; i < 600; i++)
0:         {
0:             insert_stmt.executeUpdate();
0:             insert_stmt.setInt(2, i);
0:         }
0:         
0:         insert_stmt.close();
0:         commit();
0: 
0:         // Check the consistency of the indexes
0:         rs = stmt.executeQuery(
0:             "VALUES SYSCS_UTIL.SYSCS_CHECK_TABLE('APP', 'TESTSMALLROW3')");
0:         expRS = new String [][] {{"1"}};
0:         JDBC.assertFullResultSet(rs, expRS, true);
0: 
0:         stmt.close();
0:     }
0:     
0:     protected static Test baseSuite(String name) 
0:     {
0:         TestSuite suite = new TestSuite(name);
0:         suite.addTestSuite(Derby4577Test.class);
0:         return new CleanDatabaseTestSetup(
0:                 DatabasePropertyTestSetup.setLockTimeouts(suite, 2, 4)) 
0:         {
0:             /**
0:              * Creates the tables used in the test cases.
0:              * @exception SQLException if a database error occurs
0:              */
0:             protected void decorateSQL(Statement stmt) throws SQLException
0:             {
0:                 Connection conn = stmt.getConnection();
0: 
0:                 // create a table, with blob it will be 32k page size
0:                 stmt.executeUpdate(
0:                     "CREATE TABLE testBadUpdate (id int, value blob(1M))");
0: 
0:                 stmt.executeUpdate(
0:                     "CREATE TABLE testSmallRow1 (id char(1))");
0: 
0:                 stmt.executeUpdate(
0:                     "CREATE TABLE testSmallRow2 (id char(1))");
0: 
0:                 stmt.executeUpdate(
0:                     "CREATE TABLE testSmallRow3 (id char(20), id2 int)");
0: 
0:                 conn.setAutoCommit(false);
0:             }
0:         };
0:     }
0: 
0:     public static Test suite() 
0:     {
0:         TestSuite suite = new TestSuite("Derby4577Test");
0:         suite.addTest(baseSuite("Derby4577Test:embedded"));
0:         return suite;
0:     }
0: }
============================================================================