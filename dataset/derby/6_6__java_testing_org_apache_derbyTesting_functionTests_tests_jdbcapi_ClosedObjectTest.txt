1:ed41c31: /*
1:6afb55c:  * Derby - org.apache.derbyTesting.functionTests.tests.jdbcapi.ClosedObjectTest
4:ed41c31:  *
1:6e3dbab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:6e3dbab:    contributor license agreements.  See the NOTICE file distributed with
1:6e3dbab:    this work for additional information regarding copyright ownership.
1:6e3dbab:    The ASF licenses this file to You under the Apache License, Version 2.0
1:6e3dbab:    (the "License"); you may not use this file except in compliance with
1:6e3dbab:    the License.  You may obtain a copy of the License at
1:6e3dbab: 
1:6e3dbab:       http://www.apache.org/licenses/LICENSE-2.0
1:9c8b717: 
1:6e3dbab:    Unless required by applicable law or agreed to in writing, software
1:6e3dbab:    distributed under the License is distributed on an "AS IS" BASIS,
1:6e3dbab:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:6e3dbab:    See the License for the specific language governing permissions and
1:6e3dbab:    limitations under the License.
1:ed41c31:  *
1:ed41c31:  */
1:6e3dbab: 
1:6afb55c: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
4:ed41c31: 
1:ed41c31: import java.lang.reflect.InvocationTargetException;
1:ed41c31: import java.lang.reflect.Method;
1:ed41c31: import java.sql.CallableStatement;
1:ed41c31: import java.sql.Connection;
1:ed41c31: import java.sql.PreparedStatement;
1:ed41c31: import java.sql.ResultSet;
1:ed41c31: import java.sql.SQLException;
1:ed41c31: import java.sql.Statement;
1:2ff02ef: import java.util.Collections;
1:2ff02ef: import java.util.Iterator;
1:2ff02ef: import java.util.Map;
1:ed41c31: import java.util.Properties;
1:ed41c31: import javax.sql.ConnectionPoolDataSource;
1:ed41c31: import javax.sql.DataSource;
1:ed41c31: import javax.sql.PooledConnection;
1:ed41c31: import javax.sql.XAConnection;
1:ed41c31: import javax.sql.XADataSource;
1:ed41c31: import junit.extensions.TestSetup;
1:ed41c31: import junit.framework.Test;
1:3bd1dd8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:8ed08b2: import org.apache.derbyTesting.junit.J2EEDataSource;
1:6afb55c: import org.apache.derbyTesting.junit.JDBC;
1:8ed08b2: import org.apache.derbyTesting.junit.JDBCDataSource;
1:e0104e8: import org.apache.derbyTesting.junit.TestConfiguration;
1:ed41c31: 
1:ed41c31: /**
1:ed41c31:  * Test that all methods on <code>ResultSet</code>,
1:ed41c31:  * <code>Statement</code>, <code>PreparedStatement</code>,
1:ed41c31:  * <code>CallableStatement</code> and <code>Connection</code> objects
1:ed41c31:  * throw the appropriate exceptions when the objects are closed.
1:ed41c31:  */
1:ed41c31: public class ClosedObjectTest extends BaseJDBCTestCase {
1:ed41c31:     /** The method to test. */
1:ed41c31:     private final Method method_;
1:ed41c31:     /** Test decorator which provides a closed object to invoke a
1:ed41c31:      * method on. */
1:ed41c31:     private final ObjectDecorator decorator_;
1:ed41c31:     /** Name of the test. */
1:ed41c31:     private String name_;
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Creates a new <code>ClosedObjectTest</code> instance.
1:ed41c31:      *
1:ed41c31:      * @param method the method to test
1:ed41c31:      * @param decorator a decorator which provides a closed object
1:ed41c31:      */
1:ed41c31:     public ClosedObjectTest(Method method, ObjectDecorator decorator) {
1:ed41c31:         super("testClosedObjects");
1:ed41c31:         method_ = method;
1:ed41c31:         decorator_ = decorator;
1:ed41c31:         // setting name temporarily, we don't know the real class name yet
1:ed41c31:         name_ = method.getDeclaringClass().getName() + "." + method.getName();
4:ed41c31:     }
1:ed41c31: 
1:7fc16c3:     /**
1:ed41c31:      * Gets the name of the test.
1:ed41c31:      *
1:ed41c31:      * @return name of the test
1:ed41c31:      */
1:ed41c31:     public String getName() {
1:ed41c31:         return name_;
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Runs a test case. A method is called on a closed object, and it
1:ed41c31:      * is checked that the appropriate exception is thrown.
1:ed41c31:      *
1:ed41c31:      * @exception Throwable if an error occurs
1:ed41c31:      */
1:ed41c31:     public void testClosedObjects() throws Throwable {
1:ed41c31:         try {
1:ed41c31:             Object object = decorator_.getClosedObject();
1:ed41c31: 
1:7fc16c3:             String implClassName = object.getClass().getName();
1:7fc16c3: 
1:ed41c31:             // update name of test with real class name
1:7fc16c3:             name_ = implClassName + "." + method_.getName();
1:7fc16c3: 
1:7fc16c3:             // DERBY-6147: If the test runs on a newer version of the JVM
1:7fc16c3:             // than the JDBC driver supports, we should skip those methods
1:7fc16c3:             // that are not implemented.
1:7fc16c3:             //
1:7fc16c3:             // Limit the check to platforms that support JDBC 4 or higher
1:7fc16c3:             // since the isImplemented() method uses a method only available
1:7fc16c3:             // in Java 5 and higher. We know that all JDBC 3 and JSR-169
1:7fc16c3:             // methods are implemented, so no tests need to be skipped on
1:7fc16c3:             // those older platforms anyway.
1:7fc16c3:             if (JDBC.vmSupportsJDBC4() && !isImplemented()) {
1:7fc16c3:                 println("Skipping testing of " + method_ + " on " +
1:7fc16c3:                         implClassName + " because it is not implemented");
1:7fc16c3:                 name_ += "_SKIPPED";
1:7fc16c3:                 return;
1:7fc16c3:             }
1:ed41c31: 
1:ed41c31:             method_.invoke(object,
1:ed41c31:                            getNullArguments(method_.getParameterTypes()));
1:9c8b717: 
1:5a557ed:             // If we get here, and we expected an exception to be thrown,
1:5a557ed:             // report that as a failure.
1:9c8b717:             assertFalse("No exception was thrown for method " + method_,
1:9c8b717:                             decorator_.expectsException(method_));
1:ed41c31:         } catch (InvocationTargetException ite) {
1:5a557ed:             // An exception was thrown. Check if we expected that an exception
1:5a557ed:             // was thrown, and if it was the exception we expected.
1:ed41c31:             try {
1:ed41c31:                 throw ite.getCause();
1:ed41c31:             } catch (SQLException sqle) {
1:ed41c31:                 decorator_.checkException(method_, sqle);
1:9c8b717:             }
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:7fc16c3:      * Check if the JDBC interface method tested by this test case is
1:7fc16c3:      * actually implemented by the Derby object being tested.
1:7fc16c3:      */
1:7fc16c3:     private boolean isImplemented() throws NoSuchMethodException {
1:7fc16c3:         // Check if the method is implemented in one of the Derby classes
1:7fc16c3:         // that the JDBC object belongs to.
1:e18f54b:         for (Class<?> c = decorator_.getClosedObject().getClass();
1:7fc16c3:                 c != null; c = c.getSuperclass()) {
1:7fc16c3:             if (c.getName().startsWith("org.apache.derby.")) {
1:7fc16c3:                 try {
1:7fc16c3:                     Method m = c.getDeclaredMethod(
1:7fc16c3:                         method_.getName(), method_.getParameterTypes());
1:7fc16c3:                     if (!m.isSynthetic()) {
1:7fc16c3:                         // Found a real implementation of the method.
1:7fc16c3:                         return true;
1:7fc16c3:                     }
1:7fc16c3:                 } catch (NoSuchMethodException e) {
1:7fc16c3:                     // Method was not declared in this class. Try again in
1:7fc16c3:                     // the superclass.
1:7fc16c3:                 }
1:7fc16c3:             }
1:7fc16c3:         }
1:7fc16c3: 
1:7fc16c3:         // No implementation was found.
1:7fc16c3:         return false;
1:7fc16c3:     }
1:7fc16c3: 
1:ec5ae26:     /** Creates a suite with all tests in the class. */
1:ec5ae26:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("ClosedObjectTest suite");
1:2ff02ef:         suite.addTest(baseSuite(false));
1:2ff02ef:         suite.addTest(baseSuite(true));
1:ec5ae26:         return suite;
1:dd7903b:     }
1:ec5ae26: 
1:ed41c31:     /**
1:ed41c31:      * Creates the test suite and fills it with tests using
1:ed41c31:      * <code>DataSource</code>, <code>ConnectionPoolDataSource</code>
1:ed41c31:      * and <code>XADataSource</code> to obtain objects.
1:ed41c31:      *
1:2ff02ef:      * @param network whether or not to run tests with the network client
1:ed41c31:      * @return a <code>Test</code> value
1:ed41c31:      * @exception Exception if an error occurs while building the test suite
1:ed41c31:      */
1:2ff02ef:     private static Test baseSuite(boolean network) {
1:1ae02c9:         BaseTestSuite topSuite = new BaseTestSuite(
1:2ff02ef:             "ClosedObjectTest:" + (network ? "client" : "embedded"));
1:ed41c31: 
1:1ae02c9:         BaseTestSuite dsSuite = new BaseTestSuite(
1:1ae02c9:             "ClosedObjectTest DataSource");
1:1ae02c9: 
1:ed41c31:         DataSourceDecorator dsDecorator = new DataSourceDecorator(dsSuite);
1:ed41c31:         topSuite.addTest(dsDecorator);
1:ed41c31:         fillDataSourceSuite(dsSuite, dsDecorator);
1:6afb55c: 
1:5c57294:         // JDBC 3 required for ConnectionPoolDataSource and XADataSource
1:5c57294:         if (JDBC.vmSupportsJDBC3()) {
1:2ff02ef: 
1:2ff02ef:             // Plain connection pool test.
1:2ff02ef:             topSuite.addTest(poolSuite(Collections.emptyMap()));
1:2ff02ef: 
1:2ff02ef:             // The client driver has a variant of connection pool that caches
1:2ff02ef:             // and reuses JDBC statements. Test it here by setting the
1:2ff02ef:             // maxStatements property.
1:2ff02ef:             if (network) {
1:2ff02ef:                 topSuite.addTest(poolSuite(Collections.singletonMap(
1:2ff02ef:                         "maxStatements", Integer.valueOf(5))));
1:2ff02ef:             }
1:2ff02ef: 
1:1ae02c9:             BaseTestSuite xaSuite = new BaseTestSuite("ClosedObjectTest XA");
1:ed41c31:             XADataSourceDecorator xaDecorator = new XADataSourceDecorator(xaSuite);
1:ed41c31:             topSuite.addTest(xaDecorator);
1:ed41c31:             fillDataSourceSuite(xaSuite, xaDecorator);
1:6afb55c:         }
1:ed41c31: 
1:2ff02ef:         return network ?
1:2ff02ef:                 TestConfiguration.clientServerDecorator(topSuite) :
1:2ff02ef:                 topSuite;
1:2ff02ef:     }
1:2ff02ef: 
1:2ff02ef:     /**
1:2ff02ef:      * Creates a suite that tests objects produced by a
1:2ff02ef:      * ConnectionPoolDataSource.
1:2ff02ef:      *
1:2ff02ef:      * @param dsProps properties to set on the data source
1:2ff02ef:      * @return a suite
1:2ff02ef:      */
1:2ff02ef:     private static Test poolSuite(Map dsProps) {
1:1ae02c9:         BaseTestSuite poolSuite = new BaseTestSuite(
1:2ff02ef:                 "ClosedObjectTest ConnectionPoolDataSource");
1:2ff02ef:         PoolDataSourceDecorator poolDecorator =
1:2ff02ef:                 new PoolDataSourceDecorator(poolSuite, dsProps);
1:2ff02ef:         fillDataSourceSuite(poolSuite, poolDecorator);
1:2ff02ef:         return poolDecorator;
1:ec5ae26:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Fills a test suite which is contained in a
1:ed41c31:      * <code>DataSourceDecorator</code> with tests for
1:ed41c31:      * <code>ResultSet</code>, <code>Statement</code>,
1:ed41c31:      * <code>PreparedStatement</code>, <code>CallableStatement</code>
1:ed41c31:      * and <code>Connection</code>.
1:ed41c31:      *
1:ed41c31:      * @param suite the test suite to fill
1:ed41c31:      * @param dsDecorator the decorator for the test suite
1:ed41c31:      */
1:1ae02c9:     private static void fillDataSourceSuite(BaseTestSuite suite,
1:ed41c31:                                             DataSourceDecorator dsDecorator)
1:9c8b717:     {
1:1ae02c9:         BaseTestSuite rsSuite = new BaseTestSuite("Closed ResultSet");
1:ed41c31:         ResultSetObjectDecorator rsDecorator =
1:ed41c31:             new ResultSetObjectDecorator(rsSuite, dsDecorator);
1:ed41c31:         suite.addTest(rsDecorator);
1:ed41c31:         fillObjectSuite(rsSuite, rsDecorator, ResultSet.class);
1:ed41c31: 
1:1ae02c9:         BaseTestSuite stmtSuite = new BaseTestSuite("Closed Statement");
1:ed41c31:         StatementObjectDecorator stmtDecorator =
1:ed41c31:             new StatementObjectDecorator(stmtSuite, dsDecorator);
1:ed41c31:         suite.addTest(stmtDecorator);
1:ed41c31:         fillObjectSuite(stmtSuite, stmtDecorator, Statement.class);
1:ed41c31: 
1:1ae02c9:         BaseTestSuite psSuite = new BaseTestSuite("Closed PreparedStatement");
1:ed41c31:         PreparedStatementObjectDecorator psDecorator =
1:ed41c31:             new PreparedStatementObjectDecorator(psSuite, dsDecorator);
1:ed41c31:         suite.addTest(psDecorator);
1:ed41c31:         fillObjectSuite(psSuite, psDecorator, PreparedStatement.class);
1:ed41c31: 
1:1ae02c9:         BaseTestSuite csSuite = new BaseTestSuite("Closed CallableStatement");
1:ed41c31:         CallableStatementObjectDecorator csDecorator =
1:ed41c31:             new CallableStatementObjectDecorator(csSuite, dsDecorator);
1:ed41c31:         suite.addTest(csDecorator);
1:ed41c31:         fillObjectSuite(csSuite, csDecorator, CallableStatement.class);
1:ed41c31: 
1:1ae02c9:         BaseTestSuite connSuite = new BaseTestSuite("Closed Connection");
1:ed41c31:         ConnectionObjectDecorator connDecorator =
1:ed41c31:             new ConnectionObjectDecorator(connSuite, dsDecorator);
1:ed41c31:         suite.addTest(connDecorator);
1:ed41c31:         fillObjectSuite(connSuite, connDecorator, Connection.class);
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Fills a suite with tests for all the methods of an interface.
1:ed41c31:      *
1:ed41c31:      * @param suite the suite to fill
1:ed41c31:      * @param decorator a decorator for the test (used for obtaining a
1:ed41c31:      * closed object to test the method on)
1:ed41c31:      * @param iface the interface which contains the methods to test
1:ed41c31:      */
1:1ae02c9:     private static void fillObjectSuite(BaseTestSuite suite,
1:ed41c31:                                         ObjectDecorator decorator,
1:ed41c31:                                         Class iface)
2:ed41c31:     {
1:6afb55c:         Method[] methods = iface.getMethods();
1:6afb55c:         for (int i = 0; i < methods.length; i++) {
1:6afb55c:             ClosedObjectTest cot = new ClosedObjectTest(methods[i], decorator);
1:ed41c31:             suite.addTest(cot);
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Takes an array of classes and returns an array of objects with
1:ed41c31:      * null values compatible with the classes. Helper method for
1:ed41c31:      * converting a parameter list to an argument list.
1:ed41c31:      *
1:ed41c31:      * @param params a <code>Class[]</code> value
1:ed41c31:      * @return an <code>Object[]</code> value
1:ed41c31:      */
1:ed41c31:     private static Object[] getNullArguments(Class[] params) {
1:ed41c31:         Object[] args = new Object[params.length];
1:ed41c31:         for (int i = 0; i < params.length; i++) {
1:ed41c31:             args[i] = getNullValueForType(params[i]);
1:ed41c31:         }
1:ed41c31:         return args;
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Returns a null value compatible with the class. For instance,
1:ed41c31:      * return <code>Boolean.FALSE</code> for primitive booleans, 0 for
1:ed41c31:      * primitive integers and <code>null</code> for non-primitive
1:ed41c31:      * types.
1:ed41c31:      *
1:ed41c31:      * @param type a <code>Class</code> value
1:ed41c31:      * @return a null value
1:ed41c31:      */
1:ed41c31:     private static Object getNullValueForType(Class type) {
1:ed41c31:         if (!type.isPrimitive()) {
1:ed41c31:             return null;
1:ed41c31:         }
1:ed41c31:         if (type == Boolean.TYPE) {
1:ed41c31:             return Boolean.FALSE;
1:ed41c31:         }
1:ed41c31:         if (type == Character.TYPE) {
1:39b3237:             return (char) 0;
1:ed41c31:         }
1:ed41c31:         if (type == Byte.TYPE) {
1:39b3237:             return (byte) 0;
1:ed41c31:         }
1:ed41c31:         if (type == Short.TYPE) {
1:39b3237:             return (short) 0;
1:ed41c31:         }
1:ed41c31:         if (type == Integer.TYPE) {
1:39b3237:             return 0;
1:ed41c31:         }
1:ed41c31:         if (type == Long.TYPE) {
1:39b3237:             return 0L;
1:ed41c31:         }
1:ed41c31:         if (type == Float.TYPE) {
1:39b3237:             return 0f;
1:ed41c31:         }
1:ed41c31:         if (type == Double.TYPE) {
1:39b3237:             return 0d;
1:ed41c31:         }
1:ed41c31:         fail("Don't know how to handle type " + type);
1:ed41c31:         return null;            // unreachable statement
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Abstract decorator class with functionality for obtaining a
1:ed41c31:      * closed object.
1:ed41c31:      */
1:ed41c31:     private static abstract class ObjectDecorator extends TestSetup {
1:ed41c31:         /** Decorator which provides a connection. */
1:ed41c31:         private final DataSourceDecorator decorator_;
1:ed41c31:         /** The closed object. Must be set by a sub-class. */
1:ed41c31:         protected Object object_;
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Creates a new <code>ObjectDecorator</code> instance.
1:ed41c31:          *
1:ed41c31:          * @param test a test or suite to decorate
1:ed41c31:          * @param decorator a decorator which provides a connection
1:ed41c31:          */
1:ed41c31:         public ObjectDecorator(Test test, DataSourceDecorator decorator) {
1:ed41c31:             super(test);
1:ed41c31:             decorator_ = decorator;
1:ed41c31:         }
1:ed41c31: 
1:ec5ae26:         /** Tears down the test environment. */
1:ec5ae26:         protected void tearDown() throws Exception {
1:ec5ae26:             object_ = null;
1:ec5ae26:         }
1:ec5ae26: 
1:ed41c31:         /**
1:ed41c31:          * Returns the closed object.
1:ed41c31:          *
1:ed41c31:          * @return a closed object
1:ed41c31:          */
1:ed41c31:         public Object getClosedObject() {
1:ed41c31:             return object_;
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Checks whether a method expects an exception to be thrown
1:ed41c31:          * when the object is closed. Currently, only
1:5a557ed:          * {@code close()}, {@code isClosed()}, {@code isValid()} and
1:5a557ed:          * {@code abort()} don't expect exceptions.
1:ed41c31:          *
1:ed41c31:          * @param method a method
1:ed41c31:          * @return <code>true</code> if an exception is expected
1:ed41c31:          */
1:ed41c31:         public boolean expectsException(Method method) {
1:6afb55c:             String name = method.getName();
1:5a557ed:             return !(name.equals("close") || name.equals("isClosed")
1:5a557ed:                     || name.equals("isValid") || name.equals("abort"));
1:1861dba:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Checks whether an exception is of the expected type for
1:ed41c31:          * that method.
1:ed41c31:          *
1:ed41c31:          * @param method a method
1:ed41c31:          * @param sqle an exception
1:ed41c31:          * @exception SQLException if the exception was not expected
1:ed41c31:          */
1:ed41c31:         public final void checkException(Method method, SQLException sqle)
1:ed41c31:             throws SQLException
1:ed41c31:         {
1:ed41c31:             if (!expectsException(method)) {
1:ed41c31:                 throw sqle;
1:ed41c31:             }
1:6afb55c: 
1:6afb55c:             if (sqle.getSQLState().startsWith("0A")) {
1:6afb55c:                 // method is not supported, so we don't expect closed object
1:6afb55c:                 // exception
1:6afb55c:                 return;
1:6afb55c:             }
1:6afb55c: 
1:ed41c31:             checkSQLState(method, sqle);
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Checks whether the SQL state is as expected.
1:ed41c31:          *
1:ed41c31:          * @param method a <code>Method</code> value
1:ed41c31:          * @param sqle a <code>SQLException</code> value
2:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected abstract void checkSQLState(Method method,
1:ed41c31:                                               SQLException sqle)
1:ed41c31:             throws SQLException;
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Helper method for creating a connection.
1:ed41c31:          *
1:ed41c31:          * @return a connection
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected Connection createConnection() throws SQLException {
1:ed41c31:             return decorator_.newConnection();
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Helper method for creating a statement.
1:ed41c31:          *
1:ed41c31:          * @return a statement
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected Statement createStatement() throws SQLException {
1:ed41c31:             return decorator_.getConnection().createStatement();
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Helper method for creating a prepared statement.
1:ed41c31:          *
1:ed41c31:          * @param sql statement text
1:ed41c31:          * @return a prepared statement
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected PreparedStatement prepareStatement(String sql)
1:ed41c31:             throws SQLException
1:ed41c31:         {
1:ed41c31:             return decorator_.getConnection().prepareStatement(sql);
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Helper method for creating a callable statement.
1:ed41c31:          *
1:ed41c31:          * @param call statement text
1:ed41c31:          * @return a callable statement
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected CallableStatement prepareCall(String call)
1:ed41c31:             throws SQLException
1:ed41c31:         {
1:ed41c31:             return decorator_.getConnection().prepareCall(call);
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Decorator class for testing methods on a closed result set.
1:ed41c31:      */
1:ed41c31:     private static class ResultSetObjectDecorator extends ObjectDecorator {
1:ed41c31:         /** Statement used for creating the result set to test. */
1:ed41c31:         private Statement stmt_;
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Creates a new <code>ResultSetObjectDecorator</code> instance.
1:ed41c31:          *
1:ed41c31:          * @param test the test to decorate
1:ed41c31:          * @param decorator decorator used for obtaining a statement
1:ed41c31:          */
1:ed41c31:         public ResultSetObjectDecorator(Test test,
1:ed41c31:                                         DataSourceDecorator decorator) {
1:ed41c31:             super(test, decorator);
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Sets up the test. Creates a result set and closes it.
1:ed41c31:          *
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         public void setUp() throws SQLException {
1:ed41c31:             stmt_ = createStatement();
1:ed41c31:             ResultSet rs = stmt_.executeQuery("VALUES(1)");
1:ed41c31:             rs.close();
1:ed41c31:             object_ = rs;
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Tears down the test. Closes open resources.
1:ed41c31:          *
1:ec5ae26:          * @exception Exception if an error occurs
1:ed41c31:          */
1:ec5ae26:         public void tearDown() throws Exception {
1:ed41c31:             stmt_.close();
1:ec5ae26:             stmt_ = null;
1:ec5ae26:             super.tearDown();
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Checks whether the exception has the expected SQL state
1:ed41c31:          * (XCL16 - result set is closed).
1:ed41c31:          *
1:ed41c31:          * @param method a <code>Method</code> value
1:ed41c31:          * @param sqle a <code>SQLException</code> value
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected void checkSQLState(Method method, SQLException sqle)
1:ed41c31:             throws SQLException
1:ed41c31:         {
1:ed41c31:             if (sqle.getSQLState().equals("XCL16")) {
1:4eeab6c:                 // DERBY-4767 - verification test for operation in XCL16 message.
1:4eeab6c:                 String methodString=method.getName();
1:4eeab6c:                 if (methodString.indexOf("(") > 1 )
1:4eeab6c:                     methodString=methodString.substring(0, (methodString.length() -2));
1:9c8b717:                 assertTrue("method = " + method.toString() + ", but message: " + sqle.getMessage(),
1:9c8b717:                            sqle.getMessage().indexOf(methodString) > 0); 
1:ed41c31:                 // everything is OK, do nothing
1:ed41c31:             } else {
1:ed41c31:                 // unexpected exception
1:ed41c31:                 throw sqle;
1:ed41c31:             }
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Decorator class for testing methods on a closed statement.
1:ed41c31:      */
1:ed41c31:     private static class StatementObjectDecorator extends ObjectDecorator {
1:ed41c31:         /**
1:ed41c31:          * Creates a new <code>StatementObjectDecorator</code> instance.
1:ed41c31:          *
1:ed41c31:          * @param test the test to decorate
1:ed41c31:          * @param decorator decorator which provides a statement
1:ed41c31:          */
1:ed41c31:         public StatementObjectDecorator(Test test,
1:ed41c31:                                         DataSourceDecorator decorator) {
1:ed41c31:             super(test, decorator);
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Sets up the test. Creates a statement and closes it.
1:ed41c31:          *
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         public void setUp() throws SQLException {
1:ed41c31:             Statement stmt = createStatement();
1:ed41c31:             stmt.close();
1:ed41c31:             object_ = stmt;
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Checks whether the exception has the expected SQL state
1:ed41c31:          * (statement is closed). When using embedded, XJ012 is
1:ed41c31:          * expected. When using the client driver, XCL31 is expected.
1:ed41c31:          *
1:ed41c31:          * @param method a <code>Method</code> value
1:ed41c31:          * @param sqle a <code>SQLException</code> value
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected void checkSQLState(Method method, SQLException sqle)
1:ed41c31:             throws SQLException
1:ed41c31:         {
1:ed41c31:             String sqlState = sqle.getSQLState();
1:0568a6c:             if (sqlState.equals("XJ012")) {
2:ed41c31:                 // expected, do nothing
1:ed41c31:             } else {
1:ed41c31:                 // unexpected exception
1:ed41c31:                 throw sqle;
1:ed41c31:             }
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Decorator class for testing methods on a closed prepared statement.
1:ed41c31:      */
1:ed41c31:     private static class PreparedStatementObjectDecorator
1:ed41c31:         extends StatementObjectDecorator
1:ed41c31:     {
1:ed41c31:         /**
1:ed41c31:          * Creates a new <code>PreparedStatementObjectDecorator</code>
1:ed41c31:          * instance.
1:ed41c31:          *
1:ed41c31:          * @param test the test to decorate
1:ed41c31:          * @param decorator decorator which provides a prepared statement
1:ed41c31:          */
1:ed41c31:         public PreparedStatementObjectDecorator(Test test,
1:ed41c31:                                                 DataSourceDecorator decorator)
1:ed41c31:         {
1:ed41c31:             super(test, decorator);
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Sets up the test. Prepares a statement and closes it.
1:ed41c31:          *
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         public void setUp() throws SQLException {
1:ed41c31:             PreparedStatement ps = prepareStatement("VALUES(1)");
1:ed41c31:             ps.close();
1:ed41c31:             object_ = ps;
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Checks whether the exception has the expected SQL state
1:ed41c31:          * (statement is closed), or XJ016 indicating it is a
1:ed41c31:          * Statement method not meant to be invoked on a
1:ed41c31:          * PreparedStatement.
1:ed41c31:          *
1:ed41c31:          * @param method a <code>Method</code> value
1:ed41c31:          * @param sqle a <code>SQLException</code> value
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected void checkSQLState(Method method, SQLException sqle)
1:ed41c31:             throws SQLException
1:ed41c31:         {
1:ed41c31:             if (method.getDeclaringClass() == Statement.class &&
1:ed41c31:                 sqle.getSQLState().equals("XJ016")) {
1:ed41c31:                 // XJ016 is "blah,blah not allowed on a prepared
1:ed41c31:                 // statement", so it's OK to get this one
1:ed41c31:             } else {
1:ed41c31:                 super.checkSQLState(method, sqle);
1:ed41c31:             }
1:ed41c31: 
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Decorator class for testing methods on a closed callable statement.
1:ed41c31:      */
1:ed41c31:     private static class CallableStatementObjectDecorator
1:ed41c31:         extends PreparedStatementObjectDecorator
1:ed41c31:     {
1:ed41c31:         /**
1:ed41c31:          * Creates a new <code>CallableStatementObjectDecorator</code>
1:ed41c31:          * instance.
1:ed41c31:          *
1:ed41c31:          * @param test the test to decorate
1:ed41c31:          * @param decorator decorator which provides a callable statement
1:ed41c31:          */
1:ed41c31:         public CallableStatementObjectDecorator(Test test,
1:ed41c31:                                                 DataSourceDecorator decorator)
1:ed41c31:         {
1:ed41c31:             super(test, decorator);
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Sets up the test. Prepares a call and closes the statement.
1:ed41c31:          *
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         public void setUp() throws SQLException {
1:ed41c31:             CallableStatement cs =
1:ed41c31:                 prepareCall("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:ed41c31:             cs.close();
1:ed41c31:             object_ = cs;
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Decorator class for testing methods on a closed connection.
1:ed41c31:      */
1:ed41c31:     private static class ConnectionObjectDecorator extends ObjectDecorator {
1:ed41c31:         /**
1:ed41c31:          * Creates a new <code>ConnectionObjectDecorator</code> instance.
1:ed41c31:          *
1:ed41c31:          * @param test the test to decorate
1:ed41c31:          * @param decorator decorator which provides a connection
1:ed41c31:          */
1:ed41c31:         public ConnectionObjectDecorator(Test test,
1:ed41c31:                                          DataSourceDecorator decorator) {
1:ed41c31:             super(test, decorator);
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Sets up the test. Creates a connection and closes it.
1:ed41c31:          *
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         public void setUp() throws SQLException {
1:ed41c31:             Connection conn = createConnection();
1:ed41c31:             conn.rollback();    // cannot close active transactions
1:ed41c31:             conn.close();
1:ed41c31:             object_ = conn;
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Checks that the exception has an expected SQL state (08003
1:ed41c31:          * - no current connection). Also accept
1:7c3b39d:          * <code>SQLClientInfoException</code>s from
1:ed41c31:          * <code>setClientInfo()</code>.
1:ed41c31:          *
1:ed41c31:          * @param method a <code>Method</code> value
1:ed41c31:          * @param sqle a <code>SQLException</code> value
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected void checkSQLState(Method method, SQLException sqle)
1:ed41c31:             throws SQLException
1:ed41c31:         {
1:6afb55c:             if (method.getName().equals("setClientInfo") &&
1:6afb55c:                     method.getParameterTypes().length == 1 &&
1:6afb55c:                     method.getParameterTypes()[0] == Properties.class) {
1:6afb55c:                 // setClientInfo(Properties) should throw SQLClientInfoException
1:6afb55c:                 if (!sqle.getClass().getName().equals(
1:6afb55c:                             "java.sql.SQLClientInfoException")) {
1:6afb55c:                     throw sqle;
1:6afb55c:                 }
1:ed41c31:             } else if (sqle.getSQLState().equals("08003")) {
1:ed41c31:                 // expected, connection closed
1:ed41c31:             } else {
1:ed41c31:                 // unexpected exception
1:ed41c31:                 throw sqle;
1:ed41c31:             }
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Decorator class used for obtaining connections through a
1:ed41c31:      * <code>DataSource</code>.
1:ed41c31:      */
1:ed41c31:     private static class DataSourceDecorator extends TestSetup {
1:ed41c31:         /** Connection shared by many tests. */
1:ed41c31:         private Connection connection_;
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Creates a new <code>DataSourceDecorator</code> instance.
1:ed41c31:          *
1:ed41c31:          * @param test the test to decorate
1:ed41c31:          */
1:ed41c31:         public DataSourceDecorator(Test test) {
1:ed41c31:             super(test);
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Sets up the test by creating a connection.
1:ed41c31:          *
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         public final void setUp() throws SQLException {
1:ed41c31:              connection_ = newConnection();
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Gets the connection created when the test was set up.
1:ed41c31:          *
1:ed41c31:          * @return a <code>Connection</code> value
1:ed41c31:          */
1:ed41c31:         public final Connection getConnection() {
1:ed41c31:             return connection_;
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Creates a new connection with auto-commit set to false.
1:ed41c31:          *
1:ed41c31:          * @return a <code>Connection</code> value
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         public final Connection newConnection() throws SQLException {
1:ed41c31:             Connection conn = newConnection_();
1:ed41c31:             conn.setAutoCommit(false);
1:ed41c31:             return conn;
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Tears down the test and closes the connection.
1:ed41c31:          *
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         public final void tearDown() throws SQLException {
1:ed41c31:             connection_.rollback();
1:ed41c31:             connection_.close();
1:ec5ae26:             connection_ = null;
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Creates a new connection using a <code>DataSource</code>.
1:ed41c31:          *
1:ed41c31:          * @return a <code>Connection</code> value
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected Connection newConnection_() throws SQLException {
1:8ed08b2:             DataSource ds = JDBCDataSource.getDataSource();
1:6afb55c:             // make sure the database is created when running the test
1:6afb55c:             // standalone
1:6afb55c:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:6afb55c:                                            "create=true");
1:8ed08b2:             return ds.getConnection();
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Decorator class used for obtaining connections through a
1:ed41c31:      * <code>ConnectionPoolDataSource</code>.
1:ed41c31:      */
1:ed41c31:     private static class PoolDataSourceDecorator extends DataSourceDecorator {
1:2ff02ef:         private final Map dsProps;
1:2ff02ef: 
1:ed41c31:         /**
1:ed41c31:          * Creates a new <code>PoolDataSourceDecorator</code> instance.
1:ed41c31:          *
1:ed41c31:          * @param test the test to decorate
1:2ff02ef:          * @param dsProps data source properties
1:ed41c31:          */
1:2ff02ef:         public PoolDataSourceDecorator(Test test, Map dsProps) {
1:ed41c31:             super(test);
1:2ff02ef:             this.dsProps = dsProps;
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Creates a new connection using a
1:ed41c31:          * <code>ConnectionPoolDataSource</code>.
1:ed41c31:          *
1:ed41c31:          * @return a <code>Connection</code> value
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected Connection newConnection_() throws SQLException {
1:8ed08b2:             ConnectionPoolDataSource ds = J2EEDataSource.getConnectionPoolDataSource();
1:2ff02ef:             for (Iterator it = dsProps.entrySet().iterator(); it.hasNext(); ) {
1:2ff02ef:                 Map.Entry e = (Map.Entry) it.next();
1:2ff02ef:                 J2EEDataSource.setBeanProperty(
1:2ff02ef:                     ds, (String) e.getKey(), e.getValue());
1:2ff02ef:             }
1:ed41c31:             PooledConnection pc =
1:8ed08b2:                 ds.getPooledConnection();
1:ed41c31:             return pc.getConnection();
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: 
1:ed41c31:     /**
1:ed41c31:      * Decorator class used for obtaining connections through an
1:ed41c31:      * <code>XADataSource</code>.
1:ed41c31:      */
1:ed41c31:     private static class XADataSourceDecorator extends DataSourceDecorator {
1:ed41c31:         /**
1:ed41c31:          * Creates a new <code>XADataSourceDecorator</code> instance.
1:ed41c31:          *
1:ed41c31:          * @param test the test to decorate
1:ed41c31:          */
1:ed41c31:         public XADataSourceDecorator(Test test) {
1:ed41c31:             super(test);
1:ed41c31:         }
1:ed41c31: 
1:ed41c31:         /**
1:ed41c31:          * Creates a new connection using an <code>XADataSource</code>.
1:ed41c31:          *
1:ed41c31:          * @return a <code>Connection</code> value
1:ed41c31:          * @exception SQLException if an error occurs
1:ed41c31:          */
1:ed41c31:         protected Connection newConnection_() throws SQLException {
1:8ed08b2:             XADataSource ds = J2EEDataSource.getXADataSource();
1:8ed08b2:             XAConnection xac = ds.getXAConnection();
1:ed41c31:             return xac.getConnection();
1:ed41c31:         }
1:ed41c31:     }
1:ed41c31: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:             return (char) 0;
1:             return (byte) 0;
1:             return (short) 0;
1:             return 0;
1:             return 0L;
1:             return 0f;
1:             return 0d;
commit:9c8b717
/////////////////////////////////////////////////////////////////////////
1: 
0:             // so far, only one method is allowed to be called (and is a NOP)
0:             // on a closed JDBC object
1: 
0:             if ( !"public abstract void java.sql.Connection.abort(java.util.concurrent.Executor) throws java.sql.SQLException".equals( method_.toString() ) )
1:             {
1:                 assertFalse("No exception was thrown for method " + method_,
1:                             decorator_.expectsException(method_));
1:             }
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                 assertTrue("method = " + method.toString() + ", but message: " + sqle.getMessage(),
1:                            sqle.getMessage().indexOf(methodString) > 0); 
commit:6e3dbab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:7c3b39d
/////////////////////////////////////////////////////////////////////////
0: import java.sql.SQLClientInfoException;
/////////////////////////////////////////////////////////////////////////
1:          * <code>SQLClientInfoException</code>s from
/////////////////////////////////////////////////////////////////////////
0:             if (sqle instanceof SQLClientInfoException &&
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("ClosedObjectTest suite");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite topSuite = new BaseTestSuite(
1:         BaseTestSuite dsSuite = new BaseTestSuite(
1:             "ClosedObjectTest DataSource");
1: 
/////////////////////////////////////////////////////////////////////////
1:             BaseTestSuite xaSuite = new BaseTestSuite("ClosedObjectTest XA");
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite poolSuite = new BaseTestSuite(
/////////////////////////////////////////////////////////////////////////
1:     private static void fillDataSourceSuite(BaseTestSuite suite,
1:         BaseTestSuite rsSuite = new BaseTestSuite("Closed ResultSet");
1:         BaseTestSuite stmtSuite = new BaseTestSuite("Closed Statement");
1:         BaseTestSuite psSuite = new BaseTestSuite("Closed PreparedStatement");
1:         BaseTestSuite csSuite = new BaseTestSuite("Closed CallableStatement");
1:         BaseTestSuite connSuite = new BaseTestSuite("Closed Connection");
/////////////////////////////////////////////////////////////////////////
1:     private static void fillObjectSuite(BaseTestSuite suite,
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e18f54b
/////////////////////////////////////////////////////////////////////////
1:         for (Class<?> c = decorator_.getClosedObject().getClass();
commit:5a557ed
/////////////////////////////////////////////////////////////////////////
1:             // If we get here, and we expected an exception to be thrown,
1:             // report that as a failure.
0:             assertFalse("No exception was thrown for method " + method_,
1:             // An exception was thrown. Check if we expected that an exception
1:             // was thrown, and if it was the exception we expected.
/////////////////////////////////////////////////////////////////////////
1:          * {@code close()}, {@code isClosed()}, {@code isValid()} and
1:          * {@code abort()} don't expect exceptions.
1:             return !(name.equals("close") || name.equals("isClosed")
1:                     || name.equals("isValid") || name.equals("abort"));
commit:7fc16c3
/////////////////////////////////////////////////////////////////////////
1:             String implClassName = object.getClass().getName();
1: 
1:             name_ = implClassName + "." + method_.getName();
1: 
1:             // DERBY-6147: If the test runs on a newer version of the JVM
1:             // than the JDBC driver supports, we should skip those methods
1:             // that are not implemented.
1:             //
1:             // Limit the check to platforms that support JDBC 4 or higher
1:             // since the isImplemented() method uses a method only available
1:             // in Java 5 and higher. We know that all JDBC 3 and JSR-169
1:             // methods are implemented, so no tests need to be skipped on
1:             // those older platforms anyway.
1:             if (JDBC.vmSupportsJDBC4() && !isImplemented()) {
1:                 println("Skipping testing of " + method_ + " on " +
1:                         implClassName + " because it is not implemented");
1:                 name_ += "_SKIPPED";
1:                 return;
1:             }
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Check if the JDBC interface method tested by this test case is
1:      * actually implemented by the Derby object being tested.
1:      */
1:     private boolean isImplemented() throws NoSuchMethodException {
1:         // Check if the method is implemented in one of the Derby classes
1:         // that the JDBC object belongs to.
0:         for (Class c = decorator_.getClosedObject().getClass();
1:                 c != null; c = c.getSuperclass()) {
1:             if (c.getName().startsWith("org.apache.derby.")) {
1:                 try {
1:                     Method m = c.getDeclaredMethod(
1:                         method_.getName(), method_.getParameterTypes());
1:                     if (!m.isSynthetic()) {
1:                         // Found a real implementation of the method.
1:                         return true;
1:                     }
1:                 } catch (NoSuchMethodException e) {
1:                     // Method was not declared in this class. Try again in
1:                     // the superclass.
1:                 }
1:             }
1:         }
1: 
1:         // No implementation was found.
1:         return false;
1:     }
1: 
commit:2ff02ef
/////////////////////////////////////////////////////////////////////////
1: import java.util.Collections;
1: import java.util.Iterator;
1: import java.util.Map;
/////////////////////////////////////////////////////////////////////////
1:         suite.addTest(baseSuite(false));
1:         suite.addTest(baseSuite(true));
/////////////////////////////////////////////////////////////////////////
1:      * @param network whether or not to run tests with the network client
1:     private static Test baseSuite(boolean network) {
0:         TestSuite topSuite = new TestSuite(
1:             "ClosedObjectTest:" + (network ? "client" : "embedded"));
/////////////////////////////////////////////////////////////////////////
1: 
1:             // Plain connection pool test.
1:             topSuite.addTest(poolSuite(Collections.emptyMap()));
1: 
1:             // The client driver has a variant of connection pool that caches
1:             // and reuses JDBC statements. Test it here by setting the
1:             // maxStatements property.
1:             if (network) {
1:                 topSuite.addTest(poolSuite(Collections.singletonMap(
1:                         "maxStatements", Integer.valueOf(5))));
1:             }
1: 
1:         return network ?
1:                 TestConfiguration.clientServerDecorator(topSuite) :
1:                 topSuite;
1:     }
1: 
1:     /**
1:      * Creates a suite that tests objects produced by a
1:      * ConnectionPoolDataSource.
1:      *
1:      * @param dsProps properties to set on the data source
1:      * @return a suite
1:      */
1:     private static Test poolSuite(Map dsProps) {
0:         TestSuite poolSuite = new TestSuite(
1:                 "ClosedObjectTest ConnectionPoolDataSource");
1:         PoolDataSourceDecorator poolDecorator =
1:                 new PoolDataSourceDecorator(poolSuite, dsProps);
1:         fillDataSourceSuite(poolSuite, poolDecorator);
1:         return poolDecorator;
/////////////////////////////////////////////////////////////////////////
1:         private final Map dsProps;
1: 
1:          * @param dsProps data source properties
1:         public PoolDataSourceDecorator(Test test, Map dsProps) {
1:             this.dsProps = dsProps;
/////////////////////////////////////////////////////////////////////////
1:             for (Iterator it = dsProps.entrySet().iterator(); it.hasNext(); ) {
1:                 Map.Entry e = (Map.Entry) it.next();
1:                 J2EEDataSource.setBeanProperty(
1:                     ds, (String) e.getKey(), e.getValue());
1:             }
commit:dd7903b
/////////////////////////////////////////////////////////////////////////
0:         if (JDBC.vmSupportsJDBC41()) {
0:             // DERBY-4869: The runtime environment supports JDBC 4.1, but
0:             // our database drivers don't yet. Disable this test until the
0:             // drivers have been updated.
0:             return new TestSuite("ClosedObjectTest - Disabled");
1:         }
commit:6afb55c
/////////////////////////////////////////////////////////////////////////
1:  * Derby - org.apache.derbyTesting.functionTests.tests.jdbcapi.ClosedObjectTest
/////////////////////////////////////////////////////////////////////////
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.JDBC;
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:         if (JDBC.vmSupportsJSR169()) {
0:             // JSR169 doesn't support ConnectionPoolDataSource and XADataSource
0:             return dsSuite;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
0:         TestSuite rsSuite = new TestSuite("Closed ResultSet");
0:         TestSuite stmtSuite = new TestSuite("Closed Statement");
0:         TestSuite psSuite = new TestSuite("Closed PreparedStatement");
0:         TestSuite csSuite = new TestSuite("Closed CallableStatement");
0:         TestSuite connSuite = new TestSuite("Closed Connection");
/////////////////////////////////////////////////////////////////////////
1:         Method[] methods = iface.getMethods();
1:         for (int i = 0; i < methods.length; i++) {
1:             ClosedObjectTest cot = new ClosedObjectTest(methods[i], decorator);
/////////////////////////////////////////////////////////////////////////
1:             String name = method.getName();
0:             if (name.equals("close") || name.equals("isClosed")
0:                     || name.equals("isValid")) {
0:                 return false;
/////////////////////////////////////////////////////////////////////////
1: 
1:             if (sqle.getSQLState().startsWith("0A")) {
1:                 // method is not supported, so we don't expect closed object
1:                 // exception
1:                 return;
1:             }
1: 
/////////////////////////////////////////////////////////////////////////
1:             if (method.getName().equals("setClientInfo") &&
1:                     method.getParameterTypes().length == 1 &&
1:                     method.getParameterTypes()[0] == Properties.class) {
1:                 // setClientInfo(Properties) should throw SQLClientInfoException
1:                 if (!sqle.getClass().getName().equals(
1:                             "java.sql.SQLClientInfoException")) {
1:                     throw sqle;
1:                 }
/////////////////////////////////////////////////////////////////////////
1:             // make sure the database is created when running the test
1:             // standalone
1:             JDBCDataSource.setBeanProperty(ds, "connectionAttributes",
1:                                            "create=true");
commit:ec5ae26
/////////////////////////////////////////////////////////////////////////
1:     /** Creates a suite with all tests in the class. */
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("ClosedObjectTest suite");
0:         suite.addTest(baseSuite("ClosedObjectTest:embedded"));
0:         // This test will fail in client/server mode until DERBY-2047 is fixed.
0:         //suite.addTest(TestConfiguration.clientServerDecorator(
0:         //    baseSuite("ClosedObjectTest:client")));
1:         return suite;
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
0:     private static Test baseSuite(String name)  {
0:         TestSuite topSuite = new TestSuite(name);
/////////////////////////////////////////////////////////////////////////
1:         /** Tears down the test environment. */
1:         protected void tearDown() throws Exception {
1:             object_ = null;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:          * @exception Exception if an error occurs
1:         public void tearDown() throws Exception {
1:             stmt_ = null;
1:             super.tearDown();
/////////////////////////////////////////////////////////////////////////
1:             connection_ = null;
commit:57efc3c
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derbyTesting.functionTests.util.TestDataSourceFactory;
/////////////////////////////////////////////////////////////////////////
0:             DataSource ds = TestDataSourceFactory.getDataSource();
/////////////////////////////////////////////////////////////////////////
0:             ConnectionPoolDataSource ds = TestDataSourceFactory.getConnectionPoolDataSource();
/////////////////////////////////////////////////////////////////////////
0:             XADataSource ds = TestDataSourceFactory.getXADataSource();
commit:1861dba
/////////////////////////////////////////////////////////////////////////
0:          * <code>close()</code>, <code>isClosed()</code> and
0:          * <code>isValid()</code> don't expect exceptions.
0:             final String[] exceptionLessMethods = {
0:                 "close",
0:                 "isClosed",
0:                 "isValid",
0:             };
0:             for (String name : exceptionLessMethods) {
0:                 if (name.equals(method.getName())) return false;
1:             }
0:             return true;
commit:ed41c31
/////////////////////////////////////////////////////////////////////////
1: /*
0:  * Derby - org.apache.derbyTesting.functionTests.tests.jdbc4.ClosedObjectTest
1:  *
0:  * Copyright 2006 The Apache Software Foundation or its licensors, as
0:  * applicable.
1:  *
0:  * Licensed under the Apache License, Version 2.0 (the "License"); you
0:  * may not use this file except in compliance with the License. You
0:  * may obtain a copy of the License at
1:  *
0:  *   http://www.apache.org/licenses/LICENSE-2.0
1:  *
0:  * Unless required by applicable law or agreed to in writing, software
0:  * distributed under the License is distributed on an "AS IS" BASIS,
0:  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
0:  * implied. See the License for the specific language governing
0:  * permissions and limitations under the License.
1:  *
1:  */
1: 
0: package org.apache.derbyTesting.functionTests.tests.jdbc4;
1: 
1: import java.lang.reflect.InvocationTargetException;
1: import java.lang.reflect.Method;
1: import java.sql.CallableStatement;
0: import java.sql.ClientInfoException;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
0: import java.sql.SQLFeatureNotSupportedException;
1: import java.sql.Statement;
0: import java.util.Arrays;
1: import java.util.Properties;
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.DataSource;
1: import javax.sql.PooledConnection;
1: import javax.sql.XAConnection;
1: import javax.sql.XADataSource;
1: import junit.extensions.TestSetup;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
0: import org.apache.derbyTesting.functionTests.util.BaseJDBCTestCase;
1: 
1: /**
1:  * Test that all methods on <code>ResultSet</code>,
1:  * <code>Statement</code>, <code>PreparedStatement</code>,
1:  * <code>CallableStatement</code> and <code>Connection</code> objects
1:  * throw the appropriate exceptions when the objects are closed.
1:  */
1: public class ClosedObjectTest extends BaseJDBCTestCase {
1:     /** The method to test. */
1:     private final Method method_;
1:     /** Test decorator which provides a closed object to invoke a
1:      * method on. */
1:     private final ObjectDecorator decorator_;
1:     /** Name of the test. */
1:     private String name_;
1: 
1:     /**
1:      * Creates a new <code>ClosedObjectTest</code> instance.
1:      *
1:      * @param method the method to test
1:      * @param decorator a decorator which provides a closed object
1:      */
1:     public ClosedObjectTest(Method method, ObjectDecorator decorator) {
1:         super("testClosedObjects");
1:         method_ = method;
1:         decorator_ = decorator;
1:         // setting name temporarily, we don't know the real class name yet
1:         name_ = method.getDeclaringClass().getName() + "." + method.getName();
1:     }
1: 
1:     /**
1:      * Gets the name of the test.
1:      *
1:      * @return name of the test
1:      */
1:     public String getName() {
1:         return name_;
1:     }
1: 
1:     /**
1:      * Runs a test case. A method is called on a closed object, and it
1:      * is checked that the appropriate exception is thrown.
1:      *
1:      * @exception Throwable if an error occurs
1:      */
1:     public void testClosedObjects() throws Throwable {
1:         try {
1:             Object object = decorator_.getClosedObject();
1: 
1:             // update name of test with real class name
0:             name_ = object.getClass() + "." + method_.getName();
1: 
1:             method_.invoke(object,
1:                            getNullArguments(method_.getParameterTypes()));
0:             assertFalse("No exception was thrown",
0:                         decorator_.expectsException(method_));
1:         } catch (InvocationTargetException ite) {
1:             try {
1:                 throw ite.getCause();
0:             } catch (SQLFeatureNotSupportedException fnse) {
0:                 // if we don't support the method, it is OK that we
0:                 // throw this exception
1:             } catch (SQLException sqle) {
1:                 decorator_.checkException(method_, sqle);
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Creates the test suite and fills it with tests using
1:      * <code>DataSource</code>, <code>ConnectionPoolDataSource</code>
1:      * and <code>XADataSource</code> to obtain objects.
1:      *
1:      * @return a <code>Test</code> value
1:      * @exception Exception if an error occurs while building the test suite
1:      */
0:     public static Test suite() throws Exception {
0:         TestSuite topSuite = new TestSuite();
1: 
0:         TestSuite dsSuite = new TestSuite();
1:         DataSourceDecorator dsDecorator = new DataSourceDecorator(dsSuite);
1:         topSuite.addTest(dsDecorator);
1:         fillDataSourceSuite(dsSuite, dsDecorator);
1: 
0:         TestSuite poolSuite = new TestSuite();
0:         PoolDataSourceDecorator poolDecorator =
0:             new PoolDataSourceDecorator(poolSuite);
0:         topSuite.addTest(poolDecorator);
0:         fillDataSourceSuite(poolSuite, poolDecorator);
1: 
0:         TestSuite xaSuite = new TestSuite();
1:         XADataSourceDecorator xaDecorator = new XADataSourceDecorator(xaSuite);
1:         topSuite.addTest(xaDecorator);
1:         fillDataSourceSuite(xaSuite, xaDecorator);
1: 
0:         return topSuite;
1:     }
1: 
1:     /**
1:      * Fills a test suite which is contained in a
1:      * <code>DataSourceDecorator</code> with tests for
1:      * <code>ResultSet</code>, <code>Statement</code>,
1:      * <code>PreparedStatement</code>, <code>CallableStatement</code>
1:      * and <code>Connection</code>.
1:      *
1:      * @param suite the test suite to fill
1:      * @param dsDecorator the decorator for the test suite
0:      * @exception Exception if an error occurs while filling the suite
1:      */
0:     private static void fillDataSourceSuite(TestSuite suite,
1:                                             DataSourceDecorator dsDecorator)
0:         throws Exception
1:     {
0:         TestSuite rsSuite = new TestSuite();
1:         ResultSetObjectDecorator rsDecorator =
1:             new ResultSetObjectDecorator(rsSuite, dsDecorator);
1:         suite.addTest(rsDecorator);
1:         fillObjectSuite(rsSuite, rsDecorator, ResultSet.class);
1: 
0:         TestSuite stmtSuite = new TestSuite();
1:         StatementObjectDecorator stmtDecorator =
1:             new StatementObjectDecorator(stmtSuite, dsDecorator);
1:         suite.addTest(stmtDecorator);
1:         fillObjectSuite(stmtSuite, stmtDecorator, Statement.class);
1: 
0:         TestSuite psSuite = new TestSuite();
1:         PreparedStatementObjectDecorator psDecorator =
1:             new PreparedStatementObjectDecorator(psSuite, dsDecorator);
1:         suite.addTest(psDecorator);
1:         fillObjectSuite(psSuite, psDecorator, PreparedStatement.class);
1: 
0:         TestSuite csSuite = new TestSuite();
1:         CallableStatementObjectDecorator csDecorator =
1:             new CallableStatementObjectDecorator(csSuite, dsDecorator);
1:         suite.addTest(csDecorator);
1:         fillObjectSuite(csSuite, csDecorator, CallableStatement.class);
1: 
0:         TestSuite connSuite = new TestSuite();
1:         ConnectionObjectDecorator connDecorator =
1:             new ConnectionObjectDecorator(connSuite, dsDecorator);
1:         suite.addTest(connDecorator);
1:         fillObjectSuite(connSuite, connDecorator, Connection.class);
1:     }
1: 
1:     /**
1:      * Fills a suite with tests for all the methods of an interface.
1:      *
1:      * @param suite the suite to fill
1:      * @param decorator a decorator for the test (used for obtaining a
1:      * closed object to test the method on)
1:      * @param iface the interface which contains the methods to test
0:      * @exception Exception if an error occurs while filling the suite
1:      */
0:     private static void fillObjectSuite(TestSuite suite,
1:                                         ObjectDecorator decorator,
1:                                         Class iface)
0:         throws Exception
1:     {
0:         for (Method m : iface.getMethods()) {
0:             ClosedObjectTest cot = new ClosedObjectTest(m, decorator);
1:             suite.addTest(cot);
1:         }
1:     }
1: 
1:     /**
1:      * Takes an array of classes and returns an array of objects with
1:      * null values compatible with the classes. Helper method for
1:      * converting a parameter list to an argument list.
1:      *
1:      * @param params a <code>Class[]</code> value
1:      * @return an <code>Object[]</code> value
1:      */
1:     private static Object[] getNullArguments(Class[] params) {
1:         Object[] args = new Object[params.length];
1:         for (int i = 0; i < params.length; i++) {
1:             args[i] = getNullValueForType(params[i]);
1:         }
1:         return args;
1:     }
1: 
1:     /**
1:      * Returns a null value compatible with the class. For instance,
1:      * return <code>Boolean.FALSE</code> for primitive booleans, 0 for
1:      * primitive integers and <code>null</code> for non-primitive
1:      * types.
1:      *
1:      * @param type a <code>Class</code> value
1:      * @return a null value
1:      */
1:     private static Object getNullValueForType(Class type) {
1:         if (!type.isPrimitive()) {
1:             return null;
1:         }
1:         if (type == Boolean.TYPE) {
1:             return Boolean.FALSE;
1:         }
1:         if (type == Character.TYPE) {
0:             return new Character((char) 0);
1:         }
1:         if (type == Byte.TYPE) {
0:             return new Byte((byte) 0);
1:         }
1:         if (type == Short.TYPE) {
0:             return new Short((short) 0);
1:         }
1:         if (type == Integer.TYPE) {
0:             return new Integer(0);
1:         }
1:         if (type == Long.TYPE) {
0:             return new Long(0L);
1:         }
1:         if (type == Float.TYPE) {
0:             return new Float(0f);
1:         }
1:         if (type == Double.TYPE) {
0:             return new Double(0d);
1:         }
1:         fail("Don't know how to handle type " + type);
1:         return null;            // unreachable statement
1:     }
1: 
1:     /**
1:      * Abstract decorator class with functionality for obtaining a
1:      * closed object.
1:      */
1:     private static abstract class ObjectDecorator extends TestSetup {
1:         /** Decorator which provides a connection. */
1:         private final DataSourceDecorator decorator_;
1:         /** The closed object. Must be set by a sub-class. */
1:         protected Object object_;
1: 
1:         /**
1:          * Creates a new <code>ObjectDecorator</code> instance.
1:          *
1:          * @param test a test or suite to decorate
1:          * @param decorator a decorator which provides a connection
1:          */
1:         public ObjectDecorator(Test test, DataSourceDecorator decorator) {
1:             super(test);
1:             decorator_ = decorator;
1:         }
1: 
1:         /**
1:          * Returns the closed object.
1:          *
1:          * @return a closed object
1:          */
1:         public Object getClosedObject() {
1:             return object_;
1:         }
1: 
1:         /**
1:          * Checks whether a method expects an exception to be thrown
1:          * when the object is closed. Currently, only
0:          * <code>close()</code> and <code>isClosed()</code> don't
0:          * expect exceptions.
1:          *
1:          * @param method a method
1:          * @return <code>true</code> if an exception is expected
1:          */
1:         public boolean expectsException(Method method) {
0:             return
0:                 !(method.getName().equals("close") ||
0:                   method.getName().equals("isClosed"));
1:         }
1: 
1:         /**
1:          * Checks whether an exception is of the expected type for
1:          * that method.
1:          *
1:          * @param method a method
1:          * @param sqle an exception
1:          * @exception SQLException if the exception was not expected
1:          */
1:         public final void checkException(Method method, SQLException sqle)
1:             throws SQLException
1:         {
1:             if (!expectsException(method)) {
1:                 throw sqle;
1:             }
1:             checkSQLState(method, sqle);
1:         }
1: 
1:         /**
1:          * Checks whether the SQL state is as expected.
1:          *
1:          * @param method a <code>Method</code> value
1:          * @param sqle a <code>SQLException</code> value
1:          * @exception SQLException if an error occurs
1:          */
1:         protected abstract void checkSQLState(Method method,
1:                                               SQLException sqle)
1:             throws SQLException;
1: 
1:         /**
1:          * Helper method for creating a connection.
1:          *
1:          * @return a connection
1:          * @exception SQLException if an error occurs
1:          */
1:         protected Connection createConnection() throws SQLException {
1:             return decorator_.newConnection();
1:         }
1: 
1:         /**
1:          * Helper method for creating a statement.
1:          *
1:          * @return a statement
1:          * @exception SQLException if an error occurs
1:          */
1:         protected Statement createStatement() throws SQLException {
1:             return decorator_.getConnection().createStatement();
1:         }
1: 
1:         /**
1:          * Helper method for creating a prepared statement.
1:          *
1:          * @param sql statement text
1:          * @return a prepared statement
1:          * @exception SQLException if an error occurs
1:          */
1:         protected PreparedStatement prepareStatement(String sql)
1:             throws SQLException
1:         {
1:             return decorator_.getConnection().prepareStatement(sql);
1:         }
1: 
1:         /**
1:          * Helper method for creating a callable statement.
1:          *
1:          * @param call statement text
1:          * @return a callable statement
1:          * @exception SQLException if an error occurs
1:          */
1:         protected CallableStatement prepareCall(String call)
1:             throws SQLException
1:         {
1:             return decorator_.getConnection().prepareCall(call);
1:         }
1:     }
1: 
1:     /**
1:      * Decorator class for testing methods on a closed result set.
1:      */
1:     private static class ResultSetObjectDecorator extends ObjectDecorator {
1:         /** Statement used for creating the result set to test. */
1:         private Statement stmt_;
1: 
1:         /**
1:          * Creates a new <code>ResultSetObjectDecorator</code> instance.
1:          *
1:          * @param test the test to decorate
1:          * @param decorator decorator used for obtaining a statement
1:          */
1:         public ResultSetObjectDecorator(Test test,
1:                                         DataSourceDecorator decorator) {
1:             super(test, decorator);
1:         }
1: 
1:         /**
1:          * Sets up the test. Creates a result set and closes it.
1:          *
1:          * @exception SQLException if an error occurs
1:          */
1:         public void setUp() throws SQLException {
1:             stmt_ = createStatement();
1:             ResultSet rs = stmt_.executeQuery("VALUES(1)");
1:             rs.close();
1:             object_ = rs;
1:         }
1: 
1:         /**
1:          * Tears down the test. Closes open resources.
1:          *
1:          * @exception SQLException if an error occurs
1:          */
0:         public void tearDown() throws SQLException {
1:             stmt_.close();
1:         }
1: 
1:         /**
1:          * Checks whether the exception has the expected SQL state
1:          * (XCL16 - result set is closed).
1:          *
1:          * @param method a <code>Method</code> value
1:          * @param sqle a <code>SQLException</code> value
1:          * @exception SQLException if an error occurs
1:          */
1:         protected void checkSQLState(Method method, SQLException sqle)
1:             throws SQLException
1:         {
1:             if (sqle.getSQLState().equals("XCL16")) {
1:                 // everything is OK, do nothing
1:             } else {
1:                 // unexpected exception
1:                 throw sqle;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Decorator class for testing methods on a closed statement.
1:      */
1:     private static class StatementObjectDecorator extends ObjectDecorator {
1:         /**
1:          * Creates a new <code>StatementObjectDecorator</code> instance.
1:          *
1:          * @param test the test to decorate
1:          * @param decorator decorator which provides a statement
1:          */
1:         public StatementObjectDecorator(Test test,
1:                                         DataSourceDecorator decorator) {
1:             super(test, decorator);
1:         }
1: 
1:         /**
1:          * Sets up the test. Creates a statement and closes it.
1:          *
1:          * @exception SQLException if an error occurs
1:          */
1:         public void setUp() throws SQLException {
1:             Statement stmt = createStatement();
1:             stmt.close();
1:             object_ = stmt;
1:         }
1: 
1:         /**
1:          * Checks whether the exception has the expected SQL state
1:          * (statement is closed). When using embedded, XJ012 is
1:          * expected. When using the client driver, XCL31 is expected.
1:          *
1:          * @param method a <code>Method</code> value
1:          * @param sqle a <code>SQLException</code> value
1:          * @exception SQLException if an error occurs
1:          */
1:         protected void checkSQLState(Method method, SQLException sqle)
1:             throws SQLException
1:         {
1:             String sqlState = sqle.getSQLState();
0:             if (usingEmbedded() && sqlState.equals("XJ012")) {
1:                 // expected, do nothing
0:             } else if (usingDerbyNetClient() && sqlState.equals("XCL31")) {
1:                 // expected, do nothing
1:             } else {
1:                 // unexpected exception
1:                 throw sqle;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Decorator class for testing methods on a closed prepared statement.
1:      */
1:     private static class PreparedStatementObjectDecorator
1:         extends StatementObjectDecorator
1:     {
1:         /**
1:          * Creates a new <code>PreparedStatementObjectDecorator</code>
1:          * instance.
1:          *
1:          * @param test the test to decorate
1:          * @param decorator decorator which provides a prepared statement
1:          */
1:         public PreparedStatementObjectDecorator(Test test,
1:                                                 DataSourceDecorator decorator)
1:         {
1:             super(test, decorator);
1:         }
1: 
1:         /**
1:          * Sets up the test. Prepares a statement and closes it.
1:          *
1:          * @exception SQLException if an error occurs
1:          */
1:         public void setUp() throws SQLException {
1:             PreparedStatement ps = prepareStatement("VALUES(1)");
1:             ps.close();
1:             object_ = ps;
1:         }
1: 
1:         /**
1:          * Checks whether the exception has the expected SQL state
1:          * (statement is closed), or XJ016 indicating it is a
1:          * Statement method not meant to be invoked on a
1:          * PreparedStatement.
1:          *
1:          * @param method a <code>Method</code> value
1:          * @param sqle a <code>SQLException</code> value
1:          * @exception SQLException if an error occurs
1:          */
1:         protected void checkSQLState(Method method, SQLException sqle)
1:             throws SQLException
1:         {
1:             if (method.getDeclaringClass() == Statement.class &&
1:                 sqle.getSQLState().equals("XJ016")) {
1:                 // XJ016 is "blah,blah not allowed on a prepared
1:                 // statement", so it's OK to get this one
1:             } else {
1:                 super.checkSQLState(method, sqle);
1:             }
1: 
1:         }
1:     }
1: 
1:     /**
1:      * Decorator class for testing methods on a closed callable statement.
1:      */
1:     private static class CallableStatementObjectDecorator
1:         extends PreparedStatementObjectDecorator
1:     {
1:         /**
1:          * Creates a new <code>CallableStatementObjectDecorator</code>
1:          * instance.
1:          *
1:          * @param test the test to decorate
1:          * @param decorator decorator which provides a callable statement
1:          */
1:         public CallableStatementObjectDecorator(Test test,
1:                                                 DataSourceDecorator decorator)
1:         {
1:             super(test, decorator);
1:         }
1: 
1:         /**
1:          * Sets up the test. Prepares a call and closes the statement.
1:          *
1:          * @exception SQLException if an error occurs
1:          */
1:         public void setUp() throws SQLException {
1:             CallableStatement cs =
1:                 prepareCall("CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(1)");
1:             cs.close();
1:             object_ = cs;
1:         }
1:     }
1: 
1:     /**
1:      * Decorator class for testing methods on a closed connection.
1:      */
1:     private static class ConnectionObjectDecorator extends ObjectDecorator {
1:         /**
1:          * Creates a new <code>ConnectionObjectDecorator</code> instance.
1:          *
1:          * @param test the test to decorate
1:          * @param decorator decorator which provides a connection
1:          */
1:         public ConnectionObjectDecorator(Test test,
1:                                          DataSourceDecorator decorator) {
1:             super(test, decorator);
1:         }
1: 
1:         /**
1:          * Sets up the test. Creates a connection and closes it.
1:          *
1:          * @exception SQLException if an error occurs
1:          */
1:         public void setUp() throws SQLException {
1:             Connection conn = createConnection();
1:             conn.rollback();    // cannot close active transactions
1:             conn.close();
1:             object_ = conn;
1:         }
1: 
1:         /**
1:          * Checks that the exception has an expected SQL state (08003
1:          * - no current connection). Also accept
0:          * <code>ClientInfoException</code>s from
1:          * <code>setClientInfo()</code>.
1:          *
1:          * @param method a <code>Method</code> value
1:          * @param sqle a <code>SQLException</code> value
1:          * @exception SQLException if an error occurs
1:          */
1:         protected void checkSQLState(Method method, SQLException sqle)
1:             throws SQLException
1:         {
0:             if (sqle instanceof ClientInfoException &&
0:                 method.getName().equals("setClientInfo") &&
0:                 Arrays.asList(method.getParameterTypes())
0:                 .equals(Arrays.asList(new Class[] { Properties.class }))) {
0:                 // setClientInfo(Properties) should throw
0:                 // ClientInfoException, so this is OK
1:             } else if (sqle.getSQLState().equals("08003")) {
1:                 // expected, connection closed
1:             } else {
1:                 // unexpected exception
1:                 throw sqle;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Decorator class used for obtaining connections through a
1:      * <code>DataSource</code>.
1:      */
1:     private static class DataSourceDecorator extends TestSetup {
1:         /** Connection shared by many tests. */
1:         private Connection connection_;
1: 
1:         /**
1:          * Creates a new <code>DataSourceDecorator</code> instance.
1:          *
1:          * @param test the test to decorate
1:          */
1:         public DataSourceDecorator(Test test) {
1:             super(test);
1:         }
1: 
1:         /**
1:          * Sets up the test by creating a connection.
1:          *
1:          * @exception SQLException if an error occurs
1:          */
1:         public final void setUp() throws SQLException {
1:             connection_ = newConnection();
1:         }
1: 
1:         /**
1:          * Gets the connection created when the test was set up.
1:          *
1:          * @return a <code>Connection</code> value
1:          */
1:         public final Connection getConnection() {
1:             return connection_;
1:         }
1: 
1:         /**
1:          * Creates a new connection with auto-commit set to false.
1:          *
1:          * @return a <code>Connection</code> value
1:          * @exception SQLException if an error occurs
1:          */
1:         public final Connection newConnection() throws SQLException {
1:             Connection conn = newConnection_();
1:             conn.setAutoCommit(false);
1:             return conn;
1:         }
1: 
1:         /**
1:          * Tears down the test and closes the connection.
1:          *
1:          * @exception SQLException if an error occurs
1:          */
1:         public final void tearDown() throws SQLException {
1:             connection_.rollback();
1:             connection_.close();
1:         }
1: 
1:         /**
1:          * Creates a new connection using a <code>DataSource</code>.
1:          *
1:          * @return a <code>Connection</code> value
1:          * @exception SQLException if an error occurs
1:          */
1:         protected Connection newConnection_() throws SQLException {
0:             DataSource ds = getDataSource();
0:             return ds.getConnection(CONFIG.getUserName(),
0:                                     CONFIG.getUserPassword());
1:         }
1:     }
1: 
1:     /**
1:      * Decorator class used for obtaining connections through a
1:      * <code>ConnectionPoolDataSource</code>.
1:      */
1:     private static class PoolDataSourceDecorator extends DataSourceDecorator {
1:         /**
1:          * Creates a new <code>PoolDataSourceDecorator</code> instance.
1:          *
1:          * @param test the test to decorate
1:          */
0:         public PoolDataSourceDecorator(Test test) {
1:             super(test);
1:         }
1: 
1:         /**
1:          * Creates a new connection using a
1:          * <code>ConnectionPoolDataSource</code>.
1:          *
1:          * @return a <code>Connection</code> value
1:          * @exception SQLException if an error occurs
1:          */
1:         protected Connection newConnection_() throws SQLException {
0:             ConnectionPoolDataSource ds = getConnectionPoolDataSource();
1:             PooledConnection pc =
0:                 ds.getPooledConnection(CONFIG.getUserName(),
0:                                        CONFIG.getUserPassword());
1:             return pc.getConnection();
1:         }
1:     }
1: 
1:     /**
1:      * Decorator class used for obtaining connections through an
1:      * <code>XADataSource</code>.
1:      */
1:     private static class XADataSourceDecorator extends DataSourceDecorator {
1:         /**
1:          * Creates a new <code>XADataSourceDecorator</code> instance.
1:          *
1:          * @param test the test to decorate
1:          */
1:         public XADataSourceDecorator(Test test) {
1:             super(test);
1:         }
1: 
1:         /**
1:          * Creates a new connection using an <code>XADataSource</code>.
1:          *
1:          * @return a <code>Connection</code> value
1:          * @exception SQLException if an error occurs
1:          */
1:         protected Connection newConnection_() throws SQLException {
0:             XADataSource ds = getXADataSource();
0:             XAConnection xac = ds.getXAConnection(CONFIG.getUserName(),
0:                                                   CONFIG.getUserPassword());
1:             return xac.getConnection();
1:         }
1:     }
1: }
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:4eeab6c
/////////////////////////////////////////////////////////////////////////
1:                 // DERBY-4767 - verification test for operation in XCL16 message.
1:                 String methodString=method.getName();
1:                 if (methodString.indexOf("(") > 1 )
1:                     methodString=methodString.substring(0, (methodString.length() -2));
0:                 assertTrue("method: " + methodString + ", but message: " + sqle.getMessage(), sqle.getMessage().indexOf(methodString) > 0); 
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:5c57294
/////////////////////////////////////////////////////////////////////////
1:         // JDBC 3 required for ConnectionPoolDataSource and XADataSource
1:         if (JDBC.vmSupportsJDBC3()) {
0:             
0:             TestSuite poolSuite = new TestSuite(
0:                     "ClosedObjectTest ConnectionPoolDataSource");
0:             PoolDataSourceDecorator poolDecorator =
0:                 new PoolDataSourceDecorator(poolSuite);
0:             topSuite.addTest(poolDecorator);
0:             fillDataSourceSuite(poolSuite, poolDecorator);
0:     
0:             TestSuite xaSuite = new TestSuite("ClosedObjectTest XA");
0:             XADataSourceDecorator xaDecorator = new XADataSourceDecorator(xaSuite);
0:             topSuite.addTest(xaDecorator);
0:             fillDataSourceSuite(xaSuite, xaDecorator);
/////////////////////////////////////////////////////////////////////////
0:              connection_ = newConnection();
commit:8ed08b2
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBCDataSource;
/////////////////////////////////////////////////////////////////////////
0:         suite.addTest(TestConfiguration.clientServerDecorator(
0:             baseSuite("ClosedObjectTest:client")));
/////////////////////////////////////////////////////////////////////////
1:             DataSource ds = JDBCDataSource.getDataSource();
1:             return ds.getConnection();
/////////////////////////////////////////////////////////////////////////
1:             ConnectionPoolDataSource ds = J2EEDataSource.getConnectionPoolDataSource();
1:                 ds.getPooledConnection();
/////////////////////////////////////////////////////////////////////////
1:             XADataSource ds = J2EEDataSource.getXADataSource();
1:             XAConnection xac = ds.getXAConnection();
commit:2f625cd
/////////////////////////////////////////////////////////////////////////
0:         TestSuite topSuite = new TestSuite("ClosedObjectTest suite");
0:         TestSuite dsSuite = new TestSuite("ClosedObjectTest DataSource");
0:         TestSuite poolSuite = new TestSuite(
0:                 "ClosedObjectTest ConnectionPoolDataSource");
0:         TestSuite xaSuite = new TestSuite("ClosedObjectTest XA");
commit:e0104e8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:             return ds.getConnection(TestConfiguration.getCurrent().getUserName(),
0:                     TestConfiguration.getCurrent().getUserPassword());
/////////////////////////////////////////////////////////////////////////
0:                 ds.getPooledConnection(TestConfiguration.getCurrent().getUserName(),
0:                         TestConfiguration.getCurrent().getUserPassword());
/////////////////////////////////////////////////////////////////////////
0:             XAConnection xac = ds.getXAConnection(TestConfiguration.getCurrent().getUserName(),
0:                     TestConfiguration.getCurrent().getUserPassword());
commit:3bd1dd8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
commit:29411ae
/////////////////////////////////////////////////////////////////////////
0:     public static Test suite()  {
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:David Van Couvering
-------------------------------------------------------------------------------
commit:0568a6c
/////////////////////////////////////////////////////////////////////////
1:             if (sqlState.equals("XJ012")) {
============================================================================