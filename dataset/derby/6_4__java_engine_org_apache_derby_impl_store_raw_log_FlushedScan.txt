1:eac0369: /*
1:345de35: 
1:345de35:    Derby - Class org.apache.derby.impl.store.raw.log.FlushedScan
1:345de35: 
1:270a34d:    Licensed to the Apache Software Foundation (ASF) under one or more
1:270a34d:    contributor license agreements.  See the NOTICE file distributed with
1:270a34d:    this work for additional information regarding copyright ownership.
1:270a34d:    The ASF licenses this file to you under the Apache License, Version 2.0
1:270a34d:    (the "License"); you may not use this file except in compliance with
1:270a34d:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
2:eac0369: 
2:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.impl.store.raw.log;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.reference.SQLState;
1:eac0369: import org.apache.derby.iapi.reference.MessageId;
1:eac0369: 
1:eac0369: import org.apache.derby.impl.store.raw.log.LogCounter;
1:eac0369: import org.apache.derby.impl.store.raw.log.LogRecord;
1:eac0369: import org.apache.derby.impl.store.raw.log.StreamLogScan;
1:eac0369: 
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.i18n.MessageService;
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogInstant;
1:eac0369: import org.apache.derby.iapi.store.raw.log.LogFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1:eac0369: import org.apache.derby.iapi.services.io.ArrayInputStream;
1:eac0369: 
1:eac0369: import org.apache.derby.io.StorageRandomAccessFile;
1:eac0369: 
1:eac0369: import java.io.IOException;
1:eac0369: 
2:eac0369: /**
1:eac0369: 
1:eac0369: 	Scan the the log which is implemented by a series of log files.n
1:eac0369: 	This log scan knows how to move across log file if it is positioned at
1:eac0369: 	the boundary of a log file and needs to getNextRecord.
1:eac0369: 
1:eac0369: 	<PRE>
1:eac0369: 	4 bytes - length of user data, i.e. N
1:eac0369: 	8 bytes - long representing log instant
1:eac0369: 	N bytes of supplied data
1:eac0369: 	4 bytes - length of user data, i.e. N
1:eac0369: 	</PRE>
1:eac0369: 
1:eac0369: */
1:eac0369: public class FlushedScan implements StreamLogScan {
1:eac0369: 
1:eac0369: 	private StorageRandomAccessFile scan;		// an output stream to the log file
1:eac0369: 	LogToFile logFactory; 				// log factory knows how to to skip
1:eac0369: 										// from log file to log file
1:eac0369: 
1:eac0369: 	boolean open;						// true if the scan is open
1:eac0369: 
1:eac0369: 	long currentLogFileNumber; 			// the log file the scan is currently on
1:eac0369: 
1:eac0369: 	long currentLogFileFirstUnflushedPosition;
1:eac0369: 	                                    // The length of the unflushed portion
1:eac0369: 										// of the current log file. This is the
1:eac0369: 										// length of the file for all but the
1:eac0369: 										// last log file.
1:eac0369: 
1:eac0369: 	long currentInstant;				// the log instant the scan is
1:eac0369: 										// currently on - only valid after a
1:eac0369: 										// successful getNextRecord
1:eac0369: 
1:eac0369: 	long firstUnflushed = -1;			// scan until we reach the first
1:eac0369: 										// unflushed byte in the log.
1:eac0369: 	long firstUnflushedFileNumber;
1:eac0369: 	long firstUnflushedFilePosition;
1:eac0369: 
1:eac0369: 	//RESOLVE: This belongs in a shared place.
1:eac0369: 	static final int LOG_REC_LEN_BYTE_LENGTH = 4;
1:eac0369: 
1:eac0369: 	public FlushedScan(LogToFile logFactory, long startAt)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:     		SanityManager.ASSERT(startAt != LogCounter.INVALID_LOG_INSTANT,
1:eac0369: 	    						 "cannot start scan on an invalid log instant");
1:eac0369: 	    }
1:eac0369: 
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			currentLogFileNumber = LogCounter.getLogFileNumber(startAt);
1:eac0369: 			this.logFactory = logFactory;
1:eac0369: 			scan =  logFactory.getLogFileAtPosition(startAt);
1:eac0369: 			setFirstUnflushed();
1:eac0369: 			open = true;
1:eac0369: 			currentInstant = LogCounter.INVALID_LOG_INSTANT; // set at getNextRecord
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                     StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	** Methods of LogScan
1:eac0369: 	*/
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Read a log record into the byte array provided.  Resize the input
1:eac0369: 		stream byte array if necessary.
1:eac0369: 
1:eac0369: 		@return the length of the data written into data, or -1 if the end of the
1:eac0369: 		scan has been reached.
1:eac0369: 
1:94f158a: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	public LogRecord getNextRecord(ArrayInputStream input, 
1:eac0369: 								   TransactionId tranId, 
1:eac0369: 								   int groupmask)
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			boolean candidate;
1:eac0369: 			int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
1:eac0369: 			if (tranId != null)
1:eac0369: 				peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);
1:eac0369: 			int readAmount;		// the number of bytes actually read
1:eac0369: 
1:eac0369: 			LogRecord lr;
1:eac0369: 
1:eac0369: 			do
1:eac0369: 			{
1:eac0369: 				if (!open || !positionToNextRecord()) 
1:eac0369: 					return null;
1:eac0369: 
1:eac0369: 				int checkLength;
1:eac0369: 
1:eac0369: 				// this log record is a candidate unless proven otherwise
1:eac0369: 				lr = null;
1:eac0369: 				candidate = true;
1:eac0369: 				readAmount = -1;
1:eac0369: 
1:eac0369: 				currentInstant = scan.readLong();
1:eac0369: 				byte[] data = input.getData();
1:eac0369: 				if (data.length < nextRecordLength)
1:eac0369: 				{
1:eac0369: 					// make a new array of sufficient size and reset the arrary
1:eac0369: 					// in the input stream
1:eac0369: 					data = new byte[nextRecordLength];
1:eac0369: 					input.setData(data);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (logFactory.databaseEncrypted())
1:eac0369: 				{
1:eac0369: 					scan.readFully(data, 0, nextRecordLength);
1:eac0369: 					int len = logFactory.decrypt(data, 0, nextRecordLength, data, 0);
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 						SanityManager.ASSERT(len == nextRecordLength);
1:eac0369: 					input.setLimit(0, len);
1:eac0369: 
1:eac0369: 				}
1:eac0369: 				else // no need to decrypt, only get the group and tid if we filter 
1:eac0369: 				{
1:eac0369: 					if (groupmask == 0 && tranId == null)
1:eac0369: 					{
1:eac0369: 						// no filter, get the whole thing
1:eac0369: 						scan.readFully(data, 0, nextRecordLength);
1:eac0369: 						input.setLimit(0, nextRecordLength);
1:eac0369: 					}
1:eac0369: 					else
1:eac0369: 					{
1:eac0369: 						// Read only enough so that group and the tran id is in
1:eac0369: 						// the data buffer.  Group is stored as compressed int
1:eac0369: 						// and tran id is stored as who knows what.  read min
1:eac0369: 						// of peekAmount or nextRecordLength
1:eac0369: 						readAmount = (nextRecordLength > peekAmount) ?
1:eac0369: 							peekAmount : nextRecordLength; 
1:eac0369: 
1:eac0369: 						// in the data buffer, we now have enough to peek
1:eac0369: 						scan.readFully(data, 0, readAmount);
1:eac0369: 						input.setLimit(0, readAmount);
1:eac0369: 
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				lr = (LogRecord) input.readObject();
1:eac0369: 
1:eac0369: 				if (groupmask != 0 || tranId != null)
1:eac0369: 				{
1:eac0369: 					if (groupmask != 0 && (groupmask & lr.group()) == 0)
1:eac0369: 						candidate = false; // no match, throw this log record out 
1:eac0369: 
1:eac0369: 					if (candidate && tranId != null)
1:eac0369: 					{
1:eac0369: 						TransactionId tid = lr.getTransactionId();
1:eac0369: 						if (!tid.equals(tranId)) // nomatch
1:eac0369: 							candidate = false; // throw this log record out
1:eac0369: 					}
1:eac0369: 
1:eac0369: 					// if this log record is not filtered out, we need to read
1:eac0369: 					// in the rest of the log record to the input buffer.
1:eac0369: 					// Except if it is an encrypted database, in which case the
1:eac0369: 					// entire log record have already be read in for
1:eac0369: 					// decryption.
1:eac0369: 
1:eac0369: 					if (candidate && !logFactory.databaseEncrypted())
1:eac0369: 					{
1:eac0369: 						// read the rest of the log into the buffer
1:eac0369: 						if (SanityManager.DEBUG)
1:eac0369: 							SanityManager.ASSERT(readAmount > 0);
1:eac0369: 
1:eac0369: 						if (readAmount < nextRecordLength)
1:eac0369: 						{
1:eac0369: 							// Need to remember where we are because the log
1:eac0369: 							// record may have read part of it off the input
1:eac0369: 							// stream already and that position is lost when we
1:eac0369: 							// set limit again.
1:eac0369: 							int inputPosition = input.getPosition();
1:eac0369: 
1:eac0369: 							scan.readFully(data, readAmount,
1:eac0369: 										   nextRecordLength-readAmount); 
1:eac0369: 
1:eac0369: 							input.setLimit(0, nextRecordLength);
1:eac0369: 							input.setPosition(inputPosition);
1:eac0369: 						}
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 
1:eac0369: 				if (candidate || logFactory.databaseEncrypted())
1:eac0369: 				{
1:eac0369: 					checkLength = scan.readInt();
1:eac0369: 
1:eac0369: 					if (SanityManager.DEBUG)
1:eac0369: 					{
1:eac0369: 						SanityManager.ASSERT(checkLength == nextRecordLength, "log currupted");
1:eac0369: 					}
1:eac0369: 				}
1:eac0369: 				else // chances are, we haven't read all of the log record, skip it
1:eac0369: 				{
1:eac0369: 					// the starting record position is in the currentInstant,
1:eac0369: 					// calculate the next record starting position using that
1:eac0369: 					// and the nextRecordLength
1:eac0369: 					long nextRecordStartPosition =
1:eac0369: 						LogCounter.getLogFilePosition(currentInstant) +
1:eac0369: 						nextRecordLength + LogToFile.LOG_RECORD_OVERHEAD;
1:eac0369: 
1:eac0369: 					scan.seek(nextRecordStartPosition);
1:eac0369: 				}
1:eac0369: 
1:eac0369: 			} while (candidate == false);
1:eac0369: 
1:eac0369: 			return lr;
1:eac0369: 		}
1:eac0369: 		catch (ClassNotFoundException cnfe)
1:eac0369: 		{
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
1:eac0369: 		}
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Reset the scan to the given LogInstant.
1:eac0369: 
1:eac0369: 		@param instant the position to reset to
1:eac0369: 		@exception IOException scan cannot access the log at the new position.
1:eac0369: 	*/
1:eac0369: 	public void resetPosition(LogInstant instant) throws IOException
1:eac0369: 	{
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:     		SanityManager.THROWASSERT("Unsupported feature");
1:eac0369:     	}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get the log instant that is right after the record just retrived
1:eac0369: 		@return INVALID_LOG_INSTANT if this is not a FORWARD scan or, no
1:eac0369: 		record have been returned yet or the scan has completed.
1:eac0369: 	*/
1:eac0369: 	public long getLogRecordEnd()
1:eac0369: 	{
1:eac0369:         if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:     		SanityManager.THROWASSERT("Unsupported feature");
1:eac0369:     	}
1:eac0369: 		return LogCounter.INVALID_LOG_INSTANT;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	
1:eac0369: 	/**
1:eac0369: 	   returns true if there is partially writen log records before the crash 
1:eac0369: 	   in the last log file. Partiall wrires are identified during forward 
1:eac0369: 	   scans for log recovery.
1:eac0369: 	 */
1:eac0369: 	public boolean isLogEndFuzzy()
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369:         {
1:eac0369:     		SanityManager.THROWASSERT("Unsupported feature");
1:eac0369:     	}
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the log instant (as an integer) the scan is currently on - this is the log
1:eac0369: 		instant of the log record that was returned by getNextRecord.
1:eac0369: 	*/
1:eac0369: 	public long getInstant()
1:eac0369: 	{
1:eac0369: 		return currentInstant;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Return the log instant the scan is currently on - this is the log
1:eac0369: 		instant of the log record that was returned by getNextRecord.
1:eac0369: 	*/
1:eac0369: 	public LogInstant getLogInstant()
1:eac0369: 	{
1:eac0369: 		if (currentInstant == LogCounter.INVALID_LOG_INSTANT)
1:eac0369: 			return null;
1:eac0369: 		else
1:eac0369: 			return new LogCounter(currentInstant);
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Close the scan.
1:eac0369: 	*/
1:eac0369: 	public void close()
1:eac0369: 	{
1:eac0369: 		if (scan != null)
1:eac0369: 		{
1:eac0369: 			try
1:eac0369: 			{
1:eac0369: 				scan.close();
1:eac0369: 			}
1:eac0369: 			catch (IOException ioe)
1:eac0369: 			{}
1:eac0369: 
1:eac0369: 			scan = null;
1:eac0369: 		}
1:eac0369: 		currentInstant = LogCounter.INVALID_LOG_INSTANT;
1:eac0369: 		open = false;
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	  Private methods.
1:eac0369: 	  */
1:eac0369: 	private void setFirstUnflushed()
1:eac0369: 		 throws StandardException, IOException
1:eac0369: 	{
1:eac0369: 		LogInstant firstUnflushedInstant =
1:eac0369: 			logFactory.getFirstUnflushedInstant();
1:eac0369: 		firstUnflushed = ((LogCounter)firstUnflushedInstant).getValueAsLong();
1:eac0369: 		firstUnflushedFileNumber = LogCounter.getLogFileNumber(firstUnflushed);
1:eac0369: 		firstUnflushedFilePosition = LogCounter.getLogFilePosition(firstUnflushed);
1:eac0369: 
1:eac0369: 		setCurrentLogFileFirstUnflushedPosition();
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void setCurrentLogFileFirstUnflushedPosition()
1:eac0369: 		 throws IOException
1:eac0369: 	{
1:eac0369: 		/*
1:eac0369: 		  Note we get the currentLogFileLength without synchronization.
1:eac0369: 		  This is safe because one of the following cases apply:
1:eac0369: 
1:eac0369: 		  <OL>
1:eac0369: 		  <LI> The end of the flushed section of the log is in another file.
1:eac0369: 		  In this case the end of the current file will not change.
1:eac0369: 		  <LI> The end of the log is in this file. In this case we
1:eac0369: 		  end our scan at the firstUnflushedInstant and do not use
1:eac0369: 		  currentLogFileLength.
1:eac0369: 		  </OL>
1:eac0369: 		  */
1:eac0369: 		if (currentLogFileNumber == firstUnflushedFileNumber)
1:eac0369: 			currentLogFileFirstUnflushedPosition = firstUnflushedFilePosition;
1:eac0369: 		else if (currentLogFileNumber < firstUnflushedFileNumber)
1:eac0369: 			currentLogFileFirstUnflushedPosition = scan.length();
1:eac0369: 		else
1:eac0369:         {
1:eac0369: 			// RESOLVE 
1:eac0369: 		   	throw new IOException(
1:eac0369:                 MessageService.getTextMessage(MessageId.LOG_BAD_START_INSTANT));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private void switchLogFile()
1:eac0369: 		 throws StandardException
1:eac0369: 	{
1:eac0369: 		try
1:eac0369: 		{
1:eac0369: 			readNextRecordLength = false;
1:eac0369: 			scan.close();
1:eac0369: 			scan = null;
1:eac0369: 			scan = logFactory.getLogFileAtBeginning(++currentLogFileNumber);
1:eac0369: 			setCurrentLogFileFirstUnflushedPosition();
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		catch (IOException ioe)
1:eac0369: 		{
1:eac0369: 			throw logFactory.markCorrupt(
1:eac0369:                 StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  The length of the next record. Read from scan and set by
1:eac0369: 	  currentLogFileHasUnflushedRecord. This is used to retain the length of a
1:eac0369: 	  log record in the case currentLogFileHasUnflushedRecord reads the length
1:eac0369: 	  and determines that some bytes in the log record are not yet flushed.
1:eac0369: 	  */
1:eac0369: 	int nextRecordLength;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	  Flag to indicate that the length of the next log record has been read by
1:eac0369: 	  currentLogFileHasUnflushedRecord.
1:eac0369: 
1:eac0369: 	  This flag gets reset in two ways:
1:eac0369: 
1:eac0369: 	  <OL>
1:eac0369: 	  <LI> currentLogFileHasUnflushedRecord determines that the entire log
1:eac0369: 	  record is flushed and returns true. In this case getNextRecord reads and
1:eac0369: 	  returns the log record.
1:eac0369: 	  <LI> we switch log files --due to a partial log record at the end of an
1:eac0369: 	  old log file.
1:eac0369: 	  </OL>
1:eac0369: 	  */
1:eac0369: 	boolean readNextRecordLength;
1:eac0369: 
1:eac0369: 	private boolean currentLogFileHasUnflushedRecord()
1:eac0369: 		 throws IOException
1:eac0369: 	{
1:eac0369: 		if (SanityManager.DEBUG)
1:eac0369: 			SanityManager.ASSERT(scan != null, "scan is null");
1:eac0369: 		long curPos = scan.getFilePointer();
1:eac0369: 
1:eac0369: 		if (!readNextRecordLength)
1:eac0369: 		{
1:eac0369: 			if (curPos + LOG_REC_LEN_BYTE_LENGTH >
1:eac0369: 				                 currentLogFileFirstUnflushedPosition)
1:eac0369: 				return false;
1:eac0369: 
1:eac0369: 			nextRecordLength = scan.readInt();
1:eac0369: 			curPos+=4;
1:eac0369: 			readNextRecordLength = true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		if (nextRecordLength==0) return false;
1:eac0369: 
1:eac0369: 		int bytesNeeded =
1:eac0369: 			nextRecordLength + LOG_REC_LEN_BYTE_LENGTH;
1:eac0369: 
1:eac0369: 		if (curPos + bytesNeeded > currentLogFileFirstUnflushedPosition)
1:eac0369: 		{
1:eac0369: 			return false;
1:eac0369: 		}
1:eac0369: 		else
1:eac0369: 		{
1:eac0369: 			readNextRecordLength = false;
1:eac0369: 			return true;
1:eac0369: 		}
1:eac0369: 	}
1:eac0369: 
1:eac0369: 	private boolean positionToNextRecord()
1:eac0369: 		 throws StandardException, IOException
1:eac0369: 	{
1:eac0369: 		//If the flushed section of the current log file contains our record we
1:eac0369: 		//simply return.
1:eac0369: 		if (currentLogFileHasUnflushedRecord()) return true;
1:eac0369: 
1:eac0369: 		//Update our cached copy of the first unflushed instant.
1:eac0369: 		setFirstUnflushed();
1:eac0369: 
1:eac0369: 		//In the call to setFirstUnflushed, we may have noticed that the current
1:eac0369: 		//log file really does contain our record. If so we simply return.
1:eac0369: 		if (currentLogFileHasUnflushedRecord()) return true;
1:eac0369: 
1:eac0369: 		//Our final chance of finding a record is if we are not scanning the log
1:eac0369: 		//file with the last flushed instant we can switch logfiles. Note that
1:eac0369: 		//we do this in a loop to cope with empty log files.
1:eac0369: 		while(currentLogFileNumber < firstUnflushedFileNumber)
1:eac0369: 		{
1:eac0369: 			  switchLogFile();
1:eac0369: 		      if (currentLogFileHasUnflushedRecord()) return true;
1:eac0369: 		}
1:eac0369: 
1:eac0369: 		//The log contains no more flushed log records so we return false.
1:eac0369: 		currentInstant = LogCounter.INVALID_LOG_INSTANT;
1:eac0369: 		return false;
1:eac0369: 	}
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:94f158a
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:270a34d
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.impl.store.raw.log.FlushedScan
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:1f9b9c4
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.log
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.impl.store.raw.log;
1: 
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.reference.MessageId;
1: 
1: import org.apache.derby.impl.store.raw.log.LogCounter;
1: import org.apache.derby.impl.store.raw.log.LogRecord;
1: import org.apache.derby.impl.store.raw.log.StreamLogScan;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.i18n.MessageService;
1: import org.apache.derby.iapi.store.raw.log.LogInstant;
1: import org.apache.derby.iapi.store.raw.log.LogFactory;
1: import org.apache.derby.iapi.store.raw.xact.TransactionId;
1: import org.apache.derby.iapi.services.io.ArrayInputStream;
1: 
1: import org.apache.derby.io.StorageRandomAccessFile;
1: 
1: import java.io.IOException;
1: 
1: /**
1: 
1: 	Scan the the log which is implemented by a series of log files.n
1: 	This log scan knows how to move across log file if it is positioned at
1: 	the boundary of a log file and needs to getNextRecord.
1: 
1: 	<PRE>
1: 	4 bytes - length of user data, i.e. N
1: 	8 bytes - long representing log instant
1: 	N bytes of supplied data
1: 	4 bytes - length of user data, i.e. N
1: 	</PRE>
1: 
1: */
1: public class FlushedScan implements StreamLogScan {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	private StorageRandomAccessFile scan;		// an output stream to the log file
1: 	LogToFile logFactory; 				// log factory knows how to to skip
1: 										// from log file to log file
1: 
1: 	boolean open;						// true if the scan is open
1: 
1: 	long currentLogFileNumber; 			// the log file the scan is currently on
1: 
1: 	long currentLogFileFirstUnflushedPosition;
1: 	                                    // The length of the unflushed portion
1: 										// of the current log file. This is the
1: 										// length of the file for all but the
1: 										// last log file.
1: 
1: 	long currentInstant;				// the log instant the scan is
1: 										// currently on - only valid after a
1: 										// successful getNextRecord
1: 
1: 	long firstUnflushed = -1;			// scan until we reach the first
1: 										// unflushed byte in the log.
1: 	long firstUnflushedFileNumber;
1: 	long firstUnflushedFilePosition;
1: 
1: 	//RESOLVE: This belongs in a shared place.
1: 	static final int LOG_REC_LEN_BYTE_LENGTH = 4;
1: 
1: 	public FlushedScan(LogToFile logFactory, long startAt)
1: 		 throws StandardException
1: 	{
1:         if (SanityManager.DEBUG)
1:         {
1:     		SanityManager.ASSERT(startAt != LogCounter.INVALID_LOG_INSTANT,
1: 	    						 "cannot start scan on an invalid log instant");
1: 	    }
1: 
1: 		try
1: 		{
1: 			currentLogFileNumber = LogCounter.getLogFileNumber(startAt);
1: 			this.logFactory = logFactory;
1: 			scan =  logFactory.getLogFileAtPosition(startAt);
1: 			setFirstUnflushed();
1: 			open = true;
1: 			currentInstant = LogCounter.INVALID_LOG_INSTANT; // set at getNextRecord
1: 		}
1: 
1: 		catch (IOException ioe)
1: 		{
1: 			throw logFactory.markCorrupt(
1:                     StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
1: 		}
1: 	}
1: 
1: 	/*
1: 	** Methods of LogScan
1: 	*/
1: 
1: 	/**
1: 		Read a log record into the byte array provided.  Resize the input
1: 		stream byte array if necessary.
1: 
1: 		@return the length of the data written into data, or -1 if the end of the
1: 		scan has been reached.
1: 
0: 		@exception StandardException Standard Cloudscape error policy
1: 	*/
1: 	public LogRecord getNextRecord(ArrayInputStream input, 
1: 								   TransactionId tranId, 
1: 								   int groupmask)
1: 		 throws StandardException
1: 	{
1: 		try
1: 		{
1: 			boolean candidate;
1: 			int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
1: 			if (tranId != null)
1: 				peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);
1: 			int readAmount;		// the number of bytes actually read
1: 
1: 			LogRecord lr;
1: 
1: 			do
1: 			{
1: 				if (!open || !positionToNextRecord()) 
1: 					return null;
1: 
1: 				int checkLength;
1: 
1: 				// this log record is a candidate unless proven otherwise
1: 				lr = null;
1: 				candidate = true;
1: 				readAmount = -1;
1: 
1: 				currentInstant = scan.readLong();
1: 				byte[] data = input.getData();
1: 				if (data.length < nextRecordLength)
1: 				{
1: 					// make a new array of sufficient size and reset the arrary
1: 					// in the input stream
1: 					data = new byte[nextRecordLength];
1: 					input.setData(data);
1: 				}
1: 
1: 				if (logFactory.databaseEncrypted())
1: 				{
1: 					scan.readFully(data, 0, nextRecordLength);
1: 					int len = logFactory.decrypt(data, 0, nextRecordLength, data, 0);
1: 					if (SanityManager.DEBUG)
1: 						SanityManager.ASSERT(len == nextRecordLength);
1: 					input.setLimit(0, len);
1: 
1: 				}
1: 				else // no need to decrypt, only get the group and tid if we filter 
1: 				{
1: 					if (groupmask == 0 && tranId == null)
1: 					{
1: 						// no filter, get the whole thing
1: 						scan.readFully(data, 0, nextRecordLength);
1: 						input.setLimit(0, nextRecordLength);
1: 					}
1: 					else
1: 					{
1: 						// Read only enough so that group and the tran id is in
1: 						// the data buffer.  Group is stored as compressed int
1: 						// and tran id is stored as who knows what.  read min
1: 						// of peekAmount or nextRecordLength
1: 						readAmount = (nextRecordLength > peekAmount) ?
1: 							peekAmount : nextRecordLength; 
1: 
1: 						// in the data buffer, we now have enough to peek
1: 						scan.readFully(data, 0, readAmount);
1: 						input.setLimit(0, readAmount);
1: 
1: 					}
1: 				}
1: 
1: 				lr = (LogRecord) input.readObject();
1: 
1: 				if (groupmask != 0 || tranId != null)
1: 				{
1: 					if (groupmask != 0 && (groupmask & lr.group()) == 0)
1: 						candidate = false; // no match, throw this log record out 
1: 
1: 					if (candidate && tranId != null)
1: 					{
1: 						TransactionId tid = lr.getTransactionId();
1: 						if (!tid.equals(tranId)) // nomatch
1: 							candidate = false; // throw this log record out
1: 					}
1: 
1: 					// if this log record is not filtered out, we need to read
1: 					// in the rest of the log record to the input buffer.
1: 					// Except if it is an encrypted database, in which case the
1: 					// entire log record have already be read in for
1: 					// decryption.
1: 
1: 					if (candidate && !logFactory.databaseEncrypted())
1: 					{
1: 						// read the rest of the log into the buffer
1: 						if (SanityManager.DEBUG)
1: 							SanityManager.ASSERT(readAmount > 0);
1: 
1: 						if (readAmount < nextRecordLength)
1: 						{
1: 							// Need to remember where we are because the log
1: 							// record may have read part of it off the input
1: 							// stream already and that position is lost when we
1: 							// set limit again.
1: 							int inputPosition = input.getPosition();
1: 
1: 							scan.readFully(data, readAmount,
1: 										   nextRecordLength-readAmount); 
1: 
1: 							input.setLimit(0, nextRecordLength);
1: 							input.setPosition(inputPosition);
1: 						}
1: 					}
1: 				}
1: 
1: 				if (candidate || logFactory.databaseEncrypted())
1: 				{
1: 					checkLength = scan.readInt();
1: 
1: 					if (SanityManager.DEBUG)
1: 					{
1: 						SanityManager.ASSERT(checkLength == nextRecordLength, "log currupted");
1: 					}
1: 				}
1: 				else // chances are, we haven't read all of the log record, skip it
1: 				{
1: 					// the starting record position is in the currentInstant,
1: 					// calculate the next record starting position using that
1: 					// and the nextRecordLength
1: 					long nextRecordStartPosition =
1: 						LogCounter.getLogFilePosition(currentInstant) +
1: 						nextRecordLength + LogToFile.LOG_RECORD_OVERHEAD;
1: 
1: 					scan.seek(nextRecordStartPosition);
1: 				}
1: 
1: 			} while (candidate == false);
1: 
1: 			return lr;
1: 		}
1: 		catch (ClassNotFoundException cnfe)
1: 		{
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
1: 		}
1: 		catch (IOException ioe)
1: 		{
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
1: 		}
1: 	}
1: 
1: 	/**
1: 		Reset the scan to the given LogInstant.
1: 
1: 		@param instant the position to reset to
1: 		@exception IOException scan cannot access the log at the new position.
1: 	*/
1: 	public void resetPosition(LogInstant instant) throws IOException
1: 	{
1:         if (SanityManager.DEBUG)
1:         {
1:     		SanityManager.THROWASSERT("Unsupported feature");
1:     	}
1: 	}
1: 
1: 	/**
1: 		Get the log instant that is right after the record just retrived
1: 		@return INVALID_LOG_INSTANT if this is not a FORWARD scan or, no
1: 		record have been returned yet or the scan has completed.
1: 	*/
1: 	public long getLogRecordEnd()
1: 	{
1:         if (SanityManager.DEBUG)
1:         {
1:     		SanityManager.THROWASSERT("Unsupported feature");
1:     	}
1: 		return LogCounter.INVALID_LOG_INSTANT;
1: 	}
1: 
1: 	
1: 	/**
1: 	   returns true if there is partially writen log records before the crash 
1: 	   in the last log file. Partiall wrires are identified during forward 
1: 	   scans for log recovery.
1: 	 */
1: 	public boolean isLogEndFuzzy()
1: 	{
1: 		if (SanityManager.DEBUG)
1:         {
1:     		SanityManager.THROWASSERT("Unsupported feature");
1:     	}
1: 		return false;
1: 	}
1: 
1: 	/**
1: 		Return the log instant (as an integer) the scan is currently on - this is the log
1: 		instant of the log record that was returned by getNextRecord.
1: 	*/
1: 	public long getInstant()
1: 	{
1: 		return currentInstant;
1: 	}
1: 
1: 	/**
1: 		Return the log instant the scan is currently on - this is the log
1: 		instant of the log record that was returned by getNextRecord.
1: 	*/
1: 	public LogInstant getLogInstant()
1: 	{
1: 		if (currentInstant == LogCounter.INVALID_LOG_INSTANT)
1: 			return null;
1: 		else
1: 			return new LogCounter(currentInstant);
1: 	}
1: 
1: 	/**
1: 		Close the scan.
1: 	*/
1: 	public void close()
1: 	{
1: 		if (scan != null)
1: 		{
1: 			try
1: 			{
1: 				scan.close();
1: 			}
1: 			catch (IOException ioe)
1: 			{}
1: 
1: 			scan = null;
1: 		}
1: 		currentInstant = LogCounter.INVALID_LOG_INSTANT;
1: 		open = false;
1: 	}
1: 
1: 	/*
1: 	  Private methods.
1: 	  */
1: 	private void setFirstUnflushed()
1: 		 throws StandardException, IOException
1: 	{
1: 		LogInstant firstUnflushedInstant =
1: 			logFactory.getFirstUnflushedInstant();
1: 		firstUnflushed = ((LogCounter)firstUnflushedInstant).getValueAsLong();
1: 		firstUnflushedFileNumber = LogCounter.getLogFileNumber(firstUnflushed);
1: 		firstUnflushedFilePosition = LogCounter.getLogFilePosition(firstUnflushed);
1: 
1: 		setCurrentLogFileFirstUnflushedPosition();
1: 	}
1: 
1: 	private void setCurrentLogFileFirstUnflushedPosition()
1: 		 throws IOException
1: 	{
1: 		/*
1: 		  Note we get the currentLogFileLength without synchronization.
1: 		  This is safe because one of the following cases apply:
1: 
1: 		  <OL>
1: 		  <LI> The end of the flushed section of the log is in another file.
1: 		  In this case the end of the current file will not change.
1: 		  <LI> The end of the log is in this file. In this case we
1: 		  end our scan at the firstUnflushedInstant and do not use
1: 		  currentLogFileLength.
1: 		  </OL>
1: 		  */
1: 		if (currentLogFileNumber == firstUnflushedFileNumber)
1: 			currentLogFileFirstUnflushedPosition = firstUnflushedFilePosition;
1: 		else if (currentLogFileNumber < firstUnflushedFileNumber)
1: 			currentLogFileFirstUnflushedPosition = scan.length();
1: 		else
1:         {
1: 			// RESOLVE 
1: 		   	throw new IOException(
1:                 MessageService.getTextMessage(MessageId.LOG_BAD_START_INSTANT));
1: 		}
1: 	}
1: 
1: 	private void switchLogFile()
1: 		 throws StandardException
1: 	{
1: 		try
1: 		{
1: 			readNextRecordLength = false;
1: 			scan.close();
1: 			scan = null;
1: 			scan = logFactory.getLogFileAtBeginning(++currentLogFileNumber);
1: 			setCurrentLogFileFirstUnflushedPosition();
1: 		}
1: 
1: 		catch (IOException ioe)
1: 		{
1: 			throw logFactory.markCorrupt(
1:                 StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
1: 		}
1: 	}
1: 
1: 	/**
1: 	  The length of the next record. Read from scan and set by
1: 	  currentLogFileHasUnflushedRecord. This is used to retain the length of a
1: 	  log record in the case currentLogFileHasUnflushedRecord reads the length
1: 	  and determines that some bytes in the log record are not yet flushed.
1: 	  */
1: 	int nextRecordLength;
1: 
1: 	/**
1: 	  Flag to indicate that the length of the next log record has been read by
1: 	  currentLogFileHasUnflushedRecord.
1: 
1: 	  This flag gets reset in two ways:
1: 
1: 	  <OL>
1: 	  <LI> currentLogFileHasUnflushedRecord determines that the entire log
1: 	  record is flushed and returns true. In this case getNextRecord reads and
1: 	  returns the log record.
1: 	  <LI> we switch log files --due to a partial log record at the end of an
1: 	  old log file.
1: 	  </OL>
1: 	  */
1: 	boolean readNextRecordLength;
1: 
1: 	private boolean currentLogFileHasUnflushedRecord()
1: 		 throws IOException
1: 	{
1: 		if (SanityManager.DEBUG)
1: 			SanityManager.ASSERT(scan != null, "scan is null");
1: 		long curPos = scan.getFilePointer();
1: 
1: 		if (!readNextRecordLength)
1: 		{
1: 			if (curPos + LOG_REC_LEN_BYTE_LENGTH >
1: 				                 currentLogFileFirstUnflushedPosition)
1: 				return false;
1: 
1: 			nextRecordLength = scan.readInt();
1: 			curPos+=4;
1: 			readNextRecordLength = true;
1: 		}
1: 
1: 		if (nextRecordLength==0) return false;
1: 
1: 		int bytesNeeded =
1: 			nextRecordLength + LOG_REC_LEN_BYTE_LENGTH;
1: 
1: 		if (curPos + bytesNeeded > currentLogFileFirstUnflushedPosition)
1: 		{
1: 			return false;
1: 		}
1: 		else
1: 		{
1: 			readNextRecordLength = false;
1: 			return true;
1: 		}
1: 	}
1: 
1: 	private boolean positionToNextRecord()
1: 		 throws StandardException, IOException
1: 	{
1: 		//If the flushed section of the current log file contains our record we
1: 		//simply return.
1: 		if (currentLogFileHasUnflushedRecord()) return true;
1: 
1: 		//Update our cached copy of the first unflushed instant.
1: 		setFirstUnflushed();
1: 
1: 		//In the call to setFirstUnflushed, we may have noticed that the current
1: 		//log file really does contain our record. If so we simply return.
1: 		if (currentLogFileHasUnflushedRecord()) return true;
1: 
1: 		//Our final chance of finding a record is if we are not scanning the log
1: 		//file with the last flushed instant we can switch logfiles. Note that
1: 		//we do this in a loop to cope with empty log files.
1: 		while(currentLogFileNumber < firstUnflushedFileNumber)
1: 		{
1: 			  switchLogFile();
1: 		      if (currentLogFileHasUnflushedRecord()) return true;
1: 		}
1: 
1: 		//The log contains no more flushed log records so we return false.
1: 		currentInstant = LogCounter.INVALID_LOG_INSTANT;
1: 		return false;
1: 	}
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.impl.store.raw.log
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.impl.store.raw.log;
0: 
0: import org.apache.derby.iapi.reference.SQLState;
0: import org.apache.derby.iapi.reference.MessageId;
0: 
0: import org.apache.derby.impl.store.raw.log.LogCounter;
0: import org.apache.derby.impl.store.raw.log.LogRecord;
0: import org.apache.derby.impl.store.raw.log.StreamLogScan;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.store.raw.log.LogInstant;
0: import org.apache.derby.iapi.store.raw.log.LogFactory;
0: import org.apache.derby.iapi.store.raw.xact.TransactionId;
0: import org.apache.derby.iapi.services.io.ArrayInputStream;
0: 
0: import org.apache.derby.io.StorageRandomAccessFile;
0: 
0: import java.io.IOException;
0: 
0: /**
0: 
0: 	Scan the the log which is implemented by a series of log files.n
0: 	This log scan knows how to move across log file if it is positioned at
0: 	the boundary of a log file and needs to getNextRecord.
0: 
0: 	<PRE>
0: 	4 bytes - length of user data, i.e. N
0: 	8 bytes - long representing log instant
0: 	N bytes of supplied data
0: 	4 bytes - length of user data, i.e. N
0: 	</PRE>
0: 
0: */
0: public class FlushedScan implements StreamLogScan {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	private StorageRandomAccessFile scan;		// an output stream to the log file
0: 	LogToFile logFactory; 				// log factory knows how to to skip
0: 										// from log file to log file
0: 
0: 	boolean open;						// true if the scan is open
0: 
0: 	long currentLogFileNumber; 			// the log file the scan is currently on
0: 
0: 	long currentLogFileFirstUnflushedPosition;
0: 	                                    // The length of the unflushed portion
0: 										// of the current log file. This is the
0: 										// length of the file for all but the
0: 										// last log file.
0: 
0: 	long currentInstant;				// the log instant the scan is
0: 										// currently on - only valid after a
0: 										// successful getNextRecord
0: 
0: 	long firstUnflushed = -1;			// scan until we reach the first
0: 										// unflushed byte in the log.
0: 	long firstUnflushedFileNumber;
0: 	long firstUnflushedFilePosition;
0: 
0: 	//RESOLVE: This belongs in a shared place.
0: 	static final int LOG_REC_LEN_BYTE_LENGTH = 4;
0: 
0: 	public FlushedScan(LogToFile logFactory, long startAt)
0: 		 throws StandardException
0: 	{
0:         if (SanityManager.DEBUG)
0:         {
0:     		SanityManager.ASSERT(startAt != LogCounter.INVALID_LOG_INSTANT,
0: 	    						 "cannot start scan on an invalid log instant");
0: 	    }
0: 
0: 		try
0: 		{
0: 			currentLogFileNumber = LogCounter.getLogFileNumber(startAt);
0: 			this.logFactory = logFactory;
0: 			scan =  logFactory.getLogFileAtPosition(startAt);
0: 			setFirstUnflushed();
0: 			open = true;
0: 			currentInstant = LogCounter.INVALID_LOG_INSTANT; // set at getNextRecord
0: 		}
0: 
0: 		catch (IOException ioe)
0: 		{
0: 			throw logFactory.markCorrupt(
0:                     StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
0: 		}
0: 	}
0: 
0: 	/*
0: 	** Methods of LogScan
0: 	*/
0: 
0: 	/**
0: 		Read a log record into the byte array provided.  Resize the input
0: 		stream byte array if necessary.
0: 
0: 		@return the length of the data written into data, or -1 if the end of the
0: 		scan has been reached.
0: 
0: 		@exception StandardException Standard Cloudscape error policy
0: 	*/
0: 	public LogRecord getNextRecord(ArrayInputStream input, 
0: 								   TransactionId tranId, 
0: 								   int groupmask)
0: 		 throws StandardException
0: 	{
0: 		try
0: 		{
0: 			boolean candidate;
0: 			int peekAmount = LogRecord.formatOverhead() + LogRecord.maxGroupStoredSize();
0: 			if (tranId != null)
0: 				peekAmount += LogRecord.maxTransactionIdStoredSize(tranId);
0: 			int readAmount;		// the number of bytes actually read
0: 
0: 			LogRecord lr;
0: 
0: 			do
0: 			{
0: 				if (!open || !positionToNextRecord()) 
0: 					return null;
0: 
0: 				int checkLength;
0: 
0: 				// this log record is a candidate unless proven otherwise
0: 				lr = null;
0: 				candidate = true;
0: 				readAmount = -1;
0: 
0: 				currentInstant = scan.readLong();
0: 				byte[] data = input.getData();
0: 				if (data.length < nextRecordLength)
0: 				{
0: 					// make a new array of sufficient size and reset the arrary
0: 					// in the input stream
0: 					data = new byte[nextRecordLength];
0: 					input.setData(data);
0: 				}
0: 
0: 				if (logFactory.databaseEncrypted())
0: 				{
0: 					scan.readFully(data, 0, nextRecordLength);
0: 					int len = logFactory.decrypt(data, 0, nextRecordLength, data, 0);
0: 					if (SanityManager.DEBUG)
0: 						SanityManager.ASSERT(len == nextRecordLength);
0: 					input.setLimit(0, len);
0: 
0: 				}
0: 				else // no need to decrypt, only get the group and tid if we filter 
0: 				{
0: 					if (groupmask == 0 && tranId == null)
0: 					{
0: 						// no filter, get the whole thing
0: 						scan.readFully(data, 0, nextRecordLength);
0: 						input.setLimit(0, nextRecordLength);
0: 					}
0: 					else
0: 					{
0: 						// Read only enough so that group and the tran id is in
0: 						// the data buffer.  Group is stored as compressed int
0: 						// and tran id is stored as who knows what.  read min
0: 						// of peekAmount or nextRecordLength
0: 						readAmount = (nextRecordLength > peekAmount) ?
0: 							peekAmount : nextRecordLength; 
0: 
0: 						// in the data buffer, we now have enough to peek
0: 						scan.readFully(data, 0, readAmount);
0: 						input.setLimit(0, readAmount);
0: 
0: 					}
0: 				}
0: 
0: 				lr = (LogRecord) input.readObject();
0: 
0: 				if (groupmask != 0 || tranId != null)
0: 				{
0: 					if (groupmask != 0 && (groupmask & lr.group()) == 0)
0: 						candidate = false; // no match, throw this log record out 
0: 
0: 					if (candidate && tranId != null)
0: 					{
0: 						TransactionId tid = lr.getTransactionId();
0: 						if (!tid.equals(tranId)) // nomatch
0: 							candidate = false; // throw this log record out
0: 					}
0: 
0: 					// if this log record is not filtered out, we need to read
0: 					// in the rest of the log record to the input buffer.
0: 					// Except if it is an encrypted database, in which case the
0: 					// entire log record have already be read in for
0: 					// decryption.
0: 
0: 					if (candidate && !logFactory.databaseEncrypted())
0: 					{
0: 						// read the rest of the log into the buffer
0: 						if (SanityManager.DEBUG)
0: 							SanityManager.ASSERT(readAmount > 0);
0: 
0: 						if (readAmount < nextRecordLength)
0: 						{
0: 							// Need to remember where we are because the log
0: 							// record may have read part of it off the input
0: 							// stream already and that position is lost when we
0: 							// set limit again.
0: 							int inputPosition = input.getPosition();
0: 
0: 							scan.readFully(data, readAmount,
0: 										   nextRecordLength-readAmount); 
0: 
0: 							input.setLimit(0, nextRecordLength);
0: 							input.setPosition(inputPosition);
0: 						}
0: 					}
0: 				}
0: 
0: 				if (candidate || logFactory.databaseEncrypted())
0: 				{
0: 					checkLength = scan.readInt();
0: 
0: 					if (SanityManager.DEBUG)
0: 					{
0: 						SanityManager.ASSERT(checkLength == nextRecordLength, "log currupted");
0: 					}
0: 				}
0: 				else // chances are, we haven't read all of the log record, skip it
0: 				{
0: 					// the starting record position is in the currentInstant,
0: 					// calculate the next record starting position using that
0: 					// and the nextRecordLength
0: 					long nextRecordStartPosition =
0: 						LogCounter.getLogFilePosition(currentInstant) +
0: 						nextRecordLength + LogToFile.LOG_RECORD_OVERHEAD;
0: 
0: 					scan.seek(nextRecordStartPosition);
0: 				}
0: 
0: 			} while (candidate == false);
0: 
0: 			return lr;
0: 		}
0: 		catch (ClassNotFoundException cnfe)
0: 		{
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(SQLState.LOG_CORRUPTED, cnfe));
0: 		}
0: 		catch (IOException ioe)
0: 		{
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
0: 		}
0: 	}
0: 
0: 	/**
0: 		Reset the scan to the given LogInstant.
0: 
0: 		@param instant the position to reset to
0: 		@exception IOException scan cannot access the log at the new position.
0: 	*/
0: 	public void resetPosition(LogInstant instant) throws IOException
0: 	{
0:         if (SanityManager.DEBUG)
0:         {
0:     		SanityManager.THROWASSERT("Unsupported feature");
0:     	}
0: 	}
0: 
0: 	/**
0: 		Get the log instant that is right after the record just retrived
0: 		@return INVALID_LOG_INSTANT if this is not a FORWARD scan or, no
0: 		record have been returned yet or the scan has completed.
0: 	*/
0: 	public long getLogRecordEnd()
0: 	{
0:         if (SanityManager.DEBUG)
0:         {
0:     		SanityManager.THROWASSERT("Unsupported feature");
0:     	}
0: 		return LogCounter.INVALID_LOG_INSTANT;
0: 	}
0: 
0: 	
0: 	/**
0: 	   returns true if there is partially writen log records before the crash 
0: 	   in the last log file. Partiall wrires are identified during forward 
0: 	   scans for log recovery.
0: 	 */
0: 	public boolean isLogEndFuzzy()
0: 	{
0: 		if (SanityManager.DEBUG)
0:         {
0:     		SanityManager.THROWASSERT("Unsupported feature");
0:     	}
0: 		return false;
0: 	}
0: 
0: 	/**
0: 		Return the log instant (as an integer) the scan is currently on - this is the log
0: 		instant of the log record that was returned by getNextRecord.
0: 	*/
0: 	public long getInstant()
0: 	{
0: 		return currentInstant;
0: 	}
0: 
0: 	/**
0: 		Return the log instant the scan is currently on - this is the log
0: 		instant of the log record that was returned by getNextRecord.
0: 	*/
0: 	public LogInstant getLogInstant()
0: 	{
0: 		if (currentInstant == LogCounter.INVALID_LOG_INSTANT)
0: 			return null;
0: 		else
0: 			return new LogCounter(currentInstant);
0: 	}
0: 
0: 	/**
0: 		Close the scan.
0: 	*/
0: 	public void close()
0: 	{
0: 		if (scan != null)
0: 		{
0: 			try
0: 			{
0: 				scan.close();
0: 			}
0: 			catch (IOException ioe)
0: 			{}
0: 
0: 			scan = null;
0: 		}
0: 		currentInstant = LogCounter.INVALID_LOG_INSTANT;
0: 		open = false;
0: 	}
0: 
0: 	/*
0: 	  Private methods.
0: 	  */
0: 	private void setFirstUnflushed()
0: 		 throws StandardException, IOException
0: 	{
0: 		LogInstant firstUnflushedInstant =
0: 			logFactory.getFirstUnflushedInstant();
0: 		firstUnflushed = ((LogCounter)firstUnflushedInstant).getValueAsLong();
0: 		firstUnflushedFileNumber = LogCounter.getLogFileNumber(firstUnflushed);
0: 		firstUnflushedFilePosition = LogCounter.getLogFilePosition(firstUnflushed);
0: 
0: 		setCurrentLogFileFirstUnflushedPosition();
0: 	}
0: 
0: 	private void setCurrentLogFileFirstUnflushedPosition()
0: 		 throws IOException
0: 	{
0: 		/*
0: 		  Note we get the currentLogFileLength without synchronization.
0: 		  This is safe because one of the following cases apply:
0: 
0: 		  <OL>
0: 		  <LI> The end of the flushed section of the log is in another file.
0: 		  In this case the end of the current file will not change.
0: 		  <LI> The end of the log is in this file. In this case we
0: 		  end our scan at the firstUnflushedInstant and do not use
0: 		  currentLogFileLength.
0: 		  </OL>
0: 		  */
0: 		if (currentLogFileNumber == firstUnflushedFileNumber)
0: 			currentLogFileFirstUnflushedPosition = firstUnflushedFilePosition;
0: 		else if (currentLogFileNumber < firstUnflushedFileNumber)
0: 			currentLogFileFirstUnflushedPosition = scan.length();
0: 		else
0:         {
0: 			// RESOLVE 
0: 		   	throw new IOException(
0:                 MessageService.getTextMessage(MessageId.LOG_BAD_START_INSTANT));
0: 		}
0: 	}
0: 
0: 	private void switchLogFile()
0: 		 throws StandardException
0: 	{
0: 		try
0: 		{
0: 			readNextRecordLength = false;
0: 			scan.close();
0: 			scan = null;
0: 			scan = logFactory.getLogFileAtBeginning(++currentLogFileNumber);
0: 			setCurrentLogFileFirstUnflushedPosition();
0: 		}
0: 
0: 		catch (IOException ioe)
0: 		{
0: 			throw logFactory.markCorrupt(
0:                 StandardException.newException(SQLState.LOG_IO_ERROR, ioe));
0: 		}
0: 	}
0: 
0: 	/**
0: 	  The length of the next record. Read from scan and set by
0: 	  currentLogFileHasUnflushedRecord. This is used to retain the length of a
0: 	  log record in the case currentLogFileHasUnflushedRecord reads the length
0: 	  and determines that some bytes in the log record are not yet flushed.
0: 	  */
0: 	int nextRecordLength;
0: 
0: 	/**
0: 	  Flag to indicate that the length of the next log record has been read by
0: 	  currentLogFileHasUnflushedRecord.
0: 
0: 	  This flag gets reset in two ways:
0: 
0: 	  <OL>
0: 	  <LI> currentLogFileHasUnflushedRecord determines that the entire log
0: 	  record is flushed and returns true. In this case getNextRecord reads and
0: 	  returns the log record.
0: 	  <LI> we switch log files --due to a partial log record at the end of an
0: 	  old log file.
0: 	  </OL>
0: 	  */
0: 	boolean readNextRecordLength;
0: 
0: 	private boolean currentLogFileHasUnflushedRecord()
0: 		 throws IOException
0: 	{
0: 		if (SanityManager.DEBUG)
0: 			SanityManager.ASSERT(scan != null, "scan is null");
0: 		long curPos = scan.getFilePointer();
0: 
0: 		if (!readNextRecordLength)
0: 		{
0: 			if (curPos + LOG_REC_LEN_BYTE_LENGTH >
0: 				                 currentLogFileFirstUnflushedPosition)
0: 				return false;
0: 
0: 			nextRecordLength = scan.readInt();
0: 			curPos+=4;
0: 			readNextRecordLength = true;
0: 		}
0: 
0: 		if (nextRecordLength==0) return false;
0: 
0: 		int bytesNeeded =
0: 			nextRecordLength + LOG_REC_LEN_BYTE_LENGTH;
0: 
0: 		if (curPos + bytesNeeded > currentLogFileFirstUnflushedPosition)
0: 		{
0: 			return false;
0: 		}
0: 		else
0: 		{
0: 			readNextRecordLength = false;
0: 			return true;
0: 		}
0: 	}
0: 
0: 	private boolean positionToNextRecord()
0: 		 throws StandardException, IOException
0: 	{
0: 		//If the flushed section of the current log file contains our record we
0: 		//simply return.
0: 		if (currentLogFileHasUnflushedRecord()) return true;
0: 
0: 		//Update our cached copy of the first unflushed instant.
0: 		setFirstUnflushed();
0: 
0: 		//In the call to setFirstUnflushed, we may have noticed that the current
0: 		//log file really does contain our record. If so we simply return.
0: 		if (currentLogFileHasUnflushedRecord()) return true;
0: 
0: 		//Our final chance of finding a record is if we are not scanning the log
0: 		//file with the last flushed instant we can switch logfiles. Note that
0: 		//we do this in a loop to cope with empty log files.
0: 		while(currentLogFileNumber < firstUnflushedFileNumber)
0: 		{
0: 			  switchLogFile();
0: 		      if (currentLogFileHasUnflushedRecord()) return true;
0: 		}
0: 
0: 		//The log contains no more flushed log records so we return false.
0: 		currentInstant = LogCounter.INVALID_LOG_INSTANT;
0: 		return false;
0: 	}
0: }
============================================================================