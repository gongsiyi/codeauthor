1:e1d02a0: /*
2:e1d02a0: 
1:e1d02a0:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.StatementPoolingTest
1:e1d02a0: 
1:e1d02a0:    Licensed to the Apache Software Foundation (ASF) under one or more
1:e1d02a0:    contributor license agreements.  See the NOTICE file distributed with
1:e1d02a0:    this work for additional information regarding copyright ownership.
1:e1d02a0:    The ASF licenses this file to You under the Apache License, Version 2.0
1:e1d02a0:    (the "License"); you may not use this file except in compliance with
1:e1d02a0:    the License.  You may obtain a copy of the License at
1:e1d02a0: 
1:e1d02a0:       http://www.apache.org/licenses/LICENSE-2.0
1:e1d02a0: 
1:e1d02a0:    Unless required by applicable law or agreed to in writing, software
1:e1d02a0:    distributed under the License is distributed on an "AS IS" BASIS,
1:e1d02a0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:e1d02a0:    See the License for the specific language governing permissions and
1:e1d02a0:    limitations under the License.
1:e1d02a0: 
1:e1d02a0: */
1:e1d02a0: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:e1d02a0: 
1:e1d02a0: import java.sql.CallableStatement;
1:e1d02a0: import java.sql.Connection;
1:e1d02a0: import java.sql.PreparedStatement;
1:e1d02a0: import java.sql.ResultSet;
1:e1d02a0: import java.sql.SQLException;
1:e1d02a0: import java.sql.Statement;
1:e1d02a0: import javax.sql.ConnectionPoolDataSource;
1:e1d02a0: import javax.sql.PooledConnection;
1:e1d02a0: import junit.framework.Test;
1:e1d02a0: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:e1d02a0: import org.apache.derbyTesting.junit.BaseJDBCTestSetup;
1:1ae02c9: import org.apache.derbyTesting.junit.BaseTestSuite;
1:e1d02a0: import org.apache.derbyTesting.junit.J2EEDataSource;
1:e1d02a0: import org.apache.derbyTesting.junit.JDBC;
1:e1d02a0: import org.apache.derbyTesting.junit.TestConfiguration;
1:e1d02a0: 
1:e1d02a0: /**
1:e1d02a0:  * A set of tests specifically targeted at connections that support statement
1:e1d02a0:  * pooling.
1:e1d02a0:  */
1:e1d02a0: public class StatementPoolingTest
1:e1d02a0:     extends BaseJDBCTestCase {
1:e1d02a0: 
1:b6af70a:     private LogicalPooledConnectionFactory lpcf;
1:b6af70a: 
1:e1d02a0:     public StatementPoolingTest(String name) {
1:e1d02a0:         super(name);
4:e1d02a0:     }
1:e1d02a0: 
1:b6af70a:     public void tearDown()
1:b6af70a:             throws Exception {
1:b6af70a:         closePooledConnectionFactory();
1:b6af70a:         super.tearDown();
1:b6af70a:     }
1:b6af70a:     
1:b6af70a:     /** Closes the connection factory associated with this test. */
1:b6af70a:     private void closePooledConnectionFactory()
1:b6af70a:             throws SQLException {
1:b6af70a:         if (lpcf != null) {
1:b6af70a:             try {
1:b6af70a:                 lpcf.close();
1:b6af70a:             } finally {
1:b6af70a:                 lpcf = null;
1:b6af70a:             }
1:b6af70a:         }
1:b6af70a:     }
1:b6af70a: 
1:b6af70a:     /**
1:b6af70a:      * Returns a logical connection from a pooled connection obtained from a
1:b6af70a:      * data source configured with a default statement cache size.
1:b6af70a:      *
1:b6af70a:      * @return A logical connection.
1:b6af70a:      * @throws SQLException if obtaining the connection fails
1:b6af70a:      */
1:b6af70a:     private Connection getCachingConnection()
1:b6af70a:             throws SQLException {
1:b6af70a:         return getCachingConnection(7);
1:b6af70a:     }
1:b6af70a: 
1:b6af70a:     /**
1:b6af70a:      * Returns a logical connection from a pooled connection obtained from a
1:b6af70a:      * data source configured to have the specified statement cache size.
1:b6af70a:      *
1:b6af70a:      * @param cacheSize statement cache size
1:b6af70a:      * @return A logical connection.
1:b6af70a:      * @throws SQLException if obtaining the connection fails
1:b6af70a:      */
1:b6af70a:     private Connection getCachingConnection(int cacheSize)
1:b6af70a:             throws SQLException {
1:b6af70a:         if (lpcf == null) {
1:b6af70a:             lpcf = new LogicalPooledConnectionFactory();
1:b6af70a:         }
1:b6af70a:         return lpcf.getConnection(cacheSize);
1:b6af70a:     }
1:b6af70a: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests that the statement cache is able to throw out prepared statements
1:e1d02a0:      * when it reaches maximum capacity.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:4a515d8:     public void testCacheOverflow()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         final int stmtCount = 150;
1:b6af70a:         Connection con = getCachingConnection(11);
1:e1d02a0:         for (int i=0; i < stmtCount; i++) {
1:e1d02a0:             // Yes, the "values + i" is intended here.
1:e1d02a0:             PreparedStatement pStmt = con.prepareStatement("values " + i);
1:e1d02a0:             ResultSet rs = pStmt.executeQuery();
1:e1d02a0:             JDBC.assertSingleValueResultSet(rs, Integer.toString(i));
1:e1d02a0:             pStmt.close();
1:e1d02a0:         }
1:e1d02a0:         con.close();
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Verifies that statement pooling is enabled by checking the names of the
1:e1d02a0:      * implementation classes in Derby.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if creating the JDBC objects fail
1:e1d02a0:      */
1:4a515d8:     public void testPoolingEnabledByCheckingImplementationDetails()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         final String conClass = "CachingLogicalConnection";
1:e1d02a0:         final String psClass = "LogicalPreparedStatement";
1:e1d02a0:         final String csClass = "LogicalCallableStatement";
1:ef81d0e:         final String dmdClass = "LogicalDatabaseMetaData";
1:b6af70a:         Connection con = getCachingConnection();
1:e1d02a0:         assertClassName(con, conClass);
1:e1d02a0:         assertClassName(con.prepareStatement("values 1"), psClass);
1:e1d02a0:         assertClassName(con.prepareStatement("values 1",
1:e1d02a0:                                              Statement.RETURN_GENERATED_KEYS),
1:e1d02a0:                         psClass);
1:e1d02a0:         assertClassName(con.prepareStatement("values 1",
1:e1d02a0:                                              Statement.NO_GENERATED_KEYS),
1:e1d02a0:                         psClass);
1:e1d02a0:         assertClassName(con.prepareStatement("values 1",
1:e1d02a0:                                              ResultSet.TYPE_FORWARD_ONLY,
1:e1d02a0:                                              ResultSet.CONCUR_READ_ONLY),
1:e1d02a0:                         psClass);
1:e1d02a0:         assertClassName(con.prepareStatement("values 1",
1:e1d02a0:                                              ResultSet.TYPE_SCROLL_INSENSITIVE,
1:e1d02a0:                                              ResultSet.CONCUR_UPDATABLE),
1:e1d02a0:                         psClass);
1:e1d02a0:         assertClassName(con.prepareStatement("values 1",
1:e1d02a0:                                              (String[])null),
1:e1d02a0:                         psClass);
1:e1d02a0:         assertClassName(con.prepareStatement("values 1",
1:e1d02a0:                                              new String[] {}),
1:e1d02a0:                         psClass);
1:e1d02a0:         assertClassName(con.prepareCall("values 1"), csClass);
1:e1d02a0:         assertClassName(con.prepareCall("values 1",
1:e1d02a0:                                         ResultSet.TYPE_FORWARD_ONLY,
1:e1d02a0:                                         ResultSet.CONCUR_READ_ONLY),
1:e1d02a0:                         csClass);
1:e1d02a0:         assertClassName(con.prepareCall("values 1",
1:e1d02a0:                                         ResultSet.TYPE_FORWARD_ONLY,
1:e1d02a0:                                         ResultSet.CONCUR_READ_ONLY,
1:e1d02a0:                                         ResultSet.CLOSE_CURSORS_AT_COMMIT),
1:e1d02a0:                         csClass);
1:ef81d0e:         assertClassName(con.getMetaData(), dmdClass);
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Assert that the name of the class of the object is what is expected.
1:e1d02a0:      * <p>
1:e1d02a0:      * The assert does not consider package names, only the name passed in as
1:e1d02a0:      * {@code expectedName} and the passed in name concatenated with "40".
1:ef81d0e:      * <p>
1:ef81d0e:      * <b>WARNING</b>: This method is not a general utility method. Please look
1:ef81d0e:      * at the implementation to determine if you can use it.
1:e1d02a0:      *
1:e1d02a0:      * @param obj object to check
1:e1d02a0:      * @param expectedName the expected name of the class
1:e1d02a0:      * @throws AssertionFailedError if the class name is not as expected
1:e1d02a0:      */
1:e1d02a0:     private static void assertClassName(Object obj, String expectedName) {
1:e1d02a0:         assertNotNull("The expected name cannot be <null>", expectedName);
1:e1d02a0:         assertNotNull("The object cannot be <null>", obj);
1:e1d02a0:         String[] names = obj.getClass().getName().split("\\.");
1:ef81d0e:         final String simpleName = names[names.length -1];
1:ef81d0e:         if (JDBC.vmSupportsJDBC4() && !expectedName.endsWith("40")) {
1:2a51fce: 
1:939acff:             if (JDBC.vmSupportsJDBC42()
1:939acff:                     && expectedName.contains("Statement"))
1:2a51fce:             {
1:2a51fce:                 expectedName += "42";
1:2a51fce:             }
1:9a0cdf1:             else if (usingEmbedded())
1:2a51fce:             {
1:2a51fce:                 expectedName += "40";
1:2a51fce:             }
1:314a6da:         }
1:f8c4fd4:         assertEquals(expectedName, simpleName);
1:ef81d0e:     }
1:314a6da: 
1:e1d02a0:     /**
1:b6af70a:      * This test merely checks that creating a logical prepared statement does
1:e1d02a0:      * not fail.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if creating the prepared statement fails
1:e1d02a0:      */
1:4a515d8:     public void testPrepareStatementPath()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         PreparedStatement ps = prepareStatement("values 9708");
1:e1d02a0:         ps.close();
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:b6af70a:      * This test merely checks that creating a logical callable statement does
1:e1d02a0:      * not fail.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if creating the callable statement fails
1:e1d02a0:      */
1:4a515d8:     public void testPrepareCallPath()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         CallableStatement cs = prepareCall(
1:e1d02a0:                 "CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");
1:e1d02a0:         cs.close();
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:b6af70a:      * This test merely checks that creating a logical callable statement, which
1:e1d02a0:      * is not really a call, does not fail.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if creating the callable statement fails
1:e1d02a0:      */
1:4a515d8:     public void testPrepareCallWithNoCallPath()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         CallableStatement cs = prepareCall("values 1");
1:e1d02a0:         cs.close();
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests that closing the prepared statement also closes the result set.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:4a515d8:     public void testClosingPSClosesRS()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         PreparedStatement ps = prepareStatement("values 99");
1:e1d02a0:         ResultSet rs = ps.executeQuery();
1:e1d02a0:         ps.close();
1:e1d02a0:         try {
1:e1d02a0:             rs.next();
1:e1d02a0:             fail("Result set should have been closed");
1:e1d02a0:         } catch (SQLException sqle) {
1:e1d02a0:             assertSQLState("XCL16", sqle);
1:e1d02a0:         }
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests that the connection holdability is reset, when it is first
1:e1d02a0:      * modified, the connection closed and a new logical connection obtained.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:4a515d8:     public void testHoldabilityIsResetExplicitClose()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         doTestHoldabilityIsReset(true);
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests that the connection holdability is reset, when it is first
1:e1d02a0:      * modified, and a new logical connection obtained without first explicitly
1:e1d02a0:      * closing the previous one.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:4a515d8:     public void testHoldabilityIsResetNoExplicitClose()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         doTestHoldabilityIsReset(false);
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Test sequence for testing if the connection holdability is reset.
1:e1d02a0:      *
1:e1d02a0:      * @param closeConnection determines if the logical connection is
1:e1d02a0:      *      explicitly closed before a new one is obtained
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:e1d02a0:     private void doTestHoldabilityIsReset(final boolean closeConnection)
1:e1d02a0:             throws SQLException {
1:e1d02a0:         // Keep track of our own connection, the framework currently creates
1:e1d02a0:         // a new pooled connection and then obtains a connection from that.
1:e1d02a0:         // Statement pooling only works within a single pooled connection.
1:b6af70a:         Connection con = getCachingConnection();
1:e1d02a0:         assertEquals("Unexpected default holdability",
1:e1d02a0:                 ResultSet.HOLD_CURSORS_OVER_COMMIT, con.getHoldability());
1:e1d02a0:         con.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:e1d02a0:         assertEquals("Holdability not updated",
1:e1d02a0:                 ResultSet.CLOSE_CURSORS_AT_COMMIT, con.getHoldability());
1:e1d02a0:         if (closeConnection) {
1:e1d02a0:             con.close();
1:e1d02a0:         }
1:b6af70a:         con = getCachingConnection();
1:e1d02a0:         assertEquals("Holdability not reset",
1:e1d02a0:                 ResultSet.HOLD_CURSORS_OVER_COMMIT, con.getHoldability());
1:e1d02a0:     }
1:e1d02a0: 
1:4a515d8:     public void testIsolationLevelIsResetExplicitCloseQuery()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         doTestIsolationLevelIsReset(true, true);
1:e1d02a0:     }
1:e1d02a0: 
1:4a515d8:     public void testIsolationLevelIsResetExplicitCloseNoQuery()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         doTestIsolationLevelIsReset(true, false);
1:e1d02a0:     }
1:e1d02a0: 
1:4a515d8:     public void testIsolationLevelIsResetNoExplicitCloseNoQuery()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         doTestIsolationLevelIsReset(false, false);
1:e1d02a0:     }
1:e1d02a0: 
1:4a515d8:     public void testIsolationLevelIsResetNoExplicitCloseQuery()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         doTestIsolationLevelIsReset(false, true);
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests if the connection isolation level is reset when a new connection
1:e1d02a0:      * is obtained.
1:e1d02a0:      * <p>
1:e1d02a0:      * The two arguments are introduced to test different scenarios; explicit
1:e1d02a0:      * and implicit connection closing, and session data caching (piggybacked
1:e1d02a0:      * information).
1:e1d02a0:      *
1:e1d02a0:      * @param closeConnection tells if the connection is explicitly closed
1:e1d02a0:      *      before a new one is obtained
1:e1d02a0:      * @param executeQuery tells if a query is executed on the connection before
1:e1d02a0:      *      a new connection is obtained.
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:e1d02a0:     private void doTestIsolationLevelIsReset(final boolean closeConnection,
1:e1d02a0:                                              final boolean executeQuery)
1:e1d02a0:             throws SQLException {
1:e1d02a0:         // Keep track of our own connection, the framework currently creates
1:e1d02a0:         // a new pooled connection and then obtains a connection from that.
1:e1d02a0:         // Statement pooling only works within a single pooled connection.
1:b6af70a:         Connection con = getCachingConnection();
1:e1d02a0:         assertEquals("Unexpected default isolation level",
1:e1d02a0:                 Connection.TRANSACTION_READ_COMMITTED,
1:e1d02a0:                 con.getTransactionIsolation());
1:e1d02a0:         con.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:e1d02a0:         assertEquals("Isolation level not updated",
1:e1d02a0:                 Connection.TRANSACTION_REPEATABLE_READ,
1:e1d02a0:                 con.getTransactionIsolation());
1:e1d02a0:         if (executeQuery) {
1:e1d02a0:             PreparedStatement ps = con.prepareStatement("values 2");
1:e1d02a0:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "2");
1:e1d02a0:             ps.close();
1:e1d02a0:         }
1:e1d02a0:         if (closeConnection) {
1:e1d02a0:             con.close();
1:e1d02a0:         }
1:b6af70a:         con = getCachingConnection();
1:e1d02a0:         assertEquals("Isolation level not reset",
1:e1d02a0:                 Connection.TRANSACTION_READ_COMMITTED,
1:e1d02a0:                 con.getTransactionIsolation());
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:f2a8f00:      * Tests that closing the caching logical connection closes the logical
1:f2a8f00:      * prepared statement, but not the physical prepared statement.
1:e1d02a0:      * <p>
1:f2a8f00:      * Since there are no public interface methods to test this, the approach
1:f2a8f00:      * taken will be as follows:
1:f2a8f00:      * <ol> <li>Create a new table.</li>
1:e1d02a0:      *      <li>Prepare a statement selecting from the table.</li>
1:e1d02a0:      *      <li>Close the statement, putting it into the cache.</li>
1:e1d02a0:      *      <li>Delete the table.</li>
1:e1d02a0:      *      <li>Prepare the selecting statement again.</li>
1:e1d02a0:      *      <li>Execute the statement.</li>
1:e1d02a0:      * </ol>
1:e1d02a0:      * If the physical statement was closed when closing the caching logical
1:e1d02a0:      * connection, the prepare will fail. If it was left open, the prepare will
1:e1d02a0:      * succeed because the statement is fetched from the cache, but the
1:f2a8f00:      * execution will fail because the table no longer exists.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:4a515d8:     public void testCachingLogicalConnectionCloseLeavesPhysicalStatementsOpen()
1:e1d02a0:             throws SQLException {
1:f2a8f00:         final String SELECT_SQL = "select * from clcclso";
1:e1d02a0:         // Keep track of our own connection, the framework currently creates
1:e1d02a0:         // a new pooled connection and then obtains a connection from that.
1:e1d02a0:         // Statement pooling only works within a single pooled connection.
1:b6af70a:         Connection con = getCachingConnection();
1:e1d02a0:         con.setAutoCommit(false);
1:e1d02a0:         Statement stmt = createStatement();
1:e1d02a0:         stmt.executeUpdate("create table clcclso (id int)");
1:f2a8f00:         PreparedStatement ps = con.prepareStatement(SELECT_SQL);
1:902041a:         con.commit();
1:e1d02a0:         con.close();
1:e1d02a0:         try {
1:f2a8f00:             // Should fail because the logical statement has been closed.
1:e1d02a0:             ps.execute();
1:f2a8f00:             fail("Logical connection close did not close logical statement.");
1:e1d02a0:         } catch (SQLException sqle) {
1:e1d02a0:             // Already closed.
1:e1d02a0:             assertSQLState("XJ012", sqle);
1:e1d02a0:         }
1:e1d02a0:         stmt = createStatement();
1:e1d02a0:         stmt.executeUpdate("drop table clcclso");
2:e1d02a0:         commit();
1:e1d02a0:         // If an exception is thrown here, statement pooling is disabled or not
1:e1d02a0:         // working correctly.
1:b6af70a:         con = getCachingConnection();
1:f2a8f00:         ps = con.prepareStatement(SELECT_SQL); // From cache.
1:e1d02a0:         try {
1:f2a8f00:             // Should fail here because the referenced table has been deleted.
1:e1d02a0:             ps.execute();
1:e1d02a0:             fail("Execution should have failed");
1:e1d02a0:         } catch (SQLException sqle) {
1:e1d02a0:             assertSQLState("42X05", sqle);
1:e1d02a0:         }
1:e1d02a0:         ps.close();
1:e1d02a0:         // Make sure the connection is still valid.
1:e1d02a0:         ps = con.prepareStatement("values 976");
1:e1d02a0:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "976");
1:e1d02a0:         ps.close();
1:e1d02a0:         con.close();
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Checks if a reset of one statement affects other open statement on the
1:e1d02a0:      * connection.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:e1d02a0:     public void resTestCloseDoesNotAffectOtherStatement()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         final String sql = "select * from stmtpooltest where val > 0 and val " +
1:e1d02a0:                 "<= 7 order by val";
1:e1d02a0:         PreparedStatement psForward = prepareStatement(sql);
1:e1d02a0:         ResultSet rsForward = psForward.executeQuery();
1:e1d02a0:         assertTrue(rsForward.next());
1:e1d02a0:         assertEquals("1", rsForward.getString(1));
1:e1d02a0:         assertTrue(rsForward.next());
1:e1d02a0:         assertEquals("2", rsForward.getString(1));
1:e1d02a0:         PreparedStatement psScrollable = prepareStatement(sql,
1:e1d02a0:                 ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
1:e1d02a0:         ResultSet rsScrollable = psScrollable.executeQuery();
1:e1d02a0:         // Read seven rows from the scrollable rs, position at last row.
1:e1d02a0:         for (int val=1; val <= 7; val++) {
1:e1d02a0:             assertTrue(rsScrollable.next());
1:e1d02a0:             assertEquals(val, rsScrollable.getInt(1));
1:e1d02a0:         }
1:e1d02a0: 
1:e1d02a0:         // Create a statement, then close it.
1:e1d02a0:         PreparedStatement psToClose = prepareStatement(
1:e1d02a0:                 "select val from stmtpooltest where val = 5");
1:e1d02a0:         JDBC.assertSingleValueResultSet(psToClose.executeQuery(), "5");
1:e1d02a0:         psToClose.close();
1:e1d02a0:         assertTrue(rsForward.next());
1:e1d02a0:         assertEquals("3", rsForward.getString(1));
1:e1d02a0:         assertTrue(rsScrollable.first());
1:e1d02a0:         assertEquals("1", rsScrollable.getString(1));
1:e1d02a0:         // Should fetch a cached statement.
1:e1d02a0:         psToClose = prepareStatement(
1:e1d02a0:                 "select val from stmtpooltest where val = 5");
1:e1d02a0:         JDBC.assertSingleValueResultSet(psToClose.executeQuery(), "5");
1:e1d02a0:         psToClose.close();
1:e1d02a0:         assertTrue(rsScrollable.last());
1:e1d02a0:         assertEquals("7", rsScrollable.getString(1));
1:e1d02a0:         assertFalse(rsScrollable.next());
1:e1d02a0:         rsScrollable.close();
1:e1d02a0:         assertTrue(rsForward.next());
1:e1d02a0:         assertEquals("4", rsForward.getString(1));
1:e1d02a0:         rsForward.close();
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests that closing a logical prepared statement referring a non-existing
1:e1d02a0:      * table works.
1:e1d02a0:      * <p>
1:e1d02a0:      * In this test, the prepared statement that will be made invalid by the
1:e1d02a0:      * delete is held open by the user.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:4a515d8:     public void testDeleteReferringTableWhenOpen()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         getConnection().setAutoCommit(false);
1:e1d02a0:         // Create a table, insert a row, then create a statement selecting it.
1:e1d02a0:         Statement stmt = createStatement();
1:e1d02a0:         stmt.executeUpdate("create table testdeletewhenopen (id int)");
1:e1d02a0:         stmt.executeUpdate("insert into testdeletewhenopen values 1");
1:e1d02a0:         PreparedStatement ps = prepareStatement(
1:e1d02a0:                 "select * from testdeletewhenopen");
1:e1d02a0:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:e1d02a0:         // Now delete the table and logically close the prepared statement.
1:e1d02a0:         stmt.executeUpdate("drop table testdeletewhenopen");
1:e1d02a0:         stmt.close();
1:e1d02a0:         ps.close();
1:e1d02a0:         // If running without statement pooling, you will get exception here.
1:e1d02a0:         ps = prepareStatement("select * from testdeletewhenopen");
1:e1d02a0:         // If we get this far, there is a big change we have fetched an
1:e1d02a0:         // invalid statement from the cache, but we won't get the exception
1:e1d02a0:         // until we try to execute it.
1:e1d02a0:         try {
1:e1d02a0:             ps.executeQuery();
1:e1d02a0:             fail("Prepared statement not valid, referring non-existing table");
1:e1d02a0:         } catch (SQLException sqle) {
1:e1d02a0:             assertSQLState("42X05", sqle);
1:e1d02a0:         }
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests that closing a logical prepared statement referring a non-existing
1:e1d02a0:      * table works.
1:e1d02a0:      * <p>
1:e1d02a0:      * In this test, the prepared statement that will be made invalid by the
1:e1d02a0:      * delete is in the statement cache when the delete happens.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:4a515d8:     public void testDeleteReferringTableWhenInCache()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         getConnection().setAutoCommit(false);
1:e1d02a0:         // Create a table, insert a row, then create a statement selecting it.
1:e1d02a0:         Statement stmt = createStatement();
1:e1d02a0:         stmt.executeUpdate("create table testdeletewhenopen (id int)");
1:e1d02a0:         stmt.executeUpdate("insert into testdeletewhenopen values 1");
1:e1d02a0:         PreparedStatement ps = prepareStatement(
1:e1d02a0:                 "select * from testdeletewhenopen");
1:e1d02a0:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:e1d02a0:         // Put the statement into the cache.
1:e1d02a0:         ps.close();
1:e1d02a0:         // Now delete the table and fetch the cached prepared statement.
1:e1d02a0:         stmt.executeUpdate("drop table testdeletewhenopen");
1:e1d02a0:         stmt.close();
1:e1d02a0:         // If running without statement pooling, you will get exception here.
1:e1d02a0:         ps = prepareStatement("select * from testdeletewhenopen");
1:e1d02a0:         // If we get this far, there is a big change we have fetched an
1:e1d02a0:         // invalid statement from the cache, but we won't get the exception
1:e1d02a0:         // until we try to execute it.
1:e1d02a0:         try {
1:e1d02a0:             ps.executeQuery();
1:e1d02a0:             fail("Prepared statement not valid, referring non-existing table");
1:e1d02a0:         } catch (SQLException sqle) {
1:e1d02a0:             assertSQLState("42X05", sqle);
1:e1d02a0:         }
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     public void resTestCloseCursorsAtCommit()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         doTestResultSetCloseForHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     public void resTestHoldCursorsOverCommit()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         doTestResultSetCloseForHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:b6af70a:      * Tests that a temporary table created in one logical connection is gone
1:ea777fe:      * in the next logical connection.
1:ea777fe:      *
1:ea777fe:      * @throws SQLException if the test fails for some reason
1:ea777fe:      */
1:4a515d8:     public void testTemporaryTablesAreDeletedInNewLogicalConnection()
1:ea777fe:             throws SQLException {
1:b6af70a:         Connection lcOne = getCachingConnection();
1:ea777fe: 
1:ea777fe:         // Create the first logical connection and the temporary table.
1:ea777fe:         Statement stmt = lcOne.createStatement();
1:ea777fe:         stmt.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE cpds_temp_table " +
1:ea777fe:                 "(id int) ON COMMIT PRESERVE ROWS NOT LOGGED");
1:ea777fe:         // The temporary table is created in SESSION.
1:ea777fe:         JDBC.assertEmpty(
1:ea777fe:                 stmt.executeQuery("select * from SESSION.cpds_temp_table"));
1:ea777fe:         stmt.executeUpdate("insert into SESSION.cpds_temp_table values 1");
1:ea777fe:         lcOne.commit();
1:ea777fe:         lcOne.close();
1:ea777fe: 
1:ea777fe:         // Create the second logical connection and try to query the temp table.
1:b6af70a:         Connection lcTwo = getCachingConnection();
1:ea777fe:         stmt = lcTwo.createStatement();
1:ea777fe:         try {
1:ea777fe:             stmt.executeQuery("select * from SESSION.cpds_temp_table");
1:ea777fe:             fail("Temporary table still existing in new logical connection.");
1:ea777fe:         } catch (SQLException sqle) {
1:ea777fe:             // Expect syntax error.
1:ea777fe:             assertSQLState("42X05", sqle);
1:ea777fe:         }
1:ea777fe:         lcTwo.rollback();
1:ea777fe:         lcTwo.close();
1:ea777fe:     }
1:ea777fe: 
1:ea777fe:     /**
1:e1d02a0:      * Tests if the holdability settings is taking effect, and also that the
1:e1d02a0:      * result set is closed when the connection is closed.
1:e1d02a0:      *
1:b6af70a:      * @param holdability result set holdability as specified by
1:e1d02a0:      *      {@link java.sql.ResultSet}
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:e1d02a0:     private void doTestResultSetCloseForHoldability(int holdability)
1:e1d02a0:             throws SQLException {
1:e1d02a0:         getConnection().setAutoCommit(false);
1:e1d02a0:         PreparedStatement ps = prepareStatement(
1:e1d02a0:                 "select * from stmtpooltest order by val",
1:e1d02a0:                 ResultSet.TYPE_FORWARD_ONLY,
1:e1d02a0:                 ResultSet.CONCUR_READ_ONLY,
1:e1d02a0:                 holdability);
1:e1d02a0:         ResultSet rs = ps.executeQuery();
1:e1d02a0:         assertTrue(rs.next());
1:e1d02a0:         assertEquals(1, rs.getInt(1));
1:e1d02a0:         commit();
1:e1d02a0:         if (holdability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:e1d02a0:             assertTrue(rs.next());
1:e1d02a0:             assertEquals(2, rs.getInt(1));
1:902041a:             rollback();
1:e1d02a0:         }
1:e1d02a0:         getConnection().close();
1:e1d02a0:         try {
1:e1d02a0:             rs.next();
1:e1d02a0:             fail("Should have thrown exception");
1:e1d02a0:         } catch (SQLException sqle) {
1:e1d02a0:             assertSQLState("XCL16", sqle);
1:e1d02a0:         }
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:d798bb1:      * Make sure {@link ResultSet#getStatement} returns the same object as the
1:d798bb1:      * one that created the result set.
1:d798bb1:      */
1:4a515d8:     public void testGetStatementCallable()
1:d798bb1:             throws SQLException {
1:d798bb1:         doTestGetStatement(prepareCall("values 7653"));
1:d798bb1:     }
1:d798bb1: 
1:d798bb1:     /**
1:d798bb1:      * Make sure {@link ResultSet#getStatement} returns the same object as the
1:d798bb1:      * one that created the result set.
1:d798bb1:      */
1:4a515d8:     public void testGetStatementPrepared()
1:d798bb1:             throws SQLException {
1:d798bb1:         doTestGetStatement(prepareStatement("values 7652"));
1:d798bb1:     }
1:d798bb1: 
1:d798bb1:     /**
1:d798bb1:      * Make sure {@link ResultSet#getStatement} returns the same object as the
1:d798bb1:      * one that created the result set.
1:d798bb1:      *
1:d798bb1:      * @param ps prepared or callable statement to test with
1:d798bb1:      * @throws SQLException if something goes wrong...
1:d798bb1:      */
1:d798bb1:     private void doTestGetStatement(PreparedStatement ps)
1:d798bb1:             throws SQLException {
1:d798bb1:         ResultSet psRs = ps.executeQuery();
1:d798bb1:         assertSame(ps, psRs.getStatement());
1:d798bb1:         psRs.close();
1:d798bb1:         // Try another way.
1:d798bb1:         ps.execute();
1:d798bb1:         psRs = ps.getResultSet();
1:d798bb1:         assertSame(ps, psRs.getStatement());
1:d798bb1:         assertFalse(ps.getMoreResults());
1:d798bb1:         assertNull(ps.getResultSet());
1:d798bb1:         // This one should fail.
1:d798bb1:         try {
1:d798bb1:             psRs = ps.executeQuery("values 99");
1:d798bb1:             fail("executeQuery(String) should be disallowed");
1:d798bb1:         } catch (SQLException sqle) {
1:d798bb1:             assertSQLState("XJ016", sqle);
1:d798bb1:         }
1:d798bb1:     }
1:d798bb1: 
1:d798bb1:     /**
1:e1d02a0:      * Checks if closing the logical connection closes the logical statement.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:e1d02a0:     public void resTestLogicalConnectionCloseInvalidatesLogicalStatement()
1:e1d02a0:             throws SQLException {
2:e1d02a0:         Connection con = getConnection();
1:e1d02a0:         PreparedStatement ps =
1:e1d02a0:                 con.prepareStatement("select * from stmtpooltest");
1:e1d02a0:         // Don't execute the statement.
1:e1d02a0:         assertNotNull(ps.getMetaData());
1:e1d02a0:         con.close();
1:e1d02a0:         try {
1:e1d02a0:             ps.getMetaData();
1:e1d02a0:             fail("Logical statement should be closed and throw exception");
1:e1d02a0:         } catch (SQLException sqle) {
1:e1d02a0:             assertSQLState("XJ012", sqle);
1:e1d02a0:         }
1:e1d02a0:         con = getConnection();
1:e1d02a0:         ps = con.prepareStatement("select * from stmtpooltest order by val");
1:e1d02a0:         // Execute the statement this time.
1:e1d02a0:         ResultSet rs = ps.executeQuery();
1:e1d02a0:         assertTrue(rs.next());
1:e1d02a0:         assertNotNull(ps.getMetaData());
1:e1d02a0:         rs.close();
1:e1d02a0:         con.close();
1:e1d02a0:         try {
1:e1d02a0:             ps.getMetaData();
1:e1d02a0:             fail("Logical statement should be closed and throw exception");
1:e1d02a0:         } catch (SQLException sqle) {
1:e1d02a0:             assertSQLState("XJ012", sqle);
1:e1d02a0:         }
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests that nothing is committed on the connection when autocommit is
1:e1d02a0:      * disabled.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:e1d02a0:     public void resTestNoCommitOnReuse()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         // Make sure the table is empty.
1:e1d02a0:         cleanTableExceptedToBeEmpty();
1:e1d02a0: 
1:e1d02a0:         // Start test
1:e1d02a0:         final String sql = "insert into stmtpooldata (val) values ?";
1:e1d02a0:         getConnection().setAutoCommit(false);
1:e1d02a0:         PreparedStatement ps = prepareStatement(sql);
1:e1d02a0:         ps.setInt(1, 68);
1:e1d02a0:         assertEquals(1, ps.executeUpdate());
1:e1d02a0:         ps.close();
1:e1d02a0:         ps = prepareStatement(sql);
1:e1d02a0:         ps.setInt(1, 77);
1:e1d02a0:         assertEquals(1, ps.executeUpdate());
1:e1d02a0:         Statement stmt = createStatement();
1:e1d02a0:         ResultSet rs =stmt.executeQuery(
1:e1d02a0:                 "select val from stmtpooldata order by val");
1:e1d02a0:         JDBC.assertFullResultSet(rs, new String[][] {{"68"},{"77"}});
1:e1d02a0:         rollback();
1:e1d02a0:         rs = stmt.executeQuery("select val from stmtpooldata order by val");
1:e1d02a0:         JDBC.assertEmpty(rs);
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests that autocommit is working.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:e1d02a0:     public void resTestCommitOnReuse()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         // Make sure the table is empty.
1:e1d02a0:         cleanTableExceptedToBeEmpty();
1:e1d02a0: 
1:e1d02a0:         // Start test
1:e1d02a0:         final String sql = "insert into stmtpooldata (val) values ?";
1:e1d02a0:         getConnection().setAutoCommit(true);
1:e1d02a0:         PreparedStatement ps = prepareStatement(sql);
1:e1d02a0:         ps.setInt(1, 68);
1:e1d02a0:         assertEquals(1, ps.executeUpdate());
1:e1d02a0:         ps.close();
1:e1d02a0:         ps = prepareStatement(sql);
1:e1d02a0:         ps.setInt(1, 77);
1:e1d02a0:         assertEquals(1, ps.executeUpdate());
1:e1d02a0:         Statement stmt = createStatement();
1:e1d02a0:         ResultSet rs =stmt.executeQuery(
1:e1d02a0:                 "select val from stmtpooldata order by val");
1:e1d02a0:         JDBC.assertFullResultSet(rs, new String[][] {{"68"},{"77"}});
1:e1d02a0:         rollback();
1:e1d02a0:         rs = stmt.executeQuery("select val from stmtpooldata order by val");
1:e1d02a0:         JDBC.assertFullResultSet(rs, new String[][] {{"68"},{"77"}});
1:e1d02a0:         // Clean up
1:e1d02a0:         assertEquals(2, stmt.executeUpdate("delete from stmtpooldata"));
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Tests that nothing is committed on the connection when autocommit is
1:e1d02a0:      * disabled.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if something goes wrong...
1:e1d02a0:      */
1:e1d02a0:     public void resTestNoDataCommittedOnInvalidTransactionState()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         // Make sure the table is empty.
1:e1d02a0:         cleanTableExceptedToBeEmpty();
1:e1d02a0: 
1:e1d02a0:         // Start test
1:e1d02a0:         final String sql = "insert into stmtpooldata (val) values ?";
1:e1d02a0:         getConnection().setAutoCommit(false);
1:e1d02a0:         PreparedStatement ps = prepareStatement(sql);
1:e1d02a0:         ps.setInt(1, 68);
1:e1d02a0:         assertEquals(1, ps.executeUpdate());
1:e1d02a0:         ps.close();
1:e1d02a0:         ps = prepareStatement(sql);
1:e1d02a0:         ps.setInt(1, 77);
1:e1d02a0:         assertEquals(1, ps.executeUpdate());
1:e1d02a0:         Statement stmt = createStatement();
1:e1d02a0:         ResultSet rs = stmt.executeQuery(
1:e1d02a0:                 "select val from stmtpooldata order by val");
1:e1d02a0:         JDBC.assertFullResultSet(rs, new String[][] {{"68"},{"77"}});
1:e1d02a0:         try {
1:e1d02a0:             getConnection().close();
1:e1d02a0:             // We should not get here, but let's see what has happened.
1:e1d02a0:             // Possible symptoms:
1:e1d02a0:             //   - lock timeout: connection resources has not been freed.
1:e1d02a0:             //   - no rows: rollback was issued.
1:e1d02a0:             //   - two rows: commit was issued.
1:e1d02a0:             stmt = createStatement();
1:e1d02a0:             rs = stmt.executeQuery("select val from stmtpooldata order by val");
1:e1d02a0:             int rows = 0;
1:e1d02a0:             while (rs.next()) {
1:e1d02a0:                 rows++;
1:e1d02a0:             }
1:e1d02a0:             fail("Connection should not be allowed to close. Rows in table: " +
1:e1d02a0:                     rows);
1:e1d02a0:         } catch (SQLException sqle) {
1:e1d02a0:             assertSQLState("25001", sqle);
1:e1d02a0:             rollback();
1:e1d02a0:         }
1:e1d02a0:         stmt = createStatement();
1:e1d02a0:         rs = stmt.executeQuery("select val from stmtpooldata order by val");
1:e1d02a0:         JDBC.assertEmpty(rs);
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     /**
1:e1d02a0:      * Deletes row from a test table that is expected to be empty.
1:e1d02a0:      *
1:e1d02a0:      * @throws SQLException if a database operation fails
1:e1d02a0:      */
1:e1d02a0:     private void cleanTableExceptedToBeEmpty()
1:e1d02a0:             throws SQLException {
1:e1d02a0:         Statement stmt = createStatement();
1:e1d02a0:         ResultSet rs = stmt.executeQuery("select * from stmtpooldata");
1:e1d02a0:         int rowCount = 0;
1:e1d02a0:         while (rs.next()) {
1:e1d02a0:             rowCount++;
1:e1d02a0:         }
1:e1d02a0:         rs.close();
1:e1d02a0:         // Delete rows if any, and print a warning if verbosity is on.
1:e1d02a0:         if (rowCount > 0) {
1:e1d02a0:             println("Expected empty table, got " + rowCount + " rows.");
1:e1d02a0:             assertEquals(rowCount,
1:e1d02a0:                     stmt.executeUpdate("delete from stmtpooldata"));
1:e1d02a0:         }
1:e1d02a0:     }
1:e1d02a0: 
1:e1d02a0:     public static Test suite() {
1:1ae02c9:         BaseTestSuite suite = new BaseTestSuite("StatementPoolingTest suite");
1:1ae02c9:         BaseTestSuite baseSuite =
1:1ae02c9:             new BaseTestSuite(StatementPoolingTest.class);
1:1ae02c9: 
1:e1d02a0:         // Statement pooling is not yet enabled for XA.
1:e1d02a0:         //suite.addTest(TestConfiguration.connectionXADecorator(baseSuite));
1:e1d02a0:         suite.addTest(TestConfiguration.connectionCPDecorator(baseSuite));
1:e1d02a0: 
1:e1d02a0:         // Add tests that require data from the database.
1:1ae02c9:         BaseTestSuite reqDataSuite = new BaseTestSuite("Requires data suite");
1:e1d02a0:         reqDataSuite.addTest(new StatementPoolingTest(
1:e1d02a0:                 "resTestCloseDoesNotAffectOtherStatement"));
1:e1d02a0:         reqDataSuite.addTest(new StatementPoolingTest(
1:e1d02a0:                 "resTestLogicalConnectionCloseInvalidatesLogicalStatement"));
1:e1d02a0:         reqDataSuite.addTest(new StatementPoolingTest(
1:e1d02a0:                 "resTestHoldCursorsOverCommit"));
1:e1d02a0:         reqDataSuite.addTest(new StatementPoolingTest(
1:e1d02a0:                 "resTestCloseCursorsAtCommit"));
1:e1d02a0:         reqDataSuite.addTest(new StatementPoolingTest(
1:e1d02a0:                 "resTestNoCommitOnReuse"));
1:e1d02a0:         reqDataSuite.addTest(new StatementPoolingTest(
1:e1d02a0:                 "resTestCommitOnReuse"));
1:902041a:         reqDataSuite.addTest(new StatementPoolingTest(
1:902041a:                 "resTestNoDataCommittedOnInvalidTransactionState"));
1:e1d02a0:         suite.addTest(TestConfiguration.connectionCPDecorator(
1:e1d02a0:                 new BaseJDBCTestSetup(reqDataSuite) {
1:e1d02a0:                 public void setUp() throws Exception {
1:e1d02a0:                     // Generate some data we can use in the tests.
1:e1d02a0:                     Statement stmt = getConnection().createStatement();
1:e1d02a0:                     try {
1:e1d02a0:                         stmt.executeUpdate("drop table stmtpooltest");
1:e1d02a0:                     } catch (SQLException sqle) {
1:e1d02a0:                         assertSQLState("42Y55", sqle);
1:e1d02a0:                     }
1:e1d02a0:                     stmt.executeUpdate("create table stmtpooltest (" +
1:e1d02a0:                             "id int generated always as identity," +
1:e1d02a0:                             "val int)");
1:e1d02a0:                     PreparedStatement ps = getConnection().prepareStatement(
1:e1d02a0:                             "insert into stmtpooltest values (DEFAULT, ?)");
1:e1d02a0:                     // Insert data with val in range [1,7].
1:e1d02a0:                     for (int val=1; val <= 7; val++) {
1:e1d02a0:                         ps.setInt(1, val);
1:e1d02a0:                         ps.addBatch();
1:e1d02a0:                     }
1:e1d02a0:                     ps.executeBatch();
1:e1d02a0: 
1:e1d02a0:                     try {
1:e1d02a0:                         stmt.executeUpdate("drop table stmtpooldata");
1:e1d02a0:                     } catch (SQLException sqle) {
1:e1d02a0:                         assertSQLState("42Y55", sqle);
1:e1d02a0:                     }
1:e1d02a0:                     stmt.executeUpdate("create table stmtpooldata (" +
1:e1d02a0:                             "id int generated always as identity," +
1:e1d02a0:                             "val int)");
1:e1d02a0:                     // Leave this table empty.
1:e1d02a0:                 }
1:e1d02a0:             }));
1:e1d02a0:         return TestConfiguration.clientServerDecorator(suite);
1:e1d02a0:     }
1:b6af70a: 
1:b6af70a:     /**
1:b6af70a:      * A simple factory for obtaining logical connections from a pooled
1:b6af70a:      * connection created from a data source configured with statement caching.
1:b6af70a:      * <p>
1:b6af70a:      * For now we only support holding one pooled connection open, but the
1:b6af70a:      * factory can easily be extended to hold several pooled (physical)
1:b6af70a:      * connection open if a test requires it.
1:b6af70a:      */
1:b6af70a:     //@NotThreadSafe
1:b6af70a:     private static class LogicalPooledConnectionFactory {
1:b6af70a:         private int curCacheSize;
1:b6af70a:         private PooledConnection pooledConnection;
1:b6af70a:         
1:b6af70a:         public Connection getConnection(int cacheSize) 
1:b6af70a:                 throws SQLException {
1:b6af70a:             if (pooledConnection == null || curCacheSize != cacheSize) {
1:b6af70a:                 close();
1:b6af70a:                 ConnectionPoolDataSource cpDs =
1:b6af70a:                         J2EEDataSource.getConnectionPoolDataSource();
1:b6af70a:                 J2EEDataSource.setBeanProperty(
1:39b3237:                         cpDs, "maxStatements", cacheSize);
1:b6af70a:                 J2EEDataSource.setBeanProperty(
1:b6af70a:                         cpDs, "createDatabase", "create");
1:b6af70a:                 pooledConnection = cpDs.getPooledConnection();
1:b6af70a:                 curCacheSize = cacheSize;
1:b6af70a:             }
1:b6af70a:             return pooledConnection.getConnection();
1:b6af70a:         }
1:b6af70a: 
1:b6af70a:         public void close()
1:b6af70a:                 throws SQLException {
1:b6af70a:             if (pooledConnection != null) {
1:b6af70a:                 try {
1:b6af70a:                     pooledConnection.close();
1:b6af70a:                 } finally {
1:b6af70a:                     pooledConnection = null;
1:b6af70a:                     curCacheSize = -1;
1:b6af70a:                 }
1:b6af70a:             }
1:b6af70a:         }
1:b6af70a:     }
1:e1d02a0: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:39b3237
/////////////////////////////////////////////////////////////////////////
1:                         cpDs, "maxStatements", cacheSize);
commit:2a51fce
/////////////////////////////////////////////////////////////////////////
1: 
0:             if ( isJava8() && expectedName.contains( "Statement" ) )
1:             {
1:                 expectedName += "42";
1:             }
0:             else
1:             {
1:                 expectedName += "40";
1:             }
commit:314a6da
/////////////////////////////////////////////////////////////////////////
0:     public void t01_testCacheOverflow()
/////////////////////////////////////////////////////////////////////////
0:     public void t02_testPoolingEnabledByCheckingImplementationDetails()
/////////////////////////////////////////////////////////////////////////
0:     public void t03_testPrepareStatementPath()
/////////////////////////////////////////////////////////////////////////
0:     public void t04_testPrepareCallPath()
/////////////////////////////////////////////////////////////////////////
0:     public void t05_testPrepareCallWithNoCallPath()
/////////////////////////////////////////////////////////////////////////
0:     public void t06_testClosingPSClosesRS()
/////////////////////////////////////////////////////////////////////////
0:     public void t07_testHoldabilityIsResetExplicitClose()
/////////////////////////////////////////////////////////////////////////
0:     public void t08_testHoldabilityIsResetNoExplicitClose()
/////////////////////////////////////////////////////////////////////////
0:     public void t09_testIsolationLevelIsResetExplicitCloseQuery()
0:     public void t11_testIsolationLevelIsResetExplicitCloseNoQuery()
0:     public void t12_testIsolationLevelIsResetNoExplicitCloseNoQuery()
0:     public void t13_testIsolationLevelIsResetNoExplicitCloseQuery()
/////////////////////////////////////////////////////////////////////////
0:     public void t14_testCachingLogicalConnectionCloseLeavesPhysicalStatementsOpen()
/////////////////////////////////////////////////////////////////////////
0:     public void t15_testDeleteReferringTableWhenOpen()
/////////////////////////////////////////////////////////////////////////
0:     public void t16_testDeleteReferringTableWhenInCache()
/////////////////////////////////////////////////////////////////////////
0:     public void t17_testTemporaryTablesAreDeletedInNewLogicalConnection()
/////////////////////////////////////////////////////////////////////////
0:     public void t18_testGetStatementCallable()
/////////////////////////////////////////////////////////////////////////
0:     public void t19_testGetStatementPrepared()
/////////////////////////////////////////////////////////////////////////
0:     public  void    testAll() throws Exception
0:     {
0:         t01_testCacheOverflow();
0:         t02_testPoolingEnabledByCheckingImplementationDetails();
0:         t03_testPrepareStatementPath();
0:         t04_testPrepareCallPath();
0:         t05_testPrepareCallWithNoCallPath();
0:         t06_testClosingPSClosesRS();
0:         t07_testHoldabilityIsResetExplicitClose();
0:         t08_testHoldabilityIsResetNoExplicitClose();
0:         t09_testIsolationLevelIsResetExplicitCloseQuery();
0:         t11_testIsolationLevelIsResetExplicitCloseNoQuery();
0:         t12_testIsolationLevelIsResetNoExplicitCloseNoQuery();
0:         t13_testIsolationLevelIsResetNoExplicitCloseQuery();
0:         t14_testCachingLogicalConnectionCloseLeavesPhysicalStatementsOpen();
0:         t15_testDeleteReferringTableWhenOpen();
0:         t16_testDeleteReferringTableWhenInCache();
0:         t17_testTemporaryTablesAreDeletedInNewLogicalConnection();
0:         t18_testGetStatementCallable();
0:         t19_testGetStatementPrepared();
1:     }
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.BaseTestSuite;
/////////////////////////////////////////////////////////////////////////
1:         BaseTestSuite suite = new BaseTestSuite("StatementPoolingTest suite");
1:         BaseTestSuite baseSuite =
1:             new BaseTestSuite(StatementPoolingTest.class);
1: 
1:         BaseTestSuite reqDataSuite = new BaseTestSuite("Requires data suite");
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:939acff
/////////////////////////////////////////////////////////////////////////
1:             if (JDBC.vmSupportsJDBC42()
1:                     && expectedName.contains("Statement"))
commit:9a0cdf1
/////////////////////////////////////////////////////////////////////////
1:             else if (usingEmbedded())
commit:4a515d8
/////////////////////////////////////////////////////////////////////////
1:     public void testCacheOverflow()
/////////////////////////////////////////////////////////////////////////
1:     public void testPoolingEnabledByCheckingImplementationDetails()
/////////////////////////////////////////////////////////////////////////
1:     public void testPrepareStatementPath()
/////////////////////////////////////////////////////////////////////////
1:     public void testPrepareCallPath()
/////////////////////////////////////////////////////////////////////////
1:     public void testPrepareCallWithNoCallPath()
/////////////////////////////////////////////////////////////////////////
1:     public void testClosingPSClosesRS()
/////////////////////////////////////////////////////////////////////////
1:     public void testHoldabilityIsResetExplicitClose()
/////////////////////////////////////////////////////////////////////////
1:     public void testHoldabilityIsResetNoExplicitClose()
/////////////////////////////////////////////////////////////////////////
1:     public void testIsolationLevelIsResetExplicitCloseQuery()
1:     public void testIsolationLevelIsResetExplicitCloseNoQuery()
1:     public void testIsolationLevelIsResetNoExplicitCloseNoQuery()
1:     public void testIsolationLevelIsResetNoExplicitCloseQuery()
/////////////////////////////////////////////////////////////////////////
1:     public void testCachingLogicalConnectionCloseLeavesPhysicalStatementsOpen()
/////////////////////////////////////////////////////////////////////////
1:     public void testDeleteReferringTableWhenOpen()
/////////////////////////////////////////////////////////////////////////
1:     public void testDeleteReferringTableWhenInCache()
/////////////////////////////////////////////////////////////////////////
1:     public void testTemporaryTablesAreDeletedInNewLogicalConnection()
/////////////////////////////////////////////////////////////////////////
1:     public void testGetStatementCallable()
/////////////////////////////////////////////////////////////////////////
1:     public void testGetStatementPrepared()
/////////////////////////////////////////////////////////////////////////
commit:902041a
/////////////////////////////////////////////////////////////////////////
1:         con.commit();
/////////////////////////////////////////////////////////////////////////
1:             rollback();
/////////////////////////////////////////////////////////////////////////
1:         reqDataSuite.addTest(new StatementPoolingTest(
1:                 "resTestNoDataCommittedOnInvalidTransactionState"));
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:b6af70a
/////////////////////////////////////////////////////////////////////////
1:     private LogicalPooledConnectionFactory lpcf;
1: 
1:     public void tearDown()
1:             throws Exception {
1:         closePooledConnectionFactory();
1:         super.tearDown();
1:     }
1:     
1:     /** Closes the connection factory associated with this test. */
1:     private void closePooledConnectionFactory()
1:             throws SQLException {
1:         if (lpcf != null) {
1:             try {
1:                 lpcf.close();
1:             } finally {
1:                 lpcf = null;
1:             }
1:         }
1:     }
1: 
1:     /**
1:      * Returns a logical connection from a pooled connection obtained from a
1:      * data source configured with a default statement cache size.
1:      *
1:      * @return A logical connection.
1:      * @throws SQLException if obtaining the connection fails
1:      */
1:     private Connection getCachingConnection()
1:             throws SQLException {
1:         return getCachingConnection(7);
1:     }
1: 
1:     /**
1:      * Returns a logical connection from a pooled connection obtained from a
1:      * data source configured to have the specified statement cache size.
1:      *
1:      * @param cacheSize statement cache size
1:      * @return A logical connection.
1:      * @throws SQLException if obtaining the connection fails
1:      */
1:     private Connection getCachingConnection(int cacheSize)
1:             throws SQLException {
1:         if (lpcf == null) {
1:             lpcf = new LogicalPooledConnectionFactory();
1:         }
1:         return lpcf.getConnection(cacheSize);
1:     }
1: 
/////////////////////////////////////////////////////////////////////////
1:         Connection con = getCachingConnection(11);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Connection con = getCachingConnection();
/////////////////////////////////////////////////////////////////////////
1:      * This test merely checks that creating a logical prepared statement does
/////////////////////////////////////////////////////////////////////////
1:      * This test merely checks that creating a logical callable statement does
/////////////////////////////////////////////////////////////////////////
1:      * This test merely checks that creating a logical callable statement, which
/////////////////////////////////////////////////////////////////////////
1:         Connection con = getCachingConnection();
/////////////////////////////////////////////////////////////////////////
1:         con = getCachingConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection con = getCachingConnection();
/////////////////////////////////////////////////////////////////////////
1:         con = getCachingConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection con = getCachingConnection();
/////////////////////////////////////////////////////////////////////////
1:         con = getCachingConnection();
/////////////////////////////////////////////////////////////////////////
1:      * Tests that a temporary table created in one logical connection is gone
1:         Connection lcOne = getCachingConnection();
/////////////////////////////////////////////////////////////////////////
1:         Connection lcTwo = getCachingConnection();
/////////////////////////////////////////////////////////////////////////
1:      * @param holdability result set holdability as specified by
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * A simple factory for obtaining logical connections from a pooled
1:      * connection created from a data source configured with statement caching.
1:      * <p>
1:      * For now we only support holding one pooled connection open, but the
1:      * factory can easily be extended to hold several pooled (physical)
1:      * connection open if a test requires it.
1:      */
1:     //@NotThreadSafe
1:     private static class LogicalPooledConnectionFactory {
1:         private int curCacheSize;
1:         private PooledConnection pooledConnection;
1:         
1:         public Connection getConnection(int cacheSize) 
1:                 throws SQLException {
1:             if (pooledConnection == null || curCacheSize != cacheSize) {
1:                 close();
1:                 ConnectionPoolDataSource cpDs =
1:                         J2EEDataSource.getConnectionPoolDataSource();
1:                 J2EEDataSource.setBeanProperty(
0:                         cpDs, "maxStatements", new Integer(cacheSize));
1:                 J2EEDataSource.setBeanProperty(
1:                         cpDs, "createDatabase", "create");
1:                 pooledConnection = cpDs.getPooledConnection();
1:                 curCacheSize = cacheSize;
1:             }
1:             return pooledConnection.getConnection();
1:         }
1: 
1:         public void close()
1:                 throws SQLException {
1:             if (pooledConnection != null) {
1:                 try {
1:                     pooledConnection.close();
1:                 } finally {
1:                     pooledConnection = null;
1:                     curCacheSize = -1;
1:                 }
1:             }
1:         }
1:     }
commit:d798bb1
/////////////////////////////////////////////////////////////////////////
1:      * Make sure {@link ResultSet#getStatement} returns the same object as the
1:      * one that created the result set.
1:      */
0:     public void testGetStatementCallable()
1:             throws SQLException {
1:         doTestGetStatement(prepareCall("values 7653"));
1:     }
1: 
1:     /**
1:      * Make sure {@link ResultSet#getStatement} returns the same object as the
1:      * one that created the result set.
1:      */
0:     public void testGetStatementPrepared()
1:             throws SQLException {
1:         doTestGetStatement(prepareStatement("values 7652"));
1:     }
1: 
1:     /**
1:      * Make sure {@link ResultSet#getStatement} returns the same object as the
1:      * one that created the result set.
1:      *
1:      * @param ps prepared or callable statement to test with
1:      * @throws SQLException if something goes wrong...
1:      */
1:     private void doTestGetStatement(PreparedStatement ps)
1:             throws SQLException {
1:         ResultSet psRs = ps.executeQuery();
1:         assertSame(ps, psRs.getStatement());
1:         psRs.close();
1:         // Try another way.
1:         ps.execute();
1:         psRs = ps.getResultSet();
1:         assertSame(ps, psRs.getStatement());
1:         assertFalse(ps.getMoreResults());
1:         assertNull(ps.getResultSet());
1:         // This one should fail.
1:         try {
1:             psRs = ps.executeQuery("values 99");
1:             fail("executeQuery(String) should be disallowed");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ016", sqle);
1:         }
1:     }
1: 
1:     /**
commit:f8c4fd4
/////////////////////////////////////////////////////////////////////////
1:         assertEquals(expectedName, simpleName);
commit:ef81d0e
/////////////////////////////////////////////////////////////////////////
1:         final String dmdClass = "LogicalDatabaseMetaData";
/////////////////////////////////////////////////////////////////////////
1:         assertClassName(con.getMetaData(), dmdClass);
/////////////////////////////////////////////////////////////////////////
1:      * <p>
1:      * <b>WARNING</b>: This method is not a general utility method. Please look
1:      * at the implementation to determine if you can use it.
/////////////////////////////////////////////////////////////////////////
1:         final String simpleName = names[names.length -1];
1:         if (JDBC.vmSupportsJDBC4() && !expectedName.endsWith("40")) {
0:             expectedName += "40";
1:         }
0:             fail("Expected class name " + expectedName + ", got " +
0:                     simpleName);
commit:f2a8f00
/////////////////////////////////////////////////////////////////////////
1:      * Tests that closing the caching logical connection closes the logical
1:      * prepared statement, but not the physical prepared statement.
1:      * Since there are no public interface methods to test this, the approach
1:      * taken will be as follows:
1:      * <ol> <li>Create a new table.</li>
/////////////////////////////////////////////////////////////////////////
1:      * execution will fail because the table no longer exists.
0:     public void testCachingLogicalConnectionCloseLeavesPhysicalStatementsOpen()
1:         final String SELECT_SQL = "select * from clcclso";
/////////////////////////////////////////////////////////////////////////
1:         PreparedStatement ps = con.prepareStatement(SELECT_SQL);
1:             // Should fail because the logical statement has been closed.
1:             fail("Logical connection close did not close logical statement.");
/////////////////////////////////////////////////////////////////////////
1:         ps = con.prepareStatement(SELECT_SQL); // From cache.
1:             // Should fail here because the referenced table has been deleted.
commit:ea777fe
/////////////////////////////////////////////////////////////////////////
0:         J2EEDataSource.setBeanProperty(cpDs, "createDatabase", "create");
/////////////////////////////////////////////////////////////////////////
0:         J2EEDataSource.setBeanProperty(cpDs, "createDatabase", "create");
/////////////////////////////////////////////////////////////////////////
0:         J2EEDataSource.setBeanProperty(cpDs, "createDatabase", "create");
/////////////////////////////////////////////////////////////////////////
0:         J2EEDataSource.setBeanProperty(cpDs, "createDatabase", "create");
/////////////////////////////////////////////////////////////////////////
0:      * Tests that a temporary table crated in one logical connection is gone
1:      * in the next logical connection.
1:      *
1:      * @throws SQLException if the test fails for some reason
1:      */
0:     public void testTemporaryTablesAreDeletedInNewLogicalConnection()
1:             throws SQLException {
0:         ConnectionPoolDataSource cpds =
0:                 J2EEDataSource.getConnectionPoolDataSource();
0:         J2EEDataSource.setBeanProperty(cpds, "maxStatements", new Integer(3));
0:         J2EEDataSource.setBeanProperty(cpds, "createDatabase", "create");
0:         PooledConnection pc = cpds.getPooledConnection();
0:         Connection lcOne = pc.getConnection();
1: 
1:         // Create the first logical connection and the temporary table.
1:         Statement stmt = lcOne.createStatement();
1:         stmt.executeUpdate("DECLARE GLOBAL TEMPORARY TABLE cpds_temp_table " +
1:                 "(id int) ON COMMIT PRESERVE ROWS NOT LOGGED");
1:         // The temporary table is created in SESSION.
1:         JDBC.assertEmpty(
1:                 stmt.executeQuery("select * from SESSION.cpds_temp_table"));
1:         stmt.executeUpdate("insert into SESSION.cpds_temp_table values 1");
1:         lcOne.commit();
1:         lcOne.close();
1: 
1:         // Create the second logical connection and try to query the temp table.
0:         Connection lcTwo = pc.getConnection();
1:         stmt = lcTwo.createStatement();
1:         try {
1:             stmt.executeQuery("select * from SESSION.cpds_temp_table");
1:             fail("Temporary table still existing in new logical connection.");
1:         } catch (SQLException sqle) {
1:             // Expect syntax error.
1:             assertSQLState("42X05", sqle);
1:         }
1:         lcTwo.rollback();
1:         lcTwo.close();
0:         pc.close();
1:     }
1: 
1:     /**
commit:e1d02a0
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.StatementPoolingTest
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1: */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1: 
1: import java.sql.CallableStatement;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import javax.sql.ConnectionPoolDataSource;
1: import javax.sql.PooledConnection;
1: import junit.framework.Test;
0: import junit.framework.TestSuite;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.BaseJDBCTestSetup;
1: import org.apache.derbyTesting.junit.J2EEDataSource;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * A set of tests specifically targeted at connections that support statement
1:  * pooling.
1:  */
1: public class StatementPoolingTest
1:     extends BaseJDBCTestCase {
1: 
1:     public StatementPoolingTest(String name) {
1:         super(name);
1:     }
1: 
1:     /**
1:      * Tests that the statement cache is able to throw out prepared statements
1:      * when it reaches maximum capacity.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
0:     public void testCacheOverflow()
1:             throws SQLException {
1:         final int stmtCount = 150;
0:         ConnectionPoolDataSource cpDs =
0:                 J2EEDataSource.getConnectionPoolDataSource();
0:         J2EEDataSource.setBeanProperty(cpDs, "maxStatements", new Integer(11));
0:         PooledConnection pc = cpDs.getPooledConnection();
0:         Connection con = pc.getConnection();
1:         for (int i=0; i < stmtCount; i++) {
1:             // Yes, the "values + i" is intended here.
1:             PreparedStatement pStmt = con.prepareStatement("values " + i);
1:             ResultSet rs = pStmt.executeQuery();
1:             JDBC.assertSingleValueResultSet(rs, Integer.toString(i));
1:             pStmt.close();
1:         }
1:         con.close();
0:         pc.close();
1:     }
1: 
1:     /**
1:      * Verifies that statement pooling is enabled by checking the names of the
1:      * implementation classes in Derby.
1:      *
1:      * @throws SQLException if creating the JDBC objects fail
1:      */
0:     public void testPoolingEnabledByCheckingImplementationDetails()
1:             throws SQLException {
1:         final String conClass = "CachingLogicalConnection";
1:         final String psClass = "LogicalPreparedStatement";
1:         final String csClass = "LogicalCallableStatement";
1:         Connection con = getConnection();
1:         assertClassName(con, conClass);
1:         assertClassName(con.prepareStatement("values 1"), psClass);
1:         assertClassName(con.prepareStatement("values 1",
1:                                              Statement.RETURN_GENERATED_KEYS),
1:                         psClass);
1:         assertClassName(con.prepareStatement("values 1",
1:                                              Statement.NO_GENERATED_KEYS),
1:                         psClass);
1:         assertClassName(con.prepareStatement("values 1",
1:                                              ResultSet.TYPE_FORWARD_ONLY,
1:                                              ResultSet.CONCUR_READ_ONLY),
1:                         psClass);
1:         assertClassName(con.prepareStatement("values 1",
1:                                              ResultSet.TYPE_SCROLL_INSENSITIVE,
1:                                              ResultSet.CONCUR_UPDATABLE),
1:                         psClass);
1:         assertClassName(con.prepareStatement("values 1",
1:                                              (String[])null),
1:                         psClass);
1:         assertClassName(con.prepareStatement("values 1",
1:                                              new String[] {}),
1:                         psClass);
1:         assertClassName(con.prepareCall("values 1"), csClass);
1:         assertClassName(con.prepareCall("values 1",
1:                                         ResultSet.TYPE_FORWARD_ONLY,
1:                                         ResultSet.CONCUR_READ_ONLY),
1:                         csClass);
1:         assertClassName(con.prepareCall("values 1",
1:                                         ResultSet.TYPE_FORWARD_ONLY,
1:                                         ResultSet.CONCUR_READ_ONLY,
1:                                         ResultSet.CLOSE_CURSORS_AT_COMMIT),
1:                         csClass);
1:     }
1: 
1:     /**
1:      * Assert that the name of the class of the object is what is expected.
1:      * <p>
1:      * The assert does not consider package names, only the name passed in as
1:      * {@code expectedName} and the passed in name concatenated with "40".
1:      *
1:      * @param obj object to check
1:      * @param expectedName the expected name of the class
1:      * @throws AssertionFailedError if the class name is not as expected
1:      */
1:     private static void assertClassName(Object obj, String expectedName) {
1:         assertNotNull("The expected name cannot be <null>", expectedName);
1:         assertNotNull("The object cannot be <null>", obj);
1:         String[] names = obj.getClass().getName().split("\\.");
0:         String simpleName = names[names.length -1];
0:         if (!simpleName.equals(expectedName)) {
0:             if (!simpleName.equals(expectedName + "40")) {
0:                 fail("Expected class name " + expectedName + " or " +
0:                         expectedName + "40, got " + simpleName);
1:             }
1:         }
1:     }
1: 
1:     /**
0:      * This test merley checks that creating a logical prepared statement does
1:      * not fail.
1:      *
1:      * @throws SQLException if creating the prepared statement fails
1:      */
0:     public void testPrepareStatementPath()
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement("values 9708");
1:         ps.close();
1:     }
1: 
1:     /**
0:      * This test merley checks that creating a logical callable statement does
1:      * not fail.
1:      *
1:      * @throws SQLException if creating the callable statement fails
1:      */
0:     public void testPrepareCallPath()
1:             throws SQLException {
1:         CallableStatement cs = prepareCall(
1:                 "CALL SYSCS_UTIL.SYSCS_SET_RUNTIMESTATISTICS(0)");
1:         cs.close();
1:     }
1: 
1:     /**
0:      * This test merley checks that creating a logical callable statement, which
1:      * is not really a call, does not fail.
1:      *
1:      * @throws SQLException if creating the callable statement fails
1:      */
0:     public void testPrepareCallWithNoCallPath()
1:             throws SQLException {
1:         CallableStatement cs = prepareCall("values 1");
1:         cs.close();
1:     }
1: 
1:     /**
1:      * Tests that closing the prepared statement also closes the result set.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
0:     public void testClosingPSClosesRS()
1:             throws SQLException {
1:         PreparedStatement ps = prepareStatement("values 99");
1:         ResultSet rs = ps.executeQuery();
1:         ps.close();
1:         try {
1:             rs.next();
1:             fail("Result set should have been closed");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XCL16", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Tests that the connection holdability is reset, when it is first
1:      * modified, the connection closed and a new logical connection obtained.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
0:     public void testHoldabilityIsResetExplicitClose()
1:             throws SQLException {
1:         doTestHoldabilityIsReset(true);
1:     }
1: 
1:     /**
1:      * Tests that the connection holdability is reset, when it is first
1:      * modified, and a new logical connection obtained without first explicitly
1:      * closing the previous one.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
0:     public void testHoldabilityIsResetNoExplicitClose()
1:             throws SQLException {
1:         doTestHoldabilityIsReset(false);
1:     }
1: 
1:     /**
1:      * Test sequence for testing if the connection holdability is reset.
1:      *
1:      * @param closeConnection determines if the logical connection is
1:      *      explicitly closed before a new one is obtained
1:      * @throws SQLException if something goes wrong...
1:      */
1:     private void doTestHoldabilityIsReset(final boolean closeConnection)
1:             throws SQLException {
0:         ConnectionPoolDataSource cpDs =
0:                 J2EEDataSource.getConnectionPoolDataSource();
0:         J2EEDataSource.setBeanProperty(cpDs, "maxStatements", new Integer(7));
0:         PooledConnection pc = cpDs.getPooledConnection();
1:         // Keep track of our own connection, the framework currently creates
1:         // a new pooled connection and then obtains a connection from that.
1:         // Statement pooling only works within a single pooled connection.
0:         Connection con = pc.getConnection();
1:         assertEquals("Unexpected default holdability",
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT, con.getHoldability());
1:         con.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:         assertEquals("Holdability not updated",
1:                 ResultSet.CLOSE_CURSORS_AT_COMMIT, con.getHoldability());
1:         if (closeConnection) {
1:             con.close();
1:         }
0:         con = pc.getConnection();
1:         assertEquals("Holdability not reset",
1:                 ResultSet.HOLD_CURSORS_OVER_COMMIT, con.getHoldability());
0:         pc.close();
1:     }
1: 
0:     public void testIsolationLevelIsResetExplicitCloseQuery()
1:             throws SQLException {
1:         doTestIsolationLevelIsReset(true, true);
1:     }
1: 
0:     public void testIsolationLevelIsResetExplicitCloseNoQuery()
1:             throws SQLException {
1:         doTestIsolationLevelIsReset(true, false);
1:     }
1: 
0:     public void testIsolationLevelIsResetNoExplicitCloseNoQuery()
1:             throws SQLException {
1:         doTestIsolationLevelIsReset(false, false);
1:     }
1: 
0:     public void testIsolationLevelIsResetNoExplicitCloseQuery()
1:             throws SQLException {
1:         doTestIsolationLevelIsReset(false, true);
1:     }
1: 
1:     /**
1:      * Tests if the connection isolation level is reset when a new connection
1:      * is obtained.
1:      * <p>
1:      * The two arguments are introduced to test different scenarios; explicit
1:      * and implicit connection closing, and session data caching (piggybacked
1:      * information).
1:      *
1:      * @param closeConnection tells if the connection is explicitly closed
1:      *      before a new one is obtained
1:      * @param executeQuery tells if a query is executed on the connection before
1:      *      a new connection is obtained.
1:      * @throws SQLException if something goes wrong...
1:      */
1:     private void doTestIsolationLevelIsReset(final boolean closeConnection,
1:                                              final boolean executeQuery)
1:             throws SQLException {
0:         ConnectionPoolDataSource cpDs =
0:                 J2EEDataSource.getConnectionPoolDataSource();
0:         J2EEDataSource.setBeanProperty(cpDs, "maxStatements", new Integer(7));
0:         PooledConnection pc = cpDs.getPooledConnection();
1:         // Keep track of our own connection, the framework currently creates
1:         // a new pooled connection and then obtains a connection from that.
1:         // Statement pooling only works within a single pooled connection.
0:         Connection con = pc.getConnection();
1:         assertEquals("Unexpected default isolation level",
1:                 Connection.TRANSACTION_READ_COMMITTED,
1:                 con.getTransactionIsolation());
1:         con.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);
1:         assertEquals("Isolation level not updated",
1:                 Connection.TRANSACTION_REPEATABLE_READ,
1:                 con.getTransactionIsolation());
1:         if (executeQuery) {
1:             PreparedStatement ps = con.prepareStatement("values 2");
1:             JDBC.assertSingleValueResultSet(ps.executeQuery(), "2");
1:             ps.close();
1:         }
1:         if (closeConnection) {
1:             con.close();
1:         }
0:         con = pc.getConnection();
1:         assertEquals("Isolation level not reset",
1:                 Connection.TRANSACTION_READ_COMMITTED,
1:                 con.getTransactionIsolation());
0:         pc.close();
1:     }
1: 
1:     /**
0:      * Tests that closing the connection closes the logical prepared statement,
0:      * but not the physical statement.
1:      * <p>
0:      * Since there are not public interface methods to test this, the approcah
0:      * taken will be this:
0:      * <ol> <li>Create a new table</li>
1:      *      <li>Prepare a statement selecting from the table.</li>
1:      *      <li>Close the statement, putting it into the cache.</li>
1:      *      <li>Delete the table.</li>
1:      *      <li>Prepare the selecting statement again.</li>
1:      *      <li>Execute the statement.</li>
1:      * </ol>
1:      * If the physical statement was closed when closing the caching logical
1:      * connection, the prepare will fail. If it was left open, the prepare will
1:      * succeed because the statement is fetched from the cache, but the
0:      * execution will fail becuase the table no longer exists.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
0:     public void testCachingLogicalConnectionCloseLeavesStatementsOpen()
1:             throws SQLException {
0:         ConnectionPoolDataSource cpDs =
0:                 J2EEDataSource.getConnectionPoolDataSource();
0:         J2EEDataSource.setBeanProperty(cpDs, "maxStatements", new Integer(7));
0:         PooledConnection pc = cpDs.getPooledConnection();
1:         // Keep track of our own connection, the framework currently creates
1:         // a new pooled connection and then obtains a connection from that.
1:         // Statement pooling only works within a single pooled connection.
0:         Connection con = pc.getConnection();
1:         con.setAutoCommit(false);
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("create table clcclso (id int)");
0:         PreparedStatement ps = con.prepareStatement("select * from clcclso");
1:         commit();
1:         con.close();
1:         try {
1:             ps.execute();
1:         } catch (SQLException sqle) {
1:             // Already closed.
1:             assertSQLState("XJ012", sqle);
1:         }
1:         stmt = createStatement();
1:         stmt.executeUpdate("drop table clcclso");
1:         commit();
1:         // If an exception is thrown here, statement pooling is disabled or not
1:         // working correctly.
0:         con = pc.getConnection();
0:         ps = con.prepareStatement("select * from clcclso");
1:         try {
1:             ps.execute();
1:             fail("Execution should have failed");
1:         } catch (SQLException sqle) {
1:             assertSQLState("42X05", sqle);
1:         }
1:         ps.close();
1:         // Make sure the connection is still valid.
1:         ps = con.prepareStatement("values 976");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "976");
1:         ps.close();
1:         con.close();
1:     }
1: 
1:     /**
1:      * Checks if a reset of one statement affects other open statement on the
1:      * connection.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
1:     public void resTestCloseDoesNotAffectOtherStatement()
1:             throws SQLException {
1:         final String sql = "select * from stmtpooltest where val > 0 and val " +
1:                 "<= 7 order by val";
1:         PreparedStatement psForward = prepareStatement(sql);
1:         ResultSet rsForward = psForward.executeQuery();
1:         assertTrue(rsForward.next());
1:         assertEquals("1", rsForward.getString(1));
1:         assertTrue(rsForward.next());
1:         assertEquals("2", rsForward.getString(1));
1:         PreparedStatement psScrollable = prepareStatement(sql,
1:                 ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
1:         ResultSet rsScrollable = psScrollable.executeQuery();
1:         // Read seven rows from the scrollable rs, position at last row.
1:         for (int val=1; val <= 7; val++) {
1:             assertTrue(rsScrollable.next());
1:             assertEquals(val, rsScrollable.getInt(1));
1:         }
1: 
1:         // Create a statement, then close it.
1:         PreparedStatement psToClose = prepareStatement(
1:                 "select val from stmtpooltest where val = 5");
1:         JDBC.assertSingleValueResultSet(psToClose.executeQuery(), "5");
1:         psToClose.close();
1:         assertTrue(rsForward.next());
1:         assertEquals("3", rsForward.getString(1));
1:         assertTrue(rsScrollable.first());
1:         assertEquals("1", rsScrollable.getString(1));
1:         // Should fetch a cached statement.
1:         psToClose = prepareStatement(
1:                 "select val from stmtpooltest where val = 5");
1:         JDBC.assertSingleValueResultSet(psToClose.executeQuery(), "5");
1:         psToClose.close();
1:         assertTrue(rsScrollable.last());
1:         assertEquals("7", rsScrollable.getString(1));
1:         assertFalse(rsScrollable.next());
1:         rsScrollable.close();
1:         assertTrue(rsForward.next());
1:         assertEquals("4", rsForward.getString(1));
1:         rsForward.close();
1:     }
1: 
1:     /**
1:      * Tests that closing a logical prepared statement referring a non-existing
1:      * table works.
1:      * <p>
1:      * In this test, the prepared statement that will be made invalid by the
1:      * delete is held open by the user.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
0:     public void testDeleteReferringTableWhenOpen()
1:             throws SQLException {
1:         getConnection().setAutoCommit(false);
1:         // Create a table, insert a row, then create a statement selecting it.
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("create table testdeletewhenopen (id int)");
1:         stmt.executeUpdate("insert into testdeletewhenopen values 1");
1:         PreparedStatement ps = prepareStatement(
1:                 "select * from testdeletewhenopen");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:         // Now delete the table and logically close the prepared statement.
1:         stmt.executeUpdate("drop table testdeletewhenopen");
1:         stmt.close();
1:         ps.close();
1:         // If running without statement pooling, you will get exception here.
1:         ps = prepareStatement("select * from testdeletewhenopen");
1:         // If we get this far, there is a big change we have fetched an
1:         // invalid statement from the cache, but we won't get the exception
1:         // until we try to execute it.
1:         try {
1:             ps.executeQuery();
1:             fail("Prepared statement not valid, referring non-existing table");
1:         } catch (SQLException sqle) {
1:             assertSQLState("42X05", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Tests that closing a logical prepared statement referring a non-existing
1:      * table works.
1:      * <p>
1:      * In this test, the prepared statement that will be made invalid by the
1:      * delete is in the statement cache when the delete happens.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
0:     public void testDeleteReferringTableWhenInCache()
1:             throws SQLException {
1:         getConnection().setAutoCommit(false);
1:         // Create a table, insert a row, then create a statement selecting it.
1:         Statement stmt = createStatement();
1:         stmt.executeUpdate("create table testdeletewhenopen (id int)");
1:         stmt.executeUpdate("insert into testdeletewhenopen values 1");
1:         PreparedStatement ps = prepareStatement(
1:                 "select * from testdeletewhenopen");
1:         JDBC.assertSingleValueResultSet(ps.executeQuery(), "1");
1:         // Put the statement into the cache.
1:         ps.close();
1:         // Now delete the table and fetch the cached prepared statement.
1:         stmt.executeUpdate("drop table testdeletewhenopen");
1:         stmt.close();
1:         // If running without statement pooling, you will get exception here.
1:         ps = prepareStatement("select * from testdeletewhenopen");
1:         // If we get this far, there is a big change we have fetched an
1:         // invalid statement from the cache, but we won't get the exception
1:         // until we try to execute it.
1:         try {
1:             ps.executeQuery();
1:             fail("Prepared statement not valid, referring non-existing table");
1:         } catch (SQLException sqle) {
1:             assertSQLState("42X05", sqle);
1:         }
1:     }
1: 
1:     public void resTestCloseCursorsAtCommit()
1:             throws SQLException {
1:         doTestResultSetCloseForHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);
1:     }
1: 
1:     public void resTestHoldCursorsOverCommit()
1:             throws SQLException {
1:         doTestResultSetCloseForHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);
1:     }
1: 
1:     /**
1:      * Tests if the holdability settings is taking effect, and also that the
1:      * result set is closed when the connection is closed.
1:      *
0:      * @param holdability result set holdability as specfied by
1:      *      {@link java.sql.ResultSet}
1:      * @throws SQLException if something goes wrong...
1:      */
1:     private void doTestResultSetCloseForHoldability(int holdability)
1:             throws SQLException {
1:         getConnection().setAutoCommit(false);
1:         PreparedStatement ps = prepareStatement(
1:                 "select * from stmtpooltest order by val",
1:                 ResultSet.TYPE_FORWARD_ONLY,
1:                 ResultSet.CONCUR_READ_ONLY,
1:                 holdability);
1:         ResultSet rs = ps.executeQuery();
1:         assertTrue(rs.next());
1:         assertEquals(1, rs.getInt(1));
1:         commit();
1:         if (holdability == ResultSet.HOLD_CURSORS_OVER_COMMIT) {
1:             assertTrue(rs.next());
1:             assertEquals(2, rs.getInt(1));
1:         }
1:         getConnection().close();
1:         try {
1:             rs.next();
1:             fail("Should have thrown exception");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XCL16", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Checks if closing the logical connection closes the logical statement.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
1:     public void resTestLogicalConnectionCloseInvalidatesLogicalStatement()
1:             throws SQLException {
1:         Connection con = getConnection();
1:         PreparedStatement ps =
1:                 con.prepareStatement("select * from stmtpooltest");
1:         // Don't execute the statement.
1:         assertNotNull(ps.getMetaData());
1:         con.close();
1:         try {
1:             ps.getMetaData();
1:             fail("Logical statement should be closed and throw exception");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ012", sqle);
1:         }
1:         con = getConnection();
1:         ps = con.prepareStatement("select * from stmtpooltest order by val");
1:         // Execute the statement this time.
1:         ResultSet rs = ps.executeQuery();
1:         assertTrue(rs.next());
1:         assertNotNull(ps.getMetaData());
1:         rs.close();
1:         con.close();
1:         try {
1:             ps.getMetaData();
1:             fail("Logical statement should be closed and throw exception");
1:         } catch (SQLException sqle) {
1:             assertSQLState("XJ012", sqle);
1:         }
1:     }
1: 
1:     /**
1:      * Tests that nothing is committed on the connection when autocommit is
1:      * disabled.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
1:     public void resTestNoCommitOnReuse()
1:             throws SQLException {
1:         // Make sure the table is empty.
1:         cleanTableExceptedToBeEmpty();
1: 
1:         // Start test
1:         final String sql = "insert into stmtpooldata (val) values ?";
1:         getConnection().setAutoCommit(false);
1:         PreparedStatement ps = prepareStatement(sql);
1:         ps.setInt(1, 68);
1:         assertEquals(1, ps.executeUpdate());
1:         ps.close();
1:         ps = prepareStatement(sql);
1:         ps.setInt(1, 77);
1:         assertEquals(1, ps.executeUpdate());
1:         Statement stmt = createStatement();
1:         ResultSet rs =stmt.executeQuery(
1:                 "select val from stmtpooldata order by val");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"68"},{"77"}});
1:         rollback();
1:         rs = stmt.executeQuery("select val from stmtpooldata order by val");
1:         JDBC.assertEmpty(rs);
1:     }
1: 
1:     /**
1:      * Tests that autocommit is working.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
1:     public void resTestCommitOnReuse()
1:             throws SQLException {
1:         // Make sure the table is empty.
1:         cleanTableExceptedToBeEmpty();
1: 
1:         // Start test
1:         final String sql = "insert into stmtpooldata (val) values ?";
1:         getConnection().setAutoCommit(true);
1:         PreparedStatement ps = prepareStatement(sql);
1:         ps.setInt(1, 68);
1:         assertEquals(1, ps.executeUpdate());
1:         ps.close();
1:         ps = prepareStatement(sql);
1:         ps.setInt(1, 77);
1:         assertEquals(1, ps.executeUpdate());
1:         Statement stmt = createStatement();
1:         ResultSet rs =stmt.executeQuery(
1:                 "select val from stmtpooldata order by val");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"68"},{"77"}});
1:         rollback();
1:         rs = stmt.executeQuery("select val from stmtpooldata order by val");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"68"},{"77"}});
1:         // Clean up
1:         assertEquals(2, stmt.executeUpdate("delete from stmtpooldata"));
1:     }
1: 
1:     /**
1:      * Tests that nothing is committed on the connection when autocommit is
1:      * disabled.
1:      *
1:      * @throws SQLException if something goes wrong...
1:      */
1:     public void resTestNoDataCommittedOnInvalidTransactionState()
1:             throws SQLException {
1:         // Make sure the table is empty.
1:         cleanTableExceptedToBeEmpty();
1: 
1:         // Start test
1:         final String sql = "insert into stmtpooldata (val) values ?";
1:         getConnection().setAutoCommit(false);
1:         PreparedStatement ps = prepareStatement(sql);
1:         ps.setInt(1, 68);
1:         assertEquals(1, ps.executeUpdate());
1:         ps.close();
1:         ps = prepareStatement(sql);
1:         ps.setInt(1, 77);
1:         assertEquals(1, ps.executeUpdate());
1:         Statement stmt = createStatement();
1:         ResultSet rs = stmt.executeQuery(
1:                 "select val from stmtpooldata order by val");
1:         JDBC.assertFullResultSet(rs, new String[][] {{"68"},{"77"}});
1:         try {
1:             getConnection().close();
1:             // We should not get here, but let's see what has happened.
1:             // Possible symptoms:
1:             //   - lock timeout: connection resources has not been freed.
1:             //   - no rows: rollback was issued.
1:             //   - two rows: commit was issued.
1:             stmt = createStatement();
1:             rs = stmt.executeQuery("select val from stmtpooldata order by val");
1:             int rows = 0;
1:             while (rs.next()) {
1:                 rows++;
1:             }
1:             fail("Connection should not be allowed to close. Rows in table: " +
1:                     rows);
1:         } catch (SQLException sqle) {
1:             assertSQLState("25001", sqle);
1:             rollback();
1:         }
1:         stmt = createStatement();
1:         rs = stmt.executeQuery("select val from stmtpooldata order by val");
1:         JDBC.assertEmpty(rs);
1:     }
1: 
1:     /**
1:      * Deletes row from a test table that is expected to be empty.
1:      *
1:      * @throws SQLException if a database operation fails
1:      */
1:     private void cleanTableExceptedToBeEmpty()
1:             throws SQLException {
1:         Statement stmt = createStatement();
1:         ResultSet rs = stmt.executeQuery("select * from stmtpooldata");
1:         int rowCount = 0;
1:         while (rs.next()) {
1:             rowCount++;
1:         }
1:         rs.close();
1:         // Delete rows if any, and print a warning if verbosity is on.
1:         if (rowCount > 0) {
1:             println("Expected empty table, got " + rowCount + " rows.");
1:             assertEquals(rowCount,
1:                     stmt.executeUpdate("delete from stmtpooldata"));
1:         }
1:     }
1: 
1:     public static Test suite() {
0:         TestSuite suite = new TestSuite("StatementPoolingTest suite");
0:         TestSuite baseSuite = new TestSuite(StatementPoolingTest.class);
1:         // Statement pooling is not yet enabled for XA.
1:         //suite.addTest(TestConfiguration.connectionXADecorator(baseSuite));
1:         suite.addTest(TestConfiguration.connectionCPDecorator(baseSuite));
1: 
1:         // Add tests that require data from the database.
0:         TestSuite reqDataSuite = new TestSuite("Requires data suite");
1:         reqDataSuite.addTest(new StatementPoolingTest(
1:                 "resTestCloseDoesNotAffectOtherStatement"));
1:         reqDataSuite.addTest(new StatementPoolingTest(
1:                 "resTestLogicalConnectionCloseInvalidatesLogicalStatement"));
1:         reqDataSuite.addTest(new StatementPoolingTest(
1:                 "resTestHoldCursorsOverCommit"));
1:         reqDataSuite.addTest(new StatementPoolingTest(
1:                 "resTestCloseCursorsAtCommit"));
1:         reqDataSuite.addTest(new StatementPoolingTest(
1:                 "resTestNoCommitOnReuse"));
1:         reqDataSuite.addTest(new StatementPoolingTest(
1:                 "resTestCommitOnReuse"));
0:         // This test fails, DERBY-3319 is probably the cause.
0:         //reqDataSuite.addTest(new StatementPoolingTest(
0:         //        "resTestNoDataCommittedOnInvalidTransactionState"));
1:         suite.addTest(TestConfiguration.connectionCPDecorator(
1:                 new BaseJDBCTestSetup(reqDataSuite) {
1:                 public void setUp() throws Exception {
1:                     // Generate some data we can use in the tests.
1:                     Statement stmt = getConnection().createStatement();
1:                     try {
1:                         stmt.executeUpdate("drop table stmtpooltest");
1:                     } catch (SQLException sqle) {
1:                         assertSQLState("42Y55", sqle);
1:                     }
1:                     stmt.executeUpdate("create table stmtpooltest (" +
1:                             "id int generated always as identity," +
1:                             "val int)");
1:                     PreparedStatement ps = getConnection().prepareStatement(
1:                             "insert into stmtpooltest values (DEFAULT, ?)");
1:                     // Insert data with val in range [1,7].
1:                     for (int val=1; val <= 7; val++) {
1:                         ps.setInt(1, val);
1:                         ps.addBatch();
1:                     }
1:                     ps.executeBatch();
1: 
1:                     try {
1:                         stmt.executeUpdate("drop table stmtpooldata");
1:                     } catch (SQLException sqle) {
1:                         assertSQLState("42Y55", sqle);
1:                     }
1:                     stmt.executeUpdate("create table stmtpooldata (" +
1:                             "id int generated always as identity," +
1:                             "val int)");
1:                     // Leave this table empty.
1:                 }
1:             }));
1:         return TestConfiguration.clientServerDecorator(suite);
1:     }
1: }
============================================================================