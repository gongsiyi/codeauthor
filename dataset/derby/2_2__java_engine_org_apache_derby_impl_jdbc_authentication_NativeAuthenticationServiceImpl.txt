1:5107349: /*
15:5107349: 
1:5107349:    Derby - Class org.apache.derby.impl.jdbc.authentication.NativeAuthenticationServiceImpl
1:49901a4: 
1:5107349:    Licensed to the Apache Software Foundation (ASF) under one or more
1:5107349:    contributor license agreements.  See the NOTICE file distributed with
1:5107349:    this work for additional information regarding copyright ownership.
1:5107349:    The ASF licenses this file to you under the Apache License, Version 2.0
1:5107349:    (the "License"); you may not use this file except in compliance with
1:5107349:    the License.  You may obtain a copy of the License at
1:5107349: 
1:5107349:       http://www.apache.org/licenses/LICENSE-2.0
1:5107349: 
1:5107349:    Unless required by applicable law or agreed to in writing, software
1:5107349:    distributed under the License is distributed on an "AS IS" BASIS,
1:5107349:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:5107349:    See the License for the specific language governing permissions and
1:5107349:    limitations under the License.
1:5107349: 
1:5107349:  */
1:5107349: 
1:5107349: package org.apache.derby.impl.jdbc.authentication;
1:5107349: 
1:5107349: import java.util.Properties;
1:56c1dc2: import java.security.AccessController;
1:5107349: import java.security.MessageDigest;
1:5107349: import java.security.NoSuchAlgorithmException;
1:56c1dc2: import java.security.PrivilegedAction;
1:5107349: import java.sql.Connection;
1:5107349: import java.sql.SQLException;
1:49901a4: import java.sql.SQLWarning;
1:5107349: import java.util.Arrays;
1:5107349: import javax.sql.DataSource;
1:5107349: 
1:5107349: import org.apache.derby.catalog.SystemProcedures;
1:5107349: import org.apache.derby.iapi.db.Database;
1:5107349: import org.apache.derby.iapi.reference.Property;
1:5107349: import org.apache.derby.iapi.services.info.JVMInfo;
1:5107349: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:5107349: import org.apache.derby.iapi.sql.dictionary.PasswordHasher;
1:5107349: import org.apache.derby.iapi.sql.dictionary.UserDescriptor;
1:5107349: import org.apache.derby.iapi.reference.Attribute;
1:5107349: import org.apache.derby.iapi.reference.SQLState;
1:5107349: import org.apache.derby.authentication.UserAuthenticator;
1:49901a4: import org.apache.derby.iapi.error.SQLWarningFactory;
1:5107349: import org.apache.derby.iapi.error.StandardException;
1:56c1dc2: import org.apache.derby.iapi.services.monitor.ModuleFactory;
1:5107349: import org.apache.derby.iapi.services.monitor.Monitor;
1:5107349: import org.apache.derby.iapi.services.property.PropertyUtil;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:5107349: import org.apache.derby.iapi.store.access.TransactionController;
1:5107349: import org.apache.derby.iapi.util.IdUtil;
1:5107349: import org.apache.derby.iapi.util.StringUtil;
1:5107349: import org.apache.derby.impl.jdbc.Util;
1:d94fffb: import org.apache.derby.jdbc.InternalDriver;
1:5107349: 
1:5107349: /**
1:5107349:  * <p>
1:5107349:  * This authentication service supports Derby NATIVE authentication.
1:5107349:  * </p>
1:5107349:  *
1:5107349:  * <p>
1:5107349:  * To activate this service, set the derby.authentication.provider database
1:5107349:  * or system property to a value beginning with the token "NATIVE:".
1:5107349:  * </p>
1:5107349:  *
1:5107349:  * <p>
1:5107349:  * This service instantiates and calls the basic User authentication scheme at runtime.
1:5107349:  * </p>
1:5107349:  *
1:5107349:  * <p>
1:5107349:  * User credentials are defined in the SYSUSERS table.
1:5107349:  * </p>
1:5107349:  *
1:5107349:  */
1:5107349: public final class NativeAuthenticationServiceImpl
1:5107349: 	extends AuthenticationServiceBase implements UserAuthenticator
4:5107349: {
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
7:5107349:     //
1:5107349:     // CONSTANTS
1:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349:     //
1:5107349:     // STATE
1:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:5107349:     // temporary, used when bootstrapping a locally authenticated database
1:5107349:     private boolean _creatingCredentialsDB = false;
1:5107349:     
1:5107349:     private String      _credentialsDB;
1:5107349:     private boolean _authenticateDatabaseOperationsLocally;
1:49901a4:     private long        _passwordLifetimeMillis = Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME_DEFAULT;
1:49901a4:     private double      _passwordExpirationThreshold = Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD_DEFAULT;
1:49901a4:     private String      _badlyFormattedPasswordProperty;
1:5107349: 
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349:     //
1:5107349:     // ModuleControl BEHAVIOR
1:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:5107349: 	/**
1:5107349: 	 *  Check if we should activate this authentication service.
1:5107349: 	 */
1:5107349: 	public boolean canSupport(Properties properties)
1:5107349:     {
1:5107349: 		if (!requireAuthentication(properties)) { return false; }
1:5107349: 
1:5107349:         if ( PropertyUtil.nativeAuthenticationEnabled( properties ) )
1:5107349:         {
1:5107349:             parseNativeSpecification( properties );
1:5107349: 
2:5107349:             return true;
4:5107349:         }
1:5107349:         else { return false; }
1:5107349: 	}
1:5107349: 
1:56c1dc2:     /**
1:5107349:      * <p>
1:5107349:      * Parse the specification of NATIVE authentication. It can take 3 forms:
1:5107349:      * </p>
1:5107349:      *
1:5107349:      * <ul>
1:5107349:      * <li><i>NATIVE:$credentialsDB</i> - Here $credentialsDB is the name of a Derby database.
1:5107349:      *  This means that all authentication should take place in $credentialsDB.</li>
1:5107349:      * <li><i>NATIVE:$credentialsDB:LOCAL</i>- This means that system-wide operations (like engine shutdown)
1:5107349:      *  are authenticated in $credentialsDB but connections to existing databases are authenticated
1:5107349:      *  in those databases.</li>
1:5107349:      * <li><i>NATIVE::LOCAL</i> - This means that connections to a given database are authenticated
1:5107349:      *  in that database.</li>
1:5107349:      * </ul>
1:5107349:      */
1:5107349:     private void    parseNativeSpecification( Properties properties )
1:5107349:     {
1:5107349:         // If we get here, we already know that the authentication provider property
1:5107349:         // begins with the NATIVE: token
1:5107349:         String authenticationProvider = PropertyUtil.getPropertyFromSet
1:5107349:             (
1:5107349:              properties,
1:5107349:              Property.AUTHENTICATION_PROVIDER_PARAMETER
1:5107349:              );
1:5107349: 
1:5107349:         _authenticateDatabaseOperationsLocally = PropertyUtil.localNativeAuthenticationEnabled( properties );
1:5107349: 
1:5107349:         // Everything between the first colon and the last colon is the name of a database
1:5107349:         int     dbNameStartIdx = authenticationProvider.indexOf( ":" ) + 1;
1:5107349:         int     dbNameEndIdx = _authenticateDatabaseOperationsLocally ?
1:5107349:             authenticationProvider.lastIndexOf( ":" )
1:5107349:             : authenticationProvider.length();
1:5107349: 
1:5107349:         if ( dbNameEndIdx > dbNameStartIdx )
1:5107349:         {
1:5107349:             _credentialsDB = authenticationProvider.substring( dbNameStartIdx, dbNameEndIdx );
1:5107349: 
1:5107349:             if ( _credentialsDB.length() == 0 ) { _credentialsDB = null; }
1:5107349:         }
1:49901a4: 
1:49901a4:         //
1:49901a4:         // Let the application override password lifespans.
1:49901a4:         //
1:49901a4:         _badlyFormattedPasswordProperty = null;
1:49901a4:         String passwordLifetimeString = PropertyUtil.getPropertyFromSet
1:49901a4:             (
1:49901a4:              properties,
1:49901a4:              Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME
1:49901a4:              );
1:49901a4:         if ( passwordLifetimeString != null )
1:49901a4:         {
1:49901a4:             Long    passwordLifetime = parsePasswordLifetime( passwordLifetimeString );
1:49901a4: 
1:49901a4:             if ( passwordLifetime != null ) { _passwordLifetimeMillis = passwordLifetime.longValue(); }
1:49901a4:             else
1:49901a4:             { _badlyFormattedPasswordProperty = Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME; }
1:49901a4:         }
1:49901a4: 
1:49901a4:         String  expirationThresholdString = PropertyUtil.getPropertyFromSet
1:49901a4:             (
1:49901a4:              properties,
1:49901a4:              Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD
1:49901a4:              );
1:49901a4:         if ( expirationThresholdString != null )
1:49901a4:         {
1:49901a4:             Double  expirationThreshold = parsePasswordThreshold( expirationThresholdString );
1:49901a4: 
1:49901a4:             if ( expirationThreshold != null ) { _passwordExpirationThreshold = expirationThreshold.doubleValue(); }
1:49901a4:             else
1:49901a4:             { _badlyFormattedPasswordProperty = Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD; }
1:49901a4:         }
1:49901a4:         
1:5107349:     }
1:5107349: 
1:5107349:     /**
1:5107349:      * <p>
1:5107349:      * Return true if AUTHENTICATION_PROVIDER_PARAMETER was well formatted.
1:5107349:      * The property must have designated some database as the authentication authority.
1:5107349:      * </p>
1:5107349:      */
1:5107349:     private boolean validAuthenticationProvider()
1:213d360:         throws StandardException
1:5107349:     {
1:a3d7a74:         // If there is no store, then we are booting a system-wide authentication service
1:a3d7a74:         boolean     systemWideAuthentication = ( getServiceName() == null );
1:a3d7a74: 
1:213d360:         if ( _credentialsDB != null )
1:213d360:         {
1:213d360:             // make sure that it is a well-formed database name
1:56c1dc2:             if ( getMonitor().getCanonicalServiceName( _credentialsDB ) == null )
1:213d360:             {
1:213d360:                 throw StandardException.newException( SQLState.BAD_CREDENTIALS_DB_NAME, _credentialsDB );
1:213d360:             }
1:213d360:             else { return true; }
1:213d360:         }
1:a3d7a74:         
1:a3d7a74:         // must have a global credentials db for system-wide authentication
1:a3d7a74:         if ( systemWideAuthentication ) { return false; }
1:a3d7a74: 
1:a3d7a74:         // so there is no credentials db specified and we are booting a database.
1:a3d7a74:         // this is only allowed if we are authenticating locally in that database.
1:a3d7a74:         return _authenticateDatabaseOperationsLocally;
1:5107349:     }
1:5107349: 
1:5107349: 	/**
1:5107349: 	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#boot
1:5107349: 	 * @exception StandardException upon failure to load/boot the expected
1:5107349: 	 * authentication service.
1:5107349: 	 */
1:5107349: 	public void boot(boolean create, Properties properties)
3:5107349: 	  throws StandardException
1:5107349:     {
1:5107349: 		// first perform the initialization in our superclass
1:5107349: 		super.boot( create, properties );
1:5107349: 
1:5107349:         if ( !validAuthenticationProvider() )
1:5107349:         {
1:5107349:             throw StandardException.newException( SQLState.BAD_NATIVE_AUTH_SPEC );
1:5107349:         }
1:5107349: 
1:49901a4:         if ( _badlyFormattedPasswordProperty != null )
1:49901a4:         {
1:49901a4:             throw StandardException.newException
1:49901a4:                 ( SQLState.BAD_PASSWORD_LIFETIME, _badlyFormattedPasswordProperty );
1:49901a4:         }
1:49901a4: 
1:5107349: 		// Initialize the MessageDigest class engine here
1:5107349: 		// (we don't need to do that ideally, but there is some
1:5107349: 		// overhead the first time it is instantiated.
3:5107349: 		try {
1:5107349: 			MessageDigest digestAlgorithm = MessageDigest.getInstance("SHA-1");
1:5107349: 			digestAlgorithm.reset();
1:5107349: 
1:5107349: 		} catch (NoSuchAlgorithmException nsae) {
1:5107349: 			throw Monitor.exceptionStartingModule(nsae);
1:5107349: 		}
1:5107349: 
1:5107349:         // bootstrap the creation of the initial username/password when the dbo creates a credentials db
1:5107349:         if ( create && authenticatingInThisService( getCanonicalServiceName() ) ) { _creatingCredentialsDB = true; }
1:5107349:         else { _creatingCredentialsDB = false; }
1:5107349: 
1:5107349: 		// Set ourselves as being ready, having loaded the proper
1:5107349: 		// authentication scheme for this service
1:5107349: 		//
1:5107349: 		this.setAuthenticationService(this);
1:5107349: 	}
1:5107349: 
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349:     //
1:5107349:     // UserAuthenticator BEHAVIOR
1:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:5107349:     /** Override behavior in superclass */
1:5107349:     public  String  getSystemCredentialsDatabaseName()    { return _credentialsDB; }
1:5107349:     /** Override behavior in superclass */
1:5107349: 
1:5107349: 	/**
1:5107349: 	 * Authenticate the passed-in user's credentials.
1:5107349: 	 *
1:5107349: 	 * @param userName		The user's name used to connect to JBMS system
1:5107349: 	 * @param userPassword	The user's password used to connect to JBMS system
1:5107349: 	 * @param databaseName	The database which the user wants to connect to.
1:5107349: 	 * @param info			Additional jdbc connection info.
1:5107349: 	 */
1:5107349: 	public boolean	authenticateUser
1:5107349:         (
1:5107349:          String userName,
1:5107349:          String userPassword,
1:5107349:          String databaseName,
1:5107349:          Properties info
1:5107349:          )
1:5107349:         throws SQLException
1:5107349: 	{
1:5107349:         try {
1:5107349:             // No "guest" user
1:5107349:             if ( userName == null ) { return false; }
1:601e027:             if ( userPassword == null ) { return false; }
1:5107349: 
1:5107349:             //
1:5107349:             // We must handle these cases:
1:5107349:             //
1:5107349:             // 1) Database name is null. This means that we are authenticating a system-wide
1:5107349:             // operation. The authentication must be done by the system-wide credentials database.
1:5107349:             //
1:5107349:             // 2) Database name is not null and authentication is NOT specified as local.
1:5107349:             // This means that we are authenticating a database-specific operation
1:5107349:             // in the system-wide credentials database. There are two subcases:
1:5107349:             //
1:5107349:             // 2a) The current database is NOT the credentials database. This reduces to case (1) above:
1:5107349:             // authentication must be performed in another database.
1:5107349:             //
1:5107349:             // 2b) The current database IS the credentials database. This reduces to case (3) below:
1:5107349:             // authentication must be performed in this database.
1:5107349:             //
1:5107349:             // 3) Database name is not null and authentication IS being performed locally in this database.
1:5107349:             // This means that we are authenticating a database-specific operation and performing the
1:5107349:             // authentication in this database.
1:5107349:             //
1:5107349: 
1:5107349:             if ( (databaseName == null) || !authenticatingInThisDatabase( databaseName ) )
1:5107349:             {
1:5107349:                 return authenticateRemotely(  userName, userPassword, databaseName );
1:5107349:             }
1:5107349:             else
1:5107349:             {
1:5107349:                 return authenticateLocally( userName, userPassword, databaseName );
1:5107349:             }
1:5107349:         }
1:5107349:         catch (StandardException se)
1:5107349:         {
1:5107349:             throw Util.generateCsSQLException(se);
1:5107349:         }
1:5107349: 	}
1:5107349: 
1:5107349:     /**
1:5107349:      * <p>
1:5107349:      * Return true if we are authenticating in this database.
1:5107349:      * </p>
1:5107349:      */
1:5107349:     private boolean authenticatingInThisDatabase( String userVisibleDatabaseName )
1:5107349:         throws StandardException
1:5107349:     {
1:56c1dc2:         return authenticatingInThisService( getMonitor().getCanonicalServiceName( userVisibleDatabaseName ) );
1:5107349:     }
1:5107349: 
1:5107349:     /**
1:5107349:      * <p>
1:5107349:      * Return true if we are authenticating in this service.
1:5107349:      * </p>
1:5107349:      */
1:5107349:     private boolean authenticatingInThisService( String canonicalDatabaseName )
1:5107349:         throws StandardException
1:5107349:     {
1:5107349:         if ( _authenticateDatabaseOperationsLocally ) { return true; }
1:5107349:         else { return isCredentialsService( canonicalDatabaseName ); }
1:5107349:     }
1:5107349: 
1:5107349:     /**
1:5107349:      * <p>
1:5107349:      * Return true if the passed in service is the credentials database.
1:5107349:      * </p>
1:5107349:      */
1:5107349:     private boolean isCredentialsService( String canonicalDatabaseName )
1:5107349:         throws StandardException
1:5107349:     {
1:5107349:         String  canonicalCredentialsDBName = getCanonicalServiceName( _credentialsDB );
1:5107349: 
1:56c1dc2:         String canonicalDB = getMonitor().getCanonicalServiceName( canonicalDatabaseName );
1:5107349: 
1:5107349:         if ( canonicalCredentialsDBName == null ) { return false; }
1:5107349:         else { return canonicalCredentialsDBName.equals( canonicalDatabaseName ); }
1:5107349:     }
1:5107349: 
1:5107349:     /** Get the canonical name of the current database service */
1:5107349:     private String  getCanonicalServiceName()
1:5107349:         throws StandardException
1:5107349:     {
1:5107349:         return getCanonicalServiceName( getServiceName() );
1:5107349:     }
1:5107349: 
1:5107349:     /** Turn a service name into its normalized, standard form */
1:5107349:     private String  getCanonicalServiceName( String rawName )
1:5107349:         throws StandardException
1:5107349:     {
1:56c1dc2:         return getMonitor().getCanonicalServiceName( rawName );
1:5107349:     }
1:5107349: 
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349:     //
1:5107349:     // AUTHENTICATE REMOTELY
1:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:5107349: 	/**
1:5107349: 	 * Authenticate the passed-in credentials against another Derby database. This is done
1:5107349:      * by getting a connection to the credentials database using the supplied username
1:5107349:      * and password. If the connection attempts succeeds, then authentication succeeds.
1:5107349: 	 *
1:5107349: 	 * @param userName		The user's name used to connect to JBMS system
1:5107349: 	 * @param userPassword	The user's password used to connect to JBMS system
1:5107349: 	 * @param databaseName	The database which the user wants to connect to.
1:5107349: 	 */
1:5107349: 	private boolean	authenticateRemotely
1:5107349:         (
1:5107349:          String userName,
1:5107349:          String userPassword,
1:5107349:          String databaseName
1:5107349:          )
1:49901a4:         throws StandardException, SQLWarning
1:5107349: 	{
1:5107349:         // this catches the case when someone specifies derby.authentication.provider=NATIVE::LOCAL
1:5107349:         // at the system level
1:5107349:         if ( _credentialsDB == null )
1:5107349:         {
1:5107349:             throw StandardException.newException( SQLState.BAD_NATIVE_AUTH_SPEC );
1:5107349:         }
1:5107349:         
1:49901a4:         SQLWarning  warnings = null;
1:601e027: 
1:5107349:         try {
1:d94fffb:             Properties  properties = new Properties();
1:d94fffb:             properties.setProperty( Attribute.USERNAME_ATTR, userName );
1:d94fffb:             properties.setProperty( Attribute.PASSWORD_ATTR, userPassword );
1:49901a4: 
1:d94fffb:             String  connectionURL = Attribute.PROTOCOL + _credentialsDB;
1:d94fffb: 
1:25c1e7b:             Connection  conn = InternalDriver.activeDriver().connect( connectionURL, properties, 0 );
1:5107349:             
1:49901a4:             warnings = conn.getWarnings();
1:5107349:             conn.close();
1:5107349:         }
1:5107349:         catch (SQLException se)
1:5107349:         {
1:5107349:             String  sqlState = se.getSQLState();
1:5107349: 
1:5107349:             if ( SQLState.LOGIN_FAILED.equals( sqlState ) ) { return false; }
1:5107349:             else if ( SQLState.DATABASE_NOT_FOUND.startsWith( sqlState ) )
1:5107349:             {
1:5107349:                 throw StandardException.newException( SQLState.MISSING_CREDENTIALS_DB, _credentialsDB );
1:5107349:             }
1:5107349:             else { throw wrap( se ); }
1:5107349:         }
1:5107349: 
1:49901a4:         // let warnings percolate up so that EmbedConnection can handle notifications
1:49901a4:         // about expiring passwords
1:49901a4:         if ( warnings != null ) { throw warnings; }
1:49901a4: 
1:5107349:         // If we get here, then we successfully connected to the credentials database. Hooray.
1:5107349:         return true;
1:5107349:     }
1:5107349:     private StandardException wrap( Throwable t )   { return StandardException.plainWrapException( t ); }
1:5107349:     
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349:     //
1:5107349:     // AUTHENTICATE LOCALLY
1:5107349:     //
1:5107349:     ///////////////////////////////////////////////////////////////////////////////////
1:5107349: 
1:5107349: 	/**
1:5107349: 	 * Authenticate the passed-in credentials against the local database.
1:5107349: 	 *
1:5107349: 	 * @param userName		The user's name used to connect to JBMS system
1:5107349: 	 * @param userPassword	The user's password used to connect to JBMS system
1:5107349: 	 * @param databaseName	The database which the user wants to connect to.
1:5107349: 	 */
1:5107349: 	private boolean	authenticateLocally
1:5107349:         (
1:5107349:          String userName,
1:5107349:          String userPassword,
1:5107349:          String databaseName
1:5107349:          )
1:5107349:         throws StandardException, SQLException
1:5107349: 	{
1:5107349:         userName = IdUtil.getUserAuthorizationId( userName ) ;
1:5107349: 
1:c0399dc:         //
1:c0399dc:         // Special bootstrap code. If we are creating a credentials database, then
1:c0399dc:         // we store the DBO's initial credentials in it. We also turn on NATIVE LOCAL authentication
1:c0399dc:         // forever.
1:c0399dc:         //
1:c0399dc:         if ( _creatingCredentialsDB )
1:c0399dc:         {
1:c0399dc:             _creatingCredentialsDB = false;
1:5107349:             
1:c0399dc:             TransactionController   tc = getTransaction();
1:5107349:             
1:c0399dc:             SystemProcedures.addUser( userName, userPassword, tc );
1:c0399dc:             
1:c0399dc:             tc.commit();
1:c0399dc:             
1:5107349:             return true;
1:5107349:         }
1:c0399dc:         
1:c0399dc:         //
1:c0399dc:         // we expect to find a data dictionary
1:c0399dc:         //
1:56c1dc2:         DataDictionary      dd = (DataDictionary) AuthenticationServiceBase.getServiceModule( this, DataDictionary.MODULE );        
1:c0399dc:         UserDescriptor      userDescriptor = dd.getUser( userName );
1:c0399dc:         
1:601e027:         if ( userDescriptor == null )
1:601e027:         {
1:601e027:             //
1:601e027:             // Before returning, we pretend to evaluate the password.
1:601e027:             // This helps prevent blackhats from discovering legal usernames
1:601e027:             // by measuring how long password evaluation takes. For more context,
1:601e027:             // see the 2012-02-22 comment on DERBY-5539.
1:601e027:             //
1:601e027:             PasswordHasher          hasher = dd.makePasswordHasher( getDatabaseProperties() );
1:601e027:             
1:601e027:             hasher.hashPasswordIntoString( userName, userPassword ).toCharArray();
1:601e027: 
1:601e027:             return false;
1:601e027:         }
1:c0399dc:         
1:c0399dc:         PasswordHasher      hasher = new PasswordHasher( userDescriptor.getHashingScheme() );
1:c0399dc:         char[]                     candidatePassword = hasher.hashPasswordIntoString( userName, userPassword ).toCharArray();
1:c0399dc:         char[]                     actualPassword = userDescriptor.getAndZeroPassword();
1:49901a4: 
1:49901a4:         try {
1:49901a4:             if ( (candidatePassword == null) || (actualPassword == null)) { return false; }
1:49901a4:             if ( candidatePassword.length != actualPassword.length ) { return false; }
1:c0399dc:         
1:49901a4:             for ( int i = 0; i < candidatePassword.length; i++ )
1:49901a4:             {
1:49901a4:                 if ( candidatePassword[ i ] != actualPassword[ i ] ) { return false; }
1:49901a4:             }
1:49901a4:         } finally
1:5107349:         {
1:601e027:             if ( candidatePassword != null ) { Arrays.fill( candidatePassword, (char) 0 ); }
1:601e027:             if ( actualPassword != null ) { Arrays.fill( actualPassword, (char) 0 ); }
1:5107349:         }
1:49901a4: 
1:49901a4:         //
1:49901a4:         // Password is good. Check whether the password has expired or will expire soon.
1:49901a4:         //
1:49901a4:         if ( _passwordLifetimeMillis > 0 )
1:49901a4:         {
1:49901a4:             long    passwordAge = System.currentTimeMillis() - userDescriptor.getLastModified().getTime();
1:49901a4:             long    remainingLifetime = _passwordLifetimeMillis - passwordAge;
1:49901a4: 
1:49901a4:             //
1:49901a4:             // Oops, the password has expired. Fail the authentication. Say nothing more
1:49901a4:             // so that we give password crackers as little information as possible.
1:49901a4:             //
1:49901a4:             if ( remainingLifetime <= 0L )
1:49901a4:             {
1:49901a4:                 // The DBO's password never expires.
1:49901a4:                 if ( !dd.getAuthorizationDatabaseOwner().equals( userName ) ) { return false; }
1:49901a4:                 else { remainingLifetime = 0L; }
1:49901a4:             }
1:49901a4: 
1:49901a4:             long    expirationThreshold = (long) ( _passwordLifetimeMillis * _passwordExpirationThreshold );
1:49901a4:             
1:49901a4:             if ( remainingLifetime <= expirationThreshold )
1:49901a4:             {
1:65a5491:                 if ( dd.getAuthorizationDatabaseOwner().equals( userName ) )
1:65a5491:                 {
1:b60a998:                     throw SQLWarningFactory.newSQLWarning( SQLState.DBO_PASSWORD_EXPIRES_SOON, databaseName );
1:65a5491:                 }
1:65a5491:                 
1:49901a4:                 long    daysRemaining = remainingLifetime / Property.MILLISECONDS_IN_DAY;
1:b60a998:                 throw SQLWarningFactory.newSQLWarning
1:b60a998:                     ( SQLState.PASSWORD_EXPIRES_SOON, Long.toString( daysRemaining ), databaseName );
1:49901a4:             }
1:49901a4:         }
1:c0399dc:         
1:c0399dc:         return true;
1:5107349:     }
1:c0399dc:     
1:5107349:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  ModuleFactory  getMonitor()
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<ModuleFactory>()
1:56c1dc2:              {
1:56c1dc2:                  public ModuleFactory run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getMonitor();
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:56c1dc2:     
1:56c1dc2:     /**
1:56c1dc2:      * Privileged Monitor lookup. Must be private so that user code
1:56c1dc2:      * can't call this entry point.
1:56c1dc2:      */
1:56c1dc2:     private  static  String  getServiceName( final Object serviceModule )
1:56c1dc2:     {
1:56c1dc2:         return AccessController.doPrivileged
1:56c1dc2:             (
1:56c1dc2:              new PrivilegedAction<String>()
1:56c1dc2:              {
1:56c1dc2:                  public String run()
1:56c1dc2:                  {
1:56c1dc2:                      return Monitor.getServiceName( serviceModule );
1:56c1dc2:                  }
1:56c1dc2:              }
1:56c1dc2:              );
1:56c1dc2:     }
1:56c1dc2: 
1:5107349: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:56c1dc2
/////////////////////////////////////////////////////////////////////////
1: import java.security.AccessController;
1: import java.security.PrivilegedAction;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.services.monitor.ModuleFactory;
/////////////////////////////////////////////////////////////////////////
1:             if ( getMonitor().getCanonicalServiceName( _credentialsDB ) == null )
/////////////////////////////////////////////////////////////////////////
1:         return authenticatingInThisService( getMonitor().getCanonicalServiceName( userVisibleDatabaseName ) );
/////////////////////////////////////////////////////////////////////////
1:         String canonicalDB = getMonitor().getCanonicalServiceName( canonicalDatabaseName );
/////////////////////////////////////////////////////////////////////////
1:         return getMonitor().getCanonicalServiceName( rawName );
/////////////////////////////////////////////////////////////////////////
1:         DataDictionary      dd = (DataDictionary) AuthenticationServiceBase.getServiceModule( this, DataDictionary.MODULE );        
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  ModuleFactory  getMonitor()
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<ModuleFactory>()
1:              {
1:                  public ModuleFactory run()
1:                  {
1:                      return Monitor.getMonitor();
1:                  }
1:              }
1:              );
1:     }
1: 
1:     
1:     /**
1:      * Privileged Monitor lookup. Must be private so that user code
1:      * can't call this entry point.
1:      */
1:     private  static  String  getServiceName( final Object serviceModule )
1:     {
1:         return AccessController.doPrivileged
1:             (
1:              new PrivilegedAction<String>()
1:              {
1:                  public String run()
1:                  {
1:                      return Monitor.getServiceName( serviceModule );
1:                  }
1:              }
1:              );
1:     }
1: 
commit:bc76319
/////////////////////////////////////////////////////////////////////////
commit:25c1e7b
/////////////////////////////////////////////////////////////////////////
1:             Connection  conn = InternalDriver.activeDriver().connect( connectionURL, properties, 0 );
commit:213d360
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException
1:         if ( _credentialsDB != null )
1:         {
1:             // make sure that it is a well-formed database name
0:             if ( Monitor.getMonitor().getCanonicalServiceName( _credentialsDB ) == null )
1:             {
1:                 throw StandardException.newException( SQLState.BAD_CREDENTIALS_DB_NAME, _credentialsDB );
1:             }
1:             else { return true; }
1:         }
commit:c5b9acb
/////////////////////////////////////////////////////////////////////////
commit:b60a998
/////////////////////////////////////////////////////////////////////////
1:                     throw SQLWarningFactory.newSQLWarning( SQLState.DBO_PASSWORD_EXPIRES_SOON, databaseName );
1:                 throw SQLWarningFactory.newSQLWarning
1:                     ( SQLState.PASSWORD_EXPIRES_SOON, Long.toString( daysRemaining ), databaseName );
commit:65a5491
/////////////////////////////////////////////////////////////////////////
1:                 if ( dd.getAuthorizationDatabaseOwner().equals( userName ) )
1:                 {
0:                     throw SQLWarningFactory.newSQLWarning( SQLState.DBO_PASSWORD_EXPIRES_SOON );
1:                 }
1:                 
commit:601e027
/////////////////////////////////////////////////////////////////////////
1:             if ( userPassword == null ) { return false; }
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:         if ( userDescriptor == null )
1:         {
1:             //
1:             // Before returning, we pretend to evaluate the password.
1:             // This helps prevent blackhats from discovering legal usernames
1:             // by measuring how long password evaluation takes. For more context,
1:             // see the 2012-02-22 comment on DERBY-5539.
1:             //
1:             PasswordHasher          hasher = dd.makePasswordHasher( getDatabaseProperties() );
1:             
1:             hasher.hashPasswordIntoString( userName, userPassword ).toCharArray();
1: 
1:             return false;
1:         }
/////////////////////////////////////////////////////////////////////////
1:             if ( candidatePassword != null ) { Arrays.fill( candidatePassword, (char) 0 ); }
1:             if ( actualPassword != null ) { Arrays.fill( actualPassword, (char) 0 ); }
commit:d94fffb
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.jdbc.InternalDriver;
/////////////////////////////////////////////////////////////////////////
1:             Properties  properties = new Properties();
1:             properties.setProperty( Attribute.USERNAME_ATTR, userName );
1:             properties.setProperty( Attribute.PASSWORD_ATTR, userPassword );
1:             String  connectionURL = Attribute.PROTOCOL + _credentialsDB;
0:             Connection  conn = InternalDriver.activeDriver().connect( connectionURL, properties );
1:             
commit:a3d7a74
/////////////////////////////////////////////////////////////////////////
1:         // If there is no store, then we are booting a system-wide authentication service
1:         boolean     systemWideAuthentication = ( getServiceName() == null );
1: 
0:         if ( _credentialsDB != null ) { return true; }
1:         
1:         // must have a global credentials db for system-wide authentication
1:         if ( systemWideAuthentication ) { return false; }
1: 
1:         // so there is no credentials db specified and we are booting a database.
1:         // this is only allowed if we are authenticating locally in that database.
1:         return _authenticateDatabaseOperationsLocally;
commit:49901a4
/////////////////////////////////////////////////////////////////////////
1: import java.sql.SQLWarning;
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.error.SQLWarningFactory;
/////////////////////////////////////////////////////////////////////////
1:     private long        _passwordLifetimeMillis = Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME_DEFAULT;
1:     private double      _passwordExpirationThreshold = Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD_DEFAULT;
1:     private String      _badlyFormattedPasswordProperty;
/////////////////////////////////////////////////////////////////////////
1: 
1:         //
1:         // Let the application override password lifespans.
1:         //
1:         _badlyFormattedPasswordProperty = null;
1:         String passwordLifetimeString = PropertyUtil.getPropertyFromSet
1:             (
1:              properties,
1:              Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME
1:              );
1:         if ( passwordLifetimeString != null )
1:         {
1:             Long    passwordLifetime = parsePasswordLifetime( passwordLifetimeString );
1: 
1:             if ( passwordLifetime != null ) { _passwordLifetimeMillis = passwordLifetime.longValue(); }
1:             else
1:             { _badlyFormattedPasswordProperty = Property.AUTHENTICATION_NATIVE_PASSWORD_LIFETIME; }
1:         }
1: 
1:         String  expirationThresholdString = PropertyUtil.getPropertyFromSet
1:             (
1:              properties,
1:              Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD
1:              );
1:         if ( expirationThresholdString != null )
1:         {
1:             Double  expirationThreshold = parsePasswordThreshold( expirationThresholdString );
1: 
1:             if ( expirationThreshold != null ) { _passwordExpirationThreshold = expirationThreshold.doubleValue(); }
1:             else
1:             { _badlyFormattedPasswordProperty = Property.AUTHENTICATION_PASSWORD_EXPIRATION_THRESHOLD; }
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:         if ( _badlyFormattedPasswordProperty != null )
1:         {
1:             throw StandardException.newException
1:                 ( SQLState.BAD_PASSWORD_LIFETIME, _badlyFormattedPasswordProperty );
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:         throws StandardException, SQLWarning
/////////////////////////////////////////////////////////////////////////
1:         SQLWarning  warnings = null;
1:         
/////////////////////////////////////////////////////////////////////////
1: 
1:             warnings = conn.getWarnings();
/////////////////////////////////////////////////////////////////////////
1:         // let warnings percolate up so that EmbedConnection can handle notifications
1:         // about expiring passwords
1:         if ( warnings != null ) { throw warnings; }
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:         try {
1:             if ( (candidatePassword == null) || (actualPassword == null)) { return false; }
1:             if ( candidatePassword.length != actualPassword.length ) { return false; }
1:             for ( int i = 0; i < candidatePassword.length; i++ )
1:             {
1:                 if ( candidatePassword[ i ] != actualPassword[ i ] ) { return false; }
1:             }
1:         } finally
0:             Arrays.fill( candidatePassword, (char) 0 );
0:             Arrays.fill( actualPassword, (char) 0 );
1: 
1:         //
1:         // Password is good. Check whether the password has expired or will expire soon.
1:         //
1:         if ( _passwordLifetimeMillis > 0 )
1:         {
1:             long    passwordAge = System.currentTimeMillis() - userDescriptor.getLastModified().getTime();
1:             long    remainingLifetime = _passwordLifetimeMillis - passwordAge;
1: 
1:             //
1:             // Oops, the password has expired. Fail the authentication. Say nothing more
1:             // so that we give password crackers as little information as possible.
1:             //
1:             if ( remainingLifetime <= 0L )
1:             {
1:                 // The DBO's password never expires.
1:                 if ( !dd.getAuthorizationDatabaseOwner().equals( userName ) ) { return false; }
1:                 else { remainingLifetime = 0L; }
1:             }
1: 
1:             long    expirationThreshold = (long) ( _passwordLifetimeMillis * _passwordExpirationThreshold );
1:             
1:             if ( remainingLifetime <= expirationThreshold )
1:             {
1:                 long    daysRemaining = remainingLifetime / Property.MILLISECONDS_IN_DAY;
0:                 throw SQLWarningFactory.newSQLWarning( SQLState.PASSWORD_EXPIRES_SOON, Long.toString( daysRemaining ) );
1:             }
1:         }
commit:c0399dc
/////////////////////////////////////////////////////////////////////////
1:         //
1:         // Special bootstrap code. If we are creating a credentials database, then
1:         // we store the DBO's initial credentials in it. We also turn on NATIVE LOCAL authentication
1:         // forever.
1:         //
1:         if ( _creatingCredentialsDB )
1:         {
1:             _creatingCredentialsDB = false;
1:             TransactionController   tc = getTransaction();
1:             SystemProcedures.addUser( userName, userPassword, tc );
0:             tc.setProperty
0:                 ( Property.AUTHENTICATION_PROVIDER_PARAMETER, Property.AUTHENTICATION_PROVIDER_NATIVE_LOCAL, true );
1:             tc.commit();
1:             
1:         
1:         //
1:         // we expect to find a data dictionary
1:         //
0:         DataDictionary      dd = (DataDictionary) Monitor.getServiceModule( this, DataDictionary.MODULE );        
1:         UserDescriptor      userDescriptor = dd.getUser( userName );
1:         
0:         if ( userDescriptor == null )   { return false; }
1:         
1:         PasswordHasher      hasher = new PasswordHasher( userDescriptor.getHashingScheme() );
1:         char[]                     candidatePassword = hasher.hashPasswordIntoString( userName, userPassword ).toCharArray();
1:         char[]                     actualPassword = userDescriptor.getAndZeroPassword();
1:         
0:         if ( (candidatePassword == null) || (actualPassword == null)) { return false; }
0:         if ( candidatePassword.length != actualPassword.length ) { return false; }
1:         
0:         for ( int i = 0; i < candidatePassword.length; i++ )
0:             if ( candidatePassword[ i ] != actualPassword[ i ] ) { return false; }
1:         
0:         Arrays.fill( candidatePassword, (char) 0 );
0:         Arrays.fill( actualPassword, (char) 0 );
1:         
1:         return true;
commit:5107349
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derby.impl.jdbc.authentication.NativeAuthenticationServiceImpl
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derby.impl.jdbc.authentication;
1: 
1: import java.util.Properties;
1: import java.security.MessageDigest;
1: import java.security.NoSuchAlgorithmException;
1: import java.sql.Connection;
1: import java.sql.SQLException;
1: import java.util.Arrays;
1: import javax.sql.DataSource;
1: 
1: import org.apache.derby.catalog.SystemProcedures;
1: import org.apache.derby.iapi.db.Database;
1: import org.apache.derby.iapi.reference.Property;
1: import org.apache.derby.iapi.services.info.JVMInfo;
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.PasswordHasher;
1: import org.apache.derby.iapi.sql.dictionary.UserDescriptor;
1: import org.apache.derby.iapi.reference.Attribute;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.authentication.UserAuthenticator;
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.monitor.Monitor;
1: import org.apache.derby.iapi.services.property.PropertyUtil;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.store.access.TransactionController;
1: import org.apache.derby.iapi.util.IdUtil;
1: import org.apache.derby.iapi.util.StringUtil;
1: import org.apache.derby.impl.jdbc.Util;
1: 
1: /**
1:  * <p>
1:  * This authentication service supports Derby NATIVE authentication.
1:  * </p>
1:  *
1:  * <p>
1:  * To activate this service, set the derby.authentication.provider database
1:  * or system property to a value beginning with the token "NATIVE:".
1:  * </p>
1:  *
1:  * <p>
1:  * This service instantiates and calls the basic User authentication scheme at runtime.
1:  * </p>
1:  *
1:  * <p>
1:  * User credentials are defined in the SYSUSERS table.
1:  * </p>
1:  *
1:  */
1: public final class NativeAuthenticationServiceImpl
1: 	extends AuthenticationServiceBase implements UserAuthenticator
1: {
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // CONSTANTS
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // STATE
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     // temporary, used when bootstrapping a locally authenticated database
1:     private boolean _creatingCredentialsDB = false;
1:     
1:     private String      _credentialsDB;
1:     private boolean _authenticateDatabaseOperationsLocally;
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // ModuleControl BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 *  Check if we should activate this authentication service.
1: 	 */
1: 	public boolean canSupport(Properties properties)
1:     {
1: 		if (!requireAuthentication(properties)) { return false; }
1: 
1:         if ( PropertyUtil.nativeAuthenticationEnabled( properties ) )
1:         {
1:             parseNativeSpecification( properties );
1: 
1:             return true;
1:         }
1:         else { return false; }
1: 	}
1: 
1:     /**
1:      * <p>
1:      * Parse the specification of NATIVE authentication. It can take 3 forms:
1:      * </p>
1:      *
1:      * <ul>
1:      * <li><i>NATIVE:$credentialsDB</i> - Here $credentialsDB is the name of a Derby database.
1:      *  This means that all authentication should take place in $credentialsDB.</li>
1:      * <li><i>NATIVE:$credentialsDB:LOCAL</i>- This means that system-wide operations (like engine shutdown)
1:      *  are authenticated in $credentialsDB but connections to existing databases are authenticated
1:      *  in those databases.</li>
1:      * <li><i>NATIVE::LOCAL</i> - This means that connections to a given database are authenticated
1:      *  in that database.</li>
1:      * </ul>
1:      */
1:     private void    parseNativeSpecification( Properties properties )
1:     {
1:         // If we get here, we already know that the authentication provider property
1:         // begins with the NATIVE: token
1:         String authenticationProvider = PropertyUtil.getPropertyFromSet
1:             (
1:              properties,
1:              Property.AUTHENTICATION_PROVIDER_PARAMETER
1:              );
1: 
1:         _authenticateDatabaseOperationsLocally = PropertyUtil.localNativeAuthenticationEnabled( properties );
1: 
1:         // Everything between the first colon and the last colon is the name of a database
1:         int     dbNameStartIdx = authenticationProvider.indexOf( ":" ) + 1;
1:         int     dbNameEndIdx = _authenticateDatabaseOperationsLocally ?
1:             authenticationProvider.lastIndexOf( ":" )
1:             : authenticationProvider.length();
1: 
1:         if ( dbNameEndIdx > dbNameStartIdx )
1:         {
1:             _credentialsDB = authenticationProvider.substring( dbNameStartIdx, dbNameEndIdx );
1: 
1:             if ( _credentialsDB.length() == 0 ) { _credentialsDB = null; }
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Return true if AUTHENTICATION_PROVIDER_PARAMETER was well formatted.
1:      * The property must have designated some database as the authentication authority.
1:      * </p>
1:      */
1:     private boolean validAuthenticationProvider()
1:     {
0:         return (_credentialsDB != null) || _authenticateDatabaseOperationsLocally;
1:     }
1: 
1: 	/**
1: 	 * @see org.apache.derby.iapi.services.monitor.ModuleControl#boot
1: 	 * @exception StandardException upon failure to load/boot the expected
1: 	 * authentication service.
1: 	 */
1: 	public void boot(boolean create, Properties properties)
1: 	  throws StandardException
1:     {
1: 		// first perform the initialization in our superclass
1: 		super.boot( create, properties );
1: 
1:         if ( !validAuthenticationProvider() )
1:         {
1:             throw StandardException.newException( SQLState.BAD_NATIVE_AUTH_SPEC );
1:         }
1: 
1: 		// Initialize the MessageDigest class engine here
1: 		// (we don't need to do that ideally, but there is some
1: 		// overhead the first time it is instantiated.
1: 		try {
1: 			MessageDigest digestAlgorithm = MessageDigest.getInstance("SHA-1");
1: 			digestAlgorithm.reset();
1: 
1: 		} catch (NoSuchAlgorithmException nsae) {
1: 			throw Monitor.exceptionStartingModule(nsae);
1: 		}
1: 
1:         // bootstrap the creation of the initial username/password when the dbo creates a credentials db
1:         if ( create && authenticatingInThisService( getCanonicalServiceName() ) ) { _creatingCredentialsDB = true; }
1:         else { _creatingCredentialsDB = false; }
1: 
1: 		// Set ourselves as being ready, having loaded the proper
1: 		// authentication scheme for this service
1: 		//
1: 		this.setAuthenticationService(this);
1: 	}
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // UserAuthenticator BEHAVIOR
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1:     /** Override behavior in superclass */
1:     public  String  getSystemCredentialsDatabaseName()    { return _credentialsDB; }
1:     /** Override behavior in superclass */
1: 
1: 	/**
1: 	 * Authenticate the passed-in user's credentials.
1: 	 *
1: 	 * @param userName		The user's name used to connect to JBMS system
1: 	 * @param userPassword	The user's password used to connect to JBMS system
1: 	 * @param databaseName	The database which the user wants to connect to.
1: 	 * @param info			Additional jdbc connection info.
1: 	 */
1: 	public boolean	authenticateUser
1:         (
1:          String userName,
1:          String userPassword,
1:          String databaseName,
1:          Properties info
1:          )
1:         throws SQLException
1: 	{
1:         try {
1:             // No "guest" user
1:             if ( userName == null ) { return false; }
1: 
1:             //
1:             // We must handle these cases:
1:             //
1:             // 1) Database name is null. This means that we are authenticating a system-wide
1:             // operation. The authentication must be done by the system-wide credentials database.
1:             //
1:             // 2) Database name is not null and authentication is NOT specified as local.
1:             // This means that we are authenticating a database-specific operation
1:             // in the system-wide credentials database. There are two subcases:
1:             //
1:             // 2a) The current database is NOT the credentials database. This reduces to case (1) above:
1:             // authentication must be performed in another database.
1:             //
1:             // 2b) The current database IS the credentials database. This reduces to case (3) below:
1:             // authentication must be performed in this database.
1:             //
1:             // 3) Database name is not null and authentication IS being performed locally in this database.
1:             // This means that we are authenticating a database-specific operation and performing the
1:             // authentication in this database.
1:             //
1: 
1:             if ( (databaseName == null) || !authenticatingInThisDatabase( databaseName ) )
1:             {
1:                 return authenticateRemotely(  userName, userPassword, databaseName );
1:             }
1:             else
1:             {
1:                 return authenticateLocally( userName, userPassword, databaseName );
1:             }
1:         }
1:         catch (StandardException se)
1:         {
1:             throw Util.generateCsSQLException(se);
1:         }
1: 	}
1: 
1:     /**
1:      * <p>
1:      * Return true if we are authenticating in this database.
1:      * </p>
1:      */
1:     private boolean authenticatingInThisDatabase( String userVisibleDatabaseName )
1:         throws StandardException
1:     {
0:         return authenticatingInThisService( Monitor.getMonitor().getCanonicalServiceName( userVisibleDatabaseName ) );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Return true if we are authenticating in this service.
1:      * </p>
1:      */
1:     private boolean authenticatingInThisService( String canonicalDatabaseName )
1:         throws StandardException
1:     {
1:         if ( _authenticateDatabaseOperationsLocally ) { return true; }
1:         else { return isCredentialsService( canonicalDatabaseName ); }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Return true if the passed in service is the credentials database.
1:      * </p>
1:      */
1:     private boolean isCredentialsService( String canonicalDatabaseName )
1:         throws StandardException
1:     {
1:         String  canonicalCredentialsDBName = getCanonicalServiceName( _credentialsDB );
1: 
0:         String canonicalDB = Monitor.getMonitor().getCanonicalServiceName( canonicalDatabaseName );
1: 
1:         if ( canonicalCredentialsDBName == null ) { return false; }
1:         else { return canonicalCredentialsDBName.equals( canonicalDatabaseName ); }
1:     }
1: 
1:     /** Get the canonical name of the current database service */
1:     private String  getCanonicalServiceName()
1:         throws StandardException
1:     {
1:         return getCanonicalServiceName( getServiceName() );
1:     }
1: 
1:     /** Turn a service name into its normalized, standard form */
1:     private String  getCanonicalServiceName( String rawName )
1:         throws StandardException
1:     {
0:         return Monitor.getMonitor().getCanonicalServiceName( rawName );
1:     }
1: 
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // AUTHENTICATE REMOTELY
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Authenticate the passed-in credentials against another Derby database. This is done
1:      * by getting a connection to the credentials database using the supplied username
1:      * and password. If the connection attempts succeeds, then authentication succeeds.
1: 	 *
1: 	 * @param userName		The user's name used to connect to JBMS system
1: 	 * @param userPassword	The user's password used to connect to JBMS system
1: 	 * @param databaseName	The database which the user wants to connect to.
1: 	 */
1: 	private boolean	authenticateRemotely
1:         (
1:          String userName,
1:          String userPassword,
1:          String databaseName
1:          )
1:         throws StandardException
1: 	{
1:         // this catches the case when someone specifies derby.authentication.provider=NATIVE::LOCAL
1:         // at the system level
1:         if ( _credentialsDB == null )
1:         {
1:             throw StandardException.newException( SQLState.BAD_NATIVE_AUTH_SPEC );
1:         }
1:         
0:         String      dataSourceName = JVMInfo.J2ME ?
0:             "org.apache.derby.jdbc.EmbeddedSimpleDataSource" :
0:             "org.apache.derby.jdbc.EmbeddedDataSource";
1: 
1:         try {
0:             DataSource  dataSource = (DataSource) Class.forName( dataSourceName ).newInstance();
1: 
0:             callDataSourceSetter( dataSource, "setDatabaseName", _credentialsDB );
0:             callDataSourceSetter( dataSource, "setUser", userName );
0:             callDataSourceSetter( dataSource, "setPassword", userPassword );
1: 
0:             Connection  conn = dataSource.getConnection();
1:             conn.close();
1:         }
0:         catch (ClassNotFoundException cnfe) { throw wrap( cnfe ); }
0:         catch (InstantiationException ie) { throw wrap( ie ); }
0:         catch (IllegalAccessException ie) { throw wrap( ie ); }
1:         catch (SQLException se)
1:         {
1:             String  sqlState = se.getSQLState();
1: 
1:             if ( SQLState.LOGIN_FAILED.equals( sqlState ) ) { return false; }
1:             else if ( SQLState.DATABASE_NOT_FOUND.startsWith( sqlState ) )
1:             {
1:                 throw StandardException.newException( SQLState.MISSING_CREDENTIALS_DB, _credentialsDB );
1:             }
1:             else { throw wrap( se ); }
1:         }
1: 
1:         // If we get here, then we successfully connected to the credentials database. Hooray.
1:         return true;
1:     }
0:     /** Call a setter method on a DataSource via reflection */
0:     private void callDataSourceSetter( DataSource ds, String methodName, String value )
1:         throws StandardException
1:     {
1:         try {
0:             ds.getClass().getMethod( methodName, new Class[] { String.class } ).invoke( ds, new Object[] { value } );
0:         } catch (Exception e)  { throw wrap( e ); }   
1:     }
1:     private StandardException wrap( Throwable t )   { return StandardException.plainWrapException( t ); }
1:     
1:     ///////////////////////////////////////////////////////////////////////////////////
1:     //
1:     // AUTHENTICATE LOCALLY
1:     //
1:     ///////////////////////////////////////////////////////////////////////////////////
1: 
1: 	/**
1: 	 * Authenticate the passed-in credentials against the local database.
1: 	 *
1: 	 * @param userName		The user's name used to connect to JBMS system
1: 	 * @param userPassword	The user's password used to connect to JBMS system
1: 	 * @param databaseName	The database which the user wants to connect to.
1: 	 */
1: 	private boolean	authenticateLocally
1:         (
1:          String userName,
1:          String userPassword,
1:          String databaseName
1:          )
1:         throws StandardException, SQLException
1: 	{
1:         userName = IdUtil.getUserAuthorizationId( userName ) ;
1: 
0:         TransactionController   tc = getTransaction();
1:         try {
1:             //
0:             // Special bootstrap code. If we are creating a credentials database, then
0:             // we store the DBO's initial credentials in it. We also turn on NATIVE LOCAL authentication
0:             // forever.
1:             //
0:             if ( _creatingCredentialsDB )
1:             {
0:                 _creatingCredentialsDB = false;
1:             
0:                 SystemProcedures.addUser( userName, userPassword, tc );
1:             
0:                 tc.setProperty
0:                     ( Property.AUTHENTICATION_PROVIDER_PARAMETER, Property.AUTHENTICATION_PROVIDER_NATIVE_LOCAL, true );
1:             
1:                 return true;
1:             }
1:         
1:             //
0:             // we expect to find a data dictionary
1:             //
0:             DataDictionary      dd = (DataDictionary) Monitor.getServiceModule( this, DataDictionary.MODULE );
1:         
1:             //
0:             // NATIVE authentication is only available if the database is at version 10.9 or later
1:             //
0:             dd.checkVersion( DataDictionary.DD_VERSION_DERBY_10_9, "NATIVE AUTHENTICATION" );
1:         
0:             UserDescriptor      userDescriptor = dd.getUser( userName, tc );
1:         
0:             if ( userDescriptor == null )   { return false; }
1:         
0:             PasswordHasher      hasher = new PasswordHasher( userDescriptor.getHashingScheme() );
0:             char[]                     candidatePassword = hasher.hashPasswordIntoString( userName, userPassword ).toCharArray();
0:             char[]                     actualPassword = userDescriptor.getAndZeroPassword();
1:         
0:             if ( (candidatePassword == null) || (actualPassword == null)) { return false; }
0:             if ( candidatePassword.length != actualPassword.length ) { return false; }
1:         
0:             for ( int i = 0; i < candidatePassword.length; i++ )
1:             {
0:                 if ( candidatePassword[ i ] != actualPassword[ i ] ) { return false; }
1:             }
1:         
0:             Arrays.fill( candidatePassword, (char) 0 );
0:             Arrays.fill( actualPassword, (char) 0 );
1:         
1:             return true;
1:         }
0:         finally
1:         {
0:             tc.commit();
1:         }
1:     }
1:     
1: }
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
============================================================================