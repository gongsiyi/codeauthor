1:eac0369: /*
18:eac0369: 
1:345de35:    Derby - Class org.apache.derby.catalog.types.BaseTypeIdImpl
1:345de35: 
1:2f36947:    Licensed to the Apache Software Foundation (ASF) under one or more
1:2f36947:    contributor license agreements.  See the NOTICE file distributed with
1:2f36947:    this work for additional information regarding copyright ownership.
1:2f36947:    The ASF licenses this file to You under the Apache License, Version 2.0
1:2f36947:    (the "License"); you may not use this file except in compliance with
1:2f36947:    the License.  You may obtain a copy of the License at
1:345de35: 
1:345de35:       http://www.apache.org/licenses/LICENSE-2.0
1:345de35: 
1:345de35:    Unless required by applicable law or agreed to in writing, software
1:345de35:    distributed under the License is distributed on an "AS IS" BASIS,
1:345de35:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:345de35:    See the License for the specific language governing permissions and
1:345de35:    limitations under the License.
1:345de35: 
3:eac0369:  */
1:eac0369: 
1:eac0369: package org.apache.derby.catalog.types;
1:eac0369: 
1:3bb140c: import java.io.IOException;
1:3bb140c: import java.io.ObjectInput;
1:3bb140c: import java.io.ObjectOutput;
1:3bb140c: import java.sql.Types;
1:eac0369: import org.apache.derby.catalog.TypeDescriptor;
1:3bb140c: import org.apache.derby.iapi.reference.SQLState;
1:3bb140c: import org.apache.derby.iapi.services.i18n.MessageService;
1:eac0369: import org.apache.derby.iapi.services.io.Formatable;
1:eac0369: import org.apache.derby.iapi.services.io.StoredFormatIds;
1:7e51e9d: import org.apache.derby.shared.common.sanity.SanityManager;
1:eac0369: import org.apache.derby.iapi.types.TypeId;
1:506f4c8: import org.apache.derby.iapi.util.IdUtil;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * This class is the base class for all type ids that are written to the
1:eac0369:  * system tables.
1:eac0369:  */
1:eac0369: public class BaseTypeIdImpl implements Formatable
3:eac0369: {
1:eac0369: 
1:eac0369:     /********************************************************
1:eac0369:     **
1:eac0369:     **      This class implements Formatable. That means that it
1:eac0369:     **      can write itself to and from a formatted stream. If
1:eac0369:     **      you add more fields to this class, make sure that you
1:eac0369:     **      also write/read them with the writeExternal()/readExternal()
1:eac0369:     **      methods.
1:eac0369:     **
1:eac0369:     **      If, inbetween releases, you add more fields to this class,
1:eac0369:     **      then you should bump the version number emitted by the 
1:eac0369:     **      getTypeFormatId() method.
1:eac0369:     **
1:eac0369:     ********************************************************/
1:2afe578:     
1:2afe578:     private int   formatId;
1:eac0369: 
1:d039ced:     // schema where the type lives. only for UDTs
1:2732872:     protected String schemaName;
1:d039ced: 
1:d039ced:     // unqualified type name
1:d039ced:     String unqualifiedName;
1:d039ced: 
1:2afe578:     /**
1:2afe578:      * JDBC type - derived from the format identifier.
1:2afe578:      */
1:2afe578:     transient int           JDBCTypeId;
1:2afe578: 
1:eac0369:     /**
1:eac0369:      * niladic constructor. Needed for Formatable interface to work.
1:eac0369:      *
1:eac0369:      */
1:eac0369: 
1:eac0369:     public BaseTypeIdImpl() {}
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * 1 argument constructor. Needed for Formatable interface to work.
1:eac0369:      *
1:eac0369:      * @param formatId      Format id of specific type id.
1:eac0369:      */
1:eac0369:     public BaseTypeIdImpl(int formatId)
1:eac0369:     {
1:eac0369:         this.formatId = formatId;
1:eac0369:         setTypeIdSpecificInstanceVariables();
3:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Constructor for an BaseTypeIdImpl
1:eac0369:      *
1:d039ced:      * @param SQLTypeName   The unqualified SQL name of the type
1:eac0369:      */
1:eac0369: 
1:2afe578:     BaseTypeIdImpl(String SQLTypeName)
1:eac0369:     {
1:d039ced:         this.schemaName = null;
1:d039ced:         this.unqualifiedName = SQLTypeName;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:d039ced:      * Constructor for an BaseTypeIdImpl which describes a UDT
1:d039ced:      *
1:d039ced:      * @param schemaName The schema that the UDT lives in
1:bc009a8:      * @param unqualifiedName The unqualified name of the UDT in that schema
1:d039ced:      */
1:d039ced: 
1:d039ced:     BaseTypeIdImpl(String schemaName, String unqualifiedName )
1:d039ced:     {
1:d039ced:         this.schemaName = schemaName;
1:d039ced:         this.unqualifiedName = unqualifiedName;
1:d039ced:     }
1:d039ced: 
1:d039ced:     /**
1:d039ced:      * Returns the SQL name of the datatype. If it is a Derby user-defined type,
1:eac0369:      * it returns the full Java path name for the datatype, meaning the
1:d039ced:      * dot-separated path including the package names. If it is a UDT, returns
1:d039ced:      * "schemaName"."unqualifiedName".
1:eac0369:      *
1:eac0369:      * @return      A String containing the SQL name of this type.
1:eac0369:      */
1:eac0369:     public String   getSQLTypeName()
1:eac0369:     {
1:d039ced:         if ( schemaName == null ) { return unqualifiedName; }
1:506f4c8:         else { return IdUtil.mkQualifiedName( schemaName, unqualifiedName ); }
1:eac0369:     }
1:eac0369: 
1:d039ced:     /** Get the schema name of this type. Non-null only for UDTs */
1:d039ced:     public String getSchemaName() { return schemaName; }
1:d039ced: 
1:d039ced:     /** Get the unqualified name of this type. Except for UDTs, this is the same
1:d039ced:      * value as getSQLTypeName()
1:d039ced:      */
1:d039ced:     public String getUnqualifiedName() { return unqualifiedName; }
1:d039ced: 
1:e126f58:     /** Return true if this is this type id describes an ANSI UDT */
1:e126f58:     public boolean isAnsiUDT() { return (schemaName != null); }
1:e126f58:     
1:eac0369:     /**
1:eac0369:      * Get the jdbc type id for this type.  JDBC type can be
1:eac0369:      * found in java.sql.Types. 
1:eac0369:      *
1:eac0369:      * @return      a jdbc type, e.g. java.sql.Types.DECIMAL 
1:eac0369:      *
1:eac0369:      * @see Types
1:eac0369:      */
1:eac0369:     public int getJDBCTypeId()
1:eac0369:     {
1:eac0369:         return JDBCTypeId;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Converts this TypeId, given a data type descriptor 
1:eac0369:      * (including length/precision), to a string. E.g.
1:eac0369:      *
1:eac0369:      *                      VARCHAR(30)
1:eac0369:      *
1:eac0369:      *
1:eac0369:      *      For most data types, we just return the SQL type name.
1:eac0369:      *
1:eac0369:      *      @param  td      Data type descriptor that holds the 
1:eac0369:      *                      length/precision etc. as necessary
1:eac0369:      *
1:eac0369:      *       @return        String version of datatype, suitable for running 
1:eac0369:      *                      through the Parser.
1:eac0369:      */
1:eac0369:     public String   toParsableString(TypeDescriptor td)
1:eac0369:     {
1:eac0369:         String retval = getSQLTypeName();
1:eac0369: 
1:506f4c8:         switch (getTypeFormatId())
1:eac0369:         {
1:eac0369:           case StoredFormatIds.BIT_TYPE_ID_IMPL:
1:eac0369:           case StoredFormatIds.VARBIT_TYPE_ID_IMPL:
1:eac0369: 			  int rparen = retval.indexOf(')');
1:eac0369: 			  String lead = retval.substring(0, rparen);
1:eac0369: 			  retval = lead + td.getMaximumWidth() + retval.substring(rparen);
1:6e2e8c0: 			  break;
1:d039ced: 
1:eac0369:           case StoredFormatIds.CHAR_TYPE_ID_IMPL:
1:eac0369:           case StoredFormatIds.VARCHAR_TYPE_ID_IMPL:
1:eac0369:           case StoredFormatIds.BLOB_TYPE_ID_IMPL:
1:eac0369:           case StoredFormatIds.CLOB_TYPE_ID_IMPL:
1:eac0369:                 retval += "(" + td.getMaximumWidth() + ")";
1:6e2e8c0:                 break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.DECIMAL_TYPE_ID_IMPL:
1:eac0369:                 retval += "(" + td.getPrecision() + "," + td.getScale() + ")";
1:6e2e8c0:                 break;
1:eac0369:         }
1:eac0369: 
1:eac0369:         return retval;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /** Does this type id represent a user type? */
1:eac0369:     public boolean userType()
1:eac0369:     {
1:eac0369:         return false;
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Format this BaseTypeIdImpl as a String
1:eac0369:      *
1:eac0369:      * @return      This BaseTypeIdImpl formatted as a String
1:eac0369:      */
1:eac0369: 
1:eac0369:     public String   toString()
1:eac0369:     {
1:eac0369:         return MessageService.getTextMessage(SQLState.TI_SQL_TYPE_NAME) +
1:4aef9b0:                 ": " + getSQLTypeName();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * we want equals to say if these are the same type id or not.
1:eac0369:      */
1:eac0369:     public boolean equals(Object that)
1:eac0369:     {
1:eac0369:         if (that instanceof BaseTypeIdImpl)
1:eac0369:         {
1:4aef9b0:             return this.getSQLTypeName().equals(((BaseTypeIdImpl)that).getSQLTypeName());
1:eac0369:         }
1:eac0369:         else
1:eac0369:         {
1:eac0369:             return false;
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:       Hashcode which works with equals.
1:eac0369:       */
1:eac0369:     public int hashCode()
1:eac0369:     {
1:4aef9b0:         return this.getSQLTypeName().hashCode();
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Get the formatID which corresponds to this class.
1:eac0369:      *
1:eac0369:      * @return      the formatID of this class
1:eac0369:      */
1:eac0369:     public int getTypeFormatId()
1:eac0369:     {
1:506f4c8:         if ( formatId != 0 ) { return formatId; }
1:506f4c8:         else
1:506f4c8:         {
1:506f4c8:             //
1:506f4c8:             // If you serialize this class outside the formatable machinery, you
1:506f4c8:             // will lose the format id. This can happen if you pass one of these
1:506f4c8:             // objects across the network. Here we recover the format id.
1:506f4c8:             //
1:3bb140c:             if ( TypeId.BOOLEAN_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.BOOLEAN_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.BIGINT_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.BIGINT_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.INTEGER_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.INT_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.SMALLINT_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.SMALLINT_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.TINYINT_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.TINYINT_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.DECIMAL_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.NUMERIC_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.DOUBLE_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.DOUBLE_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.REAL_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.REAL_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.REF_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.REF_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.CHAR_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.CHAR_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.VARCHAR_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.VARCHAR_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.LONGVARCHAR_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.CLOB_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.CLOB_TYPE_ID_IMPL; }
1:55d3591:             //DERBY-5407 Network Server on wire sends CHAR () FOR BIT DATA 
1:55d3591:             // not CHAR FOR BIT DATA. Keeping the check for CHAR FOR BIT
1:55d3591:             // DATA just in case if there is any dependency on that check
1:3bb140c:             else if ( TypeId.BIT_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.BIT_TYPE_ID_IMPL; }
1:3bb140c:             else if ( "CHAR FOR BIT DATA".equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.BIT_TYPE_ID_IMPL; }
1:55d3591:             //DERBY-5407 Network Server on wire sends VARCHAR () FOR BIT DATA 
1:55d3591:             // not VARCHAR FOR BIT DATA. Keeping the check for VARCHAR FOR BIT
1:55d3591:             // DATA just in case if there is any dependency on that check
1:3bb140c:             else if ( TypeId.VARBIT_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }
1:3bb140c:             else if ( "VARCHAR FOR BIT DATA".equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.LONGVARBIT_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.BLOB_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.BLOB_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.DATE_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.DATE_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.TIME_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.TIME_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.TIMESTAMP_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL; }
1:3bb140c:             else if ( TypeId.XML_NAME.equals( unqualifiedName ) ) {
1:3bb140c:                 return StoredFormatIds.XML_TYPE_ID_IMPL; }
1:506f4c8:             else { return 0; }
1:506f4c8:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Read this object from a stream of stored objects.
1:eac0369:      *
1:eac0369:      * @param in read this.
1:eac0369:      *
1:eac0369:      * @exception IOException                       thrown on error
1:eac0369:      * @exception ClassNotFoundException            thrown on error
1:eac0369:      */
1:eac0369:     public void readExternal( ObjectInput in )
1:eac0369:              throws IOException, ClassNotFoundException
1:eac0369:     {
1:d039ced:         unqualifiedName = in.readUTF();
1:d039ced: 
1:d039ced:         //
1:d039ced:         // If the name begins with a quote, then it is just the first part
1:d039ced:         // of the type name, viz., the schema that the type lives in.
1:d039ced:         // Strip the quotes from around the name and then read the
1:d039ced:         // following  unqualified name.
1:d039ced:         //
1:d039ced:         if ( unqualifiedName.charAt( 0 ) == '"' )
1:d039ced:         {
1:d039ced:             schemaName = stripQuotes( unqualifiedName );
1:d039ced:             unqualifiedName = in.readUTF();
1:d039ced:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     /**
1:eac0369:      * Write this object to a stream of stored objects.
1:eac0369:      *
1:eac0369:      * @param out write bytes here.
1:eac0369:      *
1:eac0369:      * @exception IOException               thrown on error
1:eac0369:      */
1:eac0369:     public void writeExternal( ObjectOutput out )
1:eac0369:              throws IOException
1:eac0369:     {
1:d039ced:         if ( schemaName == null ) { out.writeUTF( unqualifiedName ); }
1:d039ced:         else
1:d039ced:         {
1:d039ced:             //
1:d039ced:             // Wrap the schema name in quotes. quotes are illegal characters in
1:d039ced:             // basic SQL type names and in Java class names, so this will flag
1:d039ced:             // readExternal() that this type has a 2-part name
1:d039ced:             // (schemaName.unqualifiedName).
1:d039ced:             //
1:d039ced:             out.writeUTF( doubleQuote( schemaName ) );
1:d039ced:             out.writeUTF( unqualifiedName );
1:d039ced:         }
1:eac0369:     }
1:eac0369: 
1:eac0369:     private void setTypeIdSpecificInstanceVariables()
1:eac0369:     {
1:506f4c8:         switch (getTypeFormatId())
1:eac0369:         {
1:eac0369:           case StoredFormatIds.BOOLEAN_TYPE_ID_IMPL:
1:92268ac:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.BOOLEAN_NAME;
1:c769b62:               JDBCTypeId = Types.BOOLEAN;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.INT_TYPE_ID_IMPL:
2:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.INTEGER_NAME;
1:d039ced:               JDBCTypeId = Types.INTEGER;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.SMALLINT_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.SMALLINT_NAME;
1:d039ced:               JDBCTypeId = Types.SMALLINT;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.TINYINT_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.TINYINT_NAME;
1:d039ced:               JDBCTypeId = Types.TINYINT;
1:d039ced:               break;
1:eac0369: 
1:3bb140c:           case StoredFormatIds.BIGINT_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:3bb140c:               unqualifiedName = TypeId.BIGINT_NAME;
1:d039ced:               JDBCTypeId = Types.BIGINT;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.DECIMAL_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.DECIMAL_NAME;
1:d039ced:               JDBCTypeId = Types.DECIMAL;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.DOUBLE_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.DOUBLE_NAME;
1:d039ced:               JDBCTypeId = Types.DOUBLE;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.REAL_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.REAL_NAME;
1:d039ced:               JDBCTypeId = Types.REAL;
1:d039ced:               break;
1:eac0369:                 
1:eac0369:           case StoredFormatIds.REF_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.REF_NAME;
1:d039ced:               JDBCTypeId = Types.OTHER;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.CHAR_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.CHAR_NAME;
1:d039ced:               JDBCTypeId = Types.CHAR;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.VARCHAR_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.VARCHAR_NAME;
1:92268ac:               JDBCTypeId = Types.VARCHAR;
1:92268ac:               break;
1:92268ac: 
1:eac0369:           case StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.LONGVARCHAR_NAME;
1:d039ced:               JDBCTypeId = Types.LONGVARCHAR;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.CLOB_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.CLOB_NAME;
1:d039ced:               JDBCTypeId = Types.CLOB;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.BIT_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.BIT_NAME;
1:d039ced:               JDBCTypeId = Types.BINARY;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.VARBIT_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.VARBIT_NAME;
1:d039ced:               JDBCTypeId = Types.VARBINARY;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.LONGVARBIT_NAME;
1:d039ced:               JDBCTypeId = Types.LONGVARBINARY;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.BLOB_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.BLOB_NAME;
1:d039ced:               JDBCTypeId = Types.BLOB;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.DATE_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.DATE_NAME;
1:d039ced:               JDBCTypeId = Types.DATE;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.TIME_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.TIME_NAME;
1:d039ced:               JDBCTypeId = Types.TIME;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           case StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.TIMESTAMP_NAME;
1:d039ced:               JDBCTypeId = Types.TIMESTAMP;
1:d039ced:               break;
1:eac0369: 
1:099e28f:           case StoredFormatIds.XML_TYPE_ID_IMPL:
1:d039ced:               schemaName = null;
1:d039ced:               unqualifiedName = TypeId.XML_NAME;
1:e33b8d8:               JDBCTypeId = Types.SQLXML;
1:d039ced:               break;
1:eac0369: 
1:eac0369:           default:
1:eac0369:                 if (SanityManager.DEBUG)
1:eac0369:                 {
1:506f4c8:                     SanityManager.THROWASSERT("Unexpected formatId " + getTypeFormatId());
1:eac0369:                 }
1:d039ced:                 break;
1:eac0369:         }
1:eac0369:     }
1:eac0369: 
1:d039ced:     // wrap a string in quotes
1:d039ced:     private String doubleQuote( String raw ) { return '"' + raw + '"'; }
1:d039ced: 
1:d039ced:     // strip the bracketing quotes from a string
1:d039ced:     private String stripQuotes( String quoted ) { return quoted.substring( 1, quoted.length() - 1 ); }
1:d039ced:     
1:eac0369: }
============================================================================
author:Bryan Pendleton
-------------------------------------------------------------------------------
commit:7e51e9d
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.shared.common.sanity.SanityManager;
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:3bb140c
/////////////////////////////////////////////////////////////////////////
1: import java.io.IOException;
1: import java.io.ObjectInput;
1: import java.io.ObjectOutput;
1: import java.sql.Types;
1: import org.apache.derby.iapi.reference.SQLState;
1: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.services.sanity.SanityManager;
/////////////////////////////////////////////////////////////////////////
1:             if ( TypeId.BOOLEAN_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.BOOLEAN_TYPE_ID_IMPL; }
1:             else if ( TypeId.BIGINT_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.BIGINT_TYPE_ID_IMPL; }
1:             else if ( TypeId.INTEGER_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.INT_TYPE_ID_IMPL; }
1:             else if ( TypeId.SMALLINT_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.SMALLINT_TYPE_ID_IMPL; }
1:             else if ( TypeId.TINYINT_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.TINYINT_TYPE_ID_IMPL; }
1:             else if ( TypeId.DECIMAL_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
1:             else if ( TypeId.NUMERIC_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
1:             else if ( TypeId.DOUBLE_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.DOUBLE_TYPE_ID_IMPL; }
1:             else if ( TypeId.REAL_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.REAL_TYPE_ID_IMPL; }
1:             else if ( TypeId.REF_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.REF_TYPE_ID_IMPL; }
1:             else if ( TypeId.CHAR_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.CHAR_TYPE_ID_IMPL; }
1:             else if ( TypeId.VARCHAR_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.VARCHAR_TYPE_ID_IMPL; }
1:             else if ( TypeId.LONGVARCHAR_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL; }
1:             else if ( TypeId.CLOB_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.CLOB_TYPE_ID_IMPL; }
1:             else if ( TypeId.BIT_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.BIT_TYPE_ID_IMPL; }
1:             else if ( "CHAR FOR BIT DATA".equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.BIT_TYPE_ID_IMPL; }
1:             else if ( TypeId.VARBIT_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }
1:             else if ( "VARCHAR FOR BIT DATA".equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }
1:             else if ( TypeId.LONGVARBIT_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL; }
1:             else if ( TypeId.BLOB_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.BLOB_TYPE_ID_IMPL; }
1:             else if ( TypeId.DATE_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.DATE_TYPE_ID_IMPL; }
1:             else if ( TypeId.TIME_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.TIME_TYPE_ID_IMPL; }
1:             else if ( TypeId.TIMESTAMP_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL; }
1:             else if ( TypeId.XML_NAME.equals( unqualifiedName ) ) {
1:                 return StoredFormatIds.XML_TYPE_ID_IMPL; }
/////////////////////////////////////////////////////////////////////////
1:           case StoredFormatIds.BIGINT_TYPE_ID_IMPL:
1:               unqualifiedName = TypeId.BIGINT_NAME;
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:e33b8d8
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:               JDBCTypeId = Types.SQLXML;
commit:c769b62
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:               JDBCTypeId = Types.BOOLEAN;
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:55d3591
/////////////////////////////////////////////////////////////////////////
0:             if ( TypeId.BOOLEAN_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.BOOLEAN_TYPE_ID_IMPL; }
0:             else if ( TypeId.LONGINT_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.LONGINT_TYPE_ID_IMPL; }
0:             else if ( TypeId.INTEGER_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.INT_TYPE_ID_IMPL; }
0:             else if ( TypeId.SMALLINT_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.SMALLINT_TYPE_ID_IMPL; }
0:             else if ( TypeId.TINYINT_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.TINYINT_TYPE_ID_IMPL; }
0:             else if ( TypeId.LONGINT_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.LONGINT_TYPE_ID_IMPL; }
0:             else if ( TypeId.DECIMAL_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
0:             else if ( TypeId.NUMERIC_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
0:             else if ( TypeId.DOUBLE_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.DOUBLE_TYPE_ID_IMPL; }
0:             else if ( TypeId.REAL_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.REAL_TYPE_ID_IMPL; }
0:             else if ( TypeId.REF_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.REF_TYPE_ID_IMPL; }
0:             else if ( TypeId.CHAR_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.CHAR_TYPE_ID_IMPL; }
0:             else if ( TypeId.VARCHAR_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.VARCHAR_TYPE_ID_IMPL; }
0:             else if ( TypeId.LONGVARCHAR_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL; }
0:             else if ( TypeId.CLOB_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.CLOB_TYPE_ID_IMPL; }
1:             //DERBY-5407 Network Server on wire sends CHAR () FOR BIT DATA 
1:             // not CHAR FOR BIT DATA. Keeping the check for CHAR FOR BIT
1:             // DATA just in case if there is any dependency on that check
0:             else if ( TypeId.BIT_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.BIT_TYPE_ID_IMPL; }
1:             //DERBY-5407 Network Server on wire sends VARCHAR () FOR BIT DATA 
1:             // not VARCHAR FOR BIT DATA. Keeping the check for VARCHAR FOR BIT
1:             // DATA just in case if there is any dependency on that check
0:             else if ( TypeId.VARBIT_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }
0:             else if ( TypeId.LONGVARBIT_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL; }
0:             else if ( TypeId.BLOB_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.BLOB_TYPE_ID_IMPL; }
0:             else if ( TypeId.DATE_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.DATE_TYPE_ID_IMPL; }
0:             else if ( TypeId.TIME_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.TIME_TYPE_ID_IMPL; }
0:             else if ( TypeId.TIMESTAMP_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL; }
0:             else if ( TypeId.XML_NAME.equals( unqualifiedName ) ) { return StoredFormatIds.XML_TYPE_ID_IMPL; }
commit:111785f
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:9495437
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:92268ac
/////////////////////////////////////////////////////////////////////////
0:           case StoredFormatIds.PASSWORD_TYPE_ID_IMPL:
/////////////////////////////////////////////////////////////////////////
0:           case StoredFormatIds.PASSWORD_TYPE_ID_IMPL:
1:               schemaName = null;
0:               unqualifiedName = TypeId.PASSWORD_NAME;
1:               JDBCTypeId = Types.VARCHAR;
1:               break;
1: 
commit:2732872
/////////////////////////////////////////////////////////////////////////
1:     protected String schemaName;
commit:506f4c8
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.util.IdUtil;
/////////////////////////////////////////////////////////////////////////
1:         else { return IdUtil.mkQualifiedName( schemaName, unqualifiedName ); }
/////////////////////////////////////////////////////////////////////////
1:         switch (getTypeFormatId())
/////////////////////////////////////////////////////////////////////////
1:         if ( formatId != 0 ) { return formatId; }
1:         else
1:         {
1:             //
1:             // If you serialize this class outside the formatable machinery, you
1:             // will lose the format id. This can happen if you pass one of these
1:             // objects across the network. Here we recover the format id.
1:             //
0:             if ( "BOOLEAN".equals( unqualifiedName ) ) { return StoredFormatIds.BOOLEAN_TYPE_ID_IMPL; }
0:             else if ( "BIGINT".equals( unqualifiedName ) ) { return StoredFormatIds.LONGINT_TYPE_ID_IMPL; }
0:             else if ( "INTEGER".equals( unqualifiedName ) ) { return StoredFormatIds.INT_TYPE_ID_IMPL; }
0:             else if ( "SMALLINT".equals( unqualifiedName ) ) { return StoredFormatIds.SMALLINT_TYPE_ID_IMPL; }
0:             else if ( "TINYINT".equals( unqualifiedName ) ) { return StoredFormatIds.TINYINT_TYPE_ID_IMPL; }
0:             else if ( "LONGINT".equals( unqualifiedName ) ) { return StoredFormatIds.LONGINT_TYPE_ID_IMPL; }
0:             else if ( "DECIMAL".equals( unqualifiedName ) ) { return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
0:             else if ( "NUMERIC".equals( unqualifiedName ) ) { return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
0:             else if ( "DOUBLE".equals( unqualifiedName ) ) { return StoredFormatIds.DOUBLE_TYPE_ID_IMPL; }
0:             else if ( "REAL".equals( unqualifiedName ) ) { return StoredFormatIds.REAL_TYPE_ID_IMPL; }
0:             else if ( "REF".equals( unqualifiedName ) ) { return StoredFormatIds.REF_TYPE_ID_IMPL; }
0:             else if ( "CHAR".equals( unqualifiedName ) ) { return StoredFormatIds.CHAR_TYPE_ID_IMPL; }
0:             else if ( "VARCHAR".equals( unqualifiedName ) ) { return StoredFormatIds.VARCHAR_TYPE_ID_IMPL; }
0:             else if ( "LONG VARCHAR".equals( unqualifiedName ) ) { return StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL; }
0:             else if ( "CLOB".equals( unqualifiedName ) ) { return StoredFormatIds.CLOB_TYPE_ID_IMPL; }
0:             else if ( "CHAR FOR BIT DATA".equals( unqualifiedName ) ) { return StoredFormatIds.BIT_TYPE_ID_IMPL; }
0:             else if ( "VARCHAR FOR BIT DATA".equals( unqualifiedName ) ) { return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }
0:             else if ( "LONG VARCHAR FOR BIT DATA".equals( unqualifiedName ) ) { return StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL; }
0:             else if ( "BLOB".equals( unqualifiedName ) ) { return StoredFormatIds.BLOB_TYPE_ID_IMPL; }
0:             else if ( "DATE".equals( unqualifiedName ) ) { return StoredFormatIds.DATE_TYPE_ID_IMPL; }
0:             else if ( "TIME".equals( unqualifiedName ) ) { return StoredFormatIds.TIME_TYPE_ID_IMPL; }
0:             else if ( "TIMESTAMP".equals( unqualifiedName ) ) { return StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL; }
0:             else if ( "XML".equals( unqualifiedName ) ) { return StoredFormatIds.XML_TYPE_ID_IMPL; }
1:             else { return 0; }
1:         }
/////////////////////////////////////////////////////////////////////////
1:         switch (getTypeFormatId())
/////////////////////////////////////////////////////////////////////////
1:                     SanityManager.THROWASSERT("Unexpected formatId " + getTypeFormatId());
commit:e126f58
/////////////////////////////////////////////////////////////////////////
1:     /** Return true if this is this type id describes an ANSI UDT */
1:     public boolean isAnsiUDT() { return (schemaName != null); }
1:     
commit:bc009a8
/////////////////////////////////////////////////////////////////////////
1:      * @param unqualifiedName The unqualified name of the UDT in that schema
commit:53c606b
/////////////////////////////////////////////////////////////////////////
0:      * @param unqualifiedName The qualified name of the UDT in that schema
commit:d039ced
/////////////////////////////////////////////////////////////////////////
1:     // schema where the type lives. only for UDTs
0:     private String schemaName;
1: 
1:     // unqualified type name
1:     String unqualifiedName;
1: 
/////////////////////////////////////////////////////////////////////////
1:      * @param SQLTypeName   The unqualified SQL name of the type
1:         this.schemaName = null;
1:         this.unqualifiedName = SQLTypeName;
1:      * Constructor for an BaseTypeIdImpl which describes a UDT
1:      *
1:      * @param schemaName The schema that the UDT lives in
0:      * @param qualifiedName The qualified name of the UDT in that schema
1:      */
1: 
1:     BaseTypeIdImpl(String schemaName, String unqualifiedName )
1:     {
1:         this.schemaName = schemaName;
1:         this.unqualifiedName = unqualifiedName;
1:     }
1: 
1:     /**
1:      * Returns the SQL name of the datatype. If it is a Derby user-defined type,
1:      * dot-separated path including the package names. If it is a UDT, returns
1:      * "schemaName"."unqualifiedName".
1:         if ( schemaName == null ) { return unqualifiedName; }
0:         else { return doubleQuote( schemaName ) + '.' + doubleQuote( unqualifiedName ); }
1:     /** Get the schema name of this type. Non-null only for UDTs */
1:     public String getSchemaName() { return schemaName; }
1: 
1:     /** Get the unqualified name of this type. Except for UDTs, this is the same
1:      * value as getSQLTypeName()
1:      */
1:     public String getUnqualifiedName() { return unqualifiedName; }
1: 
/////////////////////////////////////////////////////////////////////////
1:         unqualifiedName = in.readUTF();
1: 
1:         //
1:         // If the name begins with a quote, then it is just the first part
1:         // of the type name, viz., the schema that the type lives in.
1:         // Strip the quotes from around the name and then read the
1:         // following  unqualified name.
1:         //
1:         if ( unqualifiedName.charAt( 0 ) == '"' )
1:         {
1:             schemaName = stripQuotes( unqualifiedName );
1:             unqualifiedName = in.readUTF();
1:         }
/////////////////////////////////////////////////////////////////////////
1:         if ( schemaName == null ) { out.writeUTF( unqualifiedName ); }
1:         else
1:         {
1:             //
1:             // Wrap the schema name in quotes. quotes are illegal characters in
1:             // basic SQL type names and in Java class names, so this will flag
1:             // readExternal() that this type has a 2-part name
1:             // (schemaName.unqualifiedName).
1:             //
1:             out.writeUTF( doubleQuote( schemaName ) );
1:             out.writeUTF( unqualifiedName );
1:         }
/////////////////////////////////////////////////////////////////////////
1:               schemaName = null;
1:               unqualifiedName = TypeId.BOOLEAN_NAME;
0:               JDBCTypeId = JVMInfo.JAVA_SQL_TYPES_BOOLEAN;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.INTEGER_NAME;
1:               JDBCTypeId = Types.INTEGER;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.SMALLINT_NAME;
1:               JDBCTypeId = Types.SMALLINT;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.TINYINT_NAME;
1:               JDBCTypeId = Types.TINYINT;
1:               break;
1:               schemaName = null;
0:               unqualifiedName = TypeId.LONGINT_NAME;
1:               JDBCTypeId = Types.BIGINT;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.DECIMAL_NAME;
1:               JDBCTypeId = Types.DECIMAL;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.DOUBLE_NAME;
1:               JDBCTypeId = Types.DOUBLE;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.REAL_NAME;
1:               JDBCTypeId = Types.REAL;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.REF_NAME;
1:               JDBCTypeId = Types.OTHER;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.CHAR_NAME;
1:               JDBCTypeId = Types.CHAR;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.VARCHAR_NAME;
0:               JDBCTypeId = Types.VARCHAR;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.LONGVARCHAR_NAME;
1:               JDBCTypeId = Types.LONGVARCHAR;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.CLOB_NAME;
1:               JDBCTypeId = Types.CLOB;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.BIT_NAME;
1:               JDBCTypeId = Types.BINARY;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.VARBIT_NAME;
1:               JDBCTypeId = Types.VARBINARY;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.LONGVARBIT_NAME;
1:               JDBCTypeId = Types.LONGVARBINARY;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.BLOB_NAME;
1:               JDBCTypeId = Types.BLOB;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.DATE_NAME;
1:               JDBCTypeId = Types.DATE;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.TIME_NAME;
1:               JDBCTypeId = Types.TIME;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.TIMESTAMP_NAME;
1:               JDBCTypeId = Types.TIMESTAMP;
1:               break;
1:               schemaName = null;
1:               unqualifiedName = TypeId.XML_NAME;
0:               JDBCTypeId = JDBC40Translation.SQLXML;
1:               break;
/////////////////////////////////////////////////////////////////////////
1: 
1:     // wrap a string in quotes
1:     private String doubleQuote( String raw ) { return '"' + raw + '"'; }
1: 
1:     // strip the bracketing quotes from a string
1:     private String stripQuotes( String quoted ) { return quoted.substring( 1, quoted.length() - 1 ); }
1:     
commit:4aef9b0
/////////////////////////////////////////////////////////////////////////
1:                 ": " + getSQLTypeName();
/////////////////////////////////////////////////////////////////////////
1:             return this.getSQLTypeName().equals(((BaseTypeIdImpl)that).getSQLTypeName());
/////////////////////////////////////////////////////////////////////////
1:         return this.getSQLTypeName().hashCode();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:6e2e8c0
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:                  break;
1:                break;
1:                  break;
commit:1a4ea31
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
0:                 JDBCTypeId = Types.CLOB;
/////////////////////////////////////////////////////////////////////////
0:                 JDBCTypeId = Types.BLOB;
commit:01b5961
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.reference.JDBC40Translation;
/////////////////////////////////////////////////////////////////////////
0:                 JDBCTypeId = JDBC40Translation.SQLXML;
commit:2afe578
/////////////////////////////////////////////////////////////////////////
1:     
1:     private int   formatId;
1:     /**
1:      * JDBC type - derived from the format identifier.
1:      */
1:     transient int           JDBCTypeId;
1: 
0:     private int   wrapperTypeFormatId;
/////////////////////////////////////////////////////////////////////////
1:     BaseTypeIdImpl(String SQLTypeName)
commit:08d6ce2
/////////////////////////////////////////////////////////////////////////
0:     String        SQLTypeName;
0:     int           JDBCTypeId;
0:     int           formatId;
0:     int           wrapperTypeFormatId;
/////////////////////////////////////////////////////////////////////////
commit:345de35
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.catalog.types.BaseTypeIdImpl
1: 
0:    Copyright 1998, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:4dede3b
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog.types
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.catalog.types;
1: 
1: import org.apache.derby.catalog.TypeDescriptor;
1: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
1: import org.apache.derby.iapi.services.io.Formatable;
1: import org.apache.derby.iapi.services.io.StoredFormatIds;
1: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
1: import org.apache.derby.iapi.types.TypeId;
1: 
0: import org.apache.derby.iapi.services.io.StreamStorable;
1: 
0: import org.apache.derby.iapi.services.i18n.MessageService;
1: 
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.reference.SQLState;
1: 
0: import org.apache.derby.iapi.services.info.JVMInfo;
1: 
0: import java.sql.Types;
0: import org.apache.derby.iapi.reference.JDBC20Translation; // needed for BLOB/CLOB types
1: 
0: import java.io.InputStream;
0: import java.io.ByteArrayInputStream;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import java.io.EOFException;
1: 
1: /**
1:  * This class is the base class for all type ids that are written to the
1:  * system tables.
1:  */
1: public class BaseTypeIdImpl implements Formatable
1: {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
1:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
1: 
1:     /********************************************************
1:     **
1:     **      This class implements Formatable. That means that it
1:     **      can write itself to and from a formatted stream. If
1:     **      you add more fields to this class, make sure that you
1:     **      also write/read them with the writeExternal()/readExternal()
1:     **      methods.
1:     **
1:     **      If, inbetween releases, you add more fields to this class,
1:     **      then you should bump the version number emitted by the 
1:     **      getTypeFormatId() method.
1:     **
1:     ********************************************************/
1: 
0:     protected String        SQLTypeName;
0:     protected int           JDBCTypeId;
0:     protected int           formatId;
0:     protected int           wrapperTypeFormatId;
1: 
1:     /**
1:      * niladic constructor. Needed for Formatable interface to work.
1:      *
1:      */
1: 
1:     public BaseTypeIdImpl() {}
1: 
1:     /**
1:      * 1 argument constructor. Needed for Formatable interface to work.
1:      *
1:      * @param formatId      Format id of specific type id.
1:      */
1:     public BaseTypeIdImpl(int formatId)
1:     {
1:         this.formatId = formatId;
1:         setTypeIdSpecificInstanceVariables();
1:     }
1: 
1:     /**
1:      * Constructor for an BaseTypeIdImpl
1:      *
0:      * @param SQLTypeName   The SQL name of the type
1:      */
1: 
0:     protected BaseTypeIdImpl(String SQLTypeName)
1:     {
0:         this.SQLTypeName = SQLTypeName;
1:     }
1: 
1:     /**
0:      * Returns the SQL name of the datatype. If it is a user-defined type,
1:      * it returns the full Java path name for the datatype, meaning the
0:      * dot-separated path including the package names.
1:      *
1:      * @return      A String containing the SQL name of this type.
1:      */
1:     public String   getSQLTypeName()
1:     {
0:         return SQLTypeName;
1:     }
1: 
1:     /**
1:      * Get the jdbc type id for this type.  JDBC type can be
1:      * found in java.sql.Types. 
1:      *
1:      * @return      a jdbc type, e.g. java.sql.Types.DECIMAL 
1:      *
1:      * @see Types
1:      */
1:     public int getJDBCTypeId()
1:     {
1:         return JDBCTypeId;
1:     }
1: 
0:     /** Does this type id represent a system built-in type? */
0:     public boolean systemBuiltIn()
1:     {
0:         return true;
1:     }
1: 
1:     /**
1:      * Converts this TypeId, given a data type descriptor 
1:      * (including length/precision), to a string. E.g.
1:      *
1:      *                      VARCHAR(30)
1:      *
1:      *
1:      *      For most data types, we just return the SQL type name.
1:      *
1:      *      @param  td      Data type descriptor that holds the 
1:      *                      length/precision etc. as necessary
1:      *
1:      *       @return        String version of datatype, suitable for running 
1:      *                      through the Parser.
1:      */
1:     public String   toParsableString(TypeDescriptor td)
1:     {
1:         String retval = getSQLTypeName();
1: 
0:         switch (formatId)
1:         {
1:           case StoredFormatIds.BIT_TYPE_ID_IMPL:
1:           case StoredFormatIds.VARBIT_TYPE_ID_IMPL:
1: 			  int rparen = retval.indexOf(')');
1: 			  String lead = retval.substring(0, rparen);
1: 			  retval = lead + td.getMaximumWidth() + retval.substring(rparen);
0: 			  break;
1: 
1:           case StoredFormatIds.CHAR_TYPE_ID_IMPL:
1:           case StoredFormatIds.VARCHAR_TYPE_ID_IMPL:
0:           case StoredFormatIds.NATIONAL_CHAR_TYPE_ID_IMPL:
0:           case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID_IMPL:
1:           case StoredFormatIds.BLOB_TYPE_ID_IMPL:
1:           case StoredFormatIds.CLOB_TYPE_ID_IMPL:
0:           case StoredFormatIds.NCLOB_TYPE_ID_IMPL:
1:                 retval += "(" + td.getMaximumWidth() + ")";
0:                 break;
1: 
1:           case StoredFormatIds.DECIMAL_TYPE_ID_IMPL:
1:                 retval += "(" + td.getPrecision() + "," + td.getScale() + ")";
0:                 break;
1:         }
1: 
1:         return retval;
1:     }
1: 
1:     /** Does this type id represent a user type? */
1:     public boolean userType()
1:     {
1:         return false;
1:     }
1: 
1:     /**
1:      * Format this BaseTypeIdImpl as a String
1:      *
1:      * @return      This BaseTypeIdImpl formatted as a String
1:      */
1: 
1:     public String   toString()
1:     {
1:         return MessageService.getTextMessage(SQLState.TI_SQL_TYPE_NAME) +
0:                 ": " + SQLTypeName;
1:     }
1: 
1:     /**
1:      * we want equals to say if these are the same type id or not.
1:      */
1:     public boolean equals(Object that)
1:     {
1:         if (that instanceof BaseTypeIdImpl)
1:         {
0:             return this.SQLTypeName.equals(((BaseTypeIdImpl)that).getSQLTypeName());
1:         }
1:         else
1:         {
1:             return false;
1:         }
1:     }
1: 
1:     /**
1:       Hashcode which works with equals.
1:       */
1:     public int hashCode()
1:     {
0:         return this.SQLTypeName.hashCode();
1:     }
1: 
1:     /**
0:      * Get the format id for the wrapper type id that corresponds to
0:      * this type id.
1:      */
0:     public int wrapperTypeFormatId()
1:     {
0:         return wrapperTypeFormatId;
1:     }
1: 
1: 
1:     /**
1:      * Get the formatID which corresponds to this class.
1:      *
1:      * @return      the formatID of this class
1:      */
1:     public int getTypeFormatId()
1:     {
0:         return formatId;
1:     }
1: 
1:     /**
1:      * Read this object from a stream of stored objects.
1:      *
1:      * @param in read this.
1:      *
1:      * @exception IOException                       thrown on error
1:      * @exception ClassNotFoundException            thrown on error
1:      */
1:     public void readExternal( ObjectInput in )
1:              throws IOException, ClassNotFoundException
1:     {
0:         SQLTypeName = in.readUTF();
1:     }
1: 
1:     /**
1:      * Write this object to a stream of stored objects.
1:      *
1:      * @param out write bytes here.
1:      *
1:      * @exception IOException               thrown on error
1:      */
1:     public void writeExternal( ObjectOutput out )
1:              throws IOException
1:     {
0:         out.writeUTF( SQLTypeName );
1:     }
1: 
1:     private void setTypeIdSpecificInstanceVariables()
1:     {
0:         switch (formatId)
1:         {
1:           case StoredFormatIds.BOOLEAN_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.BOOLEAN_NAME;
0:                 JDBCTypeId = JVMInfo.JAVA_SQL_TYPES_BOOLEAN;
0:                 wrapperTypeFormatId = StoredFormatIds.BOOLEAN_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.INT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.INTEGER_NAME;
0:                 JDBCTypeId = Types.INTEGER;
0:                 wrapperTypeFormatId = StoredFormatIds.INT_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.SMALLINT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.SMALLINT_NAME;
0:                 JDBCTypeId = Types.SMALLINT;
0:                 wrapperTypeFormatId = StoredFormatIds.SMALLINT_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.TINYINT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.TINYINT_NAME;
0:                 JDBCTypeId = Types.TINYINT;
0:                 wrapperTypeFormatId = StoredFormatIds.TINYINT_TYPE_ID;
0:                 break;
1: 
0:           case StoredFormatIds.LONGINT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.LONGINT_NAME;
0:                 JDBCTypeId = Types.BIGINT;
0:                 wrapperTypeFormatId = StoredFormatIds.LONGINT_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.DECIMAL_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.DECIMAL_NAME;
0:                 JDBCTypeId = Types.DECIMAL;
0:                 wrapperTypeFormatId = StoredFormatIds.DECIMAL_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.DOUBLE_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.DOUBLE_NAME;
0:                 JDBCTypeId = Types.DOUBLE;
0:                 wrapperTypeFormatId = StoredFormatIds.DOUBLE_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.REAL_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.REAL_NAME;
0:                 JDBCTypeId = Types.REAL;
0:                 wrapperTypeFormatId = StoredFormatIds.REAL_TYPE_ID;
0:                 break;
1:                 
1:           case StoredFormatIds.REF_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.REF_NAME;
0:                 JDBCTypeId = Types.OTHER;
0:                 wrapperTypeFormatId = StoredFormatIds.REF_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.CHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.CHAR_NAME;
0:                 JDBCTypeId = Types.CHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.CHAR_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.VARCHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.VARCHAR_NAME;
0:                 JDBCTypeId = Types.VARCHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.VARCHAR_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.LONGVARCHAR_NAME;
0:                 JDBCTypeId = Types.LONGVARCHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.LONGVARCHAR_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.CLOB_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.CLOB_NAME;
0:                 JDBCTypeId = JDBC20Translation.SQL_TYPES_CLOB;
0:                 wrapperTypeFormatId = StoredFormatIds.CLOB_TYPE_ID;
0:                 break;
1: 
0:           case StoredFormatIds.NATIONAL_CHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.NATIONAL_CHAR_NAME;
0:                 JDBCTypeId = Types.CHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.NATIONAL_CHAR_TYPE_ID;
0:                 break;
1: 
0:           case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.NATIONAL_VARCHAR_NAME;
0:                 JDBCTypeId = Types.VARCHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID;
0:                 break;
1: 
0:           case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.NATIONAL_LONGVARCHAR_NAME;
0:                 JDBCTypeId = Types.LONGVARCHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID;
0:                 break;
1: 
0:          case StoredFormatIds.NCLOB_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.NCLOB_NAME;
0:                 JDBCTypeId = JDBC20Translation.SQL_TYPES_CLOB;
0:                 wrapperTypeFormatId = StoredFormatIds.NCLOB_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.BIT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.BIT_NAME;
0:                 JDBCTypeId = Types.BINARY;
0:                 wrapperTypeFormatId = StoredFormatIds.BIT_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.VARBIT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.VARBIT_NAME;
0:                 JDBCTypeId = Types.VARBINARY;
0:                 wrapperTypeFormatId = StoredFormatIds.VARBIT_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.LONGVARBIT_NAME;
0:                 JDBCTypeId = Types.LONGVARBINARY;
0:                 wrapperTypeFormatId = StoredFormatIds.LONGVARBIT_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.BLOB_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.BLOB_NAME;
0:                 JDBCTypeId = JDBC20Translation.SQL_TYPES_BLOB;
0:                 wrapperTypeFormatId = StoredFormatIds.BLOB_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.DATE_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.DATE_NAME;
0:                 JDBCTypeId = Types.DATE;
0:                 wrapperTypeFormatId = StoredFormatIds.DATE_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.TIME_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.TIME_NAME;
0:                 JDBCTypeId = Types.TIME;
0:                 wrapperTypeFormatId = StoredFormatIds.TIME_TYPE_ID;
0:                 break;
1: 
1:           case StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.TIMESTAMP_NAME;
0:                 JDBCTypeId = Types.TIMESTAMP;
0:                 wrapperTypeFormatId = StoredFormatIds.TIMESTAMP_TYPE_ID;
0:                 break;
1:           default:
1:                 if (SanityManager.DEBUG)
1:                 {
0:                         SanityManager.THROWASSERT("Unexpected formatId " + formatId);
1:                 }
0:                 break;
1:         }
1:     }
1: }
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:2f36947
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:099e28f
/////////////////////////////////////////////////////////////////////////
0: 
1:           case StoredFormatIds.XML_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.XML_NAME;
0:                 // RESOLVE: There isn't a JDBC type for XML, so we
0:                 // just use our internal type.  Is it okay to do this,
0:                 // or should "JDBCTypeId" be renamed since it no longer
0:                 // just holds JDBC types?
0:                 JDBCTypeId = StoredFormatIds.XML_TYPE_ID;
0:                 wrapperTypeFormatId = StoredFormatIds.XML_TYPE_ID;
0:                 break;
0: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.catalog.types
0:    (C) Copyright IBM Corp. 1998, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.catalog.types;
0: 
0: import org.apache.derby.catalog.TypeDescriptor;
0: 
0: import org.apache.derby.iapi.services.sanity.SanityManager;
0: import org.apache.derby.iapi.services.io.Formatable;
0: import org.apache.derby.iapi.services.io.StoredFormatIds;
0: 
0: import org.apache.derby.iapi.types.DataValueDescriptor;
0: import org.apache.derby.iapi.types.TypeId;
0: 
0: import org.apache.derby.iapi.services.io.StreamStorable;
0: 
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: 
0: import org.apache.derby.iapi.services.i18n.MessageService;
0: import org.apache.derby.iapi.reference.SQLState;
0: 
0: import org.apache.derby.iapi.services.info.JVMInfo;
0: 
0: import java.sql.Types;
0: import org.apache.derby.iapi.reference.JDBC20Translation; // needed for BLOB/CLOB types
0: 
0: import java.io.InputStream;
0: import java.io.ByteArrayInputStream;
0: import java.io.ObjectOutput;
0: import java.io.ObjectInput;
0: import java.io.IOException;
0: import java.io.EOFException;
0: 
0: /**
0:  * This class is the base class for all type ids that are written to the
0:  * system tables.
0:  */
0: public class BaseTypeIdImpl implements Formatable
0: {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0:  
0:     private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1998_2004;
0: 
0:     /********************************************************
0:     **
0:     **      This class implements Formatable. That means that it
0:     **      can write itself to and from a formatted stream. If
0:     **      you add more fields to this class, make sure that you
0:     **      also write/read them with the writeExternal()/readExternal()
0:     **      methods.
0:     **
0:     **      If, inbetween releases, you add more fields to this class,
0:     **      then you should bump the version number emitted by the 
0:     **      getTypeFormatId() method.
0:     **
0:     ********************************************************/
0: 
0:     protected String        SQLTypeName;
0:     protected int           JDBCTypeId;
0:     protected int           formatId;
0:     protected int           wrapperTypeFormatId;
0: 
0:     /**
0:      * niladic constructor. Needed for Formatable interface to work.
0:      *
0:      */
0: 
0:     public BaseTypeIdImpl() {}
0: 
0:     /**
0:      * 1 argument constructor. Needed for Formatable interface to work.
0:      *
0:      * @param formatId      Format id of specific type id.
0:      */
0:     public BaseTypeIdImpl(int formatId)
0:     {
0:         this.formatId = formatId;
0:         setTypeIdSpecificInstanceVariables();
0:     }
0: 
0:     /**
0:      * Constructor for an BaseTypeIdImpl
0:      *
0:      * @param SQLTypeName   The SQL name of the type
0:      */
0: 
0:     protected BaseTypeIdImpl(String SQLTypeName)
0:     {
0:         this.SQLTypeName = SQLTypeName;
0:     }
0: 
0:     /**
0:      * Returns the SQL name of the datatype. If it is a user-defined type,
0:      * it returns the full Java path name for the datatype, meaning the
0:      * dot-separated path including the package names.
0:      *
0:      * @return      A String containing the SQL name of this type.
0:      */
0:     public String   getSQLTypeName()
0:     {
0:         return SQLTypeName;
0:     }
0: 
0:     /**
0:      * Get the jdbc type id for this type.  JDBC type can be
0:      * found in java.sql.Types. 
0:      *
0:      * @return      a jdbc type, e.g. java.sql.Types.DECIMAL 
0:      *
0:      * @see Types
0:      */
0:     public int getJDBCTypeId()
0:     {
0:         return JDBCTypeId;
0:     }
0: 
0:     /** Does this type id represent a system built-in type? */
0:     public boolean systemBuiltIn()
0:     {
0:         return true;
0:     }
0: 
0:     /**
0:      * Converts this TypeId, given a data type descriptor 
0:      * (including length/precision), to a string. E.g.
0:      *
0:      *                      VARCHAR(30)
0:      *
0:      *
0:      *      For most data types, we just return the SQL type name.
0:      *
0:      *      @param  td      Data type descriptor that holds the 
0:      *                      length/precision etc. as necessary
0:      *
0:      *       @return        String version of datatype, suitable for running 
0:      *                      through the Parser.
0:      */
0:     public String   toParsableString(TypeDescriptor td)
0:     {
0:         String retval = getSQLTypeName();
0: 
0:         switch (formatId)
0:         {
0:           case StoredFormatIds.BIT_TYPE_ID_IMPL:
0:           case StoredFormatIds.VARBIT_TYPE_ID_IMPL:
0: 			  int rparen = retval.indexOf(')');
0: 			  String lead = retval.substring(0, rparen);
0: 			  retval = lead + td.getMaximumWidth() + retval.substring(rparen);
0: 			  break;
0: 
0:           case StoredFormatIds.CHAR_TYPE_ID_IMPL:
0:           case StoredFormatIds.VARCHAR_TYPE_ID_IMPL:
0:           case StoredFormatIds.NATIONAL_CHAR_TYPE_ID_IMPL:
0:           case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID_IMPL:
0:           case StoredFormatIds.BLOB_TYPE_ID_IMPL:
0:           case StoredFormatIds.CLOB_TYPE_ID_IMPL:
0:           case StoredFormatIds.NCLOB_TYPE_ID_IMPL:
0:                 retval += "(" + td.getMaximumWidth() + ")";
0:                 break;
0: 
0:           case StoredFormatIds.DECIMAL_TYPE_ID_IMPL:
0:                 retval += "(" + td.getPrecision() + "," + td.getScale() + ")";
0:                 break;
0:         }
0: 
0:         return retval;
0:     }
0: 
0:     /** Does this type id represent a user type? */
0:     public boolean userType()
0:     {
0:         return false;
0:     }
0: 
0:     /**
0:      * Format this BaseTypeIdImpl as a String
0:      *
0:      * @return      This BaseTypeIdImpl formatted as a String
0:      */
0: 
0:     public String   toString()
0:     {
0:         return MessageService.getTextMessage(SQLState.TI_SQL_TYPE_NAME) +
0:                 ": " + SQLTypeName;
0:     }
0: 
0:     /**
0:      * we want equals to say if these are the same type id or not.
0:      */
0:     public boolean equals(Object that)
0:     {
0:         if (that instanceof BaseTypeIdImpl)
0:         {
0:             return this.SQLTypeName.equals(((BaseTypeIdImpl)that).getSQLTypeName());
0:         }
0:         else
0:         {
0:             return false;
0:         }
0:     }
0: 
0:     /**
0:       Hashcode which works with equals.
0:       */
0:     public int hashCode()
0:     {
0:         return this.SQLTypeName.hashCode();
0:     }
0: 
0:     /**
0:      * Get the format id for the wrapper type id that corresponds to
0:      * this type id.
0:      */
0:     public int wrapperTypeFormatId()
0:     {
0:         return wrapperTypeFormatId;
0:     }
0: 
0: 
0:     /**
0:      * Get the formatID which corresponds to this class.
0:      *
0:      * @return      the formatID of this class
0:      */
0:     public int getTypeFormatId()
0:     {
0:         return formatId;
0:     }
0: 
0:     /**
0:      * Read this object from a stream of stored objects.
0:      *
0:      * @param in read this.
0:      *
0:      * @exception IOException                       thrown on error
0:      * @exception ClassNotFoundException            thrown on error
0:      */
0:     public void readExternal( ObjectInput in )
0:              throws IOException, ClassNotFoundException
0:     {
0:         SQLTypeName = in.readUTF();
0:     }
0: 
0:     /**
0:      * Write this object to a stream of stored objects.
0:      *
0:      * @param out write bytes here.
0:      *
0:      * @exception IOException               thrown on error
0:      */
0:     public void writeExternal( ObjectOutput out )
0:              throws IOException
0:     {
0:         out.writeUTF( SQLTypeName );
0:     }
0: 
0:     private void setTypeIdSpecificInstanceVariables()
0:     {
0:         switch (formatId)
0:         {
0:           case StoredFormatIds.BOOLEAN_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.BOOLEAN_NAME;
0:                 JDBCTypeId = JVMInfo.JAVA_SQL_TYPES_BOOLEAN;
0:                 wrapperTypeFormatId = StoredFormatIds.BOOLEAN_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.INT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.INTEGER_NAME;
0:                 JDBCTypeId = Types.INTEGER;
0:                 wrapperTypeFormatId = StoredFormatIds.INT_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.SMALLINT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.SMALLINT_NAME;
0:                 JDBCTypeId = Types.SMALLINT;
0:                 wrapperTypeFormatId = StoredFormatIds.SMALLINT_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.TINYINT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.TINYINT_NAME;
0:                 JDBCTypeId = Types.TINYINT;
0:                 wrapperTypeFormatId = StoredFormatIds.TINYINT_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.LONGINT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.LONGINT_NAME;
0:                 JDBCTypeId = Types.BIGINT;
0:                 wrapperTypeFormatId = StoredFormatIds.LONGINT_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.DECIMAL_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.DECIMAL_NAME;
0:                 JDBCTypeId = Types.DECIMAL;
0:                 wrapperTypeFormatId = StoredFormatIds.DECIMAL_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.DOUBLE_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.DOUBLE_NAME;
0:                 JDBCTypeId = Types.DOUBLE;
0:                 wrapperTypeFormatId = StoredFormatIds.DOUBLE_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.REAL_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.REAL_NAME;
0:                 JDBCTypeId = Types.REAL;
0:                 wrapperTypeFormatId = StoredFormatIds.REAL_TYPE_ID;
0:                 break;
0:                 
0:           case StoredFormatIds.REF_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.REF_NAME;
0:                 JDBCTypeId = Types.OTHER;
0:                 wrapperTypeFormatId = StoredFormatIds.REF_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.CHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.CHAR_NAME;
0:                 JDBCTypeId = Types.CHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.CHAR_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.VARCHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.VARCHAR_NAME;
0:                 JDBCTypeId = Types.VARCHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.VARCHAR_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.LONGVARCHAR_NAME;
0:                 JDBCTypeId = Types.LONGVARCHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.LONGVARCHAR_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.CLOB_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.CLOB_NAME;
0:                 JDBCTypeId = JDBC20Translation.SQL_TYPES_CLOB;
0:                 wrapperTypeFormatId = StoredFormatIds.CLOB_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.NATIONAL_CHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.NATIONAL_CHAR_NAME;
0:                 JDBCTypeId = Types.CHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.NATIONAL_CHAR_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.NATIONAL_VARCHAR_NAME;
0:                 JDBCTypeId = Types.VARCHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.NATIONAL_VARCHAR_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.NATIONAL_LONGVARCHAR_NAME;
0:                 JDBCTypeId = Types.LONGVARCHAR;
0:                 wrapperTypeFormatId = StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID;
0:                 break;
0: 
0:          case StoredFormatIds.NCLOB_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.NCLOB_NAME;
0:                 JDBCTypeId = JDBC20Translation.SQL_TYPES_CLOB;
0:                 wrapperTypeFormatId = StoredFormatIds.NCLOB_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.BIT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.BIT_NAME;
0:                 JDBCTypeId = Types.BINARY;
0:                 wrapperTypeFormatId = StoredFormatIds.BIT_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.VARBIT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.VARBIT_NAME;
0:                 JDBCTypeId = Types.VARBINARY;
0:                 wrapperTypeFormatId = StoredFormatIds.VARBIT_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.LONGVARBIT_NAME;
0:                 JDBCTypeId = Types.LONGVARBINARY;
0:                 wrapperTypeFormatId = StoredFormatIds.LONGVARBIT_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.BLOB_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.BLOB_NAME;
0:                 JDBCTypeId = JDBC20Translation.SQL_TYPES_BLOB;
0:                 wrapperTypeFormatId = StoredFormatIds.BLOB_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.DATE_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.DATE_NAME;
0:                 JDBCTypeId = Types.DATE;
0:                 wrapperTypeFormatId = StoredFormatIds.DATE_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.TIME_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.TIME_NAME;
0:                 JDBCTypeId = Types.TIME;
0:                 wrapperTypeFormatId = StoredFormatIds.TIME_TYPE_ID;
0:                 break;
0: 
0:           case StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL:
0:                 SQLTypeName = TypeId.TIMESTAMP_NAME;
0:                 JDBCTypeId = Types.TIMESTAMP;
0:                 wrapperTypeFormatId = StoredFormatIds.TIMESTAMP_TYPE_ID;
0:                 break;
0:           default:
0:                 if (SanityManager.DEBUG)
0:                 {
0:                         SanityManager.THROWASSERT("Unexpected formatId " + formatId);
0:                 }
0:                 break;
0:         }
0:     }
0: }
============================================================================