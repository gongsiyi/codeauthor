1:67614ad: /*
6:67614ad: 
1:f68f62f:    Derby - Class org.apache.derbyTesting.functionTests.harness.Sed
1:67614ad: 
1:15651f5:    Licensed to the Apache Software Foundation (ASF) under one or more
1:15651f5:    contributor license agreements.  See the NOTICE file distributed with
1:15651f5:    this work for additional information regarding copyright ownership.
1:15651f5:    The ASF licenses this file to You under the Apache License, Version 2.0
1:15651f5:    (the "License"); you may not use this file except in compliance with
1:15651f5:    the License.  You may obtain a copy of the License at
1:67614ad: 
1:f68f62f:       http://www.apache.org/licenses/LICENSE-2.0
1:67614ad: 
1:f68f62f:    Unless required by applicable law or agreed to in writing, software
1:f68f62f:    distributed under the License is distributed on an "AS IS" BASIS,
1:f68f62f:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:f68f62f:    See the License for the specific language governing permissions and
1:f68f62f:    limitations under the License.
1:67614ad: 
2:67614ad:  */
1:67614ad: 
1:67614ad: package org.apache.derbyTesting.functionTests.harness;
1:67614ad: 
1:67614ad: /***
1:67614ad:  * Sed.java
1:67614ad:  *
1:9f0db4e:  * This is a version of "sed" in Java for the Derby Function Tests,
1:949e80b:  * written using the java.util.regex regular expression classes.
1:67614ad:  * The substitutions/deletions are based on the original kornshell tests.
1:67614ad:  *
1:67614ad:  ***/
1:67614ad: 
1:67614ad: import java.io.*;
1:67614ad: import java.util.Vector;
1:949e80b: import java.util.List;
1:67614ad: import java.util.Properties;
1:67614ad: import java.util.StringTokenizer;
1:949e80b: import java.util.regex.Pattern;
1:949e80b: import java.util.stream.Collectors;
1:5ff5941: import org.apache.derbyTesting.functionTests.util.TestUtil;
1:67614ad: 
1:67614ad: public class Sed
1:9f0db4e: {
1:27ee843: 	private	static	final	String	SQL_EXCEPTION_FILTERED_SUBSTITUTION = 
1:27ee843:         "java.sql.SQLException:";
1:67614ad: 
1:67614ad:     public Sed()
24:67614ad:     {
26:67614ad:     }
1:ccae4bc: 
1:67614ad:     public static void main(String[] args) throws Exception {
1:9f0db4e:         if (args == null || args.length != 2) {
1:9f0db4e:             System.err.println("Usage: Sed sourcefile targetfile");
1:9f0db4e:             System.exit(1);
1:9f0db4e:         }
1:9f0db4e:         File src = new File(args[0]);
1:9f0db4e:         File tgt = new File(args[1]);
1:c0b7bf9:         new Sed().exec(src,tgt,null, false, false,false);
1:67614ad:     }
1:67614ad: 
1:67614ad:     // The arguments should be the names of the input and output files
1:c0b7bf9:     public void exec
1:c0b7bf9: 		(File srcFile, File dstFile, InputStream isSed, boolean isJCC, boolean isI18N, boolean isJDBC4)
2:67614ad:         throws IOException
1:67614ad:     {
1:5ff5941:     	String hostName = TestUtil.getHostName();
1:5ff5941:     	
2:67614ad:         // Vector for storing lines to be deleted
1:3f5c48a:         Vector<String> deleteLines = new Vector<String>();
1:67614ad:         deleteLines.addElement("^ij version.*$");
1:67614ad:         deleteLines.addElement("^\\*\\*\\*\\* Test Run Started .* \\*\\*\\*\\*$");
1:67614ad:         deleteLines.addElement("^\\*\\*\\*\\* Test Run Completed .* \\*\\*\\*\\*$");
1:67614ad:         deleteLines.addElement("^ELAPSED TIME = [0-9]* milliseconds$");
1:67614ad:         deleteLines.addElement("^\\^\\?$");
1:67614ad:         //deleteLines.addElement("^\\.$"); // originally to remove lines with a dot
1:67614ad:         deleteLines.addElement("^S.*ij> $");
1:67614ad:         deleteLines.addElement("^ *$");
1:67614ad:         deleteLines.addElement("^Server StackTrace:$");
1:67614ad:         deleteLines.addElement("^\\[ *$");
1:67614ad:         deleteLines.addElement("^\\] *$");
1:67614ad:         deleteLines.addElement("^\\[$");
1:67614ad:         deleteLines.addElement("^\\]$");
1:67614ad:         deleteLines.addElement("^<not available>\\]$");
1:67614ad:         deleteLines.addElement("^(.*at .*)\\(.*:[0-9].*\\)$");
1:67614ad:         deleteLines.addElement("^(.*at .*)\\(*.java\\)$");
1:67614ad:         deleteLines.addElement("^(.*at .*)\\(Compiled Code\\)$");
1:2740973:         deleteLines.addElement("^.*at java.*\\<init\\>\\(.*\\(Compiled Code\\)\\)$");
1:67614ad:         deleteLines.addElement("^(.*at .*)\\(Interpreted Code\\)$");
1:67614ad:         deleteLines.addElement("^(.*at .*)\\(Unknown Source\\)$");
1:9fb4631:         deleteLines.addElement("^(.*at .*)\\(.*Native Method\\)$");
1:67614ad:         deleteLines.addElement("^\\tat $"); // rare case of incomplete stack trace line
1:67614ad:         deleteLines.addElement("optimizer estimated cost");
1:67614ad:         deleteLines.addElement("optimizer estimated row count");
1:67614ad:         deleteLines.addElement("Using executables built for native_threads");
1:67614ad:         deleteLines.addElement("Estimate of memory used");
1:67614ad:         deleteLines.addElement("Size of merge runs");
1:67614ad:         deleteLines.addElement("Number of merge runs");
1:67614ad:         deleteLines.addElement("Sort type");
1:67614ad:         deleteLines.addElement("Optimization started at .*$");
1:67614ad:         deleteLines.addElement("WARNING 02000: No row was found for FETCH, UPDATE or DELETE");
1:9f0db4e:         // deleteLines for stack traces from j9 jvm to match those above for other jvms
1:9f0db4e:         deleteLines.addElement("Stack trace:");	
1:67614ad:         deleteLines.addElement("^.*java/.*\\<init\\>\\(.*\\)V");
1:9f0db4e:         deleteLines.addElement("^.*org/apache/derby/.*\\(.*\\).*$");	
1:9f0db4e:         // next for j9 stack trace with jarfiles test run.
1:9f0db4e:         deleteLines.addElement("^.*java/.*\\(.*\\).*$");
1:9f0db4e:         deleteLines.addElement("^\\[.*db2jcc.jar\\] [0-9].[1-9] - .*$");	
1:9f0db4e:         deleteLines.addElement("^\\[.*db2jcc_license_c.jar\\] [1-9].[0-9] - .*$");	
1:9f0db4e:         deleteLines.addElement("^XSDB.*$");
1:67614ad: 
1:0438c35: 		// JUnit noise
1:0438c35:         deleteLines.addElement("^\\.*$");
1:0438c35:         deleteLines.addElement("^Time: [0-9].*$");
1:0438c35:         deleteLines.addElement("^OK \\(.*$");
1:67614ad: 
1:67614ad:         // Vectors for substitutions
1:3f5c48a:         Vector<String> searchStrings = new Vector<String>();
1:9f0db4e:         searchStrings.addElement("^Transaction:\\(.*\\) *\\|"); 
1:67614ad:         searchStrings.addElement("^Read [0-9]* of [0-9]* bytes$");
1:67614ad:         searchStrings.addElement("Directory .*connect.wombat.seg0");
1:b7e8951:         //DERBY-4588 - filter out specific class and object id
1:b7e8951:         searchStrings.addElement("with class loader .*,");
1:b7e8951:         
1:67614ad:         // Filter for constraint names - bug 5622 - our internal constraint names are too long. To be db2 compatible, we have reworked them.
1:9f0db4e:         StringBuffer constraintNameFilter = new StringBuffer(); 
1:67614ad:         constraintNameFilter.append("SQL[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]");
1:67614ad:         searchStrings.addElement(constraintNameFilter.toString());
1:67614ad:         // Filter for uuids
1:67614ad:         StringBuffer uuidFilter = new StringBuffer();
1:67614ad:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
1:67614ad:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
1:67614ad:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
1:67614ad:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
1:67614ad:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]");
1:67614ad:         searchStrings.addElement(uuidFilter.toString());
1:9f0db4e:         // Filter for timestamps
1:9f0db4e:         StringBuffer timestampFilter = new StringBuffer();
1:9f0db4e:         timestampFilter.append( "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] " );
1:9f0db4e:         timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
1:9f0db4e:         searchStrings.addElement( timestampFilter.toString() );
1:9f0db4e:         // 3 digit year
1:9f0db4e:         timestampFilter = new StringBuffer();
1:9f0db4e:         timestampFilter.append( "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] " );
1:9f0db4e:         timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
1:9f0db4e:         searchStrings.addElement( timestampFilter.toString() );
1:9f0db4e:         // ibm13 year
1:9f0db4e:         timestampFilter = new StringBuffer();
1:9f0db4e:         timestampFilter.append( "[0-9]-[0-9][0-9]-[0-9][0-9] " );
1:9f0db4e:         timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
1:9f0db4e:         searchStrings.addElement( timestampFilter.toString() );
1:9f0db4e:         // Filter remove transaction id's from deadlock messages
1:949e80b:         searchStrings.addElement("^  Waiting XID : \\{.*\\}");
1:9f0db4e:         searchStrings.addElement("^  Granted XID : .*$");
1:9f0db4e:         searchStrings.addElement("^The selected victim is XID : .*");
1:9f0db4e:         // Filters for build numbers
1:9f0db4e:         searchStrings.addElement("(beta - )\\(([0-9]*)\\)");
1:2ae1afe:         searchStrings.addElement("CostEstimateImpl: .*");
1:9f0db4e:         // Filter for xa tests for the numbers representing the db name (it can change)
1:9f0db4e:         searchStrings.addElement("^Transaction ([0-9])* : \\(([0-9]*)\\,([0-9a-f]*)\\,([0-9a-f]*)\\)");
1:9f0db4e:         // Filter for optimizer number for zindexesLevel1 test (due to a change in display width for the test)
1:9f0db4e:         searchStrings.addElement("^Modifying access paths using optimizer .[0-9]*");
1:9f0db4e:         searchStrings.addElement("CDWS[0-9]*");
1:9f0db4e:         searchStrings.addElement("IXWS[0-9]*");
1:9f0db4e:         // for j9, to eliminate intermittent failures due to this problem in j9:
1:9f0db4e:         searchStrings.addElement("FAILED STACK MAP");
1:9f0db4e:         if (isJCC)
1:9f0db4e:         {
1:9f0db4e:             searchStrings.addElement("[ ]*\\|");
1:9f0db4e:             searchStrings.addElement("^--*");
1:9f0db4e:         }
1:67614ad: 
1:9f0db4e:         //Filter to suppress absould paths in error message for roll forward recovery tests 
1:9f0db4e:         searchStrings.addElement("Directory.*.wombat.already.exists");
1:1c31b3a:         searchStrings.addElement("Directory.*.extinout/crwombatlog/log.*.exists");
1:67614ad: 
1:7010e1d:         // Filter for "DB2ConnectionCorrelator" text that can be printed as
1:7010e1d:         // part of some JCC error messages.
1:7010e1d:         searchStrings.addElement("  DB2ConnectionCorrelator: [0-9A-Z.]*");
1:ac3bec6: 		// Filter for SAX exception name diffs between jvms.
1:ac3bec6:         searchStrings.addElement("org.xml.sax.SAX.*$");
1:5ff5941:         // Filter out localhost, or hostName
1:5ff5941:         searchStrings.addElement(hostName);
1:67614ad: 
1:c0b7bf9: 		if ( isJDBC4 )
1:c0b7bf9: 		{
1:c0b7bf9: 			// Filters for the sql exception class names which appear in
1:c0b7bf9: 			// exception messages. These are different in JDBC3 and JDBC4.
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLDataException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLDataSetSyncException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLFeatureNotSupportedException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLIntegrityConstraintViolationException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLInvalidAuthorizationSpecException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLNonTransientConnectionException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLNonTransientException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLRuntimeException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLSyntaxErrorException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLTimeoutException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLTransactionRollbackException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLTransientConnectionException:");
1:c0b7bf9: 			searchStrings.addElement("java.sql.SQLTransientException:");
1:cc75df1: 
1:cc75df1: 			// The JDBC4 error from the driver is a little chattier
1:cc75df1: 			searchStrings.addElement("No suitable driver found for [0-9A-Za-z:]*");			
1:cc75df1: 			searchStrings.addElement("No suitable driver;[0-9A-Za-z:=]*");			
1:cc75df1: 			searchStrings.addElement("SQL Exception: No suitable driver");			
1:88a2109: 
1:88a2109: 			// Timestamp diagnostic looks a little different under jdk16
1:88a2109: 			searchStrings.addElement("\\[\\.fffffffff\\]");			
1:c0b7bf9: 		}
1:c0b7bf9: 		
1:3f5c48a:         Vector<String> subStrings = new Vector<String>();
2:67614ad:         subStrings.addElement("Transaction:(XXX)|");
1:67614ad:         subStrings.addElement("Read ... bytes");
1:67614ad:         subStrings.addElement("Directory DBLOCATION/seg0");
1:b7e8951:         subStrings.addElement("with class loader XXXX, ");
1:67614ad:         subStrings.addElement("xxxxGENERATED-IDxxxx");
1:67614ad:         subStrings.addElement("xxxxFILTERED-UUIDxxxx");
1:67614ad:         subStrings.addElement("xxxxxxFILTERED-TIMESTAMPxxxxx");
1:67614ad:         subStrings.addElement("xxxxxxFILTERED-TIMESTAMPxxxxx");
1:67614ad:         subStrings.addElement("xxxxxxFILTERED-TIMESTAMPxxxxx");
1:9f0db4e:         // remove transaction id's from deadlock messages
1:9f0db4e:         subStrings.addElement("  Waiting XID : {WWW,QQQ}");
1:9f0db4e:         subStrings.addElement("  Granted XID : {GGG.QQQ}...");
1:9f0db4e:         subStrings.addElement("The selected victim is XID : VVV");
1:9f0db4e:         // sub build numbers
1:9f0db4e:         subStrings.addElement("$1(xxXXxxFILTERED-BUILD-NUMBERxxXXxx)");
1:2ae1afe:         subStrings.addElement("CostEstimateImpl: xxXXxxFILTERED-INFORMATIONxxXXxx");
1:9f0db4e:         // sub for db name in xa tests (it can change)
1:9f0db4e:         subStrings.addElement("Transaction $1 : ($2,FILTERED,FILTERED)");
1:9f0db4e:         // sub for optimizer number for zindexesLevel1 test
1:9f0db4e:         subStrings.addElement("Modifying access paths using optimizer FILTERED_NUMBER");
1:9f0db4e:         subStrings.addElement("CDWSno");
1:9f0db4e:         subStrings.addElement("IXWSno"); 
1:9f0db4e:         // for j9, to eliminate intermittent failures due to this problem in j9:
1:9f0db4e:         subStrings.addElement("");
1:9f0db4e:         // for JCC replace multiple blanks with one blank to handle differences
1:9f0db4e:         // in display width
1:9f0db4e:         if (isJCC)
1:9f0db4e:         {
1:9f0db4e:             subStrings.addElement(" |");
1:9f0db4e:             subStrings.addElement("-----"); 
1:9f0db4e:         }
1:9f0db4e:         subStrings.addElement("Directory DBLOCATION/wombat already exists");
1:1c31b3a:         subStrings.addElement("Directory 'extinout<sp>crwombatlog<sp>log' exists");
1:9f0db4e:         // ignore the 'DB2ConnectionCorrelator' thing altogether.
1:9f0db4e:         subStrings.addElement("");
1:ac3bec6: 		// Filter for SAX exception name diffs between jvms.
1:ac3bec6:         subStrings.addElement("xxxFILTERED-SAX-EXCEPTIONxxx'.");
1:5ff5941:         // Filter out localhost, or hostName
1:5ff5941:         subStrings.addElement("xxxFILTERED_HOSTNAMExxx");
1:c0b7bf9: 
1:c0b7bf9: 		if ( isJDBC4 )
1:c0b7bf9: 		{
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:c0b7bf9: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1:cc75df1: 
1:cc75df1: 			subStrings.addElement("No suitable driver");
1:cc75df1: 			subStrings.addElement("No suitable driver");
1:cc75df1: 			subStrings.addElement("java.sql.SQLException: No suitable driver");
1:88a2109: 
1:88a2109: 			subStrings.addElement(".fffffffff");
1:c0b7bf9: 		}
1:c0b7bf9: 
1:c0b7bf9: 		doWork(srcFile, dstFile, null, deleteLines, searchStrings, subStrings, isSed, isI18N);
1:9f0db4e:         
1:9f0db4e:     } // end exec
1:67614ad: 
1:9f0db4e:     // This just does JCC changes on the output master file
1:67614ad:     public void execJCC(InputStream is, File dstFile)
1:67614ad:         throws IOException
1:67614ad:     {
1:67614ad:         // Vector for storing lines to be deleted
1:3f5c48a:         Vector<String> deleteLines = new Vector<String>();
1:67614ad: 
1:67614ad:         // Vectors for substitutions
1:3f5c48a:         Vector<String> searchStrings = new Vector<String>();
1:9f0db4e:         searchStrings.addElement("[ ]*\\|");
1:9f0db4e:         searchStrings.addElement("^--*");
1:67614ad: 
1:3f5c48a:         Vector<String> subStrings = new Vector<String>();
1:9f0db4e:         // true and false show up as 1 and 0 in JCC. 
1:9f0db4e:         //because they have no boolean support
1:9f0db4e:         subStrings.addElement(" |");
1:9f0db4e:         subStrings.addElement("-----");
1:67614ad: 
1:9f0db4e:         doWork(null, dstFile, is, deleteLines, searchStrings, subStrings, null);
1:9f0db4e: 
1:9f0db4e:     }
1:67614ad: 
1:3f5c48a:     private void doWork(File srcFile, File dstFile, InputStream is,
1:3f5c48a:         Vector<String> deleteLines,  Vector<String> searchStrings,
1:3f5c48a:         Vector<String> subStrings, InputStream isSed)
1:67614ad:         throws IOException
1:67614ad:     {
1:9f0db4e:         doWork(srcFile, dstFile, is, deleteLines, searchStrings, subStrings, isSed, false);
1:9f0db4e:     }
1:ccae4bc: 		
1:ccae4bc: 
1:3f5c48a:     private void doWork(File srcFile, File dstFile, InputStream is,
1:3f5c48a:         Vector<String> deleteLines, Vector<String> searchStrings,
1:3f5c48a:         Vector<String> subStrings, InputStream isSed, boolean isI18N)
1:ccae4bc:         throws IOException
1:9f0db4e:     {
1:67614ad:         BufferedReader inFile;
1:67614ad:         PrintWriter outFile;
1:67614ad: 
1:9f0db4e:         // ---------------------------------
1:67614ad:         // Try loading the sed properties if they exist (see jdbc_sed.properties as an example)
1:67614ad:         if ( isSed != null )
1:ccae4bc:         {
1:9f0db4e:             Properties sedp = new Properties();
1:9f0db4e: 
1:67614ad:             sedp.load(isSed);
1:949e80b:             for (String key : sedp.stringPropertyNames())
1:9f0db4e:             {
1:9f0db4e:                 if (key.equals("substitute"))
1:9f0db4e:                 {
1:9f0db4e:                     String value = sedp.getProperty(key);
1:9f0db4e:                     // value string contains a comma separated list of patterns
1:9f0db4e:                     StringTokenizer st = new StringTokenizer(value,",");
1:9f0db4e:                     String patternName = ""; 
1:9f0db4e:                     String patName = ""; 
1:9f0db4e:                     String subName = ""; 
1:9f0db4e:                     while (st.hasMoreTokens())
1:9f0db4e:                     {
1:9f0db4e:                         patternName = st.nextToken();
1:9f0db4e:                         // pattern;substitute
1:9f0db4e:                         StringTokenizer st2 = new StringTokenizer(patternName,";");
1:9f0db4e:                         patName = st2.nextToken();
1:9f0db4e:                         subName = st2.nextToken();
1:9f0db4e:                         if (!patName.equals("") && !subName.equals(""))
1:9f0db4e:                         {
1:9f0db4e:                             searchStrings.addElement(patName);
1:9f0db4e:                             subStrings.addElement(subName);
1:9f0db4e:                         }
1:9f0db4e:                     //System.out.println("pattern = " + patName + " substitute " + subName);
1:9f0db4e:                     }
1:ccae4bc:                 }
1:9f0db4e:                 else if (key.equals("delete"))
1:9f0db4e:                 {
1:9f0db4e:                     String value = sedp.getProperty(key);
1:9f0db4e:                     // value string contains a comma separated list of patterns
1:9f0db4e:                     StringTokenizer st = new StringTokenizer(value,",");
1:9f0db4e:                     String patternName = ""; 
1:9f0db4e:                     while (st.hasMoreTokens())
1:9f0db4e:                     {
1:9f0db4e:                         patternName = st.nextToken();
1:9f0db4e:                         deleteLines.addElement(patternName);
1:9f0db4e:                     }
1:9f0db4e:                 }
1:9f0db4e:             }
1:67614ad:         }
1:9f0db4e:         // ---------------------------------
1:67614ad: 
1:67614ad:         // Define the input and output files based on args
1:958e256:         if (is == null && isI18N) {
1:958e256:             // read UTF-8 encoded file
1:958e256:             InputStream fs = new FileInputStream(srcFile);
1:958e256:             inFile = new BufferedReader(new InputStreamReader(fs, "UTF-8"));
1:958e256:         } else if (is == null) {
1:958e256:             // read the file using the default encoding
1:9f0db4e:             inFile = new BufferedReader(new FileReader(srcFile));
1:958e256:         } else {
1:1edcdb3:             inFile = new BufferedReader(new InputStreamReader(is, "UTF-8"));
1:958e256:         }
1:67614ad:         outFile = new PrintWriter
1:9f0db4e:         ( new BufferedWriter(new FileWriter(dstFile), 10000), true );
1:67614ad: 
1:67614ad:         // Attempt to compile the patterns for deletes
1:949e80b:         List<Pattern> deletePatterns = deleteLines.stream()
1:949e80b:                 .map(Pattern::compile).collect(Collectors.toList());
1:67614ad: 
1:67614ad:         // Attempt to compile the patterns for substitutes
1:949e80b:         List<Pattern> substitutePatterns = searchStrings.stream()
1:949e80b:                 .map(Pattern::compile).collect(Collectors.toList());
1:67614ad: 
1:67614ad:         String str;
1:67614ad:         int j;
1:67614ad:         int lineCount = 0;
1:67614ad:         // Read the input file
1:67614ad:         while ( (str = inFile.readLine()) != null )
1:67614ad:         {
1:67614ad:             lineCount++;
1:9f0db4e:         
1:67614ad:             //System.out.println("***Line no: " + lineCount);
1:67614ad:             //System.out.println("***Line is: " + str);
1:949e80b:             boolean lineDeleted = false;
1:67614ad: 
1:67614ad:             // First delete any nulls (Cafe 1.8 leaves nulls)
1:67614ad:             if (str.length() == 1)
1:67614ad:             {
1:67614ad:                 if (str.charAt(0) == (char) 0)
1:67614ad:                 {
1:67614ad:                     // Skip this line, don't write it
1:67614ad:                     //System.out.println("Skip this line...");
2:67614ad:                     lineDeleted = true;
1:9f0db4e:                 }
1:67614ad:             }
1:67614ad: 
1:ccae4bc:             // Now determine if & if so, replace, any non-ascii characters
1:ccae4bc:             // We do this because non-ascii characters in .sql files will
1:ccae4bc:             // result in different characters depending on encoding, and
1:ccae4bc:             // encoding may be different on different os's
1:ccae4bc:             if (isI18N)
1:ccae4bc:             {
1:ccae4bc:                 boolean hasNonAscii = false;
1:ccae4bc:                 // check for any characters in the control range
1:ccae4bc:                 for (int si = 0; si < str.length(); si++)
1:ccae4bc:                 {
1:ccae4bc:                     char c = str.charAt(si);
1:ccae4bc:                     if (c < (char) 0x20 || c >= (char) 0x7f)
1:ccae4bc:                     {
1:ccae4bc:                         hasNonAscii = true;
1:ccae4bc:                         break;
1:ccae4bc:                     }
1:ccae4bc:                 }
1:ccae4bc: 
1:ccae4bc:                 if (hasNonAscii)
1:ccae4bc:                 {
1:ccae4bc:                     StringBuffer sb = new StringBuffer();
1:ccae4bc:                     for (int si = 0; si < str.length(); si++)
1:ccae4bc:                     {
1:ccae4bc:                         char c = str.charAt(si);
1:ccae4bc:                         if (c < (char) 0x20 || c >= (char) 0x7f)
1:ccae4bc:                         {
1:ccae4bc:                             sb.append(' ');
1:ccae4bc:                             // Encoded Character:> ... <
1:ccae4bc:                             sb.append("EnC:>");
1:ccae4bc:                             sb.append((int) str.charAt(si));
1:ccae4bc:                             sb.append("< ");
1:ccae4bc:                         }
1:9f0db4e:                         else
1:ccae4bc:                             sb.append(c);
1:ccae4bc:                     }
1:ccae4bc:                     str = sb.toString();
1:ccae4bc:                 }
1:ccae4bc:             }
1:ccae4bc: 
1:67614ad:             // Determine if this line should be deleted for delete pattern match
1:67614ad:             if ( lineDeleted == false )
1:67614ad:             {
1:949e80b:                 final String s = str;
1:949e80b:                 lineDeleted =
1:949e80b:                     deletePatterns.stream().anyMatch(p -> p.matcher(s).find());
1:67614ad:             }
1:ccae4bc: 
1:67614ad:             // Determine if any substitutions are needed
1:67614ad:             if (lineDeleted == false)
1:67614ad:             {
1:949e80b:                 for (j = 0; j < substitutePatterns.size(); j++)
1:67614ad:                 {
1:949e80b:                     Pattern patt = substitutePatterns.get(j);
1:949e80b:                     //System.out.println("Pattern string is " + patt);
1:949e80b:                     String sub = subStrings.get(j);
1:67614ad:                     //System.out.println("Substitute str = " + sub);
1:949e80b:                     str = patt.matcher(str).replaceAll(sub);
1:67614ad:                 }
1:949e80b:                 //System.out.println("Write the str: " + str);
1:949e80b:                 outFile.println(str);
1:67614ad:             }// end if
1:67614ad:         } // end while
1:67614ad:         inFile.close();
2:67614ad:         outFile.flush();
1:67614ad:         outFile.close();
1:9f0db4e:     }// end doWork
1:67614ad: }
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:9fb4631
/////////////////////////////////////////////////////////////////////////
1:         deleteLines.addElement("^(.*at .*)\\(.*Native Method\\)$");
commit:949e80b
/////////////////////////////////////////////////////////////////////////
1:  * written using the java.util.regex regular expression classes.
1: import java.util.List;
1: import java.util.regex.Pattern;
1: import java.util.stream.Collectors;
/////////////////////////////////////////////////////////////////////////
1:         searchStrings.addElement("^  Waiting XID : \\{.*\\}");
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:             for (String key : sedp.stringPropertyNames())
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         List<Pattern> deletePatterns = deleteLines.stream()
1:                 .map(Pattern::compile).collect(Collectors.toList());
1:         List<Pattern> substitutePatterns = searchStrings.stream()
1:                 .map(Pattern::compile).collect(Collectors.toList());
/////////////////////////////////////////////////////////////////////////
1:             boolean lineDeleted = false;
/////////////////////////////////////////////////////////////////////////
1:                 final String s = str;
1:                 lineDeleted =
1:                     deletePatterns.stream().anyMatch(p -> p.matcher(s).find());
1:                 for (j = 0; j < substitutePatterns.size(); j++)
1:                     Pattern patt = substitutePatterns.get(j);
1:                     //System.out.println("Pattern string is " + patt);
1:                     String sub = subStrings.get(j);
1:                     str = patt.matcher(str).replaceAll(sub);
1:                 //System.out.println("Write the str: " + str);
1:                 outFile.println(str);
commit:3f5c48a
/////////////////////////////////////////////////////////////////////////
1:         Vector<String> deleteLines = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1:         Vector<String> searchStrings = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1:         Vector<String> subStrings = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1:         Vector<String> deleteLines = new Vector<String>();
1:         Vector<String> searchStrings = new Vector<String>();
1:         Vector<String> subStrings = new Vector<String>();
/////////////////////////////////////////////////////////////////////////
1:     private void doWork(File srcFile, File dstFile, InputStream is,
1:         Vector<String> deleteLines,  Vector<String> searchStrings,
1:         Vector<String> subStrings, InputStream isSed)
1:     private void doWork(File srcFile, File dstFile, InputStream is,
1:         Vector<String> deleteLines, Vector<String> searchStrings,
1:         Vector<String> subStrings, InputStream isSed, boolean isI18N)
/////////////////////////////////////////////////////////////////////////
0:         Vector<Pattern> delPatternVector = new Vector<Pattern>();
0:         Vector<Pattern> subPatternVector = new Vector<Pattern>();
commit:958e256
/////////////////////////////////////////////////////////////////////////
1:         if (is == null && isI18N) {
1:             // read UTF-8 encoded file
1:             InputStream fs = new FileInputStream(srcFile);
1:             inFile = new BufferedReader(new InputStreamReader(fs, "UTF-8"));
1:         } else if (is == null) {
1:             // read the file using the default encoding
1:         } else {
1:         }
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:2ae1afe
/////////////////////////////////////////////////////////////////////////
1:         searchStrings.addElement("CostEstimateImpl: .*");
/////////////////////////////////////////////////////////////////////////
1:         subStrings.addElement("CostEstimateImpl: xxXXxxFILTERED-INFORMATIONxxXXxx");
commit:88a2109
/////////////////////////////////////////////////////////////////////////
1: 
1: 			// Timestamp diagnostic looks a little different under jdk16
1: 			searchStrings.addElement("\\[\\.fffffffff\\]");			
/////////////////////////////////////////////////////////////////////////
1: 
1: 			subStrings.addElement(".fffffffff");
commit:cc75df1
/////////////////////////////////////////////////////////////////////////
1: 
1: 			// The JDBC4 error from the driver is a little chattier
1: 			searchStrings.addElement("No suitable driver found for [0-9A-Za-z:]*");			
1: 			searchStrings.addElement("No suitable driver;[0-9A-Za-z:=]*");			
1: 			searchStrings.addElement("SQL Exception: No suitable driver");			
/////////////////////////////////////////////////////////////////////////
1: 
1: 			subStrings.addElement("No suitable driver");
1: 			subStrings.addElement("No suitable driver");
1: 			subStrings.addElement("java.sql.SQLException: No suitable driver");
commit:c0b7bf9
/////////////////////////////////////////////////////////////////////////
0: 	private	static	final	String	SQL_EXCEPTION_FILTERED_SUBSTITUTION = "SQL Exception:";
/////////////////////////////////////////////////////////////////////////
1:         new Sed().exec(src,tgt,null, false, false,false);
1:     public void exec
1: 		(File srcFile, File dstFile, InputStream isSed, boolean isJCC, boolean isI18N, boolean isJDBC4)
/////////////////////////////////////////////////////////////////////////
1: 		if ( isJDBC4 )
1: 		{
1: 			// Filters for the sql exception class names which appear in
1: 			// exception messages. These are different in JDBC3 and JDBC4.
1: 			searchStrings.addElement("java.sql.SQLDataException:");
1: 			searchStrings.addElement("java.sql.SQLDataSetSyncException:");
1: 			searchStrings.addElement("java.sql.SQLException:");
1: 			searchStrings.addElement("java.sql.SQLFeatureNotSupportedException:");
1: 			searchStrings.addElement("java.sql.SQLIntegrityConstraintViolationException:");
1: 			searchStrings.addElement("java.sql.SQLInvalidAuthorizationSpecException:");
1: 			searchStrings.addElement("java.sql.SQLNonTransientConnectionException:");
1: 			searchStrings.addElement("java.sql.SQLNonTransientException:");
1: 			searchStrings.addElement("java.sql.SQLRuntimeException:");
1: 			searchStrings.addElement("java.sql.SQLSyntaxErrorException:");
1: 			searchStrings.addElement("java.sql.SQLTimeoutException:");
1: 			searchStrings.addElement("java.sql.SQLTransactionRollbackException:");
1: 			searchStrings.addElement("java.sql.SQLTransientConnectionException:");
1: 			searchStrings.addElement("java.sql.SQLTransientException:");
1: 		}
1: 		
/////////////////////////////////////////////////////////////////////////
1: 
1: 		if ( isJDBC4 )
1: 		{
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 			subStrings.addElement(SQL_EXCEPTION_FILTERED_SUBSTITUTION);
1: 		}
1: 
1: 		doWork(srcFile, dstFile, null, deleteLines, searchStrings, subStrings, isSed, isI18N);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2740973
/////////////////////////////////////////////////////////////////////////
1:         deleteLines.addElement("^.*at java.*\\<init\\>\\(.*\\(Compiled Code\\)\\)$");
author:Katherine Marsden
-------------------------------------------------------------------------------
commit:b7e8951
/////////////////////////////////////////////////////////////////////////
1:         //DERBY-4588 - filter out specific class and object id
1:         searchStrings.addElement("with class loader .*,");
1:         
/////////////////////////////////////////////////////////////////////////
1:         subStrings.addElement("with class loader XXXX, ");
commit:4383496
/////////////////////////////////////////////////////////////////////////
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:15651f5
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:1edcdb3
/////////////////////////////////////////////////////////////////////////
1:             inFile = new BufferedReader(new InputStreamReader(is, "UTF-8"));
commit:5ff5941
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.functionTests.util.TestUtil;
/////////////////////////////////////////////////////////////////////////
1:     	String hostName = TestUtil.getHostName();
1:     	
/////////////////////////////////////////////////////////////////////////
1:         // Filter out localhost, or hostName
1:         searchStrings.addElement(hostName);
/////////////////////////////////////////////////////////////////////////
1:         // Filter out localhost, or hostName
1:         subStrings.addElement("xxxFILTERED_HOSTNAMExxx");
commit:ac3bec6
/////////////////////////////////////////////////////////////////////////
1: 		// Filter for SAX exception name diffs between jvms.
1:         searchStrings.addElement("org.xml.sax.SAX.*$");
/////////////////////////////////////////////////////////////////////////
1: 		// Filter for SAX exception name diffs between jvms.
1:         subStrings.addElement("xxxFILTERED-SAX-EXCEPTIONxxx'.");
commit:bfbf650
/////////////////////////////////////////////////////////////////////////
commit:9f0db4e
/////////////////////////////////////////////////////////////////////////
1:  * This is a version of "sed" in Java for the Derby Function Tests,
/////////////////////////////////////////////////////////////////////////
1:         if (args == null || args.length != 2) {
1:             System.err.println("Usage: Sed sourcefile targetfile");
1:             System.exit(1);
1:         }
1:         File src = new File(args[0]);
1:         File tgt = new File(args[1]);
0:         new Sed().exec(src,tgt,null, false, false);
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         // deleteLines for stack traces from j9 jvm to match those above for other jvms
1:         deleteLines.addElement("Stack trace:");	
1:         deleteLines.addElement("^.*org/apache/derby/.*\\(.*\\).*$");	
1:         // next for j9 stack trace with jarfiles test run.
0:         deleteLines.addElement("^.*derby/.*\\<.*\\>\\(.*\\).*$");	
0:         deleteLines.addElement("^.*derby/.*\\(.*\\).*$");	
1:         deleteLines.addElement("^.*java/.*\\(.*\\).*$");
1:         deleteLines.addElement("^\\[.*db2jcc.jar\\] [0-9].[1-9] - .*$");	
1:         deleteLines.addElement("^\\[.*db2jcc_license_c.jar\\] [1-9].[0-9] - .*$");	
1:         deleteLines.addElement("^XSDB.*$");
1:         searchStrings.addElement("^Transaction:\\(.*\\) *\\|"); 
1:         StringBuffer constraintNameFilter = new StringBuffer(); 
/////////////////////////////////////////////////////////////////////////
1:         // Filter for timestamps
1:         StringBuffer timestampFilter = new StringBuffer();
1:         timestampFilter.append( "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] " );
1:         timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
1:         searchStrings.addElement( timestampFilter.toString() );
1:         // 3 digit year
1:         timestampFilter = new StringBuffer();
1:         timestampFilter.append( "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] " );
1:         timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
1:         searchStrings.addElement( timestampFilter.toString() );
1:         // ibm13 year
1:         timestampFilter = new StringBuffer();
1:         timestampFilter.append( "[0-9]-[0-9][0-9]-[0-9][0-9] " );
1:         timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
1:         searchStrings.addElement( timestampFilter.toString() );
1:         // Filter remove transaction id's from deadlock messages
0:         searchStrings.addElement("^  Waiting XID : {.*}");
1:         searchStrings.addElement("^  Granted XID : .*$");
1:         searchStrings.addElement("^The selected victim is XID : .*");
1:         // Filters for build numbers
1:         searchStrings.addElement("(beta - )\\(([0-9]*)\\)");
0:         searchStrings.addElement("Level2CostEstimateImpl: .*");
1:         // Filter for xa tests for the numbers representing the db name (it can change)
1:         searchStrings.addElement("^Transaction ([0-9])* : \\(([0-9]*)\\,([0-9a-f]*)\\,([0-9a-f]*)\\)");
1:         // Filter for optimizer number for zindexesLevel1 test (due to a change in display width for the test)
1:         searchStrings.addElement("^Modifying access paths using optimizer .[0-9]*");
1:         searchStrings.addElement("CDWS[0-9]*");
1:         searchStrings.addElement("IXWS[0-9]*");
1:         // for j9, to eliminate intermittent failures due to this problem in j9:
1:         searchStrings.addElement("FAILED STACK MAP");
1:         if (isJCC)
1:         {
1:             searchStrings.addElement("[ ]*\\|");
1:             searchStrings.addElement("^--*");
1:         }
1:         //Filter to suppress absould paths in error message for roll forward recovery tests 
1:         searchStrings.addElement("Directory.*.wombat.already.exists");
1:         // remove transaction id's from deadlock messages
1:         subStrings.addElement("  Waiting XID : {WWW,QQQ}");
1:         subStrings.addElement("  Granted XID : {GGG.QQQ}...");
1:         subStrings.addElement("The selected victim is XID : VVV");
1:         // sub build numbers
1:         subStrings.addElement("$1(xxXXxxFILTERED-BUILD-NUMBERxxXXxx)");
0:         subStrings.addElement("Level2CostEstimateImpl: xxXXxxFILTERED-INFORMATIONxxXXxx");
1:         // sub for db name in xa tests (it can change)
1:         subStrings.addElement("Transaction $1 : ($2,FILTERED,FILTERED)");
1:         // sub for optimizer number for zindexesLevel1 test
1:         subStrings.addElement("Modifying access paths using optimizer FILTERED_NUMBER");
1:         subStrings.addElement("CDWSno");
1:         subStrings.addElement("IXWSno"); 
1:         // for j9, to eliminate intermittent failures due to this problem in j9:
1:         subStrings.addElement("");
1:         // for JCC replace multiple blanks with one blank to handle differences
1:         // in display width
1:         if (isJCC)
1:         {
1:             subStrings.addElement(" |");
1:             subStrings.addElement("-----"); 
1:         }
1:         subStrings.addElement("Directory DBLOCATION/wombat already exists");
1:         // ignore the 'DB2ConnectionCorrelator' thing altogether.
1:         subStrings.addElement("");
0:         doWork(srcFile, dstFile, null, deleteLines, searchStrings, subStrings, isSed, isI18N);
1:         
1:     } // end exec
1:     // This just does JCC changes on the output master file
/////////////////////////////////////////////////////////////////////////
1:         searchStrings.addElement("[ ]*\\|");
1:         searchStrings.addElement("^--*");
1:         // true and false show up as 1 and 0 in JCC. 
1:         //because they have no boolean support
1:         subStrings.addElement(" |");
1:         subStrings.addElement("-----");
1:         doWork(null, dstFile, is, deleteLines, searchStrings, subStrings, null);
1:     }
1: 
0:     private void doWork(File srcFile, File dstFile, InputStream is, Vector deleteLines, 
0:         Vector searchStrings, Vector subStrings, InputStream isSed)
1:         doWork(srcFile, dstFile, is, deleteLines, searchStrings, subStrings, isSed, false);
1:     }
0:     private void doWork(File srcFile, File dstFile, InputStream is, Vector deleteLines, 
0:         Vector searchStrings, Vector subStrings, InputStream isSed, boolean isI18N)
1:     {
/////////////////////////////////////////////////////////////////////////
1:         // ---------------------------------
1:             Properties sedp = new Properties();
1: 
0:             for (Enumeration e = sedp.propertyNames(); e.hasMoreElements(); )
1:             {
0:                 String key = (String)e.nextElement();
1:                 if (key.equals("substitute"))
1:                 {
1:                     String value = sedp.getProperty(key);
1:                     // value string contains a comma separated list of patterns
1:                     StringTokenizer st = new StringTokenizer(value,",");
1:                     String patternName = ""; 
1:                     String patName = ""; 
1:                     String subName = ""; 
1:                     while (st.hasMoreTokens())
1:                     {
1:                         patternName = st.nextToken();
1:                         // pattern;substitute
1:                         StringTokenizer st2 = new StringTokenizer(patternName,";");
1:                         patName = st2.nextToken();
1:                         subName = st2.nextToken();
1:                         if (!patName.equals("") && !subName.equals(""))
1:                         {
1:                             searchStrings.addElement(patName);
1:                             subStrings.addElement(subName);
1:                         }
1:                     //System.out.println("pattern = " + patName + " substitute " + subName);
1:                     }
1:                 else if (key.equals("delete"))
1:                 {
1:                     String value = sedp.getProperty(key);
1:                     // value string contains a comma separated list of patterns
1:                     StringTokenizer st = new StringTokenizer(value,",");
1:                     String patternName = ""; 
1:                     while (st.hasMoreTokens())
1:                     {
1:                         patternName = st.nextToken();
1:                         deleteLines.addElement(patternName);
1:                     }
1:                 }
1:             }
1:         // ---------------------------------
0:         if (is == null)
1:             inFile = new BufferedReader(new FileReader(srcFile));
1:         else
0:             inFile = new BufferedReader(new InputStreamReader(is));
1:         ( new BufferedWriter(new FileWriter(dstFile), 10000), true );
/////////////////////////////////////////////////////////////////////////
1:         
/////////////////////////////////////////////////////////////////////////
0:                         else
/////////////////////////////////////////////////////////////////////////
0:                 Substitution substitution;
0:                 StringSubstitution strsub = new StringSubstitution("");
0:                 Perl5Substitution perlsub = new Perl5Substitution("");
/////////////////////////////////////////////////////////////////////////
0:                     if (sub.indexOf("$") > 0)
1:                     {
0:                         substitution = (Substitution)strsub;
1:                     }
/////////////////////////////////////////////////////////////////////////
0:                         Util.SUBSTITUTE_ALL);
/////////////////////////////////////////////////////////////////////////
1:     }// end doWork
commit:ccae4bc
/////////////////////////////////////////////////////////////////////////
0: 	new Sed().exec(src,tgt,null, false, false);
0:     public void exec(File srcFile, File dstFile, InputStream isSed, boolean isJCC, boolean isI18N)
/////////////////////////////////////////////////////////////////////////
0: 		doWork(srcFile, dstFile, null, deleteLines, searchStrings, subStrings, isSed, isI18N);
/////////////////////////////////////////////////////////////////////////
0: 		doWork(srcFile, dstFile, is, deleteLines, searchStrings, subStrings, isSed, false);
1: 	}
1: 		
1: 
0: 	private void doWork(File srcFile, File dstFile, InputStream is, Vector deleteLines, 
0: 		Vector searchStrings, Vector subStrings, InputStream isSed, boolean isI18N)
1:         throws IOException
1: 	{
/////////////////////////////////////////////////////////////////////////
1:             // Now determine if & if so, replace, any non-ascii characters
1:             // We do this because non-ascii characters in .sql files will
1:             // result in different characters depending on encoding, and
1:             // encoding may be different on different os's
1:             if (isI18N)
1:             {
1:                 boolean hasNonAscii = false;
1:                 // check for any characters in the control range
1:                 for (int si = 0; si < str.length(); si++)
1:                 {
1:                     char c = str.charAt(si);
1:                     if (c < (char) 0x20 || c >= (char) 0x7f)
1:                     {
1:                         hasNonAscii = true;
1:                         break;
1:                     }
1:                 }
1: 
1:                 if (hasNonAscii)
1:                 {
1:                     StringBuffer sb = new StringBuffer();
1:                     for (int si = 0; si < str.length(); si++)
1:                     {
1:                         char c = str.charAt(si);
1:                         if (c < (char) 0x20 || c >= (char) 0x7f)
1:                         {
1:                             sb.append(' ');
1:                             // Encoded Character:> ... <
1:                             sb.append("EnC:>");
1:                             sb.append((int) str.charAt(si));
1:                             sb.append("< ");
1:                         }
0: 			else
1:                             sb.append(c);
1:                     }
1:                     str = sb.toString();
1:                 }
1:             }
1: 
1: 
1: 
commit:67614ad
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derbyTesting.functionTests.harness
0:    (C) Copyright IBM Corp. 1999, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derbyTesting.functionTests.harness;
1: 
1: /***
1:  * Sed.java
1:  *
0:  * This is a version of "sed" in Java for the Cloudscape Function Tests,
0:  * written using the OROMatcher Perl5 regular expression classes.
1:  * The substitutions/deletions are based on the original kornshell tests.
1:  *
1:  ***/
1: 
1: import java.io.*;
1: import java.util.Vector;
0: import org.apache.oro.text.regex.*;
0: import java.util.Enumeration;
1: import java.util.Properties;
1: import java.util.StringTokenizer;
1: 
1: public class Sed
1: { 
0: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	private static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1999_2004;
1: 
1:     public Sed()
1:     {
1:     }
1: 
1:     public static void main(String[] args) throws Exception {
0: 	if (args == null || args.length != 2) {
0: 		System.err.println("Usage: Sed sourcefile targetfile");
0: 		System.exit(1);
1: 	}
0: 	File src = new File(args[0]);
0: 	File tgt = new File(args[1]);
0: 	new Sed().exec(src,tgt,null, false);
1:     }
1: 
1:     // The arguments should be the names of the input and output files
0:     public void exec(File srcFile, File dstFile, InputStream isSed, boolean isJCC)
1:         throws IOException
1:     {
1:         // Vector for storing lines to be deleted
0:         Vector deleteLines = new Vector();
1:         deleteLines.addElement("^ij version.*$");
1:         deleteLines.addElement("^\\*\\*\\*\\* Test Run Started .* \\*\\*\\*\\*$");
1:         deleteLines.addElement("^\\*\\*\\*\\* Test Run Completed .* \\*\\*\\*\\*$");
1:         deleteLines.addElement("^ELAPSED TIME = [0-9]* milliseconds$");
0:         deleteLines.addElement("^Symantec Java! JustInTime Compiler Version .*$");
0:         deleteLines.addElement("^Copyright .* Symantec .*$");
1:         deleteLines.addElement("^\\^\\?$");
1:         //deleteLines.addElement("^\\.$"); // originally to remove lines with a dot
1:         deleteLines.addElement("^S.*ij> $");
1:         deleteLines.addElement("^ *$");
1:         deleteLines.addElement("^Server StackTrace:$");
1:         deleteLines.addElement("^\\[ *$");
1:         deleteLines.addElement("^\\] *$");
1:         deleteLines.addElement("^\\[$");
1:         deleteLines.addElement("^\\]$");
1:         deleteLines.addElement("^<not available>\\]$");
0:         deleteLines.addElement("^weblogic\\..*$");
1:         deleteLines.addElement("^(.*at .*)\\(.*:[0-9].*\\)$");
1:         deleteLines.addElement("^(.*at .*)\\(*.java\\)$");
1:         deleteLines.addElement("^(.*at .*)\\(Compiled Code\\)$");
1:         deleteLines.addElement("^(.*at .*)\\(Interpreted Code\\)$");
1:         deleteLines.addElement("^(.*at .*)\\(Unknown Source\\)$");
0:         deleteLines.addElement("^(.*at .*)\\(Native Method\\)$");
0:         deleteLines.addElement("^.*at weblogic\\..*$");
1:         deleteLines.addElement("^\\tat $"); // rare case of incomplete stack trace line
0:         deleteLines.addElement("JBMSTours\\.vti\\.jdbc1_2\\.ExternalTable"); // For some reason ArchiveData.out outputs it's errors in random order, sed them both out.
1:         deleteLines.addElement("optimizer estimated cost");
1:         deleteLines.addElement("optimizer estimated row count");
0:         deleteLines.addElement("^WARNING: Cloudscape \\(instance.*$");
0:         deleteLines.addElement("^Warning: Cloudscape \\(instance.*$");
1:         deleteLines.addElement("Using executables built for native_threads");
1:         deleteLines.addElement("Estimate of memory used");
1:         deleteLines.addElement("Size of merge runs");
1:         deleteLines.addElement("Number of merge runs");
1:         deleteLines.addElement("Sort type");
1:         deleteLines.addElement("Optimization started at .*$");
1:         deleteLines.addElement("WARNING 02000: No row was found for FETCH, UPDATE or DELETE");
0: 	// deleteLines for stack traces from j9 jvm to match those above for other jvms
0:  	deleteLines.addElement("Stack trace:");	
1:         deleteLines.addElement("^.*java/.*\\<init\\>\\(.*\\)V");
0:  	deleteLines.addElement("^.*org/apache/derby/.*\\(.*\\).*$");	
0: 	// next for j9 stack trace with jarfiles test run.
0:  	deleteLines.addElement("^.*derby/.*\\<.*\\>\\(.*\\).*$");	
0:  	deleteLines.addElement("^.*derby/.*\\(.*\\).*$");	
0:  	deleteLines.addElement("^.*java/.*\\(.*\\).*$");
0: 	deleteLines.addElement("^\\[.*db2jcc.jar\\] [0-9].[1-9] - .*$");	
0: 	deleteLines.addElement("^\\[.*db2jcc_license_c.jar\\] [1-9].[0-9] - .*$");	
1: 
1:         // Vectors for substitutions
0:         Vector searchStrings = new Vector();
0:         searchStrings.addElement("^WARNING: JBMS \\(instance *");
0:         searchStrings.addElement("^Warning: JBMS \\(instance *");
0:         searchStrings.addElement("^Transaction:\\(.*\\) *\\|");
1:         searchStrings.addElement("^Read [0-9]* of [0-9]* bytes$");
0: 	// added for ibridge connections
0:         searchStrings.addElement("jdbc:derby:informix://localhost:1527/");
0:         // This was for wl output; it needs some FIXUP to work
0:         // or we need to change the masters (which would be easier)
0:         //searchStrings.addElement("\\[B\\@[0-9a-f]");
1:         searchStrings.addElement("Directory .*connect.wombat.seg0");
0:         searchStrings.addElement("^ij> Warning: Cloudscape \\(instance.*$");
0:         searchStrings.addElement("^ij> WARNING: Cloudscape \\(instance.*$");
0:         searchStrings.addElement("^ij(\\([0-9]\\))> WARNING: Cloudscape \\(instance.*$");
0:         searchStrings.addElement("^ij(\\([0-9]\\))> Warning: Cloudscape \\(instance.*$");
0:         deleteLines.addElement("^XSDB.*$");
1:         // Filter for constraint names - bug 5622 - our internal constraint names are too long. To be db2 compatible, we have reworked them.
0:         StringBuffer constraintNameFilter = new StringBuffer();
1:         constraintNameFilter.append("SQL[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]");
1:         searchStrings.addElement(constraintNameFilter.toString());
1:         // Filter for uuids
1:         StringBuffer uuidFilter = new StringBuffer();
1:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
1:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
1:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
1:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
1:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]");
1:         searchStrings.addElement(uuidFilter.toString());
0: 		// Filter for timestamps
0: 		StringBuffer	timestampFilter = new StringBuffer();
0: 		timestampFilter.append( "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] " );
0: 		timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
0: 		searchStrings.addElement( timestampFilter.toString() );
0: 		// 3 digit year
0: 		timestampFilter = new StringBuffer();
0: 		timestampFilter.append( "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] " );
0: 		timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
0: 		searchStrings.addElement( timestampFilter.toString() );
0: 		// ibm13 year
0: 		timestampFilter = new StringBuffer();
0: 		timestampFilter.append( "[0-9]-[0-9][0-9]-[0-9][0-9] " );
0: 		timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
0: 		searchStrings.addElement( timestampFilter.toString() );
0: 		searchStrings.addElement("^COM\\.jbms\\..*\\|");
0: 		// Filter remove transaction id's from deadlock messages
0: 		searchStrings.addElement("^  Waiting XID : {.*}");
0: 		searchStrings.addElement("^  Granted XID : .*$");
0: 		searchStrings.addElement("^The selected victim is XID : .*");
0: 		// Filters for build numbers
0: 		searchStrings.addElement("(Cloudscape - DBMS:[A-Za-z]* - [0-9]\\.[0-9]\\.[0-9] - )\\(([0-9]*)\\)");
0: 		searchStrings.addElement("(beta - )\\(([0-9]*)\\)");
0: 		searchStrings.addElement("Level2CostEstimateImpl: .*");
0: 		// Filter for xa tests for the numbers representing the db name (it can change)
0: 		searchStrings.addElement("^Transaction ([0-9])* : \\(([0-9]*)\\,([0-9a-f]*)\\,([0-9a-f]*)\\)");
0: 		// Filter for optimizer number for zindexesLevel1 test (due to a change in display width for the test)
0: 		searchStrings.addElement("^Modifying access paths using optimizer .[0-9]*");
0: 		searchStrings.addElement("CDWS[0-9]*");
0: 		searchStrings.addElement("IXWS[0-9]*");
0: 		searchStrings.addElement("^.*COM.ibm.db2.jdbc.DB2Exception: \\[IBM\\]\\[CLI Driver\\] SQL1013N  The database alias name or database name \".*\\_M\".*");
0: 		// for j9, to eliminate intermittent failures due to this problem in j9:
0: 		searchStrings.addElement("FAILED STACK MAP");
0: 		if (isJCC)
1: 		{
0: 			searchStrings.addElement("[ ]*\\|");
0: 			searchStrings.addElement("^--*");
1: 		}
1: 
0: 		//Filter to suppress absould paths in error message for roll forward recovery tests 
0: 		searchStrings.addElement("Directory.*.wombat.already.exists");
1: 
0:         Vector subStrings = new Vector();
0:         subStrings.addElement("");
0:         subStrings.addElement("");
1:         subStrings.addElement("Transaction:(XXX)|");
1:         subStrings.addElement("Read ... bytes");
0: 		// for iBridge connections
0:         subStrings.addElement("cloudscape:derby:");
0:         //subStrings.addElement("Bx"); // originally for 
1:         subStrings.addElement("Directory DBLOCATION/seg0");
0:         subStrings.addElement("ij> ");
0:         subStrings.addElement("ij> ");
0:         subStrings.addElement("ij$1> ");
0:         subStrings.addElement("ij$1> ");
1:         subStrings.addElement("xxxxGENERATED-IDxxxx");
1:         subStrings.addElement("xxxxFILTERED-UUIDxxxx");
1:         subStrings.addElement("xxxxxxFILTERED-TIMESTAMPxxxxx");
1:         subStrings.addElement("xxxxxxFILTERED-TIMESTAMPxxxxx");
1:         subStrings.addElement("xxxxxxFILTERED-TIMESTAMPxxxxx");
1:         subStrings.addElement("Transaction:(XXX)|");
0: 		// remove transaction id's from deadlock messages
0: 		subStrings.addElement("  Waiting XID : {WWW,QQQ}");
0: 		subStrings.addElement("  Granted XID : {GGG.QQQ}...");
0: 		subStrings.addElement("The selected victim is XID : VVV");
0: 		// sub build numbers
0: 		subStrings.addElement("$1(xxXXxxFILTERED-BUILD-NUMBERxxXXxx)");
0: 		subStrings.addElement("$1(xxXXxxFILTERED-BUILD-NUMBERxxXXxx)");
0: 		subStrings.addElement("Level2CostEstimateImpl: xxXXxxFILTERED-INFORMATIONxxXXxx");
0: 		// sub for db name in xa tests (it can change)
0: 		subStrings.addElement("Transaction $1 : ($2,FILTERED,FILTERED)");
0: 		// sub for optimizer number for zindexesLevel1 test
0: 		subStrings.addElement("Modifying access paths using optimizer FILTERED_NUMBER");
0: 		subStrings.addElement("CDWSno");
0: 		subStrings.addElement("IXWSno");
0: 		subStrings.addElement("COM.ibm.db2.jdbc.DB2Exception: [IBM][CLI Driver] SQL1013N  The database alias name or database name xxxFILTEREDMIRRORDBxxx could not be found.  SQLSTATE=42705");
0: 		// for j9, to eliminate intermittent failures due to this problem in j9:
0: 		subStrings.addElement("");
0: 		// for JCC replace multiple blanks with one blank to handle differences
0: 		// in display width
0: 		if (isJCC)
1: 		{
0: 			subStrings.addElement(" |");
0: 			subStrings.addElement("-----");
1: 		}
0: 		subStrings.addElement("Directory DBLOCATION/wombat already exists");
0: 		doWork(srcFile, dstFile, null, deleteLines, searchStrings, subStrings, isSed);
1: 
1: 	}
0: 	// This just does JCC changes on the output master file
1:     public void execJCC(InputStream is, File dstFile)
1:         throws IOException
1:     {
1:         // Vector for storing lines to be deleted
0:         Vector deleteLines = new Vector();
1: 
1:         // Vectors for substitutions
0:         Vector searchStrings = new Vector();
0: 		searchStrings.addElement("^true[ ]*\\|");
0: 		searchStrings.addElement("^false[ ]*\\|");
0: 		searchStrings.addElement("\\|true[ ]*\\|");
0: 		searchStrings.addElement("\\|false[ ]*\\|");
0: 		searchStrings.addElement("[ ]*\\|");
0: 		searchStrings.addElement("^--*");
1: 
0:         Vector subStrings = new Vector();
0: 		// true and false show up as 1 and 0 in JCC. 
0: 		//because they have no boolean support
0: 		subStrings.addElement("1 |");
0: 		subStrings.addElement("0 |");
0: 		subStrings.addElement("|1 |");
0: 		subStrings.addElement("|0 |");
0: 		subStrings.addElement(" |");
0: 		subStrings.addElement("-----");
1: 
0: 		doWork(null, dstFile, is, deleteLines, searchStrings, subStrings, null);
1: 
1: 	}
0: 	// for rmi, there's a warning about the db, but it's really ok.
0:     public void rmiexec(File srcFile, File dstFile, InputStream isSed)
1:         throws IOException
1:     {
1:         // Vector for storing lines to be deleted
0:         Vector deleteLines = new Vector();
0: 		// for Rmi:
0: 	 	deleteLines.addElement("^.*WARNING: Wierd RMI server URL:.*$");	
0: 	 	deleteLines.addElement("^.*WARNING 01J01: Database 'wombat' not created, connection made to existing database instead.");	
1: 
0:         Vector searchStrings = new Vector();
0: 		//searchStrings.addElement("");
0:         Vector subStrings = new Vector();
0: 		//subStrings.addElement("");
1: 
0: 		doWork(srcFile, dstFile, null, deleteLines, searchStrings, subStrings, isSed);
1: 	}
1: 
0: 	private void doWork(File srcFile, File dstFile, InputStream is, Vector deleteLines, 
0: 		Vector searchStrings, Vector subStrings, InputStream isSed)
1:         throws IOException
1: 	{
1: 		
0:         boolean lineDeleted = false;
0:         PatternMatcher matcher;
0:         Perl5Compiler pcompiler;
0:         PatternMatcherInput input;
1:         BufferedReader inFile;
1:         PrintWriter outFile;
0:         String result = "";
0:         String regex;
0:         Vector delPatternVector = new Vector();
0:         Vector subPatternVector = new Vector();
1: 
0: 	// ---------------------------------
1:         // Try loading the sed properties if they exist (see jdbc_sed.properties as an example)
1:         if ( isSed != null )
1:         {
0: 	    Properties sedp = new Properties();
1: 		
1:             sedp.load(isSed);
0: 	    for (Enumeration e = sedp.propertyNames(); e.hasMoreElements(); )
1: 		{
0: 		    String key = (String)e.nextElement();
0: 		    if (key.equals("substitute"))
1: 		    {
0: 			String value = sedp.getProperty(key);
0: 			// value string contains a comma separated list of patterns
0: 			StringTokenizer st = new StringTokenizer(value,",");
0: 			String patternName = ""; 
0: 			String patName = ""; 
0: 			String subName = ""; 
0: 			while (st.hasMoreTokens())
1: 			{
0: 			    patternName = st.nextToken();
0: 			    // pattern;substitute
0: 			    StringTokenizer st2 = new StringTokenizer(patternName,";");
0: 			    patName = st2.nextToken();
0: 			    subName = st2.nextToken();
0: 			    if (!patName.equals("") && !subName.equals(""))
1: 			    {
0: 				searchStrings.addElement(patName);
0: 				subStrings.addElement(subName);
1: 			    }
0: //System.out.println("pattern = " + patName + " substitute " + subName);
1: 			}
1: 		    }
0: 		    else if (key.equals("delete"))
1: 		    {
0: 			String value = sedp.getProperty(key);
0: 			// value string contains a comma separated list of patterns
0: 			StringTokenizer st = new StringTokenizer(value,",");
0: 			String patternName = ""; 
0: 			while (st.hasMoreTokens())
1: 			{
0: 			    patternName = st.nextToken();
0: 			    deleteLines.addElement(patternName);
1: 			}
1: 		    }
1:                 }
1:         }
0: 	// ---------------------------------
1: 
0:         //Create Perl5Compiler and Perl5Matcher
0:         pcompiler = new Perl5Compiler();
0:         matcher = new Perl5Matcher();
1: 
1:         // Define the input and output files based on args
0: 		if (is == null)
0:         	inFile = new BufferedReader(new FileReader(srcFile));
0: 		else
0: 			inFile = new BufferedReader(new InputStreamReader(is));
1:         outFile = new PrintWriter
0:             ( new BufferedWriter(new FileWriter(dstFile), 10000), true );
1: 
1:         // Attempt to compile the patterns for deletes
0:         for (int i = 0; i < deleteLines.size(); i++)
1:         {
0:             try
1:             {
0:                 regex = (String)deleteLines.elementAt(i);
0:                 //System.out.println("The pattern: " + regex);
0:                 Pattern pattern = pcompiler.compile(regex);
0:                 if (pattern == null)
0:                     System.out.println("pattern is null");
0:                 delPatternVector.addElement(pattern);
1:             }
0:             catch(MalformedPatternException e)
1:             {
0:                 System.out.println("Bad pattern.");
0:                 System.out.println(e.getMessage());
1:             }
1:         }
1: 
1:         // Attempt to compile the patterns for substitutes
0:         for (int i = 0; i < searchStrings.size(); i++)
1:         {
0:             try
1:             {
0:                 regex = (String)searchStrings.elementAt(i);
0:                 //System.out.println("The pattern: " + regex);
0:                 Pattern pattern = pcompiler.compile(regex);
0:                 if (pattern == null)
0:                     System.out.println("pattern is null");
0:                 subPatternVector.addElement(pattern);
1:             }
0:             catch(MalformedPatternException e)
1:             {
0:                 System.out.println("Bad pattern.");
0:                 System.out.println(e.getMessage());
1:             }
1:         }
1: 
1:         String str;
1:         int j;
1:         int lineCount = 0;
1:         // Read the input file
1:         while ( (str = inFile.readLine()) != null )
1:         {
1:             lineCount++;
1:             
1:             //System.out.println("***Line no: " + lineCount);
1:             //System.out.println("***Line is: " + str);
0:             lineDeleted = false;
1: 
1:             // First delete any nulls (Cafe 1.8 leaves nulls)
1:             if (str.length() == 1)
1:             {
1:                 if (str.charAt(0) == (char) 0)
1:                 {
1:                     // Skip this line, don't write it
1:                     //System.out.println("Skip this line...");
1:                     lineDeleted = true;
1:                 }
1:             }
1: 
1:             // Determine if this line should be deleted for delete pattern match
1:             if ( lineDeleted == false )
1:             {
0:                 for (j = 0; j < delPatternVector.size(); j++)
1:                 {
0:                     if ( matcher.contains( str, (Pattern)delPatternVector.elementAt(j) ) )
1:                     {
0:                         //System.out.println("***Match found to delete line***");
0:                         String tmpp = ((Pattern)delPatternVector.elementAt(j)).getPattern();
0:                         //System.out.println("***Pattern is: " + tmpp);
1: 
0:                         // In this case we are removing the line, so don't write it out
1:                         lineDeleted = true;
0:                         break;
1:                     }
1:                 }
1:             }
1: 
1:             // Determine if any substitutions are needed
1:             if (lineDeleted == false)
1:             {
0: 		Substitution substitution;
0: 		StringSubstitution strsub = new StringSubstitution("");
0: 		Perl5Substitution perlsub = new Perl5Substitution("");
0:                 boolean subDone = false;
0:                 for (j = 0; j < subPatternVector.size(); j++)
1:                 {
0:                     input = new PatternMatcherInput(str);
0:                     Pattern patt = (Pattern)subPatternVector.elementAt(j);
0:                     String pstr = patt.getPattern();
0:                     //System.out.println("Pattern string is " + pstr);
0:                     String sub = (String)subStrings.elementAt(j);
0: 		    if (sub.indexOf("$") > 0)
1: 		    {
0:                         perlsub.setSubstitution(sub);
0:                         substitution = (Substitution)perlsub;
0:                     } else {
0:                         strsub.setSubstitution(sub);
0: 			substitution = (Substitution)strsub;
1: 		    }
1:                     //System.out.println("Substitute str = " + sub);
0:                     if ( matcher.contains( input, patt ) )
1:                     {
0:                         MatchResult mr = matcher.getMatch();
0:                         //System.out.println("***Match found for substitute***");
0:                         // In this case we do a substitute
0:                         result = Util.substitute(matcher, patt, substitution, str,
0:                             Util.SUBSTITUTE_ALL);
0:                         //System.out.println("New string: " + result);
0:                         //outFile.println(result);
0:                         str = result;
0:                         subDone = true;
1:                     }
1:                 }
0:                 if (subDone)
1:                 {
0:                     //System.out.println("write the subbed line");
0:                     outFile.println(result);
1:                 }
0:                 else
1:                 {
0:                     //System.out.println("Write the str: " + str);
0:                     outFile.println(str);
1:                     outFile.flush();
1:                 }
1:             }// end if
1:         } // end while
1:         inFile.close();
1:         outFile.flush();
1:         outFile.close();
0:     }// end exec
1: }
author:David Van Couvering
-------------------------------------------------------------------------------
commit:27ee843
/////////////////////////////////////////////////////////////////////////
1: 	private	static	final	String	SQL_EXCEPTION_FILTERED_SUBSTITUTION = 
1:         "java.sql.SQLException:";
commit:fe8cc95
/////////////////////////////////////////////////////////////////////////
0: 	private	static	final	String	SQL_EXCEPTION_FILTERED_SUBSTITUTION = "SQL Exception:";
commit:6f2391f
/////////////////////////////////////////////////////////////////////////
0: 	private	static	final	String	SQL_EXCEPTION_FILTERED_SUBSTITUTION = 
0:         "java.sql.SQLException:";
commit:0438c35
/////////////////////////////////////////////////////////////////////////
1: 		// JUnit noise
1:         deleteLines.addElement("^\\.*$");
1:         deleteLines.addElement("^Time: [0-9].*$");
1:         deleteLines.addElement("^OK \\(.*$");
0: 
author:Andreas Korneliussen
-------------------------------------------------------------------------------
commit:1c31b3a
/////////////////////////////////////////////////////////////////////////
1:         searchStrings.addElement("Directory.*.extinout/crwombatlog/log.*.exists");
/////////////////////////////////////////////////////////////////////////
1:         subStrings.addElement("Directory 'extinout<sp>crwombatlog<sp>log' exists");
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:7010e1d
/////////////////////////////////////////////////////////////////////////
1:         // Filter for "DB2ConnectionCorrelator" text that can be printed as
1:         // part of some JCC error messages.
1:         searchStrings.addElement("  DB2ConnectionCorrelator: [0-9A-Z.]*");
0: 
/////////////////////////////////////////////////////////////////////////
0: 		// ignore the 'DB2ConnectionCorrelator' thing altogether.
0: 		subStrings.addElement("");
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:f68f62f
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
1:    Derby - Class org.apache.derbyTesting.functionTests.harness.Sed
0: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
1:       http://www.apache.org/licenses/LICENSE-2.0
0: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
0: 
0:  */
0: 
0: package org.apache.derbyTesting.functionTests.harness;
0: 
0: /***
0:  * Sed.java
0:  *
0:  * This is a version of "sed" in Java for the Cloudscape Function Tests,
0:  * written using the OROMatcher Perl5 regular expression classes.
0:  * The substitutions/deletions are based on the original kornshell tests.
0:  *
0:  ***/
0: 
0: import java.io.*;
0: import java.util.Vector;
0: import org.apache.oro.text.regex.*;
0: import java.util.Enumeration;
0: import java.util.Properties;
0: import java.util.StringTokenizer;
0: 
0: public class Sed
0: {
0: 
0:     public Sed()
0:     {
0:     }
0: 
0:     public static void main(String[] args) throws Exception {
0: 	if (args == null || args.length != 2) {
0: 		System.err.println("Usage: Sed sourcefile targetfile");
0: 		System.exit(1);
0: 	}
0: 	File src = new File(args[0]);
0: 	File tgt = new File(args[1]);
0: 	new Sed().exec(src,tgt,null, false);
0:     }
0: 
0:     // The arguments should be the names of the input and output files
0:     public void exec(File srcFile, File dstFile, InputStream isSed, boolean isJCC)
0:         throws IOException
0:     {
0:         // Vector for storing lines to be deleted
0:         Vector deleteLines = new Vector();
0:         deleteLines.addElement("^ij version.*$");
0:         deleteLines.addElement("^\\*\\*\\*\\* Test Run Started .* \\*\\*\\*\\*$");
0:         deleteLines.addElement("^\\*\\*\\*\\* Test Run Completed .* \\*\\*\\*\\*$");
0:         deleteLines.addElement("^ELAPSED TIME = [0-9]* milliseconds$");
0:         deleteLines.addElement("^Symantec Java! JustInTime Compiler Version .*$");
0:         deleteLines.addElement("^Copyright .* Symantec .*$");
0:         deleteLines.addElement("^\\^\\?$");
0:         //deleteLines.addElement("^\\.$"); // originally to remove lines with a dot
0:         deleteLines.addElement("^S.*ij> $");
0:         deleteLines.addElement("^ *$");
0:         deleteLines.addElement("^Server StackTrace:$");
0:         deleteLines.addElement("^\\[ *$");
0:         deleteLines.addElement("^\\] *$");
0:         deleteLines.addElement("^\\[$");
0:         deleteLines.addElement("^\\]$");
0:         deleteLines.addElement("^<not available>\\]$");
0:         deleteLines.addElement("^weblogic\\..*$");
0:         deleteLines.addElement("^(.*at .*)\\(.*:[0-9].*\\)$");
0:         deleteLines.addElement("^(.*at .*)\\(*.java\\)$");
0:         deleteLines.addElement("^(.*at .*)\\(Compiled Code\\)$");
0:         deleteLines.addElement("^(.*at .*)\\(Interpreted Code\\)$");
0:         deleteLines.addElement("^(.*at .*)\\(Unknown Source\\)$");
0:         deleteLines.addElement("^(.*at .*)\\(Native Method\\)$");
0:         deleteLines.addElement("^.*at weblogic\\..*$");
0:         deleteLines.addElement("^\\tat $"); // rare case of incomplete stack trace line
0:         deleteLines.addElement("JBMSTours\\.vti\\.jdbc1_2\\.ExternalTable"); // For some reason ArchiveData.out outputs it's errors in random order, sed them both out.
0:         deleteLines.addElement("optimizer estimated cost");
0:         deleteLines.addElement("optimizer estimated row count");
0:         deleteLines.addElement("^WARNING: Cloudscape \\(instance.*$");
0:         deleteLines.addElement("^Warning: Cloudscape \\(instance.*$");
0:         deleteLines.addElement("Using executables built for native_threads");
0:         deleteLines.addElement("Estimate of memory used");
0:         deleteLines.addElement("Size of merge runs");
0:         deleteLines.addElement("Number of merge runs");
0:         deleteLines.addElement("Sort type");
0:         deleteLines.addElement("Optimization started at .*$");
0:         deleteLines.addElement("WARNING 02000: No row was found for FETCH, UPDATE or DELETE");
0: 	// deleteLines for stack traces from j9 jvm to match those above for other jvms
0:  	deleteLines.addElement("Stack trace:");	
0:         deleteLines.addElement("^.*java/.*\\<init\\>\\(.*\\)V");
0:  	deleteLines.addElement("^.*org/apache/derby/.*\\(.*\\).*$");	
0: 	// next for j9 stack trace with jarfiles test run.
0:  	deleteLines.addElement("^.*derby/.*\\<.*\\>\\(.*\\).*$");	
0:  	deleteLines.addElement("^.*derby/.*\\(.*\\).*$");	
0:  	deleteLines.addElement("^.*java/.*\\(.*\\).*$");
0: 	deleteLines.addElement("^\\[.*db2jcc.jar\\] [0-9].[1-9] - .*$");	
0: 	deleteLines.addElement("^\\[.*db2jcc_license_c.jar\\] [1-9].[0-9] - .*$");	
0: 
0:         // Vectors for substitutions
0:         Vector searchStrings = new Vector();
0:         searchStrings.addElement("^WARNING: JBMS \\(instance *");
0:         searchStrings.addElement("^Warning: JBMS \\(instance *");
0:         searchStrings.addElement("^Transaction:\\(.*\\) *\\|");
0:         searchStrings.addElement("^Read [0-9]* of [0-9]* bytes$");
0: 	// added for ibridge connections
0:         searchStrings.addElement("jdbc:derby:informix://localhost:1527/");
0:         // This was for wl output; it needs some FIXUP to work
0:         // or we need to change the masters (which would be easier)
0:         //searchStrings.addElement("\\[B\\@[0-9a-f]");
0:         searchStrings.addElement("Directory .*connect.wombat.seg0");
0:         searchStrings.addElement("^ij> Warning: Cloudscape \\(instance.*$");
0:         searchStrings.addElement("^ij> WARNING: Cloudscape \\(instance.*$");
0:         searchStrings.addElement("^ij(\\([0-9]\\))> WARNING: Cloudscape \\(instance.*$");
0:         searchStrings.addElement("^ij(\\([0-9]\\))> Warning: Cloudscape \\(instance.*$");
0:         deleteLines.addElement("^XSDB.*$");
0:         // Filter for constraint names - bug 5622 - our internal constraint names are too long. To be db2 compatible, we have reworked them.
0:         StringBuffer constraintNameFilter = new StringBuffer();
0:         constraintNameFilter.append("SQL[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]");
0:         searchStrings.addElement(constraintNameFilter.toString());
0:         // Filter for uuids
0:         StringBuffer uuidFilter = new StringBuffer();
0:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
0:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
0:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
0:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f]-");
0:         uuidFilter.append("[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]");
0:         searchStrings.addElement(uuidFilter.toString());
0: 		// Filter for timestamps
0: 		StringBuffer	timestampFilter = new StringBuffer();
0: 		timestampFilter.append( "[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] " );
0: 		timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
0: 		searchStrings.addElement( timestampFilter.toString() );
0: 		// 3 digit year
0: 		timestampFilter = new StringBuffer();
0: 		timestampFilter.append( "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] " );
0: 		timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
0: 		searchStrings.addElement( timestampFilter.toString() );
0: 		// ibm13 year
0: 		timestampFilter = new StringBuffer();
0: 		timestampFilter.append( "[0-9]-[0-9][0-9]-[0-9][0-9] " );
0: 		timestampFilter.append( "[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9]* *" );
0: 		searchStrings.addElement( timestampFilter.toString() );
0: 		searchStrings.addElement("^COM\\.jbms\\..*\\|");
0: 		// Filter remove transaction id's from deadlock messages
0: 		searchStrings.addElement("^  Waiting XID : {.*}");
0: 		searchStrings.addElement("^  Granted XID : .*$");
0: 		searchStrings.addElement("^The selected victim is XID : .*");
0: 		// Filters for build numbers
0: 		searchStrings.addElement("(Cloudscape - DBMS:[A-Za-z]* - [0-9]\\.[0-9]\\.[0-9] - )\\(([0-9]*)\\)");
0: 		searchStrings.addElement("(beta - )\\(([0-9]*)\\)");
0: 		searchStrings.addElement("Level2CostEstimateImpl: .*");
0: 		// Filter for xa tests for the numbers representing the db name (it can change)
0: 		searchStrings.addElement("^Transaction ([0-9])* : \\(([0-9]*)\\,([0-9a-f]*)\\,([0-9a-f]*)\\)");
0: 		// Filter for optimizer number for zindexesLevel1 test (due to a change in display width for the test)
0: 		searchStrings.addElement("^Modifying access paths using optimizer .[0-9]*");
0: 		searchStrings.addElement("CDWS[0-9]*");
0: 		searchStrings.addElement("IXWS[0-9]*");
0: 		searchStrings.addElement("^.*COM.ibm.db2.jdbc.DB2Exception: \\[IBM\\]\\[CLI Driver\\] SQL1013N  The database alias name or database name \".*\\_M\".*");
0: 		// for j9, to eliminate intermittent failures due to this problem in j9:
0: 		searchStrings.addElement("FAILED STACK MAP");
0: 		if (isJCC)
0: 		{
0: 			searchStrings.addElement("[ ]*\\|");
0: 			searchStrings.addElement("^--*");
0: 		}
0: 
0: 		//Filter to suppress absould paths in error message for roll forward recovery tests 
0: 		searchStrings.addElement("Directory.*.wombat.already.exists");
0: 
0:         Vector subStrings = new Vector();
0:         subStrings.addElement("");
0:         subStrings.addElement("");
0:         subStrings.addElement("Transaction:(XXX)|");
0:         subStrings.addElement("Read ... bytes");
0: 		// for iBridge connections
0:         subStrings.addElement("cloudscape:derby:");
0:         //subStrings.addElement("Bx"); // originally for 
0:         subStrings.addElement("Directory DBLOCATION/seg0");
0:         subStrings.addElement("ij> ");
0:         subStrings.addElement("ij> ");
0:         subStrings.addElement("ij$1> ");
0:         subStrings.addElement("ij$1> ");
0:         subStrings.addElement("xxxxGENERATED-IDxxxx");
0:         subStrings.addElement("xxxxFILTERED-UUIDxxxx");
0:         subStrings.addElement("xxxxxxFILTERED-TIMESTAMPxxxxx");
0:         subStrings.addElement("xxxxxxFILTERED-TIMESTAMPxxxxx");
0:         subStrings.addElement("xxxxxxFILTERED-TIMESTAMPxxxxx");
0:         subStrings.addElement("Transaction:(XXX)|");
0: 		// remove transaction id's from deadlock messages
0: 		subStrings.addElement("  Waiting XID : {WWW,QQQ}");
0: 		subStrings.addElement("  Granted XID : {GGG.QQQ}...");
0: 		subStrings.addElement("The selected victim is XID : VVV");
0: 		// sub build numbers
0: 		subStrings.addElement("$1(xxXXxxFILTERED-BUILD-NUMBERxxXXxx)");
0: 		subStrings.addElement("$1(xxXXxxFILTERED-BUILD-NUMBERxxXXxx)");
0: 		subStrings.addElement("Level2CostEstimateImpl: xxXXxxFILTERED-INFORMATIONxxXXxx");
0: 		// sub for db name in xa tests (it can change)
0: 		subStrings.addElement("Transaction $1 : ($2,FILTERED,FILTERED)");
0: 		// sub for optimizer number for zindexesLevel1 test
0: 		subStrings.addElement("Modifying access paths using optimizer FILTERED_NUMBER");
0: 		subStrings.addElement("CDWSno");
0: 		subStrings.addElement("IXWSno");
0: 		subStrings.addElement("COM.ibm.db2.jdbc.DB2Exception: [IBM][CLI Driver] SQL1013N  The database alias name or database name xxxFILTEREDMIRRORDBxxx could not be found.  SQLSTATE=42705");
0: 		// for j9, to eliminate intermittent failures due to this problem in j9:
0: 		subStrings.addElement("");
0: 		// for JCC replace multiple blanks with one blank to handle differences
0: 		// in display width
0: 		if (isJCC)
0: 		{
0: 			subStrings.addElement(" |");
0: 			subStrings.addElement("-----");
0: 		}
0: 		subStrings.addElement("Directory DBLOCATION/wombat already exists");
0: 		doWork(srcFile, dstFile, null, deleteLines, searchStrings, subStrings, isSed);
0: 
0: 	}
0: 	// This just does JCC changes on the output master file
0:     public void execJCC(InputStream is, File dstFile)
0:         throws IOException
0:     {
0:         // Vector for storing lines to be deleted
0:         Vector deleteLines = new Vector();
0: 
0:         // Vectors for substitutions
0:         Vector searchStrings = new Vector();
0: 		searchStrings.addElement("^true[ ]*\\|");
0: 		searchStrings.addElement("^false[ ]*\\|");
0: 		searchStrings.addElement("\\|true[ ]*\\|");
0: 		searchStrings.addElement("\\|false[ ]*\\|");
0: 		searchStrings.addElement("[ ]*\\|");
0: 		searchStrings.addElement("^--*");
0: 
0:         Vector subStrings = new Vector();
0: 		// true and false show up as 1 and 0 in JCC. 
0: 		//because they have no boolean support
0: 		subStrings.addElement("1 |");
0: 		subStrings.addElement("0 |");
0: 		subStrings.addElement("|1 |");
0: 		subStrings.addElement("|0 |");
0: 		subStrings.addElement(" |");
0: 		subStrings.addElement("-----");
0: 
0: 		doWork(null, dstFile, is, deleteLines, searchStrings, subStrings, null);
0: 
0: 	}
0: 	// for rmi, there's a warning about the db, but it's really ok.
0:     public void rmiexec(File srcFile, File dstFile, InputStream isSed)
0:         throws IOException
0:     {
0:         // Vector for storing lines to be deleted
0:         Vector deleteLines = new Vector();
0: 		// for Rmi:
0: 	 	deleteLines.addElement("^.*WARNING: Wierd RMI server URL:.*$");	
0: 	 	deleteLines.addElement("^.*WARNING 01J01: Database 'wombat' not created, connection made to existing database instead.");	
0: 
0:         Vector searchStrings = new Vector();
0: 		//searchStrings.addElement("");
0:         Vector subStrings = new Vector();
0: 		//subStrings.addElement("");
0: 
0: 		doWork(srcFile, dstFile, null, deleteLines, searchStrings, subStrings, isSed);
0: 	}
0: 
0: 	private void doWork(File srcFile, File dstFile, InputStream is, Vector deleteLines, 
0: 		Vector searchStrings, Vector subStrings, InputStream isSed)
0:         throws IOException
0: 	{
0: 		
0:         boolean lineDeleted = false;
0:         PatternMatcher matcher;
0:         Perl5Compiler pcompiler;
0:         PatternMatcherInput input;
0:         BufferedReader inFile;
0:         PrintWriter outFile;
0:         String result = "";
0:         String regex;
0:         Vector delPatternVector = new Vector();
0:         Vector subPatternVector = new Vector();
0: 
0: 	// ---------------------------------
0:         // Try loading the sed properties if they exist (see jdbc_sed.properties as an example)
0:         if ( isSed != null )
0:         {
0: 	    Properties sedp = new Properties();
0: 		
0:             sedp.load(isSed);
0: 	    for (Enumeration e = sedp.propertyNames(); e.hasMoreElements(); )
0: 		{
0: 		    String key = (String)e.nextElement();
0: 		    if (key.equals("substitute"))
0: 		    {
0: 			String value = sedp.getProperty(key);
0: 			// value string contains a comma separated list of patterns
0: 			StringTokenizer st = new StringTokenizer(value,",");
0: 			String patternName = ""; 
0: 			String patName = ""; 
0: 			String subName = ""; 
0: 			while (st.hasMoreTokens())
0: 			{
0: 			    patternName = st.nextToken();
0: 			    // pattern;substitute
0: 			    StringTokenizer st2 = new StringTokenizer(patternName,";");
0: 			    patName = st2.nextToken();
0: 			    subName = st2.nextToken();
0: 			    if (!patName.equals("") && !subName.equals(""))
0: 			    {
0: 				searchStrings.addElement(patName);
0: 				subStrings.addElement(subName);
0: 			    }
0: //System.out.println("pattern = " + patName + " substitute " + subName);
0: 			}
0: 		    }
0: 		    else if (key.equals("delete"))
0: 		    {
0: 			String value = sedp.getProperty(key);
0: 			// value string contains a comma separated list of patterns
0: 			StringTokenizer st = new StringTokenizer(value,",");
0: 			String patternName = ""; 
0: 			while (st.hasMoreTokens())
0: 			{
0: 			    patternName = st.nextToken();
0: 			    deleteLines.addElement(patternName);
0: 			}
0: 		    }
0:                 }
0:         }
0: 	// ---------------------------------
0: 
0:         //Create Perl5Compiler and Perl5Matcher
0:         pcompiler = new Perl5Compiler();
0:         matcher = new Perl5Matcher();
0: 
0:         // Define the input and output files based on args
0: 		if (is == null)
0:         	inFile = new BufferedReader(new FileReader(srcFile));
0: 		else
0: 			inFile = new BufferedReader(new InputStreamReader(is));
0:         outFile = new PrintWriter
0:             ( new BufferedWriter(new FileWriter(dstFile), 10000), true );
0: 
0:         // Attempt to compile the patterns for deletes
0:         for (int i = 0; i < deleteLines.size(); i++)
0:         {
0:             try
0:             {
0:                 regex = (String)deleteLines.elementAt(i);
0:                 //System.out.println("The pattern: " + regex);
0:                 Pattern pattern = pcompiler.compile(regex);
0:                 if (pattern == null)
0:                     System.out.println("pattern is null");
0:                 delPatternVector.addElement(pattern);
0:             }
0:             catch(MalformedPatternException e)
0:             {
0:                 System.out.println("Bad pattern.");
0:                 System.out.println(e.getMessage());
0:             }
0:         }
0: 
0:         // Attempt to compile the patterns for substitutes
0:         for (int i = 0; i < searchStrings.size(); i++)
0:         {
0:             try
0:             {
0:                 regex = (String)searchStrings.elementAt(i);
0:                 //System.out.println("The pattern: " + regex);
0:                 Pattern pattern = pcompiler.compile(regex);
0:                 if (pattern == null)
0:                     System.out.println("pattern is null");
0:                 subPatternVector.addElement(pattern);
0:             }
0:             catch(MalformedPatternException e)
0:             {
0:                 System.out.println("Bad pattern.");
0:                 System.out.println(e.getMessage());
0:             }
0:         }
0: 
0:         String str;
0:         int j;
0:         int lineCount = 0;
0:         // Read the input file
0:         while ( (str = inFile.readLine()) != null )
0:         {
0:             lineCount++;
0:             
0:             //System.out.println("***Line no: " + lineCount);
0:             //System.out.println("***Line is: " + str);
0:             lineDeleted = false;
0: 
0:             // First delete any nulls (Cafe 1.8 leaves nulls)
0:             if (str.length() == 1)
0:             {
0:                 if (str.charAt(0) == (char) 0)
0:                 {
0:                     // Skip this line, don't write it
0:                     //System.out.println("Skip this line...");
0:                     lineDeleted = true;
0:                 }
0:             }
0: 
0:             // Determine if this line should be deleted for delete pattern match
0:             if ( lineDeleted == false )
0:             {
0:                 for (j = 0; j < delPatternVector.size(); j++)
0:                 {
0:                     if ( matcher.contains( str, (Pattern)delPatternVector.elementAt(j) ) )
0:                     {
0:                         //System.out.println("***Match found to delete line***");
0:                         String tmpp = ((Pattern)delPatternVector.elementAt(j)).getPattern();
0:                         //System.out.println("***Pattern is: " + tmpp);
0: 
0:                         // In this case we are removing the line, so don't write it out
0:                         lineDeleted = true;
0:                         break;
0:                     }
0:                 }
0:             }
0: 
0:             // Determine if any substitutions are needed
0:             if (lineDeleted == false)
0:             {
0: 		Substitution substitution;
0: 		StringSubstitution strsub = new StringSubstitution("");
0: 		Perl5Substitution perlsub = new Perl5Substitution("");
0:                 boolean subDone = false;
0:                 for (j = 0; j < subPatternVector.size(); j++)
0:                 {
0:                     input = new PatternMatcherInput(str);
0:                     Pattern patt = (Pattern)subPatternVector.elementAt(j);
0:                     String pstr = patt.getPattern();
0:                     //System.out.println("Pattern string is " + pstr);
0:                     String sub = (String)subStrings.elementAt(j);
0: 		    if (sub.indexOf("$") > 0)
0: 		    {
0:                         perlsub.setSubstitution(sub);
0:                         substitution = (Substitution)perlsub;
0:                     } else {
0:                         strsub.setSubstitution(sub);
0: 			substitution = (Substitution)strsub;
0: 		    }
0:                     //System.out.println("Substitute str = " + sub);
0:                     if ( matcher.contains( input, patt ) )
0:                     {
0:                         MatchResult mr = matcher.getMatch();
0:                         //System.out.println("***Match found for substitute***");
0:                         // In this case we do a substitute
0:                         result = Util.substitute(matcher, patt, substitution, str,
0:                             Util.SUBSTITUTE_ALL);
0:                         //System.out.println("New string: " + result);
0:                         //outFile.println(result);
0:                         str = result;
0:                         subDone = true;
0:                     }
0:                 }
0:                 if (subDone)
0:                 {
0:                     //System.out.println("write the subbed line");
0:                     outFile.println(result);
0:                 }
0:                 else
0:                 {
0:                     //System.out.println("Write the str: " + str);
0:                     outFile.println(str);
0:                     outFile.flush();
0:                 }
0:             }// end if
0:         } // end while
0:         inFile.close();
0:         outFile.flush();
0:         outFile.close();
0:     }// end exec
0: }
commit:c1c71ef
/////////////////////////////////////////////////////////////////////////
0:    Derby - Class org.apache.derbyTesting.functionTests.harness.Sed
0: 
0:    Copyright 1999, 2004 The Apache Software Foundation or its licensors, as applicable.
0: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
0: 
0:       http://www.apache.org/licenses/LICENSE-2.0
0: 
0:    Unless required by applicable law or agreed to in writing, software
0:    distributed under the License is distributed on an "AS IS" BASIS,
0:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0:    See the License for the specific language governing permissions and
0:    limitations under the License.
commit:cb1ca12
/////////////////////////////////////////////////////////////////////////
0: {
============================================================================