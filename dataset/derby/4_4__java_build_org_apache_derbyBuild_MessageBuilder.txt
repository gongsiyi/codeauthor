1:ad6d5f1: /*
1:ad6d5f1: 
1:ad6d5f1:    Derby - Class org.apache.derbyBuild.MessageBuilder
1:ad6d5f1: 
1:ad6d5f1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:ad6d5f1:    contributor license agreements.  See the NOTICE file distributed with
1:ad6d5f1:    this work for additional information regarding copyright ownership.
1:ad6d5f1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:ad6d5f1:    (the "License"); you may not use this file except in compliance with
1:ad6d5f1:    the License.  You may obtain a copy of the License at
1:ad6d5f1: 
1:ad6d5f1:       http://www.apache.org/licenses/LICENSE-2.0
1:ad6d5f1: 
1:ad6d5f1:    Unless required by applicable law or agreed to in writing, software
1:ad6d5f1:    distributed under the License is distributed on an "AS IS" BASIS,
1:ad6d5f1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:ad6d5f1:    See the License for the specific language governing permissions and
1:ad6d5f1:    limitations under the License.
1:ad6d5f1: 
1:ad6d5f1:  */
1:ad6d5f1: 
1:ad6d5f1: package org.apache.derbyBuild;
1:ad6d5f1: 
1:ad6d5f1: import java.io.File;
1:ad6d5f1: import java.io.FileWriter;
1:ad6d5f1: import java.io.IOException;
1:ad6d5f1: import java.io.PrintWriter;
1:ad6d5f1: import java.text.MessageFormat;
1:ad6d5f1: import java.util.ArrayList;
1:ad6d5f1: import javax.xml.parsers.*;
1:ad6d5f1: import org.w3c.dom.*;
1:ad6d5f1: 
1:ad6d5f1: import org.apache.tools.ant.BuildException;
1:ad6d5f1: import org.apache.tools.ant.Project;
1:ad6d5f1: import org.apache.tools.ant.Task;
1:ad6d5f1: 
1:ad6d5f1: 
1:ad6d5f1: /**
1:ad6d5f1:  * <p>
1:ad6d5f1:  * This tool generates the engine's message strings (message_en.properties) as well
1:ad6d5f1:  * the dita source for the SQLState documentation in the Derby Reference Guide.
1:ad6d5f1:  * </p>
1:ad6d5f1:  */
1:ad6d5f1: public class MessageBuilder extends Task
1:ad6d5f1: {
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1:     //
1:ad6d5f1:     //  CONSTANTS
1:ad6d5f1:     //
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1: 
1:ad6d5f1:     private static  final   String  TAB_STOP = "    ";
1:ad6d5f1:     
1:ad6d5f1:     private static  final   String  PROPERTIES_BOILERPLATE =
1:ad6d5f1:         "###################################################\n" +
1:ad6d5f1:         "#\n" +
1:ad6d5f1:         "# Licensed to the Apache Software Foundation (ASF) under one or more\n" +
1:ad6d5f1:         "# contributor license agreements.  See the NOTICE file distributed with\n" +
1:ad6d5f1:         "# this work for additional information regarding copyright ownership.\n" +
1:ad6d5f1:         "# The ASF licenses this file to You under the Apache License, Version 2.0\n" +
1:ad6d5f1:         "# (the \"License\"); you may not use this file except in compliance with\n" +
1:ad6d5f1:         "# the License.  You may obtain a copy of the License at\n" +
1:ad6d5f1:         "#\n" +
1:ad6d5f1:         "#     http://www.apache.org/licenses/LICENSE-2.0\n" +
1:ad6d5f1:         "#\n" +
1:ad6d5f1:         "# Unless required by applicable law or agreed to in writing, software\n" +
1:ad6d5f1:         "# distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
1:ad6d5f1:         "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
1:ad6d5f1:         "# See the License for the specific language governing permissions and\n" +
1:ad6d5f1:         "# limitations under the License.\n" +
1:ad6d5f1:         "#\n" +
1:ad6d5f1:         "###################################################\n" +
1:ad6d5f1:         "\n" +
1:ad6d5f1:         "###################################################\n" +
1:ad6d5f1:         "#\n" +
1:ad6d5f1:         "# DO NOT EDIT THIS FILE!\n" +
1:ad6d5f1:         "#\n" +
1:ad6d5f1:         "# Instead, edit messages.xml. The ant MessageBuilder task takes\n" +
1:ad6d5f1:         "# messages.xml as input and from it generates this file.\n" +
1:ad6d5f1:         "#\n" +
1:ad6d5f1:         "###################################################\n";
1:ad6d5f1: 
1:ad6d5f1:     private static  final   String  REF_GUIDE_BOILERPLATE =
1:ad6d5f1:         "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
1:ad6d5f1:         "<!DOCTYPE reference PUBLIC \"-//OASIS//DTD DITA Reference//EN\"\n" +
1:a396cb1:         " \"../dtd/reference.dtd\">\n";
1:ad6d5f1: 
1:ad6d5f1:     private static  final   String  REF_GUIDE_NOTES =
1:ad6d5f1:         "<!-- \n" +
1:ad6d5f1:         "Licensed to the Apache Software Foundation (ASF) under one or more\n" +
1:ad6d5f1:         "contributor license agreements.  See the NOTICE file distributed with\n" +
1:ad6d5f1:         "this work for additional information regarding copyright ownership.\n" +
1:ad6d5f1:         "The ASF licenses this file to You under the Apache License, Version 2.0\n" +
1:ad6d5f1:         "(the \"License\"); you may not use this file except in compliance with\n" +
1:ad6d5f1:         "the License.  You may obtain a copy of the License at      \n" +
1:ad6d5f1:         "\n" +
1:ad6d5f1:         "http://www.apache.org/licenses/LICENSE-2.0  \n" +
1:ad6d5f1:         "\n" +
1:ad6d5f1:         "Unless required by applicable law or agreed to in writing, software  \n" +
1:ad6d5f1:         "distributed under the License is distributed on an \"AS IS\" BASIS,  \n" +
1:ad6d5f1:         "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  \n" +
1:ad6d5f1:         "See the License for the specific language governing permissions and  \n" +
1:ad6d5f1:         "limitations under the License.\n" +
1:ad6d5f1:         "-->\n" +
1:ad6d5f1:         "\n" +
1:ad6d5f1:         "<!-- \n" +
1:ad6d5f1:         "NOTE: this file is generated by the MessageBuilder task as part of a\n" +
1:ad6d5f1:         "Derby build. Please do not hand-edit this file. Instead, please edit\n" +
1:a396cb1:         "the corresponding text in messages.xml and/or MessageBuilder.\n" +
1:ad6d5f1:         "-->\n";
1:ad6d5f1:     
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1:     //
1:ad6d5f1:     //  STATE
1:ad6d5f1:     //
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1: 
1:ad6d5f1:     private String  _xmlSourceFile;
1:ad6d5f1:     private String  _propertiesTargetFile;
1:ad6d5f1:     private String  _ditaTargetFile;
1:ad6d5f1: 
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1:     //
1:ad6d5f1:     //  INNER CLASSES
1:ad6d5f1:     //
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * XML-wrigint wrapper around a PrintWriter.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     public  static  final   class   XMLWriter
1:ad6d5f1:     {
1:ad6d5f1:         // If this boolean is set, then all operations are NOPs.
1:ad6d5f1:         private         boolean       _vacuous;
1:ad6d5f1:         
1:ad6d5f1:         private         FileWriter   _fw;
1:ad6d5f1:         private         PrintWriter _pw;
1:38b9499:         private         ArrayList<String>    _tagStack;
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Special constructor for making a vacuous writer which doesn't do
1:ad6d5f1:          * anything. This allows us to write easy-to-read dita-generating code
1:ad6d5f1:          * that is not cluttered with "if ( documented )" conditionals.
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public  XMLWriter()
1:ad6d5f1:         {
1:ad6d5f1:             _vacuous = true;
1:ad6d5f1:          }
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Create a productive writer which actually flushes text to disk.
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public  XMLWriter( File file )
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             _vacuous = false;
1:ad6d5f1:             _fw = new FileWriter( file );
1:ad6d5f1:             _pw = new PrintWriter( _fw );
1:38b9499:             _tagStack = new ArrayList<String>();
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         public  void    flush() throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1:             
1:ad6d5f1:             _pw.flush();
1:ad6d5f1:             _fw.flush();
1:ad6d5f1:         }
1:ad6d5f1:         
1:ad6d5f1:         public  void    close() throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             _pw.close();
1:ad6d5f1:             _fw.close();
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Indent and write an empty tag.
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public void    writeEmptyTag( String tag )
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             writeEmptyTag( tag, "" );
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Indent and write an empty tag with attributes.
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public void    writeEmptyTag( String tag, String attributes )
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             indent( );
1:a396cb1:             if ( attributes.length() >0)
1:a396cb1:                 _pw.println( "<" + tag + " " + attributes + "/>");
1:a396cb1:             else
1:a396cb1:                 _pw.println( "<" + tag + "/>");
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Indent and write an opening tag.
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public void    beginTag( String tag )
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             beginTag( tag, "" );
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Indent and write an opening tag.
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public void    beginTag( String tag, String attributes )
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             indent();
1:a396cb1:             if (attributes.length() > 0)
1:a396cb1:                 _pw.println( "<" + tag + " " + attributes + ">");
1:a396cb1:             else
1:a396cb1:                 _pw.println( "<" + tag + ">");
1:ad6d5f1: 
1:ad6d5f1:             _tagStack.add( tag );
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Indent and write a closing tag.
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public void    endTag()
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             String  tag = (String) _tagStack.remove( _tagStack.size() -1 );
1:ad6d5f1:         
1:ad6d5f1:             indent();
1:ad6d5f1: 
1:ad6d5f1:             _pw.println( "</" + tag + ">");
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Indent and write a whole element
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public void    writeTextElement( String tag, String text )
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             writeTextElement( tag, "", text );
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Indent and write a whole element
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public void    writeTextElement( String tag, String attributes, String text )
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             indent();
1:a396cb1:             if ( attributes.length() > 0 )
1:a396cb1:                 _pw.print( "<" + tag + " " + attributes + ">");
1:a396cb1:             else
1:a396cb1:                 _pw.print( "<" + tag + ">");
1:ad6d5f1:             _pw.print( text );
1:ad6d5f1:             _pw.println( "</" + tag + ">");
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Indent based on the depth of our tag nesting level.
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public void    indent()
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             int     tabCount = _tagStack.size();
1:ad6d5f1: 
1:ad6d5f1:             for ( int i = 0; i < tabCount; i++ ) { _pw.write( TAB_STOP ); }
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:                 /**
1:ad6d5f1:          * <p>
1:ad6d5f1:          * Print text.
1:ad6d5f1:          * </p>
1:ad6d5f1:          */
1:ad6d5f1:         public void    println( String text )
1:ad6d5f1:             throws IOException
1:ad6d5f1:         {
1:ad6d5f1:             if ( _vacuous ) { return; }
1:ad6d5f1: 
1:ad6d5f1:             _pw.println( text );
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:     }
1:ad6d5f1:     
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1:     //
1:ad6d5f1:     //  CONSTRUCTORS
1:ad6d5f1:     //
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1: 
1:ad6d5f1:    /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Let Ant conjure us out of thin air.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     public MessageBuilder()
1:ad6d5f1:     {}
1:ad6d5f1:     
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1:     //
1:ad6d5f1:     //  Task BEHAVIOR
1:ad6d5f1:     //
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1: 
1:ad6d5f1:         
1:ad6d5f1:     /** <p>Let Ant set the input file name.</p>*/
1:ad6d5f1:     public void setXmlSourceFile( String fileName ) { _xmlSourceFile = fileName;}
1:ad6d5f1: 
1:ad6d5f1:     /** <p>Let Ant set the file name for the message property file we will write.</p>*/
1:ad6d5f1:     public void setPropertiesTargetFile( String fileName ) { _propertiesTargetFile = fileName;}
1:ad6d5f1: 
1:ad6d5f1:     /** <p>Let Ant set the file name for the SQLState dita file we will write.</p>*/
1:ad6d5f1:     public void setDitaTargetFile( String fileName ) { _ditaTargetFile = fileName;}
1:ad6d5f1:         
1:ad6d5f1:    /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Read the xml message descriptors and output messages_en.properties
1:ad6d5f1:      * and the dita source for the SQLState table in the Derby Reference Guide.
1:ad6d5f1:      * After setting up arguments using the above setter methods, Ant
1:ad6d5f1:      * calls this method in order to run this custom task.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     public  void    execute()
1:ad6d5f1:         throws BuildException
1:ad6d5f1:     {
1:ad6d5f1:         File                 source = new File( _xmlSourceFile );
1:ad6d5f1:         File                 targetProperties = new File( _propertiesTargetFile );
1:ad6d5f1:         File                 targetDita = new File( _ditaTargetFile );
1:ad6d5f1:         FileWriter      propertiesFW = null;
1:ad6d5f1:         PrintWriter    propertiesPW = null;
1:ad6d5f1:         XMLWriter    ditaWriter = null;
1:ad6d5f1: 
1:ad6d5f1:         try {
1:ad6d5f1:             propertiesFW = new FileWriter( targetProperties );
1:ad6d5f1:             propertiesPW = new PrintWriter( propertiesFW );
1:ad6d5f1:             ditaWriter = new XMLWriter( targetDita );
1:ad6d5f1: 
1:ad6d5f1:             processMessages( source, propertiesPW, ditaWriter );
1:ad6d5f1:         }
1:ad6d5f1:         catch (Exception e)
1:ad6d5f1:         {
1:870f7cd:             throw new BuildException( "Could not generate English properties from message descriptors: " + e.getMessage(), e );
1:ad6d5f1:         }
1:ad6d5f1:         finally
1:ad6d5f1:         {
1:ad6d5f1:             try {
1:ad6d5f1:                 finishWriting( propertiesFW, propertiesPW );
1:ad6d5f1: 
1:ad6d5f1:                 if ( ditaWriter != null )
1:ad6d5f1:                 {
1:ad6d5f1:                     ditaWriter.flush();
1:ad6d5f1:                     ditaWriter.close();
1:ad6d5f1:                 }
1:ad6d5f1:             }
1:ad6d5f1:             catch (Exception ex)
1:ad6d5f1:             {
1:ad6d5f1:                 throw new BuildException( "Error closing file writers.", ex );
1:ad6d5f1:             }
1:ad6d5f1:         }
1:ad6d5f1:         
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1:     //
1:ad6d5f1:     //  MINIONS TO PROCESS MESSAGE DESCRIPTORS
1:ad6d5f1:     //
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Loop through descriptors and write appropriate output to the properties
1:ad6d5f1:      * and dita files.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private void    processMessages( File input, PrintWriter propertiesPW, XMLWriter ditaWriter )
1:ad6d5f1:         throws Exception
1:ad6d5f1:     {
1:ad6d5f1:         DocumentBuilderFactory  factory = DocumentBuilderFactory.newInstance();
1:ad6d5f1:         DocumentBuilder              builder = factory.newDocumentBuilder();
1:ad6d5f1:         Document                          doc = builder.parse( input );
1:ad6d5f1:         Element                             root = doc.getDocumentElement();    // framing "messages" element
1:ad6d5f1:         NodeList                            sections = root.getElementsByTagName( "section" );             
1:ad6d5f1: 
1:ad6d5f1:         propertiesPW.println( PROPERTIES_BOILERPLATE );
1:ad6d5f1:         ditaWriter.println( REF_GUIDE_BOILERPLATE );
1:ad6d5f1: 
1:ad6d5f1:         ditaWriter.beginTag( "reference", "id=\"rrefexcept71493\" xml:lang=\"en-us\""  );
1:ad6d5f1:         {
1:ad6d5f1:             ditaWriter.println( REF_GUIDE_NOTES );
1:ad6d5f1:             ditaWriter.writeTextElement( "title", "SQL error messages and exceptions" );
1:ad6d5f1: 
1:ad6d5f1:             ditaWriter.beginTag( "refbody" );
1:ad6d5f1:             {
1:ad6d5f1:                 ditaWriter.beginTag( "section" );
1:ad6d5f1:                 {
1:ad6d5f1:                     ditaWriter.writeTextElement
1:ad6d5f1:                         (
1:ad6d5f1:                          "p",
1:ad6d5f1:                          "The following tables list <i>SQLStates</i> for exceptions. Exceptions " +
1:2acb99a:                          "that begin with an <i>X</i> are specific to <ph conref=\"../conrefs.dita#prod/productshortname\"></ph>."
1:ad6d5f1:                          );
1:ad6d5f1:                 }
1:ad6d5f1:                 ditaWriter.endTag();
1:ad6d5f1:                 
1:ad6d5f1:                 ditaWriter.beginTag( "section" );
1:ad6d5f1:                 {
1:ad6d5f1:                     processSections( propertiesPW, ditaWriter, sections );
1:ad6d5f1:                 }
1:ad6d5f1:                 ditaWriter.endTag();
1:ad6d5f1:                 
1:ad6d5f1:             }
1:ad6d5f1:             ditaWriter.endTag();
1:ad6d5f1:         }
1:ad6d5f1:         ditaWriter.endTag();
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Loop through sections in the message descriptor file..
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private void    processSections( PrintWriter propertiesPW, XMLWriter ditaWriter, NodeList nodes )
1:ad6d5f1:         throws Exception
1:ad6d5f1:     {
1:ad6d5f1:         int     nodeCount = nodes.getLength();
1:ad6d5f1:         
1:ad6d5f1:         for ( int i = 0; i < nodeCount; i++ )
1:ad6d5f1:         {
1:ad6d5f1:             Element     node = (Element) nodes.item( i );
1:ad6d5f1:             
1:ad6d5f1:             processSection( propertiesPW, ditaWriter, node );
1:ad6d5f1:         }
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Read a section from the message descriptor file.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private void    processSection( PrintWriter propertiesPW, XMLWriter ditaWriter, Element section )
1:ad6d5f1:         throws Exception
1:ad6d5f1:     {
1:ad6d5f1:         boolean     documented = ( getFirstChild( section, "documented" ) != null );
1:ad6d5f1:         NodeList   families = section.getElementsByTagName( "family" );
1:ad6d5f1:         int             familyCount = families.getLength();
1:ad6d5f1: 
1:ad6d5f1:         //
1:ad6d5f1:         // If we don't need to document this section, then we use a vacuous XMLWriter
1:ad6d5f1:         // which NOPs all writes.
1:ad6d5f1:         //
1:ad6d5f1:         if ( !documented ) { ditaWriter = new XMLWriter(); }
1:ad6d5f1: 
1:ad6d5f1:         for ( int i = 0; i < familyCount; i++ )
1:ad6d5f1:         {
1:ad6d5f1:             Element     family = (Element) families.item( i );
1:ad6d5f1:             
1:ad6d5f1:             processFamily( propertiesPW, ditaWriter, family );
1:ad6d5f1:         }
1:ad6d5f1:     }
1:ad6d5f1:     
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Read a family of message descriptors
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private void    processFamily( PrintWriter propertiesPW, XMLWriter ditaWriter, Element family )
1:ad6d5f1:         throws Exception
1:ad6d5f1:     {
1:ad6d5f1:         String        title = squeezeText( getFirstChild( family, "title" ) );
1:ad6d5f1:         NodeList   messages = family.getElementsByTagName( "msg" );
1:ad6d5f1:         int              messageCount = messages.getLength();
1:ad6d5f1: 
1:ad6d5f1:         ditaWriter.beginTag( "table" );
1:ad6d5f1:         {
1:ad6d5f1:             ditaWriter.writeTextElement( "title", title );
1:e3a6365:             ditaWriter.writeTextElement( "desc", "This table lists the SQLStates and message text for the " + title + " exceptions." );
1:ad6d5f1:             
1:ad6d5f1:             ditaWriter.beginTag( "tgroup", "cols=\"2\"" );
1:ad6d5f1:             {
1:9f43523:                 ditaWriter.writeEmptyTag( "colspec", "colname=\"col1\" colnum=\"1\" colwidth=\"1*\"" );
1:9f43523:                 ditaWriter.writeEmptyTag( "colspec", "colname=\"col2\" colnum=\"2\" colwidth=\"7.5*\"" );
1:ad6d5f1: 
1:ad6d5f1:                 ditaWriter.beginTag( "thead" );
1:ad6d5f1:                 {
1:ad6d5f1:                     ditaWriter.beginTag( "row", "valign=\"bottom\"" );
1:ad6d5f1:                     {
1:ad6d5f1:                         ditaWriter.writeTextElement( "entry", "colname=\"col1\"", "SQLSTATE" );
1:ad6d5f1:                         ditaWriter.writeTextElement( "entry", "colname=\"col2\"", "Message Text" );
1:ad6d5f1:                     }
1:ad6d5f1:                     ditaWriter.endTag();
1:ad6d5f1:                 }
1:ad6d5f1:                 ditaWriter.endTag();
1:ad6d5f1: 
1:ad6d5f1:                 ditaWriter.beginTag( "tbody" );
1:ad6d5f1:                 {
1:ad6d5f1:                     for ( int i = 0; i < messageCount; i++ )
1:ad6d5f1:                     {
1:ad6d5f1:                         Element     message = (Element) messages.item( i );
1:ad6d5f1:                         
1:ad6d5f1:                         processMessage( propertiesPW, ditaWriter, message );
1:ad6d5f1:                     }
1:ad6d5f1:                 }
1:ad6d5f1:                 ditaWriter.endTag();
1:ad6d5f1:             }
1:ad6d5f1:             ditaWriter.endTag();
1:ad6d5f1:         }
1:ad6d5f1:         ditaWriter.endTag();
1:ad6d5f1:     }
1:ad6d5f1:     
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Read and process a message.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private void    processMessage( PrintWriter propertiesPW, XMLWriter ditaWriter, Element message )
1:ad6d5f1:         throws Exception
1:ad6d5f1:     {
1:ad6d5f1:         String        name = squeezeText( getFirstChild( message, "name" ) );
1:ad6d5f1:         String        sqlstate = getSQLState( name );
1:ad6d5f1:         String        rawText = squeezeText( getFirstChild( message, "text" ) );
1:ad6d5f1:         String        propertyText = escapePropertiesText( rawText );
1:ad6d5f1:         int             parameterCount = countParameters( rawText );
1:0919fda:         String[]     comments = getOptionalSubElements( message, "comment" );
1:0919fda:         String[]     args = getOptionalSubElements( message, "arg" );
1:ad6d5f1: 
1:ad6d5f1:         if ( parameterCount != args.length )
1:ad6d5f1:         {
1:ad6d5f1:             throw new Exception( name + " has " + parameterCount + " parameters but " + args.length + " nested args." );
1:ad6d5f1:         }
1:ad6d5f1: 
1:77d8980:         String displayText;
1:77d8980:         if (rawText.indexOf('\'')>=0)
1:77d8980:         {
1:77d8980:             displayText = replaceSpecialChars( escapeTextWithAQuote( rawText ) );
1:77d8980:             displayText = plugInArgs( displayText , args );
1:77d8980:         }
1:77d8980:         else
1:77d8980:         {
1:77d8980:             displayText = plugInArgs( replaceSpecialChars( rawText), args ) ;
1:77d8980:         }
1:ad6d5f1: 
1:ad6d5f1:         ditaWriter.beginTag( "row" );
1:ad6d5f1:         {
1:ad6d5f1:             ditaWriter.writeTextElement( "entry", "colname=\"col1\"", sqlstate );
1:ad6d5f1:             ditaWriter.writeTextElement( "entry", "colname=\"col2\"", displayText );
1:ad6d5f1:         }
1:ad6d5f1:         ditaWriter.endTag();
1:7e9a11d: 
1:7e9a11d:         propertiesPW.println( "" );
1:0919fda:         
1:0919fda:         if ( comments.length != 0 )
1:0919fda:         {
1:0919fda:             for ( int i = 0; i < comments.length; i++ )
1:0919fda:             {
1:0919fda:                 propertiesPW.println( "# " + comments[ i ] );
1:0919fda:             }
1:0919fda:             propertiesPW.println( "#" );
1:0919fda:         }
1:0919fda:         
1:7e9a11d:         if ( args.length != 0 )
1:7e9a11d:         {
1:7e9a11d:             propertiesPW.println( "# Arguments:" );
1:7e9a11d:             propertiesPW.println( "#" );
1:7e9a11d:             for ( int i = 0; i < args.length; i++ )
1:7e9a11d:             {
1:526b9ed:                 propertiesPW.println( "#    {" + i + "} = " + args[ i ] );
1:7e9a11d:             }
1:7e9a11d:             propertiesPW.println( "#" );
1:7e9a11d:         }
1:ad6d5f1:         propertiesPW.println( name + "=" + propertyText );
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Convert a message handle into a SQLState, stripping off trailing
1:ad6d5f1:      * encodings as necessary.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private String  getSQLState( String name )
1:ad6d5f1:     {
1:ad6d5f1:         if ( name.length() <= 5 ) { return name; }
1:ad6d5f1:         else { return name.substring( 0, 5 ); }
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:0919fda:      * Get some optional sub-elements.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:0919fda:     private String[]    getOptionalSubElements( Element message, String subElementTag )
1:ad6d5f1:         throws Exception
1:ad6d5f1:     {
1:0919fda:         NodeList   options = message.getElementsByTagName( subElementTag );
1:0919fda:         int             count = options.getLength();
1:0919fda:         String[]    retval = new String[ count ];
1:ad6d5f1: 
1:0919fda:         for ( int i = 0; i < count; i++ )
1:ad6d5f1:         {
1:0919fda:             Element     option = (Element) options.item( i );
1:ad6d5f1:             
1:0919fda:             retval[ i ] = squeezeText( option );
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         return retval;
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Count the substitutable arguments in an internationalized message string.
1:ad6d5f1:      * These arguments have the form {n} where n is a number.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private int countParameters( String text )
1:ad6d5f1:     {
1:ad6d5f1:         int     argCount = 0;
1:ad6d5f1:         int     argIdx = 0;
1:ad6d5f1: 
1:ad6d5f1:         while( true )
1:ad6d5f1:         {
1:ad6d5f1:             argIdx = text.indexOf( '{', argIdx );
1:ad6d5f1: 
1:ad6d5f1:             if ( argIdx >= 0 )
1:ad6d5f1:             {
1:ad6d5f1:                 argCount++;
1:ad6d5f1:                 argIdx++;
1:ad6d5f1:             }
1:ad6d5f1:             else { break; }
1:ad6d5f1:         }
1:ad6d5f1: 
1:ad6d5f1:         return argCount;
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Plug arg values into parameter slots in an internationalizable message
1:ad6d5f1:      * string.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private String  plugInArgs( String message, String[] rawArgs )
1:ad6d5f1:     {
1:ad6d5f1:         int             count = rawArgs.length;
1:ad6d5f1:         String[]    cookedArgs = new String[ count ];
1:df9ed37:         MessageFormat format = new MessageFormat(message);
1:ad6d5f1: 
1:ad6d5f1:         // add xml angle brackets around the args
1:ad6d5f1:         for ( int i = 0; i < count; i++ )
1:ad6d5f1:         {
1:77d8980:             cookedArgs[ i ] = "<varname>&lt;" + rawArgs[ i ] + "&gt;</varname>";
1:df9ed37:             format.setFormatByArgumentIndex(i, null); // use plain string format
1:ad6d5f1:         }
1:ad6d5f1: 
1:df9ed37:         return format.format(cookedArgs);
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1:     //
1:ad6d5f1:     //  GENERALLY USEFUL MINIONS
1:ad6d5f1:     //
1:ad6d5f1:     /////////////////////////////////////////////////////////////////////////
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Echo a message to the console.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private void    echo( String text )
1:ad6d5f1:     {
1:ad6d5f1:         log( text, Project.MSG_WARN );
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Flush and close file writers.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private void    finishWriting( FileWriter fw, PrintWriter pw )
1:ad6d5f1:         throws IOException
1:ad6d5f1:     {
1:ad6d5f1:         if ( (fw == null) || (pw == null) ) { return; }
1:ad6d5f1:         
1:ad6d5f1:         pw.flush();
1:ad6d5f1:         fw.flush();
1:ad6d5f1: 
1:ad6d5f1:         pw.close();
1:ad6d5f1:         fw.close();
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     ////////////////////////////////////////////////////////
1:ad6d5f1:     //
1:ad6d5f1:     // XML MINIONS
1:ad6d5f1:     //
1:ad6d5f1:     ////////////////////////////////////////////////////////
1:ad6d5f1: 
1:ad6d5f1:     private Element getFirstChild( Element node, String childName )
1:ad6d5f1:         throws Exception
1:ad6d5f1:     {
1:ad6d5f1:         return (Element) node.getElementsByTagName( childName ).item( 0 );
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Squeeze the text out of an Element.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private String squeezeText( Element node )
1:ad6d5f1:         throws Exception
1:ad6d5f1:     {
1:ad6d5f1:         Node        textChild = node.getFirstChild();
1:ad6d5f1:         String      text = textChild.getNodeValue();
1:ad6d5f1: 
1:ad6d5f1:         return text;
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1:     /**
1:ad6d5f1:      * Replace a substring with some equivalent. For example, we would
1:c6892a1:      * like to replace "&lt;" with "&amp;lt;" in the error messages.
1:ad6d5f1:      * Add any substrings you would like to replace in the code below.
1:c6892a1:      * Be aware that the first parameter to the replaceAll() method is
1:ad6d5f1:      * interpreted as a regular expression.
1:ad6d5f1:      *
1:ad6d5f1:      * @param input 
1:ad6d5f1:      *      A String that may contain substrings that we want to replace
1:ad6d5f1:      * @return 
1:ad6d5f1:      *      Output String where substrings selected for replacement have been
1:ad6d5f1:      *      replaced.
1:ad6d5f1:      * @see java.util.regex.Pattern
1:ad6d5f1:      */
1:ad6d5f1:     private static String replaceSpecialChars(java.lang.String input) {
1:ad6d5f1:         String output = input.replaceAll("<", "&lt;");
1:ad6d5f1:         output = output.replaceAll(">", "&gt;");
1:ad6d5f1:         
1:ad6d5f1:         return output;
1:ad6d5f1:     }
1:ad6d5f1: 
1:77d8980: 
1:ad6d5f1:     /**
1:ad6d5f1:      * <p>
1:ad6d5f1:      * Replace newlines with the escape sequence needed by properties files.
1:ad6d5f1:      * Also, replace single quotes with two single quotes.
1:ad6d5f1:      * </p>
1:ad6d5f1:      */
1:ad6d5f1:     private static String escapePropertiesText( java.lang.String input )
1:ad6d5f1:     {
1:ad6d5f1:         String output = input.replaceAll( "\n", "\\\\n" );
1:ad6d5f1: 
1:ad6d5f1:         output = output.replaceAll( "\'", "\'\'" );
1:ad6d5f1:         
1:ad6d5f1:         return output;
1:ad6d5f1:     }
1:ad6d5f1: 
1:77d8980:     /**
1:77d8980:      * <p>
1:77d8980:      * Replace single quotes with two single quotes.
1:77d8980:      * Only needed when there are parameters with quotes.
1:77d8980:      * </p>
1:77d8980:      */
1:77d8980:     private static String escapeTextWithAQuote( java.lang.String input )
1:77d8980:     {
1:77d8980:         String output = input.replaceAll( "\'", "\'\'" );
1:ad6d5f1:         
1:77d8980:         return output;
1:ad6d5f1:     }
1:ad6d5f1: 
1:ad6d5f1: 
1:77d8980: 
1:77d8980: }
1:77d8980: 
============================================================================
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1:      * like to replace "&lt;" with "&amp;lt;" in the error messages.
1:      * Be aware that the first parameter to the replaceAll() method is
commit:38b9499
/////////////////////////////////////////////////////////////////////////
1:         private         ArrayList<String>    _tagStack;
/////////////////////////////////////////////////////////////////////////
1:             _tagStack = new ArrayList<String>();
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:526b9ed
/////////////////////////////////////////////////////////////////////////
1:                 propertiesPW.println( "#    {" + i + "} = " + args[ i ] );
commit:0919fda
/////////////////////////////////////////////////////////////////////////
1:         String[]     comments = getOptionalSubElements( message, "comment" );
1:         String[]     args = getOptionalSubElements( message, "arg" );
/////////////////////////////////////////////////////////////////////////
1:         
1:         if ( comments.length != 0 )
1:         {
1:             for ( int i = 0; i < comments.length; i++ )
1:             {
1:                 propertiesPW.println( "# " + comments[ i ] );
1:             }
1:             propertiesPW.println( "#" );
1:         }
1:         
/////////////////////////////////////////////////////////////////////////
1:      * Get some optional sub-elements.
1:     private String[]    getOptionalSubElements( Element message, String subElementTag )
1:         NodeList   options = message.getElementsByTagName( subElementTag );
1:         int             count = options.getLength();
1:         String[]    retval = new String[ count ];
1:         for ( int i = 0; i < count; i++ )
1:             Element     option = (Element) options.item( i );
1:             retval[ i ] = squeezeText( option );
commit:870f7cd
/////////////////////////////////////////////////////////////////////////
1:             throw new BuildException( "Could not generate English properties from message descriptors: " + e.getMessage(), e );
commit:7e9a11d
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 
1:         propertiesPW.println( "" );
1:         if ( args.length != 0 )
1:         {
1:             propertiesPW.println( "# Arguments:" );
1:             propertiesPW.println( "#" );
1:             for ( int i = 0; i < args.length; i++ )
1:             {
0:                 propertiesPW.println( "#    " + args[ i ] );
1:             }
1:             propertiesPW.println( "#" );
1:         }
commit:e3a6365
/////////////////////////////////////////////////////////////////////////
1:             ditaWriter.writeTextElement( "desc", "This table lists the SQLStates and message text for the " + title + " exceptions." );
commit:9f43523
/////////////////////////////////////////////////////////////////////////
1:                 ditaWriter.writeEmptyTag( "colspec", "colname=\"col1\" colnum=\"1\" colwidth=\"1*\"" );
1:                 ditaWriter.writeEmptyTag( "colspec", "colname=\"col2\" colnum=\"2\" colwidth=\"7.5*\"" );
commit:ad6d5f1
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1:    Derby - Class org.apache.derbyBuild.MessageBuilder
1: 
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to You under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
1: 
1:  */
1: 
1: package org.apache.derbyBuild;
1: 
1: import java.io.File;
1: import java.io.FileWriter;
1: import java.io.IOException;
1: import java.io.PrintWriter;
1: import java.text.MessageFormat;
1: import java.util.ArrayList;
1: import javax.xml.parsers.*;
1: import org.w3c.dom.*;
1: 
1: import org.apache.tools.ant.BuildException;
1: import org.apache.tools.ant.Project;
1: import org.apache.tools.ant.Task;
0: import org.apache.tools.ant.taskdefs.Echo;
1: 
1: 
1: /**
1:  * <p>
1:  * This tool generates the engine's message strings (message_en.properties) as well
1:  * the dita source for the SQLState documentation in the Derby Reference Guide.
1:  * </p>
1:  */
1: public class MessageBuilder extends Task
1: {
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  CONSTANTS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     private static  final   String  TAB_STOP = "    ";
1:     
1:     private static  final   String  PROPERTIES_BOILERPLATE =
1:         "###################################################\n" +
1:         "#\n" +
1:         "# Licensed to the Apache Software Foundation (ASF) under one or more\n" +
1:         "# contributor license agreements.  See the NOTICE file distributed with\n" +
1:         "# this work for additional information regarding copyright ownership.\n" +
1:         "# The ASF licenses this file to You under the Apache License, Version 2.0\n" +
1:         "# (the \"License\"); you may not use this file except in compliance with\n" +
1:         "# the License.  You may obtain a copy of the License at\n" +
1:         "#\n" +
1:         "#     http://www.apache.org/licenses/LICENSE-2.0\n" +
1:         "#\n" +
1:         "# Unless required by applicable law or agreed to in writing, software\n" +
1:         "# distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
1:         "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
1:         "# See the License for the specific language governing permissions and\n" +
1:         "# limitations under the License.\n" +
1:         "#\n" +
1:         "###################################################\n" +
1:         "\n" +
1:         "###################################################\n" +
1:         "#\n" +
1:         "# DO NOT EDIT THIS FILE!\n" +
1:         "#\n" +
1:         "# Instead, edit messages.xml. The ant MessageBuilder task takes\n" +
1:         "# messages.xml as input and from it generates this file.\n" +
1:         "#\n" +
1:         "###################################################\n";
1: 
1:     private static  final   String  REF_GUIDE_BOILERPLATE =
1:         "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
1:         "<!DOCTYPE reference PUBLIC \"-//OASIS//DTD DITA Reference//EN\"\n" +
0:         " \"../../derby/docs/trunk/src/dtd/reference.dtd\">\n";
1: 
1:     private static  final   String  REF_GUIDE_NOTES =
1:         "<!-- \n" +
1:         "Licensed to the Apache Software Foundation (ASF) under one or more\n" +
1:         "contributor license agreements.  See the NOTICE file distributed with\n" +
1:         "this work for additional information regarding copyright ownership.\n" +
1:         "The ASF licenses this file to You under the Apache License, Version 2.0\n" +
1:         "(the \"License\"); you may not use this file except in compliance with\n" +
1:         "the License.  You may obtain a copy of the License at      \n" +
1:         "\n" +
1:         "http://www.apache.org/licenses/LICENSE-2.0  \n" +
1:         "\n" +
1:         "Unless required by applicable law or agreed to in writing, software  \n" +
1:         "distributed under the License is distributed on an \"AS IS\" BASIS,  \n" +
1:         "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  \n" +
1:         "See the License for the specific language governing permissions and  \n" +
1:         "limitations under the License.\n" +
1:         "-->\n" +
1:         "\n" +
1:         "<!-- \n" +
1:         "NOTE: this file is generated by the MessageBuilder task as part of a\n" +
1:         "Derby build. Please do not hand-edit this file. Instead, please edit\n" +
0:         "the corresponding text in MessageBuilder.\n" +
1:         "-->\n";
1:     
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  STATE
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     private String  _xmlSourceFile;
1:     private String  _propertiesTargetFile;
1:     private String  _ditaTargetFile;
1: 
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  INNER CLASSES
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * XML-wrigint wrapper around a PrintWriter.
1:      * </p>
1:      */
1:     public  static  final   class   XMLWriter
1:     {
1:         // If this boolean is set, then all operations are NOPs.
1:         private         boolean       _vacuous;
1:         
1:         private         FileWriter   _fw;
1:         private         PrintWriter _pw;
0:         private         ArrayList    _tagStack;
1: 
1:         /**
1:          * <p>
1:          * Special constructor for making a vacuous writer which doesn't do
1:          * anything. This allows us to write easy-to-read dita-generating code
1:          * that is not cluttered with "if ( documented )" conditionals.
1:          * </p>
1:          */
1:         public  XMLWriter()
1:         {
1:             _vacuous = true;
1:          }
1: 
1:         /**
1:          * <p>
1:          * Create a productive writer which actually flushes text to disk.
1:          * </p>
1:          */
1:         public  XMLWriter( File file )
1:             throws IOException
1:         {
1:             _vacuous = false;
1:             _fw = new FileWriter( file );
1:             _pw = new PrintWriter( _fw );
0:             _tagStack = new ArrayList();
1:         }
1: 
1:         public  void    flush() throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1:             
1:             _pw.flush();
1:             _fw.flush();
1:         }
1:         
1:         public  void    close() throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             _pw.close();
1:             _fw.close();
1:         }
1: 
1:         /**
1:          * <p>
1:          * Indent and write an empty tag.
1:          * </p>
1:          */
1:         public void    writeEmptyTag( String tag )
1:             throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             writeEmptyTag( tag, "" );
1:         }
1: 
1:         /**
1:          * <p>
1:          * Indent and write an empty tag with attributes.
1:          * </p>
1:          */
1:         public void    writeEmptyTag( String tag, String attributes )
1:             throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             indent( );
0:             _pw.println( "<" + tag + " " + attributes + " />");
1:         }
1: 
1:         /**
1:          * <p>
1:          * Indent and write an opening tag.
1:          * </p>
1:          */
1:         public void    beginTag( String tag )
1:             throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             beginTag( tag, "" );
1:         }
1: 
1:         /**
1:          * <p>
1:          * Indent and write an opening tag.
1:          * </p>
1:          */
1:         public void    beginTag( String tag, String attributes )
1:             throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             indent();
0:             _pw.println( "<" + tag + " " + attributes + " >");
1: 
1:             _tagStack.add( tag );
1:         }
1: 
1:         /**
1:          * <p>
1:          * Indent and write a closing tag.
1:          * </p>
1:          */
1:         public void    endTag()
1:             throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             String  tag = (String) _tagStack.remove( _tagStack.size() -1 );
1:         
1:             indent();
1: 
1:             _pw.println( "</" + tag + ">");
1:         }
1: 
1:         /**
1:          * <p>
1:          * Indent and write a whole element
1:          * </p>
1:          */
1:         public void    writeTextElement( String tag, String text )
1:             throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             writeTextElement( tag, "", text );
1:         }
1: 
1:         /**
1:          * <p>
1:          * Indent and write a whole element
1:          * </p>
1:          */
1:         public void    writeTextElement( String tag, String attributes, String text )
1:             throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             indent();
0:             _pw.print( "<" + tag + " " + attributes + " >");
1:             _pw.print( text );
1:             _pw.println( "</" + tag + ">");
1:         }
1: 
1:         /**
1:          * <p>
1:          * Indent based on the depth of our tag nesting level.
1:          * </p>
1:          */
1:         public void    indent()
1:             throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             int     tabCount = _tagStack.size();
1: 
1:             for ( int i = 0; i < tabCount; i++ ) { _pw.write( TAB_STOP ); }
1:         }
1: 
1:                 /**
1:          * <p>
1:          * Print text.
1:          * </p>
1:          */
1:         public void    println( String text )
1:             throws IOException
1:         {
1:             if ( _vacuous ) { return; }
1: 
1:             _pw.println( text );
1:         }
1: 
1:     }
1:     
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  CONSTRUCTORS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:    /**
1:      * <p>
1:      * Let Ant conjure us out of thin air.
1:      * </p>
1:      */
1:     public MessageBuilder()
1:     {}
1:     
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  Task BEHAVIOR
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:         
1:     /** <p>Let Ant set the input file name.</p>*/
1:     public void setXmlSourceFile( String fileName ) { _xmlSourceFile = fileName;}
1: 
1:     /** <p>Let Ant set the file name for the message property file we will write.</p>*/
1:     public void setPropertiesTargetFile( String fileName ) { _propertiesTargetFile = fileName;}
1: 
1:     /** <p>Let Ant set the file name for the SQLState dita file we will write.</p>*/
1:     public void setDitaTargetFile( String fileName ) { _ditaTargetFile = fileName;}
1:         
1:    /**
1:      * <p>
1:      * Read the xml message descriptors and output messages_en.properties
1:      * and the dita source for the SQLState table in the Derby Reference Guide.
1:      * After setting up arguments using the above setter methods, Ant
1:      * calls this method in order to run this custom task.
1:      * </p>
1:      */
1:     public  void    execute()
1:         throws BuildException
1:     {
1:         File                 source = new File( _xmlSourceFile );
1:         File                 targetProperties = new File( _propertiesTargetFile );
1:         File                 targetDita = new File( _ditaTargetFile );
1:         FileWriter      propertiesFW = null;
1:         PrintWriter    propertiesPW = null;
1:         XMLWriter    ditaWriter = null;
1: 
1:         try {
1:             propertiesFW = new FileWriter( targetProperties );
1:             propertiesPW = new PrintWriter( propertiesFW );
1:             ditaWriter = new XMLWriter( targetDita );
1: 
1:             processMessages( source, propertiesPW, ditaWriter );
1:         }
1:         catch (Exception e)
1:         {
0:             throw new BuildException( "Could not generate English properties from message descriptors.", e );
1:         }
1:         finally
1:         {
1:             try {
1:                 finishWriting( propertiesFW, propertiesPW );
1: 
1:                 if ( ditaWriter != null )
1:                 {
1:                     ditaWriter.flush();
1:                     ditaWriter.close();
1:                 }
1:             }
1:             catch (Exception ex)
1:             {
1:                 throw new BuildException( "Error closing file writers.", ex );
1:             }
1:         }
1:         
1:     }
1: 
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  MINIONS TO PROCESS MESSAGE DESCRIPTORS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Loop through descriptors and write appropriate output to the properties
1:      * and dita files.
1:      * </p>
1:      */
1:     private void    processMessages( File input, PrintWriter propertiesPW, XMLWriter ditaWriter )
1:         throws Exception
1:     {
1:         DocumentBuilderFactory  factory = DocumentBuilderFactory.newInstance();
1:         DocumentBuilder              builder = factory.newDocumentBuilder();
1:         Document                          doc = builder.parse( input );
1:         Element                             root = doc.getDocumentElement();    // framing "messages" element
1:         NodeList                            sections = root.getElementsByTagName( "section" );             
1: 
1:         propertiesPW.println( PROPERTIES_BOILERPLATE );
1:         ditaWriter.println( REF_GUIDE_BOILERPLATE );
1: 
1:         ditaWriter.beginTag( "reference", "id=\"rrefexcept71493\" xml:lang=\"en-us\""  );
1:         {
1:             ditaWriter.println( REF_GUIDE_NOTES );
1:             ditaWriter.writeTextElement( "title", "SQL error messages and exceptions" );
1: 
1:             ditaWriter.beginTag( "refbody" );
1:             {
1:                 ditaWriter.beginTag( "section" );
1:                 {
1:                     ditaWriter.writeTextElement
1:                         (
1:                          "p",
1:                          "The following tables list <i>SQLStates</i> for exceptions. Exceptions " +
0:                          "that begin with an <i>X</i> are specific to <ph conref=\"refconrefs.dita#prod/productshortname\"></ph>."
1:                          );
1:                 }
1:                 ditaWriter.endTag();
1:                 
1:                 ditaWriter.beginTag( "section" );
1:                 {
1:                     processSections( propertiesPW, ditaWriter, sections );
1:                 }
1:                 ditaWriter.endTag();
1:                 
1:             }
1:             ditaWriter.endTag();
1:         }
1:         ditaWriter.endTag();
1:     }
1: 
1:     /**
1:      * <p>
1:      * Loop through sections in the message descriptor file..
1:      * </p>
1:      */
1:     private void    processSections( PrintWriter propertiesPW, XMLWriter ditaWriter, NodeList nodes )
1:         throws Exception
1:     {
1:         int     nodeCount = nodes.getLength();
1:         
1:         for ( int i = 0; i < nodeCount; i++ )
1:         {
1:             Element     node = (Element) nodes.item( i );
1:             
1:             processSection( propertiesPW, ditaWriter, node );
1:         }
1:     }
1: 
1:     /**
1:      * <p>
1:      * Read a section from the message descriptor file.
1:      * </p>
1:      */
1:     private void    processSection( PrintWriter propertiesPW, XMLWriter ditaWriter, Element section )
1:         throws Exception
1:     {
1:         boolean     documented = ( getFirstChild( section, "documented" ) != null );
1:         NodeList   families = section.getElementsByTagName( "family" );
1:         int             familyCount = families.getLength();
1: 
1:         //
1:         // If we don't need to document this section, then we use a vacuous XMLWriter
1:         // which NOPs all writes.
1:         //
1:         if ( !documented ) { ditaWriter = new XMLWriter(); }
1: 
1:         for ( int i = 0; i < familyCount; i++ )
1:         {
1:             Element     family = (Element) families.item( i );
1:             
1:             processFamily( propertiesPW, ditaWriter, family );
1:         }
1:     }
1:     
1:     /**
1:      * <p>
1:      * Read a family of message descriptors
1:      * </p>
1:      */
1:     private void    processFamily( PrintWriter propertiesPW, XMLWriter ditaWriter, Element family )
1:         throws Exception
1:     {
1:         String        title = squeezeText( getFirstChild( family, "title" ) );
1:         NodeList   messages = family.getElementsByTagName( "msg" );
1:         int              messageCount = messages.getLength();
1: 
1:         ditaWriter.beginTag( "table" );
1:         {
1:             ditaWriter.writeTextElement( "title", title );
1:             
1:             ditaWriter.beginTag( "tgroup", "cols=\"2\"" );
1:             {
0:                 ditaWriter.writeEmptyTag( "colspec", "colname=\"col1\" colwidth=\"1*\"" );
0:                 ditaWriter.writeEmptyTag( "colspec", "colname=\"col2\" colwidth=\"7.5*\"" );
1: 
1:                 ditaWriter.beginTag( "thead" );
1:                 {
1:                     ditaWriter.beginTag( "row", "valign=\"bottom\"" );
1:                     {
1:                         ditaWriter.writeTextElement( "entry", "colname=\"col1\"", "SQLSTATE" );
1:                         ditaWriter.writeTextElement( "entry", "colname=\"col2\"", "Message Text" );
1:                     }
1:                     ditaWriter.endTag();
1:                 }
1:                 ditaWriter.endTag();
1: 
1:                 ditaWriter.beginTag( "tbody" );
1:                 {
1:                     for ( int i = 0; i < messageCount; i++ )
1:                     {
1:                         Element     message = (Element) messages.item( i );
1:                         
1:                         processMessage( propertiesPW, ditaWriter, message );
1:                     }
1:                 }
1:                 ditaWriter.endTag();
1:             }
1:             ditaWriter.endTag();
1:         }
1:         ditaWriter.endTag();
1:     }
1:     
1:     /**
1:      * <p>
1:      * Read and process a message.
1:      * </p>
1:      */
1:     private void    processMessage( PrintWriter propertiesPW, XMLWriter ditaWriter, Element message )
1:         throws Exception
1:     {
1:         String        name = squeezeText( getFirstChild( message, "name" ) );
1:         String        sqlstate = getSQLState( name );
1:         String        rawText = squeezeText( getFirstChild( message, "text" ) );
1:         String        propertyText = escapePropertiesText( rawText );
1:         int             parameterCount = countParameters( rawText );
0:         String[]     args = getArgs( message );
0:         String       displayText = replaceSpecialChars( plugInArgs( rawText, args ) );
1: 
1:         if ( parameterCount != args.length )
1:         {
1:             throw new Exception( name + " has " + parameterCount + " parameters but " + args.length + " nested args." );
1:         }
1: 
1:         ditaWriter.beginTag( "row" );
1:         {
1:             ditaWriter.writeTextElement( "entry", "colname=\"col1\"", sqlstate );
1:             ditaWriter.writeTextElement( "entry", "colname=\"col2\"", displayText );
1:         }
1:         ditaWriter.endTag();
1:         
1:         propertiesPW.println( name + "=" + propertyText );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Convert a message handle into a SQLState, stripping off trailing
1:      * encodings as necessary.
1:      * </p>
1:      */
1:     private String  getSQLState( String name )
1:     {
1:         if ( name.length() <= 5 ) { return name; }
1:         else { return name.substring( 0, 5 ); }
1:     }
1: 
1:     /**
1:      * <p>
0:      * Get all of the human-readable parameter names out of the message element.
1:      * </p>
1:      */
0:     private String[]    getArgs( Element message )
1:         throws Exception
1:     {
0:         NodeList   args = message.getElementsByTagName( "arg" );
0:         int             argCount = args.getLength();
0:         String[]    retval = new String[ argCount ];
1: 
0:         for ( int i = 0; i < argCount; i++ )
1:         {
0:             Element     arg = (Element) args.item( i );
1:             
0:             retval[ i ] = squeezeText( arg );
1:         }
1: 
1:         return retval;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Count the substitutable arguments in an internationalized message string.
1:      * These arguments have the form {n} where n is a number.
1:      * </p>
1:      */
1:     private int countParameters( String text )
1:     {
1:         int     argCount = 0;
1:         int     argIdx = 0;
1: 
1:         while( true )
1:         {
1:             argIdx = text.indexOf( '{', argIdx );
1: 
1:             if ( argIdx >= 0 )
1:             {
1:                 argCount++;
1:                 argIdx++;
1:             }
1:             else { break; }
1:         }
1: 
1:         return argCount;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Plug arg values into parameter slots in an internationalizable message
1:      * string.
1:      * </p>
1:      */
1:     private String  plugInArgs( String message, String[] rawArgs )
1:     {
1:         int             count = rawArgs.length;
1:         String[]    cookedArgs = new String[ count ];
1: 
1:         // add xml angle brackets around the args
1:         for ( int i = 0; i < count; i++ )
1:         {
0:             cookedArgs[ i ] = "&lt;" + rawArgs[ i ] + "&gt;";
1:         }
1: 
0:         return MessageFormat.format( message, cookedArgs );
1:     }
1: 
1:     /////////////////////////////////////////////////////////////////////////
1:     //
1:     //  GENERALLY USEFUL MINIONS
1:     //
1:     /////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * <p>
1:      * Echo a message to the console.
1:      * </p>
1:      */
1:     private void    echo( String text )
1:     {
1:         log( text, Project.MSG_WARN );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Flush and close file writers.
1:      * </p>
1:      */
1:     private void    finishWriting( FileWriter fw, PrintWriter pw )
1:         throws IOException
1:     {
1:         if ( (fw == null) || (pw == null) ) { return; }
1:         
1:         pw.flush();
1:         fw.flush();
1: 
1:         pw.close();
1:         fw.close();
1:     }
1: 
1:     ////////////////////////////////////////////////////////
1:     //
1:     // XML MINIONS
1:     //
1:     ////////////////////////////////////////////////////////
1: 
1:     private Element getFirstChild( Element node, String childName )
1:         throws Exception
1:     {
1:         return (Element) node.getElementsByTagName( childName ).item( 0 );
1:     }
1: 
1:     /**
1:      * <p>
1:      * Squeeze the text out of an Element.
1:      * </p>
1:      */
1:     private String squeezeText( Element node )
1:         throws Exception
1:     {
1:         Node        textChild = node.getFirstChild();
1:         String      text = textChild.getNodeValue();
1: 
1:         return text;
1:     }
1: 
1:     /**
1:      * Replace a substring with some equivalent. For example, we would
0:      * like to replace "<" with "&lt;" in the error messages.
1:      * Add any substrings you would like to replace in the code below.
0:      * Be aware that the first paramter to the replaceAll() method is
1:      * interpreted as a regular expression.
1:      *
1:      * @param input 
1:      *      A String that may contain substrings that we want to replace
1:      * @return 
1:      *      Output String where substrings selected for replacement have been
1:      *      replaced.
1:      * @see java.util.regex.Pattern
1:      */
1:     private static String replaceSpecialChars(java.lang.String input) {
1:         String output = input.replaceAll("<", "&lt;");
1:         output = output.replaceAll(">", "&gt;");
1:         
1:         return output;
1:     }
1: 
1:     /**
1:      * <p>
1:      * Replace newlines with the escape sequence needed by properties files.
1:      * Also, replace single quotes with two single quotes.
1:      * </p>
1:      */
1:     private static String escapePropertiesText( java.lang.String input )
1:     {
1:         String output = input.replaceAll( "\n", "\\\\n" );
1: 
1:         output = output.replaceAll( "\'", "\'\'" );
1:         
1:         return output;
1:     }
1: 
1: 
1: 
1: }
1: 
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:53c9376
/////////////////////////////////////////////////////////////////////////
commit:df9ed37
/////////////////////////////////////////////////////////////////////////
0: import java.util.regex.Matcher;
0: import java.util.regex.Pattern;
/////////////////////////////////////////////////////////////////////////
1:         MessageFormat format = new MessageFormat(message);
1:             format.setFormatByArgumentIndex(i, null); // use plain string format
1:         return format.format(cookedArgs);
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:2acb99a
/////////////////////////////////////////////////////////////////////////
1:                          "that begin with an <i>X</i> are specific to <ph conref=\"../conrefs.dita#prod/productshortname\"></ph>."
commit:a396cb1
/////////////////////////////////////////////////////////////////////////
1:         " \"../dtd/reference.dtd\">\n";
/////////////////////////////////////////////////////////////////////////
1:         "the corresponding text in messages.xml and/or MessageBuilder.\n" +
/////////////////////////////////////////////////////////////////////////
1:             if ( attributes.length() >0)
1:                 _pw.println( "<" + tag + " " + attributes + "/>");
1:             else
1:                 _pw.println( "<" + tag + "/>");
/////////////////////////////////////////////////////////////////////////
1:             if (attributes.length() > 0)
1:                 _pw.println( "<" + tag + " " + attributes + ">");
1:             else
1:                 _pw.println( "<" + tag + ">");
/////////////////////////////////////////////////////////////////////////
1:             if ( attributes.length() > 0 )
1:                 _pw.print( "<" + tag + " " + attributes + ">");
1:             else
1:                 _pw.print( "<" + tag + ">");
commit:77d8980
/////////////////////////////////////////////////////////////////////////
1:         String displayText;
1:         if (rawText.indexOf('\'')>=0)
1:         {
1:             displayText = replaceSpecialChars( escapeTextWithAQuote( rawText ) );
1:             displayText = plugInArgs( displayText , args );
1: 
1:         }
1:         else
1:         {
1:             displayText = plugInArgs( replaceSpecialChars( rawText), args ) ;
1:         }
1: 
/////////////////////////////////////////////////////////////////////////
1:             cookedArgs[ i ] = "<varname>&lt;" + rawArgs[ i ] + "&gt;</varname>";
/////////////////////////////////////////////////////////////////////////
1: 
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * <p>
1:      * Replace single quotes with two single quotes.
1:      * Only needed when there are parameters with quotes.
1:      * </p>
1:      */
1:     private static String escapeTextWithAQuote( java.lang.String input )
1:     {
1:         String output = input.replaceAll( "\'", "\'\'" );
0:         
1:         return output;
1:     }
0: 
============================================================================