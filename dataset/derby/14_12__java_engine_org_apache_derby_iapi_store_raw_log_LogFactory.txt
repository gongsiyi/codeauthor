3:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.store.raw.log.LogFactory
1:7ecc1f2: 
1:75c7276:    Licensed to the Apache Software Foundation (ASF) under one or more
1:75c7276:    contributor license agreements.  See the NOTICE file distributed with
1:75c7276:    this work for additional information regarding copyright ownership.
1:75c7276:    The ASF licenses this file to you under the Apache License, Version 2.0
1:75c7276:    (the "License"); you may not use this file except in compliance with
1:75c7276:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
18:eac0369: 
8:eac0369:  */
1:32635d2: 
1:eac0369: package org.apache.derby.iapi.store.raw.log;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: import org.apache.derby.iapi.services.property.PersistentSet;
1:1bac3f3: import org.apache.derby.iapi.store.replication.master.MasterFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.data.DataFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.Corruptable;
1:eac0369: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1:eac0369: import org.apache.derby.iapi.store.raw.ScanHandle;
1:eac0369: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
1:eac0369: import org.apache.derby.io.StorageFile;
1:eac0369: import org.apache.derby.iapi.store.access.DatabaseInstant;
1:eac0369: import org.apache.derby.iapi.reference.Property;
1:eac0369: import java.io.File;
1:eac0369: 
1:eac0369: public interface LogFactory extends Corruptable {
1:eac0369: 
1:32635d2: 	/**
1:eac0369: 		The name of a runtime property in the service set that defines any runtime
1:eac0369: 		attributes a log factory should have. It is (or will be) a comma separated list
1:eac0369: 		of attributes.
1:eac0369: 		At the moment only one attribute is known and checked for.
1:eac0369: 	*/
1:eac0369: 	public static final String RUNTIME_ATTRIBUTES = Property.PROPERTY_RUNTIME_PREFIX + "storage.log";
1:eac0369: 
7:eac0369: 	/**
1:eac0369: 		An attribute that indicates the database is readonly
1:eac0369: 	*/
1:eac0369: 	public static final String RT_READONLY = "readonly";
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		The name of the default log directory.
1:eac0369: 	 */
1:eac0369: 	public static final String LOG_DIRECTORY_NAME = "log";
1:eac0369: 
1:eac0369: 
1:eac0369: 
1:eac0369: 	public static final String MODULE = "org.apache.derby.iapi.store.raw.log.LogFactory";
1:eac0369: 
1:eac0369: 	public Logger getLogger();
1:eac0369: 
1:9496f49:     /**
1:9496f49:      * Create readme file in log directory warning users against touching
1:9496f49:      *  any files in the directory
1:9496f49:      * @throws StandardException
1:9496f49:      */
1:9496f49:     public void createDataWarningFile() throws StandardException;
1:9496f49: 
1:eac0369: 	/**
1:9cc8ad0: 		Make log factory aware of which raw store factory it belongs to
1:9cc8ad0: 	*/
1:9cc8ad0: 	public void setRawStoreFactory(RawStoreFactory rsf);
1:9cc8ad0: 
1:9cc8ad0: 	/**
1:eac0369: 		Recover the database to a consistent state using the log. 
1:eac0369: 		Each implementation of the log factory has its own recovery algorithm,
1:eac0369: 		please see the implementation for a description of the specific
1:eac0369: 		recovery algorithm it uses.
1:eac0369: 
4:eac0369: 		@param dataFactory - the data factory
3:eac0369: 		@param transactionFactory - the transaction factory
1:eac0369: 
1:eac0369: 		@exception StandardException - encounter exception while recovering.
1:eac0369: 	 */
1:9cc8ad0: 	public void recover(DataFactory dataFactory,
1:eac0369: 						TransactionFactory transactionFactory)
6:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Checkpoint the rawstore.
1:eac0369: 
1:eac0369: 		The frequency of checkpoint is determined by 2 persistent service
1:eac0369: 		properties,
1:eac0369: 		RawStore.LOG_SWITCH_INTERVAL and RawStore.CHECKPOINT_INTERVAL.  
1:eac0369: 
1:731568d: 		By default, LOG_SWITCH_INTERVAL is every 1M bytes of log record
1:eac0369: 		written.  User can change this value by setting the property to some
1:eac0369: 		other values during boot time.   The legal range of LOG_SWITCH_INTERVAL
1:eac0369: 		is from 100K to 128M.
1:eac0369: 
1:731568d: 		By default, CHECKPOINT_INTERVAL equals 10M, but user
1:eac0369: 		can set it to less if more frequent checkpoint is desired.  The legal
1:731568d: 		range of CHECKPOINT_INTERVAL is from 100K to 128M.
1:eac0369: 
4:eac0369: 		@param rawStoreFactory - the raw store
1:eac0369: 		@param dataFactory - the data factory
1:eac0369: 		@param transactionFactory - the transaction factory
1:731568d: 		@param wait - if true waits for any existing checkpoint to complete 
1:731568d:                          and then executes and waits for another checkpoint.
1:731568d:                       if false if another thead is executing a checkpoint 
1:731568d:                       routine will return immediately.
1:731568d: 
1:731568d: 		@return true if checkpoint is successful,  Will return false if wait
1:731568d:                 is false and the routine finds another thread executing a 
1:731568d:                 checkpoint.
1:731568d: 
1:731568d: 		@exception StandardException - got exception while doing checkpoint.
1:eac0369: 	*/
1:eac0369: 	public boolean checkpoint(RawStoreFactory rawStoreFactory,
2:eac0369: 							  DataFactory dataFactory,
1:eac0369: 							  TransactionFactory transactionFactory, 
1:eac0369: 							  boolean wait)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Flush all unwritten log record up to the log instance indicated to disk.
1:eac0369: 
1:eac0369: 		@param where flush log up to here
1:eac0369: 
1:eac0369: 		@exception StandardException cannot flush log file due to sync error
1:eac0369: 	*/
1:eac0369: 	public void flush(LogInstant where) throws StandardException;
1:eac0369: 
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a LogScan to scan flushed records from the log.
1:eac0369: 
1:eac0369: 		<P> MT- read only
1:eac0369: 
1:eac0369: 		@param startAt - the LogInstant where we start our scan. null means
1:eac0369: 		start at the beginning of the log. This function raises an error
1:eac0369: 		if startAt is a LogInstant which is not in the log.
1:eac0369: 
1:eac0369: 		@return the LogScan.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy
1:eac0369: 	    NOTE: This will be removed after the LogSniffer Rewrite.
1:eac0369: 	*/
1:eac0369: 	LogScan openForwardsFlushedScan(LogInstant startAt)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	    Get a ScanHandle to scan flushed records from the log.
1:eac0369: 
1:eac0369: 		<P> MT- read only
1:eac0369: 
1:eac0369: 		@param startAt - the LogInstant where we start our scan. null means
1:eac0369: 		start at the beginning of the log. This function raises an error
1:eac0369: 		if startAt is a LogInstant which is not in the log.
1:eac0369: 		@param groupsIWant - log record groups the scanner wants.
1:eac0369: 		@return the LogScan.
1:3fd26f3: 		@exception StandardException Standard Derby error policy
1:eac0369: 		*/
1:6b50965: 	ScanHandle openFlushedScan(DatabaseInstant startAt, int groupsIWant)
1:eac0369: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Get a LogScan to scan the log in a forward direction.
1:eac0369: 
1:eac0369: 		<P> MT- read only
1:eac0369: 
1:eac0369: 		@param startAt - the LogInstant where we start our scan. null means
1:eac0369: 		start at the beginning of the log. This function raises an error
1:eac0369: 		if startAt is a LogInstant which is not in the log.
1:eac0369: 		@param stopAt - the LogInstant where we stop our scan. null means
1:eac0369: 		stop at the end of the log. This function raises an error
1:eac0369:  		if stopAt is a LogInstant which is not in the log.
1:eac0369: 		@return the LogScan.
1:eac0369: 
1:3fd26f3: 		@exception StandardException Standard Derby error policy
1:eac0369: 	*/
1:eac0369: 	LogScan openForwardsScan(LogInstant startAt,LogInstant stopAt)
1:eac0369: 		 throws StandardException;
1:eac0369:     /**
1:eac0369: 	  Get the instant for the last record in the log.
1:eac0369: 	  */
1:eac0369:     LogInstant getFirstUnflushedInstant();
1:eac0369: 
1:29fd25c:     /**
1:29fd25c:      * Get the log instant long value of the first log record that has not 
1:29fd25c:      * been flushed. Only works after recover() has finished, or (if in slave 
1:29fd25c:      * replication mode) after calling initializeReplicationSlaveRole.
1:29fd25c:      *
1:29fd25c:      * @return the log instant long value of the first log record that has not 
1:29fd25c:      * been flushed
1:29fd25c:      */
1:29fd25c:     public long getFirstUnflushedInstantAsLong();
1:29fd25c: 
1:eac0369: 	/**
1:eac0369: 		Backup restore support
1:eac0369: 	 */
1:9e2a749: 
1:eac0369: 	/**
1:eac0369: 		Stop making any change to the persistent store
1:3fd26f3: 		@exception StandardException Standard Derby exception policy.
1:eac0369: 	 */
1:eac0369: 	public void freezePersistentStore() throws StandardException;
1:eac0369: 		 
1:eac0369: 	/**
1:eac0369: 		Can start making change to the persistent store again
1:3fd26f3: 		@exception StandardException Standard Derby exception policy.
1:eac0369: 	 */
1:eac0369: 	public void unfreezePersistentStore() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	   checks whether is log archive mode is enabled or not.
1:eac0369: 	   @return true if the log is being archived.
1:eac0369: 	*/
1:eac0369: 	public boolean logArchived();
1:d3d292e:         
1:d3d292e:         /**
1:d3d292e:          * Used to determine if the replication master mode has been started,
1:d3d292e:          * and the logging for unlogged operations needs to be enabled.
1:d3d292e:          *
1:d3d292e:          * @return true If the master replication mode is turned on and the 
1:d3d292e:          *              unlogged operations need to be logged.
1:d3d292e:          *         false If the master replication mode is turned off and the 
1:d3d292e:          *               unlogged operations need not be logged.
1:d3d292e:          */
1:d3d292e:         public boolean inReplicationMasterMode();
1:eac0369: 
1:eac0369: 	/**
1:c6892a1: 		Get JBMS properties relevant to the log factory
1:3fd26f3: 		@exception StandardException Standard Derby Error Policy
1:eac0369: 	 */
1:eac0369: 	public void getLogFactoryProperties(PersistentSet set) 
1:9e2a749: 		 throws StandardException;
1:eac0369: 
1:eac0369: 	 /**
1:eac0369: 		Return the location of the log directory.
1:3fd26f3: 		@exception StandardException Standard Derby Error Policy
1:eac0369: 	  */
1:eac0369: 	public StorageFile getLogDirectory() throws StandardException;
1:eac0369: 
1:eac0369: 	 /**
1:eac0369: 		Return the canonical directory of the PARENT of the log directory.  The
1:eac0369: 		log directory live in the "log" subdirectory of this path.  If the log
1:eac0369: 		is at the default location (underneath the database directory), this
1:eac0369: 		returns null.  Should only be called after the log factory is booted.
1:eac0369: 	  */
1:eac0369: 	public String getCanonicalLogPath();
1:eac0369: 
1:eac0369: 
1:ae71c74: 	/*
1:eac0369: 	 * Enable the log archive mode, when log archive mode is 
1:eac0369: 	 * on the system keeps all the old log files instead
1:eac0369: 	 * of deleting them at the checkpoint.
1:eac0369: 	 * logArchive mode is persistent across the boots.
1:eac0369: 	 * @exception StandardException - thrown on error
1:eac0369: 	*/
1:eac0369: 	public void enableLogArchiveMode() throws StandardException;
1:eac0369: 
1:eac0369: 		
1:eac0369: 	/*
1:eac0369: 	 * Disable the log archive mode, when log archive mode is 
1:eac0369: 	 * off the system will delete  old log files(not required 
1:eac0369: 	 * for crash recovery) after each checkpoint. 
1:eac0369: 	 * @exception StandardException - thrown on error
1:eac0369: 	*/
1:eac0369: 	public void disableLogArchiveMode() throws StandardException;
1:eac0369: 
1:eac0369: 	/*
1:eac0369: 	 * Deletes the archived log files store in the log directory path.
1:eac0369: 	 * This call is typically used after a successful version level
1:eac0369: 	 * backup to clean up the old log files that are no more
1:eac0369: 	 * required to do roll-forward recovery from the last
1:eac0369: 	 * backup taken.
1:eac0369: 	*/
1:eac0369: 	public void deleteOnlineArchivedLogFiles();
1:eac0369: 
1:eac0369: 	//Is the transaction in rollforward recovery
1:eac0369: 	public boolean inRFR();
1:eac0369: 
1:eac0369: 	/**	
1:eac0369: 	 * redoing a checkpoint  during rollforward recovery
1:a292c89: 	 * @param cinstant The LogInstant of the checkpoint
1:a292c89: 	 * @param redoLWM  Redo Low Water Mark in the check point record
1:a292c89: 	 * @param undoLWM Undo Low Water Mark in the checkpoint
1:a292c89: 	 * @param df - the data factory
1:a292c89: 	 * @exception StandardException - encounter exception during checkpoint
1:eac0369: 	 */
1:a292c89: 	public void checkpointInRFR(LogInstant cinstant, long redoLWM, long undoLWM,
1:eac0369: 								DataFactory df) throws StandardException;
1:25f99f5: 
1:eac0369: 	
1:25f99f5: 	/*
1:25f99f5: 	 * start the transaction log backup, the transaction log is  is required
1:25f99f5: 	 * to bring the database to the consistent state on restore. 
1:25f99f5: 	 * copies the log control information , active log files to the given 
1:25f99f5: 	 * backup directory and marks that backup is in progress.
1:bf643fd:      * @param toDir - location where the log files should be copied to.
1:bf643fd:      * @exception StandardException Standard Derby error policy
1:25f99f5: 	*/
1:25f99f5: 	public void startLogBackup(File toDir) throws StandardException;
1:25f99f5: 
1:25f99f5: 	
1:25f99f5: 	/*
1:25f99f5: 	 * copy all the log files that has to go into the backup directory
1:25f99f5: 	 * and mark that backup has come to an end. 
1:bf643fd:      * @param toDir - location where the log files should be copied to.
1:bf643fd:      * @exception StandardException Standard Derby error policy
1:25f99f5: 	*/
1:25f99f5: 	public void endLogBackup(File toDir) throws StandardException;
1:25f99f5: 
1:25f99f5: 	
1:25f99f5: 	/*
1:25f99f5: 	 * Abort any activity related to backup in the log factory.
1:25f99f5: 	 * Backup is not in progress any more, it failed for some reason.
1:25f99f5: 	 **/
1:25f99f5: 	public void abortLogBackup();
1:25f99f5: 
1:89a6625:     /**
1:89a6625:      * Sets whether the database is encrypted, all the transaction log has
1:89a6625:      * to be encrypted, and flush the log if requested.
1:89a6625:      * <p>
1:89a6625:      * Log needs to be flushed first if the cryptographic state of the database
1:89a6625:      * changes (for instance re-encryption with a new key).
1:9e2a749: 	 *
1:89a6625:      * @param isEncrypted {@code true} if the database is encrypted,
1:89a6625:      *      {@code false} if not
1:89a6625: 	 * @param flushLog {@code true} if log needs to be flushed,
1:89a6625:      *      {@code false} otherwise
1:ae71c74:      */
1:89a6625:     public void setDatabaseEncrypted(boolean isEncrypted, boolean flushLog)
1:eac0369: 		throws StandardException;
1:ae71c74: 
1:ae71c74:     
1:ae71c74:     /*
1:047a763:      * set up a new log file to start writing 
1:047a763:      * the log records into the new log file 
1:047a763:      * after this call.
1:047a763:      *
1:047a763:      * <P>MT - synchronization provided by caller - RawStore boot,
1:047a763:      * This method is called while re-encrypting the database 
1:c6892a1:      * at database boot time.
1:ae71c74:      */
1:047a763:     public void startNewLogFile() throws StandardException;
1:047a763: 
1:047a763:     /*
1:047a763:      * find if the checkpoint is in the last log file. 
1:047a763:      *
1:047a763:      * <P>MT - synchronization provided by caller - RawStore boot,
1:047a763:      * This method is called only if a crash occured while 
1:047a763:      * re-encrypting the database at boot time. 
1:047a763:      * @return <code> true </code> if if the checkpoint is 
1:047a763:      *                in the last log file, otherwise 
1:047a763:      *                 <code> false </code>.
1:047a763:      */
1:047a763:     public boolean isCheckpointInLastLogFile() 
1:047a763:         throws StandardException;
1:047a763:     
1:047a763:     /*
1:047a763:      * delete the log file after the checkpoint. 
1:047a763:      *
1:047a763:      * <P>MT - synchronization provided by caller - RawStore boot,
1:047a763:      * This method is called only if a crash occured while 
1:047a763:      * re-encrypting the database at boot time. 
1:047a763:      */
1:047a763:     public void deleteLogFileAfterCheckpointLogFile() 
1:047a763:         throws StandardException;
1:eac0369: 
1:eac0369:     
1:eac0369:     /**
1:32635d2:      *  Check to see if a database has been upgraded to the required
1:32635d2:      *  level in order to use a store feature.
1:32635d2:      *
1:32635d2:      * @param requiredMajorVersion  required database Engine major version
1:32635d2:      * @param requiredMinorVersion  required database Engine minor version
1:32635d2:      * @param feature Non-null to throw an exception, null to return the 
1:32635d2:      *                state of the version match.
1:32635d2:      * @return <code> true </code> if the database has been upgraded to 
1:32635d2:      *         the required level, <code> false </code> otherwise.
1:32635d2:      * @exception  StandardException 
1:32635d2:      *             if the database is not at the require version 
1:32635d2:      *             when <code>feature</code> feature is 
1:32635d2:      *             not <code> null </code>. 
1:32635d2:      */
1:32635d2: 	public boolean checkVersion(int requiredMajorVersion, 
1:32635d2:                                 int requiredMinorVersion, 
1:32635d2:                                 String feature) 
1:32635d2:         throws StandardException;
1:eac0369: 
1:c414a36:     /**
1:c414a36:      * Make this LogFactory pass log records to the MasterFactory
1:c414a36:      * every time a log record is appended to the log on disk, and
1:c414a36:      * notify the MasterFactory when a log disk flush has taken place.
1:c414a36:      * Not implemented by ReadOnly.
1:c414a36:      * @param masterFactory The MasterFactory service responsible for
1:c414a36:      * controlling the master side replication behaviour.
1:c414a36:      * @exception StandardException Standard Derby exception policy,
1:c414a36:      * thrown on replication startup error. Will only be thrown if
1:c414a36:      * replication is attempted started on a readonly database.
1:c414a36:      */
1:c414a36:     public void startReplicationMasterRole(MasterFactory masterFactory)
1:c414a36:         throws StandardException;
1:c414a36: 
1:c414a36:     /**
1:c414a36:      * Stop this LogFactory from passing log records to the
1:c414a36:      * MasterFactory and from notifying the MasterFactory when a log
1:c414a36:      * disk flush has taken place. Not implemented by ReadOnly.
1:c414a36:      */
1:c414a36:     public void stopReplicationMasterRole();
1:c414a36: 
1:eac0369: }
1:eac0369: 
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:9496f49
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Create readme file in log directory warning users against touching
1:      *  any files in the directory
1:      * @throws StandardException
1:      */
1:     public void createDataWarningFile() throws StandardException;
1: 
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:c6892a1
/////////////////////////////////////////////////////////////////////////
1: 		Get JBMS properties relevant to the log factory
/////////////////////////////////////////////////////////////////////////
1:      * at database boot time.
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:89a6625
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Sets whether the database is encrypted, all the transaction log has
1:      * to be encrypted, and flush the log if requested.
1:      * <p>
1:      * Log needs to be flushed first if the cryptographic state of the database
1:      * changes (for instance re-encryption with a new key).
1:      * @param isEncrypted {@code true} if the database is encrypted,
1:      *      {@code false} if not
1: 	 * @param flushLog {@code true} if log needs to be flushed,
1:      *      {@code false} otherwise
1:     public void setDatabaseEncrypted(boolean isEncrypted, boolean flushLog)
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:731568d
/////////////////////////////////////////////////////////////////////////
1: 		By default, LOG_SWITCH_INTERVAL is every 1M bytes of log record
1: 		By default, CHECKPOINT_INTERVAL equals 10M, but user
1: 		range of CHECKPOINT_INTERVAL is from 100K to 128M.
1: 		@param wait - if true waits for any existing checkpoint to complete 
1:                          and then executes and waits for another checkpoint.
1:                       if false if another thead is executing a checkpoint 
1:                       routine will return immediately.
1: 
1: 		@return true if checkpoint is successful,  Will return false if wait
1:                 is false and the routine finds another thread executing a 
1:                 checkpoint.
1: 
1: 		@exception StandardException - got exception while doing checkpoint.
commit:bf643fd
/////////////////////////////////////////////////////////////////////////
1:      * @param toDir - location where the log files should be copied to.
1:      * @exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1:      * @param toDir - location where the log files should be copied to.
1:      * @exception StandardException Standard Derby error policy
commit:25f99f5
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1: 	
1: 	/*
1: 	 * start the transaction log backup, the transaction log is  is required
1: 	 * to bring the database to the consistent state on restore. 
1: 	 * copies the log control information , active log files to the given 
1: 	 * backup directory and marks that backup is in progress.
0: 	 @param toDir - location where the log files should be copied to.
0: 	 @return true if log files copy is  successful
0: 	 @exception StandardException - encounter exception while doing checkpoint.
1: 	*/
1: 	public void startLogBackup(File toDir) throws StandardException;
1: 
1: 	
1: 	/*
1: 	 * copy all the log files that has to go into the backup directory
1: 	 * and mark that backup has come to an end. 
0: 	 @param toDir - location where the log files should be copied to.
0: 	 @return true if log files copy is  successful
0: 	 @exception StandardException - encounter exception while doing checkpoint.
1: 	*/
1: 	public void endLogBackup(File toDir) throws StandardException;
1: 
1: 	
1: 	/*
1: 	 * Abort any activity related to backup in the log factory.
1: 	 * Backup is not in progress any more, it failed for some reason.
1: 	 **/
1: 	public void abortLogBackup();
1: 
commit:a5bdbd4
/////////////////////////////////////////////////////////////////////////
author:Jorgen Loland
-------------------------------------------------------------------------------
commit:9cc8ad0
/////////////////////////////////////////////////////////////////////////
1: 		Make log factory aware of which raw store factory it belongs to
1: 	*/
1: 	public void setRawStoreFactory(RawStoreFactory rsf);
1: 
1: 	/**
1: 	public void recover(DataFactory dataFactory,
author:Oystein Grovlen
-------------------------------------------------------------------------------
commit:a292c89
/////////////////////////////////////////////////////////////////////////
1: 	 * @param cinstant The LogInstant of the checkpoint
1: 	 * @param redoLWM  Redo Low Water Mark in the check point record
1: 	 * @param undoLWM Undo Low Water Mark in the checkpoint
1: 	 * @param df - the data factory
1: 	 * @exception StandardException - encounter exception during checkpoint
1: 	public void checkpointInRFR(LogInstant cinstant, long redoLWM, long undoLWM,
commit:d3d292e
/////////////////////////////////////////////////////////////////////////
1:         
1:         /**
1:          * Used to determine if the replication master mode has been started,
1:          * and the logging for unlogged operations needs to be enabled.
1:          *
1:          * @return true If the master replication mode is turned on and the 
1:          *              unlogged operations need to be logged.
1:          *         false If the master replication mode is turned off and the 
1:          *               unlogged operations need not be logged.
1:          */
1:         public boolean inReplicationMasterMode();
commit:1bac3f3
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derby.iapi.store.replication.master.MasterFactory;
commit:29fd25c
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Get the log instant long value of the first log record that has not 
1:      * been flushed. Only works after recover() has finished, or (if in slave 
1:      * replication mode) after calling initializeReplicationSlaveRole.
1:      *
1:      * @return the log instant long value of the first log record that has not 
1:      * been flushed
1:      */
1:     public long getFirstUnflushedInstantAsLong();
1: 
commit:c414a36
/////////////////////////////////////////////////////////////////////////
0: import org.apache.derby.iapi.services.replication.master.MasterFactory;
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Make this LogFactory pass log records to the MasterFactory
1:      * every time a log record is appended to the log on disk, and
1:      * notify the MasterFactory when a log disk flush has taken place.
1:      * Not implemented by ReadOnly.
1:      * @param masterFactory The MasterFactory service responsible for
1:      * controlling the master side replication behaviour.
1:      * @exception StandardException Standard Derby exception policy,
1:      * thrown on replication startup error. Will only be thrown if
1:      * replication is attempted started on a readonly database.
1:      */
1:     public void startReplicationMasterRole(MasterFactory masterFactory)
1:         throws StandardException;
1: 
1:     /**
1:      * Stop this LogFactory from passing log records to the
1:      * MasterFactory and from notifying the MasterFactory when a log
1:      * disk flush has taken place. Not implemented by ReadOnly.
1:      */
1:     public void stopReplicationMasterRole();
1: 
author:Samuel Andrew McIntyre
-------------------------------------------------------------------------------
commit:3fd26f3
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby error policy
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby exception policy.
1: 		@exception StandardException Standard Derby exception policy.
/////////////////////////////////////////////////////////////////////////
1: 		@exception StandardException Standard Derby Error Policy
1: 		@exception StandardException Standard Derby Error Policy
author:Suresh Thalamati
-------------------------------------------------------------------------------
commit:9e2a749
/////////////////////////////////////////////////////////////////////////
0:      * to be encrypted, and flush the log if requesed. Log needs to 
0: 	 * be flushed  first, if this is  being set during (re) encryption 
0: 	 * of an existing  database. 
1: 	 *
0: 	 * @param flushLog  true, if log needs to be flushed, 
0: 	 *                  otherwise false.  
0:     public  void setDatabaseEncrypted(boolean flushLog)
1: 		throws StandardException;
1: 
commit:047a763
/////////////////////////////////////////////////////////////////////////
1:      * set up a new log file to start writing 
1:      * the log records into the new log file 
1:      * after this call.
1:      *
1:      * <P>MT - synchronization provided by caller - RawStore boot,
1:      * This method is called while re-encrypting the database 
0:      * at databse boot time. 
1:     public void startNewLogFile() throws StandardException;
1: 
1:     /*
1:      * find if the checkpoint is in the last log file. 
1:      *
1:      * <P>MT - synchronization provided by caller - RawStore boot,
1:      * This method is called only if a crash occured while 
1:      * re-encrypting the database at boot time. 
1:      * @return <code> true </code> if if the checkpoint is 
1:      *                in the last log file, otherwise 
1:      *                 <code> false </code>.
1:      */
1:     public boolean isCheckpointInLastLogFile() 
1:         throws StandardException;
1:     
1:     /*
1:      * delete the log file after the checkpoint. 
1:      *
1:      * <P>MT - synchronization provided by caller - RawStore boot,
1:      * This method is called only if a crash occured while 
1:      * re-encrypting the database at boot time. 
1:      */
1:     public void deleteLogFileAfterCheckpointLogFile() 
1:         throws StandardException;
commit:32635d2
/////////////////////////////////////////////////////////////////////////
1:     
1:     /**
1:      *  Check to see if a database has been upgraded to the required
1:      *  level in order to use a store feature.
1:      *
1:      * @param requiredMajorVersion  required database Engine major version
1:      * @param requiredMinorVersion  required database Engine minor version
1:      * @param feature Non-null to throw an exception, null to return the 
1:      *                state of the version match.
1:      * @return <code> true </code> if the database has been upgraded to 
1:      *         the required level, <code> false </code> otherwise.
1:      * @exception  StandardException 
1:      *             if the database is not at the require version 
1:      *             when <code>feature</code> feature is 
1:      *             not <code> null </code>. 
1:      */
1: 	public boolean checkVersion(int requiredMajorVersion, 
1:                                 int requiredMinorVersion, 
1:                                 String feature) 
1:         throws StandardException;
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:75c7276
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:ae71c74
/////////////////////////////////////////////////////////////////////////
1:     /*
0:      * Set that the database is encrypted , all the transaction log has 
0:      * to be encrypted.
1:      */
0:     public void setDatabaseEncrypted();
1:     
1:     /*
0:      * setup transaction log for encryption. 
1:      */
0:     public  void setupLogEncryption() throws StandardException;
1: 
author:David Van Couvering
-------------------------------------------------------------------------------
commit:6b50965
/////////////////////////////////////////////////////////////////////////
1: 	ScanHandle openFlushedScan(DatabaseInstant startAt, int groupsIWant)
/////////////////////////////////////////////////////////////////////////
0: 	 @param df - the data factory
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.store.raw.log.LogFactory
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:76addbc
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw.log
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.store.raw.log;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: import org.apache.derby.iapi.services.property.PersistentSet;
1: import org.apache.derby.iapi.store.raw.data.DataFactory;
1: import org.apache.derby.iapi.store.raw.Corruptable;
1: import org.apache.derby.iapi.store.raw.RawStoreFactory;
1: import org.apache.derby.iapi.store.raw.ScanHandle;
0: import org.apache.derby.iapi.store.raw.ScannedTransactionHandle;
1: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
1: import org.apache.derby.io.StorageFile;
1: import org.apache.derby.iapi.store.access.DatabaseInstant;
1: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.catalog.UUID;
1: import java.io.File;
1: 
1: public interface LogFactory extends Corruptable {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 
1: 	/**
1: 		The name of a runtime property in the service set that defines any runtime
1: 		attributes a log factory should have. It is (or will be) a comma separated list
1: 		of attributes.
1: 		At the moment only one attribute is known and checked for.
1: 	*/
1: 	public static final String RUNTIME_ATTRIBUTES = Property.PROPERTY_RUNTIME_PREFIX + "storage.log";
1: 
1: 	/**
1: 		An attribute that indicates the database is readonly
1: 	*/
1: 	public static final String RT_READONLY = "readonly";
1: 
1: 	/**
1: 		The name of the default log directory.
1: 	 */
1: 	public static final String LOG_DIRECTORY_NAME = "log";
1: 
1: 
1: 
1: 	public static final String MODULE = "org.apache.derby.iapi.store.raw.log.LogFactory";
1: 
1: 	public Logger getLogger();
1: 
1: 	/**
1: 		Recover the database to a consistent state using the log. 
1: 		Each implementation of the log factory has its own recovery algorithm,
1: 		please see the implementation for a description of the specific
1: 		recovery algorithm it uses.
1: 
1: 		@param rawStoreFactory - the raw store
1: 		@param dataFactory - the data factory
1: 		@param transactionFactory - the transaction factory
1: 
1: 		@exception StandardException - encounter exception while recovering.
1: 	 */
0: 	public void recover(RawStoreFactory rawStoreFactory,
1: 						DataFactory dataFactory,
1: 						TransactionFactory transactionFactory)
1: 		 throws StandardException;
1: 
1: 	/**
1: 		Checkpoint the rawstore.
1: 
1: 		The frequency of checkpoint is determined by 2 persistent service
1: 		properties,
1: 		RawStore.LOG_SWITCH_INTERVAL and RawStore.CHECKPOINT_INTERVAL.  
1: 
0: 		By default, LOG_SWITCH_INTERVAL is every 100K bytes of log record
1: 		written.  User can change this value by setting the property to some
1: 		other values during boot time.   The legal range of LOG_SWITCH_INTERVAL
1: 		is from 100K to 128M.
1: 
0: 		By default, CHECKPOINT_INTERVAL equals LOG_SWITCH_INTERVAL, but user
1: 		can set it to less if more frequent checkpoint is desired.  The legal
0: 		range of CHECKPOINT_INTERVAL is from 100K to LOG_SWITCH_INTERVAL.
1: 
1: 		@param rawStoreFactory - the raw store
1: 		@param dataFactory - the data factory
1: 		@param transactionFactory - the transaction factory
0: 		@param wait - if true; waits for the checkpoint to completed even if it is being done my an another thread.
0: 		@return true if checkpoint is successful
0: 		@exception StandardException - encounter exception while doing checkpoint.
1: 	*/
1: 	public boolean checkpoint(RawStoreFactory rawStoreFactory,
1: 							  DataFactory dataFactory,
1: 							  TransactionFactory transactionFactory, 
1: 							  boolean wait)
1: 		 throws StandardException;
1: 
1: 	/**
1: 		Flush all unwritten log record up to the log instance indicated to disk.
1: 
1: 		@param where flush log up to here
1: 
1: 		@exception StandardException cannot flush log file due to sync error
1: 	*/
1: 	public void flush(LogInstant where) throws StandardException;
1: 
1: 	/**
0: 		@see RawStoreFactory#setTruncationLWM
1: 
0: 		@param name - the name of the truncation low water mark. 
1: 		@param rawStoreFactory - the raw store
1: 		@param dataFactory - the data factory
1: 		@param transactionFactory - the transaction factory
1: 
0: 		@return The exact instant to which this set the truncation low
0: 		water mark.
1: 
0: 		@exception StandardException StandardCloudscape error policy
1: 	*/
1: 
0: 	public LogInstant setTruncationLWM(UUID name, 
0: 									   LogInstant instant,
0: 									   RawStoreFactory rawStoreFactory, 
0: 									   TransactionFactory transFactory)
1: 		 throws StandardException;
1: 
1: 	/**
0: 		Internal to RawStore, setting the truncationLWM below the log
1: 
0: 		@param name - the name of the truncation low water mark. 
0: 		@exception StandardException cloudscape standard error policy
1: 
1: 	  */
0: 	public void setTruncationLWM(UUID name, LogInstant instant)
1: 		 throws StandardException;
1: 
1: 
1: 	/**
0: 		Get back a truncation LWM
0: 		@exception StandardException cloudscape standard error policy
1: 	*/
0: 	public LogInstant getTruncationLWM(UUID name)
1: 		 throws StandardException;
1: 
1: 	/**
0: 		Remove a truncation LWM - logged
1: 
0: 		@param name - the name of the truncation low water mark. 
1: 		@param rawStoreFactory - the raw store
1: 		@param dataFactory - the data factory
1: 		@param transactionFactory - the transaction factory
1: 		
0: 		@exception StandardException cloudscape standard error policy
1: 	*/
0: 	void removeTruncationLWM(UUID name,
0: 							 RawStoreFactory rawStoreFactory, 
0: 							 TransactionFactory transFactory)
1: 		 throws StandardException;
1: 
1: 	/**
0: 		Remove a truncation LWM - underneath the log
1: 
0: 		@param name - the name of the truncation low water mark. 
0: 		@exception StandardException cloudscape standard error policy
1: 	*/
0: 	void removeTruncationLWM(UUID name)
1: 		 throws StandardException;
1: 
1: 
1: 	/**
1: 		Get a LogScan to scan flushed records from the log.
1: 
1: 		<P> MT- read only
1: 
1: 		@param startAt - the LogInstant where we start our scan. null means
1: 		start at the beginning of the log. This function raises an error
1: 		if startAt is a LogInstant which is not in the log.
1: 
1: 		@return the LogScan.
1: 
0: 		@exception StandardException StandardCloudscape error policy
1: 	    NOTE: This will be removed after the LogSniffer Rewrite.
1: 	*/
1: 	LogScan openForwardsFlushedScan(LogInstant startAt)
1: 		 throws StandardException;
1: 
1: 	/**
1: 	    Get a ScanHandle to scan flushed records from the log.
1: 
1: 		<P> MT- read only
1: 
1: 		@param startAt - the LogInstant where we start our scan. null means
1: 		start at the beginning of the log. This function raises an error
1: 		if startAt is a LogInstant which is not in the log.
1: 		@param groupsIWant - log record groups the scanner wants.
1: 		@return the LogScan.
0: 		@exception StandardException StandardCloudscape error policy
1: 		*/
0: 	ScanHandle openFlushedScan(DatabaseInstant start, int groupsIWant)
1: 		 throws StandardException;
1: 
1: 	/**
1: 		Get a LogScan to scan the log in a forward direction.
1: 
1: 		<P> MT- read only
1: 
1: 		@param startAt - the LogInstant where we start our scan. null means
1: 		start at the beginning of the log. This function raises an error
1: 		if startAt is a LogInstant which is not in the log.
1: 		@param stopAt - the LogInstant where we stop our scan. null means
1: 		stop at the end of the log. This function raises an error
1:  		if stopAt is a LogInstant which is not in the log.
1: 		@return the LogScan.
1: 
0: 		@exception StandardException StandardCloudscape error policy
1: 	*/
1: 	LogScan openForwardsScan(LogInstant startAt,LogInstant stopAt)
1: 		 throws StandardException;
1:     /**
1: 	  Get the instant for the last record in the log.
1: 	  */
1:     LogInstant getFirstUnflushedInstant();
1: 
1: 	/**
1: 		Backup restore support
1: 	 */
1: 
1: 	/**
1: 		Stop making any change to the persistent store
0: 		@exception StandardException Standard cloudscape exception policy.
1: 	 */
1: 	public void freezePersistentStore() throws StandardException;
1: 		 
1: 	/**
1: 		Can start making change to the persistent store again
0: 		@exception StandardException Standard cloudscape exception policy.
1: 	 */
1: 	public void unfreezePersistentStore() throws StandardException;
1: 
1: 	/**
1: 	   checks whether is log archive mode is enabled or not.
1: 	   @return true if the log is being archived.
1: 	*/
1: 	public boolean logArchived();
1: 
1: 	/**
0: 		Get JBMS properties relavent to the log factory
0: 		@exception StandardException Standard Cloudscape Error Policy
1: 	 */
1: 	public void getLogFactoryProperties(PersistentSet set) 
1: 		 throws StandardException;
1: 
1: 	 /**
1: 		Return the location of the log directory.
0: 		@exception StandardException Standard Cloudscape Error Policy
1: 	  */
1: 	public StorageFile getLogDirectory() throws StandardException;
1: 
1: 	 /**
1: 		Return the canonical directory of the PARENT of the log directory.  The
1: 		log directory live in the "log" subdirectory of this path.  If the log
1: 		is at the default location (underneath the database directory), this
1: 		returns null.  Should only be called after the log factory is booted.
1: 	  */
1: 	public String getCanonicalLogPath();
1: 
1: 
1: 	/*
0: 	  copies the active log files and control files to the given directory
0: 	  Used copy the necessary log files while doing online backup
0: 	  @param toDir - location where the log files should be copied to.
0: 	  @return true if log files copy is  successful
0: 	  @exception StandardException - encounter exception while doing checkpoint.
1: 	*/
0: 	public boolean copyActiveLogFiles(File toDir) throws StandardException;
1: 
1: 	/*
1: 	 * Enable the log archive mode, when log archive mode is 
1: 	 * on the system keeps all the old log files instead
1: 	 * of deleting them at the checkpoint.
1: 	 * logArchive mode is persistent across the boots.
1: 	 * @exception StandardException - thrown on error
1: 	*/
1: 	public void enableLogArchiveMode() throws StandardException;
1: 
1: 		
1: 	/*
1: 	 * Disable the log archive mode, when log archive mode is 
1: 	 * off the system will delete  old log files(not required 
1: 	 * for crash recovery) after each checkpoint. 
1: 	 * @exception StandardException - thrown on error
1: 	*/
1: 	public void disableLogArchiveMode() throws StandardException;
1: 
1: 	/*
1: 	 * Deletes the archived log files store in the log directory path.
1: 	 * This call is typically used after a successful version level
1: 	 * backup to clean up the old log files that are no more
1: 	 * required to do roll-forward recovery from the last
1: 	 * backup taken.
1: 	*/
1: 	public void deleteOnlineArchivedLogFiles();
1: 
1: 	//Is the transaction in rollforward recovery
1: 	public boolean inRFR();
1: 
1: 	/**	
1: 	 * redoing a checkpoint  during rollforward recovery
0: 	 @param cinstant The LogInstant of the checkpoint
0: 	 @param redoLWM  Redo Low Water Mark in the check point record
1: 	 @param dataFactory - the data factory
0: 	 @exception StandardException - encounter exception during checkpoint
1: 	 */
0: 	public void checkpointInRFR(LogInstant cinstant, long redoLWM, 
1: 								DataFactory df) throws StandardException;
1: 
1: 
1: }
1: 
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.store.raw.log
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.store.raw.log;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: import org.apache.derby.iapi.services.property.PersistentSet;
0: import org.apache.derby.iapi.store.raw.data.DataFactory;
0: import org.apache.derby.iapi.store.raw.Corruptable;
0: import org.apache.derby.iapi.store.raw.RawStoreFactory;
0: import org.apache.derby.iapi.store.raw.ScanHandle;
0: import org.apache.derby.iapi.store.raw.ScannedTransactionHandle;
0: import org.apache.derby.iapi.store.raw.xact.TransactionFactory;
0: import org.apache.derby.io.StorageFile;
0: import org.apache.derby.iapi.store.access.DatabaseInstant;
0: import org.apache.derby.iapi.reference.Property;
0: import org.apache.derby.catalog.UUID;
0: import java.io.File;
0: 
0: public interface LogFactory extends Corruptable {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 
0: 	/**
0: 		The name of a runtime property in the service set that defines any runtime
0: 		attributes a log factory should have. It is (or will be) a comma separated list
0: 		of attributes.
0: 		At the moment only one attribute is known and checked for.
0: 	*/
0: 	public static final String RUNTIME_ATTRIBUTES = Property.PROPERTY_RUNTIME_PREFIX + "storage.log";
0: 
0: 	/**
0: 		An attribute that indicates the database is readonly
0: 	*/
0: 	public static final String RT_READONLY = "readonly";
0: 
0: 	/**
0: 		The name of the default log directory.
0: 	 */
0: 	public static final String LOG_DIRECTORY_NAME = "log";
0: 
0: 
0: 
0: 	public static final String MODULE = "org.apache.derby.iapi.store.raw.log.LogFactory";
0: 
0: 	public Logger getLogger();
0: 
0: 	/**
0: 		Recover the database to a consistent state using the log. 
0: 		Each implementation of the log factory has its own recovery algorithm,
0: 		please see the implementation for a description of the specific
0: 		recovery algorithm it uses.
0: 
0: 		@param rawStoreFactory - the raw store
0: 		@param dataFactory - the data factory
0: 		@param transactionFactory - the transaction factory
0: 
0: 		@exception StandardException - encounter exception while recovering.
0: 	 */
0: 	public void recover(RawStoreFactory rawStoreFactory,
0: 						DataFactory dataFactory,
0: 						TransactionFactory transactionFactory)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Checkpoint the rawstore.
0: 
0: 		The frequency of checkpoint is determined by 2 persistent service
0: 		properties,
0: 		RawStore.LOG_SWITCH_INTERVAL and RawStore.CHECKPOINT_INTERVAL.  
0: 
0: 		By default, LOG_SWITCH_INTERVAL is every 100K bytes of log record
0: 		written.  User can change this value by setting the property to some
0: 		other values during boot time.   The legal range of LOG_SWITCH_INTERVAL
0: 		is from 100K to 128M.
0: 
0: 		By default, CHECKPOINT_INTERVAL equals LOG_SWITCH_INTERVAL, but user
0: 		can set it to less if more frequent checkpoint is desired.  The legal
0: 		range of CHECKPOINT_INTERVAL is from 100K to LOG_SWITCH_INTERVAL.
0: 
0: 		@param rawStoreFactory - the raw store
0: 		@param dataFactory - the data factory
0: 		@param transactionFactory - the transaction factory
0: 		@param wait - if true; waits for the checkpoint to completed even if it is being done my an another thread.
0: 		@return true if checkpoint is successful
0: 		@exception StandardException - encounter exception while doing checkpoint.
0: 	*/
0: 	public boolean checkpoint(RawStoreFactory rawStoreFactory,
0: 							  DataFactory dataFactory,
0: 							  TransactionFactory transactionFactory, 
0: 							  boolean wait)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Flush all unwritten log record up to the log instance indicated to disk.
0: 
0: 		@param where flush log up to here
0: 
0: 		@exception StandardException cannot flush log file due to sync error
0: 	*/
0: 	public void flush(LogInstant where) throws StandardException;
0: 
0: 	/**
0: 		@see RawStoreFactory#setTruncationLWM
0: 
0: 		@param name - the name of the truncation low water mark. 
0: 		@param rawStoreFactory - the raw store
0: 		@param dataFactory - the data factory
0: 		@param transactionFactory - the transaction factory
0: 
0: 		@return The exact instant to which this set the truncation low
0: 		water mark.
0: 
0: 		@exception StandardException StandardCloudscape error policy
0: 	*/
0: 
0: 	public LogInstant setTruncationLWM(UUID name, 
0: 									   LogInstant instant,
0: 									   RawStoreFactory rawStoreFactory, 
0: 									   TransactionFactory transFactory)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Internal to RawStore, setting the truncationLWM below the log
0: 
0: 		@param name - the name of the truncation low water mark. 
0: 		@exception StandardException cloudscape standard error policy
0: 
0: 	  */
0: 	public void setTruncationLWM(UUID name, LogInstant instant)
0: 		 throws StandardException;
0: 
0: 
0: 	/**
0: 		Get back a truncation LWM
0: 		@exception StandardException cloudscape standard error policy
0: 	*/
0: 	public LogInstant getTruncationLWM(UUID name)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Remove a truncation LWM - logged
0: 
0: 		@param name - the name of the truncation low water mark. 
0: 		@param rawStoreFactory - the raw store
0: 		@param dataFactory - the data factory
0: 		@param transactionFactory - the transaction factory
0: 		
0: 		@exception StandardException cloudscape standard error policy
0: 	*/
0: 	void removeTruncationLWM(UUID name,
0: 							 RawStoreFactory rawStoreFactory, 
0: 							 TransactionFactory transFactory)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Remove a truncation LWM - underneath the log
0: 
0: 		@param name - the name of the truncation low water mark. 
0: 		@exception StandardException cloudscape standard error policy
0: 	*/
0: 	void removeTruncationLWM(UUID name)
0: 		 throws StandardException;
0: 
0: 
0: 	/**
0: 		Get a LogScan to scan flushed records from the log.
0: 
0: 		<P> MT- read only
0: 
0: 		@param startAt - the LogInstant where we start our scan. null means
0: 		start at the beginning of the log. This function raises an error
0: 		if startAt is a LogInstant which is not in the log.
0: 
0: 		@return the LogScan.
0: 
0: 		@exception StandardException StandardCloudscape error policy
0: 	    NOTE: This will be removed after the LogSniffer Rewrite.
0: 	*/
0: 	LogScan openForwardsFlushedScan(LogInstant startAt)
0: 		 throws StandardException;
0: 
0: 	/**
0: 	    Get a ScanHandle to scan flushed records from the log.
0: 
0: 		<P> MT- read only
0: 
0: 		@param startAt - the LogInstant where we start our scan. null means
0: 		start at the beginning of the log. This function raises an error
0: 		if startAt is a LogInstant which is not in the log.
0: 		@param groupsIWant - log record groups the scanner wants.
0: 		@return the LogScan.
0: 		@exception StandardException StandardCloudscape error policy
0: 		*/
0: 	ScanHandle openFlushedScan(DatabaseInstant start, int groupsIWant)
0: 		 throws StandardException;
0: 
0: 	/**
0: 		Get a LogScan to scan the log in a forward direction.
0: 
0: 		<P> MT- read only
0: 
0: 		@param startAt - the LogInstant where we start our scan. null means
0: 		start at the beginning of the log. This function raises an error
0: 		if startAt is a LogInstant which is not in the log.
0: 		@param stopAt - the LogInstant where we stop our scan. null means
0: 		stop at the end of the log. This function raises an error
0:  		if stopAt is a LogInstant which is not in the log.
0: 		@return the LogScan.
0: 
0: 		@exception StandardException StandardCloudscape error policy
0: 	*/
0: 	LogScan openForwardsScan(LogInstant startAt,LogInstant stopAt)
0: 		 throws StandardException;
0:     /**
0: 	  Get the instant for the last record in the log.
0: 	  */
0:     LogInstant getFirstUnflushedInstant();
0: 
0: 	/**
0: 		Backup restore support
0: 	 */
0: 
0: 	/**
0: 		Stop making any change to the persistent store
0: 		@exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void freezePersistentStore() throws StandardException;
0: 		 
0: 	/**
0: 		Can start making change to the persistent store again
0: 		@exception StandardException Standard cloudscape exception policy.
0: 	 */
0: 	public void unfreezePersistentStore() throws StandardException;
0: 
0: 	/**
0: 	   checks whether is log archive mode is enabled or not.
0: 	   @return true if the log is being archived.
0: 	*/
0: 	public boolean logArchived();
0: 
0: 	/**
0: 		Get JBMS properties relavent to the log factory
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	 */
0: 	public void getLogFactoryProperties(PersistentSet set) 
0: 		 throws StandardException;
0: 
0: 	 /**
0: 		Return the location of the log directory.
0: 		@exception StandardException Standard Cloudscape Error Policy
0: 	  */
0: 	public StorageFile getLogDirectory() throws StandardException;
0: 
0: 	 /**
0: 		Return the canonical directory of the PARENT of the log directory.  The
0: 		log directory live in the "log" subdirectory of this path.  If the log
0: 		is at the default location (underneath the database directory), this
0: 		returns null.  Should only be called after the log factory is booted.
0: 	  */
0: 	public String getCanonicalLogPath();
0: 
0: 
0: 	/*
0: 	  copies the active log files and control files to the given directory
0: 	  Used copy the necessary log files while doing online backup
0: 	  @param toDir - location where the log files should be copied to.
0: 	  @return true if log files copy is  successful
0: 	  @exception StandardException - encounter exception while doing checkpoint.
0: 	*/
0: 	public boolean copyActiveLogFiles(File toDir) throws StandardException;
0: 
0: 	/*
0: 	 * Enable the log archive mode, when log archive mode is 
0: 	 * on the system keeps all the old log files instead
0: 	 * of deleting them at the checkpoint.
0: 	 * logArchive mode is persistent across the boots.
0: 	 * @exception StandardException - thrown on error
0: 	*/
0: 	public void enableLogArchiveMode() throws StandardException;
0: 
0: 		
0: 	/*
0: 	 * Disable the log archive mode, when log archive mode is 
0: 	 * off the system will delete  old log files(not required 
0: 	 * for crash recovery) after each checkpoint. 
0: 	 * @exception StandardException - thrown on error
0: 	*/
0: 	public void disableLogArchiveMode() throws StandardException;
0: 
0: 	/*
0: 	 * Deletes the archived log files store in the log directory path.
0: 	 * This call is typically used after a successful version level
0: 	 * backup to clean up the old log files that are no more
0: 	 * required to do roll-forward recovery from the last
0: 	 * backup taken.
0: 	*/
0: 	public void deleteOnlineArchivedLogFiles();
0: 
0: 	//Is the transaction in rollforward recovery
0: 	public boolean inRFR();
0: 
0: 	/**	
0: 	 * redoing a checkpoint  during rollforward recovery
0: 	 @param cinstant The LogInstant of the checkpoint
0: 	 @param redoLWM  Redo Low Water Mark in the check point record
0: 	 @param dataFactory - the data factory
0: 	 @exception StandardException - encounter exception during checkpoint
0: 	 */
0: 	public void checkpointInRFR(LogInstant cinstant, long redoLWM, 
0: 								DataFactory df) throws StandardException;
0: 
0: 
0: }
0: 
============================================================================