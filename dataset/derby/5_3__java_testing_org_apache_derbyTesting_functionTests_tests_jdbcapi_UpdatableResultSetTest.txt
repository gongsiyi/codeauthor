1:69d1cb8: /*
1:69d1cb8:  *
1:69d1cb8:  * Derby - Class UpdatableResultSetTest
1:69d1cb8:  *
1:69d1cb8:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:69d1cb8:  * contributor license agreements.  See the NOTICE file distributed with
1:69d1cb8:  * this work for additional information regarding copyright ownership.
1:69d1cb8:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:69d1cb8:  * (the "License"); you may not use this file except in compliance with
1:69d1cb8:  * the License.  You may obtain a copy of the License at
1:69d1cb8:  *
1:69d1cb8:  *    http://www.apache.org/licenses/LICENSE-2.0
1:69d1cb8:  *
1:69d1cb8:  * Unless required by applicable law or agreed to in writing, 
1:69d1cb8:  * software distributed under the License is distributed on an 
1:69d1cb8:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:69d1cb8:  * either express or implied. See the License for the specific 
1:69d1cb8:  * language governing permissions and limitations under the License.
1:69d1cb8:  */
1:69d1cb8: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
1:1ae02c9: import java.io.InputStream;
1:1ae02c9: import java.sql.Blob;
1:1ae02c9: import java.sql.Clob;
1:1ae02c9: import java.sql.Connection;
1:1ae02c9: import java.sql.PreparedStatement;
1:1ae02c9: import java.sql.ResultSet;
1:1ae02c9: import java.sql.SQLException;
1:1ae02c9: import java.sql.Statement;
1:1ae02c9: import junit.framework.Test;
1:69d1cb8: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:985662b: import org.apache.derbyTesting.junit.TestConfiguration;
7:69d1cb8: 
1:69d1cb8: /**
1:69d1cb8:  * Tests updatable result sets.
1:69d1cb8:  *
1:69d1cb8:  * DERBY-1767 - Test that the deleteRow, insertRow and updateRow methods 
1:69d1cb8:  * with column/table/schema/cursor names containing quotes.
1:69d1cb8:  *
1:69d1cb8:  */
1:69d1cb8: public class UpdatableResultSetTest extends BaseJDBCTestCase {
1:69d1cb8:     
1:89459c8:     private static final byte[] BYTES1 = {
1:89459c8:             0x65, 0x66, 0x67, 0x68, 0x69,
1:89459c8:             0x69, 0x68, 0x67, 0x66, 0x65
1:89459c8:         };
1:89459c8: 
1:89459c8:     private static final byte[] BYTES2 = {
1:89459c8:             0x69, 0x68, 0x67, 0x66, 0x65,
1:89459c8:             0x65, 0x66, 0x67, 0x68, 0x69
1:89459c8:         };
1:89459c8: 
1:89459c8:     /**
1:89459c8:      * Key used to identify inserted rows.
1:89459c8:      * Use method <code>requestKey</code> to obtain it.
1:89459c8:      **/
1:89459c8:     private static int insertKey = 0;
1:89459c8: 
1:89459c8:     private int key = -1;
1:89459c8: 
1:69d1cb8:     /** Creates a new instance of UpdatableResultSetTest */
1:69d1cb8:     public UpdatableResultSetTest(String name) {
1:69d1cb8:         super(name);
3:69d1cb8:     }
1:69d1cb8:     
1:4316596:     /**
1:4316596:      * Create require objects and data. No tearDown
1:4316596:      * is needed because these are created in non-auto-commit
1:4316596:      * mode and no commit is ever issued. Thus on the super's
1:4316596:      * tearDown the rollback will revert everything.
1:4316596:      */
1:69d1cb8:     protected void setUp() throws SQLException {
1:4316596:         Connection conn = getConnection();
1:69d1cb8:         conn.setAutoCommit(false);
1:69d1cb8:         Statement stmt = conn.createStatement();
1:69d1cb8:         
1:89459c8:         stmt.execute("create table UpdateTestTableResultSet (" +
1:89459c8:                             "sno int not null unique," +
1:89459c8:                             "dBlob BLOB," +
1:89459c8:                             "dClob CLOB," +
1:89459c8:                             "dLongVarchar LONG VARCHAR," +
1:89459c8:                             "dLongBit LONG VARCHAR FOR BIT DATA)");
1:89459c8: 
1:69d1cb8:         // Quoted table
1:69d1cb8:         stmt.executeUpdate("create table \"my \"\"quoted\"\" table\" (x int)");
1:69d1cb8:         stmt.executeUpdate("insert into \"my \"\"quoted\"\" table\" (x) " +
1:69d1cb8:                 "values (1), (2), (3)");
1:69d1cb8:         
1:69d1cb8:         // Quoted columns
1:69d1cb8:         stmt.executeUpdate("create table \"my quoted columns\" " +
1:69d1cb8:                 "(\"my \"\"quoted\"\" column\" int)");
1:69d1cb8:         stmt.executeUpdate("insert into \"my quoted columns\" " +
1:69d1cb8:                 "values (1), (2), (3) ");
1:69d1cb8:         
1:69d1cb8:         // Quoted schema
1:69d1cb8:         stmt.executeUpdate("create table \"my \"\"quoted\"\" schema\"." +
1:69d1cb8:                 "\"my quoted schema\" (x int)");
1:69d1cb8:         stmt.executeUpdate("insert into \"my \"\"quoted\"\" schema\"." +
1:69d1cb8:                 "\"my quoted schema\" values (1), (2), (3) ");
1:69d1cb8:         
1:69d1cb8:         // No quotes, use with quoted cursor
1:69d1cb8:         stmt.executeUpdate("create table \"my table\" (x int)");
1:69d1cb8:         stmt.executeUpdate("insert into \"my table\" values (1), (2), (3) ");
1:69d1cb8:         
1:69d1cb8:         stmt.close();
1:69d1cb8:     }
1:69d1cb8:     
1:39f0f38:     /** Create a test suite with all tests in this class. */
1:39f0f38:     public static Test suite() {
1:39f0f38: 
1:985662b:         return TestConfiguration.defaultSuite(UpdatableResultSetTest.class);
1:39f0f38:     }
1:39f0f38:     
1:69d1cb8:     /**
1:69d1cb8:      * Tests insertRow with table name containing quotes
1:69d1cb8:      */
1:69d1cb8:     public void testInsertRowOnQuotedTable() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.moveToInsertRow();
1:69d1cb8:         rs.updateInt(1, 4);
1:69d1cb8:         rs.insertRow();
1:69d1cb8:         rs.moveToCurrentRow();
1:69d1cb8:         rs.close();
1:89459c8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\" " +
1:69d1cb8:                 "order by x");
1:69d1cb8:         for (int i=1; i<=4; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:39f0f38:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();
1:69d1cb8:     }
1:89459c8: 
1:89459c8:     /**
1:69d1cb8:      * Tests updateRow with table name containing quotes
1:69d1cb8:      */
1:69d1cb8:     public void testUpdateRowOnQuotedTable() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.updateInt(1, 4);
1:69d1cb8:         rs.updateRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\" " +
1:69d1cb8:                 "order by x");
1:69d1cb8:         for (int i=2; i<=4; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();        
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests deleteRow with table name containing quotes
1:69d1cb8:      */
1:69d1cb8:     public void testDeleteRowOnQuotedTable() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.deleteRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\" " +
1:69d1cb8:                 "order by x");
1:69d1cb8:         for (int i=2; i<=3; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();                
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests insertRow with column name containing quotes
1:69d1cb8:      */    
1:69d1cb8:     public void testInsertRowOnQuotedColumn() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my quoted columns\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.moveToInsertRow();
1:69d1cb8:         rs.updateInt(1, 4);
1:69d1cb8:         rs.insertRow();
1:69d1cb8:         rs.moveToCurrentRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my quoted columns\" " +
1:69d1cb8:                 "order by \"my \"\"quoted\"\" column\"");
1:69d1cb8:         for (int i=1; i<=4; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests updateRow with column name containing quotes
1:69d1cb8:      */    
1:69d1cb8:     public void testUpdateRowOnQuotedColumn() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my quoted columns\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.updateInt(1, 4);
1:69d1cb8:         rs.updateRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my quoted columns\" " +
1:69d1cb8:                 "order by \"my \"\"quoted\"\" column\"");
1:69d1cb8:         for (int i=2; i<=4; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();        
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests deleteRow with column name containing quotes
1:69d1cb8:      */    
1:69d1cb8:     public void testDeleteRowOnQuotedColumn() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my quoted columns\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.deleteRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my quoted columns\" " +
1:69d1cb8:                 "order by \"my \"\"quoted\"\" column\"");
1:69d1cb8:         for (int i=2; i<=3; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();                
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests insertRow with schema name containing quotes
1:69d1cb8:      */    
1:69d1cb8:     public void testInsertRowOnQuotedSchema() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:69d1cb8:                 "\"my quoted schema\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.moveToInsertRow();
1:69d1cb8:         rs.updateInt(1, 4);
1:69d1cb8:         rs.insertRow();
1:69d1cb8:         rs.moveToCurrentRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:69d1cb8:                 "\"my quoted schema\" order by x");
1:69d1cb8:         for (int i=1; i<=4; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests updateRow with schema name containing quotes
1:69d1cb8:      */    
1:69d1cb8:     public void testUpdateRowOnQuotedSchema() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:69d1cb8:                 "\"my quoted schema\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.updateInt(1, 4);
1:69d1cb8:         rs.updateRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:69d1cb8:                 "\"my quoted schema\" order by x");
1:69d1cb8:         for (int i=2; i<=4; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();        
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests deleteRow with schema name containing quotes
1:69d1cb8:      */    
1:69d1cb8:     public void testDeleteRowOnQuotedSchema() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:69d1cb8:                 "\"my quoted schema\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.deleteRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:69d1cb8:                 "\"my quoted schema\" order by x");
1:69d1cb8:         for (int i=2; i<=3; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();                
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests insertRow with cursor name containing quotes
1:69d1cb8:      */    
1:69d1cb8:     public void testInsertRowOnQuotedCursor() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         stmt.setCursorName("my \"\"\"\"quoted\"\"\"\" cursor\"\"");
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my table\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.moveToInsertRow();
1:69d1cb8:         rs.updateInt(1, 4);
1:69d1cb8:         rs.insertRow();
1:69d1cb8:         rs.moveToCurrentRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my table\" order by x");
1:69d1cb8:         for (int i=1; i<=4; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests updateRow with cursor name containing quotes
1:69d1cb8:      */    
1:69d1cb8:     public void testUpdateRowOnQuotedCursor() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         stmt.setCursorName("\"\"my quoted cursor");
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my table\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.updateInt(1, 4);
1:69d1cb8:         rs.updateRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my table\" order by x");
1:69d1cb8:         for (int i=2; i<=4; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();        
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:69d1cb8:      * Tests deleteRow with cursor name containing quotes
1:69d1cb8:      */    
1:69d1cb8:     public void testDeleteRowOnQuotedCursor() throws SQLException {
1:69d1cb8:         ResultSet rs = null;
1:4316596:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:69d1cb8:                 ResultSet.CONCUR_UPDATABLE);
1:69d1cb8:         stmt.setCursorName("\"\"my quoted cursor\"\"");
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my table\"");
1:69d1cb8:         rs.next();
1:69d1cb8:         rs.deleteRow();
1:69d1cb8:         rs.close();
1:69d1cb8:         
1:69d1cb8:         rs = stmt.executeQuery("select * from \"my table\" order by x");
1:69d1cb8:         for (int i=2; i<=3; i++) {
1:69d1cb8:             assertTrue("there is a row", rs.next());
1:69d1cb8:             assertEquals("row contains correct value", i, rs.getInt(1));
1:69d1cb8:         }
1:69d1cb8:         rs.close();
1:69d1cb8:         stmt.close();                
1:69d1cb8:     }
1:69d1cb8: 
1:69d1cb8:     /**
1:89459c8:      * This methods tests the ResultSet interface method
1:89459c8:      * updateBlob
1:89459c8:      *
1:89459c8:      * @throws Exception
1:89459c8:      */
1:89459c8:     public void testUpdateBlob()
1:89459c8:     throws Exception {
1:89459c8:         //Byte array in which the returned bytes from
1:89459c8:         //the Database after the update are stored. This
1:89459c8:         //array is then checked to determine if it
1:89459c8:         //has the same elements of the Byte array used for
1:89459c8:         //the update operation
1:89459c8: 
1:89459c8:         byte[] bytes_ret = new byte[10];
1:89459c8: 
1:89459c8:         //1 Input Stream for insertion
1:89459c8:         InputStream is1 = new java.io.ByteArrayInputStream(BYTES1);
1:89459c8: 
1:89459c8:         //2 Input Stream for insertion
1:89459c8:         InputStream is2 = new java.io.ByteArrayInputStream(BYTES2);
1:89459c8: 
1:89459c8:         //Prepared Statement used to insert the data
1:89459c8:         PreparedStatement ps_sb = prep("dBlob");
1:89459c8: 
1:89459c8:         //first insert
1:89459c8:         ps_sb.setInt(1, key);
1:89459c8:         ps_sb.setBinaryStream(2,is1,BYTES1.length);
1:89459c8:         ps_sb.executeUpdate();
1:89459c8: 
1:89459c8:         //second insert
1:89459c8:         int key2 = requestKey();
1:89459c8:         ps_sb.setInt(1, key2);
1:89459c8:         ps_sb.setBinaryStream(2,is2,BYTES2.length);
1:89459c8:         ps_sb.executeUpdate();
1:89459c8: 
1:89459c8:         ps_sb.close();
1:89459c8: 
1:89459c8:         //Update operation
1:89459c8:         //use a different ResultSet variable so that the
1:89459c8:         //other tests can go on unimpacted
1:89459c8:         //we do not have set methods on Clob and Blob implemented
1:89459c8:         //So query the first Clob from the database
1:89459c8:         //update the second result set with this
1:89459c8:         //Clob value
1:89459c8: 
1:89459c8:         ResultSet rs1 = fetch("dBlob", key);
1:89459c8:         rs1.next();
1:89459c8:         Blob blob = rs1.getBlob(1);
1:89459c8:         rs1.close();
1:89459c8: 
1:89459c8:         rs1 = fetchUpd("dBlob", key2);
1:89459c8:         rs1.next();
1:89459c8:         rs1.updateBlob(1,blob);
1:89459c8:         rs1.updateRow();
1:89459c8:         rs1.close();
1:89459c8: 
1:89459c8:         //Query to see whether the data that has been updated
1:89459c8:         //using the updateBlob method is the same
1:89459c8:         //data that we expected
1:89459c8: 
1:89459c8:         rs1 = fetch("dBlob", key2);
1:89459c8:         rs1.next();
1:89459c8:         assertEquals(blob, rs1.getBlob(1));
1:89459c8:         rs1.close();
1:89459c8:     }
1:89459c8: 
1:89459c8:     /**
1:89459c8:      * This methods tests the ResultSet interface method
1:89459c8:      * updateBlob
1:89459c8:      *
1:89459c8:      * @throws Exception
1:89459c8:      */
1:89459c8:     public void testUpdateBlobStringParameterName()
1:89459c8:     throws Exception {
1:89459c8:         //Byte array in which the returned bytes from
1:89459c8:         //the Database after the update are stored. This
1:89459c8:         //array is then checked to determine if it
1:89459c8:         //has the same elements of the Byte array used for
1:89459c8:         //the update operation
1:89459c8: 
1:89459c8:         byte[] bytes_ret = new byte[10];
1:89459c8: 
1:89459c8:         //1 Input Stream for insertion
1:89459c8:         InputStream is1 = new java.io.ByteArrayInputStream(BYTES1);
1:89459c8: 
1:89459c8:         //2 Input Stream for insertion
1:89459c8:         InputStream is2 = new java.io.ByteArrayInputStream(BYTES2);
1:89459c8: 
1:89459c8:         //Prepared Statement used to insert the data
1:89459c8:         PreparedStatement ps_sb = prep("dBlob");
1:89459c8: 
1:89459c8:         //first insert
1:89459c8:         ps_sb.setInt(1, key);
1:89459c8:         ps_sb.setBinaryStream(2,is1,BYTES1.length);
1:89459c8:         ps_sb.executeUpdate();
1:89459c8: 
1:89459c8:         //second insert
1:89459c8:         int key2 = requestKey();
1:89459c8:         ps_sb.setInt(1, key2);
1:89459c8:         ps_sb.setBinaryStream(2,is2,BYTES2.length);
1:89459c8:         ps_sb.executeUpdate();
1:89459c8: 
1:89459c8:         ps_sb.close();
1:89459c8: 
1:89459c8:         //Update operation
1:89459c8:         //use a different ResultSet variable so that the
1:89459c8:         //other tests can go on unimpacted
1:89459c8:         //we do not have set methods on Clob and Blob implemented
1:89459c8:         //So query the first Clob from the database
1:89459c8:         //update the second result set with this
1:89459c8:         //Clob value
1:89459c8: 
1:89459c8:         ResultSet rs1 = fetch("dBlob", key);
1:89459c8:         rs1.next();
1:89459c8:         Blob blob = rs1.getBlob(1);
1:89459c8:         rs1.close();
1:89459c8: 
1:89459c8:         rs1 = fetchUpd("dBlob", key2);
1:89459c8:         rs1.next();
1:89459c8:         rs1.updateBlob("dBlob",blob);
1:89459c8:         rs1.updateRow();
1:89459c8:         rs1.close();
1:89459c8: 
1:89459c8:         //Query to see whether the data that has been updated
1:89459c8:         //using the updateBlob method is the same
1:89459c8:         //data that we expected
1:89459c8: 
1:89459c8:         rs1 = fetch("dBlob", key2);
1:89459c8:         rs1.next();
1:89459c8:         assertEquals(blob, rs1.getBlob(1));
1:89459c8:         rs1.close();
1:89459c8:     }
1:89459c8: 
1:89459c8:     /**
1:89459c8:      * This methods tests the ResultSet interface method
1:89459c8:      * updateClob
1:89459c8:      *
1:89459c8:      * @throws Exception
1:89459c8:      */
1:89459c8:     public void testUpdateClob()
1:89459c8:     throws Exception {
1:89459c8:         //Byte array in which the returned bytes from
1:89459c8:         //the Database after the update are stored. This
1:89459c8:         //array is then checked to determine if it
1:89459c8:         //has the same elements of the Byte array used for
1:89459c8:         //the update operation
1:89459c8: 
1:89459c8:         byte[] bytes_ret = new byte[10];
1:89459c8: 
1:89459c8:         //1 Input Stream for insertion
1:89459c8:         InputStream is1 = new java.io.ByteArrayInputStream(BYTES1);
1:89459c8: 
1:89459c8:         //2 Input Stream for insertion
1:89459c8:         InputStream is2 = new java.io.ByteArrayInputStream(BYTES2);
1:89459c8: 
1:89459c8:         //Prepared Statement used to insert the data
1:89459c8:         PreparedStatement ps_sb = prep("dClob");
1:89459c8: 
1:89459c8:         //first insert
1:89459c8:         ps_sb.setInt(1,key);
1:89459c8:         ps_sb.setAsciiStream(2,is1,BYTES1.length);
1:89459c8:         ps_sb.executeUpdate();
1:89459c8: 
1:89459c8:         //second insert
1:89459c8:         int key2 = requestKey();
1:89459c8:         ps_sb.setInt(1,key2);
1:89459c8:         ps_sb.setAsciiStream(2,is2,BYTES2.length);
1:89459c8:         ps_sb.executeUpdate();
1:89459c8: 
1:89459c8:         ps_sb.close();
1:89459c8: 
1:89459c8:         //Update operation
1:89459c8:         //use a different ResultSet variable so that the
1:89459c8:         //other tests can go on unimpacted
1:89459c8:         //we do not have set methods on Clob and Blob implemented
1:89459c8:         //So query the first Clob from the database
1:89459c8:         //update the second result set with this
1:89459c8:         //Clob value
1:89459c8: 
1:89459c8:         ResultSet rs1 = fetchUpd("dClob", key);
1:89459c8:         rs1.next();
1:89459c8:         Clob clob = rs1.getClob(1);
1:89459c8:         rs1.close();
1:89459c8: 
1:89459c8:         rs1 = fetchUpd("dClob", key2);
1:89459c8:         rs1.next();
1:89459c8:         rs1.updateClob(1,clob);
1:89459c8:         rs1.updateRow();
1:89459c8:         rs1.close();
1:89459c8: 
1:89459c8:         //Query to see whether the data that has been updated
1:89459c8:         //using the updateClob method is the same
1:89459c8:         //data that we expected
1:89459c8: 
1:89459c8:         rs1 = fetch("dClob", key2);
1:89459c8:         rs1.next();
1:89459c8:         assertEquals(clob, rs1.getClob(1));
1:89459c8:         rs1.close();
1:89459c8:     }
1:89459c8: 
1:89459c8:     /**
1:89459c8:      * This methods tests the ResultSet interface method
1:89459c8:      * updateClob
1:89459c8:      *
1:89459c8:      * @throws Exception
1:89459c8:      */
1:89459c8:     public void testUpdateClobStringParameterName()
1:89459c8:     throws Exception {
1:89459c8:         //Byte array in which the returned bytes from
1:89459c8:         //the Database after the update are stored. This
1:89459c8:         //array is then checked to determine if it
1:89459c8:         //has the same elements of the Byte array used for
1:89459c8:         //the update operation
1:89459c8: 
1:89459c8:         byte[] bytes_ret = new byte[10];
1:89459c8: 
1:89459c8:         //1 Input Stream for insertion
1:89459c8:         InputStream is1 = new java.io.ByteArrayInputStream(BYTES1);
1:89459c8: 
1:89459c8:         //2 Input Stream for insertion
1:89459c8:         InputStream is2 = new java.io.ByteArrayInputStream(BYTES2);
1:89459c8: 
1:89459c8:         //Prepared Statement used to insert the data
1:89459c8:         PreparedStatement ps_sb = prep("dClob");
1:89459c8: 
1:89459c8:         //first insert
1:89459c8:         ps_sb.setInt(1, key);
1:89459c8:         ps_sb.setAsciiStream(2,is1,BYTES1.length);
1:89459c8:         ps_sb.executeUpdate();
1:89459c8: 
1:89459c8:         //second insert
1:89459c8:         int key2 = requestKey();
1:89459c8:         ps_sb.setInt(1, key2);
1:89459c8:         ps_sb.setAsciiStream(2,is2,BYTES2.length);
1:89459c8:         ps_sb.executeUpdate();
1:89459c8: 
1:89459c8:         ps_sb.close();
1:89459c8: 
1:89459c8:         //Update operation
1:89459c8:         //use a different ResultSet variable so that the
1:89459c8:         //other tests can go on unimpacted
1:89459c8:         //we do not have set methods on Clob and Blob implemented
1:89459c8:         //So query the first Clob from the database
1:89459c8:         //update the second result set with this
1:89459c8:         //Clob value
1:89459c8: 
1:89459c8:         ResultSet rs1 = fetch("dClob", key);
1:89459c8:         rs1.next();
1:89459c8:         Clob clob = rs1.getClob(1);
1:89459c8:         rs1.close();
1:89459c8: 
1:89459c8:         rs1 = fetchUpd("dClob", key2);
1:89459c8:         rs1.next();
1:89459c8:         rs1.updateClob("dClob",clob);
1:89459c8:         rs1.updateRow();
1:89459c8:         rs1.close();
1:89459c8: 
1:89459c8:         //Query to see whether the data that has been updated
1:89459c8:         //using the updateClob method is the same
1:89459c8:         //data that we expected
1:89459c8: 
1:89459c8:         rs1 = fetch("dClob", key2);
1:89459c8:         rs1.next();
1:89459c8:         assertEquals(clob, rs1.getClob(1));
1:89459c8:         rs1.close();
1:89459c8:     }
1:69d1cb8: 
1:89459c8:     /**
1:89459c8:      * Get a key that is used to identify an inserted row.
1:89459c8:      * Introduced to avoid having to delete table contents after each test,
1:89459c8:      * and because the order of the tests is not guaranteed.
1:89459c8:      *
1:89459c8:      * @return an integer in range [1, Integer.MAX_VALUE -1]
1:89459c8:      */
1:89459c8:     private static final int requestKey() {
1:89459c8:         return ++insertKey;
1:89459c8:     }
1:89459c8: 
1:89459c8:     /**
1:89459c8:      * Prepare commonly used statement to insert a row.
1:89459c8:      *
1:89459c8:      * @param colName name of the column to insert into
1:89459c8:      * @throws SQLException
1:89459c8:      */
1:89459c8:     private PreparedStatement prep(String colName)
1:89459c8:             throws SQLException {
1:89459c8:         return prepareStatement("insert into UpdateTestTableResultSet " +
1:89459c8:                 "(sno, " + colName + ") values (?,?)");
1:89459c8:     }
1:89459c8: 
1:89459c8:     /**
1:89459c8:      * Fetch the specified row for update.
1:89459c8:      *
1:89459c8:      * @param colName name of the column to fetch
1:89459c8:      * @param key identifier for row to fetch
1:89459c8:      * @return a <code>ResultSet</code> with zero or one row, depending on
1:89459c8:      *      the key used
1:89459c8:      * @throws SQLException
1:89459c8:      */
1:89459c8:     private ResultSet fetchUpd(String colName, int key)
1:89459c8:             throws SQLException {
1:89459c8:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:89459c8:                                              ResultSet.CONCUR_UPDATABLE);
1:89459c8:         return stmt.executeQuery("select " + colName +
1:89459c8:                 " from UpdateTestTableResultSet where sno = " + key +
1:89459c8:                 " for update");
1:89459c8:     }
1:89459c8: 
1:89459c8:     /**
1:89459c8:      * Fetch the specified row.
1:89459c8:      *
1:89459c8:      * @param colName name of the column to fetch
1:89459c8:      * @param key identifier for row to fetch
1:89459c8:      * @return a <code>ResultSet</code> with zero or one row, depending on
1:89459c8:      *      the key used
1:89459c8:      * @throws SQLException
1:89459c8:      */
1:89459c8:     private ResultSet fetch(String colName, int key)
1:89459c8:             throws SQLException {
1:89459c8:         Statement stmt = createStatement();
1:89459c8:         return stmt.executeQuery("select " + colName +
1:89459c8:                 " from UpdateTestTableResultSet where sno = " + key);
1:89459c8:     }
1:69d1cb8: }
============================================================================
author:Dag H. Wanvik
-------------------------------------------------------------------------------
commit:1ae02c9
/////////////////////////////////////////////////////////////////////////
1: import java.io.InputStream;
1: import java.sql.Blob;
1: import java.sql.Clob;
1: import java.sql.Connection;
1: import java.sql.PreparedStatement;
1: import java.sql.ResultSet;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import junit.framework.Test;
author:Myrna van Lunteren
-------------------------------------------------------------------------------
commit:7dc89cf
/////////////////////////////////////////////////////////////////////////
author:Kristian Waagan
-------------------------------------------------------------------------------
commit:cd1bd2a
/////////////////////////////////////////////////////////////////////////
0:         if (usingDB2Client()) {
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:89459c8
/////////////////////////////////////////////////////////////////////////
0: import java.io.*;
/////////////////////////////////////////////////////////////////////////
1:     private static final byte[] BYTES1 = {
1:             0x65, 0x66, 0x67, 0x68, 0x69,
1:             0x69, 0x68, 0x67, 0x66, 0x65
1:         };
1: 
1:     private static final byte[] BYTES2 = {
1:             0x69, 0x68, 0x67, 0x66, 0x65,
1:             0x65, 0x66, 0x67, 0x68, 0x69
1:         };
1: 
1:     /**
1:      * Key used to identify inserted rows.
1:      * Use method <code>requestKey</code> to obtain it.
1:      **/
1:     private static int insertKey = 0;
1: 
1:     private int key = -1;
1: 
/////////////////////////////////////////////////////////////////////////
1:         stmt.execute("create table UpdateTestTableResultSet (" +
1:                             "sno int not null unique," +
1:                             "dBlob BLOB," +
1:                             "dClob CLOB," +
1:                             "dLongVarchar LONG VARCHAR," +
1:                             "dLongBit LONG VARCHAR FOR BIT DATA)");
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * This methods tests the ResultSet interface method
1:      * updateBlob
1:      *
1:      * @throws Exception
1:      */
1:     public void testUpdateBlob()
1:     throws Exception {
1:         //Byte array in which the returned bytes from
1:         //the Database after the update are stored. This
1:         //array is then checked to determine if it
1:         //has the same elements of the Byte array used for
1:         //the update operation
1: 
1:         byte[] bytes_ret = new byte[10];
1: 
1:         //1 Input Stream for insertion
1:         InputStream is1 = new java.io.ByteArrayInputStream(BYTES1);
1: 
1:         //2 Input Stream for insertion
1:         InputStream is2 = new java.io.ByteArrayInputStream(BYTES2);
1: 
1:         //Prepared Statement used to insert the data
1:         PreparedStatement ps_sb = prep("dBlob");
1: 
1:         //first insert
1:         ps_sb.setInt(1, key);
1:         ps_sb.setBinaryStream(2,is1,BYTES1.length);
1:         ps_sb.executeUpdate();
1: 
1:         //second insert
1:         int key2 = requestKey();
1:         ps_sb.setInt(1, key2);
1:         ps_sb.setBinaryStream(2,is2,BYTES2.length);
1:         ps_sb.executeUpdate();
1: 
1:         ps_sb.close();
1: 
1:         //Update operation
1:         //use a different ResultSet variable so that the
1:         //other tests can go on unimpacted
1:         //we do not have set methods on Clob and Blob implemented
1:         //So query the first Clob from the database
1:         //update the second result set with this
1:         //Clob value
1: 
1:         ResultSet rs1 = fetch("dBlob", key);
1:         rs1.next();
1:         Blob blob = rs1.getBlob(1);
1:         rs1.close();
1: 
1:         rs1 = fetchUpd("dBlob", key2);
1:         rs1.next();
1:         rs1.updateBlob(1,blob);
1:         rs1.updateRow();
1:         rs1.close();
1: 
1:         //Query to see whether the data that has been updated
1:         //using the updateBlob method is the same
1:         //data that we expected
1: 
1:         rs1 = fetch("dBlob", key2);
1:         rs1.next();
1:         assertEquals(blob, rs1.getBlob(1));
1:         rs1.close();
1:     }
1: 
1:     /**
1:      * This methods tests the ResultSet interface method
1:      * updateBlob
1:      *
1:      * @throws Exception
1:      */
1:     public void testUpdateBlobStringParameterName()
1:     throws Exception {
1:         //Byte array in which the returned bytes from
1:         //the Database after the update are stored. This
1:         //array is then checked to determine if it
1:         //has the same elements of the Byte array used for
1:         //the update operation
1: 
1:         byte[] bytes_ret = new byte[10];
1: 
1:         //1 Input Stream for insertion
1:         InputStream is1 = new java.io.ByteArrayInputStream(BYTES1);
1: 
1:         //2 Input Stream for insertion
1:         InputStream is2 = new java.io.ByteArrayInputStream(BYTES2);
1: 
1:         //Prepared Statement used to insert the data
1:         PreparedStatement ps_sb = prep("dBlob");
1: 
1:         //first insert
1:         ps_sb.setInt(1, key);
1:         ps_sb.setBinaryStream(2,is1,BYTES1.length);
1:         ps_sb.executeUpdate();
1: 
1:         //second insert
1:         int key2 = requestKey();
1:         ps_sb.setInt(1, key2);
1:         ps_sb.setBinaryStream(2,is2,BYTES2.length);
1:         ps_sb.executeUpdate();
1: 
1:         ps_sb.close();
1: 
1:         //Update operation
1:         //use a different ResultSet variable so that the
1:         //other tests can go on unimpacted
1:         //we do not have set methods on Clob and Blob implemented
1:         //So query the first Clob from the database
1:         //update the second result set with this
1:         //Clob value
1: 
1:         ResultSet rs1 = fetch("dBlob", key);
1:         rs1.next();
1:         Blob blob = rs1.getBlob(1);
1:         rs1.close();
1: 
1:         rs1 = fetchUpd("dBlob", key2);
1:         rs1.next();
1:         rs1.updateBlob("dBlob",blob);
1:         rs1.updateRow();
1:         rs1.close();
1: 
1:         //Query to see whether the data that has been updated
1:         //using the updateBlob method is the same
1:         //data that we expected
1: 
1:         rs1 = fetch("dBlob", key2);
1:         rs1.next();
1:         assertEquals(blob, rs1.getBlob(1));
1:         rs1.close();
1:     }
1: 
1:     /**
1:      * This methods tests the ResultSet interface method
1:      * updateClob
1:      *
1:      * @throws Exception
1:      */
1:     public void testUpdateClob()
1:     throws Exception {
1:         //Byte array in which the returned bytes from
1:         //the Database after the update are stored. This
1:         //array is then checked to determine if it
1:         //has the same elements of the Byte array used for
1:         //the update operation
1: 
1:         byte[] bytes_ret = new byte[10];
1: 
1:         //1 Input Stream for insertion
1:         InputStream is1 = new java.io.ByteArrayInputStream(BYTES1);
1: 
1:         //2 Input Stream for insertion
1:         InputStream is2 = new java.io.ByteArrayInputStream(BYTES2);
1: 
1:         //Prepared Statement used to insert the data
1:         PreparedStatement ps_sb = prep("dClob");
1: 
1:         //first insert
1:         ps_sb.setInt(1,key);
1:         ps_sb.setAsciiStream(2,is1,BYTES1.length);
1:         ps_sb.executeUpdate();
1: 
1:         //second insert
1:         int key2 = requestKey();
1:         ps_sb.setInt(1,key2);
1:         ps_sb.setAsciiStream(2,is2,BYTES2.length);
1:         ps_sb.executeUpdate();
1: 
1:         ps_sb.close();
1: 
1:         //Update operation
1:         //use a different ResultSet variable so that the
1:         //other tests can go on unimpacted
1:         //we do not have set methods on Clob and Blob implemented
1:         //So query the first Clob from the database
1:         //update the second result set with this
1:         //Clob value
1: 
1:         ResultSet rs1 = fetchUpd("dClob", key);
1:         rs1.next();
1:         Clob clob = rs1.getClob(1);
1:         rs1.close();
1: 
1:         rs1 = fetchUpd("dClob", key2);
1:         rs1.next();
1:         rs1.updateClob(1,clob);
1:         rs1.updateRow();
1:         rs1.close();
1: 
1:         //Query to see whether the data that has been updated
1:         //using the updateClob method is the same
1:         //data that we expected
1: 
1:         rs1 = fetch("dClob", key2);
1:         rs1.next();
1:         assertEquals(clob, rs1.getClob(1));
1:         rs1.close();
1:     }
1: 
1:     /**
1:      * This methods tests the ResultSet interface method
1:      * updateClob
1:      *
1:      * @throws Exception
1:      */
1:     public void testUpdateClobStringParameterName()
1:     throws Exception {
1:         //Byte array in which the returned bytes from
1:         //the Database after the update are stored. This
1:         //array is then checked to determine if it
1:         //has the same elements of the Byte array used for
1:         //the update operation
1: 
1:         byte[] bytes_ret = new byte[10];
1: 
1:         //1 Input Stream for insertion
1:         InputStream is1 = new java.io.ByteArrayInputStream(BYTES1);
1: 
1:         //2 Input Stream for insertion
1:         InputStream is2 = new java.io.ByteArrayInputStream(BYTES2);
1: 
1:         //Prepared Statement used to insert the data
1:         PreparedStatement ps_sb = prep("dClob");
1: 
1:         //first insert
1:         ps_sb.setInt(1, key);
1:         ps_sb.setAsciiStream(2,is1,BYTES1.length);
1:         ps_sb.executeUpdate();
1: 
1:         //second insert
1:         int key2 = requestKey();
1:         ps_sb.setInt(1, key2);
1:         ps_sb.setAsciiStream(2,is2,BYTES2.length);
1:         ps_sb.executeUpdate();
1: 
1:         ps_sb.close();
1: 
1:         //Update operation
1:         //use a different ResultSet variable so that the
1:         //other tests can go on unimpacted
1:         //we do not have set methods on Clob and Blob implemented
1:         //So query the first Clob from the database
1:         //update the second result set with this
1:         //Clob value
1: 
1:         ResultSet rs1 = fetch("dClob", key);
1:         rs1.next();
1:         Clob clob = rs1.getClob(1);
1:         rs1.close();
1: 
1:         rs1 = fetchUpd("dClob", key2);
1:         rs1.next();
1:         rs1.updateClob("dClob",clob);
1:         rs1.updateRow();
1:         rs1.close();
1: 
1:         //Query to see whether the data that has been updated
1:         //using the updateClob method is the same
1:         //data that we expected
1: 
1:         rs1 = fetch("dClob", key2);
1:         rs1.next();
1:         assertEquals(clob, rs1.getClob(1));
1:         rs1.close();
1:     }
1: 
1:     /**
1:      * Get a key that is used to identify an inserted row.
1:      * Introduced to avoid having to delete table contents after each test,
1:      * and because the order of the tests is not guaranteed.
1:      *
1:      * @return an integer in range [1, Integer.MAX_VALUE -1]
1:      */
1:     private static final int requestKey() {
1:         return ++insertKey;
1:     }
1: 
1:     /**
1:      * Prepare commonly used statement to insert a row.
1:      *
1:      * @param colName name of the column to insert into
1:      * @throws SQLException
1:      */
1:     private PreparedStatement prep(String colName)
1:             throws SQLException {
1:         return prepareStatement("insert into UpdateTestTableResultSet " +
1:                 "(sno, " + colName + ") values (?,?)");
1:     }
1: 
1:     /**
1:      * Fetch the specified row for update.
1:      *
1:      * @param colName name of the column to fetch
1:      * @param key identifier for row to fetch
1:      * @return a <code>ResultSet</code> with zero or one row, depending on
1:      *      the key used
1:      * @throws SQLException
1:      */
1:     private ResultSet fetchUpd(String colName, int key)
1:             throws SQLException {
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY,
1:                                              ResultSet.CONCUR_UPDATABLE);
1:         return stmt.executeQuery("select " + colName +
1:                 " from UpdateTestTableResultSet where sno = " + key +
1:                 " for update");
1:     }
1: 
1:     /**
1:      * Fetch the specified row.
1:      *
1:      * @param colName name of the column to fetch
1:      * @param key identifier for row to fetch
1:      * @return a <code>ResultSet</code> with zero or one row, depending on
1:      *      the key used
1:      * @throws SQLException
1:      */
1:     private ResultSet fetch(String colName, int key)
1:             throws SQLException {
1:         Statement stmt = createStatement();
1:         return stmt.executeQuery("select " + colName +
1:                 " from UpdateTestTableResultSet where sno = " + key);
1:     }
commit:41c47be
/////////////////////////////////////////////////////////////////////////
0:     protected void tearDown() throws Exception {
0:         super.tearDown();
0:         conn = null;
commit:39f0f38
/////////////////////////////////////////////////////////////////////////
1:     /** Create a test suite with all tests in this class. */
1:     public static Test suite() {
0:         TestSuite ts = new TestSuite();
1: 
0:         // Test will fail with JCC.
0:         if (usingDerbyNet()) {
0:             return ts;
1:         }
1: 
0:         ts.addTestSuite(UpdatableResultSetTest.class);
0:         return ts;
1:     }
commit:69d1cb8
/////////////////////////////////////////////////////////////////////////
1: /*
1:  *
1:  * Derby - Class UpdatableResultSetTest
1:  *
1:  * Licensed to the Apache Software Foundation (ASF) under one or more
1:  * contributor license agreements.  See the NOTICE file distributed with
1:  * this work for additional information regarding copyright ownership.
1:  * The ASF licenses this file to You under the Apache License, Version 2.0
1:  * (the "License"); you may not use this file except in compliance with
1:  * the License.  You may obtain a copy of the License at
1:  *
1:  *    http://www.apache.org/licenses/LICENSE-2.0
1:  *
1:  * Unless required by applicable law or agreed to in writing, 
1:  * software distributed under the License is distributed on an 
1:  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
1:  * either express or implied. See the License for the specific 
1:  * language governing permissions and limitations under the License.
1:  */
1: package org.apache.derbyTesting.functionTests.tests.jdbcapi;
0: import org.apache.derbyTesting.functionTests.util.TestUtil;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
0: import org.apache.derbyTesting.junit.JDBC;
1: 
0: import junit.framework.*;
0: import java.sql.*;
1: 
1: /**
1:  * Tests updatable result sets.
1:  *
1:  * DERBY-1767 - Test that the deleteRow, insertRow and updateRow methods 
1:  * with column/table/schema/cursor names containing quotes.
1:  *
1:  */
1: public class UpdatableResultSetTest extends BaseJDBCTestCase {
1:     
1:     /** Creates a new instance of UpdatableResultSetTest */
1:     public UpdatableResultSetTest(String name) {
1:         super(name);
1:     }
1: 
0:     private Connection conn = null;
1:     
1:     protected void setUp() throws SQLException {
0:         conn = getConnection();
1:         conn.setAutoCommit(false);
1:         Statement stmt = conn.createStatement();
1:         
1:         // Quoted table
1:         stmt.executeUpdate("create table \"my \"\"quoted\"\" table\" (x int)");
1:         stmt.executeUpdate("insert into \"my \"\"quoted\"\" table\" (x) " +
1:                 "values (1), (2), (3)");
1:         
1:         // Quoted columns
1:         stmt.executeUpdate("create table \"my quoted columns\" " +
1:                 "(\"my \"\"quoted\"\" column\" int)");
1:         stmt.executeUpdate("insert into \"my quoted columns\" " +
1:                 "values (1), (2), (3) ");
1:         
1:         // Quoted schema
1:         stmt.executeUpdate("create table \"my \"\"quoted\"\" schema\"." +
1:                 "\"my quoted schema\" (x int)");
1:         stmt.executeUpdate("insert into \"my \"\"quoted\"\" schema\"." +
1:                 "\"my quoted schema\" values (1), (2), (3) ");
1:         
1:         // No quotes, use with quoted cursor
1:         stmt.executeUpdate("create table \"my table\" (x int)");
1:         stmt.executeUpdate("insert into \"my table\" values (1), (2), (3) ");
1:         
1:         
1:         
1:         stmt.close();
1:     }
1: 
0:     protected void tearDown() throws SQLException {
0:         conn.rollback();
0:         conn.close();
1:     }
1:     
1:     
1:     /**
1:      * Tests insertRow with table name containing quotes
1:      */
1:     public void testInsertRowOnQuotedTable() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\"");
1:         rs.next();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, 4);
1:         rs.insertRow();
1:         rs.moveToCurrentRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\" " +
1:                 "order by x");
1:         for (int i=1; i<=4; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests updateRow with table name containing quotes
1:      */
1:     public void testUpdateRowOnQuotedTable() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\"");
1:         rs.next();
1:         rs.updateInt(1, 4);
1:         rs.updateRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\" " +
1:                 "order by x");
1:         for (int i=2; i<=4; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();        
1:     }
1: 
1:     /**
1:      * Tests deleteRow with table name containing quotes
1:      */
1:     public void testDeleteRowOnQuotedTable() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\"");
1:         rs.next();
1:         rs.deleteRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" table\" " +
1:                 "order by x");
1:         for (int i=2; i<=3; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();                
1:     }
1: 
1:     /**
1:      * Tests insertRow with column name containing quotes
1:      */    
1:     public void testInsertRowOnQuotedColumn() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         rs = stmt.executeQuery("select * from \"my quoted columns\"");
1:         rs.next();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, 4);
1:         rs.insertRow();
1:         rs.moveToCurrentRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my quoted columns\" " +
1:                 "order by \"my \"\"quoted\"\" column\"");
1:         for (int i=1; i<=4; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests updateRow with column name containing quotes
1:      */    
1:     public void testUpdateRowOnQuotedColumn() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         rs = stmt.executeQuery("select * from \"my quoted columns\"");
1:         rs.next();
1:         rs.updateInt(1, 4);
1:         rs.updateRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my quoted columns\" " +
1:                 "order by \"my \"\"quoted\"\" column\"");
1:         for (int i=2; i<=4; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();        
1:     }
1: 
1:     /**
1:      * Tests deleteRow with column name containing quotes
1:      */    
1:     public void testDeleteRowOnQuotedColumn() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         rs = stmt.executeQuery("select * from \"my quoted columns\"");
1:         rs.next();
1:         rs.deleteRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my quoted columns\" " +
1:                 "order by \"my \"\"quoted\"\" column\"");
1:         for (int i=2; i<=3; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();                
1:     }
1: 
1:     /**
1:      * Tests insertRow with schema name containing quotes
1:      */    
1:     public void testInsertRowOnQuotedSchema() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:                 "\"my quoted schema\"");
1:         rs.next();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, 4);
1:         rs.insertRow();
1:         rs.moveToCurrentRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:                 "\"my quoted schema\" order by x");
1:         for (int i=1; i<=4; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests updateRow with schema name containing quotes
1:      */    
1:     public void testUpdateRowOnQuotedSchema() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:                 "\"my quoted schema\"");
1:         rs.next();
1:         rs.updateInt(1, 4);
1:         rs.updateRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:                 "\"my quoted schema\" order by x");
1:         for (int i=2; i<=4; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();        
1:     }
1: 
1:     /**
1:      * Tests deleteRow with schema name containing quotes
1:      */    
1:     public void testDeleteRowOnQuotedSchema() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:                 "\"my quoted schema\"");
1:         rs.next();
1:         rs.deleteRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my \"\"quoted\"\" schema\"." +
1:                 "\"my quoted schema\" order by x");
1:         for (int i=2; i<=3; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();                
1:     }
1: 
1:     /**
1:      * Tests insertRow with cursor name containing quotes
1:      */    
1:     public void testInsertRowOnQuotedCursor() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         stmt.setCursorName("my \"\"\"\"quoted\"\"\"\" cursor\"\"");
1:         rs = stmt.executeQuery("select * from \"my table\"");
1:         rs.next();
1:         rs.moveToInsertRow();
1:         rs.updateInt(1, 4);
1:         rs.insertRow();
1:         rs.moveToCurrentRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my table\" order by x");
1:         for (int i=1; i<=4; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();
1:     }
1: 
1:     /**
1:      * Tests updateRow with cursor name containing quotes
1:      */    
1:     public void testUpdateRowOnQuotedCursor() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         stmt.setCursorName("\"\"my quoted cursor");
1:         rs = stmt.executeQuery("select * from \"my table\"");
1:         rs.next();
1:         rs.updateInt(1, 4);
1:         rs.updateRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my table\" order by x");
1:         for (int i=2; i<=4; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();        
1:     }
1: 
1:     /**
1:      * Tests deleteRow with cursor name containing quotes
1:      */    
1:     public void testDeleteRowOnQuotedCursor() throws SQLException {
1:         ResultSet rs = null;
0:         Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
1:                 ResultSet.CONCUR_UPDATABLE);
1:         stmt.setCursorName("\"\"my quoted cursor\"\"");
1:         rs = stmt.executeQuery("select * from \"my table\"");
1:         rs.next();
1:         rs.deleteRow();
1:         rs.close();
1:         
1:         rs = stmt.executeQuery("select * from \"my table\" order by x");
1:         for (int i=2; i<=3; i++) {
1:             assertTrue("there is a row", rs.next());
1:             assertEquals("row contains correct value", i, rs.getInt(1));
1:         }
1:         rs.close();
1:         stmt.close();                
1:     }
1: }
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:4316596
/////////////////////////////////////////////////////////////////////////
1:     /**
1:      * Create require objects and data. No tearDown
1:      * is needed because these are created in non-auto-commit
1:      * mode and no commit is ever issued. Thus on the super's
1:      * tearDown the rollback will revert everything.
1:      */
1:         Connection conn = getConnection();
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
/////////////////////////////////////////////////////////////////////////
1:         Statement stmt = createStatement(ResultSet.TYPE_FORWARD_ONLY, 
commit:985662b
/////////////////////////////////////////////////////////////////////////
1: import org.apache.derbyTesting.junit.TestConfiguration;
/////////////////////////////////////////////////////////////////////////
0:             // empty suite
0:             return new TestSuite();
1:         return TestConfiguration.defaultSuite(UpdatableResultSetTest.class);
============================================================================