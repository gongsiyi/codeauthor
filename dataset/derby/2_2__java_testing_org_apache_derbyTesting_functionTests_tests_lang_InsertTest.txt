1:0b97566: /*
1:0b97566: 
1:0b97566: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.InsertTest
1:0b97566: 
1:0b97566: Licensed to the Apache Software Foundation (ASF) under one or more
1:0b97566: contributor license agreements.  See the NOTICE file distributed with
1:0b97566: this work for additional information regarding copyright ownership.
1:0b97566: The ASF licenses this file to You under the Apache License, Version 2.0
1:0b97566: (the "License"); you may not use this file except in compliance with
1:0b97566: the License.  You may obtain a copy of the License at
1:0b97566: 
1:0b97566: http://www.apache.org/licenses/LICENSE-2.0
1:0b97566: 
1:0b97566: Unless required by applicable law or agreed to in writing, software
1:0b97566: distributed under the License is distributed on an "AS IS" BASIS,
1:0b97566: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:0b97566: See the License for the specific language governing permissions and
1:0b97566: limitations under the License.
1:0b97566: 
1:0b97566: */
1:0b97566: 
1:0b97566: package org.apache.derbyTesting.functionTests.tests.lang;
1:0b97566: 
1:0b97566: import java.sql.PreparedStatement;
1:0b97566: import java.sql.SQLException;
1:0b97566: import java.sql.Statement;
1:0b97566: import junit.framework.Test;
1:0b97566: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1:0b97566: import org.apache.derbyTesting.junit.JDBC;
1:0b97566: import org.apache.derbyTesting.junit.TestConfiguration;
1:0b97566: 
1:0b97566: /**
1:0b97566:  * This class contains test cases for the INSERT statement.
1:0b97566:  */
1:0b97566: public class InsertTest extends BaseJDBCTestCase {
1:0b97566: 
1:40a9fb5:     private static final String PARAMETER_IN_SELECT_LIST = "42X34";
1:afbf89d:     private static final String TOO_MANY_RESULT_COLUMNS = "42X06";
1:40a9fb5: 
1:0b97566:     public InsertTest(String name) {
1:0b97566:         super(name);
1:0b97566:     }
1:0b97566: 
1:0b97566:     public static Test suite() {
1:0b97566:         return TestConfiguration.defaultSuite(InsertTest.class);
1:0b97566:     }
1:36dd3e2: 
1:36dd3e2:     //DERBY-6788(Wrong value inserted by INSERT INTO with multiple subselects)
1:36dd3e2:     //Following test case has zz against its name and hence it won't run. 
1:36dd3e2:     // This is because one INSERT with JOIN in the test can cause data .  
1:36dd3e2:     // corruption. Once DERBY-6788 is fixed, following test should be enabled 
1:36dd3e2:     // by removing zz. This bug might be related to 
1:36dd3e2:     // DERBY-6786(NullPointerException in INSERT INTO statement with multiple 
1:36dd3e2:     //  subselects)
1:36dd3e2:     public void zztestDerby6788() throws SQLException {
1:36dd3e2:         Statement s = createStatement();
1:36dd3e2:         s.execute("CREATE TABLE M1 (K varchar(64), S decimal)");
1:36dd3e2:         s.execute("CREATE TABLE M2 (K varchar(64), S decimal)");
1:36dd3e2:         s.execute("CREATE TABLE V  (S DECIMAL)");
1:36dd3e2:         s.execute("INSERT INTO M1 VALUES ('Bug', 2015)");
1:36dd3e2:         s.execute("INSERT INTO M2 VALUES ('Bug', 1957)");
1:36dd3e2:         JDBC.assertFullResultSet(
1:36dd3e2:             s.executeQuery(
1:36dd3e2:             "SELECT res.* FROM (SELECT d2.s FROM m1 "+
1:36dd3e2:             "LEFT JOIN " +
1:36dd3e2:             "(SELECT k,s FROM m2) AS d2 ON m1.k=d2.k) AS res"),
1:36dd3e2:             new String[][]{{"1957"}});
1:36dd3e2:         //The INSERT below will insert incorrect value into V because of
1:36dd3e2:         // DERBY-6788. This bug might be related to 
1:36dd3e2:         // DERBY-6786(NullPointerException in INSERT INTO statement with  
1:36dd3e2:         //  multiple subselects)
1:36dd3e2:         s.execute("INSERT INTO V "+
1:36dd3e2:                 "(SELECT res.* FROM (SELECT d2.s FROM m1 " +
1:36dd3e2:         		"LEFT JOIN " +
1:36dd3e2:                 "(SELECT k,s FROM m2) AS d2 ON m1.k=d2.k) AS res)");
1:36dd3e2:         JDBC.assertFullResultSet(
1:36dd3e2:                 s.executeQuery(
1:36dd3e2:                 "SELECT * FROM V"),
1:36dd3e2:                 new String[][]{{"1957"}});
1:36dd3e2:         s.execute("INSERT INTO V "+
1:36dd3e2:                 "(SELECT res.* FROM (SELECT d2.s*1 FROM m1 " +
1:36dd3e2:         		"LEFT JOIN " +
1:36dd3e2:                 "(SELECT k,s FROM m2) AS d2 ON m1.k=d2.k) AS res)");
1:36dd3e2:         JDBC.assertFullResultSet(
1:36dd3e2:                 s.executeQuery(
1:36dd3e2:                 "SELECT * FROM V"),
1:36dd3e2:                 new String[][]{{"1957"},{"1957"}});
1:36dd3e2:         s.execute("DROP   TABLE M1");
1:36dd3e2:         s.execute("DROP   TABLE M2");
1:36dd3e2:         s.execute("DROP   TABLE V");
1:36dd3e2:     }
1:2302f2a:     
1:2302f2a:     public void testDerby6786Case1() throws SQLException {
1:2302f2a:         Statement s = createStatement();
1:2302f2a:         s.execute("CREATE TABLE K1 (K VARCHAR(64), S DECIMAL)");
1:2302f2a:         s.execute("CREATE TABLE K2 (K VARCHAR(64), S DECIMAL)");
1:2302f2a:         s.execute("CREATE TABLE T  (S DECIMAL)");
1:2302f2a:         s.execute("INSERT INTO K1 VALUES ('110007', 224)");
1:2302f2a:         s.execute("INSERT INTO K2 VALUES ('110007', 361)");
1:2302f2a:         //Run just plain select
1:2302f2a:         derby6786QueriesToRun(s, "");
1:2302f2a:         //Run insert into ... select
1:2302f2a:         derby6786QueriesToRun(s, "insert into t ");
1:2302f2a:         s.execute("DROP   TABLE K1");
1:2302f2a:         s.execute("DROP   TABLE K2");
1:2302f2a:         s.execute("DROP   TABLE T");
1:2302f2a:     }
1:0b97566: 
1:2302f2a:     public void testDerby6786InsertIntoSelectCase2() throws SQLException {
1:2302f2a:         Statement s = createStatement();
1:2302f2a:         s.execute("CREATE TABLE K1 (K VARCHAR(64), S DECIMAL)");
1:2302f2a:         s.execute("CREATE TABLE K2 (K VARCHAR(64), S DECIMAL)");
1:2302f2a:         s.execute("CREATE TABLE T  (S DECIMAL)");
1:2302f2a:         s.execute("INSERT INTO K1 VALUES ('110007', 224)");
1:2302f2a:         s.execute("INSERT INTO K2 VALUES ('110007', null)");
1:2302f2a:         //Run just plain select
1:2302f2a:         derby6786QueriesToRun(s, "");
1:2302f2a:         //Run insert into ... select
1:2302f2a:         derby6786QueriesToRun(s, "insert into t ");
1:2302f2a:         s.execute("DROP   TABLE K1");
1:2302f2a:         s.execute("DROP   TABLE K2");
1:2302f2a:         s.execute("DROP   TABLE T");
1:2302f2a:     }
1:2302f2a: 
1:2302f2a:     //DERBY-6786(NullPointerException in INSERT INTO statement with multiple subselects)
1:2302f2a:     //Following test case has zz against its name and hence it won't run. 
1:2302f2a:     // This is because some queries in the test can cause NPE. Once 
1:2302f2a:     // DERBY-6786 is fixed, following test should be enabled by removing
1:2302f2a:     // zz.
1:2302f2a:     public void zztestDerby6786InsertIntoSelectCase3() throws SQLException {
1:2302f2a:         Statement s = createStatement();
1:2302f2a:         s.execute("CREATE TABLE K1 (K VARCHAR(64), S DECIMAL)");
1:2302f2a:         s.execute("CREATE TABLE K2 (K VARCHAR(64), S DECIMAL)");
1:2302f2a:         s.execute("CREATE TABLE T  (S DECIMAL)");
1:2302f2a:         s.execute("INSERT INTO K1 VALUES ('110007', 224)");
1:2302f2a:         s.execute("INSERT INTO K2 VALUES ('110019', null)");
1:2302f2a:         //Run just plain select
1:2302f2a:         derby6786QueriesToRun(s, "");
1:2302f2a:         //Run insert into ... select. Running insert will into can result into
1:2302f2a:         // NPE for some of the queries until DERBY-6786 is fixed.
1:2302f2a:         derby6786QueriesToRun(s, "insert into t ");
1:2302f2a:         s.execute("DROP   TABLE K1");
1:2302f2a:         s.execute("DROP   TABLE K2");
1:2302f2a:         s.execute("DROP   TABLE T");
1:2302f2a:     }
1:2302f2a:     
1:2302f2a:     private void derby6786QueriesToRun(Statement s, String insertInto) throws SQLException {
1:2302f2a:         //following left join works
1:2302f2a:         s.execute(insertInto +
1:2302f2a:             "select erg.* from ( " +
1:2302f2a:             "select d1.s from (select k,s from k1) as d1 " +
1:2302f2a:             "left join "+
1:2302f2a:             "(select k,s from k2) as d2 on d1.k=d2.k" +
1:2302f2a:             ") as erg " +
1:2302f2a:             "where s > 10");
1:2302f2a:         //DERBY-6786 : following left join can fail if the right table  
1:2302f2a:         // does not have a matching row
1:2302f2a:         s.execute(insertInto +
1:2302f2a:                 "select erg.* from ( " +
1:2302f2a:                 "select d2.s from (select k,s from k1) as d1 " +
1:2302f2a:                 "left join "+
1:2302f2a:                 "(select k,s from k2) as d2 on d1.k=d2.k" +
1:2302f2a:                 ") as erg " +
1:2302f2a:                 "where s > 10");
1:2302f2a:         //DERBY-6786 : following is another example of left join that can fail 
1:2302f2a:         // if the right table does not have a matching row
1:2302f2a:         s.execute(insertInto +
1:2302f2a:                 "select erg.* from ( " +
1:2302f2a:                 "select d2.s from k1 " +
1:2302f2a:                 "left join "+
1:2302f2a:                 "(select k,s from k2) as d2 on k1.k=d2.k" +
1:2302f2a:                 ") as erg " +
1:2302f2a:                 "where s > 10");
1:2302f2a:         //DERBY-6786 : following right join can fail if the left table  
1:2302f2a:         // does not have a matching row
1:2302f2a:         s.execute(insertInto +
1:2302f2a:             "select erg.* from ( " +
1:2302f2a:             "select d1.s from (select k,s from k1) as d1 " +
1:2302f2a:             "right join "+
1:2302f2a:             "(select k,s from k2) as d2 on d1.k=d2.k" +
1:2302f2a:             ") as erg " +
1:2302f2a:             "where s > 10");
1:2302f2a:         //following right join works
1:2302f2a:         s.execute(insertInto +
1:2302f2a:                 "select erg.* from ( " +
1:2302f2a:                 "select d2.s from (select k,s from k1) as d1 " +
1:2302f2a:                 "right join "+
1:2302f2a:                 "(select k,s from k2) as d2 on d1.k=d2.k" +
1:2302f2a:                 ") as erg " +
1:2302f2a:                 "where s > 10");
1:2302f2a: 
1:2302f2a:     }
1:2302f2a:     
1:0b97566:     /**
1:0b97566:      * Regression test case for DERBY-4348 where an INSERT INTO .. SELECT FROM
1:0b97566:      * statement would result in a LONG VARCHAR column becoming populated with
1:0b97566:      * the wrong values.
1:0b97566:      */
1:0b97566:     public void testInsertIntoSelectFromWithLongVarchar() throws SQLException {
1:0b97566:         // Generate the data that we want table T2 to hold when the test
1:0b97566:         // completes.
1:0b97566:         String[][] data = new String[100][2];
1:0b97566:         for (int i = 0; i < data.length; i++) {
1:0b97566:             // first column should have integers 0,1,...,99
1:0b97566:             data[i][0] = Integer.toString(i);
1:0b97566:             // second column should always be -1
1:0b97566:             data[i][1] = "-1";
1:0b97566:         }
1:0b97566: 
1:0b97566:         // Turn off auto-commit so that the tables used in the test are
1:0b97566:         // automatically cleaned up in tearDown().
1:0b97566:         setAutoCommit(false);
1:0b97566: 
1:0b97566:         Statement s = createStatement();
1:0b97566:         s.execute("create table t1(a long varchar)");
1:0b97566: 
1:0b97566:         // Fill table T1 with the values we want to see in T2's first column.
1:0b97566:         PreparedStatement insT1 = prepareStatement("insert into t1 values ?");
1:0b97566:         for (int i = 0; i < data.length; i++) {
1:0b97566:             insT1.setString(1, data[i][0]);
1:0b97566:             insT1.executeUpdate();
1:0b97566:         }
1:0b97566: 
1:0b97566:         // Create table T2 and insert the contents of T1. Column B must have
1:0b97566:         // a default value and a NOT NULL constraint in order to expose
1:0b97566:         // DERBY-4348. The presence of NOT NULL makes the INSERT statement use
1:0b97566:         // a NormalizeResultSet, and the bug was caused by a bug in the
1:0b97566:         // normalization.
1:0b97566:         s.execute("create table t2(a long varchar, b int default -1 not null)");
1:0b97566:         s.execute("insert into t2(a) select * from t1");
1:0b97566: 
1:0b97566:         // Verify that T1 contains the expected values. Use an ORDER BY to
1:0b97566:         // guarantee the same ordering as in data[][].
1:0b97566:         JDBC.assertFullResultSet(s.executeQuery(
1:0b97566:                     "select * from t2 order by int(cast (a as varchar(10)))"),
1:0b97566:                 data);
1:0b97566:     }
1:7a27cab: 
1:7a27cab:     /**
1:7a27cab:      * INSERT used to fail with a NullPointerException if the source was an
1:7a27cab:      * EXCEPT operation or an INTERSECT operation. DERBY-4420.
1:7a27cab:      */
1:7a27cab:     public void testInsertFromExceptOrIntersect() throws SQLException {
1:7a27cab:         setAutoCommit(false);
1:7a27cab:         Statement s = createStatement();
1:7a27cab: 
1:7a27cab:         // Create tables to fetch data from
1:7a27cab:         s.execute("create table t1(x int)");
1:7a27cab:         s.execute("insert into t1 values 1,2,3");
1:7a27cab:         s.execute("create table t2(x int)");
1:7a27cab:         s.execute("insert into t2 values 2,3,4");
1:7a27cab: 
1:7a27cab:         // Create table to insert into
1:7a27cab:         s.execute("create table t3(x int)");
1:7a27cab: 
1:7a27cab:         // INTERSECT (used to cause NullPointerException)
1:7a27cab:         s.execute("insert into t3 select * from t1 intersect select * from t2");
1:7a27cab:         JDBC.assertFullResultSet(
1:7a27cab:                 s.executeQuery("select * from t3 order by x"),
1:7a27cab:                 new String[][]{{"2"}, {"3"}});
1:7a27cab:         s.execute("delete from t3");
1:7a27cab: 
1:7a27cab:         // INTERSECT ALL (used to cause NullPointerException)
1:7a27cab:         s.execute("insert into t3 select * from t1 " +
1:7a27cab:                   "intersect all select * from t2");
1:7a27cab:         JDBC.assertFullResultSet(
1:7a27cab:                 s.executeQuery("select * from t3 order by x"),
1:7a27cab:                 new String[][]{{"2"}, {"3"}});
1:7a27cab:         s.execute("delete from t3");
1:7a27cab: 
1:7a27cab:         // EXCEPT (used to cause NullPointerException)
1:7a27cab:         s.execute("insert into t3 select * from t1 except select * from t2");
1:7a27cab:         JDBC.assertSingleValueResultSet(
1:7a27cab:                 s.executeQuery("select * from t3 order by x"),
1:7a27cab:                 "1");
1:7a27cab:         s.execute("delete from t3");
1:40a9fb5: 
1:7a27cab:         // EXCEPT ALL (used to cause NullPointerException)
1:7a27cab:         s.execute("insert into t3 select * from t1 " +
1:7a27cab:                   "except all select * from t2");
1:7a27cab:         JDBC.assertSingleValueResultSet(
1:7a27cab:                 s.executeQuery("select * from t3 order by x"),
1:7a27cab:                 "1");
1:7a27cab:         s.execute("delete from t3");
1:7a27cab:     }
1:7a27cab: 
1:40a9fb5:     /**
1:40a9fb5:      * Regression test for DERBY-4671. Verify that dynamic parameters can be
1:40a9fb5:      * used in the select list in an INSERT INTO ... SELECT FROM statement.
1:40a9fb5:      * This used to work, but the fix for DERBY-4420 made it throw a
1:40a9fb5:      * NullPointerException.
1:40a9fb5:      */
1:40a9fb5:     public void testInsertFromSelectWithParameters() throws SQLException {
1:40a9fb5:         Statement s = createStatement();
1:40a9fb5:         s.execute("create table derby4671(x int)");
1:40a9fb5:         s.execute("insert into derby4671 values (1), (2)");
1:40a9fb5: 
1:40a9fb5:         // This call failed with a NullPointerException
1:40a9fb5:         PreparedStatement ins1 = prepareStatement(
1:40a9fb5:                 "insert into derby4671 select ? from derby4671");
1:40a9fb5: 
1:40a9fb5:         ins1.setInt(1, 7);
1:40a9fb5:         assertUpdateCount(ins1, 2);
1:40a9fb5: 
1:40a9fb5:         JDBC.assertFullResultSet(
1:40a9fb5:                 s.executeQuery("select * from derby4671 order by x"),
1:40a9fb5:                 new String[][] {{"1"}, {"2"}, {"7"}, {"7"}});
1:40a9fb5: 
1:40a9fb5:         // Also verify that it works when the ? is in an expression
1:40a9fb5:         PreparedStatement ins2 = prepareStatement(
1:40a9fb5:                 "insert into derby4671 select (x+?)*10 from derby4671");
1:40a9fb5: 
1:40a9fb5:         ins2.setInt(1, 77);
1:40a9fb5:         assertUpdateCount(ins2, 4);
1:40a9fb5: 
1:40a9fb5:         JDBC.assertFullResultSet(
1:40a9fb5:                 s.executeQuery("select * from derby4671 order by x"),
1:40a9fb5:                 new String[][] {
1:40a9fb5:                     {"1"}, {"2"}, {"7"}, {"7"},
1:40a9fb5:                     {"780"}, {"790"}, {"840"}, {"840"}});
1:40a9fb5: 
1:40a9fb5:         // We only accept ? in the top level select list, so these should
1:40a9fb5:         // still fail
1:40a9fb5:         assertCompileError(
1:40a9fb5:                 PARAMETER_IN_SELECT_LIST,
1:40a9fb5:                 "insert into derby4671 select ? from derby4671 "
1:40a9fb5:                 + "union select ? from derby4671");
1:40a9fb5:         assertCompileError(
1:40a9fb5:                 PARAMETER_IN_SELECT_LIST,
1:40a9fb5:                 "insert into derby4671 select ? from derby4671 "
1:40a9fb5:                 + "except select ? from derby4671");
1:40a9fb5:         assertCompileError(
1:40a9fb5:                 PARAMETER_IN_SELECT_LIST,
1:40a9fb5:                 "insert into derby4671 select ? from derby4671 "
1:40a9fb5:                 + "intersect select ? from derby4671");
1:40a9fb5:     }
1:afbf89d: 
1:afbf89d:     /**
1:afbf89d:      * Regression test case for DERBY-4449. INSERT statements with an explicit
1:afbf89d:      * target column list used to fail with ArrayIndexOutOfBoundsException if
1:afbf89d:      * the table constructor had more columns than the target column list and
1:afbf89d:      * one of the extra columns was specified as DEFAULT.
1:afbf89d:      */
1:afbf89d:     public void testInsertTooManyDefaultColumns() throws SQLException {
1:afbf89d:         createStatement().execute("create table derby4449(x int)");
1:afbf89d:         // This statement has always failed gracefully (no explicit target
1:afbf89d:         // column list)
1:afbf89d:         assertCompileError(
1:afbf89d:                 TOO_MANY_RESULT_COLUMNS,
1:afbf89d:                 "insert into derby4449 values (default, default)");
1:afbf89d:         // This statement used to fail with ArrayIndexOutOfBoundsException
1:afbf89d:         assertCompileError(
1:afbf89d:                 TOO_MANY_RESULT_COLUMNS,
1:afbf89d:                 "insert into derby4449 (x) values (default, default)");
1:afbf89d:     }
1:065a81f: 
1:065a81f:     /**
1:065a81f:      * Regression test case for DERBY-6443. INSERT statements bind the
1:065a81f:      * source SELECT statement twice, and the second time it would miss
1:065a81f:      * aggregates and subqueries if they were wrapped in a function call.
1:065a81f:      * This led to inconsistencies in the query tree that caused errors
1:065a81f:      * during execution (or assertion failures during compilation in sane
1:065a81f:      * builds).
1:065a81f:      */
1:065a81f:     public void testDerby6443() throws SQLException {
1:065a81f:         Statement s = createStatement();
1:065a81f: 
1:065a81f:         // Disable auto-commit for easy cleanup of test tables (automatically
1:065a81f:         // rolled back in tearDown()), and create a separate schema to avoid
1:065a81f:         // name conflicts with other test cases.
1:065a81f:         setAutoCommit(false);
1:065a81f:         s.execute("CREATE SCHEMA d6443");
1:065a81f:         s.execute("SET SCHEMA d6443");
1:065a81f: 
1:065a81f:         // This is the original test case provided in the bug report. It
1:065a81f:         // used to fail with an assert failure when compiling the trigger
1:065a81f:         // (in sane builds), or with an ArrayIndexOutOfBoundsException when
1:065a81f:         // the trigger fired (in insane builds).
1:065a81f:         s.execute("CREATE TABLE foo (name VARCHAR(20), val DOUBLE)");
1:065a81f:         s.execute("CREATE TABLE summary "
1:065a81f:                 + "(name VARCHAR(20), aver DOUBLE, size INT)");
1:065a81f:         s.execute("CREATE TRIGGER trg_foo AFTER INSERT ON foo "
1:065a81f:                 + "REFERENCING NEW TABLE AS changed FOR EACH STATEMENT "
1:065a81f:                 + "INSERT INTO summary (name, aver, size) "
1:065a81f:                 + "SELECT name, FLOOR(AVG(LOG10(val))), COUNT(*) "
1:065a81f:                 + "FROM changed "
1:065a81f:                 + "GROUP BY name");
1:065a81f:         s.execute("INSERT INTO foo (name, val) "
1:065a81f:                 + "VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40)");
1:065a81f:         JDBC.assertFullResultSet(
1:065a81f:                 s.executeQuery("select * from foo order by val"),
1:065a81f:                 new String[][] {
1:065a81f:                     { "A", "10.0" },
1:065a81f:                     { "A", "20.0" },
1:065a81f:                     { "B", "30.0" },
1:065a81f:                     { "C", "40.0" },
1:065a81f:                 });
1:065a81f:         JDBC.assertFullResultSet(
1:065a81f:                 s.executeQuery("select * from summary order by name"),
1:065a81f:                 new String[][] {
1:065a81f:                     { "A", "1.0", "2" },
1:065a81f:                     { "B", "1.0", "1" },
1:065a81f:                     { "C", "1.0", "1" },
1:065a81f:                 });
1:065a81f: 
1:065a81f:         // Some other problematic queries...
1:065a81f: 
1:065a81f:         s.execute("create table t1(x int)");
1:065a81f:         s.execute("insert into t1 values 1");
1:065a81f:         s.execute("create table t2(x int)");
1:065a81f: 
1:065a81f:         // Used to fail with assert or ArrayIndexOutOfBoundsException.
1:065a81f:         s.execute("insert into t2 select floor(avg(x)) from t1");
1:065a81f: 
1:065a81f:         // Same here...
1:065a81f:         s.execute("create function f(x int) returns int language java "
1:065a81f:                 + "parameter style java external name 'java.lang.Math.abs'");
1:065a81f:         s.execute("insert into t2 select f(avg(x)) from t1");
1:065a81f: 
1:065a81f:         // This query used to fail with a NullPointerException.
1:065a81f:         s.execute("insert into t2 select f((select x from t1)) from t1");
1:065a81f: 
1:065a81f:         JDBC.assertFullResultSet(
1:065a81f:                 s.executeQuery("select * from t2"),
1:065a81f:                 new String[][] {{"1"}, {"1"}, {"1"}});
1:065a81f:     }
1:0b97566: }
============================================================================
author:Mamta Satoor
-------------------------------------------------------------------------------
commit:36dd3e2
/////////////////////////////////////////////////////////////////////////
1: 
1:     //DERBY-6788(Wrong value inserted by INSERT INTO with multiple subselects)
1:     //Following test case has zz against its name and hence it won't run. 
1:     // This is because one INSERT with JOIN in the test can cause data .  
1:     // corruption. Once DERBY-6788 is fixed, following test should be enabled 
1:     // by removing zz. This bug might be related to 
1:     // DERBY-6786(NullPointerException in INSERT INTO statement with multiple 
1:     //  subselects)
1:     public void zztestDerby6788() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("CREATE TABLE M1 (K varchar(64), S decimal)");
1:         s.execute("CREATE TABLE M2 (K varchar(64), S decimal)");
1:         s.execute("CREATE TABLE V  (S DECIMAL)");
1:         s.execute("INSERT INTO M1 VALUES ('Bug', 2015)");
1:         s.execute("INSERT INTO M2 VALUES ('Bug', 1957)");
1:         JDBC.assertFullResultSet(
1:             s.executeQuery(
1:             "SELECT res.* FROM (SELECT d2.s FROM m1 "+
1:             "LEFT JOIN " +
1:             "(SELECT k,s FROM m2) AS d2 ON m1.k=d2.k) AS res"),
1:             new String[][]{{"1957"}});
1:         //The INSERT below will insert incorrect value into V because of
1:         // DERBY-6788. This bug might be related to 
1:         // DERBY-6786(NullPointerException in INSERT INTO statement with  
1:         //  multiple subselects)
1:         s.execute("INSERT INTO V "+
1:                 "(SELECT res.* FROM (SELECT d2.s FROM m1 " +
1:         		"LEFT JOIN " +
1:                 "(SELECT k,s FROM m2) AS d2 ON m1.k=d2.k) AS res)");
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery(
1:                 "SELECT * FROM V"),
1:                 new String[][]{{"1957"}});
1:         s.execute("INSERT INTO V "+
1:                 "(SELECT res.* FROM (SELECT d2.s*1 FROM m1 " +
1:         		"LEFT JOIN " +
1:                 "(SELECT k,s FROM m2) AS d2 ON m1.k=d2.k) AS res)");
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery(
1:                 "SELECT * FROM V"),
1:                 new String[][]{{"1957"},{"1957"}});
1:         s.execute("DROP   TABLE M1");
1:         s.execute("DROP   TABLE M2");
1:         s.execute("DROP   TABLE V");
1:     }
commit:2302f2a
/////////////////////////////////////////////////////////////////////////
1:     
1:     public void testDerby6786Case1() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("CREATE TABLE K1 (K VARCHAR(64), S DECIMAL)");
1:         s.execute("CREATE TABLE K2 (K VARCHAR(64), S DECIMAL)");
1:         s.execute("CREATE TABLE T  (S DECIMAL)");
1:         s.execute("INSERT INTO K1 VALUES ('110007', 224)");
1:         s.execute("INSERT INTO K2 VALUES ('110007', 361)");
1:         //Run just plain select
1:         derby6786QueriesToRun(s, "");
1:         //Run insert into ... select
1:         derby6786QueriesToRun(s, "insert into t ");
1:         s.execute("DROP   TABLE K1");
1:         s.execute("DROP   TABLE K2");
1:         s.execute("DROP   TABLE T");
1:     }
1:     public void testDerby6786InsertIntoSelectCase2() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("CREATE TABLE K1 (K VARCHAR(64), S DECIMAL)");
1:         s.execute("CREATE TABLE K2 (K VARCHAR(64), S DECIMAL)");
1:         s.execute("CREATE TABLE T  (S DECIMAL)");
1:         s.execute("INSERT INTO K1 VALUES ('110007', 224)");
1:         s.execute("INSERT INTO K2 VALUES ('110007', null)");
1:         //Run just plain select
1:         derby6786QueriesToRun(s, "");
1:         //Run insert into ... select
1:         derby6786QueriesToRun(s, "insert into t ");
1:         s.execute("DROP   TABLE K1");
1:         s.execute("DROP   TABLE K2");
1:         s.execute("DROP   TABLE T");
1:     }
1: 
1:     //DERBY-6786(NullPointerException in INSERT INTO statement with multiple subselects)
1:     //Following test case has zz against its name and hence it won't run. 
1:     // This is because some queries in the test can cause NPE. Once 
1:     // DERBY-6786 is fixed, following test should be enabled by removing
1:     // zz.
1:     public void zztestDerby6786InsertIntoSelectCase3() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("CREATE TABLE K1 (K VARCHAR(64), S DECIMAL)");
1:         s.execute("CREATE TABLE K2 (K VARCHAR(64), S DECIMAL)");
1:         s.execute("CREATE TABLE T  (S DECIMAL)");
1:         s.execute("INSERT INTO K1 VALUES ('110007', 224)");
1:         s.execute("INSERT INTO K2 VALUES ('110019', null)");
1:         //Run just plain select
1:         derby6786QueriesToRun(s, "");
1:         //Run insert into ... select. Running insert will into can result into
1:         // NPE for some of the queries until DERBY-6786 is fixed.
1:         derby6786QueriesToRun(s, "insert into t ");
1:         s.execute("DROP   TABLE K1");
1:         s.execute("DROP   TABLE K2");
1:         s.execute("DROP   TABLE T");
1:     }
1:     
1:     private void derby6786QueriesToRun(Statement s, String insertInto) throws SQLException {
1:         //following left join works
1:         s.execute(insertInto +
1:             "select erg.* from ( " +
1:             "select d1.s from (select k,s from k1) as d1 " +
1:             "left join "+
1:             "(select k,s from k2) as d2 on d1.k=d2.k" +
1:             ") as erg " +
1:             "where s > 10");
1:         //DERBY-6786 : following left join can fail if the right table  
1:         // does not have a matching row
1:         s.execute(insertInto +
1:                 "select erg.* from ( " +
1:                 "select d2.s from (select k,s from k1) as d1 " +
1:                 "left join "+
1:                 "(select k,s from k2) as d2 on d1.k=d2.k" +
1:                 ") as erg " +
1:                 "where s > 10");
1:         //DERBY-6786 : following is another example of left join that can fail 
1:         // if the right table does not have a matching row
1:         s.execute(insertInto +
1:                 "select erg.* from ( " +
1:                 "select d2.s from k1 " +
1:                 "left join "+
1:                 "(select k,s from k2) as d2 on k1.k=d2.k" +
1:                 ") as erg " +
1:                 "where s > 10");
1:         //DERBY-6786 : following right join can fail if the left table  
1:         // does not have a matching row
1:         s.execute(insertInto +
1:             "select erg.* from ( " +
1:             "select d1.s from (select k,s from k1) as d1 " +
1:             "right join "+
1:             "(select k,s from k2) as d2 on d1.k=d2.k" +
1:             ") as erg " +
1:             "where s > 10");
1:         //following right join works
1:         s.execute(insertInto +
1:                 "select erg.* from ( " +
1:                 "select d2.s from (select k,s from k1) as d1 " +
1:                 "right join "+
1:                 "(select k,s from k2) as d2 on d1.k=d2.k" +
1:                 ") as erg " +
1:                 "where s > 10");
1: 
1:     }
1:     
author:Knut Anders Hatlen
-------------------------------------------------------------------------------
commit:065a81f
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Regression test case for DERBY-6443. INSERT statements bind the
1:      * source SELECT statement twice, and the second time it would miss
1:      * aggregates and subqueries if they were wrapped in a function call.
1:      * This led to inconsistencies in the query tree that caused errors
1:      * during execution (or assertion failures during compilation in sane
1:      * builds).
1:      */
1:     public void testDerby6443() throws SQLException {
1:         Statement s = createStatement();
1: 
1:         // Disable auto-commit for easy cleanup of test tables (automatically
1:         // rolled back in tearDown()), and create a separate schema to avoid
1:         // name conflicts with other test cases.
1:         setAutoCommit(false);
1:         s.execute("CREATE SCHEMA d6443");
1:         s.execute("SET SCHEMA d6443");
1: 
1:         // This is the original test case provided in the bug report. It
1:         // used to fail with an assert failure when compiling the trigger
1:         // (in sane builds), or with an ArrayIndexOutOfBoundsException when
1:         // the trigger fired (in insane builds).
1:         s.execute("CREATE TABLE foo (name VARCHAR(20), val DOUBLE)");
1:         s.execute("CREATE TABLE summary "
1:                 + "(name VARCHAR(20), aver DOUBLE, size INT)");
1:         s.execute("CREATE TRIGGER trg_foo AFTER INSERT ON foo "
1:                 + "REFERENCING NEW TABLE AS changed FOR EACH STATEMENT "
1:                 + "INSERT INTO summary (name, aver, size) "
1:                 + "SELECT name, FLOOR(AVG(LOG10(val))), COUNT(*) "
1:                 + "FROM changed "
1:                 + "GROUP BY name");
1:         s.execute("INSERT INTO foo (name, val) "
1:                 + "VALUES ('A', 10), ('A', 20), ('B', 30), ('C', 40)");
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from foo order by val"),
1:                 new String[][] {
1:                     { "A", "10.0" },
1:                     { "A", "20.0" },
1:                     { "B", "30.0" },
1:                     { "C", "40.0" },
1:                 });
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from summary order by name"),
1:                 new String[][] {
1:                     { "A", "1.0", "2" },
1:                     { "B", "1.0", "1" },
1:                     { "C", "1.0", "1" },
1:                 });
1: 
1:         // Some other problematic queries...
1: 
1:         s.execute("create table t1(x int)");
1:         s.execute("insert into t1 values 1");
1:         s.execute("create table t2(x int)");
1: 
1:         // Used to fail with assert or ArrayIndexOutOfBoundsException.
1:         s.execute("insert into t2 select floor(avg(x)) from t1");
1: 
1:         // Same here...
1:         s.execute("create function f(x int) returns int language java "
1:                 + "parameter style java external name 'java.lang.Math.abs'");
1:         s.execute("insert into t2 select f(avg(x)) from t1");
1: 
1:         // This query used to fail with a NullPointerException.
1:         s.execute("insert into t2 select f((select x from t1)) from t1");
1: 
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from t2"),
1:                 new String[][] {{"1"}, {"1"}, {"1"}});
1:     }
commit:afbf89d
/////////////////////////////////////////////////////////////////////////
1:     private static final String TOO_MANY_RESULT_COLUMNS = "42X06";
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Regression test case for DERBY-4449. INSERT statements with an explicit
1:      * target column list used to fail with ArrayIndexOutOfBoundsException if
1:      * the table constructor had more columns than the target column list and
1:      * one of the extra columns was specified as DEFAULT.
1:      */
1:     public void testInsertTooManyDefaultColumns() throws SQLException {
1:         createStatement().execute("create table derby4449(x int)");
1:         // This statement has always failed gracefully (no explicit target
1:         // column list)
1:         assertCompileError(
1:                 TOO_MANY_RESULT_COLUMNS,
1:                 "insert into derby4449 values (default, default)");
1:         // This statement used to fail with ArrayIndexOutOfBoundsException
1:         assertCompileError(
1:                 TOO_MANY_RESULT_COLUMNS,
1:                 "insert into derby4449 (x) values (default, default)");
1:     }
commit:40a9fb5
/////////////////////////////////////////////////////////////////////////
1:     private static final String PARAMETER_IN_SELECT_LIST = "42X34";
1: 
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Regression test for DERBY-4671. Verify that dynamic parameters can be
1:      * used in the select list in an INSERT INTO ... SELECT FROM statement.
1:      * This used to work, but the fix for DERBY-4420 made it throw a
1:      * NullPointerException.
1:      */
1:     public void testInsertFromSelectWithParameters() throws SQLException {
1:         Statement s = createStatement();
1:         s.execute("create table derby4671(x int)");
1:         s.execute("insert into derby4671 values (1), (2)");
1: 
1:         // This call failed with a NullPointerException
1:         PreparedStatement ins1 = prepareStatement(
1:                 "insert into derby4671 select ? from derby4671");
1: 
1:         ins1.setInt(1, 7);
1:         assertUpdateCount(ins1, 2);
1: 
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from derby4671 order by x"),
1:                 new String[][] {{"1"}, {"2"}, {"7"}, {"7"}});
1: 
1:         // Also verify that it works when the ? is in an expression
1:         PreparedStatement ins2 = prepareStatement(
1:                 "insert into derby4671 select (x+?)*10 from derby4671");
1: 
1:         ins2.setInt(1, 77);
1:         assertUpdateCount(ins2, 4);
1: 
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from derby4671 order by x"),
1:                 new String[][] {
1:                     {"1"}, {"2"}, {"7"}, {"7"},
1:                     {"780"}, {"790"}, {"840"}, {"840"}});
1: 
1:         // We only accept ? in the top level select list, so these should
1:         // still fail
1:         assertCompileError(
1:                 PARAMETER_IN_SELECT_LIST,
1:                 "insert into derby4671 select ? from derby4671 "
1:                 + "union select ? from derby4671");
1:         assertCompileError(
1:                 PARAMETER_IN_SELECT_LIST,
1:                 "insert into derby4671 select ? from derby4671 "
1:                 + "except select ? from derby4671");
1:         assertCompileError(
1:                 PARAMETER_IN_SELECT_LIST,
1:                 "insert into derby4671 select ? from derby4671 "
1:                 + "intersect select ? from derby4671");
1:     }
commit:7a27cab
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * INSERT used to fail with a NullPointerException if the source was an
1:      * EXCEPT operation or an INTERSECT operation. DERBY-4420.
1:      */
1:     public void testInsertFromExceptOrIntersect() throws SQLException {
1:         setAutoCommit(false);
1:         Statement s = createStatement();
1: 
1:         // Create tables to fetch data from
1:         s.execute("create table t1(x int)");
1:         s.execute("insert into t1 values 1,2,3");
1:         s.execute("create table t2(x int)");
1:         s.execute("insert into t2 values 2,3,4");
1: 
1:         // Create table to insert into
1:         s.execute("create table t3(x int)");
1: 
1:         // INTERSECT (used to cause NullPointerException)
1:         s.execute("insert into t3 select * from t1 intersect select * from t2");
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from t3 order by x"),
1:                 new String[][]{{"2"}, {"3"}});
1:         s.execute("delete from t3");
1: 
1:         // INTERSECT ALL (used to cause NullPointerException)
1:         s.execute("insert into t3 select * from t1 " +
1:                   "intersect all select * from t2");
1:         JDBC.assertFullResultSet(
1:                 s.executeQuery("select * from t3 order by x"),
1:                 new String[][]{{"2"}, {"3"}});
1:         s.execute("delete from t3");
1: 
1:         // EXCEPT (used to cause NullPointerException)
1:         s.execute("insert into t3 select * from t1 except select * from t2");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from t3 order by x"),
1:                 "1");
1:         s.execute("delete from t3");
1: 
1:         // EXCEPT ALL (used to cause NullPointerException)
1:         s.execute("insert into t3 select * from t1 " +
1:                   "except all select * from t2");
1:         JDBC.assertSingleValueResultSet(
1:                 s.executeQuery("select * from t3 order by x"),
1:                 "1");
1:         s.execute("delete from t3");
1:     }
commit:0b97566
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
1: Derby - Class org.apache.derbyTesting.functionTests.tests.lang.InsertTest
1: 
1: Licensed to the Apache Software Foundation (ASF) under one or more
1: contributor license agreements.  See the NOTICE file distributed with
1: this work for additional information regarding copyright ownership.
1: The ASF licenses this file to You under the Apache License, Version 2.0
1: (the "License"); you may not use this file except in compliance with
1: the License.  You may obtain a copy of the License at
1: 
1: http://www.apache.org/licenses/LICENSE-2.0
1: 
1: Unless required by applicable law or agreed to in writing, software
1: distributed under the License is distributed on an "AS IS" BASIS,
1: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1: See the License for the specific language governing permissions and
1: limitations under the License.
1: 
1: */
1: 
1: package org.apache.derbyTesting.functionTests.tests.lang;
1: 
1: import java.sql.PreparedStatement;
1: import java.sql.SQLException;
1: import java.sql.Statement;
1: import junit.framework.Test;
1: import org.apache.derbyTesting.junit.BaseJDBCTestCase;
1: import org.apache.derbyTesting.junit.JDBC;
1: import org.apache.derbyTesting.junit.TestConfiguration;
1: 
1: /**
1:  * This class contains test cases for the INSERT statement.
1:  */
1: public class InsertTest extends BaseJDBCTestCase {
1: 
1:     public InsertTest(String name) {
1:         super(name);
1:     }
1: 
1:     public static Test suite() {
1:         return TestConfiguration.defaultSuite(InsertTest.class);
1:     }
1: 
1:     /**
1:      * Regression test case for DERBY-4348 where an INSERT INTO .. SELECT FROM
1:      * statement would result in a LONG VARCHAR column becoming populated with
1:      * the wrong values.
1:      */
1:     public void testInsertIntoSelectFromWithLongVarchar() throws SQLException {
1:         // Generate the data that we want table T2 to hold when the test
1:         // completes.
1:         String[][] data = new String[100][2];
1:         for (int i = 0; i < data.length; i++) {
1:             // first column should have integers 0,1,...,99
1:             data[i][0] = Integer.toString(i);
1:             // second column should always be -1
1:             data[i][1] = "-1";
1:         }
1: 
1:         // Turn off auto-commit so that the tables used in the test are
1:         // automatically cleaned up in tearDown().
1:         setAutoCommit(false);
1: 
1:         Statement s = createStatement();
1:         s.execute("create table t1(a long varchar)");
1: 
1:         // Fill table T1 with the values we want to see in T2's first column.
1:         PreparedStatement insT1 = prepareStatement("insert into t1 values ?");
1:         for (int i = 0; i < data.length; i++) {
1:             insT1.setString(1, data[i][0]);
1:             insT1.executeUpdate();
1:         }
1: 
1:         // Create table T2 and insert the contents of T1. Column B must have
1:         // a default value and a NOT NULL constraint in order to expose
1:         // DERBY-4348. The presence of NOT NULL makes the INSERT statement use
1:         // a NormalizeResultSet, and the bug was caused by a bug in the
1:         // normalization.
1:         s.execute("create table t2(a long varchar, b int default -1 not null)");
1:         s.execute("insert into t2(a) select * from t1");
1: 
1:         // Verify that T1 contains the expected values. Use an ORDER BY to
1:         // guarantee the same ordering as in data[][].
1:         JDBC.assertFullResultSet(s.executeQuery(
1:                     "select * from t2 order by int(cast (a as varchar(10)))"),
1:                 data);
1:     }
1: }
============================================================================