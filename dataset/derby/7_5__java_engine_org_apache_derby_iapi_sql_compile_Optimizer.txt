1:eac0369: /*
1:7ecc1f2: 
1:7ecc1f2:    Derby - Class org.apache.derby.iapi.sql.compile.Optimizer
1:9858a84: 
1:d4580ab:    Licensed to the Apache Software Foundation (ASF) under one or more
1:d4580ab:    contributor license agreements.  See the NOTICE file distributed with
1:d4580ab:    this work for additional information regarding copyright ownership.
1:d4580ab:    The ASF licenses this file to you under the Apache License, Version 2.0
1:d4580ab:    (the "License"); you may not use this file except in compliance with
1:d4580ab:    the License.  You may obtain a copy of the License at
1:7ecc1f2: 
1:7ecc1f2:       http://www.apache.org/licenses/LICENSE-2.0
1:7ecc1f2: 
1:7ecc1f2:    Unless required by applicable law or agreed to in writing, software
1:7ecc1f2:    distributed under the License is distributed on an "AS IS" BASIS,
1:7ecc1f2:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:7ecc1f2:    See the License for the specific language governing permissions and
1:7ecc1f2:    limitations under the License.
1:7ecc1f2: 
3:eac0369:  */
6:eac0369: 
1:eac0369: package org.apache.derby.iapi.sql.compile;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1:eac0369: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.error.StandardException;
1:eac0369: 
1:eac0369: import org.apache.derby.iapi.util.JBitSet;
1:eac0369: 
3:eac0369: /**
1:eac0369:  * Optimizer provides services for optimizing a query.
1:eac0369:  * RESOLVE:
1:eac0369:  *	o  Need to figure out what to do about subqueries, figuring out
1:eac0369:  *	   their attachment points and how to communicate them back to the
1:eac0369:  *	   caller.
1:eac0369:  */
1:eac0369: 
1:9858a84: public interface Optimizer
1:9858a84: {
1:eac0369: 	/**
1:eac0369: 		Module name for the monitor's module locating system.
1:eac0369: 	 */
1:eac0369: 	String MODULE = "org.apache.derby.iapi.sql.compile.Optimizer";
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Property name for controlling whether to do join order optimization.
1:eac0369: 	 */
1:eac0369: 	String JOIN_ORDER_OPTIMIZATION = "derby.optimizer.optimizeJoinOrder";
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Property name for controlling whether to do rule-based optimization,
1:eac0369: 		as opposed to cost-based optimization.
1:eac0369: 	 */
1:eac0369: 	String RULE_BASED_OPTIMIZATION =
1:eac0369: 						"derby.optimizer.ruleBasedOptimization";
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Property name for controlling whether the optimizer ever times out
1:eac0369: 		while optimizing a query and goes with the best plan so far.
1:eac0369: 	 */
1:eac0369: 	String NO_TIMEOUT = "derby.optimizer.noTimeout";
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 		Property name for controlling the maximum size of memory (in KB)
1:eac0369: 		the optimizer can use for each table.  If an access path takes
1:eac0369: 		memory larger than that size for a table, the access path is skipped.
1:eac0369: 		Default is 1024 (KB).
1:eac0369: 	 */
1:eac0369: 	String MAX_MEMORY_PER_TABLE = "derby.language.maxMemoryPerTable";
1:eac0369: 
1:eac0369: 	/**
1:f18825a: 		Maximum size of dynamically created materialized rows. Caching large results
1:f18825a: 		use lot of memory and can cause stack overflow. See DERBY-634
1:f18825a: 	*/
1:f18825a: 	int MAX_DYNAMIC_MATERIALIZED_ROWS = 512;
1:f18825a: 
1:f18825a: 	/**
1:eac0369: 	   Property name for disabling statistics use for all queries.
1:eac0369: 	*/
1:eac0369: 	String USE_STATISTICS = "derby.language.useStatistics";
1:eac0369: 
1:eac0369: 	/** Indicates a "normal" plan that is not optimized to do sort avoidance */
1:eac0369: 	int NORMAL_PLAN = 1;
1:eac0369: 
1:eac0369: 	/** Indicates a sort-avoidance plan */
1:eac0369: 	int SORT_AVOIDANCE_PLAN = 2;
1:9858a84: 
1:eac0369: 	/**
1:eac0369: 	 * Iterate through the permutations, returning false when the permutations
1:eac0369: 	 * are exhausted.
1:eac0369: 	 * NOTE - Implementers are responsible for hiding tree pruning of permutations
1:eac0369: 	 * behind this method call.
2:eac0369: 	 *
1:eac0369: 	 * @return boolean	True - An optimizable permutation remains.
1:eac0369: 	 *					False - Permutations are exhausted.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean getNextPermutation() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Iterate through the "decorated permutations", returning false when they
1:eac0369: 	 * are exhausted.
1:eac0369: 	 * NOTE - Implementers are responsible for hiding tree pruning of access
1:eac0369: 	 * methods behind this method call.
1:eac0369: 	 *
1:eac0369: 	 * @return boolean	True - An optimizable decorated permutation remains.
1:eac0369: 	 *					False - Decorated permutations are exhausted.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public boolean getNextDecoratedPermutation() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Cost the current permutation.
1:eac0369: 	 * Caller is responsible for pushing all predicates which can be evaluated 
1:eac0369: 	 * prior to costing.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void costPermutation() throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Cost the current Optimizable with the specified OPL.
1:eac0369: 	 * Caller is responsible for pushing all predicates which can be evaluated 
1:eac0369: 	 * prior to costing.
1:eac0369: 	 *
1:eac0369: 	 * @param optimizable	The Optimizable
1:eac0369: 	 * @param td			TableDescriptor of the Optimizable
1:eac0369: 	 * @param cd			The ConglomerateDescriptor for the conglom to cost
1:eac0369: 	 *						(This should change to an object to represent
1:eac0369: 	 *						access paths, but for now this is OK).
1:eac0369: 	 * @param predList		The OptimizablePredicateList to apply
1:eac0369: 	 * @param outerCost		The cost of the tables outer to the one being
1:eac0369: 	 *						optimizer - tells how many outer rows there are.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	costOptimizable(Optimizable optimizable,
1:eac0369: 								TableDescriptor td, 
1:eac0369: 								ConglomerateDescriptor cd,
1:eac0369: 								OptimizablePredicateList predList,
1:eac0369: 								CostEstimate outerCost)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Consider the cost of the given optimizable.  This method is like
1:eac0369: 	 * costOptimizable, above, but it is used when the Optimizable does
1:eac0369: 	 * not need help from the optimizer in costing the Optimizable (in practice,
1:eac0369: 	 * all Optimizables except FromBaseTable use this method.
1:eac0369: 	 *
1:eac0369: 	 * Caller is responsible for pushing all predicates which can be evaluated 
1:eac0369: 	 * prior to costing.
1:eac0369: 	 *
1:eac0369: 	 * @param optimizable	The Optimizable
1:eac0369: 	 * @param predList		The OptimizablePredicateList to apply
1:eac0369: 	 * @param estimatedCost	The estimated cost of the given optimizable
1:eac0369: 	 * @param outerCost		The cost of the tables outer to the one being
1:eac0369: 	 *						optimizer - tells how many outer rows there are.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void	considerCost(Optimizable optimizable,
1:eac0369: 							OptimizablePredicateList predList,
1:eac0369: 							CostEstimate estimatedCost,
1:eac0369: 							CostEstimate outerCost)
1:eac0369: 			throws StandardException;
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Return the DataDictionary that the Optimizer is using.
1:eac0369: 	 * This is useful when an Optimizable needs to call optimize() on
1:eac0369: 	 * a child ResultSetNode.
1:eac0369: 	 * 
1:eac0369: 	 * @return DataDictionary	DataDictionary that the Optimizer is using.
1:eac0369: 	 */
1:eac0369: 	public DataDictionary getDataDictionary();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Modify the access path for each Optimizable, as necessary.  This includes
1:eac0369: 	 * things like adding result sets to translate from index rows to base rows.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	public void modifyAccessPaths() throws StandardException;
1:eac0369: 
1:eac0369: 	/** Get the estimated cost of the optimized query */
1:eac0369: 	public CostEstimate getOptimizedCost();
1:eac0369: 
1:eac0369: 	/**
1:ab10884: 	 * Get the final estimated cost of the optimized query.  This
1:ab10884: 	 * should be the cost that corresponds to the best overall join
1:ab10884: 	 * order chosen by the optimizer, and thus this method should
1:ab10884: 	 * only be called after optimization is complete (i.e. when
1:ab10884: 	 * modifying access paths).
1:ab10884: 	 */
1:ab10884: 	public CostEstimate getFinalCost();
1:ab10884: 
1:ab10884: 	/**
1:ab10884: 	 * Prepare for another round of optimization.
1:ab10884: 	 *
1:ab10884: 	 * This method is called before every "round" of optimization, where
1:ab10884: 	 * we define a "round" to be the period between the last time a call to
1:ab10884: 	 * getOptimizer() (on either a ResultSetNode or an OptimizerFactory)
1:ab10884: 	 * returned _this_ Optimizer and the time a call to this Optimizer's
1:ab10884: 	 * getNextPermutation() method returns FALSE.  Any re-initialization
1:ab10884: 	 * of state that is required before each round should be done in this
1:ab10884: 	 * method.
1:ab10884: 	 */
1:ab10884: 	public void prepForNextRound();
1:ab10884: 
1:ab10884: 	/**
1:eac0369: 	 * Set the estimated number of outer rows - good for optimizing nested
1:eac0369: 	 * optimizables like subqueries and join nodes.
1:eac0369: 	 */
1:eac0369: 	public void setOuterRows(double outerRowCount);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the number of join strategies supported by this optimizer.
1:eac0369: 	 */
1:eac0369: 	public int getNumberOfJoinStrategies();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the maximum number of estimated rows touched in a table before
1:eac0369: 	 * we decide to open the table with table locking (as opposed to row
1:eac0369: 	 * locking.
1:eac0369: 	 */
1:eac0369: 	public int tableLockThreshold();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets a join strategy by number (zero-based).
1:eac0369: 	 */
1:eac0369: 	JoinStrategy getJoinStrategy(int whichStrategy);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Gets a join strategy by name.  Returns null if not found.
1:eac0369: 	 * The look-up is case-insensitive.
1:eac0369: 	 */
1:eac0369: 	JoinStrategy getJoinStrategy(String whichStrategy);
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Get the level of this optimizer.
1:eac0369: 	 *
1:eac0369: 	 * @return The level of this optimizer.
1:eac0369: 	 */
1:eac0369: 	public int getLevel();
1:eac0369: 
1:eac0369: 	/**
1:eac0369: 	 * Tells whether any of the tables outer to the current one
1:eac0369: 	 * has a uniqueness condition on the given predicate list,
1:eac0369: 	 * and if so, how many times each unique key can be seen by
1:eac0369: 	 * the current table.
1:eac0369: 	 *
1:eac0369: 	 * @param predList		The predicate list to check
1:eac0369: 	 *
1:dbed020: 	 * @return	&lt;= 0 means there is no uniqueness condition
1:dbed020: 	 *			&gt; 0 means there is a uniqueness condition on an
1:eac0369: 	 *			outer table, and the return value is the reciprocal of
1:eac0369: 	 *			the maximum number of times the optimizer estimates that each
1:eac0369: 	 *			unique key will be returned. For example, 0.5 means the
1:eac0369: 	 *			optimizer thinks each distinct join key will be returned
1:eac0369: 	 *			at most twice.
1:eac0369: 	 *
1:eac0369: 	 * @exception StandardException		Thrown on error
1:eac0369: 	 */
1:eac0369: 	double uniqueJoinWithOuterTable(OptimizablePredicateList predList)
1:eac0369: 			throws StandardException;
1:eac0369: 	
1:eac0369: 	/** 
1:eac0369: 	 * If statistics should be considered by the optimizer while optimizing 
1:eac0369: 	 * a query. The user may disable the use of statistics by setting the
1:eac0369: 	 * property derby.optimizer.useStatistics or by using the property
1:eac0369: 	 * useStatistics in a query.
1:eac0369: 	 *
1:eac0369: 	 * @see #USE_STATISTICS
1:eac0369: 	 */
1:eac0369: 	public boolean useStatistics();
1:b223f72: 
1:b223f72:     /**
1:b223f72:      * @return the maximum number of bytes to be used per table.
1:b223f72:      */
1:b223f72:     public int getMaxMemoryPerTable();
1:7f6b163: 
1:7f6b163:     /**
1:7f6b163:      * Get the number of optimizables being considered by this Optimizer.
1:7f6b163:      */
1:7f6b163:     public  int getOptimizableCount();
1:7f6b163: 
1:7f6b163:     /**
1:7f6b163:      * Get the ith (0-based) Optimizable being considered by this Optimizer.
1:7f6b163:      */
1:7f6b163:     public  Optimizable getOptimizable( int idx );
1:7f6b163: 
1:7f6b163: 	/**
1:7f6b163: 	 * Process (i.e. add, load, or remove) current best join order as the
1:7f6b163: 	 * best one for some outer query or ancestor node, represented by another
1:7f6b163: 	 * Optimizer or an instance of FromTable, respectively. Then
1:7f6b163: 	 * iterate through our optimizableList and tell each Optimizable
1:7f6b163: 	 * to do the same.  See Optimizable.updateBestPlan() for more on why
1:7f6b163: 	 * this is necessary.
1:7f6b163: 	 *
1:7f6b163: 	 * @param action Indicates whether to add, load, or remove the plan
1:7f6b163: 	 * @param planKey Object to use as the map key when adding/looking up
1:7f6b163: 	 *  a plan.  If this is an instance of Optimizer then it corresponds
1:7f6b163: 	 *  to an outer query; otherwise it's some Optimizable above this
1:7f6b163: 	 *  Optimizer that could potentially reject plans chosen by this
1:7f6b163: 	 *  Optimizer.
1:7f6b163: 	 */
1:7f6b163: 	public void updateBestPlanMaps(short action, Object planKey)
1:7f6b163:         throws StandardException;
1:eac0369: }
============================================================================
author:Richard N. Hillegas
-------------------------------------------------------------------------------
commit:dbed020
/////////////////////////////////////////////////////////////////////////
1: 	 * @return	&lt;= 0 means there is no uniqueness condition
1: 	 *			&gt; 0 means there is a uniqueness condition on an
commit:9881ca4
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
commit:6a270cb
/////////////////////////////////////////////////////////////////////////
commit:7f6b163
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * Get the number of optimizables being considered by this Optimizer.
1:      */
1:     public  int getOptimizableCount();
1: 
1:     /**
1:      * Get the ith (0-based) Optimizable being considered by this Optimizer.
1:      */
1:     public  Optimizable getOptimizable( int idx );
1: 
1: 	/**
1: 	 * Process (i.e. add, load, or remove) current best join order as the
1: 	 * best one for some outer query or ancestor node, represented by another
1: 	 * Optimizer or an instance of FromTable, respectively. Then
1: 	 * iterate through our optimizableList and tell each Optimizable
1: 	 * to do the same.  See Optimizable.updateBestPlan() for more on why
1: 	 * this is necessary.
1: 	 *
1: 	 * @param action Indicates whether to add, load, or remove the plan
1: 	 * @param planKey Object to use as the map key when adding/looking up
1: 	 *  a plan.  If this is an instance of Optimizer then it corresponds
1: 	 *  to an outer query; otherwise it's some Optimizable above this
1: 	 *  Optimizer that could potentially reject plans chosen by this
1: 	 *  Optimizer.
1: 	 */
1: 	public void updateBestPlanMaps(short action, Object planKey)
1:         throws StandardException;
commit:9858a84
/////////////////////////////////////////////////////////////////////////
1: public interface Optimizer
1: {
/////////////////////////////////////////////////////////////////////////
0:     /** Return true if optimizer tracing is on */
0:     public  boolean tracingIsOn();
1: 
/////////////////////////////////////////////////////////////////////////
0: 	/** Get the trace machinery */
0: 	public OptTrace tracer();
1: 
/////////////////////////////////////////////////////////////////////////
author:Satheesh E. Bandaram
-------------------------------------------------------------------------------
commit:f18825a
/////////////////////////////////////////////////////////////////////////
1: 		Maximum size of dynamically created materialized rows. Caching large results
1: 		use lot of memory and can cause stack overflow. See DERBY-634
1: 	*/
1: 	int MAX_DYNAMIC_MATERIALIZED_ROWS = 512;
1: 
1: 	/**
commit:ab10884
/////////////////////////////////////////////////////////////////////////
1: 	 * Get the final estimated cost of the optimized query.  This
1: 	 * should be the cost that corresponds to the best overall join
1: 	 * order chosen by the optimizer, and thus this method should
1: 	 * only be called after optimization is complete (i.e. when
1: 	 * modifying access paths).
1: 	 */
1: 	public CostEstimate getFinalCost();
1: 
1: 	/**
1: 	 * Prepare for another round of optimization.
1: 	 *
1: 	 * This method is called before every "round" of optimization, where
1: 	 * we define a "round" to be the period between the last time a call to
1: 	 * getOptimizer() (on either a ResultSetNode or an OptimizerFactory)
1: 	 * returned _this_ Optimizer and the time a call to this Optimizer's
1: 	 * getNextPermutation() method returns FALSE.  Any re-initialization
1: 	 * of state that is required before each round should be done in this
1: 	 * method.
1: 	 */
1: 	public void prepForNextRound();
1: 
1: 	/**
author:David Van Couvering
-------------------------------------------------------------------------------
commit:d4580ab
/////////////////////////////////////////////////////////////////////////
1:    Licensed to the Apache Software Foundation (ASF) under one or more
1:    contributor license agreements.  See the NOTICE file distributed with
1:    this work for additional information regarding copyright ownership.
1:    The ASF licenses this file to you under the Apache License, Version 2.0
1:    (the "License"); you may not use this file except in compliance with
1:    the License.  You may obtain a copy of the License at
commit:6b50965
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
author:Oyvind Bakksjo
-------------------------------------------------------------------------------
commit:aaea357
author:Mike Matrigali
-------------------------------------------------------------------------------
commit:b223f72
/////////////////////////////////////////////////////////////////////////
1: 
1:     /**
1:      * @return the maximum number of bytes to be used per table.
1:      */
1:     public int getMaxMemoryPerTable();
author:Daniel John Debrunner
-------------------------------------------------------------------------------
commit:7ecc1f2
/////////////////////////////////////////////////////////////////////////
1:    Derby - Class org.apache.derby.iapi.sql.compile.Optimizer
1: 
0:    Copyright 1997, 2004 The Apache Software Foundation or its licensors, as applicable.
1: 
0:    Licensed under the Apache License, Version 2.0 (the "License");
0:    you may not use this file except in compliance with the License.
0:    You may obtain a copy of the License at
1: 
1:       http://www.apache.org/licenses/LICENSE-2.0
1: 
1:    Unless required by applicable law or agreed to in writing, software
1:    distributed under the License is distributed on an "AS IS" BASIS,
1:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
1:    See the License for the specific language governing permissions and
1:    limitations under the License.
commit:5d24b1a
/////////////////////////////////////////////////////////////////////////
commit:eac0369
/////////////////////////////////////////////////////////////////////////
1: /*
1: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
1: 
1:  */
1: 
1: package org.apache.derby.iapi.sql.compile;
1: 
1: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
1: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
1: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
1: 
1: import org.apache.derby.iapi.error.StandardException;
1: 
1: import org.apache.derby.iapi.util.JBitSet;
1: 
1: /**
1:  * Optimizer provides services for optimizing a query.
1:  * RESOLVE:
1:  *	o  Need to figure out what to do about subqueries, figuring out
1:  *	   their attachment points and how to communicate them back to the
1:  *	   caller.
1:  */
1: 
0: public interface Optimizer {
1: 	/**
0: 		IBM Copyright &copy notice.
1: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
1: 	/**
1: 		Module name for the monitor's module locating system.
1: 	 */
1: 	String MODULE = "org.apache.derby.iapi.sql.compile.Optimizer";
1: 
1: 	/**
1: 		Property name for controlling whether to do join order optimization.
1: 	 */
1: 	String JOIN_ORDER_OPTIMIZATION = "derby.optimizer.optimizeJoinOrder";
1: 
1: 	/**
1: 		Property name for controlling whether to do rule-based optimization,
1: 		as opposed to cost-based optimization.
1: 	 */
1: 	String RULE_BASED_OPTIMIZATION =
1: 						"derby.optimizer.ruleBasedOptimization";
1: 
1: 	/**
1: 		Property name for controlling whether the optimizer ever times out
1: 		while optimizing a query and goes with the best plan so far.
1: 	 */
1: 	String NO_TIMEOUT = "derby.optimizer.noTimeout";
1: 
1: 	/**
1: 		Property name for controlling the maximum size of memory (in KB)
1: 		the optimizer can use for each table.  If an access path takes
1: 		memory larger than that size for a table, the access path is skipped.
1: 		Default is 1024 (KB).
1: 	 */
1: 	String MAX_MEMORY_PER_TABLE = "derby.language.maxMemoryPerTable";
1: 
1: 	/**
1: 	   Property name for disabling statistics use for all queries.
1: 	*/
1: 	String USE_STATISTICS = "derby.language.useStatistics";
1: 
1: 	/** Indicates a "normal" plan that is not optimized to do sort avoidance */
1: 	int NORMAL_PLAN = 1;
1: 
1: 	/** Indicates a sort-avoidance plan */
1: 	int SORT_AVOIDANCE_PLAN = 2;
1: 
0: 	// optimizer trace
0: 	public static final int STARTED = 1;
0: 	public static final int TIME_EXCEEDED =2;
0: 	public static final int NO_TABLES = 3;
0: 	public static final int COMPLETE_JOIN_ORDER = 4;
0: 	public static final int COST_OF_SORTING = 5;
0: 	public static final int NO_BEST_PLAN = 6;
0: 	public static final int MODIFYING_ACCESS_PATHS = 7;
0: 	public static final int SHORT_CIRCUITING = 8;
0: 	public static final int SKIPPING_JOIN_ORDER = 9;
0: 	public static final int ILLEGAL_USER_JOIN_ORDER = 10;
0: 	public static final int USER_JOIN_ORDER_OPTIMIZED = 11;
0: 	public static final int CONSIDERING_JOIN_ORDER = 12;
0: 	public static final int TOTAL_COST_NON_SA_PLAN = 13;
0: 	public static final int TOTAL_COST_SA_PLAN = 14;
0: 	public static final int TOTAL_COST_WITH_SORTING = 15;
0: 	public static final int CURRENT_PLAN_IS_SA_PLAN = 16;
0: 	public static final int CHEAPEST_PLAN_SO_FAR = 17;
0: 	public static final int PLAN_TYPE = 18;
0: 	public static final int COST_OF_CHEAPEST_PLAN_SO_FAR = 19;
0: 	public static final int SORT_NEEDED_FOR_ORDERING = 20;
0: 	public static final int REMEMBERING_BEST_JOIN_ORDER = 21;
0: 	public static final int SKIPPING_DUE_TO_EXCESS_MEMORY = 22;
0: 	public static final int COST_OF_N_SCANS = 23;
0: 	public static final int HJ_SKIP_NOT_MATERIALIZABLE = 24;
0: 	public static final int HJ_SKIP_NO_JOIN_COLUMNS = 25;
0: 	public static final int HJ_HASH_KEY_COLUMNS = 26;
0: 	public static final int CALLING_ON_JOIN_NODE = 27;
0: 	public static final int CONSIDERING_JOIN_STRATEGY = 28;
0: 	public static final int REMEMBERING_BEST_ACCESS_PATH = 29;
0: 	public static final int NO_MORE_CONGLOMERATES = 30;
0: 	public static final int CONSIDERING_CONGLOMERATE = 31;
0: 	public static final int SCANNING_HEAP_FULL_MATCH_ON_UNIQUE_KEY = 32;
0: 	public static final int ADDING_UNORDERED_OPTIMIZABLE = 33;
0: 	public static final int CHANGING_ACCESS_PATH_FOR_TABLE = 34;
0: 	public static final int TABLE_LOCK_NO_START_STOP = 35;
0: 	public static final int NON_COVERING_INDEX_COST = 36;
0: 	public static final int ROW_LOCK_ALL_CONSTANT_START_STOP = 37;
0: 	public static final int ESTIMATING_COST_OF_CONGLOMERATE = 38;
0: 	public static final int LOOKING_FOR_SPECIFIED_INDEX = 39;
0: 	public static final int MATCH_SINGLE_ROW_COST = 40;
0: 	public static final int COST_INCLUDING_EXTRA_1ST_COL_SELECTIVITY = 41;
0: 	public static final int CALLING_NEXT_ACCESS_PATH = 42;
0: 	public static final int TABLE_LOCK_OVER_THRESHOLD = 43;
0: 	public static final int ROW_LOCK_UNDER_THRESHOLD = 44;
0: 	public static final int COST_INCLUDING_EXTRA_START_STOP = 45;
0: 	public static final int COST_INCLUDING_EXTRA_QUALIFIER_SELECTIVITY = 46;
0: 	public static final int COST_INCLUDING_EXTRA_NONQUALIFIER_SELECTIVITY = 47;
0: 	public static final int COST_OF_NONCOVERING_INDEX = 48;
0: 	public static final int REMEMBERING_JOIN_STRATEGY = 49;
0: 	public static final int REMEMBERING_BEST_ACCESS_PATH_SUBSTRING = 50;
0: 	public static final int REMEMBERING_BEST_SORT_AVOIDANCE_ACCESS_PATH_SUBSTRING = 51;
0: 	public static final int REMEMBERING_BEST_UNKNOWN_ACCESS_PATH_SUBSTRING = 52;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN1 = 53;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN2 = 54;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN3 = 55;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN4 = 56;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN5 = 57;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN6 = 58;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN7 = 59;
0: 	public static final int COST_INCLUDING_COMPOSITE_SEL_FROM_STATS= 60;
0: 	public static final int COMPOSITE_SEL_FROM_STATS = 61;
0: 	public static final int COST_INCLUDING_STATS_FOR_INDEX = 62;
1: 	/**
1: 	 * Iterate through the permutations, returning false when the permutations
1: 	 * are exhausted.
1: 	 * NOTE - Implementers are responsible for hiding tree pruning of permutations
1: 	 * behind this method call.
1: 	 *
1: 	 * @return boolean	True - An optimizable permutation remains.
1: 	 *					False - Permutations are exhausted.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean getNextPermutation() throws StandardException;
1: 
1: 	/**
1: 	 * Iterate through the "decorated permutations", returning false when they
1: 	 * are exhausted.
1: 	 * NOTE - Implementers are responsible for hiding tree pruning of access
1: 	 * methods behind this method call.
1: 	 *
1: 	 * @return boolean	True - An optimizable decorated permutation remains.
1: 	 *					False - Decorated permutations are exhausted.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public boolean getNextDecoratedPermutation() throws StandardException;
1: 
1: 	/**
1: 	 * Cost the current permutation.
1: 	 * Caller is responsible for pushing all predicates which can be evaluated 
1: 	 * prior to costing.
1: 	 *
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void costPermutation() throws StandardException;
1: 
1: 	/**
1: 	 * Cost the current Optimizable with the specified OPL.
1: 	 * Caller is responsible for pushing all predicates which can be evaluated 
1: 	 * prior to costing.
1: 	 *
1: 	 * @param optimizable	The Optimizable
1: 	 * @param td			TableDescriptor of the Optimizable
1: 	 * @param cd			The ConglomerateDescriptor for the conglom to cost
1: 	 *						(This should change to an object to represent
1: 	 *						access paths, but for now this is OK).
1: 	 * @param predList		The OptimizablePredicateList to apply
1: 	 * @param outerCost		The cost of the tables outer to the one being
1: 	 *						optimizer - tells how many outer rows there are.
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void	costOptimizable(Optimizable optimizable,
1: 								TableDescriptor td, 
1: 								ConglomerateDescriptor cd,
1: 								OptimizablePredicateList predList,
1: 								CostEstimate outerCost)
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Consider the cost of the given optimizable.  This method is like
1: 	 * costOptimizable, above, but it is used when the Optimizable does
1: 	 * not need help from the optimizer in costing the Optimizable (in practice,
1: 	 * all Optimizables except FromBaseTable use this method.
1: 	 *
1: 	 * Caller is responsible for pushing all predicates which can be evaluated 
1: 	 * prior to costing.
1: 	 *
1: 	 * @param optimizable	The Optimizable
1: 	 * @param predList		The OptimizablePredicateList to apply
1: 	 * @param estimatedCost	The estimated cost of the given optimizable
1: 	 * @param outerCost		The cost of the tables outer to the one being
1: 	 *						optimizer - tells how many outer rows there are.
0: 	 * @return Nothing.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void	considerCost(Optimizable optimizable,
1: 							OptimizablePredicateList predList,
1: 							CostEstimate estimatedCost,
1: 							CostEstimate outerCost)
1: 			throws StandardException;
1: 
1: 	/**
1: 	 * Return the DataDictionary that the Optimizer is using.
1: 	 * This is useful when an Optimizable needs to call optimize() on
1: 	 * a child ResultSetNode.
1: 	 * 
1: 	 * @return DataDictionary	DataDictionary that the Optimizer is using.
1: 	 */
1: 	public DataDictionary getDataDictionary();
1: 
1: 	/**
1: 	 * Modify the access path for each Optimizable, as necessary.  This includes
1: 	 * things like adding result sets to translate from index rows to base rows.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	public void modifyAccessPaths() throws StandardException;
1: 
0: 	/** Get a new CostEstimate object */
0: 	public CostEstimate newCostEstimate();
1: 
1: 	/** Get the estimated cost of the optimized query */
1: 	public CostEstimate getOptimizedCost();
1: 
1: 	/**
1: 	 * Set the estimated number of outer rows - good for optimizing nested
1: 	 * optimizables like subqueries and join nodes.
1: 	 */
1: 	public void setOuterRows(double outerRowCount);
1: 
1: 	/**
1: 	 * Get the number of join strategies supported by this optimizer.
1: 	 */
1: 	public int getNumberOfJoinStrategies();
1: 
1: 	/**
1: 	 * Get the maximum number of estimated rows touched in a table before
1: 	 * we decide to open the table with table locking (as opposed to row
1: 	 * locking.
1: 	 */
1: 	public int tableLockThreshold();
1: 
1: 	/**
1: 	 * Gets a join strategy by number (zero-based).
1: 	 */
1: 	JoinStrategy getJoinStrategy(int whichStrategy);
1: 
1: 	/**
1: 	 * Gets a join strategy by name.  Returns null if not found.
1: 	 * The look-up is case-insensitive.
1: 	 */
1: 	JoinStrategy getJoinStrategy(String whichStrategy);
1: 
1: 	/**
0: 	 * Optimizer trace.
1: 	 */
0: 	public void trace(int traceFlag, int intParam1, int intParam2,
0: 					  double doubleParam, Object objectParam1);
1: 
1: 	/**
1: 	 * Get the level of this optimizer.
1: 	 *
1: 	 * @return The level of this optimizer.
1: 	 */
1: 	public int getLevel();
1: 
1: 	/**
1: 	 * Tells whether any of the tables outer to the current one
1: 	 * has a uniqueness condition on the given predicate list,
1: 	 * and if so, how many times each unique key can be seen by
1: 	 * the current table.
1: 	 *
1: 	 * @param predList		The predicate list to check
1: 	 *
0: 	 * @return	<= 0 means there is no uniqueness condition
0: 	 *			> 0 means there is a uniqueness condition on an
1: 	 *			outer table, and the return value is the reciprocal of
1: 	 *			the maximum number of times the optimizer estimates that each
1: 	 *			unique key will be returned. For example, 0.5 means the
1: 	 *			optimizer thinks each distinct join key will be returned
1: 	 *			at most twice.
1: 	 *
1: 	 * @exception StandardException		Thrown on error
1: 	 */
1: 	double uniqueJoinWithOuterTable(OptimizablePredicateList predList)
1: 			throws StandardException;
1: 	
1: 	/** 
1: 	 * If statistics should be considered by the optimizer while optimizing 
1: 	 * a query. The user may disable the use of statistics by setting the
1: 	 * property derby.optimizer.useStatistics or by using the property
1: 	 * useStatistics in a query.
1: 	 *
1: 	 * @see #USE_STATISTICS
1: 	 */
1: 	public boolean useStatistics();
1: }
author:Ken Coar
-------------------------------------------------------------------------------
commit:95e7b46
/////////////////////////////////////////////////////////////////////////
0: /*
0: 
0:    Licensed Materials - Property of IBM
0:    Cloudscape - Package org.apache.derby.iapi.sql.compile
0:    (C) Copyright IBM Corp. 1997, 2004. All Rights Reserved.
0:    US Government Users Restricted Rights - Use, duplication or
0:    disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
0: 
0:  */
0: 
0: package org.apache.derby.iapi.sql.compile;
0: 
0: import org.apache.derby.iapi.sql.dictionary.DataDictionary;
0: import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
0: import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
0: 
0: import org.apache.derby.iapi.error.StandardException;
0: 
0: import org.apache.derby.iapi.util.JBitSet;
0: 
0: /**
0:  * Optimizer provides services for optimizing a query.
0:  * RESOLVE:
0:  *	o  Need to figure out what to do about subqueries, figuring out
0:  *	   their attachment points and how to communicate them back to the
0:  *	   caller.
0:  */
0: 
0: public interface Optimizer {
0: 	/**
0: 		IBM Copyright &copy notice.
0: 	*/
0: 	public static final String copyrightNotice = org.apache.derby.iapi.reference.Copyright.SHORT_1997_2004;
0: 	/**
0: 		Module name for the monitor's module locating system.
0: 	 */
0: 	String MODULE = "org.apache.derby.iapi.sql.compile.Optimizer";
0: 
0: 	/**
0: 		Property name for controlling whether to do join order optimization.
0: 	 */
0: 	String JOIN_ORDER_OPTIMIZATION = "derby.optimizer.optimizeJoinOrder";
0: 
0: 	/**
0: 		Property name for controlling whether to do rule-based optimization,
0: 		as opposed to cost-based optimization.
0: 	 */
0: 	String RULE_BASED_OPTIMIZATION =
0: 						"derby.optimizer.ruleBasedOptimization";
0: 
0: 	/**
0: 		Property name for controlling whether the optimizer ever times out
0: 		while optimizing a query and goes with the best plan so far.
0: 	 */
0: 	String NO_TIMEOUT = "derby.optimizer.noTimeout";
0: 
0: 	/**
0: 		Property name for controlling the maximum size of memory (in KB)
0: 		the optimizer can use for each table.  If an access path takes
0: 		memory larger than that size for a table, the access path is skipped.
0: 		Default is 1024 (KB).
0: 	 */
0: 	String MAX_MEMORY_PER_TABLE = "derby.language.maxMemoryPerTable";
0: 
0: 	/**
0: 	   Property name for disabling statistics use for all queries.
0: 	*/
0: 	String USE_STATISTICS = "derby.language.useStatistics";
0: 
0: 	/** Indicates a "normal" plan that is not optimized to do sort avoidance */
0: 	int NORMAL_PLAN = 1;
0: 
0: 	/** Indicates a sort-avoidance plan */
0: 	int SORT_AVOIDANCE_PLAN = 2;
0: 
0: 	// optimizer trace
0: 	public static final int STARTED = 1;
0: 	public static final int TIME_EXCEEDED =2;
0: 	public static final int NO_TABLES = 3;
0: 	public static final int COMPLETE_JOIN_ORDER = 4;
0: 	public static final int COST_OF_SORTING = 5;
0: 	public static final int NO_BEST_PLAN = 6;
0: 	public static final int MODIFYING_ACCESS_PATHS = 7;
0: 	public static final int SHORT_CIRCUITING = 8;
0: 	public static final int SKIPPING_JOIN_ORDER = 9;
0: 	public static final int ILLEGAL_USER_JOIN_ORDER = 10;
0: 	public static final int USER_JOIN_ORDER_OPTIMIZED = 11;
0: 	public static final int CONSIDERING_JOIN_ORDER = 12;
0: 	public static final int TOTAL_COST_NON_SA_PLAN = 13;
0: 	public static final int TOTAL_COST_SA_PLAN = 14;
0: 	public static final int TOTAL_COST_WITH_SORTING = 15;
0: 	public static final int CURRENT_PLAN_IS_SA_PLAN = 16;
0: 	public static final int CHEAPEST_PLAN_SO_FAR = 17;
0: 	public static final int PLAN_TYPE = 18;
0: 	public static final int COST_OF_CHEAPEST_PLAN_SO_FAR = 19;
0: 	public static final int SORT_NEEDED_FOR_ORDERING = 20;
0: 	public static final int REMEMBERING_BEST_JOIN_ORDER = 21;
0: 	public static final int SKIPPING_DUE_TO_EXCESS_MEMORY = 22;
0: 	public static final int COST_OF_N_SCANS = 23;
0: 	public static final int HJ_SKIP_NOT_MATERIALIZABLE = 24;
0: 	public static final int HJ_SKIP_NO_JOIN_COLUMNS = 25;
0: 	public static final int HJ_HASH_KEY_COLUMNS = 26;
0: 	public static final int CALLING_ON_JOIN_NODE = 27;
0: 	public static final int CONSIDERING_JOIN_STRATEGY = 28;
0: 	public static final int REMEMBERING_BEST_ACCESS_PATH = 29;
0: 	public static final int NO_MORE_CONGLOMERATES = 30;
0: 	public static final int CONSIDERING_CONGLOMERATE = 31;
0: 	public static final int SCANNING_HEAP_FULL_MATCH_ON_UNIQUE_KEY = 32;
0: 	public static final int ADDING_UNORDERED_OPTIMIZABLE = 33;
0: 	public static final int CHANGING_ACCESS_PATH_FOR_TABLE = 34;
0: 	public static final int TABLE_LOCK_NO_START_STOP = 35;
0: 	public static final int NON_COVERING_INDEX_COST = 36;
0: 	public static final int ROW_LOCK_ALL_CONSTANT_START_STOP = 37;
0: 	public static final int ESTIMATING_COST_OF_CONGLOMERATE = 38;
0: 	public static final int LOOKING_FOR_SPECIFIED_INDEX = 39;
0: 	public static final int MATCH_SINGLE_ROW_COST = 40;
0: 	public static final int COST_INCLUDING_EXTRA_1ST_COL_SELECTIVITY = 41;
0: 	public static final int CALLING_NEXT_ACCESS_PATH = 42;
0: 	public static final int TABLE_LOCK_OVER_THRESHOLD = 43;
0: 	public static final int ROW_LOCK_UNDER_THRESHOLD = 44;
0: 	public static final int COST_INCLUDING_EXTRA_START_STOP = 45;
0: 	public static final int COST_INCLUDING_EXTRA_QUALIFIER_SELECTIVITY = 46;
0: 	public static final int COST_INCLUDING_EXTRA_NONQUALIFIER_SELECTIVITY = 47;
0: 	public static final int COST_OF_NONCOVERING_INDEX = 48;
0: 	public static final int REMEMBERING_JOIN_STRATEGY = 49;
0: 	public static final int REMEMBERING_BEST_ACCESS_PATH_SUBSTRING = 50;
0: 	public static final int REMEMBERING_BEST_SORT_AVOIDANCE_ACCESS_PATH_SUBSTRING = 51;
0: 	public static final int REMEMBERING_BEST_UNKNOWN_ACCESS_PATH_SUBSTRING = 52;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN1 = 53;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN2 = 54;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN3 = 55;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN4 = 56;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN5 = 57;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN6 = 58;
0: 	public static final int COST_OF_CONGLOMERATE_SCAN7 = 59;
0: 	public static final int COST_INCLUDING_COMPOSITE_SEL_FROM_STATS= 60;
0: 	public static final int COMPOSITE_SEL_FROM_STATS = 61;
0: 	public static final int COST_INCLUDING_STATS_FOR_INDEX = 62;
0: 	/**
0: 	 * Iterate through the permutations, returning false when the permutations
0: 	 * are exhausted.
0: 	 * NOTE - Implementers are responsible for hiding tree pruning of permutations
0: 	 * behind this method call.
0: 	 *
0: 	 * @return boolean	True - An optimizable permutation remains.
0: 	 *					False - Permutations are exhausted.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean getNextPermutation() throws StandardException;
0: 
0: 	/**
0: 	 * Iterate through the "decorated permutations", returning false when they
0: 	 * are exhausted.
0: 	 * NOTE - Implementers are responsible for hiding tree pruning of access
0: 	 * methods behind this method call.
0: 	 *
0: 	 * @return boolean	True - An optimizable decorated permutation remains.
0: 	 *					False - Decorated permutations are exhausted.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public boolean getNextDecoratedPermutation() throws StandardException;
0: 
0: 	/**
0: 	 * Cost the current permutation.
0: 	 * Caller is responsible for pushing all predicates which can be evaluated 
0: 	 * prior to costing.
0: 	 *
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void costPermutation() throws StandardException;
0: 
0: 	/**
0: 	 * Cost the current Optimizable with the specified OPL.
0: 	 * Caller is responsible for pushing all predicates which can be evaluated 
0: 	 * prior to costing.
0: 	 *
0: 	 * @param optimizable	The Optimizable
0: 	 * @param td			TableDescriptor of the Optimizable
0: 	 * @param cd			The ConglomerateDescriptor for the conglom to cost
0: 	 *						(This should change to an object to represent
0: 	 *						access paths, but for now this is OK).
0: 	 * @param predList		The OptimizablePredicateList to apply
0: 	 * @param outerCost		The cost of the tables outer to the one being
0: 	 *						optimizer - tells how many outer rows there are.
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void	costOptimizable(Optimizable optimizable,
0: 								TableDescriptor td, 
0: 								ConglomerateDescriptor cd,
0: 								OptimizablePredicateList predList,
0: 								CostEstimate outerCost)
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * Consider the cost of the given optimizable.  This method is like
0: 	 * costOptimizable, above, but it is used when the Optimizable does
0: 	 * not need help from the optimizer in costing the Optimizable (in practice,
0: 	 * all Optimizables except FromBaseTable use this method.
0: 	 *
0: 	 * Caller is responsible for pushing all predicates which can be evaluated 
0: 	 * prior to costing.
0: 	 *
0: 	 * @param optimizable	The Optimizable
0: 	 * @param predList		The OptimizablePredicateList to apply
0: 	 * @param estimatedCost	The estimated cost of the given optimizable
0: 	 * @param outerCost		The cost of the tables outer to the one being
0: 	 *						optimizer - tells how many outer rows there are.
0: 	 * @return Nothing.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void	considerCost(Optimizable optimizable,
0: 							OptimizablePredicateList predList,
0: 							CostEstimate estimatedCost,
0: 							CostEstimate outerCost)
0: 			throws StandardException;
0: 
0: 	/**
0: 	 * Return the DataDictionary that the Optimizer is using.
0: 	 * This is useful when an Optimizable needs to call optimize() on
0: 	 * a child ResultSetNode.
0: 	 * 
0: 	 * @return DataDictionary	DataDictionary that the Optimizer is using.
0: 	 */
0: 	public DataDictionary getDataDictionary();
0: 
0: 	/**
0: 	 * Modify the access path for each Optimizable, as necessary.  This includes
0: 	 * things like adding result sets to translate from index rows to base rows.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	public void modifyAccessPaths() throws StandardException;
0: 
0: 	/** Get a new CostEstimate object */
0: 	public CostEstimate newCostEstimate();
0: 
0: 	/** Get the estimated cost of the optimized query */
0: 	public CostEstimate getOptimizedCost();
0: 
0: 	/**
0: 	 * Set the estimated number of outer rows - good for optimizing nested
0: 	 * optimizables like subqueries and join nodes.
0: 	 */
0: 	public void setOuterRows(double outerRowCount);
0: 
0: 	/**
0: 	 * Get the number of join strategies supported by this optimizer.
0: 	 */
0: 	public int getNumberOfJoinStrategies();
0: 
0: 	/**
0: 	 * Get the maximum number of estimated rows touched in a table before
0: 	 * we decide to open the table with table locking (as opposed to row
0: 	 * locking.
0: 	 */
0: 	public int tableLockThreshold();
0: 
0: 	/**
0: 	 * Gets a join strategy by number (zero-based).
0: 	 */
0: 	JoinStrategy getJoinStrategy(int whichStrategy);
0: 
0: 	/**
0: 	 * Gets a join strategy by name.  Returns null if not found.
0: 	 * The look-up is case-insensitive.
0: 	 */
0: 	JoinStrategy getJoinStrategy(String whichStrategy);
0: 
0: 	/**
0: 	 * Optimizer trace.
0: 	 */
0: 	public void trace(int traceFlag, int intParam1, int intParam2,
0: 					  double doubleParam, Object objectParam1);
0: 
0: 	/**
0: 	 * Get the level of this optimizer.
0: 	 *
0: 	 * @return The level of this optimizer.
0: 	 */
0: 	public int getLevel();
0: 
0: 	/**
0: 	 * Tells whether any of the tables outer to the current one
0: 	 * has a uniqueness condition on the given predicate list,
0: 	 * and if so, how many times each unique key can be seen by
0: 	 * the current table.
0: 	 *
0: 	 * @param predList		The predicate list to check
0: 	 *
0: 	 * @return	<= 0 means there is no uniqueness condition
0: 	 *			> 0 means there is a uniqueness condition on an
0: 	 *			outer table, and the return value is the reciprocal of
0: 	 *			the maximum number of times the optimizer estimates that each
0: 	 *			unique key will be returned. For example, 0.5 means the
0: 	 *			optimizer thinks each distinct join key will be returned
0: 	 *			at most twice.
0: 	 *
0: 	 * @exception StandardException		Thrown on error
0: 	 */
0: 	double uniqueJoinWithOuterTable(OptimizablePredicateList predList)
0: 			throws StandardException;
0: 	
0: 	/** 
0: 	 * If statistics should be considered by the optimizer while optimizing 
0: 	 * a query. The user may disable the use of statistics by setting the
0: 	 * property derby.optimizer.useStatistics or by using the property
0: 	 * useStatistics in a query.
0: 	 *
0: 	 * @see #USE_STATISTICS
0: 	 */
0: 	public boolean useStatistics();
0: }
============================================================================